{"sha": "19c5dfc29d83101e415590e778b99e7c37d9b730", "node_id": "C_kwDOANBUbNoAKDE5YzVkZmMyOWQ4MzEwMWU0MTU1OTBlNzc4Yjk5ZTdjMzdkOWI3MzA", "commit": {"author": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-03-14T19:52:11Z"}, "committer": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-03-14T19:52:11Z"}, "message": "PR 109125 Modula2 SIGBUS in m2pim_ldtoa_ldtoa\n\n13 regression failures seen on sparc SIGBUS in m2pim_ldtoa_ldtoa.\nThis patch fixes int bool parameter mismatches between the\ndefinition modules and their C/C++ implementations.\n\ngcc/m2/ChangeLog:\n\n\tPR modula2/109125\n\t* gm2-libs-ch/cgetopt.c (cgetopt_SetOption): Replace int\n\tfor bool.\n\t* gm2-libs-ch/termios.c (doSetUnset): Replace int for bool.\n\t* gm2-libs/Builtins.mod (isfinitef): Correct typo in return\n\tstatement.\n\nlibgm2/ChangeLog:\n\n\tPR modula2/109125\n\t* libm2iso/ErrnoCategory.cc (FALSE): Remove.\n\t(TRUE): Remove.\n\t* libm2iso/wrapsock.c (TRUE): Remove.\n\t(FALSE): Remove.\n\t* libm2iso/wraptime.cc (TRUE): Remove.\n\t(FALSE): Remove.\n\t* libm2pim/cgetopt.cc: Replace int for bool for every BOOLEAN\n\tparameter in the definition module.\n\t* libm2pim/dtoa.cc: Ditto.\n\t* libm2pim/ldtoa.cc: Ditto.\n\t* libm2pim/termios.cc: Ditto.\n\t(doSetUnset): Replace int for bool.\n\nSigned-off-by: Gaius Mulley <gaiusmod2@gmail.com>", "tree": {"sha": "44a9e4b644d621b5083c029387285185ee5b5eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44a9e4b644d621b5083c029387285185ee5b5eba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19c5dfc29d83101e415590e778b99e7c37d9b730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c5dfc29d83101e415590e778b99e7c37d9b730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c5dfc29d83101e415590e778b99e7c37d9b730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c5dfc29d83101e415590e778b99e7c37d9b730/comments", "author": null, "committer": null, "parents": [{"sha": "71b33f8fb8daa6a7a359f322b24365d9016438fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71b33f8fb8daa6a7a359f322b24365d9016438fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71b33f8fb8daa6a7a359f322b24365d9016438fc"}], "stats": {"total": 1593, "additions": 786, "deletions": 807}, "files": [{"sha": "d6b40b183b439121fdc73f6d002e5fd95a849c43", "filename": "gcc/m2/gm2-libs-ch/cgetopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/gcc%2Fm2%2Fgm2-libs-ch%2Fcgetopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/gcc%2Fm2%2Fgm2-libs-ch%2Fcgetopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-ch%2Fcgetopt.c?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -120,7 +120,7 @@ cgetopt_KillOptions (cgetopt_Options *o)\n \n void\n cgetopt_SetOption (cgetopt_Options *o, unsigned int index,\n-\t\t  char *name, unsigned int has_arg,\n+\t\t  char *name, bool has_arg,\n \t\t  int *flag, int val)\n {\n   if (index > o->high)"}, {"sha": "622404c7293ca3af726b7c2b8cb5134f08ab46f5", "filename": "gcc/m2/gm2-libs-ch/termios.c", "status": "modified", "additions": 380, "deletions": 378, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/gcc%2Fm2%2Fgm2-libs-ch%2Ftermios.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/gcc%2Fm2%2Fgm2-libs-ch%2Ftermios.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-ch%2Ftermios.c?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -188,14 +188,14 @@ int EXPORT (tcflowoni) (int fd);\n int EXPORT (tcflowoffi) (int fd);\n int EXPORT (tcflowono) (int fd);\n int EXPORT (tcflowoffo) (int fd);\n-int EXPORT (GetFlag) (struct termios *t, Flag f, int *b);\n-int EXPORT (SetFlag) (struct termios *t, Flag f, int b);\n-int EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch);\n-int EXPORT (SetChar) (struct termios *t, ControlChar c, char ch);\n+bool EXPORT (GetFlag) (struct termios *t, Flag f, bool *b);\n+bool EXPORT (SetFlag) (struct termios *t, Flag f, bool b);\n+bool EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch);\n+bool EXPORT (SetChar) (struct termios *t, ControlChar c, char ch);\n int EXPORT (tcsnow) (void);\n int EXPORT (tcsflush) (void);\n int EXPORT (tcsdrain) (void);\n-int doSetUnset (tcflag_t *bitset, unsigned int mask, int value);\n+bool doSetUnset (tcflag_t *bitset, unsigned int mask, bool value);\n void _M2_termios_init (void);\n void _M2_termios_finish (void);\n \n@@ -373,706 +373,707 @@ int EXPORT (tcflowoffo) (int fd)\n #endif\n }\n \n-/* doSetUnset - applies mask or undoes mask depending upon value.  */\n+/* doSetUnset applies mask or undoes mask depending upon value and returns true.  */\n \n-int\n-doSetUnset (tcflag_t *bitset, unsigned int mask, int value)\n+bool\n+doSetUnset (tcflag_t *bitset, unsigned int mask, bool value)\n {\n   if (value)\n     (*bitset) |= mask;\n   else\n     (*bitset) &= (~mask);\n-  return 1;\n+  return true;\n }\n \n-/* GetFlag - sets a flag value from, t, in, b, and returns TRUE if,\n-   t, supports, f.  */\n+/* GetFlag sets a flag value from t in b and returns true if t supports f.  */\n \n-int EXPORT (GetFlag) (struct termios *t, Flag f, int *b)\n+bool\n+EXPORT (GetFlag) (struct termios *t, Flag f, bool *b)\n {\n   switch (f)\n     {\n \n     case ignbrk:\n #if defined(IGNBRK)\n       *b = ((t->c_iflag & IGNBRK) == IGNBRK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ibrkint:\n #if defined(BRKINT)\n       *b = ((t->c_iflag & BRKINT) == BRKINT);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ignpar:\n #if defined(IGNPAR)\n       *b = ((t->c_iflag & IGNPAR) == IGNPAR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case iparmrk:\n #if defined(PARMRK)\n       *b = ((t->c_iflag & PARMRK) == PARMRK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case inpck:\n #if defined(INPCK)\n       *b = ((t->c_iflag & INPCK) == INPCK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case istrip:\n #if defined(ISTRIP)\n       *b = ((t->c_iflag & ISTRIP) == ISTRIP);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case inlcr:\n #if defined(INLCR)\n       *b = ((t->c_iflag & INLCR) == INLCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case igncr:\n #if defined(IGNCR)\n       *b = ((t->c_iflag & IGNCR) == IGNCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case icrnl:\n #if defined(ICRNL)\n       *b = ((t->c_iflag & ICRNL) == ICRNL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case iuclc:\n #if defined(IUCLC)\n       *b = ((t->c_iflag & IUCLC) == IUCLC);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixon:\n #if defined(IXON)\n       *b = ((t->c_iflag & IXON) == IXON);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixany:\n #if defined(IXANY)\n       *b = ((t->c_iflag & IXANY) == IXANY);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixoff:\n #if defined(IXOFF)\n       *b = ((t->c_iflag & IXOFF) == IXOFF);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case imaxbel:\n #if defined(IMAXBEL)\n       *b = ((t->c_iflag & IMAXBEL) == IMAXBEL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case opost:\n #if defined(OPOST)\n       *b = ((t->c_oflag & OPOST) == OPOST);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case olcuc:\n #if defined(OLCUC)\n       *b = ((t->c_oflag & OLCUC) == OLCUC);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlcr:\n #if defined(ONLCR)\n       *b = ((t->c_oflag & ONLCR) == ONLCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocrnl:\n #if defined(OCRNL)\n       *b = ((t->c_oflag & OCRNL) == OCRNL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onocr:\n #if defined(ONOCR)\n       *b = ((t->c_oflag & ONOCR) == ONOCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlret:\n #if defined(ONLRET)\n       *b = ((t->c_oflag & ONLRET) == ONLRET);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofill:\n #if defined(OFILL)\n       *b = ((t->c_oflag & OFILL) == OFILL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofdel:\n #if defined(OFDEL)\n       *b = ((t->c_oflag & OFDEL) == OFDEL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl0:\n #if defined(NL0)\n       *b = ((t->c_oflag & NL0) == NL0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl1:\n #if defined(NL1)\n       *b = ((t->c_oflag & NL1) == NL1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr0:\n #if defined(CR0)\n       *b = ((t->c_oflag & CR0) == CR0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr1:\n #if defined(CR1)\n       *b = ((t->c_oflag & CR1) == CR1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr2:\n #if defined(CR2)\n       *b = ((t->c_oflag & CR2) == CR2);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr3:\n #if defined(CR3)\n       *b = ((t->c_oflag & CR3) == CR3);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab0:\n #if defined(TAB0)\n       *b = ((t->c_oflag & TAB0) == TAB0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab1:\n #if defined(TAB1)\n       *b = ((t->c_oflag & TAB1) == TAB1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab2:\n #if defined(TAB2)\n       *b = ((t->c_oflag & TAB2) == TAB2);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab3:\n #if defined(TAB3)\n       *b = ((t->c_oflag & TAB3) == TAB3);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs0:\n #if defined(BS0)\n       *b = ((t->c_oflag & BS0) == BS0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs1:\n #if defined(BS1)\n       *b = ((t->c_oflag & BS1) == BS1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case off0:\n #if defined(FF0)\n       *b = ((t->c_oflag & FF0) == FF0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case off1:\n #if defined(FF1)\n       *b = ((t->c_oflag & FF1) == FF1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt0:\n #if defined(VT0)\n       *b = ((t->c_oflag & VT0) == VT0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt1:\n #if defined(VT1)\n       *b = ((t->c_oflag & VT1) == VT1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b0:\n #if defined(B0)\n       *b = ((t->c_cflag & B0) == B0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b50:\n #if defined(B50)\n       *b = ((t->c_cflag & B50) == B50);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b75:\n #if defined(B75)\n       *b = ((t->c_cflag & B75) == B75);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b110:\n #if defined(B110)\n       *b = ((t->c_cflag & B110) == B110);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b135:\n #if defined(B134)\n       *b = ((t->c_cflag & B134) == B134);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b150:\n #if defined(B150)\n       *b = ((t->c_cflag & B150) == B150);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b200:\n #if defined(B200)\n       *b = ((t->c_cflag & B200) == B200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b300:\n #if defined(B300)\n       *b = ((t->c_cflag & B300) == B300);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b600:\n #if defined(B600)\n       *b = ((t->c_cflag & B600) == B600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1200:\n #if defined(B1200)\n       *b = ((t->c_cflag & B1200) == B1200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1800:\n #if defined(B1800)\n       *b = ((t->c_cflag & B1800) == B1800);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2400:\n #if defined(B2400)\n       *b = ((t->c_cflag & B2400) == B2400);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4800:\n #if defined(B4800)\n       *b = ((t->c_cflag & B4800) == B4800);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b9600:\n #if defined(B9600)\n       *b = ((t->c_cflag & B9600) == B9600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b19200:\n #if defined(B19200)\n       *b = ((t->c_cflag & B19200) == B19200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b38400:\n #if defined(B38400)\n       *b = ((t->c_cflag & B38400) == B38400);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b57600:\n #if defined(B57600)\n       *b = ((t->c_cflag & B57600) == B57600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b115200:\n #if defined(B115200)\n       *b = ((t->c_cflag & B115200) == B115200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b240400:\n #if defined(B230400)\n       *b = ((t->c_cflag & B230400) == B230400);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b460800:\n #if defined(B460800)\n       *b = ((t->c_cflag & B460800) == B460800);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b500000:\n #if defined(B500000)\n       *b = ((t->c_cflag & B500000) == B500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b576000:\n #if defined(B576000)\n       *b = ((t->c_cflag & B576000) == B576000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b921600:\n #if defined(B921600)\n       *b = ((t->c_cflag & B921600) == B921600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1000000:\n #if defined(B1000000)\n       *b = ((t->c_cflag & B1000000) == B1000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1152000:\n #if defined(B1152000)\n       *b = ((t->c_cflag & B1152000) == B1152000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1500000:\n #if defined(B1500000)\n       *b = ((t->c_cflag & B1500000) == B1500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2000000:\n #if defined(B2000000)\n       *b = ((t->c_cflag & B2000000) == B2000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2500000:\n #if defined(B2500000)\n       *b = ((t->c_cflag & B2500000) == B2500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3000000:\n #if defined(B3000000)\n       *b = ((t->c_cflag & B3000000) == B3000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3500000:\n #if defined(B3500000)\n       *b = ((t->c_cflag & B3500000) == B3500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4000000:\n #if defined(B4000000)\n       *b = ((t->c_cflag & B4000000) == B4000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case maxbaud:\n #if defined(__MAX_BAUD)\n       *b = ((t->c_cflag & __MAX_BAUD) == __MAX_BAUD);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case crtscts:\n #if defined(CRTSCTS)\n       *b = ((t->c_cflag & CRTSCTS) == CRTSCTS);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs5:\n #if defined(CS5)\n       *b = ((t->c_cflag & CS5) == CS5);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs6:\n #if defined(CS6)\n       *b = ((t->c_cflag & CS6) == CS6);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs7:\n #if defined(CS7)\n       *b = ((t->c_cflag & CS7) == CS7);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs8:\n #if defined(CS8)\n       *b = ((t->c_cflag & CS8) == CS8);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cstopb:\n #if defined(CSTOPB)\n       *b = ((t->c_cflag & CSTOPB) == CSTOPB);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cread:\n #if defined(CREAD)\n       *b = ((t->c_cflag & CREAD) == CREAD);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case parenb:\n #if defined(PARENB)\n       *b = ((t->c_cflag & PARENB) == PARENB);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case parodd:\n #if defined(PARODD)\n       *b = ((t->c_cflag & PARODD) == PARODD);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case hupcl:\n #if defined(HUPCL)\n       *b = ((t->c_cflag & HUPCL) == HUPCL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case clocal:\n #if defined(CLOCAL)\n       *b = ((t->c_cflag & CLOCAL) == CLOCAL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lisig:\n #if defined(ISIG)\n       *b = ((t->c_lflag & ISIG) == ISIG);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case licanon:\n #if defined(ICANON)\n       *b = ((t->c_lflag & ICANON) == ICANON);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lxcase:\n #if defined(XCASE)\n       *b = ((t->c_lflag & XCASE) == XCASE);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lecho:\n #if defined(ECHO)\n       *b = ((t->c_lflag & ECHO) == ECHO);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoe:\n #if defined(ECHOE)\n       *b = ((t->c_lflag & ECHOE) == ECHOE);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechok:\n #if defined(ECHOK)\n       *b = ((t->c_lflag & ECHOK) == ECHOK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechonl:\n #if defined(ECHONL)\n       *b = ((t->c_lflag & ECHONL) == ECHONL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lnoflsh:\n #if defined(NOFLSH)\n       *b = ((t->c_lflag & NOFLSH) == NOFLSH);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ltopstop:\n #if defined(TOSTOP)\n       *b = ((t->c_lflag & TOSTOP) == TOSTOP);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoctl:\n #if defined(ECHOCTL)\n       *b = ((t->c_lflag & ECHOCTL) == ECHOCTL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoprt:\n #if defined(ECHOPRT)\n       *b = ((t->c_lflag & ECHOPRT) == ECHOPRT);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoke:\n #if defined(ECHOKE)\n       *b = ((t->c_lflag & ECHOKE) == ECHOKE);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lflusho:\n #if defined(FLUSHO)\n       *b = ((t->c_lflag & FLUSHO) == FLUSHO);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lpendin:\n #if defined(PENDIN)\n       *b = ((t->c_lflag & PENDIN) == PENDIN);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case liexten:\n #if defined(IEXTEN)\n       *b = ((t->c_lflag & IEXTEN) == IEXTEN);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     }\n-  return 0;\n+  return false;\n }\n \n /* SetFlag - sets a flag value in, t, to, b, and returns TRUE if this\n    flag value is supported.  */\n \n-int EXPORT (SetFlag) (struct termios *t, Flag f, int b)\n+bool\n+EXPORT (SetFlag) (struct termios *t, Flag f, bool b)\n {\n   switch (f)\n     {\n@@ -1081,843 +1082,844 @@ int EXPORT (SetFlag) (struct termios *t, Flag f, int b)\n #if defined(IGNBRK)\n       return doSetUnset (&t->c_iflag, IGNBRK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ibrkint:\n #if defined(BRKINT)\n       return doSetUnset (&t->c_iflag, BRKINT, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ignpar:\n #if defined(IGNPAR)\n       return doSetUnset (&t->c_iflag, IGNPAR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case iparmrk:\n #if defined(PARMRK)\n       return doSetUnset (&t->c_iflag, PARMRK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case inpck:\n #if defined(INPCK)\n       return doSetUnset (&t->c_iflag, INPCK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case istrip:\n #if defined(ISTRIP)\n       return doSetUnset (&t->c_iflag, ISTRIP, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case inlcr:\n #if defined(INLCR)\n       return doSetUnset (&t->c_iflag, INLCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case igncr:\n #if defined(IGNCR)\n       return doSetUnset (&t->c_iflag, IGNCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case icrnl:\n #if defined(ICRNL)\n       return doSetUnset (&t->c_iflag, ICRNL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case iuclc:\n #if defined(IUCLC)\n       return doSetUnset (&t->c_iflag, IUCLC, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixon:\n #if defined(IXON)\n       return doSetUnset (&t->c_iflag, IXON, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixany:\n #if defined(IXANY)\n       return doSetUnset (&t->c_iflag, IXANY, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixoff:\n #if defined(IXOFF)\n       return doSetUnset (&t->c_iflag, IXOFF, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case imaxbel:\n #if defined(IMAXBEL)\n       return doSetUnset (&t->c_iflag, IMAXBEL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case opost:\n #if defined(OPOST)\n       return doSetUnset (&t->c_oflag, OPOST, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case olcuc:\n #if defined(OLCUC)\n       return doSetUnset (&t->c_oflag, OLCUC, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlcr:\n #if defined(ONLCR)\n       return doSetUnset (&t->c_oflag, ONLCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocrnl:\n #if defined(OCRNL)\n       return doSetUnset (&t->c_oflag, OCRNL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onocr:\n #if defined(ONOCR)\n       return doSetUnset (&t->c_oflag, ONOCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlret:\n #if defined(ONLRET)\n       return doSetUnset (&t->c_oflag, ONLRET, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofill:\n #if defined(OFILL)\n       return doSetUnset (&t->c_oflag, OFILL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofdel:\n #if defined(OFDEL)\n       return doSetUnset (&t->c_oflag, OFDEL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl0:\n #if defined(NL0)\n       return doSetUnset (&t->c_oflag, NL0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl1:\n #if defined(NL1)\n       return doSetUnset (&t->c_oflag, NL1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr0:\n #if defined(CR0)\n       return doSetUnset (&t->c_oflag, CR0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr1:\n #if defined(CR1)\n       return doSetUnset (&t->c_oflag, CR1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr2:\n #if defined(CR2)\n       return doSetUnset (&t->c_oflag, CR2, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr3:\n #if defined(CR3)\n       return doSetUnset (&t->c_oflag, CR3, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab0:\n #if defined(TAB0)\n       return doSetUnset (&t->c_oflag, TAB0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab1:\n #if defined(TAB1)\n       return doSetUnset (&t->c_oflag, TAB1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab2:\n #if defined(TAB2)\n       return doSetUnset (&t->c_oflag, TAB2, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab3:\n #if defined(TAB3)\n       return doSetUnset (&t->c_oflag, TAB3, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs0:\n #if defined(BS0)\n       return doSetUnset (&t->c_oflag, BS0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs1:\n #if defined(BS1)\n       return doSetUnset (&t->c_oflag, BS1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case off0:\n #if defined(FF0)\n       return doSetUnset (&t->c_oflag, FF0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case off1:\n #if defined(FF1)\n       return doSetUnset (&t->c_oflag, FF1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt0:\n #if defined(VT0)\n       return doSetUnset (&t->c_oflag, VT0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt1:\n #if defined(VT1)\n       return doSetUnset (&t->c_oflag, VT1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b0:\n #if defined(B0)\n       return doSetUnset (&t->c_cflag, B0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b50:\n #if defined(B50)\n       return doSetUnset (&t->c_cflag, B50, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b75:\n #if defined(B75)\n       return doSetUnset (&t->c_cflag, B75, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b110:\n #if defined(B110)\n       return doSetUnset (&t->c_cflag, B110, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b135:\n #if defined(B134)\n       return doSetUnset (&t->c_cflag, B134, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b150:\n #if defined(B150)\n       return doSetUnset (&t->c_cflag, B150, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b200:\n #if defined(B200)\n       return doSetUnset (&t->c_cflag, B200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b300:\n #if defined(B300)\n       return doSetUnset (&t->c_cflag, B300, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b600:\n #if defined(B600)\n       return doSetUnset (&t->c_cflag, B600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1200:\n #if defined(B1200)\n       return doSetUnset (&t->c_cflag, B1200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1800:\n #if defined(B1800)\n       return doSetUnset (&t->c_cflag, B1800, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2400:\n #if defined(B2400)\n       return doSetUnset (&t->c_cflag, B2400, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4800:\n #if defined(B4800)\n       return doSetUnset (&t->c_cflag, B4800, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b9600:\n #if defined(B9600)\n       return doSetUnset (&t->c_cflag, B9600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b19200:\n #if defined(B19200)\n       return doSetUnset (&t->c_cflag, B19200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b38400:\n #if defined(B38400)\n       return doSetUnset (&t->c_cflag, B38400, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b57600:\n #if defined(B57600)\n       return doSetUnset (&t->c_cflag, B57600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b115200:\n #if defined(B115200)\n       return doSetUnset (&t->c_cflag, B115200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b240400:\n #if defined(B230400)\n       return doSetUnset (&t->c_cflag, B230400, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b460800:\n #if defined(B460800)\n       return doSetUnset (&t->c_cflag, B460800, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b500000:\n #if defined(B500000)\n       return doSetUnset (&t->c_cflag, B500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b576000:\n #if defined(B576000)\n       return doSetUnset (&t->c_cflag, B576000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b921600:\n #if defined(B921600)\n       return doSetUnset (&t->c_cflag, B921600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1000000:\n #if defined(B1000000)\n       return doSetUnset (&t->c_cflag, B1000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1152000:\n #if defined(B1152000)\n       return doSetUnset (&t->c_cflag, B1152000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1500000:\n #if defined(B1500000)\n       return doSetUnset (&t->c_cflag, B1500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2000000:\n #if defined(B2000000)\n       return doSetUnset (&t->c_cflag, B2000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2500000:\n #if defined(B2500000)\n       return doSetUnset (&t->c_cflag, B2500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3000000:\n #if defined(B3000000)\n       return doSetUnset (&t->c_cflag, B3000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3500000:\n #if defined(B3500000)\n       return doSetUnset (&t->c_cflag, B3500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4000000:\n #if defined(B4000000)\n       return doSetUnset (&t->c_cflag, B4000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case maxbaud:\n #if defined(__MAX_BAUD)\n       return doSetUnset (&t->c_cflag, __MAX_BAUD, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case crtscts:\n #if defined(CRTSCTS)\n       return doSetUnset (&t->c_cflag, CRTSCTS, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs5:\n #if defined(CS5)\n       return doSetUnset (&t->c_cflag, CS5, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs6:\n #if defined(CS6)\n       return doSetUnset (&t->c_cflag, CS6, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs7:\n #if defined(CS7)\n       return doSetUnset (&t->c_cflag, CS7, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs8:\n #if defined(CS8)\n       return doSetUnset (&t->c_cflag, CS8, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cstopb:\n #if defined(CSTOPB)\n       return doSetUnset (&t->c_cflag, CSTOPB, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cread:\n #if defined(CREAD)\n       return doSetUnset (&t->c_cflag, CREAD, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case parenb:\n #if defined(PARENB)\n       return doSetUnset (&t->c_cflag, PARENB, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case parodd:\n #if defined(PARODD)\n       return doSetUnset (&t->c_cflag, PARODD, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case hupcl:\n #if defined(HUPCL)\n       return doSetUnset (&t->c_cflag, HUPCL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case clocal:\n #if defined(CLOCAL)\n       return doSetUnset (&t->c_cflag, CLOCAL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lisig:\n #if defined(ISIG)\n       return doSetUnset (&t->c_lflag, ISIG, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case licanon:\n #if defined(ICANON)\n       return doSetUnset (&t->c_lflag, ICANON, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lxcase:\n #if defined(XCASE)\n       return doSetUnset (&t->c_lflag, XCASE, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lecho:\n #if defined(ECHO)\n       return doSetUnset (&t->c_lflag, ECHO, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoe:\n #if defined(ECHOE)\n       return doSetUnset (&t->c_lflag, ECHOE, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechok:\n #if defined(ECHOK)\n       return doSetUnset (&t->c_lflag, ECHOK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechonl:\n #if defined(ECHONL)\n       return doSetUnset (&t->c_lflag, ECHONL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lnoflsh:\n #if defined(NOFLSH)\n       return doSetUnset (&t->c_lflag, NOFLSH, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ltopstop:\n #if defined(TOSTOP)\n       return doSetUnset (&t->c_lflag, TOSTOP, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoctl:\n #if defined(ECHOCTL)\n       return doSetUnset (&t->c_lflag, ECHOCTL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoprt:\n #if defined(ECHOPRT)\n       return doSetUnset (&t->c_lflag, ECHOPRT, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoke:\n #if defined(ECHOKE)\n       return doSetUnset (&t->c_lflag, ECHOKE, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lflusho:\n #if defined(FLUSHO)\n       return doSetUnset (&t->c_lflag, FLUSHO, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lpendin:\n #if defined(PENDIN)\n       return doSetUnset (&t->c_lflag, PENDIN, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case liexten:\n #if defined(IEXTEN)\n       return doSetUnset (&t->c_lflag, IEXTEN, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     }\n-  return 0;\n+  return false;\n }\n \n-/* GetChar - sets a CHAR, ch, value from, t, and returns TRUE if this\n+/* GetChar sets a CHAR ch value from t and returns true if this\n    value is supported.  */\n \n-int EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch)\n+bool\n+EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch)\n {\n   switch (c)\n     {\n \n     case vintr:\n #if defined(VINTR)\n       *ch = t->c_cc[VINTR];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vquit:\n #if defined(VQUIT)\n       *ch = t->c_cc[VQUIT];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case verase:\n #if defined(VERASE)\n       *ch = t->c_cc[VERASE];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vkill:\n #if defined(VKILL)\n       *ch = t->c_cc[VKILL];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veof:\n #if defined(VEOF)\n       *ch = t->c_cc[VEOF];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vtime:\n #if defined(VTIME)\n       *ch = t->c_cc[VTIME];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vmin:\n #if defined(VMIN)\n       *ch = t->c_cc[VMIN];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vswtc:\n #if defined(VSWTC)\n       *ch = t->c_cc[VSWTC];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstart:\n #if defined(VSTART)\n       *ch = t->c_cc[VSTART];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstop:\n #if defined(VSTOP)\n       *ch = t->c_cc[VSTOP];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vsusp:\n #if defined(VSUSP)\n       *ch = t->c_cc[VSUSP];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol:\n #if defined(VEOL)\n       *ch = t->c_cc[VEOL];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vreprint:\n #if defined(VREPRINT)\n       *ch = t->c_cc[VREPRINT];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vdiscard:\n #if defined(VDISCARD)\n       *ch = t->c_cc[VDISCARD];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vwerase:\n #if defined(VWERASE)\n       *ch = t->c_cc[VWERASE];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vlnext:\n #if defined(VLNEXT)\n       *ch = t->c_cc[VLNEXT];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol2:\n #if defined(VEOL2)\n       *ch = t->c_cc[VEOL2];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     default:\n-      return 0;\n+      return false;\n     }\n }\n \n-/* SetChar - sets a CHAR value in, t, and returns TRUE if, c, is\n-   supported.  */\n+/* SetChar sets a CHAR value in t and returns true if c is supported.  */\n \n-int EXPORT (SetChar) (struct termios *t, ControlChar c, char ch)\n+bool\n+EXPORT (SetChar) (struct termios *t, ControlChar c, char ch)\n {\n   switch (c)\n     {\n \n     case vintr:\n #if defined(VINTR)\n       t->c_cc[VINTR] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vquit:\n #if defined(VQUIT)\n       t->c_cc[VQUIT] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case verase:\n #if defined(VERASE)\n       t->c_cc[VERASE] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vkill:\n #if defined(VKILL)\n       t->c_cc[VKILL] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veof:\n #if defined(VEOF)\n       t->c_cc[VEOF] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vtime:\n #if defined(VTIME)\n       t->c_cc[VTIME] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vmin:\n #if defined(VMIN)\n       t->c_cc[VMIN] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vswtc:\n #if defined(VSWTC)\n       t->c_cc[VSWTC] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstart:\n #if defined(VSTART)\n       t->c_cc[VSTART] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstop:\n #if defined(VSTOP)\n       t->c_cc[VSTOP] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vsusp:\n #if defined(VSUSP)\n       t->c_cc[VSUSP] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol:\n #if defined(VEOL)\n       t->c_cc[VEOL] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vreprint:\n #if defined(VREPRINT)\n       t->c_cc[VREPRINT] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vdiscard:\n #if defined(VDISCARD)\n       t->c_cc[VDISCARD] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vwerase:\n #if defined(VWERASE)\n       t->c_cc[VWERASE] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vlnext:\n #if defined(VLNEXT)\n       t->c_cc[VLNEXT] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol2:\n #if defined(VEOL2)\n       t->c_cc[VEOL2] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     default:\n-      return 0;\n+      return false;\n     }\n }\n "}, {"sha": "963e88ec461f8d07cd57bea86248e9603b4d503b", "filename": "gcc/m2/gm2-libs/Builtins.mod", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/gcc%2Fm2%2Fgm2-libs%2FBuiltins.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/gcc%2Fm2%2Fgm2-libs%2FBuiltins.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FBuiltins.mod?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -59,7 +59,7 @@ END memcpy ;\n \n PROCEDURE __ATTRIBUTE__  __BUILTIN__ ((__builtin_isfinite)) isfinitef (x: SHORTREAL) : INTEGER ;\n BEGIN\n-   RETURN wrapc.isfinitef\n+   RETURN wrapc.isfinitef (x)\n END isfinitef ;\n \n PROCEDURE __ATTRIBUTE__  __BUILTIN__ ((__builtin_isfinite)) isfinite (x: REAL) : INTEGER ;"}, {"sha": "053c75bb11ab0a3460291fa540a17cfb61d133dd", "filename": "libgm2/libm2iso/ErrnoCategory.cc", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2iso%2FErrnoCategory.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2iso%2FErrnoCategory.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2FErrnoCategory.cc?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -42,33 +42,25 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define M2LIBNAME \"m2iso\"\n \n \n-#if !defined(FALSE)\n-#define FALSE (1 == 0)\n-#endif\n-\n-#if !defined(TRUE)\n-#define TRUE (1 == 1)\n-#endif\n-\n-/* IsErrnoHard - returns TRUE if the value of errno is associated\n+/* IsErrnoHard returns true if the value of errno is associated\n    with a hard device error.  */\n \n-extern \"C\" int\n+extern \"C\" bool\n EXPORT(IsErrnoHard) (int e)\n {\n #if defined(HAVE_ERRNO_H) || defined(HAVE_SYS_ERRNO_H)\n   return ((e == EPERM) || (e == ENOENT) || (e == EIO) || (e == ENXIO)\n           || (e == EACCES) || (e == ENOTBLK) || (e == ENODEV) || (e == EINVAL)\n           || (e == ENFILE) || (e == EROFS) || (e == EMLINK));\n #else\n-  return FALSE;\n+  return false;\n #endif\n }\n \n-/* IsErrnoSoft - returns TRUE if the value of errno is associated\n+/* IsErrnoSoft returns true if the value of errno is associated\n    with a soft device error.  */\n \n-extern \"C\" int\n+extern \"C\" bool\n EXPORT(IsErrnoSoft) (int e)\n {\n #if defined(HAVE_ERRNO_H) || defined(HAVE_SYS_ERRNO_H)\n@@ -78,18 +70,18 @@ EXPORT(IsErrnoSoft) (int e)\n           || (e == ENOTDIR) || (e == EISDIR) || (e == EMFILE) || (e == ENOTTY)\n           || (e == ETXTBSY) || (e == EFBIG) || (e == ENOSPC) || (e == EPIPE));\n #else\n-  return FALSE;\n+  return false;\n #endif\n }\n \n-extern \"C\" int\n+extern \"C\" bool\n EXPORT(UnAvailable) (int e)\n {\n #if defined(HAVE_ERRNO_H) || defined(HAVE_SYS_ERRNO_H)\n   return ((e == ENOENT) || (e == ESRCH) || (e == ENXIO) || (e == ECHILD)\n           || (e == ENOTBLK) || (e == ENODEV) || (e == ENOTDIR));\n #else\n-  return FALSE;\n+  return false;\n #endif\n }\n "}, {"sha": "805271ef70d193f08d762f60258bffb40560f1e8", "filename": "libgm2/libm2iso/wrapsock.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2iso%2Fwrapsock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2iso%2Fwrapsock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2Fwrapsock.c?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -25,6 +25,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#include <stdbool.h>\n \n #define EXPORT(FUNC) m2iso ## _wrapsock_ ## FUNC\n #define IMPORT(MODULE,FUNC) m2iso ## _ ## MODULE ## _ ## FUNC\n@@ -88,13 +89,6 @@ extern void m2iso_M2RTS_RegisterModule (const char *modulename, const char *libn\n #include \"stdlib.h\"\n #endif\n \n-#if !defined(TRUE)\n-#define TRUE (1 == 1)\n-#endif\n-#if !defined(FALSE)\n-#define FALSE (1 == 0)\n-#endif\n-\n #include \"ChanConsts.h\"\n \n #define MAXHOSTNAME 1024\n@@ -213,32 +207,32 @@ EXPORT(getClientIP) (clientInfo *c)\n   return c->sa.sin_addr.s_addr;\n }\n \n-/* getPushBackChar - returns TRUE if a pushed back character is\n+/* getPushBackChar returns true if a pushed back character is\n    available.  */\n \n-unsigned int\n+bool\n EXPORT(getPushBackChar) (clientInfo *c, char *ch)\n {\n   if (c->hasChar > 0)\n     {\n       c->hasChar--;\n       *ch = c->pbChar[c->hasChar];\n-      return TRUE;\n+      return true;\n     }\n-  return FALSE;\n+  return false;\n }\n \n-/* setPushBackChar - returns TRUE if it is able to push back a\n+/* setPushBackChar returns true if it is able to push back a\n    character.  */\n \n-unsigned int\n+bool\n EXPORT(setPushBackChar) (clientInfo *c, char ch)\n {\n   if (c->hasChar == MAXPBBUF)\n-    return FALSE;\n+    return false;\n   c->pbChar[c->hasChar] = ch;\n   c->hasChar++;\n-  return TRUE;\n+  return true;\n }\n \n /* getSizeOfClientInfo - returns the sizeof (opaque data type).  */"}, {"sha": "ffe85f17dcadfed8bf3cdc16de43a448312a75ad", "filename": "libgm2/libm2iso/wraptime.cc", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2iso%2Fwraptime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2iso%2Fwraptime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2Fwraptime.cc?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -51,14 +51,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"limits.h\"\n #endif\n \n-#if !defined(TRUE)\n-#define TRUE (1 == 1)\n-#endif\n-\n-#if !defined(FALSE)\n-#define FALSE (1 == 0)\n-#endif\n-\n #if !defined(NULL)\n #define NULL (void *)0\n #endif\n@@ -322,16 +314,16 @@ EXPORT(GetSecond) (void *m)\n /* wraptime_GetSummerTime - returns true if summer time is in effect.  */\n \n #if defined(HAVE_STRUCT_TIMEZONE)\n-extern \"C\" unsigned int\n+extern \"C\" bool\n EXPORT(GetSummerTime) (struct timezone *tz)\n {\n   return tz->tz_dsttime != 0;\n }\n #else\n-extern \"C\" unsigned int\n+extern \"C\" bool\n EXPORT(GetSummerTime) (void *tz)\n {\n-  return FALSE;\n+  return false;\n }\n #endif\n "}, {"sha": "a3954db5517e6b1d9e62a87554c7de772e2cad90", "filename": "libgm2/libm2pim/cgetopt.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Fcgetopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Fcgetopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fcgetopt.cc?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -113,7 +113,7 @@ EXPORT(KillOptions) (cgetopt_Options *o)\n \n extern \"C\" void\n EXPORT(SetOption) (cgetopt_Options *o, unsigned int index, char *name,\n- \t\t   unsigned int has_arg, int *flag, int val)\n+ \t\t   bool has_arg, int *flag, int val)\n {\n   if (index > o->high)\n     {"}, {"sha": "18bb079a79c217aadcad7776199383a663eacf1c", "filename": "libgm2/libm2pim/dtoa.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Fdtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Fdtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fdtoa.cc?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -198,20 +198,20 @@ EXPORT(calcdecimal) (char *p, int str_size, int ndigits)\n   return x;\n }\n \n-extern \"C\" int\n+extern \"C\" bool\n EXPORT(calcsign) (char *p, int str_size)\n {\n   if (p[0] == '-')\n     {\n       memmove (p, p + 1, str_size - 1);\n-      return TRUE;\n+      return true;\n     }\n   else\n-    return FALSE;\n+    return false;\n }\n \n extern \"C\" char *\n-EXPORT(dtoa) (double d, int mode, int ndigits, int *decpt, int *sign)\n+EXPORT(dtoa) (double d, int mode, int ndigits, int *decpt, bool *sign)\n {\n   char format[50];\n   char *p;"}, {"sha": "d1d37f8f99b80dca5df84164f38873985622c202", "filename": "libgm2/libm2pim/ldtoa.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Fldtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Fldtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Fldtoa.cc?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -139,7 +139,7 @@ EXPORT(strtold) (const char *s, int *error)\n }\n \n extern \"C\" char *\n-EXPORT(ldtoa) (long double d, int mode, int ndigits, int *decpt, int *sign)\n+EXPORT(ldtoa) (long double d, int mode, int ndigits, int *decpt, bool *sign)\n {\n   char format[50];\n   char *p;"}, {"sha": "6176a5b15c14405d3005d9353d0ed88536dc9d0f", "filename": "libgm2/libm2pim/termios.cc", "status": "modified", "additions": 378, "deletions": 379, "changes": 757, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Ftermios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c5dfc29d83101e415590e778b99e7c37d9b730/libgm2%2Flibm2pim%2Ftermios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2pim%2Ftermios.cc?ref=19c5dfc29d83101e415590e778b99e7c37d9b730", "patch": "@@ -208,14 +208,14 @@ extern \"C\" int EXPORT (tcflowoni) (int fd);\n extern \"C\" int EXPORT (tcflowoffi) (int fd);\n extern \"C\" int EXPORT (tcflowono) (int fd);\n extern \"C\" int EXPORT (tcflowoffo) (int fd);\n-extern \"C\" int EXPORT (GetFlag) (struct termios *t, Flag f, int *b);\n-extern \"C\" int EXPORT (SetFlag) (struct termios *t, Flag f, int b);\n-extern \"C\" int EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch);\n-extern \"C\" int EXPORT (SetChar) (struct termios *t, ControlChar c, char ch);\n+extern \"C\" bool EXPORT (GetFlag) (struct termios *t, Flag f, bool *b);\n+extern \"C\" bool EXPORT (SetFlag) (struct termios *t, Flag f, bool b);\n+extern \"C\" bool EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch);\n+extern \"C\" bool EXPORT (SetChar) (struct termios *t, ControlChar c, char ch);\n extern \"C\" int EXPORT (tcsnow) (void);\n extern \"C\" int EXPORT (tcsflush) (void);\n extern \"C\" int EXPORT (tcsdrain) (void);\n-extern \"C\" int doSetUnset (tcflag_t *bitset, unsigned int mask, int value);\n+extern \"C\" bool doSetUnset (tcflag_t *bitset, unsigned int mask, bool value);\n \n /* InitTermios new data structure.   */\n \n@@ -412,708 +412,707 @@ EXPORT (tcflowoffo) (int fd)\n #endif\n }\n \n-/* doSetUnset applies mask or undoes mask depending upon value.  */\n+/* doSetUnset applies mask or undoes mask depending upon value and returns true.  */\n \n-extern \"C\" int\n-doSetUnset (tcflag_t *bitset, unsigned int mask, int value)\n+extern \"C\" bool\n+doSetUnset (tcflag_t *bitset, unsigned int mask, bool value)\n {\n   if (value)\n     (*bitset) |= mask;\n   else\n     (*bitset) &= (~mask);\n-  return 1;\n+  return true;\n }\n \n-/* GetFlag sets a flag value from, t, in, b, and returns TRUE\n-   if, t, supports, f.  */\n+/* GetFlag sets a flag value from t in b and returns true if t supports f.  */\n \n-extern \"C\" int\n-EXPORT (GetFlag) (struct termios *t, Flag f, int *b)\n+extern \"C\" bool\n+EXPORT (GetFlag) (struct termios *t, Flag f, bool *b)\n {\n   switch (f)\n     {\n \n     case ignbrk:\n #if defined(IGNBRK)\n       *b = ((t->c_iflag & IGNBRK) == IGNBRK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ibrkint:\n #if defined(BRKINT)\n       *b = ((t->c_iflag & BRKINT) == BRKINT);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ignpar:\n #if defined(IGNPAR)\n       *b = ((t->c_iflag & IGNPAR) == IGNPAR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case iparmrk:\n #if defined(PARMRK)\n       *b = ((t->c_iflag & PARMRK) == PARMRK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case inpck:\n #if defined(INPCK)\n       *b = ((t->c_iflag & INPCK) == INPCK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case istrip:\n #if defined(ISTRIP)\n       *b = ((t->c_iflag & ISTRIP) == ISTRIP);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case inlcr:\n #if defined(INLCR)\n       *b = ((t->c_iflag & INLCR) == INLCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case igncr:\n #if defined(IGNCR)\n       *b = ((t->c_iflag & IGNCR) == IGNCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case icrnl:\n #if defined(ICRNL)\n       *b = ((t->c_iflag & ICRNL) == ICRNL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case iuclc:\n #if defined(IUCLC)\n       *b = ((t->c_iflag & IUCLC) == IUCLC);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixon:\n #if defined(IXON)\n       *b = ((t->c_iflag & IXON) == IXON);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixany:\n #if defined(IXANY)\n       *b = ((t->c_iflag & IXANY) == IXANY);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixoff:\n #if defined(IXOFF)\n       *b = ((t->c_iflag & IXOFF) == IXOFF);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case imaxbel:\n #if defined(IMAXBEL)\n       *b = ((t->c_iflag & IMAXBEL) == IMAXBEL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case opost:\n #if defined(OPOST)\n       *b = ((t->c_oflag & OPOST) == OPOST);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case olcuc:\n #if defined(OLCUC)\n       *b = ((t->c_oflag & OLCUC) == OLCUC);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlcr:\n #if defined(ONLCR)\n       *b = ((t->c_oflag & ONLCR) == ONLCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocrnl:\n #if defined(OCRNL)\n       *b = ((t->c_oflag & OCRNL) == OCRNL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onocr:\n #if defined(ONOCR)\n       *b = ((t->c_oflag & ONOCR) == ONOCR);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlret:\n #if defined(ONLRET)\n       *b = ((t->c_oflag & ONLRET) == ONLRET);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofill:\n #if defined(OFILL)\n       *b = ((t->c_oflag & OFILL) == OFILL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofdel:\n #if defined(OFDEL)\n       *b = ((t->c_oflag & OFDEL) == OFDEL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl0:\n #if defined(NL0)\n       *b = ((t->c_oflag & NL0) == NL0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl1:\n #if defined(NL1)\n       *b = ((t->c_oflag & NL1) == NL1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr0:\n #if defined(CR0)\n       *b = ((t->c_oflag & CR0) == CR0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr1:\n #if defined(CR1)\n       *b = ((t->c_oflag & CR1) == CR1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr2:\n #if defined(CR2)\n       *b = ((t->c_oflag & CR2) == CR2);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr3:\n #if defined(CR3)\n       *b = ((t->c_oflag & CR3) == CR3);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab0:\n #if defined(TAB0)\n       *b = ((t->c_oflag & TAB0) == TAB0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab1:\n #if defined(TAB1)\n       *b = ((t->c_oflag & TAB1) == TAB1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab2:\n #if defined(TAB2)\n       *b = ((t->c_oflag & TAB2) == TAB2);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab3:\n #if defined(TAB3)\n       *b = ((t->c_oflag & TAB3) == TAB3);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs0:\n #if defined(BS0)\n       *b = ((t->c_oflag & BS0) == BS0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs1:\n #if defined(BS1)\n       *b = ((t->c_oflag & BS1) == BS1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case off0:\n #if defined(FF0)\n       *b = ((t->c_oflag & FF0) == FF0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case off1:\n #if defined(FF1)\n       *b = ((t->c_oflag & FF1) == FF1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt0:\n #if defined(VT0)\n       *b = ((t->c_oflag & VT0) == VT0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt1:\n #if defined(VT1)\n       *b = ((t->c_oflag & VT1) == VT1);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b0:\n #if defined(B0)\n       *b = ((t->c_cflag & B0) == B0);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b50:\n #if defined(B50)\n       *b = ((t->c_cflag & B50) == B50);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b75:\n #if defined(B75)\n       *b = ((t->c_cflag & B75) == B75);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b110:\n #if defined(B110)\n       *b = ((t->c_cflag & B110) == B110);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b135:\n #if defined(B134)\n       *b = ((t->c_cflag & B134) == B134);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b150:\n #if defined(B150)\n       *b = ((t->c_cflag & B150) == B150);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b200:\n #if defined(B200)\n       *b = ((t->c_cflag & B200) == B200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b300:\n #if defined(B300)\n       *b = ((t->c_cflag & B300) == B300);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b600:\n #if defined(B600)\n       *b = ((t->c_cflag & B600) == B600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1200:\n #if defined(B1200)\n       *b = ((t->c_cflag & B1200) == B1200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1800:\n #if defined(B1800)\n       *b = ((t->c_cflag & B1800) == B1800);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2400:\n #if defined(B2400)\n       *b = ((t->c_cflag & B2400) == B2400);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4800:\n #if defined(B4800)\n       *b = ((t->c_cflag & B4800) == B4800);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b9600:\n #if defined(B9600)\n       *b = ((t->c_cflag & B9600) == B9600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b19200:\n #if defined(B19200)\n       *b = ((t->c_cflag & B19200) == B19200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b38400:\n #if defined(B38400)\n       *b = ((t->c_cflag & B38400) == B38400);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b57600:\n #if defined(B57600)\n       *b = ((t->c_cflag & B57600) == B57600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b115200:\n #if defined(B115200)\n       *b = ((t->c_cflag & B115200) == B115200);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b240400:\n #if defined(B230400)\n       *b = ((t->c_cflag & B230400) == B230400);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b460800:\n #if defined(B460800)\n       *b = ((t->c_cflag & B460800) == B460800);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b500000:\n #if defined(B500000)\n       *b = ((t->c_cflag & B500000) == B500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b576000:\n #if defined(B576000)\n       *b = ((t->c_cflag & B576000) == B576000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b921600:\n #if defined(B921600)\n       *b = ((t->c_cflag & B921600) == B921600);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1000000:\n #if defined(B1000000)\n       *b = ((t->c_cflag & B1000000) == B1000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1152000:\n #if defined(B1152000)\n       *b = ((t->c_cflag & B1152000) == B1152000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1500000:\n #if defined(B1500000)\n       *b = ((t->c_cflag & B1500000) == B1500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2000000:\n #if defined(B2000000)\n       *b = ((t->c_cflag & B2000000) == B2000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2500000:\n #if defined(B2500000)\n       *b = ((t->c_cflag & B2500000) == B2500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3000000:\n #if defined(B3000000)\n       *b = ((t->c_cflag & B3000000) == B3000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3500000:\n #if defined(B3500000)\n       *b = ((t->c_cflag & B3500000) == B3500000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4000000:\n #if defined(B4000000)\n       *b = ((t->c_cflag & B4000000) == B4000000);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case maxbaud:\n #if defined(MAX)\n       *b = ((t->c_cflag & __MAX_BAUD) == __MAX_BAUD);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case crtscts:\n #if defined(CRTSCTS)\n       *b = ((t->c_cflag & CRTSCTS) == CRTSCTS);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs5:\n #if defined(CS5)\n       *b = ((t->c_cflag & CS5) == CS5);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs6:\n #if defined(CS6)\n       *b = ((t->c_cflag & CS6) == CS6);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs7:\n #if defined(CS7)\n       *b = ((t->c_cflag & CS7) == CS7);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs8:\n #if defined(CS8)\n       *b = ((t->c_cflag & CS8) == CS8);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cstopb:\n #if defined(CSTOPB)\n       *b = ((t->c_cflag & CSTOPB) == CSTOPB);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case cread:\n #if defined(CREAD)\n       *b = ((t->c_cflag & CREAD) == CREAD);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case parenb:\n #if defined(PARENB)\n       *b = ((t->c_cflag & PARENB) == PARENB);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case parodd:\n #if defined(PARODD)\n       *b = ((t->c_cflag & PARODD) == PARODD);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case hupcl:\n #if defined(HUPCL)\n       *b = ((t->c_cflag & HUPCL) == HUPCL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case clocal:\n #if defined(CLOCAL)\n       *b = ((t->c_cflag & CLOCAL) == CLOCAL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lisig:\n #if defined(ISIG)\n       *b = ((t->c_lflag & ISIG) == ISIG);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case licanon:\n #if defined(ICANON)\n       *b = ((t->c_lflag & ICANON) == ICANON);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lxcase:\n #if defined(XCASE)\n       *b = ((t->c_lflag & XCASE) == XCASE);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lecho:\n #if defined(ECHO)\n       *b = ((t->c_lflag & ECHO) == ECHO);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoe:\n #if defined(ECHOE)\n       *b = ((t->c_lflag & ECHOE) == ECHOE);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechok:\n #if defined(ECHOK)\n       *b = ((t->c_lflag & ECHOK) == ECHOK);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechonl:\n #if defined(ECHONL)\n       *b = ((t->c_lflag & ECHONL) == ECHONL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lnoflsh:\n #if defined(NOFLSH)\n       *b = ((t->c_lflag & NOFLSH) == NOFLSH);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case ltopstop:\n #if defined(TOSTOP)\n       *b = ((t->c_lflag & TOSTOP) == TOSTOP);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoctl:\n #if defined(ECHOCTL)\n       *b = ((t->c_lflag & ECHOCTL) == ECHOCTL);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoprt:\n #if defined(ECHOPRT)\n       *b = ((t->c_lflag & ECHOPRT) == ECHOPRT);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoke:\n #if defined(ECHOKE)\n       *b = ((t->c_lflag & ECHOKE) == ECHOKE);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lflusho:\n #if defined(FLUSHO)\n       *b = ((t->c_lflag & FLUSHO) == FLUSHO);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case lpendin:\n #if defined(PENDIN)\n       *b = ((t->c_lflag & PENDIN) == PENDIN);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case liexten:\n #if defined(IEXTEN)\n       *b = ((t->c_lflag & IEXTEN) == IEXTEN);\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     }\n-  return 0;\n+  return false;\n }\n \n-/* SetFlag sets a flag value in, t, to, b, and returns TRUE if\n-   this flag value is supported.  */\n+/* SetFlag sets a flag value in t to b and returns true if this flag\n+   value is supported.  */\n \n-extern \"C\" int\n-EXPORT (SetFlag) (struct termios *t, Flag f, int b)\n+extern \"C\" bool\n+EXPORT (SetFlag) (struct termios *t, Flag f, bool b)\n {\n   switch (f)\n     {\n@@ -1122,586 +1121,586 @@ EXPORT (SetFlag) (struct termios *t, Flag f, int b)\n #if defined(IGNBRK)\n       return doSetUnset (&t->c_iflag, IGNBRK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ibrkint:\n #if defined(BRKINT)\n       return doSetUnset (&t->c_iflag, BRKINT, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ignpar:\n #if defined(IGNPAR)\n       return doSetUnset (&t->c_iflag, IGNPAR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case iparmrk:\n #if defined(PARMRK)\n       return doSetUnset (&t->c_iflag, PARMRK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case inpck:\n #if defined(INPCK)\n       return doSetUnset (&t->c_iflag, INPCK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case istrip:\n #if defined(ISTRIP)\n       return doSetUnset (&t->c_iflag, ISTRIP, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case inlcr:\n #if defined(INLCR)\n       return doSetUnset (&t->c_iflag, INLCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case igncr:\n #if defined(IGNCR)\n       return doSetUnset (&t->c_iflag, IGNCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case icrnl:\n #if defined(ICRNL)\n       return doSetUnset (&t->c_iflag, ICRNL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case iuclc:\n #if defined(IUCLC)\n       return doSetUnset (&t->c_iflag, IUCLC, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixon:\n #if defined(IXON)\n       return doSetUnset (&t->c_iflag, IXON, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixany:\n #if defined(IXANY)\n       return doSetUnset (&t->c_iflag, IXANY, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ixoff:\n #if defined(IXOFF)\n       return doSetUnset (&t->c_iflag, IXOFF, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case imaxbel:\n #if defined(IMAXBEL)\n       return doSetUnset (&t->c_iflag, IMAXBEL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case opost:\n #if defined(OPOST)\n       return doSetUnset (&t->c_oflag, OPOST, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case olcuc:\n #if defined(OLCUC)\n       return doSetUnset (&t->c_oflag, OLCUC, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlcr:\n #if defined(ONLCR)\n       return doSetUnset (&t->c_oflag, ONLCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocrnl:\n #if defined(OCRNL)\n       return doSetUnset (&t->c_oflag, OCRNL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onocr:\n #if defined(ONOCR)\n       return doSetUnset (&t->c_oflag, ONOCR, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onlret:\n #if defined(ONLRET)\n       return doSetUnset (&t->c_oflag, ONLRET, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofill:\n #if defined(OFILL)\n       return doSetUnset (&t->c_oflag, OFILL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ofdel:\n #if defined(OFDEL)\n       return doSetUnset (&t->c_oflag, OFDEL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl0:\n #if defined(NL0)\n       return doSetUnset (&t->c_oflag, NL0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case onl1:\n #if defined(NL1)\n       return doSetUnset (&t->c_oflag, NL1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr0:\n #if defined(CR0)\n       return doSetUnset (&t->c_oflag, CR0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr1:\n #if defined(CR1)\n       return doSetUnset (&t->c_oflag, CR1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr2:\n #if defined(CR2)\n       return doSetUnset (&t->c_oflag, CR2, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ocr3:\n #if defined(CR3)\n       return doSetUnset (&t->c_oflag, CR3, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab0:\n #if defined(TAB0)\n       return doSetUnset (&t->c_oflag, TAB0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab1:\n #if defined(TAB1)\n       return doSetUnset (&t->c_oflag, TAB1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab2:\n #if defined(TAB2)\n       return doSetUnset (&t->c_oflag, TAB2, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case otab3:\n #if defined(TAB3)\n       return doSetUnset (&t->c_oflag, TAB3, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs0:\n #if defined(BS0)\n       return doSetUnset (&t->c_oflag, BS0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case obs1:\n #if defined(BS1)\n       return doSetUnset (&t->c_oflag, BS1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case off0:\n #if defined(FF0)\n       return doSetUnset (&t->c_oflag, FF0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case off1:\n #if defined(FF1)\n       return doSetUnset (&t->c_oflag, FF1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt0:\n #if defined(VT0)\n       return doSetUnset (&t->c_oflag, VT0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ovt1:\n #if defined(VT1)\n       return doSetUnset (&t->c_oflag, VT1, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b0:\n #if defined(B0)\n       return doSetUnset (&t->c_cflag, B0, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b50:\n #if defined(B50)\n       return doSetUnset (&t->c_cflag, B50, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b75:\n #if defined(B75)\n       return doSetUnset (&t->c_cflag, B75, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b110:\n #if defined(B110)\n       return doSetUnset (&t->c_cflag, B110, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b135:\n #if defined(B134)\n       return doSetUnset (&t->c_cflag, B134, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b150:\n #if defined(B150)\n       return doSetUnset (&t->c_cflag, B150, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b200:\n #if defined(B200)\n       return doSetUnset (&t->c_cflag, B200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b300:\n #if defined(B300)\n       return doSetUnset (&t->c_cflag, B300, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b600:\n #if defined(B600)\n       return doSetUnset (&t->c_cflag, B600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1200:\n #if defined(B1200)\n       return doSetUnset (&t->c_cflag, B1200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1800:\n #if defined(B1800)\n       return doSetUnset (&t->c_cflag, B1800, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2400:\n #if defined(B2400)\n       return doSetUnset (&t->c_cflag, B2400, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4800:\n #if defined(B4800)\n       return doSetUnset (&t->c_cflag, B4800, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b9600:\n #if defined(B9600)\n       return doSetUnset (&t->c_cflag, B9600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b19200:\n #if defined(B19200)\n       return doSetUnset (&t->c_cflag, B19200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b38400:\n #if defined(B38400)\n       return doSetUnset (&t->c_cflag, B38400, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b57600:\n #if defined(B57600)\n       return doSetUnset (&t->c_cflag, B57600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b115200:\n #if defined(B115200)\n       return doSetUnset (&t->c_cflag, B115200, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b240400:\n #if defined(B230400)\n       return doSetUnset (&t->c_cflag, B230400, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b460800:\n #if defined(B460800)\n       return doSetUnset (&t->c_cflag, B460800, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b500000:\n #if defined(B500000)\n       return doSetUnset (&t->c_cflag, B500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b576000:\n #if defined(B576000)\n       return doSetUnset (&t->c_cflag, B576000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b921600:\n #if defined(B921600)\n       return doSetUnset (&t->c_cflag, B921600, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1000000:\n #if defined(B1000000)\n       return doSetUnset (&t->c_cflag, B1000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1152000:\n #if defined(B1152000)\n       return doSetUnset (&t->c_cflag, B1152000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b1500000:\n #if defined(B1500000)\n       return doSetUnset (&t->c_cflag, B1500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2000000:\n #if defined(B2000000)\n       return doSetUnset (&t->c_cflag, B2000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b2500000:\n #if defined(B2500000)\n       return doSetUnset (&t->c_cflag, B2500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3000000:\n #if defined(B3000000)\n       return doSetUnset (&t->c_cflag, B3000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b3500000:\n #if defined(B3500000)\n       return doSetUnset (&t->c_cflag, B3500000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case b4000000:\n #if defined(B4000000)\n       return doSetUnset (&t->c_cflag, B4000000, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case maxbaud:\n #if defined(__MAX_BAUD)\n       return doSetUnset (&t->c_cflag, __MAX_BAUD, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case crtscts:\n #if defined(CRTSCTS)\n       return doSetUnset (&t->c_cflag, CRTSCTS, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs5:\n #if defined(CS5)\n       return doSetUnset (&t->c_cflag, CS5, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs6:\n #if defined(CS6)\n       return doSetUnset (&t->c_cflag, CS6, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs7:\n #if defined(CS7)\n       return doSetUnset (&t->c_cflag, CS7, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cs8:\n #if defined(CS8)\n       return doSetUnset (&t->c_cflag, CS8, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cstopb:\n #if defined(CSTOPB)\n       return doSetUnset (&t->c_cflag, CSTOPB, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case cread:\n #if defined(CREAD)\n       return doSetUnset (&t->c_cflag, CREAD, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case parenb:\n #if defined(PARENB)\n       return doSetUnset (&t->c_cflag, PARENB, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case parodd:\n #if defined(PARODD)\n       return doSetUnset (&t->c_cflag, PARODD, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case hupcl:\n #if defined(HUPCL)\n       return doSetUnset (&t->c_cflag, HUPCL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case clocal:\n #if defined(CLOCAL)\n       return doSetUnset (&t->c_cflag, CLOCAL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lisig:\n #if defined(ISIG)\n       return doSetUnset (&t->c_lflag, ISIG, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case licanon:\n #if defined(ICANON)\n       return doSetUnset (&t->c_lflag, ICANON, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lxcase:\n #if defined(XCASE)\n       return doSetUnset (&t->c_lflag, XCASE, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lecho:\n #if defined(ECHO)\n       return doSetUnset (&t->c_lflag, ECHO, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoe:\n #if defined(ECHOE)\n       return doSetUnset (&t->c_lflag, ECHOE, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechok:\n #if defined(ECHOK)\n       return doSetUnset (&t->c_lflag, ECHOK, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechonl:\n #if defined(ECHONL)\n       return doSetUnset (&t->c_lflag, ECHONL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lnoflsh:\n #if defined(NOFLSH)\n       return doSetUnset (&t->c_lflag, NOFLSH, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case ltopstop:\n #if defined(TOSTOP)\n       return doSetUnset (&t->c_lflag, TOSTOP, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoctl:\n #if defined(ECHOCTL)\n       return doSetUnset (&t->c_lflag, ECHOCTL, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoprt:\n #if defined(ECHOPRT)\n       return doSetUnset (&t->c_lflag, ECHOPRT, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lechoke:\n #if defined(ECHOKE)\n       return doSetUnset (&t->c_lflag, ECHOKE, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lflusho:\n #if defined(FLUSHO)\n       return doSetUnset (&t->c_lflag, FLUSHO, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case lpendin:\n #if defined(PENDIN)\n       return doSetUnset (&t->c_lflag, PENDIN, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     case liexten:\n #if defined(IEXTEN)\n       return doSetUnset (&t->c_lflag, IEXTEN, b);\n #else\n-      return 0;\n+      return false;\n #endif\n     }\n-  return 0;\n+  return false;\n }\n \n /* GetChar sets a CHAR, ch, value from, t, and returns TRUE if\n    this value is supported.  */\n \n-extern \"C\" int\n+extern \"C\" bool\n EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch)\n {\n   switch (c)\n@@ -1710,131 +1709,131 @@ EXPORT (GetChar) (struct termios *t, ControlChar c, char *ch)\n     case vintr:\n #if defined(VINTR)\n       *ch = t->c_cc[VINTR];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vquit:\n #if defined(VQUIT)\n       *ch = t->c_cc[VQUIT];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case verase:\n #if defined(VERASE)\n       *ch = t->c_cc[VERASE];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vkill:\n #if defined(VKILL)\n       *ch = t->c_cc[VKILL];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veof:\n #if defined(VEOF)\n       *ch = t->c_cc[VEOF];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vtime:\n #if defined(VTIME)\n       *ch = t->c_cc[VTIME];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vmin:\n #if defined(VMIN)\n       *ch = t->c_cc[VMIN];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vswtc:\n #if defined(VSWTC)\n       *ch = t->c_cc[VSWTC];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstart:\n #if defined(VSTART)\n       *ch = t->c_cc[VSTART];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstop:\n #if defined(VSTOP)\n       *ch = t->c_cc[VSTOP];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vsusp:\n #if defined(VSUSP)\n       *ch = t->c_cc[VSUSP];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol:\n #if defined(VEOL)\n       *ch = t->c_cc[VEOL];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vreprint:\n #if defined(VREPRINT)\n       *ch = t->c_cc[VREPRINT];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vdiscard:\n #if defined(VDISCARD)\n       *ch = t->c_cc[VDISCARD];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vwerase:\n #if defined(VWERASE)\n       *ch = t->c_cc[VWERASE];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vlnext:\n #if defined(VLNEXT)\n       *ch = t->c_cc[VLNEXT];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol2:\n #if defined(VEOL2)\n       *ch = t->c_cc[VEOL2];\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     default:\n-      return 0;\n+      return false;\n     }\n }\n \n /* SetChar sets a CHAR value in, t, and returns TRUE if, c,\n    is supported.  */\n \n-extern \"C\" int\n+extern \"C\" bool\n EXPORT (SetChar) (struct termios *t, ControlChar c, char ch)\n {\n   switch (c)\n@@ -1843,124 +1842,124 @@ EXPORT (SetChar) (struct termios *t, ControlChar c, char ch)\n     case vintr:\n #if defined(VINTR)\n       t->c_cc[VINTR] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vquit:\n #if defined(VQUIT)\n       t->c_cc[VQUIT] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case verase:\n #if defined(VERASE)\n       t->c_cc[VERASE] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vkill:\n #if defined(VKILL)\n       t->c_cc[VKILL] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veof:\n #if defined(VEOF)\n       t->c_cc[VEOF] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vtime:\n #if defined(VTIME)\n       t->c_cc[VTIME] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vmin:\n #if defined(VMIN)\n       t->c_cc[VMIN] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vswtc:\n #if defined(VSWTC)\n       t->c_cc[VSWTC] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstart:\n #if defined(VSTART)\n       t->c_cc[VSTART] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vstop:\n #if defined(VSTOP)\n       t->c_cc[VSTOP] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vsusp:\n #if defined(VSUSP)\n       t->c_cc[VSUSP] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol:\n #if defined(VEOL)\n       t->c_cc[VEOL] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vreprint:\n #if defined(VREPRINT)\n       t->c_cc[VREPRINT] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vdiscard:\n #if defined(VDISCARD)\n       t->c_cc[VDISCARD] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vwerase:\n #if defined(VWERASE)\n       t->c_cc[VWERASE] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case vlnext:\n #if defined(VLNEXT)\n       t->c_cc[VLNEXT] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     case veol2:\n #if defined(VEOL2)\n       t->c_cc[VEOL2] = ch;\n-      return 1;\n+      return true;\n #else\n-      return 0;\n+      return false;\n #endif\n     default:\n-      return 0;\n+      return false;\n     }\n }\n #endif"}]}