{"sha": "6d1cb95f3fe55d63086401db8e1f427ec22b4ded", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQxY2I5NWYzZmU1NWQ2MzA4NjQwMWRiOGUxZjQyN2VjMjJiNGRlZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-06-24T17:22:05Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-06-24T17:22:05Z"}, "message": "Back out these patches:\n\n\t 2003-06-02  J\"orn Rennecke <joern.rennecke@superh.com>\n          * sh.h (OLD_ARG_MODE): New macro.\n          (FUNCTION_ARG_ADVANCE, FUNCTION_ARG_PASS_BY_REFERENCE): Use it.\n          (FUNCTION_ARG_1): Break out of:\n          (FUNCTION_ARG).  Use OLD_ARG_MODE.\n\t 2003-06-06  J\"orn Rennecke <joern.rennecke@superh.com>\n          * sh.h (FUNCTION_ARG_1): Consistently use NEW_MODE for the mode\n          of the generated register.\n\n\t* sh.h (FUNCTION_ARG_SCmode_WART): Define.\n\t(FUNCTION_ARG): Unless FUNCTION_ARG_SCmode_WART is defined and\n\tan even number of floating point regs are in use, use the same\n\tsequence of argument passing registers for SCmode as would be\n\tused for two SFmode values.\n\t* sh.c (sh_va_arg): If FUNCTION_ARG_SCmode_WART is defined,\n\tswap real / imaginary parts in incoming SCmode values passed\n\tin registers.\n\nFrom-SVN: r68430", "tree": {"sha": "11e58316d1505edd9fb4821dd5138538ebed08bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11e58316d1505edd9fb4821dd5138538ebed08bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d1cb95f3fe55d63086401db8e1f427ec22b4ded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1cb95f3fe55d63086401db8e1f427ec22b4ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1cb95f3fe55d63086401db8e1f427ec22b4ded", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1cb95f3fe55d63086401db8e1f427ec22b4ded/comments", "author": null, "committer": null, "parents": [{"sha": "d28dd0f9d188c3098352e6b00b895a56d254c358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28dd0f9d188c3098352e6b00b895a56d254c358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d28dd0f9d188c3098352e6b00b895a56d254c358"}], "stats": {"total": 182, "additions": 139, "deletions": 43}, "files": [{"sha": "6b63396325f4d8c72b149dbd8d6860c0da4d4f34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1cb95f3fe55d63086401db8e1f427ec22b4ded/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1cb95f3fe55d63086401db8e1f427ec22b4ded/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d1cb95f3fe55d63086401db8e1f427ec22b4ded", "patch": "@@ -1,3 +1,24 @@\n+2003-06-24  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\tBack out these patches:\n+\t 2003-06-02  J\"orn Rennecke <joern.rennecke@superh.com>\n+          * sh.h (OLD_ARG_MODE): New macro.\n+          (FUNCTION_ARG_ADVANCE, FUNCTION_ARG_PASS_BY_REFERENCE): Use it.\n+          (FUNCTION_ARG_1): Break out of:\n+          (FUNCTION_ARG).  Use OLD_ARG_MODE.\n+\t 2003-06-06  J\"orn Rennecke <joern.rennecke@superh.com>\n+          * sh.h (FUNCTION_ARG_1): Consistently use NEW_MODE for the mode\n+          of the generated register.\n+\n+\t* sh.h (FUNCTION_ARG_SCmode_WART): Define.\n+\t(FUNCTION_ARG): Unless FUNCTION_ARG_SCmode_WART is defined and\n+\tan even number of floating point regs are in use, use the same\n+\tsequence of argument passing registers for SCmode as would be \n+\tused for two SFmode values.\n+\t* sh.c (sh_va_arg): If FUNCTION_ARG_SCmode_WART is defined,\n+\tswap real / imaginary parts in incoming SCmode values passed\n+\tin registers.\n+\n 2003-06-24  Falk Hueffner  <falk.hueffner@student.uni-tuebingen.de>\n \n         PR target/11260"}, {"sha": "aab3c3945b3eaf61a9e88ad15d81237e44295594", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1cb95f3fe55d63086401db8e1f427ec22b4ded/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1cb95f3fe55d63086401db8e1f427ec22b4ded/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6d1cb95f3fe55d63086401db8e1f427ec22b4ded", "patch": "@@ -5940,8 +5940,9 @@ sh_va_arg (valist, type)\n   HOST_WIDE_INT size, rsize;\n   tree tmp, pptr_type_node;\n   rtx addr_rtx, r;\n-  rtx result;\n+  rtx result_ptr, result = NULL_RTX;\n   int pass_by_ref = MUST_PASS_IN_STACK (TYPE_MODE (type), type);\n+  rtx lab_over;\n \n   size = int_size_in_bytes (type);\n   rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n@@ -5955,7 +5956,7 @@ sh_va_arg (valist, type)\n       tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n       tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n       int pass_as_float;\n-      rtx lab_false, lab_over;\n+      rtx lab_false;\n \n       f_next_o = TYPE_FIELDS (va_list_type_node);\n       f_next_o_limit = TREE_CHAIN (f_next_o);\n@@ -5973,6 +5974,16 @@ sh_va_arg (valist, type)\n       next_stack = build (COMPONENT_REF, TREE_TYPE (f_next_stack),\n \t\t\t  valist, f_next_stack);\n \n+      /* Structures with a single member with a distinct mode are passed\n+\t like their member.  This is relevant if the latter has a REAL_TYPE\n+\t or COMPLEX_TYPE type.  */\n+      if (TREE_CODE (type) == RECORD_TYPE\n+\t  && TYPE_FIELDS (type)\n+\t  && TREE_CODE (TYPE_FIELDS (type)) == FIELD_DECL\n+\t  && (TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == REAL_TYPE\n+\t      || TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == COMPLEX_TYPE)\n+          && TREE_CHAIN (TYPE_FIELDS (type)) == NULL_TREE)\n+\ttype = TREE_TYPE (TYPE_FIELDS (type));\n       if (TARGET_SH4)\n \t{\n \t  pass_as_float = ((TREE_CODE (type) == REAL_TYPE && size <= 8)\n@@ -5989,6 +6000,9 @@ sh_va_arg (valist, type)\n       lab_false = gen_label_rtx ();\n       lab_over = gen_label_rtx ();\n \n+      tmp = make_tree (pptr_type_node, addr_rtx);\n+      valist = build1 (INDIRECT_REF, ptr_type_node, tmp);\n+\n       if (pass_as_float)\n \t{\n \t  int first_floatreg\n@@ -6018,6 +6032,37 @@ sh_va_arg (valist, type)\n \t  if (r != addr_rtx)\n \t    emit_move_insn (addr_rtx, r);\n \n+#ifdef FUNCTION_ARG_SCmode_WART\n+\t  if (TYPE_MODE (type) == SCmode && TARGET_SH4 && TARGET_LITTLE_ENDIAN)\n+\t    {\n+\t      rtx addr, real, imag, result_value, slot;\n+\t      tree subtype = TREE_TYPE (type);\n+\n+\t      addr = std_expand_builtin_va_arg (valist, subtype);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t      if (GET_MODE (addr) != Pmode)\n+\t\taddr = convert_memory_address (Pmode, addr);\n+#endif\n+\t      imag = gen_rtx_MEM (TYPE_MODE (type), addr);\n+\t      set_mem_alias_set (imag, get_varargs_alias_set ());\n+\n+\t      addr = std_expand_builtin_va_arg (valist, subtype);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t      if (GET_MODE (addr) != Pmode)\n+\t\taddr = convert_memory_address (Pmode, addr);\n+#endif\n+\t      real = gen_rtx_MEM (TYPE_MODE (type), addr);\n+\t      set_mem_alias_set (real, get_varargs_alias_set ());\n+\n+\t      result_value = gen_rtx_CONCAT (SCmode, real, imag);\n+\t      /* ??? this interface is stupid - why require a pointer?  */\n+\t      result = gen_reg_rtx (Pmode);\n+\t      slot = assign_stack_temp (SCmode, 8, 0);\n+\t      emit_move_insn (slot, result_value);\n+\t      emit_move_insn (result, XEXP (slot, 0));\n+\t    }\n+#endif /* FUNCTION_ARG_SCmode_WART */\n+\n \t  emit_jump_insn (gen_jump (lab_over));\n \t  emit_barrier ();\n \t  emit_label (lab_false);\n@@ -6060,16 +6105,22 @@ sh_va_arg (valist, type)\n \t    emit_move_insn (addr_rtx, r);\n \t}\n \n-      emit_label (lab_over);\n-\n-      tmp = make_tree (pptr_type_node, addr_rtx);\n-      valist = build1 (INDIRECT_REF, ptr_type_node, tmp);\n+      if (! result)\n+        emit_label (lab_over);\n     }\n \n   /* ??? In va-sh.h, there had been code to make values larger than\n      size 8 indirect.  This does not match the FUNCTION_ARG macros.  */\n \n-  result = std_expand_builtin_va_arg (valist, type);\n+  result_ptr = std_expand_builtin_va_arg (valist, type);\n+  if (result)\n+    {\n+      emit_move_insn (result, result_ptr);\n+      emit_label (lab_over);\n+    }\n+  else\n+    result = result_ptr;\n+\n   if (pass_by_ref)\n     {\n #ifdef POINTERS_EXTEND_UNSIGNED"}, {"sha": "ee49f6b9a795539a852053e81273529bd7ffc314", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1cb95f3fe55d63086401db8e1f427ec22b4ded/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1cb95f3fe55d63086401db8e1f427ec22b4ded/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=6d1cb95f3fe55d63086401db8e1f427ec22b4ded", "patch": "@@ -1867,38 +1867,30 @@ struct sh_args {\n     (CUM).outgoing = 0;\t\t\t\t\t\t\\\n   } while (0)\n  \n-#define OLD_ARG_MODE(MODE, TYPE) \\\n-  (((TYPE) \\\n-    && (TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE (TYPE) == UNION_TYPE) \\\n-    && (MODE) != BLKmode && GET_MODE_CLASS (MODE) != MODE_INT) \\\n-   ? int_mode_for_mode (MODE) : (MODE))\n-\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be\n    available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-do {\t\t\t\t\t\t\t\\\n- enum machine_mode MODE_ = OLD_ARG_MODE ((MODE), (TYPE));\\\n  if ((CUM).force_mem)\t\t\t\t\t\\\n    (CUM).force_mem = 0;\t\t\t\t\t\\\n  else if (TARGET_SH5)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      tree TYPE_ = ((CUM).byref && (TYPE)\t\t\\\n \t\t   ? TREE_TYPE (TYPE)\t\t\t\\\n  \t\t   : (TYPE));\t\t\t\t\\\n-     int dwords, numregs;\t\t\t\t\\\n+     enum machine_mode MODE_ = ((CUM).byref && (TYPE)\t\\\n+\t\t\t\t? TYPE_MODE (TYPE_)\t\\\n+\t\t\t\t: (MODE));\t\t\\\n+     int dwords = (((CUM).byref\t\t\t\t\\\n+\t\t    ? (CUM).byref\t\t\t\\\n+\t\t    : (MODE_) == BLKmode\t\t\\\n+\t\t    ? int_size_in_bytes (TYPE_)\t\t\\\n+\t\t    : GET_MODE_SIZE (MODE_)) + 7) / 8;\t\\\n+     int numregs = MIN (dwords, NPARM_REGS (SImode)\t\\\n+\t\t\t- (CUM).arg_count[(int) SH_ARG_INT]); \\\n \t\t\t\t\t\t\t\\\n-     MODE_ = ((CUM).byref && (TYPE)\t\t\t\\\n-\t      ? TYPE_MODE (TYPE_) : (MODE_));\t\t\\\n-     dwords = (((CUM).byref\t\t\t\t\\\n-\t\t? (CUM).byref\t\t\t\t\\\n-\t\t: (MODE_) == BLKmode\t\t\t\\\n-\t\t? int_size_in_bytes (TYPE_)\t\t\\\n-\t\t: GET_MODE_SIZE (MODE_)) + 7) / 8;\t\\\n-     numregs = MIN (dwords, NPARM_REGS (SImode)\t\t\\\n-\t\t    - (CUM).arg_count[(int) SH_ARG_INT]); \\\n      if (numregs)\t\t\t\t\t\\\n        {\t\t\t\t\t\t\\\n \t (CUM).arg_count[(int) SH_ARG_INT] += numregs;\t\\\n@@ -1990,13 +1982,12 @@ do {\t\t\t\t\t\t\t\\\n \t   }\t\t\t\t\t\t\\\n        }\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\\\n- else if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE_), (TYPE))) \\\n-   ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE_)]\t\\\n-    = (ROUND_REG ((CUM), (MODE_))\t\t\t\\\n-       + ((MODE_) == BLKmode\t\t\t\t\\\n+ else if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE), (TYPE))) \\\n+   ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\\\n+    = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n+       + ((MODE) == BLKmode\t\t\t\t\\\n \t  ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n-\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE_)))));\t\\\n-} while (0)\n+\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))))\n \n /* Return boolean indicating arg of mode MODE will be passed in a reg.\n    This macro is only used in this file.  */\n@@ -2016,6 +2007,24 @@ do {\t\t\t\t\t\t\t\\\n \t     <= NPARM_REGS (MODE))) \\\n        : ROUND_REG ((CUM), (MODE)) < NPARM_REGS (MODE)))\n \n+/* By accident we got stuck with passing SCmode on SH4 little endian\n+   in two registers that are nominally successive - which is different from\n+   two single SFmode values, where we take endianness translation into\n+   account.  That does not work at all if an odd number of registers is\n+   already in use, so that got fixed, but library functions are still more\n+   likely to use complex numbers without mixing them with SFmode arguments\n+   (which in C would have to be structures), so for the sake of ABI\n+   compatibility the way SCmode values are passed when an even number of\n+   FP registers is in use remains different from a pair of SFmode values for\n+   now.\n+   I.e.:\n+   foo (double); a: fr5,fr4\n+   foo (float a, float b); a: fr5 b: fr4\n+   foo (__complex float a); a.real fr4 a.imag: fr5 - for consistency,\n+                            this should be the other way round...\n+   foo (float a, __complex float b); a: fr5 b.real: fr4 b.imag: fr7  */\n+#define FUNCTION_ARG_SCmode_WART 1\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -2035,37 +2044,52 @@ do {\t\t\t\t\t\t\t\\\n    its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  FUNCTION_ARG_1 ((CUM), OLD_ARG_MODE ((MODE), (TYPE)), (MODE), (TYPE), (NAMED))\n-\n-#define FUNCTION_ARG_1(CUM, MODE, NEW_MODE, TYPE, NAMED) \\\n   ((! TARGET_SH5 \\\n     && PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n     && ((NAMED) || !TARGET_HITACHI))\t\t\t\t\t\\\n-   ? gen_rtx_REG ((NEW_MODE),\t\t\t\t\t\t\\\n-\t\t  ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \t\\\n-\t\t   ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n-\t\t      && TARGET_LITTLE_ENDIAN != 0)))\t\t\t\\\n+   ? (((MODE) == SCmode && TARGET_SH4 && TARGET_LITTLE_ENDIAN\t\t\\\n+       && (! FUNCTION_ARG_SCmode_WART || (ROUND_REG ((CUM), (MODE)) & 1)))\\\n+      ? (gen_rtx_PARALLEL\t\t\t\t\t\t\\\n+\t (SCmode,\t\t\t\t\t\t\t\\\n+\t  (gen_rtvec\t\t\t\t\t\t\t\\\n+\t   (2, \t\t\t\t\t\t\t\t\\\n+\t    (gen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n+\t     (VOIDmode,\t\t\t\t\t\t\t\\\n+\t      gen_rtx_REG (SFmode,\t\t\t\t\t\\\n+\t\t\t   BASE_ARG_REG (MODE)\t\t\t\t\\\n+\t\t\t   + ROUND_REG ((CUM), (MODE)) ^ 1),\t\t\\\n+\t      const0_rtx)),\t\t\t\t\t\t\\\n+\t    (gen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n+\t     (VOIDmode,\t\t\t\t\t\t\t\\\n+\t      gen_rtx_REG (SFmode,\t\t\t\t\t\\\n+\t\t\t   BASE_ARG_REG (MODE)\t\t\t\t\\\n+\t\t\t   + (ROUND_REG ((CUM), (MODE)) + 1) ^ 1),\t\\\n+\t      GEN_INT (4)))))))\t\t\t\t\t\t\\\n+      : gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t\t     ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \\\n+\t\t      ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n+\t\t\t && TARGET_LITTLE_ENDIAN != 0))))\t\t\\\n    : TARGET_SH5\t\t\t\t\t\t\t\t\\\n    ? ((MODE) == VOIDmode && TARGET_SHCOMPACT\t\t\t\t\\\n       ? GEN_INT ((CUM).call_cookie)\t\t\t\t\t\\\n       /* The following test assumes unnamed arguments are promoted to\t\\\n \t DFmode.  */\t\t\t\t\t\t\t\\\n       : (MODE) == SFmode && (CUM).free_single_fp_reg\t\t\t\\\n-      ? SH5_PROTOTYPED_FLOAT_ARG ((CUM), (NEW_MODE), (CUM).free_single_fp_reg) \\\n+      ? SH5_PROTOTYPED_FLOAT_ARG ((CUM), (MODE), (CUM).free_single_fp_reg) \\\n       : (GET_SH_ARG_CLASS (MODE) == SH_ARG_FLOAT\t\t\t\\\n          && ((NAMED) || ! (CUM).prototype_p)\t\t\t\t\\\n          && (CUM).arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (SFmode))\t\\\n       ? ((! (CUM).prototype_p && TARGET_SHMEDIA)\t\t\t\\\n-\t ? SH5_PROTOTYPELESS_FLOAT_ARG ((CUM), (NEW_MODE))\t\t\\\n-\t : SH5_PROTOTYPED_FLOAT_ARG ((CUM), (NEW_MODE),\t\t\t\\\n+\t ? SH5_PROTOTYPELESS_FLOAT_ARG ((CUM), (MODE))\t\t\t\\\n+\t : SH5_PROTOTYPED_FLOAT_ARG ((CUM), (MODE),\t\t\t\\\n \t\t\t\t     FIRST_FP_PARM_REG\t\t\t\\\n \t\t\t\t     + (CUM).arg_count[(int) SH_ARG_FLOAT])) \\\n       : ((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\t\\\n \t && (! TARGET_SHCOMPACT\t\t\t\t\t\t\\\n \t     || (! SHCOMPACT_FORCE_ON_STACK ((MODE), (TYPE))\t\t\\\n \t         && ! SH5_WOULD_BE_PARTIAL_NREGS ((CUM), (MODE),\t\\\n \t\t\t\t\t\t  (TYPE), (NAMED)))))\t\\\n-      ? gen_rtx_REG ((NEW_MODE), (FIRST_PARM_REG\t\t\t\\\n+      ? gen_rtx_REG ((MODE), (FIRST_PARM_REG\t\t\t\t\\\n  \t\t\t      + (CUM).arg_count[(int) SH_ARG_INT]))\t\\\n       : 0)\t\t\t\t\t\t\t\t\\\n    : 0)\n@@ -2076,7 +2100,7 @@ do {\t\t\t\t\t\t\t\\\n    loads them into the full 64-bits registers.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED) \\\n   (MUST_PASS_IN_STACK ((MODE), (TYPE)) \\\n-   || SHCOMPACT_BYREF ((CUM), OLD_ARG_MODE ((MODE), (TYPE)), (TYPE), (NAMED)))\n+   || SHCOMPACT_BYREF ((CUM), (MODE), (TYPE), (NAMED)))\n \n #define SHCOMPACT_BYREF(CUM, MODE, TYPE, NAMED) \\\n   ((CUM).byref\t\t\t\t\t\t\t\t\\"}]}