{"sha": "45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkZmJlNzdkMjdlZDQyMmQxYjZlZDkzZjA1M2Q3ZDIzYTZkNjFhNQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-10-15T01:33:16Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-10-15T01:33:16Z"}, "message": "re PR libfortran/33672 (Additional runtime checks needed for namelist reads)\n\n2007-10-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/33672\n\t* io/list_read.c (nml_parse_qualifier): Add character specific error\n\tmessages.  Check for proper form of sub-string qualifiers.  Return the\n\tparsed_rank flag indicating a non-zero rank qualifier.\n\t(nml_get_obj_data):  Count the instances of non-zero rank qualifiers.\n\tIssue an error if more that one non-zero rank qualifier is found.\n\nFrom-SVN: r129309", "tree": {"sha": "a736aec2c5b1306ead15cd926c196c3c25cb0029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a736aec2c5b1306ead15cd926c196c3c25cb0029"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5/comments", "author": null, "committer": null, "parents": [{"sha": "422e566461acda13f97e45d34346935e215cd0ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422e566461acda13f97e45d34346935e215cd0ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422e566461acda13f97e45d34346935e215cd0ac"}], "stats": {"total": 105, "additions": 83, "deletions": 22}, "files": [{"sha": "2b9e67e4b4e1e4f1ff9a8a2242498965e1703872", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5", "patch": "@@ -1,3 +1,12 @@\n+2007-10-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/33672\n+\t* io/list_read.c (nml_parse_qualifier): Add character specific error\n+\tmessages.  Check for proper form of sub-string qualifiers.  Return the\n+\tparsed_rank flag indicating a non-zero rank qualifier.\n+\t(nml_get_obj_data):  Count the instances of non-zero rank qualifiers.\n+\tIssue an error if more that one non-zero rank qualifier is found.\n+\n 2007-10-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/33253"}, {"sha": "96cef54e7afb6fbbbf248a427226d695e43d6fb6", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 74, "deletions": 22, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=45dfbe77d27ed422d1b6ed93f053d7d23a6d61a5", "patch": "@@ -1713,18 +1713,27 @@ void namelist_read (st_parameter_dt *dtp)\n \n static try\n nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n-\t\t     array_loop_spec *ls, int rank, char *parse_err_msg)\n+\t\t     array_loop_spec *ls, int rank, char *parse_err_msg,\n+\t\t     int *parsed_rank)\n {\n   int dim;\n   int indx;\n   int neg;\n   int null_flag;\n-  int is_array_section;\n+  int is_array_section, is_char;\n   char c;\n \n+  is_char = 0;\n   is_array_section = 0;\n   dtp->u.p.expanded_read = 0;\n \n+  /* See if this is a character substring qualifier we are looking for.  */\n+  if (rank == -1)\n+    {\n+      rank = 1;\n+      is_char = 1;\n+    }\n+\n   /* The next character in the stream should be the '('.  */\n \n   c = next_char (dtp);\n@@ -1770,8 +1779,10 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t  if ((c==',' && dim == rank -1)\n \t\t      || (c==')' && dim < rank -1))\n \t\t    {\n-\t\t      sprintf (parse_err_msg,\n-\t\t\t       \"Bad number of index fields\");\n+\t\t      if (is_char)\n+\t\t        sprintf (parse_err_msg, \"Bad substring qualifier\");\n+\t\t      else\n+\t\t\tsprintf (parse_err_msg, \"Bad number of index fields\");\n \t\t      goto err_ret;\n \t\t    }\n \t\t  break;\n@@ -1786,21 +1797,38 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t  break;\n \n \t\tdefault:\n-\t\t  sprintf (parse_err_msg, \"Bad character in index\");\n+\t\t  if (is_char)\n+\t\t    sprintf (parse_err_msg,\n+\t\t\t     \"Bad character in substring qualifier\");\n+\t\t  else\n+\t\t    sprintf (parse_err_msg, \"Bad character in index\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      if ((c == ',' || c == ')') && indx == 0\n \t\t  && dtp->u.p.saved_string == 0)\n \t\t{\n-\t\t  sprintf (parse_err_msg, \"Null index field\");\n+\t\t  if (is_char)\n+\t\t    sprintf (parse_err_msg, \"Null substring qualifier\");\n+\t\t  else\n+\t\t    sprintf (parse_err_msg, \"Null index field\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      if ((c == ':' && indx == 1 && dtp->u.p.saved_string == 0)\n \t\t  || (indx == 2 && dtp->u.p.saved_string == 0))\n \t\t{\n-\t\t  sprintf(parse_err_msg, \"Bad index triplet\");\n+\t\t  if (is_char)\n+\t\t    sprintf (parse_err_msg, \"Bad substring qualifier\");\n+\t\t  else\n+\t\t    sprintf (parse_err_msg, \"Bad index triplet\");\n+\t\t  goto err_ret;\n+\t\t}\n+\n+\t      if (is_char && !is_array_section)\n+\t\t{\n+\t\t  sprintf (parse_err_msg,\n+\t\t\t   \"Missing colon in substring qualifier\");\n \t\t  goto err_ret;\n \t\t}\n \n@@ -1816,7 +1844,10 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t      /* Now read the index.  */\n \t      if (convert_integer (dtp, sizeof(ssize_t), neg))\n \t\t{\n-\t\t  sprintf (parse_err_msg, \"Bad integer in index\");\n+\t\t  if (is_char)\n+\t\t    sprintf (parse_err_msg, \"Bad integer substring qualifier\");\n+\t\t  else\n+\t\t    sprintf (parse_err_msg, \"Bad integer in index\");\n \t\t  goto err_ret;\n \t\t}\n \t      break;\n@@ -1848,6 +1879,11 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t  else\n \t\t    dtp->u.p.expanded_read = 1;\n \t\t}\n+\n+\t      /* Check for non-zero rank.  */\n+\t      if (is_array_section == 1 && ls[dim].start != ls[dim].end)\n+\t\t*parsed_rank = 1;\n+\n \t      break;\n \t    }\n \t}\n@@ -1858,9 +1894,13 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t  || (ls[dim].end > (ssize_t)ad[dim].ubound)\n \t  || (ls[dim].end < (ssize_t)ad[dim].lbound))\n \t{\n-\t  sprintf (parse_err_msg, \"Index %d out of range\", dim + 1);\n+\t  if (is_char)\n+\t    sprintf (parse_err_msg, \"Substring out of range\");\n+\t  else\n+\t    sprintf (parse_err_msg, \"Index %d out of range\", dim + 1);\n \t  goto err_ret;\n \t}\n+\n       if (((ls[dim].end - ls[dim].start ) * ls[dim].step < 0)\n \t  || (ls[dim].step == 0))\n \t{\n@@ -1995,7 +2035,6 @@ nml_query (st_parameter_dt *dtp, char c)\n \n       else\n \t{\n-\n \t  /* \"&namelist_name\\n\"  */\n \n \t  len = dtp->namelist_name_len;\n@@ -2015,7 +2054,6 @@ nml_query (st_parameter_dt *dtp, char c)\n #endif\n \t  for (nl = dtp->u.p.ionml; nl; nl = nl->next)\n \t    {\n-\n \t      /* \" var_name\\n\"  */\n \n \t      len = strlen (nl->var_name);\n@@ -2081,7 +2119,6 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t      namelist_info **pprev_nl, char *nml_err_msg,\n \t      index_type clow, index_type chigh)\n {\n-\n   namelist_info * cmp;\n   char * obj_name;\n   int nml_carry;\n@@ -2103,7 +2140,6 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n   len = nl->len;\n   switch (nl->type)\n   {\n-\n     case GFC_DTYPE_INTEGER:\n     case GFC_DTYPE_LOGICAL:\n       dlen = len;\n@@ -2127,7 +2163,6 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \n   do\n     {\n-\n       /* Update the pointer to the data, using the current index vector  */\n \n       pdata = (void*)(nl->mem_pos + offset);\n@@ -2333,10 +2368,11 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n   namelist_info * nl;\n   namelist_info * first_nl = NULL;\n   namelist_info * root_nl = NULL;\n-  int dim;\n+  int dim, parsed_rank;\n   int component_flag;\n   char parse_err_msg[30];\n   index_type clow, chigh;\n+  int non_zero_rank_count;\n \n   /* Look for end of input or object name.  If '?' or '=?' are encountered\n      in stdin, print the node names or the namelist to stdout.  */\n@@ -2388,6 +2424,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n   nml_untouch_nodes (dtp);\n   component_flag = 0;\n+  non_zero_rank_count = 0;\n \n   /* Get the object name - should '!' and '\\n' be permitted separators?  */\n \n@@ -2456,24 +2493,30 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n   if (c == '(' && nl->var_rank)\n     {\n+      parsed_rank = 0;\n       if (nml_parse_qualifier (dtp, nl->dim, nl->ls, nl->var_rank,\n-\t\t\t       parse_err_msg) == FAILURE)\n+\t\t\t       parse_err_msg, &parsed_rank) == FAILURE)\n \t{\n \t  sprintf (nml_err_msg, \"%s for namelist variable %s\",\n \t\t      parse_err_msg, nl->var_name);\n \t  goto nml_err_ret;\n \t}\n+\n+      if (parsed_rank > 0)\n+\tnon_zero_rank_count++;\n+\n       c = next_char (dtp);\n       unget_char (dtp, c);\n     }\n+  else if (nl->var_rank > 0)\n+    non_zero_rank_count++;\n \n   /* Now parse a derived type component. The root namelist_info address\n      is backed up, as is the previous component level.  The  component flag\n      is set and the iteration is made by jumping back to get_name.  */\n \n   if (c == '%')\n     {\n-\n       if (nl->type != GFC_DTYPE_DERIVED)\n \t{\n \t  sprintf (nml_err_msg, \"Attempt to get derived component for %s\",\n@@ -2488,7 +2531,6 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       component_flag = 1;\n       c = next_char (dtp);\n       goto get_name;\n-\n     }\n \n   /* Parse a character qualifier, if present.  chigh = 0 is a default\n@@ -2502,7 +2544,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       descriptor_dimension chd[1] = { {1, clow, nl->string_length} };\n       array_loop_spec ind[1] = { {1, clow, nl->string_length, 1} };\n \n-      if (nml_parse_qualifier (dtp, chd, ind, 1, parse_err_msg) == FAILURE)\n+      if (nml_parse_qualifier (dtp, chd, ind, -1, parse_err_msg, &parsed_rank)\n+\t  == FAILURE)\n \t{\n \t  sprintf (nml_err_msg, \"%s for namelist variable %s\",\n \t\t      parse_err_msg, nl->var_name);\n@@ -2515,8 +2558,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       if (ind[0].step != 1)\n \t{\n \t  sprintf (nml_err_msg,\n-\t\t      \"Bad step in substring for namelist object %s\",\n-\t\t      nl->var_name);\n+\t\t   \"Step not allowed in substring qualifier\"\n+\t\t   \" for namelist object %s\", nl->var_name);\n \t  goto nml_err_ret;\n \t}\n \n@@ -2533,7 +2576,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n   if (component_flag)\n     nl = first_nl;\n \n-  /*make sure no extraneous qualifiers are there.*/\n+  /* Make sure no extraneous qualifiers are there.  */\n \n   if (c == '(')\n     {\n@@ -2542,6 +2585,15 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       goto nml_err_ret;\n     }\n \n+  /* Make sure there is no more than one non-zero rank object.  */\n+  if (non_zero_rank_count > 1)\n+    {\n+      sprintf (nml_err_msg, \"Multiple sub-objects with non-zero rank in\"\n+\t       \" namelist object %s\", nl->var_name);\n+      non_zero_rank_count = 0;\n+      goto nml_err_ret;\n+    }\n+\n /* According to the standard, an equal sign MUST follow an object name. The\n    following is possibly lax - it allows comments, blank lines and so on to\n    intervene.  eat_spaces (dtp); c = next_char (dtp); would be compliant*/"}]}