{"sha": "7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M0YjQ4MGZiMzczNmZkMmE5ZjRmYmFkMjczZGJhZmUwNDY0OWMxMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T08:46:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T08:46:08Z"}, "message": "[multiple changes]\n\n2010-06-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_util.adb, sem_util.ads: Minor reformatting.\n\n2010-06-23  Vincent Celier  <celier@adacore.com>\n\n\t* prj.ads (Gprclean_Flags.Missing_Source_Files): Set to Error to keep\n\tthe previous behavior of gprclean when there are missing files.\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Load_Body_Of_Generic): In CodePeer mode, a missing\n\tgeneric body is not a fatal error.\n\t(Mark_Context): Handle properly names of child units.\n\t* sem.adb (Walk_Library_Items.Do_Action): Remove assertion on\n\tinstantiations.\n\n2010-06-23  Vincent Celier  <celier@adacore.com>\n\n\t* ali.adb (Scan_ALI): When ignoring R lines, do not skip the next\n\tnon-empty line.\n\n2010-06-23  Bob Duff  <duff@adacore.com>\n\n\t* g-pehage.ads, g-pehage.adb: Switch default optimization mode to\n\tMemory_Space, because CPU_Time doesn't seem to provide any significant\n\tspeed advantage in practice. Cleanup: Get rid of constant\n\tDefault_Optimization; doesn't seem to add anything. Use case\n\tstatements instead of if statements; seems cleaner.\n\nFrom-SVN: r161259", "tree": {"sha": "133edf7db0b7358ff43b599d5a6a541f92fce9f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/133edf7db0b7358ff43b599d5a6a541f92fce9f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/comments", "author": null, "committer": null, "parents": [{"sha": "bb511fbd86c7a1109f71551cc0e7d1cfd733c016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb511fbd86c7a1109f71551cc0e7d1cfd733c016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb511fbd86c7a1109f71551cc0e7d1cfd733c016"}], "stats": {"total": 560, "additions": 309, "deletions": 251}, "files": [{"sha": "acdcbd5d8668dabcf43e9c7bfa9e4ffb0de18ae9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -1,3 +1,33 @@\n+2010-06-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_util.adb, sem_util.ads: Minor reformatting.\n+\n+2010-06-23  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj.ads (Gprclean_Flags.Missing_Source_Files): Set to Error to keep\n+\tthe previous behavior of gprclean when there are missing files.\n+\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Load_Body_Of_Generic): In CodePeer mode, a missing\n+\tgeneric body is not a fatal error.\n+\t(Mark_Context): Handle properly names of child units.\n+\t* sem.adb (Walk_Library_Items.Do_Action): Remove assertion on\n+\tinstantiations.\n+\n+2010-06-23  Vincent Celier  <celier@adacore.com>\n+\n+\t* ali.adb (Scan_ALI): When ignoring R lines, do not skip the next\n+\tnon-empty line.\n+\n+2010-06-23  Bob Duff  <duff@adacore.com>\n+\n+\t* g-pehage.ads, g-pehage.adb: Switch default optimization mode to\n+\tMemory_Space, because CPU_Time doesn't seem to provide any significant\n+\tspeed advantage in practice. Cleanup: Get rid of constant\n+\tDefault_Optimization; doesn't seem to add anything. Use case\n+\tstatements instead of if statements; seems cleaner.\n+\n 2010-06-23  Olivier Hainque  <hainque@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <case E_Procedure>: Use"}, {"sha": "eb45dcaca504d054396e9b3bb60dc3c1093d3b80", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1295,9 +1295,9 @@ package body ALI is\n          else\n             Skip_Space;\n             No_Deps.Append ((Id, Get_Name));\n+            Skip_Eol;\n          end if;\n \n-         Skip_Eol;\n          C := Getc;\n       end loop;\n "}, {"sha": "b59e1ecec98bdf3a9bf3813c7b7dbaa6ca64de89", "filename": "gcc/ada/g-pehage.adb", "status": "modified", "additions": 59, "deletions": 54, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.adb?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -1176,7 +1176,7 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Initialize\n      (Seed   : Natural;\n       K_To_V : Float        := Default_K_To_V;\n-      Optim  : Optimization := CPU_Time;\n+      Optim  : Optimization := Memory_Space;\n       Tries  : Positive     := Default_Tries)\n    is\n    begin\n@@ -1596,39 +1596,41 @@ package body GNAT.Perfect_Hash_Generators is\n \n       New_Line (File);\n \n-      if Opt = CPU_Time then\n-         Put_Int_Matrix\n-           (File,\n-            Array_Img (\"T1\", Type_Img (NV),\n-                       Range_Img (0, T1_Len - 1),\n-                       Range_Img (0, T2_Len - 1, Type_Img (256))),\n-            T1, T1_Len, T2_Len);\n-\n-      else\n-         Put_Int_Matrix\n-           (File,\n-            Array_Img (\"T1\", Type_Img (NV),\n-                       Range_Img (0, T1_Len - 1)),\n-            T1, T1_Len, 0);\n-      end if;\n+      case Opt is\n+         when CPU_Time =>\n+            Put_Int_Matrix\n+              (File,\n+               Array_Img (\"T1\", Type_Img (NV),\n+                          Range_Img (0, T1_Len - 1),\n+                          Range_Img (0, T2_Len - 1, Type_Img (256))),\n+               T1, T1_Len, T2_Len);\n+\n+         when Memory_Space =>\n+            Put_Int_Matrix\n+              (File,\n+               Array_Img (\"T1\", Type_Img (NV),\n+                          Range_Img (0, T1_Len - 1)),\n+               T1, T1_Len, 0);\n+      end case;\n \n       New_Line (File);\n \n-      if Opt = CPU_Time then\n-         Put_Int_Matrix\n-           (File,\n-            Array_Img (\"T2\", Type_Img (NV),\n-                       Range_Img (0, T1_Len - 1),\n-                       Range_Img (0, T2_Len - 1, Type_Img (256))),\n-            T2, T1_Len, T2_Len);\n-\n-      else\n-         Put_Int_Matrix\n-           (File,\n-            Array_Img (\"T2\", Type_Img (NV),\n-                       Range_Img (0, T1_Len - 1)),\n-            T2, T1_Len, 0);\n-      end if;\n+      case Opt is\n+         when CPU_Time =>\n+            Put_Int_Matrix\n+              (File,\n+               Array_Img (\"T2\", Type_Img (NV),\n+                          Range_Img (0, T1_Len - 1),\n+                          Range_Img (0, T2_Len - 1, Type_Img (256))),\n+               T2, T1_Len, T2_Len);\n+\n+         when Memory_Space =>\n+            Put_Int_Matrix\n+              (File,\n+               Array_Img (\"T2\", Type_Img (NV),\n+                          Range_Img (0, T1_Len - 1)),\n+               T2, T1_Len, 0);\n+      end case;\n \n       New_Line (File);\n \n@@ -1650,11 +1652,12 @@ package body GNAT.Perfect_Hash_Generators is\n \n       Put (File, \"      J : \");\n \n-      if Opt = CPU_Time then\n-         Put (File, Type_Img (256));\n-      else\n-         Put (File, \"Natural\");\n-      end if;\n+      case Opt is\n+         when CPU_Time =>\n+            Put (File, Type_Img (256));\n+         when Memory_Space =>\n+            Put (File, \"Natural\");\n+      end case;\n \n       Put (File, \";\");\n       New_Line (File);\n@@ -1667,11 +1670,12 @@ package body GNAT.Perfect_Hash_Generators is\n       New_Line (File);\n       Put      (File, \"         J  := \");\n \n-      if Opt = CPU_Time then\n-         Put (File, \"C\");\n-      else\n-         Put (File, \"Character'Pos\");\n-      end if;\n+      case Opt is\n+         when CPU_Time =>\n+            Put (File, \"C\");\n+         when Memory_Space =>\n+            Put (File, \"Character'Pos\");\n+      end case;\n \n       Put      (File, \" (S (P (K) + F));\");\n       New_Line (File);\n@@ -2490,20 +2494,21 @@ package body GNAT.Perfect_Hash_Generators is\n       R : Natural;\n \n    begin\n-      if Opt = CPU_Time then\n-         for J in 0 .. T1_Len - 1 loop\n-            exit when Word (J + 1) = ASCII.NUL;\n-            R := Get_Table (Table, J, Get_Used_Char (Word (J + 1)));\n-            S := (S + R) mod NV;\n-         end loop;\n+      case Opt is\n+         when CPU_Time =>\n+            for J in 0 .. T1_Len - 1 loop\n+               exit when Word (J + 1) = ASCII.NUL;\n+               R := Get_Table (Table, J, Get_Used_Char (Word (J + 1)));\n+               S := (S + R) mod NV;\n+            end loop;\n \n-      else\n-         for J in 0 .. T1_Len - 1 loop\n-            exit when Word (J + 1) = ASCII.NUL;\n-            R := Get_Table (Table, J, 0);\n-            S := (S + R * Character'Pos (Word (J + 1))) mod NV;\n-         end loop;\n-      end if;\n+         when Memory_Space =>\n+            for J in 0 .. T1_Len - 1 loop\n+               exit when Word (J + 1) = ASCII.NUL;\n+               R := Get_Table (Table, J, 0);\n+               S := (S + R * Character'Pos (Word (J + 1))) mod NV;\n+            end loop;\n+      end case;\n \n       return S;\n    end Sum;"}, {"sha": "dfe926ef78277ea0131aa7d285e6834a4d644fc2", "filename": "gcc/ada/g-pehage.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fg-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fg-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.ads?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -86,8 +86,9 @@ package GNAT.Perfect_Hash_Generators is\n    --  number of tries.\n \n    type Optimization is (Memory_Space, CPU_Time);\n-   Default_Optimization : constant Optimization := CPU_Time;\n-   --  Optimize either the memory space or the execution time\n+   --  Optimize either the memory space or the execution time. Note: in\n+   --  practice, the optimization mode has little effect on speed. The tables\n+   --  are somewhat smaller with Memory_Space.\n \n    Verbose : Boolean := False;\n    --  Output the status of the algorithm. For instance, the tables, the random\n@@ -97,7 +98,7 @@ package GNAT.Perfect_Hash_Generators is\n    procedure Initialize\n      (Seed   : Natural;\n       K_To_V : Float        := Default_K_To_V;\n-      Optim  : Optimization := CPU_Time;\n+      Optim  : Optimization := Memory_Space;\n       Tries  : Positive     := Default_Tries);\n    --  Initialize the generator and its internal structures. Set the ratio of\n    --  vertices over keys in the random graphs. This value has to be greater"}, {"sha": "a6a79646a530120f36975dd7408052c1c0601de2", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -1630,7 +1630,7 @@ private\n       Error_On_Unknown_Language  => True,\n       Require_Obj_Dirs           => Warning,\n       Allow_Invalid_External     => Error,\n-      Missing_Source_Files       => Warning);\n+      Missing_Source_Files       => Error);\n \n    Gnatmake_Flags : constant Processing_Flags :=\n      (Report_Error               => null,"}, {"sha": "ce6887ef21a2a5e79bdf35a76d8f61d53623e5f3", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -1589,22 +1589,25 @@ package body Sem is\n \n                null;\n \n-            when  N_Subprogram_Body =>\n+            when N_Subprogram_Body =>\n \n                --  A subprogram body must be the main unit\n \n                pragma Assert (Acts_As_Spec (CU)\n                                or else CU = Cunit (Main_Unit));\n                null;\n \n-            --  All other cases cannot happen\n-\n             when N_Function_Instantiation  |\n                  N_Procedure_Instantiation |\n                  N_Package_Instantiation   =>\n-               pragma Assert (False, \"instantiation\");\n+\n+               --  Can only happen if some generic body (needed for gnat2scil\n+               --  traversal, but not by GNAT) is not available, ignore.\n+\n                null;\n \n+            --  All other cases cannot happen\n+\n             when N_Subunit =>\n                pragma Assert (False, \"subunit\");\n                null;"}, {"sha": "a50094d7e37640efe98db6ab160bf892f2e179ec", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -8748,11 +8748,16 @@ package body Sem_Ch12 is\n       --  If we have no body, and the unit requires a body, then complain. This\n       --  complaint is suppressed if we have detected other errors (since a\n       --  common reason for missing the body is that it had errors).\n+      --  In CodePeer mode, a warning has been emitted already, no need for\n+      --  further messages.\n \n       elsif Unit_Requires_Body (Gen_Unit)\n         and then not Body_Optional\n       then\n-         if Serious_Errors_Detected = 0 then\n+         if CodePeer_Mode then\n+            null;\n+\n+         elsif Serious_Errors_Detected = 0 then\n             Error_Msg_NE\n               (\"cannot find body of generic package &\", Inst_Node, Gen_Unit);\n \n@@ -10451,7 +10456,9 @@ package body Sem_Ch12 is\n       loop\n          Mark_Context\n            (Inst_Decl,\n-            Unit_Declaration_Node (Generic_Parent (Parent (Scop))));\n+            Unit_Declaration_Node\n+              (Generic_Parent\n+                 (Specification (Unit_Declaration_Node (Scop)))));\n          Scop := Scope (Scop);\n       end loop;\n \n@@ -10857,11 +10864,20 @@ package body Sem_Ch12 is\n                             Get_Body_Name (Get_Unit_Name (Unit (Comp_Unit)));\n \n                begin\n-                  Error_Msg_Unit_1 := Bname;\n-                  Error_Msg_N (\"this instantiation requires$!\", N);\n-                  Error_Msg_File_1 := Get_File_Name (Bname, Subunit => False);\n-                  Error_Msg_N (\"\\but file{ was not found!\", N);\n-                  raise Unrecoverable_Error;\n+                  --  In CodePeer mode, the missing body may make the\n+                  --  analysis incomplete, but we do not treat it as fatal.\n+\n+                  if CodePeer_Mode then\n+                     return;\n+\n+                  else\n+                     Error_Msg_Unit_1 := Bname;\n+                     Error_Msg_N (\"this instantiation requires$!\", N);\n+                     Error_Msg_File_1\n+                       := Get_File_Name (Bname, Subunit => False);\n+                     Error_Msg_N (\"\\but file{ was not found!\", N);\n+                     raise Unrecoverable_Error;\n+                  end if;\n                end;\n             end if;\n          end if;"}, {"sha": "640e4ee86d8c3661899924a135e8436947df001c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 79, "deletions": 68, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -63,6 +63,7 @@ with Ttypes;   use Ttypes;\n with Uname;    use Uname;\n \n with GNAT.HTable; use GNAT.HTable;\n+\n package body Sem_Util is\n \n    ----------------------------------------\n@@ -94,19 +95,20 @@ package body Sem_Util is\n    subtype NCT_Header_Num is Int range 0 .. 511;\n    --  Defines range of headers in hash tables (512 headers)\n \n-   -----------------------------------\n-   -- Order dependence : AI05-0144  --\n-   -----------------------------------\n+   ----------------------------------\n+   -- Order Dependence (AI05-0144) --\n+   ----------------------------------\n \n-   --  Each actual in a call is entered into the table below. A flag\n-   --  indicates whether the corresponding formal is out or in out.\n-   --  Each top-level call (procedure call, condition, assignment)\n-   --  examines all the actuals for a possible order dependence.\n-   --  The table is reset after each such check.\n+   --  Each actual in a call is entered into the table below. A flag indicates\n+   --  whether the corresponding formal is OUT or IN OUT. Each top-level call\n+   --  (procedure call, condition, assignment) examines all the actuals for a\n+   --  possible order dependence. The table is reset after each such check.\n \n    type Actual_Name is record\n-      Act  : Node_Id;\n+      Act         : Node_Id;\n       Is_Writable : Boolean;\n+      --  Comments needed???\n+\n    end record;\n \n    package Actuals_In_Call is new Table.Table (\n@@ -117,65 +119,6 @@ package body Sem_Util is\n       Table_Increment      => 10,\n       Table_Name           => \"Actuals\");\n \n-   procedure Save_Actual (N : Node_Id;  Writable : Boolean := False) is\n-   begin\n-      if Is_Entity_Name (N)\n-        or else Nkind_In (N,\n-                          N_Indexed_Component, N_Selected_Component, N_Slice)\n-        or else (Nkind (N) = N_Attribute_Reference\n-          and then Attribute_Name (N) = Name_Access)\n-\n-      then\n-         --  We are only interested in in out parameters of inner calls.\n-\n-         if not Writable\n-           or else Nkind (Parent (N)) = N_Function_Call\n-           or else Nkind (Parent (N)) in N_Op\n-         then\n-            Actuals_In_Call.Increment_Last;\n-            Actuals_In_Call.Table (Actuals_In_Call.Last) := (N, Writable);\n-         end if;\n-      end if;\n-   end Save_Actual;\n-\n-   procedure Check_Order_Dependence is\n-      Act1, Act2 : Node_Id;\n-   begin\n-      for J in 0 .. Actuals_In_Call.Last loop\n-\n-         if Actuals_In_Call.Table (J).Is_Writable then\n-            Act1 := Actuals_In_Call.Table (J).Act;\n-\n-            if Nkind (Act1) = N_Attribute_Reference then\n-               Act1 := Prefix (Act1);\n-            end if;\n-\n-            for K in 0 .. Actuals_In_Call.Last loop\n-               if K /= J then\n-                  Act2 := Actuals_In_Call.Table (K).Act;\n-                  if Nkind (Act2) = N_Attribute_Reference then\n-                     Act2 := Prefix (Act2);\n-                  end if;\n-\n-                  if Actuals_In_Call.Table (K).Is_Writable\n-                    and then K < J\n-                  then\n-                     --  already checked\n-                     null;\n-\n-                  elsif Denotes_Same_Object (Act1, Act2)\n-                    and then False\n-                  then\n-                     Error_Msg_N (\"?,mighty suspicious!!!\", Act1);\n-                  end if;\n-               end if;\n-            end loop;\n-         end if;\n-      end loop;\n-\n-      Actuals_In_Call.Set_Last (0);\n-   end Check_Order_Dependence;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -1226,6 +1169,48 @@ package body Sem_Util is\n       end if;\n    end Check_Nested_Access;\n \n+   ----------------------------\n+   -- Check_Order_Dependence --\n+   ----------------------------\n+\n+   procedure Check_Order_Dependence is\n+      Act1, Act2 : Node_Id;\n+   begin\n+      for J in 0 .. Actuals_In_Call.Last loop\n+         if Actuals_In_Call.Table (J).Is_Writable then\n+            Act1 := Actuals_In_Call.Table (J).Act;\n+\n+            if Nkind (Act1) = N_Attribute_Reference then\n+               Act1 := Prefix (Act1);\n+            end if;\n+\n+            for K in 0 .. Actuals_In_Call.Last loop\n+               if K /= J then\n+                  Act2 := Actuals_In_Call.Table (K).Act;\n+                  if Nkind (Act2) = N_Attribute_Reference then\n+                     Act2 := Prefix (Act2);\n+                  end if;\n+\n+                  if Actuals_In_Call.Table (K).Is_Writable\n+                    and then K < J\n+                  then\n+                     --  Already checked\n+\n+                     null;\n+\n+                  elsif Denotes_Same_Object (Act1, Act2)\n+                    and then False\n+                  then\n+                     Error_Msg_N (\"?,mighty suspicious!!!\", Act1);\n+                  end if;\n+               end if;\n+            end loop;\n+         end if;\n+      end loop;\n+\n+      Actuals_In_Call.Set_Last (0);\n+   end Check_Order_Dependence;\n+\n    ------------------------------------------\n    -- Check_Potentially_Blocking_Operation --\n    ------------------------------------------\n@@ -10583,6 +10568,32 @@ package body Sem_Util is\n       end if;\n    end Same_Value;\n \n+   -----------------\n+   -- Save_Actual --\n+   -----------------\n+\n+   procedure Save_Actual (N : Node_Id;  Writable : Boolean := False) is\n+   begin\n+      if Is_Entity_Name (N)\n+           or else\n+         Nkind_In (N, N_Indexed_Component, N_Selected_Component, N_Slice)\n+           or else\n+             (Nkind (N) = N_Attribute_Reference\n+                and then Attribute_Name (N) = Name_Access)\n+\n+      then\n+         --  We are only interested in IN OUT parameters of inner calls\n+\n+         if not Writable\n+           or else Nkind (Parent (N)) = N_Function_Call\n+           or else Nkind (Parent (N)) in N_Op\n+         then\n+            Actuals_In_Call.Increment_Last;\n+            Actuals_In_Call.Table (Actuals_In_Call.Last) := (N, Writable);\n+         end if;\n+      end if;\n+   end Save_Actual;\n+\n    ------------------------\n    -- Scope_Is_Transient --\n    ------------------------"}, {"sha": "54878f326a17a0854f30064fa208ca102334a1ab", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 104, "deletions": 112, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4b480fb3736fd2a9f4fbad273dbafe04649c11/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7c4b480fb3736fd2a9f4fbad273dbafe04649c11", "patch": "@@ -132,9 +132,9 @@ package Sem_Util is\n    --  Check wrong use of dynamically tagged expression\n \n    procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id);\n-   --  Verify that the full declaration of type T has been seen. If not,\n-   --  place error message on node N. Used in  object declarations, type\n-   --  conversions, qualified expressions.\n+   --  Verify that the full declaration of type T has been seen. If not, place\n+   --  error message on node N. Used in object declarations, type conversions\n+   --  and qualified expressions.\n \n    procedure Check_Nested_Access (Ent : Entity_Id);\n    --  Check whether Ent denotes an entity declared in an uplevel scope, which\n@@ -158,10 +158,10 @@ package Sem_Util is\n    --  a possible unlocked access to data.\n \n    procedure Check_VMS (Construct : Node_Id);\n-   --  Check that this the target is OpenVMS, and if so, return with\n-   --  no effect, otherwise post an error noting this can only be used\n-   --  with OpenVMS ports. The argument is the construct in question\n-   --  and is used to post the error message.\n+   --  Check that this the target is OpenVMS, and if so, return with no effect,\n+   --  otherwise post an error noting this can only be used with OpenVMS ports.\n+   --  The argument is the construct in question and is used to post the error\n+   --  message.\n \n    procedure Collect_Interfaces\n      (T               : Entity_Id;\n@@ -192,10 +192,10 @@ package Sem_Util is\n    --  information on the same interface type.\n \n    function Collect_Primitive_Operations (T : Entity_Id) return Elist_Id;\n-   --  Called upon type derivation and extension. We scan the declarative\n-   --  part in  which the type appears, and collect subprograms that have\n-   --  one subsidiary subtype of the type. These subprograms can only\n-   --  appear after the type itself.\n+   --  Called upon type derivation and extension. We scan the declarative part\n+   --  in which the type appears, and collect subprograms that have one\n+   --  subsidiary subtype of the type. These subprograms can only appear after\n+   --  the type itself.\n \n    function Compile_Time_Constraint_Error\n      (N    : Node_Id;\n@@ -207,12 +207,11 @@ package Sem_Util is\n    --  generates a warning (or error) message in the same manner, but it does\n    --  not replace any nodes. For convenience, the function always returns its\n    --  first argument. The message is a warning if the message ends with ?, or\n-   --  we are operating in Ada 83 mode, or if the Warn parameter is set to\n-   --  True.\n+   --  we are operating in Ada 83 mode, or the Warn parameter is set to True.\n \n    procedure Conditional_Delay (New_Ent, Old_Ent : Entity_Id);\n-   --  Sets the Has_Delayed_Freeze flag of New if the Delayed_Freeze flag\n-   --  of Old is set and Old has no yet been Frozen (i.e. Is_Frozen is false);\n+   --  Sets the Has_Delayed_Freeze flag of New if the Delayed_Freeze flag of\n+   --  Old is set and Old has no yet been Frozen (i.e. Is_Frozen is false).\n \n    function Copy_Parameter_List (Subp_Id : Entity_Id) return List_Id;\n    --  Utility to create a parameter profile for a new subprogram spec, when\n@@ -241,21 +240,20 @@ package Sem_Util is\n    --  from a library package which is not within any subprogram.\n \n    function Defining_Entity (N : Node_Id) return Entity_Id;\n-   --  Given a declaration N, returns the associated defining entity. If\n-   --  the declaration has a specification, the entity is obtained from\n-   --  the specification. If the declaration has a defining unit name,\n-   --  then the defining entity is obtained from the defining unit name\n-   --  ignoring any child unit prefixes.\n+   --  Given a declaration N, returns the associated defining entity. If the\n+   --  declaration has a specification, the entity is obtained from the\n+   --  specification. If the declaration has a defining unit name, then the\n+   --  defining entity is obtained from the defining unit name ignoring any\n+   --  child unit prefixes.\n \n    function Denotes_Discriminant\n      (N                : Node_Id;\n       Check_Concurrent : Boolean := False) return Boolean;\n-   --  Returns True if node N is an Entity_Name node for a discriminant.\n-   --  If the flag Check_Concurrent is true, function also returns true\n-   --  when N denotes the discriminal of the discriminant of a concurrent\n-   --  type. This is necessary to disable some optimizations on private\n-   --  components of protected types, and constraint checks on entry\n-   --  families constrained by discriminants.\n+   --  Returns True if node N is an Entity_Name node for a discriminant. If the\n+   --  flag Check_Concurrent is true, function also returns true when N denotes\n+   --  the discriminal of the discriminant of a concurrent type. This is needed\n+   --  to disable some optimizations on private components of protected types,\n+   --  and constraint checks on entry families constrained by discriminants.\n \n    function Denotes_Same_Object (A1, A2 : Node_Id) return Boolean;\n    function Denotes_Same_Prefix (A1, A2 : Node_Id) return Boolean;\n@@ -277,49 +275,48 @@ package Sem_Util is\n    function Designate_Same_Unit\n      (Name1 : Node_Id;\n       Name2 : Node_Id) return  Boolean;\n-   --  Return true if Name1 and Name2 designate the same unit name;\n-   --  each of these names is supposed to be a selected component name,\n-   --  an expanded name, a defining program unit name or an identifier\n+   --  Return true if Name1 and Name2 designate the same unit name; each of\n+   --  these names is supposed to be a selected component name, an expanded\n+   --  name, a defining program unit name or an identifier.\n \n    function Enclosing_Generic_Body\n      (N : Node_Id) return Node_Id;\n-   --  Returns the Node_Id associated with the innermost enclosing\n-   --  generic body, if any. If none, then returns Empty.\n+   --  Returns the Node_Id associated with the innermost enclosing generic\n+   --  body, if any. If none, then returns Empty.\n \n    function Enclosing_Generic_Unit\n      (N : Node_Id) return Node_Id;\n-   --  Returns the Node_Id associated with the innermost enclosing\n-   --  generic unit, if any. If none, then returns Empty.\n+   --  Returns the Node_Id associated with the innermost enclosing generic\n+   --  unit, if any. If none, then returns Empty.\n \n    function Enclosing_Lib_Unit_Entity return Entity_Id;\n    --  Returns the entity of enclosing N_Compilation_Unit Node which is the\n-   --  root of the current scope (which must not be Standard_Standard, and\n-   --  the caller is responsible for ensuring this condition).\n+   --  root of the current scope (which must not be Standard_Standard, and the\n+   --  caller is responsible for ensuring this condition).\n \n    function Enclosing_Lib_Unit_Node (N : Node_Id) return Node_Id;\n-   --  Returns the enclosing N_Compilation_Unit Node that is the root\n-   --  of a subtree containing N.\n+   --  Returns the enclosing N_Compilation_Unit Node that is the root of a\n+   --  subtree containing N.\n \n    function Enclosing_Subprogram (E : Entity_Id) return Entity_Id;\n    --  Utility function to return the Ada entity of the subprogram enclosing\n    --  the entity E, if any. Returns Empty if no enclosing subprogram.\n \n    procedure Ensure_Freeze_Node (E : Entity_Id);\n-   --  Make sure a freeze node is allocated for entity E. If necessary,\n-   --  build and initialize a new freeze node and set Has_Delayed_Freeze\n-   --  true for entity E.\n+   --  Make sure a freeze node is allocated for entity E. If necessary, build\n+   --  and initialize a new freeze node and set Has_Delayed_Freeze True for E.\n \n    procedure Enter_Name (Def_Id : Entity_Id);\n    --  Insert new name in symbol table of current scope with check for\n-   --  duplications (error message is issued if a conflict is found)\n-   --  Note: Enter_Name is not used for overloadable entities, instead\n-   --  these are entered using Sem_Ch6.Enter_Overloadable_Entity.\n+   --  duplications (error message is issued if a conflict is found).\n+   --  Note: Enter_Name is not used for overloadable entities, instead these\n+   --  are entered using Sem_Ch6.Enter_Overloadable_Entity.\n \n    procedure Explain_Limited_Type (T : Entity_Id; N : Node_Id);\n-   --  This procedure is called after issuing a message complaining\n-   --  about an inappropriate use of limited type T. If useful, it\n-   --  adds additional continuation lines to the message explaining\n-   --  why type T is limited. Messages are placed at node N.\n+   --  This procedure is called after issuing a message complaining about an\n+   --  inappropriate use of limited type T. If useful, it adds additional\n+   --  continuation lines to the message explaining why type T is limited.\n+   --  Messages are placed at node N.\n \n    procedure Find_Actual\n      (N      : Node_Id;\n@@ -376,7 +373,7 @@ package Sem_Util is\n    --  iterating through the actuals in declaration order is to use this\n    --  function to find the first actual, and then use Next_Actual to obtain\n    --  the next actual in declaration order. Note that the value returned\n-   --  is always the expression (not the N_Parameter_Association nodes\n+   --  is always the expression (not the N_Parameter_Association nodes,\n    --  even if named association is used).\n \n    function Full_Qualified_Name (E : Entity_Id) return String_Id;\n@@ -421,15 +418,15 @@ package Sem_Util is\n    function Get_Actual_Subtype (N : Node_Id) return Entity_Id;\n    --  Given a node for an expression, obtain the actual subtype of the\n    --  expression. In the case of a parameter where the formal is an\n-   --  unconstrained array or discriminated type, this will be the\n-   --  previously constructed subtype of the actual. Note that this is\n-   --  not quite the \"Actual Subtype\" of the RM, since it is always\n-   --  a constrained type, i.e. it is the subtype of the value of the\n-   --  actual. The actual subtype is also returned in other cases where\n-   --  it has already been constructed for an object. Otherwise the\n-   --  expression type is returned unchanged, except for the case of an\n-   --  unconstrained array type, where an actual subtype is created, using\n-   --  Insert_Actions if necessary to insert any associated actions.\n+   --  unconstrained array or discriminated type, this will be the previously\n+   --  constructed subtype of the actual. Note that this is not quite the\n+   --  \"Actual Subtype\" of the RM, since it is always a constrained type, i.e.\n+   --  it is the subtype of the value of the actual. The actual subtype is also\n+   --  returned in other cases where it has already been constructed for an\n+   --  object. Otherwise the expression type is returned unchanged, except for\n+   --  the case of an unconstrained array type, where an actual subtype is\n+   --  created, using Insert_Actions if necessary to insert any associated\n+   --  actions.\n \n    function Get_Actual_Subtype_If_Available (N : Node_Id) return Entity_Id;\n    --  This is like Get_Actual_Subtype, except that it never constructs an\n@@ -439,31 +436,29 @@ package Sem_Util is\n \n    function Get_Default_External_Name (E : Node_Or_Entity_Id) return Node_Id;\n    --  This is used to construct the string literal node representing a\n-   --  default external name, i.e. one that is constructed from the name\n-   --  of an entity, or (in the case of extended DEC import/export pragmas,\n-   --  an identifier provided as the external name. Letters in the name are\n+   --  default external name, i.e. one that is constructed from the name of an\n+   --  entity, or (in the case of extended DEC import/export pragmas, an\n+   --  identifier provided as the external name. Letters in the name are\n    --  according to the setting of Opt.External_Name_Default_Casing.\n \n    function Get_Generic_Entity (N : Node_Id) return Entity_Id;\n-   --  Returns the true generic entity in an instantiation. If the name in\n-   --  the instantiation is a renaming, the function returns the renamed\n-   --  generic.\n+   --  Returns the true generic entity in an instantiation. If the name in the\n+   --  instantiation is a renaming, the function returns the renamed generic.\n \n    procedure Get_Index_Bounds (N : Node_Id; L, H : out Node_Id);\n-   --  This procedure assigns to L and H respectively the values of the\n-   --  low and high bounds of node N, which must be a range, subtype\n-   --  indication, or the name of a scalar subtype. The result in L, H\n-   --  may be set to Error if there was an earlier error in the range.\n+   --  This procedure assigns to L and H respectively the values of the low and\n+   --  high bounds of node N, which must be a range, subtype indication, or the\n+   --  name of a scalar subtype. The result in L, H may be set to Error if\n+   --  there was an earlier error in the range.\n \n    function Get_Enum_Lit_From_Pos\n      (T   : Entity_Id;\n       Pos : Uint;\n       Loc : Source_Ptr) return Entity_Id;\n-   --  This function obtains the E_Enumeration_Literal entity for the\n-   --  specified value from the enumeration type or subtype T. The\n-   --  second argument is the Pos value, which is assumed to be in range.\n-   --  The third argument supplies a source location for constructed\n-   --  nodes returned by this function.\n+   --  This function obtains the E_Enumeration_Literal entity for the specified\n+   --  value from the enumeration type or subtype T. The second argument is the\n+   --  Pos value, which is assumed to be in range. The third argument supplies\n+   --  a source location for constructed nodes returned by this function.\n \n    procedure Get_Library_Unit_Name_String (Decl_Node : Node_Id);\n    --  Retrieve the fully expanded name of the library unit declared by\n@@ -472,9 +467,9 @@ package Sem_Util is\n    function Get_Name_Entity_Id (Id : Name_Id) return Entity_Id;\n    pragma Inline (Get_Name_Entity_Id);\n    --  An entity value is associated with each name in the name table. The\n-   --  Get_Name_Entity_Id function fetches the Entity_Id of this entity,\n-   --  which is the innermost visible entity with the given name. See the\n-   --  body of Sem_Ch8 for further details on handling of entity visibility.\n+   --  Get_Name_Entity_Id function fetches the Entity_Id of this entity, which\n+   --  is the innermost visible entity with the given name. See the body of\n+   --  Sem_Ch8 for further details on handling of entity visibility.\n \n    function Get_Pragma_Id (N : Node_Id) return Pragma_Id;\n    pragma Inline (Get_Pragma_Id);\n@@ -492,22 +487,20 @@ package Sem_Util is\n    --  with any other kind of entity.\n \n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n-   --  Nod is either a procedure call statement, or a function call, or\n-   --  an accept statement node. This procedure finds the Entity_Id of the\n-   --  related subprogram or entry and returns it, or if no subprogram can\n-   --  be found, returns Empty.\n+   --  Nod is either a procedure call statement, or a function call, or an\n+   --  accept statement node. This procedure finds the Entity_Id of the related\n+   --  subprogram or entry and returns it, or if no subprogram can be found,\n+   --  returns Empty.\n \n    function Get_Subprogram_Body (E : Entity_Id) return Node_Id;\n-   --  Given the entity for a subprogram (E_Function or E_Procedure),\n-   --  return the corresponding N_Subprogram_Body node. If the corresponding\n-   --  body of the declaration is missing (as for an imported subprogram)\n-   --  return Empty.\n+   --  Given the entity for a subprogram (E_Function or E_Procedure), return\n+   --  the corresponding N_Subprogram_Body node. If the corresponding body\n+   --  is missing (as for an imported subprogram), return Empty.\n \n    function Get_Task_Body_Procedure (E : Entity_Id) return Node_Id;\n    pragma Inline (Get_Task_Body_Procedure);\n    --  Given an entity for a task type or subtype, retrieves the\n-   --  Task_Body_Procedure field from the corresponding task type\n-   --  declaration.\n+   --  Task_Body_Procedure field from the corresponding task type declaration.\n \n    function Has_Access_Values (T : Entity_Id) return Boolean;\n    --  Returns true if type or subtype T is an access type, or has a component\n@@ -537,18 +530,18 @@ package Sem_Util is\n    --\n    --  Note: Known_Incompatible does not mean that at run time the alignment\n    --  of Expr is known to be wrong for Obj, just that it can be determined\n-   --  that alignments have been explicitly or implicitly specified which\n-   --  are incompatible (whereas Unknown means that even this is not known).\n-   --  The appropriate reaction of a caller to Known_Incompatible is to treat\n-   --  it as Unknown, but issue a warning that there may be an alignment error.\n+   --  that alignments have been explicitly or implicitly specified which are\n+   --  incompatible (whereas Unknown means that even this is not known). The\n+   --  appropriate reaction of a caller to Known_Incompatible is to treat it as\n+   --  Unknown, but issue a warning that there may be an alignment error.\n \n    function Has_Declarations (N : Node_Id) return Boolean;\n    --  Determines if the node can have declarations\n \n    function Has_Discriminant_Dependent_Constraint\n      (Comp : Entity_Id) return Boolean;\n-   --  Returns True if and only if Comp has a constrained subtype\n-   --  that depends on a discriminant.\n+   --  Returns True if and only if Comp has a constrained subtype that depends\n+   --  on a discriminant.\n \n    function Has_Infinities (E : Entity_Id) return Boolean;\n    --  Determines if the range of the floating-point type E includes\n@@ -578,18 +571,18 @@ package Sem_Util is\n    --  yet received a full declaration.\n \n    function Has_Stream (T : Entity_Id) return Boolean;\n-   --  Tests if type T is derived from Ada.Streams.Root_Stream_Type, or\n-   --  in the case of a composite type, has a component for which this\n-   --  predicate is True, and if so returns True. Otherwise a result of\n-   --  False means that there is no Stream type in sight. For a private\n-   --  type, the test is applied to the underlying type (or returns False\n-   --  if there is no underlying type).\n+   --  Tests if type T is derived from Ada.Streams.Root_Stream_Type, or in the\n+   --  case of a composite type, has a component for which this predicate is\n+   --  True, and if so returns True. Otherwise a result of False means that\n+   --  there is no Stream type in sight. For a private type, the test is\n+   --  applied to the underlying type (or returns False if there is no\n+   --  underlying type).\n \n    function Has_Tagged_Component (Typ : Entity_Id) return Boolean;\n    --  Returns True if Typ is a composite type (array or record) which is\n    --  either itself a tagged type, or has a component (recursively) which is\n    --  a tagged type. Returns False for non-composite type, or if no tagged\n-   --  component is present. This function is used to check if '=' has to be\n+   --  component is present. This function is used to check if \"=\" has to be\n    --  expanded into a bunch component comparisons.\n \n    function Implements_Interface\n@@ -620,11 +613,11 @@ package Sem_Util is\n    --  Returns True if node N belongs to a parameter specification\n \n    function In_Subprogram_Or_Concurrent_Unit return Boolean;\n-   --  Determines if the current scope is within a subprogram compilation\n-   --  unit (inside a subprogram declaration, subprogram body, or generic\n-   --  subprogram declaration) or within a task or protected body. The test\n-   --  is for appearing anywhere within such a construct (that is it does not\n-   --  need to be directly within).\n+   --  Determines if the current scope is within a subprogram compilation unit\n+   --  (inside a subprogram declaration, subprogram body, or generic\n+   --  subprogram declaration) or within a task or protected body. The test is\n+   --  for appearing anywhere within such a construct (that is it does not need\n+   --  to be directly within).\n \n    function In_Visible_Part (Scope_Id : Entity_Id) return Boolean;\n    --  Determine whether a declaration occurs within the visible part of a\n@@ -656,17 +649,17 @@ package Sem_Util is\n    --  Determines if N is an actual parameter in a subprogram call\n \n    function Is_Aliased_View (Obj : Node_Id) return Boolean;\n-   --  Determine if Obj is an aliased view, i.e. the name of an\n-   --  object to which 'Access or 'Unchecked_Access can apply.\n+   --  Determine if Obj is an aliased view, i.e. the name of an object to which\n+   --  'Access or 'Unchecked_Access can apply.\n \n    function Is_Ancestor_Package\n      (E1 : Entity_Id;\n       E2 : Entity_Id) return Boolean;\n    --  Determine whether package E1 is an ancestor of E2\n \n    function Is_Atomic_Object (N : Node_Id) return Boolean;\n-   --  Determines if the given node denotes an atomic object in the sense\n-   --  of the legality checks described in RM C.6(12).\n+   --  Determines if the given node denotes an atomic object in the sense of\n+   --  the legality checks described in RM C.6(12).\n \n    function Is_Coextension_Root (N : Node_Id) return Boolean;\n    --  Determine whether node N is an allocator which acts as a coextension\n@@ -1173,11 +1166,10 @@ package Sem_Util is\n    --  are only partially ordered, so Scope_Within_Or_Same (A,B) and\n    --  Scope_Within_Or_Same (B,A) can both be False for a given pair A,B.\n \n-   procedure Save_Actual (N : Node_Id;  Writable : Boolean := False);\n-   --  Enter an actual in a call in a table global, for subsequent check\n-   --  of possible order dependence in the presence of in out parameters\n-   --  for functions in Ada 2012 (or access parameters in older versions\n-   --  of the language).\n+   procedure Save_Actual (N : Node_Id; Writable : Boolean := False);\n+   --  Enter an actual in a call in a table global, for subsequent check of\n+   --  possible order dependence in the presence of IN OUT parameters for\n+   --  functions in Ada 2012 (or access parameters in older language versions).\n \n    function Scope_Within (Scope1, Scope2 : Entity_Id) return Boolean;\n    --  Like Scope_Within_Or_Same, except that this function returns"}]}