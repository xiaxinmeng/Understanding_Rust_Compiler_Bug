{"sha": "ebb479cd4d397e829eed460bd7ac9040204f8b5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiNDc5Y2Q0ZDM5N2U4MjllZWQ0NjBiZDdhYzkwNDAyMDRmOGI1YQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-10-05T18:53:19Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-10-05T18:53:19Z"}, "message": "re PR fortran/35680 (ICE on invalid transfer in variable declaration)\n\n2008-10-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35680\n\t* gfortran.h : Add 'error' bit field to gfc_expr structure.\n\t* expr.c (check_inquiry): When checking a restricted expression\n\tcheck that arguments are either variables or restricted.\n\t(check_restricted): Do not emit error if the expression has\n\t'error' set.  Clean up detection of host-associated variable.\n\n2008-10-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35680\n\t* gfortran.dg/transfer_array_intrinsic_5.f90: New test.\n\nFrom-SVN: r140892", "tree": {"sha": "c71ab288ceb2e57f96381fd328e65086481e70be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c71ab288ceb2e57f96381fd328e65086481e70be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb479cd4d397e829eed460bd7ac9040204f8b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb479cd4d397e829eed460bd7ac9040204f8b5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb479cd4d397e829eed460bd7ac9040204f8b5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb479cd4d397e829eed460bd7ac9040204f8b5a/comments", "author": null, "committer": null, "parents": [{"sha": "1d72ff1ac81ad458577b38453c46d115ae21da91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d72ff1ac81ad458577b38453c46d115ae21da91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d72ff1ac81ad458577b38453c46d115ae21da91"}], "stats": {"total": 79, "additions": 65, "deletions": 14}, "files": [{"sha": "53f3f0c1526963e0506e07f9b1f89aee2563ed1b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ebb479cd4d397e829eed460bd7ac9040204f8b5a", "patch": "@@ -1,3 +1,12 @@\n+2008-10-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35680\n+\t* gfortran.h : Add 'error' bit field to gfc_expr structure.\n+\t* expr.c (check_inquiry): When checking a restricted expression\n+\tcheck that arguments are either variables or restricted.\n+\t(check_restricted): Do not emit error if the expression has\n+\t'error' set.  Clean up detection of host-associated variable.\n+\n 2008-10-05  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/37638"}, {"sha": "7f6bf1b07e479ea9de68ad8731bbcc846916febe", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=ebb479cd4d397e829eed460bd7ac9040204f8b5a", "patch": "@@ -2017,6 +2017,8 @@ check_init_expr_arguments (gfc_expr *e)\n   return MATCH_YES;\n }\n \n+static gfc_try check_restricted (gfc_expr *);\n+\n /* F95, 7.1.6.1, Initialization expressions, (7)\n    F2003, 7.1.7 Initialization expression, (8)  */\n \n@@ -2096,6 +2098,11 @@ check_inquiry (gfc_expr *e, int not_restricted)\n \t  }\n \telse if (not_restricted && check_init_expr (ap->expr) == FAILURE)\n \t  return MATCH_ERROR;\n+\n+\tif (not_restricted == 0\n+\t      && ap->expr->expr_type != EXPR_VARIABLE\n+\t      && check_restricted (ap->expr) == FAILURE)\n+\t  return MATCH_ERROR;\n     }\n \n   return MATCH_YES;\n@@ -2421,8 +2428,6 @@ gfc_match_init_expr (gfc_expr **result)\n }\n \n \n-static gfc_try check_restricted (gfc_expr *);\n-\n /* Given an actual argument list, test to see that each argument is a\n    restricted expression and optionally if the expression type is\n    integer or character.  */\n@@ -2561,22 +2566,26 @@ check_restricted (gfc_expr *e)\n \t that host associated dummy array indices are accepted (PR23446).\n \t This mechanism also does the same for the specification expressions\n \t of array-valued functions.  */\n-      if (sym->attr.in_common\n-\t  || sym->attr.use_assoc\n-\t  || sym->attr.dummy\n-\t  || sym->attr.implied_index\n-\t  || sym->ns != gfc_current_ns\n-\t  || (sym->ns->proc_name != NULL\n-\t      && sym->ns->proc_name->attr.flavor == FL_MODULE)\n-\t  || (gfc_is_formal_arg () && (sym->ns == gfc_current_ns)))\n+      if (e->error\n+\t    || sym->attr.in_common\n+\t    || sym->attr.use_assoc\n+\t    || sym->attr.dummy\n+\t    || sym->attr.implied_index\n+\t    || (sym->ns && sym->ns == gfc_current_ns->parent)\n+\t    || (sym->ns && gfc_current_ns->parent\n+\t\t  && sym->ns == gfc_current_ns->parent->parent)\n+\t    || (sym->ns->proc_name != NULL\n+\t\t  && sym->ns->proc_name->attr.flavor == FL_MODULE)\n+\t    || (gfc_is_formal_arg () && (sym->ns == gfc_current_ns)))\n \t{\n \t  t = SUCCESS;\n \t  break;\n \t}\n \n       gfc_error (\"Variable '%s' cannot appear in the expression at %L\",\n \t\t sym->name, &e->where);\n-\n+      /* Prevent a repetition of the error.  */\n+      e->error = 1;\n       break;\n \n     case EXPR_NULL:"}, {"sha": "b032486abfd54d43392742eb837f9a1ca7ea18fb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ebb479cd4d397e829eed460bd7ac9040204f8b5a", "patch": "@@ -637,10 +637,10 @@ typedef struct\n   unsigned function:1, subroutine:1, procedure:1;\n   unsigned generic:1, generic_copy:1;\n   unsigned implicit_type:1;\t/* Type defined via implicit rules.  */\n-  unsigned untyped:1;           /* No implicit type could be found.  */\n+  unsigned untyped:1;\t\t/* No implicit type could be found.  */\n \n-  unsigned is_bind_c:1;\t\t/* say if is bound to C */\n-  unsigned extension:1;\t\t/* extends a derived type */\n+  unsigned is_bind_c:1;\t\t/* say if is bound to C.  */\n+  unsigned extension:1;\t\t/* extends a derived type.  */\n \n   /* These flags are both in the typespec and attribute.  The attribute\n      list is what gets read from/written to a module file.  The typespec\n@@ -1547,6 +1547,10 @@ typedef struct gfc_expr\n      and if we have decided not to allocate temporary data for that array.  */\n   unsigned int inline_noncopying_intrinsic : 1, is_boz : 1;\n \n+  /* Sometimes, when an error has been emitted, it is necessary to prevent\n+      it from recurring.  */\n+  unsigned int error : 1;\n+\n   /* Used to quickly find a given constructor by its offset.  */\n   splay_tree con_by_offset;\n "}, {"sha": "df7ba0b1e96269df616eb7aec9b6f91a0a152fa1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebb479cd4d397e829eed460bd7ac9040204f8b5a", "patch": "@@ -1,3 +1,8 @@\n+2008-10-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35680\n+\t* gfortran.dg/transfer_array_intrinsic_5.f90: New test.\n+\n 2008-10-05  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/37638"}, {"sha": "c886b03f66559f67cfeeed85e53bfc14da5cdc12", "filename": "gcc/testsuite/gfortran.dg/transfer_array_intrinsic_5.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb479cd4d397e829eed460bd7ac9040204f8b5a/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_5.f90?ref=ebb479cd4d397e829eed460bd7ac9040204f8b5a", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! PR35680 - used to ICE because the argument of SIZE, being in a restricted\n+! expression, was not checked if it too is restricted or is a variable. Since\n+! it is neither, an error should be produced.\n+!\n+! Contributed by  Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+!\n+program main\n+  print *, foo (), bar (), foobar ()\n+contains\n+  function foo ()\n+    integer foo(size (transfer (x, [1])))     ! { dg-error \"cannot appear\" }\n+    real x\n+ end function\n+  function bar()\n+    real x\n+    integer bar(size (transfer (x, [1])))     ! { dg-error \"cannot appear\" }\n+ end function\n+  function foobar()                           ! { dg-error \"no IMPLICIT\" }\n+    implicit none\n+    integer foobar(size (transfer (x, [1])))  ! { dg-error \"used before\" }\n+    real x\n+ end function\n+end program"}]}