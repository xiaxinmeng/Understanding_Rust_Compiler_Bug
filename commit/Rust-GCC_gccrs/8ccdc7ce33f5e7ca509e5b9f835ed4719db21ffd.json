{"sha": "8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "node_id": "C_kwDOANBUbNoAKDhjY2RjN2NlMzNmNWU3Y2E1MDllNWI5ZjgzNWVkNDcxOWRiMjFmZmQ", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-05-19T22:38:23Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-05-19T22:38:23Z"}, "message": "libstdc++: Ensure pmr aliases work without <memory_resource>\n\nCurrently the alias templates for std::pmr::vector, std::pmr::string\netc. are defined using a forward declaration for polymorphic_allocator.\nThis means you can't actually use the alias templates unless you also\ninclude <memory_resource>. The rationale for that is that it's a fairly\nlarge header, and most users don't need it. This isn't uncontroversial\nthough, and LWG 3681 questions whether it's even conforming.\n\nThis change adds a new <bits/memory_resource.h> header with the minimum\nneeded to use polymorphic_allocator and the std::pmr container aliases.\nIncluding <memory_resource> is still necessary to use the program-wide\nresource objects, or the pool resources or monotonic buffer resource.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/memory_resource.h: New file.\n\t* include/std/deque: Include <bits/memory_resource.h>.\n\t* include/std/forward_list: Likewise.\n\t* include/std/list: Likewise.\n\t* include/std/map: Likewise.\n\t* include/std/memory_resource (pmr::memory_resource): Move to\n\tnew <bits/memory_resource.h> header.\n\t(pmr::polymorphic_allocator): Likewise.\n\t* include/std/regex: Likewise.\n\t* include/std/set: Likewise.\n\t* include/std/stacktrace: Likewise.\n\t* include/std/string: Likewise.\n\t* include/std/unordered_map: Likewise.\n\t* include/std/unordered_set: Likewise.\n\t* include/std/vector: Likewise.\n\t* testsuite/21_strings/basic_string/types/pmr_typedefs.cc:\n\tRemove <memory_resource> header and check construction.\n\t* testsuite/23_containers/deque/types/pmr_typedefs.cc: Likewise.\n\t* testsuite/23_containers/forward_list/pmr_typedefs.cc:\n\tLikewise.\n\t* testsuite/23_containers/list/pmr_typedefs.cc: Likewise.\n\t* testsuite/23_containers/map/pmr_typedefs.cc: Likewise.\n\t* testsuite/23_containers/multimap/pmr_typedefs.cc: Likewise.\n\t* testsuite/23_containers/multiset/pmr_typedefs.cc: Likewise.\n\t* testsuite/23_containers/set/pmr_typedefs.cc: Likewise.\n\t* testsuite/23_containers/unordered_map/pmr_typedefs.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multimap/pmr_typedefs.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multiset/pmr_typedefs.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/pmr_typedefs.cc:\n\tLikewise.\n\t* testsuite/23_containers/vector/pmr_typedefs.cc: Likewise.\n\t* testsuite/28_regex/match_results/pmr_typedefs.cc: Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/variadic-tuple.C: Qualify function to avoid ADL\n\tfinding std::make_tuple.", "tree": {"sha": "35b201acf391285912ba2ad28de5baff3c197b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35b201acf391285912ba2ad28de5baff3c197b13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d863ba23fb16122bb0547b0c678173be0d98f43c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d863ba23fb16122bb0547b0c678173be0d98f43c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d863ba23fb16122bb0547b0c678173be0d98f43c"}], "stats": {"total": 1039, "additions": 551, "deletions": 488}, "files": [{"sha": "e2699d94ebf8b876376aa656d0e2a5d9a602367b", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-tuple.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-tuple.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-tuple.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-tuple.C?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -272,7 +272,7 @@ int main()\n   //  t3a = t3b; DPG: triggers an error, as it should.\n \n   tuple<int, float, std::string> t3c = \n-    make_tuple(17, 2.718281828, std::string(\"Fun\"));\n+    ::make_tuple(17, 2.718281828, std::string(\"Fun\"));\n \n   int seventeen = 17;\n   double pi = 3.14159;"}, {"sha": "b46def7ff9ff85b192117a615479d77d1454aa17", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -157,6 +157,7 @@ bits_headers = \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/max_size_type.h \\\n+\t${bits_srcdir}/memory_resource.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n \t${bits_srcdir}/mofunc_impl.h \\\n \t${bits_srcdir}/move.h \\"}, {"sha": "f844008a7c57d5c9fcc3a2262d6d99a8cc7a9b00", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -515,6 +515,7 @@ bits_headers = \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/max_size_type.h \\\n+\t${bits_srcdir}/memory_resource.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n \t${bits_srcdir}/mofunc_impl.h \\\n \t${bits_srcdir}/move.h \\"}, {"sha": "d8c7e168235684728ff2ad73bad3847d84ebda29", "filename": "libstdc++-v3/include/bits/memory_resource.h", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmemory_resource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmemory_resource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmemory_resource.h?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -0,0 +1,507 @@\n+// <memory_resource> -*- C++ -*-\n+\n+// Copyright (C) 2018-2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/memory_resource.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{memory_resource}\n+ */\n+\n+#ifndef _GLIBCXX_MEMORY_RESOURCE_H\n+#define _GLIBCXX_MEMORY_RESOURCE_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201703L\n+\n+#include <new>\t\t\t\t// operator new(size_t, void*)\n+#include <cstddef>\t\t\t// size_t, max_align_t, byte\n+#include <bits/functexcept.h>\t\t// __throw_bad_array_new_length\n+#include <bits/uses_allocator.h>\t// allocator_arg_t, __use_alloc\n+#include <bits/uses_allocator_args.h>\t// uninitialized_construct_using_alloc\n+#include <ext/numeric_traits.h>\t\t// __int_traits\n+#include <debug/assertions.h>\n+\n+#if ! __cpp_lib_make_obj_using_allocator\n+# include <bits/utility.h>\t\t// index_sequence\n+# include <tuple>\t\t\t// tuple, forward_as_tuple\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace pmr\n+{\n+  /// Class memory_resource\n+  class memory_resource\n+  {\n+    static constexpr size_t _S_max_align = alignof(max_align_t);\n+\n+  public:\n+    memory_resource() = default;\n+    memory_resource(const memory_resource&) = default;\n+    virtual ~memory_resource(); // key function\n+\n+    memory_resource& operator=(const memory_resource&) = default;\n+\n+    [[nodiscard]]\n+    void*\n+    allocate(size_t __bytes, size_t __alignment = _S_max_align)\n+    __attribute__((__returns_nonnull__,__alloc_size__(2),__alloc_align__(3)))\n+    { return ::operator new(__bytes, do_allocate(__bytes, __alignment)); }\n+\n+    void\n+    deallocate(void* __p, size_t __bytes, size_t __alignment = _S_max_align)\n+    __attribute__((__nonnull__))\n+    { return do_deallocate(__p, __bytes, __alignment); }\n+\n+    [[nodiscard]]\n+    bool\n+    is_equal(const memory_resource& __other) const noexcept\n+    { return do_is_equal(__other); }\n+\n+  private:\n+    virtual void*\n+    do_allocate(size_t __bytes, size_t __alignment) = 0;\n+\n+    virtual void\n+    do_deallocate(void* __p, size_t __bytes, size_t __alignment) = 0;\n+\n+    virtual bool\n+    do_is_equal(const memory_resource& __other) const noexcept = 0;\n+  };\n+\n+  [[nodiscard]]\n+  inline bool\n+  operator==(const memory_resource& __a, const memory_resource& __b) noexcept\n+  { return &__a == &__b || __a.is_equal(__b); }\n+\n+#if __cpp_impl_three_way_comparison < 201907L\n+  [[nodiscard]]\n+  inline bool\n+  operator!=(const memory_resource& __a, const memory_resource& __b) noexcept\n+  { return !(__a == __b); }\n+#endif\n+\n+  // C++17 23.12.3 Class template polymorphic_allocator\n+  template<typename _Tp>\n+    class polymorphic_allocator\n+    {\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 2975. Missing case for pair construction in polymorphic allocators\n+      template<typename _Up>\n+\tstruct __not_pair { using type = void; };\n+\n+      template<typename _Up1, typename _Up2>\n+\tstruct __not_pair<pair<_Up1, _Up2>> { };\n+\n+    public:\n+      using value_type = _Tp;\n+\n+      polymorphic_allocator() noexcept\n+      {\n+\textern memory_resource* get_default_resource() noexcept\n+\t  __attribute__((__returns_nonnull__));\n+\t_M_resource = get_default_resource();\n+      }\n+\n+      polymorphic_allocator(memory_resource* __r) noexcept\n+      __attribute__((__nonnull__))\n+      : _M_resource(__r)\n+      { _GLIBCXX_DEBUG_ASSERT(__r); }\n+\n+      polymorphic_allocator(const polymorphic_allocator& __other) = default;\n+\n+      template<typename _Up>\n+\tpolymorphic_allocator(const polymorphic_allocator<_Up>& __x) noexcept\n+\t: _M_resource(__x.resource())\n+\t{ }\n+\n+      polymorphic_allocator&\n+      operator=(const polymorphic_allocator&) = delete;\n+\n+      [[nodiscard]]\n+      _Tp*\n+      allocate(size_t __n)\n+      __attribute__((__returns_nonnull__))\n+      {\n+\tif ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Tp)) < __n)\n+\t  std::__throw_bad_array_new_length();\n+\treturn static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),\n+\t\t\t\t\t\t       alignof(_Tp)));\n+      }\n+\n+      void\n+      deallocate(_Tp* __p, size_t __n) noexcept\n+      __attribute__((__nonnull__))\n+      { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }\n+\n+#if __cplusplus > 201703L\n+      [[nodiscard]] void*\n+      allocate_bytes(size_t __nbytes,\n+\t\t     size_t __alignment = alignof(max_align_t))\n+      { return _M_resource->allocate(__nbytes, __alignment); }\n+\n+      void\n+      deallocate_bytes(void* __p, size_t __nbytes,\n+\t\t       size_t __alignment = alignof(max_align_t))\n+      { _M_resource->deallocate(__p, __nbytes, __alignment); }\n+\n+      template<typename _Up>\n+\t[[nodiscard]] _Up*\n+\tallocate_object(size_t __n = 1)\n+\t{\n+\t  if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Up)) < __n)\n+\t    std::__throw_bad_array_new_length();\n+\t  return static_cast<_Up*>(allocate_bytes(__n * sizeof(_Up),\n+\t\t\t\t\t\t  alignof(_Up)));\n+\t}\n+\n+      template<typename _Up>\n+\tvoid\n+\tdeallocate_object(_Up* __p, size_t __n = 1)\n+\t{ deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up)); }\n+\n+      template<typename _Up, typename... _CtorArgs>\n+\t[[nodiscard]] _Up*\n+\tnew_object(_CtorArgs&&... __ctor_args)\n+\t{\n+\t  _Up* __p = allocate_object<_Up>();\n+\t  __try\n+\t    {\n+\t      construct(__p, std::forward<_CtorArgs>(__ctor_args)...);\n+\t    }\n+\t  __catch (...)\n+\t    {\n+\t      deallocate_object(__p);\n+\t      __throw_exception_again;\n+\t    }\n+\t  return __p;\n+\t}\n+\n+      template<typename _Up>\n+\tvoid\n+\tdelete_object(_Up* __p)\n+\t{\n+\t  __p->~_Up();\n+\t  deallocate_object(__p);\n+\t}\n+#endif // C++2a\n+\n+#if ! __cpp_lib_make_obj_using_allocator\n+      template<typename _Tp1, typename... _Args>\n+\t__attribute__((__nonnull__))\n+\ttypename __not_pair<_Tp1>::type\n+\tconstruct(_Tp1* __p, _Args&&... __args)\n+\t{\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 2969. polymorphic_allocator::construct() shouldn't pass resource()\n+\t  using __use_tag\n+\t    = std::__uses_alloc_t<_Tp1, polymorphic_allocator, _Args...>;\n+\t  if constexpr (is_base_of_v<__uses_alloc0, __use_tag>)\n+\t    ::new(__p) _Tp1(std::forward<_Args>(__args)...);\n+\t  else if constexpr (is_base_of_v<__uses_alloc1_, __use_tag>)\n+\t    ::new(__p) _Tp1(allocator_arg, *this,\n+\t\t\t    std::forward<_Args>(__args)...);\n+\t  else\n+\t    ::new(__p) _Tp1(std::forward<_Args>(__args)..., *this);\n+\t}\n+\n+      template<typename _Tp1, typename _Tp2,\n+\t       typename... _Args1, typename... _Args2>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, piecewise_construct_t,\n+\t\t  tuple<_Args1...> __x, tuple<_Args2...> __y)\n+\t{\n+\t  auto __x_tag =\n+\t    __use_alloc<_Tp1, polymorphic_allocator, _Args1...>(*this);\n+\t  auto __y_tag =\n+\t    __use_alloc<_Tp2, polymorphic_allocator, _Args2...>(*this);\n+\t  index_sequence_for<_Args1...> __x_i;\n+\t  index_sequence_for<_Args2...> __y_i;\n+\n+\t  ::new(__p) pair<_Tp1, _Tp2>(piecewise_construct,\n+\t\t\t\t      _S_construct_p(__x_tag, __x_i, __x),\n+\t\t\t\t      _S_construct_p(__y_tag, __y_i, __y));\n+\t}\n+\n+      template<typename _Tp1, typename _Tp2>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p)\n+\t{ this->construct(__p, piecewise_construct, tuple<>(), tuple<>()); }\n+\n+      template<typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, _Up&& __x, _Vp&& __y)\n+\t{\n+\t  this->construct(__p, piecewise_construct,\n+\t      std::forward_as_tuple(std::forward<_Up>(__x)),\n+\t      std::forward_as_tuple(std::forward<_Vp>(__y)));\n+\t}\n+\n+      template <typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, const std::pair<_Up, _Vp>& __pr)\n+\t{\n+\t  this->construct(__p, piecewise_construct,\n+\t      std::forward_as_tuple(__pr.first),\n+\t      std::forward_as_tuple(__pr.second));\n+\t}\n+\n+      template<typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, pair<_Up, _Vp>&& __pr)\n+\t{\n+\t  this->construct(__p, piecewise_construct,\n+\t      std::forward_as_tuple(std::forward<_Up>(__pr.first)),\n+\t      std::forward_as_tuple(std::forward<_Vp>(__pr.second)));\n+\t}\n+#else // make_obj_using_allocator\n+      template<typename _Tp1, typename... _Args>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(_Tp1* __p, _Args&&... __args)\n+\t{\n+\t  std::uninitialized_construct_using_allocator(__p, *this,\n+\t      std::forward<_Args>(__args)...);\n+\t}\n+#endif\n+\n+      template<typename _Up>\n+\t_GLIBCXX20_DEPRECATED_SUGGEST(\"allocator_traits::destroy\")\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tdestroy(_Up* __p)\n+\t{ __p->~_Up(); }\n+\n+      polymorphic_allocator\n+      select_on_container_copy_construction() const noexcept\n+      { return polymorphic_allocator(); }\n+\n+      memory_resource*\n+      resource() const noexcept\n+      __attribute__((__returns_nonnull__))\n+      { return _M_resource; }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 3683. operator== for polymorphic_allocator cannot deduce template arg\n+      [[nodiscard]]\n+      friend bool\n+      operator==(const polymorphic_allocator& __a,\n+\t\t const polymorphic_allocator& __b) noexcept\n+      { return *__a.resource() == *__b.resource(); }\n+\n+#if __cpp_impl_three_way_comparison < 201907L\n+      [[nodiscard]]\n+      friend bool\n+      operator!=(const polymorphic_allocator& __a,\n+\t\t const polymorphic_allocator& __b) noexcept\n+      { return !(__a == __b); }\n+#endif\n+\n+    private:\n+#if ! __cpp_lib_make_obj_using_allocator\n+      using __uses_alloc1_ = __uses_alloc1<polymorphic_allocator>;\n+      using __uses_alloc2_ = __uses_alloc2<polymorphic_allocator>;\n+\n+      template<typename _Ind, typename... _Args>\n+\tstatic tuple<_Args&&...>\n+\t_S_construct_p(__uses_alloc0, _Ind, tuple<_Args...>& __t)\n+\t{ return std::move(__t); }\n+\n+      template<size_t... _Ind, typename... _Args>\n+\tstatic tuple<allocator_arg_t, polymorphic_allocator, _Args&&...>\n+\t_S_construct_p(__uses_alloc1_ __ua, index_sequence<_Ind...>,\n+\t\t       tuple<_Args...>& __t)\n+\t{\n+\t  return {\n+\t      allocator_arg, *__ua._M_a, std::get<_Ind>(std::move(__t))...\n+\t  };\n+\t}\n+\n+      template<size_t... _Ind, typename... _Args>\n+\tstatic tuple<_Args&&..., polymorphic_allocator>\n+\t_S_construct_p(__uses_alloc2_ __ua, index_sequence<_Ind...>,\n+\t\t       tuple<_Args...>& __t)\n+\t{ return { std::get<_Ind>(std::move(__t))..., *__ua._M_a }; }\n+#endif\n+\n+      memory_resource* _M_resource;\n+    };\n+\n+  template<typename _Tp1, typename _Tp2>\n+    [[nodiscard]]\n+    inline bool\n+    operator==(const polymorphic_allocator<_Tp1>& __a,\n+\t       const polymorphic_allocator<_Tp2>& __b) noexcept\n+    { return *__a.resource() == *__b.resource(); }\n+\n+#if __cpp_impl_three_way_comparison < 201907L\n+  template<typename _Tp1, typename _Tp2>\n+    [[nodiscard]]\n+    inline bool\n+    operator!=(const polymorphic_allocator<_Tp1>& __a,\n+\t       const polymorphic_allocator<_Tp2>& __b) noexcept\n+    { return !(__a == __b); }\n+#endif\n+\n+} // namespace pmr\n+\n+  template<typename _Alloc> struct allocator_traits;\n+\n+  /// Partial specialization for std::pmr::polymorphic_allocator\n+  template<typename _Tp>\n+    struct allocator_traits<pmr::polymorphic_allocator<_Tp>>\n+    {\n+      /// The allocator type\n+      using allocator_type = pmr::polymorphic_allocator<_Tp>;\n+\n+      /// The allocated type\n+      using value_type = _Tp;\n+\n+      /// The allocator's pointer type.\n+      using pointer = _Tp*;\n+\n+      /// The allocator's const pointer type.\n+      using const_pointer = const _Tp*;\n+\n+      /// The allocator's void pointer type.\n+      using void_pointer = void*;\n+\n+      /// The allocator's const void pointer type.\n+      using const_void_pointer = const void*;\n+\n+      /// The allocator's difference type\n+      using difference_type = std::ptrdiff_t;\n+\n+      /// The allocator's size type\n+      using size_type = std::size_t;\n+\n+      /** @{\n+       * A `polymorphic_allocator` does not propagate when a\n+       * container is copied, moved, or swapped.\n+       */\n+      using propagate_on_container_copy_assignment = false_type;\n+      using propagate_on_container_move_assignment = false_type;\n+      using propagate_on_container_swap = false_type;\n+\n+      static allocator_type\n+      select_on_container_copy_construction(const allocator_type&) noexcept\n+      { return allocator_type(); }\n+      /// @}\n+\n+      /// Whether all instances of the allocator type compare equal.\n+      using is_always_equal = false_type;\n+\n+      template<typename _Up>\n+\tusing rebind_alloc = pmr::polymorphic_allocator<_Up>;\n+\n+      template<typename _Up>\n+\tusing rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  __a  An allocator.\n+       *  @param  __n  The number of objects to allocate space for.\n+       *\n+       *  Calls `a.allocate(n)`.\n+      */\n+      [[nodiscard]] static pointer\n+      allocate(allocator_type& __a, size_type __n)\n+      { return __a.allocate(__n); }\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  __a  An allocator.\n+       *  @param  __n  The number of objects to allocate space for.\n+       *  @return Memory of suitable size and alignment for `n` objects\n+       *          of type `value_type`.\n+       *\n+       *  The third parameter is ignored..\n+       *\n+       *  Returns `a.allocate(n)`.\n+      */\n+      [[nodiscard]] static pointer\n+      allocate(allocator_type& __a, size_type __n, const_void_pointer)\n+      { return __a.allocate(__n); }\n+\n+      /**\n+       *  @brief  Deallocate memory.\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to the memory to deallocate.\n+       *  @param  __n  The number of objects space was allocated for.\n+       *\n+       *  Calls `a.deallocate(p, n)`.\n+      */\n+      static void\n+      deallocate(allocator_type& __a, pointer __p, size_type __n)\n+      { __a.deallocate(__p, __n); }\n+\n+      /**\n+       *  @brief  Construct an object of type `_Up`\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to memory of suitable size and alignment for\n+       *\t       an object of type `_Up`.\n+       *  @param  __args Constructor arguments.\n+       *\n+       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`\n+       *  in C++11, C++14 and C++17. Changed in C++20 to call\n+       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.\n+      */\n+      template<typename _Up, typename... _Args>\n+\tstatic void\n+\tconstruct(allocator_type& __a, _Up* __p, _Args&&... __args)\n+\t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief  Destroy an object of type `_Up`\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to the object to destroy\n+       *\n+       *  Calls `p->_Up()`.\n+      */\n+      template<typename _Up>\n+\tstatic _GLIBCXX20_CONSTEXPR void\n+\tdestroy(allocator_type&, _Up* __p)\n+\tnoexcept(is_nothrow_destructible<_Up>::value)\n+\t{ __p->~_Up(); }\n+\n+      /**\n+       *  @brief  The maximum supported allocation size\n+       *  @return `numeric_limits<size_t>::max() / sizeof(value_type)`\n+      */\n+      static _GLIBCXX20_CONSTEXPR size_type\n+      max_size(const allocator_type&) noexcept\n+      { return size_t(-1) / sizeof(value_type); }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+#endif // _GLIBCXX_MEMORY_RESOURCE_H"}, {"sha": "abdc2e04cddaaf59710c98530a5f3e8e05c51ed4", "filename": "libstdc++-v3/include/std/deque", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -71,12 +71,12 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Tp>\n       using deque = std::deque<_Tp, polymorphic_allocator<_Tp>>;\n   } // namespace pmr"}, {"sha": "fe99e5ed5ef26d6948b888cf46186f85baa33e83", "filename": "libstdc++-v3/include/std/forward_list", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -44,12 +44,12 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Tp>\n       using forward_list = std::forward_list<_Tp, polymorphic_allocator<_Tp>>;\n   } // namespace pmr"}, {"sha": "9151e98cb882701d3fc3406f4c46a413247b55c1", "filename": "libstdc++-v3/include/std/list", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -68,12 +68,12 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Tp>\n       using list = std::list<_Tp, polymorphic_allocator<_Tp>>;\n   } // namespace pmr"}, {"sha": "ce07f29ee0925871ed18761868c52e9e22f015ea", "filename": "libstdc++-v3/include/std/map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -68,12 +68,12 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Key, typename _Tp, typename _Cmp = std::less<_Key>>\n       using map\n \t= std::map<_Key, _Tp, _Cmp,"}, {"sha": "19c922516d5808ed9eb8f56da1f1ab116c1c27e7", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 2, "deletions": 462, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -33,22 +33,12 @@\n \n #if __cplusplus >= 201703L\n \n-#include <new>\n+#include <bits/memory_resource.h>\n #include <vector>\t\t\t// vector\n-#include <cstddef>\t\t\t// size_t, max_align_t, byte\n #include <shared_mutex>\t\t\t// shared_mutex\n #include <bits/align.h>\t\t\t// align\n-#include <bits/functexcept.h>\t\t// __throw_bad_array_new_length\n-#include <bits/uses_allocator.h>\t// allocator_arg_t, __use_alloc\n-#include <bits/uses_allocator_args.h>\t// uninitialized_construct_using_alloc\n-#include <ext/numeric_traits.h>\n #include <debug/assertions.h>\n \n-#if ! __cpp_lib_make_obj_using_allocator\n-# include <bits/utility.h>\t\t// index_sequence\n-# include <tuple>\t\t\t// tuple, forward_as_tuple\n-#endif\n-\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -62,12 +52,7 @@ namespace pmr\n # define __cpp_lib_memory_resource 1\n #endif\n \n-  class memory_resource;\n-\n-#if __cplusplus == 201703L\n-  template<typename _Tp>\n-    class polymorphic_allocator;\n-#else // C++20\n+#if __cplusplus >= 202002L\n # define __cpp_lib_polymorphic_allocator 201902L\n   template<typename _Tp = std::byte>\n     class polymorphic_allocator;\n@@ -103,451 +88,6 @@ namespace pmr\n   class unsynchronized_pool_resource;\n   class monotonic_buffer_resource;\n \n-  /// Class memory_resource\n-  class memory_resource\n-  {\n-    static constexpr size_t _S_max_align = alignof(max_align_t);\n-\n-  public:\n-    memory_resource() = default;\n-    memory_resource(const memory_resource&) = default;\n-    virtual ~memory_resource(); // key function\n-\n-    memory_resource& operator=(const memory_resource&) = default;\n-\n-    [[nodiscard]]\n-    void*\n-    allocate(size_t __bytes, size_t __alignment = _S_max_align)\n-    __attribute__((__returns_nonnull__,__alloc_size__(2),__alloc_align__(3)))\n-    { return ::operator new(__bytes, do_allocate(__bytes, __alignment)); }\n-\n-    void\n-    deallocate(void* __p, size_t __bytes, size_t __alignment = _S_max_align)\n-    __attribute__((__nonnull__))\n-    { return do_deallocate(__p, __bytes, __alignment); }\n-\n-    [[nodiscard]]\n-    bool\n-    is_equal(const memory_resource& __other) const noexcept\n-    { return do_is_equal(__other); }\n-\n-  private:\n-    virtual void*\n-    do_allocate(size_t __bytes, size_t __alignment) = 0;\n-\n-    virtual void\n-    do_deallocate(void* __p, size_t __bytes, size_t __alignment) = 0;\n-\n-    virtual bool\n-    do_is_equal(const memory_resource& __other) const noexcept = 0;\n-  };\n-\n-  [[nodiscard]]\n-  inline bool\n-  operator==(const memory_resource& __a, const memory_resource& __b) noexcept\n-  { return &__a == &__b || __a.is_equal(__b); }\n-\n-#if __cpp_impl_three_way_comparison < 201907L\n-  [[nodiscard]]\n-  inline bool\n-  operator!=(const memory_resource& __a, const memory_resource& __b) noexcept\n-  { return !(__a == __b); }\n-#endif\n-\n-  // C++17 23.12.3 Class template polymorphic_allocator\n-  template<typename _Tp>\n-    class polymorphic_allocator\n-    {\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 2975. Missing case for pair construction in polymorphic allocators\n-      template<typename _Up>\n-\tstruct __not_pair { using type = void; };\n-\n-      template<typename _Up1, typename _Up2>\n-\tstruct __not_pair<pair<_Up1, _Up2>> { };\n-\n-    public:\n-      using value_type = _Tp;\n-\n-      polymorphic_allocator() noexcept\n-      : _M_resource(get_default_resource())\n-      { }\n-\n-      polymorphic_allocator(memory_resource* __r) noexcept\n-      __attribute__((__nonnull__))\n-      : _M_resource(__r)\n-      { _GLIBCXX_DEBUG_ASSERT(__r); }\n-\n-      polymorphic_allocator(const polymorphic_allocator& __other) = default;\n-\n-      template<typename _Up>\n-\tpolymorphic_allocator(const polymorphic_allocator<_Up>& __x) noexcept\n-\t: _M_resource(__x.resource())\n-\t{ }\n-\n-      polymorphic_allocator&\n-      operator=(const polymorphic_allocator&) = delete;\n-\n-      [[nodiscard]]\n-      _Tp*\n-      allocate(size_t __n)\n-      __attribute__((__returns_nonnull__))\n-      {\n-\tif ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Tp)) < __n)\n-\t  std::__throw_bad_array_new_length();\n-\treturn static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),\n-\t\t\t\t\t\t       alignof(_Tp)));\n-      }\n-\n-      void\n-      deallocate(_Tp* __p, size_t __n) noexcept\n-      __attribute__((__nonnull__))\n-      { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }\n-\n-#if __cplusplus > 201703L\n-      [[nodiscard]] void*\n-      allocate_bytes(size_t __nbytes,\n-\t\t     size_t __alignment = alignof(max_align_t))\n-      { return _M_resource->allocate(__nbytes, __alignment); }\n-\n-      void\n-      deallocate_bytes(void* __p, size_t __nbytes,\n-\t\t       size_t __alignment = alignof(max_align_t))\n-      { _M_resource->deallocate(__p, __nbytes, __alignment); }\n-\n-      template<typename _Up>\n-\t[[nodiscard]] _Up*\n-\tallocate_object(size_t __n = 1)\n-\t{\n-\t  if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Up)) < __n)\n-\t    std::__throw_bad_array_new_length();\n-\t  return static_cast<_Up*>(allocate_bytes(__n * sizeof(_Up),\n-\t\t\t\t\t\t  alignof(_Up)));\n-\t}\n-\n-      template<typename _Up>\n-\tvoid\n-\tdeallocate_object(_Up* __p, size_t __n = 1)\n-\t{ deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up)); }\n-\n-      template<typename _Up, typename... _CtorArgs>\n-\t[[nodiscard]] _Up*\n-\tnew_object(_CtorArgs&&... __ctor_args)\n-\t{\n-\t  _Up* __p = allocate_object<_Up>();\n-\t  __try\n-\t    {\n-\t      construct(__p, std::forward<_CtorArgs>(__ctor_args)...);\n-\t    }\n-\t  __catch (...)\n-\t    {\n-\t      deallocate_object(__p);\n-\t      __throw_exception_again;\n-\t    }\n-\t  return __p;\n-\t}\n-\n-      template<typename _Up>\n-\tvoid\n-\tdelete_object(_Up* __p)\n-\t{\n-\t  __p->~_Up();\n-\t  deallocate_object(__p);\n-\t}\n-#endif // C++2a\n-\n-#if ! __cpp_lib_make_obj_using_allocator\n-      template<typename _Tp1, typename... _Args>\n-\t__attribute__((__nonnull__))\n-\ttypename __not_pair<_Tp1>::type\n-\tconstruct(_Tp1* __p, _Args&&... __args)\n-\t{\n-\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t  // 2969. polymorphic_allocator::construct() shouldn't pass resource()\n-\t  using __use_tag\n-\t    = std::__uses_alloc_t<_Tp1, polymorphic_allocator, _Args...>;\n-\t  if constexpr (is_base_of_v<__uses_alloc0, __use_tag>)\n-\t    ::new(__p) _Tp1(std::forward<_Args>(__args)...);\n-\t  else if constexpr (is_base_of_v<__uses_alloc1_, __use_tag>)\n-\t    ::new(__p) _Tp1(allocator_arg, *this,\n-\t\t\t    std::forward<_Args>(__args)...);\n-\t  else\n-\t    ::new(__p) _Tp1(std::forward<_Args>(__args)..., *this);\n-\t}\n-\n-      template<typename _Tp1, typename _Tp2,\n-\t       typename... _Args1, typename... _Args2>\n-\t__attribute__((__nonnull__))\n-\tvoid\n-\tconstruct(pair<_Tp1, _Tp2>* __p, piecewise_construct_t,\n-\t\t  tuple<_Args1...> __x, tuple<_Args2...> __y)\n-\t{\n-\t  auto __x_tag =\n-\t    __use_alloc<_Tp1, polymorphic_allocator, _Args1...>(*this);\n-\t  auto __y_tag =\n-\t    __use_alloc<_Tp2, polymorphic_allocator, _Args2...>(*this);\n-\t  index_sequence_for<_Args1...> __x_i;\n-\t  index_sequence_for<_Args2...> __y_i;\n-\n-\t  ::new(__p) pair<_Tp1, _Tp2>(piecewise_construct,\n-\t\t\t\t      _S_construct_p(__x_tag, __x_i, __x),\n-\t\t\t\t      _S_construct_p(__y_tag, __y_i, __y));\n-\t}\n-\n-      template<typename _Tp1, typename _Tp2>\n-\t__attribute__((__nonnull__))\n-\tvoid\n-\tconstruct(pair<_Tp1, _Tp2>* __p)\n-\t{ this->construct(__p, piecewise_construct, tuple<>(), tuple<>()); }\n-\n-      template<typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n-\t__attribute__((__nonnull__))\n-\tvoid\n-\tconstruct(pair<_Tp1, _Tp2>* __p, _Up&& __x, _Vp&& __y)\n-\t{\n-\t  this->construct(__p, piecewise_construct,\n-\t      std::forward_as_tuple(std::forward<_Up>(__x)),\n-\t      std::forward_as_tuple(std::forward<_Vp>(__y)));\n-\t}\n-\n-      template <typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n-\t__attribute__((__nonnull__))\n-\tvoid\n-\tconstruct(pair<_Tp1, _Tp2>* __p, const std::pair<_Up, _Vp>& __pr)\n-\t{\n-\t  this->construct(__p, piecewise_construct,\n-\t      std::forward_as_tuple(__pr.first),\n-\t      std::forward_as_tuple(__pr.second));\n-\t}\n-\n-      template<typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n-\t__attribute__((__nonnull__))\n-\tvoid\n-\tconstruct(pair<_Tp1, _Tp2>* __p, pair<_Up, _Vp>&& __pr)\n-\t{\n-\t  this->construct(__p, piecewise_construct,\n-\t      std::forward_as_tuple(std::forward<_Up>(__pr.first)),\n-\t      std::forward_as_tuple(std::forward<_Vp>(__pr.second)));\n-\t}\n-#else // make_obj_using_allocator\n-      template<typename _Tp1, typename... _Args>\n-\t__attribute__((__nonnull__))\n-\tvoid\n-\tconstruct(_Tp1* __p, _Args&&... __args)\n-\t{\n-\t  std::uninitialized_construct_using_allocator(__p, *this,\n-\t      std::forward<_Args>(__args)...);\n-\t}\n-#endif\n-\n-      template<typename _Up>\n-\t_GLIBCXX20_DEPRECATED_SUGGEST(\"allocator_traits::destroy\")\n-\t__attribute__((__nonnull__))\n-\tvoid\n-\tdestroy(_Up* __p)\n-\t{ __p->~_Up(); }\n-\n-      polymorphic_allocator\n-      select_on_container_copy_construction() const noexcept\n-      { return polymorphic_allocator(); }\n-\n-      memory_resource*\n-      resource() const noexcept\n-      __attribute__((__returns_nonnull__))\n-      { return _M_resource; }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 3683. operator== for polymorphic_allocator cannot deduce template arg\n-      [[nodiscard]]\n-      friend bool\n-      operator==(const polymorphic_allocator& __a,\n-\t\t const polymorphic_allocator& __b) noexcept\n-      { return *__a.resource() == *__b.resource(); }\n-\n-#if __cpp_impl_three_way_comparison < 201907L\n-      [[nodiscard]]\n-      friend bool\n-      operator!=(const polymorphic_allocator& __a,\n-\t\t const polymorphic_allocator& __b) noexcept\n-      { return !(__a == __b); }\n-#endif\n-\n-    private:\n-#if ! __cpp_lib_make_obj_using_allocator\n-      using __uses_alloc1_ = __uses_alloc1<polymorphic_allocator>;\n-      using __uses_alloc2_ = __uses_alloc2<polymorphic_allocator>;\n-\n-      template<typename _Ind, typename... _Args>\n-\tstatic tuple<_Args&&...>\n-\t_S_construct_p(__uses_alloc0, _Ind, tuple<_Args...>& __t)\n-\t{ return std::move(__t); }\n-\n-      template<size_t... _Ind, typename... _Args>\n-\tstatic tuple<allocator_arg_t, polymorphic_allocator, _Args&&...>\n-\t_S_construct_p(__uses_alloc1_ __ua, index_sequence<_Ind...>,\n-\t\t       tuple<_Args...>& __t)\n-\t{\n-\t  return {\n-\t      allocator_arg, *__ua._M_a, std::get<_Ind>(std::move(__t))...\n-\t  };\n-\t}\n-\n-      template<size_t... _Ind, typename... _Args>\n-\tstatic tuple<_Args&&..., polymorphic_allocator>\n-\t_S_construct_p(__uses_alloc2_ __ua, index_sequence<_Ind...>,\n-\t\t       tuple<_Args...>& __t)\n-\t{ return { std::get<_Ind>(std::move(__t))..., *__ua._M_a }; }\n-#endif\n-\n-      memory_resource* _M_resource;\n-    };\n-\n-  template<typename _Tp1, typename _Tp2>\n-    [[nodiscard]]\n-    inline bool\n-    operator==(const polymorphic_allocator<_Tp1>& __a,\n-\t       const polymorphic_allocator<_Tp2>& __b) noexcept\n-    { return *__a.resource() == *__b.resource(); }\n-\n-#if __cpp_impl_three_way_comparison < 201907L\n-  template<typename _Tp1, typename _Tp2>\n-    [[nodiscard]]\n-    inline bool\n-    operator!=(const polymorphic_allocator<_Tp1>& __a,\n-\t       const polymorphic_allocator<_Tp2>& __b) noexcept\n-    { return !(__a == __b); }\n-#endif\n-\n-} // namespace pmr\n-\n-  /// Partial specialization for std::pmr::polymorphic_allocator\n-  template<typename _Tp>\n-    struct allocator_traits<pmr::polymorphic_allocator<_Tp>>\n-    {\n-      /// The allocator type\n-      using allocator_type = pmr::polymorphic_allocator<_Tp>;\n-\n-      /// The allocated type\n-      using value_type = _Tp;\n-\n-      /// The allocator's pointer type.\n-      using pointer = _Tp*;\n-\n-      /// The allocator's const pointer type.\n-      using const_pointer = const _Tp*;\n-\n-      /// The allocator's void pointer type.\n-      using void_pointer = void*;\n-\n-      /// The allocator's const void pointer type.\n-      using const_void_pointer = const void*;\n-\n-      /// The allocator's difference type\n-      using difference_type = std::ptrdiff_t;\n-\n-      /// The allocator's size type\n-      using size_type = std::size_t;\n-\n-      /** @{\n-       * A `polymorphic_allocator` does not propagate when a\n-       * container is copied, moved, or swapped.\n-       */\n-      using propagate_on_container_copy_assignment = false_type;\n-      using propagate_on_container_move_assignment = false_type;\n-      using propagate_on_container_swap = false_type;\n-\n-      static allocator_type\n-      select_on_container_copy_construction(const allocator_type&) noexcept\n-      { return allocator_type(); }\n-      /// @}\n-\n-      /// Whether all instances of the allocator type compare equal.\n-      using is_always_equal = false_type;\n-\n-      template<typename _Up>\n-\tusing rebind_alloc = pmr::polymorphic_allocator<_Up>;\n-\n-      template<typename _Up>\n-\tusing rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;\n-\n-      /**\n-       *  @brief  Allocate memory.\n-       *  @param  __a  An allocator.\n-       *  @param  __n  The number of objects to allocate space for.\n-       *\n-       *  Calls `a.allocate(n)`.\n-      */\n-      [[nodiscard]] static pointer\n-      allocate(allocator_type& __a, size_type __n)\n-      { return __a.allocate(__n); }\n-\n-      /**\n-       *  @brief  Allocate memory.\n-       *  @param  __a  An allocator.\n-       *  @param  __n  The number of objects to allocate space for.\n-       *  @return Memory of suitable size and alignment for `n` objects\n-       *          of type `value_type`.\n-       *\n-       *  The third parameter is ignored..\n-       *\n-       *  Returns `a.allocate(n)`.\n-      */\n-      [[nodiscard]] static pointer\n-      allocate(allocator_type& __a, size_type __n, const_void_pointer)\n-      { return __a.allocate(__n); }\n-\n-      /**\n-       *  @brief  Deallocate memory.\n-       *  @param  __a  An allocator.\n-       *  @param  __p  Pointer to the memory to deallocate.\n-       *  @param  __n  The number of objects space was allocated for.\n-       *\n-       *  Calls `a.deallocate(p, n)`.\n-      */\n-      static void\n-      deallocate(allocator_type& __a, pointer __p, size_type __n)\n-      { __a.deallocate(__p, __n); }\n-\n-      /**\n-       *  @brief  Construct an object of type `_Up`\n-       *  @param  __a  An allocator.\n-       *  @param  __p  Pointer to memory of suitable size and alignment for\n-       *\t       an object of type `_Up`.\n-       *  @param  __args Constructor arguments.\n-       *\n-       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`\n-       *  in C++11, C++14 and C++17. Changed in C++20 to call\n-       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.\n-      */\n-      template<typename _Up, typename... _Args>\n-\tstatic void\n-\tconstruct(allocator_type& __a, _Up* __p, _Args&&... __args)\n-\t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n-\n-      /**\n-       *  @brief  Destroy an object of type `_Up`\n-       *  @param  __a  An allocator.\n-       *  @param  __p  Pointer to the object to destroy\n-       *\n-       *  Calls `p->_Up()`.\n-      */\n-      template<typename _Up>\n-\tstatic _GLIBCXX20_CONSTEXPR void\n-\tdestroy(allocator_type&, _Up* __p)\n-\tnoexcept(is_nothrow_destructible<_Up>::value)\n-\t{ __p->~_Up(); }\n-\n-      /**\n-       *  @brief  The maximum supported allocation size\n-       *  @return `numeric_limits<size_t>::max() / sizeof(value_type)`\n-      */\n-      static _GLIBCXX20_CONSTEXPR size_type\n-      max_size(const allocator_type&) noexcept\n-      { return size_t(-1) / sizeof(value_type); }\n-    };\n-\n-namespace pmr\n-{\n   /// Parameters for tuning a pool resource's behaviour.\n   struct pool_options\n   {"}, {"sha": "491bced23b5adc7179d331be3f89a24ad4ac032c", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -67,12 +67,12 @@\n #include <bits/regex_executor.h>\n \n #if __cplusplus >= 201703L && _GLIBCXX_USE_CXX11_ABI\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _BidirectionalIterator>\n       using match_results\n \t= std::match_results<_BidirectionalIterator, polymorphic_allocator<"}, {"sha": "551c77727f1066b24582f5fedcd32567424910c9", "filename": "libstdc++-v3/include/std/set", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -68,12 +68,12 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Key, typename _Cmp = std::less<_Key>>\n       using set = std::set<_Key, _Cmp, polymorphic_allocator<_Key>>;\n     template<typename _Key, typename _Cmp = std::less<_Key>>"}, {"sha": "1efaf253abb63d29e2128d4cc657302a4956a91e", "filename": "libstdc++-v3/include/std/stacktrace", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -33,6 +33,7 @@\n #include <new>\n #include <string>\n #include <sstream>\n+#include <bits/memory_resource.h>\n #include <bits/stl_algobase.h>\n #include <bits/stl_algo.h>\n #include <bits/stl_iterator.h>\n@@ -758,7 +759,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     using stacktrace\n       = basic_stacktrace<polymorphic_allocator<stacktrace_entry>>;\n   }"}, {"sha": "24051663f741e6eddae751f17c91dd24a9abd3ea", "filename": "libstdc++-v3/include/std/string", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -54,11 +54,11 @@\n #include <bits/basic_string.tcc>\n \n #if __cplusplus >= 201703L && _GLIBCXX_USE_CXX11_ABI\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _CharT, typename _Traits = char_traits<_CharT>>\n       using basic_string = std::basic_string<_CharT, _Traits,\n \t\t\t\t\t     polymorphic_allocator<_CharT>>;"}, {"sha": "e13bb9a21488b74a742ee1ad705daec4c43762da", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -53,12 +53,12 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Key, typename _Tp, typename _Hash = std::hash<_Key>,\n \t     typename _Pred = std::equal_to<_Key>>\n       using unordered_map"}, {"sha": "8b665718a83a488728de4aa7a97e2d58b2a8cc00", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -53,12 +53,12 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr\n   {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Key, typename _Hash = std::hash<_Key>,\n \t     typename _Pred = std::equal_to<_Key>>\n       using unordered_set"}, {"sha": "d7f69fd7a48bb7d7e51a01b2a6b9777c587792de", "filename": "libstdc++-v3/include/std/vector", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -75,11 +75,11 @@\n #endif\n \n #if __cplusplus >= 201703L\n+#include <bits/memory_resource.h>\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace pmr {\n-    template<typename _Tp> class polymorphic_allocator;\n     template<typename _Tp>\n       using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;\n   } // namespace pmr"}, {"sha": "cabe59090af47c3e72cde891d4047c3336c203f5", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/types/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Ftypes%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Ftypes%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Ftypes%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -19,7 +19,8 @@\n // { dg-require-effective-target cxx11_abi }\n \n #include <string>\n-#include <memory_resource>\n+\n+std::pmr::string s = \"polly\";\n \n struct T : std::char_traits<char> { };\n "}, {"sha": "c973d4f432c63fc49ef6d5267e4c9166a2775afa", "filename": "libstdc++-v3/testsuite/23_containers/deque/types/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Ftypes%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Ftypes%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Ftypes%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <deque>\n-#include <memory_resource>\n+\n+std::pmr::deque<int> c{1, 2, 3, 4};\n \n struct X { };\n "}, {"sha": "f66e53f62a866f59ca1d2269fc8f9e5425efc6b3", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <forward_list>\n-#include <memory_resource>\n+\n+std::pmr::forward_list<int> c{1, 2, 3, 4};\n \n struct X { };\n "}, {"sha": "3c5ef7947201455ae4474b867ee1b004a9268036", "filename": "libstdc++-v3/testsuite/23_containers/list/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <list>\n-#include <memory_resource>\n+\n+std::pmr::list<int> c{1, 2, 3, 4};\n \n struct X { };\n "}, {"sha": "91602ccbc17ec471bf8e631fc15785e7c6d1f4c7", "filename": "libstdc++-v3/testsuite/23_containers/map/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <map>\n-#include <memory_resource>\n+\n+std::pmr::map<int, int> c{{1,0}, {2,0}, {3,0}, {4,0}};\n \n struct X { };\n struct Y { };"}, {"sha": "13b0970a100630e773666929316035d4436b618f", "filename": "libstdc++-v3/testsuite/23_containers/multimap/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <map>\n-#include <memory_resource>\n+\n+std::pmr::multimap<int, int> c{{1,0}, {2,0}, {3,0}, {4,0}};\n \n struct X { };\n struct Y { };"}, {"sha": "f1013b6efdccb25303e880beb72fa9b6b61fc671", "filename": "libstdc++-v3/testsuite/23_containers/multiset/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <set>\n-#include <memory_resource>\n+\n+std::pmr::multiset<int> c{1, 2, 3, 4};\n \n struct X { };\n struct Cmp { bool operator()(X, X) const { return false; } };"}, {"sha": "4b70b984729adce2be96f7997c24fbb40ccc9d77", "filename": "libstdc++-v3/testsuite/23_containers/set/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <set>\n-#include <memory_resource>\n+\n+std::pmr::set<int> c{1, 2, 3, 4};\n \n struct X { };\n struct Cmp { bool operator()(X, X) const { return false; } };"}, {"sha": "d8e17139f05d9d4de9bf270197a7b79e2efce8b1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <unordered_map>\n-#include <memory_resource>\n+\n+std::pmr::unordered_map<int, int> c{{1,0}, {2,0}, {3,0}, {4,0}};\n \n struct X { };\n struct Y { };"}, {"sha": "6dfe1d5b8bd202e8887b2553ecf7fdca68315555", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <unordered_map>\n-#include <memory_resource>\n+\n+std::pmr::unordered_multimap<int, int> c{{1,0}, {2,0}, {3,0}, {4,0}};\n \n struct X { };\n struct Y { };"}, {"sha": "4deeb710686c4571da25c11bdaf847aa2c9e390e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <unordered_set>\n-#include <memory_resource>\n+\n+std::pmr::unordered_multiset<int> c{1, 2, 3, 4};\n \n struct X { };\n struct Hash { std::size_t operator()(X) const { return 0; } };"}, {"sha": "4736cfff86fd032d8f20517ec09eb8a37ca58d98", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <unordered_set>\n-#include <memory_resource>\n+\n+std::pmr::unordered_set<int> c{1, 2, 3, 4};\n \n struct X { };\n struct Hash { std::size_t operator()(X) const { return 0; } };"}, {"sha": "f4969e3364e6d7aa98e3fe1a9e90cdc0d9e3f618", "filename": "libstdc++-v3/testsuite/23_containers/vector/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -18,7 +18,8 @@\n // { dg-do compile { target c++17 } }\n \n #include <vector>\n-#include <memory_resource>\n+\n+std::pmr::vector<int> c{1, 2, 3, 4};\n \n struct X { };\n "}, {"sha": "5ff4c771a6c31b4f9cc314f3c9d085f616db365c", "filename": "libstdc++-v3/testsuite/28_regex/match_results/pmr_typedefs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fmatch_results%2Fpmr_typedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fmatch_results%2Fpmr_typedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fmatch_results%2Fpmr_typedefs.cc?ref=8ccdc7ce33f5e7ca509e5b9f835ed4719db21ffd", "patch": "@@ -20,7 +20,8 @@\n // { dg-require-effective-target cxx11_abi }\n \n #include <regex>\n-#include <memory_resource>\n+\n+std::pmr::match_results<const char*> m;\n \n struct X;\n static_assert(std::is_same_v<std::pmr::match_results<X*>,"}]}