{"sha": "704e8a825c78b9a8424c291509413bbb48e602c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA0ZThhODI1Yzc4YjlhODQyNGMyOTE1MDk0MTNiYmI0OGU2MDJjNw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-07-16T15:42:14Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-07-17T00:27:10Z"}, "message": "Add wi_fold_in_parts.\n\nrange-ops uses wi_fold to individually fold subranges one at a time and\nthen combined them.  This patch first calls wi_fold_in_parts which checks if\none of the subranges is small, and if so, further splits that subrange\ninto constants.\n\n\tgcc/\n\tPR tree-optimization/96542\n\t* range-op.cc (range_operator::wi_fold_in_parts): New.\n\t(range_operator::fold_range): Call wi_fold_in_parts.\n\t(operator_lshift::wi_fold): Fix broken lshift by [0,0].\n\t* range-op.h (wi_fold_in_parts): Add prototype.\n\n\tgcc/testsuite\n\t* gcc.dg/pr96542.c: New.", "tree": {"sha": "8f2b7e49da176c3ec9af9b0124e45dda8e1dca1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f2b7e49da176c3ec9af9b0124e45dda8e1dca1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/704e8a825c78b9a8424c291509413bbb48e602c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704e8a825c78b9a8424c291509413bbb48e602c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/704e8a825c78b9a8424c291509413bbb48e602c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704e8a825c78b9a8424c291509413bbb48e602c7/comments", "author": null, "committer": null, "parents": [{"sha": "87277b6a04486b606761b86dbcfbc9a4b6871f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87277b6a04486b606761b86dbcfbc9a4b6871f4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87277b6a04486b606761b86dbcfbc9a4b6871f4c"}], "stats": {"total": 108, "additions": 103, "deletions": 5}, "files": [{"sha": "e0be51dbc906a71e40b9192a85f4b762ce6ce229", "filename": "gcc/range-op.cc", "status": "modified", "additions": 70, "deletions": 5, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704e8a825c78b9a8424c291509413bbb48e602c7/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704e8a825c78b9a8424c291509413bbb48e602c7/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=704e8a825c78b9a8424c291509413bbb48e602c7", "patch": "@@ -133,6 +133,65 @@ range_operator::wi_fold (irange &r, tree type,\n   r.set_varying (type);\n }\n \n+// Call wi_fold, except further split small subranges into constants.\n+// This can provide better precision. For something   8 >> [0,1]\n+// Instead of [8, 16], we will produce [8,8][16,16]\n+\n+void\n+range_operator::wi_fold_in_parts (irange &r, tree type,\n+\t\t\t\t  const wide_int &lh_lb,\n+\t\t\t\t  const wide_int &lh_ub,\n+\t\t\t\t  const wide_int &rh_lb,\n+\t\t\t\t  const wide_int &rh_ub) const\n+{\n+  wi::overflow_type ov_rh, ov_lh;\n+  int_range_max tmp;\n+  wide_int rh_range = wi::sub (rh_ub, rh_lb, TYPE_SIGN (type), &ov_rh);\n+  wide_int lh_range = wi::sub (lh_ub, lh_lb, TYPE_SIGN (type), &ov_lh);\n+  signop sign = TYPE_SIGN (type);;\n+  // If there are 2, 3, or 4 values in the RH range, do them separately.\n+  // Call wi_fold_in_parts to check the RH side.\n+  if (wi::gt_p (rh_range, 0, sign) && wi::lt_p (rh_range, 4, sign)\n+      && ov_rh == wi::OVF_NONE)\n+    {\n+      wi_fold_in_parts (r, type, lh_lb, lh_ub, rh_lb, rh_lb);\n+      if (wi::gt_p (rh_range, 1, sign))\n+\t{\n+\t  wi_fold_in_parts (tmp, type, lh_lb, lh_ub, rh_lb + 1, rh_lb + 1);\n+\t  r.union_ (tmp);\n+\t  if (wi::eq_p (rh_range, 3))\n+\t    {\n+\t      wi_fold_in_parts (tmp, type, lh_lb, lh_ub, rh_lb + 2, rh_lb + 2);\n+\t      r.union_ (tmp);\n+\t    }\n+\t}\n+      wi_fold_in_parts (tmp, type, lh_lb, lh_ub, rh_ub, rh_ub);\n+      r.union_ (tmp);\n+    }\n+  // Otherise check for 2, 3, or 4 values in the LH range and split them up.\n+  // The RH side has been checked, so no recursion needed.\n+  else if (wi::gt_p (lh_range, 0, sign) && wi::lt_p (lh_range, 4, sign)\n+\t   && ov_lh == wi::OVF_NONE)\n+    {\n+      wi_fold (r, type, lh_lb, lh_lb, rh_lb, rh_ub);\n+      if (wi::gt_p (lh_range, 1, sign))\n+\t{\n+\t  wi_fold (tmp, type, lh_lb + 1, lh_lb + 1, rh_lb, rh_ub);\n+\t  r.union_ (tmp);\n+\t  if (wi::eq_p (lh_range, 3))\n+\t    {\n+\t      wi_fold (tmp, type, lh_lb + 2, lh_lb + 2, rh_lb, rh_ub);\n+\t      r.union_ (tmp);\n+\t    }\n+\t}\n+      wi_fold (tmp, type, lh_ub, lh_ub, rh_lb, rh_ub);\n+      r.union_ (tmp);\n+    }\n+  // Otherwise just call wi_fold.\n+  else\n+    wi_fold (r, type, lh_lb, lh_ub, rh_lb, rh_ub);\n+}\n+\n // The default for fold is to break all ranges into sub-ranges and\n // invoke the wi_fold method on each sub-range pair.\n \n@@ -152,8 +211,8 @@ range_operator::fold_range (irange &r, tree type,\n   // If both ranges are single pairs, fold directly into the result range.\n   if (num_lh == 1 && num_rh == 1)\n     {\n-      wi_fold (r, type, lh.lower_bound (0), lh.upper_bound (0),\n-\t       rh.lower_bound (0), rh.upper_bound (0));\n+      wi_fold_in_parts (r, type, lh.lower_bound (0), lh.upper_bound (0),\n+\t\t\trh.lower_bound (0), rh.upper_bound (0));\n       op1_op2_relation_effect (r, type, lh, rh, rel);\n       return true;\n     }\n@@ -167,7 +226,7 @@ range_operator::fold_range (irange &r, tree type,\n \twide_int lh_ub = lh.upper_bound (x);\n \twide_int rh_lb = rh.lower_bound (y);\n \twide_int rh_ub = rh.upper_bound (y);\n-\twi_fold (tmp, type, lh_lb, lh_ub, rh_lb, rh_ub);\n+\twi_fold_in_parts (tmp, type, lh_lb, lh_ub, rh_lb, rh_ub);\n \tr.union_ (tmp);\n \tif (r.varying_p ())\n \t  {\n@@ -1915,8 +1974,14 @@ operator_lshift::wi_fold (irange &r, tree type,\n   int bound_shift = overflow_pos - rh_ub.to_shwi ();\n   // If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can\n   // overflow.  However, for that to happen, rh.max needs to be zero,\n-  // which means rh is a singleton range of zero, which means it\n-  // should be handled by the lshift fold_range above.\n+  // which means rh is a singleton range of zero, which means we simply return\n+  // [lh_lb, lh_ub] as the range.\n+  if (wi::eq_p (rh_ub, rh_lb) && wi::eq_p (rh_ub, 0))\n+    {\n+      r = int_range<2> (type, lh_lb, lh_ub);\n+      return;\n+    }\n+\n   wide_int bound = wi::set_bit_in_zero (bound_shift, prec);\n   wide_int complement = ~(bound - 1);\n   wide_int low_bound, high_bound;"}, {"sha": "17be9e00c08ec04ad28988c120fb426bbfb35994", "filename": "gcc/range-op.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704e8a825c78b9a8424c291509413bbb48e602c7/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704e8a825c78b9a8424c291509413bbb48e602c7/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=704e8a825c78b9a8424c291509413bbb48e602c7", "patch": "@@ -97,6 +97,12 @@ class range_operator\n \t\t\t\t\tconst irange &op1_range,\n \t\t\t\t\tconst irange &op2_range,\n \t\t\t\t\trelation_kind rel) const;\n+  // Called by fold range to split small subranges into parts.\n+  void wi_fold_in_parts (irange &r, tree type,\n+\t\t\t const wide_int &lh_lb,\n+\t\t\t const wide_int &lh_ub,\n+\t\t\t const wide_int &rh_lb,\n+\t\t\t const wide_int &rh_ub) const;\n };\n \n extern range_operator *range_op_handler (enum tree_code code, tree type);"}, {"sha": "5014f2acad8348368335bd1ecb425947afe6a494", "filename": "gcc/testsuite/gcc.dg/pr96542.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704e8a825c78b9a8424c291509413bbb48e602c7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96542.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704e8a825c78b9a8424c291509413bbb48e602c7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96542.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96542.c?ref=704e8a825c78b9a8424c291509413bbb48e602c7", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile} */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+\n+unsigned char\n+foo (unsigned int x)\n+{\n+  _Bool y = x;\n+  return (((unsigned char) ~0) >> y) * 2;\n+}\n+\n+unsigned char\n+bar (unsigned int x)\n+{\n+  return (((unsigned char) ~0) >> (_Bool) x) * 2;\n+}\n+\n+unsigned\n+baz (unsigned int x)\n+{\n+  if (x >= 4) return 32;\n+  return (-1U >> x) * 16;\n+}\n+\n+/* { dg-final { scan-tree-dump-times  \"254\" 2 \"evrp\" } }  */\n+/* { dg-final { scan-tree-dump \"= PHI <32.*, 4294967280\" \"evrp\" } }  */\n+"}]}