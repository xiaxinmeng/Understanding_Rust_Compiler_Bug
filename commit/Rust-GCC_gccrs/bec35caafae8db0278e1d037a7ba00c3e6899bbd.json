{"sha": "bec35caafae8db0278e1d037a7ba00c3e6899bbd", "node_id": "C_kwDOANBUbNoAKGJlYzM1Y2FhZmFlOGRiMDI3OGUxZDAzN2E3YmEwMGMzZTY4OTliYmQ", "commit": {"author": {"name": "Surya Kumari Jangala", "email": "jskumari@linux.ibm.com", "date": "2022-08-03T04:00:03Z"}, "committer": {"name": "Surya Kumari Jangala", "email": "jskumari@linux.ibm.com", "date": "2022-09-07T15:22:35Z"}, "message": "sched1: Fix -fcompare-debug issue in schedule_region [PR105586]\n\nIn schedule_region(), a basic block that does not contain any real insns\nis not scheduled and the dfa state at the entry of the bb is not copied\nto the fallthru basic block. However a DEBUG insn is treated as a real\ninsn, and if a bb contains non-real insns and a DEBUG insn, it's dfa\nstate is copied to the fallthru bb. This was resulting in\n-fcompare-debug failure as the incoming dfa state of the fallthru block\nis different with -g. We should always copy the dfa state of a bb to\nit's fallthru bb even if the bb does not contain real insns.\n\n2022-08-22  Surya Kumari Jangala  <jskumari@linux.ibm.com>\n\ngcc/\n\tPR rtl-optimization/105586\n\t* sched-rgn.cc (save_state_for_fallthru_edge): New function.\n\t(schedule_region): Use it for all blocks.\n\ngcc/testsuite/\n\tPR rtl-optimization/105586\n\t* gcc.target/powerpc/pr105586.c: New test.", "tree": {"sha": "f1da05c5fb744751d006f6dd4f0f1039046c779f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1da05c5fb744751d006f6dd4f0f1039046c779f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bec35caafae8db0278e1d037a7ba00c3e6899bbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec35caafae8db0278e1d037a7ba00c3e6899bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec35caafae8db0278e1d037a7ba00c3e6899bbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec35caafae8db0278e1d037a7ba00c3e6899bbd/comments", "author": null, "committer": null, "parents": [{"sha": "a961ad1b13b9c294d4565344912b8e35ba71b369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a961ad1b13b9c294d4565344912b8e35ba71b369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a961ad1b13b9c294d4565344912b8e35ba71b369"}], "stats": {"total": 56, "additions": 42, "deletions": 14}, "files": [{"sha": "420c45dffb46013f6df4259c4276b6674392550b", "filename": "gcc/sched-rgn.cc", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec35caafae8db0278e1d037a7ba00c3e6899bbd/gcc%2Fsched-rgn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec35caafae8db0278e1d037a7ba00c3e6899bbd/gcc%2Fsched-rgn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.cc?ref=bec35caafae8db0278e1d037a7ba00c3e6899bbd", "patch": "@@ -3082,6 +3082,27 @@ free_bb_state_array (void)\n   bb_state = NULL;\n }\n \n+/* If LAST_BB falls through to another block B, record that B should\n+   start with DFA start STATE.  */\n+\n+static void\n+save_state_for_fallthru_edge (basic_block last_bb, state_t state)\n+{\n+  edge f = find_fallthru_edge (last_bb->succs);\n+  if (f\n+      && (!f->probability.initialized_p ()\n+\t  || (f->probability.to_reg_br_prob_base () * 100\n+\t      / REG_BR_PROB_BASE\n+\t      >= param_sched_state_edge_prob_cutoff)))\n+  {\n+    memcpy (bb_state[f->dest->index], state,\n+\t    dfa_state_size);\n+    if (sched_verbose >= 5)\n+      fprintf (sched_dump, \"saving state for edge %d->%d\\n\",\n+\t       f->src->index, f->dest->index);\n+  }\n+}\n+\n /* Schedule a region.  A region is either an inner loop, a loop-free\n    subroutine, or a single basic block.  Each bb in the region is\n    scheduled after its flow predecessors.  */\n@@ -3155,6 +3176,7 @@ schedule_region (int rgn)\n       if (no_real_insns_p (head, tail))\n \t{\n \t  gcc_assert (first_bb == last_bb);\n+\t  save_state_for_fallthru_edge (last_bb, bb_state[first_bb->index]);\n \t  continue;\n \t}\n \n@@ -3173,26 +3195,13 @@ schedule_region (int rgn)\n       curr_bb = first_bb;\n       if (dbg_cnt (sched_block))\n         {\n-\t  edge f;\n \t  int saved_last_basic_block = last_basic_block_for_fn (cfun);\n \n \t  schedule_block (&curr_bb, bb_state[first_bb->index]);\n \t  gcc_assert (EBB_FIRST_BB (bb) == first_bb);\n \t  sched_rgn_n_insns += sched_n_insns;\n \t  realloc_bb_state_array (saved_last_basic_block);\n-\t  f = find_fallthru_edge (last_bb->succs);\n-\t  if (f\n-\t      && (!f->probability.initialized_p ()\n-\t\t  || (f->probability.to_reg_br_prob_base () * 100\n-\t\t      / REG_BR_PROB_BASE\n-\t\t      >= param_sched_state_edge_prob_cutoff)))\n-\t    {\n-\t      memcpy (bb_state[f->dest->index], curr_state,\n-\t\t      dfa_state_size);\n-\t      if (sched_verbose >= 5)\n-\t\tfprintf (sched_dump, \"saving state for edge %d->%d\\n\",\n-\t\t\t f->src->index, f->dest->index);\n-\t    }\n+\t  save_state_for_fallthru_edge (last_bb, curr_state);\n         }\n       else\n         {"}, {"sha": "bd397f58bc05ec0171eb0940544bf45fee2d76f3", "filename": "gcc/testsuite/gcc.target/powerpc/pr105586.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec35caafae8db0278e1d037a7ba00c3e6899bbd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr105586.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec35caafae8db0278e1d037a7ba00c3e6899bbd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr105586.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr105586.c?ref=bec35caafae8db0278e1d037a7ba00c3e6899bbd", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-mdejagnu-tune=power4 -O2 -fcompare-debug -fno-if-conversion -fno-guess-branch-probability\" } */\n+\n+extern int bar(int i);\n+\n+typedef unsigned long u64;\n+int g;\n+\n+__int128 h;\n+\n+void\n+foo(int a, int b) {\n+  int i;\n+  char u8_1 = g, u8_3 = a;\n+  u64 u64_1 = bar(0), u64_3 = u8_3 * u64_1;\n+  __int128 u128_1 = h ^ __builtin_expect(i, 0);\n+  u64 u64_4 = u64_1 << ((__builtin_sub_overflow_p(0, u8_1, (u64)0) ^ u128_1) & 8);\n+  u64 u64_r = b + u64_3 + u64_4;\n+  bar((short)u64_r + u8_3);\n+}"}]}