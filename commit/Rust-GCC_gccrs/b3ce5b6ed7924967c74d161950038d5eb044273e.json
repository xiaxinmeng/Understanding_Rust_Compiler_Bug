{"sha": "b3ce5b6ed7924967c74d161950038d5eb044273e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjZTViNmVkNzkyNDk2N2M3NGQxNjE5NTAwMzhkNWViMDQ0MjczZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-03-14T00:38:34Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-03-14T00:38:34Z"}, "message": "re PR tree-optimization/30730 (-Wunsafe-loop-optimizations gives too many warnings)\n\n\tPR tree-optimization/30730\n\tPR tree-optimization/26900\n\t* tree-ssa-loop-niter.c: Include gmp.h.\n\t(bounds): New type.\n\t(mpz_set_double_int, get_type_bounds, mpz_to_double_int,\n\tsplit_to_var_and_offset, determine_value_range,\n\tbound_difference_of_offsetted_base, refine_bounds_using_guard,\n\tbound_difference, bounds_add, bounds_negate,\n\tnumber_of_iterations_ne_max, dump_affine_iv): New functions.\n\t(number_of_iterations_ne, number_of_iterations_lt_to_ne,\n\tassert_loop_rolls_lt, assert_loop_rolls_le): Use bounds on the\n\tdifference of initial and final value of control iv to validate\n\tresults.\n\t(number_of_iterations_cond): Add loop parameter.  Determine bounds\n\ton the difference of the extremes of the control iv.  Add dumps.\n\t(expand_simple_operations): Handle phi nodes.\n\t(simplify_using_initial_conditions): Do not record used conditions.\n\t(number_of_iterations_exit): Pass loop to number_of_iterations_cond.\n\tDo not set additional_info.\n\t(implies_nonnegative_p, implies_ge_p): Removed.\n\t(derive_constant_upper_bound): Do not use parameter `additional'.\n\t(record_estimate): Parameter `additional' removed.  Parameter\n\t`i_bound' added.  Do not call derive_constant_upper_bound.\n\t(record_nonwrapping_iv): Use derive_constant_upper_bound to\n\tbound the number of iterations estimate.\n\t(estimate_numbers_of_iterations_loop): Pass the estimate from\n\tthe number of iterations analysis to record_estimate.\n\t* tree.h (multiple_of_p): Declare.\n\t* tree-scalar-evolution.c (expression_expensive_p): Removed.\n\t(scev_const_prop): Do not check expression_expensive_p.\n\t* fold-const.c (multiple_of_p): Exported.\n\t* double-int.c (double_int_mask): Exported.\n\t* double-int.h (double_int_mask): Declare.\n\t* tree-flow.h (struct tree_niter_desc): Removed additional_info\n\tfield.  Added max field.\n\n\t* gcc.dg/tree-ssa/loop-26.c: New test.\n\nFrom-SVN: r122896", "tree": {"sha": "bf5bf3bffd54164948533f0f4a35ee7c79aaffd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf5bf3bffd54164948533f0f4a35ee7c79aaffd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3ce5b6ed7924967c74d161950038d5eb044273e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ce5b6ed7924967c74d161950038d5eb044273e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ce5b6ed7924967c74d161950038d5eb044273e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ce5b6ed7924967c74d161950038d5eb044273e/comments", "author": null, "committer": null, "parents": [{"sha": "ec34c4e4c0e8227b1b741028248228354eccfdba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec34c4e4c0e8227b1b741028248228354eccfdba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec34c4e4c0e8227b1b741028248228354eccfdba"}], "stats": {"total": 1084, "additions": 919, "deletions": 165}, "files": [{"sha": "1a40c6f846e3e86401edd982deb2944cc0ad9c3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -1,3 +1,41 @@\n+2007-03-13  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/30730\n+\tPR tree-optimization/26900\n+\t* tree-ssa-loop-niter.c: Include gmp.h.\n+\t(bounds): New type.\n+\t(mpz_set_double_int, get_type_bounds, mpz_to_double_int,\n+\tsplit_to_var_and_offset, determine_value_range,\n+\tbound_difference_of_offsetted_base, refine_bounds_using_guard,\n+\tbound_difference, bounds_add, bounds_negate,\n+\tnumber_of_iterations_ne_max, dump_affine_iv): New functions.\n+\t(number_of_iterations_ne, number_of_iterations_lt_to_ne,\n+\tassert_loop_rolls_lt, assert_loop_rolls_le): Use bounds on the\n+\tdifference of initial and final value of control iv to validate\n+\tresults.\n+\t(number_of_iterations_cond): Add loop parameter.  Determine bounds\n+\ton the difference of the extremes of the control iv.  Add dumps.\n+\t(expand_simple_operations): Handle phi nodes.\n+\t(simplify_using_initial_conditions): Do not record used conditions.\n+\t(number_of_iterations_exit): Pass loop to number_of_iterations_cond.\n+\tDo not set additional_info.\n+\t(implies_nonnegative_p, implies_ge_p): Removed.\n+\t(derive_constant_upper_bound): Do not use parameter `additional'.\n+\t(record_estimate): Parameter `additional' removed.  Parameter\n+\t`i_bound' added.  Do not call derive_constant_upper_bound.\n+\t(record_nonwrapping_iv): Use derive_constant_upper_bound to\n+\tbound the number of iterations estimate.\n+\t(estimate_numbers_of_iterations_loop): Pass the estimate from\n+\tthe number of iterations analysis to record_estimate.\n+\t* tree.h (multiple_of_p): Declare.\n+\t* tree-scalar-evolution.c (expression_expensive_p): Removed.\n+\t(scev_const_prop): Do not check expression_expensive_p.\n+\t* fold-const.c (multiple_of_p): Exported.\n+\t* double-int.c (double_int_mask): Exported.\n+\t* double-int.h (double_int_mask): Declare.\n+\t* tree-flow.h (struct tree_niter_desc): Removed additional_info\n+\tfield.  Added max field.\n+\n 2007-03-13  David Taylor  <taylor@candd.org>\n \n \tPR driver/12448:"}, {"sha": "45a833a0654538c0f4caa39d70ddfc26393b8cda", "filename": "gcc/double-int.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -26,7 +26,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* Returns mask for PREC bits.  */\n \n-static inline double_int\n+double_int\n double_int_mask (unsigned prec)\n {\n   unsigned HOST_WIDE_INT m;"}, {"sha": "807166b89573455cb0a6aef2d9a0b6ba3099493e", "filename": "gcc/double-int.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -134,6 +134,7 @@ void dump_double_int (FILE *, double_int, bool);\n double_int double_int_ext (double_int, unsigned, bool);\n double_int double_int_sext (double_int, unsigned);\n double_int double_int_zext (double_int, unsigned);\n+double_int double_int_mask (unsigned);\n \n #define ALL_ONES (~((unsigned HOST_WIDE_INT) 0))\n "}, {"sha": "c0358cfc826d7eb2627de9b0eb3cb630d344e4a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -1,3 +1,7 @@\n+2007-03-13  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-26.c: New test.\n+\n 2007-03-13  Uros Bizjak  <ubizjak@gmail.com>\n \t\n \t* testsuite/gcc.target/i386/cmpxchg16b-1.c: New test.\n@@ -10,13 +14,13 @@\n \n 2007-03-12  Seongbae Park <seongbae.park@gmail.com>\n \n- \t* gcc.dg/wvla-1.c: New test\n- \t* gcc.dg/wvla-2.c: New test\n- \t* gcc.dg/wvla-3.c: New test\n- \t* gcc.dg/wvla-4.c: New test\n- \t* gcc.dg/wvla-5.c: New test\n- \t* gcc.dg/wvla-6.c: New test\n- \t* gcc.dg/wvla-7.c: New test\n+\t* gcc.dg/wvla-1.c: New test\n+\t* gcc.dg/wvla-2.c: New test\n+\t* gcc.dg/wvla-3.c: New test\n+\t* gcc.dg/wvla-4.c: New test\n+\t* gcc.dg/wvla-5.c: New test\n+\t* gcc.dg/wvla-6.c: New test\n+\t* gcc.dg/wvla-7.c: New test\n \t* g++.dg/warn/Wvla-1.C: New test\n \t* g++.dg/warn/Wvla-2.C: New test\n \t* g++.dg/warn/Wvla-3.C: New test"}, {"sha": "5ebb3b1e1f7726bba9c34b3addadfab2057f27c1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-26.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-26.c?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -0,0 +1,29 @@\n+/* PR 30730, PR 26900, number of iterations analysis should be able to\n+   determine number of iterations of the following loops unconditionally.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fstrict-overflow -fdump-tree-empty\" } */\n+\n+unsigned foo(unsigned int n)\n+{\n+  unsigned x = 0;;\n+\n+  while (n > 10)\n+    {\n+      n -= 2;\n+      x++;\n+    }\n+\n+  return x;\n+}\n+\n+int foo0(int i0, int i1)\n+{\n+  int i, j = 0;\n+  for (i=i0; i<=i1+1; ++i)\n+    ++j;\n+  return j;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Removing empty loop\" 2 \"empty\" } } */\n+/* { dg-final { cleanup-tree-dump \"empty\" } } */"}, {"sha": "ea2d677be43ace48f544ad53703410c95b670940", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -822,18 +822,8 @@ struct tree_niter_desc\n \t\t\t   a loop (provided that assumptions == true and\n \t\t\t   may_be_zero == false), more precisely the number\n \t\t\t   of executions of the latch of the loop.  */\n-  tree additional_info;\t/* The boolean expression.  Sometimes we use additional\n-\t\t\t   knowledge to simplify the other expressions\n-\t\t\t   contained in this structure (for example the\n-\t\t\t   knowledge about value ranges of operands on entry to\n-\t\t\t   the loop).  If this is a case, conjunction of such\n-\t\t\t   condition is stored in this field, so that we do not\n-\t\t\t   lose the information: for example if may_be_zero\n-\t\t\t   is (n <= 0) and niter is (unsigned) n, we know\n-\t\t\t   that the number of iterations is at most\n-\t\t\t   MAX_SIGNED_INT.  However if the (n <= 0) assumption\n-\t\t\t   is eliminated (by looking at the guard on entry of\n-\t\t\t   the loop), then the information would be lost.  */\n+  double_int max;\t/* The upper bound on the number of iterations of\n+\t\t\t   the loop.  */\n \n   /* The simplified shape of the exit condition.  The loop exits if\n      CONTROL CMP BOUND is false, where CMP is one of NE_EXPR,"}, {"sha": "846d27414d50ac72a63ffd6a741956ec2f4cba5a", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -2864,14 +2864,6 @@ scev_finalize (void)\n   BITMAP_FREE (already_instantiated);\n }\n \n-/* Returns true if EXPR looks expensive.  */\n-\n-static bool\n-expression_expensive_p (tree expr)\n-{\n-  return force_expr_to_var_cost (expr) >= target_spill_cost;\n-}\n-\n /* Replace ssa names for that scev can prove they are constant by the\n    appropriate constants.  Also perform final value replacement in loops,\n    in case the replacement expressions are cheap.\n@@ -2958,10 +2950,13 @@ scev_const_prop (void)\n \tcontinue;\n \n       niter = number_of_latch_executions (loop);\n-      if (niter == chrec_dont_know\n-\t  /* If computing the number of iterations is expensive, it may be\n-\t     better not to introduce computations involving it.  */\n-\t  || expression_expensive_p (niter))\n+      /* We used to check here whether the computation of NITER is expensive,\n+\t and avoided final value elimination if that is the case.  The problem\n+\t is that it is hard to evaluate whether the expression is too\n+\t expensive, as we do not know what optimization opportunities the\n+\t the elimination of the final value may reveal.  Therefore, we now\n+\t eliminate the final values of induction variables unconditionally.  */\n+      if (niter == chrec_dont_know)\n \tcontinue;\n \n       /* Ensure that it is possible to insert new statements somewhere.  */"}, {"sha": "f105d2b636eee5d374adcfdf19bf1b193fdbd057", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 829, "deletions": 133, "changes": 962, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -42,16 +42,507 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"tree-inline.h\"\n+#include \"gmp.h\"\n \n #define SWAP(X, Y) do { void *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n \n+/* The maximum number of dominator BBs we search for conditions\n+   of loop header copies we use for simplifying a conditional\n+   expression.  */\n+#define MAX_DOMINATORS_TO_WALK 8\n \n /*\n \n    Analysis of number of iterations of an affine exit test.\n \n */\n \n+/* Bounds on some value, BELOW <= X <= UP.  */\n+\n+typedef struct\n+{\n+  mpz_t below, up;\n+} bounds;\n+\n+/* Sets RESULT to VAL, taken unsigned if UNS is true and as signed\n+   otherwise.  */\n+\n+static void\n+mpz_set_double_int (mpz_t result, double_int val, bool uns)\n+{\n+  bool negate = false;\n+  unsigned HOST_WIDE_INT vp[2];\n+\n+  if (!uns && double_int_negative_p (val))\n+    {\n+      negate = true;\n+      val = double_int_neg (val);\n+    }\n+\n+  vp[0] = val.low;\n+  vp[1] = (unsigned HOST_WIDE_INT) val.high;\n+  mpz_import (result, 2, -1, sizeof (HOST_WIDE_INT), 0, 0, vp);\n+\n+  if (negate)\n+    mpz_neg (result, result);\n+}\n+\n+/* Stores bounds of TYPE to MIN and MAX.  */\n+\n+static void\n+get_type_bounds (tree type, mpz_t min, mpz_t max)\n+{\n+  if (TYPE_UNSIGNED (type))\n+    {\n+      mpz_set_ui (min, 0);\n+      mpz_set_double_int (max, double_int_mask (TYPE_PRECISION (type)), true);\n+    }\n+  else\n+    {\n+      double_int mx, mn;\n+      \n+      mx = double_int_mask (TYPE_PRECISION (type) - 1);\n+      mn = double_int_sext (double_int_add (mx, double_int_one),\n+\t\t\t    TYPE_PRECISION (type));\n+      mpz_set_double_int (max, mx, true);\n+      mpz_set_double_int (min, mn, false);\n+    }\n+}\n+\n+/* Returns VAL converted to TYPE.  If VAL does not fit in TYPE,\n+   the minimum or maximum value of the type is returned instead.  */\n+\n+static double_int\n+mpz_to_double_int (tree type, mpz_t val)\n+{\n+  mpz_t min, max;\n+  unsigned HOST_WIDE_INT vp[2];\n+  bool negate = false;\n+  size_t count;\n+  double_int res;\n+\n+  mpz_init (min);\n+  mpz_init (max);\n+  get_type_bounds (type, min, max);\n+\n+  if (mpz_cmp (val, min) < 0)\n+    mpz_set (val, min);\n+  else if (mpz_cmp (val, max) > 0)\n+    mpz_set (val, max);\n+\n+  if (mpz_sgn (val) < 0)\n+    negate = true;\n+\n+  vp[0] = 0;\n+  vp[1] = 0;\n+  mpz_export (vp, &count, -1, sizeof (HOST_WIDE_INT), 0, 0, val);\n+  gcc_assert (count <= 2);\n+  \n+  mpz_clear (min);\n+  mpz_clear (max);\n+\n+  res.low = vp[0];\n+  res.high = (HOST_WIDE_INT) vp[1];\n+\n+  res = double_int_ext (res, TYPE_PRECISION (type), TYPE_UNSIGNED (type));\n+  if (negate)\n+    res = double_int_neg (res);\n+\n+  return res;\n+}\n+\n+/* Splits expression EXPR to a variable part VAR and constant OFFSET.  */\n+\n+static void\n+split_to_var_and_offset (tree expr, tree *var, mpz_t offset)\n+{\n+  tree type = TREE_TYPE (expr);\n+  tree op0, op1;\n+  double_int off;\n+  bool negate = false;\n+\n+  *var = expr;\n+  mpz_set_ui (offset, 0);\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case MINUS_EXPR:\n+      negate = true;\n+      /* Fallthru.  */\n+\n+    case PLUS_EXPR:\n+      op0 = TREE_OPERAND (expr, 0);\n+      op1 = TREE_OPERAND (expr, 1);\n+\n+      if (TREE_CODE (op1) != INTEGER_CST)\n+\tbreak;\n+\n+      *var = op0;\n+      /* Always sign extend the offset.  */\n+      off = double_int_sext (tree_to_double_int (op1),\n+\t\t\t     TYPE_PRECISION (type));\n+      mpz_set_double_int (offset, off, false);\n+      break;\n+\n+    case INTEGER_CST:\n+      *var = build_int_cst_type (type, 0);\n+      off = tree_to_double_int (expr);\n+      mpz_set_double_int (offset, off, TYPE_UNSIGNED (type));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Stores estimate on the minimum/maximum value of the expression VAR + OFF\n+   in TYPE to MIN and MAX.  */\n+\n+static void\n+determine_value_range (tree type, tree var, mpz_t off,\n+\t\t       mpz_t min, mpz_t max)\n+{\n+  /* If the expression is a constant, we know its value exactly.  */\n+  if (integer_zerop (var))\n+    {\n+      mpz_set (min, off);\n+      mpz_set (max, off);\n+      return;\n+    }\n+\n+  /* If the computation may wrap, we know nothing about the value, except for\n+     the range of the type.  */\n+  get_type_bounds (type, min, max);\n+  if (!nowrap_type_p (type))\n+    return;\n+\n+  /* Since the addition of OFF does not wrap, if OFF is positive, then we may\n+     add it to MIN, otherwise to MAX.  */\n+  if (mpz_sgn (off) < 0)\n+    mpz_add (max, max, off);\n+  else\n+    mpz_add (min, min, off);\n+}\n+\n+/* Stores the bounds on the difference of the values of the expressions\n+   (var + X) and (var + Y), computed in TYPE, to BNDS.  */\n+\n+static void\n+bound_difference_of_offsetted_base (tree type, mpz_t x, mpz_t y,\n+\t\t\t\t    bounds *bnds)\n+{\n+  int rel = mpz_cmp (x, y);\n+  bool may_wrap = !nowrap_type_p (type);\n+  mpz_t m;\n+\n+  /* If X == Y, then the expressions are always equal.\n+     If X > Y, there are the following possibilities:\n+       a) neither of var + X and var + Y overflow or underflow, or both of\n+\t  them do.  Then their difference is X - Y.\n+       b) var + X overflows, and var + Y does not.  Then the values of the\n+\t  expressions are var + X - M and var + Y, where M is the range of\n+\t  the type, and their difference is X - Y - M.\n+       c) var + Y underflows and var + X does not.  Their difference again\n+\t  is M - X + Y.\n+       Therefore, if the arithmetics in type does not overflow, then the\n+       bounds are (X - Y, X - Y), otherwise they are (X - Y - M, X - Y)\n+     Similarly, if X < Y, the bounds are either (X - Y, X - Y) or\n+     (X - Y, X - Y + M).  */\n+\n+  if (rel == 0)\n+    {\n+      mpz_set_ui (bnds->below, 0);\n+      mpz_set_ui (bnds->up, 0);\n+      return;\n+    }\n+\n+  mpz_init (m);\n+  mpz_set_double_int (m, double_int_mask (TYPE_PRECISION (type)), true);\n+  mpz_add_ui (m, m, 1);\n+  mpz_sub (bnds->up, x, y);\n+  mpz_set (bnds->below, bnds->up);\n+\n+  if (may_wrap)\n+    {\n+      if (rel > 0)\n+\tmpz_sub (bnds->below, bnds->below, m);\n+      else\n+\tmpz_add (bnds->up, bnds->up, m);\n+    }\n+\n+  mpz_clear (m);\n+}\n+\n+/* From condition C0 CMP C1 derives information regarding the\n+   difference of values of VARX + OFFX and VARY + OFFY, computed in TYPE,\n+   and stores it to BNDS.  */\n+\n+static void\n+refine_bounds_using_guard (tree type, tree varx, mpz_t offx,\n+\t\t\t   tree vary, mpz_t offy,\n+\t\t\t   tree c0, enum tree_code cmp, tree c1,\n+\t\t\t   bounds *bnds)\n+{\n+  tree varc0, varc1, tmp;\n+  mpz_t offc0, offc1, loffx, loffy, bnd;\n+  bool lbound = false;\n+  bool no_wrap = nowrap_type_p (type);\n+  bool x_ok, y_ok;\n+\n+  switch (cmp)\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      break;\n+\n+    case EQ_EXPR:\n+      /* We could derive quite precise information from EQ_EXPR, however, such\n+\t a guard is unlikely to appear, so we do not bother with handling it. \n+\t TODO.  */\n+      return;\n+\n+    case NE_EXPR:\n+      /* NE_EXPR comparisons do not contain much of useful information (except for\n+\t special cases like comparing with the bounds of the type, TODO).  */\n+      return;\n+    default:\n+      return;\n+    } \n+\n+  mpz_init (offc0);\n+  mpz_init (offc1);\n+  split_to_var_and_offset (expand_simple_operations (c0), &varc0, offc0);\n+  split_to_var_and_offset (expand_simple_operations (c1), &varc1, offc1);\n+\n+  /* We are only interested in comparisons of expressions based on VARX and\n+     VARY.  TODO -- we might also be able to derive some bounds from\n+     expressions containing just one of the variables.  */\n+\n+  if (operand_equal_p (varx, varc1, 0))\n+    {\n+      tmp = varc0; varc0 = varc1; varc1 = tmp;\n+      mpz_swap (offc0, offc1);\n+      cmp = swap_tree_comparison (cmp);\n+    }\n+\n+  if (!operand_equal_p (varx, varc0, 0)\n+      || !operand_equal_p (vary, varc1, 0))\n+    goto end;\n+\n+  mpz_init_set (loffx, offx);\n+  mpz_init_set (loffy, offy);\n+\n+  if (cmp == GT_EXPR || cmp == GE_EXPR)\n+    {\n+      tmp = varx; varx = vary; vary = tmp;\n+      mpz_swap (offc0, offc1);\n+      mpz_swap (loffx, loffy);\n+      cmp = swap_tree_comparison (cmp);\n+      lbound = true;\n+    }\n+\n+  /* If there is no overflow, the condition implies that\n+\n+     (VARX + OFFX) cmp (VARY + OFFY) + (OFFX - OFFY + OFFC1 - OFFC0).\n+\n+     The overflows and underflows may complicate things a bit; each\n+     overflow decreases the appropriate offset by M, and underflow\n+     increases it by M.  The above inequality would not necessarily be\n+     true if\n+   \n+     -- VARX + OFFX underflows and VARX + OFFC0 does not, or\n+\tVARX + OFFC0 overflows, but VARX + OFFX does not.\n+\tThis may only happen if OFFX < OFFC0.\n+     -- VARY + OFFY overflows and VARY + OFFC1 does not, or\n+\tVARY + OFFC1 underflows and VARY + OFFY does not.\n+\tThis may only happen if OFFY > OFFC1.  */\n+\n+  if (no_wrap)\n+    {\n+      x_ok = true;\n+      y_ok = true;\n+    }\n+  else\n+    {\n+      x_ok = (integer_zerop (varx)\n+\t      || mpz_cmp (loffx, offc0) >= 0);\n+      y_ok = (integer_zerop (vary)\n+\t      || mpz_cmp (loffy, offc1) <= 0);\n+    }\n+\n+  if (x_ok && y_ok)\n+    {\n+      mpz_init (bnd);\n+      mpz_sub (bnd, loffx, loffy);\n+      mpz_add (bnd, bnd, offc1);\n+      mpz_sub (bnd, bnd, offc0);\n+\n+      if (cmp == LT_EXPR)\n+\tmpz_sub_ui (bnd, bnd, 1);\n+\n+      if (lbound)\n+\t{\n+\t  mpz_neg (bnd, bnd);\n+\t  if (mpz_cmp (bnds->below, bnd) < 0)\n+\t    mpz_set (bnds->below, bnd);\n+\t}\n+      else\n+\t{\n+\t  if (mpz_cmp (bnd, bnds->up) < 0)\n+\t    mpz_set (bnds->up, bnd);\n+\t}\n+      mpz_clear (bnd);\n+    }\n+\n+  mpz_clear (loffx);\n+  mpz_clear (loffy);\n+end:\n+  mpz_clear (offc0);\n+  mpz_clear (offc1);\n+}\n+\n+/* Stores the bounds on the value of the expression X - Y in LOOP to BNDS.\n+   The subtraction is considered to be performed in arbitrary precision,\n+   without overflows.\n+ \n+   We do not attempt to be too clever regarding the value ranges of X and\n+   Y; most of the time, they are just integers or ssa names offsetted by\n+   integer.  However, we try to use the information contained in the\n+   comparisons before the loop (usually created by loop header copying).  */\n+\n+static void\n+bound_difference (struct loop *loop, tree x, tree y, bounds *bnds)\n+{\n+  tree type = TREE_TYPE (x);\n+  tree varx, vary;\n+  mpz_t offx, offy;\n+  mpz_t minx, maxx, miny, maxy;\n+  int cnt = 0;\n+  edge e;\n+  basic_block bb;\n+  tree cond, c0, c1, ctype;\n+  enum tree_code cmp;\n+\n+  mpz_init (bnds->below);\n+  mpz_init (bnds->up);\n+  mpz_init (offx);\n+  mpz_init (offy);\n+  split_to_var_and_offset (x, &varx, offx);\n+  split_to_var_and_offset (y, &vary, offy);\n+\n+  if (!integer_zerop (varx)\n+      && operand_equal_p (varx, vary, 0))\n+    {\n+      /* Special case VARX == VARY -- we just need to compare the\n+         offsets.  The matters are a bit more complicated in the\n+\t case addition of offsets may wrap.  */\n+      bound_difference_of_offsetted_base (type, offx, offy, bnds);\n+    }\n+  else\n+    {\n+      /* Otherwise, use the value ranges to determine the initial\n+\t estimates on below and up.  */\n+      mpz_init (minx);\n+      mpz_init (maxx);\n+      mpz_init (miny);\n+      mpz_init (maxy);\n+      determine_value_range (type, varx, offx, minx, maxx);\n+      determine_value_range (type, vary, offy, miny, maxy);\n+\n+      mpz_sub (bnds->below, minx, maxy);\n+      mpz_sub (bnds->up, maxx, miny);\n+      mpz_clear (minx);\n+      mpz_clear (maxx);\n+      mpz_clear (miny);\n+      mpz_clear (maxy);\n+    }\n+\n+  /* If both X and Y are constants, we cannot get any more precise.  */\n+  if (integer_zerop (varx) && integer_zerop (vary))\n+    goto end;\n+\n+  /* Now walk the dominators of the loop header and use the entry\n+     guards to refine the estimates.  */\n+  for (bb = loop->header;\n+       bb != ENTRY_BLOCK_PTR && cnt < MAX_DOMINATORS_TO_WALK;\n+       bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    {\n+      if (!single_pred_p (bb))\n+\tcontinue;\n+      e = single_pred_edge (bb);\n+\n+      if (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+\tcontinue;\n+\n+      cond = COND_EXPR_COND (last_stmt (e->src));\n+      if (!COMPARISON_CLASS_P (cond))\n+\tcontinue;\n+      c0 = TREE_OPERAND (cond, 0);\n+      cmp = TREE_CODE (cond);\n+      c1 = TREE_OPERAND (cond, 1);\n+      ctype = TREE_TYPE (c0);\n+\n+      if (!tree_ssa_useless_type_conversion_1 (ctype, type))\n+\tcontinue;\n+\n+      if (e->flags & EDGE_FALSE_VALUE)\n+\tcmp = invert_tree_comparison (cmp, false);\n+\n+      refine_bounds_using_guard (type, varx, offx, vary, offy,\n+\t\t\t\t c0, cmp, c1, bnds);\n+      ++cnt;\n+    }\n+\n+end:\n+  mpz_clear (offx);\n+  mpz_clear (offy);\n+}\n+\n+/* Update the bounds in BNDS that restrict the value of X to the bounds\n+   that restrict the value of X + DELTA.  X can be obtained as a\n+   difference of two values in TYPE.  */\n+\n+static void\n+bounds_add (bounds *bnds, double_int delta, tree type)\n+{\n+  mpz_t mdelta, max;\n+\n+  mpz_init (mdelta);\n+  mpz_set_double_int (mdelta, delta, false);\n+\n+  mpz_init (max);\n+  mpz_set_double_int (max, double_int_mask (TYPE_PRECISION (type)), true);\n+\n+  mpz_add (bnds->up, bnds->up, mdelta);\n+  mpz_add (bnds->below, bnds->below, mdelta);\n+\n+  if (mpz_cmp (bnds->up, max) > 0)\n+    mpz_set (bnds->up, max);\n+\n+  mpz_neg (max, max);\n+  if (mpz_cmp (bnds->below, max) < 0)\n+    mpz_set (bnds->below, max);\n+\n+  mpz_clear (mdelta);\n+  mpz_clear (max);\n+}\n+\n+/* Update the bounds in BNDS that restrict the value of X to the bounds\n+   that restrict the value of -X.  */\n+\n+static void\n+bounds_negate (bounds *bnds)\n+{\n+  mpz_t tmp;\n+\n+  mpz_init_set (tmp, bnds->up);\n+  mpz_neg (bnds->up, bnds->below);\n+  mpz_neg (bnds->below, tmp);\n+  mpz_clear (tmp);\n+}\n+\n /* Returns inverse of X modulo 2^s, where MASK = 2^s-1.  */\n \n static tree\n@@ -96,33 +587,79 @@ inverse (tree x, tree mask)\n   return rslt;\n }\n \n+/* Derives the upper bound BND on the number of executions of loop with exit\n+   condition S * i <> C, assuming that the loop is not infinite.  If\n+   NO_OVERFLOW is true, then the control variable of the loop does not\n+   overflow.  If NO_OVERFLOW is true or BNDS.below >= 0, then BNDS.up\n+   contains the upper bound on the value of C.  */\n+\n+static void\n+number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n+\t\t\t     bounds *bnds)\n+{\n+  double_int max;\n+  mpz_t d;\n+\n+  /* If the control variable does not overflow, the number of iterations is\n+     at most c / s.  Otherwise it is at most the period of the control\n+     variable.  */\n+  if (!no_overflow && !multiple_of_p (TREE_TYPE (c), c, s))\n+    {\n+      max = double_int_mask (TYPE_PRECISION (TREE_TYPE (c))\n+\t\t\t     - tree_low_cst (num_ending_zeros (s), 1));\n+      mpz_set_double_int (bnd, max, true);\n+      return;\n+    }\n+\n+  /* Determine the upper bound on C.  */\n+  if (no_overflow || mpz_sgn (bnds->below) >= 0)\n+    mpz_set (bnd, bnds->up);\n+  else if (TREE_CODE (c) == INTEGER_CST)\n+    mpz_set_double_int (bnd, tree_to_double_int (c), true);\n+  else\n+    mpz_set_double_int (bnd, double_int_mask (TYPE_PRECISION (TREE_TYPE (c))),\n+\t\t\ttrue);\n+\n+  mpz_init (d);\n+  mpz_set_double_int (d, tree_to_double_int (s), true);\n+  mpz_fdiv_q (bnd, bnd, d);\n+  mpz_clear (d);\n+}\n+\n /* Determines number of iterations of loop whose ending condition\n    is IV <> FINAL.  TYPE is the type of the iv.  The number of\n    iterations is stored to NITER.  NEVER_INFINITE is true if\n    we know that the exit must be taken eventually, i.e., that the IV\n    ever reaches the value FINAL (we derived this earlier, and possibly set\n-   NITER->assumptions to make sure this is the case).  */\n+   NITER->assumptions to make sure this is the case).  BNDS contains the\n+   bounds on the difference FINAL - IV->base.  */\n \n static bool\n number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n-\t\t\t struct tree_niter_desc *niter, bool never_infinite)\n+\t\t\t struct tree_niter_desc *niter, bool never_infinite,\n+\t\t\t bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n   tree s, c, d, bits, assumption, tmp, bound;\n+  mpz_t max;\n \n   niter->control = *iv;\n   niter->bound = final;\n   niter->cmp = NE_EXPR;\n \n-  /* Rearrange the terms so that we get inequality s * i <> c, with s\n-     positive.  Also cast everything to the unsigned type.  */\n+  /* Rearrange the terms so that we get inequality S * i <> C, with S\n+     positive.  Also cast everything to the unsigned type.  If IV does\n+     not overflow, BNDS bounds the value of C.  Also, this is the\n+     case if the computation |FINAL - IV->base| does not overflow, i.e.,\n+     if BNDS->below in the result is nonnegative.  */\n   if (tree_int_cst_sign_bit (iv->step))\n     {\n       s = fold_convert (niter_type,\n \t\t\tfold_build1 (NEGATE_EXPR, type, iv->step));\n       c = fold_build2 (MINUS_EXPR, niter_type,\n \t\t       fold_convert (niter_type, iv->base),\n \t\t       fold_convert (niter_type, final));\n+      bounds_negate (bnds);\n     }\n   else\n     {\n@@ -132,6 +669,11 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n \t\t       fold_convert (niter_type, iv->base));\n     }\n \n+  mpz_init (max);\n+  number_of_iterations_ne_max (max, iv->no_overflow, c, s, bnds);\n+  niter->max = mpz_to_double_int (niter_type, max);\n+  mpz_clear (max);\n+\n   /* First the trivial cases -- when the step is 1.  */\n   if (integer_onep (s))\n     {\n@@ -175,24 +717,32 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n    of the step.  The assumptions necessary to ensure that the computation\n    of the final value does not overflow are recorded in NITER.  If we\n    find the final value, we adjust DELTA and return TRUE.  Otherwise\n-   we return false.  */\n+   we return false.  BNDS bounds the value of IV1->base - IV0->base,\n+   and will be updated by the same amount as DELTA.  */\n \n static bool\n number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t       struct tree_niter_desc *niter,\n-\t\t\t       tree *delta, tree step)\n+\t\t\t       tree *delta, tree step,\n+\t\t\t       bounds *bnds)\n {\n   tree niter_type = TREE_TYPE (step);\n   tree mod = fold_build2 (FLOOR_MOD_EXPR, niter_type, *delta, step);\n   tree tmod;\n+  mpz_t mmod;\n   tree assumption = boolean_true_node, bound, noloop;\n+  bool ret = false;\n \n   if (TREE_CODE (mod) != INTEGER_CST)\n     return false;\n   if (integer_nonzerop (mod))\n     mod = fold_build2 (MINUS_EXPR, niter_type, step, mod);\n   tmod = fold_convert (type, mod);\n \n+  mpz_init (mmod);\n+  mpz_set_double_int (mmod, tree_to_double_int (mod), true);\n+  mpz_neg (mmod, mmod);\n+\n   if (integer_nonzerop (iv0->step))\n     {\n       /* The final value of the iv is iv1->base + MOD, assuming that this\n@@ -205,12 +755,15 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t    iv1->base, bound);\n \t  if (integer_zerop (assumption))\n-\t    return false;\n+\t    goto end;\n \t}\n-      noloop = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t    iv0->base,\n-\t\t\t    fold_build2 (PLUS_EXPR, type,\n-\t\t\t\t\t iv1->base, tmod));\n+      if (mpz_cmp (mmod, bnds->below) < 0)\n+\tnoloop = boolean_false_node;\n+      else\n+\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t      iv0->base,\n+\t\t\t      fold_build2 (PLUS_EXPR, type,\n+\t\t\t\t\t   iv1->base, tmod));\n     }\n   else\n     {\n@@ -224,12 +777,15 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t    iv0->base, bound);\n \t  if (integer_zerop (assumption))\n-\t    return false;\n+\t    goto end;\n \t}\n-      noloop = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t    fold_build2 (MINUS_EXPR, type,\n-\t\t\t\t\t iv0->base, tmod),\n-\t\t\t    iv1->base);\n+      if (mpz_cmp (mmod, bnds->below) < 0)\n+\tnoloop = boolean_false_node;\n+      else\n+\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t      fold_build2 (MINUS_EXPR, type,\n+\t\t\t\t\t   iv0->base, tmod),\n+\t\t\t      iv1->base);\n     }\n \n   if (!integer_nonzerop (assumption))\n@@ -240,8 +796,13 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n     niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t      niter->may_be_zero,\n \t\t\t\t      noloop);\n+  bounds_add (bnds, tree_to_double_int (mod), type);\n   *delta = fold_build2 (PLUS_EXPR, niter_type, *delta, mod);\n-  return true;\n+\n+  ret = true;\n+end:\n+  mpz_clear (mmod);\n+  return ret;\n }\n \n /* Add assertions to NITER that ensure that the control variable of the loop\n@@ -315,14 +876,75 @@ assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n }\n \n /* Add an assumption to NITER that a loop whose ending condition\n-   is IV0 < IV1 rolls.  TYPE is the type of the control iv.  */\n+   is IV0 < IV1 rolls.  TYPE is the type of the control iv.  BNDS\n+   bounds the value of IV1->base - IV0->base.  */\n \n static void\n assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t      struct tree_niter_desc *niter)\n+\t\t      struct tree_niter_desc *niter, bounds *bnds)\n {\n   tree assumption = boolean_true_node, bound, diff;\n   tree mbz, mbzl, mbzr;\n+  bool rolls_p, no_overflow_p;\n+  double_int dstep;\n+  mpz_t mstep, max;\n+\n+  /* We are going to compute the number of iterations as\n+     (iv1->base - iv0->base + step - 1) / step, computed in the unsigned\n+     variant of TYPE.  This formula only works if \n+     \n+     -step + 1 <= (iv1->base - iv0->base) <= MAX - step + 1\n+   \n+     (where MAX is the maximum value of the unsigned variant of TYPE, and\n+     the computations in this formula are performed in full precision\n+     (without overflows).\n+\n+     Usually, for loops with exit condition iv0->base + step * i < iv1->base,\n+     we have a condition of form iv0->base - step < iv1->base before the loop,\n+     and for loops iv0->base < iv1->base - step * i the condition\n+     iv0->base < iv1->base + step, due to loop header copying, which enable us\n+     to prove the lower bound.\n+     \n+     The upper bound is more complicated.  Unless the expressions for initial\n+     and final value themselves contain enough information, we usually cannot\n+     derive it from the context.  */\n+\n+  /* First check whether the answer does not follow from the bounds we gathered\n+     before.  */\n+  if (integer_nonzerop (iv0->step))\n+    dstep = tree_to_double_int (iv0->step);\n+  else\n+    {\n+      dstep = double_int_sext (tree_to_double_int (iv1->step),\n+\t\t\t       TYPE_PRECISION (type));\n+      dstep = double_int_neg (dstep);\n+    }\n+\n+  mpz_init (mstep);\n+  mpz_set_double_int (mstep, dstep, true);\n+  mpz_neg (mstep, mstep);\n+  mpz_add_ui (mstep, mstep, 1);\n+\n+  rolls_p = mpz_cmp (mstep, bnds->below) <= 0;\n+\n+  mpz_init (max);\n+  mpz_set_double_int (max, double_int_mask (TYPE_PRECISION (type)), true);\n+  mpz_add (max, max, mstep);\n+  no_overflow_p = (mpz_cmp (bnds->up, max) <= 0\n+\t\t   /* For pointers, only values lying inside a single object\n+\t\t      can be compared or manipulated by pointer arithmetics.\n+\t\t      Gcc in general does not allow or handle objects larger\n+\t\t      than half of the address space, hence the upper bound\n+\t\t      is satisfied for pointers.  */\n+\t\t   || POINTER_TYPE_P (type));\n+  mpz_clear (mstep);\n+  mpz_clear (max);\n+\n+  if (rolls_p && no_overflow_p)\n+    return;\n+\n+  /* Now the hard part; we must formulate the assumption(s) as expressions, and\n+     we must be careful not to introduce overflow.  */\n \n   if (integer_nonzerop (iv0->step))\n     {\n@@ -362,27 +984,31 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n       mbzr = fold_build2 (MINUS_EXPR, type, iv1->base, diff);\n     }\n \n-  mbz = fold_build2 (GT_EXPR, boolean_type_node, mbzl, mbzr);\n-\n   if (!integer_nonzerop (assumption))\n     niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t      niter->assumptions, assumption);\n-  if (!integer_zerop (mbz))\n-    niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t      niter->may_be_zero, mbz);\n+  if (!rolls_p)\n+    {\n+      mbz = fold_build2 (GT_EXPR, boolean_type_node, mbzl, mbzr);\n+      niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t\tniter->may_be_zero, mbz);\n+    }\n }\n \n /* Determines number of iterations of loop whose ending condition\n    is IV0 < IV1.  TYPE is the type of the iv.  The number of\n-   iterations is stored to NITER.  */\n+   iterations is stored to NITER.  BNDS bounds the difference\n+   IV1->base - IV0->base.  */\n \n static bool\n number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t struct tree_niter_desc *niter,\n-\t\t\t bool never_infinite ATTRIBUTE_UNUSED)\n+\t\t\t bool never_infinite ATTRIBUTE_UNUSED,\n+\t\t\t bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n   tree delta, step, s;\n+  mpz_t mstep, tmp;\n \n   if (integer_nonzerop (iv0->step))\n     {\n@@ -412,10 +1038,18 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t for (i = iv1->base; i > iv0->base; i--).\n \t     \n \t In both cases # of iterations is iv1->base - iv0->base, assuming that\n-\t iv1->base >= iv0->base.  */\n-      niter->may_be_zero = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\tiv1->base, iv0->base);\n+\t iv1->base >= iv0->base.\n+\n+         First try to derive a lower bound on the value of\n+\t iv1->base - iv0->base, computed in full precision.  If the difference\n+\t is nonnegative, we are done, otherwise we must record the\n+\t condition.  */\n+\n+      if (mpz_sgn (bnds->below) < 0)\n+\tniter->may_be_zero = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t  iv1->base, iv0->base);\n       niter->niter = delta;\n+      niter->max = mpz_to_double_int (niter_type, bnds->up);\n       return true;\n     }\n \n@@ -428,7 +1062,8 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   /* If we can determine the final value of the control iv exactly, we can\n      transform the condition to != comparison.  In particular, this will be\n      the case if DELTA is constant.  */\n-  if (number_of_iterations_lt_to_ne (type, iv0, iv1, niter, &delta, step))\n+  if (number_of_iterations_lt_to_ne (type, iv0, iv1, niter, &delta, step,\n+\t\t\t\t     bnds))\n     {\n       affine_iv zps;\n \n@@ -438,7 +1073,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t zps does not overflow.  */\n       zps.no_overflow = true;\n \n-      return number_of_iterations_ne (type, &zps, delta, niter, true);\n+      return number_of_iterations_ne (type, &zps, delta, niter, true, bnds);\n     }\n \n   /* Make sure that the control iv does not overflow.  */\n@@ -448,12 +1083,23 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   /* We determine the number of iterations as (delta + step - 1) / step.  For\n      this to work, we must know that iv1->base >= iv0->base - step + 1,\n      otherwise the loop does not roll.  */\n-  assert_loop_rolls_lt (type, iv0, iv1, niter);\n+  assert_loop_rolls_lt (type, iv0, iv1, niter, bnds);\n \n   s = fold_build2 (MINUS_EXPR, niter_type,\n \t\t   step, build_int_cst (niter_type, 1));\n   delta = fold_build2 (PLUS_EXPR, niter_type, delta, s);\n   niter->niter = fold_build2 (FLOOR_DIV_EXPR, niter_type, delta, step);\n+\n+  mpz_init (mstep);\n+  mpz_init (tmp);\n+  mpz_set_double_int (mstep, tree_to_double_int (step), true);\n+  mpz_add (tmp, bnds->up, mstep);\n+  mpz_sub_ui (tmp, tmp, 1);\n+  mpz_fdiv_q (tmp, tmp, mstep);\n+  niter->max = mpz_to_double_int (niter_type, tmp);\n+  mpz_clear (mstep);\n+  mpz_clear (tmp);\n+\n   return true;\n }\n \n@@ -462,11 +1108,12 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n    iterations is stored to NITER.  NEVER_INFINITE is true if\n    we know that this condition must eventually become false (we derived this\n    earlier, and possibly set NITER->assumptions to make sure this\n-   is the case).  */\n+   is the case).  BNDS bounds the difference IV1->base - IV0->base.  */\n \n static bool\n number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t\t struct tree_niter_desc *niter, bool never_infinite)\n+\t\t\t struct tree_niter_desc *niter, bool never_infinite,\n+\t\t\t bounds *bnds)\n {\n   tree assumption;\n \n@@ -497,7 +1144,28 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n   else\n     iv0->base = fold_build2 (MINUS_EXPR, type,\n \t\t\t     iv0->base, build_int_cst (type, 1));\n-  return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite);\n+\n+  bounds_add (bnds, double_int_one, type);\n+\n+  return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite, bnds);\n+}\n+\n+/* Dumps description of affine induction variable IV to FILE.  */\n+\n+static void\n+dump_affine_iv (FILE *file, affine_iv *iv)\n+{\n+  if (!integer_zerop (iv->step))\n+    fprintf (file, \"[\");\n+\n+  print_generic_expr (dump_file, iv->base, TDF_SLIM);\n+\n+  if (!integer_zerop (iv->step))\n+    {\n+      fprintf (file, \", + , \");\n+      print_generic_expr (dump_file, iv->step, TDF_SLIM);\n+      fprintf (file, \"]%s\", iv->no_overflow ? \"(no_overflow)\" : \"\");\n+    }\n }\n \n /* Determine the number of iterations according to condition (for staying\n@@ -507,6 +1175,8 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n    type TYPE, which must be an integer or pointer type.  The steps of the\n    ivs must be constants (or NULL_TREE, which is interpreted as constant zero).\n \n+   LOOP is the loop whose number of iterations we are determining.\n+\n    ONLY_EXIT is true if we are sure this is the only way the loop could be\n    exited (including possibly non-returning function calls, exceptions, etc.)\n    -- in this case we can use the information whether the control induction\n@@ -518,11 +1188,13 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n    was determined (possibly with some assumptions).  */\n \n static bool\n-number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n+number_of_iterations_cond (struct loop *loop,\n+\t\t\t   tree type, affine_iv *iv0, enum tree_code code,\n \t\t\t   affine_iv *iv1, struct tree_niter_desc *niter,\n \t\t\t   bool only_exit)\n {\n-  bool never_infinite;\n+  bool never_infinite, ret;\n+  bounds bnds;\n \n   /* The meaning of these assumptions is this:\n      if !assumptions\n@@ -532,7 +1204,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   niter->assumptions = boolean_true_node;\n   niter->may_be_zero = boolean_false_node;\n   niter->niter = NULL_TREE;\n-  niter->additional_info = boolean_true_node;\n+  niter->max = double_int_zero;\n \n   niter->bound = NULL_TREE;\n   niter->cmp = ERROR_MARK;\n@@ -618,23 +1290,89 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   if (integer_zerop (fold_build2 (code, boolean_type_node, iv0->base, iv1->base)))\n     {\n       niter->niter = build_int_cst (unsigned_type_for (type), 0);\n+      niter->max = double_int_zero;\n       return true;\n     }\n-\n+\t  \n   /* OK, now we know we have a senseful loop.  Handle several cases, depending\n      on what comparison operator is used.  */\n+  bound_difference (loop, iv1->base, iv0->base, &bnds);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file,\n+\t       \"Analysing # of iterations of loop %d\\n\", loop->num);\n+\n+      fprintf (dump_file, \"  exit condition \");\n+      dump_affine_iv (dump_file, iv0);\n+      fprintf (dump_file, \" %s \",\n+\t       code == NE_EXPR ? \"!=\"\n+\t       : code == LT_EXPR ? \"<\"\n+\t       : \"<=\");\n+      dump_affine_iv (dump_file, iv1);\n+      fprintf (dump_file, \"\\n\");\n+\n+      fprintf (dump_file, \"  bounds on difference of bases: \");\n+      mpz_out_str (dump_file, 10, bnds.below);\n+      fprintf (dump_file, \" ... \");\n+      mpz_out_str (dump_file, 10, bnds.up);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n   switch (code)\n     {\n     case NE_EXPR:\n       gcc_assert (integer_zerop (iv1->step));\n-      return number_of_iterations_ne (type, iv0, iv1->base, niter, never_infinite);\n+      ret = number_of_iterations_ne (type, iv0, iv1->base, niter,\n+\t\t\t\t     never_infinite, &bnds);\n+      break;\n+\n     case LT_EXPR:\n-      return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite);\n+      ret = number_of_iterations_lt (type, iv0, iv1, niter, never_infinite,\n+\t\t\t\t     &bnds);\n+      break;\n+\n     case LE_EXPR:\n-      return number_of_iterations_le (type, iv0, iv1, niter, never_infinite);\n+      ret = number_of_iterations_le (type, iv0, iv1, niter, never_infinite,\n+\t\t\t\t     &bnds);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n+\n+  mpz_clear (bnds.up);\n+  mpz_clear (bnds.below);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      if (ret)\n+\t{\n+\t  fprintf (dump_file, \"  result:\\n\");\n+\t  if (!integer_nonzerop (niter->assumptions))\n+\t    {\n+\t      fprintf (dump_file, \"    under assumptions \");\n+\t      print_generic_expr (dump_file, niter->assumptions, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  if (!integer_zerop (niter->may_be_zero))\n+\t    {\n+\t      fprintf (dump_file, \"    zero if \");\n+\t      print_generic_expr (dump_file, niter->may_be_zero, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  fprintf (dump_file, \"    # of iterations \");\n+\t  print_generic_expr (dump_file, niter->niter, TDF_SLIM);\n+\t  fprintf (dump_file, \", bounded by \");\n+\t  dump_double_int (dump_file, niter->max, true);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      else\n+\tfprintf (dump_file, \"  failed\\n\\n\");\n+    }\n+  return ret;\n }\n \n /* Substitute NEW for OLD in EXPR and fold the result.  */\n@@ -718,6 +1456,24 @@ expand_simple_operations (tree expr)\n     return expr;\n \n   stmt = SSA_NAME_DEF_STMT (expr);\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    {\n+      basic_block src, dest;\n+\n+      if (PHI_NUM_ARGS (stmt) != 1)\n+\treturn expr;\n+      e = PHI_ARG_DEF (stmt, 0);\n+\n+      /* Avoid propagating through loop exit phi nodes, which\n+\t could break loop-closed SSA form restrictions.  */\n+      dest = bb_for_stmt (stmt);\n+      src = single_pred (dest);\n+      if (TREE_CODE (e) == SSA_NAME\n+\t  && src->loop_father != dest->loop_father)\n+\treturn expr;\n+\n+      return expand_simple_operations (e);\n+    }\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return expr;\n \n@@ -861,23 +1617,16 @@ tree_simplify_using_condition (tree cond, tree expr)\n   return tree_simplify_using_condition_1 (cond, expr);\n }\n \n-/* The maximum number of dominator BBs we search for conditions\n-   of loop header copies we use for simplifying a conditional\n-   expression.  */\n-#define MAX_DOMINATORS_TO_WALK 8\n-\n /* Tries to simplify EXPR using the conditions on entry to LOOP.\n-   Record the conditions used for simplification to CONDS_USED.\n    Returns the simplified expression (or EXPR unchanged, if no\n    simplification was possible).*/\n \n static tree\n-simplify_using_initial_conditions (struct loop *loop, tree expr,\n-\t\t\t\t   tree *conds_used)\n+simplify_using_initial_conditions (struct loop *loop, tree expr)\n {\n   edge e;\n   basic_block bb;\n-  tree exp, cond;\n+  tree cond;\n   int cnt = 0;\n \n   if (TREE_CODE (expr) == INTEGER_CST)\n@@ -900,15 +1649,7 @@ simplify_using_initial_conditions (struct loop *loop, tree expr,\n       cond = COND_EXPR_COND (last_stmt (e->src));\n       if (e->flags & EDGE_FALSE_VALUE)\n \tcond = invert_truthvalue (cond);\n-      exp = tree_simplify_using_condition (cond, expr);\n-\n-      if (exp != expr)\n-\t*conds_used = fold_build2 (TRUTH_AND_EXPR,\n-\t\t\t\t   boolean_type_node,\n-\t\t\t\t   *conds_used,\n-\t\t\t\t   cond);\n-\n-      expr = exp;\n+      expr = tree_simplify_using_condition (cond, expr);\n       ++cnt;\n     }\n \n@@ -1065,7 +1806,7 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \n   iv0.base = expand_simple_operations (iv0.base);\n   iv1.base = expand_simple_operations (iv1.base);\n-  if (!number_of_iterations_cond (type, &iv0, code, &iv1, niter,\n+  if (!number_of_iterations_cond (loop, type, &iv0, code, &iv1, niter,\n \t\t\t\t  loop_only_exit_p (loop, exit)))\n     {\n       fold_undefer_and_ignore_overflow_warnings ();\n@@ -1081,15 +1822,12 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n       niter->niter = simplify_using_outer_evolutions (loop, niter->niter);\n     }\n \n-  niter->additional_info = boolean_true_node;\n   niter->assumptions\n \t  = simplify_using_initial_conditions (loop,\n-\t\t\t\t\t       niter->assumptions,\n-\t\t\t\t\t       &niter->additional_info);\n+\t\t\t\t\t       niter->assumptions);\n   niter->may_be_zero\n \t  = simplify_using_initial_conditions (loop,\n-\t\t\t\t\t       niter->may_be_zero,\n-\t\t\t\t\t       &niter->additional_info);\n+\t\t\t\t\t       niter->may_be_zero);\n \n   fold_undefer_and_ignore_overflow_warnings ();\n \n@@ -1469,55 +2207,12 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n \n */\n \n-/* Returns true if we can prove that COND ==> VAL >= 0.  */\n-\n-static bool\n-implies_nonnegative_p (tree cond, tree val)\n-{\n-  tree type = TREE_TYPE (val);\n-  tree compare;\n-\n-  if (tree_expr_nonnegative_p (val))\n-    return true;\n-\n-  if (integer_nonzerop (cond))\n-    return false;\n-\n-  compare = fold_build2 (GE_EXPR,\n-\t\t\t boolean_type_node, val, build_int_cst (type, 0));\n-  compare = tree_simplify_using_condition_1 (cond, compare);\n-\n-  return integer_nonzerop (compare);\n-}\n-\n-/* Returns true if we can prove that COND ==> A >= B.  */\n-\n-static bool\n-implies_ge_p (tree cond, tree a, tree b)\n-{\n-  tree compare = fold_build2 (GE_EXPR, boolean_type_node, a, b);\n-\n-  if (integer_nonzerop (compare))\n-    return true;\n-\n-  if (integer_nonzerop (cond))\n-    return false;\n-\n-  compare = tree_simplify_using_condition_1 (cond, compare);\n-\n-  return integer_nonzerop (compare);\n-}\n-\n /* Returns a constant upper bound on the value of expression VAL.  VAL\n    is considered to be unsigned.  If its type is signed, its value must\n-   be nonnegative.\n-   \n-   The condition ADDITIONAL must be satisfied (for example, if VAL is\n-   \"(unsigned) n\" and ADDITIONAL is \"n > 0\", then we can derive that\n-   VAL is at most (unsigned) MAX_INT).  */\n+   be nonnegative.  */\n  \n static double_int\n-derive_constant_upper_bound (tree val, tree additional)\n+derive_constant_upper_bound (tree val)\n {\n   tree type = TREE_TYPE (val);\n   tree op0, op1, subtype, maxt;\n@@ -1544,7 +2239,7 @@ derive_constant_upper_bound (tree val, tree additional)\n \t  /* If TYPE is also signed, the fact that VAL is nonnegative implies\n \t     that OP0 is nonnegative.  */\n \t  && TYPE_UNSIGNED (type)\n-\t  && !implies_nonnegative_p (additional, op0))\n+\t  && !tree_expr_nonnegative_p (op0))\n \t{\n \t  /* If we cannot prove that the casted expression is nonnegative,\n \t     we cannot establish more useful upper bound than the precision\n@@ -1554,7 +2249,7 @@ derive_constant_upper_bound (tree val, tree additional)\n \n       /* We now know that op0 is an nonnegative value.  Try deriving an upper\n \t bound for it.  */\n-      bnd = derive_constant_upper_bound (op0, additional);\n+      bnd = derive_constant_upper_bound (op0);\n \n       /* If the bound does not fit in TYPE, max. value of TYPE could be\n \t attained.  */\n@@ -1569,7 +2264,7 @@ derive_constant_upper_bound (tree val, tree additional)\n       op1 = TREE_OPERAND (val, 1);\n \n       if (TREE_CODE (op1) != INTEGER_CST\n-\t  || !implies_nonnegative_p (additional, op0))\n+\t  || !tree_expr_nonnegative_p (op0))\n \treturn max;\n \n       /* Canonicalize to OP0 - CST.  Consider CST to be signed, in order to\n@@ -1580,7 +2275,7 @@ derive_constant_upper_bound (tree val, tree additional)\n       if (TREE_CODE (val) == PLUS_EXPR)\n \tcst = double_int_neg (cst);\n \n-      bnd = derive_constant_upper_bound (op0, additional);\n+      bnd = derive_constant_upper_bound (op0);\n \n       if (double_int_negative_p (cst))\n \t{\n@@ -1611,15 +2306,18 @@ derive_constant_upper_bound (tree val, tree additional)\n \t   */\n \n \t  /* This should only happen if the type is unsigned; however, for\n-\t     programs that use overflowing signed arithmetics even with\n+\t     buggy programs that use overflowing signed arithmetics even with\n \t     -fno-wrapv, this condition may also be true for signed values.  */\n \t  if (double_int_ucmp (bnd, cst) < 0)\n \t    return max;\n \n-\t  if (TYPE_UNSIGNED (type)\n-\t      && !implies_ge_p (additional,\n-\t\t\t\top0, double_int_to_tree (type, cst)))\n-\t    return max;\n+\t  if (TYPE_UNSIGNED (type))\n+\t    {\n+\t      tree tem = fold_binary (GE_EXPR, boolean_type_node, op0,\n+\t\t\t\t      double_int_to_tree (type, cst));\n+\t      if (!tem || integer_nonzerop (tem))\n+\t\treturn max;\n+\t    }\n \n \t  bnd = double_int_add (bnd, double_int_neg (cst));\n \t}\n@@ -1634,7 +2332,7 @@ derive_constant_upper_bound (tree val, tree additional)\n \t  || tree_int_cst_sign_bit (op1))\n \treturn max;\n \n-      bnd = derive_constant_upper_bound (op0, additional);\n+      bnd = derive_constant_upper_bound (op0);\n       return double_int_udiv (bnd, tree_to_double_int (op1), FLOOR_DIV_EXPR);\n \n     case BIT_AND_EXPR:\n@@ -1649,27 +2347,25 @@ derive_constant_upper_bound (tree val, tree additional)\n       if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n \t  || GIMPLE_STMT_OPERAND (stmt, 0) != val)\n \treturn max;\n-      return derive_constant_upper_bound (GIMPLE_STMT_OPERAND (stmt, 1),\n-\t  \t\t\t\t  additional);\n+      return derive_constant_upper_bound (GIMPLE_STMT_OPERAND (stmt, 1));\n \n     default: \n       return max;\n     }\n }\n \n-/* Records that AT_STMT is executed at most BOUND + 1 times in LOOP.  The\n-   additional condition ADDITIONAL is recorded with the bound.  IS_EXIT\n+/* Records that AT_STMT is executed at most BOUND + 1 times in LOOP.  IS_EXIT\n    is true if the loop is exited immediately after STMT, and this exit\n    is taken at last when the STMT is executed BOUND + 1 times.\n    REALISTIC is true if the estimate comes from a reliable source\n-   (number of iterations analysis, or size of data accessed in the loop).  */\n+   (number of iterations analysis, or size of data accessed in the loop).\n+   I_BOUND is an unsigned double_int upper estimate on BOUND.  */\n \n static void\n-record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt,\n-\t\t bool is_exit, bool realistic)\n+record_estimate (struct loop *loop, tree bound, double_int i_bound,\n+\t\t tree at_stmt, bool is_exit, bool realistic)\n {\n   struct nb_iter_bound *elt = xmalloc (sizeof (struct nb_iter_bound));\n-  double_int i_bound = derive_constant_upper_bound (bound, additional);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1701,6 +2397,7 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, tree stmt,\n {\n   tree niter_bound, extreme, delta;\n   tree type = TREE_TYPE (base), unsigned_type;\n+  double_int max;\n \n   if (TREE_CODE (step) != INTEGER_CST || integer_zerop (step))\n     return;\n@@ -1741,8 +2438,8 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, tree stmt,\n   /* STMT is executed at most NITER_BOUND + 1 times, since otherwise the value\n      would get out of the range.  */\n   niter_bound = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step);\n-  record_estimate (loop, niter_bound, boolean_true_node, stmt,\n-\t\t   false, data_size_bounds_p);\n+  max = derive_constant_upper_bound (niter_bound);\n+  record_estimate (loop, niter_bound, max, stmt, false, data_size_bounds_p);\n }\n \n /* Initialize LOOP->ESTIMATED_NB_ITERATIONS with the lowest safe\n@@ -2065,8 +2762,7 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \tniter = build3 (COND_EXPR, type, niter_desc.may_be_zero,\n \t\t\tbuild_int_cst (type, 0),\n \t\t\tniter);\n-      record_estimate (loop, niter,\n-\t\t       niter_desc.additional_info,\n+      record_estimate (loop, niter, niter_desc.max,\n \t\t       last_stmt (ex->src),\n \t\t       true, true);\n     }"}, {"sha": "6cd846d7cc05971ac93fc78c820f19050da96b3d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ce5b6ed7924967c74d161950038d5eb044273e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b3ce5b6ed7924967c74d161950038d5eb044273e", "patch": "@@ -4481,6 +4481,7 @@ extern enum tree_code invert_tree_comparison (enum tree_code, bool);\n \n extern bool tree_expr_nonzero_p (tree);\n extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n+extern int multiple_of_p (tree, tree, tree);\n \n /* In builtins.c */\n extern tree fold_call_expr (tree, bool);"}]}