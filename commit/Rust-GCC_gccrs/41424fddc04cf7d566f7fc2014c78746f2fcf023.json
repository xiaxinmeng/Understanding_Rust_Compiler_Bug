{"sha": "41424fddc04cf7d566f7fc2014c78746f2fcf023", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE0MjRmZGRjMDRjZjdkNTY2ZjdmYzIwMTRjNzg3NDZmMmZjZjAyMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-28T07:28:31Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-28T07:28:31Z"}, "message": "Initial revision\n\nFrom-SVN: r3568", "tree": {"sha": "30a2da91125d916426e7437015ca146c711f5f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30a2da91125d916426e7437015ca146c711f5f04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41424fddc04cf7d566f7fc2014c78746f2fcf023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41424fddc04cf7d566f7fc2014c78746f2fcf023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41424fddc04cf7d566f7fc2014c78746f2fcf023", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41424fddc04cf7d566f7fc2014c78746f2fcf023/comments", "author": null, "committer": null, "parents": [{"sha": "db9e5545df5d21e02c20fe6d09c2ac48c01796df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db9e5545df5d21e02c20fe6d09c2ac48c01796df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db9e5545df5d21e02c20fe6d09c2ac48c01796df"}], "stats": {"total": 590, "additions": 590, "deletions": 0}, "files": [{"sha": "4b309d1703afbc97b46829ad14929124dc548bf8", "filename": "gcc/c-iterate.c", "status": "added", "additions": 590, "deletions": 0, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41424fddc04cf7d566f7fc2014c78746f2fcf023/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41424fddc04cf7d566f7fc2014c78746f2fcf023/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=41424fddc04cf7d566f7fc2014c78746f2fcf023", "patch": "@@ -0,0 +1,590 @@\n+/* Build expressions with type checking for C compiler.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file is part of the C front end.\n+   It is responsible for implementing iterators,\n+   both their declarations and the expansion of statements using them.  */\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"tree.h\"\n+#include \"c-tree.h\"\n+#include \"flags.h\"\n+\n+static void expand_stmt_with_iterators_1 ();\n+static tree collect_iterators();\n+static void iterator_loop_prologue ();\n+static void iterator_loop_epilogue ();\n+static void add_ixpansion ();\n+static void delete_ixpansion();\n+static int top_level_ixpansion_p ();\n+static void istack_sublevel_to_current ();\n+\f\n+void\n+iterator_for_loop_start (idecl)\n+     tree idecl;\n+{\n+  iterator_loop_prologue (idecl, 0, 0);\n+}\n+\n+void\n+iterator_for_loop_end (idecl)\n+     tree idecl;\n+{\n+  iterator_loop_epilogue (idecl, 0, 0);\n+}\n+\n+void\n+iterator_for_loop_record (idecl)\n+     tree idecl;\n+{\n+  add_ixpansion (idecl, 0, 0, 0, 0);\n+}\n+\n+\n+/*\n+  \t\tITERATOR DECLS\n+\n+Iterators are  implemented  as integer decls  with a special  flag set\n+(rms's   idea).  This  makes  eliminates  the need   for  special type\n+checking.  The  flag  is accesed using   the  ITERATOR_P  macro.  Each\n+iterator's limit is saved as a  decl with a special  name. The decl is\n+initialized with the limit value -- this way we  get all the necessary\n+semantical processing for free by calling finish  decl. We might still\n+eliminate  that decl  later  -- it takes up  time and  space and, more\n+importantly, produces strange error  messages when  something is wrong\n+with the initializing expresison.  */\n+\n+tree\n+build_iterator_decl (id, limit)\n+    tree id, limit;\n+{\n+  tree type = integer_type_node, lim_decl;\n+  tree t1, t2, t3;\n+  tree start_node, limit_node, step_node;\n+  tree decl;\n+    \n+  if (limit)\n+    {\n+      limit_node = save_expr (limit);\n+      SAVE_EXPR_CONTEXT (limit_node) = current_function_decl;\n+    }\n+  else\n+    abort ();\n+  lim_decl = build_limit_decl (id, limit_node);\n+  push_obstacks_nochange ();\n+  decl = build_decl (VAR_DECL, id, type);\n+  ITERATOR_P (decl) = 1;\n+  ITERATOR_LIMIT (decl) = lim_decl;\n+  finish_decl (pushdecl (decl), 0, 0);\n+  return decl;\n+}\n+\f\n+/*\n+  \t\tITERATOR RTL EXPANSIONS\n+\n+   Expanding simple statements with iterators is  pretty straightforward:\n+   collect (collect_iterators) the list  of  all \"free\" iterators  in the\n+   statement and for each  of them add  a  special prologue before and an\n+   epilogue after the expansion for  the statement. Iterator is \"free\" if\n+   it has not been \"bound\" by a FOR operator. The rtx associated with the\n+   iterator's  decl is used as  the loop counter.  Special processing  is\n+   used  for \"{(...)}\" constructs:  each iterator expansion is registered\n+   (by \"add_ixpansion\" function)  and inner expansions are superseded  by\n+   outer ones. The cleanup of superseded expansions is done by  a call to\n+   delete_ixpansion.  */\n+\n+void\n+iterator_expand (stmt)\n+    tree stmt;\n+{\n+  tree iter_list = collect_iterators (stmt, NULL_TREE);\n+  expand_stmt_with_iterators_1 (stmt, iter_list);\n+  istack_sublevel_to_current ();\n+}\n+\n+\n+static void \n+expand_stmt_with_iterators_1 (stmt, iter_list)\n+     tree stmt, iter_list;\n+{\n+  if (iter_list == 0)\n+    expand_expr_stmt (stmt);\n+  else\n+    {\n+      tree current_iterator = TREE_VALUE (iter_list);\n+      tree iter_list_tail   = TREE_CHAIN (iter_list);\n+      rtx p_start, p_end, e_start, e_end;\n+\n+      iterator_loop_prologue (current_iterator, &p_start, &p_end);\n+      expand_stmt_with_iterators_1 (stmt, iter_list_tail);\n+      iterator_loop_epilogue (current_iterator, &e_start, &e_end);\n+\n+      /** Delete all inner expansions based on current_iterator **/\n+      /** before adding the outer one. **/\n+\n+      delete_ixpansion (current_iterator);\n+      add_ixpansion (current_iterator, p_start, p_end, e_start, e_end);\n+    }\n+}\n+\n+\n+/* Return a list containing all the free (i.e. not bound by \"for\"\n+   statement or anaccumulator) iterators mentioned in EXP,\n+   plus those in LIST.   Duplicates are avoided.  */\n+\n+static tree\n+collect_iterators (exp, list)\n+     tree exp, list;\n+{\n+  if (exp == 0) return list;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case VAR_DECL:\n+      if (! ITERATOR_P (exp) || ITERATOR_BOUND_P (exp))\n+\treturn list;\n+      if (value_member (exp, list))\n+\treturn list;\n+      return tree_cons (NULL_TREE, exp, list);\n+\n+    case TREE_LIST:\n+      {\n+\ttree tail;\n+\tfor (tail = exp; tail; tail = TREE_CHAIN (tail))\n+\t  list = collect_iterators (TREE_VALUE (tail), list);\n+\treturn list;\n+      }\n+\n+      /* we do not automatically iterate blocks -- one must */\n+      /* use the FOR construct to do that */\n+\n+    case BLOCK:\n+      return list;\n+\n+    default:\n+      switch (TREE_CODE_CLASS (code))\n+\t{\n+\tcase '1':\n+\tcase '2':\n+\tcase '<':\n+\tcase 'e':\n+\tcase 'r':\n+\t  {\n+\t    int num_args = tree_code_length[code];\n+\t    int i;\n+\t    the_list = (tree) 0;\n+\t    for (i = 0; i < num_args; i++)\n+\t      list = collect_iterators (TREE_OPERAND (exp, i), list);\n+\t    return list;\n+\t  }\n+\t}\n+    }\n+}\n+\f\n+/* Emit rtl for the start of a loop for iterator IDECL.\n+\n+   If necessary, create loop counter rtx and store it as DECL_RTL of IDECL.\n+\n+   The prologue normally starts and ends with notes, which are returned\n+   by this function in *START_NOTE and *END_NODE.\n+   If START_NOTE and END_NODE are 0, we don't make those notes.  */\n+\n+static void\n+iterator_loop_prologue (idecl, start_note, end_note)\n+     tree idecl;\n+     rtx *start_note, *end_note;\n+{\n+  /* Force the save_expr in DECL_INITIAL to be calculated\n+     if it hasn't been calculated yet.  */\n+  expand_expr (DECL_INITIAL (idecl), 0, VOIDmode, 0);\n+\n+  if (DECL_RTL (idecl) == 0)\n+    expand_decl (idecl);\n+\n+  if (start_note)\n+    *start_note = emit_note (0, NOTE_INSN_DELETED);\n+  /* Initialize counter.  */\n+  expand_expr (build_modify_expr (idecl, NOP_EXPR, integer_zero_node),\n+\t       0, VOIDmode, 0);\n+\n+  expand_start_loop_continue_elsewhere (1);\n+\n+  ITERATOR_BOUND_P (idecl) = 1;\n+\n+  if (end_note)\n+    *end_note = emit_note (0, NOTE_INSN_DELETED);\n+}\n+\n+/* Similar to the previous function, but for the end of the loop.\n+\n+   DECL_RTL is zeroed unless we are inside \"({...})\". The reason for that is\n+   described below.\n+\n+   When we create two (or more)  loops based on the  same IDECL, and both\n+   inside the same \"({...})\"  construct, we  must be prepared  to  delete\n+   both of the loops  and create a single one  on the  level  above, i.e.\n+   enclosing the \"({...})\". The new loop has to use  the same counter rtl\n+   because the references to the iterator decl  (IDECL) have already been\n+   expanded as references to the counter rtl.\n+\n+   It is incorrect to use the same counter reg in different functions,\n+   and it is desirable to use different counters in disjoint loops\n+   when we know there's no need to combine them\n+   (because then they can get allocated separately).  */\n+\n+static void\n+iterator_loop_epilogue (idecl, start_note, end_note)\n+     tree idecl;\n+     rtx *start_note, *end_note;\n+{\n+  tree test, incr;\n+\n+  if (start_note)\n+    *start_note = emit_note (0, NOTE_INSN_DELETED);\n+  expand_loop_continue_here ();\n+  incr = build_binary_op (PLUS_EXPR, idecl, integer_one_node, 0);\n+  expand_expr (build_modify_expr (idecl, NOP_EXPR, incr));\n+  test = build_binary_op (LT_EXPR, idecl, DECL_INITIAL (idecl), 0);\n+  expand_exit_loop_if_false (0, test);\n+  expand_end_loop ();\n+\n+  ITERATOR_BOUND_P (idecl) = 0;\n+  /* we can reset rtl since there is not chance that this expansion */\n+  /* would be superceded by a higher level one */\n+  if (top_level_ixpansion_p ())\n+    DECL_RTL (idecl) = 0;\n+  if (end_note)\n+    *end_note = emit_note (0, NOTE_INSN_DELETED);\n+}\n+\f\n+/*\n+\t\tKEEPING TRACK OF EXPANSIONS\n+\n+   In order to clean out expansions corresponding to statements inside\n+   \"{(...)}\" constructs we have to keep track of all expansions.  The\n+   cleanup is needed when an automatic, or implicit, expansion on\n+   iterator, say X, happens to a statement which contains a {(...)}\n+   form with a statement already expanded on X.  In this case we have\n+   to go back and cleanup the inner expansion.  This can be further\n+   complicated by the fact that {(...)} can be nested.\n+\n+   To make this cleanup possible, we keep lists of all expansions, and\n+   to make it work for nested constructs, we keep a stack.  The list at\n+   the top of the stack (ITER_STACK.CURRENT_LEVEL) corresponds to the\n+   currently parsed level.  All expansions of the levels below the\n+   current one are kept in one list whose head is pointed to by\n+   ITER_STACK.SUBLEVEL_FIRST (SUBLEVEL_LAST is there for making merges\n+   easy).  The process works as follows:\n+\n+   -- On \"({\"  a new node is added to the stack by PUSH_ITERATOR_STACK.\n+\t       The sublevel list is not changed at this point.\n+\n+   -- On \"})\" the list for the current level is appended to the sublevel\n+\t      list. \n+\n+   -- On \";\"  sublevel lists are appended to the current level lists.\n+\t      The reason is this: if they have not been superseded by the\n+\t      expansion at the current level, they still might be\n+\t      superseded later by the expansion on the higher level.\n+\t      The levels do not have to distinguish levels below, so we\n+\t      can merge the lists together.  */\n+\n+struct  ixpansion\n+{\n+  tree ixdecl;\t\t\t/* Iterator decl */\n+  rtx  ixprologue_start;\t/* First insn of epilogue. NULL means */\n+  /* explicit (FOR) expansion*/\n+  rtx  ixprologue_end;\n+  rtx  ixepilogue_start;\n+  rtx  ixepilogue_end;\n+  struct ixpansion *next;\t/* Next in the list */\n+};\n+\n+static struct obstack ixp_obstack;\n+\n+static char *ixp_firstobj;\n+\n+struct iter_stack_node\n+{\n+  struct ixpansion *first;\t/* Head of list of ixpansions */\n+  struct ixpansion *last;\t/* Last node in list  of ixpansions */\n+  struct iter_stack_node *next; /* Next level iterator stack node  */\n+};\n+\n+struct iter_stack_node *iter_stack;\n+\n+struct iter_stack_node sublevel_ixpansions;\n+\n+/** Return true if we are not currently inside a \"({...})\" construct */\n+\n+static int\n+top_level_ixpansion_p ()\n+{\n+  return iter_stack == 0;\n+}\n+\n+/* Given two chains of iter_stack_nodes,\n+   append the nodes in X into Y.  */\n+\n+static void\n+isn_append (x, y)\n+     struct iter_stack_node *x, *y;\n+{\n+  if (x->first == 0) \n+    return;\n+\n+  if (y->first == 0)\n+    {\n+      y->first = x->first;\n+      y->last  = x->last;\n+    }\n+  else\n+    {\n+      y->last->next = x->first;\n+      y->last = x->last;\n+    }\n+}\n+\n+/** Make X empty **/\n+\n+#define ISN_ZERO(X) (X).first=(X).last=0\n+\f\n+/* Move the ixpansions in sublevel_ixpansions into the current\n+   node on the iter_stack, or discard them if the iter_stack is empty.\n+   We do this at the end of a statement.  */\n+\n+static void\n+istack_sublevel_to_current ()\n+{\n+  /* At the top level we can throw away sublevel's expansions  **/\n+  /* because there is nobody above us to ask for a cleanup **/\n+  if (iter_stack != 0)\n+    /** Merging with empty sublevel list is a no-op **/\n+    if (sublevel_ixpansions.last)\n+      isn_append (&sublevel_ixpansions, iter_stack);\n+\n+  if (iter_stack == 0)\n+    obstack_free (&ixp_obstack, ixp_firstobj);\n+\n+  ISN_ZERO (sublevel_ixpansions);\n+}\n+\n+/* Push a new node on the iter_stack, when we enter a ({...}).  */\n+\n+void\n+push_iterator_stack ()\n+{\n+  struct iter_stack_node *new_top\n+    = (struct iter_stack_node*) \n+      obstack_alloc (&ixp_obstack, sizeof (struct iter_stack_node));\n+\n+  new_top->first = 0;\n+  new_top->last = 0;\n+  new_top->next = iter_stack;\n+  iter_stack = new_top;\n+}\n+\n+/* Pop iter_stack, moving the ixpansions in the node being popped\n+   into sublevel_ixpansions.  */\n+\n+void\n+pop_iterator_stack ()\n+{\n+  if (iter_stack == 0)\n+    abort ();\n+\n+  isn_append (iter_stack, &sublevel_ixpansions);\n+  /** Pop current level node: */\n+  iter_stack = iter_stack->next;\n+}\n+\f\n+\n+/* Record an iterator expansion (\"ixpansion\") for IDECL.\n+   The remaining paramters are the notes in the loop entry\n+   and exit rtl.  */\n+\n+static void\n+add_ixpansion (idecl, pro_start, pro_end, epi_start, epi_end)\n+     tree idecl;\n+     rtx pro_start, pro_end, epi_start, epi_end;\n+{\n+  struct ixpansion* newix;\n+    \n+  /* Do nothing if we are not inside \"({...})\",\n+     as in that case this expansion can't need subsequent RTL modification.  */\n+  if (iter_stack == 0)\n+    return;\n+\n+  newix = (struct ixpansion*) obstack_alloc (&ixp_obstack,\n+\t\t\t\t\t     sizeof (struct ixpansion));\n+  newix->ixdecl = idecl;\n+  newix->ixprologue_start = pro_start;\n+  newix->ixprologue_end   = pro_end;\n+  newix->ixepilogue_start = epi_start;\n+  newix->ixepilogue_end   = epi_end;\n+\n+  newix->next = iter_stack->first;\n+  iter_stack->first = newix;\n+  if (iter_stack->last == 0)\n+    iter_stack->last = newix;\n+}\n+\n+/* Delete the RTL for all ixpansions for iterator IDECL\n+   in our sublevels.  We do this when we make a larger\n+   containing expansion for IDECL.  */\n+\n+static void\n+delete_ixpansion (idecl)\n+     tree idecl;\n+{\n+  struct ixpansion* previx = 0, *ix;\n+\n+  for (ix = sublevel_ixpansions.first; ix; ix = ix->next)\n+    if (ix->ixdecl == idecl)\n+      {\n+\t/** zero means that this is a mark for FOR -- **/\n+\t/** we do not delete anything, just issue an error. **/\n+\n+\tif (ix->ixprologue_start == 0)\n+\t  error_with_decl (idecl,\n+\t\t\t   \"`for (%s)' appears within implicit iteration\")\n+\telse\n+\t  {\n+\t    rtx insn;\n+\t    /* We delete all insns, including notes because leaving loop */\n+\t    /* notes and barriers produced by iterator expansion would */\n+\t    /* be misleading to other phases */\n+\n+\t    for (insn = NEXT_INSN (ix->ixprologue_start);\n+\t\t insn != ix->ixprologue_end;\n+\t\t insn = NEXT_INSN (insn)) \n+\t      delete_insn (insn);\n+\t    for (insn = NEXT_INSN (ix->ixepilogue_start);\n+\t\t insn != ix->ixepilogue_end;\n+\t\t insn = NEXT_INSN (insn)) \n+\t      delete_insn (insn);\n+\t  }\n+\n+\t/* Delete this ixpansion from sublevel_ixpansions.  */\n+\tif (previx)\n+\t  previx->next = ix->next;\n+\telse \n+\t  sublevel_ixpansions.first = ix->next;\n+\tif (sublevel_ixpansions.last == ix)\n+\t  sublevel_ixpansions.last = previx;\n+      }\n+    else\n+      previx = ix;\n+}\n+\f\n+/*\n+We initialize iterators obstack once per file\n+*/\n+\n+init_iterators ()\n+{\n+  gcc_obstack_init (&ixp_obstack);\n+  ixp_firstobj = (char *) obstack_alloc (&ixp_obstack, 0);\n+}\n+\n+#ifdef DEBUG_ITERATORS\n+\n+/*\n+The functions below are for use from source level debugger.\n+They print short forms of iterator lists and the iterator stack.\n+*/\n+\n+/* Print the name of the iterator D */\n+void\n+PRDECL (D)\n+     tree D;\n+{\n+  if (D)\n+    {\n+      if (TREE_CODE (D) == VAR_DECL)\n+\t{\n+\t  tree tname = DECL_NAME (D);\n+\t  char *dname = IDENTIFIER_POINTER (tname);\n+\t  fprintf (stderr, dname);\n+\t}\n+      else\n+\tfprintf (stderr, \"<<Not a Decl!!!>>\");\n+    }\n+  else\n+    fprintf (stderr, \"<<NULL!!>>\");\n+}\n+\n+/* Print Iterator List -- names only */\n+\n+tree\n+pil (head)\n+     tree head;\n+{\n+  tree current, next;\n+  for (current=head; current; current = next)\n+    {\n+      tree node = TREE_VALUE (current);\n+      PRDECL (node);\n+      next = TREE_CHAIN (current);\n+      if (next) fprintf (stderr, \",\");\n+    }\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+/* Print IXpansion List */\n+\n+struct ixpansion *\n+pixl (head)\n+     struct ixpansion *head;\n+{\n+  struct ixpansion *current, *next;\n+  fprintf (stderr, \"> \");\n+  if (head == 0)\n+    fprintf (stderr, \"(empty)\");\n+\t\n+  for (current=head; current; current = next)\n+    {\n+      tree node = current->ixdecl;\n+      PRDECL (node);\n+      next = current->next;\n+      if (next)\n+\tfprintf (stderr, \",\");\n+    }\n+  fprintf (stderr, \"\\n\");\n+  return head;\n+}\n+\n+/* Print Iterator Stack*/\n+\n+void\n+pis ()\n+{\n+  struct iter_stack_node *stack_node;\n+\n+  fprintf (stderr, \"--SubLevel: \");\n+  pixl (sublevel_ixpansions.first);\n+  fprintf (stderr, \"--Stack:--\\n\");\n+  for (stack_node = iter_stack;\n+       stack_node;\n+       stack_node = stack_node->next)\n+    pixl (stack_node->first);\n+}\n+#endif"}]}