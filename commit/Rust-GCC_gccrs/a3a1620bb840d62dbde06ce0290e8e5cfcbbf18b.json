{"sha": "a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhMTYyMGJiODQwZDYyZGJkZTA2Y2UwMjkwZThlNWNmY2JiZjE4Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-01-20T02:36:16Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-01-20T02:36:16Z"}, "message": "PR72792 PR72793 relax requirements on rebind members\n\n\tPR libstdc++/72792\n\tPR libstdc++/72793\n\t* include/bits/alloc_traits.h (__allocator_traits_base::__rebind):\n\tReplace with class template using void_t.\n\t(__alloc_rebind): Define in terms of\n\t__allocator_traits_base::__rebind.\n\t(allocator_traits): Remove unconditional static_assert for\n\trebind_alloc.\n\t* include/bits/ptr_traits.h (__replace_first_arg): Remove type member.\n\t(pointer_traits::__rebind): Replace with class template using void_t.\n\t(pointer_traits::rebind): Define in terms of __rebind.\n\t(pointer_traits): Remove unconditional static_assert for rebind.\n\t* testsuite/20_util/allocator_traits/members/rebind_alloc.cc: New test.\n\t* testsuite/20_util/pointer_traits/rebind.cc: New test.\n\nFrom-SVN: r244680", "tree": {"sha": "a8129bd7cd698ffbc306fef0a1ba2f58053e5eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8129bd7cd698ffbc306fef0a1ba2f58053e5eab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "198766b6488cf0b50b3cff97099fb1c0482a9f3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198766b6488cf0b50b3cff97099fb1c0482a9f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/198766b6488cf0b50b3cff97099fb1c0482a9f3a"}], "stats": {"total": 194, "additions": 180, "deletions": 14}, "files": [{"sha": "c8cdaaa04fbb56d2f278b0bf27410f095e7cbe36", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "patch": "@@ -1,5 +1,20 @@\n 2017-01-20  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/72792\n+\tPR libstdc++/72793\n+\t* include/bits/alloc_traits.h (__allocator_traits_base::__rebind):\n+\tReplace with class template using void_t.\n+\t(__alloc_rebind): Define in terms of\n+\t__allocator_traits_base::__rebind.\n+\t(allocator_traits): Remove unconditional static_assert for\n+\trebind_alloc.\n+\t* include/bits/ptr_traits.h (__replace_first_arg): Remove type member.\n+\t(pointer_traits::__rebind): Replace with class template using void_t.\n+\t(pointer_traits::rebind): Define in terms of __rebind.\n+\t(pointer_traits): Remove unconditional static_assert for rebind.\n+\t* testsuite/20_util/allocator_traits/members/rebind_alloc.cc: New test.\n+\t* testsuite/20_util/pointer_traits/rebind.cc: New test.\n+\n \tPR libstdc++/69321\n \t* include/experimental/any (__any_caster): Avoid instantiating\n \tmanager function for types that can't be stored in any."}, {"sha": "a836711166648ed936d303537669db087982a7ca", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "patch": "@@ -44,8 +44,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   struct __allocator_traits_base\n   {\n-    template<typename _Alloc, typename _Up>\n-      using __rebind = typename _Alloc::template rebind<_Up>::other;\n+    template<typename _Tp, typename _Up, typename = void>\n+      struct __rebind : __replace_first_arg<_Tp, _Up> { };\n+\n+    template<typename _Tp, typename _Up>\n+      struct __rebind<_Tp, _Up,\n+\t\t      __void_t<typename _Tp::template rebind<_Up>::other>>\n+      { using type = typename _Tp::template rebind<_Up>::other; };\n \n   protected:\n     template<typename _Tp>\n@@ -71,9 +76,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   };\n \n   template<typename _Alloc, typename _Up>\n-    using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,\n-\t\t\t\t\t    __allocator_traits_base::__rebind,\n-\t\t\t\t\t    _Alloc, _Up>;\n+    using __alloc_rebind\n+      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;\n \n   /**\n    * @brief  Uniform interface to all allocator types.\n@@ -184,9 +188,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Tp>\n \tusing rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n \n-      static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,\n-\t  \"allocator defines rebind or is like Alloc<T, Args>\");\n-\n     private:\n       template<typename _Alloc2>\n \tstatic auto"}, {"sha": "d390d04099ea53773a49e8290ca8cb755ffe7e6e", "filename": "libstdc++-v3/include/bits/ptr_traits.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h?ref=a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "patch": "@@ -56,7 +56,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Given Template<T, ...> and U return Template<U, ...>, otherwise invalid.\n   template<typename _Tp, typename _Up>\n     struct __replace_first_arg\n-    { using type = __undefined; };\n+    { };\n \n   template<template<typename, typename...> class _Template, typename _Up,\n            typename _Tp, typename... _Types>\n@@ -84,8 +84,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Tp>\n \tusing __difference_type = typename _Tp::difference_type;\n \n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __rebind : __replace_first_arg<_Tp, _Up> { };\n+\n       template<typename _Tp, typename _Up>\n-\tusing __rebind = typename _Tp::template rebind<_Up>;\n+\tstruct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>\n+\t{ using type = typename _Tp::template rebind<_Up>; };\n \n     public:\n       /// The pointer type.\n@@ -101,17 +105,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       /// A pointer to a different type.\n       template<typename _Up>\n-        using rebind\n-\t  = __detected_or_t_<__replace_first_arg_t, __rebind, _Ptr, _Up>;\n+        using rebind = typename __rebind<_Ptr, _Up>::type;\n \n       static _Ptr\n       pointer_to(__make_not_void<element_type>& __e)\n       { return _Ptr::pointer_to(__e); }\n \n       static_assert(!is_same<element_type, __undefined>::value,\n \t  \"pointer type defines element_type or is like SomePointer<T, Args>\");\n-      static_assert(!is_same<rebind<element_type>, __undefined>::value,\n-\t  \"pointer type defines rebind<U> or is like SomePointer<T, Args>\");\n     };\n \n   /**"}, {"sha": "60a624911437277af8aadf81c241a14386a91e54", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/rebind_alloc.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Frebind_alloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Frebind_alloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Frebind_alloc.cc?ref=a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <memory>\n+\n+using std::is_same;\n+\n+template<typename T, typename U>\n+  using Rebind = typename std::allocator_traits<T>::template rebind_alloc<U>;\n+\n+template<typename T>\n+  struct HasRebind {\n+    using value_type = T;\n+    template<typename U> struct rebind { using other = std::allocator<U>; };\n+  };\n+\n+static_assert(is_same<Rebind<HasRebind<int>, long>,\n+\t\t      std::allocator<long>>::value,\n+\t      \"nested alias template is used\");\n+\n+template<typename T>\n+  struct NoRebind0 {\n+    using value_type = T;\n+  };\n+\n+static_assert(is_same<Rebind<NoRebind0<int>, long>,\n+\t\t      NoRebind0<long>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, typename>\n+  struct NoRebind1 {\n+    using value_type = T;\n+  };\n+\n+static_assert(is_same<Rebind<NoRebind1<int, void>, long>,\n+\t\t      NoRebind1<long, void>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, typename, typename>\n+  struct NoRebind2 {\n+    using value_type = T;\n+  };\n+\n+static_assert(is_same<Rebind<NoRebind2<int, void, void>, long>,\n+\t\t      NoRebind2<long, void, void>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, typename...>\n+  struct NoRebindN {\n+    using value_type = T;\n+  };\n+\n+static_assert(is_same<Rebind<NoRebindN<int>, long>,\n+\t\t      NoRebindN<long>>::value,\n+\t      \"first template argument is replaced\");\n+static_assert(is_same<Rebind<NoRebindN<int, void>, long>,\n+\t\t      NoRebindN<long, void>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, int = 0>\n+  struct CannotRebind {\n+    using value_type = T;\n+  };\n+// PR libstdc++/72792 specialization of allocator_traits is still well-formed:\n+std::allocator_traits<CannotRebind<int>>::value_type v;"}, {"sha": "a62815988ede5805a1d5820d19419b7f346a60f8", "filename": "libstdc++-v3/testsuite/20_util/pointer_traits/rebind.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frebind.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frebind.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frebind.cc?ref=a3a1620bb840d62dbde06ce0290e8e5cfcbbf18b", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <memory>\n+\n+using std::is_same;\n+\n+template<typename T, typename U>\n+  using Rebind = typename std::pointer_traits<T>::template rebind<U>;\n+\n+template<typename T>\n+  struct HasRebind {\n+    template<typename U> using rebind = U*;\n+  };\n+\n+static_assert(is_same<Rebind<HasRebind<int>, long>,\n+\t\t      long*>::value,\n+\t      \"nested alias template is used\");\n+\n+template<typename T> struct NoRebind0 { };\n+\n+static_assert(is_same<Rebind<NoRebind0<int>, long>,\n+\t\t      NoRebind0<long>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, typename> struct NoRebind1 { };\n+\n+static_assert(is_same<Rebind<NoRebind1<int, void>, long>,\n+\t\t      NoRebind1<long, void>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, typename, typename> struct NoRebind2 { };\n+\n+static_assert(is_same<Rebind<NoRebind2<int, void, void>, long>,\n+\t\t      NoRebind2<long, void, void>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, typename...> struct NoRebindN { };\n+\n+static_assert(is_same<Rebind<NoRebindN<int>, long>,\n+\t\t      NoRebindN<long>>::value,\n+\t      \"first template argument is replaced\");\n+static_assert(is_same<Rebind<NoRebindN<int, void>, long>,\n+\t\t      NoRebindN<long, void>>::value,\n+\t      \"first template argument is replaced\");\n+\n+template<typename T, int = 0>\n+  struct CannotRebind {\n+    using element_type = T;\n+  };\n+// PR libstdc++/72793 specialization of pointer_traits is still well-formed:\n+std::pointer_traits<CannotRebind<int>>::element_type e;"}]}