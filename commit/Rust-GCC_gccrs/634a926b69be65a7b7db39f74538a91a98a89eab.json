{"sha": "634a926b69be65a7b7db39f74538a91a98a89eab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM0YTkyNmI2OWJlNjVhN2I3ZGIzOWY3NDUzOGE5MWE5OGE4OWVhYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T13:19:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T13:19:23Z"}, "message": "[multiple changes]\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* comperr.adb (Compiler_Abort): Add a pair of pragma Warnings\n\tOn/Off to defend against a spurious warning in conditional\n\tcompilation.\n\t* exp_ch4.adb (Rewrite_Comparison): Reimplemented.\n\t* namet.adb (Finalize): Add a pair of pragma Warnings On/Off to\n\tdefend against a spurious warning in conditional compilation.\n\t* output.adb Add a pair of pragma Warnings On/Off to defend\n\tagainst a spurious warning in conditional compilation.\n\t* sem_eval.adb (Eval_Relational_Op): Major code clean up.\n\t(Fold_General_Op): New routine.\n\t(Fold_Static_Real_Op): New routine.\n\t(Test_Comparison): New routine.\n\t* sem_eval.ads (Test_Comparison): New routine.\n\t* sem_warn.adb (Is_Attribute_Constant_Comparison): New routine.\n\t(Warn_On_Constant_Valid_Condition): New routine.\n\t(Warn_On_Known_Condition): Use Is_Attribute_Constant_Comparison\n\tto detect a specific case.\n\t* sem_warn.adb (Warn_On_Constant_Valid_Condition): New routine.\n\t* urealp.adb (Tree_Read): Add a pair of pragma Warnings On/Off\n\tto defend against a spurious warning in conditional compilation.\n\t(Tree_Write): Add a pair of pragma Warnings On/Off to defend\n\tagainst a spurious warning in conditional compilation.\n\t* usage.adb Add a pair of pragma Warnings On/Off to defend\n\tagainst a spurious warning in conditional compilation.\n\n2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sinfo.ads, sem_ch13.adb: Update comment.\n\nFrom-SVN: r247224", "tree": {"sha": "530e84594a50d84c8b9b035436abbf141e1cd7c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/530e84594a50d84c8b9b035436abbf141e1cd7c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/634a926b69be65a7b7db39f74538a91a98a89eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634a926b69be65a7b7db39f74538a91a98a89eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634a926b69be65a7b7db39f74538a91a98a89eab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634a926b69be65a7b7db39f74538a91a98a89eab/comments", "author": null, "committer": null, "parents": [{"sha": "884f97cc82df643671e6df4ed43a49518311022a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884f97cc82df643671e6df4ed43a49518311022a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884f97cc82df643671e6df4ed43a49518311022a"}], "stats": {"total": 1028, "additions": 585, "deletions": 443}, "files": [{"sha": "d83d4f651f27c0ef362b7c6a9f6574d06c4ef716", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -1,3 +1,34 @@\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* comperr.adb (Compiler_Abort): Add a pair of pragma Warnings\n+\tOn/Off to defend against a spurious warning in conditional\n+\tcompilation.\n+\t* exp_ch4.adb (Rewrite_Comparison): Reimplemented.\n+\t* namet.adb (Finalize): Add a pair of pragma Warnings On/Off to\n+\tdefend against a spurious warning in conditional compilation.\n+\t* output.adb Add a pair of pragma Warnings On/Off to defend\n+\tagainst a spurious warning in conditional compilation.\n+\t* sem_eval.adb (Eval_Relational_Op): Major code clean up.\n+\t(Fold_General_Op): New routine.\n+\t(Fold_Static_Real_Op): New routine.\n+\t(Test_Comparison): New routine.\n+\t* sem_eval.ads (Test_Comparison): New routine.\n+\t* sem_warn.adb (Is_Attribute_Constant_Comparison): New routine.\n+\t(Warn_On_Constant_Valid_Condition): New routine.\n+\t(Warn_On_Known_Condition): Use Is_Attribute_Constant_Comparison\n+\tto detect a specific case.\n+\t* sem_warn.adb (Warn_On_Constant_Valid_Condition): New routine.\n+\t* urealp.adb (Tree_Read): Add a pair of pragma Warnings On/Off\n+\tto defend against a spurious warning in conditional compilation.\n+\t(Tree_Write): Add a pair of pragma Warnings On/Off to defend\n+\tagainst a spurious warning in conditional compilation.\n+\t* usage.adb Add a pair of pragma Warnings On/Off to defend\n+\tagainst a spurious warning in conditional compilation.\n+\n+2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sinfo.ads, sem_ch13.adb: Update comment.\n+\n 2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_util.adb (Is_Post_State): A reference to a"}, {"sha": "b3e20a41f1a1c0d38fbc856444d2368330f41a7c", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -98,9 +98,18 @@ package body Comperr is\n          Write_Eol;\n       end End_Line;\n \n+      --  Disable the warnings emitted by -gnatwc because the following two\n+      --  constants are initialized by means of conditional compilation.\n+\n+      pragma Warnings\n+        (Off, \"condition can only be * if invalid values present\");\n+\n       Is_GPL_Version : constant Boolean := Gnatvsn.Build_Type = GPL;\n       Is_FSF_Version : constant Boolean := Gnatvsn.Build_Type = FSF;\n \n+      pragma Warnings\n+        (On, \"condition can only be * if invalid values present\");\n+\n    --  Start of processing for Compiler_Abort\n \n    begin"}, {"sha": "7070781b6cb29cca90faf1ed58edaa5340af358f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 23, "deletions": 119, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -13211,12 +13211,10 @@ package body Exp_Ch4 is\n    ------------------------\n \n    procedure Rewrite_Comparison (N : Node_Id) is\n-      Warning_Generated : Boolean := False;\n-      --  Set to True if first pass with Assume_Valid generates a warning in\n-      --  which case we skip the second pass to avoid warning overloaded.\n+      Typ : constant Entity_Id := Etype (N);\n \n-      Result : Node_Id;\n-      --  Set to Standard_True or Standard_False\n+      False_Result : Boolean;\n+      True_Result  : Boolean;\n \n    begin\n       if Nkind (N) = N_Type_Conversion then\n@@ -13227,125 +13225,31 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  Now start looking at the comparison in detail. We potentially go\n-      --  through this loop twice. The first time, Assume_Valid is set False\n-      --  in the call to Compile_Time_Compare. If this call results in a\n-      --  clear result of always True or Always False, that's decisive and\n-      --  we are done. Otherwise we repeat the processing with Assume_Valid\n-      --  set to True to generate additional warnings. We can skip that step\n-      --  if Constant_Condition_Warnings is False.\n+      --  Determine the potential outcome of the comparison assuming that the\n+      --  operands are valid and emit a warning when the comparison evaluates\n+      --  to True or False only in the presence of invalid values.\n \n-      for AV in False .. True loop\n-         declare\n-            Typ : constant Entity_Id := Etype (N);\n-            Op1 : constant Node_Id   := Left_Opnd (N);\n-            Op2 : constant Node_Id   := Right_Opnd (N);\n+      Warn_On_Constant_Valid_Condition (N);\n \n-            Res : constant Compare_Result :=\n-                    Compile_Time_Compare (Op1, Op2, Assume_Valid => AV);\n-            --  Res indicates if compare outcome can be compile time determined\n+      --  Determine the potential outcome of the comparison assuming that the\n+      --  operands are not valid.\n \n-            True_Result  : Boolean;\n-            False_Result : Boolean;\n-\n-         begin\n-            case N_Op_Compare (Nkind (N)) is\n-               when N_Op_Eq =>\n-                  True_Result  := Res = EQ;\n-                  False_Result := Res = LT or else Res = GT or else Res = NE;\n-\n-               when N_Op_Ge =>\n-                  True_Result  := Res in Compare_GE;\n-                  False_Result := Res = LT;\n-\n-                  if Res = LE\n-                    and then Constant_Condition_Warnings\n-                    and then Comes_From_Source (Original_Node (N))\n-                    and then Nkind (Original_Node (N)) = N_Op_Ge\n-                    and then not In_Instance\n-                    and then Is_Integer_Type (Etype (Left_Opnd (N)))\n-                    and then not Has_Warnings_Off (Etype (Left_Opnd (N)))\n-                  then\n-                     Error_Msg_N\n-                       (\"can never be greater than, could replace by \"\n-                        & \"\"\"'=\"\"?c?\", N);\n-                     Warning_Generated := True;\n-                  end if;\n-\n-               when N_Op_Gt =>\n-                  True_Result  := Res = GT;\n-                  False_Result := Res in Compare_LE;\n-\n-               when N_Op_Lt =>\n-                  True_Result  := Res = LT;\n-                  False_Result := Res in Compare_GE;\n-\n-               when N_Op_Le =>\n-                  True_Result  := Res in Compare_LE;\n-                  False_Result := Res = GT;\n-\n-                  if Res = GE\n-                    and then Constant_Condition_Warnings\n-                    and then Comes_From_Source (Original_Node (N))\n-                    and then Nkind (Original_Node (N)) = N_Op_Le\n-                    and then not In_Instance\n-                    and then Is_Integer_Type (Etype (Left_Opnd (N)))\n-                    and then not Has_Warnings_Off (Etype (Left_Opnd (N)))\n-                  then\n-                     Error_Msg_N\n-                       (\"can never be less than, could replace by \"\"'=\"\"?c?\",\n-                        N);\n-                     Warning_Generated := True;\n-                  end if;\n-\n-               when N_Op_Ne =>\n-                  True_Result  := Res = NE or else Res = GT or else Res = LT;\n-                  False_Result := Res = EQ;\n-            end case;\n-\n-            --  If this is the first iteration, then we actually convert the\n-            --  comparison into True or False, if the result is certain.\n-\n-            if AV = False then\n-               if True_Result or False_Result then\n-                  Result := Boolean_Literals (True_Result);\n-                  Rewrite (N,\n-                    Convert_To (Typ,\n-                      New_Occurrence_Of (Result, Sloc (N))));\n-                  Analyze_And_Resolve (N, Typ);\n-                  Warn_On_Known_Condition (N);\n-                  return;\n-               end if;\n+      Test_Comparison\n+        (Op           => N,\n+         Assume_Valid => False,\n+         True_Result  => True_Result,\n+         False_Result => False_Result);\n \n-            --  If this is the second iteration (AV = True), and the original\n-            --  node comes from source and we are not in an instance, then give\n-            --  a warning if we know result would be True or False. Note: we\n-            --  know Constant_Condition_Warnings is set if we get here.\n+      --  The outcome is a decisive False or True, rewrite the operator\n \n-            elsif Comes_From_Source (Original_Node (N))\n-              and then not In_Instance\n-            then\n-               if True_Result then\n-                  Error_Msg_N\n-                    (\"condition can only be False if invalid values present??\",\n-                     N);\n-               elsif False_Result then\n-                  Error_Msg_N\n-                    (\"condition can only be True if invalid values present??\",\n-                     N);\n-               end if;\n-            end if;\n-         end;\n-\n-         --  Skip second iteration if not warning on constant conditions or\n-         --  if the first iteration already generated a warning of some kind or\n-         --  if we are in any case assuming all values are valid (so that the\n-         --  first iteration took care of the valid case).\n+      if False_Result or True_Result then\n+         Rewrite (N,\n+           Convert_To (Typ,\n+             New_Occurrence_Of (Boolean_Literals (True_Result), Sloc (N))));\n \n-         exit when not Constant_Condition_Warnings;\n-         exit when Warning_Generated;\n-         exit when Assume_No_Invalid_Values;\n-      end loop;\n+         Analyze_And_Resolve (N, Typ);\n+         Warn_On_Known_Condition (N);\n+      end if;\n    end Rewrite_Comparison;\n \n    ----------------------------"}, {"sha": "a1610468a7494da84874d69afa1c41b4489e23ec", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -672,6 +672,12 @@ package body Namet is\n                   Max_Chain_Length := C;\n                end if;\n \n+               --  Disable the warnings emitted by -gnatwc because the tests\n+               --  involving Verbosity involve conditional compilation.\n+\n+               pragma Warnings\n+                 (Off, \"condition can only be * if invalid values present\");\n+\n                if Verbosity >= 2 then\n                   Write_Str (\"Hash_Table (\");\n                   Write_Int (J);\n@@ -703,6 +709,9 @@ package body Namet is\n                      N := Name_Entries.Table (N).Hash_Link;\n                   end loop;\n                end if;\n+\n+               pragma Warnings\n+                 (On, \"condition can only be * if invalid values present\");\n             end;\n          end if;\n       end loop;"}, {"sha": "34e54d838f6ffa593ebbf6d0d573f46c3a6d0400", "filename": "gcc/ada/output.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Foutput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Foutput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,7 +55,12 @@ package body Output is\n    Indentation_Limit : constant Positive := 40;\n    --  Indentation beyond this number of spaces wraps around\n \n+   --  Disable the warnings emitted by -gnatwc because the comparison within\n+   --  the assertion depends on conditional compilation.\n+\n+   pragma Warnings (Off, \"condition can only be * if invalid values present\");\n    pragma Assert (Indentation_Limit < Buffer_Max / 2);\n+   pragma Warnings (On,  \"condition can only be * if invalid values present\");\n    --  Make sure this is substantially shorter than the line length\n \n    Cur_Indentation : Natural := 0;"}, {"sha": "ca8a5cc9f5df017366f79b3af9ad1f4768984acc", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -2456,7 +2456,8 @@ package body Sem_Ch13 is\n \n                      goto Continue;\n \n-                  --  For tasks pass the aspect as an attribute\n+                  --  For task and protected types pass the aspect as an\n+                  --  attribute.\n \n                   else\n                      Aitem :="}, {"sha": "855614957d41dcc682d61b5581fde0f649ceaa66", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 387, "deletions": 308, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3144,274 +3144,364 @@ package body Sem_Eval is\n    --  equality test A = \"ABC\", and the former is definitely static.\n \n    procedure Eval_Relational_Op (N : Node_Id) is\n-      Left   : constant Node_Id   := Left_Opnd (N);\n-      Right  : constant Node_Id   := Right_Opnd (N);\n-      Typ    : constant Entity_Id := Etype (Left);\n-      Otype  : Entity_Id := Empty;\n-      Result : Boolean;\n+      Left  : constant Node_Id := Left_Opnd  (N);\n+      Right : constant Node_Id := Right_Opnd (N);\n \n-   begin\n-      --  One special case to deal with first. If we can tell that the result\n-      --  will be false because the lengths of one or more index subtypes are\n-      --  compile time known and different, then we can replace the entire\n-      --  result by False. We only do this for one dimensional arrays, because\n-      --  the case of multi-dimensional arrays is rare and too much trouble. If\n-      --  one of the operands is an illegal aggregate, its type might still be\n-      --  an arbitrary composite type, so nothing to do.\n+      procedure Decompose_Expr\n+        (Expr : Node_Id;\n+         Ent  : out Entity_Id;\n+         Kind : out Character;\n+         Cons : out Uint;\n+         Orig : Boolean := True);\n+      --  Given expression Expr, see if it is of the form X [+/- K]. If so, Ent\n+      --  is set to the entity in X, Kind is 'F','L','E' for 'First or 'Last or\n+      --  simple entity, and Cons is the value of K. If the expression is not\n+      --  of the required form, Ent is set to Empty.\n+      --\n+      --  Orig indicates whether Expr is the original expression to consider,\n+      --  or if we are handling a sub-expression (e.g. recursive call to\n+      --  Decompose_Expr).\n+\n+      procedure Fold_General_Op (Is_Static : Boolean);\n+      --  Attempt to fold arbitrary relational operator N. Flag Is_Static must\n+      --  be set when the operator denotes a static expression.\n+\n+      procedure Fold_Static_Real_Op;\n+      --  Attempt to fold static real type relational operator N\n+\n+      function Static_Length (Expr : Node_Id) return Uint;\n+      --  If Expr is an expression for a constrained array whose length is\n+      --  known at compile time, return the non-negative length, otherwise\n+      --  return -1.\n+\n+      --------------------\n+      -- Decompose_Expr --\n+      --------------------\n+\n+      procedure Decompose_Expr\n+        (Expr : Node_Id;\n+         Ent  : out Entity_Id;\n+         Kind : out Character;\n+         Cons : out Uint;\n+         Orig : Boolean := True)\n+      is\n+         Exp : Node_Id;\n \n-      if Is_Array_Type (Typ)\n-        and then Typ /= Any_Composite\n-        and then Number_Dimensions (Typ) = 1\n-        and then (Nkind (N) = N_Op_Eq or else Nkind (N) = N_Op_Ne)\n-      then\n-         if Raises_Constraint_Error (Left)\n-              or else\n-            Raises_Constraint_Error (Right)\n+      begin\n+         --  Assume that the expression does not meet the expected form\n+\n+         Cons := No_Uint;\n+         Ent  := Empty;\n+         Kind := '?';\n+\n+         if Nkind (Expr) = N_Op_Add\n+           and then Compile_Time_Known_Value (Right_Opnd (Expr))\n          then\n-            return;\n+            Exp  := Left_Opnd (Expr);\n+            Cons := Expr_Value (Right_Opnd (Expr));\n+\n+         elsif Nkind (Expr) = N_Op_Subtract\n+           and then Compile_Time_Known_Value (Right_Opnd (Expr))\n+         then\n+            Exp  := Left_Opnd (Expr);\n+            Cons := -Expr_Value (Right_Opnd (Expr));\n+\n+         --  If the bound is a constant created to remove side effects, recover\n+         --  the original expression to see if it has one of the recognizable\n+         --  forms.\n+\n+         elsif Nkind (Expr) = N_Identifier\n+           and then not Comes_From_Source (Entity (Expr))\n+           and then Ekind (Entity (Expr)) = E_Constant\n+           and then Nkind (Parent (Entity (Expr))) = N_Object_Declaration\n+         then\n+            Exp := Expression (Parent (Entity (Expr)));\n+            Decompose_Expr (Exp, Ent, Kind, Cons, Orig => False);\n+\n+            --  If original expression includes an entity, create a reference\n+            --  to it for use below.\n+\n+            if Present (Ent) then\n+               Exp := New_Occurrence_Of (Ent, Sloc (Ent));\n+            else\n+               return;\n+            end if;\n+\n+         else\n+            --  Only consider the case of X + 0 for a full expression, and\n+            --  not when recursing, otherwise we may end up with evaluating\n+            --  expressions not known at compile time to 0.\n+\n+            if Orig then\n+               Exp  := Expr;\n+               Cons := Uint_0;\n+            else\n+               return;\n+            end if;\n          end if;\n \n-         --  OK, we have the case where we may be able to do this fold\n+         --  At this stage Exp is set to the potential X\n \n-         Length_Mismatch : declare\n-            procedure Get_Static_Length (Op : Node_Id; Len : out Uint);\n-            --  If Op is an expression for a constrained array with a known at\n-            --  compile time length, then Len is set to this (non-negative\n-            --  length). Otherwise Len is set to minus 1.\n+         if Nkind (Exp) = N_Attribute_Reference then\n+            if Attribute_Name (Exp) = Name_First then\n+               Kind := 'F';\n+            elsif Attribute_Name (Exp) = Name_Last then\n+               Kind := 'L';\n+            else\n+               return;\n+            end if;\n \n-            -----------------------\n-            -- Get_Static_Length --\n-            -----------------------\n+            Exp := Prefix (Exp);\n \n-            procedure Get_Static_Length (Op : Node_Id; Len : out Uint) is\n-               T : Entity_Id;\n+         else\n+            Kind := 'E';\n+         end if;\n \n-            begin\n-               --  First easy case string literal\n+         if Is_Entity_Name (Exp) and then Present (Entity (Exp)) then\n+            Ent := Entity (Exp);\n+         end if;\n+      end Decompose_Expr;\n+\n+      ---------------------\n+      -- Fold_General_Op --\n+      ---------------------\n+\n+      procedure Fold_General_Op (Is_Static : Boolean) is\n+         CR : constant Compare_Result :=\n+                Compile_Time_Compare (Left, Right, Assume_Valid => False);\n \n-               if Nkind (Op) = N_String_Literal then\n-                  Len := UI_From_Int (String_Length (Strval (Op)));\n+         Result : Boolean;\n+\n+      begin\n+         if CR = Unknown then\n+            return;\n+         end if;\n+\n+         case Nkind (N) is\n+            when N_Op_Eq =>\n+               if CR = EQ then\n+                  Result := True;\n+               elsif CR = NE or else CR = GT or else CR = LT then\n+                  Result := False;\n+               else\n                   return;\n                end if;\n \n-               --  Second easy case, not constrained subtype, so no length\n-\n-               if not Is_Constrained (Etype (Op)) then\n-                  Len := Uint_Minus_1;\n+            when N_Op_Ge =>\n+               if CR = GT or else CR = EQ or else CR = GE then\n+                  Result := True;\n+               elsif CR = LT then\n+                  Result := False;\n+               else\n                   return;\n                end if;\n \n-               --  General case\n+            when N_Op_Gt =>\n+               if CR = GT then\n+                  Result := True;\n+               elsif CR = EQ or else CR = LT or else CR = LE then\n+                  Result := False;\n+               else\n+                  return;\n+               end if;\n \n-               T := Etype (First_Index (Etype (Op)));\n+            when N_Op_Le =>\n+               if CR = LT or else CR = EQ or else CR = LE then\n+                  Result := True;\n+               elsif CR = GT then\n+                  Result := False;\n+               else\n+                  return;\n+               end if;\n \n-               --  The simple case, both bounds are known at compile time\n+            when N_Op_Lt =>\n+               if CR = LT then\n+                  Result := True;\n+               elsif CR = EQ or else CR = GT or else CR = GE then\n+                  Result := False;\n+               else\n+                  return;\n+               end if;\n \n-               if Is_Discrete_Type (T)\n-                 and then Compile_Time_Known_Value (Type_Low_Bound (T))\n-                 and then Compile_Time_Known_Value (Type_High_Bound (T))\n-               then\n-                  Len := UI_Max (Uint_0,\n-                                 Expr_Value (Type_High_Bound (T)) -\n-                                   Expr_Value (Type_Low_Bound  (T)) + 1);\n+            when N_Op_Ne =>\n+               if CR = NE or else CR = GT or else CR = LT then\n+                  Result := True;\n+               elsif CR = EQ then\n+                  Result := False;\n+               else\n                   return;\n                end if;\n \n-               --  A more complex case, where the bounds are of the form\n-               --  X [+/- K1] .. X [+/- K2]), where X is an expression that is\n-               --  either A'First or A'Last (with A an entity name), or X is an\n-               --  entity name, and the two X's are the same and K1 and K2 are\n-               --  known at compile time, in this case, the length can also be\n-               --  computed at compile time, even though the bounds are not\n-               --  known. A common case of this is e.g. (X'First .. X'First+5).\n-\n-               Extract_Length : declare\n-                  procedure Decompose_Expr\n-                    (Expr : Node_Id;\n-                     Ent  : out Entity_Id;\n-                     Kind : out Character;\n-                     Cons : out Uint;\n-                     Orig : Boolean := True);\n-                  --  Given an expression see if it is of the form given above,\n-                  --  X [+/- K]. If so Ent is set to the entity in X, Kind is\n-                  --  'F','L','E' for 'First/'Last/simple entity, and Cons is\n-                  --  the value of K. If the expression is not of the required\n-                  --  form, Ent is set to Empty.\n-                  --\n-                  --  Orig indicates whether Expr is the original expression\n-                  --  to consider, or if we are handling a sub-expression\n-                  --  (e.g. recursive call to Decompose_Expr).\n-\n-                  --------------------\n-                  -- Decompose_Expr --\n-                  --------------------\n-\n-                  procedure Decompose_Expr\n-                    (Expr : Node_Id;\n-                     Ent  : out Entity_Id;\n-                     Kind : out Character;\n-                     Cons : out Uint;\n-                     Orig : Boolean := True)\n-                  is\n-                     Exp : Node_Id;\n+            when others =>\n+               raise Program_Error;\n+         end case;\n \n-                  begin\n-                     Ent := Empty;\n+         --  Determine the potential outcome of the relation assuming the\n+         --  operands are valid and emit a warning when the relation yields\n+         --  True or False only in the presence of invalid values.\n \n-                     --  Ignored values:\n+         Warn_On_Constant_Valid_Condition (N);\n \n-                     Kind := '?';\n-                     Cons := No_Uint;\n+         Fold_Uint (N, Test (Result), Is_Static);\n+      end Fold_General_Op;\n \n-                     if Nkind (Expr) = N_Op_Add\n-                       and then Compile_Time_Known_Value (Right_Opnd (Expr))\n-                     then\n-                        Exp  := Left_Opnd (Expr);\n-                        Cons := Expr_Value (Right_Opnd (Expr));\n+      -------------------------\n+      -- Fold_Static_Real_Op --\n+      -------------------------\n \n-                     elsif Nkind (Expr) = N_Op_Subtract\n-                       and then Compile_Time_Known_Value (Right_Opnd (Expr))\n-                     then\n-                        Exp  := Left_Opnd (Expr);\n-                        Cons := -Expr_Value (Right_Opnd (Expr));\n+      procedure Fold_Static_Real_Op is\n+         Left_Real  : constant Ureal := Expr_Value_R (Left);\n+         Right_Real : constant Ureal := Expr_Value_R (Right);\n+         Result     : Boolean;\n \n-                     --  If the bound is a constant created to remove side\n-                     --  effects, recover original expression to see if it has\n-                     --  one of the recognizable forms.\n+      begin\n+         case Nkind (N) is\n+            when N_Op_Eq => Result := (Left_Real =  Right_Real);\n+            when N_Op_Ge => Result := (Left_Real >= Right_Real);\n+            when N_Op_Gt => Result := (Left_Real >  Right_Real);\n+            when N_Op_Le => Result := (Left_Real <= Right_Real);\n+            when N_Op_Lt => Result := (Left_Real <  Right_Real);\n+            when N_Op_Ne => Result := (Left_Real /= Right_Real);\n+            when others  => raise Program_Error;\n+         end case;\n+\n+         Fold_Uint (N, Test (Result), True);\n+      end Fold_Static_Real_Op;\n \n-                     elsif Nkind (Expr) = N_Identifier\n-                       and then not Comes_From_Source (Entity (Expr))\n-                       and then Ekind (Entity (Expr)) = E_Constant\n-                       and then\n-                         Nkind (Parent (Entity (Expr))) = N_Object_Declaration\n-                     then\n-                        Exp := Expression (Parent (Entity (Expr)));\n-                        Decompose_Expr (Exp, Ent, Kind, Cons, Orig => False);\n+      -------------------\n+      -- Static_Length --\n+      -------------------\n \n-                        --  If original expression includes an entity, create a\n-                        --  reference to it for use below.\n+      function Static_Length (Expr : Node_Id) return Uint is\n+         Cons1 : Uint;\n+         Cons2 : Uint;\n+         Ent1  : Entity_Id;\n+         Ent2  : Entity_Id;\n+         Kind1 : Character;\n+         Kind2 : Character;\n+         Typ   : Entity_Id;\n \n-                        if Present (Ent) then\n-                           Exp := New_Occurrence_Of (Ent, Sloc (Ent));\n-                        else\n-                           return;\n-                        end if;\n+      begin\n+         --  First easy case string literal\n \n-                     else\n-                        --  Only consider the case of X + 0 for a full\n-                        --  expression, and not when recursing, otherwise we\n-                        --  may end up with evaluating expressions not known\n-                        --  at compile time to 0.\n-\n-                        if Orig then\n-                           Exp  := Expr;\n-                           Cons := Uint_0;\n-                        else\n-                           return;\n-                        end if;\n-                     end if;\n+         if Nkind (Expr) = N_String_Literal then\n+            return UI_From_Int (String_Length (Strval (Expr)));\n \n-                     --  At this stage Exp is set to the potential X\n+         --  Second easy case, not constrained subtype, so no length\n \n-                     if Nkind (Exp) = N_Attribute_Reference then\n-                        if Attribute_Name (Exp) = Name_First then\n-                           Kind := 'F';\n-                        elsif Attribute_Name (Exp) = Name_Last then\n-                           Kind := 'L';\n-                        else\n-                           return;\n-                        end if;\n+         elsif not Is_Constrained (Etype (Expr)) then\n+            return Uint_Minus_1;\n+         end if;\n \n-                        Exp := Prefix (Exp);\n+         --  General case\n \n-                     else\n-                        Kind := 'E';\n-                     end if;\n+         Typ := Etype (First_Index (Etype (Expr)));\n \n-                     if Is_Entity_Name (Exp)\n-                       and then Present (Entity (Exp))\n-                     then\n-                        Ent := Entity (Exp);\n-                     end if;\n-                  end Decompose_Expr;\n+         --  The simple case, both bounds are known at compile time\n \n-                  --  Local Variables\n+         if Is_Discrete_Type (Typ)\n+           and then Compile_Time_Known_Value (Type_Low_Bound (Typ))\n+           and then Compile_Time_Known_Value (Type_High_Bound (Typ))\n+         then\n+            return\n+              UI_Max (Uint_0, Expr_Value (Type_High_Bound (Typ)) -\n+                              Expr_Value (Type_Low_Bound  (Typ)) + 1);\n+         end if;\n \n-                  Ent1,  Ent2  : Entity_Id;\n-                  Kind1, Kind2 : Character;\n-                  Cons1, Cons2 : Uint;\n+         --  A more complex case, where the bounds are of the form X [+/- K1]\n+         --  .. X [+/- K2]), where X is an expression that is either A'First or\n+         --  A'Last (with A an entity name), or X is an entity name, and the\n+         --  two X's are the same and K1 and K2 are known at compile time, in\n+         --  this case, the length can also be computed at compile time, even\n+         --  though the bounds are not known. A common case of this is e.g.\n+         --  (X'First .. X'First+5).\n+\n+         Decompose_Expr\n+           (Original_Node (Type_Low_Bound  (Typ)), Ent1, Kind1, Cons1);\n+         Decompose_Expr\n+           (Original_Node (Type_High_Bound (Typ)), Ent2, Kind2, Cons2);\n+\n+         if Present (Ent1) and then Ent1 = Ent2 and then Kind1 = Kind2 then\n+            return Cons2 - Cons1 + 1;\n+         else\n+            return Uint_Minus_1;\n+         end if;\n+      end Static_Length;\n \n-               --  Start of processing for Extract_Length\n+      --  Local variables\n \n-               begin\n-                  Decompose_Expr\n-                    (Original_Node (Type_Low_Bound  (T)), Ent1, Kind1, Cons1);\n-                  Decompose_Expr\n-                    (Original_Node (Type_High_Bound (T)), Ent2, Kind2, Cons2);\n-\n-                  if Present (Ent1)\n-                    and then Ent1 = Ent2\n-                    and then Kind1 = Kind2\n-                  then\n-                     Len := Cons2 - Cons1 + 1;\n-                  else\n-                     Len := Uint_Minus_1;\n-                  end if;\n-               end Extract_Length;\n-            end Get_Static_Length;\n+      Left_Typ  : constant Entity_Id := Etype (Left);\n+      Right_Typ : constant Entity_Id := Etype (Right);\n+      Fold      : Boolean;\n+      Left_Len  : Uint;\n+      Op_Typ    : Entity_Id := Empty;\n+      Right_Len : Uint;\n+\n+      Is_Static_Expression : Boolean;\n \n-            --  Local Variables\n+   --  Start of processing for Eval_Relational_Op\n+\n+   begin\n+      --  One special case to deal with first. If we can tell that the result\n+      --  will be false because the lengths of one or more index subtypes are\n+      --  compile time known and different, then we can replace the entire\n+      --  result by False. We only do this for one dimensional arrays, because\n+      --  the case of multi-dimensional arrays is rare and too much trouble. If\n+      --  one of the operands is an illegal aggregate, its type might still be\n+      --  an arbitrary composite type, so nothing to do.\n \n-            Len_L : Uint;\n-            Len_R : Uint;\n+      if Is_Array_Type (Left_Typ)\n+        and then Left_Typ /= Any_Composite\n+        and then Number_Dimensions (Left_Typ) = 1\n+        and then Nkind_In (N, N_Op_Eq, N_Op_Ne)\n+      then\n+         if Raises_Constraint_Error (Left)\n+              or else\n+            Raises_Constraint_Error (Right)\n+         then\n+            return;\n \n-         --  Start of processing for Length_Mismatch\n+         --  OK, we have the case where we may be able to do this fold\n \n-         begin\n-            Get_Static_Length (Left,  Len_L);\n-            Get_Static_Length (Right, Len_R);\n+         else\n+            Left_Len  := Static_Length (Left);\n+            Right_Len := Static_Length (Right);\n \n-            if Len_L /= Uint_Minus_1\n-              and then Len_R /= Uint_Minus_1\n-              and then Len_L /= Len_R\n+            if Left_Len /= Uint_Minus_1\n+              and then Right_Len /= Uint_Minus_1\n+              and then Left_Len /= Right_Len\n             then\n                Fold_Uint (N, Test (Nkind (N) = N_Op_Ne), False);\n                Warn_On_Known_Condition (N);\n                return;\n             end if;\n-         end Length_Mismatch;\n-      end if;\n-\n-      declare\n-         Is_Static_Expression : Boolean;\n+         end if;\n \n-         Is_Foldable : Boolean;\n-         pragma Unreferenced (Is_Foldable);\n+      --  General case\n \n-      begin\n-         --  Initialize the value of Is_Static_Expression. The value of\n-         --  Is_Foldable returned by Test_Expression_Is_Foldable is not needed\n-         --  since, even when some operand is a variable, we can still perform\n-         --  the static evaluation of the expression in some cases (for\n-         --  example, for a variable of a subtype of Integer we statically\n-         --  know that any value stored in such variable is smaller than\n-         --  Integer'Last).\n+      else\n+         --  Initialize the value of Is_Static_Expression. The value of Fold\n+         --  returned by Test_Expression_Is_Foldable is not needed since, even\n+         --  when some operand is a variable, we can still perform the static\n+         --  evaluation of the expression in some cases (for example, for a\n+         --  variable of a subtype of Integer we statically know that any value\n+         --  stored in such variable is smaller than Integer'Last).\n \n          Test_Expression_Is_Foldable\n-           (N, Left, Right, Is_Static_Expression, Is_Foldable);\n+           (N, Left, Right, Is_Static_Expression, Fold);\n \n-         --  Only comparisons of scalars can give static results. In\n-         --  particular, comparisons of strings never yield a static\n-         --  result, even if both operands are static strings, except that\n-         --  as noted above, we allow equality/inequality for strings.\n+         --  Only comparisons of scalars can give static results. A comparison\n+         --  of strings never yields a static result, even if both operands are\n+         --  static strings, except that as noted above, we allow equality and\n+         --  inequality for strings.\n \n-         if Is_String_Type (Typ)\n+         if Is_String_Type (Left_Typ)\n            and then not Comes_From_Source (N)\n            and then Nkind_In (N, N_Op_Eq, N_Op_Ne)\n          then\n             null;\n \n-         elsif not Is_Scalar_Type (Typ) then\n+         elsif not Is_Scalar_Type (Left_Typ) then\n             Is_Static_Expression := False;\n             Set_Is_Static_Expression (N, False);\n          end if;\n@@ -3420,117 +3510,27 @@ package body Sem_Eval is\n          --  an explicit scope, determine appropriate specific numeric type,\n          --  and diagnose possible ambiguity.\n \n-         if Is_Universal_Numeric_Type (Etype (Left))\n+         if Is_Universal_Numeric_Type (Left_Typ)\n               and then\n-            Is_Universal_Numeric_Type (Etype (Right))\n+            Is_Universal_Numeric_Type (Right_Typ)\n          then\n-            Otype := Find_Universal_Operator_Type (N);\n+            Op_Typ := Find_Universal_Operator_Type (N);\n          end if;\n \n-         --  For static real type expressions, do not use Compile_Time_Compare\n-         --  since it worries about run-time results which are not exact.\n-\n-         if Is_Static_Expression and then Is_Real_Type (Typ) then\n-            declare\n-               Left_Real  : constant Ureal := Expr_Value_R (Left);\n-               Right_Real : constant Ureal := Expr_Value_R (Right);\n-\n-            begin\n-               case Nkind (N) is\n-                  when N_Op_Eq => Result := (Left_Real =  Right_Real);\n-                  when N_Op_Ne => Result := (Left_Real /= Right_Real);\n-                  when N_Op_Lt => Result := (Left_Real <  Right_Real);\n-                  when N_Op_Le => Result := (Left_Real <= Right_Real);\n-                  when N_Op_Gt => Result := (Left_Real >  Right_Real);\n-                  when N_Op_Ge => Result := (Left_Real >= Right_Real);\n-                  when others  => raise Program_Error;\n-               end case;\n-\n-               Fold_Uint (N, Test (Result), True);\n-            end;\n-\n-         --  For all other cases, we use Compile_Time_Compare to do the compare\n+         --  Attempt to fold the relational operator\n \n+         if Is_Static_Expression and then Is_Real_Type (Left_Typ) then\n+            Fold_Static_Real_Op;\n          else\n-            declare\n-               CR : constant Compare_Result :=\n-                      Compile_Time_Compare\n-                        (Left, Right, Assume_Valid => False);\n-\n-            begin\n-               if CR = Unknown then\n-                  return;\n-               end if;\n-\n-               case Nkind (N) is\n-                  when N_Op_Eq =>\n-                     if CR = EQ then\n-                        Result := True;\n-                     elsif CR = NE or else CR = GT or else CR = LT then\n-                        Result := False;\n-                     else\n-                        return;\n-                     end if;\n-\n-                  when N_Op_Ne =>\n-                     if CR = NE or else CR = GT or else CR = LT then\n-                        Result := True;\n-                     elsif CR = EQ then\n-                        Result := False;\n-                     else\n-                        return;\n-                     end if;\n-\n-                  when N_Op_Lt =>\n-                     if CR = LT then\n-                        Result := True;\n-                     elsif CR = EQ or else CR = GT or else CR = GE then\n-                        Result := False;\n-                     else\n-                        return;\n-                     end if;\n-\n-                  when N_Op_Le =>\n-                     if CR = LT or else CR = EQ or else CR = LE then\n-                        Result := True;\n-                     elsif CR = GT then\n-                        Result := False;\n-                     else\n-                        return;\n-                     end if;\n-\n-                  when N_Op_Gt =>\n-                     if CR = GT then\n-                        Result := True;\n-                     elsif CR = EQ or else CR = LT or else CR = LE then\n-                        Result := False;\n-                     else\n-                        return;\n-                     end if;\n-\n-                  when N_Op_Ge =>\n-                     if CR = GT or else CR = EQ or else CR = GE then\n-                        Result := True;\n-                     elsif CR = LT then\n-                        Result := False;\n-                     else\n-                        return;\n-                     end if;\n-\n-                  when others =>\n-                     raise Program_Error;\n-               end case;\n-            end;\n-\n-            Fold_Uint (N, Test (Result), Is_Static_Expression);\n+            Fold_General_Op (Is_Static_Expression);\n          end if;\n-      end;\n+      end if;\n \n       --  For the case of a folded relational operator on a specific numeric\n-      --  type, freeze operand type now.\n+      --  type, freeze the operand type now.\n \n-      if Present (Otype) then\n-         Freeze_Before (N, Otype);\n+      if Present (Op_Typ) then\n+         Freeze_Before (N, Op_Typ);\n       end if;\n \n       Warn_On_Known_Condition (N);\n@@ -6053,6 +6053,85 @@ package body Sem_Eval is\n       end if;\n    end Test;\n \n+   ---------------------\n+   -- Test_Comparison --\n+   ---------------------\n+\n+   procedure Test_Comparison\n+     (Op           : Node_Id;\n+      Assume_Valid : Boolean;\n+      True_Result  : out Boolean;\n+      False_Result : out Boolean)\n+   is\n+      Left     : constant Node_Id   := Left_Opnd (Op);\n+      Left_Typ : constant Entity_Id := Etype (Left);\n+      Orig_Op  : constant Node_Id   := Original_Node (Op);\n+\n+      procedure Replacement_Warning (Msg : String);\n+      --  Emit a warning on a comparison which can be replaced by '='\n+\n+      -------------------------\n+      -- Replacement_Warning --\n+      -------------------------\n+\n+      procedure Replacement_Warning (Msg : String) is\n+      begin\n+         if Constant_Condition_Warnings\n+           and then Comes_From_Source (Orig_Op)\n+           and then Is_Integer_Type (Left_Typ)\n+           and then not Error_Posted (Op)\n+           and then not Has_Warnings_Off (Left_Typ)\n+           and then not In_Instance\n+         then\n+            Error_Msg_N (Msg, Op);\n+         end if;\n+      end Replacement_Warning;\n+\n+      --  Local variables\n+\n+      Res : constant Compare_Result :=\n+              Compile_Time_Compare (Left, Right_Opnd (Op), Assume_Valid);\n+\n+   --  Start of processing for Test_Comparison\n+\n+   begin\n+      case N_Op_Compare (Nkind (Op)) is\n+         when N_Op_Eq =>\n+            True_Result  := Res = EQ;\n+            False_Result := Res = LT or else Res = GT or else Res = NE;\n+\n+         when N_Op_Ge =>\n+            True_Result  := Res in Compare_GE;\n+            False_Result := Res = LT;\n+\n+            if Res = LE and then Nkind (Orig_Op) = N_Op_Ge then\n+               Replacement_Warning\n+                 (\"can never be greater than, could replace by \"\"'=\"\"?c?\");\n+            end if;\n+\n+         when N_Op_Gt =>\n+            True_Result  := Res = GT;\n+            False_Result := Res in Compare_LE;\n+\n+         when N_Op_Le =>\n+            True_Result  := Res in Compare_LE;\n+            False_Result := Res = GT;\n+\n+            if Res = GE and then Nkind (Orig_Op) = N_Op_Le then\n+               Replacement_Warning\n+                 (\"can never be less than, could replace by \"\"'=\"\"?c?\");\n+            end if;\n+\n+         when N_Op_Lt =>\n+            True_Result  := Res = LT;\n+            False_Result := Res in Compare_GE;\n+\n+         when N_Op_Ne =>\n+            True_Result  := Res = NE or else Res = GT or else Res = LT;\n+            False_Result := Res = EQ;\n+      end case;\n+   end Test_Comparison;\n+\n    ---------------------------------\n    -- Test_Expression_Is_Foldable --\n    ---------------------------------"}, {"sha": "75d9d796ea07709abf4b037218abab9ea8d5247d", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -508,6 +508,16 @@ package Sem_Eval is\n    --  except when testing a generic actual T1 against an ancestor T2 in a\n    --  formal derived type association (indicated by Formal_Derived_Matching).\n \n+   procedure Test_Comparison\n+     (Op           : Node_Id;\n+      Assume_Valid : Boolean;\n+      True_Result  : out Boolean;\n+      False_Result : out Boolean);\n+   --  Determine the outcome of evaluating comparison operator Op using routine\n+   --  Compile_Time_Compare. Assume_Valid should be set when the operands are\n+   --  to be assumed valid. Flags True_Result and False_Result are set when the\n+   --  comparison evaluates to True or False respectively.\n+\n    procedure Why_Not_Static (Expr : Node_Id);\n    --  This procedure may be called after generating an error message that\n    --  complains that something is non-static. If it finds good reasons, it"}, {"sha": "e6511f437f3915942452952275e5a24e7fc2b430", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 74, "deletions": 8, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -141,6 +141,12 @@ package body Sem_Warn is\n    --  a body formal, the setting of the flag in the corresponding spec is\n    --  also checked (and True returned if either flag is True).\n \n+   function Is_Attribute_And_Known_Value_Comparison\n+     (Op : Node_Id) return Boolean;\n+   --  Determine whether operator Op denotes a comparison where the left\n+   --  operand is an attribute reference and the value of the right operand is\n+   --  known at compile time.\n+\n    function Never_Set_In_Source_Check_Spec (E : Entity_Id) return Boolean;\n    --  Tests Never_Set_In_Source status for entity E. If E is not a formal,\n    --  this is simply the setting of the flag Never_Set_In_Source. If E is\n@@ -2840,6 +2846,23 @@ package body Sem_Warn is\n       In_Out_Warnings.Init;\n    end Initialize;\n \n+   ---------------------------------------------\n+   -- Is_Attribute_And_Known_Value_Comparison --\n+   ---------------------------------------------\n+\n+   function Is_Attribute_And_Known_Value_Comparison\n+     (Op : Node_Id) return Boolean\n+   is\n+      Orig_Op : constant Node_Id := Original_Node (Op);\n+\n+   begin\n+      return\n+        Nkind (Orig_Op) in N_Op_Compare\n+          and then Nkind (Original_Node (Left_Opnd (Orig_Op))) =\n+                     N_Attribute_Reference\n+          and then Compile_Time_Known_Value (Right_Opnd (Orig_Op));\n+   end Is_Attribute_And_Known_Value_Comparison;\n+\n    ------------------------------------\n    -- Never_Set_In_Source_Check_Spec --\n    ------------------------------------\n@@ -3239,13 +3262,55 @@ package body Sem_Warn is\n       end if;\n    end Referenced_As_Out_Parameter_Check_Spec;\n \n+   --------------------------------------\n+   -- Warn_On_Constant_Valid_Condition --\n+   --------------------------------------\n+\n+   procedure Warn_On_Constant_Valid_Condition (Op : Node_Id) is\n+      True_Result  : Boolean;\n+      False_Result : Boolean;\n+\n+   begin\n+      --  Determine the potential outcome of the comparison assuming that the\n+      --  operands are valid. Do not consider instances because the check was\n+      --  already performed in the generic. Do not consider comparison between\n+      --  an attribute reference and a compile time known value since this is\n+      --  most likely a conditional compilation. Do not consider internal files\n+      --  in order to allow for various assertions and safeguards within our\n+      --  runtime.\n+\n+      if Constant_Condition_Warnings\n+        and then Comes_From_Source (Original_Node (Op))\n+        and then not In_Instance\n+        and then not Is_Attribute_And_Known_Value_Comparison (Op)\n+        and then not Is_Internal_File_Name\n+                       (Unit_File_Name (Get_Source_Unit (Op)))\n+      then\n+         Test_Comparison\n+           (Op           => Op,\n+            Assume_Valid => True,\n+            True_Result  => True_Result,\n+            False_Result => False_Result);\n+\n+         --  Warn on a possible evaluation to False / True in the presence of\n+         --  invalid values.\n+\n+         if True_Result then\n+            Error_Msg_N\n+              (\"condition can only be False if invalid values present??\", Op);\n+\n+         elsif False_Result then\n+            Error_Msg_N\n+              (\"condition can only be True if invalid values present??\", Op);\n+         end if;\n+      end if;\n+   end Warn_On_Constant_Valid_Condition;\n+\n    -----------------------------\n    -- Warn_On_Known_Condition --\n    -----------------------------\n \n    procedure Warn_On_Known_Condition (C : Node_Id) is\n-      P           : Node_Id;\n-      Orig        : constant Node_Id := Original_Node (C);\n       Test_Result : Boolean;\n \n       function Is_Known_Branch return Boolean;\n@@ -3327,6 +3392,11 @@ package body Sem_Warn is\n          end if;\n       end Track;\n \n+      --  Local variables\n+\n+      Orig : constant Node_Id := Original_Node (C);\n+      P    : Node_Id;\n+\n    --  Start of processing for Warn_On_Known_Condition\n \n    begin\n@@ -3365,11 +3435,7 @@ package body Sem_Warn is\n          --  Don't warn if comparison of result of attribute against a constant\n          --  value, since this is likely legitimate conditional compilation.\n \n-         if Nkind (Orig) in N_Op_Compare\n-           and then Compile_Time_Known_Value (Right_Opnd (Orig))\n-           and then Nkind (Original_Node (Left_Opnd (Orig))) =\n-                                                     N_Attribute_Reference\n-         then\n+         if Is_Attribute_And_Known_Value_Comparison (C) then\n             return;\n          end if;\n "}, {"sha": "98f33875d15afadcb253fabeebc7d82684510960", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -168,6 +168,11 @@ package Sem_Warn is\n    --  code has a test that explicitly checks P'First, then it is not operating\n    --  in blind assumption mode).\n \n+   procedure Warn_On_Constant_Valid_Condition (Op : Node_Id);\n+   --  Determine the outcome of evaluating conditional or relational operator\n+   --  Op assuming that its operands are valid. Emit a warning when the result\n+   --  of the evaluation is True or False.\n+\n    procedure Warn_On_Known_Condition (C : Node_Id);\n    --  C is a node for a boolean expression resulting from a relational\n    --  or membership operation. If the expression has a compile time known"}, {"sha": "6b77dccb0c9c2adefaf8e85606eae9c626d8d4f0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -9358,6 +9358,7 @@ package Sinfo is\n \n    function Generalized_Indexing\n      (N : Node_Id) return Node_Id;    -- Node4\n+\n    function Generic_Associations\n      (N : Node_Id) return List_Id;    -- List3\n "}, {"sha": "5aaee7d13fee3d34dacb59b818e44dcf64073108", "filename": "gcc/ada/urealp.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Furealp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Furealp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -493,7 +493,14 @@ package body Urealp is\n \n    procedure Tree_Read is\n    begin\n+      --  Disable the warnings emitted by -gnatwc because the following check\n+      --  acts as a signal in case Num_Ureal_Constants is changed.\n+\n+      pragma Warnings\n+        (Off, \"condition can only be * if invalid values present\");\n       pragma Assert (Num_Ureal_Constants = 10);\n+      pragma Warnings\n+        (On,  \"condition can only be * if invalid values present\");\n \n       Ureals.Tree_Read;\n       Tree_Read_Int (Int (UR_0));\n@@ -518,7 +525,14 @@ package body Urealp is\n \n    procedure Tree_Write is\n    begin\n+      --  Disable the warnings emitted by -gnatwc because the following check\n+      --  acts as a signal in case Num_Ureal_Constants is changed.\n+\n+      pragma Warnings\n+        (Off, \"condition can only be * if invalid values present\");\n       pragma Assert (Num_Ureal_Constants = 10);\n+      pragma Warnings\n+        (On,  \"condition can only be * if invalid values present\");\n \n       Ureals.Tree_Write;\n       Tree_Write_Int (Int (UR_0));"}, {"sha": "8a47fd642d0925f3dca825c2eb98671da88651d8", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a926b69be65a7b7db39f74538a91a98a89eab/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=634a926b69be65a7b7db39f74538a91a98a89eab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -671,7 +671,13 @@ begin\n    Write_Switch_Char (\"zr\");\n    Write_Line (\"Distribution stub generation for receiver stubs\");\n \n+   --  Disable the warnings emitted by -gnatwc because Ada_Version_Default may\n+   --  be changed to denote a different default value.\n+\n+   pragma Warnings (Off, \"condition can only be * if invalid values present\");\n+\n    if not Latest_Ada_Only then\n+\n       --  Line for -gnat83 switch\n \n       Write_Switch_Char (\"83\");\n@@ -708,6 +714,8 @@ begin\n       Write_Line (\"Ada 2012 mode\");\n    end if;\n \n+   pragma Warnings (On, \"condition can only be * if invalid values present\");\n+\n    --  Line for -gnat-p switch\n \n    Write_Switch_Char (\"-p\");"}]}