{"sha": "70d5ccef064325bcab1d3fbc57a6fef9aee2a096", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBkNWNjZWYwNjQzMjViY2FiMWQzZmJjNTdhNmZlZjlhZWUyYTA5Ng==", "commit": {"author": {"name": "David Taylor", "email": "taylor@texas.cygnus.com", "date": "1998-12-07T22:21:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-12-07T22:21:45Z"}, "message": "* HP aCC demangling support.\n\n        * cplus-dem.c\n        (main): Remove default to HP style demangling, set to EDG\n        demangling correctly when -edg specified; set the demangling style\n        when user specifies 'edg'. Set strip_underscore to\n        prepends_underscore, if not HPUXHPPA.  Set\n        current_demangling_style to hp_demangling if HPUXHPPA.  Set\n        current demangling style correctly if the switch is hp.  Read\n        label correctly also in the HP style case.\n        (work_stuff): add temp_start field; add field for volatile member\n        function.\n        (arm_pt): handle ARM_DEMANGLING and EDG_DEMANGLING styles; HP\n        style for this case is the same as ARM.\n        (demangle_args): handle EDG_DEMANGLING style; support HP style.\n        (demangle_arm_hp_template): new function. (It was\n        demangle_arm_pt.); check and set value of temp_start field in\n        multiple places. Also, when ceching for end of template args,\n        check to see if at end of static member of template class.\n        (demangle_class): new local variable : save_class_name_end Don't\n        include template args in string defining class.\n        (demangle_class_name): use demangel_arm_hp_template.\n        (demangle_function_name): handle case where demangling style is\n        HP_DEMANGLING and currently point at an 'X' in the mangled name.\n        Handle EDG_DEMANGLING style.  Handle constructor and destructor\n        ops for HP style.\n        (demangle_prefix): handle EDG_DEMANGLING and ARM_DEMANGLING\n        styles.  global destructor and constructor for HP style are same\n        as for ARM style. Same for local variables.\n        (demangle_qualified): handle EDG_DEMANGLING style.\n        (demangle_signature): add case for volatile member function.  For\n        cases '1' - '9' : initialize the temp_start field to -1 and handle\n        the EDG_DEMANGLING style.  for case 'F' : handle EDG_DEMANGLING\n        and AUTO_DEMANGLING styles.  If expecting a function and managed\n        to demangle the funct args, then handle the LUCID_DEMANGLING,\n        ARM_DEMANGLING, and EDG_DEMANGLING styles.  Add case for local\n        class name after \"Lnnn_ in HP style case. HP style too needs to\n        forget types.  _nnn is OK for HP style, so don't report failure.\n        (do_hpacc_template_const_value): new function. Handle template's\n        value param for HP/aCC.\n        (do_hpacc_template_literal): new function.  Handle a template's\n        literal parameter for HP aCC.\n        (recursively_demangle): new function\n        (snarf_numeric_literal): new function.\n        (usage): add 'edg' to the list of demangling styles; add hp switch\n        to message.\n\nCo-Authored-By: Andrew MacLeod <amacleod@cygnus.com>\nCo-Authored-By: Edith Epstein <eepstein@cygnus.com>\nCo-Authored-By: Elena Zannoni <ezannoni@cygnus.com>\nCo-Authored-By: Satish Pai <pai@apollo.hp.com>\nCo-Authored-By: Stan Shebs <shebs@cygnus.com>\n\nFrom-SVN: r24170", "tree": {"sha": "2d7e8f67156a418746c35bbc2638c2e8b0b84c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d7e8f67156a418746c35bbc2638c2e8b0b84c4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70d5ccef064325bcab1d3fbc57a6fef9aee2a096", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d5ccef064325bcab1d3fbc57a6fef9aee2a096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70d5ccef064325bcab1d3fbc57a6fef9aee2a096", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d5ccef064325bcab1d3fbc57a6fef9aee2a096/comments", "author": null, "committer": null, "parents": [{"sha": "fe77a034435df38be9d4ffe8a9bc8b78685023e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe77a034435df38be9d4ffe8a9bc8b78685023e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe77a034435df38be9d4ffe8a9bc8b78685023e6"}], "stats": {"total": 550, "additions": 508, "deletions": 42}, "files": [{"sha": "c97c1a089d24ab00ccc1719e6dea0eca67441f9c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d5ccef064325bcab1d3fbc57a6fef9aee2a096/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d5ccef064325bcab1d3fbc57a6fef9aee2a096/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=70d5ccef064325bcab1d3fbc57a6fef9aee2a096", "patch": "@@ -1,3 +1,56 @@\n+Fri Dec  4 13:51:04 1998  David Taylor   <taylor@texas.cygnus.com>\n+\t\t\t  Elena Zannoni  <ezannoni@cygnus.com>\n+\t\t\t  Stan Shebs     <shebs@cygnus.com>\n+\t\t\t  Edith Epstein  <eepstein@cygnus.com>\n+\t\t\t  Andres MacLeod <amacleod@cygnus.com>\n+\t\t\t  Satish Pai\t <pai@apollo.hp.com>\n+\n+\t* HP aCC demangling support.\n+\t* cplus-dem.c\n+\t(main): Remove default to HP style demangling, set to EDG\n+ \tdemangling correctly when -edg specified; set the demangling style\n+ \twhen user specifies 'edg'. Set strip_underscore to\n+ \tprepends_underscore, if not HPUXHPPA.  Set\n+ \tcurrent_demangling_style to hp_demangling if HPUXHPPA.  Set\n+ \tcurrent demangling style correctly if the switch is hp.  Read\n+ \tlabel correctly also in the HP style case.\n+\t(work_stuff): add temp_start field; add field for volatile member\n+ \tfunction.\n+\t(arm_pt): handle ARM_DEMANGLING and EDG_DEMANGLING styles; HP\n+ \tstyle for this case is the same as ARM.\n+\t(demangle_args): handle EDG_DEMANGLING style; support HP style.\n+\t(demangle_arm_hp_template): new function. (It was\n+ \tdemangle_arm_pt.); check and set value of temp_start field in\n+ \tmultiple places. Also, when ceching for end of template args,\n+ \tcheck to see if at end of static member of template class.\n+\t(demangle_class): new local variable : save_class_name_end Don't\n+ \tinclude template args in string defining class.\n+\t(demangle_class_name): use demangel_arm_hp_template.\n+\t(demangle_function_name): handle case where demangling style is\n+ \tHP_DEMANGLING and currently point at an 'X' in the mangled name.\n+  \tHandle EDG_DEMANGLING style.  Handle constructor and destructor\n+ \tops for HP style.\n+\t(demangle_prefix): handle EDG_DEMANGLING and ARM_DEMANGLING\n+ \tstyles.  global destructor and constructor for HP style are same\n+ \tas for ARM style. Same for local variables.\n+\t(demangle_qualified): handle EDG_DEMANGLING style.\n+\t(demangle_signature): add case for volatile member function.  For\n+ \tcases '1' - '9' : initialize the temp_start field to -1 and handle\n+ \tthe EDG_DEMANGLING style.  for case 'F' : handle EDG_DEMANGLING\n+ \tand AUTO_DEMANGLING styles.  If expecting a function and managed\n+ \tto demangle the funct args, then handle the LUCID_DEMANGLING,\n+ \tARM_DEMANGLING, and EDG_DEMANGLING styles.  Add case for local\n+ \tclass name after \"Lnnn_ in HP style case. HP style too needs to\n+ \tforget types.  _nnn is OK for HP style, so don't report failure.\n+\t(do_hpacc_template_const_value): new function. Handle template's\n+ \tvalue param for HP/aCC.\n+\t(do_hpacc_template_literal): new function.  Handle a template's\n+ \tliteral parameter for HP aCC.\n+\t(recursively_demangle): new function\n+\t(snarf_numeric_literal): new function.\n+\t(usage): add 'edg' to the list of demangling styles; add hp switch\n+ \tto message.\n+\n Sat Nov 28 17:25:22 1998  Christopher Faylor <cgf@cygnus.com>\n \n \t* pexecute.c: Remove obsolete ifdefed cygwin code."}, {"sha": "2293aa24d02561b64deaa740f955dfa1161372f0", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 455, "deletions": 42, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d5ccef064325bcab1d3fbc57a6fef9aee2a096/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d5ccef064325bcab1d3fbc57a6fef9aee2a096/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=70d5ccef064325bcab1d3fbc57a6fef9aee2a096", "patch": "@@ -2,6 +2,7 @@\n    Copyright 1989, 91, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n    Written by James Clark (jjc@jclark.uucp)\n    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling\n+   Modified by Satish Pai (pai@apollo.hp.com) for HP demangling\n    \n This file is part of the libiberty library.\n Libiberty is free software; you can redistribute it and/or\n@@ -93,6 +94,8 @@ enum demangling_styles current_demangling_style = gnu_demangling;\n \n static char cplus_markers[] = { CPLUS_MARKER, '.', '$', '\\0' };\n \n+static char char_str[2] = { '\\000', '\\000' };\n+\n void\n set_cplus_marker_for_demangling (ch)\n      int ch;\n@@ -125,6 +128,7 @@ struct work_stuff\n   int constructor;\n   int destructor;\n   int static_type;\t/* A static member function */\n+  int temp_start;       /* index in demangled to start of template args */   \n   int type_quals;       /* The type qualifiers.  */\n   int dllimported;\t/* Symbol imported from a PE DLL */\n   char **tmpl_argvec;   /* Template function arguments. */\n@@ -391,6 +395,15 @@ static int\n demangle_template_value_parm PARAMS ((struct work_stuff*, const char**, \n \t\t\t\t      string*, type_kind_t));\n \n+static int \n+do_hpacc_template_const_value PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int \n+do_hpacc_template_literal PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int \n+snarf_numeric_literal PARAMS ((char **, string *));\n+\n /* There is a TYPE_QUAL value for each type qualifier.  They can be\n    combined by bitwise-or to form the complete set of qualifiers for a\n    type.  */\n@@ -970,21 +983,40 @@ demangle_signature (work, mangled, declp)\n \t    oldmangled = *mangled;\n \t  (*mangled)++;\n \t  break;\n+\n+\tcase 'L':\n+\t  /* Local class name follows after \"Lnnn_\" */\n+\t  if (HP_DEMANGLING)\n+\t    {\n+\t      while (**mangled && (**mangled != '_'))\n+\t\t(*mangled)++;\n+\t      if (!**mangled)\n+\t\tsuccess = 0;\n+\t      else\n+\t\t(*mangled)++;\n+\t    }\n+\t  else\n+\t    success = 0;\n+\t  break;\n \t  \n \tcase '0': case '1': case '2': case '3': case '4':\n \tcase '5': case '6': case '7': case '8': case '9':\n \t  if (oldmangled == NULL)\n \t    {\n \t      oldmangled = *mangled;\n \t    }\n+          work->temp_start = -1; /* uppermost call to demangle_class */ \n \t  success = demangle_class (work, mangled, declp);\n \t  if (success)\n \t    {\n \t      remember_type (work, oldmangled, *mangled - oldmangled);\n \t    }\n-\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t  if (AUTO_DEMANGLING || GNU_DEMANGLING || EDG_DEMANGLING)\n \t    {\n-\t      expect_func = 1;\n+              /* EDG and others will have the \"F\", so we let the loop cycle \n+                 if we are looking at one. */\n+              if (**mangled != 'F')\n+                 expect_func = 1;\n \t    }\n \t  oldmangled = NULL;\n \t  break;\n@@ -1005,7 +1037,7 @@ demangle_signature (work, mangled, declp)\n \n \tcase 'F':\n \t  /* Function */\n-\t  /* ARM style demangling includes a specific 'F' character after\n+\t  /* ARM/HP style demangling includes a specific 'F' character after\n \t     the class name.  For GNU style, it is just implied.  So we can\n \t     safely just consume any 'F' at this point and be compatible\n \t     with either style.  */\n@@ -1014,16 +1046,27 @@ demangle_signature (work, mangled, declp)\n \t  func_done = 1;\n \t  (*mangled)++;\n \n-\t  /* For lucid/ARM style we have to forget any types we might\n+\t  /* For lucid/ARM/HP style we have to forget any types we might\n \t     have remembered up to this point, since they were not argument\n \t     types.  GNU style considers all types seen as available for\n \t     back references.  See comment in demangle_args() */\n \n-\t  if (LUCID_DEMANGLING || ARM_DEMANGLING)\n+\t  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)\n \t    {\n \t      forget_types (work);\n \t    }\n \t  success = demangle_args (work, mangled, declp);\n+\t  /* After picking off the function args, we expect to either\n+\t     find the function return type (preceded by an '_') or the\n+\t     end of the string. */\n+\t  if (success && (AUTO_DEMANGLING || EDG_DEMANGLING) && **mangled == '_')\n+\t    {\n+\t      ++(*mangled);\n+              /* At this level, we do not care about the return type. */\n+              success = do_type (work, mangled, &tname);\n+              string_delete (&tname);\n+            }\n+\n \t  break;\n \t  \n \tcase 't':\n@@ -1081,7 +1124,17 @@ demangle_signature (work, mangled, declp)\n \t       a mangled name that is either bogus, or has been mangled by\n \t       some algorithm we don't know how to deal with.  So just\n \t       reject the entire demangling.  */\n-\t    success = 0;\n+            /* However, \"_nnn\" is an expected suffix for alternate entry point\n+               numbered nnn for a function, with HP aCC, so skip over that\n+               without reporting failure. pai/1997-09-04 */\n+            if (HP_DEMANGLING)\n+              {\n+                (*mangled)++;\n+                while (**mangled && isdigit (**mangled))\n+                  (*mangled)++;\n+              }\n+            else\n+\t      success = 0;\n \t  break;\n \n \tcase 'H':\n@@ -1111,7 +1164,7 @@ demangle_signature (work, mangled, declp)\n \t    {\n \t      /* Non-GNU demanglers use a specific token to mark the start\n \t\t of the outermost function argument tokens.  Typically 'F',\n-\t\t for ARM-demangling, for example.  So if we find something\n+\t\t for ARM/HP-demangling, for example.  So if we find something\n \t\t we are not prepared for, it must be an error.  */\n \t      success = 0;\n \t    }\n@@ -1124,6 +1177,10 @@ demangle_signature (work, mangled, declp)\n \tif (success && expect_func)\n \t  {\n \t    func_done = 1;\n+              if (LUCID_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING)\n+                {\n+                  forget_types (work);\n+                }\n \t    success = demangle_args (work, mangled, declp);\n \t    /* Since template include the mangling of their return types,\n \t       we must set expect_func to 0 so that we don't try do\n@@ -1139,7 +1196,7 @@ demangle_signature (work, mangled, declp)\n \t  /* With GNU style demangling, bar__3foo is 'foo::bar(void)', and\n \t     bar__3fooi is 'foo::bar(int)'.  We get here when we find the\n \t     first case, and need to ensure that the '(void)' gets added to\n-\t     the current declp.  Note that with ARM, the first case\n+\t     the current declp.  Note that with ARM/HP, the first case\n \t     represents the name of a static data member 'foo::bar',\n \t     which is in the current declp, so we leave it alone.  */\n \t  success = demangle_args (work, mangled, declp);\n@@ -1683,8 +1740,9 @@ arm_pt (work, mangled, n, anchor, args)\n      int n;\n      const char **anchor, **args;\n {\n-  /* ARM template? */\n-  if (ARM_DEMANGLING && (*anchor = mystrstr (mangled, \"__pt__\")))\n+  /* Check if ARM template with \"__pt__\" in it (\"parameterized type\") */\n+  /* Allow HP also here, because HP's cfront compiler follows ARM to some extent */\n+  if ((ARM_DEMANGLING || HP_DEMANGLING) && (*anchor = mystrstr (mangled, \"__pt__\")))\n     {\n       int len;\n       *args = *anchor + 6;\n@@ -1695,36 +1753,168 @@ arm_pt (work, mangled, n, anchor, args)\n \t  return 1;\n \t}\n     }\n+  if (AUTO_DEMANGLING || EDG_DEMANGLING)\n+    {\n+      if ((*anchor = mystrstr (mangled, \"__tm__\"))\n+          || (*anchor = mystrstr (mangled, \"__ps__\"))\n+          || (*anchor = mystrstr (mangled, \"__pt__\")))\n+        {\n+          int len;\n+          *args = *anchor + 6;\n+          len = consume_count (args);\n+          if (*args + len == mangled + n && **args == '_')\n+            {\n+              ++*args;\n+              return 1;\n+            }\n+        }\n+      else if (*anchor = mystrstr (mangled, \"__S\"))\n+        {\n+ \t  int len;\n+ \t  *args = *anchor + 3;\n+ \t  len = consume_count (args);\n+ \t  if (*args + len == mangled + n && **args == '_')\n+            {\n+              ++*args;\n+ \t      return 1;\n+            }\n+        }\n+    }\n+\n   return 0;\n }\n \n static void\n-demangle_arm_pt (work, mangled, n, declp)\n+demangle_arm_hp_template (work, mangled, n, declp)\n      struct work_stuff *work;\n      const char **mangled;\n      int n;\n      string *declp;\n {\n   const char *p;\n-  const char *args;\n+  char *args;\n   const char *e = *mangled + n;\n+  string arg;\n \n-  /* ARM template? */\n-  if (arm_pt (work, *mangled, n, &p, &args))\n+  /* Check for HP aCC template spec: classXt1t2 where t1, t2 are\n+     template args */\n+  if (HP_DEMANGLING && ((*mangled)[n] == 'X'))\n     {\n-      string arg;\n+      char *start_spec_args = NULL;\n+\n+      /* First check for and omit template specialization pseudo-arguments,\n+         such as in \"Spec<#1,#1.*>\" */\n+      start_spec_args = strchr (*mangled, '<');\n+      if (start_spec_args && (start_spec_args - *mangled < n))\n+        string_appendn (declp, *mangled, start_spec_args - *mangled);\n+      else\n+        string_appendn (declp, *mangled, n);\n+      (*mangled) += n + 1;\n+      string_init (&arg);\n+      if (work->temp_start == -1) /* non-recursive call */ \n+        work->temp_start = declp->p - declp->b;\n+      string_append (declp, \"<\");\n+      while (1)\n+        {\n+          string_clear (&arg);\n+          switch (**mangled)\n+            {\n+              case 'T':\n+                /* 'T' signals a type parameter */\n+                (*mangled)++;\n+                if (!do_type (work, mangled, &arg))\n+                  goto hpacc_template_args_done;\n+                break;\n+                \n+              case 'U':\n+              case 'S':\n+                /* 'U' or 'S' signals an integral value */\n+                if (!do_hpacc_template_const_value (work, mangled, &arg))\n+                  goto hpacc_template_args_done;\n+                break;\n+                \n+              case 'A':\n+                /* 'A' signals a named constant expression (literal) */\n+                if (!do_hpacc_template_literal (work, mangled, &arg))\n+                  goto hpacc_template_args_done;\n+                break;\n+                \n+              default:\n+                /* Today, 1997-09-03, we have only the above types\n+                   of template parameters */ \n+                /* FIXME: maybe this should fail and return null */ \n+                goto hpacc_template_args_done;\n+            }\n+          string_appends (declp, &arg);\n+         /* Check if we're at the end of template args.\n+             0 if at end of static member of template class,\n+             _ if done with template args for a function */ \n+          if ((**mangled == '\\000') || (**mangled == '_')) \n+            break; \n+          else\n+            string_append (declp, \",\");\n+        }\n+    hpacc_template_args_done:\n+      string_append (declp, \">\");\n+      string_delete (&arg);\n+      if (**mangled == '_')\n+        (*mangled)++;\n+      return;\n+    }\n+  /* ARM template? (Also handles HP cfront extensions) */\n+  else if (arm_pt (work, *mangled, n, &p, &args))\n+    {\n+      string type_str;\n+\n       string_init (&arg);\n       string_appendn (declp, *mangled, p - *mangled);\n+      if (work->temp_start == -1)  /* non-recursive call */\n+\twork->temp_start = declp->p - declp->b;  \n       string_append (declp, \"<\");\n       /* should do error checking here */\n       while (args < e) {\n \tstring_clear (&arg);\n-\tdo_type (work, &args, &arg);\n+\n+\t/* Check for type or literal here */\n+\tswitch (*args)\n+\t  {\n+\t    /* HP cfront extensions to ARM for template args */\n+\t    /* spec: Xt1Lv1 where t1 is a type, v1 is a literal value */\n+\t    /* FIXME: We handle only numeric literals for HP cfront */\n+          case 'X':\n+            /* A typed constant value follows */ \n+            args++;\n+            if (!do_type (work, &args, &type_str))\n+\t      goto cfront_template_args_done;\n+            string_append (&arg, \"(\");\n+            string_appends (&arg, &type_str);\n+            string_append (&arg, \")\");\n+            if (*args != 'L')\n+              goto cfront_template_args_done;\n+            args++;\n+            /* Now snarf a literal value following 'L' */\n+            if (!snarf_numeric_literal (&args, &arg))\n+\t      goto cfront_template_args_done;\n+            break;\n+\n+          case 'L':\n+            /* Snarf a literal following 'L' */\n+            args++;\n+            if (!snarf_numeric_literal (&args, &arg))\n+\t      goto cfront_template_args_done;\n+            break;\n+          default:\n+            /* Not handling other HP cfront stuff */ \n+            if (!do_type (work, &args, &arg))\n+              goto cfront_template_args_done;\n+\t  }\n \tstring_appends (declp, &arg);\n \tstring_append (declp, \",\");\n       }\n+    cfront_template_args_done:\n       string_delete (&arg);\n-      --declp->p;\n+      if (args >= e)\n+\t--declp->p; /* remove extra comma */ \n       string_append (declp, \">\");\n     }\n   else if (n>10 && strncmp (*mangled, \"_GLOBAL_\", 8) == 0\n@@ -1737,11 +1927,17 @@ demangle_arm_pt (work, mangled, n, declp)\n     }\n   else\n     {\n+      if (work->temp_start == -1) /* non-recursive call only */ \n+\twork->temp_start = 0;     /* disable in recursive calls */ \n       string_appendn (declp, *mangled, n);\n     }\n   *mangled += n;\n }\n \n+/* Extract a class name, possibly a template with arguments, from the\n+   mangled string; qualifiers, local class indicators, etc. have\n+   already been dealt with */\n+\n static int\n demangle_class_name (work, mangled, declp)\n      struct work_stuff *work;\n@@ -1754,7 +1950,7 @@ demangle_class_name (work, mangled, declp)\n   n = consume_count (mangled);\n   if ((int) strlen (*mangled) >= n)\n     {\n-      demangle_arm_pt (work, mangled, n, declp);\n+      demangle_arm_hp_template (work, mangled, n, declp);\n       success = 1;\n     }\n \n@@ -1805,13 +2001,20 @@ demangle_class (work, mangled, declp)\n   int success = 0;\n   int btype;\n   string class_name;\n+  char *save_class_name_end = 0;  \n \n   string_init (&class_name);\n   btype = register_Btype (work);\n   if (demangle_class_name (work, mangled, &class_name))\n     {\n+      save_class_name_end = class_name.p;\n       if ((work->constructor & 1) || (work->destructor & 1))\n \t{\n+          /* adjust so we don't include template args */\n+          if (work->temp_start && (work->temp_start != -1))\n+            {\n+              class_name.p = class_name.b + work->temp_start;\n+            }\n \t  string_prepends (declp, &class_name);\n \t  if (work -> destructor & 1)\n \t    {\n@@ -1823,6 +2026,7 @@ demangle_class (work, mangled, declp)\n \t      work -> constructor -= 1; \n \t    }\n \t}\n+      class_name.p = save_class_name_end;\n       remember_Ktype (work, class_name.b, LEN_STRING(&class_name));\n       remember_Btype (work, class_name.b, LEN_STRING(&class_name), btype);\n       string_prepend (declp, SCOPE_STRING (work));\n@@ -1907,13 +2111,13 @@ demangle_prefix (work, mangled, declp)\n \t    }\n \t}\n     }\n-  else if (ARM_DEMANGLING && strncmp(*mangled, \"__std__\", 7) == 0)\n+  else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, \"__std__\", 7) == 0)\n     {\n       /* it's a ARM global destructor to be executed at program exit */\n       (*mangled) += 7;\n       work->destructor = 2;\n     }\n-  else if (ARM_DEMANGLING && strncmp(*mangled, \"__sti__\", 7) == 0)\n+  else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, \"__sti__\", 7) == 0)\n     {\n       /* it's a ARM global constructor to be executed at program initial */\n       (*mangled) += 7;\n@@ -1963,7 +2167,7 @@ demangle_prefix (work, mangled, declp)\n       /* The ARM says nothing about the mangling of local variables.\n \t But cfront mangles local variables by prepending __<nesting_level>\n \t to them. As an extension to ARM demangling we handle this case.  */\n-      if ((LUCID_DEMANGLING || ARM_DEMANGLING)\n+      if ((LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING)\n \t  && isdigit ((unsigned char)scan[2]))\n \t{\n \t  *mangled = scan + 2;\n@@ -1978,18 +2182,36 @@ demangle_prefix (work, mangled, declp)\n \t     names like __Q2_3foo3bar for nested type names.  So don't accept\n \t     this style of constructor for cfront demangling.  A GNU\n \t     style member-template constructor starts with 'H'. */\n-\t  if (!(LUCID_DEMANGLING || ARM_DEMANGLING))\n+\t  if (!(LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING))\n \t    work -> constructor += 1;\n \t  *mangled = scan + 2;\n \t}\n     }\n+  else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't')\n+    {\n+      /* Cfront-style parameterized type.  Handled later as a signature. */\n+      success = 1;\n+      \n+      /* ARM template? */\n+      demangle_arm_hp_template (work, mangled, strlen (*mangled), declp);\n+    }\n+  else if (EDG_DEMANGLING && ((scan[2] == 't' && scan[3] == 'm')\n+                              || (scan[2] == 'p' && scan[3] == 's')\n+                              || (scan[2] == 'p' && scan[3] == 't')))\n+    {\n+      /* EDG-style parameterized type.  Handled later as a signature. */\n+      success = 1;\n+      \n+      /* EDG template? */\n+      demangle_arm_hp_template (work, mangled, strlen (*mangled), declp);\n+    }\n   else if ((scan == *mangled) && !isdigit ((unsigned char)scan[2])\n \t   && (scan[2] != 't'))\n     {\n       /* Mangled name starts with \"__\".  Skip over any leading '_' characters,\n \t then find the next \"__\" that separates the prefix from the signature.\n \t */\n-      if (!(ARM_DEMANGLING || LUCID_DEMANGLING)\n+      if (!(ARM_DEMANGLING || LUCID_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)\n \t  || (arm_special (mangled, declp) == 0))\n \t{\n \t  while (*scan == '_')\n@@ -2016,14 +2238,6 @@ demangle_prefix (work, mangled, declp)\n \t    }\n \t}\n     }\n-  else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't')\n-    {\n-      /* Cfront-style parameterized type.  Handled later as a signature.  */\n-      success = 1;\n-\n-      /* ARM template? */\n-      demangle_arm_pt (work, mangled, strlen (*mangled), declp);\n-    }\n   else if (*(scan + 2) != '\\0')\n     {\n       /* Mangled name does not start with \"__\" but does have one somewhere\n@@ -2245,6 +2459,35 @@ gnu_special (work, mangled, declp)\n   return (success);\n }\n \n+static void\n+recursively_demangle(work, mangled, result, namelength)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *result;\n+     int namelength;\n+{\n+  char * recurse = (char *)NULL;\n+  char * recurse_dem = (char *)NULL;\n+  \n+  recurse = (char *) xmalloc (namelength + 1);\n+  memcpy (recurse, *mangled, namelength);\n+  recurse[namelength] = '\\000';\n+  \n+  recurse_dem = cplus_demangle (recurse, work->options);\n+  \n+  if (recurse_dem)\n+    {\n+      string_append (result, recurse_dem);\n+      free (recurse_dem);\n+    }\n+  else\n+    {\n+      string_appendn (result, *mangled, namelength);\n+    }\n+  free (recurse);\n+  *mangled += namelength;\n+}\n+\n /*\n \n LOCAL FUNCTION\n@@ -2478,10 +2721,22 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \t}\n       else\n \t{\n-\t  success = do_type (work, mangled, &last_name);\n-\t  if (!success)\n-\t    break;\n-\t  string_appends (&temp, &last_name);\n+\t  if (EDG_DEMANGLING)\n+            {\n+\t      int namelength;\n+ \t      /* Now recursively demangle the qualifier\n+ \t       * This is necessary to deal with templates in \n+ \t       * mangling styles like EDG */ \n+\t      namelength = consume_count (mangled);\n+ \t      recursively_demangle(work, mangled, &temp, namelength);\n+            }\n+          else\n+            {\n+              success = do_type (work, mangled, &last_name);\n+              if (!success)\n+                break;\n+              string_appends (&temp, &last_name);\n+            }\n \t}\n \n       if (remember_K)\n@@ -3063,6 +3318,141 @@ demangle_fund_type (work, mangled, result)\n   return success ? ((int) tk) : 0;\n }\n \n+\n+/* Handle a template's value parameter for HP aCC (extension from ARM)\n+   **mangled points to 'S' or 'U' */\n+\n+static int\n+do_hpacc_template_const_value (work, mangled, result)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *result;\n+{\n+  int unsigned_const;\n+\n+  if (**mangled != 'U' && **mangled != 'S')\n+    return 0;\n+  \n+  unsigned_const = (**mangled == 'U');\n+\n+  (*mangled)++;\n+\n+  switch (**mangled)\n+    {\n+      case 'N':\n+        string_append (result, \"-\");\n+        /* fall through */ \n+      case 'P':\n+        (*mangled)++;\n+        break;\n+      case 'M':\n+        /* special case for -2^31 */ \n+        string_append (result, \"-2147483648\");\n+        (*mangled)++;\n+        return 1;\n+      default:\n+        return 0;\n+    }\n+\n+  /* We have to be looking at an integer now */\n+  if (!(isdigit (**mangled)))\n+    return 0;\n+\n+  /* We only deal with integral values for template\n+     parameters -- so it's OK to look only for digits */\n+  while (isdigit (**mangled))\n+    {\n+      char_str[0] = **mangled;\n+      string_append (result, char_str);\n+      (*mangled)++;\n+    }\n+\n+  if (unsigned_const)\n+    string_append (result, \"U\");\n+\n+  /* FIXME? Some day we may have 64-bit (or larger :-) ) constants\n+     with L or LL suffixes. pai/1997-09-03 */\n+  \n+  return 1; /* success */ \n+}\n+\n+/* Handle a template's literal parameter for HP aCC (extension from ARM)\n+   **mangled is pointing to the 'A' */\n+\n+static int\n+do_hpacc_template_literal (work, mangled, result)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *result;\n+{\n+  int literal_len = 0;\n+  int i;\n+  char * recurse;\n+  char * recurse_dem;\n+  \n+  if (**mangled != 'A')\n+    return 0;\n+\n+  (*mangled)++;\n+\n+  literal_len = consume_count (mangled);\n+\n+  if (!literal_len)\n+    return 0;\n+\n+  /* Literal parameters are names of arrays, functions, etc.  and the\n+     canonical representation uses the address operator */\n+  string_append (result, \"&\");\n+\n+  /* Now recursively demangle the literal name */ \n+  recurse = (char *) xmalloc (literal_len + 1);\n+  memcpy (recurse, *mangled, literal_len);\n+  recurse[literal_len] = '\\000';\n+\n+  recurse_dem = cplus_demangle (recurse, work->options);\n+  \n+  if (recurse_dem)\n+    {\n+      string_append (result, recurse_dem);\n+      free (recurse_dem);\n+    }\n+  else\n+    {\n+      string_appendn (result, *mangled, literal_len);\n+    }\n+  (*mangled) += literal_len;\n+  free (recurse);\n+\n+  return 1;\n+}\n+\n+static int\n+snarf_numeric_literal (args, arg)\n+     char ** args;\n+     string * arg;\n+{\n+  if (**args == '-')\n+    {\n+      char_str[0] = '-';\n+      string_append (arg, char_str);\n+      (*args)++;\n+    }\n+  else if (**args == '+')\n+    (*args)++;\n+  \n+  if (!isdigit (**args))\n+    return 0;\n+\n+  while (isdigit (**args))\n+    {\n+      char_str[0] = **args;\n+      string_append (arg, char_str);\n+      (*args)++;\n+    }\n+\n+  return 1;\n+}\n+\n /* Demangle the next argument, given by MANGLED into RESULT, which\n    *should be an uninitialized* string.  It will be initialized here,\n    and free'd should anything go wrong.  */\n@@ -3376,7 +3766,7 @@ demangle_args (work, mangled, declp)\n \t    {\n \t      r = 1;\n \t    }\n-          if (ARM_DEMANGLING && work -> ntypes >= 10)\n+          if ((HP_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING) && work -> ntypes >= 10)\n             {\n               /* If we have 10 or more types we might have more than a 1 digit\n                  index so we'll have to consume the whole count here. This\n@@ -3396,7 +3786,7 @@ demangle_args (work, mangled, declp)\n \t          return (0);\n \t    \t}\n \t    }\n-\t  if (LUCID_DEMANGLING || ARM_DEMANGLING)\n+\t  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)\n \t    {\n \t      t--;\n \t    }\n@@ -3516,8 +3906,18 @@ demangle_function_name (work, mangled, declp, scan)\n      separator.  */\n \n   (*mangled) = scan + 2;\n+  /* We may be looking at an instantiation of a template function:\n+     foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a\n+     following _F marks the start of the function arguments.  Handle\n+     the template arguments first. */\n+  \n+  if (HP_DEMANGLING && (**mangled == 'X'))\n+    {\n+      demangle_arm_hp_template (work, mangled, 0, declp);\n+      /* This leaves MANGLED pointing to the 'F' marking func args */\n+    }\n \n-  if (LUCID_DEMANGLING || ARM_DEMANGLING)\n+  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)\n     {\n \n       /* See if we have an ARM style constructor or destructor operator.\n@@ -3835,8 +4235,8 @@ usage (stream, status)\n      int status;\n {    \n   fprintf (stream, \"\\\n-Usage: %s [-_] [-n] [-s {gnu,lucid,arm}] [--strip-underscores]\\n\\\n-      [--no-strip-underscores] [--format={gnu,lucid,arm}]\\n\\\n+Usage: %s [-_] [-n] [-s {gnu,lucid,arm,hp,edg}] [--strip-underscores]\\n\\\n+       [--no-strip-underscores] [--format={gnu,lucid,arm,hp,edg}]\\n\\\n       [--help] [--version] [arg...]\\n\",\n \t   program_name);\n   exit (status);\n@@ -3893,7 +4293,7 @@ main (argc, argv)\n \t  strip_underscore = 0;\n \t  break;\n \tcase 'v':\n-\t  printf (\"GNU %s version %s\\n\", program_name, program_version);\n+\t  printf (\"GNU %s (C++ demangler), version %s\\n\", program_name, program_version);\n \t  exit (0);\n \tcase '_':\n \t  strip_underscore = 1;\n@@ -3911,6 +4311,14 @@ main (argc, argv)\n \t    {\n \t      current_demangling_style = arm_demangling;\n \t    }\n+\t  else if (strcmp (optarg, \"hp\") == 0)\n+\t    {\n+\t      current_demangling_style = hp_demangling;\n+\t    }\n+          else if (strcmp (optarg, \"edg\") == 0)\n+            {\n+              current_demangling_style = edg_demangling;\n+            }\n \t  else\n \t    {\n \t      fprintf (stderr, \"%s: unknown demangling style `%s'\\n\",\n@@ -3935,7 +4343,11 @@ main (argc, argv)\n \t  int i = 0;\n \t  c = getchar ();\n \t  /* Try to read a label.  */\n-\t  while (c != EOF && (isalnum(c) || c == '_' || c == '$' || c == '.'))\n+\t  while (c != EOF && (isalnum(c) || c == '_' || c == '$' || c == '.' ||\n+                              c == '<' || c == '>' || c == '#' || c == ',' || c == '*' || c == '&' ||\n+                              c == '[' || c == ']' || c == ':' || c == '(' || c == ')'))\n+                              /* the ones in the 2nd & 3rd lines were added to handle\n+                                 HP aCC template specialization manglings */ \n \t    {\n \t      if (i >= MBUF_SIZE-1)\n \t\tbreak;\n@@ -4007,3 +4419,4 @@ xrealloc (ptr, size)\n   return value;\n }\n #endif\t/* main */\n+"}]}