{"sha": "e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjOWZiOWJiYzZiMDk0Y2QwMWI2MGMxOTZmMzZkNmNjY2M3YmI4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-19T18:55:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-19T18:55:22Z"}, "message": "alpha.c (local_symbol_p): Split out from ...\n\n\t* config/alpha/alpha.c (local_symbol_p): Split out from ...\n\t(local_symbolic_operand): ... here.\n\t(small_symbolic_operand): Check mode.\n\t(global_symbolic_operand): New.\n\t(input_operand): Reject symbolics if explicit relocs.\n\t(call_operand): Tidy.\n\t(alpha_legitimize_address): Use movdi_er_high_g.\n\t(alpha_expand_mov): Likewise.\n\t* config/alpha/alpha-protos.h: Update.\n\t* config/alpha/alpha.h (PREDICATE_CODES): Update.\n\t* config/alpha/alpha.md (UNSPEC_LITERAL, UNSPEC_LITUSE): New.\n\t(UNSPEC_LDGP2, UNSPECV_PLDGP2): New.\n\t(UNSPECV_LDGP2): Remove.\n\t(all call patterns): Use 's' not 'i' for symbolic constraint.\n\t(call_osf call_value_osf): Use call_operand.\n\t(all osf call patterns): Use $gp.  New peepholes for explicit relocs.\n\t(movdi_er_nofix, movdi_er_fix): Remove symbolic alternative.\n\t(prologue_ldgp_1_er): Remove.\n\t(ldgp_er_1, ldgp_er_2, prologue_ldgp_er_2): New.\n\t(builtin_setjmp_receiver_er patterns): Use them.\n\t(exception_receiver_er): Likewise.\n\nFrom-SVN: r45694", "tree": {"sha": "81af2f725513a686a794a59ed2445d4f90d9ea30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81af2f725513a686a794a59ed2445d4f90d9ea30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/comments", "author": null, "committer": null, "parents": [{"sha": "33593de731a6e5ebed1f8ec4a4339092ed316ccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33593de731a6e5ebed1f8ec4a4339092ed316ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33593de731a6e5ebed1f8ec4a4339092ed316ccf"}], "stats": {"total": 643, "additions": 474, "deletions": 169}, "files": [{"sha": "9c147c8e92b6ed93e9eb34d04597e9bae6661a08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "patch": "@@ -1,3 +1,27 @@\n+2001-09-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (local_symbol_p): Split out from ...\n+\t(local_symbolic_operand): ... here.\n+\t(small_symbolic_operand): Check mode.\n+\t(global_symbolic_operand): New.\n+\t(input_operand): Reject symbolics if explicit relocs.\n+\t(call_operand): Tidy.\n+\t(alpha_legitimize_address): Use movdi_er_high_g.\n+\t(alpha_expand_mov): Likewise.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.h (PREDICATE_CODES): Update.\n+\t* config/alpha/alpha.md (UNSPEC_LITERAL, UNSPEC_LITUSE): New.\n+\t(UNSPEC_LDGP2, UNSPECV_PLDGP2): New.\n+\t(UNSPECV_LDGP2): Remove.\n+\t(all call patterns): Use 's' not 'i' for symbolic constraint.\n+\t(call_osf call_value_osf): Use call_operand.\n+\t(all osf call patterns): Use $gp.  New peepholes for explicit relocs.\n+\t(movdi_er_nofix, movdi_er_fix): Remove symbolic alternative.\n+\t(prologue_ldgp_1_er): Remove.\n+\t(ldgp_er_1, ldgp_er_2, prologue_ldgp_er_2): New.\n+\t(builtin_setjmp_receiver_er patterns): Use them.\n+\t(exception_receiver_er): Likewise.\n+\n 2001-09-19  Richard Henderson  <rth@redhat.com>\n \n \t* cfgbuild.c (find_sub_basic_blocks): Handle insns that can throw."}, {"sha": "8aae90c565c82a99705373cbd5d223786f3a4234", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "patch": "@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+extern int alpha_next_sequence_number;\n+\n extern void literal_section PARAMS ((void));\n extern void override_options PARAMS ((void));\n extern int zap_mask PARAMS ((HOST_WIDE_INT));\n@@ -55,6 +57,8 @@ extern int some_ni_operand PARAMS ((rtx, enum machine_mode));\n extern int input_operand PARAMS ((rtx, enum machine_mode));\n extern int current_file_function_operand PARAMS ((rtx, enum machine_mode));\n extern int local_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int small_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int global_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_operand PARAMS ((rtx, enum machine_mode));\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int alpha_comparison_operator PARAMS ((rtx, enum machine_mode));"}, {"sha": "79c247b5189e5ad6773579e51026ffbedcd55a01", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 104, "deletions": 50, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "patch": "@@ -114,6 +114,8 @@ int alpha_this_literal_sequence_number;\n int alpha_this_gpdisp_sequence_number;\n \n /* Declarations of static functions.  */\n+static bool local_symbol_p\n+  PARAMS ((rtx));\n static void alpha_set_memflags_1\n   PARAMS ((rtx, int, int, int));\n static rtx alpha_emit_set_const_1\n@@ -795,6 +797,9 @@ input_operand (op, mode)\n     case LABEL_REF:\n     case SYMBOL_REF:\n     case CONST:\n+      if (TARGET_EXPLICIT_RELOCS)\n+\treturn 0;\n+\n       /* This handles both the Windows/NT and OSF cases.  */\n       return mode == ptr_mode || mode == DImode;\n \n@@ -840,16 +845,32 @@ current_file_function_operand (op, mode)\n \t      || op == XEXP (DECL_RTL (current_function_decl), 0)));\n }\n \n-/* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n-   known to be defined in this file.  */\n+/* Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n+   a variable known to be defined in this file.  */\n+\n+static bool\n+local_symbol_p (op)\n+     rtx op;\n+{\n+  const char *str = XSTR (op, 0);\n+\n+  /* ??? SYMBOL_REF_FLAG is set for local function symbols, but we\n+     run into problems with the rtl inliner in that the symbol was\n+     once external, but is local after inlining, which results in\n+     unrecognizable insns.  */\n+\n+  return (CONSTANT_POOL_ADDRESS_P (op)\n+\t  /* If @, then ENCODE_SECTION_INFO sez it's local.  */\n+\t  || str[0] == '@'\n+\t  /* If *$, then ASM_GENERATE_INTERNAL_LABEL sez it's local.  */\n+\t  || (str[0] == '*' && str[1] == '$'));\n+}\n \n int\n local_symbolic_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  const char *str;\n-\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n@@ -864,18 +885,7 @@ local_symbolic_operand (op, mode)\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n \n-  str = XSTR (op, 0);\n-\n-  /* ??? SYMBOL_REF_FLAG is set for local function symbols, but we\n-     run into problems with the rtl inliner in that the symbol was\n-     once external, but is local after inlining, which results in\n-     unrecognizable insns.  */\n-\n-  return (CONSTANT_POOL_ADDRESS_P (op)\n-\t  /* If @, then ENCODE_SECTION_INFO sez it's local.  */\n-\t  || str[0] == '@'\n-\t  /* If *$, then ASM_GENERATE_INTERNAL_LABEL sez it's local.  */\n-\t  || (str[0] == '*' && str[1] == '$'));\n+  return local_symbol_p (op);\n }\n \n /* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n@@ -891,6 +901,9 @@ small_symbolic_operand (op, mode)\n   if (! TARGET_SMALL_DATA)\n     return 0;\n \n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n@@ -900,14 +913,36 @@ small_symbolic_operand (op, mode)\n     return 0;\n \n   if (CONSTANT_POOL_ADDRESS_P (op))\n-    return GET_MODE_SIZE (get_pool_mode (op)) <= g_switch_value;\n+    return GET_MODE_SIZE (get_pool_mode (op)) <= (unsigned) g_switch_value;\n   else\n     {\n       str = XSTR (op, 0);\n       return str[0] == '@' && str[1] == 's';\n     }\n }\n \n+/* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n+   not known (or known not) to be defined in this file.  */\n+\n+int\n+global_symbolic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    op = XEXP (XEXP (op, 0), 0);\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+\n+  return ! local_symbol_p (op);\n+}\n+\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n \n int\n@@ -918,17 +953,17 @@ call_operand (op, mode)\n   if (mode != Pmode)\n     return 0;\n \n-  if (TARGET_ABI_UNICOSMK)\n-    return GET_CODE (op) == REG;\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    return 1;\n   if (GET_CODE (op) == REG)\n     {\n       if (TARGET_ABI_OSF)\n \treturn REGNO (op) == 27;\n       else\n \treturn 1;\n     }\n+  if (TARGET_ABI_UNICOSMK)\n+    return 0;\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return 1;\n \n   return 0;\n }\n@@ -1593,26 +1628,36 @@ alpha_legitimize_address (x, oldx, mode)\n     }\n \n   /* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */\n-  if (TARGET_EXPLICIT_RELOCS && local_symbolic_operand (x, Pmode))\n+  if (TARGET_EXPLICIT_RELOCS && symbolic_operand (x, Pmode))\n     {\n       rtx scratch;\n+      if (local_symbolic_operand (x, Pmode))\n+\t{\n+\t  if (small_symbolic_operand (x, Pmode))\n+\t    scratch = pic_offset_table_rtx;\n+\t  else\n+\t    {\n+\t      rtx insn, tmp;\n \n-      if (small_symbolic_operand (x, Pmode))\n-\tscratch = pic_offset_table_rtx;\n+\t      scratch = gen_reg_rtx (Pmode);\n+\n+\t      tmp = gen_rtx_HIGH (Pmode, x);\n+\t      tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n+              insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n+\t\t\t\t\t\t    REG_NOTES (insn));\n+\t    }\n+\n+\t  return gen_rtx_LO_SUM (Pmode, scratch, x);\n+\t}\n       else\n \t{\n-\t  rtx insn, tmp;\n-\n \t  scratch = gen_reg_rtx (Pmode);\n-\n-\t  tmp = gen_rtx_HIGH (Pmode, x);\n-\t  tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n-          insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n-\t\t\t\t\t\tREG_NOTES (insn));\n+\t  emit_insn (gen_movdi_er_high_g (scratch, pic_offset_table_rtx,\n+\t\t\t\t\t  x, const0_rtx));\n+\t  /* ??? FIXME: Tag the use of scratch with a lituse.  */\n+\t  return scratch;\n \t}\n-\n-      return gen_rtx_LO_SUM (Pmode, scratch, x);\n     }\n \n   return NULL;\n@@ -2172,27 +2217,36 @@ alpha_expand_mov (mode, operands)\n       && ! reg_or_0_operand (operands[1], mode))\n     operands[1] = force_reg (mode, operands[1]);\n \n-  if (TARGET_EXPLICIT_RELOCS && local_symbolic_operand (operands[1], mode))\n+  if (TARGET_EXPLICIT_RELOCS && symbolic_operand (operands[1], mode))\n     {\n-      rtx scratch;\n-\n-      if (small_symbolic_operand (operands[1], Pmode))\n-\tscratch = pic_offset_table_rtx;\n-      else\n+      if (local_symbolic_operand (operands[1], mode))\n \t{\n-\t  rtx insn, tmp;\n+\t  rtx scratch;\n \n-\t  scratch = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t  if (small_symbolic_operand (operands[1], Pmode))\n+\t    scratch = pic_offset_table_rtx;\n+\t  else\n+\t    {\n+\t      rtx insn, tmp;\n \n-\t  tmp = gen_rtx_HIGH (Pmode, operands[1]);\n-\t  tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n-          insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n-\t\t\t\t\t\tREG_NOTES (insn));\n-\t}\n+\t      scratch = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\n+\t      tmp = gen_rtx_HIGH (Pmode, operands[1]);\n+\t      tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n+              insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n+\t\t\t\t\t\t    REG_NOTES (insn));\n+\t    }\n \n-      operands[1] = gen_rtx_LO_SUM (Pmode, scratch, operands[1]);\n-      return false;\n+          operands[1] = gen_rtx_LO_SUM (Pmode, scratch, operands[1]);\n+\t  return false;\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_movdi_er_high_g (operands[0], pic_offset_table_rtx,\n+\t\t\t\t\t  operands[1], const0_rtx));\n+\t  return true;\n+\t}\n     }\n \n   /* Early out for non-constants and valid constants.  */"}, {"sha": "45ff18c8f7ff6f8261027c21daff760ebdb6c6e9", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "patch": "@@ -2189,6 +2189,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"fp0_operand\", {CONST_DOUBLE}},\t\t\t\t\t\\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\t\\\n   {\"local_symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n+  {\"small_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n+  {\"global_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n   {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\t\\\n   {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n \t\t     SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\"}, {"sha": "55f084593533f8bd147904ecad839e7090ebaa25", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 340, "deletions": 119, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=e2c9fb9bbc6b094cd01b60c196f36d6cccc7bb89", "patch": "@@ -35,6 +35,9 @@\n    (UNSPEC_UMK_LALM\t7)\n    (UNSPEC_UMK_LAL\t8)\n    (UNSPEC_UMK_LOAD_CIW\t9)\n+   (UNSPEC_LDGP2\t10)\n+   (UNSPEC_LITERAL\t11)\n+   (UNSPEC_LITUSE\t12)\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -49,9 +52,9 @@\n    (UNSPECV_REALIGN\t6)\n    (UNSPECV_EHR\t\t7)\t; exception_receiver\n    (UNSPECV_MCOUNT\t8)\n-   (UNSPECV_LDGP1\t9)\n-   (UNSPECV_LDGP2\t10)\n-   (UNSPECV_FORCE_MOV\t11)\n+   (UNSPECV_FORCE_MOV\t9)\n+   (UNSPECV_LDGP1\t10)\n+   (UNSPECV_PLDGP2\t11)\t; prologue ldgp\n   ])\n \n ;; Where necessary, the suffixes _le and _be are used to distinguish between\n@@ -638,7 +641,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"\"\n   \"\")\n \n-(define_insn \"*adddi_er_high\"\n+(define_insn \"*adddi_er_high_l\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t (high:DI (match_operand:DI 2 \"local_symbolic_operand\" \"\"))))]\n@@ -4502,8 +4505,9 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n })\n \n (define_expand \"sibcall\"\n-  [(call (mem:DI (match_operand 0 \"\" \"\"))\n-\t\t (match_operand 1 \"\" \"\"))]\n+  [(parallel [(call (mem:DI (match_operand 0 \"\" \"\"))\n+\t\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:DI 29))])]\n   \"TARGET_ABI_OSF\"\n {\n   if (GET_CODE (operands[0]) != MEM)\n@@ -4514,21 +4518,19 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n (define_expand \"call_osf\"\n   [(parallel [(call (mem:DI (match_operand 0 \"\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n-\t      (clobber (reg:DI 27))\n+\t      (use (reg:DI 29))\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n   if (GET_CODE (operands[0]) != MEM)\n     abort ();\n \n   operands[0] = XEXP (operands[0], 0);\n-\n-  if (GET_CODE (operands[0]) != SYMBOL_REF\n-      && ! (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 27))\n+  if (! call_operand (operands[0], Pmode))\n     {\n-      rtx tem = gen_rtx_REG (DImode, 27);\n-      emit_move_insn (tem, operands[0]);\n-      operands[0] = tem;\n+      rtx pv = gen_rtx_REG (Pmode, 27);\n+      emit_move_insn (pv, operands[0]);\n+      operands[0] = pv;\n     }\n })\n \n@@ -4634,9 +4636,10 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n })\n \n (define_expand \"sibcall_value\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand 1 \"\" \"\"))\n-\t      (match_operand 2 \"\" \"\")))]\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:DI (match_operand 1 \"\" \"\"))\n+\t\t         (match_operand 2 \"\" \"\")))\n+\t      (use (reg:DI 29))])]\n   \"TARGET_ABI_OSF\"\n {\n   if (GET_CODE (operands[1]) != MEM)\n@@ -4648,21 +4651,19 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:DI (match_operand 1 \"\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n-\t      (clobber (reg:DI 27))\n+\t      (use (reg:DI 29))\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n   if (GET_CODE (operands[1]) != MEM)\n     abort ();\n \n   operands[1] = XEXP (operands[1], 0);\n-\n-  if (GET_CODE (operands[1]) != SYMBOL_REF\n-      && ! (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 27))\n+  if (! call_operand (operands[1], Pmode))\n     {\n-      rtx tem = gen_rtx_REG (DImode, 27);\n-      emit_move_insn (tem, operands[1]);\n-      operands[1] = tem;\n+      rtx pv = gen_rtx_REG (Pmode, 27);\n+      emit_move_insn (pv, operands[1]);\n+      operands[1] = pv;\n     }\n })\n \n@@ -4735,39 +4736,98 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   emit_move_insn (gen_rtx_REG (DImode, 25), operands[2]);\n })\n \n-(define_insn \"*call_osf_1_er_noreturn\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:DI 27))\n-   (clobber (reg:DI 26))]\n-  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\n-   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  \"@\n-   jsr $26,($27),0\n-   bsr $26,$%0..ng\n-   ldq $27,%0($29)\\t\\t!literal!%#\\;jsr $26,($27),%0\\t\\t!lituse_jsr!%#\"\n-  [(set_attr \"type\" \"jsr\")\n-   (set_attr \"length\" \"*,*,8\")])\n-\n (define_insn \"*call_osf_1_er\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,s\"))\n \t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:DI 27))\n+   (use (reg:DI 29))\n    (clobber (reg:DI 26))]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n   \"@\n-   jsr $26,($27),0\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\n+   jsr $26,(%0),0\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\n    bsr $26,$%0..ng\n-   ldq $27,%0($29)\\t\\t!literal!%#\\;jsr $26,($27),%0\\t\\t!lituse_jsr!%#\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+   ldq $27,%0($29)\\t\\t!literal!%#\\;jsr $26,($27),0\\t\\t!lituse_jsr!%#\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"12,*,16\")])\n \n+;; We must use peep2 instead of a split because we need accurate life\n+;; information for $gp.  Consider the case of { bar(); while (1); }.\n+(define_peephole2\n+  [(parallel [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:DI 29))\n+\t      (clobber (reg:DI 26))])]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && reload_completed\n+   && ! current_file_function_operand (operands[0], Pmode)\n+   && peep2_regno_dead_p (1, 29)\"\n+  [(parallel [(call (mem:DI (match_dup 2))\n+\t\t    (match_dup 1))\n+\t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n+\t      (unspec_volatile [(reg:DI 29)] UNSPECV_BLOCKAGE)\n+\t      (use (match_dup 0))])]\n+{\n+  if (CONSTANT_P (operands[0]))\n+    {\n+      operands[2] = gen_rtx_REG (Pmode, 27);\n+      emit_move_insn (operands[2], operands[0]);\n+    }\n+  else\n+    {\n+      operands[2] = operands[0];\n+      operands[0] = const0_rtx;\n+    }\n+})\n+\n+(define_peephole2\n+  [(parallel [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:DI 29))\n+\t      (clobber (reg:DI 26))])]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && reload_completed\n+   && ! current_file_function_operand (operands[0], Pmode)\n+   && ! peep2_regno_dead_p (1, 29)\"\n+  [(parallel [(call (mem:DI (match_dup 2))\n+\t\t    (match_dup 1))\n+\t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n+\t      (unspec_volatile [(reg:DI 29)] UNSPECV_BLOCKAGE)\n+\t      (use (match_dup 0))])\n+   (set (reg:DI 29)\n+\t(unspec_volatile:DI [(reg:DI 26) (match_dup 3)] UNSPECV_LDGP1))\n+   (set (reg:DI 29)\n+\t(unspec:DI [(reg:DI 29) (match_dup 3)] UNSPEC_LDGP2))]\n+{\n+  if (CONSTANT_P (operands[0]))\n+    {\n+      operands[2] = gen_rtx_REG (Pmode, 27);\n+      emit_move_insn (operands[2], operands[0]);\n+    }\n+  else\n+    {\n+      operands[2] = operands[0];\n+      operands[0] = const0_rtx;\n+    }\n+  operands[3] = GEN_INT (alpha_next_sequence_number++);\n+})\n+\n+;; We add a blockage unspec_volatile to prevent insns from moving down\n+;; from above the call to in between the call and the ldah gpdisp.\n+\n+(define_insn \"*call_osf_2_er\"\n+  [(call (mem:DI (match_operand:DI 0 \"register_operand\" \"c\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n+   (unspec_volatile [(reg:DI 29)] UNSPECV_BLOCKAGE)\n+   (use (match_operand 2 \"\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"jsr $26,(%0),%2\"\n+  [(set_attr \"type\" \"jsr\")])\n+\n (define_insn \"*call_osf_1_noreturn\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,s\"))\n \t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:DI 27))\n+   (use (reg:DI 29))\n    (clobber (reg:DI 26))]\n-  \"TARGET_ABI_OSF && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  \"! TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n   \"@\n    jsr $26,($27),0\n    bsr $26,$%0..ng\n@@ -4776,11 +4836,11 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    (set_attr \"length\" \"*,*,8\")])\n \n (define_insn \"*call_osf_1\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,s\"))\n \t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:DI 27))\n+   (use (reg:DI 29))\n    (clobber (reg:DI 26))]\n-  \"TARGET_ABI_OSF\"\n+  \"! TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n   \"@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,$%0..ng\n@@ -4790,13 +4850,14 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \n (define_insn \"*sibcall_osf_1\"\n   [(call (mem:DI (match_operand:DI 0 \"current_file_function_operand\" \"R\"))\n-\t (match_operand 1 \"\" \"\"))]\n+\t (match_operand 1 \"\" \"\"))\n+   (use (reg:DI 29))]\n   \"TARGET_ABI_OSF\"\n   \"br $31,$%0..ng\"\n   [(set_attr \"type\" \"jsr\")])\n \n (define_insn \"*call_nt_1\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,i\"))\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,s\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:DI 26))]\n   \"TARGET_ABI_WINDOWS_NT\"\n@@ -4808,7 +4869,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    (set_attr \"length\" \"*,*,12\")])\n \n (define_insn \"*call_vms_1\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,i\"))\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,s\"))\n \t (match_operand 1 \"\" \"\"))\n    (use (match_operand:DI 2 \"nonimmediate_operand\" \"r,m\"))\n    (use (reg:DI 25))\n@@ -5302,7 +5363,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n }\n   [(set_attr \"type\" \"iadd\")])\n \n-(define_insn \"*movdi_er_low\"\n+(define_insn \"*movdi_er_low_l\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:DI 2 \"local_symbolic_operand\" \"\")))]\n@@ -5314,25 +5375,33 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     return \"lda %0,%2(%1)\\t\\t!gprellow\";\n })\n \n+(define_insn \"movdi_er_high_g\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"global_symbolic_operand\" \"\")\n+\t\t    (match_operand 3 \"const_int_operand\" \"\")]\n+\t\t   UNSPEC_LITERAL))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"ldq %0,%2(%1)\\t\\t!literal\"\n+  [(set_attr \"type\" \"ldsym\")])\n+\n (define_insn \"*movdi_er_nofix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,m,rJ,*fJ,Q,*f\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,m,rJ,*fJ,Q,*f\"))]\n   \"TARGET_EXPLICIT_RELOCS && ! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n-       || reg_or_0_operand (operands[1], DImode))\n-   && ! local_symbolic_operand (operands[1], DImode)\"\n+       || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n    mov %r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n    ldah %0,%H1\n-   ldq %0,%1($29)\\t\\t!literal\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    fmov %R1,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ild,ist,fcpys,fld,fst\")])\n \n ;; The 'U' constraint matches symbolic operands on Unicos/Mk. Those should\n ;; have been split up by the rules above but we shouldn't reject the\n@@ -5359,26 +5428,24 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    (set_attr \"length\" \"*,*,*,16,*,*,*,*,*,*\")])\n \n (define_insn \"*movdi_er_fix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q,r,*f\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,m,rJ,*fJ,Q,*f,*f,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q,r,*f\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,m,rJ,*fJ,Q,*f,*f,r\"))]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_FIX\n    && (register_operand (operands[0], DImode)\n-       || reg_or_0_operand (operands[1], DImode))\n-   && ! local_symbolic_operand (operands[1], DImode)\"\n+       || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n    mov %r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n    ldah %0,%H1\n-   ldq %0,%1($29)\\t\\t!literal\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    fmov %R1,%0\n    ldt %0,%1\n    stt %R1,%0\n    ftoit %1,%0\n    itoft %1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n \n (define_insn \"*movdi_fix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q,r,*f\")\n@@ -6260,23 +6327,56 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n ;; with them.\n \n (define_expand \"prologue_ldgp\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_LDGP1)\n-   (unspec_volatile [(const_int 0)] UNSPECV_LDGP2)]\n+  [(set (match_dup 0)\n+\t(unspec_volatile:DI [(match_dup 1) (match_dup 2)] UNSPECV_LDGP1))\n+   (set (match_dup 0)\n+\t(unspec_volatile:DI [(match_dup 0) (match_dup 2)] UNSPECV_PLDGP2))]\n   \"\"\n-  \"\")\n+{\n+  operands[0] = pic_offset_table_rtx;\n+  operands[1] = gen_rtx_REG (Pmode, 27);\n+  operands[2] = (TARGET_EXPLICIT_RELOCS\n+\t\t ? GEN_INT (alpha_next_sequence_number++)\n+\t\t : const0_rtx);\n+})\n \n-(define_insn \"*prologue_ldgp_1_er\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_LDGP1)]\n-  \"TARGET_EXPLICIT_RELOCS\"\n-  \"ldah $29,0($27)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\\n$%~..ng:\")\n+(define_insn \"*ldgp_er_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 2 \"const_int_operand\" \"\")]\n+\t\t\t    UNSPECV_LDGP1))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"ldah %0,0(%1)\\t\\t!gpdisp!%2\")\n+\n+(define_insn \"*ldgp_er_2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"\")]\n+\t\t   UNSPEC_LDGP2))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"lda %0,0(%1)\\t\\t!gpdisp!%2\")\n+\n+(define_insn \"*prologue_ldgp_er_2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 2 \"const_int_operand\" \"\")]\n+\t\t   \t    UNSPECV_PLDGP2))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"lda %0,0(%1)\\t\\t!gpdisp!%2\\n$%~..ng:\")\n \n (define_insn \"*prologue_ldgp_1\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_LDGP1)]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 2 \"const_int_operand\" \"\")]\n+\t\t\t    UNSPECV_LDGP1))]\n   \"\"\n-  \"ldgp $29,0($27)\\n$%~..ng:\")\n+  \"ldgp %0,0(%1)\\n$%~..ng:\")\n \n (define_insn \"*prologue_ldgp_2\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_LDGP2)]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 2 \"const_int_operand\" \"\")]\n+\t\t   \t    UNSPECV_PLDGP2))]\n   \"\"\n   \"\")\n \n@@ -6359,68 +6459,95 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"jmp $31,(%0),0\"\n   [(set_attr \"type\" \"ibr\")])\n \n-(define_insn \"*builtin_setjmp_receiver_sub_label_er\"\n+(define_insn \"*builtin_setjmp_receiver_er_sl_1\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && TARGET_AS_CAN_SUBTRACT_LABELS\"\n-  \"\\n$LSJ%=:\\;ldah $29,0($27)\\t\\t!gpdisp!%*\\;lda $29,$LSJ%=-%l0($29)\\t\\t!gpdisp!%*\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multi\")])\n+  \"lda $27,$LSJ%=-%l0($27)\\n$LSJ%=:\")\n+  \n+(define_insn \"*builtin_setjmp_receiver_er_1\"\n+  [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"br $27,$LSJ%=\\n$LSJ%=:\"\n+  [(set_attr \"type\" \"ibr\")])\n \n-(define_insn \"*builtin_setjmp_receiver_sub_label\"\n+(define_split\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n-  \"TARGET_ABI_OSF && TARGET_AS_CAN_SUBTRACT_LABELS\"\n-  \"\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multi\")])\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\n+   && prev_nonnote_insn (insn) == operands[0]\"\n+  [(const_int 0)]\n+  \"DONE;\")\n \n-(define_insn \"*builtin_setjmp_receiver_er\"\n+(define_insn \"*builtin_setjmp_receiver_1\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n-  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n-  \"br $29,$LSJ%=\\n$LSJ%=:\\;ldah $29,0($29)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+  \"TARGET_ABI_OSF\"\n+  \"br $27,$LSJ%=\\n$LSJ%=:\\;ldgp $29,0($27)\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"multi\")])\n \n-(define_insn \"builtin_setjmp_receiver\"\n+(define_expand \"builtin_setjmp_receiver_er\"\n+  [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)\n+   (set (match_dup 1)\n+\t(unspec_volatile:DI [(match_dup 2) (match_dup 3)] UNSPECV_LDGP1))\n+   (set (match_dup 1)\n+\t(unspec:DI [(match_dup 1) (match_dup 3)] UNSPEC_LDGP2))]\n+  \"\"\n+{\n+  operands[1] = pic_offset_table_rtx;\n+  operands[2] = gen_rtx_REG (Pmode, 27);\n+  operands[3] = GEN_INT (alpha_next_sequence_number++);\n+})\n+\n+(define_expand \"builtin_setjmp_receiver\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n   \"TARGET_ABI_OSF\"\n-  \"br $29,$LSJ%=\\n$LSJ%=:\\;ldgp $29,0($29)\"\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"multi\")])\n+{\n+  if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      emit_insn (gen_builtin_setjmp_receiver_er (operands[0]));\n+      DONE;\n+    }\n+})\n+\n+(define_expand \"exception_receiver_er\"\n+  [(set (match_dup 0)\n+\t(unspec_volatile:DI [(match_dup 1) (match_dup 2)] UNSPECV_LDGP1))\n+   (set (match_dup 0)\n+\t(unspec:DI [(match_dup 0) (match_dup 2)] UNSPEC_LDGP2))]\n+  \"\"\n+{\n+  operands[0] = pic_offset_table_rtx;\n+  operands[1] = gen_rtx_REG (Pmode, 26);\n+  operands[2] = GEN_INT (alpha_next_sequence_number++);\n+})\n \n (define_expand \"exception_receiver\"\n   [(unspec_volatile [(match_dup 0)] UNSPECV_EHR)]\n   \"TARGET_ABI_OSF\"\n {\n   if (TARGET_LD_BUGGY_LDGP)\n     operands[0] = alpha_gp_save_rtx ();\n+  else if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      emit_insn (gen_exception_receiver_er ());\n+      DONE;\n+    }\n   else\n     operands[0] = const0_rtx;\n })\n \n-(define_insn \"*exception_receiver_1_er\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_EHR)]\n-  \"TARGET_EXPLICIT_RELOCS && ! TARGET_LD_BUGGY_LDGP\"\n-  \"ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multi\")])\n-\n (define_insn \"*exception_receiver_1\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_EHR)]\n   \"! TARGET_LD_BUGGY_LDGP\"\n   \"ldgp $29,0($26)\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"multi\")])\n \n-;; ??? We don't represent the usage of $29 properly in address loads\n-;; and function calls.  This leads to the following move being deleted\n-;; as dead code unless it is represented as a volatile unspec.\n-\n (define_insn \"*exception_receiver_2\"\n   [(unspec_volatile [(match_operand:DI 0 \"nonimmediate_operand\" \"r,m\")]\n \t\t    UNSPECV_EHR)]\n   \"TARGET_LD_BUGGY_LDGP\"\n   \"@\n-   mov %0,$29\n+   bis $31,%0,$29\n    ldq $29,%0\"\n   [(set_attr \"type\" \"ilog,ild\")])\n \n@@ -6555,37 +6682,119 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n ;; The call patterns are at the end of the file because their\n ;; wildcard operand0 interferes with nice recognition.\n \n-(define_insn \"*call_value_umk\"\n+(define_insn \"*call_value_osf_1_er\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r\"))\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,s\"))\n \t      (match_operand 2 \"\" \"\")))\n-   (use (reg:DI 25))\n+   (use (reg:DI 29))\n    (clobber (reg:DI 26))]\n-  \"TARGET_ABI_UNICOSMK\"\n-  \"jsr $26,(%1)\"\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"@\n+   jsr $26,(%1),0\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\n+   bsr $26,$%1..ng\n+   ldq $27,%1($29)\\t\\t!literal!%#\\;jsr $26,($27),0\\t\\t!lituse_jsr!%#\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"12,*,16\")])\n+\n+;; We must use peep2 instead of a split because we need accurate life\n+;; information for $gp.  Consider the case of { bar(); while (1); }.\n+(define_peephole2\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:DI (match_operand:DI 1 \"call_operand\" \"\"))\n+\t\t         (match_operand 2 \"\" \"\")))\n+\t      (use (reg:DI 29))\n+\t      (clobber (reg:DI 26))])]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF  && reload_completed\n+   && ! current_file_function_operand (operands[0], Pmode)\n+   && peep2_regno_dead_p (1, 29)\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (call (mem:DI (match_dup 3))\n+\t\t\t (match_dup 2)))\n+\t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n+\t      (unspec_volatile [(reg:DI 29)] UNSPECV_BLOCKAGE)\n+\t      (use (match_dup 1))])]\n+{\n+  if (CONSTANT_P (operands[1]))\n+    {\n+      operands[3] = gen_rtx_REG (Pmode, 27);\n+      emit_move_insn (operands[3], operands[1]);\n+    }\n+  else\n+    {\n+      operands[3] = operands[1];\n+      operands[1] = const0_rtx;\n+    }\n+})\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:DI (match_operand:DI 1 \"call_operand\" \"\"))\n+\t\t         (match_operand 2 \"\" \"\")))\n+\t      (use (reg:DI 29))\n+\t      (clobber (reg:DI 26))])]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF  && reload_completed\n+   && ! current_file_function_operand (operands[0], Pmode)\n+   && ! peep2_regno_dead_p (1, 29)\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (call (mem:DI (match_dup 3))\n+\t\t\t (match_dup 2)))\n+\t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n+\t      (unspec_volatile [(reg:DI 29)] UNSPECV_BLOCKAGE)\n+\t      (use (match_dup 1))])\n+   (set (reg:DI 29)\n+\t(unspec_volatile:DI [(reg:DI 26) (match_dup 4)] UNSPECV_LDGP1))\n+   (set (reg:DI 29)\n+\t(unspec:DI [(reg:DI 29) (match_dup 4)] UNSPEC_LDGP2))]\n+{\n+  if (CONSTANT_P (operands[1]))\n+    {\n+      operands[3] = gen_rtx_REG (Pmode, 27);\n+      emit_move_insn (operands[3], operands[1]);\n+    }\n+  else\n+    {\n+      operands[3] = operands[1];\n+      operands[1] = const0_rtx;\n+    }\n+  operands[4] = GEN_INT (alpha_next_sequence_number++);\n+})\n+\n+;; We add a blockage unspec_volatile to prevent insns from moving down\n+;; from above the call to in between the call and the ldah gpdisp.\n+(define_insn \"*call_value_osf_2_er\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"register_operand\" \"c\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (set (reg:DI 26)\n+\t(plus:DI (pc) (const_int 4)))\n+   (unspec_volatile [(reg:DI 29)] UNSPECV_BLOCKAGE)\n+   (use (match_operand 3 \"\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"jsr $26,(%1),%3\"\n   [(set_attr \"type\" \"jsr\")])\n \n-(define_insn \"*call_value_osf_1_er\"\n+(define_insn \"*call_value_osf_1_noreturn\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,i\"))\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,s\"))\n \t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:DI 27))\n+   (use (reg:DI 29))\n    (clobber (reg:DI 26))]\n-  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"! TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n   \"@\n-   jsr $26,($27),0\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\n+   jsr $26,($27),0\n    bsr $26,$%1..ng\n-   ldq $27,%1($29)\\t\\t!literal!%#\\;jsr $26,($27),%1\\t\\t!lituse_jsr!%#\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+   jsr $26,%1\"\n   [(set_attr \"type\" \"jsr\")\n-   (set_attr \"length\" \"12,*,16\")])\n+   (set_attr \"length\" \"*,*,8\")])\n \n (define_insn \"*call_value_osf_1\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,i\"))\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,s\"))\n \t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:DI 27))\n+   (use (reg:DI 29))\n    (clobber (reg:DI 26))]\n-  \"TARGET_ABI_OSF\"\n+  \"! TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n   \"@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,$%1..ng\n@@ -6596,14 +6805,15 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n (define_insn \"*sibcall_value_osf_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:DI (match_operand:DI 1 \"current_file_function_operand\" \"R\"))\n-\t      (match_operand 2 \"\" \"\")))]\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (reg:DI 29))]\n   \"TARGET_ABI_OSF\"\n   \"br $31,$%1..ng\"\n   [(set_attr \"type\" \"jsr\")])\n \n (define_insn \"*call_value_nt_1\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,R,i\"))\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,R,s\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:DI 26))]\n   \"TARGET_ABI_WINDOWS_NT\"\n@@ -6616,7 +6826,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \n (define_insn \"*call_value_vms_1\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,i\"))\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,s\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand:DI 3 \"nonimmediate_operand\" \"r,m\"))\n    (use (reg:DI 25))\n@@ -6628,3 +6838,14 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    ldq $27,%3\\;jsr $26,%1\\;ldq $27,0($29)\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"12,16\")])\n+\n+(define_insn \"*call_value_umk\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (reg:DI 25))\n+   (clobber (reg:DI 26))]\n+  \"TARGET_ABI_UNICOSMK\"\n+  \"jsr $26,(%1)\"\n+  [(set_attr \"type\" \"jsr\")])\n+"}]}