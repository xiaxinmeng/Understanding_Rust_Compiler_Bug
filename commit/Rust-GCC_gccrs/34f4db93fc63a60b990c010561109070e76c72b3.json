{"sha": "34f4db93fc63a60b990c010561109070e76c72b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRmNGRiOTNmYzYzYTYwYjk5MGMwMTA1NjExMDkwNzBlNzZjNzJiMw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-02-08T11:54:04Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-02-08T11:54:04Z"}, "message": "parse.h: DECL_P renamed JDECL_P.\n\nMon Feb  8 11:50:50 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.h: DECL_P renamed JDECL_P.\n        * parse.y: DECL_P replaced by JDECL_P.\n        (build_array_from_name): Always use pointer's type.\n        (patch_bc_statement): Extra code to search continue target in a\n        for loop. Fixed comments. Continue target is current loop when\n        unlabeled.\n\nFrom-SVN: r25082", "tree": {"sha": "dd1f41b261cb83e48297682ef52ec3746737c5a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd1f41b261cb83e48297682ef52ec3746737c5a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34f4db93fc63a60b990c010561109070e76c72b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f4db93fc63a60b990c010561109070e76c72b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f4db93fc63a60b990c010561109070e76c72b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f4db93fc63a60b990c010561109070e76c72b3/comments", "author": null, "committer": null, "parents": [{"sha": "9691f3a1ea16da2c8584a7306d480c6016c36451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9691f3a1ea16da2c8584a7306d480c6016c36451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9691f3a1ea16da2c8584a7306d480c6016c36451"}], "stats": {"total": 127, "additions": 80, "deletions": 47}, "files": [{"sha": "edb855aa83a86bf5e8c3c734370a623fb3c77958", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=34f4db93fc63a60b990c010561109070e76c72b3", "patch": "@@ -1,3 +1,12 @@\n+Mon Feb  8 11:50:50 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.h: DECL_P renamed JDECL_P.\n+        * parse.y: DECL_P replaced by JDECL_P.\n+        (build_array_from_name): Always use pointer's type.\n+        (patch_bc_statement): Extra code to search continue target in a\n+        for loop. Fixed comments. Continue target is current loop when\n+        unlabeled.\n+\n 1999-02-05  Andrew Haley  <aph@cygnus.com>\n \n \t* class.c (make_class_data): The superclass of an interface should"}, {"sha": "4773ef423e9ac7ae8156e048aa05e68a9616fe87", "filename": "gcc/java/parse.c", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=34f4db93fc63a60b990c010561109070e76c72b3", "patch": "@@ -5315,10 +5315,9 @@ build_array_from_name (type, type_wfl, name, ret_name)\n     {\n       name = get_identifier (&more_dims [string]);\n \n-      /* If type already is a reference on an array, get the base type */\n-      if ((TREE_CODE (type) == POINTER_TYPE) && \n-\t  TYPE_ARRAY_P (TREE_TYPE (type)))\n-\ttype = TREE_TYPE (type);\n+      /* If we have a pointer, use its type */\n+      if (TREE_CODE (type) == POINTER_TYPE)\n+        type = TREE_TYPE (type);\n \n       /* Building the first dimension of a primitive type uses this\n          function */\n@@ -8741,14 +8740,14 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n     }\n   /* We might have been trying to resolve field.method(). In which\n      case, the resolution is over and decl is the answer */\n-  else if (DECL_P (decl) && IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)) == decl)\n+  else if (JDECL_P (decl) && IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)) == decl)\n     field_ref = decl;\n-  else if (DECL_P (decl))\n+  else if (JDECL_P (decl))\n     {\n       int static_final_found = 0;\n       if (!type_found)\n \ttype_found = DECL_CONTEXT (decl);\n-      is_static = DECL_P (decl) && FIELD_STATIC (decl);\n+      is_static = JDECL_P (decl) && FIELD_STATIC (decl);\n       if (FIELD_FINAL (decl) \n \t  && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))\n \t  && DECL_LANG_SPECIFIC (decl)\n@@ -8813,7 +8812,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \tcase NEW_CLASS_EXPR:\n \t  /* If the access to the function call is a non static field,\n \t     build the code to access it. */\n-\t  if (DECL_P (decl) && !FIELD_STATIC (decl))\n+\t  if (JDECL_P (decl) && !FIELD_STATIC (decl))\n \t    {\n \t      decl = maybe_access_field (decl, *where_found, \n \t\t\t\t\t DECL_CONTEXT (decl));\n@@ -8874,7 +8873,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \tcase ARRAY_REF:\n \t  /* If the access to the function call is a non static field,\n \t     build the code to access it. */\n-\t  if (DECL_P (decl) && !FIELD_STATIC (decl))\n+\t  if (JDECL_P (decl) && !FIELD_STATIC (decl))\n \t    {\n \t      decl = maybe_access_field (decl, *where_found, type);\n \t      if (decl == error_mark_node)\n@@ -10518,7 +10517,7 @@ java_complete_lhs (node)\n \t    patch_assignment (node, wfl_op1, wfl_op2);\n \n \t  /* Now, we still mark the lhs as initialized */\n-\t  if (DECL_P (TREE_OPERAND (node, 0)))\n+\t  if (JDECL_P (TREE_OPERAND (node, 0)))\n \t    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;\n \n \t  return error_mark_node;\n@@ -10958,7 +10957,7 @@ static int\n check_final_assignment (lvalue, wfl)\n      tree lvalue, wfl;\n {\n-  if (DECL_P (lvalue) && FIELD_FINAL (lvalue) &&\n+  if (JDECL_P (lvalue) && FIELD_FINAL (lvalue) &&\n       DECL_NAME (current_function_decl) != clinit_identifier_node)\n     {\n       parse_error_context \n@@ -11015,7 +11014,7 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n   /* Lhs can be a named variable */\n-  if (DECL_P (lvalue))\n+  if (JDECL_P (lvalue))\n     {\n       INITIALIZED_P (lvalue) = 1;\n       lhs_type = TREE_TYPE (lvalue);\n@@ -12126,9 +12125,9 @@ patch_unaryop (node, wfl_op)\n     case PREINCREMENT_EXPR:\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n-      if (!DECL_P (op) && !((TREE_CODE (op) == INDIRECT_REF \n-\t\t\t     || TREE_CODE (op) == COMPONENT_REF) \n-\t\t\t    && JPRIMITIVE_TYPE_P (TREE_TYPE (op))))\n+      if (!JDECL_P (op) && !((TREE_CODE (op) == INDIRECT_REF \n+\t\t\t      || TREE_CODE (op) == COMPONENT_REF) \n+\t\t\t     && JPRIMITIVE_TYPE_P (TREE_TYPE (op))))\n \t{\n \t  tree lvalue;\n \t  /* Before screaming, check that we're not in fact trying to\n@@ -12929,7 +12928,7 @@ build_new_loop (loop_body)\n        COMPOUND_EXPR\t\t(loop main body)\n          EXIT_EXPR\t\t(this order is for while/for loops.\n          LABELED_BLOCK_EXPR      the order is reversed for do loops)\n-           LABEL_DECL           (continue occurding here branche at the \n+           LABEL_DECL           (a continue occuring here branches at the \n            BODY\t\t\t end of this labeled block)\n        INCREMENT\t\t(if any)\n \n@@ -13120,6 +13119,16 @@ patch_bc_statement (node)\n   /* Find the statement we're targeting. */\n   target_stmt = LABELED_BLOCK_BODY (bc_label);\n \n+  /* Target loop is slightly burrowed in the case of a for loop, it\n+     appears at the first sight to be a block. */\n+  if (TREE_CODE (target_stmt) == BLOCK)\n+    {\n+      tree sub = BLOCK_SUBBLOCKS (target_stmt);\n+      if (sub && TREE_CODE (sub) == COMPOUND_EXPR && TREE_OPERAND (sub, 1)\n+\t  && TREE_CODE (TREE_OPERAND (sub, 1)) == LOOP_EXPR)\n+\ttarget_stmt = TREE_OPERAND (sub, 1);\n+    }\n+\n   /* 14.13 The break Statement */\n   if (IS_BREAK_STMT_P (node))\n     {\n@@ -13128,7 +13137,7 @@ patch_bc_statement (node)\n          while/do/for/switch */\n       if (is_unlabeled &&\n \t  !(TREE_CODE (target_stmt) == LOOP_EXPR        /* do/while/for */\n-\t    || TREE_CODE (target_stmt) == SWITCH_EXPR)) /* switch FIXME */\n+\t    || TREE_CODE (target_stmt) == SWITCH_EXPR)) /* switch */\n \t{\n \t  parse_error_context (wfl_operator, \n \t\t\t       \"`break' must be in loop or switch\");\n@@ -13139,18 +13148,21 @@ patch_bc_statement (node)\n \tEXIT_BLOCK_LABELED_BLOCK (node) = bc_label;\n     }\n   /* 14.14 The continue Statement */\n-  /* The continue statement must always target a loop */\n+  /* The continue statement must always target a loop, unnamed or not. */\n   else \n-    {\n+    { \n       if (TREE_CODE (target_stmt) != LOOP_EXPR) /* do/while/for */\n \t{\n \t  parse_error_context (wfl_operator, \"`continue' must be in loop\");\n \t  return error_mark_node;\n \t}\n       /* Everything looks good. We can fix the `continue' jump to go\n-         at the place in the loop were the continue is. The continue\n-\t is the current labeled block, by construction. */\n-      EXIT_BLOCK_LABELED_BLOCK (node) = bc_label = ctxp->current_labeled_block;\n+\t at the place in the loop were the continue is.  For unlabeled\n+\t continue, the continuation point is the current labeled\n+\t block, by construction. */\n+      if (is_unlabeled)\n+\tEXIT_BLOCK_LABELED_BLOCK (node) = \n+\t  bc_label = ctxp->current_labeled_block;\n     }\n \n   CAN_COMPLETE_NORMALLY (bc_label) = 1;"}, {"sha": "e3c93b579b3e59e08227ea2ffdda4c8089ee4ff0", "filename": "gcc/java/parse.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=34f4db93fc63a60b990c010561109070e76c72b3", "patch": "@@ -193,9 +193,9 @@ extern tree stabilize_reference PROTO ((tree));\n \t\t\t     && (TYPE) == TREE_TYPE (null_pointer_node))\n \n /* Other predicate */\n-#define DECL_P(NODE) (NODE && (TREE_CODE (NODE) == PARM_DECL\t\t\\\n-\t\t\t       || TREE_CODE (NODE) == VAR_DECL\t\t\\\n-\t\t\t       || TREE_CODE (NODE) == FIELD_DECL))\n+#define JDECL_P(NODE) (NODE && (TREE_CODE (NODE) == PARM_DECL\t\t\\\n+\t\t\t\t|| TREE_CODE (NODE) == VAR_DECL\t\t\\\n+\t\t\t\t|| TREE_CODE (NODE) == FIELD_DECL))\n \n #define TYPE_INTERFACE_P(TYPE) \t\t\t\t\t\\\n   (CLASS_P (TYPE) && CLASS_INTERFACE (TYPE_NAME (TYPE)))"}, {"sha": "5208e155292d9853709902f7b634338703b5874a", "filename": "gcc/java/parse.y", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f4db93fc63a60b990c010561109070e76c72b3/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=34f4db93fc63a60b990c010561109070e76c72b3", "patch": "@@ -2677,10 +2677,9 @@ build_array_from_name (type, type_wfl, name, ret_name)\n     {\n       name = get_identifier (&more_dims [string]);\n \n-      /* If type already is a reference on an array, get the base type */\n-      if ((TREE_CODE (type) == POINTER_TYPE) && \n-\t  TYPE_ARRAY_P (TREE_TYPE (type)))\n-\ttype = TREE_TYPE (type);\n+      /* If we have a pointer, use its type */\n+      if (TREE_CODE (type) == POINTER_TYPE)\n+        type = TREE_TYPE (type);\n \n       /* Building the first dimension of a primitive type uses this\n          function */\n@@ -6103,14 +6102,14 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n     }\n   /* We might have been trying to resolve field.method(). In which\n      case, the resolution is over and decl is the answer */\n-  else if (DECL_P (decl) && IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)) == decl)\n+  else if (JDECL_P (decl) && IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)) == decl)\n     field_ref = decl;\n-  else if (DECL_P (decl))\n+  else if (JDECL_P (decl))\n     {\n       int static_final_found = 0;\n       if (!type_found)\n \ttype_found = DECL_CONTEXT (decl);\n-      is_static = DECL_P (decl) && FIELD_STATIC (decl);\n+      is_static = JDECL_P (decl) && FIELD_STATIC (decl);\n       if (FIELD_FINAL (decl) \n \t  && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))\n \t  && DECL_LANG_SPECIFIC (decl)\n@@ -6175,7 +6174,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \tcase NEW_CLASS_EXPR:\n \t  /* If the access to the function call is a non static field,\n \t     build the code to access it. */\n-\t  if (DECL_P (decl) && !FIELD_STATIC (decl))\n+\t  if (JDECL_P (decl) && !FIELD_STATIC (decl))\n \t    {\n \t      decl = maybe_access_field (decl, *where_found, \n \t\t\t\t\t DECL_CONTEXT (decl));\n@@ -6236,7 +6235,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \tcase ARRAY_REF:\n \t  /* If the access to the function call is a non static field,\n \t     build the code to access it. */\n-\t  if (DECL_P (decl) && !FIELD_STATIC (decl))\n+\t  if (JDECL_P (decl) && !FIELD_STATIC (decl))\n \t    {\n \t      decl = maybe_access_field (decl, *where_found, type);\n \t      if (decl == error_mark_node)\n@@ -7880,7 +7879,7 @@ java_complete_lhs (node)\n \t    patch_assignment (node, wfl_op1, wfl_op2);\n \n \t  /* Now, we still mark the lhs as initialized */\n-\t  if (DECL_P (TREE_OPERAND (node, 0)))\n+\t  if (JDECL_P (TREE_OPERAND (node, 0)))\n \t    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;\n \n \t  return error_mark_node;\n@@ -8320,7 +8319,7 @@ static int\n check_final_assignment (lvalue, wfl)\n      tree lvalue, wfl;\n {\n-  if (DECL_P (lvalue) && FIELD_FINAL (lvalue) &&\n+  if (JDECL_P (lvalue) && FIELD_FINAL (lvalue) &&\n       DECL_NAME (current_function_decl) != clinit_identifier_node)\n     {\n       parse_error_context \n@@ -8377,7 +8376,7 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n   /* Lhs can be a named variable */\n-  if (DECL_P (lvalue))\n+  if (JDECL_P (lvalue))\n     {\n       INITIALIZED_P (lvalue) = 1;\n       lhs_type = TREE_TYPE (lvalue);\n@@ -9488,9 +9487,9 @@ patch_unaryop (node, wfl_op)\n     case PREINCREMENT_EXPR:\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n-      if (!DECL_P (op) && !((TREE_CODE (op) == INDIRECT_REF \n-\t\t\t     || TREE_CODE (op) == COMPONENT_REF) \n-\t\t\t    && JPRIMITIVE_TYPE_P (TREE_TYPE (op))))\n+      if (!JDECL_P (op) && !((TREE_CODE (op) == INDIRECT_REF \n+\t\t\t      || TREE_CODE (op) == COMPONENT_REF) \n+\t\t\t     && JPRIMITIVE_TYPE_P (TREE_TYPE (op))))\n \t{\n \t  tree lvalue;\n \t  /* Before screaming, check that we're not in fact trying to\n@@ -10291,7 +10290,7 @@ build_new_loop (loop_body)\n        COMPOUND_EXPR\t\t(loop main body)\n          EXIT_EXPR\t\t(this order is for while/for loops.\n          LABELED_BLOCK_EXPR      the order is reversed for do loops)\n-           LABEL_DECL           (continue occurding here branche at the \n+           LABEL_DECL           (a continue occuring here branches at the \n            BODY\t\t\t end of this labeled block)\n        INCREMENT\t\t(if any)\n \n@@ -10482,6 +10481,16 @@ patch_bc_statement (node)\n   /* Find the statement we're targeting. */\n   target_stmt = LABELED_BLOCK_BODY (bc_label);\n \n+  /* Target loop is slightly burrowed in the case of a for loop, it\n+     appears at the first sight to be a block. */\n+  if (TREE_CODE (target_stmt) == BLOCK)\n+    {\n+      tree sub = BLOCK_SUBBLOCKS (target_stmt);\n+      if (sub && TREE_CODE (sub) == COMPOUND_EXPR && TREE_OPERAND (sub, 1)\n+\t  && TREE_CODE (TREE_OPERAND (sub, 1)) == LOOP_EXPR)\n+\ttarget_stmt = TREE_OPERAND (sub, 1);\n+    }\n+\n   /* 14.13 The break Statement */\n   if (IS_BREAK_STMT_P (node))\n     {\n@@ -10490,7 +10499,7 @@ patch_bc_statement (node)\n          while/do/for/switch */\n       if (is_unlabeled &&\n \t  !(TREE_CODE (target_stmt) == LOOP_EXPR        /* do/while/for */\n-\t    || TREE_CODE (target_stmt) == SWITCH_EXPR)) /* switch FIXME */\n+\t    || TREE_CODE (target_stmt) == SWITCH_EXPR)) /* switch */\n \t{\n \t  parse_error_context (wfl_operator, \n \t\t\t       \"`break' must be in loop or switch\");\n@@ -10501,18 +10510,21 @@ patch_bc_statement (node)\n \tEXIT_BLOCK_LABELED_BLOCK (node) = bc_label;\n     }\n   /* 14.14 The continue Statement */\n-  /* The continue statement must always target a loop */\n+  /* The continue statement must always target a loop, unnamed or not. */\n   else \n-    {\n+    { \n       if (TREE_CODE (target_stmt) != LOOP_EXPR) /* do/while/for */\n \t{\n \t  parse_error_context (wfl_operator, \"`continue' must be in loop\");\n \t  return error_mark_node;\n \t}\n       /* Everything looks good. We can fix the `continue' jump to go\n-         at the place in the loop were the continue is. The continue\n-\t is the current labeled block, by construction. */\n-      EXIT_BLOCK_LABELED_BLOCK (node) = bc_label = ctxp->current_labeled_block;\n+\t at the place in the loop were the continue is.  For unlabeled\n+\t continue, the continuation point is the current labeled\n+\t block, by construction. */\n+      if (is_unlabeled)\n+\tEXIT_BLOCK_LABELED_BLOCK (node) = \n+\t  bc_label = ctxp->current_labeled_block;\n     }\n \n   CAN_COMPLETE_NORMALLY (bc_label) = 1;"}]}