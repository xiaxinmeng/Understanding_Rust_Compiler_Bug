{"sha": "c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcyZmMyZDlkOTg0ZTg3N2Q1ZjkxMmMzZTU5ZThhMTJkMWFhZDAzYw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-10T01:05:19Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-10T01:05:19Z"}, "message": "Initial revision\n\nFrom-SVN: r4077", "tree": {"sha": "c39971c9d7ab0c5af58d8e1646e5441330042183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c39971c9d7ab0c5af58d8e1646e5441330042183"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/comments", "author": null, "committer": null, "parents": [{"sha": "b2055d6de346dec843ac1ca854180c12c8830930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2055d6de346dec843ac1ca854180c12c8830930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2055d6de346dec843ac1ca854180c12c8830930"}], "stats": {"total": 4820, "additions": 4820, "deletions": 0}, "files": [{"sha": "33e10bc6b5df9c0f698af654a65c63172589e406", "filename": "gcc/objc/Object.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FObject.h?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,121 @@\n+/* Interface for the Object class for Objective-C.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#ifndef __object_INCLUDE_GNU\n+#define __object_INCLUDE_GNU\n+\n+#include <objc/objc.h>\n+\n+/*\n+ * All classes are derived from Object.  As such,\n+ * this is the overhead tacked onto those objects.\n+ */\n+@interface Object\n+{\n+    Class_t\tisa;\t/* A pointer to the instance's class structure */\n+}\n+\n+        /* Initializing classes and instances */\n++ initialize;\n+- init;\n+\n+        /* Creating, freeing, and copying instances */\n++ new;\n++ alloc;\n+- free;\n+- copy;\n+- shallowCopy;\n+- deepen;\n+- deepCopy;\n+\n+        /* Identifying classes */\n+- (Class_t)class;\n+- (Class_t)superClass;\n+- (MetaClass_t)metaClass;\n+- (const char *)name;\n+\n+        /* Identifying and comparing objects */\n+- self;\n+- (unsigned int)hash;\n+- (BOOL)isEqual:anObject;\n+\n+        /* Testing object type */\n+- (BOOL)isMetaClass;\n+- (BOOL)isClass;\n+- (BOOL)isInstance;\n+\n+        /* Testing inheritance relationships */\n+- (BOOL)isKindOf:(Class_t)aClassObject;\n+- (BOOL)isMemberOf:(Class_t)aClassObject;\n+- (BOOL)isKindOfClassNamed:(const char *)aClassName;\n+- (BOOL)isMemberOfClassNamed:(const char *)aClassName;\n+\n+        /* Testing class functionality */\n++ (BOOL)instancesRespondTo:(SEL)aSel;\n+- (BOOL)respondsTo:(SEL)aSel;\n+\n+\t/* Testing protocol conformance */\n+- (BOOL)conformsTo:(Protocol*)aProtocol;\n+\n+        /* Introspection */\n++ (IMP)instanceMethodFor:(SEL)aSel;\n+- (IMP)methodFor:(SEL)aSel;\n++ (struct objc_method_description *)descriptionForInstanceMethod:(SEL)aSel;\n+- (struct objc_method_description *)descriptionForMethod:(SEL)aSel;\n+\n+        /* Sending messages determined at run time */\n+- perform:(SEL)aSel;\n+- perform:(SEL)aSel with:anObject;\n+- perform:(SEL)aSel with:anObject1 with:anObject2;\n+\n+        /* Forwarding */\n+- forward:(SEL)aSel :(arglist_t)argFrame;\n+- performv:(SEL)aSel :(arglist_t)argFrame;\n+\n+        /* Posing */\n++ poseAs:(Class_t)aClassObject;\n+- (Class_t)transmuteClassTo:(Class_t)aClassObject;\n+\n+        /* Enforcing intentions */\n+- subclassResponsibility:(SEL)aSel;\n+- notImplemented:(SEL)aSel;\n+\n+        /* Error handling */\n+- doesNotRecognize:(SEL)aSel;\n+- error:(const char *)aString, ...;\n+\n+        /* Archiving */\n++ (int)version;\n++ setVersion:(int)aVersion;\n+\n+- read: (TypedStream*)aStream;\n+- write: (TypedStream*)aStream;\n+\n++ read: (TypedStream*)aStream;\n++ write: (TypedStream*)aStream;\n+\n+@end\n+\n+#endif"}, {"sha": "330c9a80e7a5b91089d9f3a36d4e2e8c4480826c", "filename": "gcc/objc/Object.m", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FObject.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FObject.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FObject.m?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,454 @@\n+/* The implementation of class Object for Objective-C.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#include <objc/Object.h>\n+#include <objc/Protocol.h>\n+#include <objc/objc-api.h>\n+#include <objc/objc-archive.h>\n+\n+extern int strlen(const char *);\n+extern int strcmp(const char *, const char *);\n+extern int read(int, void *, int);\n+extern int write(int, const void *, int);\n+extern int errno;\n+\n+#define MAX_CLASS_NAME_LEN 256\n+\n+@implementation Object\n+\n+// Initialize a class\n+// often overridden by subclasses\n++ initialize\n+{\n+  return self;\n+}\n+\n+// Initialize an instance\n+// this method does not apply to class objects\n+// often overridden by subclasses (should call superclass version)\n+- init\n+{\n+  return self;\n+}\n+\n+// Create and initialize an instance of a class\n+// not usually overridden by subclasses (should call superclass version)\n++ new\n+{\n+  return [[self alloc] init];\n+}\n+\n+// Creates an instance of a class\n+// should NOT be overridden by subclasses\n++ alloc\n+{\n+  return class_create_instance(self);\n+}\n+\n+// Free an instance\n+// this method does not apply to class objects\n+// often overridden by subclasses (should call superclass version)\n+- free\n+{\n+  return object_dispose(self);\n+}\n+\n+// Create a copy of the receiving instance\n+// this method does not apply to class objects\n+// not usually overridden by subclasses\n+- copy\n+{\n+  return [[self shallowCopy] deepen];\n+}\n+\n+// Creates a copy of only the receiving instance\n+// this method does not apply to class objects\n+// should NOT be overridden by subclasses\n+- shallowCopy\n+{\n+  return object_copy(self);\n+}\n+\n+// Deepens a shallow copy of an instance\n+// this method does not apply to class objects\n+// often overridden by subclasses (should call superclass version)\n+- deepen\n+{\n+  return self;\n+}\n+\n+// Creates a recursive copy of the receiving instance\n+// this method does not apply to class objects\n+// may be overridden by subclasses\n+// Not correct, but included for compatibility with Stepstone\n+- deepCopy\n+{\n+  return [self copy];\n+}\n+\n+// Return the class object or the class of an instance\n+// not usually overridden by subclasses\n+- (Class_t)class\n+{\n+  return object_get_class(self);\n+}\n+\n+// Return the superclass of a class or instance\n+// not usually overridden by subclasses\n+- (Class_t)superClass\n+{\n+  return object_get_super_class(self);\n+}\n+\n+// Return the metaclass of a class or instance\n+// not usually overridden by subclasses\n+- (MetaClass_t)metaClass\n+{\n+  return object_get_meta_class(self);\n+}\n+\n+// Return the character string name of a class or an instance's class\n+// not usually overridden by subclasses\n+- (const char *)name\n+{\n+  return object_get_class_name(self);\n+}\n+\n+// Return the receiving class or instance object\n+// not usually overridden by subclasses\n+- self\n+{\n+  return self;\n+}\n+\n+// Return a hash value for a class or instance object\n+// not usually overridden by subclasses\n+- (unsigned int)hash\n+{\n+  return (unsigned int)self;\n+}\n+\n+// Indicates if anObject is the receiving class or instance object\n+// not usually overridden by subclasses\n+- (BOOL)isEqual:anObject\n+{\n+  return self==anObject;\n+}\n+\n+// Indicates if the receiver is a metaclass object\n+// should NOT be overridden by subclasses\n+- (BOOL)isMetaClass\n+{\n+  return NO;\n+}\n+\n+// Indicates if the receiver is a class object\n+// should NOT be overridden by subclasses\n+- (BOOL)isClass\n+{\n+  return object_is_class(self);\n+}\n+\n+// Indicates if the receiver is an instance object\n+// should NOT be overridden by subclasses\n+- (BOOL)isInstance\n+{\n+  return object_is_instance(self);\n+}\n+\n+// Indicates if the receiver is a type of aClassObject\n+// not usually overridden by subclasses\n+- (BOOL)isKindOf:(Class_t)aClassObject\n+{\n+  Class_t class;\n+\n+  for (class = self->isa; class!=Nil; class = class_get_super_class(class))\n+    if (class==aClassObject)\n+      return YES;\n+  return NO;\n+}\n+\n+// Indicates if the receiver is a member of the aClassObject class\n+// not usually overridden by subclasses\n+- (BOOL)isMemberOf:(Class_t)aClassObject\n+{\n+  return self->isa==aClassObject;\n+}\n+\n+// Indicates if the receiver is a type of the class named aClassName\n+// not usually overridden by subclasses\n+- (BOOL)isKindOfClassNamed:(const char *)aClassName\n+{\n+  Class_t class;\n+\n+  if (aClassName!=NULL)\n+    for (class = self->isa; class!=Nil; class = class_get_super_class(class))\n+      if (!strcmp(class_get_class_name(class), aClassName))\n+        return YES;\n+  return NO;\n+}\n+\n+// Indicates if the receiver is a member of the class named aClassName\n+// not usually overridden by subclasses\n+- (BOOL)isMemberOfClassNamed:(const char *)aClassName\n+{\n+  return ((aClassName!=NULL)\n+          &&!strcmp(class_get_class_name(self->isa), aClassName));\n+}\n+\n+// Indicates if instances of a class respond to the message aSel\n+// not usually overridden by subclasses\n++ (BOOL)instancesRespondTo:(SEL)aSel\n+{\n+  return class_get_instance_method(self, aSel)!=METHOD_NULL;\n+}\n+\n+// Indicates if the receiving class or instance responds to the message aSel\n+// not usually overridden by subclasses\n+- (BOOL)respondsTo:(SEL)aSel\n+{\n+  return ((object_is_instance(self)\n+           ?class_get_instance_method(self->isa, aSel)\n+           :class_get_class_method(self->isa, aSel))!=METHOD_NULL);\n+}\n+\n+// Returns the address of a class's instance method\n+// not usually overridden by subclasses\n++ (IMP)instanceMethodFor:(SEL)aSel\n+{\n+  return method_get_imp(class_get_instance_method(self, aSel));\n+}\n+\n+// Indicates if the receiving class or instance conforms to the given protocol\n+// not usually overridden by subclasses\n+- (BOOL) conformsTo: (Protocol*)aProtocol\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+\n+  for (proto_list = isa->protocols;\n+       proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+      {\n+        if ([proto_list->list[i] conformsTo: aProtocol])\n+          return YES;\n+      }\n+    }\n+\n+  return NO;\n+}\n+\n+\n+// Returns the address of a class's class or an instance's instance method\n+// not usually overridden by subclasses\n+- (IMP)methodFor:(SEL)aSel\n+{\n+  return (method_get_imp(object_is_instance(self)\n+                         ?class_get_instance_method(self->isa, aSel)\n+                         :class_get_class_method(self->isa, aSel)));\n+}\n+\n+// Returns a method description for a class's instance method aSel\n+// not usually overridden by subclasses\n++ (struct objc_method_description *)descriptionForInstanceMethod:(SEL)aSel\n+{\n+  return ((struct objc_method_description *)\n+           class_get_instance_method(self, aSel));\n+}\n+\n+// Returns a description for a class's class or an instance's instance method\n+// not usually overridden by subclasses\n+- (struct objc_method_description *)descriptionForMethod:(SEL)aSel\n+{\n+  return ((struct objc_method_description *)\n+           (object_is_instance(self)\n+            ?class_get_instance_method(self->isa, aSel)\n+            :class_get_class_method(self->isa, aSel)));\n+}\n+\n+// Sends the message aSel, which takes no parameters, to the receiver\n+// not usually overridden by subclasses\n+- perform:(SEL)aSel\n+{\n+  IMP msg = objc_msg_lookup(self, aSel);\n+  if (!msg)\n+    return [self error:\"invalid selector passed to %s\", sel_get_name(_cmd)];\n+  return (*msg)(self, aSel);\n+}\n+\n+// Sends the message aSel, which takes one id parameter, to the receiver\n+// not usually overridden by subclasses\n+- perform:(SEL)aSel with:anObject\n+{\n+  IMP msg = objc_msg_lookup(self, aSel);\n+  if (!msg)\n+    return [self error:\"invalid selector passed to %s\", sel_get_name(_cmd)];\n+  return (*msg)(self, aSel, anObject);\n+}\n+\n+// Sends the message aSel, which takes two id parameters, to the receiver\n+// not usually overridden by subclasses\n+- perform:(SEL)aSel with:anObject1 with:anObject2\n+{\n+  IMP msg = objc_msg_lookup(self, aSel);\n+  if (!msg)\n+    return [self error:\"invalid selector passed to %s\", sel_get_name(_cmd)];\n+  return (*msg)(self, aSel, anObject1, anObject2);\n+}\n+\n+// Forwards a message to which a class or instance object does not respond\n+// may be overridden by subclasses\n+- forward:(SEL)aSel :(arglist_t)argFrame\n+{\n+  return [self doesNotRecognize: aSel];\n+}\n+\n+// Sends a message aSel, of arbitrary arguments, to the receiver\n+// should NOT be overridden by subclasses\n+- performv:(SEL)aSel :(arglist_t)argFrame\n+{\n+  return objc_msg_sendv(self, aSel, method_get_argsize(0), argFrame);\n+}\n+\n+// Instructs the runtime system that the receiver is to pose for aClassObject\n+// not usually overridden by subclasses\n++ poseAs:(Class_t)aClassObject\n+{\n+  return class_pose_as(self, aClassObject);\n+}\n+\n+// Changes the receiver's class to be aClassObject\n+// this method does not apply to class objects\n+// not usually overridden by subclasses\n+- (Class_t)transmuteClassTo:(Class_t)aClassObject\n+{\n+  if (object_is_instance(self))\n+    if (class_is_class(aClassObject))\n+      if (class_get_instance_size(aClassObject)==class_get_instance_size(isa))\n+        if ([self isKindOf:aClassObject])\n+          {\n+            Class_t old_isa = isa;\n+            isa = aClassObject;\n+            return old_isa;\n+          }\n+  return nil;\n+}\n+\n+// Indicates that a subclass did not override a class or instance message\n+//   it was supposed to have overridden\n+// not usually overridden by subclasses\n+- subclassResponsibility:(SEL)aSel\n+{\n+  return [self error:\"subclass should override %s\", sel_get_name(aSel)];\n+}\n+\n+// Indicates that a class or instance method has not been implemented\n+// may be overridden by subclasses\n+- notImplemented:(SEL)aSel\n+{\n+  return [self error:\"method %s not implemented\", sel_get_name(aSel)];\n+}\n+\n+// Reports that a class or instance does not recognize the message aSel\n+// not usually overridden by subclasses\n+- doesNotRecognize:(SEL)aSel\n+{\n+  return [self error:\"%s does not recognize %s\",\n+                     object_get_class_name(self), sel_get_name(aSel)];\n+}\n+\n+// Reports an error\n+// not usually overridden by subclasses\n+- error:(const char *)aString, ...\n+{\n+#define FMT \"error: %s (%s)\\n%s\\n\"\n+  char fmt[(strlen(FMT)+strlen(object_get_class_name(self))\n+            +((aString!=NULL)?strlen(aString):0)+8)];\n+  va_list ap;\n+\n+  sprintf(fmt, FMT, object_get_class_name(self),\n+                    object_is_instance(self)?\"instance\":\"class\",\n+                    (aString!=NULL)?aString:\"\");\n+  va_start(ap, aString);\n+  (*_objc_error)(self, fmt, ap);\n+  va_end(ap);\n+  return nil;\n+#undef FMT\n+}\n+\n+// Returns the class's version number\n+// not usually overridden by subclasses\n++ (int)version\n+{\n+  return class_get_version(self);\n+}\n+\n+// Sets the class's version number\n+// not usually overridden by subclasses\n++ setVersion:(int)aVersion\n+{\n+  class_set_version(self, aVersion);\n+  return self;\n+}\n+\n+// These are used to write or read the instance variables \n+// declared in this particular part of the object.  Subclasses\n+// should extend these, by calling [super read/write: aStream]\n+// before doing their own archiving.  These methods are private, in\n+// the sense that they should only be called from subclasses.\n+\n+- read: (TypedStream*)aStream\n+{\n+  // [super read: aStream];  \n+  return self;\n+}\n+\n+- write: (TypedStream*)aStream\n+{\n+  // [super write: aStream];\n+  return self;\n+}\n+\n+// These are used to read or write class information, such as static\n+// variables used in that class.  The version number of the class being \n+// read can be obtained from \n+//     objc_typed_stream_class_version(stream, class_name)  \n+\n++ write: (TypedStream*)aStream\n+{\n+  // [super write: aStream];\n+  return self;\n+}\n+\n++ read: (TypedStream*)aStream\n+{\n+  // [super read: aStream];\n+  return self;\n+}\n+\n+\n+\n+@end"}, {"sha": "1b26bcb33b6cd1e53a4bea6e9c31c0d30925d8b2", "filename": "gcc/objc/Protocol.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FProtocol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FProtocol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FProtocol.h?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,57 @@\n+/* Declare the class Protocol for Objective C programs.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __Protocol_INCLUDE_GNU\n+#define __Protocol_INCLUDE_GNU\n+\n+#include <objc/Object.h>\t\n+\n+@interface Protocol : Object\n+{\n+@private\n+        char *protocol_name;\n+        struct objc_protocol_list *protocol_list;\n+        struct objc_method_description_list *instance_methods, *class_methods; \n+}\n+\n+/* Obtaining attributes intrinsic to the protocol */\n+\n+- (const char *)name;\n+\n+/* Testing protocol conformance */\n+\n+- (BOOL) conformsTo: (Protocol *)aProtocolObject;\n+\n+/* Looking up information specific to a protocol */\n+\n+- (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel;\n+- (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel;\n+\n+@end\n+\n+\n+\n+\n+#endif __Protocol_INCLUDE_GNU"}, {"sha": "f4999bc8e44d0a8d181ef770da4934cd56b74fdf", "filename": "gcc/objc/Protocol.m", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FProtocol.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2FProtocol.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FProtocol.m?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,127 @@\n+/* This file contains the implementation of class Protocol.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC. \n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+ \n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include <objc/Protocol.h>\n+#include <objc/objc-api.h>\n+\n+/* Method description list */\n+struct objc_method_description_list {\n+        int count;\n+        struct objc_method_description list[1];\n+};\n+\n+\n+@implementation Protocol\n+{\n+@private\n+        char *protocol_name;\n+        struct objc_protocol_list *protocol_list;\n+        struct objc_method_description_list *instance_methods, *class_methods; \n+}\n+\n+/* Obtaining attributes intrinsic to the protocol */\n+\n+- (const char *)name\n+{\n+  return protocol_name;\n+}\n+\n+/* Testing protocol conformance */\n+\n+- (BOOL) conformsTo: (Protocol *)aProtocolObject\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+\n+  if (!strcmp(aProtocolObject->protocol_name, self->protocol_name))\n+    return YES;\n+\n+  for (proto_list = protocol_list; proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+\t{\n+\t  if ([proto_list->list[i] conformsTo: aProtocolObject])\n+\t    return YES;\n+\t}\n+    }\n+\n+  return NO;\n+}\n+\n+/* Looking up information specific to a protocol */\n+\n+- (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+  const char* name = sel_get_name (aSel);\n+  struct objc_method_description *result;\n+\n+  for (i = 0; i < instance_methods->count; i++)\n+    {\n+      if (!strcmp ((char*)instance_methods->list[i].name, name))\n+\treturn &(instance_methods->list[i]);\n+    }\n+\n+  for (proto_list = protocol_list; proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+\t{\n+\t  if ((result = [proto_list->list[i]\n+\t\t\t descriptionForInstanceMethod: aSel]))\n+\t    return result;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+- (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel;\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+  const char* name = sel_get_name (aSel);\n+  struct objc_method_description *result;\n+\n+  for (i = 0; i < class_methods->count; i++)\n+    {\n+      if (!strcmp ((char*)class_methods->list[i].name, name))\n+\treturn &(class_methods->list[i]);\n+    }\n+\n+  for (proto_list = protocol_list; proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+\t{\n+\t  if ((result = [proto_list->list[i]\n+\t\t\t descriptionForClassMethod: aSel]))\n+\t    return result;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+@end"}, {"sha": "8398984f744821ee7b1c7c4d5032daa47accc0f5", "filename": "gcc/objc/archive.c", "status": "added", "additions": 1378, "deletions": 0, "changes": 1378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Farchive.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,1378 @@\n+/* GNU Objective C Runtime archiving\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+/*\n+** Note: This version assumes that int and longs are both 32bit.\n+**       Most API function are in the bottom of this file.\n+*/\n+\n+#include \"runtime.h\"\n+#include <objc/objc-archive.h>\n+\n+#define __objc_fatal(format, args...) \\\n+ { fprintf(stderr, \"archining: \"); \\\n+   fprintf(stderr, format, ## args); \\\n+   fprintf(stderr, \"\\n\"); abort(); }\n+\n+/* Declare some functions... */\n+\n+static int\n+objc_read_class (struct objc_typed_stream* stream, Class** class);\n+\n+static int\n+objc_sizeof_type(const char* type);\n+\n+static int\n+objc_write_use_common (struct objc_typed_stream* stream, unsigned int key);\n+\n+static int\n+objc_write_register_common (struct objc_typed_stream* stream,\n+\t\t\t    unsigned int key);\n+\n+static int \n+objc_write_class (struct objc_typed_stream* stream,\n+\t\t\t struct objc_class* class);\n+\n+static const char*\n+__objc_skip_type (const char* type);\n+\n+static __inline__ int\n+__objc_code_unsigned_char (unsigned char* buf, unsigned char val)\n+{\n+  if ((val&_B_VALUE) == val)\n+    {\n+      buf[0] = val|_B_SINT;\n+      return 1;\n+    }\n+  else\n+    {\n+      buf[0] = _B_NINT|0x01;\n+      buf[1] = val;\n+      return 2;\n+    }\n+}\n+\n+int\n+objc_write_unsigned_char (struct objc_typed_stream* stream,\n+\t\t\t  unsigned char value)\n+{\n+  unsigned char buf[sizeof (unsigned char)+1];\n+  int len = __objc_code_unsigned_char (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_char (unsigned char* buf, char val)\n+{\n+  if (val >= 0)\n+    return __objc_code_unsigned_char (buf, val);\n+  else\n+    {\n+      buf[0] = _B_NINT|_B_SIGN|0x01;\n+      buf[1] = -val;\n+      return 2;\n+    }\n+}\n+\n+int\n+objc_write_char (struct objc_typed_stream* stream, char value)\n+{\n+  unsigned char buf[sizeof (char)+1];\n+  int len = __objc_code_char (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_unsigned_short (unsigned char* buf, unsigned short val)\n+{\n+  if (val <= 0xffU)\n+    return __objc_code_unsigned_char (buf, val);\n+\n+  else \n+    {\n+      buf[0] = _B_NINT|0x02;\n+      buf[1] = val/0x100;\n+      buf[2] = val%0x100;\n+      return 3;\n+    }\n+}\n+\n+int\n+objc_write_unsigned_short (struct objc_typed_stream* stream, unsigned short value)\n+{\n+  unsigned char buf[sizeof (unsigned short)+1];\n+  int len = __objc_code_unsigned_short (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+      \n+static __inline__ int\n+__objc_code_short (unsigned char* buf, short val)\n+{\n+  if (val > 0)\n+    return __objc_code_unsigned_short (buf, val);\n+\n+  if (val > -0x7f)\t\t/* val > -128 */\n+    return __objc_code_char (buf, val);\n+\n+  else \n+    {\n+      int len = __objc_code_unsigned_short (buf, -val);\n+      buf[0] |= _B_SIGN;\n+      return len;\n+    }\n+}\n+\n+int\n+objc_write_short (struct objc_typed_stream* stream, short value)\n+{\n+  unsigned char buf[sizeof (short)+1];\n+  int len = __objc_code_short (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+      \n+\n+static __inline__ int\n+__objc_code_unsigned_int (unsigned char* buf, unsigned int val)\n+{\n+  if (val < 0x10000)\n+    return __objc_code_unsigned_short (buf, val%0x10000);\n+\n+  else if (val < 0x1000000)\n+    {\n+      buf[0] = _B_NINT|3;\n+      buf[1] = val/0x10000;\n+      buf[2] = (val%0x10000)/0x100;\n+      buf[3] = val%0x100;\n+      return 4;\n+    }\n+\n+  else \n+    {\n+      buf[0] = _B_NINT|4;\n+      buf[1] = val/0x1000000;\n+      buf[2] = (val%0x1000000)/0x10000;\n+      buf[3] = (val%0x10000)/0x100;\n+      buf[4] = val%0x100;\n+      return 5;\n+    }\n+}\n+\n+int\n+objc_write_unsigned_int (struct objc_typed_stream* stream, unsigned int value)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len = __objc_code_unsigned_int (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_int (unsigned char* buf, int val)\n+{\n+  if (val >= 0)\n+    return __objc_code_unsigned_int (buf, val);\n+\n+  if (val > -0x7f)\n+    return __objc_code_char (buf, val);\n+\n+  else \n+    {\n+      int len = __objc_code_unsigned_int (buf, -val);\n+      buf[0] |= _B_SIGN;\n+      return len;\n+    }\n+}\n+\n+int\n+objc_write_int (struct objc_typed_stream* stream, int value)\n+{\n+  unsigned char buf[sizeof(int)+1];\n+  int len = __objc_code_int (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+int\n+objc_write_string (struct objc_typed_stream* stream,\n+\t\t   const unsigned char* string, unsigned int nbytes)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len = __objc_code_unsigned_int (buf, nbytes);\n+  \n+  if ((buf[0]&_B_CODE) == _B_SINT)\n+    buf[0] = (buf[0]&_B_VALUE)|_B_SSTR;\n+\n+  else /* _B_NINT */\n+    buf[0] = (buf[0]&_B_VALUE)|_B_NSTR;\n+\n+  if ((*stream->write)(stream->physical, buf, len) != 0)\n+    return (*stream->write)(stream->physical, string, nbytes);\n+  else\n+    return 0;\n+}\n+\n+int\n+objc_write_string_atomic (struct objc_typed_stream* stream,\n+\t\t\t  unsigned char* string, unsigned int nbytes)\n+{\n+  unsigned int key;\n+  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, string)))\n+    return objc_write_use_common (stream, key);\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->stream_table, (void*)key=(unsigned int)string, string);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn objc_write_string (stream, string, nbytes);\n+      return length;\n+    }\n+}\n+\n+static int\n+objc_write_register_common (struct objc_typed_stream* stream, unsigned int key)\n+{\n+  unsigned char buf[sizeof (unsigned int)+2];\n+  int len = __objc_code_unsigned_int (buf+1, key);\n+  if (len == 1)\n+    {\n+      buf[0] = _B_RCOMM|0x01;\n+      buf[1] &= _B_VALUE;\n+      return (*stream->write)(stream->physical, buf, len+1);\n+    }\n+  else\n+    {\n+      buf[1] = (buf[1]&_B_VALUE)|_B_RCOMM;\n+      return (*stream->write)(stream->physical, buf+1, len);\n+    }\n+}\n+\n+static int\n+objc_write_use_common (struct objc_typed_stream* stream, unsigned int key)\n+{\n+  unsigned char buf[sizeof (unsigned int)+2];\n+  int len = __objc_code_unsigned_int (buf+1, key);\n+  if (len == 1)\n+    {\n+      buf[0] = _B_UCOMM|0x01;\n+      buf[1] &= _B_VALUE;\n+      return (*stream->write)(stream->physical, buf, 2);\n+    }\n+  else\n+    {\n+      buf[1] = (buf[1]&_B_VALUE)|_B_UCOMM;\n+      return (*stream->write)(stream->physical, buf+1, len);\n+    }\n+}\n+\n+static __inline__ int\n+__objc_write_extension (struct objc_typed_stream* stream, unsigned char code)\n+{\n+  if (code <= _B_VALUE)\n+    {\n+      unsigned char buf = code|_B_EXT;\n+      return (*stream->write)(stream->physical, &buf, 1);\n+    }\n+  else \n+    abort();\n+}\n+\n+__inline__ int\n+__objc_write_object (struct objc_typed_stream* stream, id object)\n+{\n+  unsigned char buf = '\\0';\n+  SEL write_sel = sel_get_uid (\"write:\");\n+  if (object)\n+    {\n+      __objc_write_extension (stream, _BX_OBJECT);\n+      objc_write_class (stream, object->class_pointer);\n+      (*objc_msg_lookup(object, write_sel))(object, write_sel, stream);\n+      return (*stream->write)(stream->physical, &buf, 1);\n+    }\n+  else\n+    return objc_write_use_common(stream, 0);\n+}\n+\n+int \n+objc_write_object (struct objc_typed_stream* stream, id object)\n+{\n+  unsigned int key;\n+  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, object)))\n+    return objc_write_use_common (stream, key);\n+\n+  else if (object == nil)\n+    return objc_write_use_common(stream, 0);\n+\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->stream_table, (void*)key=(unsigned int)object, object);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn __objc_write_object (stream, object);\n+      return length;\n+    }\n+}\n+\n+__inline__ int\n+__objc_write_class (struct objc_typed_stream* stream, struct objc_class* class)\n+{\n+  unsigned char buf = '\\0';\n+  SEL write_sel = sel_get_uid (\"write:\");\n+  __objc_write_extension (stream, _BX_CLASS);\n+  objc_write_string_atomic(stream, (char*)class->name,\n+\t\t\t   strlen(class->name));\n+  objc_write_unsigned_int (stream, CLS_GETNUMBER(class));\n+  (*objc_msg_lookup(class, write_sel))(class, write_sel, stream);\n+  return (*stream->write)(stream->physical, &buf, 1);\n+}\n+\n+\n+static int \n+objc_write_class (struct objc_typed_stream* stream,\n+\t\t\t struct objc_class* class)\n+{\n+  unsigned int key;\n+  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, class)))\n+    return objc_write_use_common (stream, key);\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->stream_table, (void*)key=(unsigned int)class, class);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn __objc_write_class (stream, class);\n+      return length;\n+    }\n+}\n+\n+\n+__inline__ int \n+__objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n+{\n+  const char* sel_name = sel_get_name (selector);\n+  __objc_write_extension (stream, _BX_SEL);\n+  return objc_write_string (stream, sel_name, strlen(sel_name));\n+}\n+\n+int \n+objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n+{\n+  const char* sel_name = sel_get_name (selector);\n+  unsigned int key;\n+  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, sel_name)))\n+    return objc_write_use_common (stream, key);\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->stream_table, (void*)key=(unsigned int)sel_name, (char*)sel_name);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn __objc_write_selector (stream, selector);\n+      return length;\n+    }\n+}\n+\n+\n+\n+/*\n+** Read operations \n+*/\n+\n+__inline__ int\n+objc_read_char (struct objc_typed_stream* stream, char* val)\n+{\n+  unsigned char buf;\n+  int len;\n+  len = (*stream->read)(stream->physical, &buf, 1);\n+  if (len != 0)\n+    {\n+      if ((buf & _B_CODE) == _B_SINT)\n+\t(*val) = (buf & _B_VALUE);\n+\n+      else if ((buf & _B_NUMBER) == 1)\n+\t{\n+\t  len = (*stream->read)(stream->physical, val, 1);\n+\t  if (buf&_B_SIGN)\n+\t    (*val) = -1*(*val);\n+\t}\n+\n+      else\n+\t__objc_fatal(\"expected 8bit signed int, got %dbit int\",\n+\t\t     (int)(buf&_B_NUMBER)*8);\n+    }\n+  return len;\n+}\n+\n+\n+__inline__ int\n+objc_read_unsigned_char (struct objc_typed_stream* stream, unsigned char* val)\n+{\n+  unsigned char buf;\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, &buf, 1)))\n+    {\n+      if ((buf & _B_CODE) == _B_SINT)\n+\t(*val) = (buf & _B_VALUE);\n+\n+      else if ((buf & _B_NUMBER) == 1)\n+\tlen = (*stream->read)(stream->physical, val, 1);\n+\n+      else\n+\t__objc_fatal(\"expected 8bit unsigned int, got %dbit int\",\n+\t\t     (int)(buf&_B_NUMBER)*8);\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+objc_read_short (struct objc_typed_stream* stream, short* value)\n+{\n+  unsigned char buf[sizeof(short)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (short))\n+\t    __objc_fatal(\"expected short, got bigger (%dbits)\", nbytes*8);\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t  if (buf[0] & _B_SIGN)\n+\t    (*value) = -(*value);\n+\t}\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+objc_read_unsigned_short (struct objc_typed_stream* stream,\n+\t\t\t  unsigned short* value)\n+{\n+  unsigned char buf[sizeof(unsigned short)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (short))\n+\t    __objc_fatal(\"expected short, got int or bigger\");\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t}\n+    }\n+  return len;\n+}\n+\n+\n+__inline__ int\n+objc_read_int (struct objc_typed_stream* stream, int* value)\n+{\n+  unsigned char buf[sizeof(int)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (int))\n+\t    __objc_fatal(\"expected int, got bigger\");\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t  if (buf[0] & _B_SIGN)\n+\t    (*value) = -(*value);\n+\t}\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+__objc_read_nbyte_uint (struct objc_typed_stream* stream,\n+\t\t       unsigned int nbytes, unsigned int* val)\n+{\n+  int len, pos = 0;\n+  unsigned char buf[sizeof(unsigned int)+1];\n+\n+  if (nbytes > sizeof (int))\n+    __objc_fatal(\"expected int, got bigger\");\n+\n+  len = (*stream->read)(stream->physical, buf, nbytes);\n+  (*val) = 0;\n+  while (pos < nbytes)\n+    (*val) = ((*val)*0x100) + buf[pos++];\n+  return len;\n+}\n+  \n+\n+__inline__ int\n+objc_read_unsigned_int (struct objc_typed_stream* stream,\n+\t\t\tunsigned int* value)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\tlen = __objc_read_nbyte_uint (stream, (buf[0] & _B_VALUE), value);\n+\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+objc_read_string (struct objc_typed_stream* stream,\n+\t\t  char** string)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      unsigned int key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n+\t{\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      switch (buf[0]&_B_CODE) {\n+      case _B_SSTR:\n+\t{\n+\t  int length = buf[0]&_B_VALUE;\n+\t  (*string) = (char*)malloc(length+1);\n+\t  if (key)\n+\t    hash_add (&stream->stream_table, (void*)key, *string);\n+\t  len = (*stream->read)(stream->physical, *string, length);\n+\t  (*string)[length] = '\\0';\n+\t}\n+\tbreak;\n+\n+      case _B_UCOMM:\n+\t{\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*string) = hash_value_for_key (stream->stream_table, (void*)key);\n+\t}\n+\tbreak;\n+\n+      case _B_NSTR:\n+\t{\n+\t  unsigned int nbytes = buf[0]&_B_VALUE;\n+\t  len = __objc_read_nbyte_uint(stream, nbytes, &nbytes);\n+\t  if (len) {\n+\t    (*string) = (char*)malloc(nbytes);\n+\t    if (key)\n+\t      hash_add (&stream->stream_table, (void*)key, *string);\n+\t    len = (*stream->read)(stream->physical, *string, buf[0]&_B_VALUE);\n+\t    (*string)[nbytes] = '\\0';\n+\t  }\n+\t}\n+\tbreak;\n+\t\n+      default:\n+\t__objc_fatal(\"expected string, got opcode %c\\n\", (buf[0]&_B_CODE));\n+      }\n+    }\n+\n+  return len;\n+}\n+\n+\n+int\n+objc_read_object (struct objc_typed_stream* stream, id* object)\n+{\n+  unsigned char buf[sizeof (unsigned int)];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      SEL read_sel = sel_get_uid (\"read:\");\n+      unsigned int key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register common */\n+\t{\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      if (buf[0] == (_B_EXT | _BX_OBJECT))\n+\t{\n+\t  Class* class;\n+\n+\t  /* get class */\n+\t  len = objc_read_class (stream, &class);\n+\n+\t  /* create instance */\n+\t  (*object) = class_create_instance(class);\n+\n+\t  /* register? */\n+\t  if (key)\n+\t    hash_add (&stream->stream_table, (void*)key, *object);\n+\n+\t  /* send -read: */\n+\t  if (__objc_responds_to (*object, read_sel))\n+\t    (*get_imp(class, read_sel))(*object, read_sel, stream);\n+\n+\t  /* check null-byte */\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  if (buf[0] != '\\0')\n+\t    __objc_fatal(\"expected null-byte, got opcode %c\", buf[0]);\n+\t}\n+\n+      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n+\t{\n+\t  if (key)\n+\t    __objc_fatal(\"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*object) = hash_value_for_key (stream->stream_table, (void*)key);\n+\t}\n+\n+      else\n+\t__objc_fatal(\"expected object, got opcode %c\", buf[0]);\n+    }\n+  return len;\n+}\n+\n+static int\n+objc_read_class (struct objc_typed_stream* stream, Class** class)\n+{\n+  unsigned char buf[sizeof (unsigned int)];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      SEL read_sel = sel_get_uid (\"read:\");\n+      unsigned int key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n+\t{\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      if (buf[0] == (_B_EXT | _BX_CLASS))\n+\t{\n+\t  char* class_name;\n+\t  int version;\n+\n+\t  /* get class */\n+\t  len = objc_read_string (stream, &class_name);\n+\t  (*class) = objc_get_class(class_name);\n+\t  free (class_name);\n+\n+\t  /* register */\n+\t  if (key)\n+\t    hash_add (&stream->stream_table, (void*)key, *class);\n+\n+\t  /* call +read: */\n+\t  (*objc_msg_lookup(*class, read_sel))(*class, read_sel, stream);\n+\n+\t  objc_read_unsigned_int(stream, &version);\n+\t  hash_add (&stream->class_table, (*class)->name, (void*)version);\n+\n+\t  /* check null-byte */\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  if (buf[0] != '\\0')\n+\t    __objc_fatal(\"expected null-byte, got opcode %c\", buf[0]);\n+\t}\n+\n+      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n+\t{\n+\t  if (key)\n+\t    __objc_fatal(\"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*class) = hash_value_for_key (stream->stream_table, (void*)key);\n+\t  if (!*class)\n+\t    __objc_fatal(\"cannot find class for key %x\", key);\n+\t}\n+\n+      else\n+\t__objc_fatal(\"expected class, got opcode %c\", buf[0]);\n+    }\n+  return len;\n+}\n+\n+int\n+objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n+{\n+  unsigned char buf[sizeof (unsigned int)];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      unsigned int key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n+\t{\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      if (buf[0] == (_B_EXT|_BX_SEL)) /* selector! */\n+\t{\n+\t  char* selector_name;\n+\n+\t  /* get selector */\n+\t  len = objc_read_string (stream, &selector_name);\n+\t  (*selector) = sel_get_uid(selector_name);\n+\t  free (selector_name);\n+\n+\t  /* register */\n+\t  if (key)\n+\t    hash_add (&stream->stream_table, (void*)key, *selector);\n+\t}\n+\n+      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n+\t{\n+\t  if (key)\n+\t    __objc_fatal(\"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*selector) = hash_value_for_key (stream->stream_table, (void*)key);\n+\t}\n+\n+      else\n+\t__objc_fatal(\"expected selector, got opcode %c\", buf[0]);\n+    }\n+  return len;\n+}\n+\n+static int\n+objc_sizeof_type(const char* type)\n+{\n+  switch(*type) {\n+  case _C_ID: return sizeof(id);\n+    break;\n+\n+  case _C_CLASS:\n+    return sizeof(Class*);\n+    break;\n+\n+  case _C_SEL:\n+    return sizeof(SEL);\n+    break;\n+\n+  case _C_CHR:\n+    return sizeof(char);\n+    break;\n+    \n+  case _C_UCHR:\n+    return sizeof(unsigned char);\n+    break;\n+\n+  case _C_SHT:\n+    return sizeof(short);\n+    break;\n+\n+  case _C_USHT:\n+    return sizeof(unsigned short);\n+    break;\n+\n+  case _C_INT:\n+  case _C_LNG:\n+    return sizeof(int);\n+    break;\n+\n+  case _C_UINT:\n+  case _C_ULNG:\n+    return sizeof(unsigned int);\n+    break;\n+\n+  case _C_ATOM:\n+  case _C_CHARPTR:\n+    return sizeof(char*);\n+    break;\n+\n+  default:\n+    fprintf(stderr, \"objc_write_type: cannot parse typespec: %s\\n\", type);\n+    abort();\n+  }\n+}\n+\n+\n+static const char*\n+__objc_skip_type (const char* type)\n+{\n+  switch (*type) {\n+  case _C_ID:\n+  case _C_CLASS:\n+  case _C_SEL:\n+  case _C_CHR:\n+  case _C_UCHR:\n+  case _C_CHARPTR:\n+  case _C_ATOM:\n+  case _C_SHT:\n+  case _C_USHT:\n+  case _C_INT:\n+  case _C_UINT:\n+  case _C_LNG:\n+  case _C_ULNG:\n+  case _C_FLT:\n+  case _C_DBL:\n+    return ++type;\n+    break;\n+\n+  case _C_ARY_B:\n+    while(isdigit(*++type));\n+    type = __objc_skip_type(type);\n+    if (*type == _C_ARY_E)\n+      return ++type;\n+    else\n+      __objc_fatal(\"cannot parse typespec: %s\", type);\n+    break;\n+\n+  default:\n+    fprintf(stderr, \"objc_read_types: cannot parse typespec: %s\\n\", type);\n+    abort();\n+  }\n+}\n+\n+/*\n+** USER LEVEL FUNCTIONS\n+*/\n+\n+/*\n+** Write one object, encoded in TYPE and pointed to by DATA to the\n+** typed stream STREAM.  \n+*/\n+\n+int\n+objc_write_type(TypedStream* stream, const char* type, const void* data)\n+{\n+  switch(*type) {\n+  case _C_ID:\n+    return objc_write_object (stream, *(id*)data);\n+    break;\n+\n+  case _C_CLASS:\n+    return objc_write_class (stream, *(Class**)data);\n+    break;\n+\n+  case _C_SEL:\n+    return objc_write_selector (stream, *(SEL*)data);\n+    break;\n+\n+  case _C_CHR:\n+    return objc_write_char(stream, *(char*)data);\n+    break;\n+    \n+  case _C_UCHR:\n+    return objc_write_unsigned_char(stream, *(unsigned char*)data);\n+    break;\n+\n+  case _C_SHT:\n+    return objc_write_short(stream, *(short*)data);\n+    break;\n+\n+  case _C_USHT:\n+    return objc_write_unsigned_short(stream, *(unsigned short*)data);\n+    break;\n+\n+  case _C_INT:\n+  case _C_LNG:\n+    return objc_write_int(stream, *(int*)data);\n+    break;\n+\n+  case _C_UINT:\n+  case _C_ULNG:\n+    return objc_write_unsigned_int(stream, *(unsigned int*)data);\n+    break;\n+\n+  case _C_CHARPTR:\n+    return objc_write_string (stream, (char*)data, strlen((char*)data));\n+    break;\n+\n+  case _C_ATOM:\n+    return objc_write_string_atomic (stream, (char*)data, strlen((char*)data));\n+    break;\n+\n+  case _C_ARY_B:\n+    {\n+      int len = atoi(type+1);\n+      while (isdigit(*++type));\n+      return objc_write_array (stream, type, len, data);\n+    }\n+    break; \n+\n+  default:\n+    fprintf(stderr, \"objc_write_type: cannot parse typespec: %s\\n\", type);\n+    abort();\n+  }\n+}\n+\n+/*\n+** Read one object, encoded in TYPE and pointed to by DATA to the\n+** typed stream STREAM.  DATA specifies the address of the types to\n+** read.  Expected type is checked against the type actually present\n+** on the stream. \n+*/\n+\n+int\n+objc_read_type(TypedStream* stream, const char* type, void* data)\n+{\n+  char c;\n+  switch(c = *type) {\n+  case _C_ID:\n+    return objc_read_object (stream, (id*)data);\n+    break;\n+\n+  case _C_CLASS:\n+    return objc_read_class (stream, (Class**)data);\n+    break;\n+\n+  case _C_SEL:\n+    return objc_read_selector (stream, (SEL*)data);\n+    break;\n+\n+  case _C_CHR:\n+    return objc_read_char (stream, (char*)data);\n+    break;\n+    \n+  case _C_UCHR:\n+    return objc_read_unsigned_char (stream, (unsigned char*)data);\n+    break;\n+\n+  case _C_SHT:\n+    return objc_read_short (stream, (short*)data);\n+    break;\n+\n+  case _C_USHT:\n+    return objc_read_unsigned_short (stream, (unsigned short*)data);\n+    break;\n+\n+  case _C_INT:\n+  case _C_LNG:\n+    return objc_read_int (stream, (int*)data);\n+    break;\n+\n+  case _C_UINT:\n+  case _C_ULNG:\n+    return objc_read_unsigned_int (stream, (unsigned int*)data);\n+    break;\n+\n+  case _C_CHARPTR:\n+  case _C_ATOM:\n+    return objc_read_string (stream, (char**)data);\n+    break;\n+\n+  case _C_ARY_B:\n+    {\n+      int len = atoi(type+1);\n+      while (isdigit(*++type));\n+      return objc_read_array (stream, type, len, data);\n+    }\n+    break; \n+\n+  default:\n+    fprintf(stderr, \"objc_write_type: cannot parse typespec: %s\\n\", type);\n+    abort();\n+  }\n+}\n+\n+/*\n+** Write the object specified by the template TYPE to STREAM.  Last\n+** arguments specify addresses of values to be written.  It might \n+** seem surprising to specify values by address, but this is extremely\n+** convenient for copy-paste with objc_read_types calls.  A more\n+** down-to-the-earth cause for this passing of addresses is that values\n+** of arbitrary size is not well supported in ANSI C for functions with\n+** variable number of arguments.\n+*/\n+\n+int \n+objc_write_types (TypedStream* stream, const char* type, ...)\n+{\n+  va_list args;\n+  const char *c;\n+  int res = 0;\n+\n+  va_start(args, type);\n+\n+  for (c = type; *c; c = __objc_skip_type (c))\n+    {\n+      switch(*c) {\n+      case _C_ID:\n+\tres = objc_write_object (stream, *va_arg (args, id*));\n+\tbreak;\n+\n+      case _C_CLASS:\n+\tres = objc_write_class (stream, *va_arg(args, Class**));\n+\tbreak;\n+\n+      case _C_SEL:\n+\tres = objc_write_selector (stream, *va_arg(args, SEL*));\n+\tbreak;\n+\t\n+      case _C_CHR:\n+\tres = objc_write_char (stream, *va_arg (args, char*));\n+\tbreak;\n+\t\n+      case _C_UCHR:\n+\tres = objc_write_unsigned_char (stream,\n+\t\t\t\t\t*va_arg (args, unsigned char*));\n+\tbreak;\n+\t\n+      case _C_SHT:\n+\tres = objc_write_short (stream, *va_arg(args, short*));\n+\tbreak;\n+\n+      case _C_USHT:\n+\tres = objc_write_unsigned_short (stream,\n+\t\t\t\t\t *va_arg(args, unsigned short*));\n+\tbreak;\n+\n+      case _C_INT:\n+      case _C_LNG:\n+\tres = objc_write_int(stream, *va_arg(args, int*));\n+\tbreak;\n+\t\n+      case _C_UINT:\n+      case _C_ULNG:\n+\tres = objc_write_unsigned_int(stream, *va_arg(args, unsigned int*));\n+\tbreak;\n+\n+      case _C_CHARPTR:\n+\t{\n+\t  char* str = va_arg(args, char*);\n+\t  res = objc_write_string (stream, str, strlen(str));\n+\t}\n+\tbreak;\n+\n+      case _C_ATOM:\n+\t{\n+\t  char* str = va_arg(args, char*);\n+\t  res = objc_write_string_atomic (stream, str, strlen(str));\n+\t}\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t{\n+\t  int len = atoi(c+1);\n+\t  const char* t = c;\n+\t  while (isdigit(*++t));\n+\t  res = objc_write_array (stream, t, len, va_arg(args, void*));\n+\t  t = __objc_skip_type (t);\n+\t  if (*t != _C_ARY_E)\n+\t    __objc_fatal(\"expected `]', got: %s\", t);\n+\t}\n+\tbreak; \n+\t\n+      default:\n+\tfprintf(stderr, \"objc_write_type: cannot parse typespec: %s\\n\", type);\n+\tabort();\n+      }\n+    }\n+  va_end(args);\n+  return res;\n+}\n+\n+\n+/* \n+** Last arguments specify addresses of values to be read.  Expected\n+** type is checked against the type actually present on the stream. \n+*/\n+\n+int \n+objc_read_types(TypedStream* stream, const char* type, ...)\n+{\n+  va_list args;\n+  const char *c;\n+  int res = 0;\n+\n+  va_start(args, type);\n+\n+  for (c = type; *c; c = __objc_skip_type(c))\n+    {\n+      switch(*c) {\n+      case _C_ID:\n+\tres = objc_read_object(stream, va_arg(args, id*));\n+\tbreak;\n+\n+      case _C_CLASS:\n+\tres = objc_read_class(stream, va_arg(args, Class**));\n+\tbreak;\n+\n+      case _C_SEL:\n+\tres = objc_read_selector(stream, va_arg(args, SEL*));\n+\tbreak;\n+\t\n+      case _C_CHR:\n+\tres = objc_read_char(stream, va_arg(args, char*));\n+\tbreak;\n+\t\n+      case _C_UCHR:\n+\tres = objc_read_unsigned_char(stream, va_arg(args, unsigned char*));\n+\tbreak;\n+\t\n+      case _C_SHT:\n+\tres = objc_read_short(stream, va_arg(args, short*));\n+\tbreak;\n+\n+      case _C_USHT:\n+\tres = objc_read_unsigned_short(stream, va_arg(args, unsigned short*));\n+\tbreak;\n+\n+      case _C_INT:\n+      case _C_LNG:\n+\tres = objc_read_int(stream, va_arg(args, int*));\n+\tbreak;\n+\t\n+      case _C_UINT:\n+      case _C_ULNG:\n+\tres = objc_read_unsigned_int(stream, va_arg(args, unsigned int*));\n+\tbreak;\n+\n+      case _C_CHARPTR:\n+      case _C_ATOM:\n+\t{\n+\t  char** str = va_arg(args, char**);\n+\t  res = objc_read_string (stream, str);\n+\t}\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t{\n+\t  int len = atoi(c+1);\n+\t  const char* t = c;\n+\t  while (isdigit(*++t));\n+\t  res = objc_read_array (stream, t, len, va_arg(args, void*));\n+\t  t = __objc_skip_type (t);\n+\t  if (*t != _C_ARY_E)\n+\t    __objc_fatal(\"expected `]', got: %s\", t);\n+\t}\n+\tbreak; \n+\t\n+      default:\n+\tfprintf(stderr, \"objc_read_type: cannot parse typespec: %s\\n\", type);\n+\tabort();\n+      }\n+    }\n+  va_end(args);\n+  return res;\n+}\n+\n+/*\n+** Write an array of COUNT elements of TYPE from the memory address DATA.\n+** This is equivalent of objc_write_type (stream, \"[N<type>]\", data)\n+*/\n+\n+int\n+objc_write_array (TypedStream* stream, const char* type,\n+\t\t  int count, const void* data)\n+{\n+  int off = objc_sizeof_type(type);\n+  const char* where = data;\n+\n+  while (count-- > 0)\n+    {\n+      objc_write_type(stream, type, where);\n+      where += off;\n+    }\n+  return 1;\n+}\n+\n+/*\n+** Read an array of COUNT elements of TYPE into the memory address\n+** DATA.  The memory pointed to by data is supposed to be allocated\n+** by the callee.  This is equivalent of \n+**   objc_read_type (stream, \"[N<type>]\", data)\n+*/\n+\n+int\n+objc_read_array (TypedStream* stream, const char* type,\n+\t\t int count, void* data)\n+{\n+  int off = objc_sizeof_type(type);\n+  char* where = (char*)data;\n+\n+  while (count-- > 0)\n+    {\n+      objc_read_type(stream, type, where);\n+      where += off;\n+    }\n+  return 1;\n+}\n+\n+static int \n+__objc_fread(FILE* file, char* data, int len)\n+{\n+  return fread(data, len, 1, file);\n+}\n+\n+static int \n+__objc_fwrite(FILE* file, char* data, int len)\n+{\n+  return fwrite(data, len, 1, file);\n+}\n+\n+static int\n+__objc_feof(FILE* file)\n+{\n+  return feof(file);\n+}\n+\n+static int \n+__objc_no_write(FILE* file, char* data, int len)\n+{\n+  __objc_fatal (\"TypedStream not open for writing\");\n+}\n+\n+static int \n+__objc_no_read(FILE* file, char* data, int len)\n+{\n+  __objc_fatal (\"TypedStream not open for reading\");\n+}\n+\n+static int\n+__objc_read_typed_stream_signature (TypedStream* stream)\n+{\n+  char buffer[80];\n+  int pos = 0;\n+  do\n+    (*stream->read)(stream->physical, buffer+pos, 1);\n+  while (buffer[pos++] != '\\0');\n+  sscanf (buffer, \"GNU TypedStream %d\", &stream->version);\n+  if (stream->version != OBJC_TYPED_STREAM_VERSION)\n+    __objc_fatal (\"cannot handle TypedStream version %d\", stream->version);\n+}\n+\n+static int\n+__objc_write_typed_stream_signature (TypedStream* stream)\n+{\n+  char buffer[80];\n+  sprintf(buffer, \"GNU TypedStream %d\", OBJC_TYPED_STREAM_VERSION);\n+  stream->version = OBJC_TYPED_STREAM_VERSION;\n+  (*stream->write)(stream->physical, buffer, strlen(buffer)+1);\n+}\n+\n+/*\n+** Open the stream PHYSICAL in MODE\n+*/\n+\n+TypedStream* \n+objc_open_typed_stream (FILE* physical, int mode)\n+{\n+  int fflush(FILE*);\n+\n+  TypedStream* s = (TypedStream*)malloc(sizeof(TypedStream));\n+\n+  s->mode = mode;\n+  s->physical = physical;\n+  s->stream_table = hash_new(64,\n+\t\t\t     (hash_func_type)hash_ptr,\n+\t\t\t     (compare_func_type)compare_ptrs);\n+  s->eof = (objc_typed_eof_func)__objc_feof;\n+  s->flush = (objc_typed_flush_func)fflush;\n+  if (mode == OBJC_READONLY)\n+    {\n+      s->class_table = hash_new(8, (hash_func_type)hash_string,\n+\t\t\t\t(compare_func_type)compare_strings);\n+      s->read = (objc_typed_read_func)__objc_fread;\n+      s->write = (objc_typed_write_func)__objc_no_write;\n+      __objc_read_typed_stream_signature (s);\n+    }\n+  else if (mode == OBJC_WRITEONLY)\n+    {\n+      s->class_table = 0;\n+      s->read = (objc_typed_read_func)__objc_no_read;\n+      s->write = (objc_typed_write_func)__objc_fwrite;\n+      __objc_write_typed_stream_signature (s);\n+    }      \n+  else\n+    {\n+      objc_close_typed_stream (s);\n+      return NULL;\n+    }\n+  s->type = OBJC_FILE_STREAM;\n+  return s;\n+}\n+\n+/*\n+** Open the file named by FILE_NAME in MODE\n+*/\n+\n+TypedStream*\n+objc_open_typed_stream_for_file (const char* file_name, int mode)\n+{\n+  FILE* file = NULL;\n+  TypedStream* s;\n+\n+  if (mode == OBJC_READONLY)\n+    file = fopen (file_name, \"r\");\n+  else\n+    file = fopen (file_name, \"w\");\n+\n+  if (file)\n+    {\n+      s = objc_open_typed_stream (file, mode);\n+      if (s)\n+\ts->type |= OBJC_MANAGED_STREAM;\n+      return s;\n+    }\n+  else\n+    return NULL;\n+}\n+\n+/*\n+** Close STREAM freeing the structure it self.  If it was opened with \n+** objc_open_typed_stream_for_file, the file will also be closed.\n+*/\n+\n+void\n+objc_close_typed_stream (TypedStream* stream)\n+{\n+  if (stream->type == (OBJC_MANAGED_STREAM | OBJC_FILE_STREAM))\n+    fclose ((FILE*)stream->physical);\n+  hash_delete (stream->stream_table);\n+  if (stream->mode == OBJC_READONLY)\n+    hash_delete (stream->class_table);\n+  free (stream);\n+}\n+\n+BOOL\n+objc_end_of_typed_stream (TypedStream* stream)\n+{\n+  return (*stream->eof)(stream->physical);\n+}\n+\n+void\n+objc_flush_typed_stream (TypedStream* stream)\n+{\n+  (*stream->flush)(stream->physical);\n+}\n+"}, {"sha": "a5feef57b97731643069917c57b914fb8001b250", "filename": "gcc/objc/class.c", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fclass.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,378 @@\n+/* GNU Objective C Runtime class related functions\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup, Dennis Glatting\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\t\t/* the kitchen sink */\n+\n+\n+/* The table of classname->class.  Used for objc_lookup_class and friends */\n+static cache_ptr __objc_class_hash = 0;\n+\n+/* This is a hook which is called by objc_get_class and \n+   objc_lookup_class if the runtime is not able to find the class.\n+   This may e.g. try to load in the class using dynamic loading */\n+Class_t (*_objc_lookup_class)(const char* name) = 0;\n+\n+\n+/* True when class links has been resolved */     \n+BOOL __objc_class_links_resolved = NO;\n+\n+\n+/* Initial number of buckets size of class hash table. */\n+#define CLASS_HASH_SIZE 32\n+\n+void __objc_init_class_tables()\n+{\n+  /* Allocate the class hash table */\n+\n+  if(__objc_class_hash)\n+    return;\n+\n+  __objc_class_hash\n+    =  hash_new (CLASS_HASH_SIZE,\n+\t\t (hash_func_type) hash_string,\n+\t\t (compare_func_type) compare_strings);\n+}  \n+\n+/* This function adds a class to the class hash table, and assigns the \n+   class a number, unless it's already known */\n+void\n+__objc_add_class_to_hash(Class_t class)\n+{\n+  Class_t h_class;\n+\n+  /* make sure the table is there */\n+  assert(__objc_class_hash);\n+\n+  /* make sure it's not a meta class */  \n+  assert(CLS_ISCLASS(class));\n+\n+  /* Check to see if the class is already in the hash table.  */\n+  h_class = hash_value_for_key (__objc_class_hash, class->name);\n+  if (!h_class)\n+    {\n+      /* The class isn't in the hash table.  Add the class and assign a class\n+         number.  */\n+      static unsigned int class_number = 1;\n+\n+      CLS_SETNUMBER(class, class_number);\n+      CLS_SETNUMBER(class->class_pointer, class_number);\n+\n+      ++class_number;\n+      hash_add (&__objc_class_hash, class->name, class);\n+    }\n+}\n+\n+/* Get the class object for the class named NAME.  If NAME does not\n+   identify a known class, the hook _objc_lookup_class is called.  If\n+   this fails, nil is returned */\n+Class_t objc_lookup_class (const char* name)\n+{\n+  Class_t class;\n+\n+  /* Make sure the class hash table exists.  */\n+  assert (__objc_class_hash);\n+\n+  class = hash_value_for_key (__objc_class_hash, name);\n+\n+  if (class)\n+    return class;\n+\n+  if (_objc_lookup_class)\n+    return (*_objc_lookup_class)(name);\n+  else\n+    return 0;\n+}\n+\n+/* Get the class object for the class named NAME.  If NAME does not\n+   identify a known class, the hook _objc_lookup_class is called.  If\n+   this fails,  an error message is issued and the system aborts */\n+Class_t\n+objc_get_class (const char *name)\n+{\n+  Class_t class;\n+\n+  /* Make sure the class hash table exists.  */\n+  assert (__objc_class_hash);\n+\n+  class = hash_value_for_key (__objc_class_hash, name);\n+\n+  if (class)\n+    return class;\n+\n+  if (_objc_lookup_class)\n+    class = (*_objc_lookup_class)(name);\n+\n+  if(class)\n+    return class;\n+  \n+  fprintf(stderr, \"objc runtime: cannot find class %s\\n\", name);\n+  abort();\n+}\n+\n+\n+/* Resolve super/subclass links for all classes.  The only thing we \n+   can be sure of is that the class_pointer for class objects point \n+   to the right meta class objects */\n+void __objc_resolve_class_links()\n+{\n+  node_ptr node;\n+  Class_t class1;\n+  Class_t object_class = objc_get_class (\"Object\");\n+\n+  assert(object_class);\n+\n+  /* Assign subclass links */\n+  for (node = hash_next (__objc_class_hash, NULL); node;\n+       node = hash_next (__objc_class_hash, node))\n+    {\n+      Class_t class1 = node->value;\n+\n+      /* Make sure we have what we think we have.  */\n+      assert (CLS_ISCLASS(class1));\n+      assert (CLS_ISMETA(class1->class_pointer));\n+\n+      /* The class_pointer of all meta classes point to Object's meta class. */\n+      class1->class_pointer->class_pointer = object_class->class_pointer;\n+\n+      if (!(CLS_ISRESOLV(class1)))\n+        {\n+          CLS_SETRESOLV(class1);\n+          CLS_SETRESOLV(class1->class_pointer);\n+              \n+          if(class1->super_class)\n+            {   \n+              Class_t a_super_class \n+                = objc_get_class ((char *) class1->super_class);\n+              \n+              assert (a_super_class);\n+              \n+              DEBUG_PRINTF (\"making class connections for: %s\\n\",\n+                            class1->name);\n+              \n+              /* assign subclass links for superclass */\n+              class1->sibling_class = a_super_class->subclass_list;\n+              a_super_class->subclass_list = class1;\n+              \n+              /* Assign subclass links for meta class of superclass */\n+              if (a_super_class->class_pointer)\n+                {\n+                  class1->class_pointer->sibling_class\n+                    = a_super_class->class_pointer->subclass_list;\n+                  a_super_class->class_pointer->subclass_list \n+                    = class1->class_pointer;\n+                }\n+            }\n+          else                  /* a root class, make its meta object */\n+                                /* be a subclass of Object */\n+            {\n+              class1->class_pointer->sibling_class \n+                = object_class->subclass_list;\n+              object_class->subclass_list = class1->class_pointer;\n+            }\n+        }\n+    }\n+\n+  /* Assign superclass links */\n+  for (node = hash_next (__objc_class_hash, NULL); node;\n+       node = hash_next (__objc_class_hash, node))\n+    {\n+      Class_t class1 = node->value;\n+      Class_t sub_class;\n+      for (sub_class = class1->subclass_list; sub_class;\n+           sub_class = sub_class->sibling_class)\n+        {\n+          sub_class->super_class = class1;\n+          if(CLS_ISCLASS(sub_class))\n+            sub_class->class_pointer->super_class = class1->class_pointer;\n+        }\n+    }\n+}\n+\n+\n+/* This is a incomplete implementation of posing.   This function does the\n+   bulk of the work but does not initialize the class method caches.  That is\n+   a run-time specific operation.\n+\n+I implement posing by hiding SUPER_CLASS, creating new class and meta class\n+   structures, initializing it with IMPOSTOR, and changing it such that it is\n+   identified as SUPER_CLASS. SUPER_CLASS remains in the hierarchy but is\n+   inaccessible by the means. The class hierarchy is then re arranged such\n+   that all of the subclasses of SUPER_CLASS now inherit from the new class\n+   structures -- except the impostor itself. The only dramatic effect on the\n+   application is that subclasses of SUPER_CLASS cannot do a [ ....\n+   super_class ] and expect their real super class. */\n+Class_t\n+class_pose_as (Class_t impostor, Class_t super_class)\n+{\n+  Class_t new_class = (Class_t) calloc (1, sizeof (Class));\n+  MetaClass_t new_meta_class =\n+    (MetaClass_t) __objc_xmalloc(sizeof (MetaClass));\n+  node_ptr node;\n+  char *new_name = (char *)__objc_xmalloc (strlen (super_class->name) + 12);\n+\n+  /* We must know the state of the hierachy.  Do initial setup if needed */\n+  if(!CLS_ISRESOLV(impostor))\n+    __objc_resolve_class_links();\n+\n+  assert (new_class);\n+  assert (new_meta_class);\n+  assert (new_name);\n+\n+  assert (CLS_ISCLASS(impostor));\n+  assert (CLS_ISCLASS(super_class));\n+\n+  assert (impostor->instance_size == super_class->instance_size);\n+\n+  /* Create the impostor class.  */\n+  new_class->class_pointer = new_meta_class;\n+  new_class->super_class = super_class;\n+  new_class->name = super_class->name;\n+  new_class->version = super_class->version;\n+  new_class->info = super_class->info;\n+  new_class->instance_size = super_class->instance_size;\n+  new_class->ivars = super_class->ivars;\n+  new_class->methods = impostor->methods;\n+#ifdef OBJC_SPARSE_LOOKUP\n+  new_class->dtable = impostor->dtable;\n+#else\n+  new_class->cache = impostor->cache;\n+#endif\n+\n+  /* Create the impostor meta class.  */\n+  new_meta_class->class_pointer = super_class->class_pointer->class_pointer;\n+  new_meta_class->super_class = super_class->class_pointer->super_class;\n+  new_meta_class->name = super_class->class_pointer->name;\n+  new_meta_class->version = super_class->class_pointer->version;\n+  new_meta_class->info = super_class->class_pointer->info;\n+  new_meta_class->instance_size = super_class->class_pointer->instance_size;\n+  new_meta_class->ivars = super_class->class_pointer->ivars;\n+  new_meta_class->methods = impostor->class_pointer->methods;\n+#ifdef OBJC_SPARSE_LOOKUP\n+  new_meta_class->dtable = impostor->class_pointer->dtable;\n+#else\n+  new_meta_class->cache = impostor->class_pointer->cache;\n+#endif\n+\n+  /* Now change super/subclass links of all related classes.  This is rather\n+     complex, since we have both super_class link, and subclass_list for the\n+     involved classes. */\n+  {\n+    Class_t *classpp;\n+    MetaClass_t *metaclasspp;\n+\n+    /* Remove impostor from subclass list of super_class */\n+    for (classpp = &(super_class->subclass_list);\n+         *classpp;\n+         classpp = &((*classpp)->sibling_class))\n+      {\n+        if (*classpp == impostor)\n+          *classpp = (*classpp)->sibling_class;\n+        if (*classpp == 0)\n+          break;\n+      }\n+\n+    /* Do the same for the meta classes */\n+\n+    for (metaclasspp = &(super_class->class_pointer->subclass_list);\n+         *metaclasspp;\n+         metaclasspp = &((*metaclasspp)->sibling_class))\n+      {\n+        if (*metaclasspp == impostor->class_pointer)\n+          *metaclasspp = (*metaclasspp)->sibling_class;\n+        if (*metaclasspp == 0)\n+          break;\n+      }\n+\n+    /* From the loop above, classpp now points to the sibling_class entry */\n+    /* of the last element in the list of subclasses for super_class */\n+\n+    /* Append the subclass list of impostor to the subclass list of */\n+    /* superclass, and excange those two and set subclass of */\n+    /* super_class to be impostor only */\n+\n+    *classpp = impostor->subclass_list;\n+    new_class->subclass_list = super_class->subclass_list;\n+    super_class->subclass_list = new_class;\n+    new_class->sibling_class = 0;\n+\n+    /* Do the same thing for the meta classes */\n+    *metaclasspp = impostor->class_pointer->subclass_list;\n+    new_meta_class->subclass_list = super_class->class_pointer->subclass_list;\n+    super_class->class_pointer->subclass_list = new_meta_class;\n+    new_meta_class->sibling_class = 0;\n+\n+    /* Update superclass links for all subclasses of new_class */\n+    for (classpp = &(new_class->subclass_list); *classpp;\n+         classpp = &((*classpp)->sibling_class))\n+      (*classpp)->super_class = new_class;\n+\n+    for (metaclasspp = &(new_meta_class->subclass_list); *metaclasspp;\n+         metaclasspp = &((*metaclasspp)->sibling_class))\n+      (*metaclasspp)->super_class = new_meta_class;\n+\n+  }\n+\n+  /* Delete the class from the hash table, change its name so that it can no\n+     longer be found, then place it back into the hash table using its new\n+     name.\n+  \n+  Don't worry about the class number.  It is already assigned.\n+     memory is lost with the hash key.) */\n+  hash_remove (__objc_class_hash, super_class->name);\n+  sprintf (new_name, \"%s*\", super_class->name);\n+  super_class->name = new_name;\n+  super_class->class_pointer->name = new_name;\n+  hash_add (&__objc_class_hash, super_class->name, super_class);\n+\n+  /* Place the impostor class in class hash table and assign it a class\n+     number.  */\n+  __objc_add_class_to_hash (new_class);\n+\n+  /* Now update dispatch tables for new_class and it's subclasses */\n+  __objc_update_dispatch_table_for_class ((Class_t) new_meta_class);\n+  __objc_update_dispatch_table_for_class (new_class);\n+\n+  return new_class;\n+}\n+\n+#ifdef OBJC_HASH_LOOKUP\n+__objc_class_hash_tables_size ()\n+{\n+  node_ptr node;\n+  Class_t class1;\n+  int total = 0;\n+\n+  for (node = hash_next (__objc_class_hash, NULL); node;\n+       node = hash_next (__objc_class_hash, node))\n+    {\n+      Class_t class1 = node->value;\n+      total += (class1->cache->mask)*sizeof(struct objc_bucket);\n+      total += sizeof(struct objc_cache);\n+    }\n+\n+  return total;\n+}\n+#endif"}, {"sha": "eb31f246d68fa03001d6ee17026721c6b95e01c5", "filename": "gcc/objc/init.c", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Finit.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,272 @@\n+/* GNU Objective C Runtime initialization \n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\n+\n+/* The version number of this runtime.  This must match the number \n+   defined in gcc (objc-act.c) */\n+#define OBJC_VERSION 5\n+#define PROTOCOL_VERSION 2\n+\n+/* This list contains all modules currently loaded into the runtime */\n+static struct objc_list* __objc_module_list = 0;\n+\n+/* This list contains all proto_list's not yet assigned class links */\n+static struct objc_list* unclaimed_proto_list = 0;\n+\n+/* Check compiler vs runtime version */\n+static void init_check_module_version(Module_t);\n+\n+/* Assign isa links to protos */\n+static void __objc_init_protocols (struct objc_protocol_list* protos);\n+\n+/* Add protocol to class */\n+static void __objc_class_add_protocols (Class_t, struct objc_protocol_list*);\n+\n+/* Is all categories/classes resolved? */\n+BOOL __objc_dangling_categories = NO;\n+\n+/* This function is called by constructor functions generated for each\n+   module compiled.  (_GLOBAL_$I$...) The purpose of this function is to\n+   gather the module pointers so that they may be processed by the\n+   initialization routines as soon as possible */\n+\n+void\n+__objc_exec_class (Module_t module)\n+{\n+  /* Has we processed any constructors previously?  This flag used to \n+     indicate that some global data structures need to be built.  */ \n+  static BOOL previous_constructors = 0;\n+\n+  static struct objc_list* unclaimed_categories = 0;\n+\n+  /* The symbol table (defined in objc.h) generated by gcc */\n+  Symtab_t symtab = module->symtab;\n+\n+  /* Pointer to the class Object class object */\n+  Class_t object_class;\n+\n+  /* Entry used to traverse hash lists */\n+  struct objc_list** cell;\n+\n+  /* The table of selector references for this module */\n+  SEL *selectors = symtab->refs; \n+\n+  /* dummy counter */\n+  int i;\n+\n+  DEBUG_PRINTF (\"received module: %s\\n\", module->name);\n+  /* check gcc version */\n+  init_check_module_version(module);\n+\n+  /* On the first call of this routine, initialize some data structures.  */\n+  if (!previous_constructors)\n+    {\n+      __objc_init_selector_tables();\n+      __objc_init_class_tables();\n+      __objc_init_dispatch_tables();\n+      previous_constructors = 1;\n+    }\n+\n+  /* Save the module pointer for later processing. (not currently used) */\n+  __objc_module_list = list_cons(module, __objc_module_list);\n+\n+  /* Parse the classes in the load module and gather selector information.  */\n+  DEBUG_PRINTF (\"gathering selectors from module: %s\\n\", module->name);\n+  for (i = 0; i < symtab->cls_def_cnt; ++i)\n+    {\n+      Class_t class = (Class_t) symtab->defs[i];\n+\n+      /* Make sure we have what we think.  */\n+      assert (CLS_ISCLASS(class));\n+      assert (CLS_ISMETA(class->class_pointer));\n+      DEBUG_PRINTF (\"phase 1, processing class: %s\\n\", class->name);\n+\n+      /* Store the class in the class table and assign class numbers.  */\n+      __objc_add_class_to_hash (class);\n+\n+      /* Register all of the selectors in the class and meta class.  */\n+      __objc_register_selectors_from_class (class);\n+      __objc_register_selectors_from_class ((Class_t) class->class_pointer);\n+\n+      /* Install the fake dispatch tables */\n+      __objc_install_premature_dtable(class);\n+      __objc_install_premature_dtable(class->class_pointer);\n+\n+      if (class->protocols)\n+\t__objc_init_protocols (class->protocols);\n+   }\n+\n+  /* Replace referenced selectors from names to SEL's.  */\n+  for (i = 0; selectors[i]; ++i)\n+    selectors[i] = sel_register_name ((const char *) selectors[i]);\n+\n+  /* Process category information from the module.  */\n+  for (i = 0; i < symtab->cat_def_cnt; ++i)\n+    {\n+      Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n+      Class_t class = objc_lookup_class (category->class_name);\n+      \n+      /* If the class for the category exists then append its methods.  */\n+      if (class)\n+\t{\n+\n+\t  DEBUG_PRINTF (\"processing categories from (module,object): %s, %s\\n\",\n+\t\t\tmodule->name,\n+\t\t\tclass->name);\n+\n+\t  /* Do instance methods.  */\n+\t  if (category->instance_methods)\n+\t    class_add_method_list (class, category->instance_methods);\n+\n+\t  /* Do class methods.  */\n+\t  if (category->class_methods)\n+\t    class_add_method_list ((Class_t) class->class_pointer, \n+\t\t\t\t   category->class_methods);\n+\n+\t  if (category->protocols)\n+\t    {\n+\t      __objc_init_protocols (category->protocols);\n+\t      __objc_class_add_protocols (class, category->protocols);\n+\t    }\n+\n+\t}\n+      else\n+\t{\n+\t  /* The object to which the category methods belong can't be found.\n+\t     Save the information.  */\n+\t  unclaimed_categories = list_cons(category, unclaimed_categories);\n+\t}\n+    }\n+\n+  /* Scan the unclaimed category hash.  Attempt to attach any unclaimed\n+     categories to objects.  */\n+  for (cell = &unclaimed_categories;\n+       *cell;\n+       *cell && (cell = &(*cell)->tail))\n+    {\n+      Category_t category = (*cell)->head;\n+      Class_t class = objc_lookup_class (category->class_name);\n+      \n+      if (class)\n+\t{\n+\t  DEBUG_PRINTF (\"attaching stored categories to object: %s\\n\",\n+\t\t\tclass->name);\n+\t  \n+\t  list_remove_head (cell);\n+\t  \n+\t  if (category->instance_methods)\n+\t    class_add_method_list (class, category->instance_methods);\n+\t  \n+\t  if (category->class_methods)\n+\t    class_add_method_list ((Class_t) class->class_pointer,\n+\t\t\t\t   category->class_methods);\n+\t  \n+\t  if (category->protocols)\n+\t    {\n+\t      __objc_init_protocols (category->protocols);\n+\t      __objc_class_add_protocols (class, category->protocols);\n+\t    }\n+\t  \n+\t}\n+    }\n+  \n+  if (unclaimed_proto_list && objc_lookup_class (\"Protocol\"))\n+    {\n+      list_mapcar (unclaimed_proto_list,(void(*)(void*))__objc_init_protocols);\n+      list_free (unclaimed_proto_list);\n+      unclaimed_proto_list = 0;\n+    }\n+\n+}\n+\n+/* Sanity check the version of gcc used to compile `module'*/\n+static void init_check_module_version(Module_t module)\n+{\n+  if ((module->version != OBJC_VERSION) || (module->size != sizeof (Module)))\n+    {\n+      fprintf (stderr, \"Module %s version %d doesn't match runtime %d\\n\",\n+\t       module->name, module->version, OBJC_VERSION);\n+      if(module->version > OBJC_VERSION)\n+\tfprintf (stderr, \"Runtime (libobjc.a) is out of date\\n\");\n+      else if (module->version < OBJC_VERSION)\n+\tfprintf (stderr, \"Compiler (gcc) is out of date\\n\");\n+      else\n+\tfprintf (stderr, \"Objective C internal error -- bad Module size\\n\");\n+      abort ();\n+    }\n+}\n+\n+static void\n+__objc_init_protocols (struct objc_protocol_list* protos)\n+{\n+  int i;\n+  Class_t proto_class;\n+\n+  if (! protos)\n+    return;\n+\n+  proto_class = objc_lookup_class(\"Protocol\");\n+\n+  if (proto_class == 0 && ! list_find (&unclaimed_proto_list, protos))\n+    {\n+      unclaimed_proto_list = list_cons (protos, unclaimed_proto_list);\n+      return;\n+    }\n+\n+  assert (protos->next == 0);\t/* only single ones allowed */\n+\n+  for(i = 0; i < protos->count; i++)\n+    {\n+      if (((int)((id)protos->list[i])->class_pointer) == PROTOCOL_VERSION)\n+\t((id)protos->list[i])->class_pointer = proto_class;\n+      else\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"Version %d doesn't protocol version %d\\n\",\n+\t\t   ((int)((id)protos->list[i])->class_pointer),\n+\t\t   PROTOCOL_VERSION);\n+\t  abort ();\n+\t}\n+    }\n+}\n+\n+static void __objc_class_add_protocols (Class_t class,\n+\t\t\t\t\tstruct objc_protocol_list* protos)\n+{\n+#ifndef NeXT_OBJC\t\t/* force class Protocol to be linked in */\n+  extern char* __objc_class_name_Protocol;\n+  char* x = __objc_class_name_Protocol;\n+#endif\n+\n+  /* Well... */\n+  if (! protos)\n+    return;\n+\n+  /* Add it... */\n+  protos->next = class->protocols;\n+  class->protocols = protos;\n+}"}, {"sha": "53adc82fa99303184316a934cc88419d9cbe8067", "filename": "gcc/objc/misc.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fmisc.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,78 @@\n+/* GNU Objective C Runtime Miscellanious \n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\n+\n+void* malloc(size_t);\n+void* realloc(void*, size_t);\n+\n+void objc_error(id object, const char* fmt, va_list);\n+\n+void (*_objc_error)(id, const char*, va_list) = objc_error;\n+/* id (*_objc_object_alloc)(Class_t) = 0; */\n+/* id (*_objc_object_dispose)(id)    = 0; */\n+/* id (*_objc_object_copy)(id)       = 0; */\n+\n+void\n+objc_error(id object, const char* fmt, va_list ap)\n+{\n+  vfprintf (stderr, fmt, ap);\n+  abort ();\n+}\n+\n+volatile void\n+objc_fatal(const char* msg)\n+{\n+  write(2, msg, strlen(msg));\n+  abort();\n+}\n+\n+void*\n+__objc_xmalloc(size_t size)\n+{\n+  void* res = malloc(size);\n+  if(!res)\n+    objc_fatal(\"Virtual memory exhausted\\n\");\n+  return res;\n+}\n+\n+void*\n+__objc_xrealloc(void* mem, size_t size)\n+{\n+  void* res = realloc(mem, size);\n+  if(!res)\n+    objc_fatal(\"Virtual memory exhausted\\n\");\n+  return res;\n+}\n+\n+void*\n+__objc_xcalloc(size_t nelem, size_t size)\n+{\n+  void* res = (void*)calloc(nelem, size);\n+  if(!res)\n+    objc_fatal(\"Virtual memory exhausted\\n\");\n+  return res;\n+}"}, {"sha": "ff2b3f22679535a5250ddbc9c8b6386d218abc1f", "filename": "gcc/objc/objc-api.h", "status": "added", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-api.h?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,440 @@\n+/* GNU Objective-C Runtime API.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#ifndef __objc_api_INCLUDE_GNU\n+#define __objc_api_INCLUDE_GNU\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+\n+static const ARGSIZE = 96;\t\t/* for `method_get_argsize()' */\n+\n+/*\n+** Points to the function that the runtime system calls to handle\n+** an error.  By default, it prints formatted error messages to the\n+** standard error stream and calls abort to produce a core file.\n+** The function is guaranteed to be passed a valid object and a\n+** non-NULL format string.\n+*/\n+extern void (*_objc_error)(id object, const char *format, va_list args);\n+\n+/*\n+** This is a hook which is called by objc_lookup_class and\n+** objc_get_class if the runtime is not able to find the class.\n+** This may e.g. try to load in the class using dynamic loading.\n+** The function is guaranteed to be passed a non-NULL name string.\n+*/\n+extern Class_t (*_objc_lookup_class)(const char *name);\n+\n+/*\n+** Points to the function that the runtime system calls to allocate\n+** memory for new instances.  Called through class_create_instance(),\n+** this function should return a valid block of memory of at least\n+** class_get_instance_size() bytes, or nil upon failure.  The\n+** function is guaranteed to be passed a valid class object.\n+*/\n+extern id (*_objc_object_alloc)(Class_t class);\n+\n+/*\n+** Points to the function that the runtime system calls to create\n+** an exact copy of an object.  Called through object_copy(), this\n+** function should return a new instance of object's class created\n+** by class_create_instance() which is bit-identical to object, or\n+** nil upon failure.  The function is guaranteed to be passed a\n+** valid instance object.\n+*/\n+extern id (*_objc_object_copy)(id object);\n+\n+/*\n+** Points to the function that the runtime system calls to free\n+** instances.  Called through object_dispose(), this function\n+** should free the memory pointed to by object and return nil.\n+** This function is not responsible for freeing memory pointed\n+** to by any of the object's instance variables.  The function\n+** is guaranteed to be passed a valid instance object.\n+*/\n+extern id (*_objc_object_dispose)(id object);\n+\n+/*\n+** Searches for a class method specified by aSel, starting with the\n+** metaclass class and proceeding up the class hierarchy, until either\n+** the method is found or the root class has been examined.  Returns\n+** a pointer to the method's Method structure if found.  Returns the\n+** value METHOD_NULL if the method is not found, class is not a\n+** metaclass object, or aSel is not a valid selector.\n+*/\n+Method_t class_get_class_method(MetaClass_t class, SEL aSel);\n+\n+/*\n+** Searches for an instance method specified by aSel, starting with\n+** the class class and proceeding up the class hierarchy, until either\n+** the method is found or the root class has been examined.  Returns\n+** a pointer to the method's Method structure if found.  Returns the\n+** value METHOD_NULL if the method is not found, class is not a class\n+** object, or aSel is not a valid selector.\n+*/\n+Method_t class_get_instance_method(Class_t class, SEL aSel);\n+\n+/*\n+** Causes impostor to pose as its superclass.  Messages sent to the\n+** superclass will actually be sent to the posing class.  Instance\n+** variables may not be declared in the posing class.  The posing\n+** class can add new methods to the class or override existing methods\n+** in the superclass.  Returns non-nil on success.  Returns nil if\n+** either of impostor or superclass are not class objects, impostor is\n+** not a subclass of superclass, or upon some other error.\n+*/\n+Class_t class_pose_as(Class_t impostor, Class_t superclass);\n+\n+/*\n+** Returns the class object for the class named name.  If name does not\n+** identify a known class, the hook _objc_lookup_class is called.  If\n+** this fails, an error message is issued and the system aborts.\n+*/\n+Class_t objc_get_class(const char *name);\n+\n+/*\n+** Returns the class object for the class named name.  If name does not\n+** identify a known class, the hook _objc_lookup_class is called.  If\n+** this fails, nil is returned.\n+*/\n+Class_t objc_lookup_class(const char *name);\n+\n+/*\n+** Returns the method name associated with selector, or NULL\n+** if selector is not defined.\n+*/\n+const char *sel_get_name(SEL selector);\n+\n+/*\n+** Returns the selector associated with the method name name.  If name\n+** has not been defined or name is NULL, 0 is returned.\n+*/\n+SEL sel_get_uid(const char *name);\n+\n+/*\n+** Registers a selector for name and returns the new selector.  If\n+** name is NULL or the empty string (\"\"), 0 is returned.\n+*/\n+SEL sel_register_name(const char *name);\n+\n+/*\n+** Indicate if aSel is a valid selector.  This is not a safe\n+** operation, and it should really never be nessecary to use.\n+*/\n+BOOL sel_is_mapped (SEL aSel);\n+\n+/*******************************************************************/\n+/*                                                                 */\n+/* Internal __inline functions                                     */\n+/*                                                                 */\n+/*******************************************************************/\n+\n+/*\n+** Allocates memory for a new object of class class by calling the\n+** function specified by the variable _objc_object_alloc if non-zero,\n+** otherwise uses a default method.  Then, initializes the object's\n+** isa instance variable to class, and returns the new object.\n+** Returns nil if the memory could not be allocated or class is not\n+** a class object.\n+*/\n+extern inline id\n+class_create_instance(Class_t class)\n+{\n+  id new = nil;\n+  if (CLS_ISCLASS(class))\n+    new = (_objc_object_alloc\n+           ?(*_objc_object_alloc)(class)\n+           :(id)malloc(class->instance_size));\n+  if (new!=nil)\n+    new->class_pointer = class;\n+  return new;\n+}\n+\n+/*\n+** Returns name of the class class or empty string if class is not\n+** a class object.  If class is Nil, the string \"Nil\" is returned.\n+*/\n+static inline const char *\n+class_get_class_name(Class_t class)\n+{\n+  return CLS_ISCLASS(class)?class->name:((class==Nil)?\"Nil\":0);\n+}\n+\n+/*\n+** Returns the size of an instance of class class in bytes, or 0 if\n+** class is not a class.  The size of an instance is at least 4 bytes.\n+*/\n+static inline long\n+class_get_instance_size(Class_t class)\n+{\n+  return CLS_ISCLASS(class)?class->instance_size:0;\n+}\n+\n+/*\n+** Returns a pointer to class's metaclass, or Nil if class is not a\n+** class.\n+*/\n+static inline MetaClass_t\n+class_get_meta_class(Class_t class)\n+{\n+  return CLS_ISCLASS(class)?class->class_pointer:Nil;\n+}\n+\n+/*\n+** Returns a pointer to class's superclass, or Nil if class is not a\n+** class.  Note that the superclass of Object is Nil.\n+*/\n+static inline Class_t\n+class_get_super_class(Class_t class)\n+{\n+  return CLS_ISCLASS(class)?class->super_class:Nil;\n+}\n+\n+/*\n+** Returns the version number for the class, or -1 if class is not a\n+** class.\n+*/\n+static inline int\n+class_get_version(Class_t class)\n+{\n+  return CLS_ISCLASS(class)?class->version:-1;\n+}\n+\n+/*\n+** Returns YES if class is a class, or NO if not.\n+*/\n+static inline BOOL\n+class_is_class(Class_t class)\n+{\n+  return CLS_ISCLASS(class);\n+}\n+\n+/*\n+** Returns YES if class is a metaclass, or NO if not.\n+*/\n+static inline BOOL\n+class_is_meta_class(Class_t class)\n+{\n+  return CLS_ISMETA(class);\n+}\n+\n+\n+/*\n+** Sets the version number of class class.  Does nothing if class is\n+** not a class.\n+*/\n+static inline void\n+class_set_version(Class_t class, long version)\n+{\n+  if (CLS_ISCLASS(class))\n+    class->version = version;\n+}\n+\n+/*\n+** Returns the size in bytes of the argument frame to a method.  Since\n+** at least two parameters (self and _cmd) are sent to each method, this\n+** value will be at least 8.  If method is not a valid method, 0 is\n+** returned.\n+** \n+** Currently, the frame size info is only reliable on a NeXT, so until\n+** we get this fixed, we'll use a value which is most possibly large\n+** enough. You can possibly reduce this value (96) on anything but a\n+** Sparc if you don't return structs from the methods forwarded to.\n+*/\n+static inline unsigned int\n+method_get_argsize(Method_t method)\n+{\n+  return ARGSIZE;\t\t/* This was a magic number (96)... */\n+}\n+\n+/*\n+** Returns a pointer to the implementation of method method.  If method\n+** is not a method, NULL is returned.\n+*/\n+static inline IMP\n+method_get_imp(Method_t method)\n+{\n+  return (method!=METHOD_NULL)?method->method_imp:(IMP)0;\n+}\n+\n+/*\n+** Returns the implementation (pointer to function) of the method\n+** identified by a (class, selector) pair.  Use this, and *not* \n+** objc_msg_lookup, since objc_msg_lookup may eventually return a\n+** pointer to an internal function which does lazy initialization...\n+*/\n+IMP get_imp (Class_t class, SEL sel);\n+\n+/*\n+** Creates a new instance object that's an exact copy of object by\n+** calling the function pointed to by the variable _objc_object_copy if\n+** non-zero, otherwise uses a default method.  Returns the new object.\n+** Returns nil if object is not an instance object, memory for the new\n+** object could not be allocated, or some other error occurred.\n+*/\n+extern inline id\n+object_copy(id object)\n+{\n+  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n+    {\n+      if (_objc_object_copy)\n+        return (*_objc_object_copy)(object);\n+      else\n+        {\n+          id copy = class_create_instance(object->class_pointer);\n+          if (copy!=nil)\n+            bcopy(object, copy, object->class_pointer->instance_size);\n+          return copy;\n+        }\n+      return nil;\n+    }\n+}\n+\n+/*\n+** Frees the memory occupied by object by calling the function pointed\n+** to by the variable _objc_object_dispose if non-zero, otherwise uses\n+** a default method.  Always returns nil.  If object is not an instance\n+** object, does nothing.\n+*/\n+extern inline id\n+object_dispose(id object)\n+{\n+  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n+    {\n+      if (_objc_object_dispose)\n+        (*_objc_object_dispose)(object);\n+      else\n+        free(object);\n+    }\n+  return nil;\n+}\n+\n+/*\n+** Returns the class of an object.  If object is an instance, this is\n+** its class object.  If object is a class object, returns object (this\n+** is arguably not correct, but is implemented this way for compatibility\n+** with NeXT (and Stepstone?)).  If object is a metaclass object, or\n+** object is nil, returns Nil.\n+*/\n+static inline Class_t\n+object_get_class(id object)\n+{\n+  return ((object!=nil)\n+\t  ? (CLS_ISCLASS(object->class_pointer)\n+\t     ? object->class_pointer\n+\t     : (CLS_ISMETA(object->class_pointer)\n+\t\t? (Class_t)object\n+\t\t: Nil))\n+\t  : Nil);\n+}\n+\n+/*\n+** Returns the name of the class of object.  If object is an instace,\n+** this is the name of its class.  If object is a class or a metaclass,\n+** returns its name.  If object is nil, returns \"Nil\".\n+*/\n+static inline const char *\n+object_get_class_name(id object)\n+{\n+  return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n+                         ?object->class_pointer->name\n+                         :((Class_t)object)->name)\n+                       :\"Nil\");\n+}\n+\n+/*\n+** Returns the metaclass of an object.  If object is an instance or a\n+** class, this is the metaclass object for it.  If object is a metaclass\n+** object, or object is nil, returns Nil.\n+*/\n+static inline MetaClass_t\n+object_get_meta_class(id object)\n+{\n+  return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n+                         ?object->class_pointer->class_pointer\n+                         :(CLS_ISMETA(object->class_pointer)\n+                           ?object->class_pointer\n+                           :Nil))\n+                       :Nil);\n+}\n+\n+/*\n+** Returns the superclass of object.  If object is an instance or\n+** a class, this is its superclass-object for it.  If object is a\n+** metaclass-object or nil, this is Nil.\n+*/\n+static inline Class_t\n+object_get_super_class(id object)\n+{\n+  return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n+                         ?object->class_pointer->super_class\n+                         :(CLS_ISMETA(object->class_pointer)\n+                           ?((Class_t)object)->super_class\n+                           :Nil))\n+                       :Nil);\n+}\n+\n+/*\n+** YES if object is a class, NO if not.\n+*/\n+static inline BOOL\n+object_is_class(id object)\n+{\n+  return CLS_ISCLASS((Class_t)object);\n+}\n+\n+/*\n+** YES if object is an instance, NO if not.\n+*/\n+static inline BOOL\n+object_is_instance(id object)\n+{\n+  return (object!=nil)&&CLS_ISCLASS(object->class_pointer);\n+}\n+\n+/*\n+** YES if object is a metaclass, NO if not.\n+*/\n+static inline BOOL\n+object_is_meta_class(id object)\n+{\n+  return CLS_ISMETA((Class_t)object);\n+}\n+\n+/*\n+** Functions used for archiving.  This is not documented yet!\n+*/\n+\n+TypedStream* new_typed_stream(FILE* physical);\n+void free_typed_stream(TypedStream* stream);\n+\n+void objc_write_object(TypedStream* stream, id object);\n+int objc_read_object(TypedStream* stream, id *object);\n+\n+void objc_write_type(TypedStream* stream, const char* type, const void* data);\n+void objc_read_type(TypedStream* stream, const char* type, void* data);\n+\n+#endif /* not __objc_api_INCLUDE_GNU */"}, {"sha": "a8f1a3be94fe765fd1f417f02589f741340ea6a9", "filename": "gcc/objc/objects.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjects.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,75 @@\n+/* GNU Objective C Runtime class related functions\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\t\t/* the kitchen sink */\n+\n+id __objc_object_alloc(Class_t);\n+id __objc_object_dispose(id);\n+id __objc_object_copy(id);\n+\n+id (*_objc_object_alloc)(Class_t) = __objc_object_alloc;\n+id (*_objc_object_dispose)(id)    = __objc_object_dispose;\n+id (*_objc_object_copy)(id)       = __objc_object_copy;\n+\n+id\n+class_create_instance(Class_t class)\n+{\n+  id res = (*_objc_object_alloc)(class);\n+  res->class_pointer = class;\n+  return res;\n+}\n+\n+id \n+object_copy(id object)\n+{\n+  return (*_objc_object_copy)(object);\n+}\n+\n+id \n+object_dispose(id object)\n+{\n+  return (*_objc_object_dispose)(object);\n+}\n+\n+id __objc_object_alloc(Class_t class)\n+{\n+  return (id)__objc_xmalloc(class->instance_size);\n+}\n+\n+id __objc_object_dispose(id object) \n+{\n+  free(object);\n+  return 0;\n+}\n+\n+id __objc_object_copy(id object)\n+{\n+  id copy = class_create_instance(object->class_pointer);\n+  bcopy(object, copy, object->class_pointer->instance_size);\n+  return copy;\n+}\n+\n+"}, {"sha": "6f2a55041da057fe029bfacf1811bd355a87c127", "filename": "gcc/objc/runtime.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fruntime.h?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,71 @@\n+/* GNU Objective C Runtime internal declarations\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#ifndef __objc_runtime_INCLUDE_GNU\n+#define __objc_runtime_INCLUDE_GNU\n+\n+#include <objc/objc.h>\t\t/* core data types */\n+#include <objc/objc-api.h>\t/* runtime api functions */\n+\n+#include <objc/hash.h>\t\t/* hash structures */\n+#include <objc/list.h>\t\t/* linear lists */\n+\n+#include <stdio.h>\t\t/* argh! I hate this */\n+#include <stdarg.h>\t\t/* for varargs and va_list's */\n+#include <stdlib.h>\n+\n+#include <assert.h>\n+\n+extern void __objc_add_class_to_hash(Class_t); /* (objc-class.c) */\n+extern void __objc_init_selector_tables();     /* (objc-sel.c) */\n+extern void __objc_init_class_tables();     /* (objc-class.c) */\n+extern void __objc_init_dispatch_tables();     /* (objc-dispatch.c) */\n+extern void __objc_install_premature_dtable(Class_t); /* (objc-dispatch.c) */\n+extern void __objc_resolve_class_links(); /* (objc-class.c) */\n+extern void __objc_register_selectors_from_class(Class_t); /* (objc-sel.c) */\n+extern void __objc_update_dispatch_table_for_class (Class_t);/* (objc-msg.c) */\n+\n+/* True when class links has been resolved */     \n+extern BOOL __objc_class_links_resolved;\n+\n+/* Number of selectors stored in each of the selector  tables */\n+extern int __objc_selector_max_index;\n+\n+#ifdef DEBUG\n+#define DEBUG_PRINTF printf\n+#else\n+#define DEBUG_PRINTF\n+#endif \n+\n+\n+/* standard functions */\n+int bcopy(void*, void*, size_t);\n+int vprintf(const char*, va_list);\n+\n+\n+#endif /* not __objc_runtime_INCLUDE_GNU */\n+\n+"}, {"sha": "8bab62c2c8113a5f71700d300f793b5c6607113c", "filename": "gcc/objc/sarray.c", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fsarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fsarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsarray.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,428 @@\n+/* Sparse Arrays for Objective C dispatch tables\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include <objc/sarray.h>\n+#include <stdio.h>\n+#include \"assert.h\"\n+\n+int nbuckets = 0;\n+int nindices = 0;\n+int narrays = 0;\n+int idxsize = 0;\n+\n+#ifdef OBJC_SPARSE2\n+const char* __objc_sparse2_id = \"2 level sparse indices\";\n+#endif\n+\n+#ifdef OBJC_SPARSE3\n+const char* __objc_sparse3_id = \"3 level sparse indices\";\n+#endif\n+\n+void\n+sarray_at_put(struct sarray* array, sidx index, void* element)\n+{\n+  struct sindex** the_index;\n+  struct sbucket** the_bucket;\n+#ifdef OBJC_SPARSE3\n+  unsigned int ioffset;\n+#endif\n+  unsigned int boffset;\n+  unsigned int eoffset;\n+#ifdef PRECOMPUTE_SELECTORS\n+  union sofftype xx; \n+  xx.idx = index;\n+#ifdef OBJC_SPARSE3\n+  ioffset = xx.off.ioffset;\n+#endif\n+  boffset = xx.off.boffset;\n+  eoffset = xx.off.eoffset;\n+#else\n+  ioffset = index/INDEX_CAPACITY;\n+  boffset = (index/BUCKET_SIZE)%INDEX_SIZE;\n+  eoffset = index%BUCKET_SIZE;\n+#endif\n+\n+  assert(soffset_decode(index) < array->capacity); /* Range check */\n+\n+#ifdef OBJC_SPARSE3\n+  the_index = &(array->indices[ioffset]);\n+  the_bucket = &((*the_index)->buckets[boffset]);\n+#else\n+  the_bucket = &(array->buckets[boffset]);\n+#endif\n+  \n+  if ((*the_bucket)->elems[eoffset] == element)\n+    return;\t\t/* great! we just avoided a lazy copy */\n+\n+#ifdef OBJC_SPARSE3\n+\n+  /* First, perform lazy copy/allocation of index if needed */\n+\n+  if ((*the_index) == array->empty_index) {\n+\n+    /* The index was previously empty, allocate a new */\n+    *the_index = (struct sindex*)__objc_xmalloc(sizeof(struct sindex));\n+    bcopy(array->empty_index, *the_index, sizeof(struct sindex));\n+    (*the_index)->version = array->version;\n+    the_bucket = &((*the_index)->buckets[boffset]);\n+    nindices += 1;\n+    \n+  } else if ((*the_index)->version != array->version) {\n+\n+    /* This index must be lazy copied */\n+    struct sindex* old_index = *the_index;\n+    *the_index = (struct sindex*)__objc_xmalloc(sizeof(struct sindex));\n+    bcopy(old_index, *the_index, sizeof(struct sindex));\n+    (*the_index)->version = array->version;\n+    the_bucket = &((*the_index)->buckets[boffset]);\n+    nindices += 1;\n+    \n+  }\n+\n+#endif /* OBJC_SPARSE3 */\n+\n+  /* next, perform lazy allocation/copy of the bucket if needed */\n+\n+  if ((*the_bucket) == array->empty_bucket) {\n+\n+    /* The bucket was previously empty (or something like that), */\n+    /* allocate a new.  This is the effect of `lazy' allocation */  \n+    *the_bucket = (struct sbucket*)__objc_xmalloc(sizeof(struct sbucket));\n+    bcopy(array->empty_bucket, *the_bucket, sizeof(struct sbucket));\n+    (*the_bucket)->version = array->version;\n+    nbuckets += 1;\n+\n+  } else if ((*the_bucket)->version != array->version) {\n+\n+    /* Perform lazy copy. */\n+    struct sbucket* old_bucket = *the_bucket;\n+    *the_bucket = (struct sbucket*)__objc_xmalloc(sizeof(struct sbucket));\n+    bcopy(old_bucket, *the_bucket, sizeof(struct sbucket));\n+    (*the_bucket)->version = array->version;\n+    nbuckets += 1;\n+\n+  }\n+  (*the_bucket)->elems[eoffset] = element;\n+}\n+\n+void\n+sarray_at_put_safe(struct sarray* array, sidx index, void* element)\n+{\n+  if(soffset_decode(index) >= array->capacity)\n+    sarray_realloc(array, soffset_decode(index)+1);\n+  sarray_at_put(array, index, element);\n+}\n+\n+struct sarray* \n+sarray_new (int size, void* default_element)\n+{\n+#ifdef OBJC_SPARSE3\n+  unsigned num_indices = ((size-1)/(INDEX_CAPACITY))+1;\n+#else /* OBJC_SPARSE2 */\n+  unsigned num_indices = ((size-1)/BUCKET_SIZE)+1;\n+#endif\n+  int counter;\n+  struct sarray* arr;\n+\n+  assert(size > 0);\n+\n+  /* Allocate core array */\n+  arr = (struct sarray*) __objc_xmalloc(sizeof(struct sarray));\n+  arr->version = 0;\n+  narrays  += 1;\n+  \n+  /* Initialize members */\n+#ifdef OBJC_SPARSE3\n+  arr->capacity = num_indices*INDEX_CAPACITY;\n+  arr->indices = (struct sindex**) \n+    __objc_xmalloc(sizeof(struct sindex*)*num_indices);\n+  idxsize  += num_indices;\n+\n+  arr->empty_index = (struct sindex*) __objc_xmalloc(sizeof(struct sindex));\n+  arr->empty_index->version = 0;\n+  nindices += 1;\n+\n+#else /* OBJC_SPARSE2 */\n+  arr->capacity = num_indices*BUCKET_SIZE;\n+  arr->buckets = (struct sbucket**) \n+    __objc_xmalloc(sizeof(struct sbucket*)*num_indices);\n+  idxsize  += num_indices;\n+\n+#endif\n+\n+  arr->empty_bucket = (struct sbucket*) __objc_xmalloc(sizeof(struct sbucket));\n+  arr->empty_bucket->version = 0;\n+  nbuckets += 1;\n+\n+  arr->ref_count = 1;\n+  arr->is_copy_of = (struct sarray*)0;\n+  \n+  for (counter=0; counter<BUCKET_SIZE; counter++)\n+    arr->empty_bucket->elems[counter] = default_element;\n+\n+#ifdef OBJC_SPARSE3\n+  for (counter=0; counter<INDEX_SIZE; counter++)\n+    arr->empty_index->buckets[counter] = arr->empty_bucket;\n+\n+  for (counter=0; counter<num_indices; counter++)\n+    arr->indices[counter] = arr->empty_index;\n+\n+#else /* OBJC_SPARSE2 */\n+\n+  for (counter=0; counter<num_indices; counter++)\n+    arr->buckets[counter] = arr->empty_bucket;\n+\n+#endif\n+\n+  return arr;\n+}\n+\f\n+\n+/* Reallocate the sparse array to hold `newsize' entries */\n+\n+void \n+sarray_realloc(struct sarray* array, int newsize)\n+{\n+#ifdef OBJC_SPARSE3\n+  int old_max_index = (array->capacity-1)/INDEX_CAPACITY;\n+  int new_max_index = ((newsize-1)/INDEX_CAPACITY);\n+  int rounded_size = (new_max_index+1)*INDEX_CAPACITY;\n+\n+#else /* OBJC_SPARSE2 */\n+  int old_max_index = (array->capacity-1)/BUCKET_SIZE;\n+  int new_max_index = ((newsize-1)/BUCKET_SIZE);\n+  int rounded_size = (new_max_index+1)*BUCKET_SIZE;\n+\n+#endif\n+\n+  int counter;\n+\n+  assert(newsize > 0);\n+\n+  /* The size is the same, just ignore the request */\n+  if(rounded_size == array->capacity)\n+    return;\n+\n+  assert(array->ref_count == 1);\t/* stop if lazy copied... */\n+\n+  if(rounded_size < array->capacity) \n+    {\n+      /* update capacity */\n+      array->capacity = rounded_size;\n+\n+      /* free buckets above new_max_index */\n+      for(counter = old_max_index; counter > new_max_index; counter-- ) {\n+#ifdef OBJC_SPARSE3\n+\tstruct sindex* idx = array->indices[counter];\n+\tif((idx != array->empty_index) && (idx->version == array->version)) {\n+\t  int c2; \n+\t  for(c2=0; c2<INDEX_SIZE; c2++) {\n+\t    struct sbucket* bkt = idx->buckets[c2];\n+\t    if((bkt != array->empty_bucket) && (bkt->version == array->version))\n+\t      {\n+\t\tfree(bkt);\n+\t\tnbuckets -= 1;\n+\t      }\n+\t  }\n+\t  free(idx);\n+\t  nindices -= 1;\n+\t}\n+#else /* OBJC_SPARSE2 */\n+\tstruct sbucket* bkt = array->buckets[counter];\n+\tif ((bkt != array->empty_bucket) && (bkt->version == array->version))\n+\t  {\n+\t    free(bkt);\n+\t    nbuckets -= 1;\n+\t  }\n+#endif\n+      }\n+\t  \n+#ifdef OBJC_SPARSE3\n+      /* realloc to free the space above new_max_index */\n+      array->indices = (struct sindex**)\n+\t__objc_xrealloc(array->indices, \n+\t\t\t(new_max_index+1)*sizeof(struct sindex*));\n+#else /* OBJC_SPARSE2 */\n+      array->buckets = (struct sbucket**)\n+\t__objc_xrealloc(array->buckets, \n+\t\t\t(new_max_index+1)*sizeof(struct sbucket*));\n+#endif      \n+      idxsize -= (old_max_index-new_max_index);\n+\n+      return;\n+    }\n+\n+  /* We are asked to extend the array -- reallocate the bucket table, */\n+  /* and insert empty_bucket in newly allocated places. */\n+  if(rounded_size > array->capacity) \n+    {\n+      /* update capacity */\n+      array->capacity = rounded_size;\n+\n+#ifdef OBJC_SPARSE3\n+      /* realloc to make room in table above old_max_index */\n+      array->indices = (struct sindex**)\n+\t__objc_xrealloc(array->indices, \n+\t\t\t(new_max_index+1)*sizeof(struct sindex*));\n+\n+      /* reset entries above old_max_index to empty_bucket */\n+      for(counter = old_max_index+1; counter <= new_max_index; counter++)\n+\tarray->indices[counter] = array->empty_index;\n+\n+#else /* OBJC_SPARSE2 */\n+\n+      /* realloc to make room in table above old_max_index */\n+      array->buckets = (struct sbucket**)\n+\t__objc_xrealloc(array->buckets, \n+\t\t\t(new_max_index+1)*sizeof(struct sbucket*));\n+\n+      /* reset entries above old_max_index to empty_bucket */\n+      for(counter = old_max_index+1; counter <= new_max_index; counter++)\n+\tarray->buckets[counter] = array->empty_bucket;\n+\n+#endif\n+      idxsize += (new_max_index-old_max_index);\n+      return;\n+    }\n+}\n+\f\n+\n+/* Free a sparse array allocated with sarray_new */\n+\n+void \n+sarray_free(struct sarray* array) {\n+#ifdef OBJC_SPARSE3\n+  unsigned int old_max_index = (array->capacity-1)/INDEX_CAPACITY;\n+#else\n+  unsigned int old_max_index = (array->capacity-1)/BUCKET_SIZE;\n+#endif\n+  int counter = 0;\n+\n+  assert(array->ref_count != 0);\t/* Freed multiple times!!! */\n+\n+  if(--(array->ref_count) != 0)\t/* There exists copies of me */\n+    return;\n+\n+  if((array->is_copy_of) && ((array->is_copy_of->ref_count - 1) == 0))\n+    sarray_free(array->is_copy_of);\n+\n+  /* Free all entries that do not point to empty_bucket */\n+  for(counter = 0; counter <= old_max_index; counter++ ) {\n+#ifdef OBJC_SPARSE3\n+    struct sindex* idx = array->indices[counter];\n+    if((idx != array->empty_index) && (idx->version == array->version)) {\n+      int c2; \n+      for(c2=0; c2<INDEX_SIZE; c2++) {\n+\tstruct sbucket* bkt = idx->buckets[c2];\n+\tif((bkt != array->empty_bucket) && (bkt->version == array->version))\n+\t  {\n+\t    free(bkt);\n+\t    nbuckets -= 1;\n+\t  }\n+      }\n+      free(idx);\n+      nindices -= 1;\n+    }\n+#else /* OBJC_SPARSE2 */\n+    struct sbucket* bkt = array->buckets[counter];\n+    if ((bkt != array->empty_bucket) && (bkt->version == array->version))\n+      {\n+\tfree(bkt);\n+\tnbuckets -= 1;\n+      }\n+#endif\n+  }\n+\t\n+#ifdef OBJC_SPARSE3  \n+  /* free empty_index */\n+  if(array->empty_index->version == array->version) {\n+    free(array->empty_index);\n+    nindices -= 1;\n+  }\n+#endif\n+\n+  /* free empty_bucket */\n+  if(array->empty_bucket->version == array->version) {\n+    free(array->empty_bucket);\n+    nbuckets -= 1;\n+  }\n+\n+#ifdef OBJC_SPARSE3\n+  /* free bucket table */\n+  free(array->indices);\n+  idxsize -= (old_max_index+1);\n+\n+#else\n+  /* free bucket table */\n+  free(array->buckets);\n+  idxsize -= (old_max_index+1);\n+\n+#endif\n+\n+  /* free array */\n+  free(array);\n+  narrays -= 1;\n+}\n+\n+/* This is a lazy copy.  Only the core of the structure is actually */\n+/* copied.   */\n+\n+struct sarray* \n+sarray_lazy_copy(struct sarray* oarr)\n+{\n+#ifdef OBJC_SPARSE3\n+  unsigned num_indices = ((oarr->capacity-1)/INDEX_CAPACITY)+1;\n+#else /* OBJC_SPARSE2 */\n+  unsigned num_indices = ((oarr->capacity-1)/BUCKET_SIZE)+1;\n+#endif\n+  struct sarray* arr;\n+\n+  /* Allocate core array */\n+  arr = (struct sarray*) __objc_xmalloc(sizeof(struct sarray));\n+  bcopy(oarr, arr, sizeof(struct sarray));\n+  arr->version = oarr->version + 1;\n+  arr->is_copy_of = oarr;\n+  oarr->ref_count += 1;\n+  arr->ref_count = 1;\n+  \n+#ifdef OBJC_SPARSE3\n+  /* Copy bucket table */\n+  arr->indices = (struct sindex**) \n+    __objc_xmalloc(sizeof(struct sindex*)*num_indices);\n+  bcopy(oarr->indices, arr->indices, \n+\tsizeof(struct sindex*)*num_indices);\n+#else \n+  /* Copy bucket table */\n+  arr->buckets = (struct sbucket**) \n+    __objc_xmalloc(sizeof(struct sbucket*)*num_indices);\n+  bcopy(oarr->buckets, arr->buckets, \n+\tsizeof(struct sbucket*)*num_indices);\n+#endif\n+\n+  idxsize += num_indices;\n+  narrays += 1;\n+\n+  return arr;\n+}"}, {"sha": "b22295758c52070f74f07be57ac363261caadfb6", "filename": "gcc/objc/sarray.h", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fsarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fsarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsarray.h?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,224 @@\n+/* Sparse Arrays for Objective C dispatch tables\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __sarray_INCLUDE_GNU\n+#define __sarray_INCLUDE_GNU\n+\n+#define OBJC_SPARSE3\t\t/* 2-level sparse array */\n+/* #define OBJC_SPARSE2 */      /* 3-level sparse array */\n+\n+#ifdef OBJC_SPARSE2\n+extern const char* __objc_sparse2_id;\n+#endif\n+\n+#ifdef OBJC_SPARSE3\n+extern const char* __objc_sparse3_id;\n+#endif\n+\n+#include <stddef.h>\n+\n+extern int nbuckets;\t\t/* for stats */\n+extern int nindices;\n+extern int narrays;\n+extern int idxsize;\n+\n+#include <assert.h>\n+\n+#if defined(sparc) || defined(OBJC_SPARSE2)\n+#define PRECOMPUTE_SELECTORS\n+#endif\n+\n+#ifdef OBJC_SPARSE3\n+\n+/* Buckets are 8 words each */\n+#define BUCKET_BITS 3\n+#define BUCKET_SIZE (1<<BUCKET_BITS)\n+#define BUCKET_MASK (BUCKET_SIZE-1)\n+\n+/* Indices are 16 words each */\n+#define INDEX_BITS 4\n+#define INDEX_SIZE (1<<INDEX_BITS)\n+#define INDEX_MASK (INDEX_SIZE-1)\n+\n+#define INDEX_CAPACITY (BUCKET_SIZE*INDEX_SIZE)\n+\n+#else /* OBJC_SPARSE2 */\n+\n+/* Buckets are 32 words each */\n+#define BUCKET_BITS 5\n+#define BUCKET_SIZE (1<<BUCKET_BITS)\n+#define BUCKET_MASK (BUCKET_SIZE-1)\n+\n+#endif /* OBJC_SPARSE2 */\n+\n+typedef unsigned int sidx;\n+\n+#ifdef PRECOMPUTE_SELECTORS\n+\n+struct soffset {\n+#ifdef OBJC_SPARSE3\n+  unsigned char unused;\n+  unsigned char eoffset;\n+  unsigned char boffset;\n+  unsigned char ioffset;\n+#else /* OBJC_SPARSE2 */\n+#ifdef sparc\n+  unsigned int boffset : 30 - BUCKET_BITS;\n+  unsigned int eoffset : BUCKET_BITS;\n+  unsigned int unused  : 2;\n+#else\n+  unsigned short boffset;\n+  unsigned short eoffset;\n+#endif\n+#endif /* OBJC_SPARSE2 */\n+};\n+\n+union sofftype {\n+  struct soffset off;\n+  sidx idx;\n+};\n+\n+#endif /* not PRECOMPUTE_SELECTORS */\n+\n+void * __objc_xrealloc (void *optr, size_t size);\n+void * __objc_xmalloc (size_t size);\n+\n+struct sbucket {\n+  void* elems[BUCKET_SIZE];\t/* elements stored in array */\n+  short version;\t\t\t/* used for copy-on-write */\n+};\n+\n+#ifdef OBJC_SPARSE3\n+\n+struct sindex {\n+  struct sbucket* buckets[INDEX_SIZE];\n+  short version;\n+};\n+\n+#endif /* OBJC_SPARSE3 */\n+\n+struct sarray {\n+#ifdef OBJC_SPARSE3\n+  struct sindex** indices;\n+  struct sindex* empty_index;\n+#else /* OBJC_SPARSE2 */\n+  struct sbucket** buckets;\n+#endif  /* OBJC_SPARSE2 */\n+  struct sbucket* empty_bucket;\n+  short version;\n+  short ref_count;\n+  struct sarray* is_copy_of;\n+  int capacity;\n+};\n+\n+struct sarray* sarray_new(int, void* default_element);\n+void sarray_free(struct sarray*);\n+struct sarray* sarray_lazy_copy(struct sarray*);\n+struct sarray* sarray_hard_copy(struct sarray*); /* ... like the name? */\n+void sarray_realloc(struct sarray*, int new_size);\n+void sarray_at_put(struct sarray*, sidx index, void* elem);\n+void sarray_at_put_safe(struct sarray*, sidx index, void* elem);\n+\f\n+\n+#ifdef PRECOMPUTE_SELECTORS\n+/* Transform soffset values to ints and vica verca */\n+static inline unsigned int\n+soffset_decode(sidx index)\n+{\n+  union sofftype x;\n+  x.idx = index;\n+#ifdef OBJC_SPARSE3\n+  return x.off.eoffset\n+    + (x.off.boffset*BUCKET_SIZE)\n+      + (x.off.ioffset*INDEX_CAPACITY);\n+#else /* OBJC_SPARSE2 */\n+  return x.off.eoffset + (x.off.boffset*BUCKET_SIZE);\n+#endif /* OBJC_SPARSE2 */\n+}\n+\n+static inline sidx\n+soffset_encode(unsigned int offset)\n+{\n+  union sofftype x;\n+  x.off.eoffset = offset%BUCKET_SIZE;\n+#ifdef OBJC_SPARSE3\n+  x.off.boffset = (offset/BUCKET_SIZE)%INDEX_SIZE;\n+  x.off.ioffset = offset/INDEX_CAPACITY;\n+#else /* OBJC_SPARSE2 */\n+  x.off.boffset = offset/BUCKET_SIZE;\n+#endif\n+  return (sidx)x.idx;\n+}\n+\n+#else /* not PRECOMPUTE_SELECTORS */\n+\n+static inline unsigned int\n+soffset_decode(sidx index)\n+{\n+  return index;\n+}\n+\n+static inline sidx\n+soffset_encode(unsigned int offset)\n+{\n+  return offset;\n+}\n+#endif /* not PRECOMPUTE_SELECTORS */\n+\n+/* Get element from the Sparse array `array' at offset `index' */\n+\n+static inline void* sarray_get(struct sarray* array, sidx index)\n+{\n+#ifdef PRECOMPUTE_SELECTORS\n+  union sofftype x;\n+  x.idx = index;\n+#ifdef OBJC_SPARSE3\n+  return \n+    array->\n+      indices[x.off.ioffset]->\n+\tbuckets[x.off.boffset]->\n+\t  elems[x.off.eoffset];\n+#else /* OBJC_SPARSE2 */\n+  return array->buckets[x.off.boffset]->elems[x.off.eoffset];\n+#endif /* OBJC_SPARSE2 */\n+#else /* not PRECOMPUTE_SELECTORS */\n+  return array->\n+    indices[index/INDEX_CAPACITY]->\n+      buckets[(index/BUCKET_SIZE)%INDEX_SIZE]->\n+\telems[index%BUCKET_SIZE];\n+#endif /* not PRECOMPUTE_SELECTORS */\n+}\n+\n+static inline void* sarray_get_safe(struct sarray* array, sidx index)\n+{\n+  if(soffset_decode(index) < array->capacity)\n+    return sarray_get(array, index);\n+  else\n+    return (array->empty_bucket->elems[0]);\n+}\n+\n+#endif /* __sarray_INCLUDE_GNU */"}, {"sha": "44a73f64f5dffbc324e91a7cf22faf9bc5843649", "filename": "gcc/objc/selector.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fselector.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,143 @@\n+/* GNU Objective C Runtime selector related functions\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\n+#include <objc/sarray.h>\n+\n+/* Initial selector hash table size. Value doesnt matter much */\n+#define SELECTOR_HASH_SIZE 128\n+\n+/* Tables mapping selector names to uid and opposite */\n+static struct sarray* __objc_selector_array = 0; /* uid -> name */\n+static cache_ptr      __objc_selector_hash  = 0; /* name -> uid */\n+\n+static void register_selectors_from_list(MethodList_t);\n+\n+/* Number of selectors stored in each of the above tables */\n+int __objc_selector_max_index = 0;\n+\n+void __objc_init_selector_tables()\n+{\n+  __objc_selector_array = sarray_new (SELECTOR_HASH_SIZE, 0);\n+  __objc_selector_hash\n+    = hash_new (SELECTOR_HASH_SIZE,\n+\t\t(hash_func_type) hash_string,\n+\t\t(compare_func_type) compare_strings);\n+}  \n+\n+/* This routine is given a class and records all of the methods in its class\n+   structure in the record table.  */\n+void\n+__objc_register_selectors_from_class (Class_t class)\n+{\n+  MethodList_t method_list;\n+\n+  method_list = class->methods;\n+  while (method_list)\n+    {\n+      register_selectors_from_list (method_list);\n+      method_list = method_list->method_next;\n+    }\n+}\n+\n+\n+/* This routine is given a list of methods and records each of the methods in\n+   the record table.  This is the routine that does the actual recording\n+   work.\n+\n+   This one is only called for Class objects.  For categories,\n+   class_add_method_list is called.\n+   */\n+static void\n+register_selectors_from_list (MethodList_t method_list)\n+{\n+  int i = 0;\n+  while (i < method_list->method_count)\n+    {\n+      Method_t method = &method_list->method_list[i];\n+      method->method_name = sel_register_name ((char*)method->method_name);\n+      i += 1;\n+    }\n+}\n+\n+/* return selector representing name */\n+SEL\n+sel_get_uid (const char *name)\n+{\n+  return (SEL) hash_value_for_key (__objc_selector_hash, name);\n+}\n+\n+/* Get name of selector.  If selector is unknown, the empty string \"\" \n+   is returned */ \n+const char*\n+sel_get_name (SEL selector)\n+{\n+  if ((soffset_decode((unsigned)selector) > 0)\n+      && (soffset_decode((unsigned)selector) <= __objc_selector_max_index))\n+    return sarray_get (__objc_selector_array, (sidx) selector);\n+  else\n+    return NULL;\n+}\n+\n+BOOL\n+sel_is_mapped (SEL selector)\n+{\n+  unsigned int idx = soffset_decode ((sidx)selector);\n+  return ((idx > 0) && (idx <= __objc_selector_max_index));\n+}\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+/* The uninstalled dispatch table */\n+extern struct sarray* __objc_uninstalled_dtable;\n+#endif\n+\n+/* Store the passed selector name in the selector record and return its\n+   selector value (value returned by sel_get_uid). */\n+SEL\n+sel_register_name (const char *sel)\n+{\n+  SEL j;\n+  sidx i;\n+\n+  if ((j = sel_get_uid ((const char *) sel)))\n+    return j;\n+\n+  /* Save the selector name.  */\n+  __objc_selector_max_index += 1;\n+  i = soffset_encode(__objc_selector_max_index);\n+\n+  DEBUG_PRINTF (\"Record selector %s as: %#x\\n\", sel, i);\n+\n+  sarray_at_put_safe (__objc_selector_array, i, (void *) sel);\n+  hash_add (&__objc_selector_hash, (void *) sel, (void *) i);\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+  sarray_realloc(__objc_uninstalled_dtable, __objc_selector_max_index+1);\n+#endif\n+\n+  return (SEL) i;\n+}\n+"}, {"sha": "90688a5d00893d89e5dfafb032d9c91d5d2840e3", "filename": "gcc/objc/sendmsg.c", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "patch": "@@ -0,0 +1,574 @@\n+/* GNU Objective C Runtime message lookup \n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the Free Software\n+   Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+   details.\n+\n+You should have received a copy of the GNU General Public License along with\n+   GNU CC; see the file COPYING.  If not, write to the Free Software\n+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+const char* __objc_sparse_lookup_id = \"Method lookup uses sparse arrays\";\n+#endif\n+\n+#ifdef OBJC_HASH_LOOKUP\n+const char* __objc_hash_lookup_id = \"Method lookup uses hash caching\";\n+#endif\n+\n+#ifdef OBJC_HASH_LOOKUP\n+#include <objc/cache.h>\n+#endif\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+/* The uninstalled dispatch table */\n+struct sarray* __objc_uninstalled_dtable = 0;\n+#endif\n+\n+/* Send +initialize to class */\n+static void __objc_send_initialize(Class_t);\n+\n+static void __objc_install_dispatch_table_for_class (Class_t);\n+\n+/* Forward declare some functions */\n+#ifdef OBJC_SPARSE_LOOKUP\n+static void __objc_init_install_dtable(id, SEL);\n+#endif\n+static id __objc_missing_method(id, SEL, ...);\n+static Method_t search_for_method_in_hierarchy (Class_t class, SEL sel);\n+static Method_t search_for_method_in_list(MethodList_t list, SEL op);\n+id nil_method(id, SEL, ...);\n+\n+id\n+nil_method(id receiver, SEL op, ...)\n+{\n+  return receiver;\n+}\n+\n+/* Given a class and selector, return the selector's implementation.  */\n+__inline__ IMP\n+get_imp (Class_t class, SEL sel)\n+{\n+#ifdef OBJC_SPARSE_LOOKUP\n+  void* res = sarray_get (class->dtable, (unsigned int) sel);\n+  if(res == __objc_init_install_dtable)\n+    __objc_install_dispatch_table_for_class (class);\n+  return sarray_get (class->dtable, (unsigned int) sel);\n+#else\n+  return cache_get (class, sel);\n+#endif\n+}\n+\n+/* This is the lookup function.  All entries in the table are either a \n+   valid method *or* one of `__objc_missing_method' which calls\n+   forward:: etc, or `__objc_init_install_dtable' which installs the\n+   real dtable */\n+__inline__ IMP\n+objc_msg_lookup(id receiver, SEL op)\n+{\n+  if(receiver)\n+#ifdef OBJC_HASH_LOOKUP\n+    return cache_get(receiver->class_pointer, op);\n+#else\n+    return sarray_get(receiver->class_pointer->dtable, (sidx)op);\n+#endif\n+  else\n+    return nil_method;\n+}\n+\n+IMP\n+objc_msg_lookup_super (Super_t super, SEL sel)\n+{\n+  if (super->self)\n+    return get_imp (super->class, sel);\n+  else\n+    return nil_method;\n+}\n+\n+retval_t\n+objc_msg_sendv(id object, SEL op, size_t frame_size, arglist_t arg_frame)\n+{\n+#ifdef __objc_frame_receiver\n+  __objc_frame_receiver(arg_frame) = object;\n+  __objc_frame_selector(arg_frame) = op;\n+  return __builtin_apply((apply_t)get_imp(object->class_pointer, op),\n+\t\t\t arg_frame,\n+\t\t\t frame_size);\n+#else\n+#warning performv:: will not work\n+  (*_objc_error)(object, \"objc_msg_sendv (performv::) not supported\\n\", 0);\n+  return 0;\n+#endif\n+}\n+\n+void __objc_init_dispatch_tables()\n+{\n+#ifdef OBJC_SPARSE_LOOKUP  \n+  __objc_uninstalled_dtable\n+    = sarray_new(200, __objc_init_install_dtable);\n+#endif\n+}\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+/* This one is a bit hairy.  This function is installed in the \n+   premature dispatch table, and thus called once for each class,\n+   namely when the very first message is send to it.  */\n+\n+static void __objc_init_install_dtable(id receiver, SEL op)\n+{\n+  __label__ allready_initialized;\n+  IMP imp;\n+  void* args;\n+  void* result;\n+\n+  /* If the class has not yet had it's class links resolved, we must \n+     re-compute all class links */\n+  if(!CLS_ISRESOLV(receiver->class_pointer))\n+    __objc_resolve_class_links();\n+\n+  /* This may happen, if the programmer has taken the address of a \n+     method before the dtable was initialized... too bad for him! */\n+  if(receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n+    goto allready_initialized;\n+\n+  if(CLS_ISCLASS(receiver->class_pointer))\n+    {\n+      /* receiver is an ordinary object */\n+      assert(CLS_ISCLASS(receiver->class_pointer));\n+\n+      /* install instance methods table */\n+      __objc_install_dispatch_table_for_class (receiver->class_pointer);\n+\n+      /* call +initialize -- this will in turn install the factory \n+\t dispatch table if not already done :-) */\n+      __objc_send_initialize(receiver->class_pointer);\n+    }\n+  else\n+    {\n+      /* receiver is a class object */\n+      assert(CLS_ISCLASS((Class_t)receiver));\n+      assert(CLS_ISMETA(receiver->class_pointer));\n+\n+      /* Install real dtable for factory methods */\n+      __objc_install_dispatch_table_for_class (receiver->class_pointer);\n+      \n+      if(op != sel_get_uid (\"initialize\"))\n+\t__objc_send_initialize((Class_t)receiver);\n+      else\n+\tCLS_SETINITIALIZED((Class_t)receiver);\n+    }\n+\n+allready_initialized:\n+  \n+  /* Get real method for this in newly installed dtable */\n+  imp = get_imp(receiver->class_pointer, op);\n+\n+  args = __builtin_apply_args();\n+  result = __builtin_apply((apply_t)imp, args, 96);\n+  __builtin_return (result);\n+  \n+}\n+#endif\n+\n+/* Install dummy table for class which causes the first message to\n+   that class (or instances hereof) to be initialized properly */\n+void __objc_install_premature_dtable(Class_t class)\n+{\n+#ifdef OBJC_SPARSE_LOOKUP\n+  assert(__objc_uninstalled_dtable);\n+  class->dtable = __objc_uninstalled_dtable;\n+#else\n+  class->cache = (Cache_t)__objc_xcalloc(1, sizeof(Cache));\n+#endif\n+}   \n+\n+/* Send +initialize to class if not already done */\n+static void __objc_send_initialize(Class_t class)\n+{\n+  Method_t m;\n+  IMP imp;\n+\n+  /* This *must* be a class object */\n+  assert(CLS_ISCLASS(class));\n+  assert(!CLS_ISMETA(class));\n+\n+  if (!CLS_ISINITIALIZED(class))\n+    {\n+      CLS_SETINITIALIZED(class);\n+      CLS_SETINITIALIZED(class->class_pointer);\n+      \n+      if(class->super_class)\n+\t__objc_send_initialize(class->super_class);\n+  \n+      m = search_for_method_in_list(class->class_pointer->methods,\n+\t\t\t\t    sel_get_uid(\"initialize\"));\n+      if(m != NULL)\n+        {\n+          CLS_SETINITIALIZED(class);\n+          (*m->method_imp) ((id) class, sel_get_uid(\"initialize\"));\n+        }\n+    }\n+}  \n+\n+static void\n+__objc_install_dispatch_table_for_class (Class_t class)\n+{\n+#ifdef OBJC_SPARSE_LOOKUP\n+  Class_t super = class->super_class;\n+  MethodList_t mlist;\n+  int counter;\n+\n+  if (super != 0 && (super->dtable == __objc_uninstalled_dtable))\n+    __objc_install_dispatch_table_for_class (super);\n+\n+  /* Allocate dtable if nessecary */\n+  if (super == 0)\n+    {\n+      class->dtable = sarray_new (__objc_selector_max_index,\n+\t\t\t\t  __objc_missing_method);\n+    }\n+  else\n+    class->dtable = sarray_lazy_copy (super->dtable);\n+\n+  for (mlist = class->methods; mlist; mlist = mlist->method_next)\n+    {\n+      counter = mlist->method_count - 1;\n+      while (counter >= 0)\n+        {\n+          Method_t method = &(mlist->method_list[counter]);\n+\t  sarray_at_put (class->dtable,\n+\t\t\t (sidx) method->method_name,\n+\t\t\t method->method_imp);\n+          counter -= 1;\n+        }\n+    }\n+#endif\n+}\n+\n+void __objc_update_dispatch_table_for_class (Class_t class)\n+{\n+  Class_t next;\n+#ifdef OBJC_SPARSE_LOOKUP\n+  struct sarray* save;\n+#else\n+  Cache_t save;\n+#endif\n+\n+  /* not yet installed -- skip it */\n+#ifdef OBJC_SPARSE_LOOKUP\n+  if (class->dtable == __objc_uninstalled_dtable) \n+#else\n+  if (class->cache->mask == 0)\n+#endif\n+    return;\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+  save = class->dtable;\n+  __objc_install_premature_dtable (class);\n+  sarray_free (save);\n+\n+#else\n+  save = class->cache;\n+  __objc_install_premature_dtable (class);\n+  free(save);\n+\n+#endif\n+\n+  if (class->subclass_list)\t/* Traverse subclasses */\n+    for (next = class->subclass_list; next; next = next->sibling_class)\n+      __objc_update_dispatch_table_for_class (next);\n+}\n+\n+\n+/* This function adds a method list to a class.  This function is\n+   typically called by another function specific to the run-time.  As\n+   such this function does not worry about thread safe issued.\n+\n+   This one is only called for categories. Class objects have their\n+   methods installed rightaway, and their selectors are made into\n+   SEL's by the function __objc_register_selectors_from_class. */ \n+void\n+class_add_method_list (Class_t class, MethodList_t list)\n+{\n+  int i;\n+\n+  /* Passing of a linked list is not allowed.  Do multiple calls.  */\n+  assert (!list->method_next);\n+\n+  /* Check for duplicates.  */\n+  for (i = 0; i < list->method_count; ++i)\n+    {\n+      Method_t method = &list->method_list[i];\n+\n+      if (method->method_name)  /* Sometimes these are NULL */\n+\t{\n+\t  /* This is where selector names are transmogriffed to SEL's */\n+\t  method->method_name = sel_register_name ((char*)method->method_name);\n+\n+\t  if (search_for_method_in_list (class->methods, method->method_name))\n+\t    {\n+\t      /* Duplication. Print a error message an change the method name\n+\t\t to NULL. */\n+\t      fprintf (stderr, \"attempt to add a existing method: %s\\n\",\n+\t\t       sel_get_name(method->method_name));\n+\t      method->method_name = 0;\n+\t    }\n+\t}\n+    }\n+\n+  /* Add the methods to the class's method list.  */\n+  list->method_next = class->methods;\n+  class->methods = list;\n+}\n+\n+\n+Method_t\n+class_get_instance_method(Class_t class, SEL op)\n+{\n+  return search_for_method_in_hierarchy(class, op);\n+}\n+\n+Method_t\n+class_get_class_method(MetaClass_t class, SEL op)\n+{\n+  return search_for_method_in_hierarchy(class, op);\n+}\n+\n+\n+/* Search for a method starting from the current class up its hierarchy.\n+   Return a pointer to the method's method structure if found.  NULL\n+   otherwise. */   \n+\n+static Method_t\n+search_for_method_in_hierarchy (Class_t cls, SEL sel)\n+{\n+  Method_t method = NULL;\n+  Class_t class;\n+\n+  if (! sel_is_mapped (sel))\n+    return NULL;\n+\n+  /* Scan the method list of the class.  If the method isn't found in the\n+     list then step to its super class. */\n+  for (class = cls; ((! method) && class); class = class->super_class)\n+    method = search_for_method_in_list (class->methods, sel);\n+\n+  return method;\n+}\n+\n+\n+\n+/* Given a linked list of method and a method's name.  Search for the named\n+   method's method structure.  Return a pointer to the method's method\n+   structure if found.  NULL otherwise. */  \n+static Method_t\n+search_for_method_in_list (MethodList_t list, SEL op)\n+{\n+  MethodList_t method_list = list;\n+\n+  if (! sel_is_mapped (op))\n+    return NULL;\n+\n+  /* If not found then we'll search the list.  */\n+  while (method_list)\n+    {\n+      int i;\n+\n+      /* Search the method list.  */\n+      for (i = 0; i < method_list->method_count; ++i)\n+        {\n+          Method_t method = &method_list->method_list[i];\n+\n+          if (method->method_name)\n+            if (method->method_name == op)\n+              return method;\n+        }\n+\n+      /* The method wasn't found.  Follow the link to the next list of\n+         methods.  */\n+      method_list = method_list->method_next;\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+/* This fuction is installed in the dispatch table for all methods which are\n+   not implemented.  Thus, it is called when a selector is not recognized. */\n+static id\n+__objc_missing_method (id object, SEL sel, ...)\n+{\n+  IMP imp;\n+  SEL frwd_sel;\n+  SEL err_sel;\n+\n+  /* first try if the object understands forward:: */\n+  frwd_sel = sel_get_uid(\"forward::\");\n+  imp = get_imp(object->class_pointer, frwd_sel);\n+  if(imp != __objc_missing_method)\n+    {\n+      void *result, *args = __builtin_apply_args();\n+      result = (*imp)(object, frwd_sel, sel, args);\n+      __builtin_return(result);\n+    }\n+\n+  /* If the object recognizes the doesNotRecognize: method then we're going\n+     to send it. */\n+  err_sel = sel_get_uid (\"doesNotRecognize:\");\n+  imp = get_imp (object->class_pointer, err_sel);\n+  if (imp != __objc_missing_method)\n+    {\n+      return (*imp) (object, err_sel, sel);\n+    }\n+  \n+  /* The object doesn't recognize the method.  Check for responding to\n+     error:.  If it does then sent it. */\n+  {\n+    char msg[256 + strlen (sel_get_name (sel))\n+             + strlen (object->class_pointer->name)];\n+\n+    sprintf (msg, \"(%s) %s does not recognize %s\",\n+\t     (CLS_ISMETA(object->class_pointer)\n+\t      ? \"class\"\n+\t      : \"instance\" ),\n+             object->class_pointer->name, sel_get_name (sel));\n+\n+    err_sel = sel_get_uid (\"error:\");\n+    imp = get_imp (object->class_pointer, err_sel);\n+    if (imp != __objc_missing_method)\n+      return (*imp) (object, sel_get_uid (\"error:\"), msg);\n+\n+    /* The object doesn't respond to doesNotRecognize: or error:;  Therefore,\n+       a default action is taken. */\n+    fprintf (stderr, \"fatal: %s\\n\", msg);\n+    abort ();\n+  }\n+}\n+\n+int __objc_print_dtable_stats()\n+{\n+  int total = 0;\n+  printf(\"memory usage: (%s)\\n\",\n+#ifdef OBJC_SPARSE_LOOKUP\n+#ifdef OBJC_SPARSE2\n+\t \"2-level sparse arrays\"\n+#else\n+\t \"3-level sparse arrays\"\n+#endif\n+#else\n+\t \"hash-cache\"\n+#endif\n+\t );\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+  printf(\"arrays: %d = %d bytes\\n\", narrays, narrays*sizeof(struct sarray));\n+  total += narrays*sizeof(struct sarray);\n+#ifdef OBJC_SPARSE3\n+  printf(\"indices: %d = %d bytes\\n\", nindices, nindices*sizeof(struct sindex));\n+  total += nindices*sizeof(struct sindex);\n+#endif\n+  printf(\"buckets: %d = %d bytes\\n\", nbuckets, nbuckets*sizeof(struct sbucket));\n+  total += nbuckets*sizeof(struct sbucket);\n+\n+  printf(\"idxtables: %d = %d bytes\\n\", idxsize, idxsize*sizeof(void*));\n+  total += idxsize*sizeof(void*);\n+#else /* HASH_LOOKUP */\n+  total = __objc_class_hash_tables_size ();\n+#endif\n+  printf(\"-----------------------------------\\n\");\n+  printf(\"total: %d bytes\\n\", total);\n+  printf(\"===================================\\n\");\n+  }\n+\n+#ifdef OBJC_HASH_LOOKUP\n+static Cache_t __objc_cache_insert(Cache_t cache, SEL op, IMP imp);\n+\n+static Cache_t\n+__objc_double_cache(Cache_t cache)\n+{\n+  int i;\n+  Cache_t newc = (Cache_t)__objc_xcalloc(1, sizeof(Cache)\n+\t\t\t\t\t +(sizeof(Cache)*2*(cache->mask+1)));\n+  newc->occupied = cache->occupied;\n+  newc->mask = ((cache->mask)<<1) | 1;\n+  for(i=0; i <= cache->mask; i++)\n+    newc = __objc_cache_insert(newc,\n+\t\t\t       cache->buckets[i].method_selector,\n+\t\t\t       cache->buckets[i].method_imp);\n+  free(cache);\n+  return newc;\n+}\n+\n+\n+static Cache_t\n+__objc_cache_insert(Cache_t cache, SEL op, IMP imp)\n+{\n+  int index = ((unsigned int)op)&(cache)->mask;\n+\n+  if(op == 0)\n+    return cache;\n+\n+  do\n+    {\n+      if((cache)->buckets[index].method_selector == 0)\n+\t{\n+\t  (cache)->buckets[index].method_selector = op;\n+\t  (cache)->buckets[index].method_imp = imp;\n+\t  (cache)->occupied += 1;\n+\t  return cache;\n+\t}\n+    }\n+  while (--index >= 0);\n+    \n+  cache = __objc_double_cache(cache);\n+  return __objc_cache_insert(cache, op, imp);\n+}\n+\n+void* \n+__objc_cache_miss(Class_t class, SEL op) \n+{\n+  Method_t m;\n+  Cache_t cache = class->cache;\n+  \n+  if(!CLS_ISRESOLV(class))\n+    __objc_resolve_class_links();\n+\n+  m = search_for_method_in_hierarchy(class, op);\n+\n+  if(!CLS_ISINITIALIZED(class))\n+    if(CLS_ISMETA(class))\n+      __objc_send_initialize(objc_get_class(class->name));\n+    else\n+      __objc_send_initialize(class);\n+\n+  if(m == NULL)\n+    return __objc_missing_method;\n+\n+  if((cache->occupied+2)*2 > cache->mask)\n+    class->cache = __objc_double_cache(cache);\n+  \n+  class->cache = __objc_cache_insert(class->cache, op, m->method_imp);\n+  return m->method_imp;\n+}\n+\n+#endif\n+\n+"}]}