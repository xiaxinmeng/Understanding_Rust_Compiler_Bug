{"sha": "cdf66caf4fa836a4398f74faceb373d84e019bb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RmNjZjYWY0ZmE4MzZhNDM5OGY3NGZhY2ViMzczZDg0ZTAxOWJiNw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-12-01T05:22:16Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-12-01T05:22:16Z"}, "message": "re PR tree-optimization/68529 (scev failed for while(i--))\n\n\n\tPR tree-optimization/68529\n\t* tree-ssa-loop-niter.c (number_of_iterations_ne): Add new param.\n\tCompute no-overflow information for control iv.\n\t(number_of_iterations_lt, number_of_iterations_le): Add new param.\n\t(number_of_iterations_cond): Pass new argument to above functions.\n\n\tPR tree-optimization/68529\n\t* gcc.dg/tree-ssa/pr68529-1.c: New test.\n\t* gcc.dg/tree-ssa/pr68529-2.c: New test.\n\t* gcc.dg/tree-ssa/pr68529-3.c: New test.\n\nFrom-SVN: r231097", "tree": {"sha": "b0feb2d5b46ce5a54088544843561463d10ac4f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0feb2d5b46ce5a54088544843561463d10ac4f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdf66caf4fa836a4398f74faceb373d84e019bb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf66caf4fa836a4398f74faceb373d84e019bb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf66caf4fa836a4398f74faceb373d84e019bb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf66caf4fa836a4398f74faceb373d84e019bb7/comments", "author": null, "committer": null, "parents": [{"sha": "6ea98dee208bef31e56452969bfa7e85d0dd3c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ea98dee208bef31e56452969bfa7e85d0dd3c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ea98dee208bef31e56452969bfa7e85d0dd3c36"}], "stats": {"total": 154, "additions": 139, "deletions": 15}, "files": [{"sha": "5f675f1f64392dd701b9153415864a09493e271c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdf66caf4fa836a4398f74faceb373d84e019bb7", "patch": "@@ -1,3 +1,11 @@\n+2015-12-01  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/68529\n+\t* tree-ssa-loop-niter.c (number_of_iterations_ne): Add new param.\n+\tCompute no-overflow information for control iv.\n+\t(number_of_iterations_lt, number_of_iterations_le): Add new param.\n+\t(number_of_iterations_cond): Pass new argument to above functions.\n+\n 2015-11-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline-transform.c (inline_call): Drop -fstrict-aliasing when"}, {"sha": "6e17cc4f207df536cc6a833d135c4d372999d431", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cdf66caf4fa836a4398f74faceb373d84e019bb7", "patch": "@@ -1,3 +1,10 @@\n+2015-12-01  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/68529\n+\t* gcc.dg/tree-ssa/pr68529-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr68529-2.c: New test.\n+\t* gcc.dg/tree-ssa/pr68529-3.c: New test.\n+\n 2015-11-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.dg/lto/alias-1_0.c: New testcase."}, {"sha": "9dcc22f366a24fedefa171a6bb1a28717e66eb1e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68529-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-1.c?ref=cdf66caf4fa836a4398f74faceb373d84e019bb7", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+void bar(char *s);\n+int foo()\n+{\n+  char c[10000] = {};\n+  unsigned short nchar = 9999;\n+\n+  while(nchar-- != 0)\n+    {\n+      c[nchar] = 'A';\n+    }\n+\n+  bar (c);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"distributed: split to 0 loops and 1 library calls\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"generated memset\" \"ldist\" } } */"}, {"sha": "6d576187e9d46073413c3617f03337f564e31742", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68529-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-2.c?ref=cdf66caf4fa836a4398f74faceb373d84e019bb7", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+void bar(char *s);\n+int foo(unsigned short l)\n+{\n+  char c[10000] = {};\n+  unsigned short nchar = 9999;\n+\n+  if (nchar <= l)\n+    return -1;\n+\n+  while(nchar-- != l)\n+    {\n+      c[nchar] = 'A';\n+    }\n+\n+  bar (c);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"distributed: split to 0 loops and 1 library calls\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"generated memset\" \"ldist\" } } */"}, {"sha": "583b4a610a57b0c04e7adbb92baabdb0fb270d5b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68529-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68529-3.c?ref=cdf66caf4fa836a4398f74faceb373d84e019bb7", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+void bar(char *s);\n+int foo1(unsigned short l)\n+{\n+  char c[10000] = {};\n+  unsigned short nchar = 9999;\n+\n+  while(nchar-- != l)\n+    {\n+      c[nchar] = 'A';\n+    }\n+\n+  bar (c);\n+  return 0;\n+}\n+\n+int foo2()\n+{\n+  char c[100000] = {};\n+  unsigned short nchar;\n+\n+  for (nchar = 0; nchar != 1000; --nchar)\n+    {\n+      c[nchar] = 'A';\n+    }\n+\n+  bar (c);\n+  return 0;\n+}\n+\n+int foo3()\n+{\n+  char c[100000] = {};\n+  unsigned short nchar;\n+\n+  for (nchar = 0; nchar != 1000; nchar += 3)\n+    {\n+      c[nchar] = 'A';\n+    }\n+\n+  bar (c);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"failed: evolution of offset is not affine\" 3 \"ldist\" } } */"}, {"sha": "67080a35fb92a52a042579771402dca7aea48bf5", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf66caf4fa836a4398f74faceb373d84e019bb7/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=cdf66caf4fa836a4398f74faceb373d84e019bb7", "patch": "@@ -957,13 +957,14 @@ number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n    bounds on the difference FINAL - IV->base.  */\n \n static bool\n-number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n-\t\t\t struct tree_niter_desc *niter, bool exit_must_be_taken,\n-\t\t\t bounds *bnds)\n+number_of_iterations_ne (struct loop *loop, tree type, affine_iv *iv,\n+\t\t\t tree final, struct tree_niter_desc *niter,\n+\t\t\t bool exit_must_be_taken, bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n   tree s, c, d, bits, assumption, tmp, bound;\n   mpz_t max;\n+  tree e;\n \n   niter->control = *iv;\n   niter->bound = final;\n@@ -998,6 +999,23 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n \t\t\t\t TYPE_SIGN (niter_type));\n   mpz_clear (max);\n \n+  /* Compute no-overflow information for the control iv.  Note we are\n+     handling NE_EXPR, if iv base equals to final value, the loop exits\n+     immediately, and the iv does not overflow.  */\n+  if (tree_int_cst_sign_bit (iv->step))\n+    e = fold_build2 (GE_EXPR, boolean_type_node, iv->base, final);\n+  else\n+    e = fold_build2 (LE_EXPR, boolean_type_node, iv->base, final);\n+  e = simplify_using_initial_conditions (loop, e);\n+  if (integer_onep (e)\n+      && (integer_onep (s)\n+\t  || (TREE_CODE (c) == INTEGER_CST\n+\t      && TREE_CODE (s) == INTEGER_CST\n+\t      && wi::mod_trunc (c, s, TYPE_SIGN (type)) == 0)))\n+    {\n+      niter->control.no_overflow = true;\n+    }\n+\n   /* First the trivial cases -- when the step is 1.  */\n   if (integer_onep (s))\n     {\n@@ -1361,8 +1379,8 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n    that the exit must be taken eventually.  */\n \n static bool\n-number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t\t struct tree_niter_desc *niter,\n+number_of_iterations_lt (struct loop *loop, tree type, affine_iv *iv0,\n+\t\t\t affine_iv *iv1, struct tree_niter_desc *niter,\n \t\t\t bool exit_must_be_taken, bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n@@ -1434,7 +1452,8 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t zps does not overflow.  */\n       zps.no_overflow = true;\n \n-      return number_of_iterations_ne (type, &zps, delta, niter, true, bnds);\n+      return number_of_iterations_ne (loop, type, &zps,\n+\t\t\t\t      delta, niter, true, bnds);\n     }\n \n   /* Make sure that the control iv does not overflow.  */\n@@ -1473,9 +1492,9 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n    is the case).  BNDS bounds the difference IV1->base - IV0->base.  */\n \n static bool\n-number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t\t struct tree_niter_desc *niter, bool exit_must_be_taken,\n-\t\t\t bounds *bnds)\n+number_of_iterations_le (struct loop *loop, tree type, affine_iv *iv0,\n+\t\t\t affine_iv *iv1, struct tree_niter_desc *niter,\n+\t\t\t bool exit_must_be_taken, bounds *bnds)\n {\n   tree assumption;\n   tree type1 = type;\n@@ -1523,7 +1542,7 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   bounds_add (bnds, 1, type1);\n \n-  return number_of_iterations_lt (type, iv0, iv1, niter, exit_must_be_taken,\n+  return number_of_iterations_lt (loop, type, iv0, iv1, niter, exit_must_be_taken,\n \t\t\t\t  bnds);\n }\n \n@@ -1698,18 +1717,18 @@ number_of_iterations_cond (struct loop *loop,\n     {\n     case NE_EXPR:\n       gcc_assert (integer_zerop (iv1->step));\n-      ret = number_of_iterations_ne (type, iv0, iv1->base, niter,\n+      ret = number_of_iterations_ne (loop, type, iv0, iv1->base, niter,\n \t\t\t\t     exit_must_be_taken, &bnds);\n       break;\n \n     case LT_EXPR:\n-      ret = number_of_iterations_lt (type, iv0, iv1, niter, exit_must_be_taken,\n-\t\t\t\t     &bnds);\n+      ret = number_of_iterations_lt (loop, type, iv0, iv1, niter,\n+\t\t\t\t     exit_must_be_taken, &bnds);\n       break;\n \n     case LE_EXPR:\n-      ret = number_of_iterations_le (type, iv0, iv1, niter, exit_must_be_taken,\n-\t\t\t\t     &bnds);\n+      ret = number_of_iterations_le (loop, type, iv0, iv1, niter,\n+\t\t\t\t     exit_must_be_taken, &bnds);\n       break;\n \n     default:"}]}