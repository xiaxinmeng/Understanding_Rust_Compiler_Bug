{"sha": "e1af8299421eb7261ddcadf3630cf6dfa6c32099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFhZjgyOTk0MjFlYjcyNjFkZGNhZGYzNjMwY2Y2ZGZhNmMzMjA5OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-06-18T23:15:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-06-18T23:15:59Z"}, "message": "fold-const.c (build_range_check): If !in_p and recursive call fails, exit immediately.\n\n\t* fold-const.c (build_range_check): If !in_p and recursive call\n\tfails, exit immediately.  If high - low overflows and etype is\n\ta signed type, retry with unsigned etype.\n\t(merge_ranges): If !in0_p and !in1_p, handle even range2 adjacent\n\tto range1 at TYPE_MAX_VALUE and TYPE_MIN_VALUE.\n\n\t* gcc.dg/range-test-1.c: New test.\n\t* g++.dg/opt/range-test-1.C: New test.\n\nFrom-SVN: r83369", "tree": {"sha": "a3d6ae542615df88c6d0ba17800fb0f3dd2fbf4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3d6ae542615df88c6d0ba17800fb0f3dd2fbf4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1af8299421eb7261ddcadf3630cf6dfa6c32099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1af8299421eb7261ddcadf3630cf6dfa6c32099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1af8299421eb7261ddcadf3630cf6dfa6c32099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1af8299421eb7261ddcadf3630cf6dfa6c32099/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "caf2523d6d984c1c46b1c5056b835448f4fc02a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf2523d6d984c1c46b1c5056b835448f4fc02a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf2523d6d984c1c46b1c5056b835448f4fc02a9"}], "stats": {"total": 511, "additions": 504, "deletions": 7}, "files": [{"sha": "069c48e0f9b9129074c098e2c0bd7b1791dfa535", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1af8299421eb7261ddcadf3630cf6dfa6c32099", "patch": "@@ -1,3 +1,11 @@\n+2004-06-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* fold-const.c (build_range_check): If !in_p and recursive call\n+\tfails, exit immediately.  If high - low overflows and etype is\n+\ta signed type, retry with unsigned etype.\n+\t(merge_ranges): If !in0_p and !in1_p, handle even range2 adjacent\n+\tto range1 at TYPE_MAX_VALUE and TYPE_MIN_VALUE.\n+\n 2004-06-18  Richard Henderson  <rth@redhat.com>\n \n \t* c-gimplify.c (gimplify_condition): Remove."}, {"sha": "00fd1346e2c65c51d675666fc48669cc9a73102d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 111, "deletions": 7, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e1af8299421eb7261ddcadf3630cf6dfa6c32099", "patch": "@@ -3776,17 +3776,22 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \f\n /* Given a range, LOW, HIGH, and IN_P, an expression, EXP, and a result\n    type, TYPE, return an expression to test if EXP is in (or out of, depending\n-   on IN_P) the range.  */\n+   on IN_P) the range.  Return 0 if the test couldn't be created.  */\n \n static tree\n build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n {\n   tree etype = TREE_TYPE (exp);\n   tree value;\n \n-  if (! in_p\n-      && (0 != (value = build_range_check (type, exp, 1, low, high))))\n-    return invert_truthvalue (value);\n+  if (! in_p)\n+    {\n+      value = build_range_check (type, exp, 1, low, high);\n+      if (value != 0)\n+        return invert_truthvalue (value);\n+\n+      return 0;\n+    }\n \n   if (low == 0 && high == 0)\n     return fold_convert (type, integer_one_node);\n@@ -3842,8 +3847,39 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t}\n     }\n \n-  if (0 != (value = const_binop (MINUS_EXPR, high, low, 0))\n-      && ! TREE_OVERFLOW (value))\n+  value = const_binop (MINUS_EXPR, high, low, 0);\n+  if (value != 0 && TREE_OVERFLOW (value) && ! TYPE_UNSIGNED (etype))\n+    {\n+      tree utype, minv, maxv;\n+\n+      /* Check if (unsigned) INT_MAX + 1 == (unsigned) INT_MIN\n+\t for the type in question, as we rely on this here.  */\n+      switch (TREE_CODE (etype))\n+\t{\n+\tcase INTEGER_TYPE:\n+\tcase ENUMERAL_TYPE:\n+\tcase CHAR_TYPE:\n+\t  utype = lang_hooks.types.unsigned_type (etype);\n+\t  maxv = fold_convert (utype, TYPE_MAX_VALUE (etype));\n+\t  maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,\n+\t\t\t      integer_one_node, 1);\n+\t  minv = fold_convert (utype, TYPE_MIN_VALUE (etype));\n+\t  if (integer_zerop (range_binop (NE_EXPR, integer_type_node,\n+\t\t\t\t\t  minv, 1, maxv, 1)))\n+\t    {\n+\t      etype = utype;\n+\t      high = fold_convert (etype, high);\n+\t      low = fold_convert (etype, low);\n+\t      exp = fold_convert (etype, exp);\n+\t      value = const_binop (MINUS_EXPR, high, low, 0);\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  if (value != 0 && ! TREE_OVERFLOW (value))\n     return build_range_check (type,\n \t\t\t      fold (build2 (MINUS_EXPR, etype, exp, low)),\n \t\t\t      1, fold_convert (etype, integer_zero_node),\n@@ -3973,7 +4009,75 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \t\t\t\t\t 1, low1, 0)))\n \t    in_p = 0, low = low0, high = high1;\n \t  else\n-\t    return 0;\n+\t    {\n+\t      /* Canonicalize - [min, x] into - [-, x].  */\n+\t      if (low0 && TREE_CODE (low0) == INTEGER_CST)\n+\t\tswitch (TREE_CODE (TREE_TYPE (low0)))\n+\t\t  {\n+\t\t  case ENUMERAL_TYPE:\n+\t\t    if (TYPE_PRECISION (TREE_TYPE (low0))\n+\t\t\t!= GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (low0))))\n+\t\t      break;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case INTEGER_TYPE:\n+\t\t  case CHAR_TYPE:\n+\t\t    if (tree_int_cst_equal (low0,\n+\t\t\t\t\t    TYPE_MIN_VALUE (TREE_TYPE (low0))))\n+\t\t      low0 = 0;\n+\t\t    break;\n+\t\t  case POINTER_TYPE:\n+\t\t    if (TYPE_UNSIGNED (TREE_TYPE (low0))\n+\t\t\t&& integer_zerop (low0))\n+\t\t      low0 = 0;\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\n+\t      /* Canonicalize - [x, max] into - [x, -].  */\n+\t      if (high1 && TREE_CODE (high1) == INTEGER_CST)\n+\t\tswitch (TREE_CODE (TREE_TYPE (high1)))\n+\t\t  {\n+\t\t  case ENUMERAL_TYPE:\n+\t\t    if (TYPE_PRECISION (TREE_TYPE (high1))\n+\t\t\t!= GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (high1))))\n+\t\t      break;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case INTEGER_TYPE:\n+\t\t  case CHAR_TYPE:\n+\t\t    if (tree_int_cst_equal (high1,\n+\t\t\t\t\t    TYPE_MAX_VALUE (TREE_TYPE (high1))))\n+\t\t      high1 = 0;\n+\t\t    break;\n+\t\t  case POINTER_TYPE:\n+\t\t    if (TYPE_UNSIGNED (TREE_TYPE (high1))\n+\t\t\t&& integer_zerop (range_binop (PLUS_EXPR, NULL_TREE,\n+\t\t\t\t\t\t       high1, 1,\n+\t\t\t\t\t\t       integer_one_node, 1)))\n+\t\t      high1 = 0;\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\n+\t      /* The ranges might be also adjacent between the maximum and\n+\t         minimum values of the given type.  For\n+\t         - [{min,-}, x] and - [y, {max,-}] ranges where x + 1 < y\n+\t         return + [x + 1, y - 1].  */\n+\t      if (low0 == 0 && high1 == 0)\n+\t        {\n+\t\t  low = range_binop (PLUS_EXPR, NULL_TREE, high0, 1,\n+\t\t\t\t     integer_one_node, 1);\n+\t\t  high = range_binop (MINUS_EXPR, NULL_TREE, low1, 0,\n+\t\t\t\t      integer_one_node, 0);\n+\t\t  if (low == 0 || high == 0)\n+\t\t    return 0;\n+\n+\t\t  in_p = 1;\n+\t\t}\n+\t      else\n+\t\treturn 0;\n+\t    }\n \t}\n       else if (subset)\n \tin_p = 0, low = low0, high = high0;"}, {"sha": "f7e42f1587d62354442bf75a25f2b5525f8dd638", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1af8299421eb7261ddcadf3630cf6dfa6c32099", "patch": "@@ -1,3 +1,8 @@\n+2004-06-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/range-test-1.c: New test.\n+\t* g++.dg/opt/range-test-1.C: New test.\n+\n 2004-06-17  Richard Henderson  <rth@redhat.com>\n \n \t* objc.dg/sync-1.m: New."}, {"sha": "9391748837e5c257e9bf46550447e134368a1400", "filename": "gcc/testsuite/g++.dg/opt/range-test-1.C", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Frange-test-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Frange-test-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Frange-test-1.C?ref=e1af8299421eb7261ddcadf3630cf6dfa6c32099", "patch": "@@ -0,0 +1,212 @@\n+// Test fold-const.c (fold_range_test) optimizations.\n+// { dg-do run } */\n+// { dg-options \"-O2\" } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <limits.h>\n+\n+#if (INT_MAX == 2147483647) && (INT_MIN == -2147483648) \\\n+    && (SCHAR_MIN == -128) && (SCHAR_MAX == 127) \\\n+    && (UCHAR_MIN == 0) && (UCHAR_MAX == 255)\n+\n+#ifndef T\n+\n+enum integers\n+{\n+  int_smallest = INT_MIN,\n+  int_2ndsmallest = INT_MIN + 1,\n+  int_3rdsmallest = INT_MIN + 2,\n+  int_minus2 = -2,\n+  int_minus1 = -1,\n+  int_zero = 0,\n+  int_one = 1,\n+  int_two = 2,\n+  int_3rdlargest = INT_MAX - 2,\n+  int_2ndlargest = INT_MAX - 1,\n+  int_largest = INT_MAX\n+};\n+\n+enum smallenum\n+{\n+  smalle_minus4 = -4,\n+  smalle_minus3 = -3,\n+  smalle_minus2 = -2,\n+  smalle_minus1 = -1,\n+  smalle_zero = 0,\n+  smalle_one = 1,\n+  smalle_two = 2,\n+  smalle_three = 3\n+};\n+\n+enum enum2\n+{\n+  enum2_two = 2,\n+  enum2_three = 3,\n+  enum2_four = 4,\n+  enum2_five = 5\n+};\n+\n+enum enum3\n+{\n+  enum3_zero,\n+  enum3_one,\n+  enum3_two,\n+  enum3_three,\n+  enum3_four,\n+  enum3_five,\n+  enum3_six,\n+  enum3_seven\n+};\n+\n+int var;\n+void\n+check ()\n+{\n+  ++var;\n+}\n+\n+#define T(IDX, TYPE, TEST, YESARR, NOARR)\t\t\t\t\\\n+void __attribute__((noinline))\t\t\t\t\t\t\\\n+test##IDX (TYPE x)\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TEST)\t\t\t\t\t\t\t\t\\\n+    check ();\t\t\t\t\t\t\t\t\\\n+}\n+#include \"range-test-1.C\"\n+#undef T\n+\n+int\n+main ()\n+{\n+  int i, fails = 0;\n+\n+#define C ,\n+#define T(IDX, TYPE, TEST, YESARR, NOARR)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    static TYPE yesarr##IDX [] = YESARR;\t\t\t\t\\\n+    static TYPE noarr##IDX [] = NOARR;\t\t\t\t\t\\\n+    for (i = 0; i < (int) (sizeof (yesarr##IDX) / sizeof (TYPE)); ++i)\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tvar = 0;\t\t\t\t\t\t\t\\\n+\ttest##IDX (yesarr##IDX [i]);\t\t\t\t\t\\\n+\tif (var != 1)\t\t\t\t\t\t\t\\\n+\t  printf (\"test\" #IDX \" failed for yesarr [%u]\\n\", i), ++fails;\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    var = 0;\t\t\t\t\t\t\t\t\\\n+    for (i = 0; i < (int) (sizeof (noarr##IDX) / sizeof (TYPE)); ++i)\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ttest##IDX (noarr##IDX [i]);\t\t\t\t\t\\\n+\tif (var != 0)\t\t\t\t\t\t\t\\\n+\t  printf (\"test\" #IDX \" failed for noarr [%u]\\n\", i), ++fails;\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+#include \"range-test-1.C\"\n+#undef T\n+\n+  if (fails)\n+    abort ();\n+\n+  exit (0);\n+}\n+\n+#else\n+\n+/* Use `C' instead of `,' below to separate array entries.  */\n+\n+/* These ought to be all optimized into single comparison.  */\n+T(1, unsigned int, x == 0 || x == 1,\n+  { 0 C 1 }, { -1U C 2 C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(2, unsigned int, x == 0 || x == -1U || x == -2U,\n+  { 0 C -1U C -2U }, { -3U C -6U C 1 C 2 C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(3, unsigned int, x == 0 || x == 1 || x == 2,\n+  { 0 C 1 C 2 }, { -3U C -6U C -1U C -2U C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(4, unsigned int, x == 3 || x == 4 || x == 5 || x == 6,\n+  { 3 C 4 C 5 C 6 }, { -3U C 0 C 1 C 2 C 7 C 8 C 12 C 0x7fffffff C 0x80000000 })\n+T(5, unsigned int, x == -3U || x == -4U || x == -5U || x == -6U,\n+  { -3U C -4U C -5U C -6U }, { -7U C -8U C -2U C -1U C 1 C 2 C 0x7fffffff C 0x80000000 })\n+T(6, unsigned int, x == -3U || x == -4U || x == -5U,\n+  { -3U C -4U C -5U }, { -6U C -7U C -8U C -2U C -1U C 1 C 2 C 0x7fffffff C 0x80000000 })\n+T(7, char *, x == (char *) -3UL || x == (char *) -4UL || x == (char *) -5UL,\n+  { (char *) -3UL C (char *) -4UL C (char *) -5UL },\n+  { (char *) -6UL C (char *) -20UL C (char *) -2UL C (char *) -1UL C (char *) 0\n+    C (char *) 1UL C (char *) 35UL C (char *) 0x7fffffffUL C (char *) 0x80000000UL })\n+T(8, unsigned long, x == -2UL || x == -1UL || x == 0,\n+  { 0 C -1UL C -2UL }, { -3UL C -6UL C 1 C 2 C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(9, unsigned long, x >= -4UL || x <= 8,\n+  { -4UL C -3UL C -2UL C -1UL C 0 C 1 C 2 C 3 C 4 C 5 C 6 C 7 C 8 },\n+  { -7UL C -5UL C 9 C 10 C 61 C 127 C 0x7fffffff C 0x80000000 })\n+T(10, signed char, x == 0 || x == -1 || x == -2 || x == -3,\n+  { 0 C -1 C -2 C -3 }, { -4 C -5 C 1 C 2 C 3 C 35 C -24 })\n+T(11, int, x == 0 || x == 1,\n+  { 0 C 1 }, { -1 C 2 C 12 C 35 C INT_MAX C INT_MIN })\n+T(12, int, x == 0 || x == -1 || x == -2,\n+  { 0 C -1 C -2 }, { -3 C -6 C 1 C 2 C 12 C 35 C INT_MAX C INT_MIN })\n+T(13, int, x == 0 || x == 1 || x == 2,\n+  { 0 C 1 C 2 }, { -3 C -6 C -1 C -2 C 12 C 35 C INT_MAX C INT_MIN })\n+T(14, int, x == 3 || x == 4 || x == 5 || x == 6,\n+  { 3 C 4 C 5 C 6 }, { -3 C 0 C 1 C 2 C 7 C 8 C 12 C INT_MAX C INT_MIN })\n+T(15, int, x == -3 || x == -4 || x == -5 || x == -6,\n+  { -3 C -4 C -5 C -6 }, { -7 C -8 C -2 C -1 C 1 C 2 C INT_MAX C INT_MIN })\n+T(16, int, x == -3 || x == -4 || x == -5,\n+  { -3 C -4 C -5 }, { -6 C -7 C -8 C -2 C -1 C 1 C 2 C INT_MAX C INT_MIN })\n+T(17, unsigned int, (x >= -8U && x <= -3U) || x == -2U || x == -1U || x == 0 || x == 1 || x == 2,\n+  { -8U C -7U C -6U C -5U C -4U C -3U C -2U C -1U C 0 C 1 C 2 },\n+  { -9U C -10U C 3 C 4 C 12 C -54U C INT_MAX C INT_MIN })\n+T(18, int, (x >= -8 && x <= -3) || x == -2 || x == -1 || x == 0 || x == 1 || x == 2,\n+  { -8 C -7 C -6 C -5 C -4 C -3 C -2 C -1 C 0 C 1 C 2 },\n+  { -9 C -10 C 3 C 4 C 12 C -54 C INT_MAX C INT_MIN })\n+T(19, unsigned long, x <= 16 || (x >= 18 && x <= -1UL),\n+  { -3UL C -6UL C -1UL C 0 C 1 C 2 C 12 C 15 C 16 C 18 C 19 C 35 C 0x7fffffff\n+    C 0x80000000 }, { 17 })\n+T(20, char *, x == (char *) -1UL || x == 0,\n+  { (char *) -1UL C 0 }, { (char *) -6UL C (char *) -20UL C (char *) -2UL\n+    C (char *) 1UL C (char *) 35UL C (char *) 0x7fffffffUL C (char *) 0x80000000UL })\n+T(21, integers, x == int_zero || x == int_one,\n+  { int_zero C int_one }, { int_minus1 C int_two C int_largest C int_smallest })\n+T(22, int, x == INT_MIN || x == INT_MAX,\n+  { INT_MIN C INT_MAX },\n+  { -1 C 0 C 1 C INT_MAX - 1 C INT_MAX - 2 C INT_MIN + 1 C INT_MIN + 2 })\n+T(23, int, x == INT_MIN + 1 || x == INT_MIN + 2 || x == INT_MIN || x == INT_MAX,\n+  { INT_MIN + 1 C INT_MIN + 2 C INT_MIN C INT_MAX },\n+  { -1 C 0 C 1 C INT_MAX - 1 C INT_MAX - 2 C INT_MIN + 3 C INT_MIN + 4 })\n+T(24, signed char, x == SCHAR_MIN || x == SCHAR_MAX,\n+  { SCHAR_MIN C SCHAR_MAX },\n+  { -1 C 0 C 1 C SCHAR_MAX - 1 C SCHAR_MAX - 2 C SCHAR_MIN + 1 C SCHAR_MIN + 2 })\n+T(25, integers, x == int_smallest || x == int_largest,\n+  { int_smallest C int_largest }, { int_minus1 C int_zero C int_one\n+    C int_2ndsmallest C int_2ndlargest C int_3rdsmallest C int_3rdlargest })\n+\n+/* These should be optimized into unconditional jumps.  */\n+T(o1, unsigned long, x <= 16 || (x >= 17 && x <= -1UL),\n+  { -3UL C -6UL C -1UL C 0 C 1 C 2 C 12 C 15 C 16 C 17 C 18 C 19 C 35 C 0x7fffffff\n+    C 0x80000000 }, { })\n+T(o2, unsigned long, x <= -3UL || (x == -2UL || x == -1UL),\n+  { -3UL C -6UL C -1UL C 0 C 1 C 2 C 12 C 15 C 16 C 17 C 18 C 19 C 35 C 0x7fffffff\n+    C 0x80000000 }, { })\n+\n+/* These should be eventually optimized into a single comparison.  */\n+T(td1, unsigned char, x == 0 || x == 4 || x == 1 || x == 5 || x == 2 || x == 6 || x == 3,\n+  { 0 C 1 C 2 C 3 C 4 C 5 C 6 }, { 7 C 8 C 127 C 128 C 254 C 255 })\n+\n+/* These should not be optimized into a single comparison.  */\n+T(n1, smallenum, x == smalle_minus4 || x == smalle_three,\n+  { smalle_minus4 C smalle_three }, { smalle_minus3 C smalle_minus2 C smalle_minus1\n+    C smalle_zero C smalle_one C smalle_two })\n+T(n2, enum2, x == enum2_two || x == enum2_five,\n+  { enum2_two C enum2_five }, { enum2_three C enum2_four })\n+T(n3, enum3, x == enum3_zero || x == enum3_seven,\n+  { enum3_zero C enum3_seven }, { enum3_one C enum3_two C enum3_three C enum3_four\n+    C enum3_five C enum3_six })\n+\n+#endif\n+\n+#else\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}\n+\n+#endif"}, {"sha": "93a90ac7187b5849351d64c1a101472e23d9cc0c", "filename": "gcc/testsuite/gcc.dg/range-test-1.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ftestsuite%2Fgcc.dg%2Frange-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1af8299421eb7261ddcadf3630cf6dfa6c32099/gcc%2Ftestsuite%2Fgcc.dg%2Frange-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frange-test-1.c?ref=e1af8299421eb7261ddcadf3630cf6dfa6c32099", "patch": "@@ -0,0 +1,168 @@\n+/* Test fold-const.c (fold_range_test) optimizations.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <limits.h>\n+\n+#if (INT_MAX == 2147483647) && (INT_MIN == -2147483648) \\\n+    && (SCHAR_MIN == -128) && (SCHAR_MAX == 127) \\\n+    && (UCHAR_MIN == 0) && (UCHAR_MAX == 255)\n+\n+#ifndef T\n+\n+enum integers\n+{\n+  int_smallest = INT_MIN,\n+  int_2ndsmallest = INT_MIN + 1,\n+  int_3rdsmallest = INT_MIN + 2,\n+  int_minus2 = -2,\n+  int_minus1 = -1,\n+  int_zero = 0,\n+  int_one = 1,\n+  int_two = 2,\n+  int_3rdlargest = INT_MAX - 2,\n+  int_2ndlargest = INT_MAX - 1,\n+  int_largest = INT_MAX\n+};\n+\n+int var;\n+void\n+check (void)\n+{\n+  ++var;\n+}\n+\n+#define T(IDX, TYPE, TEST, YESARR, NOARR)\t\t\t\t\\\n+void __attribute__((noinline))\t\t\t\t\t\t\\\n+test##IDX (TYPE x)\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TEST)\t\t\t\t\t\t\t\t\\\n+    check ();\t\t\t\t\t\t\t\t\\\n+}\n+#include \"range-test-1.c\"\n+#undef T\n+\n+int\n+main (void)\n+{\n+  int i, fails = 0;\n+\n+#define C ,\n+#define T(IDX, TYPE, TEST, YESARR, NOARR)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    static TYPE yesarr##IDX [] = YESARR;\t\t\t\t\\\n+    static TYPE noarr##IDX [] = NOARR;\t\t\t\t\t\\\n+    for (i = 0; i < (int) (sizeof (yesarr##IDX) / sizeof (TYPE)); ++i)\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tvar = 0;\t\t\t\t\t\t\t\\\n+\ttest##IDX (yesarr##IDX [i]);\t\t\t\t\t\\\n+\tif (var != 1)\t\t\t\t\t\t\t\\\n+\t  printf (\"test\" #IDX \" failed for yesarr [%u]\\n\", i), ++fails;\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    var = 0;\t\t\t\t\t\t\t\t\\\n+    for (i = 0; i < (int) (sizeof (noarr##IDX) / sizeof (TYPE)); ++i)\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ttest##IDX (noarr##IDX [i]);\t\t\t\t\t\\\n+\tif (var != 0)\t\t\t\t\t\t\t\\\n+\t  printf (\"test\" #IDX \" failed for noarr [%u]\\n\", i), ++fails;\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+#include \"range-test-1.c\"\n+#undef T\n+\n+  if (fails)\n+    abort ();\n+\n+  exit (0);\n+}\n+\n+#else\n+\n+/* Use `C' instead of `,' below to separate array entries.  */\n+\n+/* These ought to be all optimized into single comparison.  */\n+T(1, unsigned int, x == 0 || x == 1,\n+  { 0 C 1 }, { -1U C 2 C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(2, unsigned int, x == 0 || x == -1U || x == -2U,\n+  { 0 C -1U C -2U }, { -3U C -6U C 1 C 2 C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(3, unsigned int, x == 0 || x == 1 || x == 2,\n+  { 0 C 1 C 2 }, { -3U C -6U C -1U C -2U C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(4, unsigned int, x == 3 || x == 4 || x == 5 || x == 6,\n+  { 3 C 4 C 5 C 6 }, { -3U C 0 C 1 C 2 C 7 C 8 C 12 C 0x7fffffff C 0x80000000 })\n+T(5, unsigned int, x == -3U || x == -4U || x == -5U || x == -6U,\n+  { -3U C -4U C -5U C -6U }, { -7U C -8U C -2U C -1U C 1 C 2 C 0x7fffffff C 0x80000000 })\n+T(6, unsigned int, x == -3U || x == -4U || x == -5U,\n+  { -3U C -4U C -5U }, { -6U C -7U C -8U C -2U C -1U C 1 C 2 C 0x7fffffff C 0x80000000 })\n+T(7, char *, x == (char *) -3UL || x == (char *) -4UL || x == (char *) -5UL,\n+  { (char *) -3UL C (char *) -4UL C (char *) -5UL },\n+  { (char *) -6UL C (char *) -20UL C (char *) -2UL C (char *) -1UL C (char *) 0\n+    C (char *) 1UL C (char *) 35UL C (char *) 0x7fffffffUL C (char *) 0x80000000UL })\n+T(8, unsigned long, x == -2UL || x == -1UL || x == 0,\n+  { 0 C -1UL C -2UL }, { -3UL C -6UL C 1 C 2 C 12 C 35 C 0x7fffffff C 0x80000000 })\n+T(9, unsigned long, x >= -4UL || x <= 8,\n+  { -4UL C -3UL C -2UL C -1UL C 0 C 1 C 2 C 3 C 4 C 5 C 6 C 7 C 8 },\n+  { -7UL C -5UL C 9 C 10 C 61 C 127 C 0x7fffffff C 0x80000000 })\n+T(10, signed char, x == 0 || x == -1 || x == -2 || x == -3,\n+  { 0 C -1 C -2 C -3 }, { -4 C -5 C 1 C 2 C 3 C 35 C -24 })\n+T(11, int, x == 0 || x == 1,\n+  { 0 C 1 }, { -1 C 2 C 12 C 35 C INT_MAX C INT_MIN })\n+T(12, int, x == 0 || x == -1 || x == -2,\n+  { 0 C -1 C -2 }, { -3 C -6 C 1 C 2 C 12 C 35 C INT_MAX C INT_MIN })\n+T(13, int, x == 0 || x == 1 || x == 2,\n+  { 0 C 1 C 2 }, { -3 C -6 C -1 C -2 C 12 C 35 C INT_MAX C INT_MIN })\n+T(14, int, x == 3 || x == 4 || x == 5 || x == 6,\n+  { 3 C 4 C 5 C 6 }, { -3 C 0 C 1 C 2 C 7 C 8 C 12 C INT_MAX C INT_MIN })\n+T(15, int, x == -3 || x == -4 || x == -5 || x == -6,\n+  { -3 C -4 C -5 C -6 }, { -7 C -8 C -2 C -1 C 1 C 2 C INT_MAX C INT_MIN })\n+T(16, int, x == -3 || x == -4 || x == -5,\n+  { -3 C -4 C -5 }, { -6 C -7 C -8 C -2 C -1 C 1 C 2 C INT_MAX C INT_MIN })\n+T(17, unsigned int, (x >= -8U && x <= -3U) || x == -2U || x == -1U || x == 0 || x == 1 || x == 2,\n+  { -8U C -7U C -6U C -5U C -4U C -3U C -2U C -1U C 0 C 1 C 2 },\n+  { -9U C -10U C 3 C 4 C 12 C -54U C INT_MAX C INT_MIN })\n+T(18, int, (x >= -8 && x <= -3) || x == -2 || x == -1 || x == 0 || x == 1 || x == 2,\n+  { -8 C -7 C -6 C -5 C -4 C -3 C -2 C -1 C 0 C 1 C 2 },\n+  { -9 C -10 C 3 C 4 C 12 C -54 C INT_MAX C INT_MIN })\n+T(19, unsigned long, (x >= 0 && x <= 16) || (x >= 18 && x <= -1UL),\n+  { -3UL C -6UL C -1UL C 0 C 1 C 2 C 12 C 15 C 16 C 18 C 19 C 35 C 0x7fffffff\n+    C 0x80000000 }, { 17 })\n+T(20, char *, x == (char *) -1UL || x == 0,\n+  { (char *) -1UL C 0 }, { (char *) -6UL C (char *) -20UL C (char *) -2UL\n+    C (char *) 1UL C (char *) 35UL C (char *) 0x7fffffffUL C (char *) 0x80000000UL })\n+T(21, enum integers, x == int_zero || x == int_one,\n+  { int_zero C int_one }, { int_minus1 C int_two C 12 C 35 C int_largest C int_smallest })\n+T(22, int, x == INT_MIN || x == INT_MAX,\n+  { INT_MIN C INT_MAX },\n+  { -1 C 0 C 1 C INT_MAX - 1 C INT_MAX - 2 C INT_MIN + 1 C INT_MIN + 2 })\n+T(23, int, x == INT_MIN + 1 || x == INT_MIN + 2 || x == INT_MIN || x == INT_MAX,\n+  { INT_MIN + 1 C INT_MIN + 2 C INT_MIN C INT_MAX },\n+  { -1 C 0 C 1 C INT_MAX - 1 C INT_MAX - 2 C INT_MIN + 3 C INT_MIN + 4 })\n+T(24, signed char, x == SCHAR_MIN || x == SCHAR_MAX,\n+  { SCHAR_MIN C SCHAR_MAX },\n+  { -1 C 0 C 1 C SCHAR_MAX - 1 C SCHAR_MAX - 2 C SCHAR_MIN + 1 C SCHAR_MIN + 2 })\n+T(25, enum integers, x == int_smallest || x == int_largest,\n+  { int_smallest C int_largest }, { int_minus1 C int_zero C int_one\n+    C int_2ndsmallest C int_2ndlargest C int_3rdsmallest C int_3rdlargest })\n+\n+/* This should be optimized into unconditional jump.  */\n+T(o1, unsigned long, (x >= 0 && x <= 16) || (x >= 17 && x <= -1UL),\n+  { -3UL C -6UL C -1UL C 0 C 1 C 2 C 12 C 15 C 16 C 17 C 18 C 19 C 35 C 0x7fffffff\n+    C 0x80000000 }, { })\n+T(o2, unsigned long, (x >= 0 && x <= -3UL) || (x == -2UL || x == -1UL),\n+  { -3UL C -6UL C -1UL C 0 C 1 C 2 C 12 C 15 C 16 C 17 C 18 C 19 C 35 C 0x7fffffff\n+    C 0x80000000 }, { })\n+\n+/* This should be eventually optimized into a single comparison.  */\n+T(td1, unsigned char, x == 0 || x == 4 || x == 1 || x == 5 || x == 2 || x == 6 || x == 3,\n+  { 0 C 1 C 2 C 3 C 4 C 5 C 6 }, { 7 C 8 C 127 C 128 C 254 C 255 })\n+\n+#endif\n+\n+#else\n+int\n+main (void)\n+{\n+  return 0;\n+}\n+#endif"}]}