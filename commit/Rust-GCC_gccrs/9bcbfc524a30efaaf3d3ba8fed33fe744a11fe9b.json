{"sha": "9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJjYmZjNTI0YTMwZWZhYWYzZDNiYThmZWQzM2ZlNzQ0YTExZmU5Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-22T19:16:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-22T19:16:03Z"}, "message": "predict.c (estimate_probability): Examine both sides of a branch for no exits.\n\n        * predict.c (estimate_probability): Examine both sides of\n        a branch for no exits.  Use 90% not 50% for predict taken.\n        Reorg for one copy of note generation code.\n\nFrom-SVN: r33343", "tree": {"sha": "b977e3494c1f74abe0d48b035151221824fcd3a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b977e3494c1f74abe0d48b035151221824fcd3a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b/comments", "author": null, "committer": null, "parents": [{"sha": "b2433fcde0f08059731043f5af3d1ad687a1fbba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2433fcde0f08059731043f5af3d1ad687a1fbba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2433fcde0f08059731043f5af3d1ad687a1fbba"}], "stats": {"total": 80, "additions": 48, "deletions": 32}, "files": [{"sha": "4b12657cebfd67c09a8a90308e1c68b7e35d5992", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b", "patch": "@@ -1,3 +1,9 @@\n+2000-04-22  Richard Henderson  <rth@cygnus.com>\n+\n+\t* predict.c (estimate_probability): Examine both sides of\n+\ta branch for no exits.  Use 90% not 50% for predict taken.\n+\tReorg for one copy of note generation code.\n+\n 2000-04-22  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (mark_used_reg): Hack around rs6000 eliminable pic reg."}, {"sha": "6900f0ed217d8f02e0653a42dd9edae8f87cc9b9", "filename": "gcc/predict.c", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9bcbfc524a30efaaf3d3ba8fed33fe744a11fe9b", "patch": "@@ -103,34 +103,32 @@ estimate_probability (loops_info)\n     {\n       rtx last_insn = BLOCK_END (i);\n       rtx cond, earliest;\n-      int prob = 0;\n+      int prob;\n       edge e;\n \n       if (GET_CODE (last_insn) != JUMP_INSN\n \t  || ! condjump_p (last_insn) || simplejump_p (last_insn))\n \tcontinue;\n+\n       if (find_reg_note (last_insn, REG_BR_PROB, 0))\n \tcontinue;\n+\n       cond = get_condition (last_insn, &earliest);\n       if (! cond)\n \tcontinue;\n \n-      /* If the jump branches around a block with no successors,\n-\t predict it to be taken.  */\n-      prob = 0;\n+      /* If one of the successor blocks has no successors, predict\n+\t that side not taken.  */\n+      /* ??? Ought to do the same for any subgraph with no exit.  */\n       for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n-\tif ((e->flags & EDGE_FALLTHRU) && e->dest->succ == NULL)\n+\tif (e->dest->succ == NULL)\n \t  {\n-\t    prob = REG_BR_PROB_BASE;\n-\t    break;\n+\t    if (e->flags & EDGE_FALLTHRU)\n+\t      prob = REG_BR_PROB_BASE;\n+\t    else\n+\t      prob = 0;\n+\t    goto emitnote;\n \t  }\n-      if (prob)\n-\t{\n-\t  REG_NOTES (last_insn)\n-\t    = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t\t REG_NOTES (last_insn));\n-\t  continue;\n-\t}\n \n       /* Try \"pointer heuristic.\"\n \t A comparison ptr == 0 is predicted as false.\n@@ -143,25 +141,25 @@ estimate_probability (loops_info)\n \t      && (XEXP (cond, 1) == const0_rtx\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n \t\t      && REGNO_POINTER_FLAG (REGNO (XEXP (cond, 1))))))\n-\t    prob = REG_BR_PROB_BASE / 10;\n+\t    {\n+\t      prob = REG_BR_PROB_BASE / 10;\n+\t      goto emitnote;\n+\t    }\n \t  break;\n \tcase NE:\n \t  if (GET_CODE (XEXP (cond, 0)) == REG\n \t      && REGNO_POINTER_FLAG (REGNO (XEXP (cond, 0)))\n \t      && (XEXP (cond, 1) == const0_rtx\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n \t\t      && REGNO_POINTER_FLAG (REGNO (XEXP (cond, 1))))))\n-\t    prob = REG_BR_PROB_BASE / 2;\n+\t    {\n+\t      prob = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 10);\n+\t      goto emitnote;\n+\t    }\n \t  break;\n+\n \tdefault:\n-\t  prob = 0;\n-\t}\n-      if (prob)\n-\t{\n-\t  REG_NOTES (last_insn)\n-\t    = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t\t REG_NOTES (last_insn));\n-\t  continue;\n+\t  break;\n \t}\n \n       /* Try \"opcode heuristic.\"\n@@ -172,30 +170,42 @@ estimate_probability (loops_info)\n \t{\n \tcase CONST_INT:\n \t  /* Unconditional branch.  */\n-\t  prob = REG_BR_PROB_BASE / 2;\n-\t  break;\n+\t  prob = (cond == const0_rtx ? 0 : REG_BR_PROB_BASE);\n+\t  goto emitnote;\n+\n \tcase EQ:\n \t  prob = REG_BR_PROB_BASE / 10;\n-\t  break;\n+\t  goto emitnote;\n \tcase NE:\n-\t  prob = REG_BR_PROB_BASE / 2;\n-\t  break;\n+\t  prob = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 10);\n+\t  goto emitnote;\n \tcase LE:\n \tcase LT:\n \t  if (XEXP (cond, 1) == const0_rtx)\n-\t    prob = REG_BR_PROB_BASE / 10;\n+\t    {\n+\t      prob = REG_BR_PROB_BASE / 10;\n+\t      goto emitnote;\n+\t    }\n \t  break;\n \tcase GE:\n \tcase GT:\n \t  if (XEXP (cond, 1) == const0_rtx\n \t      || (GET_CODE (XEXP (cond, 1)) == CONST_INT\n \t\t  && INTVAL (XEXP (cond, 1)) == -1))\n-\t    prob = REG_BR_PROB_BASE / 2;\n+\t    {\n+\t      prob = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 10);\n+\t      goto emitnote;\n+\t    }\n \t  break;\n \n \tdefault:\n-\t  prob = 0;\n+\t  break;\n \t}\n+\n+      /* If we havn't chosen something by now, predict 50-50.  */\n+      prob = REG_BR_PROB_BASE / 2;\n+\n+    emitnote:\n       REG_NOTES (last_insn)\n \t= gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n \t\t\t     REG_NOTES (last_insn));"}]}