{"sha": "fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNiOTM2M2ViOWJhOTRiOGUxNTc0NDRkYzdhYzJjOTNlNjlkNmM1OA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2015-12-15T03:33:53Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2015-12-15T03:33:53Z"}, "message": "Fix PR c++/21802 (two-stage name lookup fails for operators)\n\ngcc/cp/ChangeLog:\n\n\tPR c++/21802\n\tPR c++/53223\n\t* cp-tree.h (cp_tree_code_length): Declare.\n\t(build_min_non_dep_op_overload): Declare.\n\t* tree.c (cp_tree_code_length): Define.\n\t(build_min_non_dep_op_overload): Define.\n\t(build_win_non_dep_call_vec): Copy the KOENIG_LOOKUP_P flag.\n\t* typeck.c (build_x_indirect_ref): Use\n\tbuild_min_non_dep_op_overload when the given expression\n\thas been resolved to an operator overload.\n\t(build_x_binary_op): Likewise.\n\t(build_x_array_ref): Likewise.\n\t(build_x_unary_op): Likewise.\n\t(build_x_compound_expr): Likewise.\n\t(build_x_modify_expr): Likewise.\n\t* decl2.c (grok_array_decl): Likewise.\n\t* call.c (build_new_op_1): If during template processing we\n\tchose an operator overload that is a hidden friend function, set\n\tthe call's KOENIG_LOOKUP_P flag to 1.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/21802\n\tPR c++/53223\n\t* g++.dg/cpp0x/pr53223.C: New test.\n\t* g++.dg/lookup/pr21802.C: New test.\n\t* g++.dg/lookup/two-stage4.C: Remove XFAIL.\n\nFrom-SVN: r231640", "tree": {"sha": "91059fe54587a7f7fd54738db81ccbb8f1b6cdfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91059fe54587a7f7fd54738db81ccbb8f1b6cdfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/comments", "author": null, "committer": null, "parents": [{"sha": "8d3586e4e2426a2ae77c082134be67fe036c87a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d3586e4e2426a2ae77c082134be67fe036c87a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d3586e4e2426a2ae77c082134be67fe036c87a7"}], "stats": {"total": 572, "additions": 548, "deletions": 24}, "files": [{"sha": "0598be5a2f54db48759da760925931748c11fcda", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -1,3 +1,25 @@\n+2015-12-15  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\tPR c++/21802\n+\tPR c++/53223\n+\t* cp-tree.h (cp_tree_code_length): Declare.\n+\t(build_min_non_dep_op_overload): Declare.\n+\t* tree.c (cp_tree_code_length): Define.\n+\t(build_min_non_dep_op_overload): Define.\n+\t(build_win_non_dep_call_vec): Copy the KOENIG_LOOKUP_P flag.\n+\t* typeck.c (build_x_indirect_ref): Use\n+\tbuild_min_non_dep_op_overload when the given expression\n+\thas been resolved to an operator overload.\n+\t(build_x_binary_op): Likewise.\n+\t(build_x_array_ref): Likewise.\n+\t(build_x_unary_op): Likewise.\n+\t(build_x_compound_expr): Likewise.\n+\t(build_x_modify_expr): Likewise.\n+\t* decl2.c (grok_array_decl): Likewise.\n+\t* call.c (build_new_op_1): If during template processing we\n+\tchose an operator overload that is a hidden friend function, set\n+\tthe call's KOENIG_LOOKUP_P flag to 1.\n+\n 2015-12-14  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/68309"}, {"sha": "cdfa01ac63fdc0419cb18c7c6253aa01385a799a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -5630,6 +5630,19 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t    result = error_mark_node;\n \t  else\n \t    result = build_over_call (cand, LOOKUP_NORMAL, complain);\n+\n+\t  if (processing_template_decl\n+\t      && result != NULL_TREE\n+\t      && result != error_mark_node\n+\t      && DECL_HIDDEN_FRIEND_P (cand->fn))\n+\t    {\n+\t      tree call = result;\n+\t      if (REFERENCE_REF_P (call))\n+\t\tcall = TREE_OPERAND (call, 0);\n+\t      /* This prevents build_new_function_call from discarding this\n+\t\t function during instantiation of the enclosing template.  */\n+\t      KOENIG_LOOKUP_P (call) = 1;\n+\t    }\n \t}\n       else\n \t{"}, {"sha": "d5e3acdb67a51d488aa520561ea6a9b28339afbd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -6477,6 +6477,7 @@ extern bool is_lambda_ignored_entity            (tree);\n \n /* in tree.c */\n extern int cp_tree_operand_length\t\t(const_tree);\n+extern int cp_tree_code_length\t\t\t(enum tree_code);\n void cp_free_lang_data \t\t\t\t(tree t);\n extern tree force_target_expr\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_target_expr_with_type\t\t(tree, tree, tsubst_flags_t);\n@@ -6513,6 +6514,7 @@ extern tree build_min\t\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_nt_loc\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t ...);\n extern tree build_min_non_dep\t\t\t(enum tree_code, tree, ...);\n+extern tree build_min_non_dep_op_overload\t(enum tree_code, tree, tree, ...);\n extern tree build_min_non_dep_call_vec\t\t(tree, tree, vec<tree, va_gc> *);\n extern tree build_cplus_new\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_aggr_init_expr\t\t(tree, tree);"}, {"sha": "5ae6266c7e1703975aaee7d4eafcf5a4fa76eda5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -354,6 +354,7 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n   tree expr;\n   tree orig_array_expr = array_expr;\n   tree orig_index_exp = index_exp;\n+  tree overload = NULL_TREE;\n \n   if (error_operand_p (array_expr) || error_operand_p (index_exp))\n     return error_mark_node;\n@@ -379,7 +380,7 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n       if (decltype_p)\n \tcomplain |= tf_decltype;\n       expr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr,\n-\t\t\t   index_exp, NULL_TREE, /*overload=*/NULL, complain);\n+\t\t\t   index_exp, NULL_TREE, &overload, complain);\n     }\n   else\n     {\n@@ -424,8 +425,14 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n       expr = build_array_ref (input_location, array_expr, index_exp);\n     }\n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep (ARRAY_REF, expr, orig_array_expr, orig_index_exp,\n-\t\t\t      NULL_TREE, NULL_TREE);\n+    {\n+      if (overload != NULL_TREE)\n+\treturn (build_min_non_dep_op_overload\n+\t\t(ARRAY_REF, expr, overload, orig_array_expr, orig_index_exp));\n+\n+      return build_min_non_dep (ARRAY_REF, expr, orig_array_expr, orig_index_exp,\n+\t\t\t\tNULL_TREE, NULL_TREE);\n+    }\n   return expr;\n }\n "}, {"sha": "0c0987df0f699c582d96dd3e7de192a11f10c001", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -2741,9 +2741,72 @@ build_min_non_dep_call_vec (tree non_dep, tree fn, vec<tree, va_gc> *argvec)\n     non_dep = TREE_OPERAND (non_dep, 0);\n   TREE_TYPE (t) = TREE_TYPE (non_dep);\n   TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (non_dep);\n+  KOENIG_LOOKUP_P (t) = KOENIG_LOOKUP_P (non_dep);\n   return convert_from_reference (t);\n }\n \n+/* Similar to build_min_non_dep, but for expressions that have been resolved to\n+   a call to an operator overload.  OP is the operator that has been\n+   overloaded.  NON_DEP is the non-dependent expression that's been built,\n+   which should be a CALL_EXPR or an INDIRECT_REF to a CALL_EXPR.  OVERLOAD is\n+   the overload that NON_DEP is calling.  */\n+\n+tree\n+build_min_non_dep_op_overload (enum tree_code op,\n+\t\t\t       tree non_dep,\n+\t\t\t       tree overload, ...)\n+{\n+  va_list p;\n+  int nargs, expected_nargs;\n+  tree fn, call;\n+  vec<tree, va_gc> *args;\n+\n+  if (REFERENCE_REF_P (non_dep))\n+    non_dep = TREE_OPERAND (non_dep, 0);\n+\n+  nargs = call_expr_nargs (non_dep);\n+\n+  expected_nargs = cp_tree_code_length (op);\n+  if (op == POSTINCREMENT_EXPR\n+      || op == POSTDECREMENT_EXPR)\n+    expected_nargs += 1;\n+  gcc_assert (nargs == expected_nargs);\n+\n+  args = make_tree_vector ();\n+  va_start (p, overload);\n+\n+  if (TREE_CODE (TREE_TYPE (overload)) == FUNCTION_TYPE)\n+    {\n+      fn = overload;\n+      for (int i = 0; i < nargs; i++)\n+\t{\n+\t  tree arg = va_arg (p, tree);\n+\t  vec_safe_push (args, arg);\n+\t}\n+    }\n+  else if (TREE_CODE (TREE_TYPE (overload)) == METHOD_TYPE)\n+    {\n+      tree object = va_arg (p, tree);\n+      tree binfo = TYPE_BINFO (TREE_TYPE (object));\n+      tree method = build_baselink (binfo, binfo, overload, NULL_TREE);\n+      fn = build_min (COMPONENT_REF, TREE_TYPE (overload),\n+\t\t      object, method, NULL_TREE);\n+      for (int i = 1; i < nargs; i++)\n+\t{\n+\t  tree arg = va_arg (p, tree);\n+\t  vec_safe_push (args, arg);\n+\t}\n+    }\n+  else\n+   gcc_unreachable ();\n+\n+  va_end (p);\n+  call = build_min_non_dep_call_vec (non_dep, fn, args);\n+  release_tree_vector (args);\n+\n+  return call;\n+}\n+\n tree\n get_type_decl (tree t)\n {\n@@ -4383,6 +4446,32 @@ cp_tree_operand_length (const_tree t)\n     }\n }\n \n+/* Like cp_tree_operand_length, but takes a tree_code CODE.  */\n+\n+int\n+cp_tree_code_length (enum tree_code code)\n+{\n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n+  switch (code)\n+    {\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      return 1;\n+\n+    case ARRAY_REF:\n+      return 2;\n+\n+    case EXPR_PACK_EXPANSION:\n+      return 1;\n+\n+    default:\n+      return TREE_CODE_LENGTH (code);\n+    }\n+}\n+\n /* Implement -Wzero_as_null_pointer_constant.  Return true if the\n    conditions for the warning hold, false otherwise.  */\n bool"}, {"sha": "39c1af2f2573577f6bc993bba671b7bc1f686d91", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 81, "deletions": 19, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -2905,6 +2905,7 @@ build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring,\n {\n   tree orig_expr = expr;\n   tree rval;\n+  tree overload = NULL_TREE;\n \n   if (processing_template_decl)\n     {\n@@ -2917,12 +2918,18 @@ build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring,\n     }\n \n   rval = build_new_op (loc, INDIRECT_REF, LOOKUP_NORMAL, expr,\n-\t\t       NULL_TREE, NULL_TREE, /*overload=*/NULL, complain);\n+\t\t       NULL_TREE, NULL_TREE, &overload, complain);\n   if (!rval)\n     rval = cp_build_indirect_ref (expr, errorstring, complain);\n \n   if (processing_template_decl && rval != error_mark_node)\n-    return build_min_non_dep (INDIRECT_REF, rval, orig_expr);\n+    {\n+      if (overload != NULL_TREE)\n+\treturn (build_min_non_dep_op_overload\n+\t\t(INDIRECT_REF, rval, overload, orig_expr));\n+\n+      return build_min_non_dep (INDIRECT_REF, rval, orig_expr);\n+    }\n   else\n     return rval;\n }\n@@ -3814,12 +3821,13 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n tree\n build_x_binary_op (location_t loc, enum tree_code code, tree arg1,\n \t\t   enum tree_code arg1_code, tree arg2,\n-\t\t   enum tree_code arg2_code, tree *overload,\n+\t\t   enum tree_code arg2_code, tree *overload_p,\n \t\t   tsubst_flags_t complain)\n {\n   tree orig_arg1;\n   tree orig_arg2;\n   tree expr;\n+  tree overload = NULL_TREE;\n \n   orig_arg1 = arg1;\n   orig_arg2 = arg2;\n@@ -3837,7 +3845,10 @@ build_x_binary_op (location_t loc, enum tree_code code, tree arg1,\n     expr = build_m_component_ref (arg1, arg2, complain);\n   else\n     expr = build_new_op (loc, code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n-\t\t\t overload, complain);\n+\t\t\t &overload, complain);\n+\n+  if (overload_p != NULL)\n+    *overload_p = overload;\n \n   /* Check for cases such as x+y<<z which users are likely to\n      misinterpret.  But don't warn about obj << x + y, since that is a\n@@ -3853,7 +3864,13 @@ build_x_binary_op (location_t loc, enum tree_code code, tree arg1,\n \t\t\t    arg2_code, orig_arg2);\n \n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep (code, expr, orig_arg1, orig_arg2);\n+    {\n+      if (overload != NULL_TREE)\n+\treturn (build_min_non_dep_op_overload\n+\t\t(code, expr, overload, orig_arg1, orig_arg2));\n+\n+      return build_min_non_dep (code, expr, orig_arg1, orig_arg2);\n+    }\n \n   return expr;\n }\n@@ -3867,6 +3884,7 @@ build_x_array_ref (location_t loc, tree arg1, tree arg2,\n   tree orig_arg1 = arg1;\n   tree orig_arg2 = arg2;\n   tree expr;\n+  tree overload = NULL_TREE;\n \n   if (processing_template_decl)\n     {\n@@ -3879,11 +3897,17 @@ build_x_array_ref (location_t loc, tree arg1, tree arg2,\n     }\n \n   expr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, arg1, arg2,\n-\t\t       NULL_TREE, /*overload=*/NULL, complain);\n+\t\t       NULL_TREE, &overload, complain);\n \n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep (ARRAY_REF, expr, orig_arg1, orig_arg2,\n-\t\t\t      NULL_TREE, NULL_TREE);\n+    {\n+      if (overload != NULL_TREE)\n+\treturn (build_min_non_dep_op_overload\n+\t\t(ARRAY_REF, expr, overload, orig_arg1, orig_arg2));\n+\n+      return build_min_non_dep (ARRAY_REF, expr, orig_arg1, orig_arg2,\n+\t\t\t\tNULL_TREE, NULL_TREE);\n+    }\n   return expr;\n }\n \n@@ -5278,6 +5302,7 @@ build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n   tree orig_expr = xarg;\n   tree exp;\n   int ptrmem = 0;\n+  tree overload = NULL_TREE;\n \n   if (processing_template_decl)\n     {\n@@ -5305,7 +5330,8 @@ build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n     /* Don't look for a function.  */;\n   else\n     exp = build_new_op (loc, code, LOOKUP_NORMAL, xarg, NULL_TREE,\n-\t\t\tNULL_TREE, /*overload=*/NULL, complain);\n+\t\t\tNULL_TREE, &overload, complain);\n+\n   if (!exp && code == ADDR_EXPR)\n     {\n       if (is_overloaded_fn (xarg))\n@@ -5371,8 +5397,14 @@ build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n     }\n \n   if (processing_template_decl && exp != error_mark_node)\n-    exp = build_min_non_dep (code, exp, orig_expr,\n-\t\t\t     /*For {PRE,POST}{INC,DEC}REMENT_EXPR*/NULL_TREE);\n+    {\n+      if (overload != NULL_TREE)\n+\treturn (build_min_non_dep_op_overload\n+\t\t(code, exp, overload, orig_expr, integer_zero_node));\n+\n+      exp = build_min_non_dep (code, exp, orig_expr,\n+\t\t\t       /*For {PRE,POST}{INC,DEC}REMENT_EXPR*/NULL_TREE);\n+    }\n   if (TREE_CODE (exp) == ADDR_EXPR)\n     PTRMEM_OK_P (exp) = ptrmem;\n   return exp;\n@@ -6335,6 +6367,7 @@ build_x_compound_expr (location_t loc, tree op1, tree op2,\n   tree result;\n   tree orig_op1 = op1;\n   tree orig_op2 = op2;\n+  tree overload = NULL_TREE;\n \n   if (processing_template_decl)\n     {\n@@ -6346,12 +6379,18 @@ build_x_compound_expr (location_t loc, tree op1, tree op2,\n     }\n \n   result = build_new_op (loc, COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2,\n-\t\t\t NULL_TREE, /*overload=*/NULL, complain);\n+\t\t\t NULL_TREE, &overload, complain);\n   if (!result)\n     result = cp_build_compound_expr (op1, op2, complain);\n \n   if (processing_template_decl && result != error_mark_node)\n-    return build_min_non_dep (COMPOUND_EXPR, result, orig_op1, orig_op2);\n+    {\n+      if (overload != NULL_TREE)\n+\treturn (build_min_non_dep_op_overload\n+\t\t(COMPOUND_EXPR, result, overload, orig_op1, orig_op2));\n+\n+      return build_min_non_dep (COMPOUND_EXPR, result, orig_op1, orig_op2);\n+    }\n \n   return result;\n }\n@@ -7794,19 +7833,42 @@ cp_expr\n build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t\t     tree rhs, tsubst_flags_t complain)\n {\n+  tree orig_lhs = lhs;\n+  tree orig_rhs = rhs;\n+  tree overload = NULL_TREE;\n+  tree op = build_nt (modifycode, NULL_TREE, NULL_TREE);\n+\n   if (processing_template_decl)\n-    return build_min_nt_loc (loc, MODOP_EXPR, lhs,\n-\t\t\t     build_min_nt_loc (loc, modifycode, NULL_TREE,\n-\t\t\t\t\t       NULL_TREE), rhs);\n+    {\n+      if (modifycode == NOP_EXPR\n+\t  || type_dependent_expression_p (lhs)\n+\t  || type_dependent_expression_p (rhs))\n+        return build_min_nt_loc (loc, MODOP_EXPR, lhs,\n+\t\t\t\t build_min_nt_loc (loc, modifycode, NULL_TREE,\n+\t\t\t\t\t\t   NULL_TREE), rhs);\n+\n+      lhs = build_non_dependent_expr (lhs);\n+      rhs = build_non_dependent_expr (rhs);\n+    }\n \n   if (modifycode != NOP_EXPR)\n     {\n-      tree rval = build_new_op (loc, MODIFY_EXPR, LOOKUP_NORMAL, lhs, rhs,\n-\t\t\t\tmake_node (modifycode), /*overload=*/NULL,\n-\t\t\t\tcomplain);\n+      tree rval = build_new_op (loc, MODIFY_EXPR, LOOKUP_NORMAL,\n+\t\t\t\tlhs, rhs, op, &overload, complain);\n       if (rval)\n \t{\n+\t  if (rval == error_mark_node)\n+\t    return rval;\n \t  TREE_NO_WARNING (rval) = 1;\n+\t  if (processing_template_decl)\n+\t    {\n+\t      if (overload != NULL_TREE)\n+\t\treturn (build_min_non_dep_op_overload\n+\t\t\t(MODIFY_EXPR, rval, overload, orig_lhs, orig_rhs));\n+\n+\t      return (build_min_non_dep\n+\t\t      (MODOP_EXPR, rval, orig_lhs, op, orig_rhs));\n+\t    }\n \t  return rval;\n \t}\n     }"}, {"sha": "d2349b950b2cb4727c1902c61f6bb166fd2dc98a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -1,4 +1,12 @@\n-2015-12-14svn commit   Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+2015-12-15  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\tPR c++/21802\n+\tPR c++/53223\n+\t* g++.dg/cpp0x/pr53223.C: New test.\n+\t* g++.dg/lookup/pr21802.C: New test.\n+\t* g++.dg/lookup/two-stage4.C: Remove XFAIL.\n+\n+2015-12-14 Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \t* gfortran.dg/quad_2.f90: Update test.\n "}, {"sha": "b6ccd502d16220eb761760fb24d545343da52ad3", "filename": "gcc/testsuite/g++.dg/cpp0x/pr53223.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr53223.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr53223.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr53223.C?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -0,0 +1,45 @@\n+// PR c++/53223\n+// { dg-do compile { target c++11 } }\n+\n+#include <type_traits>\n+\n+#define SA(x) static_assert ((x), #x)\n+\n+struct A\n+{\n+  int good() const;\n+  int operator *() const;\n+  int operator ++() const;\n+  int operator [](int) const;\n+};\n+\n+int operator-- (const A&);\n+\n+template<typename T>\n+void func(T t)\n+{\n+  A x;\n+  auto &&g1 = x.good();\n+  auto &&g2 = x.operator*();\n+  auto &&error1 = *x;\n+  auto &&error2 = ++x;\n+  auto &&error3 = --x;\n+  auto &&error4 = x[5];\n+  SA ((std::is_same<int &&, decltype (error1)>::value));\n+  SA ((std::is_same<int &&, decltype (error2)>::value));\n+  SA ((std::is_same<int &&, decltype (error3)>::value));\n+  SA ((std::is_same<int &&, decltype (error4)>::value));\n+}\n+\n+void func2(int)\n+{\n+  A x;\n+  auto &&g = *x;\n+}\n+\n+int main()\n+{\n+  func(0);\n+  func2(0);\n+}\n+"}, {"sha": "139f7b49c25ab981b4de9bff6a8ceffd6799b09a", "filename": "gcc/testsuite/g++.dg/lookup/pr21802.C", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr21802.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr21802.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr21802.C?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -0,0 +1,276 @@\n+// PR c++/21802\n+// { dg-do run }\n+#include <cassert>\n+\n+struct X;\n+int I = 6;\n+\n+/* A mostly exhaustive and ad-hoc assortment of operator overloads and calls\n+   thereof, to stress-test two-stage name lookup of operators inside template\n+   definitions and then to verify that the calls get built correctly.  */\n+\n+template <typename T>\n+inline int operator+(const X &, T x) { return x; }\n+inline int operator-(const X &, int x) { return x; }\n+inline int operator*(const X &, int x) { return x; }\n+inline int operator/(const X &, int x) { return x; }\n+inline int operator+=(const X &, int x) { return x; }\n+\n+struct X\n+{\n+  X () : m (1) { }\n+  template <typename T>\n+  int operator%(T x) { return m + x; }\n+  virtual int operator>>(int x) { return m + x; }\n+  int operator<<(int x) { return m + x; }\n+  int operator&(int x) { return m + x; }\n+  int operator|(int x) { return m + x; }\n+  int operator^(int x) { return m + x; }\n+  int operator&&(int x) { return m + x; }\n+  int operator||(int x) { return m + x; }\n+  friend int operator==(X o, int x) { return o.m + x; }\n+  int operator!=(int x) { return m + x; }\n+  int operator<(int x) { return m + x; }\n+  int operator<=(int x) { return m + x; }\n+  int operator>(int x) { return m + x; }\n+  int operator>=(int x) { return m + x; }\n+  int operator*() { return m + I; }\n+  int operator!() { return m + I; }\n+  int operator~() { return m + I; }\n+  int operator++() { return m + I + 100; }\n+  int operator--() { return m + I + 100; }\n+  int operator++(int) { return m + I; }\n+  int operator--(int) { return m + I; }\n+  int operator()() { return m + I; }\n+  int operator,(int x) { return m + x; }\n+  int operator[](int x) { return m + x; }\n+  int operator*=(int x) { return m + x; }\n+  int operator-=(int x) { return m + x; }\n+  int operator/=(int x) { return m + x; }\n+  virtual int operator& () { return m + I; }\n+  int m;\n+};\n+struct Y : virtual X\n+{\n+  /* Virtual override.  */\n+  int operator>>(int x) { return m + x + 1; }\n+  int operator& () { return m + I + 1; }\n+\n+  /* Not virtual.  */\n+  template <typename T>\n+  int operator&(T x) { return m + x + 1; }\n+  friend int operator==(Y o, int x) { return o.m + x + 1; }\n+};\n+\n+/* The folloiwng \"FooN\" functions each contain a different way to call and to\n+   resolve these operator overloads.  */\n+\n+template <typename T>\n+void\n+Foo1 (T)\n+{\n+  Y x;\n+  { int t = x + I; assert (t == 6); }\n+  { int t = x - I; assert (t == 6); }\n+  { int t = x * I; assert (t == 6); }\n+  { int t = x / I; assert (t == 6); }\n+  { int t = (x+=I); assert (t == 6); }\n+\n+  { int t = x % I; assert (t == 7); }\n+  { int t = x << I; assert (t == 7); }\n+  { int t = x | I; assert (t == 7); }\n+  { int t = x && I; assert (t == 7); }\n+  { int t = x || I; assert (t == 7); }\n+  { int t = x != I; assert (t == 7); }\n+  { int t = x < I; assert (t == 7); }\n+  { int t = x <= I; assert (t == 7); }\n+  { int t = x > I; assert (t == 7); }\n+  { int t = x >= I; assert (t == 7); }\n+  { int t = *x; assert (t == 7); }\n+  { int t = !x; assert (t == 7); }\n+  { int t = ~x; assert (t == 7); }\n+  { int t = x++; assert (t == 7); }\n+  { int t = x--; assert (t == 7); }\n+  { int t = ++x; assert (t == 107); }\n+  { int t = --x; assert (t == 107); }\n+  { int t = x (); assert (t == 7); }\n+  { int t = (x, I); assert (t == 7); }\n+  { int t = x[I]; assert (t == 7); }\n+  { int t = (x-=I); assert (t == 7); }\n+  { int t = (x/=I); assert (t == 7); }\n+  { int t = (x*=I); assert (t == 7); }\n+\n+  { int t = x >> I; assert (t == 8); }\n+  { int t = x & I; assert (t == 8); }\n+  { int t = &x; assert (t == 8); }\n+  { int t = x == I; assert (t == 8); }\n+}\n+\n+template <typename T>\n+void\n+Foo2 (T)\n+{\n+  X x;\n+  { int t = x + I; assert (t == 6); }\n+  { int t = x - I; assert (t == 6); }\n+  { int t = x * I; assert (t == 6); }\n+  { int t = x / I; assert (t == 6); }\n+  { int t = (x+=I); assert (t == 6); }\n+\n+  { int t = x % I; assert (t == 7); }\n+  { int t = x >> I; assert (t == 7); }\n+  { int t = x << I; assert (t == 7); }\n+  { int t = x | I; assert (t == 7); }\n+  { int t = x && I; assert (t == 7); }\n+  { int t = x || I; assert (t == 7); }\n+  { int t = x == I; assert (t == 7); }\n+  { int t = x != I; assert (t == 7); }\n+  { int t = x < I; assert (t == 7); }\n+  { int t = x <= I; assert (t == 7); }\n+  { int t = x > I; assert (t == 7); }\n+  { int t = x >= I; assert (t == 7); }\n+  { int t = *x; assert (t == 7); }\n+  { int t = !x; assert (t == 7); }\n+  { int t = ~x; assert (t == 7); }\n+  { int t = x++; assert (t == 7); }\n+  { int t = x--; assert (t == 7); }\n+  { int t = ++x; assert (t == 107); }\n+  { int t = --x; assert (t == 107); }\n+  { int t = x (); assert (t == 7); }\n+  { int t = (x, I); assert (t == 7); }\n+  { int t = x[I]; assert (t == 7); }\n+  { int t = &x; assert (t == 7); }\n+  { int t = (x-=I); assert (t == 7); }\n+  { int t = (x/=I); assert (t == 7); }\n+  { int t = (x*=I); assert (t == 7); }\n+  { int t = x & I; assert (t == 7); }\n+}\n+\n+template <typename T>\n+void\n+Foo3 (T)\n+{\n+  Y o;\n+  X &x = o;\n+  { int t = x + I; assert (t == 6); }\n+  { int t = x - I; assert (t == 6); }\n+  { int t = x * I; assert (t == 6); }\n+  { int t = x / I; assert (t == 6); }\n+  { int t = (x+=I); assert (t == 6); }\n+\n+  { int t = x % I; assert (t == 7); }\n+  { int t = x << I; assert (t == 7); }\n+  { int t = x | I; assert (t == 7); }\n+  { int t = x && I; assert (t == 7); }\n+  { int t = x || I; assert (t == 7); }\n+  { int t = x == I; assert (t == 7); }\n+  { int t = x != I; assert (t == 7); }\n+  { int t = x < I; assert (t == 7); }\n+  { int t = x <= I; assert (t == 7); }\n+  { int t = x > I; assert (t == 7); }\n+  { int t = x >= I; assert (t == 7); }\n+  { int t = *x; assert (t == 7); }\n+  { int t = !x; assert (t == 7); }\n+  { int t = ~x; assert (t == 7); }\n+  { int t = x++; assert (t == 7); }\n+  { int t = x--; assert (t == 7); }\n+  { int t = ++x; assert (t == 107); }\n+  { int t = --x; assert (t == 107); }\n+  { int t = x (); assert (t == 7); }\n+  { int t = (x, I); assert (t == 7); }\n+  { int t = x[I]; assert (t == 7); }\n+  { int t = (x-=I); assert (t == 7); }\n+  { int t = (x/=I); assert (t == 7); }\n+  { int t = (x*=I); assert (t == 7); }\n+\n+  { int t = x & I; assert (t == 7); }\n+  { int t = x >> I; assert (t == 8); }\n+  { int t = &x; assert (t == 8); }\n+}\n+\n+template <typename T>\n+void\n+Foo4 (T)\n+{\n+  Y x;\n+  { int t = operator+ (x, I); assert (t == 6); }\n+  { int t = operator- (x, I); assert (t == 6); }\n+  { int t = operator* (x, I); assert (t == 6); }\n+  { int t = operator/ (x, I); assert (t == 6); }\n+  { int t = operator+= (x, I); assert (t == 6); }\n+\n+  { int t = x.operator% (I); assert (t == 7); }\n+  { int t = x.operator<< (I); assert (t == 7); }\n+  { int t = x.operator| (I); assert (t == 7); }\n+  { int t = x.operator&& (I); assert (t == 7); }\n+  { int t = x.operator|| (I); assert (t == 7); }\n+  { int t = x.operator!= (I); assert (t == 7); }\n+  { int t = x.operator< (I); assert (t == 7); }\n+  { int t = x.operator<= (I); assert (t == 7); }\n+  { int t = x.operator> (I); assert (t == 7); }\n+  { int t = x.operator>= (I); assert (t == 7); }\n+  { int t = x.operator* (); assert (t == 7); }\n+  { int t = x.operator! (); assert (t == 7); }\n+  { int t = x.operator~ (); assert (t == 7); }\n+  { int t = x.operator++ (0); assert (t == 7); }\n+  { int t = x.operator-- (0); assert (t == 7); }\n+  { int t = x.operator++ (); assert (t == 107); }\n+  { int t = x.operator-- (); assert (t == 107); }\n+  { int t = x.operator() (); assert (t == 7); }\n+  { int t = x.operator, (I); assert (t == 7); }\n+  { int t = x.operator[] (I); assert (t == 7); }\n+  { int t = x.operator-= (I); assert (t == 7); }\n+  { int t = x.operator/= (I); assert (t == 7); }\n+  { int t = x.operator*= (I); assert (t == 7); }\n+\n+  { int t = x.operator>> (I); assert (t == 8); }\n+  { int t = x.operator& (); assert (t == 8); }\n+  { int t = x.operator& (I); assert (t == 8); }\n+  { int t = operator== (x, I); assert (t == 8); }\n+}\n+\n+\n+/* These definitions should be irrelevant to operator lookup of non-dependent\n+   expressions inside the above templates since they are not in scope at\n+   template-definition time (even though they are in scope at instantiation\n+   time).  */\n+inline int operator+(const Y&, int) { return 11; }\n+inline int operator-(const Y&, int) { return 11; }\n+inline int operator*(const Y&, int) { return 11; }\n+inline int operator/(const Y&, int) { return 11; }\n+inline int operator%(const Y&, int) { return 11; }\n+inline int operator>>(const Y&, int) { return 11; }\n+inline int operator<<(const Y&, int) { return 11; }\n+inline int operator&(const Y&, int) { return 11; }\n+inline int operator|(const Y&, int) { return 11; }\n+inline int operator^(const Y&, int) { return 11; }\n+inline int operator&&(const Y&, int) { return 11; }\n+inline int operator||(const Y&, int) { return 11; }\n+inline int operator==(const Y&, int) { return 11; }\n+inline int operator!=(const Y&, int) { return 11; }\n+inline int operator<(const Y&, int) { return 11; }\n+inline int operator<=(const Y&, int) { return 11; }\n+inline int operator>(const Y&, int) { return 11; }\n+inline int operator>=(const Y&, int) { return 11; }\n+inline int operator*(const Y&) { return 11; }\n+inline int operator!(const Y&) { return 11; }\n+inline int operator~(const Y&) { return 11; }\n+inline int operator++(const Y&) { return 11; }\n+inline int operator--(const Y&) { return 11; }\n+inline int operator++(const Y&, int) { return 11; }\n+inline int operator--(const Y&, int) { return 11; }\n+inline int operator,(const Y&, int) { return 11; }\n+inline int operator&(const Y&) { return 11; }\n+inline int operator+=(const Y&, int x) { return 11; }\n+inline int operator*=(const Y&, int x) { return 11; }\n+inline int operator-=(const Y&, int x) { return 11; }\n+inline int operator/=(const Y&, int x) { return 11; }\n+\n+int\n+main ()\n+{\n+  Foo1 (0);\n+  Foo2 (0);\n+  Foo3 (0);\n+  Foo4 (0);\n+}"}, {"sha": "a89e61880315a30a008aabc82a247e4c0fb89be0", "filename": "gcc/testsuite/g++.dg/lookup/two-stage4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ftwo-stage4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ftwo-stage4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ftwo-stage4.C?ref=fcb9363eb9ba94b8e157444dc7ac2c93e69d6c58", "patch": "@@ -8,7 +8,7 @@ template<typename T> bool operator==(wrap<T>, wrap<T>);\n template<typename T>\n void g(T, wrap<wrap<int> > x)\n {\n-  bool b = x == x; // { dg-bogus \"\" \"\" { xfail *-*-* } }\n+  bool b = x == x; // { dg-bogus \"\" \"\" }\n }\n \n template<typename T> void operator==(wrap<wrap<T> >, wrap<wrap<T> >);"}]}