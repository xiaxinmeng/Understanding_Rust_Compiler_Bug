{"sha": "1c71e60ef78d26b2146bdcf45f2177722ec1ff30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM3MWU2MGVmNzhkMjZiMjE0NmJkY2Y0NWYyMTc3NzIyZWMxZmYzMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-02-04T21:40:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-02-04T21:40:37Z"}, "message": "i386.c (SAVE_REGS_FIRST): Remove.\n\n        * i386.c (SAVE_REGS_FIRST): Remove.\n        (ix86_initial_elimination_offset): Handle only SAVE_REGS_FIRST mode.\n        (ix86_compute_frame_size): Likewise.\n        (ix86_expand_prologue): Likewise.  Use pro_epilogue_adjust_stack.\n        (ix86_emit_restore_regs): Remove.\n        (ix86_emit_epilogue_esp_adjustment): Use pro_epilogue_adjust_stack\n        when a frame pointer is in use.\n        (ix86_expand_epilogue): Handle only SAVE_REGS_FIRST mode.  Use mov\n        instead of pop to restore a register when profitable; emit leave\n        when profitable.\n        (ix86_attr_length_default): Handle pro_epilogue_adjust_stack\n        as a TYPE_LEA insn.\n        (ix86_adjust_cost): Handle pro_epilogue_adjust_stack as TYPE_ALU.\n        * i386.md (prologue_allocate_stack): Remove.\n        (epilogue_deallocate_stack): Remove.\n        (pro_epilogue_adjust_stack): New.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r31792", "tree": {"sha": "6485ad8d0a5ce7bc2a97c39d06150f3432713f49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6485ad8d0a5ce7bc2a97c39d06150f3432713f49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c71e60ef78d26b2146bdcf45f2177722ec1ff30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c71e60ef78d26b2146bdcf45f2177722ec1ff30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c71e60ef78d26b2146bdcf45f2177722ec1ff30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c71e60ef78d26b2146bdcf45f2177722ec1ff30/comments", "author": null, "committer": null, "parents": [{"sha": "c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597"}], "stats": {"total": 267, "additions": 123, "deletions": 144}, "files": [{"sha": "1162cc1167baec54de38114211493ab2e70cf2c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c71e60ef78d26b2146bdcf45f2177722ec1ff30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c71e60ef78d26b2146bdcf45f2177722ec1ff30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c71e60ef78d26b2146bdcf45f2177722ec1ff30", "patch": "@@ -1,3 +1,23 @@\n+2000-02-04  Jan Hubicka  <jh@suse.cz>\n+\t    Richard Henderson  <rth@cygnus.com>\n+\n+        * i386.c (SAVE_REGS_FIRST): Remove.\n+        (ix86_initial_elimination_offset): Handle only SAVE_REGS_FIRST mode.\n+        (ix86_compute_frame_size): Likewise.\n+\t(ix86_expand_prologue): Likewise.  Use pro_epilogue_adjust_stack.\n+        (ix86_emit_restore_regs): Remove.\n+\t(ix86_emit_epilogue_esp_adjustment): Use pro_epilogue_adjust_stack\n+\twhen a frame pointer is in use.\n+        (ix86_expand_epilogue): Handle only SAVE_REGS_FIRST mode.  Use mov\n+\tinstead of pop to restore a register when profitable; emit leave\n+\twhen profitable.\n+        (ix86_attr_length_default): Handle pro_epilogue_adjust_stack\n+        as a TYPE_LEA insn.\n+\t(ix86_adjust_cost): Handle pro_epilogue_adjust_stack as TYPE_ALU.\n+        * i386.md (prologue_allocate_stack): Remove.\n+\t(epilogue_deallocate_stack): Remove.\n+\t(pro_epilogue_adjust_stack): New.\n+\n 2000-02-04  Richard Henderson  <rth@cygnus.com>\n \n \t* function.c (diddle_return_value): Rework to use a callback function."}, {"sha": "93a89f1300e4c1be923d0f5d46cdc05a17404981", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 70, "deletions": 123, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c71e60ef78d26b2146bdcf45f2177722ec1ff30/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c71e60ef78d26b2146bdcf45f2177722ec1ff30/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1c71e60ef78d26b2146bdcf45f2177722ec1ff30", "patch": "@@ -41,16 +41,6 @@ Boston, MA 02111-1307, USA. */\n #include \"basic-block.h\"\n #include \"ggc.h\"\n \n-/* True when we want to do pushes before allocating stack to get better\n-   scheduling.\n-\n-   Saving registers first is win in the most cases except for LEAVE\n-   instruction.  Macro is 0 iff we will use LEAVE.  */\n-\n-#define SAVED_REGS_FIRST \\\n-  (!frame_pointer_needed || (!TARGET_USE_LEAVE && !optimize_size))\n-\n-\n #ifdef EXTRA_CONSTRAINT\n /* If EXTRA_CONSTRAINT is defined, then the 'S'\n    constraint in REG_CLASS_FROM_LETTER will no longer work, and various\n@@ -411,7 +401,6 @@ static HOST_WIDE_INT ix86_compute_frame_size PARAMS((HOST_WIDE_INT,\n \t\t\t\t\t\t     int *, int *, int *));\n static int ix86_nsaved_regs PARAMS((void));\n static void ix86_emit_save_regs PARAMS((void));\n-static void ix86_emit_restore_regs PARAMS((void));\n static void ix86_emit_epilogue_esp_adjustment PARAMS((int));\n \n struct ix86_address\n@@ -1705,16 +1694,13 @@ ix86_initial_elimination_offset (from, to)\n \n      saved frame pointer if frame_pointer_needed\n \t\t\t\t\t\t<- HARD_FRAME_POINTER\n-     [saved regs if SAVED_REGS_FIRST]\n+     [saved regs]\n \n      [padding1]   \\\n \t\t   |\t\t\t\t<- FRAME_POINTER\n      [frame]\t   > tsize\n \t\t   |\n      [padding2]   /\n-\n-     [saved regs if !SAVED_REGS_FIRST]\n-     \t\t\t\t\t\t<- STACK_POINTER\n     */\n \n   if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n@@ -1725,8 +1711,7 @@ ix86_initial_elimination_offset (from, to)\n \t   && to == HARD_FRAME_POINTER_REGNUM)\n     {\n       ix86_compute_frame_size (get_frame_size (), &nregs, &padding1, (int *)0);\n-      if (SAVED_REGS_FIRST)\n-\tpadding1 += nregs * UNITS_PER_WORD;\n+      padding1 += nregs * UNITS_PER_WORD;\n       return -padding1;\n     }\n   else\n@@ -1743,10 +1728,8 @@ ix86_initial_elimination_offset (from, to)\n \treturn tsize + nregs * UNITS_PER_WORD + frame_size;\n       else if (from != FRAME_POINTER_REGNUM)\n \tabort ();\n-      else if (SAVED_REGS_FIRST)\n-\treturn tsize - padding1;\n       else\n-\treturn tsize + nregs * UNITS_PER_WORD - padding1;\n+\treturn tsize - padding1;\n     }\n }\n \n@@ -1788,13 +1771,10 @@ ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n     if (stack_alignment_needed < 4)\n       stack_alignment_needed = 4;\n \n-    if (stack_alignment_needed > preferred_alignment)\n+    if (stack_alignment_needed > PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n       abort ();\n \n-    if (SAVED_REGS_FIRST)\n-      offset += nregs * UNITS_PER_WORD;\n-    else\n-      total_size += nregs * UNITS_PER_WORD;\n+    offset += nregs * UNITS_PER_WORD;\n \n     total_size += offset;\n \n@@ -1807,9 +1787,8 @@ ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n       }\n \n     /* Align stack boundary. */\n-    if (!current_function_is_leaf)\n-      padding2 = ((total_size + preferred_alignment - 1)\n-\t\t  & -preferred_alignment) - total_size;\n+    padding2 = ((total_size + preferred_alignment - 1)\n+\t\t& -preferred_alignment) - total_size;\n   }\n #endif\n \n@@ -1868,18 +1847,16 @@ ix86_expand_prologue ()\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  if (SAVED_REGS_FIRST)\n-    ix86_emit_save_regs ();\n+  ix86_emit_save_regs ();\n \n   if (tsize == 0)\n     ;\n   else if (! TARGET_STACK_PROBE || tsize < CHECK_STACK_LIMIT)\n     {\n       if (frame_pointer_needed)\n-\tinsn = emit_insn (gen_prologue_allocate_stack (stack_pointer_rtx,\n-\t\t\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t\t\t       GEN_INT (-tsize),\n-\t\t\t\t\t\t       hard_frame_pointer_rtx));\n+\tinsn = emit_insn (gen_pro_epilogue_adjust_stack\n+\t\t\t  (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t           GEN_INT (-tsize), hard_frame_pointer_rtx));\n       else\n         insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t      GEN_INT (-tsize)));\n@@ -1903,9 +1880,6 @@ ix86_expand_prologue ()\n \t\t\t     CALL_INSN_FUNCTION_USAGE (insn));\n     }\n \n-  if (!SAVED_REGS_FIRST)\n-    ix86_emit_save_regs ();\n-\n #ifdef SUBTARGET_PROLOGUE\n   SUBTARGET_PROLOGUE;\n #endif  \n@@ -1920,25 +1894,6 @@ ix86_expand_prologue ()\n     emit_insn (gen_blockage ());\n }\n \n-/* Emit code to pop all registers from stack.  */\n-\n-static void\n-ix86_emit_restore_regs ()\n-{\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n-  int limit = (frame_pointer_needed\n-\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n-  int regno;\n-\n-  for (regno = 0; regno < limit; regno++)\n-    if ((regs_ever_live[regno] && !call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-      {\n-\temit_insn (gen_popsi1 (gen_rtx_REG (SImode, regno)));\n-      }\n-}\n-\n /* Emit code to add TSIZE to esp value.  Use POP instruction when\n    profitable.  */\n \n@@ -1980,9 +1935,16 @@ ix86_emit_epilogue_esp_adjustment (tsize)\n     }\n   else\n     {\n-      /* If there is no frame pointer, we must still release the frame. */\n-      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t     GEN_INT (tsize)));\n+      /* If a frame pointer is present, we must be sure to tie the sp\n+\t to the fp so that we don't mis-schedule.  */\n+      if (frame_pointer_needed)\n+        emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  GEN_INT (tsize),\n+\t\t\t\t\t\t  hard_frame_pointer_rtx));\n+      else\n+        emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (tsize)));\n     }\n }\n \n@@ -1991,91 +1953,77 @@ ix86_emit_epilogue_esp_adjustment (tsize)\n void\n ix86_expand_epilogue ()\n {\n-  int regno;\n   int nregs;\n-  int limit;\n+  int regno;\n+\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n   HOST_WIDE_INT offset;\n-  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), &nregs, (int *)0,\n-\t\t\t\t\t\t (int *)0);\n+  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), &nregs,\n+\t\t\t\t\t\t (int *)0, (int *)0);\n \n-  /* SP is often unreliable so we may have to go off the frame pointer. */\n \n-  offset = -(tsize + nregs * UNITS_PER_WORD);\n+  /* Calculate start of saved registers relative to ebp.  */\n+  offset = -nregs * UNITS_PER_WORD;\n \n-  if (SAVED_REGS_FIRST)\n+#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n+  if (profile_block_flag == 2)\n     {\n-      if (!sp_valid)\n-        {\n-\t  if (nregs)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t    gen_rtx_PLUS (SImode, hard_frame_pointer_rtx,\n-\t\t\t\t\t\t  GEN_INT (- nregs * UNITS_PER_WORD))));\n-\t  else\n-\t    emit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,\n-\t\t\t\t\t\t   hard_frame_pointer_rtx));\n-\t}\n-      else if (tsize)\n-\tix86_emit_epilogue_esp_adjustment (tsize);\n-      ix86_emit_restore_regs ();\n+      FUNCTION_BLOCK_PROFILER_EXIT;\n     }\n+#endif\n \n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n-     less work than reloading sp and popping the register.  Otherwise,\n-     restore sp (if necessary) and pop the registers. */\n-\n-  else if (nregs > 1 || sp_valid)\n+     less work than reloading sp and popping the register.  */\n+  if (!sp_valid && nregs <= 1)\n     {\n-      if (!sp_valid)\n-\t{\n-\t  rtx addr_offset;\n-\t  addr_offset = adj_offsettable_operand (AT_BP (QImode), offset);\n-\t  addr_offset = XEXP (addr_offset, 0);\n-\n-\t  emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, addr_offset));\n-\t}\n+      if (!frame_pointer_needed)\n+\tabort();\n \n-      ix86_emit_restore_regs ();\n-    }\n-  else\n-    {\n-      limit = (frame_pointer_needed\n-\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n-      for (regno = 0; regno < limit; regno++)\n+      for (regno = 0; regno < HARD_FRAME_POINTER_REGNUM; regno++)\n \tif ((regs_ever_live[regno] && ! call_used_regs[regno])\n \t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n \t  {\n \t    emit_move_insn (gen_rtx_REG (SImode, regno),\n \t\t\t    adj_offsettable_operand (AT_BP (Pmode), offset));\n \t    offset += 4;\n \t  }\n-    }\n \n-  if (frame_pointer_needed)\n-    {\n       /* If not an i386, mov & pop is faster than \"leave\". */\n       if (TARGET_USE_LEAVE || optimize_size)\n \temit_insn (gen_leave ());\n       else\n \t{\n-\t  if (!SAVED_REGS_FIRST)\n-\t    emit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,\n-\t\t\t\t\t\t   hard_frame_pointer_rtx));\n+\t  emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t\t\t    hard_frame_pointer_rtx,\n+\t\t\t\t\t\t    const0_rtx,\n+\t\t\t\t\t\t    hard_frame_pointer_rtx));\n \t  emit_insn (gen_popsi1 (hard_frame_pointer_rtx));\n \t}\n     }\n-  else if (!SAVED_REGS_FIRST && tsize)\n-    ix86_emit_epilogue_esp_adjustment (tsize);\n-\n-#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n-  if (profile_block_flag == 2)\n+  else\n     {\n-      FUNCTION_BLOCK_PROFILER_EXIT;\n+      /* First step is to deallocate the stack frame so that we can\n+\t pop the registers.  */\n+      if (!sp_valid)\n+\t{\n+\t  if (!frame_pointer_needed)\n+\t    abort ();\n+          emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t\t\t    hard_frame_pointer_rtx,\n+\t\t\t\t\t\t    GEN_INT (offset),\n+\t\t\t\t\t\t    hard_frame_pointer_rtx));\n+\t}\n+      else if (tsize)\n+\tix86_emit_epilogue_esp_adjustment (tsize);\n+\n+      for (regno = 0; regno < STACK_POINTER_REGNUM; regno++)\n+\tif ((regs_ever_live[regno] && !call_used_regs[regno])\n+\t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+\t  emit_insn (gen_popsi1 (gen_rtx_REG (SImode, regno)));\n     }\n-#endif\n \n   if (current_function_pops_args && current_function_args_size)\n     {\n@@ -5853,14 +5801,14 @@ ix86_attr_length_default (insn)\n       {\n         /* Irritatingly, single_set doesn't work with REG_UNUSED present,\n \t   as we'll get from running life_analysis during reg-stack when\n-\t   not optimizing.  */\n+\t   not optimizing.  Not that it matters anyway, now that\n+\t   pro_epilogue_adjust_stack uses lea, and is by design not\n+\t   single_set. */\n         rtx set = PATTERN (insn);\n         if (GET_CODE (set) == SET)\n \t  ;\n \telse if (GET_CODE (set) == PARALLEL\n-\t\t && XVECLEN (set, 0) == 2\n-\t\t && GET_CODE (XVECEXP (set, 0, 0)) == SET\n-\t\t && GET_CODE (XVECEXP (set, 0, 1)) == CLOBBER)\n+\t\t && GET_CODE (XVECEXP (set, 0, 0)) == SET)\n \t  set = XVECEXP (set, 0, 0);\n \telse\n \t  abort ();\n@@ -6011,18 +5959,17 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n   if (dep_insn_code_number < 0 || recog_memoized (insn) < 0)\n     return cost;\n \n-  /* Prologue and epilogue allocators have false dependency on ebp.\n-     This results in one cycle extra stall on Pentium prologue scheduling, so\n-     handle this important case manually. */\n+  insn_type = get_attr_type (insn);\n+  dep_insn_type = get_attr_type (dep_insn);\n \n-  if ((dep_insn_code_number == CODE_FOR_prologue_allocate_stack\n-       || dep_insn_code_number == CODE_FOR_epilogue_deallocate_stack)\n+  /* Prologue and epilogue allocators can have a false dependency on ebp.\n+     This results in one cycle extra stall on Pentium prologue scheduling,\n+     so handle this important case manually.  */\n+  if (dep_insn_code_number == CODE_FOR_pro_epilogue_adjust_stack\n+      && dep_insn_type == TYPE_ALU\n       && !reg_mentioned_p (stack_pointer_rtx, insn))\n     return 0;\n \n-  insn_type = get_attr_type (insn);\n-  dep_insn_type = get_attr_type (dep_insn);\n-\n   switch (ix86_cpu)\n     {\n     case PROCESSOR_PENTIUM:"}, {"sha": "dc63bb18bb7a996cfbdfabed83b142ddfca5f0c8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c71e60ef78d26b2146bdcf45f2177722ec1ff30/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c71e60ef78d26b2146bdcf45f2177722ec1ff30/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1c71e60ef78d26b2146bdcf45f2177722ec1ff30", "patch": "@@ -8807,35 +8807,47 @@\n ;;\n ;; in proper program order.\n \n-(define_insn \"prologue_allocate_stack\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n+(define_insn \"pro_epilogue_adjust_stack\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n+\t         (match_operand:SI 2 \"immediate_operand\" \"i,i\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"+r,r\")\n \t(match_dup 3))\n    (clobber (reg:CC 17))]\n   \"\"\n   \"*\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) == 128\n-\t  || (INTVAL (operands[2]) < 0\n-\t      && INTVAL (operands[2]) != -128)))\n+  switch (get_attr_type (insn))\n     {\n-      operands[2] = GEN_INT (-INTVAL (operands[2]));\n-      return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+    case TYPE_IMOV:\n+      return \\\"mov{l}\\\\t{%1, %0|%0, %1}\\\";\n+\n+    case TYPE_ALU:\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t          && INTVAL (operands[2]) != -128)))\n+\t{\n+\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+\t}\n+      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+\n+    case TYPE_LEA:\n+      operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+      return \\\"lea{l}\\\\t{%a2, %0|%0, %a2}\\\";\n+\n+    default:\n+      abort ();\n     }\n-  return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n }\"\n-  [(set_attr \"type\" \"alu\")])\n-\n-(define_insn \"epilogue_deallocate_stack\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"+r\"))\n-   (set (match_dup 1) (match_dup 1))]\n-  \"\"\n-  \"mov{l}\\\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"imov\")])\n+  [(set (attr \"type\")\n+\t(cond [(eq_attr \"alternative\" \"0\")\n+\t\t (const_string \"alu\")\n+\t       (match_operand:SI 2 \"const0_operand\" \"\")\n+\t\t (const_string \"imov\")\n+\t      ]\n+\t      (const_string \"lea\")))])\n \n (define_insn \"allocate_stack_worker\"\n   [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"a\")] 3)"}]}