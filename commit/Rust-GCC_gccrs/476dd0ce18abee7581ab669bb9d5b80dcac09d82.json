{"sha": "476dd0ce18abee7581ab669bb9d5b80dcac09d82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc2ZGQwY2UxOGFiZWU3NTgxYWI2NjliYjlkNWI4MGRjYWMwOWQ4Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-08-28T06:20:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-08-28T06:20:12Z"}, "message": "rtl-iter.h: New file.\n\ngcc/\n\t* rtl-iter.h: New file.\n\t* rtlanal.c: Include it.\n\t(rtx_all_subrtx_bounds, rtx_nonconst_subrtx_bounds): New variables.\n\t(generic_subrtx_iterator <T>::add_single_to_queue)\n\t(generic_subrtx_iterator <T>::add_subrtxes_to_queue)\n\t(generic_subrtx_iterator <T>::free_array): New functions.\n\t(generic_subrtx_iterator <T>::LOCAL_ELEMS): Define.\n\t(generic_subrtx_iterator <const_rtx_accessor>)\n\t(generic_subrtx_iterator <rtx_var_accessor>\n\t(generic_subrtx_iterator <rtx_ptr_accessor>): Instantiate.\n\t(setup_reg_subrtx_bounds): New function.\n\t(init_rtlanal): Call it.\n\nFrom-SVN: r214618", "tree": {"sha": "c855da4d54b26f5a3874bf40485ae131931ab59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c855da4d54b26f5a3874bf40485ae131931ab59c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/476dd0ce18abee7581ab669bb9d5b80dcac09d82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476dd0ce18abee7581ab669bb9d5b80dcac09d82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476dd0ce18abee7581ab669bb9d5b80dcac09d82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476dd0ce18abee7581ab669bb9d5b80dcac09d82/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c05e50c733d217f7f1da1f5173584fbc5032d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c05e50c733d217f7f1da1f5173584fbc5032d2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c05e50c733d217f7f1da1f5173584fbc5032d2e"}], "stats": {"total": 437, "additions": 436, "deletions": 1}, "files": [{"sha": "aefa4507598ecc27a1675d00832615ea5f41f466", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476dd0ce18abee7581ab669bb9d5b80dcac09d82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476dd0ce18abee7581ab669bb9d5b80dcac09d82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=476dd0ce18abee7581ab669bb9d5b80dcac09d82", "patch": "@@ -1,3 +1,18 @@\n+2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtl-iter.h: New file.\n+\t* rtlanal.c: Include it.\n+\t(rtx_all_subrtx_bounds, rtx_nonconst_subrtx_bounds): New variables.\n+\t(generic_subrtx_iterator <T>::add_single_to_queue)\n+\t(generic_subrtx_iterator <T>::add_subrtxes_to_queue)\n+\t(generic_subrtx_iterator <T>::free_array): New functions.\n+\t(generic_subrtx_iterator <T>::LOCAL_ELEMS): Define.\n+\t(generic_subrtx_iterator <const_rtx_accessor>)\n+\t(generic_subrtx_iterator <rtx_var_accessor>\n+\t(generic_subrtx_iterator <rtx_ptr_accessor>): Instantiate.\n+\t(setup_reg_subrtx_bounds): New function.\n+\t(init_rtlanal): Call it.\n+\n 2014-08-27  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n         PR target/62261"}, {"sha": "958999b00ee0dc1f338aa58388772daa87cbbbff", "filename": "gcc/rtl-iter.h", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476dd0ce18abee7581ab669bb9d5b80dcac09d82/gcc%2Frtl-iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476dd0ce18abee7581ab669bb9d5b80dcac09d82/gcc%2Frtl-iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-iter.h?ref=476dd0ce18abee7581ab669bb9d5b80dcac09d82", "patch": "@@ -0,0 +1,291 @@\n+/* RTL iterators\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This structure describes the subrtxes of an rtx as follows:\n+\n+   - if the rtx has no subrtxes, START and COUNT are both 0.\n+\n+   - if all the subrtxes of an rtx are stored in a contiguous block\n+     of XEXPs (\"e\"s), START is the index of the first XEXP and COUNT\n+     is the number of them.\n+\n+   - otherwise START is arbitrary and COUNT is UCHAR_MAX.\n+\n+   rtx_all_subrtx_bounds applies to all codes.  rtx_nonconst_subrtx_bounds\n+   is like rtx_all_subrtx_bounds except that all constant rtxes are treated\n+   as having no subrtxes.  */\n+struct rtx_subrtx_bound_info {\n+  unsigned char start;\n+  unsigned char count;\n+};\n+extern rtx_subrtx_bound_info rtx_all_subrtx_bounds[];\n+extern rtx_subrtx_bound_info rtx_nonconst_subrtx_bounds[];\n+\n+/* Return true if CODE has no subrtxes.  */\n+\n+static inline bool\n+leaf_code_p (enum rtx_code code)\n+{\n+  return rtx_all_subrtx_bounds[code].count == 0;\n+}\n+\n+/* Used to iterate over subrtxes of an rtx.  T abstracts the type of\n+   access.  */\n+template <typename T>\n+class generic_subrtx_iterator\n+{\n+  static const size_t LOCAL_ELEMS = 16;\n+  typedef typename T::value_type value_type;\n+  typedef typename T::rtx_type rtx_type;\n+  typedef typename T::rtunion_type rtunion_type;\n+\n+public:\n+  struct array_type\n+  {\n+    array_type ();\n+    ~array_type ();\n+    value_type stack[LOCAL_ELEMS];\n+    vec <value_type, va_heap, vl_embed> *heap;\n+  };\n+  generic_subrtx_iterator (array_type &, value_type,\n+\t\t\t   const rtx_subrtx_bound_info *);\n+\n+  value_type operator * () const;\n+  bool at_end () const;\n+  void next ();\n+  void skip_subrtxes ();\n+  void substitute (value_type);\n+\n+private:\n+  /* The bounds to use for iterating over subrtxes.  */\n+  const rtx_subrtx_bound_info *m_bounds;\n+\n+  /* The storage used for the worklist.  */\n+  array_type &m_array;\n+\n+  /* The current rtx.  */\n+  value_type m_current;\n+\n+  /* The base of the current worklist.  */\n+  value_type *m_base;\n+\n+  /* The number of subrtxes in M_BASE.  */\n+  size_t m_end;\n+\n+  /* The following booleans shouldn't end up in registers or memory\n+     but just direct control flow.  */\n+\n+  /* True if the iteration is over.  */\n+  bool m_done;\n+\n+  /* True if we should skip the subrtxes of M_CURRENT.  */\n+  bool m_skip;\n+\n+  /* True if M_CURRENT has been replaced with a different rtx.  */\n+  bool m_substitute;\n+\n+  static void free_array (array_type &);\n+  static size_t add_subrtxes_to_queue (array_type &, value_type *, size_t,\n+\t\t\t\t       rtx_type);\n+  static value_type *add_single_to_queue (array_type &, value_type *, size_t,\n+\t\t\t\t\t  value_type);\n+};\n+\n+template <typename T>\n+inline generic_subrtx_iterator <T>::array_type::array_type () : heap (0) {}\n+\n+template <typename T>\n+inline generic_subrtx_iterator <T>::array_type::~array_type ()\n+{\n+  if (__builtin_expect (heap != 0, false))\n+    free_array (*this);\n+}\n+\n+/* Iterate over X and its subrtxes, in arbitrary order.  Use ARRAY to\n+   store the worklist.  We use an external array in order to avoid\n+   capturing the fields of this structure when taking the address of\n+   the array.  Use BOUNDS to find the bounds of simple \"e\"-string codes.  */\n+\n+template <typename T>\n+inline generic_subrtx_iterator <T>::\n+generic_subrtx_iterator (array_type &array, value_type x,\n+\t\t\t const rtx_subrtx_bound_info *bounds)\n+  : m_bounds (bounds),\n+    m_array (array),\n+    m_current (x),\n+    m_base (m_array.stack),\n+    m_end (0),\n+    m_done (false),\n+    m_skip (false),\n+    m_substitute (false)\n+{\n+}\n+\n+/* Return the current subrtx.  */\n+\n+template <typename T>\n+inline typename T::value_type\n+generic_subrtx_iterator <T>::operator * () const\n+{\n+  return m_current;\n+}\n+\n+/* Return true if the iteration has finished.  */\n+\n+template <typename T>\n+inline bool\n+generic_subrtx_iterator <T>::at_end () const\n+{\n+  return m_done;\n+}\n+\n+/* Move on to the next subrtx.  */\n+\n+template <typename T>\n+inline void\n+generic_subrtx_iterator <T>::next ()\n+{\n+  if (m_substitute)\n+    {\n+      m_substitute = false;\n+      m_skip = false;\n+      return;\n+    }\n+  if (!m_skip)\n+    {\n+      /* Add the subrtxes of M_CURRENT.  */\n+      rtx_type x = T::get_rtx (m_current);\n+      if (__builtin_expect (x != 0, true))\n+\t{\n+\t  enum rtx_code code = GET_CODE (x);\n+\t  ssize_t count = m_bounds[code].count;\n+\t  if (count > 0)\n+\t    {\n+\t      /* Handle the simple case of a single \"e\" block that is known\n+\t\t to fit into the current array.  */\n+\t      if (__builtin_expect (m_end + count <= LOCAL_ELEMS + 1, true))\n+\t\t{\n+\t\t  /* Set M_CURRENT to the first subrtx and queue the rest.  */\n+\t\t  ssize_t start = m_bounds[code].start;\n+\t\t  rtunion_type *src = &x->u.fld[start];\n+\t\t  if (__builtin_expect (count > 2, false))\n+\t\t    m_base[m_end++] = T::get_value (src[2].rt_rtx);\n+\t\t  if (count > 1)\n+\t\t    m_base[m_end++] = T::get_value (src[1].rt_rtx);\n+\t\t  m_current = T::get_value (src[0].rt_rtx);\n+\t\t  return;\n+\t\t}\n+\t      /* Handle cases which aren't simple \"e\" sequences or where\n+\t\t the sequence might overrun M_BASE.  */\n+\t      count = add_subrtxes_to_queue (m_array, m_base, m_end, x);\n+\t      if (count > 0)\n+\t\t{\n+\t\t  m_end += count;\n+\t\t  if (m_end > LOCAL_ELEMS)\n+\t\t    m_base = m_array.heap->address ();\n+\t\t  m_current = m_base[--m_end];\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    m_skip = false;\n+  if (m_end == 0)\n+    m_done = true;\n+  else\n+    m_current = m_base[--m_end];\n+}\n+\n+/* Skip the subrtxes of the current rtx.  */\n+\n+template <typename T>\n+inline void\n+generic_subrtx_iterator <T>::skip_subrtxes ()\n+{\n+  m_skip = true;\n+}\n+\n+/* Ignore the subrtxes of the current rtx and look at X instead.  */\n+\n+template <typename T>\n+inline void\n+generic_subrtx_iterator <T>::substitute (value_type x)\n+{\n+  m_substitute = true;\n+  m_current = x;\n+}\n+\n+/* Iterators for const_rtx.  */\n+struct const_rtx_accessor\n+{\n+  typedef const_rtx value_type;\n+  typedef const_rtx rtx_type;\n+  typedef const rtunion rtunion_type;\n+  static rtx_type get_rtx (value_type x) { return x; }\n+  static value_type get_value (rtx_type x) { return x; }\n+};\n+typedef generic_subrtx_iterator <const_rtx_accessor> subrtx_iterator;\n+\n+/* Iterators for non-constant rtx.  */\n+struct rtx_var_accessor\n+{\n+  typedef rtx value_type;\n+  typedef rtx rtx_type;\n+  typedef rtunion rtunion_type;\n+  static rtx_type get_rtx (value_type x) { return x; }\n+  static value_type get_value (rtx_type x) { return x; }\n+};\n+typedef generic_subrtx_iterator <rtx_var_accessor> subrtx_var_iterator;\n+\n+/* Iterators for rtx *.  */\n+struct rtx_ptr_accessor\n+{\n+  typedef rtx *value_type;\n+  typedef rtx rtx_type;\n+  typedef rtunion rtunion_type;\n+  static rtx_type get_rtx (value_type ptr) { return *ptr; }\n+  static value_type get_value (rtx_type &x) { return &x; }\n+};\n+typedef generic_subrtx_iterator <rtx_ptr_accessor> subrtx_ptr_iterator;\n+\n+#define ALL_BOUNDS rtx_all_subrtx_bounds\n+#define NONCONST_BOUNDS rtx_nonconst_subrtx_bounds\n+\n+/* Use ITER to iterate over const_rtx X and its recursive subrtxes,\n+   using subrtx_iterator::array ARRAY as the storage for the worklist.\n+   ARRAY can be reused for multiple consecutive iterations but shouldn't\n+   be shared by two concurrent iterations.  TYPE is ALL if all subrtxes\n+   are of interest or NONCONST if it is safe to ignore subrtxes of\n+   constants.  */\n+#define FOR_EACH_SUBRTX(ITER, ARRAY, X, TYPE) \\\n+  for (subrtx_iterator ITER (ARRAY, X, TYPE##_BOUNDS); !ITER.at_end (); \\\n+       ITER.next ())\n+\n+/* Like FOR_EACH_SUBRTX, but iterate over subrtxes of an rtx X.  */\n+#define FOR_EACH_SUBRTX_VAR(ITER, ARRAY, X, TYPE) \\\n+  for (subrtx_var_iterator ITER (ARRAY, X, TYPE##_BOUNDS); !ITER.at_end (); \\\n+       ITER.next ())\n+\n+/* Like FOR_EACH_SUBRTX, but iterate over subrtx pointers of rtx pointer X.\n+   For example, if X is &PATTERN (insn) and the pattern is a SET, iterate\n+   over &PATTERN (insn), &SET_DEST (PATTERN (insn)), etc.  */\n+#define FOR_EACH_SUBRTX_PTR(ITER, ARRAY, X, TYPE) \\\n+  for (subrtx_ptr_iterator ITER (ARRAY, X, TYPE##_BOUNDS); !ITER.at_end (); \\\n+       ITER.next ())"}, {"sha": "e6e13a60162726d35b734d0f95eddd2bcd8af8ed", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 130, "deletions": 1, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476dd0ce18abee7581ab669bb9d5b80dcac09d82/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476dd0ce18abee7581ab669bb9d5b80dcac09d82/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=476dd0ce18abee7581ab669bb9d5b80dcac09d82", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n #include \"addresses.h\"\n+#include \"rtl-iter.h\"\n \n /* Forward declarations */\n static void set_of_1 (rtx, const_rtx, void *);\n@@ -62,6 +63,9 @@ static unsigned int num_sign_bit_copies1 (const_rtx, enum machine_mode, const_rt\n    -1 if a code has no such operand.  */\n static int non_rtx_starting_operands[NUM_RTX_CODE];\n \n+rtx_subrtx_bound_info rtx_all_subrtx_bounds[NUM_RTX_CODE];\n+rtx_subrtx_bound_info rtx_nonconst_subrtx_bounds[NUM_RTX_CODE];\n+\n /* Truncation narrows the mode from SOURCE mode to DESTINATION mode.\n    If TARGET_MODE_REP_EXTENDED (DESTINATION, DESTINATION_REP) is\n    SIGN_EXTEND then while narrowing we also have to enforce the\n@@ -78,6 +82,93 @@ static int non_rtx_starting_operands[NUM_RTX_CODE];\n static unsigned int\n num_sign_bit_copies_in_rep[MAX_MODE_INT + 1][MAX_MODE_INT + 1];\n \f\n+/* Store X into index I of ARRAY.  ARRAY is known to have at least I\n+   elements.  Return the new base of ARRAY.  */\n+\n+template <typename T>\n+typename T::value_type *\n+generic_subrtx_iterator <T>::add_single_to_queue (array_type &array,\n+\t\t\t\t\t\t  value_type *base,\n+\t\t\t\t\t\t  size_t i, value_type x)\n+{\n+  if (base == array.stack)\n+    {\n+      if (i < LOCAL_ELEMS)\n+\t{\n+\t  base[i] = x;\n+\t  return base;\n+\t}\n+      gcc_checking_assert (i == LOCAL_ELEMS);\n+      vec_safe_grow (array.heap, i + 1);\n+      base = array.heap->address ();\n+      memcpy (base, array.stack, sizeof (array.stack));\n+      base[LOCAL_ELEMS] = x;\n+      return base;\n+    }\n+  unsigned int length = array.heap->length ();\n+  if (length > i)\n+    {\n+      gcc_checking_assert (base == array.heap->address ());\n+      base[i] = x;\n+      return base;\n+    }\n+  else\n+    {\n+      gcc_checking_assert (i == length);\n+      vec_safe_push (array.heap, x);\n+      return array.heap->address ();\n+    }\n+}\n+\n+/* Add the subrtxes of X to worklist ARRAY, starting at END.  Return the\n+   number of elements added to the worklist.  */\n+\n+template <typename T>\n+size_t\n+generic_subrtx_iterator <T>::add_subrtxes_to_queue (array_type &array,\n+\t\t\t\t\t\t    value_type *base,\n+\t\t\t\t\t\t    size_t end, rtx_type x)\n+{\n+  const char *format = GET_RTX_FORMAT (GET_CODE (x));\n+  size_t orig_end = end;\n+  for (int i = 0; format[i]; ++i)\n+    if (format[i] == 'e')\n+      {\n+\tvalue_type subx = T::get_value (x->u.fld[i].rt_rtx);\n+\tif (__builtin_expect (end < LOCAL_ELEMS, true))\n+\t  base[end++] = subx;\n+\telse\n+\t  base = add_single_to_queue (array, base, end++, subx);\n+      }\n+    else if (format[i] == 'E')\n+      {\n+\tint length = GET_NUM_ELEM (x->u.fld[i].rt_rtvec);\n+\trtx *vec = x->u.fld[i].rt_rtvec->elem;\n+\tif (__builtin_expect (end + length <= LOCAL_ELEMS, true))\n+\t  for (int j = 0; j < length; j++)\n+\t    base[end++] = T::get_value (vec[j]);\n+\telse\n+\t  for (int j = 0; j < length; j++)\n+\t    base = add_single_to_queue (array, base, end++,\n+\t\t\t\t\tT::get_value (vec[j]));\n+      }\n+  return end - orig_end;\n+}\n+\n+template <typename T>\n+void\n+generic_subrtx_iterator <T>::free_array (array_type &array)\n+{\n+  vec_free (array.heap);\n+}\n+\n+template <typename T>\n+const size_t generic_subrtx_iterator <T>::LOCAL_ELEMS;\n+\n+template class generic_subrtx_iterator <const_rtx_accessor>;\n+template class generic_subrtx_iterator <rtx_var_accessor>;\n+template class generic_subrtx_iterator <rtx_ptr_accessor>;\n+\n /* Return 1 if the value of X is unstable\n    (would be different at a different point in the program).\n    The frame pointer, arg pointer, etc. are considered stable\n@@ -5346,8 +5437,42 @@ truncated_to_mode (enum machine_mode mode, const_rtx x)\n   return false;\n }\n \f\n+/* Return true if RTX code CODE has a single sequence of zero or more\n+   \"e\" operands and no rtvec operands.  Initialize its rtx_all_subrtx_bounds\n+   entry in that case.  */\n+\n+static bool\n+setup_reg_subrtx_bounds (unsigned int code)\n+{\n+  const char *format = GET_RTX_FORMAT ((enum rtx_code) code);\n+  unsigned int i = 0;\n+  for (; format[i] != 'e'; ++i)\n+    {\n+      if (!format[i])\n+\t/* No subrtxes.  Leave start and count as 0.  */\n+\treturn true;\n+      if (format[i] == 'E' || format[i] == 'V')\n+\treturn false;\n+    }\n+\n+  /* Record the sequence of 'e's.  */\n+  rtx_all_subrtx_bounds[code].start = i;\n+  do\n+    ++i;\n+  while (format[i] == 'e');\n+  rtx_all_subrtx_bounds[code].count = i - rtx_all_subrtx_bounds[code].start;\n+  /* rtl-iter.h relies on this.  */\n+  gcc_checking_assert (rtx_all_subrtx_bounds[code].count <= 3);\n+\n+  for (; format[i]; ++i)\n+    if (format[i] == 'E' || format[i] == 'V' || format[i] == 'e')\n+      return false;\n+\n+  return true;\n+}\n+\n /* Initialize non_rtx_starting_operands, which is used to speed up\n-   for_each_rtx.  */\n+   for_each_rtx, and rtx_all_subrtx_bounds.  */\n void\n init_rtlanal (void)\n {\n@@ -5357,6 +5482,10 @@ init_rtlanal (void)\n       const char *format = GET_RTX_FORMAT (i);\n       const char *first = strpbrk (format, \"eEV\");\n       non_rtx_starting_operands[i] = first ? first - format : -1;\n+      if (!setup_reg_subrtx_bounds (i))\n+\trtx_all_subrtx_bounds[i].count = UCHAR_MAX;\n+      if (GET_RTX_CLASS (i) != RTX_CONST_OBJ)\n+\trtx_nonconst_subrtx_bounds[i] = rtx_all_subrtx_bounds[i];\n     }\n \n   init_num_sign_bit_copies_in_rep ();"}]}