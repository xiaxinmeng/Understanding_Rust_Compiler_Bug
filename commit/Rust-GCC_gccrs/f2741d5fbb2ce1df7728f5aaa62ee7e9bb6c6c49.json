{"sha": "f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI3NDFkNWZiYjJjZTFkZjc3MjhmNWFhYTYyZWU3ZTliYjZjNmM0OQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-01-07T08:26:02Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-01-07T08:26:02Z"}, "message": "DatagramSocket.java: Added classpath license info.\n\n2003-01-07  Michael Koch  <konqueror@gmx.de>\n\n \t* java/net/DatagramSocket.java:\n \tAdded classpath license info.\n \t(DatagramSocket): Merged description with classpath.\n \t(close): Merged description with classpath.\n \t(getChannel): Merged description with classpath.\n \t(getInetAddress): Merged description with classpath.\n \t(getPort): Merged description with classpath.\n \t(getLocalAddress): Merged description with classpath.\n \t(getLocalPort): Merged description with classpath.\n \t(getSoTimeout): Merged description with classpath.\n \t(setSoTimeout): Merged description with classpath.\n \t(getSendBufferSize): Merged description with classpath.\n \t(setSendBufferSize): Merged description with classpath.\n \t(getReceiveBufferSize): Merged description with classpath.\n \t(setReceiveBufferSize): Merged description with classpath.\n\nFrom-SVN: r60989", "tree": {"sha": "10daee732ae5c0218bd18f1154d6c69c2c5e6c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10daee732ae5c0218bd18f1154d6c69c2c5e6c1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49/comments", "author": null, "committer": null, "parents": [{"sha": "fe50034d9ccb0a20a1b15270f9de70120628be76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe50034d9ccb0a20a1b15270f9de70120628be76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe50034d9ccb0a20a1b15270f9de70120628be76"}], "stats": {"total": 611, "additions": 344, "deletions": 267}, "files": [{"sha": "d33591262c3ea27f8c44f581211d42915b082633", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49", "patch": "@@ -1,3 +1,21 @@\n+2003-01-07  Michael Koch  <konqueror@gmx.de>\n+ \n+ \t* java/net/DatagramSocket.java:\n+ \tAdded classpath license info.\n+ \t(DatagramSocket): Merged description with classpath.\n+ \t(close): Merged description with classpath.\n+ \t(getChannel): Merged description with classpath.\n+ \t(getInetAddress): Merged description with classpath.\n+ \t(getPort): Merged description with classpath.\n+ \t(getLocalAddress): Merged description with classpath.\n+ \t(getLocalPort): Merged description with classpath.\n+ \t(getSoTimeout): Merged description with classpath.\n+ \t(setSoTimeout): Merged description with classpath.\n+ \t(getSendBufferSize): Merged description with classpath.\n+ \t(setSendBufferSize): Merged description with classpath.\n+ \t(getReceiveBufferSize): Merged description with classpath.\n+ \t(setReceiveBufferSize): Merged description with classpath.\n+\t\n 2003-01-04  Tom Tromey  <tromey@redhat.com>\n \n \t* java/awt/List.java: Merged with Classpath."}, {"sha": "2cef7b46c284b0f3e33410a697d2c7d6e589691e", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 326, "deletions": 267, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=f2741d5fbb2ce1df7728f5aaa62ee7e9bb6c6c49", "patch": "@@ -1,30 +1,64 @@\n-// DatagramSocket.java\n-\n-/* Copyright (C) 1999, 2000, 2002  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+/* DatagramSocket.java -- A class to model UDP sockets\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n package java.net;\n \n import java.io.IOException;\n import java.nio.channels.DatagramChannel;\n import java.nio.channels.IllegalBlockingModeException;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date May 3, 1999.\n- */\n-\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n \n+/**\n+ * This class models a connectionless datagram socket that sends \n+ * individual packets of data across the network.  In the TCP/IP world,\n+ * this means UDP.  Datagram packets do not have guaranteed delivery,\n+ * or any guarantee about the order the data will be received on the\n+ * remote host.\n+ * \n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Warren Levy (warrenl@cygnus.com)\n+ * @date May 3, 1999.\n+ */\n+\n public class DatagramSocket\n {\n   /**\n@@ -33,24 +67,22 @@\n    */\n   static DatagramSocketImplFactory factory;\n \t  \n+  /**\n+   * This is the implementation object used by this socket.\n+   */\n   DatagramSocketImpl impl;\n \n   DatagramChannel ch;\n \n+  /**\n+   * This is the address we are \"connected\" to\n+   */\n   private InetAddress remoteAddress;\n-  private int remotePort;\n \n   /**\n-   * Creates a DatagramSocket\n-   *\n-   * @exception SocketException If an error occurs\n-   * @exception SecurityException If a security manager exists and\n-   * its checkListen method doesn't allow the operation\n+   * This is the port we are \"connected\" to\n    */\n-  public DatagramSocket() throws SocketException\n-  {\n-    this(0, null);\n-  }\n+  private int remotePort;\n \n   /**\n    * Creates a DatagramSocket from a specified DatagramSocketImpl instance\n@@ -67,46 +99,43 @@ protected DatagramSocket (DatagramSocketImpl impl)\n   }\n \n   /**\n-   * Creates a datagram socket that is bound to a given socket address\n-   *\n-   * @param bindaddr The socket address to bind to\n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * a random port and every address on the local machine.\n    *\n-   * @exception SocketException If an error occurs\n+   * @exception SocketException If an error occurs.\n    * @exception SecurityException If a security manager exists and\n-   * its checkListen method doesn't allow the operation\n-   * \n-   * @since 1.4\n+   * its checkListen method doesn't allow the operation.\n    */\n-  public DatagramSocket (SocketAddress bindaddr)\n-    throws SocketException\n+  public DatagramSocket() throws SocketException\n   {\n-    this (((InetSocketAddress) bindaddr).getPort (),\n-          ((InetSocketAddress) bindaddr).getAddress ());\n+    this(0, null);\n   }\n \n   /**\n-   * Creates a datagram socket that is bound to a specific port\n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * the specified port and every address on the local machine.\n    *\n-   * @param port The port number to bind to\n+   * @param port The local port number to bind to.\n    *\n-   * @exception SocketException If an error occurs\n-   * @exception SecurityException If a security manager exists and\n-   * its checkListen method doesn't allow the operation\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation.\n+   * @exception SocketException If an error occurs.\n    */\n   public DatagramSocket(int port) throws SocketException\n   {\n     this(port, null);\n   }\n \n   /**\n-   * Creates a datagram socket that is bound to a specific port/inet address\n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * the specified local port and address.\n    *\n-   * @param port The port number to bind to\n-   * @param laddr The local address to bind to\n+   * @param port The local port number to bind to.\n+   * @param laddr The local address to bind to.\n    *\n-   * @exception SocketException If an error occurs\n-   * @exception SecurityException If a security manager exists and\n-   * its checkListen method doesn't allow the operation\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation.\n+   * @exception SocketException If an error occurs.\n    */\n   public DatagramSocket(int port, InetAddress laddr) throws SocketException\n   {\n@@ -123,8 +152,8 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n     else\n       try\n \t{\n-\t  impl = (DatagramSocketImpl) Class.forName(\"java.net.\" + propVal +\n-\t\t\t\t\t\"DatagramSocketImpl\").newInstance();\n+          impl = (DatagramSocketImpl) Class.forName\n+            (\"java.net.\" + propVal + \"DatagramSocketImpl\").newInstance();\n \t}\n       catch (Exception e)\n \t{\n@@ -145,34 +174,26 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n   }\n \n   /**\n-   * Binds the socket to the given socket addres\n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * the specified local port and address.\n    *\n-   * @param address The socket address to bind to\n+   * @param port The local port number to bind to.\n+   * @param laddr The local address to bind to.\n    *\n-   * @exception SocketException If an error occurs\n-   * @exception SecurityException If a security manager exists and\n-   * its checkListen method doesn't allow the operation\n-   * @exception IllegalArgumentException If address type is not supported\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation.\n+   * @exception SocketException If an error occurs.\n    *\n    * @since 1.4\n    */\n-  public void bind (SocketAddress address)\n-    throws SocketException\n+  public DatagramSocket (SocketAddress address) throws SocketException\n   {\n-    if (! (address instanceof InetSocketAddress))\n-      throw new IllegalArgumentException ();\n-\n-    InetSocketAddress tmp = (InetSocketAddress) address;\n-\n-    SecurityManager s = System.getSecurityManager ();\n-    if (s != null)\n-      s.checkListen(tmp.getPort ());\n-\n-    impl.bind (tmp.getPort (), tmp.getAddress ());\n+    this (((InetSocketAddress) address).getPort (),\n+          ((InetSocketAddress) address).getAddress ());\n   }\n   \n   /**\n-   * Closes the datagram socket\n+   * Closes this datagram socket.\n    */\n   public void close()\n   {\n@@ -182,27 +203,41 @@ public void close()\n   }\n \n   /**\n-   * Checks if the datagram socket is closed\n+   * This method returns the remote address to which this socket is \n+   * connected.  If this socket is not connected, then this method will\n+   * return <code>null</code>.\n    * \n-   * @since 1.4\n+   * @return The remote address.\n+   *\n+   * @since 1.2\n    */\n-  public boolean isClosed()\n+  public InetAddress getInetAddress()\n   {\n-    return !impl.getFileDescriptor().valid();\n+    if (!isConnected ())\n+      return null;\n+\n+    return remoteAddress;\n   }\n \n   /**\n-   * Gets a datagram channel assoziated with the socket\n+   * This method returns the remote port to which this socket is\n+   * connected.  If this socket is not connected, then this method will\n+   * return -1.\n    * \n-   * @since 1.4\n+   * @return The remote port.\n+   *\n+   * @since 1.2\n    */\n-  public DatagramChannel getChannel()\n+  public int getPort()\n   {\n-    return ch;\n+    if (!isConnected ())\n+      return -1;\n+    \n+    return remotePort;\n   }\n \n   /**\n-   * Returns the local address of the datagram socket\n+   * Returns the local address this datagram socket is bound to.\n    * \n    * @since 1.1\n    */\n@@ -244,9 +279,9 @@ public InetAddress getLocalAddress()\n   }\n \n   /**\n-   * Returns the local port this socket uses\n+   * Returns the local port this socket is bound to.\n    *\n-   * @return The local port number\n+   * @return The local port number.\n    */\n   public int getLocalPort()\n   {\n@@ -257,11 +292,12 @@ public int getLocalPort()\n   }\n \n   /**\n-   * Gets the SO_TIMEOUT value\n+   * Returns the value of the socket's SO_TIMEOUT setting.  If this method\n+   * returns 0 then SO_TIMEOUT is disabled.\n    *\n-   * @return The current timeout in milliseconds\n+   * @return The current timeout in milliseconds.\n    *\n-   * @exception SocketException If an error occurs\n+   * @exception SocketException If an error occurs.\n    * \n    * @since 1.1\n    */\n@@ -271,27 +307,181 @@ public synchronized int getSoTimeout() throws SocketException\n       throw new SocketException (\"Cannot initialize Socket implementation\");\n \n     Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n+\n     if (timeout instanceof Integer) \n       return ((Integer)timeout).intValue();\n     else\n       return 0;\n   }\n \n   /**\n-   * Receive a datagram packet\n+   * Sets the value of the socket's SO_TIMEOUT value.  A value of 0 will\n+   * disable SO_TIMEOUT.  Any other value is the number of milliseconds\n+   * a socket read/write will block before timing out.\n+   *\n+   * @param timeout The new SO_TIMEOUT value in milliseconds.\n+   *\n+   * @exception SocketException If an error occurs.\n+   *\n+   * @since 1.1\n+   */\n+  public synchronized void setSoTimeout(int timeout) throws SocketException\n+  {\n+    if (timeout < 0)\n+      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n+\n+    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n+  }\n+\n+  /**\n+   * This method returns the value of the system level socket option\n+   * SO_SNDBUF, which is used by the operating system to tune buffer\n+   * sizes for data transfers.\n+   *\n+   * @return The send buffer size.\n+   *\n+   * @exception SocketException If an error occurs.\n+   *\n+   * @since 1.2\n+   */\n+  public int getSendBufferSize() throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    Object obj = impl.getOption(SocketOptions.SO_SNDBUF);\n+\n+    if (obj instanceof Integer)\n+      return(((Integer)obj).intValue());\n+    else\n+      throw new SocketException(\"Unexpected type\");\n+  }\n+\n+  /**\n+   * This method sets the value for the system level socket option\n+   * SO_SNDBUF to the specified value.  Note that valid values for this\n+   * option are specific to a given operating system.\n+   *\n+   * @param size The new send buffer size.\n+   *\n+   * @exception SocketException If an error occurs.\n+   * @exception IllegalArgumentException If size is 0 or negative.\n+   *\n+   * @since 1.2\n+   */\n+  public void setSendBufferSize(int size) throws SocketException\n+  {\n+    if (size < 0)\n+      throw new IllegalArgumentException(\"Buffer size is less than 0\");\n+  \n+    impl.setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n+  }\n+\n+  /**\n+   * This method returns the value of the system level socket option\n+   * SO_RCVBUF, which is used by the operating system to tune buffer\n+   * sizes for data transfers.\n+   *\n+   * @return The receive buffer size.\n+   *\n+   * @exception SocketException If an error occurs.\n    *\n-   * @param p The datagram packet to put the incoming data into\n+   * @since 1.2\n+   */\n+  public int getReceiveBufferSize() throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    Object obj = impl.getOption(SocketOptions.SO_RCVBUF);\n+  \n+    if (obj instanceof Integer)\n+      return(((Integer)obj).intValue());\n+    else \n+      throw new SocketException(\"Unexpected type\");\n+  }\n+\n+  /**\n+   * This method sets the value for the system level socket option\n+   * SO_RCVBUF to the specified value.  Note that valid values for this\n+   * option are specific to a given operating system.\n+   *\n+   * @param size The new receive buffer size.\n+   *\n+   * @exception SocketException If an error occurs.\n+   * @exception IllegalArgumentException If size is 0 or negative.\n    * \n-   * @exception IOException If an error occurs\n+   * @since 1.2\n+   */\n+  public void setReceiveBufferSize(int size) throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    if (size < 0)\n+      throw new IllegalArgumentException(\"Buffer size is less than 0\");\n+\n+    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n+  }\n+\n+  /**\n+   * Connects the datagram socket to a specified address/port.\n+   *\n+   * @param address The address to connect to.\n+   * @param port The port to connect to.\n+   *\n+   * @exception SocketException If an error occurs.\n+   * @exception IllegalArgumentException If address is null\n+   * or the port number is illegal.\n+   * @exception SecurityException If the caller is not allowed to send\n+   * datagrams to and receive datagrams from the address and port.\n+   *\n+   * @since 1.2\n+   */\n+  public void connect(InetAddress address, int port)\n+    throws SocketException\n+  {\n+    if (address == null)\n+      throw new IllegalArgumentException (\"Address may not be null\");\n+\n+    if ((port < 1) || (port > 65535))\n+      throw new IllegalArgumentException (\"Port number is illegal\");\n+\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkAccept(address.getHostName (), port);\n+\n+    impl.connect (address, port);\n+\n+    remoteAddress = address;\n+    remotePort = port;\n+  }\n+\n+  /**\n+   * Disconnects the datagram socket.\n+   *\n+   * @since 1.2\n+   */\n+  public void disconnect()\n+  {\n+    impl.disconnect();\n+  }\n+\n+  /**\n+   * Receive a datagram packet.\n+   *\n+   * @param p The datagram packet to put the incoming data into.\n+   * \n+   * @exception IOException If an error occurs.\n    * @exception SocketTimeoutException If setSoTimeout was previously called\n-   * and the timeout has expired\n+   * and the timeout has expired.\n    * @exception PortUnreachableException If the socket is connected to a\n    * currently unreachable destination. Note, there is no guarantee that the\n-   * exception will be thrown\n+   * exception will be thrown.\n    * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode\n+   * channel, and the channel is in non-blocking mode.\n    * @exception SecurityException If a security manager exists and its\n-   * checkAccept ethod doesn't allow the receive\n+   * checkAccept ethod doesn't allow the receive.\n    */\n   public synchronized void receive(DatagramPacket p) throws IOException\n   {\n@@ -313,18 +503,18 @@ public synchronized void receive(DatagramPacket p) throws IOException\n   }\n \n   /**\n-   * Sends a datagram packet\n+   * Sends a datagram packet.\n    *\n-   * @param p The datagram packet to send\n+   * @param p The datagram packet to send.\n    *\n-   * @exception IOException If an error occurs\n+   * @exception IOException If an error occurs.\n    * @exception SecurityException If a security manager exists and its\n-   * checkMulticast or checkConnect method doesn't allow the send\n+   * checkMulticast or checkConnect method doesn't allow the send.\n    * @exception PortUnreachableException If the socket is connected to a\n    * currently unreachable destination. Note, there is no guarantee that the\n-   * exception will be thrown\n+   * exception will be thrown.\n    * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode\n+   * channel, and the channel is in non-blocking mode.\n    */\n   public void send(DatagramPacket p) throws IOException\n   {\n@@ -357,62 +547,59 @@ public void send(DatagramPacket p) throws IOException\n   }\n \n   /**\n-   * Sets a new value for SO_TIMEOUT\n+   * Binds the socket to the given socket address.\n    *\n-   * @param timeout The timeout in milliseconds\n+   * @param address The socket address to bind to.\n    *\n-   * @exception SocketException If an error occurs\n+   * @exception SocketException If an error occurs.\n+   * @exception SecurityException If a security manager exists and\n+   * its checkListen method doesn't allow the operation.\n+   * @exception IllegalArgumentException If address type is not supported.\n    *\n-   * @since 1.1\n+   * @since 1.4\n    */\n-  public synchronized void setSoTimeout(int timeout) throws SocketException\n+  public void bind (SocketAddress address)\n+    throws SocketException\n   {\n-    if (timeout < 0)\n-      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n+    if (! (address instanceof InetSocketAddress))\n+      throw new IllegalArgumentException ();\n \n-    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n+    InetSocketAddress tmp = (InetSocketAddress) address;\n+\n+    SecurityManager s = System.getSecurityManager ();\n+    if (s != null)\n+      s.checkListen(tmp.getPort ());\n+\n+    impl.bind (tmp.getPort (), tmp.getAddress ());\n   }\n \n   /**\n-   * Connects the datagrem socket to a specified address/port\n-   *\n-   * @param address The address to connect to\n-   * @param port The port to connect to\n-   *\n-   * @exception SocketException If an error occurs\n-   * @exception IllegalArgumentException If address is null\n-   * or the port number is illegal\n-   * @exception SecurityException If the caller is not allowed to send\n-   * datagrams to and receive datagrams from the address and port\n+   * Checks if the datagram socket is closed.\n    *\n-   * @since 1.2\n+   * @since 1.4\n    */\n-  public void connect(InetAddress address, int port)\n-    throws SocketException\n+  public boolean isClosed()\n   {\n-    if (address == null)\n-      throw new IllegalArgumentException (\"Address may not be null\");\n-\n-    if (port < 1 || port > 65535)\n-      throw new IllegalArgumentException (\"Port number is illegal\");\n-\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkAccept(address.getHostName (), port);\n-\n-    impl.connect (address, port);\n+    return !impl.getFileDescriptor().valid();\n+  }\n \n-    remoteAddress = address;\n-    remotePort = port;\n+  /**\n+   * Returns the datagram channel assoziated with this datagram socket.\n+   * \n+   * @since 1.4\n+   */\n+  public DatagramChannel getChannel()\n+  {\n+    return ch;\n   }\n \n   /**\n    * Connects the datagram socket to a specified socket address.\n    *\n-   * @param address The socket address to connect to\n+   * @param address The socket address to connect to.\n    *\n-   * @exception SocketException If an error occurs\n-   * @exception IllegalArgumentException If address type is not supported\n+   * @exception SocketException If an error occurs.\n+   * @exception IllegalArgumentException If address type is not supported.\n    *\n    * @since 1.4\n    */\n@@ -427,17 +614,7 @@ public void connect (SocketAddress address) throws SocketException\n   }\n   \n   /**\n-   * Disconnects the datagram socket\n-   *\n-   * @since 1.2\n-   */\n-  public void disconnect()\n-  {\n-    impl.disconnect();\n-  }\n-\n-  /**\n-   * Returns the binding state of the socket\n+   * Returns the binding state of the socket.\n    * \n    * @since 1.4\n    */\n@@ -456,7 +633,7 @@ public boolean isBound()\n   }\n \n   /**\n-   * Returns the connection state of the socket\n+   * Returns the connection state of the socket.\n    * \n    * @since 1.4\n    */\n@@ -465,36 +642,9 @@ public boolean isConnected()\n     return remoteAddress != null;\n   }\n \n-  /**\n-   * Returns the InetAddress the socket is connected to\n-   * or null if the socket is not connected\n-   * \n-   * @since 1.2\n-   */\n-  public InetAddress getInetAddress()\n-  {\n-    if (!isConnected ())\n-      return null;\n-\n-    return remoteAddress;\n-  }\n-\n-  /**\n-   * Returns the port number the socket is connected to or -1 if not connected\n-   * \n-   * @since 1.2\n-   */\n-  public int getPort()\n-  {\n-    if (!isConnected ())\n-      return -1;\n-    \n-    return remotePort;\n-  }\n-\n   /**\n    * Returns the SocketAddress of the host this socket is conneted to\n-   * or null if this socket is not connected\n+   * or null if this socket is not connected.\n    * \n    * @since 1.4\n    */\n@@ -508,7 +658,7 @@ public SocketAddress getRemoteSocketAddress()\n \n   /**\n    * Returns the local SocketAddress this socket is bound to\n-   * or null if it is not bound\n+   * or null if it is not bound.\n    * \n    * @since 1.4\n    */\n@@ -529,36 +679,12 @@ public SocketAddress getLocalSocketAddress()\n   }\n \n   /**\n-   * This method returns the value of the system level socket option\n-   * SO_RCVBUF, which is used by the operating system to tune buffer\n-   * sizes for data transfers.\n+   * Enables/Disables SO_REUSEADDR.\n    *\n-   * @return The receive buffer size.\n+   * @param on Whether or not to have SO_REUSEADDR turned on.\n    *\n    * @exception SocketException If an error occurs.\n    *\n-   * @since 1.2\n-   */\n-  public int getReceiveBufferSize() throws SocketException\n-  {\n-    if (impl == null)\n-      throw new SocketException (\"Cannot initialize Socket implementation\");\n-\n-    Object obj = impl.getOption(SocketOptions.SO_RCVBUF);\n-  \n-    if (obj instanceof Integer)\n-      return(((Integer)obj).intValue());\n-    else \n-      throw new SocketException(\"Unexpected type\");\n-  }\n-\n-  /**\n-   * Enables/Disables SO_REUSEADDR\n-   * \n-   * @param on Whether or not to have SO_REUSEADDR turned on\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n    * @since 1.4\n    */\n   public void setReuseAddress(boolean on) throws SocketException\n@@ -570,9 +696,9 @@ public void setReuseAddress(boolean on) throws SocketException\n   }\n \n   /**\n-   * Checks if SO_REUSEADDR is enabled\n+   * Checks if SO_REUSEADDR is enabled.\n    *\n-   * @exception SocketException If an error occurs\n+   * @exception SocketException If an error occurs.\n    * \n    * @since 1.4\n    */\n@@ -672,73 +798,6 @@ public int getTrafficClass() throws SocketException\n       throw new SocketException (\"Unexpected type\");\n   }\n   \n-  /**\n-   * This method returns the value of the system level socket option\n-   * SO_SNDBUF, which is used by the operating system to tune buffer\n-   * sizes for data transfers.\n-   *\n-   * @return The send buffer size.\n-   *\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.2\n-   */\n-  public int getSendBufferSize() throws SocketException\n-  {\n-    if (impl == null)\n-      throw new SocketException (\"Cannot initialize Socket implementation\");\n-\n-    Object obj = impl.getOption(SocketOptions.SO_SNDBUF);\n-\n-    if (obj instanceof Integer)\n-      return(((Integer)obj).intValue());\n-    else\n-      throw new SocketException(\"Unexpected type\");\n-  }\n-\n-  /**\n-   * This method sets the value for the system level socket option\n-   * SO_RCVBUF to the specified value.  Note that valid values for this\n-   * option are specific to a given operating system.\n-   *\n-   * @param size The new receive buffer size.\n-   *\n-   * @exception SocketException If an error occurs.\n-   * @exception IllegalArgumentException If size is 0 or negative\n-   *  \n-   * @since 1.2\n-   */\n-  public void setReceiveBufferSize(int size) throws SocketException\n-  {\n-    if (impl == null)\n-      throw new SocketException (\"Cannot initialize Socket implementation\");\n-\n-    if (size < 0)\n-      throw new IllegalArgumentException(\"Buffer size is less than 0\");\n-\n-    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n-  }\n-\n-  /**\n-   * This method sets the value for the system level socket option\n-   * SO_SNDBUF to the specified value.  Note that valid values for this\n-   * option are specific to a given operating system.\n-   *\n-   * @param size The new send buffer size.\n-   *\n-   * @exception SocketException If an error occurs.\n-   * @exception IllegalArgumentException If size is 0 or negative\n-   *\n-   * @since 1.2\n-   */\n-  public void setSendBufferSize(int size) throws SocketException\n-  {\n-    if (size < 0)\n-      throw new IllegalArgumentException(\"Buffer size is less than 0\");\n-  \n-    impl.setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n-  }\n-\n   /**\n    * Sets the datagram socket implementation factory for the application\n    *"}]}