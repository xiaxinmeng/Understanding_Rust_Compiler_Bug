{"sha": "27e29549a03c1c71c56abb27767d8393f7d0e65e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdlMjk1NDlhMDNjMWM3MWM1NmFiYjI3NzY3ZDgzOTNmN2QwZTY1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-11-14T06:22:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-11-14T06:22:56Z"}, "message": "calls.c (precompute_register_parameters): Force all PARALLELs into pseudo registers.\n\n        * calls.c (precompute_register_parameters): Force all PARALLELs\n        into pseudo registers.\n        (load_register_parameters): Copy PARALLELs into hard registers.\n        * function.c (assign_parm_setup_block): Copy PARALLELS into\n        pseudo registers.  Do emit_group_store in conversion_insns.\n        * expr.c (emit_group_load_1): Rename from emit_group_load, take\n        tmps as an argument.  Move final copy loop ...\n        (emit_group_load): ... here.  New function.\n        (emit_group_load_into_temps, emit_group_move_into_temps): New.\n        * expr.h: Declare them.\n\nFrom-SVN: r90613", "tree": {"sha": "289c94268246a21e58d4318a10556bfb945f4896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/289c94268246a21e58d4318a10556bfb945f4896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27e29549a03c1c71c56abb27767d8393f7d0e65e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e29549a03c1c71c56abb27767d8393f7d0e65e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e29549a03c1c71c56abb27767d8393f7d0e65e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e29549a03c1c71c56abb27767d8393f7d0e65e/comments", "author": null, "committer": null, "parents": [{"sha": "eaf0dc0254ab1fafb2a22b12ad336a23eae0197b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf0dc0254ab1fafb2a22b12ad336a23eae0197b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf0dc0254ab1fafb2a22b12ad336a23eae0197b"}], "stats": {"total": 175, "additions": 143, "deletions": 32}, "files": [{"sha": "82ca433c09feb0943eee3c14ac48c3c829b18aef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27e29549a03c1c71c56abb27767d8393f7d0e65e", "patch": "@@ -1,3 +1,16 @@\n+2004-11-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* calls.c (precompute_register_parameters): Force all PARALLELs\n+\tinto pseudo registers.\n+\t(load_register_parameters): Copy PARALLELs into hard registers.\n+\t* function.c (assign_parm_setup_block): Copy PARALLELS into\n+\tpseudo registers.  Do emit_group_store in conversion_insns.\n+\t* expr.c (emit_group_load_1): Rename from emit_group_load, take\n+\ttmps as an argument.  Move final copy loop ...\n+\t(emit_group_load): ... here.  New function.\n+\t(emit_group_load_into_temps, emit_group_move_into_temps): New.\n+\t* expr.h: Declare them.\n+\n 2004-11-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-cfg.c, tree-if-conv.c, tree-ssa-loop-ivopts.c,"}, {"sha": "e66181e9f9fc8ba6fc4f339f9290d4463b092e3a", "filename": "gcc/calls.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=27e29549a03c1c71c56abb27767d8393f7d0e65e", "patch": "@@ -644,7 +644,8 @@ call_expr_flags (tree t)\n    Set REG_PARM_SEEN if we encounter a register parameter.  */\n \n static void\n-precompute_register_parameters (int num_actuals, struct arg_data *args, int *reg_parm_seen)\n+precompute_register_parameters (int num_actuals, struct arg_data *args,\n+\t\t\t\tint *reg_parm_seen)\n {\n   int i;\n \n@@ -679,6 +680,17 @@ precompute_register_parameters (int num_actuals, struct arg_data *args, int *reg\n \t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n \t\t\t     args[i].value, args[i].unsignedp);\n \n+\t/* If we're going to have to load the value by parts, pull the\n+\t   parts into pseudos.  The part extraction process can involve\n+\t   non-trivial computation.  */\n+\tif (GET_CODE (args[i].reg) == PARALLEL)\n+\t  {\n+\t    tree type = TREE_TYPE (args[i].tree_value);\n+\t    args[i].value\n+\t      = emit_group_load_into_temps (args[i].reg, args[i].value,\n+\t\t\t\t\t    type, int_size_in_bytes (type));\n+\t  }\n+\n \t/* If the value is expensive, and we are inside an appropriately\n \t   short loop, put the value into a pseudo and then put the pseudo\n \t   into the hard reg.\n@@ -687,13 +699,13 @@ precompute_register_parameters (int num_actuals, struct arg_data *args, int *reg\n \t   register parameters.  This is to avoid reload conflicts while\n \t   loading the parameters registers.  */\n \n-\tif ((! (REG_P (args[i].value)\n-\t\t|| (GET_CODE (args[i].value) == SUBREG\n-\t\t    && REG_P (SUBREG_REG (args[i].value)))))\n-\t    && args[i].mode != BLKmode\n-\t    && rtx_cost (args[i].value, SET) > COSTS_N_INSNS (1)\n-\t    && ((SMALL_REGISTER_CLASSES && *reg_parm_seen)\n-\t\t|| optimize))\n+\telse if ((! (REG_P (args[i].value)\n+\t\t     || (GET_CODE (args[i].value) == SUBREG\n+\t\t\t && REG_P (SUBREG_REG (args[i].value)))))\n+\t\t && args[i].mode != BLKmode\n+\t\t && rtx_cost (args[i].value, SET) > COSTS_N_INSNS (1)\n+\t\t && ((SMALL_REGISTER_CLASSES && *reg_parm_seen)\n+\t\t     || optimize))\n \t  args[i].value = copy_to_mode_reg (args[i].mode, args[i].value);\n       }\n }\n@@ -1454,11 +1466,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t     locations.  The Irix 6 ABI has examples of this.  */\n \n \t  if (GET_CODE (reg) == PARALLEL)\n-\t    {\n-\t      tree type = TREE_TYPE (args[i].tree_value);\n-\t      emit_group_load (reg, args[i].value, type,\n-\t\t\t       int_size_in_bytes (type));\n-\t    }\n+\t    emit_group_move (reg, args[i].value);\n \n \t  /* If simple case, just do move.  If normal partial, store_one_arg\n \t     has already loaded the register for us.  In all other cases,"}, {"sha": "59da4fdbdea57b1472559f2d9bd92bec3dc514f1", "filename": "gcc/expr.c", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=27e29549a03c1c71c56abb27767d8393f7d0e65e", "patch": "@@ -1557,15 +1557,14 @@ gen_group_rtx (rtx orig)\n   return gen_rtx_PARALLEL (GET_MODE (orig), gen_rtvec_v (length, tmps));\n }\n \n-/* Emit code to move a block ORIG_SRC of type TYPE to a block DST,\n-   where DST is non-consecutive registers represented by a PARALLEL.\n-   SSIZE represents the total size of block ORIG_SRC in bytes, or -1\n-   if not known.  */\n+/* A subroutine of emit_group_load.  Arguments as for emit_group_load,\n+   except that values are placed in TMPS[i], and must later be moved\n+   into corrosponding XEXP (XVECEXP (DST, 0, i), 0) element.  */\n \n-void\n-emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n+static void\n+emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n {\n-  rtx *tmps, src;\n+  rtx src;\n   int start, i;\n   enum machine_mode m = GET_MODE (orig_src);\n \n@@ -1585,7 +1584,7 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n       /* ...and back again.  */\n       if (imode != BLKmode)\n \tsrc = gen_lowpart (imode, src);\n-      emit_group_load (dst, src, type, ssize);\n+      emit_group_load_1 (tmps, dst, src, type, ssize);\n       return;\n     }\n \n@@ -1596,8 +1595,6 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n   else\n     start = 1;\n \n-  tmps = alloca (sizeof (rtx) * XVECLEN (dst, 0));\n-\n   /* Process the pieces.  */\n   for (i = start; i < XVECLEN (dst, 0); i++)\n     {\n@@ -1709,10 +1706,61 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n \ttmps[i] = expand_shift (LSHIFT_EXPR, mode, tmps[i],\n \t\t\t\tbuild_int_cst (NULL_TREE, shift), tmps[i], 0);\n     }\n+}\n+\n+/* Emit code to move a block SRC of type TYPE to a block DST,\n+   where DST is non-consecutive registers represented by a PARALLEL.\n+   SSIZE represents the total size of block ORIG_SRC in bytes, or -1\n+   if not known.  */\n+\n+void\n+emit_group_load (rtx dst, rtx src, tree type, int ssize)\n+{\n+  rtx *tmps;\n+  int i;\n+\n+  tmps = alloca (sizeof (rtx) * XVECLEN (dst, 0));\n+  emit_group_load_1 (tmps, dst, src, type, ssize);\n \n   /* Copy the extracted pieces into the proper (probable) hard regs.  */\n-  for (i = start; i < XVECLEN (dst, 0); i++)\n-    emit_move_insn (XEXP (XVECEXP (dst, 0, i), 0), tmps[i]);\n+  for (i = 0; i < XVECLEN (dst, 0); i++)\n+    {\n+      rtx d = XEXP (XVECEXP (dst, 0, i), 0);\n+      if (d == NULL)\n+\tcontinue;\n+      emit_move_insn (d, tmps[i]);\n+    }\n+}\n+\n+/* Similar, but load SRC into new pseudos in a format that looks like\n+   PARALLEL.  This can later be fed to emit_group_move to get things\n+   in the right place.  */\n+\n+rtx\n+emit_group_load_into_temps (rtx parallel, rtx src, tree type, int ssize)\n+{\n+  rtvec vec;\n+  int i;\n+\n+  vec = rtvec_alloc (XVECLEN (parallel, 0));\n+  emit_group_load_1 (&RTVEC_ELT (vec, 0), parallel, src, type, ssize);\n+\n+  /* Convert the vector to look just like the original PARALLEL, except\n+     with the computed values.  */\n+  for (i = 0; i < XVECLEN (parallel, 0); i++)\n+    {\n+      rtx e = XVECEXP (parallel, 0, i);\n+      rtx d = XEXP (e, 0);\n+\n+      if (d)\n+\t{\n+\t  d = force_reg (GET_MODE (d), RTVEC_ELT (vec, i));\n+\t  e = alloc_EXPR_LIST (REG_NOTE_KIND (e), d, XEXP (e, 1));\n+\t}\n+      RTVEC_ELT (vec, i) = e;\n+    }\n+\n+  return gen_rtx_PARALLEL (GET_MODE (parallel), vec);\n }\n \n /* Emit code to move a block SRC to block DST, where SRC and DST are\n@@ -1733,6 +1781,27 @@ emit_group_move (rtx dst, rtx src)\n \t\t    XEXP (XVECEXP (src, 0, i), 0));\n }\n \n+/* Move a group of registers represented by a PARALLEL into pseudos.  */\n+\n+rtx\n+emit_group_move_into_temps (rtx src)\n+{\n+  rtvec vec = rtvec_alloc (XVECLEN (src, 0));\n+  int i;\n+\n+  for (i = 0; i < XVECLEN (src, 0); i++)\n+    {\n+      rtx e = XVECEXP (src, 0, i);\n+      rtx d = XEXP (e, 0);\n+\n+      if (d)\n+\te = alloc_EXPR_LIST (REG_NOTE_KIND (e), copy_to_reg (d), XEXP (e, 1));\n+      RTVEC_ELT (vec, i) = e;\n+    }\n+\n+  return gen_rtx_PARALLEL (GET_MODE (src), vec);\n+}\n+\n /* Emit code to move a block SRC to a block ORIG_DST of type TYPE,\n    where SRC is non-consecutive registers represented by a PARALLEL.\n    SSIZE represents the total size of block ORIG_DST, or -1 if not"}, {"sha": "feac478a5abf913bc03d03d21366be2cf6b9b3a2", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=27e29549a03c1c71c56abb27767d8393f7d0e65e", "patch": "@@ -387,10 +387,16 @@ extern rtx gen_group_rtx (rtx);\n    PARALLEL.  */\n extern void emit_group_load (rtx, rtx, tree, int);\n \n+/* Similarly, but load into new temporaries.  */\n+extern rtx emit_group_load_into_temps (rtx, rtx, tree, int);\n+\n /* Move a non-consecutive group of registers represented by a PARALLEL into\n    a non-consecutive group of registers represented by a PARALLEL.  */\n extern void emit_group_move (rtx, rtx);\n \n+/* Move a group of registers represented by a PARALLEL into pseudos.  */\n+extern rtx emit_group_move_into_temps (rtx);\n+\n /* Store a BLKmode value from non-consecutive registers represented by a\n    PARALLEL.  */\n extern void emit_group_store (rtx, rtx, tree, int);"}, {"sha": "e4e04d2a53d743d77ed865e70007a6f6fbdeb3cb", "filename": "gcc/function.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e29549a03c1c71c56abb27767d8393f7d0e65e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=27e29549a03c1c71c56abb27767d8393f7d0e65e", "patch": "@@ -2536,11 +2536,15 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n    present and valid in DATA->STACK_RTL.  */\n \n static void\n-assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n+assign_parm_setup_block (struct assign_parm_data_all *all,\n+\t\t\t tree parm, struct assign_parm_data_one *data)\n {\n   rtx entry_parm = data->entry_parm;\n   rtx stack_parm = data->stack_parm;\n \n+  if (GET_CODE (entry_parm) == PARALLEL)\n+    entry_parm = emit_group_move_into_temps (entry_parm);\n+\n   /* If we've a non-block object that's nevertheless passed in parts,\n      reconstitute it in register operations rather than on the stack.  */\n   if (GET_CODE (entry_parm) == PARALLEL\n@@ -2550,6 +2554,8 @@ assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n     {\n       rtx parmreg = gen_reg_rtx (data->nominal_mode);\n \n+      push_to_sequence (all->conversion_insns);\n+\n       /* For values returned in multiple registers, handle possible\n \t incompatible calls to emit_group_store.\n \n@@ -2572,6 +2578,10 @@ assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n       else\n \temit_group_store (parmreg, entry_parm, data->nominal_type,\n \t\t\t  int_size_in_bytes (data->nominal_type));\n+\n+      all->conversion_insns = get_insns ();\n+      end_sequence ();\n+\n       SET_DECL_RTL (parm, parmreg);\n       return;\n     }\n@@ -2609,7 +2619,12 @@ assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n \n       /* Handle values in multiple non-contiguous locations.  */\n       if (GET_CODE (entry_parm) == PARALLEL)\n-\temit_group_store (mem, entry_parm, data->passed_type, size);\n+\t{\n+\t  push_to_sequence (all->conversion_insns);\n+\t  emit_group_store (mem, entry_parm, data->passed_type, size);\n+\t  all->conversion_insns = get_insns ();\n+\t  end_sequence ();\n+\t}\n \n       else if (size == 0)\n \t;\n@@ -2648,7 +2663,7 @@ assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n \t    {\n \t      rtx tem, x;\n \t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n-\t      rtx reg = gen_rtx_REG (word_mode, REGNO (data->entry_parm));\n+\t      rtx reg = gen_lowpart (word_mode, entry_parm);\n \n \t      x = expand_shift (LSHIFT_EXPR, word_mode, reg,\n \t\t\t\tbuild_int_cst (NULL_TREE, by),\n@@ -2657,11 +2672,11 @@ assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n \t      emit_move_insn (tem, x);\n \t    }\n \t  else\n-\t    move_block_from_reg (REGNO (data->entry_parm), mem,\n+\t    move_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t\t size_stored / UNITS_PER_WORD);\n \t}\n       else\n-\tmove_block_from_reg (REGNO (data->entry_parm), mem,\n+\tmove_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t     size_stored / UNITS_PER_WORD);\n     }\n \n@@ -2782,7 +2797,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  emit_move_insn (tempreg, DECL_RTL (parm));\n \t  tempreg = convert_to_mode (GET_MODE (parmreg), tempreg, unsigned_p);\n \t  emit_move_insn (parmreg, tempreg);\n-\t  all->conversion_insns = get_insns();\n+\t  all->conversion_insns = get_insns ();\n \t  end_sequence ();\n \n \t  did_conversion = true;\n@@ -3083,7 +3098,7 @@ assign_parms (tree fndecl)\n       assign_parm_adjust_stack_rtl (&data);\n \n       if (assign_parm_setup_block_p (&data))\n-\tassign_parm_setup_block (parm, &data);\n+\tassign_parm_setup_block (&all, parm, &data);\n       else if (data.passed_pointer || use_register_for_decl (parm))\n \tassign_parm_setup_reg (&all, parm, &data);\n       else"}]}