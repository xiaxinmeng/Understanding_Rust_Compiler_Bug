{"sha": "058bfe530068df2d3ccc4131a1837b44a83acba4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4YmZlNTMwMDY4ZGYyZDNjY2M0MTMxYTE4MzdiNDRhODNhY2JhNA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-07-10T00:22:35Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-07-10T00:22:35Z"}, "message": "make ObjC do LTO.\n\ngcc/\n\tPR objc/44140\n\t* config/darwin.c (output_objc_section_asm_op): Save and restore\n\tsection when outputting ObjC section list.\n\ntestsuite/\n\n\tPR objc/44140\n\t* objc.dg/lto/trivial-1_0.m: New.\n\t* objc.dg/lto/lto.exp: New.\n\t* obj-c++.dg/lto/trivial-1_0.mm: New.\n\t* obj-c++.dg/lto/lto.exp: New.\n\t* objc.dg/symtab-1.m: Adjust sizes.\n\t* objc.dg/image-info.m: Do not run for gnu-runtime.\n\ngcc/objc/\n\n\tPR objc/44140\n\t* objc-act.c: build_objc_string_decl() remove declaration.\n\t(finish_var_decl): Remove forcing of var output and marking\n\tas \"Used\". \n\t(init_def_list): Use integer_zero_node. \n\t(init_objc_symtab): Use integer_zero_node, make the short\n\tinteger type specific on relevant nodes.\n\t(generate_objc_symtab_decl): Remove call to \n\tforward_declare_categories().  Use null_pointer_node where\n\tappropriate.  \n\t(build_module_descriptor): Comment and mark this item as \n\tDECL_PRESERVE_P. \n\t(generate_static_references): Use gcc_unreachable instead of\n\tabort (). \n\t(diagnose_missing_method): New.\n\t(build_next_selector_translation_table): New.\n\t(build_gnu_selector_translation_table): New.\n\t(add_objc_string): Merge code from build_objc_string_decl...\n\t... and delete build_objc_string_decl().\n\t(generate_dispatch_table): Make integer types explicit.\n\t(generate_category): Pass implent and arrange for the data\n\tto be extracted within the routine.  Do not start new vars, \n\tbut finish the ones collcted during parsing.\n\t(generate_shared_structures): Likewise.\n\t(finish_objc):  Reorder code so that we finish variables before\n\treferencing them.  Save the global data before calling meta-data\n\tcreation routines, and pass the current reference to the two \n\tmain routines.  Only call generate_objc_image_info () for the \n\tNeXT runtime.\n\t(generate_classref_translation_entry): Comment on and make this\n\titem DECL_PRESERVE_P.\n\t(handle_class_ref): Use varpool interfaces, comment on and make\n\tthis item DECL_PRESERVE_P.\n\t(handle_impent): Likewise.\n\t(generate_objc_image_info): Only generate when the content is \n\tnon-zero.  Make integer types explict.\n\nFrom-SVN: r162030", "tree": {"sha": "4629b5a86dbf043bfa8fdd1c7e561c7fc9ec54be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4629b5a86dbf043bfa8fdd1c7e561c7fc9ec54be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/058bfe530068df2d3ccc4131a1837b44a83acba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058bfe530068df2d3ccc4131a1837b44a83acba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058bfe530068df2d3ccc4131a1837b44a83acba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058bfe530068df2d3ccc4131a1837b44a83acba4/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0571e6db633e48c91a7c241cbf807810afeae2d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0571e6db633e48c91a7c241cbf807810afeae2d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0571e6db633e48c91a7c241cbf807810afeae2d6"}], "stats": {"total": 659, "additions": 490, "deletions": 169}, "files": [{"sha": "45f780aea8db85edc2a33e8c3c09819300559eaf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -1,3 +1,9 @@\n+2010-07-10  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR objc/44140\n+\t* config/darwin.c (output_objc_section_asm_op): Save and restore\n+\tsection when outputting ObjC section list.\n+\n 2010-07-09  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-streamer-out.c (produce_symtab): Do not write alias cgraph/varpool"}, {"sha": "952539f2aa9b3a97b8391551909db9b6c0908b43", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -99,6 +99,7 @@ output_objc_section_asm_op (const void *directive)\n      section is requested.  */\n   if (! been_here)\n     {\n+      section *saved_in_section = in_section;\n       static const enum darwin_section_enum tomark[] =\n \t{\n \t  /* written, cold -> hot */\n@@ -129,6 +130,7 @@ output_objc_section_asm_op (const void *directive)\n       been_here = true;\n       for (i = 0; i < ARRAY_SIZE (tomark); i++)\n \tswitch_to_section (darwin_sections[tomark[i]]);\n+      switch_to_section (saved_in_section);\n     }\n   output_section_asm_op (directive);\n }"}, {"sha": "17b116f6ebefc09bfdff1e7119f5ef5a8f56e600", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -1,3 +1,42 @@\n+2010-07-10  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR objc/44140\n+\t* objc-act.c: build_objc_string_decl() remove declaration.\n+\t(finish_var_decl): Remove forcing of var output and marking\n+\tas \"Used\". \n+\t(init_def_list): Use integer_zero_node. \n+\t(init_objc_symtab): Use integer_zero_node, make the short\n+\tinteger type specific on relevant nodes.\n+\t(generate_objc_symtab_decl): Remove call to \n+\tforward_declare_categories().  Use null_pointer_node where\n+\tappropriate.  \n+\t(build_module_descriptor): Comment and mark this item as \n+\tDECL_PRESERVE_P. \n+\t(generate_static_references): Use gcc_unreachable instead of\n+\tabort (). \n+\t(diagnose_missing_method): New.\n+\t(build_next_selector_translation_table): New.\n+\t(build_gnu_selector_translation_table): New.\n+\t(add_objc_string): Merge code from build_objc_string_decl...\n+\t... and delete build_objc_string_decl().\n+\t(generate_dispatch_table): Make integer types explicit.\n+\t(generate_category): Pass implent and arrange for the data\n+\tto be extracted within the routine.  Do not start new vars, \n+\tbut finish the ones collcted during parsing.\n+\t(generate_shared_structures): Likewise.\n+\t(finish_objc):  Reorder code so that we finish variables before\n+\treferencing them.  Save the global data before calling meta-data\n+\tcreation routines, and pass the current reference to the two \n+\tmain routines.  Only call generate_objc_image_info () for the \n+\tNeXT runtime.\n+\t(generate_classref_translation_entry): Comment on and make this\n+\titem DECL_PRESERVE_P.\n+\t(handle_class_ref): Use varpool interfaces, comment on and make\n+\tthis item DECL_PRESERVE_P.\n+\t(handle_impent): Likewise.\n+\t(generate_objc_image_info): Only generate when the content is \n+\tnon-zero.  Make integer types explict.\n+\n 2010-07-03  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR objc/24867"}, {"sha": "a0f36906e9b34308b592ac341d94c437980495ff", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 180, "deletions": 166, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -214,7 +214,6 @@ enum string_section\n };\n \n static tree add_objc_string (tree, enum string_section);\n-static tree build_objc_string_decl (enum string_section);\n static void build_selector_table_decl (void);\n \n /* Protocol additions.  */\n@@ -1541,14 +1540,6 @@ static void\n finish_var_decl (tree var, tree initializer)\n {\n   finish_decl (var, input_location, initializer, NULL_TREE, NULL_TREE);\n-  /* Ensure that the variable actually gets output.  */\n-  mark_decl_referenced (var);\n-  /* Mark the decl to avoid \"defined but not used\" warning.  */\n-  TREE_USED (var) = 1;\n-  DECL_READ_P (var) = 1;\n-  /* We reserve the right for the runtime to use/modify these variables\n-     in ways that are opaque to us.  */\n-  DECL_PRESERVE_P (var) = 1;\n }\n \n /* Find the decl for the constant string class reference.  This is only\n@@ -2188,7 +2179,7 @@ init_def_list (tree type)\n \texpr = build_unary_op (input_location,\n \t\t\t       ADDR_EXPR, static_instances_decl, 0);\n       else\n-\texpr = build_int_cst (NULL_TREE, 0);\n+\texpr = integer_zero_node;\n \n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n     }\n@@ -2211,7 +2202,9 @@ init_objc_symtab (tree type)\n   /* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */\n \n   if (flag_next_runtime || ! sel_ref_chain)\n-    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, convert (\n+\t\t\t\t\tbuild_pointer_type (objc_selector_type),\n+\t\t\t\t\t\t\tinteger_zero_node));\n   else\n     {\n       tree expr = build_unary_op (input_location, ADDR_EXPR,\n@@ -2224,11 +2217,13 @@ init_objc_symtab (tree type)\n \n   /* cls_def_cnt = { ..., 5, ... } */\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, imp_count));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (short_integer_type_node, imp_count));\n \n   /* cat_def_cnt = { ..., 5, ... } */\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, cat_count));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+\t\t\t  build_int_cst (short_integer_type_node, cat_count));\n \n   /* cls_def = { ..., { &Foo, &Bar, ...}, ... } */\n \n@@ -2289,10 +2284,7 @@ forward_declare_categories (void)\n static void\n generate_objc_symtab_decl (void)\n {\n-  /* forward declare categories */\n-  if (cat_count)\n-    forward_declare_categories ();\n-\n+ \n   build_objc_symtab_template ();\n   UOBJC_SYMBOLS_decl = start_var_decl (objc_symtab_template, \"_OBJC_SYMBOLS\");\n   finish_var_decl (UOBJC_SYMBOLS_decl,\n@@ -2328,7 +2320,7 @@ init_module_descriptor (tree type)\n     expr = build_unary_op (input_location,\n \t\t\t   ADDR_EXPR, UOBJC_SYMBOLS_decl, 0);\n   else\n-    expr = build_int_cst (NULL_TREE, 0);\n+    expr = null_pointer_node;\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n \n   return objc_build_constructor (type, v);\n@@ -2367,6 +2359,9 @@ build_module_descriptor (void)\n \n   /* Create an instance of \"_objc_module\".  */\n   UOBJC_MODULES_decl = start_var_decl (objc_module_template, \"_OBJC_MODULES\");\n+  /* This is the root of the metadata for defined classes and categories, it\n+     is referenced by the runtime and, therefore, needed.  */\n+  DECL_PRESERVE_P (UOBJC_MODULES_decl) = 1;\n   finish_var_decl (UOBJC_MODULES_decl,\n \t\t   init_module_descriptor (TREE_TYPE (UOBJC_MODULES_decl)));\n \n@@ -2490,7 +2485,7 @@ generate_static_references (void)\n   VEC(constructor_elt,gc) *decls = NULL;\n \n   if (flag_next_runtime)\n-    abort ();\n+    gcc_unreachable ();\n \n   for (cl_chain = objc_static_instances, num_class = 0;\n        cl_chain; cl_chain = TREE_CHAIN (cl_chain), num_class++)\n@@ -2574,54 +2569,78 @@ build_selector (tree ident)\n \t\t  add_objc_string (ident, meth_var_names));\n }\n \n+/* Used only by build_*_selector_translation_table (). */\n static void\n-build_selector_translation_table (void)\n+diagnose_missing_method (tree meth, location_t here)\n {\n-  tree chain;\n-  int offset = 0;\n-  tree decl = NULL_TREE;\n-  VEC(constructor_elt,gc) *inits = NULL;\n+  tree method_chain;\n+  bool found = false;\n+  for (method_chain = meth_var_names_chain;\n+       method_chain;\n+       method_chain = TREE_CHAIN (method_chain))\n+    {\n+      if (TREE_VALUE (method_chain) == meth)\n+\t{\n+\t  found = true;\n+\t  break;\n+\t}\n+     }\n \n+  if (!found)\n+    warning_at (here, 0, \"creating selector for nonexistent method %qE\",\n+\t\t\tmeth);\n+}\n+\n+static void\n+build_next_selector_translation_table (void)\n+{\n+  tree chain;\n   for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n     {\n       tree expr;\n-\n+      tree decl = TREE_PURPOSE (chain);\n       if (warn_selector && objc_implementation_context)\n-      {\n-        tree method_chain;\n-        bool found = false;\n-        for (method_chain = meth_var_names_chain;\n-             method_chain;\n-             method_chain = TREE_CHAIN (method_chain))\n-          {\n-            if (TREE_VALUE (method_chain) == TREE_VALUE (chain))\n-              {\n-                found = true;\n-                break;\n-              }\n-          }\n-        if (!found)\n-\t  {\n-\t    location_t loc;\n-\t    if (flag_next_runtime && TREE_PURPOSE (chain))\n-\t      loc = DECL_SOURCE_LOCATION (TREE_PURPOSE (chain));\n-\t    else\n-\t      loc = input_location;\n-\t    warning_at (loc, 0, \"creating selector for nonexistent method %qE\",\n-\t\t\tTREE_VALUE (chain));\n-\t  }\n-      }\n+      \t{\n+\t  location_t loc;\n+      \t  if (decl) \n+      \t    loc = DECL_SOURCE_LOCATION (decl);\n+      \t  else\n+      \t    loc = input_location;\n+\t  diagnose_missing_method (TREE_VALUE (chain), loc);\n+\t}\n \n       expr = build_selector (TREE_VALUE (chain));\n-      /* add one for the '\\0' character */\n-      offset += IDENTIFIER_LENGTH (TREE_VALUE (chain)) + 1;\n \n-      if (flag_next_runtime)\n+      if (decl)\n \t{\n-\t  decl = TREE_PURPOSE (chain);\n+\t  /* Entries of this form are used for references to methods.\n+\t  The runtime re-writes these on start-up, but the compiler can't see \n+\t  that and optimizes it away unless we force it.  */\n+\t  DECL_PRESERVE_P (decl) = 1;\n \t  finish_var_decl (decl, expr);\n \t}\n-      else\n+    }\n+}\n+\n+static void\n+build_gnu_selector_translation_table (void)\n+{\n+  tree chain;\n+/*  int offset = 0;\n+  tree decl = NULL_TREE;*/\n+  VEC(constructor_elt,gc) *inits = NULL;\n+\n+  for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n+    {\n+      tree expr;\n+\n+      if (warn_selector && objc_implementation_context)\n+\tdiagnose_missing_method (TREE_VALUE (chain), input_location);\n+\n+      expr = build_selector (TREE_VALUE (chain));\n+      /* add one for the '\\0' character \n+      offset += IDENTIFIER_LENGTH (TREE_VALUE (chain)) + 1;*/\n+\n \t{\n \t  if (flag_typed_selectors)\n \t    {\n@@ -2634,9 +2653,8 @@ build_selector_translation_table (void)\n \n \t  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n \t}\n-    }\n+    } /* each element in the chain */\n \n-  if (! flag_next_runtime)\n     {\n       /* Cause the selector table (previously forward-declared)\n \t to be actually output.\t */\n@@ -2645,12 +2663,12 @@ build_selector_translation_table (void)\n       if (flag_typed_selectors)\n \t{\n \t  VEC(constructor_elt,gc) *v = NULL;\n-\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n-\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n+\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n \t  expr = objc_build_constructor (objc_selector_template, v);\n \t}\n       else\n-\texpr = build_int_cst (NULL_TREE, 0);\n+\texpr = integer_zero_node;\n \n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n       expr = objc_build_constructor (TREE_TYPE (UOBJC_SELECTOR_TABLE_decl),\n@@ -2854,19 +2872,34 @@ objc_get_class_reference (tree ident)\n /* For each string section we have a chain which maps identifier nodes\n    to decls for the strings.  */\n \n+static GTY(()) int class_names_idx;\n+static GTY(()) int meth_var_names_idx;\n+static GTY(()) int meth_var_types_idx;\n+\n static tree\n add_objc_string (tree ident, enum string_section section)\n {\n   tree *chain, decl, type, string_expr;\n-\n+  char buf[256];\n+  \n+  buf[0] = 0;\n   if (section == class_names)\n-    chain = &class_names_chain;\n+    {\n+      chain = &class_names_chain;\n+      sprintf (buf, \"_OBJC_CLASS_NAME_%d\", class_names_idx++);\n+    }\n   else if (section == meth_var_names)\n-    chain = &meth_var_names_chain;\n+    {\n+      chain = &meth_var_names_chain;\n+      sprintf (buf, \"_OBJC_METH_VAR_NAME_%d\", meth_var_names_idx++);\n+    }\n   else if (section == meth_var_types)\n-    chain = &meth_var_types_chain;\n+    {\n+      chain = &meth_var_types_chain;\n+      sprintf (buf, \"_OBJC_METH_VAR_TYPE_%d\", meth_var_types_idx++);\n+    }\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   while (*chain)\n     {\n@@ -2878,12 +2911,11 @@ add_objc_string (tree ident, enum string_section section)\n       chain = &TREE_CHAIN (*chain);\n     }\n \n-  decl = build_objc_string_decl (section);\n-\n   type = build_sized_array_type (char_type_node, IDENTIFIER_LENGTH (ident) + 1);\n-  decl = start_var_decl (type, IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  decl = start_var_decl (type, buf);\n   string_expr = my_build_string (IDENTIFIER_LENGTH (ident) + 1,\n \t\t\t\t IDENTIFIER_POINTER (ident));\n+  TREE_CONSTANT (decl) = 1;\n   finish_var_decl (decl, string_expr);\n \n   *chain = tree_cons (decl, ident, NULL_TREE);\n@@ -2892,44 +2924,6 @@ add_objc_string (tree ident, enum string_section section)\n \t\t\t\t\t\t    ADDR_EXPR, decl, 1));\n }\n \n-static GTY(()) int class_names_idx;\n-static GTY(()) int meth_var_names_idx;\n-static GTY(()) int meth_var_types_idx;\n-\n-static tree\n-build_objc_string_decl (enum string_section section)\n-{\n-  tree decl, ident;\n-  char buf[256];\n-\n-  if (section == class_names)\n-    sprintf (buf, \"_OBJC_CLASS_NAME_%d\", class_names_idx++);\n-  else if (section == meth_var_names)\n-    sprintf (buf, \"_OBJC_METH_VAR_NAME_%d\", meth_var_names_idx++);\n-  else if (section == meth_var_types)\n-    sprintf (buf, \"_OBJC_METH_VAR_TYPE_%d\", meth_var_types_idx++);\n-\n-  ident = get_identifier (buf);\n-\n-  decl = build_decl (input_location,\n-\t\t     VAR_DECL, ident, build_array_type (char_type_node, 0));\n-  DECL_EXTERNAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 0;\n-  TREE_USED (decl) = 1;\n-  TREE_CONSTANT (decl) = 1;\n-  DECL_CONTEXT (decl) = 0;\n-  DECL_ARTIFICIAL (decl) = 1;\n-#ifdef OBJCPLUS\n-  DECL_THIS_STATIC (decl) = 1; /* squash redeclaration errors */\n-#endif\n-\n-  make_decl_rtl (decl);\n-  pushdecl_top_level (decl);\n-\n-  return decl;\n-}\n-\n-\n void\n objc_declare_alias (tree alias_ident, tree class_ident)\n {\n@@ -5334,8 +5328,8 @@ generate_dispatch_table (tree type, const char *name, int size, tree list)\n   decl = start_var_decl (type, synth_id_with_class_suffix\n \t\t\t       (name, objc_implementation_context));\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (integer_type_node, size));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, list);\n \n   finish_var_decl (decl,\n@@ -5658,11 +5652,15 @@ lookup_category (tree klass, tree cat_name)\n /* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */\n \n static void\n-generate_category (tree cat)\n+generate_category (struct imp_entry *impent)\n {\n-  tree decl;\n   tree initlist, cat_name_expr, class_name_expr;\n   tree protocol_decl, category;\n+  tree cat = impent->imp_context;\n+\n+  implementation_template = impent->imp_template;\n+  UOBJC_CLASS_decl = impent->class_decl;\n+  UOBJC_METACLASS_decl = impent->meta_decl;\n \n   add_class_reference (CLASS_NAME (cat));\n   cat_name_expr = add_objc_string (CLASS_SUPER_NAME (cat), class_names);\n@@ -5680,30 +5678,32 @@ generate_category (tree cat)\n   else\n     protocol_decl = 0;\n \n-  decl = start_var_decl (objc_category_template,\n-\t\t\t synth_id_with_class_suffix\n-\t\t\t (\"_OBJC_CATEGORY\", objc_implementation_context));\n-\n-  initlist = build_category_initializer (TREE_TYPE (decl),\n+  initlist = build_category_initializer (TREE_TYPE (UOBJC_CLASS_decl),\n \t\t\t\t\t cat_name_expr, class_name_expr,\n \t\t\t\t\t UOBJC_INSTANCE_METHODS_decl,\n \t\t\t\t\t UOBJC_CLASS_METHODS_decl,\n \t\t\t\t\t protocol_decl);\n-\n-  finish_var_decl (decl, initlist);\n+  /* Finish and initialize the forward decl.  */\n+  finish_var_decl (UOBJC_CLASS_decl, initlist);\n }\n \n /* static struct objc_class _OBJC_METACLASS_Foo={ ... };\n    static struct objc_class _OBJC_CLASS_Foo={ ... };  */\n \n static void\n-generate_shared_structures (int cls_flags)\n+generate_shared_structures (struct imp_entry *impent)\n {\n-  tree decl;\n   tree name_expr, super_expr, root_expr;\n-  tree my_root_id = NULL_TREE, my_super_id = NULL_TREE;\n+  tree my_root_id, my_super_id;\n   tree cast_type, initlist, protocol_decl;\n-\n+  int cls_flags;\n+  \n+  objc_implementation_context = impent->imp_context;\n+  implementation_template = impent->imp_template;\n+  UOBJC_CLASS_decl = impent->class_decl;\n+  UOBJC_METACLASS_decl = impent->meta_decl;\n+  cls_flags = impent->has_cxx_cdtors ? CLS_HAS_CXX_STRUCTORS : 0 ;\n+  \n   my_super_id = CLASS_SUPER_NAME (implementation_template);\n   if (my_super_id)\n     {\n@@ -5734,13 +5734,12 @@ generate_shared_structures (int cls_flags)\n \n   /* Install class `isa' and `super' pointers at runtime.  */\n   if (my_super_id)\n-    {\n-      super_expr = add_objc_string (my_super_id, class_names);\n-      super_expr = build_c_cast (input_location,\n-\t\t\t\t cast_type, super_expr); /* cast! */\n-    }\n+    super_expr = add_objc_string (my_super_id, class_names);\n   else\n-    super_expr = build_int_cst (NULL_TREE, 0);\n+    super_expr = integer_zero_node;\n+    \n+  super_expr = build_c_cast (input_location,\n+\t\t\t\t cast_type, super_expr); /* cast! */\n \n   root_expr = add_objc_string (my_root_id, class_names);\n   root_expr = build_c_cast (input_location, cast_type, root_expr); /* cast! */\n@@ -5756,31 +5755,23 @@ generate_shared_structures (int cls_flags)\n \n   /* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */\n \n-  decl = start_var_decl (objc_class_template,\n-\t\t\t IDENTIFIER_POINTER\n-\t\t\t (DECL_NAME (UOBJC_METACLASS_decl)));\n-\n   initlist\n     = build_shared_structure_initializer\n-      (TREE_TYPE (decl),\n+      (TREE_TYPE (UOBJC_METACLASS_decl),\n        root_expr, super_expr, name_expr,\n        convert (integer_type_node, TYPE_SIZE_UNIT (objc_class_template)),\n        2 /*CLS_META*/,\n        UOBJC_CLASS_METHODS_decl,\n        UOBJC_CLASS_VARIABLES_decl,\n        protocol_decl);\n \n-  finish_var_decl (decl, initlist);\n+  finish_var_decl (UOBJC_METACLASS_decl, initlist);\n \n   /* static struct objc_class _OBJC_CLASS_Foo={ ... }; */\n \n-  decl = start_var_decl (objc_class_template,\n-\t\t\t IDENTIFIER_POINTER\n-\t\t\t (DECL_NAME (UOBJC_CLASS_decl)));\n-\n   initlist\n     = build_shared_structure_initializer\n-      (TREE_TYPE (decl),\n+      (TREE_TYPE (UOBJC_CLASS_decl),\n        build_unary_op (input_location, ADDR_EXPR, UOBJC_METACLASS_decl, 0),\n        super_expr, name_expr,\n        convert (integer_type_node,\n@@ -5791,7 +5782,7 @@ generate_shared_structures (int cls_flags)\n        UOBJC_INSTANCE_VARIABLES_decl,\n        protocol_decl);\n \n-  finish_var_decl (decl, initlist);\n+  finish_var_decl (UOBJC_CLASS_decl, initlist);\n }\n \n \n@@ -9176,15 +9167,17 @@ finish_objc (void)\n   if (objc_static_instances)\n     generate_static_references ();\n \n-  if (imp_list || class_names_chain\n-      || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)\n-    generate_objc_symtab_decl ();\n+  /* forward declare categories */\n+  if (cat_count)\n+    forward_declare_categories ();\n \n   for (impent = imp_list; impent; impent = impent->next)\n     {\n       objc_implementation_context = impent->imp_context;\n       implementation_template = impent->imp_template;\n \n+      /* FIXME: This needs reworking to be more obvious.  */\n+\n       UOBJC_CLASS_decl = impent->class_decl;\n       UOBJC_METACLASS_decl = impent->meta_decl;\n \n@@ -9202,28 +9195,35 @@ finish_objc (void)\n \t  /* all of the following reference the string pool...  */\n \t  generate_ivar_lists ();\n \t  generate_dispatch_tables ();\n-\t  generate_shared_structures (impent->has_cxx_cdtors\n-\t\t\t\t      ? CLS_HAS_CXX_STRUCTORS\n-\t\t\t\t      : 0);\n+\t  generate_shared_structures (impent);\n \t}\n       else\n \t{\n \t  generate_dispatch_tables ();\n-\t  generate_category (objc_implementation_context);\n+\t  generate_category (impent);\n \t}\n+\n+      impent->class_decl = UOBJC_CLASS_decl;\n+      impent->meta_decl = UOBJC_METACLASS_decl;\n     }\n \n   /* If we are using an array of selectors, we must always\n      finish up the array decl even if no selectors were used.  */\n-  if (! flag_next_runtime || sel_ref_chain)\n-    build_selector_translation_table ();\n+  if (flag_next_runtime)\n+    build_next_selector_translation_table ();\n+  else\n+    build_gnu_selector_translation_table ();\n \n   if (protocol_chain)\n     generate_protocols ();\n \n-  if ((flag_replace_objc_classes && imp_list) || flag_objc_gc)\n+  if (flag_next_runtime)\n     generate_objc_image_info ();\n \n+  if (imp_list || class_names_chain\n+      || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)\n+    generate_objc_symtab_decl ();\n+\n   /* Arrange for ObjC data structures to be initialized at run time.  */\n   if (objc_implementation_context || class_names_chain || objc_static_instances\n       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)\n@@ -9282,8 +9282,9 @@ generate_classref_translation_entry (tree chain)\n   expr = add_objc_string (TREE_VALUE (chain), class_names);\n   expr = convert (type, expr); /* cast! */\n \n-  /* The decl that is the one that we\n-     forward declared in build_class_reference.  */\n+  /* This is a class reference.  It is re-written by the runtime,\n+     but will be optimized away unless we force it.  */\n+  DECL_PRESERVE_P (decl) = 1;\n   finish_var_decl (decl, expr);\n   return;\n }\n@@ -9309,28 +9310,29 @@ handle_class_ref (tree chain)\n \n   /* Make a decl for this name, so we can use its address in a tree.  */\n   decl = build_decl (input_location,\n-\t\t     VAR_DECL, get_identifier (string), char_type_node);\n+\t\t     VAR_DECL, get_identifier (string), TREE_TYPE (integer_zero_node));\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n-\n   pushdecl (decl);\n-  rest_of_decl_compilation (decl, 0, 0);\n+  finish_var_decl (decl, 0);\n \n   /* Make a decl for the address.  */\n   sprintf (string, \"%sobjc_class_ref_%s\",\n \t   (flag_next_runtime ? \".\" : \"__\"), name);\n   exp = build1 (ADDR_EXPR, string_type_node, decl);\n   decl = build_decl (input_location,\n \t\t     VAR_DECL, get_identifier (string), string_type_node);\n-  DECL_INITIAL (decl) = exp;\n   TREE_STATIC (decl) = 1;\n   TREE_USED (decl) = 1;\n   DECL_READ_P (decl) = 1;\n-  /* Force the output of the decl as this forces the reference of the class.  */\n-  mark_decl_referenced (decl);\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_INITIAL (decl) = error_mark_node;\n+ \n+  /* We must force the reference.  */\n+  DECL_PRESERVE_P (decl) = 1;\n \n   pushdecl (decl);\n-  rest_of_decl_compilation (decl, 0, 0);\n+  finish_var_decl (decl, exp);\n }\n \n static void\n@@ -9381,17 +9383,21 @@ handle_impent (struct imp_entry *impent)\n     {\n       tree decl, init;\n \n-      init = build_int_cst (c_common_type_for_size (BITS_PER_WORD, 1), 0);\n+      init = integer_zero_node;\n       decl = build_decl (input_location,\n \t\t\t VAR_DECL, get_identifier (string), TREE_TYPE (init));\n       TREE_PUBLIC (decl) = 1;\n       TREE_READONLY (decl) = 1;\n       TREE_USED (decl) = 1;\n       TREE_CONSTANT (decl) = 1;\n-      DECL_CONTEXT (decl) = 0;\n+      DECL_CONTEXT (decl) = NULL_TREE;\n       DECL_ARTIFICIAL (decl) = 1;\n-      DECL_INITIAL (decl) = init;\n-      assemble_variable (decl, 1, 0, 0);\n+      TREE_STATIC (decl) = 1;\n+      DECL_INITIAL (decl) = error_mark_node; /* A real initializer is coming... */\n+      /* We must force the reference.  */\n+      DECL_PRESERVE_P (decl) = 1;\n+\n+      finish_var_decl(decl, init) ;\n     }\n }\n \f\n@@ -9406,16 +9412,24 @@ generate_objc_image_info (void)\n {\n   tree decl;\n   int flags\n-    = ((flag_replace_objc_classes && imp_list ? 1 : 0)\n+    = ((flag_replace_objc_classes && imp_count ? 1 : 0)\n        | (flag_objc_gc ? 2 : 0));\n   VEC(constructor_elt,gc) *v = NULL;\n-  tree array_type = build_sized_array_type (integer_type_node, 2);\n+  tree array_type;\n+  \n+   if (!flags)\n+    return; /* No need for an image_info entry.  */\n+  \n+  array_type  = build_sized_array_type (integer_type_node, 2);\n \n   decl = start_var_decl (array_type, \"_OBJC_IMAGE_INFO\");\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, 0));\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, flags));\n-\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (integer_type_node, flags));\n+  /* If we need this (determined above) it is because the runtime wants to\n+     refer to it in a manner hidden from the compiler.  So we must force the \n+     output.  */\n+  DECL_PRESERVE_P (decl) = 1;\n   finish_var_decl (decl, objc_build_constructor (TREE_TYPE (decl), v));\n }\n "}, {"sha": "6d0de14c32f6a788ef807cdeae0747f6641b3623", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -1,3 +1,13 @@\n+2010-07-10  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR objc/44140\n+\t* objc.dg/lto/trivial-1_0.m: New.\n+\t* objc.dg/lto/lto.exp: New.\n+\t* obj-c++.dg/lto/trivial-1_0.mm: New.\n+\t* obj-c++.dg/lto/lto.exp: New.\n+\t* objc.dg/symtab-1.m: Adjust sizes.\n+\t* objc.dg/image-info.m: Do not run for gnu-runtime.\n+\n 2010-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* gcc.dg/pr32370.c: Allow another kind of error message."}, {"sha": "291895ffc01328d2f62d20b1c5e2a35689d47ed7", "filename": "gcc/testsuite/obj-c++.dg/lto/lto.exp", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Flto%2Flto.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Flto%2Flto.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Flto%2Flto.exp?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -0,0 +1,84 @@\n+# Copyright (C) 2010 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+#\n+# Based on gcc/testsuite/gcc.dg/lto/lto.exp.\n+\n+# Test link-time optimization across multiple files.\n+#\n+# Programs are broken into multiple files.  Each one is compiled\n+# separately with LTO information.  The final executable is generated\n+# by collecting all the generated object files using regular LTO or WHOPR.\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# Load procedures from common libraries. \n+load_lib standard.exp\n+load_lib obj-c++-dg.exp\n+\n+# Load the language-independent compabibility support procedures.\n+load_lib lto.exp\n+\n+# If LTO has not been enabled, bail.\n+if { ![check_effective_target_lto] } {\n+    return\n+}\n+\n+global LTO_OPTIONS\n+\n+set LTO_OPTIONS [list\t\\\n+  {-O0 -fwhopr -fgnu-runtime}\t\\\n+  {-O2 -fwhopr -fgnu-runtime}\t\\\n+  {-O0 -flto -fgnu-runtime} \t\\\n+  {-O2 -flto -fgnu-runtime}\t\\\n+]\n+\n+obj-c++_init\n+lto_init no-mathlib\n+\n+# Define an identifier for use with this suite to avoid name conflicts\n+# with other lto tests running at the same time.\n+set sid \"obj_cpp_lto\"\n+set tests [lsort [glob -nocomplain $srcdir/$subdir/*_0.mm]]\n+\n+# Main loop.\n+foreach src $tests {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+\tcontinue\n+    }\n+    lto-execute $src $sid\n+}\n+\n+# darwin targets can also run code with the NeXT runtime.\n+if [istarget \"*-*-darwin*\" ] {\n+set LTO_OPTIONS [list\t\\\n+  {-O0 -fwhopr -fnext-runtime}\t\\\n+  {-O2 -fwhopr -fnext-runtime}\t\\\n+  {-O0 -flto -fnext-runtime} \t\\\n+  {-O2 -flto -fnext-runtime}\t\\\n+]\n+  foreach src $tests {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+\tcontinue\n+    }\n+    lto-execute $src $sid\n+  }\n+}\n+\n+lto_finish"}, {"sha": "45b6e70248106b72ff3cd599442764aba4cbc53b", "filename": "gcc/testsuite/obj-c++.dg/lto/trivial-1_0.mm", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Flto%2Ftrivial-1_0.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Flto%2Ftrivial-1_0.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Flto%2Ftrivial-1_0.mm?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-lto-do run } */\n+/* { dg-skip-if \"Needs OBJC2 ABI\" { \"*-*-darwin*\" && lp64 } { \"*\" } { \"\" } } */\n+extern \"C\" {\n+extern int printf (char *,...) ;\n+extern void abort (void) ;\n+} \n+\n+typedef struct objc_class *Class;\n+\n+struct objc_class {\n+    Class isa;\n+    /* other stuff... */\n+}  ;\n+\n+@interface myRootObject {\n+@public\n+     Class isa; \n+}\n++initialize;\n++(Class)class;\n+\n+@end\n+\n+@implementation myRootObject\n++initialize {\n+     return self;\n+}\n+\n++(Class)class {\n+     return (Class)self;\n+}\n+\n+@end\n+\n+int main(void)\n+{\n+  Class cl = [myRootObject class];\n+  if (cl != (Class)0) {\n+    printf((char *)\"trivial OK\\n\");\n+    return 0;\n+  }\n+  abort () ;\n+}"}, {"sha": "e9e9de689062b4d89bc6dc7162c4d99fd685addb", "filename": "gcc/testsuite/objc.dg/image-info.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Fimage-info.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Fimage-info.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fimage-info.m?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -4,6 +4,7 @@\n /* Contributed by Ziemowit Laski <zlaski@apple.com>.  */\n \n /* { dg-do compile { target { *-*-darwin* } } } */\n+/* { dg-skip-if \"NeXT-only\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n /* { dg-options \"-freplace-objc-classes\" } */\n \n #include \"../objc-obj-c++-shared/Object1.h\""}, {"sha": "4ea89cced6ca44eb0440c2528c0280ace6e88059", "filename": "gcc/testsuite/objc.dg/lto/lto.exp", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Flto%2Flto.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Flto%2Flto.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Flto%2Flto.exp?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -0,0 +1,84 @@\n+# Copyright (C) 2010 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+#\n+# Based on gcc/testsuite/gcc.dg/lto/lto.exp.\n+\n+# Test link-time optimization across multiple files.\n+#\n+# Programs are broken into multiple files.  Each one is compiled\n+# separately with LTO information.  The final executable is generated\n+# by collecting all the generated object files using regular LTO or WHOPR.\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# Load procedures from common libraries. \n+load_lib standard.exp\n+load_lib objc-dg.exp\n+\n+# Load the language-independent compabibility support procedures.\n+load_lib lto.exp\n+\n+# If LTO has not been enabled, bail.\n+if { ![check_effective_target_lto] } {\n+    return\n+}\n+\n+global LTO_OPTIONS\n+\n+set LTO_OPTIONS [list\t\\\n+  {-O0 -fwhopr -fgnu-runtime}\t\\\n+  {-O2 -fwhopr -fgnu-runtime}\t\\\n+  {-O0 -flto -fgnu-runtime} \t\\\n+  {-O2 -flto -fgnu-runtime}\t\\\n+]\n+\n+objc_init\n+lto_init no-mathlib\n+\n+# Define an identifier for use with this suite to avoid name conflicts\n+# with other lto tests running at the same time.\n+set sid \"objc_lto\"\n+set tests [lsort [glob -nocomplain $srcdir/$subdir/*_0.m]]\n+\n+# Main loop.\n+foreach src $tests {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+\tcontinue\n+    }\n+    lto-execute $src $sid\n+}\n+\n+# darwin targets can also run code with the NeXT runtime.\n+if [istarget \"*-*-darwin*\" ] {\n+set LTO_OPTIONS [list\t\\\n+  {-O0 -fwhopr -fnext-runtime}\t\\\n+  {-O2 -fwhopr -fnext-runtime}\t\\\n+  {-O0 -flto -fnext-runtime} \t\\\n+  {-O2 -flto -fnext-runtime}\t\\\n+]\n+  foreach src $tests {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+\tcontinue\n+    }\n+    lto-execute $src $sid\n+  }\n+}\n+\n+lto_finish"}, {"sha": "076f2306c1beac6be1aff1977a05845074f95762", "filename": "gcc/testsuite/objc.dg/lto/trivial-1_0.m", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Flto%2Ftrivial-1_0.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Flto%2Ftrivial-1_0.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Flto%2Ftrivial-1_0.m?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-lto-do run } */\n+/* { dg-skip-if \"\" { \"*-*-darwin*\" && lp64 } { \"*\" } { \"\" } } */\n+extern int printf (char *,...) ;\n+\n+typedef struct objc_class *Class;\n+\n+struct objc_class {\n+    Class isa;\n+    /* other stuff... */\n+}  ;\n+\n+@interface myRootObject {\n+@public\n+     Class isa;\n+}\n++initialize;\n++(Class)class;\n+\n+@end\n+\n+@implementation myRootObject\n++initialize {\n+     return self;\n+}\n+\n++(Class)class {\n+     return (Class)self;\n+}\n+\n+@end\n+\n+int main(void)\n+{\n+  [myRootObject class];\n+  printf(\"trivial OK\\n\");\n+  return 0;\n+}"}, {"sha": "100b245325e87c2a097ee27a16d74080688faa7d", "filename": "gcc/testsuite/objc.dg/symtab-1.m", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Fsymtab-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058bfe530068df2d3ccc4131a1837b44a83acba4/gcc%2Ftestsuite%2Fobjc.dg%2Fsymtab-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fsymtab-1.m?ref=058bfe530068df2d3ccc4131a1837b44a83acba4", "patch": "@@ -22,6 +22,7 @@ @implementation Derived\n -(void)checkValues { }\n @end\n \n-/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.word\\t2\\n\\t.word\\t0\\n\\t.long\\tL_OBJC_CLASS_Derived.*\\n\\t.long\\tL_OBJC_CLASS_Base.*\\n\" { target { i?86-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.short\\t2\\n\\t.short\\t0\\n\\t.long\\tL_OBJC_CLASS_Derived.*\\n\\t.long\\tL_OBJC_CLASS_Base.*\\n\" { target { powerpc-*-darwin* && { ! lp64 } } } } } */\n-/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.quad\\t0\\n\\t.long\\t0\\n\\t.space 4\\n\\t.word\\t2\\n\\t.word\\t0\\n\\t.space 4\\n\\t.quad\\tL_OBJC_CLASS_Derived.*\\n\\t.quad\\tL_OBJC_CLASS_Base.*\\n\" { target { *-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.word\\t2\\n\\t.word\\t0\\n\\t.long\\tL_OBJC_CLASS_Derived.*\\n\\t.long\\tL_OBJC_CLASS_Base.*\\n\" { target { *86*-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.long\\t0\\n\\t.long\\t0\\n\\t.short\\t2\\n\\t.short\\t0\\n\\t.long\\tL_OBJC_CLASS_Derived.*\\n\\t.long\\tL_OBJC_CLASS_Base.*\\n\" { target { powerpc*-*-darwin* && { ! lp64 } } } } } */\n+/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.quad\\t0\\n\\t.quad\\t0\\n\\t.word\\t2\\n\\t.word\\t0\\n\\t.space 4\\n\\t.quad\\tL_OBJC_CLASS_Derived.*\\n\\t.quad\\tL_OBJC_CLASS_Base.*\\n\" { target { *86*-*-darwin* && { lp64 } } } } } */\n+/* { dg-final { scan-assembler \"L_OBJC_SYMBOLS.*:\\n\\t.quad\\t0\\n\\t.quad\\t0\\n\\t.short\\t2\\n\\t.short\\t0\\n\\t.space 4\\n\\t.quad\\tL_OBJC_CLASS_Derived.*\\n\\t.quad\\tL_OBJC_CLASS_Base.*\\n\" { target { powerpc*-*-darwin* && { lp64 } } } } } */"}]}