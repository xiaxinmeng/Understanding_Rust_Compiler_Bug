{"sha": "a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZmZWQ4M2ZmYTYyYWEwMWQ3YWRkMjFjOWQyYjM2YmExMmVmYjczMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-12-19T12:19:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-12-19T12:19:12Z"}, "message": "re PR target/46729 (32-bit 30_threads execution tests fail on Solaris 10/SPARC with Sun as)\n\n\tPR target/46729\n\t* config/sparc/sparc.h (GLOBAL_OFFSET_TABLE_REGNUM): New macro.\n\t(PIC_OFFSET_TABLE_REGNUM): Rewrite in terms of above macro.\n\t* config/sparc/sparc.c (pic_helper_needed): Delete.\n\t(global_offset_table): Likewise.\n\t(pic_helper_symbol): Rename to...\n\t(got_helper_rtx): ...this.\n\t(global_offset_table_rtx): New global variable.\n\t(sparc_got_symbol): Likewise.\n\t(sparc_got): New static function.\n\t(check_pic): Use local variable and call sparc_got.\n\t(sparc_tls_symbol): Initialize to NULL_RTX.\n\t(sparc_tls_got): In non-PIC mode, reload the GOT register for Sun TLS\n\tand 32-bit ABI and copy the GOT symbol to a new register otherwise.\n\t(get_pc_thunk_name): Rename local variable.\n\t(gen_load_pcrel_sym): New wrapper around load_pcrel_sym{si,di}.\n\t(load_pic_register): Rename to...\n\t(load_got_register): ...this.  Adjust and call gen_load_pcrel_sym.\n\t(sparc_expand_prologue): Do not test flag_pic.\n\t(sparc_output_mi_thunk): Use pic_offset_table_rtx directly.\n\t(sparc_file_end): Test got_helper_rtx instead of pic_helper_needed.\n\tRename local variable and do not call get_pc_thunk_name again.\n\t* config/sparc/sparc.md (load_pcrel_sym): Add operand #3.\n\nFrom-SVN: r168049", "tree": {"sha": "76cc3ddd8315fc60ee1aa286b0d55ec81acc588c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76cc3ddd8315fc60ee1aa286b0d55ec81acc588c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/comments", "author": null, "committer": null, "parents": [{"sha": "2f8bed161326b1ffd27a3614ac8d8391a5eb7dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8bed161326b1ffd27a3614ac8d8391a5eb7dd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8bed161326b1ffd27a3614ac8d8391a5eb7dd0"}], "stats": {"total": 203, "additions": 131, "deletions": 72}, "files": [{"sha": "68bb8f757c0e3235d9eda3dbb735b35b4d0a9d83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "patch": "@@ -1,3 +1,29 @@\n+2010-12-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/46729\n+\t* config/sparc/sparc.h (GLOBAL_OFFSET_TABLE_REGNUM): New macro.\n+\t(PIC_OFFSET_TABLE_REGNUM): Rewrite in terms of above macro.\n+\t* config/sparc/sparc.c (pic_helper_needed): Delete.\n+\t(global_offset_table): Likewise.\n+\t(pic_helper_symbol): Rename to...\n+\t(got_helper_rtx): ...this.\n+\t(global_offset_table_rtx): New global variable.\n+\t(sparc_got_symbol): Likewise.\n+\t(sparc_got): New static function.\n+\t(check_pic): Use local variable and call sparc_got.\n+\t(sparc_tls_symbol): Initialize to NULL_RTX.\n+\t(sparc_tls_got): In non-PIC mode, reload the GOT register for Sun TLS\n+\tand 32-bit ABI and copy the GOT symbol to a new register otherwise.\n+\t(get_pc_thunk_name): Rename local variable.\n+\t(gen_load_pcrel_sym): New wrapper around load_pcrel_sym{si,di}.\n+\t(load_pic_register): Rename to...\n+\t(load_got_register): ...this.  Adjust and call gen_load_pcrel_sym.\n+\t(sparc_expand_prologue): Do not test flag_pic.\n+\t(sparc_output_mi_thunk): Use pic_offset_table_rtx directly.\n+\t(sparc_file_end): Test got_helper_rtx instead of pic_helper_needed.\n+\tRename local variable and do not call get_pc_thunk_name again.\n+\t* config/sparc/sparc.md (load_pcrel_sym): Add operand #3.\n+\n 2010-12-19  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \tPR middle-end/46674"}, {"sha": "a066b2ab305cdc7fd559804405eb0e20367e624e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 95, "deletions": 68, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "patch": "@@ -391,7 +391,7 @@ static rtx sparc_builtin_saveregs (void);\n static int epilogue_renumber (rtx *, int);\n static bool sparc_assemble_integer (rtx, unsigned int, int);\n static int set_extends (rtx);\n-static void load_pic_register (void);\n+static void load_got_register (void);\n static int save_or_restore_regs (int, int, rtx, int, int);\n static void emit_save_or_restore_regs (int);\n static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -3020,26 +3020,39 @@ sparc_cannot_force_const_mem (rtx x)\n     }\n }\n \f\n-/* PIC support.  */\n-static GTY(()) bool pic_helper_needed = false;\n-static GTY(()) rtx pic_helper_symbol;\n-static GTY(()) rtx global_offset_table;\n+/* Global Offset Table support.  */\n+static GTY(()) rtx got_helper_rtx = NULL_RTX;\n+static GTY(()) rtx global_offset_table_rtx = NULL_RTX;\n+\n+/* Return the SYMBOL_REF for the Global Offset Table.  */\n+\n+static GTY(()) rtx sparc_got_symbol = NULL_RTX;\n+\n+static rtx\n+sparc_got (void)\n+{\n+  if (!sparc_got_symbol)\n+    sparc_got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+\n+  return sparc_got_symbol;\n+}\n \n /* Ensure that we are not using patterns that are not OK with PIC.  */\n \n int\n check_pic (int i)\n {\n+  rtx op;\n+\n   switch (flag_pic)\n     {\n     case 1:\n-      gcc_assert (GET_CODE (recog_data.operand[i]) != SYMBOL_REF\n-\t  \t  && (GET_CODE (recog_data.operand[i]) != CONST\n-\t          || (GET_CODE (XEXP (recog_data.operand[i], 0)) == MINUS\n-\t\t      && (XEXP (XEXP (recog_data.operand[i], 0), 0)\n-\t\t\t  == global_offset_table)\n-\t\t      && (GET_CODE (XEXP (XEXP (recog_data.operand[i], 0), 1))\n-\t\t\t  == CONST))));\n+      op = recog_data.operand[i];\n+      gcc_assert (GET_CODE (op) != SYMBOL_REF\n+\t  \t  && (GET_CODE (op) != CONST\n+\t\t      || (GET_CODE (XEXP (op, 0)) == MINUS\n+\t\t\t  && XEXP (XEXP (op, 0), 0) == sparc_got ()\n+\t\t\t  && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST)));\n     case 2:\n     default:\n       return 1;\n@@ -3274,9 +3287,9 @@ sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n   return 1;\n }\n \n-/* Construct the SYMBOL_REF for the tls_get_offset function.  */\n+/* Return the SYMBOL_REF for the tls_get_addr function.  */\n \n-static GTY(()) rtx sparc_tls_symbol;\n+static GTY(()) rtx sparc_tls_symbol = NULL_RTX;\n \n static rtx\n sparc_tls_get_addr (void)\n@@ -3287,21 +3300,28 @@ sparc_tls_get_addr (void)\n   return sparc_tls_symbol;\n }\n \n+/* Return the Global Offset Table to be used in TLS mode.  */\n+\n static rtx\n sparc_tls_got (void)\n {\n-  rtx temp;\n+  /* In PIC mode, this is just the PIC offset table.  */\n   if (flag_pic)\n     {\n       crtl->uses_pic_offset_table = 1;\n       return pic_offset_table_rtx;\n     }\n \n-  if (!global_offset_table)\n-    global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-  temp = gen_reg_rtx (Pmode);\n-  emit_move_insn (temp, global_offset_table);\n-  return temp;\n+  /* In non-PIC mode, Sun as (unlike GNU as) emits PC-relative relocations for\n+     the GOT symbol with the 32-bit ABI, so we reload the GOT register.  */\n+  if (TARGET_SUN_TLS && TARGET_ARCH32)\n+    {\n+      load_got_register ();\n+      return global_offset_table_rtx;\n+    }\n+\n+  /* In all other cases, we load a new pseudo with the GOT symbol.  */\n+  return copy_to_reg (sparc_got ());\n }\n \n /* Return true if X contains a thread-local symbol.  */\n@@ -3741,59 +3761,69 @@ sparc_mode_dependent_address_p (const_rtx addr)\n static void\n get_pc_thunk_name (char name[32], unsigned int regno)\n {\n-  const char *pic_name = reg_names[regno];\n+  const char *reg_name = reg_names[regno];\n \n   /* Skip the leading '%' as that cannot be used in a\n      symbol name.  */\n-  pic_name += 1;\n+  reg_name += 1;\n \n   if (USE_HIDDEN_LINKONCE)\n-    sprintf (name, \"__sparc_get_pc_thunk.%s\", pic_name);\n+    sprintf (name, \"__sparc_get_pc_thunk.%s\", reg_name);\n   else\n     ASM_GENERATE_INTERNAL_LABEL (name, \"LADDPC\", regno);\n }\n \n-/* Emit code to load the PIC register.  */\n+/* Wrapper around the load_pcrel_sym{si,di} patterns.  */\n \n-static void\n-load_pic_register (void)\n+static rtx\n+gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2, rtx op3)\n {\n   int orig_flag_pic = flag_pic;\n+  rtx insn;\n \n-  if (TARGET_VXWORKS_RTP)\n-    {\n-      emit_insn (gen_vxworks_load_got ());\n-      emit_use (pic_offset_table_rtx);\n-      return;\n-    }\n-\n-  /* If we haven't initialized the special PIC symbols, do so now.  */\n-  if (!pic_helper_needed)\n-    {\n-      char name[32];\n+  /* The load_pcrel_sym{si,di} patterns require absolute addressing.  */\n+  flag_pic = 0;\n+  if (TARGET_ARCH64)\n+    insn = gen_load_pcrel_symdi (op0, op1, op2, op3);\n+  else\n+    insn = gen_load_pcrel_symsi (op0, op1, op2, op3);\n+  flag_pic = orig_flag_pic;\n \n-      pic_helper_needed = true;\n+  return insn;\n+}\n \n-      get_pc_thunk_name (name, REGNO (pic_offset_table_rtx));\n-      pic_helper_symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+/* Emit code to load the GOT register.  */\n \n-      global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-    }\n+static void\n+load_got_register (void)\n+{\n+  /* In PIC mode, this will retrieve pic_offset_table_rtx.  */\n+  if (!global_offset_table_rtx)\n+    global_offset_table_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);\n \n-  flag_pic = 0;\n-  if (TARGET_ARCH64)\n-    emit_insn (gen_load_pcrel_symdi (pic_offset_table_rtx, global_offset_table,\n-\t\t\t\t     pic_helper_symbol));\n+  if (TARGET_VXWORKS_RTP)\n+    emit_insn (gen_vxworks_load_got ());\n   else\n-    emit_insn (gen_load_pcrel_symsi (pic_offset_table_rtx, global_offset_table,\n-\t\t\t\t     pic_helper_symbol));\n-  flag_pic = orig_flag_pic;\n+    {\n+      /* The GOT symbol is subject to a PC-relative relocation so we need a\n+\t helper function to add the PC value and thus get the final value.  */\n+      if (!got_helper_rtx)\n+\t{\n+\t  char name[32];\n+\t  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);\n+\t  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+\t}\n+\n+      emit_insn (gen_load_pcrel_sym (global_offset_table_rtx, sparc_got (),\n+\t\t\t\t     got_helper_rtx,\n+\t\t\t\t     GEN_INT (GLOBAL_OFFSET_TABLE_REGNUM)));\n+    }\n \n   /* Need to emit this whether or not we obey regdecls,\n      since setjmp/longjmp can cause life info to screw up.\n      ??? In the case where we don't obey regdecls, this is not sufficient\n      since we may not fall out the bottom.  */\n-  emit_use (pic_offset_table_rtx);\n+  emit_use (global_offset_table_rtx);\n }\n \n /* Emit a call instruction with the pattern given by PAT.  ADDR is the\n@@ -4479,7 +4509,7 @@ gen_stack_pointer_dec (rtx decrement)\n \n /* Expand the function prologue.  The prologue is responsible for reserving\n    storage for the frame, saving the call-saved registers and loading the\n-   PIC register if needed.  */\n+   GOT register if needed.  */\n \n void\n sparc_expand_prologue (void)\n@@ -4587,9 +4617,9 @@ sparc_expand_prologue (void)\n   if (num_gfregs)\n     emit_save_or_restore_regs (SORR_SAVE);\n \n-  /* Load the PIC register if needed.  */\n-  if (flag_pic && crtl->uses_pic_offset_table)\n-    load_pic_register ();\n+  /* Load the GOT register if needed.  */\n+  if (crtl->uses_pic_offset_table)\n+    load_got_register ();\n }\n \n /* This function generates the assembly code for function entry, which boils\n@@ -9157,7 +9187,7 @@ sparc_rtx_costs (rtx x, int code, int outer_code, int *total,\n /* Emit the sequence of insns SEQ while preserving the registers REG and REG2.\n    This is achieved by means of a manual dynamic stack space allocation in\n    the current frame.  We make the assumption that SEQ doesn't contain any\n-   function calls, with the possible exception of calls to the PIC helper.  */\n+   function calls, with the possible exception of calls to the GOT helper.  */\n \n static void\n emit_and_preserve (rtx seq, rtx reg, rtx reg2)\n@@ -9320,20 +9350,19 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     {\n       /* The hoops we have to jump through in order to generate a sibcall\n \t without using delay slots...  */\n-      rtx spill_reg, spill_reg2, seq, scratch = gen_rtx_REG (Pmode, 1);\n+      rtx spill_reg, seq, scratch = gen_rtx_REG (Pmode, 1);\n \n       if (flag_pic)\n         {\n \t  spill_reg = gen_rtx_REG (word_mode, 15);  /* %o7 */\n-\t  spill_reg2 = gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM);\n \t  start_sequence ();\n-\t  /* Delay emitting the PIC helper function because it needs to\n+\t  /* Delay emitting the GOT helper function because it needs to\n \t     change the section and we are emitting assembly code.  */\n-\t  load_pic_register ();  /* clobbers %o7 */\n+\t  load_got_register ();  /* clobbers %o7 */\n \t  scratch = sparc_legitimize_pic_address (funexp, scratch);\n \t  seq = get_insns ();\n \t  end_sequence ();\n-\t  emit_and_preserve (seq, spill_reg, spill_reg2);\n+\t  emit_and_preserve (seq, spill_reg, pic_offset_table_rtx);\n \t}\n       else if (TARGET_ARCH32)\n \t{\n@@ -9484,17 +9513,15 @@ sparc_output_dwarf_dtprel (FILE *file, int size, rtx x)\n static void\n sparc_file_end (void)\n {\n-  /* If need to emit the special PIC helper function, do so now.  */\n-  if (pic_helper_needed)\n+  /* If we need to emit the special GOT helper function, do so now.  */\n+  if (got_helper_rtx)\n     {\n-      unsigned int regno = REGNO (pic_offset_table_rtx);\n-      const char *pic_name = reg_names[regno];\n-      char name[32];\n+      const char *name = XSTR (got_helper_rtx, 0);\n+      const char *reg_name = reg_names[GLOBAL_OFFSET_TABLE_REGNUM];\n #ifdef DWARF2_UNWIND_INFO\n       bool do_cfi;\n #endif\n \n-      get_pc_thunk_name (name, regno);\n       if (USE_HIDDEN_LINKONCE)\n \t{\n \t  tree decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n@@ -9529,10 +9556,10 @@ sparc_file_end (void)\n #endif\n       if (flag_delayed_branch)\n \tfprintf (asm_out_file, \"\\tjmp\\t%%o7+8\\n\\t add\\t%%o7, %s, %s\\n\",\n-\t\t pic_name, pic_name);\n+\t\t reg_name, reg_name);\n       else\n \tfprintf (asm_out_file, \"\\tadd\\t%%o7, %s, %s\\n\\tjmp\\t%%o7+8\\n\\t nop\\n\",\n-\t\t pic_name, pic_name);\n+\t\t reg_name, reg_name);\n #ifdef DWARF2_UNWIND_INFO\n       if (do_cfi)\n \tfprintf (asm_out_file, \"\\t.cfi_endproc\\n\");"}, {"sha": "c41a623577b16119d51861e99aecb4f3fbe5e8e0", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "patch": "@@ -906,10 +906,15 @@ extern int sparc_mode_class[];\n    not be a register used by the prologue.  */\n #define STATIC_CHAIN_REGNUM (TARGET_ARCH64 ? 5 : 2)\n \n+/* Register which holds the global offset table, if any.  */\n+\n+#define GLOBAL_OFFSET_TABLE_REGNUM 23\n+\n /* Register which holds offset table for position-independent\n    data references.  */\n \n-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 23 : INVALID_REGNUM)\n+#define PIC_OFFSET_TABLE_REGNUM \\\n+  (flag_pic ? GLOBAL_OFFSET_TABLE_REGNUM : INVALID_REGNUM)\n \n /* Pick a default value we can notice from override_options:\n    !v9: Default is on."}, {"sha": "853bd2fbdcc6eb0e46c1e2f0dbb9aff23dd4e7e3", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6fed83ffa62aa01d7add21c9d2b36ba12efb731/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=a6fed83ffa62aa01d7add21c9d2b36ba12efb731", "patch": "@@ -1113,14 +1113,15 @@\n \n ;; Load in operand 0 the (absolute) address of operand 1, which is a symbolic\n ;; value subject to a PC-relative relocation.  Operand 2 is a helper function\n-;; that adds the PC value at the call point to operand 0.\n+;; that adds the PC value at the call point to register #(operand 3).\n \n (define_insn \"load_pcrel_sym<P:mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n \t(unspec:P [(match_operand:P 1 \"symbolic_operand\" \"\")\n-\t\t   (match_operand:P 2 \"call_address_operand\" \"\")] UNSPEC_LOAD_PCREL_SYM))\n+\t\t   (match_operand:P 2 \"call_address_operand\" \"\")\n+\t\t   (match_operand:P 3 \"const_int_operand\" \"\")] UNSPEC_LOAD_PCREL_SYM))\n    (clobber (reg:P 15))]\n-  \"\"\n+  \"REGNO (operands[0]) == INTVAL (operands[3])\"\n {\n   if (flag_delayed_branch)\n     return \"sethi\\t%%hi(%a1-4), %0\\n\\tcall\\t%a2\\n\\t add\\t%0, %%lo(%a1+4), %0\";"}]}