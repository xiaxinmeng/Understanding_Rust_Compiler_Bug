{"sha": "28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhiZTI5Y2U1MjAzNzVkMzkyYjVkN2FhMTlmNGRiZDRlNzI4ZjdlOA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-07-07T09:46:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-07T09:46:48Z"}, "message": "par-load.adb (Load): If a child unit is loaded through a limited_with clause...\n\n2005-07-07  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* par-load.adb (Load): If a child unit is loaded through a limited_with\n\tclause, each parent must be loaded as a limited unit as well.\n\n\t* sem_ch10.adb (Previous_Withed_Unit): Better name for\n\tCheck_Withed_Unit. Return true if there is a previous with_clause for\n\tthis unit, whether limited or not.\n\t(Expand_Limited_With_Clause): Do not generate a limited_with_clause on\n\tthe current unit.\n\t(Is_Visible_Through_Renamings): New local subprogram of install_limited\n\t_withed_unit that checks if some package installed through normal with\n\tclauses has a renaming declaration of package whose limited-view is\n\tready to be installed. This enforces the check of the rule 10.1.2 (21/2)\n\tof the current Draft document for Ada 2005.\n\t(Analyze_Context): Complete the list of compilation units that\n\tare allowed to contain limited-with clauses. It also contains\n\tchecks that were previously done by Install_Limited_Context_Clauses.\n\tThis makes the code more clear and easy to maintain.\n\t(Expand_Limited_With_Clause) It is now a local subprogram of\n\tInstall_Limited_Context_Clauses, and contains the code that adds\n\tthe implicit limited-with clauses for parents of child units.\n\tThis functionality was prevously done by Analyze_Context.\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Check wrong use of\n\tincomplete type.\n\n\t* sem_ch7.adb (Analyze_Package_Declaration): Check if the package has\n\tbeen erroneously named in a limited-with clause of its own context.\n\tIn this case the error has been previously notified by Analyze_Context.\n\nFrom-SVN: r101697", "tree": {"sha": "3f0ce912786f973e87338b2f1abe54b3ff6cb086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f0ce912786f973e87338b2f1abe54b3ff6cb086"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e7ce6ab67dd7e0e4b3c20e2b7391d63a8a187e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7ce6ab67dd7e0e4b3c20e2b7391d63a8a187e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7ce6ab67dd7e0e4b3c20e2b7391d63a8a187e1"}], "stats": {"total": 573, "additions": 386, "deletions": 187}, "files": [{"sha": "469a971c69d5dccaa60223156d3f046b8bdf6afe", "filename": "gcc/ada/par-load.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "patch": "@@ -301,6 +301,8 @@ begin\n       end if;\n \n    --  If current unit is a child unit spec, load its parent\n+   --  If the child unit is loaded through a limited with, the parent\n+   --  must be as well.\n \n    elsif Nkind (Unit (Curunit)) = N_Package_Declaration\n      or else Nkind (Unit (Curunit)) =  N_Subprogram_Declaration\n@@ -323,7 +325,8 @@ begin\n              (Load_Name  => Spec_Name,\n               Required   => True,\n               Subunit    => False,\n-              Error_Node => Curunit);\n+              Error_Node => Curunit,\n+              From_Limited_With => From_Limited_With);\n \n          if Unum /= No_Unit then\n             Set_Parent_Spec (Unit (Curunit), Cunit (Unum));"}, {"sha": "a352efd6455383d9fcdec8660548e5b62217743f", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 352, "deletions": 186, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "patch": "@@ -95,14 +95,6 @@ package body Sem_Ch10 is\n    --  Verify that a stub is declared immediately within a compilation unit,\n    --  and not in an inner frame.\n \n-   procedure Expand_Limited_With_Clause (Nam : Node_Id; N : Node_Id);\n-   --  If a child unit appears in a limited_with clause, there are implicit\n-   --  limited_with clauses on all parents that are not already visible\n-   --  through a regular with clause. This procedure creates the implicit\n-   --  limited with_clauses for the parents and loads the corresponding units.\n-   --  The shadow entities are created when the inserted clause is analyzed.\n-   --  Implements Ada 2005 (AI-50217).\n-\n    procedure Expand_With_Clause (Nam : Node_Id; N : Node_Id);\n    --  When a child unit appears in a context clause, the implicit withs on\n    --  parents are made explicit, and with clauses are inserted in the context\n@@ -124,8 +116,8 @@ package body Sem_Ch10 is\n    --  all its ancestors.\n \n    procedure Install_Context_Clauses (N : Node_Id);\n-   --  Subsidiary to previous one. Process only with_ and use_clauses for\n-   --  current unit and its library unit if any.\n+   --  Subsidiary to Install_Context and Install_Parents. Process only with_\n+   --  and use_clauses for current unit and its library unit if any.\n \n    procedure Install_Limited_Context_Clauses (N : Node_Id);\n    --  Subsidiary to Install_Context. Process only limited with_clauses\n@@ -138,7 +130,6 @@ package body Sem_Ch10 is\n    procedure Install_Withed_Unit\n      (With_Clause     : Node_Id;\n       Private_With_OK : Boolean := False);\n-\n    --  If the unit is not a child unit, make unit immediately visible.\n    --  The caller ensures that the unit is not already currently installed.\n    --  The flag Private_With_OK is set true in Install_Private_With_Clauses,\n@@ -807,11 +798,9 @@ package body Sem_Ch10 is\n       Item  : Node_Id;\n \n    begin\n-      --  Loop through context items. This is done is three passes:\n-      --  a) The first pass analyze non-limited with-clauses.\n-      --  b) The second pass add implicit limited_with clauses for\n-      --     the parents of child units (Ada 2005: AI-50217)\n-      --  c) The third pass analyzes limited_with clauses (Ada 2005: AI-50217)\n+      --  Loop through context items. This is done in two:\n+      --  a) The first  pass analyzes non-limited with-clauses\n+      --  b) The second pass analyzes limited_with clauses (Ada 2005: AI-50217)\n \n       Item := First (Context_Items (N));\n       while Present (Item) loop\n@@ -848,47 +837,133 @@ package body Sem_Ch10 is\n          Next (Item);\n       end loop;\n \n-      --  Second pass: add implicit limited_with_clauses for parents of\n-      --  child units mentioned in limited_with clauses.\n+      --  Second pass: examine all limited_with clauses\n \n       Item := First (Context_Items (N));\n-\n       while Present (Item) loop\n          if Nkind (Item) = N_With_Clause\n            and then Limited_Present (Item)\n-           and then  Nkind (Name (Item)) = N_Selected_Component\n          then\n-            Expand_Limited_With_Clause\n-              (Nam => Prefix (Name (Item)), N  => Item);\n-         end if;\n+            --  No need to check errors on implicitly generated limited-with\n+            --  clauses.\n \n-         Next (Item);\n-      end loop;\n+            if not Implicit_With (Item) then\n \n-      --  Third pass: examine all limited_with clauses\n+               --  Check compilation unit containing the limited-with clause\n+\n+               if Ukind /= N_Package_Declaration\n+                 and then Ukind /= N_Subprogram_Declaration\n+                 and then Ukind /= N_Subprogram_Renaming_Declaration\n+                 and then Ukind /= N_Generic_Package_Declaration\n+                 and then Ukind /= N_Generic_Package_Renaming_Declaration\n+                 and then Ukind /= N_Generic_Subprogram_Declaration\n+                 and then Ukind /= N_Generic_Procedure_Renaming_Declaration\n+                 and then Ukind /= N_Package_Instantiation\n+                 and then Ukind /= N_Package_Renaming_Declaration\n+                 and then Ukind /= N_Procedure_Instantiation\n+               then\n+                  Error_Msg_N (\"limited with_clause not allowed here\", Item);\n \n-      Item := First (Context_Items (N));\n+               --  Check wrong use of a limited with clause applied to the\n+               --  compilation unit containing the limited-with clause.\n \n-      while Present (Item) loop\n-         if Nkind (Item) = N_With_Clause\n-           and then Limited_Present (Item)\n-         then\n-            --  Check the compilation unit containing the limited-with\n-            --  clause\n-\n-            if Ukind /= N_Package_Declaration\n-              and then Ukind /= N_Subprogram_Declaration\n-              and then Ukind /= N_Subprogram_Renaming_Declaration\n-              and then Ukind /= N_Generic_Package_Declaration\n-              and then Ukind /= N_Generic_Package_Renaming_Declaration\n-              and then Ukind /= N_Generic_Subprogram_Declaration\n-              and then Ukind /= N_Generic_Procedure_Renaming_Declaration\n-              and then Ukind /= N_Package_Instantiation\n-              and then Ukind /= N_Package_Renaming_Declaration\n-              and then Ukind /= N_Procedure_Instantiation\n-            then\n-               Error_Msg_N\n-                 (\"limited with_clause not allowed here\", Item);\n+               --      limited with P.Q;\n+               --      package P.Q is ...\n+\n+               elsif Unit (Library_Unit (Item)) = Unit (N) then\n+                  Error_Msg_N (\"wrong use of limited-with clause\", Item);\n+\n+               --  Check wrong use of limited-with clause applied to some\n+               --  immediate ancestor.\n+\n+               elsif Is_Child_Spec (Unit (N)) then\n+                  declare\n+                     Lib_U : constant Entity_Id := Unit (Library_Unit (Item));\n+                     P     : Node_Id;\n+\n+                  begin\n+                     P := Parent_Spec (Unit (N));\n+                     loop\n+                        if Unit (P) = Lib_U then\n+                           Error_Msg_N (\"limited with_clause of immediate \"\n+                                        & \"ancestor not allowed\", Item);\n+                           exit;\n+                        end if;\n+\n+                        exit when not Is_Child_Spec (Unit (P));\n+                        P := Parent_Spec (Unit (P));\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               --  Check if the limited-withed unit is already visible through\n+               --  some context clause of the current compilation unit or some\n+               --  ancestor of the current compilation unit.\n+\n+               declare\n+                  Lim_Unit_Name : constant Node_Id := Name (Item);\n+                  Comp_Unit     : Node_Id;\n+                  It            : Node_Id;\n+                  Unit_Name     : Node_Id;\n+\n+               begin\n+                  Comp_Unit := N;\n+                  loop\n+                     It := First (Context_Items (Comp_Unit));\n+                     while Present (It) loop\n+                        if Item /= It\n+                          and then Nkind (It) = N_With_Clause\n+                          and then not Limited_Present (It)\n+                          and then\n+                             (Nkind (Unit (Library_Unit (It)))\n+                               = N_Package_Declaration\n+                            or else\n+                              Nkind (Unit (Library_Unit (It)))\n+                               = N_Package_Renaming_Declaration)\n+                        then\n+                           if Nkind (Unit (Library_Unit (It)))\n+                                = N_Package_Declaration\n+                           then\n+                              Unit_Name := Name (It);\n+                           else\n+                              Unit_Name := Name (Unit (Library_Unit (It)));\n+                           end if;\n+\n+                           --  Check if the named package (or some ancestor)\n+                           --  leaves visible the full-view of the unit given\n+                           --  in the limited-with clause\n+\n+                           loop\n+                              if Designate_Same_Unit (Lim_Unit_Name,\n+                                                      Unit_Name)\n+                              then\n+                                 Error_Msg_Sloc := Sloc (It);\n+                                 Error_Msg_NE\n+                                   (\"unlimited view visible through the\"\n+                                    & \" context clause found #\",\n+                                    Item, It);\n+                                 Error_Msg_N\n+                                   (\"simultaneous visibility of the limited\"\n+                                    & \" and unlimited views not allowed\"\n+                                    , Item);\n+                                 exit;\n+\n+                              elsif Nkind (Unit_Name) = N_Identifier then\n+                                 exit;\n+                              end if;\n+\n+                              Unit_Name := Prefix (Unit_Name);\n+                           end loop;\n+                        end if;\n+\n+                        Next (It);\n+                     end loop;\n+\n+                     exit when not Is_Child_Spec (Unit (Comp_Unit));\n+\n+                     Comp_Unit := Parent_Spec (Unit (Comp_Unit));\n+                  end loop;\n+               end;\n             end if;\n \n             --  Skip analyzing with clause if no unit, see above\n@@ -2469,79 +2544,6 @@ package body Sem_Ch10 is\n       New_Nodes_OK := New_Nodes_OK - 1;\n    end Expand_With_Clause;\n \n-   --------------------------------\n-   -- Expand_Limited_With_Clause --\n-   --------------------------------\n-\n-   procedure Expand_Limited_With_Clause (Nam : Node_Id; N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (Nam);\n-      Unum  : Unit_Number_Type;\n-      Withn : Node_Id;\n-\n-   begin\n-      New_Nodes_OK := New_Nodes_OK + 1;\n-\n-      if Nkind (Nam) = N_Identifier then\n-         Withn :=\n-           Make_With_Clause (Loc, Name => Nam);\n-         Set_Limited_Present (Withn);\n-         Set_First_Name      (Withn);\n-         Set_Implicit_With   (Withn);\n-\n-         --  Load the corresponding parent unit\n-\n-         Unum :=\n-           Load_Unit\n-           (Load_Name  => Get_Spec_Name (Get_Unit_Name (Nam)),\n-            Required   => True,\n-            Subunit    => False,\n-            Error_Node => Nam);\n-\n-         if not Analyzed (Cunit (Unum)) then\n-            Set_Library_Unit (Withn, Cunit (Unum));\n-            Set_Corresponding_Spec\n-              (Withn, Specification (Unit (Cunit (Unum))));\n-\n-            Prepend (Withn, Context_Items (Parent (N)));\n-            Mark_Rewrite_Insertion (Withn);\n-         end if;\n-\n-      else pragma Assert (Nkind (Nam) = N_Selected_Component);\n-         Withn :=\n-           Make_With_Clause\n-           (Loc,\n-            Name =>\n-              Make_Selected_Component\n-                (Loc,\n-                 Prefix        => Prefix (Nam),\n-                 Selector_Name => Selector_Name (Nam)));\n-\n-         Set_Parent (Withn, Parent (N));\n-         Set_Limited_Present (Withn);\n-         Set_First_Name      (Withn);\n-         Set_Implicit_With   (Withn);\n-\n-         Unum :=\n-           Load_Unit\n-             (Load_Name  => Get_Spec_Name (Get_Unit_Name (Nam)),\n-              Required   => True,\n-              Subunit    => False,\n-              Error_Node => Nam);\n-\n-         if not Analyzed (Cunit (Unum)) then\n-            Set_Library_Unit (Withn, Cunit (Unum));\n-            Set_Corresponding_Spec\n-              (Withn, Specification (Unit (Cunit (Unum))));\n-            Prepend (Withn, Context_Items (Parent (N)));\n-            Mark_Rewrite_Insertion (Withn);\n-\n-            Expand_Limited_With_Clause (Prefix (Nam), N);\n-         end if;\n-      end if;\n-\n-      New_Nodes_OK := New_Nodes_OK - 1;\n-   end Expand_Limited_With_Clause;\n-\n    -----------------------\n    -- Get_Parent_Entity --\n    -----------------------\n@@ -2938,27 +2940,30 @@ package body Sem_Ch10 is\n    procedure Install_Limited_Context_Clauses (N : Node_Id) is\n       Item : Node_Id;\n \n-      procedure Check_Parent (P : Node_Id; W : Node_Id);\n+      procedure Check_Renamings (P : Node_Id; W : Node_Id);\n       --  Check that the unlimited view of a given compilation_unit is not\n-      --  already visible in the parents (neither immediately through the\n-      --  context clauses, nor indirectly through \"use + renamings\").\n+      --  already visible through \"use + renamings\".\n \n       procedure Check_Private_Limited_Withed_Unit (N : Node_Id);\n       --  Check that if a limited_with clause of a given compilation_unit\n       --  mentions a private child of some library unit, then the given\n       --  compilation_unit shall be the declaration of a private descendant\n       --  of that library unit.\n \n-      procedure Check_Withed_Unit (W : Node_Id);\n-      --  Check that a limited with_clause does not appear in the same\n-      --  context_clause as a nonlimited with_clause that mentions\n-      --  the same library.\n+      procedure Expand_Limited_With_Clause\n+        (Comp_Unit : Node_Id; Nam : Node_Id; N : Node_Id);\n+      --  If a child unit appears in a limited_with clause, there are implicit\n+      --  limited_with clauses on all parents that are not already visible\n+      --  through a regular with clause. This procedure creates the implicit\n+      --  limited with_clauses for the parents and loads the corresponding\n+      --  units. The shadow entities are created when the inserted clause is\n+      --  analyzed. Implements Ada 2005 (AI-50217).\n \n-      ------------------\n-      -- Check_Parent --\n-      ------------------\n+      ---------------------\n+      -- Check_Renamings --\n+      ---------------------\n \n-      procedure Check_Parent (P : Node_Id; W : Node_Id) is\n+      procedure Check_Renamings (P : Node_Id; W : Node_Id) is\n          Item   : Node_Id;\n          Spec   : Node_Id;\n          WEnt   : Entity_Id;\n@@ -2982,36 +2987,11 @@ package body Sem_Ch10 is\n                return;\n          end case;\n \n-         --  Step 1: Check if the unlimited view is installed in the parent\n-\n-         Item := First (Context_Items (P));\n-         while Present (Item) loop\n-            if Nkind (Item) = N_With_Clause\n-              and then not Limited_Present (Item)\n-              and then not Implicit_With (Item)\n-              and then Library_Unit (Item) = Library_Unit (W)\n-            then\n-               Error_Msg_N (\"unlimited view visible in ancestor\", W);\n-               return;\n-            end if;\n-\n-            Next (Item);\n-         end loop;\n-\n-         --  Step 2: Check \"use + renamings\"\n+         --  Check \"use + renamings\"\n \n          WEnt := Defining_Unit_Name (Specification (Unit (Library_Unit (W))));\n          Spec := Specification (Unit (P));\n \n-         --  We tried to traverse the list of entities corresponding to the\n-         --  defining entity of the package spec. However, first_entity was\n-         --  found to be 'empty'. Don't know why???\n-\n-         --          Def  := Defining_Unit_Name (Spec);\n-         --          Ent  := First_Entity (Def);\n-\n-         --  As a workaround we traverse the list of visible declarations ???\n-\n          Item := First (Visible_Declarations (Spec));\n          while Present (Item) loop\n \n@@ -3063,9 +3043,9 @@ package body Sem_Ch10 is\n          --  Recursive call to check all the ancestors\n \n          if Is_Child_Spec (Unit (P)) then\n-            Check_Parent (P => Parent_Spec (Unit (P)), W => W);\n+            Check_Renamings (P => Parent_Spec (Unit (P)), W => W);\n          end if;\n-      end Check_Parent;\n+      end Check_Renamings;\n \n       ---------------------------------------\n       -- Check_Private_Limited_Withed_Unit --\n@@ -3108,32 +3088,109 @@ package body Sem_Ch10 is\n          end if;\n       end Check_Private_Limited_Withed_Unit;\n \n-      -----------------------\n-      -- Check_Withed_Unit --\n-      -----------------------\n+      --------------------------------\n+      -- Expand_Limited_With_Clause --\n+      --------------------------------\n \n-      procedure Check_Withed_Unit (W : Node_Id) is\n-         Item : Node_Id;\n+      procedure Expand_Limited_With_Clause\n+        (Comp_Unit : Node_Id;\n+         Nam       : Node_Id;\n+         N         : Node_Id)\n+      is\n+         Loc   : constant Source_Ptr := Sloc (Nam);\n+         Unum  : Unit_Number_Type;\n+         Withn : Node_Id;\n+\n+         function Previous_Withed_Unit (W : Node_Id) return Boolean;\n+         --  Returns true if the context already includes a with_clause for\n+         --  this unit. If the with_clause is non-limited, the unit is fully\n+         --  visible and an implicit limited_with should not be created. If\n+         --  there is already a limited_with clause for W, a second one is\n+         --  simply redundant.\n+\n+         --------------------------\n+         -- Previous_Withed_Unit --\n+         --------------------------\n+\n+         function Previous_Withed_Unit (W : Node_Id) return Boolean is\n+            Item : Node_Id;\n+\n+         begin\n+            --  A limited with_clause can not appear in the same context_clause\n+            --  as a nonlimited with_clause which mentions the same library.\n+\n+            Item := First (Context_Items (Comp_Unit));\n+            while Present (Item) loop\n+               if Nkind (Item) = N_With_Clause\n+                 and then Library_Unit (Item) = Library_Unit (W)\n+               then\n+                  return True;\n+               end if;\n+\n+               Next (Item);\n+            end loop;\n+\n+            return False;\n+         end Previous_Withed_Unit;\n+\n+      --  Start of processing for Expand_Limited_With_Clause\n \n       begin\n-         --  A limited with_clause can not appear in the same context_clause\n-         --  as a nonlimited with_clause which mentions the same library.\n+         New_Nodes_OK := New_Nodes_OK + 1;\n \n-         Item := First (Context_Items (N));\n-         while Present (Item) loop\n-            if Nkind (Item) = N_With_Clause\n-              and then not Limited_Present (Item)\n-              and then not Implicit_With (Item)\n-              and then Library_Unit (Item) = Library_Unit (W)\n-            then\n-               Error_Msg_N (\"limited and unlimited view \"\n-                            & \"not allowed in the same context clauses\", W);\n+         if Nkind (Nam) = N_Identifier then\n+            Withn := Make_With_Clause (Loc, Nam);\n+\n+         else pragma Assert (Nkind (Nam) = N_Selected_Component);\n+            Withn := Make_With_Clause (Loc,\n+                       Make_Selected_Component (Loc,\n+                          Prefix        => Prefix (Nam),\n+                          Selector_Name => Selector_Name (Nam)));\n+            Set_Parent (Withn, Parent (N));\n+         end if;\n+\n+         Set_Limited_Present (Withn);\n+         Set_First_Name      (Withn);\n+         Set_Implicit_With   (Withn);\n+\n+         Unum :=\n+           Load_Unit\n+             (Load_Name  => Get_Spec_Name (Get_Unit_Name (Nam)),\n+              Required   => True,\n+              Subunit    => False,\n+              Error_Node => Nam);\n+\n+         if not Analyzed (Cunit (Unum)) then\n+            --  Do not generate a limited_with_clause on the current unit.\n+            --  This path is taken when a unit has a limited_with clause on\n+            --  one of its child units.\n+\n+            if Unum = Current_Sem_Unit then\n                return;\n             end if;\n \n-            Next (Item);\n-         end loop;\n-      end Check_Withed_Unit;\n+            Set_Library_Unit (Withn, Cunit (Unum));\n+            Set_Corresponding_Spec\n+              (Withn, Specification (Unit (Cunit (Unum))));\n+\n+            if not Previous_Withed_Unit (Withn) then\n+               Prepend (Withn, Context_Items (Parent (N)));\n+               Mark_Rewrite_Insertion (Withn);\n+\n+               --  Add implicit limited_with_clauses for parents of child units\n+               --  mentioned in limited_with clauses\n+\n+               if Nkind (Nam) = N_Selected_Component then\n+                  Expand_Limited_With_Clause (Comp_Unit, Prefix (Nam), N);\n+               end if;\n+\n+               Analyze (Withn);\n+               Install_Limited_Withed_Unit (Withn);\n+            end if;\n+         end if;\n+\n+         New_Nodes_OK := New_Nodes_OK - 1;\n+      end Expand_Limited_With_Clause;\n \n    --  Start of processing for Install_Limited_Context_Clauses\n \n@@ -3143,17 +3200,29 @@ package body Sem_Ch10 is\n          if Nkind (Item) = N_With_Clause\n            and then Limited_Present (Item)\n          then\n-            Check_Withed_Unit (Item);\n+            if Nkind (Name (Item)) = N_Selected_Component then\n+               Expand_Limited_With_Clause\n+                 (Comp_Unit => N, Nam => Prefix (Name (Item)), N => Item);\n+            end if;\n \n             if Private_Present (Library_Unit (Item)) then\n                Check_Private_Limited_Withed_Unit (Item);\n             end if;\n \n-            if Is_Child_Spec (Unit (N)) then\n-               Check_Parent (Parent_Spec (Unit (N)), Item);\n+            if not Implicit_With (Item)\n+              and then Is_Child_Spec (Unit (N))\n+            then\n+               Check_Renamings (Parent_Spec (Unit (N)), Item);\n             end if;\n \n-            Install_Limited_Withed_Unit (Item);\n+            --  A unit may have a limited with on itself if it has a\n+            --  limited with_clause on one of its child units. In that\n+            --  case it is already being compiled and it makes no sense\n+            --  to install its limited view.\n+\n+            if Library_Unit (Item) /= Cunit (Current_Sem_Unit) then\n+               Install_Limited_Withed_Unit (Item);\n+            end if;\n          end if;\n \n          Next (Item);\n@@ -3406,6 +3475,10 @@ package body Sem_Ch10 is\n       --  Check that the shadow entity is not already in the homonym\n       --  chain, for example through a limited_with clause in a parent unit.\n \n+      function Is_Visible_Through_Renamings (P : Entity_Id) return Boolean;\n+      --  Check if some package installed though normal with-clauses has a\n+      --  renaming declaration of package P. AARM 10.1.2(21/2).\n+\n       --------------\n       -- In_Chain --\n       --------------\n@@ -3425,6 +3498,94 @@ package body Sem_Ch10 is\n          return False;\n       end In_Chain;\n \n+      ----------------------------------\n+      -- Is_Visible_Through_Renamings --\n+      ----------------------------------\n+\n+      function Is_Visible_Through_Renamings (P : Entity_Id) return Boolean is\n+         Kind : constant Node_Kind := Nkind (Unit (Cunit (Current_Sem_Unit)));\n+         Aux_Unit : Node_Id;\n+         Item     : Node_Id;\n+         Decl     : Entity_Id;\n+\n+      begin\n+         --  Example of the error detected by this subprogram:\n+\n+         --  package P is\n+         --    type T is ...\n+         --  end P;\n+\n+         --  with P;\n+         --  package Q is\n+         --     package Ren_P renames P;\n+         --  end Q;\n+\n+         --  with Q;\n+         --  package R is ...\n+\n+         --  limited with P; -- ERROR\n+         --  package R.C is ...\n+\n+         Aux_Unit := Cunit (Current_Sem_Unit);\n+         loop\n+            Item := First (Context_Items (Aux_Unit));\n+            while Present (Item) loop\n+               if Nkind (Item) = N_With_Clause\n+                 and then not Limited_Present (Item)\n+                 and then Nkind (Unit (Library_Unit (Item)))\n+                            = N_Package_Declaration\n+               then\n+                  Decl :=\n+                    First (Visible_Declarations\n+                            (Specification (Unit (Library_Unit (Item)))));\n+                  while Present (Decl) loop\n+                     if Nkind (Decl) = N_Package_Renaming_Declaration\n+                       and then Entity (Name (Decl)) = P\n+                     then\n+                        --  Generate the error message only if the current unit\n+                        --  is a package declaration; in case of subprogram\n+                        --  bodies and package bodies we just return true to\n+                        --  indicate that the limited view must not be\n+                        --  installed.\n+\n+                        if Kind = N_Package_Declaration then\n+                           Error_Msg_Sloc := Sloc (Item);\n+                           Error_Msg_NE\n+                             (\"unlimited view of & visible through the context\"\n+                              & \" clause found #\", N, P);\n+\n+                           Error_Msg_Sloc := Sloc (Decl);\n+                           Error_Msg_NE\n+                             (\"unlimited view of & visible through the\"\n+                              & \" renaming found #\", N, P);\n+\n+                           Error_Msg_N\n+                             (\"simultaneous visibility of the limited and\"\n+                              & \" unlimited views not allowed\", N);\n+                        end if;\n+\n+                        return True;\n+                     end if;\n+\n+                     Next (Decl);\n+                  end loop;\n+               end if;\n+\n+               Next (Item);\n+            end loop;\n+\n+            if Present (Library_Unit (Aux_Unit)) then\n+               Aux_Unit := Library_Unit (Aux_Unit);\n+            else\n+               Aux_Unit := Parent_Spec (Unit (Aux_Unit));\n+            end if;\n+\n+            exit when not Present (Aux_Unit);\n+         end loop;\n+\n+         return False;\n+      end Is_Visible_Through_Renamings;\n+\n    --  Start of processing for Install_Limited_Withed_Unit\n \n    begin\n@@ -3446,7 +3607,14 @@ package body Sem_Ch10 is\n          P := Defining_Identifier (P);\n       end if;\n \n-      --  A common usage of the limited-with is to have a limited-with\n+      --  Do not install the limited-view if the full-view is already visible\n+      --  through some renaming declaration\n+\n+      if Is_Visible_Through_Renamings (P) then\n+         return;\n+      end if;\n+\n+      --  A common use of the limited-with is to have a limited-with\n       --  in the package spec, and a normal with in its package body.\n       --  For example:\n \n@@ -3542,7 +3710,6 @@ package body Sem_Ch10 is\n                Set_Scope (P, Parent_Id);\n             end;\n          end if;\n-\n       else\n \n          --  If the unit appears in a previous regular with_clause, the\n@@ -3559,10 +3726,9 @@ package body Sem_Ch10 is\n                Next_Entity (Ent);\n             end loop;\n          end;\n-\n       end if;\n \n-      --  The package must be visible while the with_type clause is active,\n+      --  The package must be visible while the limited-with clause is active,\n       --  because references to the type P.T must resolve in the usual way.\n \n       Set_Is_Immediately_Visible (P);"}, {"sha": "8ce93e7ae548900949ea015760534520a36b929a", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "patch": "@@ -2679,6 +2679,25 @@ package body Sem_Ch4 is\n \n                Resolve (Name);\n \n+               --  Ada 2005 (AI-50217): Check wrong use of incomplete type.\n+               --  Example:\n+\n+               --    limited with Pkg;\n+               --    package Pkg is\n+               --       type Acc_Inc is access Pkg.T;\n+               --       X : Acc_Inc;\n+               --       N : Natural := X.all.Comp; -- ERROR\n+               --    end Pkg;\n+\n+               if Nkind (Name) = N_Explicit_Dereference\n+                 and then From_With_Type (Etype (Prefix (Name)))\n+                 and then not Is_Potentially_Use_Visible (Etype (Name))\n+               then\n+                  Error_Msg_NE\n+                    (\"premature usage of incomplete}\", Prefix (Name),\n+                     Etype (Prefix (Name)));\n+               end if;\n+\n                --  We never need an actual subtype for the case of a selection\n                --  for a indexed component of a non-packed array, since in\n                --  this case gigi generates all the checks and can find the"}, {"sha": "e5827c42e0559c2b850cb5187da3eb7605170c6a", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28be29ce520375d392b5d7aa19f4dbd4e728f7e8/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=28be29ce520375d392b5d7aa19f4dbd4e728f7e8", "patch": "@@ -623,6 +623,17 @@ package body Sem_Ch7 is\n       PF : Boolean;\n \n    begin\n+      --  Ada 2005 (AI-217): Check if the package has been erroneously named\n+      --  in a limited-with clause of its own context. In this case the error\n+      --  has been previously notified by Analyze_Context.\n+\n+      --     limited with Pkg; -- ERROR\n+      --     package Pkg is ...\n+\n+      if From_With_Type (Id) then\n+         return;\n+      end if;\n+\n       Generate_Definition (Id);\n       Enter_Name (Id);\n       Set_Ekind (Id, E_Package);"}]}