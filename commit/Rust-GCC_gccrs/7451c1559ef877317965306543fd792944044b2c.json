{"sha": "7451c1559ef877317965306543fd792944044b2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ1MWMxNTU5ZWY4NzczMTc5NjUzMDY1NDNmZDc5Mjk0NDA0NGIyYw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-04-19T20:54:55Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-04-19T20:54:55Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (ordinary_java_source_files): Added new files.\n\t* java/security/AlgorithmParameterGenerator.java,\n\tjava/security/AlgorithmParameters.java, java/security/Engine.java,\n\tjava/security/Identity.java, java/security/IdentityScope.java,\n\tjava/security/KeyFactory.java,\n\tjava/security/KeyPairGenerator.java, java/security/KeyStore.java,\n\tjava/security/MessageDigest.java, java/security/Policy.java,\n\tjava/security/ProtectionDomain.java,\n\tjava/security/SecureRandom.java, java/security/Security.java,\n\tjava/security/Signature.java, java/security/SignatureSpi.java,\n\tjava/security/SignedObject.java, java/security/Signer.java,\n\tjava/security/interfaces/RSAMultiPrimePrivateCrtKey.java,\n\tjava/security/spec/PSSParameterSpec.java,\n\tjava/security/spec/RSAMultiPrimePrivateCrtKeySpec.java,\n\tjava/security/spec/RSAOtherPrimeInfo.java: New versions from\n\tClasspath.\n\nFrom-SVN: r65829", "tree": {"sha": "847219286ef699ba044b108442bad4ce9ee618f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/847219286ef699ba044b108442bad4ce9ee618f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7451c1559ef877317965306543fd792944044b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7451c1559ef877317965306543fd792944044b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7451c1559ef877317965306543fd792944044b2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7451c1559ef877317965306543fd792944044b2c/comments", "author": null, "committer": null, "parents": [{"sha": "9e9e204234b883d783914aa909e96c57d45ac081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9e204234b883d783914aa909e96c57d45ac081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9e204234b883d783914aa909e96c57d45ac081"}], "stats": {"total": 5675, "additions": 3787, "deletions": 1888}, "files": [{"sha": "c68224c2da89c37523d62e76366c58c771f516a1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,3 +1,23 @@\n+2003-04-19  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (ordinary_java_source_files): Added new files.\n+\t* java/security/AlgorithmParameterGenerator.java,\n+\tjava/security/AlgorithmParameters.java, java/security/Engine.java,\n+\tjava/security/Identity.java, java/security/IdentityScope.java,\n+\tjava/security/KeyFactory.java,\n+\tjava/security/KeyPairGenerator.java, java/security/KeyStore.java,\n+\tjava/security/MessageDigest.java, java/security/Policy.java,\n+\tjava/security/ProtectionDomain.java,\n+\tjava/security/SecureRandom.java, java/security/Security.java,\n+\tjava/security/Signature.java, java/security/SignatureSpi.java,\n+\tjava/security/SignedObject.java, java/security/Signer.java,\n+\tjava/security/interfaces/RSAMultiPrimePrivateCrtKey.java,\n+\tjava/security/spec/PSSParameterSpec.java,\n+\tjava/security/spec/RSAMultiPrimePrivateCrtKeySpec.java,\n+\tjava/security/spec/RSAOtherPrimeInfo.java: New versions from\n+\tClasspath.\n+\n 2003-04-19  Scott Gilbertson  <scottg@mantatest.com>\n \n \t* gnu/awt/xlib/XGraphics.java (XGraphics): Use new GC.create."}, {"sha": "35a2099868be8f7b76ae1f4f46fa4c4f8e18f919", "filename": "libjava/Makefile.am", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -2294,6 +2294,7 @@ java/security/DummySignature.java \\\n java/security/DigestInputStream.java \\\n java/security/DomainCombiner.java \\\n java/security/DummyMessageDigest.java \\\n+java/security/Engine.java \\\n java/security/GeneralSecurityException.java \\\n java/security/Guard.java \\\n java/security/GuardedObject.java \\\n@@ -2374,6 +2375,7 @@ java/security/interfaces/DSAParams.java \\\n java/security/interfaces/DSAPrivateKey.java \\\n java/security/interfaces/DSAPublicKey.java \\\n java/security/interfaces/RSAKey.java \\\n+java/security/interfaces/RSAMultiPrimePrivateCrtKey.java \\\n java/security/interfaces/RSAPrivateCrtKey.java \\\n java/security/interfaces/RSAPrivateKey.java \\\n java/security/interfaces/RSAPublicKey.java \\\n@@ -2386,7 +2388,10 @@ java/security/spec/InvalidKeySpecException.java \\\n java/security/spec/InvalidParameterSpecException.java \\\n java/security/spec/KeySpec.java \\\n java/security/spec/PKCS8EncodedKeySpec.java \\\n+java/security/spec/PSSParameterSpec.java \\\n java/security/spec/RSAKeyGenParameterSpec.java \\\n+java/security/spec/RSAMultiPrimePrivateCrtKeySpec.java\\\n+java/security/spec/RSAOtherPrimeInfo.java \\\n java/security/spec/RSAPrivateCrtKeySpec.java \\\n java/security/spec/RSAPrivateKeySpec.java \\\n java/security/spec/RSAPublicKeySpec.java \\"}, {"sha": "2b94176c9b5b4ba5e1b5e05dc366cfad351da176", "filename": "libjava/Makefile.in", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -2056,6 +2056,7 @@ java/security/DummySignature.java \\\n java/security/DigestInputStream.java \\\n java/security/DomainCombiner.java \\\n java/security/DummyMessageDigest.java \\\n+java/security/Engine.java \\\n java/security/GeneralSecurityException.java \\\n java/security/Guard.java \\\n java/security/GuardedObject.java \\\n@@ -2136,6 +2137,7 @@ java/security/interfaces/DSAParams.java \\\n java/security/interfaces/DSAPrivateKey.java \\\n java/security/interfaces/DSAPublicKey.java \\\n java/security/interfaces/RSAKey.java \\\n+java/security/interfaces/RSAMultiPrimePrivateCrtKey.java \\\n java/security/interfaces/RSAPrivateCrtKey.java \\\n java/security/interfaces/RSAPrivateKey.java \\\n java/security/interfaces/RSAPublicKey.java \\\n@@ -2148,7 +2150,10 @@ java/security/spec/InvalidKeySpecException.java \\\n java/security/spec/InvalidParameterSpecException.java \\\n java/security/spec/KeySpec.java \\\n java/security/spec/PKCS8EncodedKeySpec.java \\\n+java/security/spec/PSSParameterSpec.java \\\n java/security/spec/RSAKeyGenParameterSpec.java \\\n+java/security/spec/RSAMultiPrimePrivateCrtKeySpec.java\\\n+java/security/spec/RSAOtherPrimeInfo.java \\\n java/security/spec/RSAPrivateCrtKeySpec.java \\\n java/security/spec/RSAPrivateKeySpec.java \\\n java/security/spec/RSAPublicKeySpec.java \\\n@@ -3571,7 +3576,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/DomainCombiner.P \\\n .deps/java/security/DummyKeyPairGenerator.P \\\n .deps/java/security/DummyMessageDigest.P \\\n-.deps/java/security/DummySignature.P \\\n+.deps/java/security/DummySignature.P .deps/java/security/Engine.P \\\n .deps/java/security/GeneralSecurityException.P \\\n .deps/java/security/Guard.P .deps/java/security/GuardedObject.P \\\n .deps/java/security/Identity.P .deps/java/security/IdentityScope.P \\\n@@ -3636,6 +3641,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/interfaces/DSAPrivateKey.P \\\n .deps/java/security/interfaces/DSAPublicKey.P \\\n .deps/java/security/interfaces/RSAKey.P \\\n+.deps/java/security/interfaces/RSAMultiPrimePrivateCrtKey.P \\\n .deps/java/security/interfaces/RSAPrivateCrtKey.P \\\n .deps/java/security/interfaces/RSAPrivateKey.P \\\n .deps/java/security/interfaces/RSAPublicKey.P \\\n@@ -3648,7 +3654,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/spec/InvalidParameterSpecException.P \\\n .deps/java/security/spec/KeySpec.P \\\n .deps/java/security/spec/PKCS8EncodedKeySpec.P \\\n+.deps/java/security/spec/PSSParameterSpec.P \\\n .deps/java/security/spec/RSAKeyGenParameterSpec.P \\\n+.deps/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.P \\\n+.deps/java/security/spec/RSAOtherPrimeInfo.P \\\n .deps/java/security/spec/RSAPrivateCrtKeySpec.P \\\n .deps/java/security/spec/RSAPrivateKeySpec.P \\\n .deps/java/security/spec/RSAPublicKeySpec.P \\"}, {"sha": "b8ad8e27ddc7fb87f6d15b14489b9a25e0dfbb93", "filename": "libjava/java/security/AlgorithmParameterGenerator.java", "status": "modified", "additions": 156, "deletions": 94, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FAlgorithmParameterGenerator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FAlgorithmParameterGenerator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FAlgorithmParameterGenerator.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* AlgorithmParameterGenerator.java --- Algorithm Parameter Generator\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,29 +36,64 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.security.spec.AlgorithmParameterSpec;\n \n /**\n-   AlgorithmParameterGenerator is used to generate \n-   algorithm parameters for specified algorithms.\n-   This class is used to generate the algorithm parameters\n-   for a specific algorithm.\n-\n-   @since JDK 1.2\n-   @author Mark Benvenuto\n+ * <p>The <code>AlgorithmParameterGenerator</code> class is used to generate a\n+ * set of parameters to be used with a certain algorithm. Parameter generators\n+ * are constructed using the <code>getInstance()</code> factory methods (static\n+ * methods that return instances of a given class).</p>\n+ *\n+ * <p>The object that will generate the parameters can be initialized in two\n+ * different ways: in an algorithm-independent manner, or in an\n+ * algorithm-specific manner:</p>\n+ *\n+ * <ul>\n+ *  <li>The algorithm-independent approach uses the fact that all parameter\n+ *  generators share the concept of a <i>\"size\"</i> and a <i>source of\n+ *  randomness</i>. The measure of <i>size</i> is universally shared by all\n+ *  algorithm parameters, though it is interpreted differently for different\n+ *  algorithms. For example, in the case of parameters for the <i>DSA</i>\n+ *  algorithm, <i>\"size\"</i> corresponds to the size of the prime modulus (in\n+ *  bits). When using this approach, algorithm-specific parameter generation\n+ *  values - if any - default to some standard values, unless they can be\n+ *  derived from the specified size.</li>\n+ *  <li>The other approach initializes a parameter generator object using\n+ *  algorithm-specific semantics, which are represented by a set of\n+ *  algorithm-specific parameter generation values. To generate Diffie-Hellman\n+ *  system parameters, for example, the parameter generation values usually\n+ *  consist of the size of the prime modulus and the size of the random\n+ *  exponent, both specified in number of bits.</li>\n+ * <ul>\n+ *\n+ * <p>In case the client does not explicitly initialize the\n+ * <code>AlgorithmParameterGenerator</code> (via a call to an <code>init()</code>\n+ * method), each provider must supply (and document) a default initialization.\n+ * For example, the <b>GNU</b> provider uses a default modulus prime size of\n+ * <code>1024</code> bits for the generation of <i>DSA</i> parameters.\n+ *\n+ * @author Mark Benvenuto\n+ * @since 1.2\n+ * @see AlgorithmParameters\n+ * @see AlgorithmParameterSpec\n  */\n public class AlgorithmParameterGenerator\n {\n+  /** Service name for algorithm parameter generators. */\n+  private static final String ALGORITHM_PARAMETER_GENERATOR =\n+    \"AlgorithmParameterGenerator\";\n+\n   private AlgorithmParameterGeneratorSpi paramGenSpi;\n   private Provider provider;\n   private String algorithm;\n \n   /**\n-     Creates an instance of AlgorithmParameters\n-\n-     @param paramSpi A parameters engine to use\n-     @param provider A provider to use\n-     @param algorithm The algorithm \n+   * Creates an <code>AlgorithmParameterGenerator</code> object.\n+   *\n+   * @param paramGenSpi the delegate.\n+   * @param provider the provider.\n+   * @param algorithm the algorithm.\n    */\n   protected AlgorithmParameterGenerator(AlgorithmParameterGeneratorSpi\n \t\t\t\t\tparamGenSpi, Provider provider,\n@@ -70,158 +105,185 @@ protected AlgorithmParameterGenerator(AlgorithmParameterGeneratorSpi\n   }\n \n   /**\n-     Returns the name of the algorithm used\n-\n-     @return A string with the name of the algorithm\n+   * Returns the standard name of the algorithm this parameter generator is\n+   * associated with.\n+   *\n+   * @return the string name of the algorithm.\n    */\n   public final String getAlgorithm()\n   {\n     return algorithm;\n   }\n \n-  /** \n-     Gets an instance of the AlgorithmParameterGenerator class \n-     which generates algorithm parameters for the specified algorithm. \n-     If the algorithm is not found then, it throws NoSuchAlgorithmException.\n-\n-     @param algorithm the name of algorithm to choose\n-     @return a AlgorithmParameterGenerator repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by providers\n+  /**\n+   * Generates an <code>AlgorithmParameterGenerator</code> object that\n+   * implements the specified digest algorithm. If the default provider package\n+   * provides an implementation of the requested digest algorithm, an instance\n+   * of <code>AlgorithmParameterGenerator</code> containing that implementation\n+   * is returned. If the algorithm is not available in the default package,\n+   * other packages are searched.\n+   *\n+   * @param algorithm the string name of the algorithm this parameter generator\n+   * is associated with.\n+   * @return the new <code>AlgorithmParameterGenerator</code> object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * environment.\n    */\n   public static AlgorithmParameterGenerator getInstance(String algorithm)\n     throws NoSuchAlgorithmException\n   {\n     Provider[] p = Security.getProviders();\n-\n     for (int i = 0; i < p.length; i++)\n-      {\n-\tString classname =\n-\t  p[i].getProperty(\"AlgorithmParameterGenerator.\" + algorithm);\n-\tif (classname != null)\n-\t  return getInstance(classname, algorithm, p[i]);\n-      }\n+      try\n+        {\n+          return getInstance(algorithm, p[i]);\n+        }\n+      catch (NoSuchAlgorithmException ignored) {}\n \n     throw new NoSuchAlgorithmException(algorithm);\n   }\n \n-  /** \n-     Gets an instance of the AlgorithmParameterGenerator class \n-     which generates algorithm parameters for the specified algorithm. \n-     If the algorithm is not found then, it throws NoSuchAlgorithmException.\n-\n-     @param algorithm the name of algorithm to choose\n-     @param provider the name of the provider to find the algorithm in\n-     @return a AlgorithmParameterGenerator repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by the provider\n-     @throws NoSuchProviderException if the provider is not found\n+  /**\n+   * Generates an <code>AlgorithmParameterGenerator</code> object for the\n+   * requested algorithm, as supplied from the specified provider, if such a\n+   * parameter generator is available from the provider.\n+   *\n+   * @param algorithm the string name of the algorithm.\n+   * @param provider the string name of the provider.\n+   * @return the new <code>AlgorithmParameterGenerator</code> object.\n+   * @throws NoSuchAlgorithmException if the <code>algorithm</code> is not\n+   * available from the <code>provider</code>.\n+   * @throws NoSuchProviderException if the <code>provider</code> is not\n+   * available in the environment.\n+   * @throws IllegalArgumentException if the <code>provider</code> name is\n+   * <code>null</code> or empty.\n+   * @see Provider\n    */\n   public static AlgorithmParameterGenerator getInstance(String algorithm,\n \t\t\t\t\t\t\tString provider)\n     throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n+    if (provider == null || provider.length() == 0)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n+\n     Provider p = Security.getProvider(provider);\n     if (p == null)\n       throw new NoSuchProviderException();\n \n-    return getInstance(p.\n-\t\t       getProperty(\"AlgorithmParameterGenerator.\" +\n-\t\t\t\t   algorithm), algorithm, p);\n+    return getInstance(algorithm, p);\n   }\n \n-  private static AlgorithmParameterGenerator getInstance(String classname,\n-\t\t\t\t\t\t\t String algorithm,\n-\t\t\t\t\t\t\t Provider provider)\n+  /**\n+   * Generates an AlgorithmParameterGenerator object for the requested\n+   * algorithm, as supplied from the specified provider, if such a parameter\n+   * generator is available from the provider. Note: the <code>provider</code>\n+   * doesn't have to be registered.\n+   *\n+   * @param algorithm the string name of the algorithm.\n+   * @param provider the provider.\n+   * @return the new AlgorithmParameterGenerator object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available from\n+   * the provider.\n+   * @throws IllegalArgumentException if the provider is null.\n+   * @since 1.4\n+   * @see Provider\n+   */\n+  public static AlgorithmParameterGenerator getInstance(String algorithm,\n+                                                        Provider provider)\n     throws NoSuchAlgorithmException\n   {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n \n     try\n       {\n-\treturn new\n-\t  AlgorithmParameterGenerator((AlgorithmParameterGeneratorSpi) Class.\n-\t\t\t\t      forName(classname).newInstance(),\n-\t\t\t\t      provider, algorithm);\n-      }\n-    catch (ClassNotFoundException cnfe)\n-      {\n-\tthrow new NoSuchAlgorithmException(\"Class not found\");\n-      }\n-    catch (InstantiationException ie)\n-      {\n-\tthrow new NoSuchAlgorithmException(\"Class instantiation failed\");\n-      }\n-    catch (IllegalAccessException iae)\n+\treturn new AlgorithmParameterGenerator(\n+\t  (AlgorithmParameterGeneratorSpi) Engine.getInstance(\n+\t    ALGORITHM_PARAMETER_GENERATOR, algorithm, provider),\n+\t  provider, algorithm);\n+        }\n+    catch (ClassCastException cce)\n       {\n-\tthrow new NoSuchAlgorithmException(\"Illegal Access\");\n+\tthrow new NoSuchAlgorithmException(algorithm);\n       }\n   }\n \n   /**\n-     Gets the provider that the class is from.\n-\n-     @return the provider of this class\n+   * Returns the provider of this algorithm parameter generator object.\n+   *\n+   * @return the provider of this algorithm parameter generator object.\n    */\n   public final Provider getProvider()\n   {\n     return provider;\n   }\n \n   /**\n-     Initializes the Algorithm Parameter Generator with the specified\n-     size. (Since no source of randomness is supplied, a default\n-     one is supplied).\n-\n-     @param size size (in bits) to use\n+   * Initializes this parameter generator for a certain <i>size</i>. To create\n+   * the parameters, the {@link SecureRandom} implementation of the\n+   * highest-priority installed provider is used as the source of randomness.\n+   * (If none of the installed providers supply an implementation of\n+   * {@link SecureRandom}, a system-provided source of randomness is used.)\n+   *\n+   * @param size the size (number of bits).\n    */\n   public final void init(int size)\n   {\n     init(size, new SecureRandom());\n   }\n \n   /**\n-     Initializes the Algorithm Parameter Generator with the specified\n-     size and source of randomness.\n-\n-     @param size size (in bits) to use\n-     @param random source of randomness to use\n+   * Initializes this parameter generator for a certain size and source of\n+   * randomness.\n+   *\n+   * @param size the size (number of bits).\n+   * @param random the source of randomness.\n    */\n   public final void init(int size, SecureRandom random)\n   {\n     paramGenSpi.engineInit(size, random);\n   }\n \n   /**\n-     Initializes the Algorithm Parameter Generator with the specified\n-     AlgorithmParameterSpec. (Since no source of randomness is supplied, \n-     a default one is supplied).\n-\n-     @param genParamSpec the AlgorithmParameterSpec class to use\n+   * Initializes this parameter generator with a set of algorithm-specific\n+   * parameter generation values. To generate the parameters, the {@link\n+   * SecureRandom} implementation of the highest-priority installed provider is\n+   * used as the source of randomness. (If none of the installed providers\n+   * supply an implementation of {@link SecureRandom}, a system-provided source\n+   * of randomness is used.)\n+   *\n+   * @param genParamSpec the set of algorithm-specific parameter generation\n+   * values.\n+   * @throws InvalidAlgorithmParameterException if the given parameter\n+   * generation values are inappropriate for this parameter generator.\n    */\n-  public final void init(AlgorithmParameterSpec genParamSpec) throws\n-    InvalidAlgorithmParameterException\n+  public final void init(AlgorithmParameterSpec genParamSpec)\n+    throws InvalidAlgorithmParameterException\n   {\n     init(genParamSpec, new SecureRandom());\n   }\n \n   /**\n-     Initializes the Algorithm Parameter Generator with the specified\n-     AlgorithmParameterSpec and source of randomness.\n-\n-     @param genParamSpec the AlgorithmParameterSpec class to use\n-     @param random source of randomness to use\n+   * Initializes this parameter generator with a set of algorithm-specific\n+   * parameter generation values.\n+   *\n+   * @param genParamSpec the set of algorithm-specific parameter generation\n+   * values.\n+   * @param random the source of randomness.\n+   * @throws InvalidAlgorithmParameterException if the given parameter\n+   * generation values are inappropriate for this parameter generator.\n    */\n   public final void init(AlgorithmParameterSpec genParamSpec,\n-\t\t\t SecureRandom random) throws\n-    InvalidAlgorithmParameterException\n+                         SecureRandom random)\n+    throws InvalidAlgorithmParameterException\n   {\n     paramGenSpi.engineInit(genParamSpec, random);\n   }\n \n   /**\n-     Generate a new set of AlgorithmParameters.\n-\n-     @returns a new set of algorithm parameters\n+   * Generates the parameters.\n+   *\n+   * @return the new {@link AlgorithmParameters} object.\n    */\n   public final AlgorithmParameters generateParameters()\n   {"}, {"sha": "a7212772ba556eaf28fb552ee655ea9514c0036d", "filename": "libjava/java/security/AlgorithmParameters.java", "status": "modified", "additions": 184, "deletions": 131, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FAlgorithmParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FAlgorithmParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FAlgorithmParameters.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* AlgorithmParameters.java --- Algorithm Parameters Implementation Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,239 +35,292 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.security;\n+\n import java.security.spec.InvalidParameterSpecException;\n import java.security.spec.AlgorithmParameterSpec;\n import java.io.IOException;\n \n /**\n-   AlgorithmParameters is the Algorithm Parameters class which \n-   provides an interface through which to modify parameters for \n-   classes. This class is used to manage the algorithm parameters.\n-\n-   @since JDK 1.2\n-   @author Mark Benvenuto\n+ * <p>This class is used as an opaque representation of cryptographic\n+ * parameters.</p>\n+ *\n+ * <p>An <code>AlgorithmParameters</code> object for managing the parameters\n+ * for a particular algorithm can be obtained by calling one of the\n+ * <code>getInstance()</code> factory methods (static methods that return\n+ * instances of a given class).</p>\n+ *\n+ * <p>There are two ways to request such an implementation: by specifying\n+ * either just an algorithm name, or both an algorithm name and a package\n+ * provider.</p>\n+ *\n+ * <ul>\n+ *    <li>If just an algorithm name is specified, the system will determine if\n+ *    there is an AlgorithmParameters implementation for the algorithm requested\n+ *    available in the environment, and if there is more than one, if there is\n+ *    a preferred one.</li>\n+ *    <li>If both an algorithm name and a package provider are specified, the\n+ *    system will determine if there is an implementation in the package\n+ *    requested, and throw an exception if there is not.</li>\n+ * </ul>\n+ *\n+ * <p>Once an <code>AlgorithmParameters</code> object is returned, it must be\n+ * initialized via a call to <code>init()</code>, using an appropriate\n+ * parameter specification or parameter encoding.</p>\n+ *\n+ * <p>A transparent parameter specification is obtained from an\n+ * <ocde>AlgorithmParameters</code> object via a call to\n+ * <code>getParameterSpec()</code>, and a byte encoding of the parameters is\n+ * obtained via a call to <code>getEncoded()</code>.</p>\n+ *\n+ * @author Mark Benvenuto\n+ * @since 1.2\n+ * @see AlgorithmParameterSpec\n+ * @see java.security.spec.DSAParameterSpec\n+ * @see KeyPairGenerator\n  */\n public class AlgorithmParameters\n {\n+  /** Service name for algorithm parameters. */\n+  private static final String ALGORITHM_PARAMETERS = \"AlgorithmParameters\";\n+\n   private AlgorithmParametersSpi paramSpi;\n   private Provider provider;\n   private String algorithm;\n \n   /**\n-     Creates an instance of AlgorithmParameters\n-\n-     @param paramSpi A parameters engine to use\n-     @param provider A provider to use\n-     @param algorithm The algorithm \n+   * Creates an <code>AlgorithmParameters</code> object.\n+   *\n+   * @param paramSpi the delegate.\n+   * @param provider the provider.\n+   * @param algorithm the algorithm.\n    */\n   protected AlgorithmParameters(AlgorithmParametersSpi paramSpi,\n-\t\t\t\tProvider provider, String algorithm)\n+                                Provider provider, String algorithm)\n   {\n     this.paramSpi = paramSpi;\n     this.provider = provider;\n     this.algorithm = algorithm;\n   }\n \n   /**\n-     Returns the name of the algorithm used\n-\n-     @return A string with the name of the algorithm\n+   * Returns the name of the algorithm associated with this parameter object.\n+   *\n+   * @return the algorithm name.\n    */\n   public final String getAlgorithm()\n   {\n     return algorithm;\n   }\n \n-  /** \n-     Gets an instance of the AlgorithmParameters class representing\n-     the specified algorithm parameters. If the algorithm is not \n-     found then, it throws NoSuchAlgorithmException.\n-\n-     The returned AlgorithmParameters must still be intialized with\n-     init().\n-\n-     @param algorithm the name of algorithm to choose\n-     @return a AlgorithmParameters repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by providers\n+  /**\n+   * <p>Generates a parameter object for the specified algorithm.</p>\n+   *\n+   * <p>If the default provider package provides an implementation of the\n+   * requested algorithm, an instance of <code>AlgorithmParameters</code>\n+   * containing that implementation is returned. If the algorithm is not\n+   * available in the default package, other packages are searched.</p>\n+   *\n+   * <p>The returned parameter object must be initialized via a call to\n+   * <code>init()</code>, using an appropriate parameter specification or\n+   * parameter encoding.</p>\n+   *\n+   * @param algorithm the name of the algorithm requested.\n+   * @return the new parameter object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * environment.\n    */\n-  public static AlgorithmParameters getInstance(String algorithm) throws\n-    NoSuchAlgorithmException\n+  public static AlgorithmParameters getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n   {\n     Provider[] p = Security.getProviders();\n-\n     for (int i = 0; i < p.length; i++)\n-      {\n-\tString classname =\n-\t  p[i].getProperty(\"AlgorithmParameters.\" + algorithm);\n-\tif (classname != null)\n-\t  return getInstance(classname, algorithm, p[i]);\n-      }\n+      try\n+        {\n+          return getInstance(algorithm, p[i]);\n+        }\n+      catch (NoSuchAlgorithmException ignored) {}\n \n     throw new NoSuchAlgorithmException(algorithm);\n   }\n \n-  /** \n-     Gets an instance of the AlgorithmParameters class representing\n-     the specified algorithm parameters from the specified provider. \n-     If the algorithm is not found then, it throws \n-     NoSuchAlgorithmException. If the provider is not found, then \n-     it throws NoSuchProviderException.\n-\n-     The returned AlgorithmParameters must still be intialized with\n-     init().\n-\n-     @param algorithm the name of algorithm to choose\n-     @param provider the name of the provider to find the algorithm in\n-     @return a AlgorithmParameters repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by the provider\n-     @throws NoSuchProviderException if the provider is not found\n+  /**\n+   * <p>Generates a parameter object for the specified algorithm, as supplied\n+   * by the specified provider, if such an algorithm is available from the\n+   * provider.</p>\n+   *\n+   * <p>The returned parameter object must be initialized via a call to\n+   * <code>init()</code>, using an appropriate parameter specification or\n+   * parameter encoding.</p>\n+   *\n+   * @param algorithm the name of the algorithm requested.\n+   * @param provider the name of the provider.\n+   * @return the new parameter object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * package supplied by the requested provider.\n+   * @throws NoSuchProviderException if the provider is not available in the\n+   * environment.\n+   * @throws IllegalArgumentException if the provider name is null or empty.\n+   * @see Provider\n    */\n-  public static AlgorithmParameters getInstance(String algorithm,\n-\t\t\t\t\t\tString provider) throws\n-    NoSuchAlgorithmException, NoSuchProviderException\n+  public static AlgorithmParameters getInstance(String algorithm, String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n+    if (provider == null || provider.length() == 0)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n+    \n     Provider p = Security.getProvider(provider);\n     if (p == null)\n       throw new NoSuchProviderException();\n \n-    return getInstance(p.getProperty(\"AlgorithmParameters.\" + algorithm),\n-\t\t       algorithm, p);\n+    return getInstance(algorithm, p);\n   }\n \n-  private static AlgorithmParameters getInstance(String classname,\n-\t\t\t\t\t\t String algorithm,\n-\t\t\t\t\t\t Provider provider)\n+  /**\n+   * Generates an <code>AlgorithmParameterGenerator</code> object for the\n+   * requested algorithm, as supplied from the specified provider, if such a\n+   * parameter generator is available from the provider. Note: the\n+   * <code>provider</code> doesn't have to be registered.\n+   *\n+   * @param algorithm the string name of the algorithm.\n+   * @param provider the provider.\n+   * @return the new <code>AlgorithmParameterGenerator</code> object.\n+   * @throws NoSuchAlgorithmException if the <code>algorithm</code> is not\n+   * available from the <code>provider</code>.\n+   * @throws IllegalArgumentException if the <code>provider</code> is\n+   * <code>null</code>.\n+   * @since 1.4\n+   */\n+  public static AlgorithmParameters getInstance(String algorithm,\n+                                                Provider provider)\n     throws NoSuchAlgorithmException\n   {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n \n     try\n       {\n-\treturn new AlgorithmParameters((AlgorithmParametersSpi) Class.\n-\t\t\t\t       forName(classname).newInstance(),\n-\t\t\t\t       provider, algorithm);\n-      }\n-    catch (ClassNotFoundException cnfe)\n-      {\n-\tthrow new NoSuchAlgorithmException(\"Class not found\");\n-      }\n-    catch (InstantiationException ie)\n-      {\n-\tthrow new NoSuchAlgorithmException(\"Class instantiation failed\");\n+\treturn new AlgorithmParameters((AlgorithmParametersSpi)\n+\t  Engine.getInstance(ALGORITHM_PARAMETERS, algorithm, provider),\n+\t  provider, algorithm);\n       }\n-    catch (IllegalAccessException iae)\n+    catch (ClassCastException cce)\n       {\n-\tthrow new NoSuchAlgorithmException(\"Illegal Access\");\n+\tthrow new NoSuchAlgorithmException(algorithm);\n       }\n   }\n \n   /**\n-     Gets the provider that the class is from.\n-\n-     @return the provider of this class\n+   * Returns the provider of this parameter object.\n+   *\n+   * @return the provider of this parameter object.\n    */\n   public final Provider getProvider()\n   {\n     return provider;\n   }\n \n   /**\n-     Initializes the engine with the specified \n-     AlgorithmParameterSpec class.\n-\n-     @param paramSpec A AlgorithmParameterSpec to initialize with\n-\n-     @throws InvalidParameterSpecException For an inapporiate ParameterSpec class\n+   * Initializes this parameter object using the parameters specified in\n+   * <code>paramSpec</code>.\n+   *\n+   * @param paramSpec the parameter specification.\n+   * @throws InvalidParameterSpecException if the given parameter specification\n+   * is inappropriate for the initialization of this parameter object, or if\n+   * this parameter object has already been initialized.\n    */\n-  public final void init(AlgorithmParameterSpec paramSpec) throws\n-    InvalidParameterSpecException\n+  public final void init(AlgorithmParameterSpec paramSpec)\n+    throws InvalidParameterSpecException\n   {\n     paramSpi.engineInit(paramSpec);\n   }\n \n   /**\n-     Initializes the engine with the specified \n-     parameters stored in the byte array and decodes them\n-     according to the ASN.1 specification. If the ASN.1\n-     specification exists then it succeeds or else it throws\n-     IOException.\n-\n-     @param params Parameters to initialize with\n-\n-     @throws IOException Decoding Error\n+   * Imports the specified parameters and decodes them according to the primary\n+   * decoding format for parameters. The primary decoding format for parameters\n+   * is ASN.1, if an ASN.1 specification for this type of parameters exists.\n+   *\n+   * @param params the encoded parameters.\n+   * @throws IOException on decoding errors, or if this parameter object has\n+   * already been initialized.\n    */\n   public final void init(byte[]params) throws IOException\n   {\n     paramSpi.engineInit(params);\n   }\n \n   /**\n-     Initializes the engine with the specified \n-     parameters stored in the byte array and decodes them\n-     according to the specified decoding specification. \n-     If format is null, then it is decoded using the ASN.1 \n-     specification if it exists or else it throws\n-     IOException.\n-\n-     @param params Parameters to initialize with\n-     @param format Name of decoding format to use\n-\n-     @throws IOException Decoding Error\n+   * Imports the parameters from params and decodes them according to the\n+   * specified decoding scheme. If <code>format</code> is <code>null</code>,\n+   * the primary decoding format for parameters is used. The primary decoding\n+   * format is ASN.1, if an ASN.1 specification for these parameters exists.\n+   *\n+   * @param params the encoded parameters.\n+   * @param format the name of the decoding scheme.\n+   * @throws IOException on decoding errors, or if this parameter object has\n+   * already been initialized.\n    */\n   public final void init(byte[]params, String format) throws IOException\n   {\n     paramSpi.engineInit(params, format);\n   }\n \n   /**\n-     Returns a specification of this AlgorithmParameters object.\n-     paramSpec identifies the class to return the AlgortihmParameters\n-     in. \n-\n-     @param paramSpec Class to return AlgorithmParameters in\n-\n-     @return the parameter specification\n-\n-     @throws InvalidParameterSpecException if the paramSpec is an invalid parameter class\n+   * Returns a (transparent) specification of this parameter object.\n+   * <code>paramSpec</code> identifies the specification class in which the\n+   * parameters should be returned. It could, for example, be\n+   * <code>DSAParameterSpec.class</code>, to indicate that the parameters should\n+   * be returned in an instance of the {@link java.security.spec.DSAParameterSpec}\n+   * class.\n+   *\n+   * @param paramSpec the specification class in which the parameters should be\n+   * returned.\n+   * @return the parameter specification.\n+   * @throws InvalidParameterSpecException if the requested parameter\n+   * specification is inappropriate for this parameter object, or if this\n+   * parameter object has not been initialized.\n    */\n-  public final AlgorithmParameterSpec getParameterSpec(Class paramSpec) throws\n-    InvalidParameterSpecException\n+  public final AlgorithmParameterSpec getParameterSpec(Class paramSpec)\n+    throws InvalidParameterSpecException\n   {\n     return paramSpi.engineGetParameterSpec(paramSpec);\n   }\n \n   /**\n-     Returns the parameters in the default encoding format. \n-     The primary encoding format is ASN.1 format if it exists\n-     for the specified type.\n-\n-     @return byte array representing the parameters\n+   * Returns the parameters in their primary encoding format. The primary\n+   * encoding format for parameters is ASN.1, if an ASN.1 specification for\n+   * this type of parameters exists.\n+   *\n+   * @return the parameters encoded using their primary encoding format.\n+   * @throws IOException on encoding errors, or if this parameter object has not\n+   * been initialized.\n    */\n   public final byte[] getEncoded() throws IOException\n   {\n     return paramSpi.engineGetEncoded();\n   }\n \n   /**\n-     Returns the parameters in the specified encoding format. \n-     If <code>format</code> is <code>null</code> then the \n-     primary encoding format is used, the ASN.1 format, \n-     if it exists for the specified type.\n-\n-     @return byte array representing the parameters\n+   * Returns the parameters encoded in the specified scheme. If format is\n+   * <code>null</code>, the primary encoding format for parameters is used. The\n+   * primary encoding format is ASN.1, if an ASN.1 specification for these\n+   * parameters exists.\n+   *\n+   * @param format the name of the encoding format.\n+   * @return the parameters encoded using the specified encoding scheme.\n+   * @throws IOException on encoding errors, or if this parameter object has\n+   * not been initialized.\n    */\n   public final byte[] getEncoded(String format) throws IOException\n   {\n     return paramSpi.engineGetEncoded(format);\n   }\n \n   /**\n-     Returns a string representation of the encoding format\n-\n-     @return a string containing the string representation\n+   * Returns a formatted string describing the parameters.\n+   *\n+   * @return a formatted string describing the parameters, or <code>null</code>\n+   * if this parameter object has not been initialized.\n    */\n   public final String toString()\n   {"}, {"sha": "88ff5364a3f9916c0edc9e238cab32eff91512fe", "filename": "libjava/java/security/Engine.java", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FEngine.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FEngine.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FEngine.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -0,0 +1,152 @@\n+/* Engine -- generic getInstance method.\n+   Copyright (C) 2003  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.security;\n+\n+/**\n+ * Generic implementation of the getInstance methods in the various\n+ * engine classes in java.security.\n+ * <p>\n+ * These classes ({@link java.security.Signature} for example) can be\n+ * thought of as the \"chrome, upholstery, and steering wheel\", and the SPI\n+ * (service provider interface, e.g. {@link java.security.SignatureSpi})\n+ * classes can be thought of as the \"engine\" -- providing the actual\n+ * functionality of whatever cryptographic algorithm the instance\n+ * represents.\n+ *\n+ * @see Provider\n+ * @author Casey Marshall \n+ */\n+final class Engine\n+{\n+\n+  // Constants.\n+  // ------------------------------------------------------------------------\n+\n+  /** Prefix for aliases. */\n+  private static final String ALG_ALIAS = \"Alg.Alias.\";\n+\n+  /** Maximum number of aliases to try. */\n+  private static final int MAX_ALIASES = 5;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /** This class cannot be instantiated. */\n+  private Engine() { }\n+\n+  // Class method.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the implementation for <i>algorithm</i> for service\n+   * <i>service</i> from <i>provider</i>. The service is e.g.\n+   * \"Signature\", and the algorithm \"DSA\".\n+   *\n+   * @param service   The service name.\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider  The provider to get the implementation from.\n+   * @return The engine class for the specified algorithm; the object\n+   *         returned is typically a subclass of the SPI class for that\n+   *         service, but callers should check that this is so.\n+   * @throws NoSuchAlgorithmException If the implementation cannot be\n+   *         found or cannot be instantiated.\n+   * @throws IllegalArgumentException If any of the three arguments are null.\n+   */\n+  static Object\n+  getInstance(String service, String algorithm, Provider provider)\n+  throws NoSuchAlgorithmException\n+  {\n+    if (service == null || algorithm == null || provider == null)\n+      throw new IllegalArgumentException();\n+\n+    // If there is no property \"service.algorithm\"\n+    if (provider.getProperty(service + \".\" + algorithm) == null)\n+      {\n+        // Iterate through aliases, until we find the class name or resolve\n+        // too many aliases.\n+        String alias = null;\n+        int count = 0;\n+        while ((alias = provider.getProperty(\n+                ALG_ALIAS + service + \".\" + algorithm)) != null)\n+          {\n+            if (algorithm.equals(alias))  // Refers to itself!\n+              break;\n+            algorithm = alias;\n+            if (count++ > MAX_ALIASES)\n+              throw new NoSuchAlgorithmException(\"too many aliases\");\n+          }\n+        if (provider.getProperty(service + \".\" + algorithm) == null)\n+          throw new NoSuchAlgorithmException(algorithm);\n+      }\n+\n+    // Find and instantiate the implementation.\n+    Class clazz = null;\n+    ClassLoader loader = provider.getClass().getClassLoader();\n+    String error = algorithm;\n+    try\n+      {\n+        if (loader != null)\n+          clazz = loader.loadClass(provider.getProperty(service+\".\"+algorithm));\n+        else\n+          clazz = Class.forName(provider.getProperty(service+\".\"+algorithm));\n+        return clazz.newInstance();\n+      }\n+    catch (ClassNotFoundException cnfe)\n+      {\n+        error = \"class not found: \" + algorithm;\n+      }\n+    catch (IllegalAccessException iae)\n+      {\n+        error = \"illegal access: \" + iae.getMessage();\n+      }\n+    catch (InstantiationException ie)\n+      {\n+        error = \"instantiation exception: \" + ie.getMessage();\n+      }\n+    catch (ExceptionInInitializerError eiie)\n+      {\n+        error = \"exception in initializer: \" + eiie.getMessage();\n+      }\n+    catch (SecurityException se)\n+      {\n+        error = \"security exception: \" + se.getMessage();\n+      }\n+\n+    throw new NoSuchAlgorithmException(error);\n+  }\n+}"}, {"sha": "d44e96cc213b6d4c061847612ccccb5c990864ab", "filename": "libjava/java/security/Identity.java", "status": "modified", "additions": 169, "deletions": 138, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FIdentity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FIdentity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FIdentity.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,7 +1,7 @@\n /* Identity.java --- Identity Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, Free Software Foundation, Inc.\n \n-   This file is part of GNU Classpath.\n+This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -36,31 +36,36 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.io.Serializable;\n import java.util.Vector;\n \n /**\n-   The Identity class is used to repsent people and companies that \n-   can be authenticated using public key encryption. The identities\n-   can also be abstract objects such as smart cards.\n-\n-   Identity object store a name and public key for each identity.\n-   The names cannot be changed and the identities can be scoped.\n-   Each identity (name and public key) within a scope is unique \n-   to that scope.\n-\n-   Each identity has a set of ceritificates which all specify the \n-   same public key but not necessarily the same name.\n-\n-   The Identity class can be subclassed to allow additional \n-   information to be attached to it.\n-\n-   @since JDK 1.1\n-\n-   @deprecated Use java.security.KeyStore, the java.security.cert \n-   package, and java.security.Principal. \n-\n-   @author Mark Benvenuto       \n+ * <p>This class represents identities: real-world objects such as people,\n+ * companies or organizations whose identities can be authenticated using their\n+ * public keys. Identities may also be more abstract (or concrete) constructs,\n+ * such as daemon threads or smart cards.</p>\n+ *\n+ * <p>All Identity objects have a <i>name</i> and a <i>public key</i>. Names\n+ * are immutable. <i>Identities</i> may also be <b>scoped</b>. That is, if an\n+ * <i>Identity</i> is specified to have a particular <i>scope</i>, then the\n+ * <i>name</i> and <i>public key</i> of the <i>Identity</i> are unique within\n+ * that <i>scope</i>.</p>\n+ *\n+ * <p>An <i>Identity</i> also has a <i>set of certificates</i> (all certifying\n+ * its own <i>public key</i>). The <i>Principal</i> names specified in these\n+ * certificates need not be the same, only the key.</p>\n+ *\n+ * <p>An <i>Identity</i> can be subclassed, to include postal and email\n+ * addresses, telephone numbers, images of faces and logos, and so on.</p>\n+ *\n+ * @author Mark Benvenuto\n+ * @see IdentityScope\n+ * @see Signer\n+ * @see Principal\n+ * @deprecated This class is no longer used. Its functionality has been replaced\n+ * by <code>java.security.KeyStore</code>, the <code>java.security.cert</code>\n+ * package, and <code>java.security.Principal</code>.\n  */\n public abstract class Identity implements Principal, Serializable\n {\n@@ -72,22 +77,18 @@ public abstract class Identity implements Principal, Serializable\n   private String info;\n   private Vector certificates;\n \n-  /**\n-     Creates a new instance of Identity from Serialized Data\n-   */\n+  /** Constructor for serialization only. */\n   protected Identity()\n   {\n   }\n \n   /**\n-     Creates a new instance of Identity with the specified name \n-     and IdentityScope.\n-\n-     @param name the name to use\n-     @param scope the scope to use\n-\n-     @throws KeyManagementException if the identity is already \n-     present\n+   * Constructs an identity with the specified name and scope.\n+   *\n+   * @param name the identity name.\n+   * @param scope the scope of the identity.\n+   * @throws KeyManagementException if there is already an identity with the\n+   * same name in the scope.\n    */\n   public Identity(String name, IdentityScope scope)\n     throws KeyManagementException\n@@ -97,10 +98,9 @@ public Identity(String name, IdentityScope scope)\n   }\n \n   /**\n-     Creates a new instance of Identity with the specified name \n-     and no scope.\n-\n-     @param name the name to use\n+   * Constructs an identity with the specified name and no scope.\n+   *\n+   * @param name the identity name.\n    */\n   public Identity(String name)\n   {\n@@ -109,48 +109,52 @@ public Identity(String name)\n   }\n \n   /**\n-     Gets the name for this Identity.\n-\n-     @return the name\n+   * Returns this identity's name.\n+   *\n+   * @return the name of this identity.\n    */\n   public final String getName()\n   {\n     return name;\n   }\n \n   /**\n-     Gets the scope for this Identity.\n-\n-     @return the scope\n+   * Returns this identity's scope.\n+   *\n+   * @return the scope of this identity.\n    */\n   public final IdentityScope getScope()\n   {\n     return scope;\n   }\n \n   /**\n-     Gets the public key for this identity.\n-\n-     @return the public key\n+   * Returns this identity's public key.\n+   *\n+   * @return the public key for this identity.\n+   * @see #setPublicKey(java.security.PublicKey)\n    */\n   public PublicKey getPublicKey()\n   {\n     return publicKey;\n   }\n \n   /**\n-     Sets the public key for this identity.\n-     The old key and all certificates are removed.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"setIdentityPublicKey\".\n-\n-     @param key the public key to use\n-\n-     @throws KeyManagementException if this public key is used by \n-     another identity in the current scope.\n-     @throws SecurityException - if the security manager denies \n-     access to \"setIdentityPublicKey\"\n+   * <p>Sets this identity's public key. The old key and all of this identity's\n+   * certificates are removed by this operation.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"setIdentityPublicKey\"</code> as its\n+   * argument to see if it's ok to set the public key.</p>\n+   *\n+   * @param key the public key for this identity.\n+   * @throws KeyManagementException if another identity in the identity's scope\n+   * has the same public key, or if another exception occurs.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()<code> method doesn't allow setting the public\n+   * key.\n+   * @see #getPublicKey()\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public void setPublicKey(PublicKey key) throws KeyManagementException\n   {\n@@ -162,15 +166,18 @@ public void setPublicKey(PublicKey key) throws KeyManagementException\n   }\n \n   /**\n-     Sets the general information string.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"setIdentityInfo\".\n-\n-     @param info the general information string.\n-\n-     @throws SecurityException - if the security manager denies \n-     access to \"setIdentityInfo\"\n+   * <p>Specifies a general information string for this identity.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"setIdentityInfo\"</code> as its\n+   * argument to see if it's ok to specify the information string.</p>\n+   *\n+   * @param info the information string.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()</code> method doesn't allow setting the\n+   * information string.\n+   * @see #getInfo()\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public void setInfo(String info)\n   {\n@@ -182,60 +189,65 @@ public void setInfo(String info)\n   }\n \n   /**\n-     Gets the general information string.\n-\n-     @return the string\n+   * Returns general information previously specified for this identity.\n+   *\n+   * @return general information about this identity.\n+   * @see #setInfo(String)\n    */\n   public String getInfo()\n   {\n     return info;\n   }\n \n   /**\n-     Adds a certificate to the list of ceritificates for this \n-     identity. The public key in this certificate must match the \n-     existing public key if it exists.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"addIdentityCertificate\".\n-\n-     @param certificate the certificate to add\n-\n-     @throws KeyManagementException if the certificate is invalid\n-     or the public key conflicts\n-     @throws SecurityException - if the security manager denies \n-     access to \"addIdentityCertificate\"\n+   * <p>Adds a certificate for this identity. If the identity has a public key,\n+   * the public key in the certificate must be the same, and if the identity\n+   * does not have a public key, the identity's public key is set to be that\n+   * specified in the certificate.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"addIdentityCertificate\"</code> as its\n+   * argument to see if it's ok to add a certificate.</p>\n+   *\n+   * @param certificate the certificate to be added.\n+   * @throws KeyManagementException if the certificate is not valid, if the\n+   * public key in the certificate being added conflicts with this identity's\n+   * public key, or if another exception occurs.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()</code> method doesn't allow adding a\n+   * certificate.\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n-  public void addCertificate(java.security.Certificate certificate)\n+  public void addCertificate(Certificate certificate)\n     throws KeyManagementException\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkSecurityAccess(\"addIdentityCertificate\");\n \n-    //Check public key of this certificate against the first one \n-    //in the vector\n+    // Check public key of this certificate against the first one in the vector\n     if (certificates.size() > 0)\n       {\n-\tif (((Certificate) certificates.firstElement()).getPublicKey() !=\n-\t    publicKey)\n+\tif (((Certificate) certificates.firstElement()).getPublicKey() != publicKey)\n \t  throw new KeyManagementException(\"Public key does not match\");\n       }\n     certificates.addElement(certificate);\n   }\n \n   /**\n-     Removes a certificate from the list of ceritificates for this \n-     identity. \n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"removeIdentityCertificate\".\n-\n-     @param certificate the certificate to add\n-\n-     @throws KeyManagementException if the certificate is invalid\n-     @throws SecurityException - if the security manager denies \n-     access to \"removeIdentityCertificate\"\n+   * <p>Removes a certificate from this identity.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"removeIdentityCertificate\"</code> as\n+   * its argument to see if it's ok to remove a certificate.</p>\n+   *\n+   * @param certificate the certificate to be removed.\n+   * @throws KeyManagementException if the certificate is missing, or if\n+   * another exception occurs.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()</code> method doesn't allow removing a\n+   * certificate.\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public void removeCertificate(Certificate certificate)\n     throws KeyManagementException\n@@ -251,26 +263,32 @@ public void removeCertificate(Certificate certificate)\n   }\n \n   /**\n-     Returns an array of certificates for this identity.\n-\n-     @returns array of certificates\n+   * Returns a copy of all the certificates for this identity.\n+   *\n+   * @return a copy of all the certificates for this identity.\n    */\n   public Certificate[] certificates()\n   {\n     Certificate certs[] = new Certificate[certificates.size()];\n     int max = certificates.size();\n     for (int i = 0; i < max; i++)\n       certs[i] = (Certificate) certificates.elementAt(i);\n+\n     return certs;\n   }\n \n   /**\n-     Checks for equality between this Identity and the specified \n-     object. If first checks if they are the same object, then \n-     if the name and scope matches and returns true if successful.\n-     If these tests fail, identityEquals is called.\n-\n-     @return true if they are equal, false otherwise\n+   * Tests for equality between the specified object and this identity. This\n+   * first tests to see if the entities actually refer to the same object, in\n+   * which case it returns <code>true</code>. Next, it checks to see if the\n+   * entities have the same <i>name</i> and the same <i>scope</i>. If they do,\n+   * the method returns <code>true</code>. Otherwise, it calls\n+   * <code>identityEquals()</code>, which subclasses should override.\n+   *\n+   * @param identity the object to test for equality with this identity.\n+   * @return <code>true</code> if the objects are considered equal, <code>false\n+   * </code>otherwise.\n+   * @see #identityEquals(Identity)\n    */\n   public final boolean equals(Object identity)\n   {\n@@ -289,11 +307,15 @@ public final boolean equals(Object identity)\n   }\n \n   /**\n-     Checks for equality between this Identity and the specified \n-     object. A subclass should override this method. The default \n-     behavior is to return true if the public key and names match.\n-\n-     @return true if they are equal, false otherwise\n+   * Tests for equality between the specified <code>identity</code> and this\n+   * <i>identity</i>. This method should be overriden by subclasses to test for\n+   * equality. The default behavior is to return <code>true</code> if the names\n+   * and public keys are equal.\n+   *\n+   * @param identity the identity to test for equality with this identity.\n+   * @return <code>true</code> if the identities are considered equal,\n+   * <code>false</code> otherwise.\n+   * @see #equals(Object)\n    */\n   protected boolean identityEquals(Identity identity)\n   {\n@@ -302,15 +324,19 @@ protected boolean identityEquals(Identity identity)\n   }\n \n   /**\n-     Returns a string representing this Identity.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"printIdentity\".\n-\n-     @returns a string representing this Identity.\n-\n-     @throws SecurityException - if the security manager denies \n-     access to \"printIdentity\"\n+   * <p>Returns a short string describing this identity, telling its name and\n+   * its scope (if any).</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"printIdentity\"</code> as its argument\n+   * to see if it's ok to return the string.</p>\n+   *\n+   * @return information about this identity, such as its name and the name of\n+   * its scope (if any).\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()</code> method doesn't allow returning a string\n+   * describing this identity.\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public String toString()\n   {\n@@ -323,18 +349,23 @@ public String toString()\n   }\n \n   /**\n-     Returns a detailed string representing this Identity.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"printIdentity\".\n-\n-     @param detailed indicates whether or not to provide detailed \n-     information\n-\n-     @returns a string representing this Identity.\n-\n-     @throws SecurityException - if the security manager denies \n-     access to \"printIdentity\"\n+   * <p>Returns a string representation of this identity, with optionally more\n+   * details than that provided by the <code>toString()</code> method without\n+   * any arguments.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"printIdentity\"</code> as its argument\n+   * to see if it's ok to return the string.</p>\n+   *\n+   * @param detailed whether or not to provide detailed information.\n+   * @return information about this identity. If detailed is <code>true</code>,\n+   * then this method returns more information than that provided by the\n+   * <code>toString()</code> method without any arguments.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()</code> method doesn't allow returning a string\n+   * describing this identity.\n+   * @see #toString()\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public String toString(boolean detailed)\n   {\n@@ -355,9 +386,9 @@ public String toString(boolean detailed)\n   }\n \n   /**\n-     Gets the hashcode for this Identity.\n-\n-     @returns the hashcode\n+   * Returns a hashcode for this identity.\n+   *\n+   * @return a hashcode for this identity.\n    */\n   public int hashCode()\n   {"}, {"sha": "200b3c6867a496c8dcc4f7ec366790efd85a5e1e", "filename": "libjava/java/security/IdentityScope.java", "status": "modified", "additions": 98, "deletions": 88, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FIdentityScope.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FIdentityScope.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FIdentityScope.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,7 +1,7 @@\n /* IdentityScope.java --- IdentityScope Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, Free Software Foundation, Inc.\n \n-   This file is part of GNU Classpath.\n+This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -36,59 +36,69 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.util.Enumeration;\n \n /**\n-   IdentityScope represents a scope of an identity. IdentityScope \n-   is also an Identity and can have a name and scope along with \n-   the other qualitites identities posses.\n-\n-   An IdentityScope contains other Identity objects. All Identity \n-   objects are manipulated in the scope the same way. The scope \n-   is suppose to apply different scope to different type of \n-   Identities.\n-\n-   No identity within the same scope can have the same public key.\n-\n-   @since JDK 1.1\n-\n-   @deprecated Use java.security.KeyStore, the java.security.cert \n-   package, and java.security.Principal. \n-\n-   @author Mark Benvenuto       \n+ * <p>This class represents a scope for identities. It is an Identity itself,\n+ * and therefore has a name and can have a scope. It can also optionally have a\n+ * public key and associated certificates.</p>\n+ *\n+ * <p>An <code>IdentityScope</code> can contain {@link Identity} objects of all\n+ * kinds, including {@link Signer}s. All types of <code>Identity</code> objects\n+ * can be retrieved, added, and removed using the same methods. Note that it is\n+ * possible, and in fact expected, that different types of identity scopes will\n+ * apply different policies for their various operations on the various types of\n+ * Identities.</p>\n+ *\n+ * <p>There is a one-to-one mapping between keys and identities, and there can\n+ * only be one copy of one key per scope. For example, suppose Acme Software,\n+ * Inc is a software publisher known to a user. Suppose it is an <i>Identity</i>,\n+ * that is, it has a public key, and a set of associated certificates. It is\n+ * named in the scope using the name \"Acme Software\". No other named <i>Identity\n+ * </i> in the scope has the same public key. Of course, none has the same name\n+ * as well.</p>\n+ *\n+ * @author Mark Benvenuto\n+ * @see Identity\n+ * @see Signer\n+ * @see Principal\n+ * @see Key\n+ * @deprecated This class is no longer used. Its functionality has been replaced\n+ * by <code>java.security.KeyStore</code>, the <code>java.security.cert</code>\n+ * package, and <code>java.security.Principal</code>.\n  */\n public abstract class IdentityScope extends Identity\n {\n+  static final long serialVersionUID = -2337346281189773310L;\n   private static IdentityScope systemScope = null;\n \n   /**\n-     Creates a new instance of IdentityScope from Serialized Data\n+   * This constructor is used for serialization only and should not be used by\n+   * subclasses.\n    */\n   protected IdentityScope()\n   {\n     super();\n   }\n \n   /**\n-     Creates a new instance of IdentityScope with the specified name \n-     and no scope.\n-\n-     @param name the name to use\n+   * Constructs a new identity scope with the specified name.\n+   *\n+   * @param name the scope name.\n    */\n   public IdentityScope(String name)\n   {\n     super(name);\n   }\n \n   /**\n-     Creates a new instance of IdentityScope with the specified name \n-     and IdentityScope.\n-\n-     @param name the name to use\n-     @param scope the scope to use\n-\n-     @throws KeyManagementException if the identity scope is already \n-     present\n+   * Constructs a new identity scope with the specified name and scope.\n+   *\n+   * @param name the scope name.\n+   * @param scope the scope for the new identity scope.\n+   * @throws KeyManagementException if there is already an identity with the\n+   * same name in the scope.\n    */\n   public IdentityScope(String name, IdentityScope scope)\n     throws KeyManagementException\n@@ -97,7 +107,10 @@ public IdentityScope(String name, IdentityScope scope)\n   }\n \n   /**\n-     Gets the system's Scope.\n+   * Returns the system's identity scope.\n+   *\n+   * @return the system's identity scope.\n+   * @see #setSystemScope(IdentityScope)\n    */\n   public static IdentityScope getSystemScope()\n   {\n@@ -110,15 +123,18 @@ public static IdentityScope getSystemScope()\n   }\n \n   /**\n-     Sets the scope of the system.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"setSystemScope\".\n-\n-     @param scope the new sustem scope\n-\n-     @throws SecurityException - if the security manager denies \n-     access to \"setSystemScope\"\n+   * <p>Sets the system's identity scope.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"setSystemScope\"</code> as its argument\n+   * to see if it's ok to set the identity scope.</p>\n+   *\n+   * @param scope the scope to set.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()<code> method doesn't allow setting the\n+   * identity scope.\n+   * @see #getSystemScope()\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   protected static void setSystemScope(IdentityScope scope)\n   {\n@@ -130,87 +146,81 @@ protected static void setSystemScope(IdentityScope scope)\n   }\n \n   /**\n-     Gets the number of entries within this IdentityScope.\n-\n-     @returns the number of entries\n+   * Returns the number of identities within this identity scope.\n+   *\n+   * @return the number of identities within this identity scope.\n    */\n   public abstract int size();\n \n   /**\n-     Gets the specified Identity within this scope\n-     by specified name.\n-\n-     @param name name of Identity to get\n-\n-     @returns an identity representing the name or null if it \n-     cannot be found\n+   * Returns the identity in this scope with the specified name (if any).\n+   *\n+   * @param name the name of the identity to be retrieved.\n+   * @return the identity named name, or <code>null</code> if there are no\n+   * identities named name in this scope.\n    */\n   public abstract Identity getIdentity(String name);\n \n   /**\n-     Gets the specified Identity within this scope\n-     by the specified Principal.\n-\n-     @param principal The Principal of the Identity to get\n-\n-     @returns an identity representing the principal or null if it \n-     cannot be found\n+   * Retrieves the identity whose name is the same as that of the specified\n+   * principal. (Note: <code>Identity</code> implements <code>Principal</code>.)\n+   *\n+   * @param principal the principal corresponding to the identity to be\n+   * retrieved.\n+   * @return the identity whose name is the same as that of the principal, or\n+   * <code>null</code> if there are no identities of the same name in this scope.\n    */\n   public Identity getIdentity(Principal principal)\n   {\n     return getIdentity(principal.getName());\n   }\n \n   /**\n-     Gets the specified Identity within this scope\n-     by the specified public key.\n-\n-     @param key the PublicKey of the Identity to get\n-\n-     @returns an identity representing the public key or null if it \n-     cannot be found\n+   * Retrieves the identity with the specified public key.\n+   *\n+   * @param key the public key for the identity to be returned.\n+   * @return the identity with the given key, or <code>null</code> if there are\n+   * no identities in this scope with that key.\n    */\n   public abstract Identity getIdentity(PublicKey key);\n \n   /**\n-     Adds an identity to his scope.\n-\n-     @param identity the identity to add\n-\n-     @throws KeyManagementException if it is an invalid identity,\n-     an identity with the same key exists, or another error\n-     occurs.\n+   * Adds an identity to this identity scope.\n+   *\n+   * @param identity the identity to be added.\n+   * @throws KeyManagementException if the identity is not valid, a name\n+   * conflict occurs, another identity has the same public key as the identity\n+   * being added, or another exception occurs.\n    */\n   public abstract void addIdentity(Identity identity)\n     throws KeyManagementException;\n \n   /**\n-     Removes an identity to his scope.\n-\n-     @param identity the identity to remove\n-\n-     @throws KeyManagementException if it is a missing identity, \n-     or another error occurs.\n+   * Removes an identity from this identity scope.\n+   *\n+   * @param identity the identity to be removed.\n+   * @throws KeyManagementException if the identity is missing, or another\n+   * exception occurs.\n    */\n   public abstract void removeIdentity(Identity identity)\n     throws KeyManagementException;\n \n   /**\n-     Returns an Enumeration of identities.\n-\n-     @returns an enumeration of the identities.\n+   * Returns an enumeration of all identities in this identity scope.\n+   *\n+   * @return an enumeration of all identities in this identity scope.\n    */\n   public abstract Enumeration identities();\n \n   /**\n-     Returns a string representing this IdentityScope.\n-     It includes the name, the scope name, and number of identities.\n-\n-     @returns a string representing this IdentityScope.\n+   * Returns a string representation of this identity scope, including its name,\n+   * its scope name, and the number of identities in this identity scope.\n+   *\n+   * @return a string representation of this identity scope.\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public String toString()\n   {\n-    return (super.getName() + \" \" + super.getScope().getName()\n-\t    + \" \" + size());\n+    return (super.getName() + \" \" + super.getScope().getName() + \" \" + size());\n   }\n }"}, {"sha": "918bf3d6da93778875930ddde85aefc8c36a69a7", "filename": "libjava/java/security/KeyFactory.java", "status": "modified", "additions": 159, "deletions": 114, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FKeyFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FKeyFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyFactory.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* KeyFactory.java --- Key Factory Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,37 +36,67 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.security.spec.KeySpec;\n import java.security.spec.InvalidKeySpecException;\n+import java.security.NoSuchAlgorithmException;\n \n /**\n-   Key factories are used to convert keys (opaque cryptographic \n-   keys of type Key) into key specifications (transparent \n-   representations of the underlying key material).\n-\n-   Key factories are bi-directional. They allow a key class \n-   to be converted into a key specification (key material) and\n-   back again.\n-\n-   For example DSA public keys can be specified as \n-   DSAPublicKeySpec or X509EncodedKeySpec. The key factory\n-   translate these key specifications. \n-\n-   @since JDK 1.2\n+ * <p>Key factories are used to convert keys (opaque cryptographic keys of type\n+ * {@link Key}) into key specifications (transparent representations of the\n+ * underlying key material), and vice versa.</p>\n+ *\n+ * <p>Key factories are bi-directional. That is, they allow you to build an\n+ * opaque key object from a given key specification (key material), or to\n+ * retrieve the underlying key material of a key object in a suitable format.</p>\n+ *\n+ * <p>Multiple compatible key specifications may exist for the same key. For\n+ * example, a <i>DSA</i> public key may be specified using {@link\n+ * java.security.spec.DSAPublicKeySpec} or {@link\n+ * java.security.spec.X509EncodedKeySpec}. A key factory can be used to\n+ * translate between compatible key specifications.</p>\n+ *\n+ * <p>The following is an example of how to use a key factory in order to\n+ * instantiate a <i>DSA</i> public key from its encoding. Assume Alice has\n+ * received a digital signature from Bob. Bob also sent her his public key (in\n+ * encoded format) to verify his signature. Alice then performs the following\n+ * actions:\n+ *\n+ * <pre>\n+ *  X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(bobEncodedPubKey);\n+ *  KeyFactory keyFactory = KeyFactory.getInstance(\"DSA\");\n+ *  PublicKey bobPubKey = keyFactory.generatePublic(bobPubKeySpec);\n+ *  Signature sig = Signature.getInstance(\"DSA\");\n+ *  sig.initVerify(bobPubKey);\n+ *  sig.update(data);\n+ *  sig.verify(signature);\n+ * </pre>\n+ *\n+ * @since 1.2\n+ * @see Key\n+ * @see PublicKey\n+ * @see PrivateKey\n+ * @see KeySpec\n+ * @see java.security.spec.DSAPublicKeySpec\n+ * @see java.security.spec.X509EncodedKeySpec\n    @author Mark Benvenuto\n  */\n public class KeyFactory\n {\n+  /** The service name for key factories. */\n+  private static final String KEY_FACTORY = \"KeyFactory\";\n+\n   private KeyFactorySpi keyFacSpi;\n   private Provider provider;\n   private String algorithm;\n \n   /**\n-     Constructs a new keyFactory with the specified parameters.\n-\n-     @param keyFacSpi Key Factory SPI to use\n-     @param provider the provider of the Key Factory SPI\n-     @param algorithm the name of the key algorithm for this key factory\n+   * Creates a <code>KeyFactory</code> object.\n+   *\n+   * @param keyFacSpi the delegate.\n+   * @param provider the provider.\n+   * @param algorithm the name of the algorithm to associate with this\n+   * <code>KeyFactory</code>.\n    */\n   protected KeyFactory(KeyFactorySpi keyFacSpi, Provider provider,\n \t\t       String algorithm)\n@@ -76,148 +106,165 @@ protected KeyFactory(KeyFactorySpi keyFacSpi, Provider provider,\n     this.algorithm = algorithm;\n   }\n \n-  /** \n-     Gets an instance of the KeyFactory class representing\n-     the specified key factory. If the algorithm is not \n-     found then, it throws NoSuchAlgorithmException.\n-\n-     @param algorithm the name of algorithm to choose\n-     @return a KeyFactory repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by providers\n+  /**\n+   * Generates a <code>KeyFactory</code> object that implements the specified\n+   * algorithm. If the default provider package provides an implementation of\n+   * the requested algorithm, an instance of <code>KeyFactory</code> containing\n+   * that implementation is returned. If the algorithm is not available in the\n+   * default package, other packages are searched.\n+   *\n+   * @param algorithm the name of the requested key algorithm. See Appendix A\n+   * in the Java Cryptography Architecture API Specification &amp; Reference\n+   * for information about standard algorithm names.\n+   * @return a <code>KeyFactory</code> object for the specified algorithm.\n+   * @throws NoSuchAlgorithmException if the requested algorithm is not\n+   * available in the default provider package or any of the other provider\n+   * packages that were searched.\n    */\n   public static KeyFactory getInstance(String algorithm)\n     throws NoSuchAlgorithmException\n   {\n     Provider[] p = Security.getProviders();\n-\n     for (int i = 0; i < p.length; i++)\n-      {\n-\tString classname = p[i].getProperty(\"KeyFactory.\" + algorithm);\n-\tif (classname != null)\n-\t  return getInstance(classname, algorithm, p[i]);\n-      }\n+      try\n+        {\n+          return getInstance(algorithm, p[i]);\n+        }\n+      catch (NoSuchAlgorithmException ignored) {}\n \n     throw new NoSuchAlgorithmException(algorithm);\n   }\n \n-  /** \n-     Gets an instance of the KeyFactory class representing\n-     the specified key factory from the specified provider. \n-     If the algorithm is not found then, it throws \n-     NoSuchAlgorithmException. If the provider is not found, then \n-     it throws NoSuchProviderException.\n-\n-     @param algorithm the name of algorithm to choose\n-     @param provider the name of the provider to find the algorithm in\n-     @return a KeyFactory repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by the provider\n-     @throws NoSuchProviderException if the provider is not found\n+  /**\n+   * Generates a <code>KeyFactory</code> object for the specified algorithm\n+   * from the specified provider.\n+   *\n+   * @param algorithm the name of the requested key algorithm. See Appendix A\n+   * in the Java Cryptography Architecture API Specification &amp; Reference\n+   * for information about standard algorithm names.\n+   * @param provider the name of the provider.\n+   * @return a <code>KeyFactory</code> object for the specified algorithm.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available from\n+   * the specified provider.\n+   * @throws NoSuchProviderException if the provider has not been configured.\n+   * @throws IllegalArgumentException if the provider name is null or empty.\n+   * @see Provider\n    */\n   public static KeyFactory getInstance(String algorithm, String provider)\n     throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n+    if (provider == null || provider.length() == 0)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n+\n     Provider p = Security.getProvider(provider);\n     if (p == null)\n       throw new NoSuchProviderException();\n \n-    return getInstance(p.getProperty(\"KeyFactory.\" + algorithm),\n-\t\t       algorithm, p);\n+    return getInstance(algorithm, p);\n   }\n \n-  private static KeyFactory getInstance(String classname,\n-\t\t\t\t\tString algorithm,\n-\t\t\t\t\tProvider provider)\n+  /**\n+   * Generates a <code>KeyFactory</code> object for the specified algorithm from\n+   * the specified provider. Note: the <code>provider</code> doesn't have to be\n+   * registered.\n+   *\n+   * @param algorithm the name of the requested key algorithm. See Appendix A\n+   * in the Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @param provider the provider.\n+   * @return a <code>KeyFactory</code> object for the specified algorithm.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available from\n+   * the specified provider.\n+   * @throws IllegalArgumentException if the <code>provider</code> is\n+   * <code>null</code>.\n+   * @since 1.4\n+   * @see Provider\n+   */\n+  public static KeyFactory getInstance(String algorithm, Provider provider)\n     throws NoSuchAlgorithmException\n   {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n \n     try\n       {\n-\treturn new KeyFactory((KeyFactorySpi) Class.forName(classname).\n-\t\t\t      newInstance(), provider, algorithm);\n-      }\n-    catch (ClassNotFoundException cnfe)\n-      {\n-\tthrow new NoSuchAlgorithmException(\"Class not found\");\n+\treturn new KeyFactory((KeyFactorySpi)\n+\t  Engine.getInstance(KEY_FACTORY, algorithm, provider),\n+          provider, algorithm);\n       }\n-    catch (InstantiationException ie)\n+    catch (ClassCastException cce)\n       {\n-\tthrow new NoSuchAlgorithmException(\"Class instantiation failed\");\n-      }\n-    catch (IllegalAccessException iae)\n-      {\n-\tthrow new NoSuchAlgorithmException(\"Illegal Access\");\n-      }\n+\tthrow new NoSuchAlgorithmException(algorithm);\n+      } \n   }\n \n   /**\n-     Gets the provider that the class is from.\n-\n-     @return the provider of this class\n+   * Returns the provider of this key factory object.\n+   *\n+   * @return the provider of this key factory object.\n    */\n   public final Provider getProvider()\n   {\n     return provider;\n   }\n \n   /**\n-     Returns the name of the algorithm used\n-\n-     @return A string with the name of the algorithm\n+   * Gets the name of the algorithm associated with this <code>KeyFactory</code>.\n+   *\n+   * @return the name of the algorithm associated with this\n+   * <code>KeyFactory</code>.\n    */\n   public final String getAlgorithm()\n   {\n     return algorithm;\n   }\n \n   /**\n-     Generates a public key from the provided key specification.\n-\n-     @param keySpec key specification\n-\n-     @return the public key\n-\n-     @throws InvalidKeySpecException invalid key specification for\n-     this key factory to produce a public key\n+   * Generates a public key object from the provided key specification (key\n+   * material).\n+   *\n+   * @param keySpec the specification (key material) of the public key.\n+   * @return the public key.\n+   * @throws InvalidKeySpecException if the given key specification is\n+   * inappropriate for this key factory to produce a public key.\n    */\n-  public final PublicKey generatePublic(KeySpec keySpec) throws\n-    InvalidKeySpecException\n+  public final PublicKey generatePublic(KeySpec keySpec)\n+    throws InvalidKeySpecException\n   {\n     return keyFacSpi.engineGeneratePublic(keySpec);\n   }\n \n   /**\n-     Generates a private key from the provided key specification.\n-\n-     @param keySpec key specification\n-\n-     @return the private key\n-\n-     @throws InvalidKeySpecException invalid key specification for\n-     this key factory to produce a private key\n+   * Generates a private key object from the provided key specification (key\n+   * material).\n+   *\n+   * @param keySpec the specification (key material) of the private key.\n+   * @return the private key.\n+   * @throws InvalidKeySpecException if the given key specification is\n+   * inappropriate for this key factory to produce a private key.\n    */\n-  public final PrivateKey generatePrivate(KeySpec keySpec) throws\n-    InvalidKeySpecException\n+  public final PrivateKey generatePrivate(KeySpec keySpec)\n+    throws InvalidKeySpecException\n   {\n     return keyFacSpi.engineGeneratePrivate(keySpec);\n   }\n \n   /**\n-     Returns a key specification for the given key. keySpec \n-     identifies the specification class to return the key \n-     material in.\n-\n-     @param key the key\n-     @param keySpec the specification class to return the \n-     key material in.\n-\n-     @return the key specification in an instance of the requested\n-     specification class\n-\n-     @throws InvalidKeySpecException the requested key specification\n-     is inappropriate for this key or the key is \n-     unrecognized.\n+   * Returns a specification (key material) of the given key object.\n+   * <code>keySpec</code> identifies the specification class in which the key\n+   * material should be returned. It could, for example, be\n+   * <code>DSAPublicKeySpec.class</code>, to indicate that the key material\n+   * should be returned in an instance of the {@link\n+   * java.security.spec.DSAPublicKeySpec} class.\n+   *\n+   * @param key the key.\n+   * @param keySpec the specification class in which the key material should be\n+   * returned.\n+   * @return the underlying key specification (key material) in an instance of\n+   * the requested specification class.\n+   * @throws InvalidKeySpecException if the requested key specification is\n+   * inappropriate for the given key, or the given key cannot be processed\n+   * (e.g., the given key has an unrecognized algorithm or format).\n    */\n   public final KeySpec getKeySpec(Key key, Class keySpec)\n     throws InvalidKeySpecException\n@@ -226,15 +273,13 @@ public final KeySpec getKeySpec(Key key, Class keySpec)\n   }\n \n   /**\n-     Translates the key from an unknown or untrusted provider\n-     into a key for this key factory.\n-\n-     @param the key from an unknown or untrusted provider\n-\n-     @return the translated key\n-\n-     @throws InvalidKeySpecException if the key cannot be \n-     processed by this key factory\n+   * Translates a key object, whose provider may be unknown or potentially\n+   * untrusted, into a corresponding key object of this key factory.\n+   *\n+   * @param key the key whose provider is unknown or untrusted.\n+   * @return the translated key.\n+   * @throws InvalidKeyException if the given key cannot be processed by this\n+   * key factory.\n    */\n   public final Key translateKey(Key key) throws InvalidKeyException\n   {"}, {"sha": "8bc829608c5391940ed96656e47851a0c4d2774b", "filename": "libjava/java/security/KeyPairGenerator.java", "status": "modified", "additions": 238, "deletions": 143, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* KeyPairGenerator.java --- Key Pair Generator Class\n-   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,25 +40,94 @@\n import java.security.spec.AlgorithmParameterSpec;\n \n /**\n-   KeyPairGenerator is the class used to generate key pairs\n-   for a security algorithm.\n-\n-   The KeyPairGenerator is created with the getInstance()\n-   methods. The class is used to generate public and private\n-   keys for an algorithm and associate it with \n-   algorithm parameters.\n-\n-   @author Mark Benvenuto\n+ * <p>The <code>KeyPairGenerator</code> class is used to generate pairs of\n+ * public and private keys. Key pair generators are constructed using the\n+ * <code>getInstance()</code> factory methods (static methods that return\n+ * instances of a given class).</p>\n+ *\n+ * <p>A Key pair generator for a particular algorithm creates a public/private\n+ * key pair that can be used with this algorithm. It also associates\n+ * algorithm-specific parameters with each of the generated keys.</p>\n+ *\n+ * <p>There are two ways to generate a key pair: in an algorithm-independent\n+ * manner, and in an algorithm-specific manner. The only difference between the\n+ * two is the initialization of the object:</p>\n+ *\n+ * <ul>\n+ *    <li><b>Algorithm-Independent Initialization</b><br/>\n+ *    All key pair generators share the concepts of a <i>keysize</i> and a\n+ *    <i>source of randomness</i>. The <i>keysize</i> is interpreted differently\n+ *    for different algorithms (e.g., in the case of the <i>DSA</i> algorithm,\n+ *    the <i>keysize</i> corresponds to the length of the modulus). There is an\n+ *    <code>initialize()</code> method in this <code>KeyPairGenerator</code>\n+ *    class that takes these two universally shared types of arguments. There\n+ *    is also one that takes just a <i>keysize</i> argument, and uses the\n+ *    {@link SecureRandom} implementation of the highest-priority installed\n+ *    provider as the <i>source of randomness</i>. (If none of the installed\n+ *    providers supply an implementation of {@link SecureRandom}, a\n+ *    system-provided source of randomness is used.)<br/><br/>\n+ *\n+ *    Since no other parameters are specified when you call the above\n+ *    algorithm-independent initialize methods, it is up to the provider what\n+ *    to do about the algorithm-specific parameters (if any) to be associated\n+ *    with each of the keys.<br/><br/>\n+ *\n+ *    If the algorithm is the <i>DSA</i> algorithm, and the <i>keysize</i>\n+ *    (modulus size) is <code>512</code>, <code>768</code>, or <code>1024</code>,\n+ *    then the <b>GNU</b> provider uses a set of precomputed values for the\n+ *    <code>p</code>, <code>q</code>, and <code>g</code> parameters. If the\n+ *    <i>modulus size</i> is not one of the above values, the <b>GNU</b>\n+ *    provider creates a new set of parameters. Other providers might have\n+ *    precomputed parameter sets for more than just the three modulus sizes\n+ *    mentioned above. Still others might not have a list of precomputed\n+ *    parameters at all and instead always create new parameter sets.<br/></li>\n+ *\n+ *    <li><b>Algorithm-Specific Initialization</b><br/>\n+ *    For situations where a set of algorithm-specific parameters already\n+ *    exists (e.g., so-called <i>community parameters</i> in <i>DSA</i>), there\n+ *    are two initialize methods that have an {@link AlgorithmParameterSpec}\n+ *    argument. One also has a {@link SecureRandom} argument, while the the\n+ *    other uses the {@link SecureRandom} implementation of the highest-priority\n+ *    installed provider as the source of randomness. (If none of the installed\n+ *    providers supply an implementation of {@link SecureRandom}, a\n+ *    system-provided source of randomness is used.)</li>\n+ * </ul>\n+ *\n+ * <p>In case the client does not explicitly initialize the\n+ * <code>KeyPairGenerator</code> (via a call to an initialize method), each\n+ * provider must supply (and document) a default initialization. For example,\n+ * the <b>GNU</b> provider uses a default modulus size (keysize) of\n+ * <code>1024</code> bits.</p>\n+ *\n+ * <p>Note that this class is abstract and extends from {@link\n+ * KeyPairGeneratorSpi} for historical reasons. Application developers should\n+ * only take notice of the methods defined in this <code>KeyPairGenerator</code>\n+ * class; all the methods in the superclass are intended for cryptographic\n+ * service providers who wish to supply their own implementations of key pair\n+ * generators.</p>\n+ *\n+ * @see Signature\n+ * @see KeyPair\n+ * @see AlgorithmParameterSpec\n+ * @author Mark Benvenuto\n+ * @author Casey Marshall\n  */\n public abstract class KeyPairGenerator extends KeyPairGeneratorSpi\n {\n+  /** The service name for key pair generators. */\n+  private static final String KEY_PAIR_GENERATOR = \"KeyPairGenerator\";\n+\n   Provider provider;\n   private String algorithm;\n \n   /**\n-     Constructs a new KeyPairGenerator\n-\n-     @param algorithm the algorithm to use\n+   * Creates a <code>KeyPairGenerator</code> object for the specified \n+   * algorithm.\n+   *\n+   * @param algorithm the standard string name of the algorithm. \n+   * See Appendix A in the Java Cryptography Architecture API \n+   * Specification &amp; Reference for information about standard \n+   * algorithm names.\n    */\n   protected KeyPairGenerator(String algorithm)\n   {\n@@ -67,55 +136,65 @@ protected KeyPairGenerator(String algorithm)\n   }\n \n   /**\n-     Returns the name of the algorithm used\n-\n-     @return A string with the name of the algorithm\n+   * Returns the standard name of the algorithm for this key pair generator.\n+   * See Appendix A in the Java Cryptography Architecture API Specification\n+   * &amp; Reference for information about standard algorithm names.\n+   *\n+   * @return the standard string name of the algorithm.\n    */\n   public String getAlgorithm()\n   {\n     return algorithm;\n   }\n \n-  /** \n-     Gets an instance of the KeyPairGenerator class \n-     which generates key pairs for the specified algorithm. \n-     If the algorithm is not found then, it throws NoSuchAlgorithmException.\n-\n-     @param algorithm the name of algorithm to choose\n-     @return a AlgorithmParameterGenerator repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n-     \t\t\t\t      providers\n+  /**\n+   * Generates a <code>KeyPairGenerator</code> object that implements the\n+   * specified digest algorithm. If the default provider package provides an\n+   * implementation of the requested digest algorithm, an instance of\n+   * <code>KeyPairGenerator</code> containing that implementation is returned.\n+   * If the algorithm is not available in the default package, other packages\n+   * are searched.\n+   *\n+   * @param algorithm the standard string name of the algorithm. See Appendix A\n+   * in the Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @return the new <code>KeyPairGenerator</code> object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * environment.\n    */\n-  public static KeyPairGenerator getInstance(String algorithm) throws\n-    NoSuchAlgorithmException\n+  public static KeyPairGenerator getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n   {\n     Provider[] p = Security.getProviders();\n-\n     for (int i = 0; i < p.length; i++)\n       {\n-\ttry\n-\t  {\n-\t    return getInstance(algorithm, p[i]);\n+        try\n+          {\n+            return getInstance(algorithm, p[i]);\n \t  }\n-\tcatch (NoSuchAlgorithmException ignored) {}\n+        catch (NoSuchAlgorithmException ignored) {}\n       }\n \n     throw new NoSuchAlgorithmException(algorithm);\n   }\n \n-  /** \n-     Gets an instance of the KeyPairGenerator class \n-     which generates key pairs for the specified algorithm. \n-     If the algorithm is not found then, it throws NoSuchAlgorithmException.\n-\n-     @param algorithm the name of algorithm to choose\n-     @param provider the name of the provider to find the algorithm in\n-     @return a AlgorithmParameterGenerator repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n-     \t\t\t\t      the provider\n-     @throws NoSuchProviderException if the provider is not found\n+  /**\n+   * Generates a <code>KeyPairGenerator</code> object implementing the \n+   * specified algorithm, as supplied from the specified provider, if \n+   * such an algorithm is available from the provider.\n+   *\n+   * @param algorithm the standard string name of the algorithm. See \n+   * Appendix A in the Java Cryptography Architecture API Specification \n+   * &amp; Reference for information about standard algorithm names.\n+   * @param provider the string name of the provider.\n+   * @return the new <code>KeyPairGenerator</code> object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available \n+   * from the provider.\n+   * @throws NoSuchProviderException if the provider is not available in the\n+   * environment.\n+   * @throws IllegalArgumentException if the provider name is <code>null</code>\n+   * or empty.\n+   * @see Provider\n    */\n   public static KeyPairGenerator getInstance(String algorithm, String provider)\n     throws NoSuchAlgorithmException, NoSuchProviderException\n@@ -127,110 +206,109 @@ public static KeyPairGenerator getInstance(String algorithm, String provider)\n     return getInstance(algorithm, p);\n   }\n \n-  private static KeyPairGenerator getInstance(String algorithm, Provider p)\n-    throws NoSuchAlgorithmException\n-  {\n-    // try the name as is\n-    String className = p.getProperty(\"KeyPairGenerator.\" + algorithm);\n-    if (className == null) { // try all uppercase\n-      String upper = algorithm.toUpperCase();\n-      className = p.getProperty(\"KeyPairGenerator.\" + upper);\n-      if (className == null) { // try if it's an alias\n-        String alias = p.getProperty(\"Alg.Alias.KeyPairGenerator.\" + algorithm);\n-        if (alias == null) { // try all-uppercase alias name\n-          alias = p.getProperty(\"Alg.Alias.KeyPairGenerator.\" + upper);\n-          if (alias == null) { // spit the dummy\n-            throw new NoSuchAlgorithmException(algorithm);\n-          }\n-        }\n-        className = p.getProperty(\"KeyPairGenerator.\" + alias);\n-        if (className == null) {\n-          throw new NoSuchAlgorithmException(algorithm);\n-        }\n-      }\n-    }\n-    return getInstance(className, algorithm, p);\n-  }\n-\n-  private static KeyPairGenerator getInstance(String classname,\n-\t\t\t\t\t      String algorithm,\n-\t\t\t\t\t      Provider provider)\n+  /**\n+   * Generates a <code>KeyPairGenerator</code> object implementing the specified\n+   * algorithm, as supplied from the specified provider, if such an algorithm is\n+   * available from the provider. Note: the provider doesn't have to be\n+   * registered.\n+   *\n+   * @param algorithm the standard string name of the algorithm. See Appendix A\n+   * in the Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @param provider the provider.\n+   * @return the new <code>KeyPairGenerator</code> object.\n+   * @throws NoSuchAlgorithmException if the <code>algorithm</code> is not\n+   * available from the <code>provider</code>.\n+   * @throws IllegalArgumentException if the <code>provider</code> is\n+   * <code>null</code>.\n+   * @since 1.4\n+   * @see Provider\n+   */\n+  public static KeyPairGenerator getInstance(String algorithm, \n+\t\t\t\t\t     Provider provider)\n     throws NoSuchAlgorithmException\n   {\n-    try\n-      {\n-\tObject o = Class.forName(classname).newInstance();\n-\tKeyPairGenerator kpg;\n-\tif (o instanceof KeyPairGeneratorSpi)\n-\t  kpg = new DummyKeyPairGenerator((KeyPairGeneratorSpi) o, algorithm);\n-\telse\n-\t  {\n-\t    kpg = (KeyPairGenerator) o;\n-\t    kpg.algorithm = algorithm;\n-\t  }\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n \n-\tkpg.provider = provider;\n-\treturn kpg;\n-      }\n-    catch (ClassNotFoundException cnfe)\n+    Object o = Engine.getInstance(KEY_PAIR_GENERATOR, algorithm, provider);\n+    KeyPairGenerator result = null;\n+    if (o instanceof KeyPairGeneratorSpi)\n       {\n-\tthrow new NoSuchAlgorithmException(\"Class not found\");\n+\tresult = new DummyKeyPairGenerator((KeyPairGeneratorSpi) o, algorithm);\n       }\n-    catch (InstantiationException ie)\n+    else if (o instanceof KeyPairGenerator)\n       {\n-\tthrow new NoSuchAlgorithmException(\"Class instantiation failed\");\n-      }\n-    catch (IllegalAccessException iae)\n-      {\n-\tthrow new NoSuchAlgorithmException(\"Illegal Access\");\n+        result = (KeyPairGenerator) o;\n+        result.algorithm = algorithm;\n       }\n+    result.provider = provider;\n+    return result;\n   }\n \n   /**\n-     Gets the provider that the class is from.\n-\n-     @return the provider of this class\n+   * Returns the provider of this key pair generator object.\n+   *\n+   * @return the provider of this key pair generator object.\n    */\n   public final Provider getProvider()\n   {\n     return provider;\n   }\n \n   /**\n-     Initializes the KeyPairGenerator for the specified key size.\n-     (Since no source of randomness is specified, a default one is\n-     provided.)\n-\n-     @param keysize Size of key to generate\n+   * Initializes the key pair generator for a certain keysize using a default\n+   * parameter set and the {@link SecureRandom} implementation of the\n+   * highest-priority installed provider as the source of randomness. (If none\n+   * of the installed providers supply an implementation of {@link SecureRandom},\n+   * a system-provided source of randomness is used.)\n+   *\n+   * @param keysize the keysize. This is an algorithm-specific metric, such as\n+   * modulus length, specified in number of bits.\n+   * @throws InvalidParameterException if the keysize is not supported by this\n+   * <code>KeyPairGenerator</code> object.\n    */\n   public void initialize(int keysize)\n   {\n     initialize(keysize, new SecureRandom());\n   }\n \n   /**\n-     Initializes the KeyPairGenerator for the specified key size\n-     and specified SecureRandom.\n-\n-     @param keysize Size of key to generate\n-     @param random SecureRandom to use\n-\n-     @since JDK 1.2\n+   * Initializes the key pair generator for a certain keysize with the given\n+   * source of randomness (and a default parameter set).\n+   *\n+   * @param keysize the keysize. This is an algorithm-specific metric, such as\n+   * modulus length, specified in number of bits.\n+   * @param random the source of randomness.\n+   * @throws InvalidParameterException if the <code>keysize</code> is not\n+   * supported by this <code>KeyPairGenerator</code> object.\n+   * @since 1.2\n    */\n   public void initialize(int keysize, SecureRandom random)\n   {\n     initialize(keysize, random);\n   }\n \n   /**\n-     Initializes the KeyPairGenerator with the specified\n-     AlgorithmParameterSpec class.\n-     (Since no source of randomness is specified, a default one is\n-     provided.)\n-\n-     @param params AlgorithmParameterSpec to initialize with\n-\n-     @since JDK 1.2\n+   * <p>Initializes the key pair generator using the specified parameter set and\n+   * the {@link SecureRandom} implementation of the highest-priority installed\n+   * provider as the source of randomness. (If none of the installed providers\n+   * supply an implementation of {@link SecureRandom}, a system-provided source\n+   * of randomness is used.)</p>\n+   *\n+   * <p>This concrete method has been added to this previously-defined abstract\n+   * class. This method calls the\n+   * {@link KeyPairGeneratorSpi#initialize(AlgorithmParameterSpec, SecureRandom)}\n+   * initialize method, passing it <code>params</code> and a source of\n+   * randomness (obtained from the highest-priority installed provider or\n+   * system-provided if none of the installed providers supply one). That\n+   * initialize method always throws an {@link UnsupportedOperationException}\n+   * if it is not overridden by the provider.</p>\n+   *\n+   * @param params the parameter set used to generate the keys.\n+   * @throws InvalidAlgorithmParameterException if the given parameters are\n+   * inappropriate for this key pair generator.\n+   * @since 1.2\n    */\n   public void initialize(AlgorithmParameterSpec params)\n     throws InvalidAlgorithmParameterException\n@@ -239,13 +317,21 @@ public void initialize(AlgorithmParameterSpec params)\n   }\n \n   /**\n-     Initializes the KeyPairGenerator with the specified\n-     AlgorithmParameterSpec class and specified SecureRandom.\n-\n-     @param params AlgorithmParameterSpec to initialize with\n-     @param random SecureRandom to use\n-\n-     @since JDK 1.2\n+   * <p>Initializes the key pair generator with the given parameter set and\n+   * source of randomness.</p>\n+   *\n+   * <p>This concrete method has been added to this previously-defined abstract\n+   * class. This method calls the\n+   * {@link KeyPairGeneratorSpi#initialize(AlgorithmParameterSpec, SecureRandom)}\n+   * initialize method, passing it <code>params</code> and <code>random</code>.\n+   * That initialize method always throws an {@link UnsupportedOperationException}\n+   * if it is not overridden by the provider.</p>\n+   *\n+   * @param params the parameter set used to generate the keys.\n+   * @param random the source of randomness.\n+   * @throws InvalidAlgorithmParameterException if the given parameters are\n+   * inappropriate for this key pair generator.\n+   * @since 1.2\n    */\n   public void initialize(AlgorithmParameterSpec params, SecureRandom random)\n     throws InvalidAlgorithmParameterException\n@@ -254,36 +340,45 @@ public void initialize(AlgorithmParameterSpec params, SecureRandom random)\n   }\n \n   /**\n-     Generates a KeyPair according the rules for the algorithm.\n-     Unless intialized, algorithm defaults will be used. It \n-     creates a unique key pair each time.\n-\n-     Same as generateKeyPair();\n-\n-     @return a key pair\n+   * <p>Generates a key pair.</p>\n+   *\n+   * <p>If this <code>KeyPairGenerator</code> has not been initialized\n+   * explicitly, provider-specific defaults will be used for the size and other\n+   * (algorithm-specific) values of the generated keys.</p>\n+   *\n+   * <p>This will generate a new key pair every time it is called.</p>\n+   *\n+   * <p>This method is functionally equivalent to {@link #generateKeyPair()}.</p>\n+   *\n+   * @return the generated key pair.\n+   * @since 1.2\n    */\n   public final KeyPair genKeyPair()\n   {\n     try\n       {\n-\treturn getInstance(\"DSA\", \"GNU\").generateKeyPair();\n+        return getInstance(\"DSA\", \"GNU\").generateKeyPair();\n       }\n     catch (Exception e)\n       {\n-\tSystem.err.println(\"genKeyPair failed: \" + e);\n-\te.printStackTrace();\n-\treturn null;\n+        System.err.println(\"genKeyPair failed: \" + e);\n+        e.printStackTrace();\n+        return null;\n       }\n   }\n \n   /**\n-     Generates a KeyPair according the rules for the algorithm.\n-     Unless intialized, algorithm defaults will be used. It \n-     creates a unique key pair each time.\n-\n-     Same as genKeyPair();\n-\n-     @return a key pair\n+   * <p>Generates a key pair.</p>\n+   *\n+   * <p>If this <code>KeyPairGenerator</code> has not been initialized\n+   * explicitly, provider-specific defaults will be used for the size and other\n+   * (algorithm-specific) values of the generated keys.</p>\n+   *\n+   * <p>This will generate a new key pair every time it is called.</p>\n+   *\n+   * <p>This method is functionally equivalent to {@link #genKeyPair()}.</p>\n+   *\n+   * @return the generated key pair.\n    */\n   public KeyPair generateKeyPair()\n   {"}, {"sha": "cd3c2687cf727ade8ceebd3e093d0e88699267f2", "filename": "libjava/java/security/KeyStore.java", "status": "modified", "additions": 113, "deletions": 106, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FKeyStore.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FKeyStore.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyStore.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* KeyStore.java --- Key Store Class\n-   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -44,37 +44,52 @@\n import java.util.Enumeration;\n \n /**\n-   Keystore represents an in-memory collection of keys and \n-   certificates. There are two types of entries:\n-\n-   * Key Entry\n-\n-   This type of keystore entry store sensitive crytographic key\n-   information in a protected format.Typically this is a secret \n-   key or a private key with a certificate chain.\n-\n-\n-   * Trusted Ceritificate Entry\n-\n-   This type of keystore entry contains a single public key \n-   certificate belonging to annother entity. It is called trusted\n-   because the keystore owner trusts that the certificates\n-   belongs to the subject (owner) of the certificate.\n-\n-   The keystore contains an \"alias\" string for each entry. \n-\n-   The structure and persistentence of the key store is not \n-   specified. Any method could be used to protect sensitive \n-   (private or secret) keys. Smart cards or integrated \n-   cryptographic engines could be used or the keystore could \n-   be simply stored in a file. \n+ * Keystore represents an in-memory collection of keys and \n+ * certificates. There are two types of entries:\n+ *\n+ * <dl>\n+ * <dt>Key Entry</dt>\n+ *\n+ * <dd><p>This type of keystore entry store sensitive crytographic key\n+ * information in a protected format.Typically this is a secret \n+ * key or a private key with a certificate chain.</p></dd>\n+ *\n+ * <dt>Trusted Ceritificate Entry</dt>\n+ *\n+ * <dd><p>This type of keystore entry contains a single public key \n+ * certificate belonging to annother entity. It is called trusted\n+ * because the keystore owner trusts that the certificates\n+ * belongs to the subject (owner) of the certificate.</p></dd>\n+ * </dl>\n+ *\n+ * <p>Entries in a key store are referred to by their \"alias\": a simple\n+ * unique string.\n+ *\n+ * <p>The structure and persistentence of the key store is not \n+ * specified. Any method could be used to protect sensitive \n+ * (private or secret) keys. Smart cards or integrated \n+ * cryptographic engines could be used or the keystore could \n+ * be simply stored in a file.</p>\n+ *\n+ * @see java.security.cert.Certificate\n+ * @see Key\n  */\n public class KeyStore\n {\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** Service name for key stores. */\n+  private static final String KEY_STORE = \"KeyStore\";\n+\n   private KeyStoreSpi keyStoreSpi;\n   private Provider provider;\n   private String type;\n \n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n   /**\n      Creates an instance of KeyStore\n \n@@ -89,112 +104,121 @@ protected KeyStore(KeyStoreSpi keyStoreSpi, Provider provider, String type)\n     this.type = type;\n   }\n \n-  /** \n-     Gets an instance of the KeyStore class representing\n-     the specified keystore. If the type is not \n-     found then, it throws KeyStoreException.\n-\n-     @param type the type of keystore to choose\n-\n-     @return a KeyStore repesenting the desired type\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n \n-     @throws KeyStoreException if the type of keystore is not implemented by providers\n+  /** \n+   * Gets an instance of the KeyStore class representing\n+   * the specified keystore. If the type is not \n+   * found then, it throws KeyStoreException.\n+   *\n+   * @param type the type of keystore to choose\n+   * @return a KeyStore repesenting the desired type\n+   * @throws KeyStoreException if the type of keystore is not implemented\n+   *         by providers or the implementation cannot be instantiated.\n    */\n   public static KeyStore getInstance(String type) throws KeyStoreException\n   {\n     Provider[] p = Security.getProviders();\n \n     for (int i = 0; i < p.length; i++)\n       {\n-\tString classname = p[i].getProperty(\"KeyStore.\" + type);\n-\tif (classname != null)\n-\t  return getInstance(classname, type, p[i]);\n+        try\n+          {\n+            return getInstance(type, p[i]);\n+          }\n+        catch (KeyStoreException ignore)\n+          {\n+          }\n       }\n \n     throw new KeyStoreException(type);\n   }\n \n   /** \n-     Gets an instance of the KeyStore class representing\n-     the specified key store from the specified provider. \n-     If the type is not found then, it throws KeyStoreException. \n-     If the provider is not found, then it throws \n-     NoSuchProviderException.\n-\n-     @param type the type of keystore to choose\n-     @param provider the provider name\n-\n-     @return a KeyStore repesenting the desired type\n-\n-     @throws KeyStoreException if the type of keystore is not \n-              implemented by the given provider\n-     @throws NoSuchProviderException if the provider is not found\n-     @throws IllegalArgumentException if the provider string is \n-               null or empty\n+   * Gets an instance of the KeyStore class representing\n+   * the specified key store from the specified provider. \n+   * If the type is not found then, it throws KeyStoreException. \n+   * If the provider is not found, then it throws \n+   * NoSuchProviderException.\n+   *\n+   * @param type the type of keystore to choose\n+   * @param provider the provider name\n+   * @return a KeyStore repesenting the desired type\n+   * @throws KeyStoreException if the type of keystore is not \n+   *          implemented by the given provider\n+   * @throws NoSuchProviderException if the provider is not found\n+   * @throws IllegalArgumentException if the provider string is \n+   *           null or empty\n    */\n   public static KeyStore getInstance(String type, String provider)\n     throws KeyStoreException, NoSuchProviderException\n   {\n     if (provider == null || provider.length() == 0)\n       throw new IllegalArgumentException(\"Illegal provider\");\n+\n     Provider p = Security.getProvider(provider);\n     if (p == null)\n       throw new NoSuchProviderException();\n \n-    return getInstance(p.getProperty(\"KeyStore.\" + type), type, p);\n+    return getInstance(type, p);\n   }\n \n   /** \n-     Gets an instance of the KeyStore class representing\n-     the specified key store from the specified provider. \n-     If the type is not found then, it throws KeyStoreException. \n-     If the provider is not found, then it throws \n-     NoSuchProviderException.\n-\n-     @param type the type of keystore to choose\n-     @param provider the keystore provider\n-\n-     @return a KeyStore repesenting the desired type\n-\n-     @throws KeyStoreException if the type of keystore is not \n-              implemented by the given provider\n-     @throws IllegalArgumentException if the provider object is null\n-     @since 1.4\n+   * Gets an instance of the KeyStore class representing\n+   * the specified key store from the specified provider. \n+   * If the type is not found then, it throws KeyStoreException. \n+   * If the provider is not found, then it throws \n+   * NoSuchProviderException.\n+   *\n+   * @param type the type of keystore to choose\n+   * @param provider the keystore provider\n+   * @return a KeyStore repesenting the desired type\n+   * @throws KeyStoreException if the type of keystore is not \n+   *          implemented by the given provider\n+   * @throws IllegalArgumentException if the provider object is null\n+   * @since 1.4\n    */\n   public static KeyStore getInstance(String type, Provider provider)\n     throws KeyStoreException \n   {\n     if (provider == null)\n       throw new IllegalArgumentException(\"Illegal provider\");\n-\n-    return getInstance(provider.getProperty(\"KeyStore.\" + type),\n-\t\t       type, provider);\n-  }\n-\n-  private static KeyStore getInstance(String classname,\n-\t\t\t\t      String type,\n-\t\t\t\t      Provider provider)\n-    throws KeyStoreException\n-  {\n     try\n       {\n-\treturn new KeyStore((KeyStoreSpi) Class.forName(classname).\n-\t\t\t    newInstance(), provider, type);\n+        return new KeyStore(\n+          (KeyStoreSpi) Engine.getInstance(KEY_STORE, type, provider),\n+          provider, type);\n       }\n-    catch (ClassNotFoundException cnfe)\n+    catch (NoSuchAlgorithmException nsae)\n       {\n-\tthrow new KeyStoreException(\"Class not found\");\n+        throw new KeyStoreException(type);\n       }\n-    catch (InstantiationException ie)\n+    catch (ClassCastException cce)\n       {\n-\tthrow new KeyStoreException(\"Class instantiation failed\");\n-      }\n-    catch (IllegalAccessException iae)\n-      {\n-\tthrow new KeyStoreException(\"Illegal Access\");\n+        throw new KeyStoreException(type);\n       }\n   }\n \n+  /**\n+   * Returns the default KeyStore type. This method looks up the\n+   * type in <JAVA_HOME>/lib/security/java.security with the \n+   * property \"keystore.type\" or if that fails then \"jks\" .\n+   */\n+  public static final String getDefaultType()\n+  {\n+    // Security reads every property in java.security so it \n+    // will return this property if it exists. \n+    String tmp = Security.getProperty(\"keystore.type\");\n+\n+    if (tmp == null)\n+      tmp = \"jks\";\n+\n+    return tmp;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n \n   /**\n      Gets the provider that the class is from.\n@@ -471,21 +495,4 @@ public final void load(InputStream stream, char[]password)\n     keyStoreSpi.engineLoad(stream, password);\n   }\n \n-  /**\n-     Returns the default KeyStore type. This method looks up the\n-     type in <JAVA_HOME>/lib/security/java.security with the \n-     property \"keystore.type\" or if that fails then \"jks\" .\n-   */\n-  public static final String getDefaultType()\n-  {\n-    String tmp;\n-    //Security reads every property in java.security so it \n-    //will return this property if it exists. \n-    tmp = Security.getProperty(\"keystore.type\");\n-\n-    if (tmp == null)\n-      tmp = \"jks\";\n-\n-    return tmp;\n-  }\n }"}, {"sha": "cbf0e0753a75724705ad260ce2f1269ad54c0182", "filename": "libjava/java/security/MessageDigest.java", "status": "modified", "additions": 196, "deletions": 156, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FMessageDigest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FMessageDigest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FMessageDigest.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,6 +1,5 @@\n-\n /* MessageDigest.java --- The message digest interface.\n-   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,34 +37,94 @@\n \n package java.security;\n \n+/**\n+ * <p>This <code>MessageDigest</code> class provides applications the\n+ * functionality of a message digest algorithm, such as <i>MD5</i> or <i>SHA</i>.\n+ * Message digests are secure one-way hash functions that take arbitrary-sized\n+ * data and output a fixed-length hash value.</p>\n+ *\n+ * <p>A <code>MessageDigest</code> object starts out initialized. The data is\n+ * processed through it using the <code>update()</code> methods. At any point\n+ * <code>reset()</code> can be called to reset the digest. Once all the data to\n+ * be updated has been updated, one of the <code>digest()</code> methods should\n+ * be called to complete the hash computation.</p>\n+ *\n+ * <p>The <code>digest()</code> method can be called <b>once</b> for a given\n+ * number of updates. After <code>digest()</code> has been called, the\n+ * <code>MessageDigest</code> object is <b>reset</b> to its initialized state.\n+ * </p>\n+ *\n+ * <p>Implementations are free to implement the {@link Cloneable} interface.\n+ * Client applications can test cloneability by attempting cloning and catching\n+ * the {@link CloneNotSupportedException}:\n+ *\n+ * <pre>\n+ *    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n+ *    try\n+ *      {\n+ *        md.update(toChapter1);\n+ *        MessageDigest tc1 = md.clone();\n+ *        byte[] toChapter1Digest = tc1.digest();\n+ *        md.update(toChapter2);\n+ *        // ...\n+ *      }\n+ *    catch (CloneNotSupportedException x)\n+ *      {\n+ *        throw new DigestException(\"couldn't make digest of partial content\");\n+ *      }\n+ * </pre>\n+ *\n+ * <p>Note that if a given implementation is not cloneable, it is still possible\n+ * to compute intermediate digests by instantiating several instances, if the\n+ * number of digests is known in advance.</p>\n+ *\n+ * <p>Note that this class is abstract and extends from {@link MessageDigestSpi}\n+ * for historical reasons. Application developers should only take notice of the\n+ * methods defined in this <code>MessageDigest</code> class; all the methods in\n+ * the superclass are intended for cryptographic service providers who wish to\n+ * supply their own implementations of message digest algorithms.</p>\n+ *\n+ * @see MessageDigestSpi\n+ * @see Provider\n+ * @since JDK 1.1\n+ */\n public abstract class MessageDigest extends MessageDigestSpi\n {\n+  /** The service name for message digests. */\n+  private static final String MESSAGE_DIGEST = \"MessageDigest\";\n+\n   private String algorithm;\n   Provider provider;\n   private byte[] lastDigest;\n \n   /**\n-     Creates a MessageDigest representing the specified\n-     algorithm.\n-\n-     @param algorithm the name of digest algorithm to choose\n+   * Creates a message digest with the specified algorithm name.\n+   *\n+   * @param algorithm the standard name of the digest algorithm. \n+   * See Appendix A in the Java Cryptography Architecture API \n+   * Specification &amp; Reference for information about standard \n+   * algorithm names.\n    */\n   protected MessageDigest(String algorithm)\n   {\n     this.algorithm = algorithm;\n     provider = null;\n   }\n \n-  /** \n-     Gets an instance of the MessageDigest class representing\n-     the specified digest. If the algorithm is not found then, \n-     it throws NoSuchAlgorithmException.\n-\n-     @param algorithm the name of digest algorithm to choose\n-     @return a MessageDigest representing the desired algorithm\n-\n-     @exception NoSuchAlgorithmException if the algorithm is not implemented by\n-    \t\t\t\t\t providers\n+  /**\n+   * Generates a <code>MessageDigest</code> object that implements the specified\n+   * digest algorithm. If the default provider package provides an\n+   * implementation of the requested digest algorithm, an instance of\n+   * <code>MessageDigest</code> containing that implementation is returned. If\n+   * the algorithm is not available in the default package, other packages are\n+   * searched.\n+   *\n+   * @param algorithm the name of the algorithm requested. See Appendix A in the\n+   * Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @return a Message Digest object implementing the specified algorithm.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * caller's environment.\n    */\n   public static MessageDigest getInstance(String algorithm)\n     throws NoSuchAlgorithmException\n@@ -83,199 +142,183 @@ public static MessageDigest getInstance(String algorithm)\n     throw new NoSuchAlgorithmException(algorithm);\n   }\n \n-  /** \n-     Gets an instance of the MessageDigest class representing\n-     the specified digest from the specified provider. If the \n-     algorithm is not found then, it throws NoSuchAlgorithmException.\n-     If the provider is not found, then it throws\n-     NoSuchProviderException.\n-\n-     @param algorithm the name of digest algorithm to choose\n-     @param provider the name of the provider to find the algorithm in\n-     @return a MessageDigest representing the desired algorithm\n-\n-     @exception NoSuchAlgorithmException if the algorithm is not implemented by\n-     \t\t\t\t\t the provider\n-     @exception NoSuchProviderException if the provider is not found\n+  /**\n+   * Generates a <code>MessageDigest</code> object implementing the specified\n+   * algorithm, as supplied from the specified provider, if such an algorithm is\n+   * available from the provider.\n+   *\n+   * @param algorithm the name of the algorithm requested. See Appendix A in the\n+   * Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @param provider the name of the provider.\n+   * @return a Message Digest object implementing the specified algorithm.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * package supplied by the requested provider.\n+   * @throws NoSuchProviderException if the provider is not available in the\n+   * environment.\n+   * @throws IllegalArgumentException if the provider name is null or empty.\n+   * @see Provider\n    */\n-\n   public static MessageDigest getInstance(String algorithm, String provider)\n     throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n-    Provider p = Security.getProvider(provider);\n+    if (provider == null || provider.length() == 0)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n \n+    Provider p = Security.getProvider(provider);\n     if (p == null)\n       throw new NoSuchProviderException(provider);\n \n     return getInstance(algorithm, p);\n   }\n \n-  private static MessageDigest getInstance(String algorithm, Provider p)\n-    throws NoSuchAlgorithmException\n-  {\n-    // try the name as is\n-    String className = p.getProperty(\"MessageDigest.\" + algorithm);\n-    if (className == null) { // try all uppercase\n-      String upper = algorithm.toUpperCase();\n-      className = p.getProperty(\"MessageDigest.\" + upper);\n-      if (className == null) { // try if it's an alias\n-        String alias = p.getProperty(\"Alg.Alias.MessageDigest.\" +algorithm);\n-        if (alias == null) { // try all-uppercase alias name\n-          alias = p.getProperty(\"Alg.Alias.MessageDigest.\" +upper);\n-          if (alias == null) { // spit the dummy\n-            throw new NoSuchAlgorithmException(algorithm);\n-          }\n-        }\n-        className = p.getProperty(\"MessageDigest.\" + alias);\n-        if (className == null) {\n-          throw new NoSuchAlgorithmException(algorithm);\n-        }\n-      }\n-    }\n-    return getInstance(className, algorithm, p);\n-  }\n-\n-  private static MessageDigest getInstance(String classname,\n-\t\t\t\t\t   String algorithm,\n-\t\t\t\t\t   Provider provider)\n+  /**\n+   * Generates a <code>MessageDigest</code> object implementing the specified\n+   * algorithm, as supplied from the specified provider, if such an algorithm\n+   * is available from the provider. Note: the provider doesn't have to be\n+   * registered.\n+   *\n+   * @param algorithm the name of the algorithm requested. See Appendix A in\n+   * the Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @param provider the provider.\n+   * @return a Message Digest object implementing the specified algorithm.\n+   * @throws NoSuchAlgorithmException if the <code>algorithm</code> is not\n+   * available in the package supplied by the requested <code>provider</code>.\n+   * @throws IllegalArgumentException if the <code>provider</code> is\n+   * <code>null</code>.\n+   * @since 1.4\n+   * @see Provider\n+   */\n+  public static MessageDigest getInstance(String algorithm, Provider provider)\n     throws NoSuchAlgorithmException\n   {\n-    if (classname == null)\n-      throw new NoSuchAlgorithmException(algorithm);\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n \n     MessageDigest result = null;\n-    try\n-      {\n-        Object obj = Class.forName(classname).newInstance();\n-        if (obj instanceof MessageDigest) {\n-          result = (MessageDigest) obj;\n-          result.algorithm = algorithm;\n-        } else if (obj instanceof MessageDigestSpi) {\n-          result = new DummyMessageDigest((MessageDigestSpi) obj, algorithm);\n-        } else {\n-          throw new ClassCastException(\"Class \"+classname+\" from Provider \"\n-              +provider.getName()\n-              +\" does not extend java.security.MessageDigestSpi\");\n-        }\n-        result.provider = provider;\n-        return result;\n-      }\n-    catch (ClassNotFoundException cnfe)\n+    Object o = Engine.getInstance(MESSAGE_DIGEST, algorithm, provider);\n+     \n+    if (o instanceof MessageDigestSpi)\n       {\n-\tthrow new NoSuchAlgorithmException(algorithm + \": Class not found.\");\n+\tresult = new DummyMessageDigest((MessageDigestSpi) o, algorithm);\n       }\n-    catch (InstantiationException ie)\n+    else if (o instanceof MessageDigest)\n       {\n-\tthrow new NoSuchAlgorithmException(algorithm\n-\t\t\t\t\t   + \": Class instantiation failed.\");\n+\tresult = (MessageDigest) o;\n+\tresult.algorithm = algorithm;\n       }\n-    catch (IllegalAccessException iae)\n+    else\n       {\n-\tthrow new NoSuchAlgorithmException(algorithm + \": Illegal Access\");\n+        throw new NoSuchAlgorithmException(algorithm);\n       }\n+    result.provider = provider;\n+    return result;\n   }\n \n-\n   /**\n-     Gets the provider that the MessageDigest is from.\n-\n-     @return the provider the this MessageDigest\n+   * Returns the provider of this message digest object.\n+   *\n+   * @return the provider of this message digest object.\n    */\n   public final Provider getProvider()\n   {\n     return provider;\n   }\n \n   /**\n-     Updates the digest with the byte.\n-\n-     @param input byte to update the digest with\n+   * Updates the digest using the specified byte.\n+   *\n+   * @param input the byte with which to update the digest.\n    */\n   public void update(byte input)\n   {\n     engineUpdate(input);\n   }\n \n   /**\n-     Updates the digest with the bytes from the array from the\n-     specified offset to the specified length.\n-\n-     @param input bytes to update the digest with\n-     @param offset the offset to start at\n-     @param len length of the data to update with\n+   * Updates the digest using the specified array of bytes, starting at the\n+   * specified offset.\n+   *\n+   * @param input the array of bytes.\n+   * @param offset the offset to start from in the array of bytes.\n+   * @param len the number of bytes to use, starting at offset.\n    */\n-  public void update(byte[]input, int offset, int len)\n+  public void update(byte[] input, int offset, int len)\n   {\n     engineUpdate(input, offset, len);\n   }\n \n   /**\n-     Updates the digest with the bytes from the array.\n-\n-     @param input bytes to update the digest with\n+   * Updates the digest using the specified array of bytes.\n+   *\n+   * @param input the array of bytes.\n    */\n-  public void update(byte[]input)\n+  public void update(byte[] input)\n   {\n     engineUpdate(input, 0, input.length);\n   }\n \n   /**\n-     Computes the digest of the stored data.\n-\n-     @return a byte array representing the message digest\n+   * Completes the hash computation by performing final operations such as\n+   * padding. The digest is reset after this call is made.\n+   *\n+   * @return the array of bytes for the resulting hash value.\n    */\n   public byte[] digest()\n   {\n     return lastDigest = engineDigest();\n   }\n \n   /**\n-     Computes the final digest of the stored bytes and returns\n-     them. \n-\n-     @param buf An array of bytes to store the digest\n-     @param offset An offset to start storing the digest at\n-     @param len The length of the buffer\n-     @return Returns the length of the buffer\n+   * Completes the hash computation by performing final operations such as\n+   * padding. The digest is reset after this call is made.\n+   *\n+   * @param buf An output buffer for the computed digest.\n+   * @param offset The offset into the output buffer to begin storing the digest.\n+   * @param len The number of bytes within buf allotted for the digest.\n+   * @return The number of bytes placed into buf.\n+   * @throws DigestException if an error occurs.\n    */\n-  public int digest(byte[]buf, int offset, int len) throws DigestException\n+  public int digest(byte[] buf, int offset, int len) throws DigestException\n   {\n     return engineDigest(buf, offset, len);\n   }\n \n   /**\n-     Computes a final update using the input array of bytes,\n-     then computes a final digest and returns it. It calls \n-     update(input) and then digest();\n-\n-     @param input An array of bytes to perform final update with\n-     @return a byte array representing the message digest\n+   * Performs a final update on the digest using the specified array of bytes,\n+   * then completes the digest computation. That is, this method first calls\n+   * <code>update(input)</code>, passing the input array to the <code>update()\n+   * </code> method, then calls <code>digest()</code>.\n+   *\n+   * @param input the input to be updated before the digest is completed.\n+   * @return the array of bytes for the resulting hash value.\n    */\n-  public byte[] digest(byte[]input)\n+  public byte[] digest(byte[] input)\n   {\n     update(input);\n     return digest();\n   }\n \n   /**\n-     Returns a representation of the MessageDigest as a String.\n-\n-     @return a string representing the message digest\n+   * Returns a string representation of this message digest object.\n+   *\n+   * @return a string representation of the object.\n    */\n   public String toString()\n   {\n-    return (getClass()).getName()\n-      + \" Message Digest <\" + digestToString() + \">\";\n+    return (getClass()).getName() + \" Message Digest <\" + digestToString() + \">\";\n   }\n \n   /**\n-     Does a simple byte comparison of the two digests.\n-\n-     @param digesta first digest to compare\n-     @param digestb second digest to compare\n-     @return true if they are equal, false otherwise\n+   * Compares two digests for equality. Does a simple byte compare.\n+   *\n+   * @param digesta one of the digests to compare.\n+   * @param digestb the other digest to compare.\n+   * @return <code>true</code> if the digests are equal, <code>false</code>\n+   * otherwise.\n    */\n-  public static boolean isEqual(byte[]digesta, byte[]digestb)\n+  public static boolean isEqual(byte[] digesta, byte[] digestb)\n   {\n     if (digesta.length != digestb.length)\n       return false;\n@@ -287,48 +330,46 @@ public static boolean isEqual(byte[]digesta, byte[]digestb)\n     return true;\n   }\n \n-\n-  /**\n-     Resets the message digest.\n-   */\n+  /** Resets the digest for further use. */\n   public void reset()\n   {\n     engineReset();\n   }\n \n-  /** \n-     Gets the name of the algorithm currently used.\n-     The names of algorithms are usually SHA-1 or MD5.\n-\n-     @return name of algorithm.\n+  /**\n+   * Returns a string that identifies the algorithm, independent of\n+   * implementation details. The name should be a standard Java Security name\n+   * (such as <code>\"SHA\"</code>, <code>\"MD5\"</code>, and so on). See Appendix\n+   * A in the Java Cryptography Architecture API Specification &amp; Reference\n+   * for information about standard algorithm names.\n+   *\n+   * @return the name of the algorithm.\n    */\n   public final String getAlgorithm()\n   {\n     return algorithm;\n   }\n \n   /**\n-     Gets the length of the message digest.\n-     The default is zero which means that this message digest\n-     does not implement this function.\n-\n-     @return length of the message digest\n+   * Returns the length of the digest in bytes, or <code>0</code> if this\n+   * operation is not supported by the provider and the implementation is not\n+   * cloneable.\n+   *\n+   * @return the digest length in bytes, or <code>0</code> if this operation is\n+   * not supported by the provider and the implementation is not cloneable.\n+   * @since 1.2\n    */\n   public final int getDigestLength()\n   {\n     return engineGetDigestLength();\n   }\n \n   /**\n-     Returns a clone of this class if supported.\n-     If it does not then it throws CloneNotSupportedException.\n-     The cloning of this class depends on whether the subclass\n-     MessageDigestSpi implements Cloneable which contains the\n-     actual implementation of the appropriate algorithm.\n-\n-     @return clone of this class\n-\n-     @exception CloneNotSupportedException this class does not support cloning\n+   * Returns a clone if the implementation is cloneable.\n+   *\n+   * @return a clone if the implementation is cloneable.\n+   * @throws CloneNotSupportedException if this is called on an implementation\n+   * that does not support {@link Cloneable}.\n    */\n   public Object clone() throws CloneNotSupportedException\n   {\n@@ -359,5 +400,4 @@ private String digestToString()\n \n     return buf.toString();\n   }\n-\n }"}, {"sha": "47171cff33cb6cd62767af5573448b5a481b8d37", "filename": "libjava/java/security/Policy.java", "status": "modified", "additions": 227, "deletions": 95, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FPolicy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FPolicy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FPolicy.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* Policy.java --- Policy Manager Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,139 +37,271 @@\n \n package java.security;\n \n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n /**\n-   Policy is an abstract class for managing the system security\n-   policy for the Java application environment. It specifies\n-   which permissions are available for code from various\n-   sources. The security policy is represented through a \n-   subclass of Policy.\n-\n-   Only one Policy is in effect at any time. ProtectionDomain\n-   initializes itself with information from this class on the \n-   set of permssions to grant.\n-\n-   The location for the actual Policy could be anywhere in any\n-   form because it depends on the Policy implementation. The\n-   default system is in a flat ASCII file or it could be in a \n-   database.\n-\n-   The current installed Policy can be accessed with getPolicy\n-   and changed with setPolicy if the code has the correct\n-   permissions.\n-\n-   The refresh method causes the Policy class to refresh/reload\n-   its configuration. The method used to refresh depends on the \n-   Policy implementation.\n-\n-   When a protection domain initializes its permissions it uses\n-   code like:\n-   <code>\n-   policy = Policy.getPolicy();\n-   permissionCollection perms = policy.getPermissions(MyCodeSource)     \n-   </code>\n-   The protection domain passes the Policy handler a CodeSource\n-   object which contains the codebase URL and public key. The \n-   Policy implementation then returns the proper set of \n-   permissions for the CodeSource.\n-\n-   The default Policy implementation can be changed by setting\n-   the \"policy.provider\" security provider in java.security\n-   to the correct Policy implementation class.\n-\n-   @author Mark Benvenuto\n-\n-   @since JDK 1.2\n+ * <p>This is an abstract class for representing the system security policy for\n+ * a Java application environment (specifying which permissions are available\n+ * for code from various sources). That is, the security policy is represented\n+ * by a <code>Policy</code> subclass providing an implementation of the abstract\n+ * methods in this <code>Policy</code> class.</p>\n+ *\n+ * <p>There is only one <code>Policy</code> object in effect at any given time.\n+ * </p>\n+ *\n+ * <p>The source location for the policy information utilized by the\n+ * <code>Policy</code> object is up to the <code>Policy</code> implementation.\n+ * The policy configuration may be stored, for example, as a flat ASCII file, as\n+ * a serialized binary file of the <code>Policy</code> class, or as a database.\n+ * </p>\n+ *\n+ * <p>The currently-installed <code>Policy</code> object can be obtained by\n+ * calling the <code>getPolicy()</code> method, and it can be changed by a call\n+ * to the <code>setPolicy()</code> method (by code with permission to reset the\n+ * <code>Policy</code>).</p>\n+ *\n+ * <p>The <code>refresh()</code> method causes the policy object to refresh /\n+ * reload its current configuration.</p>\n+ *\n+ * <p>This is implementation-dependent. For example, if the policy object stores\n+ * its policy in configuration files, calling <code>refresh()</code> will cause\n+ * it to re-read the configuration policy files. The refreshed policy may not\n+ * have an effect on classes in a particular {@link ProtectionDomain}. This is\n+ * dependent on the <code>Policy</code> provider's implementation of the\n+ * <code>implies()</code> method and the {@link PermissionCollection} caching\n+ * strategy.</p>\n+ *\n+ * <p>The default <code>Policy</code> implementation can be changed by setting\n+ * the value of the <code>\"policy.provider\"</code> security property (in the\n+ * Java security properties file) to the fully qualified name of the desired\n+ * <code>Policy</code> implementation class. The Java security properties file\n+ * is located in the file named <code>&lt;JAVA_HOME>/lib/security/java.security\n+ * </code>, where <code>&lt;JAVA_HOME></code> refers to the directory where the\n+ * SDK was installed.</p>\n+ *\n+ * <p><b>IMPLEMENTATION NOTE:</b> This implementation attempts to read the\n+ * System property named <code>policy.provider</code> to find the concrete\n+ * implementation of the <code>Policy</code>. If/when this fails, it falls back\n+ * to a default implementation, which <b>allows everything</b>.\n+ *\n+ * @author Mark Benvenuto\n+ * @see CodeSource\n+ * @see PermissionCollection\n+ * @see SecureClassLoader\n+ * @since 1.2\n  */\n public abstract class Policy\n {\n-  // FIXME: The class name of the Policy provider should really be sourced \n-  // from the \"java.security\" configuration file. For now, just hard-code \n-  // a stub implementation.\n   static private Policy currentPolicy = null;\n-  static \n-  {\n-    String pp = System.getProperty (\"policy.provider\");\n-    if (pp != null)\n-      try\n-\t{\n-\t  currentPolicy = (Policy)Class.forName(pp).newInstance();\n-\t} \n-      catch (Exception _) \n-\t{\n-\t  currentPolicy = null;\n-\t}\n-    if (currentPolicy == null)\n-      currentPolicy = new gnu.java.security.provider.DefaultPolicy();\n-  }\n-  \n-  /**\n-     Constructs a new Policy class.\n-   */\n+\n+  /** Map of ProtectionDomains to PermissionCollections for this instance. */\n+  private Map pd2pc = null;\n+\n+  /** Constructs a new <code>Policy</code> object. */\n   public Policy()\n   {\n   }\n \n   /**\n-     Gets the currently installed Policy handler. The value should\n-     not be cached as it can be changed by setPolicy. This \n-     function first calls <code>SecurityManager.checkPermission</code>\n-     with <code>SecurityPermission(\"getPolicy\")</code> to check\n-     if the caller has Permission to get the current Policy.\n-\n-     @return the current Policy\n-\n-     @throws SecurityException if the security manager exists\n-     the caller does not have permission to \n-     <code>getPolicy</code>.\n+   * Returns the installed <code>Policy</code> object. This value should not be\n+   * cached, as it may be changed by a call to <code>setPolicy()</code>. This\n+   * method first calls {@link SecurityManager#checkPermission(Permission)} with\n+   * a <code>SecurityPermission(\"getPolicy\")</code> permission to ensure it's ok\n+   * to get the <code>Policy</code> object.\n+   *\n+   * @return the installed <code>Policy</code>.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkPermission()</code> method doesn't allow getting the\n+   * <code>Policy</code> object.\n+   * @see SecurityManager#checkPermission(Permission)\n+   * @see #setPolicy(Policy)\n    */\n   public static Policy getPolicy()\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkPermission(new SecurityPermission(\"getPolicy\"));\n \n-    return currentPolicy;\n+    return getCurrentPolicy();\n   }\n \n   /**\n-     Sets the currently installed Policy handler. This \n-     function first calls <code>SecurityManager.checkPermission</code>\n-     with <code>SecurityPermission(\"setPolicy\")</code> to check\n-     if the caller has Permission to get the current Policy.\n-\n-     @param policy the new Policy to use\n-\n-     @throws SecurityException if the security manager exists\n-     the caller does not have permission to \n-     <code>getPolicy</code>.\n+   * Sets the system-wide <code>Policy</code> object. This method first calls\n+   * {@link SecurityManager#checkPermission(Permission)} with a\n+   * <code>SecurityPermission(\"setPolicy\")</code> permission to ensure it's ok\n+   * to set the <code>Policy</code>.\n+   *\n+   * @param policy the new system <code>Policy</code> object.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkPermission()</code> method doesn't allow setting the\n+   * <code>Policy</code>.\n+   * @see SecurityManager#checkPermission(Permission)\n+   * @see #getPolicy()\n    */\n   public static void setPolicy(Policy policy)\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkPermission(new SecurityPermission(\"setPolicy\"));\n \n+    setup(policy);\n     currentPolicy = policy;\n   }\n \n+  private static void setup(final Policy policy)\n+  {\n+    if (policy.pd2pc == null)\n+      policy.pd2pc = Collections.synchronizedMap(new LinkedHashMap());\n+\n+    ProtectionDomain pd = policy.getClass().getProtectionDomain();\n+    if (pd.getCodeSource() != null)\n+      {\n+        PermissionCollection pc = null;\n+        if (currentPolicy != null)\n+          pc = currentPolicy.getPermissions(pd);\n+\n+        if (pc == null) // assume it has all\n+          {\n+            pc = new Permissions();\n+            pc.add(new AllPermission());\n+          }\n+\n+        policy.pd2pc.put(pd, pc); // add the mapping pd -> pc\n+      }\n+  }\n \n   /**\n-     Evalutes the global policy and returns a set of Permissions \n-     allowed for the specified CodeSource.\n+   * Ensures/forces loading of the configured policy provider, while bypassing\n+   * the {@link SecurityManager} checks for <code>\"getPolicy\"</code> security\n+   * permission.  Needed by {@link ProtectionDomain}.\n+   */\n+  static Policy getCurrentPolicy()\n+  {\n+    // FIXME: The class name of the Policy provider should really be sourced\n+    // from the \"java.security\" configuration file. For now, just hard-code\n+    // a stub implementation.\n+    if (currentPolicy == null)\n+      {\n+        String pp = System.getProperty (\"policy.provider\");\n+        if (pp != null)\n+          try\n+            {\n+              currentPolicy = (Policy) Class.forName(pp).newInstance();\n+            }\n+          catch (Exception ignored) {}\n \n-     @param codesource The CodeSource to get Permission for\n+        if (currentPolicy == null)\n+          currentPolicy = new gnu.java.security.provider.DefaultPolicy();\n+      }\n+    return currentPolicy;\n+  }\n \n-     @return a set of permissions for codesource specified by \n-     the current policy\n+  /**\n+   * Tests if <code>currentPolicy</code> is not <code>null</code>,\n+   * thus allowing clients to not force loading of any policy\n+   * provider; needed by {@link ProtectionDomain}.\n+   */\n+  static boolean isLoaded()\n+  {\n+    return currentPolicy != null;\n+  }\n \n-     @throws SecurityException if the current thread does not\n-     have permission to call <code>getPermissions</code>\n+  /**\n+   * Evaluates the global policy and returns a {@link PermissionCollection}\n+   * object specifying the set of permissions allowed for code from the\n+   * specified code source.\n+   *\n+   * @param codesource the {@link CodeSource} associated with the caller. This\n+   * encapsulates the original location of the code (where the code came from)\n+   * and the public key(s) of its signer.\n+   * @return the set of permissions allowed for code from codesource according\n+   * to the policy. The returned set of permissions must be a new mutable\n+   * instance and it must support heterogeneous {@link Permission} types.\n    */\n   public abstract PermissionCollection getPermissions(CodeSource codesource);\n \n   /**\n-     Refreshes and/or reloads the current Policy. The actual\n-     behavior of this method depends on the implementation. \n+   * Evaluates the global policy and returns a {@link PermissionCollection}\n+   * object specifying the set of permissions allowed given the characteristics\n+   * of the protection domain.\n+   *\n+   * @param domain the {@link ProtectionDomain} associated with the caller.\n+   * @return the set of permissions allowed for the domain according to the\n+   * policy. The returned set of permissions must be a new mutable instance and\n+   * it must support heterogeneous {@link Permission} types.\n+   * @since 1.4\n+   * @see ProtectionDomain\n+   * @see SecureClassLoader\n+   */\n+  public PermissionCollection getPermissions(ProtectionDomain domain)\n+  {\n+    if (domain == null)\n+      return new Permissions();\n+\n+    if (pd2pc == null)\n+      setup(this);\n+\n+    PermissionCollection result = (PermissionCollection) pd2pc.get(domain);\n+    if (result != null)\n+      {\n+        Permissions realResult = new Permissions();\n+        for (Enumeration e = result.elements(); e.hasMoreElements(); )\n+          realResult.add((Permission) e.nextElement());\n+\n+        return realResult;\n+      }\n+\n+    result = getPermissions(domain.getCodeSource());\n+    if (result == null)\n+      result = new Permissions();\n+\n+    PermissionCollection pc = domain.getPermissions();\n+    if (pc != null)\n+      for (Enumeration e = pc.elements(); e.hasMoreElements(); )\n+        result.add((Permission) e.nextElement());\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Evaluates the global policy for the permissions granted to the {@link\n+   * ProtectionDomain} and tests whether the <code>permission</code> is granted.\n+   *\n+   * @param domain the {@link ProtectionDomain} to test.\n+   * @param permission the {@link Permission} object to be tested for\n+   * implication.\n+   * @return <code>true</code> if <code>permission</code> is a proper subset of\n+   * a permission granted to this {@link ProtectionDomain}.\n+   * @since 1.4\n+   * @see ProtectionDomain\n+   */\n+  public boolean implies(ProtectionDomain domain, Permission permission)\n+  {\n+    if (pd2pc == null)\n+      setup(this);\n+\n+    PermissionCollection pc = (PermissionCollection) pd2pc.get(domain);\n+    if (pc != null)\n+      return pc.implies(permission);\n+\n+    boolean result = false;\n+    pc = getPermissions(domain);\n+    if (pc != null)\n+      {\n+        result = pc.implies(permission);\n+        pd2pc.put(domain, pc);\n+      }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Refreshes/reloads the policy configuration. The behavior of this method\n+   * depends on the implementation. For example, calling refresh on a file-based\n+   * policy will cause the file to be re-read.\n    */\n   public abstract void refresh();\n }"}, {"sha": "21d9b6d09b4689d5ba68f9c57f30b0e63e1ab979", "filename": "libjava/java/security/ProtectionDomain.java", "status": "modified", "additions": 181, "deletions": 56, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FProtectionDomain.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FProtectionDomain.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FProtectionDomain.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* ProtectionDomain.java -- A security domain\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2003, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,107 +38,232 @@\n package java.security;\n \n /**\n- * This class represents a group of classes, along with the permissions\n- * they are granted.  The classes are identified by a <code>CodeSource</code>.\n- * Thus, any class loaded from the specified <code>CodeSource</code> is\n- * treated as part of this domain.  The set of permissions is represented\n- * by a <code>PermissionCollection</code>.\n- * <p>\n- * Every class in the system will belong to one and only one\n- * <code>ProtectionDomain</code>.\n+ * <p>This <code>ProtectionDomain</code> class encapsulates the characteristics\n+ * of a domain, which encloses a set of classes whose instances are granted a\n+ * set of permissions when being executed on behalf of a given set of\n+ * <i>Principals</i>.\n  *\n- * @version 0.0\n+ * <p>A static set of permissions can be bound to a <code>ProtectionDomain</code>\n+ * when it is constructed; such permissions are granted to the domain regardless\n+ * of the {@link Policy} in force. However, to support dynamic security\n+ * policies, a <code>ProtectionDomain</code> can also be constructed such that\n+ * it is dynamically mapped to a set of permissions by the current {@link\n+ * Policy} whenever a permission is checked.</p>\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @version 0.0\n  */\n public class ProtectionDomain\n {\n-  /**\n-   * This is the <code>CodeSource</code> for this protection domain\n-   */\n+  /** This is the <code>CodeSource</code> for this protection domain. */\n   private CodeSource code_source;\n \n+  /** This is the set of permissions granted to this domain. */\n+  private PermissionCollection perms;\n+\n+  /** The {@link ClassLoader} associated with this domain. */\n+  private ClassLoader classloader;\n+\n+  /** The array of Principals associated with this domain.. */\n+  private Principal[] principals;\n+\n+  /** Post 1.4 the policy may be refreshed! use false for pre 1.4. */\n+  private boolean staticBinding;\n+\n   /**\n-   * This is the set of permissions granted to this domain\n+   * Creates a new <code>ProtectionDomain</code> with the given {@link\n+   * CodeSource} and {@link Permissions}. If the permissions object is not\n+   * <code>null</code>, then <code>setReadOnly()</code> will be called on the\n+   * passed in {@link Permissions} object. The only permissions granted to this\n+   * domain are the ones specified; the current {@link Policy} will not be\n+   * consulted.\n+   *\n+   * @param codesource the codesource associated with this domain.\n+   * @param permissions the permissions granted to this domain\n    */\n-  private PermissionCollection perms;\n+  public ProtectionDomain(CodeSource codesource, PermissionCollection permissions)\n+  {\n+    this(codesource, permissions, null, null, false);\n+  }\n \n   /**\n-   * This method initializes a new instance of <code>ProtectionDomain</code>\n-   * representing the specified <code>CodeSource</code> and permission set.\n-   * No permissions may be added to the <code>PermissionCollection</code>\n-   * and this contructor will call the <code>setReadOnly</code> method on\n-   * the specified permission set.\n+   * <p>Creates a new ProtectionDomain qualified by the given CodeSource,\n+   * Permissions, ClassLoader and array of Principals. If the permissions\n+   * object is not null, then <code>setReadOnly()</code> will be called on the\n+   * passed in Permissions object. The permissions granted to this domain are\n+   * dynamic; they include both the static permissions passed to this\n+   * constructor, and any permissions granted to this domain by the current\n+   * Policy at the time a permission is checked.</p>\n    *\n-   * @param code_source The <code>CodeSource</code> for this domain\n-   * @param perms The permission set for this domain\n+   * <p>This constructor is typically used by {@link ClassLoader}s and {@link\n+   * DomainCombiner}s which delegate to <code>Policy</code> to actively\n+   * associate the permissions granted to this domain. This constructor affords\n+   * the Policy provider the opportunity to augment the supplied\n+   * PermissionCollection to reflect policy changes.</p>\n    *\n-   * @see java.security.PermissionCollection#setReadOnly()\n-   */\n-  public ProtectionDomain(CodeSource code_source, PermissionCollection perms)\n+   * @param codesource the CodeSource associated with this domain.\n+   * @param permissions the permissions granted to this domain.\n+   * @param classloader the ClassLoader associated with this domain.\n+   * @param principals the array of Principals associated with this domain.\n+   * @since 1.4\n+   * @see Policy#refresh()\n+   * @see Policy#getPermissions(ProtectionDomain)\n+  */\n+  public ProtectionDomain(CodeSource codesource,\n+                          PermissionCollection permissions,\n+                          ClassLoader classloader, Principal[] principals)\n   {\n-    this.code_source = code_source;\n-    this.perms = perms;\n-    if (perms != null)\n-      perms.setReadOnly();\n+    this(codesource, permissions, classloader, principals, false);\n+  }\n+\n+  private ProtectionDomain(CodeSource codesource,\n+                           PermissionCollection permissions,\n+                           ClassLoader classloader, Principal[] principals,\n+                           boolean staticBinding)\n+  {\n+    super();\n+\n+    code_source = codesource;\n+    if (permissions != null)\n+      {\n+        perms = permissions;\n+        perms.setReadOnly();\n+      }\n+\n+    this.classloader = classloader;\n+    this.principals =\n+        (principals != null ? (Principal[]) principals.clone() : new Principal[0]);\n+    this.staticBinding = staticBinding;\n   }\n \n   /**\n-     * This method returns the <code>CodeSource</code> for this domain.\n-     *\n-     * @return This domain's <code>CodeSource</code>.\n+   * Returns the {@link CodeSource} of this domain.\n+   *\n+   * @return the {@link CodeSource} of this domain which may be <code>null</code>.\n+   * @since 1.2\n    */\n   public final CodeSource getCodeSource()\n   {\n     return code_source;\n   }\n \n   /**\n-   * This method returns the set of permissions granted to this domain.\n+   * Returns the {@link ClassLoader} of this domain.\n    *\n-   * @return The permission set for this domain\n+   * @return the {@link ClassLoader} of this domain which may be\n+   * <code>null</code>.\n+   * @since 1.4\n+   */\n+  public final ClassLoader getClassLoader()\n+  {\n+    return this.classloader;\n+  }\n+\n+  /**\n+   * Returns an array of principals for this domain.\n+   *\n+   * @return returns a non-null array of principals for this domain. Changes to\n+   * this array will have no impact on the <code>ProtectionDomain</code>.\n+   * @since 1.4\n+   */\n+  public final Principal[] getPrincipals()\n+  {\n+    return (Principal[]) principals.clone();\n+  }\n+\n+  /**\n+   * Returns the static permissions granted to this domain.\n+   *\n+   * @return the static set of permissions for this domain which may be\n+   * <code>null</code>.\n+   * @see Policy#refresh()\n+   * @see Policy#getPermissions(ProtectionDomain)\n    */\n   public final PermissionCollection getPermissions()\n   {\n     return perms;\n   }\n \n   /**\n-   * This method tests whether or not the specified <code>Permission</code> is\n-   * implied by the set of permissions granted to this domain.\n+   * <p>Check and see if this <code>ProtectionDomain</code> implies the\n+   * permissions expressed in the <code>Permission</code> object.</p>\n+   *\n+   * <p>The set of permissions evaluated is a function of whether the\n+   * <code>ProtectionDomain</code> was constructed with a static set of\n+   * permissions or it was bound to a dynamically mapped set of permissions.</p>\n    *\n-   * @param perm The <code>Permission</code> to test.\n+   * <p>If the <code>ProtectionDomain</code> was constructed to a statically\n+   * bound {@link PermissionCollection} then the permission will only be checked\n+   * against the {@link PermissionCollection} supplied at construction.</p>\n    *\n-   * @return <code>true</code> if the specified <code>Permission</code> is implied for this domain, <code>false</code> otherwise.\n+   * <p>However, if the <code>ProtectionDomain</code> was constructed with the\n+   * constructor variant which supports dynamically binding permissions, then\n+   * the permission will be checked against the combination of the\n+   * {@link PermissionCollection} supplied at construction and the current\n+   * {@link Policy} binding.\n+   *\n+   * @param permission the {@link Permission} object to check.\n+   * @return <code>true</code> if <code>permission</code> is implicit to this\n+   * <code>ProtectionDomain</code>.\n    */\n-  public boolean implies(Permission perm)\n+  public boolean implies(Permission permission)\n   {\n-    PermissionCollection pc = getPermissions();\n-    if (pc == null)\n-      return (false);\n-\n-    return (pc.implies(perm));\n+    if (staticBinding)\n+      return (perms == null ? false : perms.implies(permission));\n+    // Else dynamically bound.  Do we have it?\n+    // NOTE: this will force loading of Policy.currentPolicy\n+    return Policy.getCurrentPolicy().implies(this, permission);\n   }\n \n   /**\n-   * This method returns a <code>String</code> representation of this\n-   * object.  It will print the <code>CodeSource</code> and \n-   * permission set associated with this domain.\n+   * Convert a <code>ProtectionDomain</code> to a String.\n    *\n-   * @return A <code>String</code> representation of this object.\n+   * @return a string representation of the object.\n    */\n   public String toString()\n   {\n     String linesep = System.getProperty(\"line.separator\");\n-    StringBuffer sb = new StringBuffer(\"\");\n-    sb.append(\"ProtectionDomain (\" + linesep);\n+    StringBuffer sb = new StringBuffer(\"ProtectionDomain (\").append(linesep);\n+\n     if (code_source == null)\n-      sb.append(\"CodeSource:null\" + linesep);\n+      sb.append(\"CodeSource:null\");\n+    else\n+      sb.append(code_source);\n+\n+    sb.append(linesep);\n+    if (classloader == null)\n+      sb.append(\"ClassLoader:null\");\n     else\n-      sb.append(code_source + linesep);\n-    sb.append(perms);\n-    sb.append(linesep + \")\" + linesep);\n-    \n-    return sb.toString();\n+      sb.append(classloader);\n+\n+    sb.append(linesep);\n+    sb.append(\"Principals:\");\n+    if (principals != null && principals.length > 0)\n+      {\n+        sb.append(\"[\");\n+        Principal pal;\n+        for (int i = 0; i < principals.length; i++)\n+          {\n+            pal = principals[i];\n+            sb.append(\"'\").append(pal.getName())\n+                .append(\"' of type \").append(pal.getClass().getName());\n+            if (i < principals.length-1)\n+              sb.append(\", \");\n+          }\n+        sb.append(\"]\");\n+      }\n+    else\n+      sb.append(\"none\");\n+\n+    sb.append(linesep);\n+    if (!staticBinding) // include all but dont force loading Policy.currentPolicy\n+      if (Policy.isLoaded())\n+        sb.append(Policy.getCurrentPolicy().getPermissions(this));\n+      else // fallback on this one's permissions\n+        sb.append(perms);\n+    else\n+      sb.append(perms);\n+\n+    return sb.append(linesep).append(\")\").append(linesep).toString();\n   }\n }"}, {"sha": "5cd3cae679dc06c934f4c2a3d240909cc96f9f52", "filename": "libjava/java/security/SecureRandom.java", "status": "modified", "additions": 93, "deletions": 124, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSecureRandom.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSecureRandom.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSecureRandom.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -42,14 +42,24 @@\n import java.util.Enumeration;\n \n /**\n-   SecureRandom is the class interface for using SecureRandom\n-   providers. It provides an interface to the SecureRandomSpi\n-   engine so that programmers can generate pseudo-random numbers.\n-\n-   @author Mark Benvenuto <ivymccough@worldnet.att.net>\n+ * An interface to a cryptographically secure pseudo-random number\n+ * generator (PRNG). Random (or at least unguessable) numbers are used\n+ * in all areas of security and cryptography, from the generation of\n+ * keys and initialization vectors to the generation of random padding\n+ * bytes.\n+ *\n+ * @author Mark Benvenuto <ivymccough@worldnet.att.net>\n+ * @author Casey Marshall\n  */\n public class SecureRandom extends Random\n {\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** Service name for PRNGs. */\n+  private static final String SECURE_RANDOM = \"SecureRandom\";\n+\n   static final long serialVersionUID = 4940670005562187L;\n \n   //Serialized Field\n@@ -60,6 +70,9 @@ public class SecureRandom extends Random\n   SecureRandomSpi secureRandomSpi = null;\n   byte[] state = null;\n \n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n   /**\n      Default constructor for SecureRandom. It constructs a \n      new SecureRandom by instantating the first SecureRandom \n@@ -69,7 +82,7 @@ public class SecureRandom extends Random\n      on the first call to getnextBytes it will force a seed.\n \n      It is maintained for backwards compatibility and programs\n-     should use getInstance.\n+     should use {@link #getInstance(java.lang.String)}.\n    */\n   public SecureRandom()\n   {\n@@ -88,20 +101,20 @@ public SecureRandom()\n           {\n             key = (String) e.nextElement();\n             if (key.startsWith(\"SECURERANDOM.\"))\n-\t      {\n-\t\tif ((classname = p[i].getProperty(key)) != null)\n-\t\t  {\n-\t\t    try\n-\t\t      {\n-\t\t\tsecureRandomSpi = (SecureRandomSpi) Class.\n-\t\t\t  forName(classname).newInstance();\n-\t\t\tprovider = p[i];\n-\t\t\treturn;\n-\t\t      }\n-\t\t    catch (Throwable ignore) { }\n-\t\t  }\n-\t      }\n-\t  }\n+              {\n+                if ((classname = p[i].getProperty(key)) != null)\n+                  {\n+                    try\n+                      {\n+                        secureRandomSpi = (SecureRandomSpi) Class.\n+                          forName(classname).newInstance();\n+                        provider = p[i];\n+                        return;\n+                      }\n+                    catch (Throwable ignore) { }\n+                  }\n+              }\n+          }\n       }\n \n     // Nothing found. Fall back to SHA1PRNG\n@@ -141,49 +154,58 @@ protected SecureRandom(SecureRandomSpi secureRandomSpi, Provider provider)\n     this.provider = provider;\n   }\n \n-  /**\n-     Returns an instance of a SecureRandom. It creates the class\n-     for the specified algorithm if it exists from a provider.\n-\n-     @param algorithm A SecureRandom algorithm to use\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n \n-     @return Returns a new SecureRandom implmenting the chosen algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm cannot be found\n+  /**\n+   * Returns an instance of a SecureRandom. It creates the class from\n+   * the first provider that implements it.\n+   *\n+   * @param algorithm The algorithm name.\n+   * @return A new SecureRandom implmenting the given algorithm.\n+   * @throws NoSuchAlgorithmException If no installed provider implements\n+   *         the given algorithm.\n    */\n   public static SecureRandom getInstance(String algorithm) throws\n     NoSuchAlgorithmException\n   {\n     Provider p[] = Security.getProviders();\n     for (int i = 0; i < p.length; i++)\n       {\n-\ttry\n-\t  {\n-\t    return getInstance(algorithm, p[i]);\n-\t  }\n-\tcatch (NoSuchAlgorithmException ignored) { }\n+        try\n+          {\n+            return getInstance(algorithm, p[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignored)\n+          {\n+          }\n       }\n \n     // None found.\n     throw new NoSuchAlgorithmException(algorithm);\n   }\n \n   /**\n-     Returns an instance of a SecureRandom. It creates the class\n-     for the specified algorithm from the specified provider.\n-\n-     @param algorithm A SecureRandom algorithm to use\n-     @param provider A security provider to use\n-\n-     @return Returns a new SecureRandom implmenting the chosen algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm cannot be found\n-     @throws NoSuchProviderException if the provider cannot be found\n+   * Returns an instance of a SecureRandom. It creates the class\n+   * for the specified algorithm from the named provider.\n+   *\n+   * @param algorithm The algorithm name.\n+   * @param provider  The provider name.\n+   * @return A new SecureRandom implmenting the chosen algorithm.\n+   * @throws NoSuchAlgorithmException If the named provider does not implement\n+   *         the algorithm, or if the implementation cannot be\n+   *         instantiated.\n+   * @throws NoSuchProviderException If no provider named\n+   *         <code>provider</code> is currently installed.\n+   * @throws IllegalArgumentException If <code>provider</code> is null\n+   *         or is empty.\n    */\n-  public static SecureRandom getInstance(String algorithm,\n-\t\t\t\t\t String provider) throws\n-    NoSuchAlgorithmException, NoSuchProviderException\n+  public static SecureRandom getInstance(String algorithm, String provider)\n+  throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n+    if (provider == null || provider.length() == 0)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n+\n     Provider p = Security.getProvider(provider);\n     if (p == null)\n       throw new NoSuchProviderException();\n@@ -192,88 +214,35 @@ public static SecureRandom getInstance(String algorithm,\n   }\n \n   /**\n-     Returns an instance of a SecureRandom. It creates the class for\n-     the specified algorithm from the given provider.\n-\n-     @param algorithm The SecureRandom algorithm to create.\n-     @param provider  The provider to get the instance from.\n-\n-     @throws NoSuchAlgorithmException If the algorithm cannot be found, or\n-             if the class cannot be instantiated.\n+   * Returns an instance of a SecureRandom. It creates the class for\n+   * the specified algorithm from the given provider.\n+   *\n+   * @param algorithm The SecureRandom algorithm to create.\n+   * @param provider  The provider to get the instance from.\n+   * @throws NoSuchAlgorithmException If the algorithm cannot be found, or\n+   *         if the class cannot be instantiated.\n+   * @throws IllegalArgumentException If <code>provider</code> is null.\n    */\n-  public static SecureRandom getInstance(String algorithm,\n-                                         Provider provider) throws\n-    NoSuchAlgorithmException\n+  public static SecureRandom getInstance(String algorithm, Provider provider)\n+  throws NoSuchAlgorithmException\n   {\n-    return getInstance(algorithm, provider, true);\n-  }\n-\n-  /**\n-     Creates the instance of SecureRandom, recursing to resolve aliases.\n-\n-     @param algorithm The SecureRandom algorithm to create.\n-     @param provider  The provider to get the implementation from.\n-     @param recurse   Whether or not to recurse to resolve aliases.\n-\n-     @throws NoSuchAlgorithmException If the algorithm cannot be found,\n-             if there are too many aliases, or if the class cannot be\n-             instantiated.\n-   */\n-  private static SecureRandom getInstance(String algorithm,\n-                                          Provider provider,\n-                                          boolean recurse)\n-    throws NoSuchAlgorithmException\n-  {\n-    String msg = algorithm;\n-    for (Enumeration e = provider.propertyNames(); e.hasMoreElements(); )\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n+    try\n       {\n-        // We could replace the boolean with an integer, incrementing it\n-        // every\n-        String key = (String) e.nextElement();\n-        if (key.startsWith(\"SECURERANDOM.\")\n-            && key.substring(13).equalsIgnoreCase(algorithm))\n-\t  {\n-\t    try\n-\t      {\n-\t\tClass c = Class.forName(provider.getProperty(key));\n-\t\treturn new SecureRandom((SecureRandomSpi) c.newInstance(),\n-\t\t\t\t\tprovider);\n-\t      }\n-\t    catch (Throwable ignored) { }\n-\t  }\n-\telse if (key.startsWith(\"ALG.ALIAS.SECURERANDOM.\")\n-\t\t && key.substring(23).equalsIgnoreCase(algorithm) && recurse)\n-\t  {\n-\t    try\n-\t      {\n-\t\t// First see if this alias refers to a class in this\n-\t\t// provider.\n-\t\treturn getInstance(provider.getProperty(key), provider, false);\n-\t      }\n-\t    catch (NoSuchAlgorithmException nsae)\n-\t      {\n-\t\tProvider[] provs = Security.getProviders();\n-\t\tfor (int i = 0; i < provs.length; i++)\n-\t\t  {\n-\t\t    if (provs[i] == provider)\n-\t\t      continue;\n-\t\t    // Now try other providers for the implementation\n-\t\t    try\n-\t\t      {\n-\t\t\treturn getInstance(provider.getProperty(key),\n-\t\t\t\t\t   provs[i], false);\n-\t\t      }\n-\t\t    catch (NoSuchAlgorithmException nsae2)\n-\t\t      {\n-\t\t\tmsg = nsae2.getMessage();\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n+        return new SecureRandom((SecureRandomSpi)\n+          Engine.getInstance(SECURE_RANDOM, algorithm, provider),\n+          provider);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n       }\n-    throw new NoSuchAlgorithmException(algorithm);\n   }\n \n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n   /**\n      Returns the provider being used by the current SecureRandom class.\n \n@@ -318,8 +287,8 @@ public void setSeed(long seed)\n \t\t       (byte) (0xff & (seed >> 16)),\n \t\t       (byte) (0xff & (seed >> 8)),\n \t\t       (byte) (0xff & seed)\n-\t};\n-\tsecureRandomSpi.engineSetSeed(tmp);\n+        };\n+        secureRandomSpi.engineSetSeed(tmp);\n       }\n   }\n "}, {"sha": "2b2ac392b3ca4b668869d5a587ff0a1b8bce8813", "filename": "libjava/java/security/Security.java", "status": "modified", "additions": 493, "deletions": 128, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSecurity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSecurity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSecurity.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* Security.java --- Java base security class implmentation\n-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001, 2002, 2003, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,28 +36,35 @@\n exception statement from your version. */\n \n package java.security;\n-import java.io.File;\n+\n+import java.io.FileNotFoundException;\n import java.io.InputStream;\n import java.io.IOException;\n-import java.io.FileNotFoundException;\n import java.net.URL;\n import java.security.Provider;\n-import java.util.Vector;\n+import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n import java.util.Properties;\n+import java.util.Set;\n+import java.util.Vector;\n \n /**\n-   Security class that loads the Providers and provides an \n-   interface to security properties.\n-\n-   @author Mark Benvenuto <ivymccough@worldnet.att.net>\n+ * This class centralizes all security properties and common security methods.\n+ * One of its primary uses is to manage providers.\n+ *\n+ * @author Mark Benvenuto <ivymccough@worldnet.att.net>\n  */\n-\n public final class Security extends Object\n {\n+  private static final String ALG_ALIAS = \"Alg.Alias.\";\n+\n   private static Vector providers = new Vector();\n   private static Properties secprops;\n-\n   static\n   {\n     String base = System.getProperty(\"gnu.classpath.home.url\");\n@@ -76,7 +83,6 @@ private static void loadProviders(String baseUrl, String vendor)\n       return;\n \n     String secfilestr = baseUrl + \"/security/\" + vendor + \".security\";\n-\n     try\n       {\n \tInputStream fin = new URL(secfilestr).openStream();\n@@ -85,12 +91,9 @@ private static void loadProviders(String baseUrl, String vendor)\n \n \tint i = 1;\n \tString name;\n-\n-\twhile ((name = secprops.getProperty(\"security.provider.\" + i)) !=\n-\t       null)\n+\twhile ((name = secprops.getProperty(\"security.provider.\" + i)) != null)\n \t  {\n \t    Exception exception = null;\n-\n \t    try\n \t      {\n \t\tproviders.addElement(Class.forName(name).newInstance());\n@@ -107,15 +110,16 @@ private static void loadProviders(String baseUrl, String vendor)\n \t      {\n \t        exception = x;\n \t      }\n+\n \t    if (exception != null)\n-\t      System.err.println (\"Error loading security provider \" + name\n-\t                          + \": \" + exception);\n+\t      System.err.println (\n+\t          \"Error loading security provider \" + name + \": \" + exception);\n \t    i++;\n \t  }\n       }\n     catch (FileNotFoundException ignored)\n       {\n-        // Actually we probibly shouldn't ignore these, once the security\n+        // Actually we probably shouldn't ignore these, once the security\n \t// properties file is actually installed somewhere.\n       }\n     catch (IOException ignored)\n@@ -124,57 +128,78 @@ private static void loadProviders(String baseUrl, String vendor)\n   }\n \n   /**\n-     Gets a specific property for an algorithm. This is used to produce\n-     specialized algorithm parsers.\n-\n-     @deprecated it used to a return the value of a propietary property\n-     for the \"SUN\" Cryptographic Service Provider to obtain \n-     algorithm-specific parameters. Used AlogorithmParameters and \n-     KeyFactory instead.\n-\n-     @param algName name of algorithm to get property of \n-     @param propName name of property to check\n-\n-     @return a string containing the value of the property\n+   * Gets a specified property for an algorithm. The algorithm name should be a\n+   * standard name. See Appendix A in the Java Cryptography Architecture API\n+   * Specification &amp; Reference for information about standard algorithm\n+   * names. One possible use is by specialized algorithm parsers, which may map\n+   * classes to algorithms which they understand (much like {@link Key} parsers\n+   * do).\n+   *\n+   * @param algName the algorithm name.\n+   * @param propName the name of the property to get.\n+   * @return the value of the specified property.\n+   * @deprecated This method used to return the value of a proprietary property\n+   * in the master file of the \"SUN\" Cryptographic Service Provider in order to\n+   * determine how to parse algorithm-specific parameters. Use the new\n+   * provider-based and algorithm-independent {@link AlgorithmParameters} and\n+   * {@link KeyFactory} engine classes (introduced in the Java 2 platform)\n+   * instead.\n    */\n   public static String getAlgorithmProperty(String algName, String propName)\n   {\n-    /* TODO: Figure out what this actually does */\n+    if (algName == null || propName == null)\n+      return null;\n+\n+    String property = String.valueOf(propName) + \".\" + String.valueOf(algName);\n+    Provider p;\n+    for (Iterator i = providers.iterator(); i.hasNext(); )\n+      {\n+        p = (Provider) i.next();\n+        for (Iterator j = p.keySet().iterator(); j.hasNext(); )\n+          {\n+            String key = (String) j.next();\n+            if (key.equalsIgnoreCase(property))\n+              return p.getProperty(key);\n+          }\n+      }\n     return null;\n   }\n \n   /**\n-     Adds a new provider, at a specified position. The position is the\n-     preference order in which providers are searched for requested algorithms.\n-     Note that it is not guaranteed that this preference will be respected. The\n-     position is 1-based, that is, 1 is most preferred, followed by 2, and so\n-     on.\n-     <p>\n-     If the given provider is installed at the requested position, the\n-     provider that used to be at that position, and all providers with a\n-     position greater than position, are shifted up one position (towards the\n-     end of the list of installed providers).\n-     <p>\n-     A provider cannot be added if it is already installed.\n-     <p>\n-     <b>NOT IMPLEMENTED YET:</b>[\n-     First, if there is a security manager, its <code>checkSecurityAccess</code>\n-     method is called with the string\n-     <code>\"insertProvider.\"+provider.getName()</code>\n-     to see if it's ok to add a new provider. If the default implementation of\n-     <code>checkSecurityAccess</code> is used (i.e., that method is not\n-     overriden), then this will result in a call to the security manager's\n-     <code>checkPermission</code> method with a <code>SecurityPermission(\n-     \"insertProvider.\"+provider.getName())</code> permission.]\n-\n-     @param provider the provider to be added.\n-     @param position the preference position that the caller would like for\n-     this provider.\n-     @return the actual preference position (1-based) in which the provider was\n-     added, or -1 if the provider was not added because it is already installed.\n-     @throws SecurityException if a security manager exists and its <code>\n-     SecurityManager.checkSecurityAccess(java.lang.String)</code> method denies\n-     access to add a new provider.\n+   * <p>Adds a new provider, at a specified position. The position is the\n+   * preference order in which providers are searched for requested algorithms.\n+   * Note that it is not guaranteed that this preference will be respected. The\n+   * position is 1-based, that is, <code>1</code> is most preferred, followed by\n+   * <code>2</code>, and so on.</p>\n+   *\n+   * <p>If the given provider is installed at the requested position, the\n+   * provider that used to be at that position, and all providers with a\n+   * position greater than position, are shifted up one position (towards the\n+   * end of the list of installed providers).</p>\n+   *\n+   * <p>A provider cannot be added if it is already installed.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with the string <code>\"insertProvider.\"+provider.\n+   * getName()</code> to see if it's ok to add a new provider. If the default\n+   * implementation of <code>checkSecurityAccess()</code> is used (i.e., that\n+   * method is not overriden), then this will result in a call to the security\n+   * manager's <code>checkPermission()</code> method with a\n+   * <code>SecurityPermission(\"insertProvider.\"+provider.getName())</code>\n+   * permission.</p>\n+   *\n+   * @param provider the provider to be added.\n+   * @param position the preference position that the caller would like for\n+   * this provider.\n+   * @return the actual preference position in which the provider was added, or\n+   * <code>-1</code> if the provider was not added because it is already\n+   * installed.\n+   * @throws SecurityException if a security manager exists and its\n+   * {@link SecurityManager#checkSecurityAccess(String)} method denies access\n+   * to add a new provider.\n+   * @see #getProvider(String)\n+   * @see #removeProvider(String)\n+   * @see SecurityPermission\n    */\n   public static int insertProviderAt(Provider provider, int position)\n   {\n@@ -186,8 +211,7 @@ public static int insertProviderAt(Provider provider, int position)\n     int max = providers.size ();\n     for (int i = 0; i < max; i++)\n       {\n-\tif (((Provider) providers.elementAt(i)).getName() ==\n-\t    provider.getName())\n+\tif (((Provider) providers.elementAt(i)).getName() == provider.getName())\n \t  return -1;\n       }\n \n@@ -201,53 +225,64 @@ public static int insertProviderAt(Provider provider, int position)\n     return position + 1;\n   }\n \n-\n   /**\n-     Adds a provider to the next position available.\n-     <p>\n-     <b>NOT IMPLEMENTED YET:</b> [\n-     First, if there is a security manager, its <code>checkSecurityAccess</code>\n-     method is called with the string\n-     <code>\"insertProvider.\"+provider.getName()</code>\n-     to see if it's ok to add a new provider. If the default implementation of\n-     <code>checkSecurityAccess</code> is used (i.e., that method is not\n-     overriden), then this will result in a call to the security manager's\n-     <code>checkPermission</code> method with a <code>SecurityPermission(\n-     \"insertProvider.\"+provider.getName())</code> permission.]\n-\n-     @param provider the provider to be added.\n-     @return the preference position in which the provider was added, or <code>\n-     -1</code> if the provider was not added because it is already installed.\n-     @throws SecurityException if a security manager exists and its <code>\n-     SecurityManager.checkSecurityAccess(java.lang.String)</code> method denies\n-     access to add a new provider.\n+   * <p>Adds a provider to the next position available.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with the string <code>\"insertProvider.\"+provider.\n+   * getName()</code> to see if it's ok to add a new provider. If the default\n+   * implementation of <code>checkSecurityAccess()</code> is used (i.e., that\n+   * method is not overriden), then this will result in a call to the security\n+   * manager's <code>checkPermission()</code> method with a\n+   * <code>SecurityPermission(\"insertProvider.\"+provider.getName())</code>\n+   * permission.</p>\n+   *\n+   * @param provider the provider to be added.\n+   * @return the preference position in which the provider was added, or\n+   * <code>-1</code> if the provider was not added because it is already\n+   * installed.\n+   * @throws SecurityException if a security manager exists and its\n+   * {@link SecurityManager#checkSecurityAccess(String)} method denies access\n+   * to add a new provider.\n+   * @see #getProvider(String)\n+   * @see #removeProvider(String)\n+   * @see SecurityPermission\n    */\n   public static int addProvider(Provider provider)\n   {\n     return insertProviderAt (provider, providers.size () + 1);\n   }\n \n   /**\n-     Removes a provider. This allows dynamic unloading\n-     of providers. It will automatically shift up providers to a higher\n-     ranking. If the provider is not installed, it fails silently.\n-\n-     This method checks the security manager with the call checkSecurityAccess\n-     with \"removeProvider.\"+provider.getName() to see if the user can remove\n-     this provider.\n-\n-     @param name name of the provider to add\n-\n-     @throws SecurityException - if the security manager denies access to\n-     remove a new provider\n+   * <p>Removes the provider with the specified name.</p>\n+   *\n+   * <p>When the specified provider is removed, all providers located at a\n+   * position greater than where the specified provider was are shifted down\n+   * one position (towards the head of the list of installed providers).</p>\n+   *\n+   * <p>This method returns silently if the provider is not installed.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with the string <code>\"removeProvider.\"+name</code>\n+   * to see if it's ok to remove the provider. If the default implementation of\n+   * <code>checkSecurityAccess()</code> is used (i.e., that method is not\n+   * overriden), then this will result in a call to the security manager's\n+   * <code>checkPermission()</code> method with a <code>SecurityPermission(\n+   * \"removeProvider.\"+name)</code> permission.</p>\n+   *\n+   * @param name the name of the provider to remove.\n+   * @throws SecurityException if a security manager exists and its\n+   * {@link SecurityManager#checkSecurityAccess(String)} method denies access\n+   * to remove the provider.\n+   * @see #getProvider(String)\n+   * @see #addProvider(Provider)\n    */\n   public static void removeProvider(String name)\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkSecurityAccess(\"removeProvider.\" + name);\n \n-    Provider p = null;\n     int max = providers.size ();\n     for (int i = 0; i < max; i++)\n       {\n@@ -260,10 +295,10 @@ public static void removeProvider(String name)\n   }\n \n   /**\n-     Returns array containing all the providers. It is in the preference order \n-     of the providers.\n-\n-     @return an array of installed providers\n+   * Returns an array containing all the installed providers. The order of the\n+   * providers in the array is their preference order.\n+   *\n+   * @return an array of all the installed providers.\n    */\n   public static Provider[] getProviders()\n   {\n@@ -273,12 +308,13 @@ public static Provider[] getProviders()\n   }\n \n   /**\n-     Returns the provider with the specified name. It will return null \n-     if the provider cannot be found. \n-\n-     @param name name of the requested provider\n-\n-     @return requested provider\n+   * Returns the provider installed with the specified name, if any. Returns\n+   * <code>null</code> if no provider with the specified name is installed.\n+   *\n+   * @param name the name of the provider to get.\n+   * @return the provider of the specified name.\n+   * @see #removeProvider(String)\n+   * @see #addProvider(Provider)\n    */\n   public static Provider getProvider(String name)\n   {\n@@ -294,17 +330,20 @@ public static Provider getProvider(String name)\n   }\n \n   /**\n-     Gets the value of a security property.\n-\n-     This method checks the security manager with the call checkSecurityAccess\n-     with \"getProperty.\"+key to see if the user can get this property.\n-\n-     @param key property to get\n-\n-     @return value of the property      \n-\n-     @throws SecurityException - if the security manager denies access to \n-     getting a property\n+   * <p>Gets a security property value.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkPermission()</code>\n+   * method is called with a <code>SecurityPermission(\"getProperty.\"+key)</code>\n+   * permission to see if it's ok to retrieve the specified security property\n+   * value.</p>\n+   *\n+   * @param key the key of the property being retrieved.\n+   * @return the value of the security property corresponding to key.\n+   * @throws SecurityException if a security manager exists and its\n+   * {@link SecurityManager#checkPermission(Permission)} method denies access\n+   * to retrieve the specified security property value.\n+   * @see #setProperty(String, String)\n+   * @see SecurityPermission\n    */\n   public static String getProperty(String key)\n   {\n@@ -315,18 +354,21 @@ public static String getProperty(String key)\n     return secprops.getProperty(key);\n   }\n \n-\n   /**\n-     Sets the value of a security property.\n-\n-     This method checks the security manager with the call checkSecurityAccess\n-     with \"setProperty.\"+key to see if the user can get this property.\n-\n-     @param key property to set\n-     @param datnum new value of property\n-\n-     @throws SecurityException - if the security manager denies access to \n-     setting a property\n+   * <p>Sets a security property value.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkPermission()</code>\n+   * method is called with a <code>SecurityPermission(\"setProperty.\"+key)</code>\n+   * permission to see if it's ok to set the specified security property value.\n+   * </p>\n+   *\n+   * @param key the name of the property to be set.\n+   * @param datnum the value of the property to be set.\n+   * @throws SecurityException if a security manager exists and its\n+   * {@link SecurityManager#checkPermission(Permission)} method denies access\n+   * to set the specified security property value.\n+   * @see #getProperty(String)\n+   * @see SecurityPermission\n    */\n   public static void setProperty(String key, String datnum)\n   {\n@@ -336,4 +378,327 @@ public static void setProperty(String key, String datnum)\n \n     secprops.put(key, datnum);\n   }\n+\n+  /**\n+   * Returns a Set of Strings containing the names of all available algorithms\n+   * or types for the specified Java cryptographic service (e.g., Signature,\n+   * MessageDigest, Cipher, Mac, KeyStore). Returns an empty Set if there is no\n+   * provider that supports the specified service. For a complete list of Java\n+   * cryptographic services, please see the Java Cryptography Architecture API\n+   * Specification & Reference. Note: the returned set is immutable.\n+   *\n+   * @param serviceName the name of the Java cryptographic service (e.g.,\n+   * Signature, MessageDigest, Cipher, Mac, KeyStore). Note: this parameter is\n+   * case-insensitive.\n+   * @return a Set of Strings containing the names of all available algorithms\n+   * or types for the specified Java cryptographic service or an empty set if\n+   * no provider supports the specified service.\n+   * @since 1.4\n+   */\n+  public static Set getAlgorithms(String serviceName)\n+  {\n+    HashSet result = new HashSet();\n+    if (serviceName == null || serviceName.length() == 0)\n+      return result;\n+\n+    serviceName = serviceName.trim();\n+    if (serviceName.length() == 0)\n+      return result;\n+\n+    serviceName = serviceName.toUpperCase()+\".\";\n+    Provider[] providers = getProviders();\n+    int ndx;\n+    for (int i = 0; i < providers.length; i++)\n+      for (Enumeration e = providers[i].propertyNames(); e.hasMoreElements(); )\n+        {\n+          String service = ((String) e.nextElement()).trim();\n+          if (service.toUpperCase().startsWith(serviceName))\n+            {\n+              service = service.substring(serviceName.length()).trim();\n+              ndx = service.indexOf(' '); // get rid of attributes\n+              if (ndx != -1)\n+                service = service.substring(0, ndx);\n+              result.add(service);\n+            }\n+        }\n+    return Collections.unmodifiableSet(result);\n+  }\n+\n+  /**\n+   * <p>Returns an array containing all installed providers that satisfy the\n+   * specified selection criterion, or <code>null</code> if no such providers\n+   * have been installed. The returned providers are ordered according to their\n+   * preference order.</p>\n+   *\n+   * <p>A cryptographic service is always associated with a particular\n+   * algorithm or type. For example, a digital signature service is always\n+   * associated with a particular algorithm (e.g., <i>DSA</i>), and a\n+   * CertificateFactory service is always associated with a particular\n+   * certificate type (e.g., <i>X.509</i>).</p>\n+   *\n+   * <p>The selection criterion must be specified in one of the following two\n+   * formats:</p>\n+   *\n+   * <ul>\n+   *    <li><p>&lt;crypto_service>.&lt;algorithm_or_type></p>\n+   *    <p>The cryptographic service name must not contain any dots.</p>\n+   *    <p>A provider satisfies the specified selection criterion iff the\n+   *    provider implements the specified algorithm or type for the specified\n+   *    cryptographic service.</p>\n+   *    <p>For example, \"CertificateFactory.X.509\" would be satisfied by any\n+   *    provider that supplied a CertificateFactory implementation for X.509\n+   *    certificates.</p></li>\n+   *\n+   *    <li><p>&lt;crypto_service>.&lt;algorithm_or_type>&nbsp;&lt;attribute_name>:&lt;attribute_value></p>\n+   *    <p>The cryptographic service name must not contain any dots. There must\n+   *    be one or more space charaters between the the &lt;algorithm_or_type>\n+   *    and the &lt;attribute_name>.</p>\n+   *    <p>A provider satisfies this selection criterion iff the provider\n+   *    implements the specified algorithm or type for the specified\n+   *    cryptographic service and its implementation meets the constraint\n+   *    expressed by the specified attribute name/value pair.</p>\n+   *    <p>For example, \"Signature.SHA1withDSA KeySize:1024\" would be satisfied\n+   *    by any provider that implemented the SHA1withDSA signature algorithm\n+   *    with a keysize of 1024 (or larger).</p></li>\n+   * </ul>\n+   *\n+   * <p>See Appendix A in the Java Cryptogaphy Architecture API Specification\n+   * &amp; Reference for information about standard cryptographic service names,\n+   * standard algorithm names and standard attribute names.</p>\n+   *\n+   * @param filter the criterion for selecting providers. The filter is case-\n+   * insensitive.\n+   * @return all the installed providers that satisfy the selection criterion,\n+   * or null if no such providers have been installed.\n+   * @throws InvalidParameterException if the filter is not in the required\n+   * format.\n+   * @see #getProviders(Map)\n+   */\n+  public static Provider[] getProviders(String filter)\n+  {\n+    if (providers == null || providers.isEmpty())\n+      return null;\n+\n+    if (filter == null || filter.length() == 0)\n+      return getProviders();\n+\n+    HashMap map = new HashMap(1);\n+    int i = filter.indexOf(':');\n+    if (i == -1) // <service>.<algorithm>\n+      map.put(filter, \"\");\n+    else // <service>.<algorithm> <attribute>:<value>\n+      map.put(filter.substring(0, i), filter.substring(i+1));\n+\n+    return getProviders(map);\n+  }\n+\n+ /**\n+  * <p>Returns an array containing all installed providers that satisfy the\n+  * specified selection criteria, or <code>null</code> if no such providers\n+  * have been installed. The returned providers are ordered according to their\n+  * preference order.</p>\n+  *\n+  * <p>The selection criteria are represented by a map. Each map entry\n+  * represents a selection criterion. A provider is selected iff it satisfies\n+  * all selection criteria. The key for any entry in such a map must be in one\n+  * of the following two formats:</p>\n+  *\n+  * <ul>\n+  *    <li><p>&lt;crypto_service>.&lt;algorithm_or_type></p>\n+  *    <p>The cryptographic service name must not contain any dots.</p>\n+  *    <p>The value associated with the key must be an empty string.</p>\n+  *    <p>A provider satisfies this selection criterion iff the provider\n+  *    implements the specified algorithm or type for the specified\n+  *    cryptographic service.</p></li>\n+  *\n+  *    <li><p>&lt;crypto_service>.&lt;algorithm_or_type> &lt;attribute_name></p>\n+  *    <p>The cryptographic service name must not contain any dots. There must\n+  *    be one or more space charaters between the &lt;algorithm_or_type> and\n+  *    the &lt;attribute_name>.</p>\n+  *    <p>The value associated with the key must be a non-empty string. A\n+  *    provider satisfies this selection criterion iff the provider implements\n+  *    the specified algorithm or type for the specified cryptographic service\n+  *    and its implementation meets the constraint expressed by the specified\n+  *    attribute name/value pair.</p></li>\n+  * </ul>\n+  *\n+  * <p>See Appendix A in the Java Cryptogaphy Architecture API Specification\n+  * &amp; Reference for information about standard cryptographic service names,\n+  * standard algorithm names and standard attribute names.</p>\n+  *\n+  * @param filter the criteria for selecting providers. The filter is case-\n+  * insensitive.\n+  * @return all the installed providers that satisfy the selection criteria,\n+  * or <code>null</code> if no such providers have been installed.\n+  * @throws InvalidParameterException if the filter is not in the required\n+  * format.\n+  * @see #getProviders(String)\n+  */\n+  public static Provider[] getProviders(Map filter)\n+  {\n+    if (providers == null || providers.isEmpty())\n+      return null;\n+\n+    if (filter == null)\n+      return getProviders();\n+\n+    Set querries = filter.keySet();\n+    if (querries == null || querries.isEmpty())\n+      return getProviders();\n+\n+    LinkedHashSet result = new LinkedHashSet(providers); // assume all\n+    int dot, ws;\n+    String querry, service, algorithm, attribute, value;\n+    LinkedHashSet serviceProviders = new LinkedHashSet(); // preserve insertion order\n+    for (Iterator i = querries.iterator(); i.hasNext(); )\n+      {\n+        querry = (String) i.next();\n+        if (querry == null) // all providers\n+          continue;\n+\n+        querry = querry.trim();\n+        if (querry.length() == 0) // all providers\n+          continue;\n+\n+        dot = querry.indexOf('.');\n+        if (dot == -1) // syntax error\n+          throw new InvalidParameterException(\n+              \"missing dot in '\" + String.valueOf(querry)+\"'\");\n+\n+        value = (String) filter.get(querry);\n+        // deconstruct querry into [service, algorithm, attribute]\n+        if (value == null || value.trim().length() == 0) // <service>.<algorithm>\n+          {\n+            value = null;\n+            attribute = null;\n+            service = querry.substring(0, dot).trim();\n+            algorithm = querry.substring(dot+1).trim();\n+          }\n+        else // <service>.<algorithm> <attribute>\n+          {\n+            ws = querry.indexOf(' ');\n+            if (ws == -1)\n+              throw new InvalidParameterException(\n+                  \"value (\" + String.valueOf(value) +\n+                  \") is not empty, but querry (\" + String.valueOf(querry) +\n+                  \") is missing at least one space character\");\n+            value = value.trim();\n+            attribute = querry.substring(ws+1).trim();\n+            // was the dot in the attribute?\n+            if (attribute.indexOf('.') != -1)\n+              throw new InvalidParameterException(\n+                  \"attribute_name (\" + String.valueOf(attribute) +\n+                  \") in querry (\" + String.valueOf(querry) + \") contains a dot\");\n+\n+            querry = querry.substring(0, ws).trim();\n+            service = querry.substring(0, dot).trim();\n+            algorithm = querry.substring(dot+1).trim();\n+          }\n+\n+        // service and algorithm must not be empty\n+        if (service.length() == 0)\n+          throw new InvalidParameterException(\n+              \"<crypto_service> in querry (\" + String.valueOf(querry) +\n+              \") is empty\");\n+\n+        if (algorithm.length() == 0)\n+          throw new InvalidParameterException(\n+              \"<algorithm_or_type> in querry (\" + String.valueOf(querry) +\n+              \") is empty\");\n+\n+        selectProviders(service, algorithm, attribute, value, result, serviceProviders);\n+        result.retainAll(serviceProviders); // eval next retaining found providers\n+        if (result.isEmpty()) // no point continuing\n+          break;\n+      }\n+\n+    if (result.isEmpty())\n+      return null;\n+\n+    return (Provider[]) result.toArray(new Provider[0]);\n+  }\n+\n+  private static void selectProviders(String svc, String algo, String attr,\n+                                      String val, LinkedHashSet providerSet,\n+                                      LinkedHashSet result)\n+  {\n+    result.clear(); // ensure we start with an empty result set\n+    for (Iterator i = providerSet.iterator(); i.hasNext(); )\n+      {\n+        Provider p = (Provider) i.next();\n+        if (provides(p, svc, algo, attr, val))\n+          result.add(p);\n+      }\n+  }\n+\n+  private static boolean provides(Provider p, String svc, String algo,\n+                                  String attr, String val)\n+  {\n+    Iterator it;\n+    String serviceDotAlgorithm = null;\n+    String key = null;\n+    String realVal;\n+    boolean found = false;\n+    // if <svc>.<algo> <attr> is in the set then so is <svc>.<algo>\n+    // but it may be stored under an alias <algo>. resolve\n+    outer: for (int r = 0; r < 3; r++) // guard against circularity\n+      {\n+        serviceDotAlgorithm = (svc+\".\"+String.valueOf(algo)).trim();\n+        inner: for (it = p.keySet().iterator(); it.hasNext(); )\n+          {\n+            key = (String) it.next();\n+            if (key.equalsIgnoreCase(serviceDotAlgorithm)) // eureka\n+              {\n+                found = true;\n+                break outer;\n+              }\n+            // it may be there but as an alias\n+            if (key.equalsIgnoreCase(ALG_ALIAS + serviceDotAlgorithm))\n+              {\n+                algo = p.getProperty(key);\n+                continue outer;\n+              }\n+            // else continue inner\n+          }\n+      }\n+\n+    if (!found)\n+      return false;\n+\n+    // found a candidate for the querry.  do we have an attr to match?\n+    if (val == null) // <service>.<algorithm> querry\n+      return true;\n+\n+    // <service>.<algorithm> <attribute>; find the key entry that match\n+    String realAttr;\n+    int limit = serviceDotAlgorithm.length() + 1;\n+    for (it = p.keySet().iterator(); it.hasNext(); )\n+      {\n+        key = (String) it.next();\n+        if (key.length() <= limit)\n+          continue;\n+\n+        if (key.substring(0, limit).equalsIgnoreCase(serviceDotAlgorithm+\" \"))\n+          {\n+            realAttr = key.substring(limit).trim();\n+            if (! realAttr.equalsIgnoreCase(attr))\n+              continue;\n+\n+            // eveything matches so far.  do the value\n+            realVal = p.getProperty(key);\n+            if (realVal == null)\n+              return false;\n+\n+            realVal = realVal.trim();\n+            // is it a string value?\n+            if (val.equalsIgnoreCase(realVal))\n+              return true;\n+\n+            // assume value is a number. cehck for greater-than-or-equal\n+            return (new Integer(val).intValue() >= new Integer(realVal).intValue());\n+          }\n+      }\n+\n+    return false;\n+  }\n }"}, {"sha": "dff2e2d87ba9b2a22dbe202307c4926c5a77b9c9", "filename": "libjava/java/security/Signature.java", "status": "modified", "additions": 368, "deletions": 260, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSignature.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* Signature.java --- Signature Class\n-   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,73 +36,113 @@\n exception statement from your version. */\n \n package java.security;\n+\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n import java.security.spec.AlgorithmParameterSpec;\n \n /**\n-   Signature is used to provide an interface to digital signature \n-   algorithms. Digital signatures provide authentication and data \n-   integrity of digital data. \n-\n-   The GNU provider provides the NIST standard DSA which uses DSA \n-   and SHA-1. It can be specified by SHA/DSA, SHA-1/DSA or its \n-   OID. If the RSA signature algorithm is provided then\n-   it could be MD2/RSA. MD5/RSA, or SHA-1/RSA. The algorithm must\n-   be specified because there is no default.\n-\n-   Signature provides implementation-independent algorithms which \n-   are requested by the user through getInstance. It can be \n-   requested by specifying just the algorithm name or by \n-   specifying both the algorithm name and provider name. \n-\n-   The three phases of using Signature are:\n-\n-   1. Initialing\n-\n-   * It must be initialized with a private key for signing.\n-   * It must be initialized with a public key for verifying.\n-\n-   2. Updating\n-\n-   Update the bytes for signing or verifying with calls to update.\n-\n-   3. Signing or Verify the signature on the currently stored\n-   bytes by calling sign or verify.\n-\n-   @author Mark Benvenuto <ivymccough@worldnet.att.net>\n-   @since JDK 1.1\n+ * <p>This <code>Signature</code> class is used to provide applications the\n+ * functionality of a digital signature algorithm. Digital signatures are used\n+ * for authentication and integrity assurance of digital data.</p>\n+ *\n+ * <p>The signature algorithm can be, among others, the NIST standard <i>DSS</i>,\n+ * using <i>DSA</i> and <i>SHA-1</i>. The <i>DSA</i> algorithm using the\n+ * <i>SHA-1</i> message digest algorithm can be specified as <code>SHA1withDSA\n+ * </code>. In the case of <i>RSA</i>, there are multiple choices for the\n+ * message digest algorithm, so the signing algorithm could be specified as, for\n+ * example, <code>MD2withRSA</code>, <code>MD5withRSA</code>, or\n+ * <code>SHA1withRSA</code>. The algorithm name must be specified, as there is\n+ * no default.</p>\n+ *\n+ * <p>Like other algorithm-based classes in Java Security, <code>Signature</code>\n+ * provides implementation-independent algorithms, whereby a caller (application\n+ * code) requests a particular signature algorithm and is handed back a properly\n+ * initialized <code>Signature</code> object. It is also possible, if desired,\n+ * to request a particular algorithm from a particular provider. See the\n+ * <code>getInstance()</code> methods.</p>\n+ *\n+ * <p>Thus, there are two ways to request a <code>Signature</code> algorithm\n+ * object: by specifying either just an algorithm name, or both an algorithm\n+ * name and a package provider.</p>\n+ *\n+ * <p>If just an algorithm name is specified, the system will determine if there\n+ * is an implementation of the algorithm requested available in the environment,\n+ * and if there is more than one, if there is a preferred one.</p>\n+ *\n+ * <p>If both an algorithm name and a package provider are specified, the system\n+ * will determine if there is an implementation of the algorithm in the package\n+ * requested, and throw an exception if there is not.</p>\n+ *\n+ * <p>A <code>Signature</code> object can be used to generate and verify digital\n+ * signatures.</p>\n+ *\n+ * <p>There are three phases to the use of a <code>Signature</code> object for\n+ * either signing data or verifying a signature:</p>\n+ *\n+ * <ol>\n+ *    <li>Initialization, with either\n+ *      <ul>\n+ *        <li>a public key, which initializes the signature for verification\n+ *        (see <code>initVerify()</code>), or</li>\n+ *        <li>a private key (and optionally a Secure Random Number Generator),\n+ *        which initializes the signature for signing (see\n+ *        {@link #initSign(PrivateKey)} and {@link #initSign(PrivateKey, SecureRandom)}\n+ *        ).</li>\n+ *      </ul></li>\n+ *    <li>Updating<br/>\n+ *      Depending on the type of initialization, this will update the bytes to\n+ *      be signed or verified. See the update methods.<br/></li>\n+ *    <li>Signing or Verifying a signature on all updated bytes. See the\n+ *    <code>sign()</code> methods and the <code>verify()</code> method.</li>\n+ *  </ol>\n+ *\n+ * <p>Note that this class is abstract and extends from {@link SignatureSpi} for\n+ * historical reasons. Application developers should only take notice of the\n+ * methods defined in this <code>Signature</code> class; all the methods in the\n+ * superclass are intended for cryptographic service providers who wish to\n+ * supply their own implementations of digital signature algorithms.\n+ *\n+ * @author Mark Benvenuto <ivymccough@worldnet.att.net>\n  */\n public abstract class Signature extends SignatureSpi\n {\n+  /** Service name for signatures. */\n+  private static final String SIGNATURE = \"Signature\";\n+\n   /**\n-     Possible state variable which signifies if it has not been \n-     initialized.\n+   * Possible <code>state</code> value, signifying that this signature object\n+   * has not yet been initialized.\n    */\n-  protected static final int UNINITIALIZED = 1;\n+  protected static final int UNINITIALIZED = 0;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n \n   /**\n-     Possible state variable which signifies if it has been \n-     initialized for signing.\n+   * Possible <code>state</code> value, signifying that this signature object\n+   * has been initialized for signing.\n    */\n   protected static final int SIGN = 2;\n \n   /**\n-     Possible state variable which signifies if it has been \n-     initialized for verifying.\n+   * Possible <code>state</code> value, signifying that this signature object\n+   * has been initialized for verification.\n    */\n   protected static final int VERIFY = 3;\n \n-  /**\n-     State of this Signature class.\n-   */\n+  /** Current state of this signature object. */\n   protected int state = UNINITIALIZED;\n \n   private String algorithm;\n   Provider provider;\n \n   /**\n-     Creates a new signature for this algorithm.\n-\n-     @param algorithm the algorithm to use\n+   * Creates a <code>Signature</code> object for the specified algorithm.\n+   *\n+   * @param algorithm the standard string name of the algorithm. See Appendix A\n+   * in the Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n    */\n   protected Signature(String algorithm)\n   {\n@@ -111,21 +151,24 @@ protected Signature(String algorithm)\n   }\n \n   /**\n-     Gets an instance of the Signature class representing\n-     the specified signature. If the algorithm is not found then, \n-     it throws NoSuchAlgorithmException.\n-\n-     @param algorithm the name of signature algorithm to choose\n-     @return a Signature repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n-     \t\t\t\t      providers\n+   * Generates a <code>Signature</code> object that implements the specified\n+   * digest algorithm. If the default provider package provides an\n+   * implementation of the requested digest algorithm, an instance of\n+   * <code>Signature</code> containing that implementation is returned. If the\n+   * algorithm is not available in the default package, other packages are\n+   * searched.\n+   *\n+   * @param algorithm the standard name of the algorithm requested. See Appendix\n+   * A in the Java Cryptography Architecture API Specification &amp; Reference\n+   * for information about standard algorithm names.\n+   * @return the new Signature object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * environment.\n    */\n   public static Signature getInstance(String algorithm)\n     throws NoSuchAlgorithmException\n   {\n     Provider[] p = Security.getProviders();\n-\n     for (int i = 0; i < p.length; i++)\n       {\n         try\n@@ -138,107 +181,98 @@ public static Signature getInstance(String algorithm)\n     throw new NoSuchAlgorithmException(algorithm);\n   }\n \n-  /** \n-     Gets an instance of the Signature class representing\n-     the specified signature from the specified provider. If the \n-     algorithm is not found then, it throws NoSuchAlgorithmException.\n-     If the provider is not found, then it throws\n-     NoSuchProviderException.\n-\n-     @param algorithm the name of signature algorithm to choose\n-     @param provider the name of the provider to find the algorithm in\n-     @return a Signature repesenting the desired algorithm\n-\n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n-\t\t\t\t      the provider\n-     @throws NoSuchProviderException if the provider is not found\n+  /**\n+   * Generates a <code>Signature</code> object implementing the specified\n+   * algorithm, as supplied from the specified provider, if such an algorithm\n+   * is available from the provider.\n+   *\n+   * @param algorithm the name of the algorithm requested. See Appendix A in\n+   * the Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @param provider the name of the provider.\n+   * @return the new <code>Signature</code> object.\n+   * @throws NoSuchAlgorithmException if the algorithm is not available in the\n+   * package supplied by the requested provider.\n+   * @throws NoSuchProviderException if the provider is not available in the\n+   * environment.\n+   * @throws IllegalArgumentException if the provider name is <code>null</code>\n+   * or empty.\n+   * @see Provider\n    */\n   public static Signature getInstance(String algorithm, String provider)\n     throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n+    if (provider == null || provider.length() == 0)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n+    \n     Provider p = Security.getProvider(provider);\n     if (p == null)\n       throw new NoSuchProviderException(provider);\n \n     return getInstance(algorithm, p);\n   }\n \n-  private static Signature getInstance(String algorithm, Provider p)\n+  /**\n+   * Generates a <code>Signature</code> object implementing the specified\n+   * algorithm, as supplied from the specified provider, if such an algorithm\n+   * is available from the provider. Note: the provider doesn't have to be\n+   * registered.\n+   *\n+   * @param algorithm the name of the algorithm requested. See Appendix A in\n+   * the Java Cryptography Architecture API Specification &amp; Reference for\n+   * information about standard algorithm names.\n+   * @param provider the provider.\n+   * @return the new <code>Signature</code> object.\n+   * @throws NoSuchAlgorithmException if the <code>algorithm</code> is not\n+   * available in the package supplied by the requested <code>provider</code>.\n+   * @throws IllegalArgumentException if the <code>provider</code> is\n+   * <code>null</code>.\n+   * @since 1.4\n+   * @see Provider\n+   */\n+  public static Signature getInstance(String algorithm, Provider provider)\n     throws NoSuchAlgorithmException\n   {\n-    // try the name as is\n-    String className = p.getProperty(\"Signature.\" + algorithm);\n-    if (className == null) { // try all uppercase\n-      String upper = algorithm.toUpperCase();\n-      className = p.getProperty(\"Signature.\" + upper);\n-      if (className == null) { // try if it's an alias\n-        String alias = p.getProperty(\"Alg.Alias.Signature.\" + algorithm);\n-        if (alias == null) {\n-          alias = p.getProperty(\"Alg.Alias.Signature.\" + upper);\n-          if (alias == null) { // spit the dummy\n-            throw new NoSuchAlgorithmException(algorithm);\n-          }\n-        }\n-        className = p.getProperty(\"Signature.\" + alias);\n-        if (className == null) {\n-          throw new NoSuchAlgorithmException(algorithm);\n-        }\n-      }\n-    }\n-    return getInstance(className, algorithm, p);\n-  }\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"Illegal provider\");\n \n-  private static Signature getInstance(String classname,\n-\t\t\t\t       String algorithm,\n-\t\t\t\t       Provider provider)\n-    throws NoSuchAlgorithmException\n-  {\n-    try\n-      {\n-\tObject o = Class.forName(classname).newInstance();\n-\tSignature sig;\n-\tif (o instanceof SignatureSpi)\n-\t  sig = new DummySignature((SignatureSpi) o, algorithm);\n-\telse\n-\t  {\n-\t    sig = (Signature) o;\n-\t    sig.algorithm = algorithm;\n-\t  }\n-\n-\tsig.provider = provider;\n-\treturn sig;\n-      }\n-    catch (ClassNotFoundException cnfe)\n+    Signature result = null;\n+    Object o = Engine.getInstance(SIGNATURE, algorithm, provider);\n+\n+    if (o instanceof SignatureSpi)\n       {\n-\tthrow new NoSuchAlgorithmException(\"Class not found\");\n+\tresult = new DummySignature((SignatureSpi) o, algorithm);\n       }\n-    catch (InstantiationException ie)\n+    else if (o instanceof Signature)\n       {\n-\tthrow new NoSuchAlgorithmException(\"Class instantiation failed\");\n+\tresult = (Signature) o;\n+\tresult.algorithm = algorithm;\n       }\n-    catch (IllegalAccessException iae)\n+    else\n       {\n-\tthrow new NoSuchAlgorithmException(\"Illegal Access\");\n+\tthrow new NoSuchAlgorithmException(algorithm);\n       }\n+    result.provider = provider;\n+    return result;\n   }\n \n   /**\n-     Gets the provider that the Signature is from.\n-\n-     @return the provider of this Signature\n+   * Returns the provider of this signature object.\n+   *\n+   * @return the provider of this signature object.\n    */\n   public final Provider getProvider()\n   {\n     return provider;\n   }\n \n   /**\n-     Initializes this class with the public key for \n-     verification purposes.\n-\n-     @param publicKey the public key to verify with\n-\n-     @throws InvalidKeyException invalid key\n+   * Initializes this object for verification. If this method is called again\n+   * with a different argument, it negates the effect of this call.\n+   *\n+   * @param publicKey the public key of the identity whose signature is going\n+   * to be verified.\n+   * @throws InvalidKeyException if the key is invalid.\n    */\n   public final void initVerify(PublicKey publicKey) throws InvalidKeyException\n   {\n@@ -247,39 +281,43 @@ public final void initVerify(PublicKey publicKey) throws InvalidKeyException\n   }\n \n   /**\n-     Verify Signature with a certificate. This is a FIPS 140-1 compatible method\n-     since it verifies a signature with a certificate.\n-\n-     If the certificate is an X.509 certificate, has a KeyUsage parameter and\n-     the parameter indicates this key is not to be used for signing then an \n-     error is returned.\n-\n-     @param certificate a certificate containing a public key to verify with\n+   * <p>Initializes this object for verification, using the public key from the\n+   * given certificate.</p>\n+   *\n+   * <p>If the certificate is of type <i>X.509</i> and has a <i>key usage</i>\n+   * extension field marked as <i>critical</i>, and the value of the <i>key\n+   * usage</i> extension field implies that the public key in the certificate\n+   * and its corresponding private key are not supposed to be used for digital\n+   * signatures, an {@link InvalidKeyException} is thrown.</p>\n+   *\n+   * @param certificate the certificate of the identity whose signature is\n+   * going to be verified.\n+   * @throws InvalidKeyException if the public key in the certificate is not\n+   * encoded properly or does not include required parameter information or\n+   * cannot be used for digital signature purposes.\n    */\n-  public final void initVerify(java.security.cert.Certificate certificate)\n+  public final void initVerify(Certificate certificate)\n     throws InvalidKeyException\n   {\n     state = VERIFY;\n     if (certificate.getType().equals(\"X509\"))\n       {\n-\tjava.security.cert.X509Certificate cert =\n-\t  (java.security.cert.X509Certificate) certificate;\n-\n+        X509Certificate cert = (X509Certificate) certificate;\n \tboolean[]array = cert.getKeyUsage();\n \tif (array != null && array[0] == false)\n-\t  throw new InvalidKeyException\n-\t    (\"KeyUsage of this Certificate indicates it cannot be used for digital signing\");\n+\t  throw new InvalidKeyException(\n+              \"KeyUsage of this Certificate indicates it cannot be used for digital signing\");\n       }\n     this.initVerify(certificate.getPublicKey());\n   }\n \n   /**\n-     Initializes this class with the private key for \n-     signing purposes.\n-\n-     @param privateKey the private key to sign with\n-\n-     @throws InvalidKeyException invalid key\n+   * Initialize this object for signing. If this method is called again with a\n+   * different argument, it negates the effect of this call.\n+   *\n+   * @param privateKey the private key of the identity whose signature is going\n+   * to be generated.\n+   * @throws InvalidKeyException if the key is invalid.\n    */\n   public final void initSign(PrivateKey privateKey) throws InvalidKeyException\n   {\n@@ -288,15 +326,13 @@ public final void initSign(PrivateKey privateKey) throws InvalidKeyException\n   }\n \n   /**\n-     Initializes this class with the private key and source \n-     of randomness for signing purposes.\n-\n-     @param privateKey the private key to sign with\n-     @param random Source of randomness\n-\n-     @throws InvalidKeyException invalid key\n-\n-     @since JDK 1.2\n+   * Initialize this object for signing. If this method is called again with a\n+   * different argument, it negates the effect of this call.\n+   *\n+   * @param privateKey the private key of the identity whose signature is going\n+   * to be generated.\n+   * @param random the source of randomness for this signature.\n+   * @throws InvalidKeyException if the key is invalid.\n    */\n   public final void initSign(PrivateKey privateKey, SecureRandom random)\n     throws InvalidKeyException\n@@ -305,91 +341,137 @@ public final void initSign(PrivateKey privateKey, SecureRandom random)\n     engineInitSign(privateKey, random);\n   }\n \n-\n   /**\n-     Returns the signature bytes of all the data fed to this class.\n-     The format of the output depends on the underlying signature\n-     algorithm.\n-\n-     @return the signature\n-\n-     @throws SignatureException engine not properly initialized\n+   * <p>Returns the signature bytes of all the data updated. The format of the\n+   * signature depends on the underlying signature scheme.</p>\n+   *\n+   * <p>A call to this method resets this signature object to the state it was\n+   * in when previously initialized for signing via a call to\n+   * <code>initSign(PrivateKey)</code>. That is, the object is reset and\n+   * available to generate another signature from the same signer, if desired,\n+   * via new calls to <code>update()</code> and <code>sign()</code>.</p>\n+   *\n+   * @return the signature bytes of the signing operation's result.\n+   * @throws SignatureException if this signature object is not initialized\n+   * properly.\n    */\n   public final byte[] sign() throws SignatureException\n   {\n     if (state == SIGN)\n       {\n-\tstate = UNINITIALIZED;\n-\treturn engineSign();\n+        state = UNINITIALIZED;\n+        return engineSign();\n       }\n     else\n       throw new SignatureException();\n   }\n \n   /**\n-     Generates signature bytes of all the data fed to this class \n-     and outputs it to the passed array. The format of the \n-     output depends on the underlying signature algorithm.\n-\n-     After calling this method, the signature is reset to its\n-     initial state and can be used to generate additional\n-     signatures.\n-\n-     @param outbuf array of bytes\n-     @param offset the offset to start at in the array\n-     @param len the length of the bytes to put into the array. \n-     Neither this method or the GNU provider will \n-     return partial digests. If len is less than the \n-     signature length, this method will throw \n-     SignatureException. If it is greater than or equal\n-     then it is ignored.\n-\n-     @return number of bytes in outbuf\n-\n-     @throws SignatureException engine not properly initialized\n-\n-     @since JDK 1.2\n+   * <p>Finishes the signature operation and stores the resulting signature\n+   * bytes in the provided buffer <code>outbuf</code>, starting at <code>offset\n+   * </code>. The format of the signature depends on the underlying signature\n+   * scheme.</p>\n+   *\n+   * <p>This signature object is reset to its initial state (the state it was\n+   * in after a call to one of the <code>initSign()</code> methods) and can be\n+   * reused to generate further signatures with the same private key.</p>\n+   *\n+   * @param outbuf buffer for the signature result.\n+   * @param offset offset into outbuf where the signature is stored.\n+   * @param len number of bytes within outbuf allotted for the signature.\n+   * @return the number of bytes placed into outbuf.\n+   * @throws SignatureException if an error occurs or len is less than the\n+   * actual signature length.\n+   * @since 1.2\n    */\n   public final int sign(byte[] outbuf, int offset, int len)\n     throws SignatureException\n   {\n     if (state == SIGN)\n       {\n-\tstate = UNINITIALIZED;\n-\treturn engineSign(outbuf, offset, len);\n+        state = UNINITIALIZED;\n+        return engineSign(outbuf, offset, len);\n       }\n     else\n       throw new SignatureException();\n   }\n \n   /**\n-     Verifies the passed signature.\n-\n-     @param signature the signature bytes to verify\n-\n-     @return true if verified, false otherwise\n-\n-     @throws SignatureException engine not properly initialized\n-     or wrong signature\n+   * <p>Verifies the passed-in signature.</p>\n+   *\n+   * <p>A call to this method resets this signature object to the state it was\n+   * in when previously initialized for verification via a call to\n+   * <code>initVerify(PublicKey)</code>. That is, the object is reset and\n+   * available to verify another signature from the identity whose public key\n+   * was specified in the call to <code>initVerify()</code>.</p>\n+   *\n+   * @param signature the signature bytes to be verified.\n+   * @return <code>true</code> if the signature was verified, <code>false</code>\n+   * if not.\n+   * @throws SignatureException if this signature object is not initialized\n+   * properly, or the passed-in signature is improperly encoded or of the wrong\n+   * type, etc.\n    */\n   public final boolean verify(byte[]signature) throws SignatureException\n   {\n     if (state == VERIFY)\n       {\n-\tstate = UNINITIALIZED;\n-\treturn engineVerify(signature);\n+        state = UNINITIALIZED;\n+        return engineVerify(signature);\n       }\n     else\n       throw new SignatureException();\n   }\n \n   /**\n-     Updates the data to be signed or verified with the specified \n-     byte.\n+   * <p>Verifies the passed-in <code>signature</code> in the specified array of\n+   * bytes, starting at the specified <code>offset</code>.</p>\n+   *\n+   * <p>A call to this method resets this signature object to the state it was\n+   * in when previously initialized for verification via a call to\n+   * <code>initVerify(PublicKey)</code>. That is, the object is reset and\n+   * available to verify another signature from the identity whose public key\n+   * was specified in the call to <code>initVerify()</code>.</p>\n+   *\n+   * @param signature the signature bytes to be verified.\n+   * @param offset the offset to start from in the array of bytes.\n+   * @param length the number of bytes to use, starting at offset.\n+   * @return <code>true</code> if the signature was verified, <code>false</code>\n+   * if not.\n+   * @throws SignatureException if this signature object is not initialized\n+   * properly, or the passed-in <code>signature</code> is improperly encoded or\n+   * of the wrong type, etc.\n+   * @throws IllegalArgumentException if the <code>signature</code> byte array\n+   * is <code>null</code>, or the <code>offset</code> or <code>length</code> is\n+   * less than <code>0</code>, or the sum of the <code>offset</code> and\n+   * <code>length</code> is greater than the length of the <code>signature</code>\n+   * byte array.\n+   */\n+  public final boolean verify(byte[] signature, int offset, int length)\n+    throws SignatureException\n+  {\n+    if (state != VERIFY)\n+      throw new SignatureException(\"illegal state\");\n+\n+    if (signature == null)\n+      throw new IllegalArgumentException(\"signaure is null\");\n+    if (offset < 0)\n+      throw new IllegalArgumentException(\"offset is less than 0\");\n+    if (length < 0)\n+      throw new IllegalArgumentException(\"length is less than 0\");\n+    if (offset + length < signature.length)\n+      throw new IllegalArgumentException(\"range is out of bounds\");\n \n-     @param b byte to update with\n+    state = UNINITIALIZED;\n+    return engineVerify(signature, offset, length);\n+  }\n \n-     @throws SignatureException Engine not properly initialized\n+  /**\n+   * Updates the data to be signed or verified by a byte.\n+   *\n+   * @param b the byte to use for the update.\n+   * @throws SignatureException if this signature object is not initialized\n+   * properly.\n    */\n   public final void update(byte b) throws SignatureException\n   {\n@@ -400,12 +482,12 @@ public final void update(byte b) throws SignatureException\n   }\n \n   /**\n-     Updates the data to be signed or verified with the specified \n-     bytes.\n-\n-     @param data array of bytes\n-\n-     @throws SignatureException engine not properly initialized\n+   * Updates the data to be signed or verified, using the specified array of\n+   * bytes.\n+   *\n+   * @param data the byte array to use for the update.\n+   * @throws SignatureException if this signature object is not initialized\n+   * properly.\n    */\n   public final void update(byte[]data) throws SignatureException\n   {\n@@ -416,14 +498,14 @@ public final void update(byte[]data) throws SignatureException\n   }\n \n   /**\n-     Updates the data to be signed or verified with the specified \n-     bytes.\n-\n-     @param data array of bytes\n-     @param off the offset to start at in the array\n-     @param len the length of the bytes to use in the array\n-\n-     @throws SignatureException engine not properly initialized\n+   * Updates the data to be signed or verified, using the specified array of\n+   * bytes, starting at the specified offset.\n+   *\n+   * @param data the array of bytes.\n+   * @param off the offset to start from in the array of bytes.\n+   * @param len the number of bytes to use, starting at offset.\n+   * @throws SignatureException if this signature object is not initialized\n+   * properly.\n    */\n   public final void update(byte[]data, int off, int len)\n     throws SignatureException\n@@ -434,38 +516,45 @@ public final void update(byte[]data, int off, int len)\n       throw new SignatureException();\n   }\n \n-  /** \n-     Gets the name of the algorithm currently used.\n-     The names of algorithms are usually SHA/DSA or SHA/RSA.\n-\n-     @return name of algorithm.\n+  /**\n+   * Returns the name of the algorithm for this signature object.\n+   *\n+   * @return the name of the algorithm for this signature object.\n    */\n   public final String getAlgorithm()\n   {\n     return algorithm;\n   }\n \n   /**\n-     Returns a representation of the Signature as a String\n-\n-     @return a string representing the signature\n+   * Returns a string representation of this signature object, providing\n+   * information that includes the state of the object and the name of the\n+   * algorithm used.\n+   *\n+   * @return a string representation of this signature object.\n    */\n   public String toString()\n   {\n     return (algorithm + \" Signature\");\n   }\n \n   /**\n-     Sets the specified algorithm parameter to the specified value.\n-\n-     @param param parameter name\n-     @param value parameter value\n-\n-     @throws InvalidParameterException invalid parameter, parameter \n-     already set and cannot set again, a security exception, \n-     etc.\n-\n-     @deprecated use the other setParameter\n+   * Sets the specified algorithm parameter to the specified value. This method\n+   * supplies a general-purpose mechanism through which it is possible to set\n+   * the various parameters of this object. A parameter may be any settable\n+   * parameter for the algorithm, such as a parameter size, or a source of\n+   * random bits for signature generation (if appropriate), or an indication of\n+   * whether or not to perform a specific but optional computation. A uniform\n+   * algorithm-specific naming scheme for each parameter is desirable but left\n+   * unspecified at this time.\n+   *\n+   * @param param the string identifier of the parameter.\n+   * @param value the parameter value.\n+   * @throws InvalidParameterException if param is an invalid parameter for this\n+   * signature algorithm engine, the parameter is already set and cannot be set\n+   * again, a security exception occurs, and so on.\n+   * @see #getParameter(String)\n+   * @deprecated Use setParameter(AlgorithmParameterSpec).\n    */\n   public final void setParameter(String param, Object value)\n     throws InvalidParameterException\n@@ -474,17 +563,12 @@ public final void setParameter(String param, Object value)\n   }\n \n   /**\n-     Sets the signature engine with the specified \n-     AlgorithmParameterSpec;\n-\n-     By default this always throws UnsupportedOperationException \n-     if not overridden;\n-\n-     @param params the parameters\n-\n-     @throws InvalidParameterException invalid parameter, parameter \n-     already set and cannot set again, a security exception, \n-     etc.\n+   * Initializes this signature engine with the specified parameter set.\n+   *\n+   * @param params the parameters.\n+   * @throws InvalidAlgorithmParameterException if the given parameters are\n+   * inappropriate for this signature engine.\n+   * @see #getParameters()\n    */\n   public final void setParameter(AlgorithmParameterSpec params)\n     throws InvalidAlgorithmParameterException\n@@ -493,15 +577,40 @@ public final void setParameter(AlgorithmParameterSpec params)\n   }\n \n   /**\n-     Gets the value for the specified algorithm parameter.\n-\n-     @param param parameter name\n-\n-     @return parameter value\n-\n-     @throws InvalidParameterException invalid parameter\n+   * <p>Returns the parameters used with this signature object.</p>\n+   *\n+   * <p>The returned parameters may be the same that were used to initialize\n+   * this signature, or may contain a combination of default and randomly\n+   * generated parameter values used by the underlying signature implementation\n+   * if this signature requires algorithm parameters but was not initialized\n+   * with any.\n+   *\n+   * @return the parameters used with this signature, or <code>null</code> if\n+   * this signature does not use any parameters.\n+   * @see #setParameter(AlgorithmParameterSpec)\n+   */\n+  public final AlgorithmParameters getParameters()\n+  {\n+    return engineGetParameters();\n+  }\n \n-     @deprecated use the other getParameter\n+  /**\n+   * Gets the value of the specified algorithm parameter. This method supplies\n+   * a general-purpose mechanism through which it is possible to get the various\n+   * parameters of this object. A parameter may be any settable parameter for\n+   * the algorithm, such as a parameter size, or a source of random bits for\n+   * signature generation (if appropriate), or an indication of whether or not\n+   * to perform a specific but optional computation. A uniform\n+   * algorithm-specific naming scheme for each parameter is desirable but left\n+   * unspecified at this time.\n+   *\n+   * @param param the string name of the parameter.\n+   * @return the object that represents the parameter value, or null if there\n+   * is none.\n+   * @throws InvalidParameterException if param is an invalid parameter for this\n+   * engine, or another exception occurs while trying to get this parameter.\n+   * @see #setParameter(String, Object)\n+   * @deprecated\n    */\n   public final Object getParameter(String param)\n     throws InvalidParameterException\n@@ -510,12 +619,11 @@ public final Object getParameter(String param)\n   }\n \n   /**\n-     Returns a clone if cloneable.\n-\n-     @return a clone if cloneable.\n-\n-     @throws CloneNotSupportedException if the implementation does \n-     not support cloning\n+   * Returns a clone if the implementation is cloneable.\n+   *\n+   * @return a clone if the implementation is cloneable.\n+   * @throws CloneNotSupportedException if this is called on an implementation\n+   * that does not support {@link Cloneable}.\n    */\n   public Object clone() throws CloneNotSupportedException\n   {"}, {"sha": "7deafd6b041e4c37af429c3d7d7e75fcbb4f18fe", "filename": "libjava/java/security/SignatureSpi.java", "status": "modified", "additions": 175, "deletions": 127, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSignatureSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSignatureSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSignatureSpi.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* SignatureSpi.java --- Signature Service Provider Interface\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,67 +36,70 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.security.spec.AlgorithmParameterSpec;\n \n /**\n-   SignatureSpi defines the Service Provider Interface (SPI)\n-   for the Signature class. The signature class provides an \n-   interface to a digital signature algorithm. Digital signatures\n-   are used for authentication and integrity of data.\n-\n-   @author Mark Benvenuto <ivymccough@worldnet.att.net>\n-\n-   @since JDK 1.2\n+ * <p>This class defines the <i>Service Provider Interface (SPI)</i> for the\n+ * {@link Signature} class, which is used to provide the functionality of a\n+ * digital signature algorithm. Digital signatures are used for authentication\n+ * and integrity assurance of digital data.</p>\n+ *\n+ * <p>All the abstract methods in this class must be implemented by each\n+ * cryptographic service provider who wishes to supply the implementation of a\n+ * particular signature algorithm.\n+ *\n+ * @author Mark Benvenuto <ivymccough@worldnet.att.net>\n+ * @since 1.2\n+ * @see Signature\n  */\n public abstract class SignatureSpi\n {\n-  /**\n-     Source of randomness\n-   */\n+  /** Application-specified source of randomness. */\n   protected SecureRandom appRandom;\n \n-  /**\n-     Creates a new instance of SignatureSpi.\n-   */\n   public SignatureSpi()\n   {\n     appRandom = null;\n   }\n \n   /**\n-     Initializes this class with the public key for \n-     verification purposes.\n-\n-     @param publicKey the public key to verify with\n-\n-     @throws InvalidKeyException invalid key\n+   * Initializes this signature object with the specified public key for\n+   * verification operations.\n+   *\n+   * @param publicKey the public key of the identity whose signature is going\n+   * to be verified.\n+   * @throws InvalidKeyException if the key is improperly encoded, parameters\n+   * are missing, and so on.\n    */\n   protected abstract void engineInitVerify(PublicKey publicKey)\n     throws InvalidKeyException;\n \n   /**\n-     Initializes this class with the private key for \n-     signing purposes.\n-\n-     @param privateKey the private key to sign with\n-\n-     @throws InvalidKeyException invalid key\n+   * Initializes this signature object with the specified private key for\n+   * signing operations.\n+   *\n+   * @param privateKey the private key of the identity whose signature will be\n+   * generated.\n+   * @throws InvalidKeyException if the key is improperly encoded, parameters\n+   * are missing, and so on.\n    */\n   protected abstract void engineInitSign(PrivateKey privateKey)\n     throws InvalidKeyException;\n \n   /**\n-     Initializes this class with the private key and source \n-     of randomness for signing purposes.\n-\n-     This cannot be abstract backward compatibility reasons\n-\n-     @param privateKey the private key to sign with\n-     @param random Source of randomness\n-\n-     @throws InvalidKeyException invalid key\n-\n-     @since JDK 1.2\n+   * <p>Initializes this signature object with the specified private key and\n+   * source of randomness for signing operations.</p>\n+   *\n+   * <p>This concrete method has been added to this previously-defined abstract\n+   * class. (For backwards compatibility, it cannot be abstract.)</p>\n+   *\n+   * @param privateKey the private key of the identity whose signature will be\n+   * generated.\n+   * @param random the source of randomness.\n+   * @throws InvalidKeyException if the key is improperly encoded, parameters\n+   * are missing, and so on.\n+   * @since 1.2\n    */\n   protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n     throws InvalidKeyException\n@@ -106,118 +109,135 @@ protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n   }\n \n   /**\n-     Updates the data to be signed or verified with the specified \n-     byte.\n-\n-     @param b byte to update with\n-\n-     @throws SignatureException Engine not properly initialized\n+   * Updates the data to be signed or verified using the specified byte.\n+   *\n+   * @param b the byte to use for the update.\n+   * @throws SignatureException if the engine is not initialized properly.\n    */\n   protected abstract void engineUpdate(byte b) throws SignatureException;\n \n   /**\n-     Updates the data to be signed or verified with the specified \n-     bytes.\n-\n-     @param b array of bytes\n-     @param off the offset to start at in the array\n-     @param len the length of the bytes to use in the array\n-\n-     @throws SignatureException engine not properly initialized\n+   * Updates the data to be signed or verified, using the specified array of\n+   * bytes, starting at the specified offset.\n+   *\n+   * @param b the array of bytes.\n+   * @param off the offset to start from in the array of bytes.\n+   * @param len the number of bytes to use, starting at offset.\n+   * @throws SignatureException if the engine is not initialized properly.\n    */\n   protected abstract void engineUpdate(byte[] b, int off, int len)\n     throws SignatureException;\n \n   /**\n-     Returns the signature bytes of all the data fed to this class.\n-     The format of the output depends on the underlying signature\n-     algorithm.\n-\n-     @return the signature\n-\n-     @throws SignatureException engine not properly initialized\n+   * Returns the signature bytes of all the data updated so far. The format of\n+   * the signature depends on the underlying signature scheme.\n+   *\n+   * @return the signature bytes of the signing operation's result.\n+   * @throws SignatureException if the engine is not initialized properly.\n    */\n   protected abstract byte[] engineSign() throws SignatureException;\n \n   /**\n-     Generates signature bytes of all the data fed to this class \n-     and outputs it to the passed array. The format of the \n-     output depends on the underlying signature algorithm.\n-\n-     This cannot be abstract backward compatibility reasons.\n-     After calling this method, the signature is reset to its\n-     initial state and can be used to generate additional\n-     signatures.\n-\n-     @param outbuff array of bytes\n-     @param offset the offset to start at in the array\n-     @param len the length of the bytes to put into the array. \n-     Neither this method or the GNU provider will \n-     return partial digests. If len is less than the \n-     signature length, this method will throw \n-     SignatureException. If it is greater than or equal\n-     then it is ignored.\n-\n-     @return number of bytes in outbuf\n-\n-     @throws SignatureException engine not properly initialized\n-\n-     @since JDK 1.2\n+   * <p>Finishes this signature operation and stores the resulting signature\n+   * bytes in the provided buffer <code>outbuf</code>, starting at <code>offset\n+   * </code>. The format of the signature depends on the underlying signature\n+   * scheme.</p>\n+   *\n+   * <p>The signature implementation is reset to its initial state (the state it\n+   * was in after a call to one of the <code>engineInitSign()</code> methods)\n+   * and can be reused to generate further signatures with the same private key.\n+   * This method should be abstract, but we leave it concrete for binary\n+   * compatibility. Knowledgeable providers should override this method.</p>\n+   *\n+   * @param outbuf buffer for the signature result.\n+   * @param offset offset into outbuf where the signature is stored.\n+   * @param len number of bytes within outbuf allotted for the signature. Both\n+   * this default implementation and the <b>GNU</b> provider do not return\n+   * partial digests. If the value of this parameter is less than the actual\n+   * signature length, this method will throw a {@link SignatureException}. This\n+   * parameter is ignored if its value is greater than or equal to the actual\n+   * signature length.\n+   * @return the number of bytes placed into <code>outbuf</code>.\n+   * @throws SignatureException if an error occurs or len is less than the\n+   * actual signature length.\n+   * @since 1.2\n    */\n   protected int engineSign(byte[] outbuf, int offset, int len)\n     throws SignatureException\n   {\n     byte tmp[] = engineSign();\n-\n     if (tmp.length > len)\n       throw new SignatureException(\"Invalid Length\");\n \n     System.arraycopy(outbuf, offset, tmp, 0, tmp.length);\n-\n     return tmp.length;\n   }\n \n   /**\n-     Verifies the passed signature.\n-\n-     @param sigBytes the signature bytes to verify\n-\n-     @return true if verified, false otherwise\n-\n-     @throws SignatureException engine not properly initialized\n-     or wrong signature\n+   * Verifies the passed-in signature.\n+   *\n+   * @param sigBytes the signature bytes to be verified.\n+   * @return <code>true</code> if the signature was verified, <code>false</code>\n+   * if not.\n+   * @throws SignatureException if the engine is not initialized properly, or\n+   * the passed-in signature is improperly encoded or of the wrong type, etc.\n    */\n   protected abstract boolean engineVerify(byte[] sigBytes)\n     throws SignatureException;\n \n   /**\n-     Sets the specified algorithm parameter to the specified value.\n-\n-     @param param parameter name\n-     @param value parameter value\n-\n-     @throws InvalidParameterException invalid parameter, parameter \n-     already set and cannot set again, a security exception, \n-     etc.\n+   * <p>Verifies the passed-in <code>signature</code> in the specified array of\n+   * bytes, starting at the specified <code>offset</code>.</p>\n+   *\n+   * <p>Note: Subclasses should overwrite the default implementation.</p>\n+   *\n+   * @param sigBytes the signature bytes to be verified.\n+   * @param offset the offset to start from in the array of bytes.\n+   * @param length the number of bytes to use, starting at offset.\n+   * @return <code>true</code> if the signature was verified, <code>false</code>\n+   * if not.\n+   * @throws SignatureException if the engine is not initialized properly, or\n+   * the passed-in <code>signature</code> is improperly encoded or of the wrong\n+   * type, etc.\n+   */\n+  protected boolean engineVerify(byte[] sigBytes, int offset, int length)\n+    throws SignatureException\n+  {\n+    byte[] tmp = new byte[length];\n+    System.arraycopy(sigBytes, offset, tmp, 0, length);\n+    return engineVerify(tmp);\n+  }\n \n-     @deprecated use the other setParameter\n+  /**\n+   * Sets the specified algorithm parameter to the specified value. This method\n+   * supplies a general-purpose mechanism through which it is possible to set\n+   * the various parameters of this object. A parameter may be any settable\n+   * parameter for the algorithm, such as a parameter size, or a source of\n+   * random bits for signature generation (if appropriate), or an indication of\n+   * whether or not to perform a specific but optional computation. A uniform\n+   * algorithm-specific naming scheme for each parameter is desirable but left\n+   * unspecified at this time.\n+   *\n+   * @param param the string identifier of the parameter.\n+   * @param value the parameter value.\n+   * @throws InvalidParameterException if <code>param</code> is an invalid\n+   * parameter for this signature algorithm engine, the parameter is already set\n+   * and cannot be set again, a security exception occurs, and so on.\n+   * @deprecated Replaced by engineSetParameter(AlgorithmParameterSpec).\n    */\n   protected abstract void engineSetParameter(String param, Object value)\n     throws InvalidParameterException;\n \n   /**\n-     Sets the signature engine with the specified \n-     AlgorithmParameterSpec;\n-\n-     This cannot be abstract backward compatibility reasons\n-     By default this always throws UnsupportedOperationException \n-     if not overridden;\n-\n-     @param params the parameters\n-\n-     @throws InvalidParameterException invalid parameter, parameter \n-     already set and cannot set again, a security exception, \n-     etc.\n+   * This method is overridden by providers to initialize this signature engine\n+   * with the specified parameter set.\n+   *\n+   * @param params the parameters.\n+   * @throws UnsupportedOperationException if this method is not overridden by\n+   * a provider.\n+   * @throws InvalidAlgorithmParameterException if this method is overridden by\n+   * a provider and the the given parameters are inappropriate for this\n+   * signature engine.\n    */\n   protected void engineSetParameter(AlgorithmParameterSpec params)\n     throws InvalidAlgorithmParameterException\n@@ -226,26 +246,54 @@ protected void engineSetParameter(AlgorithmParameterSpec params)\n   }\n \n   /**\n-     Gets the value for the specified algorithm parameter.\n-\n-     @param param parameter name\n-\n-     @return parameter value\n-\n-     @throws InvalidParameterException invalid parameter\n+   * <p>This method is overridden by providers to return the parameters used\n+   * with this signature engine, or <code>null</code> if this signature engine\n+   * does not use any parameters.</p>\n+   *\n+   * <p>The returned parameters may be the same that were used to initialize\n+   * this signature engine, or may contain a combination of default and randomly\n+   * generated parameter values used by the underlying signature implementation\n+   * if this signature engine requires algorithm parameters but was not\n+   * initialized with any.</p>\n+   *\n+   * @return the parameters used with this signature engine, or <code>null</code>\n+   * if this signature engine does not use any parameters.\n+   * @throws UnsupportedOperationException if this method is not overridden by\n+   * a provider.\n+   */\n+  protected AlgorithmParameters engineGetParameters()\n+  {\n+    throw new UnsupportedOperationException();    \n+  }\n \n-     @deprecated use the other getParameter\n+  /**\n+   * Gets the value of the specified algorithm parameter. This method supplies\n+   * a general-purpose mechanism through which it is possible to get the various\n+   * parameters of this object. A parameter may be any settable parameter for\n+   * the algorithm, such as a parameter size, or a source of random bits for\n+   * signature generation (if appropriate), or an indication of whether or not\n+   * to perform a specific but optional computation. A uniform algorithm-specific\n+   * naming scheme for each parameter is desirable but left unspecified at this\n+   * time.\n+   *\n+   * @param param the string name of the parameter.\n+   * @return the object that represents the parameter value, or <code>null</code>\n+   * if there is none.\n+   * @throws InvalidParameterException if <code>param<?code> is an invalid\n+   * parameter for this engine, or another exception occurs while trying to get\n+   * this parameter.\n+   * @deprecated\n    */\n   protected abstract Object engineGetParameter(String param)\n     throws InvalidParameterException;\n \n   /**\n-     Returns a clone if cloneable.\n-\n-     @return a clone if cloneable.\n-\n-     @throws CloneNotSupportedException if the implementation does \n-     not support cloning\n+   * Returns a clone if the implementation is cloneable.\n+   *\n+   * @return a clone if the implementation is cloneable.\n+   * @throws CloneNotSupportedException if this is called on an implementation\n+   * that does not support {@link Cloneable}.\n+   * @see Cloneable\n    */\n   public Object clone() throws CloneNotSupportedException\n   {"}, {"sha": "6a8d612b7fc16e95e8f3e83636bf5ca6dd596e5e", "filename": "libjava/java/security/SignedObject.java", "status": "modified", "additions": 139, "deletions": 78, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSignedObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSignedObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSignedObject.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* SignedObject.java --- Signed Object Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,77 +36,131 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.io.ObjectInput;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n \n /**\n-   SignedObject is used for storing rutime objects whose integrity\n-   cannot be compromised without being detected.\n-\n-   SignedObject contains a Serializable object which is yet to be \n-   signed and its signature.\n-\n-   The signed copy is a \"deep copy\" (in serialized form) of the \n-   original object. Any changes to the original will not affect \n-   the original.\n-\n-   Several things to note are that, first there is no need to \n-   initialize the signature engine as this class will handle that \n-   automatically. Second, verification will only succeed if the\n-   public key corresponds to the private key used to generate \n-   the SignedObject.\n-\n-   For fexibility, the signature engine can be specified in the \n-   constructor or the verify method. The programmer who writes \n-   code that verifies the SignedObject has not changed should be \n-   aware of the Signature engine they use. A malicious Signature \n-   may choose to always return true on verification and \n-   bypass the secrity check.\n-\n-   The GNU provider provides the NIST standard DSA which uses DSA \n-   and SHA-1. It can be specified by SHA/DSA, SHA-1/DSA or its \n-   OID. If the RSA signature algorithm is provided then\n-   it could be MD2/RSA. MD5/RSA, or SHA-1/RSA. The algorithm must\n-   be specified because there is no default.\n-\n-   @author Mark Benvenuto <ivymccough@worldnet.att.net>\n-\n-   @since JDK 1.2\n+ * <p><code>SignedObject</code> is a class for the purpose of creating authentic\n+ * runtime objects whose integrity cannot be compromised without being detected.\n+ * </p>\n+ *\n+ * <p>More specifically, a <code>SignedObject</code> contains another\n+ * {@link Serializable} object, the (to-be-)signed object and its signature.</p>\n+ *\n+ * <p>The signed object is a <i>\"deep copy\"</i> (in serialized form) of an\n+ * original object. Once the copy is made, further manipulation of the original\n+ * object has no side effect on the copy.</p>\n+ *\n+ * <p>The underlying signing algorithm is designated by the {@link Signature}\n+ * object passed to the constructor and the <code>verify()</code> method. A\n+ * typical usage for signing is the following:</p>\n+ *\n+ * <pre>\n+ * Signature signingEngine = Signature.getInstance(algorithm, provider);\n+ * SignedObject so = new SignedObject(myobject, signingKey, signingEngine);\n+ * </pre>\n+ *\n+ * <p>A typical usage for verification is the following (having received\n+ * <code>SignedObject</code> so):</p>\n+ *\n+ * <pre>\n+ * Signature verificationEngine = Signature.getInstance(algorithm, provider);\n+ * if (so.verify(publickey, verificationEngine))\n+ *   try\n+ *     {\n+ *       Object myobj = so.getObject();\n+ *     }\n+ *   catch (ClassNotFoundException ignored) {};\n+ * </pre>\n+ *\n+ * <p>Several points are worth noting. First, there is no need to initialize the\n+ * signing or verification engine, as it will be re-initialized inside the\n+ * constructor and the <code>verify()</code> method. Secondly, for verification\n+ * to succeed, the specified public key must be the public key corresponding to\n+ * the private key used to generate the <code>SignedObject</code>.</p>\n+ *\n+ * <p>More importantly, for flexibility reasons, the <code>constructor</code>\n+ * and <code>verify()</code> method allow for customized signature engines,\n+ * which can implement signature algorithms that are not installed formally as\n+ * part of a crypto provider. However, it is crucial that the programmer writing\n+ * the verifier code be aware what {@link Signature} engine is being used, as\n+ * its own implementation of the <code>verify()</code> method is invoked to\n+ * verify a signature. In other words, a malicious {@link Signature} may choose\n+ * to always return <code>true</code> on verification in an attempt to bypass a\n+ * security check.</p>\n+ *\n+ * <p>The signature algorithm can be, among others, the NIST standard <i>DSS</i>,\n+ * using <i>DSA</i> and <i>SHA-1</i>. The algorithm is specified using the same\n+ * convention as that for signatures. The <i>DSA</i> algorithm using the\n+ * </i>SHA-1</i> message digest algorithm can be specified, for example, as\n+ * <code>\"SHA/DSA\"</code> or <code>\"SHA-1/DSA\"</code> (they are equivalent). In\n+ * the case of <i>RSA</i>, there are multiple choices for the message digest\n+ * algorithm, so the signing algorithm could be specified as, for example,\n+ * <code>\"MD2/RSA\"</code>, <code>\"MD5/RSA\"</code> or <code>\"SHA-1/RSA\"</code>.\n+ * The algorithm name must be specified, as there is no default.</p>\n+ *\n+ * <p>The name of the Cryptography Package Provider is designated also by the\n+ * {@link Signature} parameter to the <code>constructor</code> and the <code>\n+ * verify()</code> method. If the provider is not specified, the default\n+ * provider is used. Each installation can be configured to use a particular\n+ * provider as default.</p>\n+ *\n+ * <p>Potential applications of <code>SignedObject</code> include:</p>\n+ *\n+ * <ul>\n+ *  <li>It can be used internally to any Java runtime as an unforgeable\n+ *  authorization token -- one that can be passed around without the fear that\n+ *  the token can be maliciously modified without being detected.</li>\n+ *  <li>It can be used to sign and serialize data/object for storage outside the\n+ *  Java runtime (e.g., storing critical access control data on disk).</li>\n+ *  <li>Nested <i>SignedObjects</i> can be used to construct a logical sequence\n+ *  of signatures, resembling a chain of authorization and delegation.</li>\n+ * </ul>\n+ *\n+ * @author Mark Benvenuto <ivymccough@worldnet.att.net>\n+ * @since 1.2\n+ * @see Signature\n  */\n public final class SignedObject implements Serializable\n {\n   static final long serialVersionUID = 720502720485447167L;\n \n+  /** @serial */\n   private byte[] content;\n+  /** @serial */\n   private byte[] signature;\n+  /** @serial */\n   private String thealgorithm;\n \n   /**\n-     Constructs a new SignedObject from a Serializeable object. The \n-     object is signed with private key and signature engine\n-\n-     @param object the object to sign\n-     @param signingKey the key to sign with\n-     @param signingEngine the signature engine to use\n-\n-     @throws IOException serialization error occurred\n-     @throws InvalidKeyException invalid key\n-     @throws SignatureException signing error\n+   * Constructs a <code>SignedObject</code> from any {@link Serializable}\n+   * object. The given object is signed with the given signing key, using the\n+   * designated signature engine.\n+   *\n+   * @param object the object to be signed.\n+   * @param signingKey the private key for signing.\n+   * @param signingEngine the signature signing engine.\n+   * @throws IOException if an error occurs during serialization.\n+   * @throws InvalidKeyException if the key is invalid.\n+   * @throws SignatureException if signing fails.\n    */\n   public SignedObject(Serializable object, PrivateKey signingKey,\n-\t\t      Signature signingEngine) throws IOException,\n-    InvalidKeyException, SignatureException\n+\t\t      Signature signingEngine)\n+    throws IOException, InvalidKeyException, SignatureException\n   {\n     thealgorithm = signingEngine.getAlgorithm();\n \n     ByteArrayOutputStream ostream = new ByteArrayOutputStream();\n     ObjectOutputStream p = new ObjectOutputStream(ostream);\n     p.writeObject(object);\n     p.flush();\n+    p.close();\n \n     content = ostream.toByteArray();\n \n@@ -116,64 +170,71 @@ public SignedObject(Serializable object, PrivateKey signingKey,\n   }\n \n   /**\n-     Returns the encapsulated object. The object is \n-     de-serialized before being returned.\n-\n-     @return the encapsulated object\n-\n-     @throws IOException de-serialization error occurred\n-     @throws ClassNotFoundException de-serialization error occurred\n+   * Retrieves the encapsulated object. The encapsulated object is de-serialized\n+   * before it is returned.\n+   *\n+   * @return the encapsulated object.\n+   * @throws IOException if an error occurs during de-serialization.\n+   * @throws ClassNotFoundException if an error occurs during de-serialization.\n    */\n   public Object getObject() throws IOException, ClassNotFoundException\n   {\n-    ByteArrayInputStream istream = new ByteArrayInputStream(content);\n+    ByteArrayInputStream bais = new ByteArrayInputStream(content);\n+    ObjectInput oi = new ObjectInputStream(bais);\n+    Object obj = oi.readObject();\n+    oi.close();\n+    bais.close();\n \n-    return new ObjectInputStream(istream).readObject();\n+    return obj;\n   }\n \n   /**\n-     Returns the signature of the encapsulated object.\n-\n-     @return a byte array containing the signature\n+   * Retrieves the signature on the signed object, in the form of a byte array.\n+   *\n+   * @return a copy of the signature.\n    */\n   public byte[] getSignature()\n   {\n-    return signature;\n+    return (byte[]) signature.clone();\n+\n   }\n \n   /**\n-     Returns the name of the signature algorithm.\n-\n-     @return the name of the signature algorithm.\n+   * Retrieves the name of the signature algorithm.\n+   *\n+   * @return the signature algorithm name.\n    */\n   public String getAlgorithm()\n   {\n     return thealgorithm;\n   }\n \n   /**\n-     Verifies the SignedObject by checking that the signature that \n-     this class contains for the encapsulated object.\n-\n-     @param verificationKey the public key to use\n-     @param verificationEngine the signature engine to use\n-\n-     @return true if signature is correct, false otherwise\n-\n-     @throws InvalidKeyException invalid key\n-     @throws SignatureException signature verification failed\n+   * Verifies that the signature in this <code>SignedObject</code> is the valid\n+   * signature for the object stored inside, with the given verification key,\n+   * using the designated verification engine.\n+   *\n+   * @param verificationKey the public key for verification.\n+   * @param verificationEngine the signature verification engine.\n+   * @return <code>true</code> if the signature is valid, <code>false</code>\n+   * otherwise.\n+   * @throws SignatureException if signature verification failed.\n+   * @throws InvalidKeyException if the verification key is invalid.\n    */\n-  public boolean verify(PublicKey verificationKey,\n-\t\t\tSignature verificationEngine) throws\n-    InvalidKeyException, SignatureException\n+  public boolean verify(PublicKey verificationKey, Signature verificationEngine)\n+    throws InvalidKeyException, SignatureException\n   {\n     verificationEngine.initVerify(verificationKey);\n     verificationEngine.update(content);\n     return verificationEngine.verify(signature);\n   }\n \n-  //     readObject is called to restore the state of the SignedObject from a\n-  //     stream.\n-  //private void readObject(ObjectInputStream s)\n-  //                 throws IOException, ClassNotFoundException\n+  /** Called to restore the state of the SignedObject from a stream. */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    s.defaultReadObject();\n+    content = (byte[]) content.clone();\n+    signature = (byte[]) signature.clone();\n+  }\n }"}, {"sha": "b5b3aaf19aad2c0050d040b93ac224f991385926", "filename": "libjava/java/security/Signer.java", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSigner.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2FSigner.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSigner.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -1,5 +1,5 @@\n /* Signer.java --- Signer Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,60 +38,67 @@\n package java.security;\n \n /**\n-   Signer is a subclass used to store a digital signature key with \n-   an Identity.\n-\n-   @author Mark Benvenuto <ivymccough@worldnet.att.net>\n-\n-   @since JDK 1.1\n+ * <p>This class is used to represent an {@link Identity} that can also\n+ * digitally sign data.</p>\n+ *\n+ * <p>The management of a signer's private keys is an important and sensitive\n+ * issue that should be handled by subclasses as appropriate to their intended\n+ * use.</p>\n+ *\n+ * @author Mark Benvenuto <ivymccough@worldnet.att.net>\n+ * @deprecated This class is no longer used. Its functionality has been replaced\n+ * by <code>java.security.KeyStore</code>, the <code>java.security.cert</code>\n+ * package, and <code>java.security.Principal</code>.\n  */\n public abstract class Signer extends Identity\n {\n+  static final long serialVersionUID = -1763464102261361480L;\n   private PrivateKey privateKey = null;\n \n   /**\n-     Constructs a new Signer.\n+   * Creates a <code>Signer</code>. This constructor should only be used for\n+   * serialization.\n    */\n   protected Signer()\n   {\n   }\n \n   /**\n-     Constructs a new Signer with the specified name.\n-\n-     @param name the name of the identity.\n+   * Creates a <code>Signer</code> with the specified identity name.\n+   *\n+   * @param name the identity name.\n    */\n   public Signer(String name)\n   {\n     super(name);\n   }\n \n   /**\n-     Constructs a new Signer with the specifid name and \n-     IdentityScope.\n-\n-     @param name the name of the identity.\n-     @scope the IdentityScope to use\n-\n-     @throws KeyManagementException if duplicate identity name \n-     within scope\n+   * Creates a <code>Signer</code> with the specified identity name and scope.\n+   *\n+   * @param name the identity name.\n+   * @param scope the scope of the identity.\n+   * @throws KeyManagementException if there is already an identity with the\n+   * same name in the scope.\n    */\n-  public Signer(String name, IdentityScope scope)\n-    throws KeyManagementException\n+  public Signer(String name, IdentityScope scope) throws KeyManagementException\n   {\n     super(name, scope);\n   }\n \n   /**\n-     Returns the private key for this signer.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"getSignerPrivateKey\".\n-\n-     @returns the private key for the signer\n-\n-     @throws SecurityException - if the security manager denies \n-     access to \"getSignerPrivateKey\"\n+   * <p>Returns this signer's private key.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"getSignerPrivateKey\"</code> as its\n+   * argument to see if it's ok to return the private key.</p>\n+   *\n+   * @return this signer's private key, or <code>null</code> if the private key\n+   * has not yet been set.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()</code> method doesn't allow returning the\n+   * private key.\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public PrivateKey getPrivateKey()\n   {\n@@ -103,17 +110,20 @@ public PrivateKey getPrivateKey()\n   }\n \n   /**\n-     Specifies the KeyPair associated with this Signer.\n-\n-     This class checks the security manager with the call \n-     checkSecurityAccess with \"setSignerKeyPair\".\n-\n-     @param pair the keyPair\n-\n-     @throws InvalidParameterException invalidly intialized key pair\n-     @throws KeyException another key error\n-     @throws SecurityException - if the security manager denies \n-     access to \"getSignerPrivateKey\"\n+   * <p>Sets the key pair (public key and private key) for this signer.</p>\n+   *\n+   * <p>First, if there is a security manager, its <code>checkSecurityAccess()\n+   * </code> method is called with <code>\"setSignerKeyPair\"</code> as its\n+   * argument to see if it's ok to set the key pair.</p>\n+   *\n+   * @param pair an initialized key pair.\n+   * @throws InvalidParameterException if the key pair is not properly\n+   * initialized.\n+   * @throws KeyException if the key pair cannot be set for any other reason.\n+   * @throws SecurityException if a security manager exists and its\n+   * <code>checkSecurityAccess()</code> method doesn't allow setting the key\n+   * pair.\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public final void setKeyPair(KeyPair pair)\n     throws InvalidParameterException, KeyException\n@@ -124,15 +134,15 @@ public final void setKeyPair(KeyPair pair)\n \n     try\n       {\n-\tif (pair.getPublic() != null)\n-\t  setPublicKey(pair.getPublic());\n-\telse\n-\t  throw new InvalidParameterException();\n+        if (pair.getPublic() != null)\n+          setPublicKey(pair.getPublic());\n+        else\n+          throw new InvalidParameterException();\n \n       }\n     catch (KeyManagementException kme)\n       {\n-\tthrow new KeyException();\n+        throw new KeyException();\n       }\n \n     if (pair.getPrivate() != null)\n@@ -142,9 +152,10 @@ public final void setKeyPair(KeyPair pair)\n   }\n \n   /**\n-     Returns a string representing this Signer.\n-\n-     @returns a string representing this Signer.\n+   * Returns a string of information about the signer.\n+   *\n+   * @return a string of information about the signer.\n+   * @see SecurityManager#checkSecurityAccess(String)\n    */\n   public String toString()\n   {"}, {"sha": "7e115fabcd17501abc5e4d61afd7b53f1daeb666", "filename": "libjava/java/security/interfaces/RSAMultiPrimePrivateCrtKey.java", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Finterfaces%2FRSAMultiPrimePrivateCrtKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Finterfaces%2FRSAMultiPrimePrivateCrtKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Finterfaces%2FRSAMultiPrimePrivateCrtKey.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -0,0 +1,110 @@\n+/* RSAMultiPrimePrivateCrtKey.java --\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.security.interfaces;\n+\n+import java.math.BigInteger;\n+import java.security.spec.RSAOtherPrimeInfo;\n+\n+/**\n+ * The interface to an RSA multi-prime private key, as defined in the PKCS#1\n+ * v2.1, using the <i>Chinese Remainder Theorem</i> (CRT) information values.\n+ *\n+ * @since 1.4\n+ * @see java.security.spec.RSAPrivateKeySpec\n+ * @see java.security.spec.RSAMultiPrimePrivateCrtKeySpec\n+ * @see RSAPrivateKey\n+ * @see RSAPrivateCrtKey\n+ */\n+public interface RSAMultiPrimePrivateCrtKey extends RSAPrivateKey\n+{\n+  // Constants\n+  // --------------------------------------------------------------------------\n+\n+  // Methods\n+  // --------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the public exponent.\n+   *\n+   * @return the public exponent.\n+   */\n+  BigInteger getPublicExponent();\n+\n+  /**\n+   * Returns the primeP.\n+   *\n+   * @return the primeP.\n+   */\n+  BigInteger getPrimeP();\n+\n+  /**\n+   * Returns the primeQ.\n+   *\n+   * @return the primeQ.\n+   */\n+  BigInteger getPrimeQ();\n+\n+  /**\n+   * Returns the primeExponentP.\n+   *\n+   * @return the primeExponentP.\n+   */\n+  BigInteger getPrimeExponentP();\n+\n+  /**\n+   * Returns the primeExponentQ.\n+   *\n+   * @return the primeExponentQ.\n+   */\n+  BigInteger getPrimeExponentQ();\n+\n+  /**\n+   * Returns the crtCoefficient.\n+   *\n+   * @return the crtCoefficient.\n+   */\n+  BigInteger getCrtCoefficient();\n+\n+  /**\n+   * Returns the otherPrimeInfo or <code>null</code> if there are only two\n+   * prime factors (p and q).\n+   *\n+   * @return the otherPrimeInfo.\n+   */\n+  RSAOtherPrimeInfo[] getOtherPrimeInfo();\n+}"}, {"sha": "c8aa913b4f7f8ae9256f125ccc6e1b01b4c379a5", "filename": "libjava/java/security/spec/PSSParameterSpec.java", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Fspec%2FPSSParameterSpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Fspec%2FPSSParameterSpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fspec%2FPSSParameterSpec.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -0,0 +1,90 @@\n+/* PSSParameterSpec.java --\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.security.spec;\n+\n+/**\n+ * This class specifies a parameter spec for RSA PSS encoding scheme, as\n+ * defined in the PKCS#1 v2.1.\n+ *\n+ * @since 1.4\n+ * @see AlgorithmParameterSpec\n+ * @see java.security.Signature\n+ */\n+public class PSSParameterSpec implements AlgorithmParameterSpec\n+{\n+  // Constants and fields\n+  // --------------------------------------------------------------------------\n+\n+  private int saltLen;\n+\n+  // Constructor(s)\n+  // --------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new <code>PSSParameterSpec</code> given the salt length as\n+   * defined in PKCS#1.\n+   *\n+   * @param saltLen the length of salt in bits to be used in PKCS#1 PSS encoding.\n+   * @throws IllegalArgumentException if <code>saltLen</code> is less than\n+   * <code>0</code>.\n+   */\n+  public PSSParameterSpec(int saltLen)\n+  {\n+    super();\n+\n+    if (saltLen < 0)\n+      throw new IllegalArgumentException();\n+    this.saltLen = saltLen;\n+  }\n+\n+  // Class methods\n+  // --------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // --------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the salt length in bits.\n+   *\n+   * @return the salt length.\n+   */\n+  public int getSaltLength()\n+  {\n+    return this.saltLen;\n+  }\n+}"}, {"sha": "f2cb88bafd124f1503523f0fdcb8ce03989558f1", "filename": "libjava/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.java", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Fspec%2FRSAMultiPrimePrivateCrtKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Fspec%2FRSAMultiPrimePrivateCrtKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fspec%2FRSAMultiPrimePrivateCrtKeySpec.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -0,0 +1,218 @@\n+/* PSSParameterSpec.java --\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.security.spec;\n+\n+import java.math.BigInteger;\n+import java.security.spec.RSAOtherPrimeInfo;\n+\n+/**\n+ * This class specifies an RSA multi-prime private key, as defined in the\n+ * PKCS#1 v2.1, using the <i>Chinese Remainder Theorem</i> (CRT) information\n+ * values for efficiency.\n+ *\n+ * @since 1.4\n+ * @see java.security.Key\n+ * @see java.security.KeyFactory\n+ * @see KeySpec\n+ * @see PKCS8EncodedKeySpec\n+ * @see RSAPrivateKeySpec\n+ * @see RSAPublicKeySpec\n+ * @see RSAOtherPrimeInfo\n+ */\n+public class RSAMultiPrimePrivateCrtKeySpec extends RSAPrivateKeySpec\n+{\n+  // Constants and fields\n+  // --------------------------------------------------------------------------\n+\n+  private BigInteger publicExponent;\n+  private BigInteger primeP;\n+  private BigInteger primeQ;\n+  private BigInteger primeExponentP;\n+  private BigInteger primeExponentQ;\n+  private BigInteger crtCoefficient;\n+  private RSAOtherPrimeInfo[] otherPrimeInfo;\n+\n+  // Constructor(s)\n+  // --------------------------------------------------------------------------\n+\n+  /**\n+   * <p>Creates a new <code>RSAMultiPrimePrivateCrtKeySpec</code> given the\n+   * modulus, publicExponent, privateExponent, primeP, primeQ, primeExponentP,\n+   * primeExponentQ, crtCoefficient, and otherPrimeInfo as defined in PKCS#1\n+   * v2.1.</p>\n+   *\n+   * <p>Note that <code>otherPrimeInfo</code> is cloned when constructing this\n+   * object.</p>\n+   *\n+   * @param modulus the modulus n.\n+   * @param publicExponent the public exponent e.\n+   * @param privateExponent the private exponent d.\n+   * @param primeP the prime factor p of n.\n+   * @param primeQ the prime factor q of n.\n+   * @param primeExponentP this is d mod (p-1).\n+   * @param primeExponentQ this is d mod (q-1).\n+   * @param crtCoefficient the Chinese Remainder Theorem coefficient q-1 mod p.\n+   * @param otherPrimeInfo triplets of the rest of primes, <code>null</code>\n+   * can be specified if there are only two prime factors (p and q).\n+   * @throws NullPointerException if any of the parameters, i.e. modulus,\n+   * publicExponent, privateExponent, primeP, primeQ, primeExponentP,\n+   * primeExponentQ, crtCoefficient, is <code>null</code>.\n+   * @throws IllegalArgumentException if an empty, i.e. 0-length,\n+   * otherPrimeInfo is specified.\n+   */\n+  public RSAMultiPrimePrivateCrtKeySpec(BigInteger modulus,\n+                                        BigInteger publicExponent,\n+                                        BigInteger privateExponent,\n+                                        BigInteger primeP,\n+                                        BigInteger primeQ,\n+                                        BigInteger primeExponentP,\n+                                        BigInteger primeExponentQ,\n+                                        BigInteger crtCoefficient,\n+                                        RSAOtherPrimeInfo[] otherPrimeInfo)\n+  {\n+    super(modulus, privateExponent);\n+\n+    if (modulus == null)\n+      throw new NullPointerException(\"modulus\");\n+    if (publicExponent == null)\n+      throw new NullPointerException(\"publicExponent\");\n+    if (privateExponent == null)\n+      throw new NullPointerException(\"privateExponent\");\n+    if (primeP == null)\n+      throw new NullPointerException(\"primeP\");\n+    if (primeQ == null)\n+      throw new NullPointerException(\"primeQ\");\n+    if (primeExponentP == null)\n+      throw new NullPointerException(\"primeExponentP\");\n+    if (primeExponentQ == null)\n+      throw new NullPointerException(\"primeExponentQ\");\n+    if (crtCoefficient == null)\n+      throw new NullPointerException(\"crtCoefficient\");\n+    if (otherPrimeInfo != null)\n+      if (otherPrimeInfo.length == 0)\n+        throw new IllegalArgumentException();\n+      else\n+        this.otherPrimeInfo = (RSAOtherPrimeInfo[]) otherPrimeInfo.clone();\n+\n+    this.publicExponent = publicExponent;\n+    this.primeP = primeP;\n+    this.primeQ = primeQ;\n+    this.primeExponentP = primeExponentP;\n+    this.primeExponentQ = primeExponentQ;\n+    this.crtCoefficient = crtCoefficient;\n+  }\n+\n+  // Class methods\n+  // --------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // --------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the public exponent.\n+   *\n+   * @return the public exponent.\n+   */\n+  public BigInteger getPublicExponent()\n+  {\n+    return this.publicExponent;\n+  }\n+\n+  /**\n+   * Returns the primeP.\n+   *\n+   * @return the primeP.\n+   */\n+  public BigInteger getPrimeP()\n+  {\n+    return this.primeP;\n+  }\n+\n+  /**\n+   * Returns the primeQ.\n+   *\n+   * @return the primeQ.\n+   */\n+  public BigInteger getPrimeQ()\n+  {\n+    return this.primeQ;\n+  }\n+\n+  /**\n+   * Returns the primeExponentP.\n+   *\n+   * @return the primeExponentP.\n+   */\n+  public BigInteger getPrimeExponentP()\n+  {\n+    return this.primeExponentP;\n+  }\n+\n+  /**\n+   * Returns the primeExponentQ.\n+   *\n+   * @return the primeExponentQ.\n+   */\n+  public BigInteger getPrimeExponentQ()\n+  {\n+    return this.primeExponentQ;\n+  }\n+\n+  /**\n+   * Returns the crtCoefficient.\n+   *\n+   * @return the crtCoefficient.\n+   */\n+  public BigInteger getCrtCoefficient()\n+  {\n+    return this.crtCoefficient;\n+  }\n+\n+  /**\n+   * Returns a copy of the otherPrimeInfo or <code>null</code> if there are\n+   * only two prime factors (p and q).\n+   *\n+   * @return the otherPrimeInfo.\n+   */\n+  public RSAOtherPrimeInfo[] getOtherPrimeInfo()\n+  {\n+    return this.otherPrimeInfo == null\n+        ? null\n+        : (RSAOtherPrimeInfo[]) this.otherPrimeInfo.clone();\n+  }\n+}"}, {"sha": "082101e16a0006ac8969b9410a84c707dbbd49b5", "filename": "libjava/java/security/spec/RSAOtherPrimeInfo.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Fspec%2FRSAOtherPrimeInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7451c1559ef877317965306543fd792944044b2c/libjava%2Fjava%2Fsecurity%2Fspec%2FRSAOtherPrimeInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fspec%2FRSAOtherPrimeInfo.java?ref=7451c1559ef877317965306543fd792944044b2c", "patch": "@@ -0,0 +1,133 @@\n+/* RSAOtherPrimeInfo.java --\n+   Copyright (C) 2003, Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.security.spec;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * This class represents the triplet (prime, exponent, and coefficient) inside\n+ * RSA's OtherPrimeInfo structure, as defined in the PKCS#1 v2.1. The ASN.1\n+ * syntax of RSA's OtherPrimeInfo is as follows:\n+ *\n+ * <pre>\n+ *  OtherPrimeInfo ::= SEQUENCE {\n+ *    prime INTEGER,\n+ *    exponent INTEGER,\n+ *    coefficient INTEGER\n+ *  }\n+ * </pre>\n+ *\n+ * @since 1.4\n+ * @see RSAPrivateCrtKeySpec\n+ * @see java.security.interfaces.RSAMultiPrimePrivateCrtKey\n+ */\n+public class RSAOtherPrimeInfo\n+{\n+  // Constants and fields\n+  // --------------------------------------------------------------------------\n+\n+  private BigInteger prime;\n+  private BigInteger primeExponent;\n+  private BigInteger crtCoefficient;\n+\n+  // Constructor(s)\n+  // --------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new <code>RSAOtherPrimeInfo</code> given the prime,\n+   * primeExponent, and crtCoefficient as defined in PKCS#1.\n+   *\n+   * @param prime the prime factor of n.\n+   * @param primeExponent the exponent.\n+   * @param crtCoefficient the Chinese Remainder Theorem coefficient.\n+   * @throws NullPointerException if any of the parameters, i.e. prime,\n+   * primeExponent, crtCoefficient, is <code>null</code>.\n+   */\n+  public RSAOtherPrimeInfo(BigInteger prime, BigInteger primeExponent,\n+                           BigInteger crtCoefficient)\n+  {\n+    super();\n+\n+    if (prime == null)\n+      throw new NullPointerException(\"prime\");\n+    if (primeExponent == null)\n+      throw new NullPointerException(\"primeExponent\");\n+    if (crtCoefficient == null)\n+      throw new NullPointerException(\"crtCoefficient\");\n+\n+    this.prime = prime;\n+    this.primeExponent = primeExponent;\n+    this.crtCoefficient = crtCoefficient;\n+  }\n+\n+  // Class methods\n+  // --------------------------------------------------------------------------\n+\n+  // Instance methods\n+  // --------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the prime.\n+   *\n+   * @return the prime.\n+   */\n+  public final BigInteger getPrime()\n+  {\n+    return this.prime;\n+  }\n+\n+  /**\n+   * Returns the prime's exponent.\n+   *\n+   * @return the primeExponent.\n+   */\n+  public final BigInteger getExponent()\n+  {\n+    return this.primeExponent;\n+  }\n+\n+  /**\n+   * Returns the prime's crtCoefficient.\n+   *\n+   * @return the crtCoefficient.\n+   */\n+  public final BigInteger getCrtCoefficient()\n+  {\n+    return this.crtCoefficient;\n+  }\n+}"}]}