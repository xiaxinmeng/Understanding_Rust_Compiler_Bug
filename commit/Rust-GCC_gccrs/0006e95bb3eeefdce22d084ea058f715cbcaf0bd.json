{"sha": "0006e95bb3eeefdce22d084ea058f715cbcaf0bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwNmU5NWJiM2VlZWZkY2UyMmQwODRlYTA1OGY3MTVjYmNhZjBiZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-12T23:09:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-12T23:09:22Z"}, "message": "(put_reg_into_stack): New arg volatile_p.\n\n(put_var_into_stack): Call with new arg.\n\nFrom-SVN: r10579", "tree": {"sha": "e7a652e5e8c104a75e6aa6daf537532f8b2ea67e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7a652e5e8c104a75e6aa6daf537532f8b2ea67e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0006e95bb3eeefdce22d084ea058f715cbcaf0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0006e95bb3eeefdce22d084ea058f715cbcaf0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0006e95bb3eeefdce22d084ea058f715cbcaf0bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0006e95bb3eeefdce22d084ea058f715cbcaf0bd/comments", "author": null, "committer": null, "parents": [{"sha": "eae26de54197dad4c48edfb1171fb331349fd845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae26de54197dad4c48edfb1171fb331349fd845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae26de54197dad4c48edfb1171fb331349fd845"}], "stats": {"total": 33, "additions": 19, "deletions": 14}, "files": [{"sha": "b3e710929348633a71f9f2ab02e372507e8c3b6d", "filename": "gcc/function.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0006e95bb3eeefdce22d084ea058f715cbcaf0bd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0006e95bb3eeefdce22d084ea058f715cbcaf0bd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0006e95bb3eeefdce22d084ea058f715cbcaf0bd", "patch": "@@ -424,7 +424,8 @@ struct fixup_replacement\n \n static struct temp_slot *find_temp_slot_from_address  PROTO((rtx));\n static void put_reg_into_stack\tPROTO((struct function *, rtx, tree,\n-\t\t\t\t       enum machine_mode, enum machine_mode));\n+\t\t\t\t       enum machine_mode, enum machine_mode,\n+\t\t\t\t       int));\n static void fixup_var_refs\tPROTO((rtx, enum machine_mode, int));\n static struct fixup_replacement\n   *find_fixup_replacement\tPROTO((struct fixup_replacement **, rtx));\n@@ -1261,7 +1262,7 @@ put_var_into_stack (decl)\n \n   if (GET_CODE (reg) == REG)\n     put_reg_into_stack (function, reg, TREE_TYPE (decl),\n-\t\t\tpromoted_mode, decl_mode);\n+\t\t\tpromoted_mode, decl_mode, TREE_SIDE_EFFECTS (decl));\n   else if (GET_CODE (reg) == CONCAT)\n     {\n       /* A CONCAT contains two pseudos; put them both in the stack.\n@@ -1270,19 +1271,21 @@ put_var_into_stack (decl)\n       tree part_type = TREE_TYPE (TREE_TYPE (decl));\n #ifdef FRAME_GROWS_DOWNWARD\n       /* Since part 0 should have a lower address, do it second.  */\n-      put_reg_into_stack (function, XEXP (reg, 1),\n-\t\t\t  part_type, part_mode, part_mode);\n-      put_reg_into_stack (function, XEXP (reg, 0),\n-\t\t\t  part_type, part_mode, part_mode);\n+      put_reg_into_stack (function, XEXP (reg, 1), part_type, part_mode,\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl));\n+      put_reg_into_stack (function, XEXP (reg, 0), part_type, part_mode,\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl));\n #else\n-      put_reg_into_stack (function, XEXP (reg, 0),\n-\t\t\t  part_type, part_mode, part_mode);\n-      put_reg_into_stack (function, XEXP (reg, 1),\n-\t\t\t  part_type, part_mode, part_mode);\n+      put_reg_into_stack (function, XEXP (reg, 0), part_type, part_mode,\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl));\n+      put_reg_into_stack (function, XEXP (reg, 1), part_type, part_mode,\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl));\n #endif\n \n       /* Change the CONCAT into a combined MEM for both parts.  */\n       PUT_CODE (reg, MEM);\n+      MEM_VOLATILE_P (reg) = MEM_VOLATILE_P (XEXP (reg, 0));\n+\n       /* The two parts are in memory order already.\n \t Use the lower parts address as ours.  */\n       XEXP (reg, 0) = XEXP (XEXP (reg, 0), 0);\n@@ -1295,14 +1298,16 @@ put_var_into_stack (decl)\n /* Subroutine of put_var_into_stack.  This puts a single pseudo reg REG\n    into the stack frame of FUNCTION (0 means the current function).\n    DECL_MODE is the machine mode of the user-level data type.\n-   PROMOTED_MODE is the machine mode of the register.  */\n+   PROMOTED_MODE is the machine mode of the register.\n+   VOLATILE_P is nonzero if this is for a \"volatile\" decl.  */\n \n static void\n-put_reg_into_stack (function, reg, type, promoted_mode, decl_mode)\n+put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p)\n      struct function *function;\n      rtx reg;\n      tree type;\n      enum machine_mode promoted_mode, decl_mode;\n+     int volatile_p;\n {\n   rtx new = 0;\n \n@@ -1322,11 +1327,11 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode)\n \tnew = assign_stack_local (decl_mode, GET_MODE_SIZE (decl_mode), 0);\n     }\n \n+  PUT_MODE (reg, decl_mode);\n   XEXP (reg, 0) = XEXP (new, 0);\n   /* `volatil' bit means one thing for MEMs, another entirely for REGs.  */\n-  REG_USERVAR_P (reg) = 0;\n+  MEM_VOLATILE_P (reg) = volatile_p;\n   PUT_CODE (reg, MEM);\n-  PUT_MODE (reg, decl_mode);\n \n   /* If this is a memory ref that contains aggregate components,\n      mark it as such for cse and loop optimize.  */"}]}