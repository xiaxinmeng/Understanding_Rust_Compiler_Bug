{"sha": "7373d92d2f7827d896b80e54c4bf9bd8ef6cf978", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM3M2Q5MmQyZjc4MjdkODk2YjgwZTU0YzRiZjliZDhlZjZjZjk3OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-11T10:43:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-11T10:43:58Z"}, "message": "(expand_call, emit_library_call{,_value}, store_one_arg): Use\nconvert_modes instead of convert_to_mode.\n\nFrom-SVN: r7026", "tree": {"sha": "f3cfe9b1e7cf0901c27128edc79b349709b4e6c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3cfe9b1e7cf0901c27128edc79b349709b4e6c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7373d92d2f7827d896b80e54c4bf9bd8ef6cf978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7373d92d2f7827d896b80e54c4bf9bd8ef6cf978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7373d92d2f7827d896b80e54c4bf9bd8ef6cf978", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7373d92d2f7827d896b80e54c4bf9bd8ef6cf978/comments", "author": null, "committer": null, "parents": [{"sha": "678566a5af9e48dc2eb9bcaa84a8741412697471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/678566a5af9e48dc2eb9bcaa84a8741412697471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/678566a5af9e48dc2eb9bcaa84a8741412697471"}], "stats": {"total": 20, "additions": 11, "deletions": 9}, "files": [{"sha": "285fb8f9b5870035c9ffd600560ac008cb22a758", "filename": "gcc/calls.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7373d92d2f7827d896b80e54c4bf9bd8ef6cf978/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7373d92d2f7827d896b80e54c4bf9bd8ef6cf978/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=7373d92d2f7827d896b80e54c4bf9bd8ef6cf978", "patch": "@@ -1287,10 +1287,12 @@ expand_call (exp, target, ignore)\n \targs[i].initial_value = args[i].value\n \t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n \n-\tif (GET_MODE (args[i].value ) != VOIDmode\n-\t    && GET_MODE (args[i].value) != args[i].mode)\n-\t  args[i].value = convert_to_mode (args[i].mode, args[i].value,\n-\t\t\t\t\t   args[i].unsignedp);\n+\tif (TYPE_MODE (TREE_TYPE (args[i].tree_value)) != args[i].mode)\n+\t  args[i].value\n+\t    = convert_modes (args[i].mode, \n+\t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n+\t\t\t     args[i].value, args[i].unsignedp);\n+\n \tpreserve_temp_slots (args[i].value);\n \tpop_temp_slots ();\n \n@@ -2174,7 +2176,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t Pass it as a double instead.  */\n #ifdef LIBGCC_NEEDS_DOUBLE\n       if (LIBGCC_NEEDS_DOUBLE && mode == SFmode)\n-\tval = convert_to_mode (DFmode, val, 0), mode = DFmode;\n+\tval = convert_modes (DFmode, SFmode, val, 0), mode = DFmode;\n #endif\n \n       /* There's no need to call protect_from_queue, because\n@@ -2525,7 +2527,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t Pass it as a double instead.  */\n #ifdef LIBGCC_NEEDS_DOUBLE\n       if (LIBGCC_NEEDS_DOUBLE && mode == SFmode)\n-\tval = convert_to_mode (DFmode, val, 0), mode = DFmode;\n+\tval = convert_modes (DFmode, SFmode, val, 0), mode = DFmode;\n #endif\n \n       /* There's no need to call protect_from_queue, because\n@@ -2955,9 +2957,9 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n       /* If we are promoting object (or for any other reason) the mode\n \t doesn't agree, convert the mode.  */\n \n-      if (GET_MODE (arg->value) != VOIDmode\n-\t  && GET_MODE (arg->value) != arg->mode)\n-\targ->value = convert_to_mode (arg->mode, arg->value, arg->unsignedp);\n+      if (arg->mode != TYPE_MODE (TREE_TYPE (pval)))\n+\targ->value = convert_modes (arg->mode, TYPE_MODE (TREE_TYPE (pval)),\n+\t\t\t\t    arg->value, arg->unsignedp);\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n       if (arg->pass_on_stack)"}]}