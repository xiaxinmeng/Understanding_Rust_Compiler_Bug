{"sha": "0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg2NWM2MzE0ZWYwNTQyY2Y5MTVmMWEwN2U0YWQ0M2E5Y2QwZDJlOQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-08-02T15:44:50Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-08-02T15:44:50Z"}, "message": "Unroll my commit of 1999/08/01 16:14:58, there was a communications mixup\nabout its status.\n\nFrom-SVN: r28403", "tree": {"sha": "0590639133f50d9e0624a4599e7d51eeca1c9bce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0590639133f50d9e0624a4599e7d51eeca1c9bce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/comments", "author": null, "committer": null, "parents": [{"sha": "ccc0b2f9b51cbdc92aded8e71484d6b2b3e5fdfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc0b2f9b51cbdc92aded8e71484d6b2b3e5fdfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc0b2f9b51cbdc92aded8e71484d6b2b3e5fdfd"}], "stats": {"total": 167, "additions": 56, "deletions": 111}, "files": [{"sha": "e82875745acaca5e61bbbe4f1290e3da18b38164", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "patch": "@@ -36,44 +36,6 @@ Sun Aug  1 20:14:00 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* tree.h (init_dummy_function_start): Declare.\n \n-Sun Jul 25 19:32:58 1999  Geoff Keating  <geoffk@cygnus.com>\n-\n-\t* config/rs6000/rs6000.c (num_insns_constant_wide): Correct\n-\tfor type promotion.\n-\t(add_operand): Get test correct for 64-bit HOST_WIDE_INT.\n-\t(non_add_cint_operand): Likewise.\n-\t(logical_operand): Likewise.\n-\t(non_logical_cint_operand): Likewise.\n-\t(print_operand): Correct printf()s for 64-bit HOST_WIDE_INT.\n-\t(print_operand_address): Correct printf() for 64-bit HOST_WIDE_INT.\n-\t(rs6000_select_rtx_section): Suppress warning.\n-\t(small_data_operand): Suppress warning.\n-\t(rs6000_got_register): Suppress warning.\n-\t* config/rs6000/rs6000.md (andsi3): HOST_WIDE_INT is a signed\n-\ttype, so `J' is generally the wrong constraint for a SImode value;\n-\tuse `L' instead.\n-\t(andsi3_internal2): Likewise.\n-\t(andsi3_internal3): Likewise.\n-\t(iorsi3_internal1): Likewise.\n-\t(xorsi3_internal1): Likewise.\n-\t(movsi): Likewise.\n-\t(movsf_softfloat): Likewise.\n-\tvarious unnamed compare insns: Likewise.\n-\t(movsi+2): Preserve sign bits of SImode constant.\n-\t(floatsidf2_internal+1): Sign-extend SImode constant correctly.\n-\t(movdf+1): Preserve high bits of DFmode constant.\n-\t(movdi_32+1): Sign-extend properly.\n-\tvarious unnamed compare insns: Sign-extend properly.\n-\n-\t* unroll.c (loop_iterations): Convert HOST_WIDE_INT to unsigned\n-\tproperly for mode.\n-\t* expmed.c (expand_mult_highpart): Convert HOST_WIDE_INT from unsigned\n-\tproperly for mode.\n-\t(expand_divmod): Likewise.\n-\t* optabs.c (expand_fix): Keep HOST_WIDE_INT constants properly signed.\n-\t(expand_binop): Sometimes there is work to do when changing\n-\tthe mode of a CONST_INT.\n-\n Sun Aug  1 12:55:31 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* stmt.c (emit_filename, emit_lineno, expr_stmts_for_value,"}, {"sha": "6987b2be6a31f47557dff77e19201cb6f218872f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "patch": "@@ -666,11 +666,16 @@ num_insns_constant_wide (value)\n   if (((unsigned HOST_WIDE_INT)value + 0x8000) < 0x10000)\n     return 1;\n \n+#if HOST_BITS_PER_WIDE_INT == 32\n+  /* constant loadable with {cau|addis} */\n+  else if ((value & 0xffff) == 0)\n+    return 1;\n+\n+#else\n   /* constant loadable with {cau|addis} */\n-  else if (CONST_OK_FOR_LETTER_P (value, 'L'))\n+  else if ((value & 0xffff) == 0 && (value & ~0xffffffff) == 0)\n     return 1;\n \n-#if HOST_BITS_PER_WIDE_INT == 64\n   else if (TARGET_64BIT)\n     {\n       HOST_WIDE_INT low  = value & 0xffffffff;\n@@ -875,7 +880,7 @@ mem_or_easy_const_operand (op, mode)\n }\n \n /* Return 1 if the operand is either a non-special register or an item\n-   that can be used as the operand of a `mode' add insn.  */\n+   that can be used as the operand of an SI add insn.  */\n \n int\n add_operand (op, mode)\n@@ -884,7 +889,7 @@ add_operand (op, mode)\n {\n   return (reg_or_short_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL(op), 'L')));\n+\t      && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) == 0));\n }\n \n /* Return 1 if OP is a constant but not a valid add_operand.  */\n@@ -896,7 +901,7 @@ non_add_cint_operand (op, mode)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) >= 0x10000\n-\t  && ! CONST_OK_FOR_LETTER_P (INTVAL(op), 'L'));\n+\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) != 0);\n }\n \n /* Return 1 if the operand is a non-special register or a constant that\n@@ -909,10 +914,8 @@ logical_operand (op, mode)\n {\n   return (gpc_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n-\t      && ((INTVAL (op) & GET_MODE_MASK (mode)\n-\t\t   & (~ (HOST_WIDE_INT) 0xffff)) == 0\n-\t\t  || (INTVAL (op) & GET_MODE_MASK (mode)\n-\t\t      & (~ (HOST_WIDE_INT) 0xffff0000)) == 0)));\n+\t      && ((INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0\n+\t\t  || (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) == 0)));\n }\n \n /* Return 1 if C is a constant that is not a logical operand (as\n@@ -921,13 +924,11 @@ logical_operand (op, mode)\n int\n non_logical_cint_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) & GET_MODE_MASK (mode) &\n-\t      (~ (HOST_WIDE_INT) 0xffff)) != 0\n-\t  && (INTVAL (op) & GET_MODE_MASK (mode) &\n-\t      (~ (HOST_WIDE_INT) 0xffff0000)) != 0);\n+\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) != 0\n+\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) != 0);\n }\n \n /* Return 1 if C is a constant that can be encoded in a 32-bit mask on the\n@@ -1197,7 +1198,7 @@ small_data_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n #if TARGET_ELF\n-  rtx sym_ref;\n+  rtx sym_ref, const_part;\n \n   if (rs6000_sdata == SDATA_NONE || rs6000_sdata == SDATA_DATA)\n     return 0;\n@@ -2473,7 +2474,7 @@ ccr_bit (op, scc_p)\n \n struct rtx_def *\n rs6000_got_register (value)\n-     rtx value ATTRIBUTE_UNUSED;\n+     rtx value;\n {\n   /* The second flow pass currently (June 1999) can't update regs_ever_live\n      without disturbing other parts of the compiler, so update it here to\n@@ -2626,7 +2627,7 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%b value\");\n \n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 0xffff);\n+      fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n       return;\n \n     case 'B':\n@@ -2712,7 +2713,7 @@ print_operand (file, x, code)\n       /* If constant, output low-order five bits.  Otherwise,\n \t write normally. */\n       if (INT_P (x))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 31);\n+\tfprintf (file, \"%d\", INT_LOWPART (x) & 31);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -2721,7 +2722,7 @@ print_operand (file, x, code)\n       /* If constant, output low-order six bits.  Otherwise,\n \t write normally. */\n       if (INT_P (x))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 63);\n+\tfprintf (file, \"%d\", INT_LOWPART (x) & 63);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -2758,7 +2759,7 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%k value\");\n \n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, ~ INT_LOWPART (x));\n+      fprintf (file, \"%d\", ~ INT_LOWPART (x));\n       return;\n \n     case 'L':\n@@ -2902,7 +2903,7 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%s value\");\n \n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, (32 - INT_LOWPART (x)) & 31);\n+      fprintf (file, \"%d\", (32 - INT_LOWPART (x)) & 31);\n       return;\n \n     case 'S':\n@@ -3005,8 +3006,7 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%u value\");\n \n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, \n-\t       (INT_LOWPART (x) >> 16) & 0xffff);\n+      fprintf (file, \"0x%x\", (INT_LOWPART (x) >> 16) & 0xffff);\n       return;\n \n     case 'v':\n@@ -3076,8 +3076,7 @@ print_operand (file, x, code)\n       /* If constant, low-order 16 bits of constant, signed.  Otherwise, write\n \t normally.  */\n       if (INT_P (x))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, \n-\t\t ((INT_LOWPART (x) & 0xffff) ^ 0x8000) - 0x8000);\n+\tfprintf (file, \"%d\", ((INT_LOWPART (x) & 0xffff) ^ 0x8000) - 0x8000);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -3086,7 +3085,7 @@ print_operand (file, x, code)\n       /* If constant, low-order 16 bits of constant, unsigned.\n \t Otherwise, write normally.  */\n       if (INT_P (x))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 0xffff);\n+\tfprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -3222,10 +3221,7 @@ print_operand_address (file, x)\n \t\t reg_names[ REGNO (XEXP (x, 1)) ]);\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    {\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (x, 1)));\n-      fprintf (file, \"(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n-    }\n+    fprintf (file, \"%d(%s)\", INTVAL (XEXP (x, 1)), reg_names[ REGNO (XEXP (x, 0)) ]);\n #if TARGET_ELF\n   else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n            && CONSTANT_P (XEXP (x, 1)))\n@@ -5653,7 +5649,7 @@ rs6000_longcall_ref (call_ref)\n \n void\n rs6000_select_rtx_section (mode, x)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n      rtx x;\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x))"}, {"sha": "baf0243f425e63898b83824832888eeb158b73ac", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "patch": "@@ -1938,7 +1938,7 @@\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n \t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"?r,T,K,L\")))\n+\t\t(match_operand:SI 2 \"and_operand\" \"?r,T,K,J\")))\n    (clobber (match_scratch:CC 3 \"=X,X,x,x\"))]\n   \"\"\n   \"@\n@@ -1955,7 +1955,7 @@\n (define_insn \"*andsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n \t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,J,T,r,K,J,T\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=r,r,r,r,r,r,r,r\"))\n    (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n@@ -1992,7 +1992,7 @@\n (define_insn \"*andsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n \t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,J,T,r,K,J,T\"))\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r\")\n \t(and:SI (match_dup 1)\n@@ -2054,7 +2054,7 @@\n (define_insn \"*iorsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,L\")))]\n+\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n   \"\"\n   \"@\n    or %0,%1,%2\n@@ -2161,7 +2161,7 @@\n (define_insn \"*xorsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,L\")))]\n+\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n   \"\"\n   \"@\n    xor %0,%1,%2\n@@ -4226,7 +4226,7 @@\n \t\t  (match_dup 3)))]\n   \"\n {\n-  operands[6] = GEN_INT (~ (HOST_WIDE_INT) 0x7fffffff);\n+  operands[6] = GEN_INT (0x80000000);\n   operands[7] = gen_rtx_REG (DFmode, FPMEM_REGNUM);\n }\")\n \n@@ -6127,7 +6127,7 @@\n \t\t(match_dup 3)))]\n   \"\n {\n-  operands[2] = GEN_INT (INTVAL (operands[1]) & (~ (HOST_WIDE_INT) 0xffff));\n+  operands[2] = GEN_INT (INTVAL (operands[1]) & 0xffff0000);\n   operands[3] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n }\")\n \n@@ -6383,7 +6383,7 @@\n   int endian = (WORDS_BIG_ENDIAN == 0);\n   operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n   operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n-  operands[4] = GEN_INT(INTVAL (operands[1]) >> 31 >> 1);\n+  operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n }\")\n \n (define_split\n@@ -6740,14 +6740,13 @@\n    (set (match_dup 3) (match_dup 1))]\n   \"\n {\n-  HOST_WIDE_INT value = INTVAL (operands[1]);\n   operands[2] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n   operands[3] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n #if HOST_BITS_PER_WIDE_INT == 32\n-  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n+  operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n #else\n-  operands[4] = GEN_INT (value >> 32);\n-  operands[1] = GEN_INT ((value & 0x7fffffff) - (value & 0x80000000));\n+  operands[4] = GEN_INT ((HOST_WIDE_INT) INTVAL (operands[1]) >> 32);\n+  operands[1] = GEN_INT (INTVAL (operands[1]) & 0xffffffff);\n #endif\n }\")\n \n@@ -8894,9 +8893,9 @@\n      sign-extended to 16 bits.  Then see what constant could be XOR'ed\n      with C to get the sign-extended value.  */\n \n-  HOST_WIDE_INT c = INTVAL (operands[2]);\n-  HOST_WIDE_INT sextc = (c & 0x7fff) - (c & 0x8000);\n-  HOST_WIDE_INT xorv = c ^ sextc;\n+  int c = INTVAL (operands[2]);\n+  int sextc = (c << 16) >> 16;\n+  int xorv = c ^ sextc;\n \n   operands[4] = GEN_INT (xorv);\n   operands[5] = GEN_INT (sextc);\n@@ -9129,7 +9128,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\")))\n+\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\")))\n    (clobber (match_scratch:SI 3 \"=r,&r,r,r,r\"))]\n   \"\"\n   \"@\n@@ -9158,7 +9157,7 @@\n   [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,x,x,x\")\n \t(compare:CC\n \t (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n+\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n \t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(eq:SI (match_dup 1) (match_dup 2)))\n@@ -9210,7 +9209,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(plus:SI (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n+\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n \t\t (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r\")))\n    (clobber (match_scratch:SI 4 \"=&r,&r,&r,&r,&r\"))]\n   \"\"\n@@ -9227,7 +9226,7 @@\n \t(compare:CC\n \t (plus:SI\n \t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n+\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n \t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r\"))\n \t (const_int 0)))\n    (clobber (match_scratch:SI 4 \"=&r,&r,&r,&r,&r\"))]\n@@ -9246,7 +9245,7 @@\n \t(compare:CC\n \t (plus:SI\n \t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n+\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n \t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r\"))\n \t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n@@ -9265,7 +9264,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(neg:SI (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))))]\n+\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))))]\n   \"\"\n   \"@\n    xor %0,%1,%2\\;{ai|addic} %0,%0,-1\\;{sfe|subfe} %0,%0,%0"}, {"sha": "ffe16fedaf47f142417a45ed004a5ec217afaf7a", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "patch": "@@ -2718,13 +2718,13 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n   int size = GET_MODE_BITSIZE (mode);\n   rtx op1, wide_op1;\n \n-  /* We can't support modes wider than HOST_BITS_PER_WIDE_INT.  */\n+  /* We can't support modes wider than HOST_BITS_PER_INT.  */\n   if (size > HOST_BITS_PER_WIDE_INT)\n     abort ();\n \n-  op1 = GEN_INT (cnst1 | -(cnst1 & ((HOST_WIDE_INT) 1 << (size - 1))));\n+  op1 = GEN_INT (cnst1);\n \n-  if (GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_WIDE_INT)\n+  if (GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_INT)\n     wide_op1 = op1;\n   else\n     wide_op1\n@@ -3726,8 +3726,6 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n \t    post_shift = floor_log2 (d & -d);\n \t    ml = invert_mod2n (d >> post_shift, size);\n-\t    /* Sign-extend ml for compute_mode.  */\n-\t    ml |= -(ml & (1 << (GET_MODE_BITSIZE (compute_mode)-1)));\n \t    t1 = expand_mult (compute_mode, op0, GEN_INT (ml), NULL_RTX,\n \t\t\t      unsignedp);\n \t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, t1,"}, {"sha": "11a4001e6821c1de885196c953c113b507ce421f", "filename": "gcc/md.texi", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "patch": "@@ -1384,14 +1384,13 @@ Floating point register\n Signed 16 bit constant\n \n @item J\n-Unsigned 16 bit constant shifted left 16 bits (use @samp{L} instead for \n-@code{SImode} constants)\n+Constant whose low 16 bits are 0\n \n @item K\n-Unsigned 16 bit constant\n+Constant whose high 16 bits are 0\n \n @item L\n-Signed 16 bit constant shifted left 16 bits\n+Constant suitable as a mask operand\n \n @item M\n Constant larger than 31\n@@ -1419,9 +1418,6 @@ AIX TOC entry\n @item S\n Constant suitable as a 64-bit mask operand\n \n-@item T\n-Constant suitable as a 32-bit mask operand\n-\n @item U\n System V Release 4 small data area reference\n @end table"}, {"sha": "2b9091bcf4e05c0f59aa876dd8db646f7310a484", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "patch": "@@ -857,12 +857,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       /* In case the insn wants input operands in modes different from\n \t the result, convert the operands.  */\n \n-      if ((GET_MODE (op0) != VOIDmode || GET_CODE (op0) == CONST_INT)\n+      if (GET_MODE (op0) != VOIDmode\n \t  && GET_MODE (op0) != mode0\n \t  && mode0 != VOIDmode)\n \txop0 = convert_to_mode (mode0, xop0, unsignedp);\n \n-      if ((GET_MODE (xop1) != VOIDmode || GET_CODE (xop1) == CONST_INT)\n+      if (GET_MODE (xop1) != VOIDmode\n \t  && GET_MODE (xop1) != mode1\n \t  && mode1 != VOIDmode)\n \txop1 = convert_to_mode (mode1, xop1, unsignedp);\n@@ -4231,7 +4231,7 @@ expand_fix (to, from, unsignedp)\n \t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t  expand_fix (to, target, 0);\n \t  target = expand_binop (GET_MODE (to), xor_optab, to,\n-\t\t\t\t GEN_INT ((HOST_WIDE_INT) -1 << (bitsize - 1)),\n+\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1 << (bitsize - 1)),\n \t\t\t\t to, 1, OPTAB_LIB_WIDEN);\n \n \t  if (target != to)"}, {"sha": "d6dbcf0fbc1d151382bbb30773d1bb03d661cec8", "filename": "gcc/unroll.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=0865c6314ef0542cf915f1a07e4ad43a9cd0d2e9", "patch": "@@ -3588,7 +3588,6 @@ loop_iterations (loop_start, loop_end, loop_info)\n   rtx comparison, comparison_value;\n   rtx iteration_var, initial_value, increment, final_value;\n   enum rtx_code comparison_code;\n-  enum machine_mode comparison_mode;\n   HOST_WIDE_INT abs_inc;\n   unsigned HOST_WIDE_INT abs_diff;\n   int off_by_one;\n@@ -3653,7 +3652,6 @@ loop_iterations (loop_start, loop_end, loop_info)\n      invariant register when it canonicalizes the comparison.  */\n \n   comparison_code = GET_CODE (comparison);\n-  comparison_mode = GET_MODE (comparison);\n   iteration_var = XEXP (comparison, 0);\n   comparison_value = XEXP (comparison, 1);\n \n@@ -3993,10 +3991,6 @@ loop_iterations (loop_start, loop_end, loop_info)\n   else\n     abort ();\n \n-  /* It may be that comparison_mode is smaller than a HOST_WIDE_INT,\n-     for instance on a 64-bit host when comparison_mode is SImode.  */\n-  abs_diff &= GET_MODE_MASK (comparison_mode);\n-\n   /* For NE tests, make sure that the iteration variable won't miss\n      the final value.  If abs_diff mod abs_incr is not zero, then the\n      iteration variable will overflow before the loop exits, and we"}]}