{"sha": "954a5693c0d9adf74cb0954c3006ce54d43f7661", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU0YTU2OTNjMGQ5YWRmNzRjYjA5NTRjMzAwNmNlNTRkNDNmNzY2MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-05-17T20:00:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-05-17T20:00:55Z"}, "message": "(notreg_cost): New function, extracted from COST macro.\n\n(COST): Use notreg_cost.\n\nFrom-SVN: r14075", "tree": {"sha": "d2c0272f19ba6b8489396e70821d0380cb6336ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2c0272f19ba6b8489396e70821d0380cb6336ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/954a5693c0d9adf74cb0954c3006ce54d43f7661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954a5693c0d9adf74cb0954c3006ce54d43f7661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954a5693c0d9adf74cb0954c3006ce54d43f7661", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954a5693c0d9adf74cb0954c3006ce54d43f7661/comments", "author": null, "committer": null, "parents": [{"sha": "50196afaca12b3d80a75fd1d5c4c7fca44e6ba75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50196afaca12b3d80a75fd1d5c4c7fca44e6ba75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50196afaca12b3d80a75fd1d5c4c7fca44e6ba75"}], "stats": {"total": 37, "additions": 24, "deletions": 13}, "files": [{"sha": "df64afae27a852b0dc9218054b6c95443053cdc0", "filename": "gcc/cse.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954a5693c0d9adf74cb0954c3006ce54d43f7661/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954a5693c0d9adf74cb0954c3006ce54d43f7661/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=954a5693c0d9adf74cb0954c3006ce54d43f7661", "patch": "@@ -483,19 +483,7 @@ struct table_elt\n    ? (CHEAP_REG (X) ? 0\t\t\t\t\t\t\t\\\n       : REGNO (X) >= FIRST_PSEUDO_REGISTER ? 1\t\t\t\t\\\n       : 2)\t\t\t\t\t\t\t\t\\\n-   : ((GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-       && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\\n-       && GET_MODE_CLASS (GET_MODE (SUBREG_REG (X))) == MODE_INT\t\\\n-       && (GET_MODE_SIZE (GET_MODE (X))\t\t\t\t\t\\\n-\t   < GET_MODE_SIZE (GET_MODE (SUBREG_REG (X))))\t\t\t\\\n-       && subreg_lowpart_p (X)\t\t\t\t\t\t\\\n-       && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE (X)),\t\\\n-\t\t\t\t GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (X))))) \\\n-      ? (CHEAP_REG (SUBREG_REG (X)) ? 0\t\t\t\t\t\\\n-\t : REGNO (SUBREG_REG (X)) >= FIRST_PSEUDO_REGISTER ? 1\t\t\\\n-\t : 2)\t\t\t\t\t\t\t\t\\\n-      : rtx_cost (X, SET) * 2))\n+   : notreg_cost(X))\n \n /* Determine if the quantity number for register X represents a valid index\n    into the `qty_...' variables.  */\n@@ -620,6 +608,7 @@ struct cse_basic_block_data {\n \t   || XEXP (X, 0) == virtual_stack_dynamic_rtx\t\t\\\n \t   || XEXP (X, 0) == virtual_outgoing_args_rtx)))\n \n+static int notreg_cost\t\tPROTO((rtx));\n static void new_basic_block\tPROTO((void));\n static void make_new_qty\tPROTO((int));\n static void make_regs_eqv\tPROTO((int, int));\n@@ -685,6 +674,28 @@ extern int rtx_equal_function_value_matters;\n    Another is in rtl generation, to pick the cheapest way to multiply.\n    Other uses like the latter are expected in the future.  */\n \n+/* Internal function, to compute cost when X is not a register; called\n+   from COST macro to keep it simple.  */\n+\n+static int\n+notreg_cost (x)\n+     rtx x;\n+{\n+  return ((GET_CODE (x) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (x)) == REG\n+\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n+\t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_INT\n+\t   && (GET_MODE_SIZE (GET_MODE (x))\n+\t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t   && subreg_lowpart_p (x)\n+\t   && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE (x)),\n+\t\t\t\t     GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))))\n+\t  ? (CHEAP_REG (SUBREG_REG (x)) ? 0\n+\t     : (REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER ? 1\n+\t\t: 2))\n+\t  : rtx_cost (x, SET) * 2);\n+}\n+\n /* Return the right cost to give to an operation\n    to make the cost of the corresponding register-to-register instruction\n    N times that of a fast register-to-register instruction.  */"}]}