{"sha": "b0887a432e679835dba79c5d6825f110bdf8a138", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA4ODdhNDMyZTY3OTgzNWRiYTc5YzVkNjgyNWYxMTBiZGY4YTEzOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T07:05:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T07:05:08Z"}, "message": "[multiple changes]\n\n2010-10-11  Javier Miranda  <miranda@adacore.com>\n\n\t* a-textio.adb: Move new implementation of Get_Line to a subunit.\n\t* a-tigeli.adb: New subunit containing the implementation of Get_Line.\n\n2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aux.adb: Code clean up.\n\nFrom-SVN: r165272", "tree": {"sha": "d5ecd111565223f691ba48e2126707ce03dd10f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5ecd111565223f691ba48e2126707ce03dd10f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0887a432e679835dba79c5d6825f110bdf8a138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0887a432e679835dba79c5d6825f110bdf8a138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0887a432e679835dba79c5d6825f110bdf8a138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0887a432e679835dba79c5d6825f110bdf8a138/comments", "author": null, "committer": null, "parents": [{"sha": "e0ae93e2ea3775ff2a3256c651ca9b285e2538cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ae93e2ea3775ff2a3256c651ca9b285e2538cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ae93e2ea3775ff2a3256c651ca9b285e2538cc"}], "stats": {"total": 439, "additions": 243, "deletions": 196}, "files": [{"sha": "0959150d389455efbdbd205b75a38cd279f9a4d4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b0887a432e679835dba79c5d6825f110bdf8a138", "patch": "@@ -1,3 +1,12 @@\n+2010-10-11  Javier Miranda  <miranda@adacore.com>\n+\n+\t* a-textio.adb: Move new implementation of Get_Line to a subunit.\n+\t* a-tigeli.adb: New subunit containing the implementation of Get_Line.\n+\n+2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aux.adb: Code clean up.\n+\n 2010-10-11  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sem_aux.adb, sem_ch6.adb: Minor reformatting"}, {"sha": "f8538abde51abdd0a871316779f1c69e69bdcd24", "filename": "gcc/ada/a-textio.adb", "status": "modified", "additions": 1, "deletions": 190, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2Fa-textio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2Fa-textio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.adb?ref=b0887a432e679835dba79c5d6825f110bdf8a138", "patch": "@@ -32,8 +32,6 @@\n with Ada.Streams;             use Ada.Streams;\n with Interfaces.C_Streams;    use Interfaces.C_Streams;\n \n-with System;                  use System;\n-with System.Storage_Elements; use System.Storage_Elements;\n with System.File_IO;\n with System.CRTL;\n with System.WCh_Cnv;          use System.WCh_Cnv;\n@@ -686,197 +684,10 @@ package body Ada.Text_IO is\n       Get_Immediate (Current_In, Item, Available);\n    end Get_Immediate;\n \n-   --------------\n-   -- Get_Line --\n-   --------------\n-\n    procedure Get_Line\n      (File : File_Type;\n       Item : out String;\n-      Last : out Natural)\n-   is\n-      Chunk_Size : constant := 80;\n-      --  We read into a fixed size auxiliary buffer. Because this buffer\n-      --  needs to be pre-initialized, there is a trade-off between size and\n-      --  speed. Experiments find returns are diminishing after 50 and this\n-      --  size allows most lines to be processed with a single read.\n-\n-      ch : int;\n-      N  : Natural;\n-\n-      procedure memcpy (s1, s2 : chars; n : size_t);\n-      pragma Import (C, memcpy);\n-\n-      function memchr (s : chars; ch : int; n : size_t) return chars;\n-      pragma Import (C, memchr);\n-\n-      procedure memset (b : chars; ch : int; n : size_t);\n-      pragma Import (C, memset);\n-\n-      function Get_Chunk (N : Positive) return Natural;\n-      --  Reads at most N - 1 characters into Item (Last + 1 .. Item'Last),\n-      --  updating Last. Raises End_Error if nothing was read (End_Of_File).\n-      --  Returns number of characters still to read (either 0 or 1) in\n-      --  case of success.\n-\n-      ---------------\n-      -- Get_Chunk --\n-      ---------------\n-\n-      function Get_Chunk (N : Positive) return Natural is\n-         Buf : String (1 .. Chunk_Size);\n-         S   : constant chars := Buf (1)'Address;\n-         P   : chars;\n-\n-      begin\n-         if N = 1 then\n-            return N;\n-         end if;\n-\n-         memset (S, 10, size_t (N));\n-\n-         if fgets (S, N, File.Stream) = Null_Address then\n-            if ferror (File.Stream) /= 0 then\n-               raise Device_Error;\n-\n-            --  If incomplete last line, pretend we found a LM\n-\n-            elsif Last >= Item'First then\n-               return 0;\n-\n-            else\n-               raise End_Error;\n-            end if;\n-         end if;\n-\n-         P := memchr (S, LM, size_t (N));\n-\n-         --  If no LM is found, the buffer got filled without reading a new\n-         --  line. Otherwise, the LM is either one from the input, or else one\n-         --  from the initialization, which means an incomplete end-of-line was\n-         --  encountered. Only in first case the LM will be followed by a 0.\n-\n-         if P = Null_Address then\n-            pragma Assert (Buf (N) = ASCII.NUL);\n-            memcpy (Item (Last + 1)'Address,\n-                    Buf (1)'Address, size_t (N - 1));\n-            Last := Last + N - 1;\n-\n-            return 1;\n-\n-         else\n-            --  P points to the LM character. Set K so Buf (K) is the character\n-            --  right before.\n-\n-            declare\n-               K : Natural := Natural (P - S);\n-\n-            begin\n-               --  Now Buf (K + 2) should be 0, or otherwise Buf (K) is the 0\n-               --  put in by fgets, so compensate.\n-\n-               if K + 2 > Buf'Last or else Buf (K + 2) /= ASCII.NUL then\n-\n-                  --  Incomplete last line, so remove the extra 0\n-\n-                  pragma Assert (Buf (K) = ASCII.NUL);\n-                  K := K - 1;\n-               end if;\n-\n-               memcpy (Item (Last + 1)'Address,\n-                       Buf (1)'Address, size_t (K));\n-               Last := Last + K;\n-            end;\n-\n-            return 0;\n-         end if;\n-      end Get_Chunk;\n-\n-   --  Start of processing for Get_Line\n-\n-   begin\n-      FIO.Check_Read_Status (AP (File));\n-\n-      --  Immediate exit for null string, this is a case in which we do not\n-      --  need to test for end of file and we do not skip a line mark under\n-      --  any circumstances.\n-\n-      if Item'First > Item'Last then\n-         return;\n-      end if;\n-\n-      N := Item'Last - Item'First + 1;\n-\n-      Last := Item'First - 1;\n-\n-      --  Here we have at least one character, if we are immediately before\n-      --  a line mark, then we will just skip past it storing no characters.\n-\n-      if File.Before_LM then\n-         File.Before_LM := False;\n-         File.Before_LM_PM := False;\n-\n-      --  Otherwise we need to read some characters\n-\n-      else\n-         while N >= Chunk_Size loop\n-            if Get_Chunk (Chunk_Size) = 0 then\n-               N := 0;\n-            else\n-               N := N - Chunk_Size + 1;\n-            end if;\n-         end loop;\n-\n-         if N > 1 then\n-            N := Get_Chunk (N);\n-         end if;\n-\n-         --  Almost there, only a little bit more to read\n-\n-         if N = 1 then\n-            ch := Getc (File);\n-\n-            --  If we get EOF after already reading data, this is an incomplete\n-            --  last line, in which case no End_Error should be raised.\n-\n-            if ch = EOF and then Last < Item'First then\n-               raise End_Error;\n-\n-            elsif ch /= LM then\n-\n-               --  Buffer really is full without having seen LM, update col\n-\n-               Last := Last + 1;\n-               Item (Last) := Character'Val (ch);\n-               File.Col := File.Col + Count (Last - Item'First + 1);\n-               return;\n-            end if;\n-         end if;\n-      end if;\n-\n-      --  We have skipped past, but not stored, a line mark. Skip following\n-      --  page mark if one follows, but do not do this for a non-regular file\n-      --  (since otherwise we get annoying wait for an extra character)\n-\n-      File.Line := File.Line + 1;\n-      File.Col := 1;\n-\n-      if File.Before_LM_PM then\n-         File.Line := 1;\n-         File.Before_LM_PM := False;\n-         File.Page := File.Page + 1;\n-\n-      elsif File.Is_Regular_File then\n-         ch := Getc (File);\n-\n-         if ch = PM and then File.Is_Regular_File then\n-            File.Line := 1;\n-            File.Page := File.Page + 1;\n-         else\n-            Ungetc (ch, File);\n-         end if;\n-      end if;\n-   end Get_Line;\n+      Last : out Natural) is separate;\n \n    procedure Get_Line\n      (Item : out String;"}, {"sha": "f37ccb4576f5de2decc85932a175dae3100577c4", "filename": "gcc/ada/a-tigeli.adb", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2Fa-tigeli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2Fa-tigeli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tigeli.adb?ref=b0887a432e679835dba79c5d6825f110bdf8a138", "patch": "@@ -0,0 +1,224 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          A D A . T E X T _ I O                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;                  use System;\n+with System.Storage_Elements; use System.Storage_Elements;\n+\n+separate (Ada.Text_IO)\n+procedure Get_Line\n+  (File : File_Type;\n+   Item : out String;\n+   Last : out Natural)\n+is\n+   Chunk_Size : constant := 80;\n+   --  We read into a fixed size auxiliary buffer. Because this buffer\n+   --  needs to be pre-initialized, there is a trade-off between size and\n+   --  speed. Experiments find returns are diminishing after 50 and this\n+   --  size allows most lines to be processed with a single read.\n+\n+   ch : int;\n+   N  : Natural;\n+\n+   procedure memcpy (s1, s2 : chars; n : size_t);\n+   pragma Import (C, memcpy);\n+\n+   function memchr (s : chars; ch : int; n : size_t) return chars;\n+   pragma Import (C, memchr);\n+\n+   procedure memset (b : chars; ch : int; n : size_t);\n+   pragma Import (C, memset);\n+\n+   function Get_Chunk (N : Positive) return Natural;\n+   --  Reads at most N - 1 characters into Item (Last + 1 .. Item'Last),\n+   --  updating Last. Raises End_Error if nothing was read (End_Of_File).\n+   --  Returns number of characters still to read (either 0 or 1) in\n+   --  case of success.\n+\n+   ---------------\n+   -- Get_Chunk --\n+   ---------------\n+\n+   function Get_Chunk (N : Positive) return Natural is\n+      Buf : String (1 .. Chunk_Size);\n+      S   : constant chars := Buf (1)'Address;\n+      P   : chars;\n+\n+   begin\n+      if N = 1 then\n+         return N;\n+      end if;\n+\n+      memset (S, 10, size_t (N));\n+\n+      if fgets (S, N, File.Stream) = Null_Address then\n+         if ferror (File.Stream) /= 0 then\n+            raise Device_Error;\n+\n+         --  If incomplete last line, pretend we found a LM\n+\n+         elsif Last >= Item'First then\n+            return 0;\n+\n+         else\n+            raise End_Error;\n+         end if;\n+      end if;\n+\n+      P := memchr (S, LM, size_t (N));\n+\n+      --  If no LM is found, the buffer got filled without reading a new\n+      --  line. Otherwise, the LM is either one from the input, or else one\n+      --  from the initialization, which means an incomplete end-of-line was\n+      --  encountered. Only in first case the LM will be followed by a 0.\n+\n+      if P = Null_Address then\n+         pragma Assert (Buf (N) = ASCII.NUL);\n+         memcpy (Item (Last + 1)'Address,\n+                 Buf (1)'Address, size_t (N - 1));\n+         Last := Last + N - 1;\n+\n+         return 1;\n+\n+      else\n+         --  P points to the LM character. Set K so Buf (K) is the character\n+         --  right before.\n+\n+         declare\n+            K : Natural := Natural (P - S);\n+\n+         begin\n+            --  Now Buf (K + 2) should be 0, or otherwise Buf (K) is the 0\n+            --  put in by fgets, so compensate.\n+\n+            if K + 2 > Buf'Last or else Buf (K + 2) /= ASCII.NUL then\n+\n+               --  Incomplete last line, so remove the extra 0\n+\n+               pragma Assert (Buf (K) = ASCII.NUL);\n+               K := K - 1;\n+            end if;\n+\n+            memcpy (Item (Last + 1)'Address,\n+                    Buf (1)'Address, size_t (K));\n+            Last := Last + K;\n+         end;\n+\n+         return 0;\n+      end if;\n+   end Get_Chunk;\n+\n+--  Start of processing for Get_Line\n+\n+begin\n+   FIO.Check_Read_Status (AP (File));\n+\n+   --  Immediate exit for null string, this is a case in which we do not\n+   --  need to test for end of file and we do not skip a line mark under\n+   --  any circumstances.\n+\n+   if Item'First > Item'Last then\n+      return;\n+   end if;\n+\n+   N := Item'Last - Item'First + 1;\n+\n+   Last := Item'First - 1;\n+\n+   --  Here we have at least one character, if we are immediately before\n+   --  a line mark, then we will just skip past it storing no characters.\n+\n+   if File.Before_LM then\n+      File.Before_LM := False;\n+      File.Before_LM_PM := False;\n+\n+   --  Otherwise we need to read some characters\n+\n+   else\n+      while N >= Chunk_Size loop\n+         if Get_Chunk (Chunk_Size) = 0 then\n+            N := 0;\n+         else\n+            N := N - Chunk_Size + 1;\n+         end if;\n+      end loop;\n+\n+      if N > 1 then\n+         N := Get_Chunk (N);\n+      end if;\n+\n+      --  Almost there, only a little bit more to read\n+\n+      if N = 1 then\n+         ch := Getc (File);\n+\n+         --  If we get EOF after already reading data, this is an incomplete\n+         --  last line, in which case no End_Error should be raised.\n+\n+         if ch = EOF and then Last < Item'First then\n+            raise End_Error;\n+\n+         elsif ch /= LM then\n+\n+            --  Buffer really is full without having seen LM, update col\n+\n+            Last := Last + 1;\n+            Item (Last) := Character'Val (ch);\n+            File.Col := File.Col + Count (Last - Item'First + 1);\n+            return;\n+         end if;\n+      end if;\n+   end if;\n+\n+   --  We have skipped past, but not stored, a line mark. Skip following\n+   --  page mark if one follows, but do not do this for a non-regular file\n+   --  (since otherwise we get annoying wait for an extra character)\n+\n+   File.Line := File.Line + 1;\n+   File.Col := 1;\n+\n+   if File.Before_LM_PM then\n+      File.Line := 1;\n+      File.Before_LM_PM := False;\n+      File.Page := File.Page + 1;\n+\n+   elsif File.Is_Regular_File then\n+      ch := Getc (File);\n+\n+      if ch = PM and then File.Is_Regular_File then\n+         File.Line := 1;\n+         File.Page := File.Page + 1;\n+      else\n+         Ungetc (ch, File);\n+      end if;\n+   end if;\n+end Get_Line;"}, {"sha": "7bda710e05973100c16d19c3436aa393b1fd411a", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0887a432e679835dba79c5d6825f110bdf8a138/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=b0887a432e679835dba79c5d6825f110bdf8a138", "patch": "@@ -578,7 +578,10 @@ package body Sem_Aux is\n       Btype : constant Entity_Id := Base_Type (Ent);\n \n    begin\n-      if Ekind (Btype) = E_Limited_Private_Type\n+      if Is_Limited_Record (Btype) then\n+         return True;\n+\n+      elsif Ekind (Btype) = E_Limited_Private_Type\n         and then Nkind (Parent (Btype)) = N_Formal_Type_Declaration\n       then\n          return not In_Package_Body (Scope ((Btype)));\n@@ -595,8 +598,11 @@ package body Sem_Aux is\n             if not Is_Limited_Type (Etype (Btype)) then\n                return False;\n \n+            --  A descendant of a limited formal type is not immutably limited\n+            --  in the generic body, or in the body of a generic child.\n+\n             elsif Ekind (Scope (Etype (Btype))) = E_Generic_Package then\n-               return not In_Package_Body (Scope (Etype (Btype)));\n+               return not In_Package_Body (Scope (Btype));\n \n             else\n                return False;\n@@ -626,10 +632,7 @@ package body Sem_Aux is\n          --  handled as build in place even though they might return objects\n          --  of a type that is not inherently limited.\n \n-         if Is_Limited_Record (Btype) then\n-            return True;\n-\n-         elsif Is_Class_Wide_Type (Btype) then\n+         if Is_Class_Wide_Type (Btype) then\n             return Is_Immutably_Limited_Type (Root_Type (Btype));\n \n          else"}]}