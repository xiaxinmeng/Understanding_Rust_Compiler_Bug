{"sha": "594ec92f509cf8120087d0553af925ed4d80afd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk0ZWM5MmY1MDljZjgxMjAwODdkMDU1M2FmOTI1ZWQ0ZDgwYWZkNQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2012-01-10T16:50:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2012-01-10T16:50:41Z"}, "message": "re PR middle-end/51516 ([trans-mem] problem with TM clone aliases)\n\n        PR middle-end/51516\n        * trans-mem.c (get_cg_data): Traverse aliases if requested.\n        (ipa_tm_scan_calls_block): Update parameters to get_cg_data.\n        (ipa_tm_note_irrevocable): Same.\n        (ipa_tm_scan_irr_block): Same.\n        (ipa_tm_decrement_clone_counts): Same.\n        (ipa_tm_scan_irr_function): Same.\n        (ipa_tm_create_version_alias): Same.\n        (ipa_tm_create_version): Same.\n        (ipa_tm_transform_calls_redirect): Same.\n        (ipa_tm_transform_calls): Same.\n        (ipa_tm_transform_transaction): Same.\n        (ipa_tm_execute): Same.\n\n\nCo-Authored-By: Patrick Marlier <patrick.marlier@gmail.com>\n\nFrom-SVN: r183070", "tree": {"sha": "cfbb9933a42c600f36346eff1c9db523ddd16cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfbb9933a42c600f36346eff1c9db523ddd16cae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/594ec92f509cf8120087d0553af925ed4d80afd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594ec92f509cf8120087d0553af925ed4d80afd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/594ec92f509cf8120087d0553af925ed4d80afd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594ec92f509cf8120087d0553af925ed4d80afd5/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aee1522197074239bfe9629b009015ac1c595810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee1522197074239bfe9629b009015ac1c595810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee1522197074239bfe9629b009015ac1c595810"}], "stats": {"total": 129, "additions": 97, "deletions": 32}, "files": [{"sha": "91e2a65e469d6ba93dbe1c6ad7e407bb07329beb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594ec92f509cf8120087d0553af925ed4d80afd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594ec92f509cf8120087d0553af925ed4d80afd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=594ec92f509cf8120087d0553af925ed4d80afd5", "patch": "@@ -1,3 +1,20 @@\n+2012-01-10  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Patrick Marlier  <patrick.marlier@gmail.com>\n+\n+\tPR middle-end/51516\n+\t* trans-mem.c (get_cg_data): Traverse aliases if requested.\n+\t(ipa_tm_scan_calls_block): Update parameters to get_cg_data.\n+\t(ipa_tm_note_irrevocable): Same.\n+\t(ipa_tm_scan_irr_block): Same.\n+\t(ipa_tm_decrement_clone_counts): Same.\n+\t(ipa_tm_scan_irr_function): Same.\n+\t(ipa_tm_create_version_alias): Same.\n+\t(ipa_tm_create_version): Same.\n+\t(ipa_tm_transform_calls_redirect): Same.\n+\t(ipa_tm_transform_calls): Same.\n+\t(ipa_tm_transform_transaction): Same.\n+\t(ipa_tm_execute): Same.\n+\n 2012-01-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/51806"}, {"sha": "c13ae47fcb8b6d01c691f3a0d6618a72f6563f37", "filename": "gcc/testsuite/g++.dg/tm/pr51516.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594ec92f509cf8120087d0553af925ed4d80afd5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr51516.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594ec92f509cf8120087d0553af925ed4d80afd5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr51516.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr51516.C?ref=594ec92f509cf8120087d0553af925ed4d80afd5", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-optimized\" } */\n+\n+struct C {\n+  long l;\n+  C():l(0) {}\n+};\n+\n+int main()\n+{\n+  C* alloc;\n+  __transaction_atomic {\n+    alloc = new C;\n+  }\n+  alloc->l = 2;\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"_ITM_getTMCloneOrIrrevocable\" } } */\n+/* { dg-final { scan-tree-dump-times \";; Function C::C\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8780825c58d5421957e2b7eaf9dd583b6092b2cf", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594ec92f509cf8120087d0553af925ed4d80afd5/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594ec92f509cf8120087d0553af925ed4d80afd5/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=594ec92f509cf8120087d0553af925ed4d80afd5", "patch": "@@ -3522,18 +3522,24 @@ DEF_VEC_ALLOC_P (cgraph_node_p, heap);\n typedef VEC (cgraph_node_p, heap) *cgraph_node_queue;\n \n /* Return the ipa data associated with NODE, allocating zeroed memory\n-   if necessary.  */\n+   if necessary.  TRAVERSE_ALIASES is true if we must traverse aliases\n+   and set *NODE accordingly.  */\n \n static struct tm_ipa_cg_data *\n-get_cg_data (struct cgraph_node *node)\n+get_cg_data (struct cgraph_node **node, bool traverse_aliases)\n {\n-  struct tm_ipa_cg_data *d = (struct tm_ipa_cg_data *) node->aux;\n+  struct tm_ipa_cg_data *d;\n+\n+  if (traverse_aliases && (*node)->alias)\n+    *node = cgraph_get_node ((*node)->thunk.alias);\n+\n+  d = (struct tm_ipa_cg_data *) (*node)->aux;\n \n   if (d == NULL)\n     {\n       d = (struct tm_ipa_cg_data *)\n \tobstack_alloc (&tm_obstack.obstack, sizeof (*d));\n-      node->aux = (void *) d;\n+      (*node)->aux = (void *) d;\n       memset (d, 0, sizeof (*d));\n     }\n \n@@ -3582,7 +3588,7 @@ ipa_tm_scan_calls_block (cgraph_node_queue *callees_p,\n \n \t      node = cgraph_get_node (fndecl);\n \t      gcc_assert (node != NULL);\n-\t      d = get_cg_data (node);\n+\t      d = get_cg_data (&node, true);\n \n \t      pcallers = (for_clone ? &d->tm_callers_clone\n \t\t\t  : &d->tm_callers_normal);\n@@ -3643,14 +3649,15 @@ static void\n ipa_tm_note_irrevocable (struct cgraph_node *node,\n \t\t\t cgraph_node_queue *worklist_p)\n {\n-  struct tm_ipa_cg_data *d = get_cg_data (node);\n+  struct tm_ipa_cg_data *d = get_cg_data (&node, true);\n   struct cgraph_edge *e;\n \n   d->is_irrevocable = true;\n \n   for (e = node->callers; e ; e = e->next_caller)\n     {\n       basic_block bb;\n+      struct cgraph_node *caller;\n \n       /* Don't examine recursive calls.  */\n       if (e->caller == node)\n@@ -3660,7 +3667,8 @@ ipa_tm_note_irrevocable (struct cgraph_node *node,\n       if (is_tm_safe_or_pure (e->caller->decl))\n \tcontinue;\n \n-      d = get_cg_data (e->caller);\n+      caller = e->caller;\n+      d = get_cg_data (&caller, true);\n \n       /* Check if the callee is in a transactional region.  If so,\n \t schedule the function for normal re-scan as well.  */\n@@ -3670,7 +3678,7 @@ ipa_tm_note_irrevocable (struct cgraph_node *node,\n \t  && bitmap_bit_p (d->transaction_blocks_normal, bb->index))\n \td->want_irr_scan_normal = true;\n \n-      maybe_push_queue (e->caller, worklist_p, &d->in_worklist);\n+      maybe_push_queue (caller, worklist_p, &d->in_worklist);\n     }\n }\n \n@@ -3704,14 +3712,16 @@ ipa_tm_scan_irr_block (basic_block bb)\n \t  if (TREE_CODE (fn) == ADDR_EXPR)\n \t    {\n \t      struct tm_ipa_cg_data *d;\n+\t      struct cgraph_node *node;\n \n \t      fn = TREE_OPERAND (fn, 0);\n \t      if (is_tm_ending_fndecl (fn))\n \t\tbreak;\n \t      if (find_tm_replacement_function (fn))\n \t\tbreak;\n \n-\t      d = get_cg_data (cgraph_get_node (fn));\n+\t      node = cgraph_get_node(fn);\n+\t      d = get_cg_data (&node, true);\n \n \t      /* Return true if irrevocable, but above all, believe\n \t\t the user.  */\n@@ -3869,13 +3879,16 @@ ipa_tm_decrement_clone_counts (basic_block bb, bool for_clone)\n \t    {\n \t      struct tm_ipa_cg_data *d;\n \t      unsigned *pcallers;\n+\t      struct cgraph_node *tnode;\n \n \t      if (is_tm_ending_fndecl (fndecl))\n \t\tcontinue;\n \t      if (find_tm_replacement_function (fndecl))\n \t\tcontinue;\n \n-\t      d = get_cg_data (cgraph_get_node (fndecl));\n+\t      tnode = cgraph_get_node (fndecl);\n+\t      d = get_cg_data (&tnode, true);\n+\n \t      pcallers = (for_clone ? &d->tm_callers_clone\n \t\t\t  : &d->tm_callers_normal);\n \n@@ -3909,7 +3922,7 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n   push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  d = get_cg_data (node);\n+  d = get_cg_data (&node, true);\n   queue = VEC_alloc (basic_block, heap, 10);\n   new_irr = BITMAP_ALLOC (&tm_obstack);\n \n@@ -3988,9 +4001,13 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n static bool\n ipa_tm_mayenterirr_function (struct cgraph_node *node)\n {\n-  struct tm_ipa_cg_data *d = get_cg_data (node);\n-  tree decl = node->decl;\n-  unsigned flags = flags_from_decl_or_type (decl);\n+  struct tm_ipa_cg_data *d;\n+  tree decl;\n+  unsigned flags;\n+\n+  d = get_cg_data (&node, true);\n+  decl = node->decl;\n+  flags = flags_from_decl_or_type (decl);\n \n   /* Handle some TM builtins.  Ordinarily these aren't actually generated\n      at this point, but handling these functions when written in by the\n@@ -4244,7 +4261,8 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n \n   new_node = cgraph_same_body_alias (NULL, new_decl, info->new_decl);\n   new_node->tm_clone = true;\n-  get_cg_data (node)->clone = new_node;\n+  /* ?? Do not traverse aliases here.  */\n+  get_cg_data (&node, false)->clone = new_node;\n \n   record_tm_clone_pair (old_decl, new_decl);\n \n@@ -4280,7 +4298,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n   new_node = cgraph_copy_node_for_versioning (old_node, new_decl, NULL, NULL);\n   new_node->lowered = true;\n   new_node->tm_clone = 1;\n-  get_cg_data (old_node)->clone = new_node;\n+  get_cg_data (&old_node, true)->clone = new_node;\n \n   if (cgraph_function_body_availability (old_node) >= AVAIL_OVERWRITABLE)\n     {\n@@ -4498,7 +4516,10 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n     }\n   else\n     {\n-      struct tm_ipa_cg_data *d = get_cg_data (e->callee);\n+      struct tm_ipa_cg_data *d;\n+      struct cgraph_node *tnode = e->callee;\n+\n+      d = get_cg_data (&tnode, true);\n       new_node = d->clone;\n \n       /* As we've already skipped pure calls and appropriate builtins,\n@@ -4599,10 +4620,12 @@ ipa_tm_transform_calls (struct cgraph_node *node, struct tm_region *region,\n static void\n ipa_tm_transform_transaction (struct cgraph_node *node)\n {\n-  struct tm_ipa_cg_data *d = get_cg_data (node);\n+  struct tm_ipa_cg_data *d;\n   struct tm_region *region;\n   bool need_ssa_rename = false;\n \n+  d = get_cg_data (&node, true);\n+\n   current_function_decl = node->decl;\n   push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -4636,9 +4659,11 @@ ipa_tm_transform_transaction (struct cgraph_node *node)\n static void\n ipa_tm_transform_clone (struct cgraph_node *node)\n {\n-  struct tm_ipa_cg_data *d = get_cg_data (node);\n+  struct tm_ipa_cg_data *d;\n   bool need_ssa_rename;\n \n+  d = get_cg_data (&node, true);\n+\n   /* If this function makes no calls and has no irrevocable blocks,\n      then there's nothing to do.  */\n   /* ??? Remove non-aborting top-level transactions.  */\n@@ -4685,7 +4710,7 @@ ipa_tm_execute (void)\n     if (is_tm_callable (node->decl)\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n-\td = get_cg_data (node);\n+\td = get_cg_data (&node, true);\n \tmaybe_push_queue (node, &tm_callees, &d->in_callee_queue);\n       }\n \n@@ -4711,7 +4736,7 @@ ipa_tm_execute (void)\n \ttm_region_init (NULL);\n \tif (all_tm_regions)\n \t  {\n-\t    d = get_cg_data (node);\n+\t    d = get_cg_data (&node, true);\n \n \t    /* Scan for calls that are in each transaction.  */\n \t    ipa_tm_scan_calls_transaction (d, &tm_callees);\n@@ -4734,7 +4759,7 @@ ipa_tm_execute (void)\n     {\n       node = VEC_index (cgraph_node_p, tm_callees, i);\n       a = cgraph_function_body_availability (node);\n-      d = get_cg_data (node);\n+      d = get_cg_data (&node, true);\n \n       /* Put it in the worklist so we can scan the function later\n \t (ipa_tm_scan_irr_function) and mark the irrevocable\n@@ -4759,7 +4784,7 @@ ipa_tm_execute (void)\n \t      if (node->alias)\n \t\t{\n \t\t  node = cgraph_get_node (node->thunk.alias);\n-\t\t  d = get_cg_data (node);\n+\t\t  d = get_cg_data (&node, true);\n \t\t  maybe_push_queue (node, &tm_callees, &d->in_callee_queue);\n \t\t  continue;\n \t\t}\n@@ -4785,7 +4810,7 @@ ipa_tm_execute (void)\n \t}\n \n       node = VEC_index (cgraph_node_p, irr_worklist, i);\n-      d = get_cg_data (node);\n+      d = get_cg_data (&node, true);\n       d->in_worklist = false;\n \n       if (d->want_irr_scan_normal)\n@@ -4805,7 +4830,7 @@ ipa_tm_execute (void)\n       node = VEC_index (cgraph_node_p, tm_callees, i);\n       if (ipa_tm_mayenterirr_function (node))\n \t{\n-\t  d = get_cg_data (node);\n+\t  d = get_cg_data (&node, true);\n \t  gcc_assert (d->in_worklist == false);\n \t  maybe_push_queue (node, &irr_worklist, &d->in_worklist);\n \t}\n@@ -4826,7 +4851,7 @@ ipa_tm_execute (void)\n \t}\n \n       node = VEC_index (cgraph_node_p, irr_worklist, i);\n-      d = get_cg_data (node);\n+      d = get_cg_data (&node, true);\n       d->in_worklist = false;\n       node->local.tm_may_enter_irr = true;\n \n@@ -4837,7 +4862,7 @@ ipa_tm_execute (void)\n \t  if (!is_tm_safe_or_pure (caller->decl)\n \t      && !caller->local.tm_may_enter_irr)\n \t    {\n-\t      d = get_cg_data (caller);\n+\t      d = get_cg_data (&caller, true);\n \t      maybe_push_queue (caller, &irr_worklist, &d->in_worklist);\n \t    }\n \t}\n@@ -4849,7 +4874,8 @@ ipa_tm_execute (void)\n \t  if (ref->use == IPA_REF_ALIAS\n \t      && !caller->local.tm_may_enter_irr)\n \t    {\n-\t      d = get_cg_data (caller);\n+\t      /* ?? Do not traverse aliases here.  */\n+\t      d = get_cg_data (&caller, false);\n \t      maybe_push_queue (caller, &irr_worklist, &d->in_worklist);\n \t    }\n \t}\n@@ -4861,7 +4887,7 @@ ipa_tm_execute (void)\n     if (node->reachable && node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n-\td = get_cg_data (node);\n+\td = get_cg_data (&node, true);\n \tif (is_tm_safe (node->decl))\n \t  ipa_tm_diagnose_tm_safe (node);\n \telse if (d->all_tm_regions)\n@@ -4880,7 +4906,7 @@ ipa_tm_execute (void)\n \tcontinue;\n \n       a = cgraph_function_body_availability (node);\n-      d = get_cg_data (node);\n+      d = get_cg_data (&node, true);\n \n       if (a <= AVAIL_NOT_AVAILABLE)\n \tdoit = is_tm_callable (node->decl);\n@@ -4900,7 +4926,7 @@ ipa_tm_execute (void)\n       node = VEC_index (cgraph_node_p, tm_callees, i);\n       if (node->analyzed)\n \t{\n-\t  d = get_cg_data (node);\n+\t  d = get_cg_data (&node, true);\n \t  if (d->clone)\n \t    ipa_tm_transform_clone (node);\n \t}\n@@ -4909,7 +4935,7 @@ ipa_tm_execute (void)\n     if (node->reachable && node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n-\td = get_cg_data (node);\n+\td = get_cg_data (&node, true);\n \tif (d->all_tm_regions)\n \t  ipa_tm_transform_transaction (node);\n       }"}]}