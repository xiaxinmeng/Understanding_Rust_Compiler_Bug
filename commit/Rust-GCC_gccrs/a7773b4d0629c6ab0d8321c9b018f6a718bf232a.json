{"sha": "a7773b4d0629c6ab0d8321c9b018f6a718bf232a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3NzNiNGQwNjI5YzZhYjBkODMyMWM5YjAxOGY2YTcxOGJmMjMyYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-06T03:51:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-06T03:51:03Z"}, "message": "escape: Avoid allocation of varargs parameter.\n\n    \n    There was a bug in the escape analysis that would cause\n    the slice implicitly created to hold varargs parameters to always\n    escape, as well as the appended to slice argument.  The intended\n    behavior was that the elements of the appendee and appended to\n    slice would escape to the heap.  Alongside of these issues,\n    the varargs slice would also have a chance to be initialized to an\n    invalid memory location if it were stack-allocated.  This has been\n    fixed as well.\n    \n    Reviewed-on: https://go-review.googlesource.com/30450\n\nFrom-SVN: r240826", "tree": {"sha": "77833c482521ede307d11d30420a0d8a13b0d313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77833c482521ede307d11d30420a0d8a13b0d313"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7773b4d0629c6ab0d8321c9b018f6a718bf232a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7773b4d0629c6ab0d8321c9b018f6a718bf232a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7773b4d0629c6ab0d8321c9b018f6a718bf232a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7773b4d0629c6ab0d8321c9b018f6a718bf232a/comments", "author": null, "committer": null, "parents": [{"sha": "f779aeb8af7def1bb21eade301d546fe0297d9e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f779aeb8af7def1bb21eade301d546fe0297d9e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f779aeb8af7def1bb21eade301d546fe0297d9e6"}], "stats": {"total": 34, "additions": 32, "deletions": 2}, "files": [{"sha": "a4dac9935a971a7345817d2f3cc7f74b2256efd1", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7773b4d0629c6ab0d8321c9b018f6a718bf232a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7773b4d0629c6ab0d8321c9b018f6a718bf232a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a7773b4d0629c6ab0d8321c9b018f6a718bf232a", "patch": "@@ -1,4 +1,4 @@\n-325f8074c5224ae537f8e00aede5c780b70f914c\n+60b84be3fa146d821dcd3939dad6336c89432cff\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ba82d8055d4cb87637394c0f6c5f98e7ade0597d", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7773b4d0629c6ab0d8321c9b018f6a718bf232a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7773b4d0629c6ab0d8321c9b018f6a718bf232a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=a7773b4d0629c6ab0d8321c9b018f6a718bf232a", "patch": "@@ -1215,7 +1215,7 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t\t\t     \"special treatment of append(slice1, slice2...)\");\n \n \t\t  // The content of the original slice leaks as well.\n-\t\t  Node* appendee = Node::make_node(call->args()->back());\n+\t\t  Node* appendee = Node::make_node(call->args()->front());\n \t\t  this->assign_deref(this->context_->sink(), appendee);\n \t\t}\n \t\tbreak;\n@@ -2088,6 +2088,36 @@ Escape_analysis_assign::assign_deref(Node* dst, Node* src)\n \t  // or numeric constants.\n \t  return;\n \n+\tcase Expression::EXPRESSION_FIXED_ARRAY_CONSTRUCTION:\n+\tcase Expression::EXPRESSION_SLICE_CONSTRUCTION:\n+\tcase Expression::EXPRESSION_STRUCT_CONSTRUCTION:\n+\t  {\n+\t    // Dereferencing an array, slice, or struct is like accessing each\n+\t    // of its values.  In this situation, we model the flow from src to\n+\t    // dst where src is one of the above as a flow from each of src's\n+\t    // values to dst.\n+\t    Expression* e = src->expr();\n+\t    Expression_list* vals = NULL;\n+\t    if (e->slice_literal() != NULL)\n+\t      vals = e->slice_literal()->vals();\n+\t    else if (e->array_literal() != NULL)\n+\t      vals = e->array_literal()->vals();\n+\t    else\n+\t      vals = e->struct_literal()->vals();\n+\n+\t    if (vals != NULL)\n+\t      {\n+\t\tfor (Expression_list::const_iterator p = vals->begin();\n+\t\t     p != vals->end();\n+\t\t     ++p)\n+\t\t  {\n+\t\t    if ((*p) != NULL)\n+\t\t      this->assign(dst, Node::make_node(*p));\n+\t\t  }\n+\t      }\n+\t  }\n+\t  return;\n+\n \tdefault:\n \t  break;\n         }"}]}