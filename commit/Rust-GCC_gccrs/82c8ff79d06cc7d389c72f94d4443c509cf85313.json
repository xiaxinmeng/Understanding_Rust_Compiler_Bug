{"sha": "82c8ff79d06cc7d389c72f94d4443c509cf85313", "node_id": "C_kwDOANBUbNoAKDgyYzhmZjc5ZDA2Y2M3ZDM4OWM3MmY5NGQ0NDQzYzUwOWNmODUzMTM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-27T09:47:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-27T09:47:00Z"}, "message": "reassoc: Fix up inter-bb range optimization [PR104196]\n\nAs mentioned in the PR, reassoc1 miscompiles following testcase.\nWe have:\n  if (a.1_1 >= 0)\n    goto <bb 5>; [59.00%]\n  else\n    goto <bb 4>; [41.00%]\n\n  <bb 4> [local count: 440234144]:\n  _3 = -2147483647 - a.1_1;\n  _9 = a.1_1 != -2147479551;\n  _4 = _3 == 1;\n  _8 = _4 | _9;\n  if (_8 != 0)\n    goto <bb 5>; [34.51%]\n  else\n    goto <bb 3>; [65.49%]\n\nand the inter-bb range test optimization treats it as:\n  if ((a.1_1 >= 0)\n      | (-2147483647 - a.1_1 == 1)\n      | (a.1_1 != -2147479551))\n    goto bb5;\n  else\n    goto bb3;\nand recognizes that a.1_1 >= 0 is redundant with a.1_1 != -2147479551\nand so will optimize it into:\n  if (0\n      | (-2147483647 - a.1_1 == 1)\n      | (a.1_1 != -2147479551))\n    goto bb5;\n  else\n    goto bb3;\nWhen merging 2 comparisons, we use update_range_test which picks one\nof the comparisons as the one holding the result (currently always\nthe RANGE one rather than all the OTHERRANGE* ones) and adjusts the\nothers to be true or false.\nThe problem with doing that is that means the\n  _3 = -2147483647 - a.1_1;\nstmt with undefined behavior on overflow used to be conditional before\nbut now is unconditional.  reassoc performs a no_side_effect_bb check\nwhich among other checks punts on gimple_has_side_effects and\ngimple_assign_rhs_could_trap_p stmts as well as ones that have uses of\ntheir lhs outside of the same bb, but it doesn't punt for this potential\nsigned overflow case.\n\nNow, for this testcase, it can be fixed in update_range_test by being\nsmarter and choosing the other comparison to modify.  This is achieved\nby storing into oe->id index of the bb with GIMPLE_COND the\ncomparison feeds into not just for the cases where the comparison is\nthe GIMPLE_COND itself, but in all cases, and then finding oe->id that\nisn't dominated by others.  If we find such, use that oe for the merge\ntest and if successful, swap range->idx and swap_with->idx.\nSo for the above case we optimize it into:\n  if ((a.1_1 != -2147479551)\n      | (-2147483647 - a.1_1 == 1)\n      | 0)\n    goto bb5;\n  else\n    goto bb3;\ninstead.\n\nUnfortunately, this doesn't work in all cases,\noptimize_range_tests_to_bit_test and\noptimize_range_tests_cmp_bitwise optimizations use non-NULL seq\nto update_range_test and they carefully choose a particular comparison\nbecause the sequence then uses SSA_NAMEs that may be defined only in\ntheir blocks.  For that case, the patch keeps using the chosen comparison\nbut if the merge is successful, rewrites stmts with signed overflow behavior\ninto defined overflow.\nFor this I ran into a problem, rewrite_to_defined_overflow returns a\nsequence that includes the original stmt with modified arguments, this means\nit needs to be gsi_remove first.  Unfortunately, gsi_remove regardless of\nthe remove_permanently argument creates debug temps for the lhs, which I\nthink is quite undesirable here.  So I've added an argument (default to\nfalse) to rewrite_to_defined_overflow to do the modification in place\nwithout the need to remove the stmt.\n\n2022-01-27  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/104196\n\t* gimple-fold.h (rewrite_to_defined_overflow): Add IN_PLACE argument.\n\t* gimple-fold.cc (rewrite_to_defined_overflow): Likewise.  If true,\n\treturn NULL and emit needed stmts before and after stmt.\n\t* tree-ssa-reassoc.cc (update_range_test): For inter-bb range opt\n\tpick as operand_entry that will hold the merged test the one feeding\n\tearliest condition, ensure that by swapping range->idx with some\n\tother range's idx if needed.  If seq is non-NULL, don't actually swap\n\tit but instead rewrite stmts with undefined overflow in between\n\tthe two locations.\n\t(maybe_optimize_range_tests): Set ops[]->id to bb->index with the\n\tcorresponding condition even if they have non-NULL ops[]->op.\n\tFormatting fix.\n\n\t* gcc.c-torture/execute/pr104196.c: New test.", "tree": {"sha": "e7cdd5a8b936cdd191754b84da1c8b87a072b423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7cdd5a8b936cdd191754b84da1c8b87a072b423"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82c8ff79d06cc7d389c72f94d4443c509cf85313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c8ff79d06cc7d389c72f94d4443c509cf85313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c8ff79d06cc7d389c72f94d4443c509cf85313", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c8ff79d06cc7d389c72f94d4443c509cf85313/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2a0f3a4546fbede84d957b2ed0f94709ba4deb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a0f3a4546fbede84d957b2ed0f94709ba4deb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2a0f3a4546fbede84d957b2ed0f94709ba4deb8"}], "stats": {"total": 136, "additions": 128, "deletions": 8}, "files": [{"sha": "9e0c01d63533697ded154a77f8a408755412adec", "filename": "gcc/gimple-fold.cc", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Fgimple-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Fgimple-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.cc?ref=82c8ff79d06cc7d389c72f94d4443c509cf85313", "patch": "@@ -8539,11 +8539,12 @@ arith_code_with_undefined_signed_overflow (tree_code code)\n    its operand, carrying out the operation in the corresponding unsigned\n    type and converting the result back to the original type.\n \n-   Returns a sequence of statements that replace STMT and also contain\n-   a modified form of STMT itself.  */\n+   If IN_PLACE is true, adjust the stmt in place and return NULL.\n+   Otherwise returns a sequence of statements that replace STMT and also\n+   contain a modified form of STMT itself.  */\n \n gimple_seq\n-rewrite_to_defined_overflow (gimple *stmt)\n+rewrite_to_defined_overflow (gimple *stmt, bool in_place /* = false */)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -8568,9 +8569,24 @@ rewrite_to_defined_overflow (gimple *stmt)\n   if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n     gimple_assign_set_rhs_code (stmt, PLUS_EXPR);\n   gimple_set_modified (stmt, true);\n-  gimple_seq_add_stmt (&stmts, stmt);\n+  if (in_place)\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      if (stmts)\n+\tgsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+      stmts = NULL;\n+    }\n+  else\n+    gimple_seq_add_stmt (&stmts, stmt);\n   gimple *cvt = gimple_build_assign (lhs, NOP_EXPR, gimple_assign_lhs (stmt));\n-  gimple_seq_add_stmt (&stmts, cvt);\n+  if (in_place)\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      gsi_insert_after (&gsi, cvt, GSI_SAME_STMT);\n+      update_stmt (stmt);\n+    }\n+  else\n+    gimple_seq_add_stmt (&stmts, cvt);\n \n   return stmts;\n }"}, {"sha": "82631a4512ee4c8ac2f7aff519a70984d93fb089", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=82c8ff79d06cc7d389c72f94d4443c509cf85313", "patch": "@@ -62,7 +62,7 @@ extern tree gimple_fold_indirect_ref (tree);\n extern bool gimple_fold_builtin_sprintf (gimple_stmt_iterator *);\n extern bool gimple_fold_builtin_snprintf (gimple_stmt_iterator *);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);\n-extern gimple_seq rewrite_to_defined_overflow (gimple *);\n+extern gimple_seq rewrite_to_defined_overflow (gimple *, bool = false);\n extern void replace_call_with_value (gimple_stmt_iterator *, tree);\n extern tree tree_vec_extract (gimple_stmt_iterator *, tree, tree, tree, tree);\n "}, {"sha": "80f267a7c38a68d41ece33c7bec65cbf074f891c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr104196.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr104196.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr104196.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr104196.c?ref=82c8ff79d06cc7d389c72f94d4443c509cf85313", "patch": "@@ -0,0 +1,19 @@\n+/* PR tree-optimization/104196 */\n+\n+int a = 6;\n+\n+int\n+main ()\n+{\n+  while (1)\n+    {\n+      int b = a < 0 && 0 < -__INT_MAX__ - a ? 0 : a;\n+      if (b != 4096 - __INT_MAX__)\n+\t{\n+\t  if (a < 6)\n+\t    __builtin_abort ();\n+\t  break;\n+\t}\n+    }\n+  return 0;\n+}"}, {"sha": "7ee50946556c96f8dce8cb6380b22a1b807ff370", "filename": "gcc/tree-ssa-reassoc.cc", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Ftree-ssa-reassoc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8ff79d06cc7d389c72f94d4443c509cf85313/gcc%2Ftree-ssa-reassoc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.cc?ref=82c8ff79d06cc7d389c72f94d4443c509cf85313", "patch": "@@ -2768,7 +2768,49 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n \t\t   vec<operand_entry *> *ops, tree exp, gimple_seq seq,\n \t\t   bool in_p, tree low, tree high, bool strict_overflow_p)\n {\n-  operand_entry *oe = (*ops)[range->idx];\n+  unsigned int idx = range->idx;\n+  struct range_entry *swap_with = NULL;\n+  basic_block rewrite_bb_first = NULL, rewrite_bb_last = NULL;\n+  if (opcode == ERROR_MARK)\n+    {\n+      /* For inter-bb range test optimization, pick from the range tests\n+\t the one which is tested in the earliest condition (one dominating\n+\t the others), because otherwise there could be some UB (e.g. signed\n+\t overflow) in following bbs that we'd expose which wasn't there in\n+\t the original program.  See PR104196.  */\n+      basic_block orig_range_bb = BASIC_BLOCK_FOR_FN (cfun, (*ops)[idx]->id);\n+      basic_block range_bb = orig_range_bb;\n+      for (unsigned int i = 0; i < count; i++)\n+\t{\n+\t  struct range_entry *this_range;\n+\t  if (otherrange)\n+\t    this_range = otherrange + i;\n+\t  else\n+\t    this_range = otherrangep[i];\n+\t  operand_entry *oe = (*ops)[this_range->idx];\n+\t  basic_block this_bb = BASIC_BLOCK_FOR_FN (cfun, oe->id);\n+\t  if (range_bb != this_bb\n+\t      && dominated_by_p (CDI_DOMINATORS, range_bb, this_bb))\n+\t    {\n+\t      swap_with = this_range;\n+\t      range_bb = this_bb;\n+\t      idx = this_range->idx;\n+\t    }\n+\t}\n+      /* If seq is non-NULL, it can contain statements that use SSA_NAMEs\n+\t only defined in later blocks.  In this case we can't move the\n+\t merged comparison earlier, so instead check if there are any stmts\n+\t that might trigger signed integer overflow in between and rewrite\n+\t them.  But only after we check if the optimization is possible.  */\n+      if (seq && swap_with)\n+\t{\n+\t  rewrite_bb_first = range_bb;\n+\t  rewrite_bb_last = orig_range_bb;\n+\t  idx = range->idx;\n+\t  swap_with = NULL;\n+\t}\n+    }\n+  operand_entry *oe = (*ops)[idx];\n   tree op = oe->op;\n   gimple *stmt = op ? SSA_NAME_DEF_STMT (op)\n \t\t    : last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe->id));\n@@ -2805,6 +2847,9 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n \treturn false;\n     }\n \n+  if (swap_with)\n+    std::swap (range->idx, swap_with->idx);\n+\n   if (strict_overflow_p && issue_strict_overflow_warning (wc))\n     warning_at (loc, OPT_Wstrict_overflow,\n \t\t\"assuming signed overflow does not occur \"\n@@ -2839,6 +2884,42 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  /* In inter-bb range optimization mode, if we have a seq, we can't\n+     move the merged comparison to the earliest bb from the comparisons\n+     being replaced, so instead rewrite stmts that could trigger signed\n+     integer overflow.  */\n+  for (basic_block bb = rewrite_bb_last;\n+       bb != rewrite_bb_first; bb = single_pred (bb))\n+    for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\tif (is_gimple_assign (stmt))\n+\t  if (tree lhs = gimple_assign_lhs (stmt))\n+\t    if ((INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t\t || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t\t&& TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs)))\n+\t      {\n+\t\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\t\tif (arith_code_with_undefined_signed_overflow (code))\n+\t\t  {\n+\t\t    gimple_stmt_iterator gsip = gsi;\n+\t\t    gimple_stmt_iterator gsin = gsi;\n+\t\t    gsi_prev (&gsip);\n+\t\t    gsi_next (&gsin);\n+\t\t    rewrite_to_defined_overflow (stmt, true);\n+\t\t    unsigned uid = gimple_uid (stmt);\n+\t\t    if (gsi_end_p (gsip))\n+\t\t      gsip = gsi_after_labels (bb);\n+\t\t    else\n+\t\t      gsi_next (&gsip);\n+\t\t    for (; gsi_stmt (gsip) != gsi_stmt (gsin);\n+\t\t\t gsi_next (&gsip))\n+\t\t      gimple_set_uid (gsi_stmt (gsip), uid);\n+\t\t  }\n+\t      }\n+      }\n+\n   if (opcode == BIT_IOR_EXPR\n       || (opcode == ERROR_MARK && oe->rank == BIT_IOR_EXPR))\n     tem = invert_truthvalue_loc (loc, tem);\n@@ -4755,7 +4836,7 @@ maybe_optimize_range_tests (gimple *stmt)\n \t      && (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt))\n \t\t  != tcc_comparison)\n \t      && !get_ops (rhs, code, &ops,\n-\t\t\tloop_containing_stmt (stmt))\n+\t\t\t   loop_containing_stmt (stmt))\n \t      && has_single_use (rhs))\n \t    {\n \t      /* Otherwise, push the _234 range test itself.  */\n@@ -4792,6 +4873,8 @@ maybe_optimize_range_tests (gimple *stmt)\n \t      bb_ent.op = rhs;\n \t    }\n \t  bbinfo.safe_push (bb_ent);\n+\t  for (unsigned int i = bb_ent.first_idx; i < bb_ent.last_idx; ++i)\n+\t    ops[i]->id = bb->index;\n \t  continue;\n \t}\n       else if (bb == last_bb)\n@@ -4855,6 +4938,8 @@ maybe_optimize_range_tests (gimple *stmt)\n \t  bb_ent.last_idx = ops.length ();\n \t}\n       bbinfo.safe_push (bb_ent);\n+      for (unsigned int i = bb_ent.first_idx; i < bb_ent.last_idx; ++i)\n+\tops[i]->id = bb->index;\n       if (bb == first_bb)\n \tbreak;\n     }"}]}