{"sha": "b1983f4582bbe060b7da83578acb9ed653681fc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5ODNmNDU4MmJiZTA2MGI3ZGE4MzU3OGFjYjllZDY1MzY4MWZjOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-30T14:47:52Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-30T15:01:43Z"}, "message": "libstdc++: Avoid errors in allocator's noexcept-specifier (PR 89510)\n\nThis fixes a regression due to the conditional noexcept-specifier on\nstd::allocator::construct and std::allocator::destroy, as well as the\ncorresponding members of new_allocator, malloc_allocator, and\nallocator_traits. Those noexcept-specifiers were using expressions which\nmight be ill-formed, which caused errors outside the immediate context\nwhen checking for the presence of construct and destroy in SFINAE\ncontexts.\n\nThe fix is to use the is_nothrow_constructible and\nis_nothrow_destructible type traits instead, because those traits are\nsafe to use even when the construction/destruction itself is not valid.\n\nThe is_nothrow_constructible trait will be false for a type that is not\nalso nothrow-destructible, even if the new-expression used in the\nconstruct function body is actually noexcept. That's not the correct\nanswer, but isn't a problem because providing a noexcept-specifier on\nthese functions is not required by the standard anyway. If the answer is\nfalse when it should be true, that's suboptimal but OK (unlike giving\nerrors for valid code, or giving a true answer when it should be false).\n\n\tPR libstdc++/89510\n\t* include/bits/alloc_traits.h (allocator_traits::_S_construct)\n\t(allocator_traits::_S_destroy)\n\t(allocator_traits<allocator<T>>::construct): Use traits in\n\tnoexcept-specifiers.\n\t* include/bits/allocator.h (allocator<void>::construct)\n\t(allocator<void>::destroy): Likewise.\n\t* include/ext/malloc_allocator.h (malloc_allocator::construct)\n\t(malloc_allocator::destroy): Likewise.\n\t* include/ext/new_allocator.h (new_allocator::construct)\n\t(new_allocator::destroy): Likewise.\n\t* testsuite/20_util/allocator/89510.cc: New test.\n\t* testsuite/ext/malloc_allocator/89510.cc: New test.\n\t* testsuite/ext/new_allocator/89510.cc: New test.", "tree": {"sha": "ee0a4badb32338e9f157a7241a365acc588cff26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee0a4badb32338e9f157a7241a365acc588cff26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1983f4582bbe060b7da83578acb9ed653681fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1983f4582bbe060b7da83578acb9ed653681fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1983f4582bbe060b7da83578acb9ed653681fc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1983f4582bbe060b7da83578acb9ed653681fc8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "448c89d590455ed4ab7abc40309b5cf8ec52d13d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448c89d590455ed4ab7abc40309b5cf8ec52d13d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/448c89d590455ed4ab7abc40309b5cf8ec52d13d"}], "stats": {"total": 484, "additions": 471, "deletions": 13}, "files": [{"sha": "b21c44fc0b8cee04cfe7a132822cfd2e62771765", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -1,3 +1,20 @@\n+2020-04-30  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/89510\n+\t* include/bits/alloc_traits.h (allocator_traits::_S_construct)\n+\t(allocator_traits::_S_destroy)\n+\t(allocator_traits<allocator<T>>::construct): Use traits in\n+\tnoexcept-specifiers.\n+\t* include/bits/allocator.h (allocator<void>::construct)\n+\t(allocator<void>::destroy): Likewise.\n+\t* include/ext/malloc_allocator.h (malloc_allocator::construct)\n+\t(malloc_allocator::destroy): Likewise.\n+\t* include/ext/new_allocator.h (new_allocator::construct)\n+\t(new_allocator::destroy): Likewise.\n+\t* testsuite/20_util/allocator/89510.cc: New test.\n+\t* testsuite/ext/malloc_allocator/89510.cc: New test.\n+\t* testsuite/ext/new_allocator/89510.cc: New test.\n+\n 2020-04-29  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/94854"}, {"sha": "86d8ed221ff8d312aada579600b6543997f1fcc3", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -251,8 +251,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,\n \t\t\t       is_constructible<_Tp, _Args...>>>\n \t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n-\tnoexcept(noexcept(::new((void*)__p)\n-\t\t\t  _Tp(std::forward<_Args>(__args)...)))\n+\tnoexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)\n \t{\n #if __cplusplus <= 201703L\n \t  ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);\n@@ -271,7 +270,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Alloc2, typename _Tp>\n \tstatic _GLIBCXX14_CONSTEXPR void\n \t_S_destroy(_Alloc2&, _Tp* __p, ...)\n-\tnoexcept(noexcept(__p->~_Tp()))\n+\tnoexcept(std::is_nothrow_destructible<_Tp>::value)\n \t{ std::_Destroy(__p); }\n \n       template<typename _Alloc2>\n@@ -507,7 +506,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstatic _GLIBCXX20_CONSTEXPR void\n \tconstruct(allocator_type& __a __attribute__((__unused__)), _Up* __p,\n \t\t  _Args&&... __args)\n-\tnoexcept(noexcept(::new((void*)__p) _Up(std::declval<_Args>()...)))\n+\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n \t{\n #if __cplusplus <= 201703L\n \t  __a.construct(__p, std::forward<_Args>(__args)...);"}, {"sha": "d224aa3ec5ec807dad60ec4c70810cca07a383b1", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -93,14 +93,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Up, typename... _Args>\n \tvoid\n \tconstruct(_Up* __p, _Args&&... __args)\n-\tnoexcept(noexcept(::new((void *)__p)\n-\t\t\t    _Up(std::forward<_Args>(__args)...)))\n+\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n \t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n \n       template<typename _Up>\n \tvoid\n \tdestroy(_Up* __p)\n-\tnoexcept(noexcept(__p->~_Up()))\n+\tnoexcept(std::is_nothrow_destructible<_Up>::value)\n \t{ __p->~_Up(); }\n #endif // C++11 to C++17\n     };"}, {"sha": "366c766f25b56533100a8b53d7ce9283b594c004", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -147,14 +147,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Up, typename... _Args>\n         void\n         construct(_Up* __p, _Args&&... __args)\n-\tnoexcept(noexcept(::new((void *)__p)\n-\t\t\t  _Up(std::forward<_Args>(__args)...)))\n+\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n \t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n \n       template<typename _Up>\n         void \n         destroy(_Up* __p)\n-\tnoexcept(noexcept(__p->~_Up()))\n+\tnoexcept(std::is_nothrow_destructible<_Up>::value)\n \t{ __p->~_Up(); }\n #else\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "131718b8b2ff68ff6db77d854378bb342cbc5477", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -146,14 +146,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Up, typename... _Args>\n \tvoid\n \tconstruct(_Up* __p, _Args&&... __args)\n-\tnoexcept(noexcept(::new((void *)__p)\n-\t\t\t    _Up(std::forward<_Args>(__args)...)))\n+\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n \t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n \n       template<typename _Up>\n \tvoid\n \tdestroy(_Up* __p)\n-\tnoexcept(noexcept( __p->~_Up()))\n+\tnoexcept(std::is_nothrow_destructible<_Up>::value)\n \t{ __p->~_Up(); }\n #else\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "a3100a2b062da4685e781ee09a015a446a9cb4e1", "filename": "libstdc++-v3/testsuite/20_util/allocator/89510.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F89510.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F89510.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F89510.cc?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -0,0 +1,147 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <memory>\n+\n+using AT = std::allocator_traits<std::allocator<int>>;\n+\n+template<typename...> using void_t = void;\n+\n+template<typename T, typename U, typename = void>\n+struct has_construct\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_construct<T, U,\n+    void_t<decltype(std::declval<T&>().construct(std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_destroy\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_destroy<T, U,\n+    void_t<decltype(std::declval<T&>().destroy(std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_traits_construct\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_traits_construct<T, U,\n+    void_t<decltype(AT::construct(std::declval<T&>(), std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_traits_destroy\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_traits_destroy<T, U,\n+    void_t<decltype(AT::destroy(std::declval<T&>(), std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+struct NoDefault { NoDefault(int); };\n+struct NoDest { private: ~NoDest(); };\n+\n+// Whether true or false, this should not give an error:\n+constexpr bool c = has_construct<std::allocator<NoDefault>, NoDefault>::value;\n+constexpr bool cv = has_construct<std::allocator<void>, NoDefault>::value;\n+constexpr bool c2 = has_traits_construct<std::allocator<int>, NoDefault>::value;\n+constexpr bool d = has_destroy<std::allocator<NoDest>, NoDest>::value;\n+constexpr bool d2 = has_traits_destroy<std::allocator<int>, NoDest>::value;\n+\n+std::allocator<int> a;\n+\n+long* lp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(lp)), \"\" );\n+static_assert( noexcept(a.construct(lp, 1L)), \"\" );\n+static_assert( noexcept(a.construct(lp, 2)), \"\" );\n+static_assert( noexcept(a.construct(lp, 2U)), \"\" );\n+static_assert( noexcept(a.destroy(lp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, lp)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 1L)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 2)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 2U)), \"\" );\n+static_assert( noexcept(AT::destroy(a, lp)), \"\" );\n+\n+struct X\n+{\n+  X() noexcept;\n+  X(int) noexcept;\n+  ~X() noexcept;\n+};\n+\n+X* xp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(xp)), \"\" );\n+static_assert( noexcept(a.construct(xp, 1)), \"\" );\n+static_assert( noexcept(a.destroy(xp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, xp)), \"\" );\n+static_assert( noexcept(AT::construct(a, xp, 1)), \"\" );\n+static_assert( noexcept(AT::destroy(a, xp)), \"\" );\n+\n+struct Y\n+{\n+  Y() noexcept;\n+  Y(int) noexcept(false);\n+  ~Y() noexcept;\n+};\n+\n+Y* yp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(yp)), \"\" );\n+static_assert( ! noexcept(a.construct(yp, 1)), \"\" );\n+static_assert( noexcept(a.destroy(yp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, yp)), \"\" );\n+static_assert( ! noexcept(AT::construct(a, yp, 1)), \"\" );\n+static_assert( noexcept(AT::destroy(a, yp)), \"\" );\n+\n+struct Z\n+{\n+  Z() noexcept;\n+  Z(int) noexcept;\n+  ~Z() noexcept(false);\n+};\n+\n+Z* zp;\n+// These construct calls should be noexcept, but they are false because\n+// they use is_nothrow_constructible which depends on is_nothrow_destructible.\n+#if __cplusplus <= 201703L\n+static_assert( ! noexcept(a.construct(zp)), \"wrong\" );\n+static_assert( ! noexcept(a.construct(zp, 1)), \"wrong\" );\n+static_assert( ! noexcept(a.destroy(zp)), \"\" );\n+#endif\n+static_assert( ! noexcept(AT::construct(a, zp)), \"\" );\n+static_assert( ! noexcept(AT::construct(a, zp, 1)), \"\" );\n+static_assert( ! noexcept(AT::destroy(a, zp)), \"\" );"}, {"sha": "f2ab25adb74c40e400a8bc714d39992b59413cd1", "filename": "libstdc++-v3/testsuite/ext/malloc_allocator/89510.cc", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2F89510.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2F89510.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2F89510.cc?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -0,0 +1,149 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <ext/malloc_allocator.h>\n+#include <memory>\n+#include <type_traits>\n+\n+using __gnu_cxx::malloc_allocator;\n+using AT = std::allocator_traits<malloc_allocator<int>>;\n+\n+template<typename...> using void_t = void;\n+\n+template<typename T, typename U, typename = void>\n+struct has_construct\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_construct<T, U,\n+    void_t<decltype(std::declval<T&>().construct(std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_destroy\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_destroy<T, U,\n+    void_t<decltype(std::declval<T&>().destroy(std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_traits_construct\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_traits_construct<T, U,\n+    void_t<decltype(AT::construct(std::declval<T&>(), std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_traits_destroy\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_traits_destroy<T, U,\n+    void_t<decltype(AT::destroy(std::declval<T&>(), std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+struct NoDefault { NoDefault(int); };\n+struct NoDest { private: ~NoDest(); };\n+\n+// Whether true or false, these should not give errors:\n+constexpr bool c = has_construct<malloc_allocator<NoDefault>, NoDefault>::value;\n+constexpr bool c2 = has_traits_construct<malloc_allocator<int>, NoDefault>::value;\n+constexpr bool d = has_destroy<malloc_allocator<NoDest>, NoDest>::value;\n+constexpr bool b2 = has_traits_destroy<malloc_allocator<int>, NoDest>::value;\n+\n+malloc_allocator<int> a;\n+\n+long* lp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(lp)), \"\" );\n+static_assert( noexcept(a.construct(lp, 1L)), \"\" );\n+static_assert( noexcept(a.construct(lp, 2)), \"\" );\n+static_assert( noexcept(a.construct(lp, 2U)), \"\" );\n+static_assert( noexcept(a.destroy(lp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, lp)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 1L)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 2)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 2U)), \"\" );\n+static_assert( noexcept(AT::destroy(a, lp)), \"\" );\n+\n+struct X\n+{\n+  X() noexcept;\n+  X(int) noexcept;\n+  ~X() noexcept;\n+};\n+\n+X* xp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(xp)), \"\" );\n+static_assert( noexcept(a.construct(xp, 1)), \"\" );\n+static_assert( noexcept(a.destroy(xp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, xp)), \"\" );\n+static_assert( noexcept(AT::construct(a, xp, 1)), \"\" );\n+static_assert( noexcept(AT::destroy(a, xp)), \"\" );\n+\n+struct Y\n+{\n+  Y() noexcept;\n+  Y(int) noexcept(false);\n+  ~Y() noexcept;\n+};\n+\n+Y* yp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(yp)), \"\" );\n+static_assert( ! noexcept(a.construct(yp, 1)), \"\" );\n+static_assert( noexcept(a.destroy(yp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, yp)), \"\" );\n+static_assert( ! noexcept(AT::construct(a, yp, 1)), \"\" );\n+static_assert( noexcept(AT::destroy(a, yp)), \"\" );\n+\n+struct Z\n+{\n+  Z() noexcept;\n+  Z(int) noexcept;\n+  ~Z() noexcept(false);\n+};\n+\n+Z* zp;\n+// These construct calls should be noexcept, but they are false because\n+// they use is_nothrow_constructible which depends on is_nothrow_destructible.\n+#if __cplusplus <= 201703L\n+static_assert( ! noexcept(a.construct(zp)), \"wrong\" );\n+static_assert( ! noexcept(a.construct(zp, 1)), \"wrong\" );\n+static_assert( ! noexcept(a.destroy(zp)), \"\" );\n+#endif\n+static_assert( ! noexcept(AT::construct(a, zp)), \"\" );\n+static_assert( ! noexcept(AT::construct(a, zp, 1)), \"\" );\n+static_assert( ! noexcept(AT::destroy(a, zp)), \"\" );"}, {"sha": "f684a9c157da7e098a6cef915860c198d033044f", "filename": "libstdc++-v3/testsuite/ext/new_allocator/89510.cc", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2F89510.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1983f4582bbe060b7da83578acb9ed653681fc8/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2F89510.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fnew_allocator%2F89510.cc?ref=b1983f4582bbe060b7da83578acb9ed653681fc8", "patch": "@@ -0,0 +1,149 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <ext/new_allocator.h>\n+#include <memory>\n+#include <type_traits>\n+\n+using __gnu_cxx::new_allocator;\n+using AT = std::allocator_traits<new_allocator<int>>;\n+\n+template<typename...> using void_t = void;\n+\n+template<typename T, typename U, typename = void>\n+struct has_construct\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_construct<T, U,\n+    void_t<decltype(std::declval<T&>().construct(std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_destroy\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_destroy<T, U,\n+    void_t<decltype(std::declval<T&>().destroy(std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_traits_construct\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_traits_construct<T, U,\n+    void_t<decltype(AT::construct(std::declval<T&>(), std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+template<typename T, typename U, typename = void>\n+struct has_traits_destroy\n+: std::false_type\n+{ };\n+\n+template<typename T, typename U>\n+struct has_traits_destroy<T, U,\n+    void_t<decltype(AT::destroy(std::declval<T&>(), std::declval<U*>()))>>\n+: std::true_type\n+{ };\n+\n+struct NoDefault { NoDefault(int); };\n+struct NoDest { private: ~NoDest(); };\n+\n+// Whether true or false, these should not give errors:\n+constexpr bool c = has_construct<new_allocator<NoDefault>, NoDefault>::value;\n+constexpr bool c2 = has_traits_construct<new_allocator<int>, NoDefault>::value;\n+constexpr bool d = has_destroy<new_allocator<NoDest>, NoDest>::value;\n+constexpr bool d2 = has_traits_destroy<new_allocator<int>, NoDest>::value;\n+\n+new_allocator<int> a;\n+\n+long* lp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(lp)), \"\" );\n+static_assert( noexcept(a.construct(lp, 1L)), \"\" );\n+static_assert( noexcept(a.construct(lp, 2)), \"\" );\n+static_assert( noexcept(a.construct(lp, 2U)), \"\" );\n+static_assert( noexcept(a.destroy(lp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, lp)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 1L)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 2)), \"\" );\n+static_assert( noexcept(AT::construct(a, lp, 2U)), \"\" );\n+static_assert( noexcept(AT::destroy(a, lp)), \"\" );\n+\n+struct X\n+{\n+  X() noexcept;\n+  X(int) noexcept;\n+  ~X() noexcept;\n+};\n+\n+X* xp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(xp)), \"\" );\n+static_assert( noexcept(a.construct(xp, 1)), \"\" );\n+static_assert( noexcept(a.destroy(xp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, xp)), \"\" );\n+static_assert( noexcept(AT::construct(a, xp, 1)), \"\" );\n+static_assert( noexcept(AT::destroy(a, xp)), \"\" );\n+\n+struct Y\n+{\n+  Y() noexcept;\n+  Y(int) noexcept(false);\n+  ~Y() noexcept;\n+};\n+\n+Y* yp;\n+#if __cplusplus <= 201703L\n+static_assert( noexcept(a.construct(yp)), \"\" );\n+static_assert( ! noexcept(a.construct(yp, 1)), \"\" );\n+static_assert( noexcept(a.destroy(yp)), \"\" );\n+#endif\n+static_assert( noexcept(AT::construct(a, yp)), \"\" );\n+static_assert( ! noexcept(AT::construct(a, yp, 1)), \"\" );\n+static_assert( noexcept(AT::destroy(a, yp)), \"\" );\n+\n+struct Z\n+{\n+  Z() noexcept;\n+  Z(int) noexcept;\n+  ~Z() noexcept(false);\n+};\n+\n+Z* zp;\n+// These construct calls should be noexcept, but they are false because\n+// they use is_nothrow_constructible which depends on is_nothrow_destructible.\n+#if __cplusplus <= 201703L\n+static_assert( ! noexcept(a.construct(zp)), \"wrong\" );\n+static_assert( ! noexcept(a.construct(zp, 1)), \"wrong\" );\n+static_assert( ! noexcept(a.destroy(zp)), \"\" );\n+#endif\n+static_assert( ! noexcept(AT::construct(a, zp)), \"\" );\n+static_assert( ! noexcept(AT::construct(a, zp, 1)), \"\" );\n+static_assert( ! noexcept(AT::destroy(a, zp)), \"\" );"}]}