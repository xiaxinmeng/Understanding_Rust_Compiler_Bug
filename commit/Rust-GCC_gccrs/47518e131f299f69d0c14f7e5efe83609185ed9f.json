{"sha": "47518e131f299f69d0c14f7e5efe83609185ed9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc1MThlMTMxZjI5OWY2OWQwYzE0ZjdlNWVmZTgzNjA5MTg1ZWQ5Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-09-16T04:34:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-09-16T04:34:23Z"}, "message": "PR c++/82165 - enum bitfields and operator overloading.\n\nIn this testcase, !f.b0 was failing to call the overloaded operator because\nTREE_TYPE is the magic bitfield integer type, and we weren't using\nunlowered_expr_type the way we do in other places.  It would be nice if we\ncould give bit-field COMPONENT_REFs their declared type until genericization\ntime...\n\n\t* call.c (build_new_op_1): Use unlowered_expr_type.\n\nFrom-SVN: r275745", "tree": {"sha": "b90c2e33bc4eee6596a3fc5d7bccd6c8014dab24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b90c2e33bc4eee6596a3fc5d7bccd6c8014dab24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47518e131f299f69d0c14f7e5efe83609185ed9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47518e131f299f69d0c14f7e5efe83609185ed9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47518e131f299f69d0c14f7e5efe83609185ed9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47518e131f299f69d0c14f7e5efe83609185ed9f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a4d034d714f5799d3038aaf85347923686c7db64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d034d714f5799d3038aaf85347923686c7db64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4d034d714f5799d3038aaf85347923686c7db64"}], "stats": {"total": 70, "additions": 56, "deletions": 14}, "files": [{"sha": "bed72c90a2ec36971801342e34d4e92bfce10bff", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47518e131f299f69d0c14f7e5efe83609185ed9f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47518e131f299f69d0c14f7e5efe83609185ed9f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=47518e131f299f69d0c14f7e5efe83609185ed9f", "patch": "@@ -1,5 +1,8 @@\n 2019-09-15  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/82165 - enum bitfields and operator overloading.\n+\t* call.c (build_new_op_1): Use unlowered_expr_type.\n+\n \t* call.c (build_new_op_1): Don't apply any standard conversions to\n \tthe operands of a built-in operator.  Don't suppress conversions in\n \tcp_build_unary_op."}, {"sha": "b780b0af58ee8974341a3980e9897b007616b490", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47518e131f299f69d0c14f7e5efe83609185ed9f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47518e131f299f69d0c14f7e5efe83609185ed9f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=47518e131f299f69d0c14f7e5efe83609185ed9f", "patch": "@@ -5815,6 +5815,9 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n     }\n   tree fnname = ovl_op_identifier (ismodop, ismodop ? code2 : code);\n \n+  tree arg1_type = unlowered_expr_type (arg1);\n+  tree arg2_type = arg2 ? unlowered_expr_type (arg2) : NULL_TREE;\n+\n   arg1 = prep_operand (arg1);\n \n   bool memonly = false;\n@@ -5846,8 +5849,8 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n     case EQ_EXPR:\n     case NE_EXPR:\n       /* These are saved for the sake of maybe_warn_bool_compare.  */\n-      code_orig_arg1 = TREE_CODE (TREE_TYPE (arg1));\n-      code_orig_arg2 = TREE_CODE (TREE_TYPE (arg2));\n+      code_orig_arg1 = TREE_CODE (arg1_type);\n+      code_orig_arg2 = TREE_CODE (arg2_type);\n       break;\n \n       /* =, ->, [], () must be non-static member functions.  */\n@@ -5870,8 +5873,8 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n   if (code == COND_EXPR)\n     /* Use build_conditional_expr instead.  */\n     gcc_unreachable ();\n-  else if (! OVERLOAD_TYPE_P (TREE_TYPE (arg1))\n-\t   && (! arg2 || ! OVERLOAD_TYPE_P (TREE_TYPE (arg2))))\n+  else if (! OVERLOAD_TYPE_P (arg1_type)\n+\t   && (! arg2 || ! OVERLOAD_TYPE_P (arg2_type)))\n     goto builtin;\n \n   if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n@@ -5903,11 +5906,11 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n   args[2] = NULL_TREE;\n \n   /* Add class-member operators to the candidate set.  */\n-  if (CLASS_TYPE_P (TREE_TYPE (arg1)))\n+  if (CLASS_TYPE_P (arg1_type))\n     {\n       tree fns;\n \n-      fns = lookup_fnfields (TREE_TYPE (arg1), fnname, 1);\n+      fns = lookup_fnfields (arg1_type, fnname, 1);\n       if (fns == error_mark_node)\n \t{\n \t  result = error_mark_node;\n@@ -5927,7 +5930,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n      has an enumeration type, or T2 or reference to cv-qualified-opt\n      T2 for the second argument, if the second argument has an\n      enumeration type.  Filter out those that don't match.  */\n-  else if (! arg2 || ! CLASS_TYPE_P (TREE_TYPE (arg2)))\n+  else if (! arg2 || ! CLASS_TYPE_P (arg2_type))\n     {\n       struct z_candidate **candp, **next;\n \n@@ -5947,9 +5950,9 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \n \t      if (TYPE_REF_P (parmtype))\n \t\tparmtype = TREE_TYPE (parmtype);\n-\t      if (TREE_CODE (TREE_TYPE (args[i])) == ENUMERAL_TYPE\n+\t      if (TREE_CODE (unlowered_expr_type (args[i])) == ENUMERAL_TYPE\n \t\t  && (same_type_ignoring_top_level_qualifiers_p\n-\t\t      (TREE_TYPE (args[i]), parmtype)))\n+\t\t      (unlowered_expr_type (args[i]), parmtype)))\n \t\tbreak;\n \n \t      parmlist = TREE_CHAIN (parmlist);\n@@ -6124,15 +6127,15 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t    case LE_EXPR:\n \t    case EQ_EXPR:\n \t    case NE_EXPR:\n-\t      if (TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE\n-\t\t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE\n-\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n-\t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2)))\n+\t      if (TREE_CODE (arg1_type) == ENUMERAL_TYPE\n+\t\t  && TREE_CODE (arg2_type) == ENUMERAL_TYPE\n+\t\t  && (TYPE_MAIN_VARIANT (arg1_type)\n+\t\t      != TYPE_MAIN_VARIANT (arg2_type))\n \t\t  && (complain & tf_warning))\n \t\t{\n \t\t  warning (OPT_Wenum_compare,\n \t\t\t   \"comparison between %q#T and %q#T\",\n-\t\t\t   TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t\t\t   arg1_type, arg2_type);\n \t\t}\n \t      break;\n \t    default:"}, {"sha": "3f57d5f0397cf21779d63e9a87fccf4028b85d20", "filename": "gcc/testsuite/g++.dg/expr/bitfield13.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47518e131f299f69d0c14f7e5efe83609185ed9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fbitfield13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47518e131f299f69d0c14f7e5efe83609185ed9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fbitfield13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fbitfield13.C?ref=47518e131f299f69d0c14f7e5efe83609185ed9f", "patch": "@@ -0,0 +1,36 @@\n+// PR c++/82165\n+// { dg-do compile { target c++11 } }\n+\n+struct flags {\n+  enum field { f0, f1, no_field };\n+  field b0 : 4;\n+  field b1 : 4;\n+  field a0, a1;\n+};\n+\n+constexpr bool operator!(flags::field f) {\n+  return f == flags::no_field;\n+}\n+\n+#define SA(X) static_assert ((X), #X)\n+\n+int main() {\n+  constexpr flags f { flags::f0, flags::f1, flags::f0, flags::f1 };\n+\n+  SA( flags::f0 == 0 ); // 0\n+  SA( flags::f1 == 1 ); // 1\n+  SA( flags::no_field == 2 ); // 2\n+  SA( !flags::f0 == 0 ); // (!) 0\n+  SA( !flags::f1 == 0 ); // (!) 0\n+  SA( !flags::no_field == 1 ); // (!) 1\n+\n+  SA( f.a0 == 0 ); // 0\n+  SA( f.a1 == 1 ); // 1\n+  SA( !f.a0 == 0 ); // (!) 0\n+  SA( !f.a1 == 0 ); // (!) 0\n+\n+  SA( f.b0 == 0 ); // 0\n+  SA( f.b1 == 1 ); // 1\n+  SA( !f.b0 == 0 ); // expected \"(!) 0\", but got \"1\"\n+  SA( !f.b1 == 0 ); // expected \"(!) 0\", but got \"0\"\n+}"}]}