{"sha": "6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEzYzEyN2NjNGUxOThiZDIwYWUzMmMzN2M5M2NkZjdkZWZiMDg3MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:46:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:46:16Z"}, "message": "Improve vectorization COND_EXPR <bool op bool, ...>\n\nThis patch allows us to recognise:\n\n    ... = bool1 != bool2 ? x : y\n\nas equivalent to:\n\n    bool tmp = bool1 ^ bool2;\n    ... = tmp ? x : y\n\nFor the latter we were already able to find the natural number\nof vector units for tmp based on the types that feed bool1 and\nbool2, whereas with the former we would simply treat bool1 and\nbool2 as vectorised 8-bit values, possibly requiring them to\nbe packed and unpacked from their natural width.\n\nThis is used by a later SVE patch.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (vect_recog_mask_conversion_pattern): When\n\thandling COND_EXPRs with boolean comparisons, try to find a better\n\tbasis for the mask type than the boolean itself.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256207", "tree": {"sha": "26147d6f8dcd086b063ed6d907ba6ab1c313bf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26147d6f8dcd086b063ed6d907ba6ab1c313bf36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3c127cc4e198bd20ae32c37c93cdf7defb0871/comments", "author": null, "committer": null, "parents": [{"sha": "98ac791361227ed388237207baf629981cef03f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ac791361227ed388237207baf629981cef03f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ac791361227ed388237207baf629981cef03f7"}], "stats": {"total": 50, "additions": 45, "deletions": 5}, "files": [{"sha": "e273614bf131ed2d1e21c41ea71fb937e4abc1f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3c127cc4e198bd20ae32c37c93cdf7defb0871/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3c127cc4e198bd20ae32c37c93cdf7defb0871/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "patch": "@@ -1,3 +1,11 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-patterns.c (vect_recog_mask_conversion_pattern): When\n+\thandling COND_EXPRs with boolean comparisons, try to find a better\n+\tbasis for the mask type than the boolean itself.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* doc/rtl.texi (MAX_BITSIZE_MODE_ANY_MODE): Describe how the default"}, {"sha": "5124c110b240d91d968c91ab785f79a33bc3d135", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3c127cc4e198bd20ae32c37c93cdf7defb0871/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3c127cc4e198bd20ae32c37c93cdf7defb0871/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "patch": "@@ -3968,15 +3968,43 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n \t    return NULL;\n \t}\n       else if (COMPARISON_CLASS_P (rhs1))\n-\trhs1_type = TREE_TYPE (TREE_OPERAND (rhs1, 0));\n+\t{\n+\t  /* Check whether we're comparing scalar booleans and (if so)\n+\t     whether a better mask type exists than the mask associated\n+\t     with boolean-sized elements.  This avoids unnecessary packs\n+\t     and unpacks if the booleans are set from comparisons of\n+\t     wider types.  E.g. in:\n+\n+\t       int x1, x2, x3, x4, y1, y1;\n+\t       ...\n+\t       bool b1 = (x1 == x2);\n+\t       bool b2 = (x3 == x4);\n+\t       ... = b1 == b2 ? y1 : y2;\n+\n+\t     it is better for b1 and b2 to use the mask type associated\n+\t     with int elements rather bool (byte) elements.  */\n+\t  rhs1_type = search_type_for_mask (TREE_OPERAND (rhs1, 0), vinfo);\n+\t  if (!rhs1_type)\n+\t    rhs1_type = TREE_TYPE (TREE_OPERAND (rhs1, 0));\n+\t}\n       else\n \treturn NULL;\n \n       vectype2 = get_mask_type_for_scalar_type (rhs1_type);\n \n-      if (!vectype1 || !vectype2\n-\t  || known_eq (TYPE_VECTOR_SUBPARTS (vectype1),\n-\t\t       TYPE_VECTOR_SUBPARTS (vectype2)))\n+      if (!vectype1 || !vectype2)\n+\treturn NULL;\n+\n+      /* Continue if a conversion is needed.  Also continue if we have\n+\t a comparison whose vector type would normally be different from\n+\t VECTYPE2 when considered in isolation.  In that case we'll\n+\t replace the comparison with an SSA name (so that we can record\n+\t its vector type) and behave as though the comparison was an SSA\n+\t name from the outset.  */\n+      if (known_eq (TYPE_VECTOR_SUBPARTS (vectype1),\n+\t\t    TYPE_VECTOR_SUBPARTS (vectype2))\n+\t  && (TREE_CODE (rhs1) == SSA_NAME\n+\t      || rhs1_type == TREE_TYPE (TREE_OPERAND (rhs1, 0))))\n \treturn NULL;\n \n       /* If rhs1 is invariant and we can promote it leave the COND_EXPR\n@@ -4020,7 +4048,11 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n \t  append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n \t}\n \n-      tmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+      if (maybe_ne (TYPE_VECTOR_SUBPARTS (vectype1),\n+\t\t    TYPE_VECTOR_SUBPARTS (vectype2)))\n+\ttmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+      else\n+\ttmp = rhs1;\n \n       lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n       pattern_stmt = gimple_build_assign (lhs, COND_EXPR, tmp,"}]}