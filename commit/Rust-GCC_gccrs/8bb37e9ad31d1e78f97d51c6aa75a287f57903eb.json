{"sha": "8bb37e9ad31d1e78f97d51c6aa75a287f57903eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJiMzdlOWFkMzFkMWU3OGY5N2Q1MWM2YWE3NWEyODdmNTc5MDNlYg==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2012-08-01T16:53:05Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2012-08-01T16:53:05Z"}, "message": "tree-vrp.c (find_case_label_ranges): New function.\n\n2012-08-01  Tom de Vries  <tom@codesourcery.com>\n\n\t* tree-vrp.c (find_case_label_ranges): New function.\n\t(vrp_visit_switch_stmt, simplify_switch_using_ranges): Use\n\tfind_case_label_ranges instead of find_case_label_range.  Handle second\n\trange.\n\nFrom-SVN: r190043", "tree": {"sha": "b03905c678544a293cda83979fee70fcabdaf151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b03905c678544a293cda83979fee70fcabdaf151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb/comments", "author": null, "committer": null, "parents": [{"sha": "5f564b8f5655167ef3837eb104207705593276dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f564b8f5655167ef3837eb104207705593276dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f564b8f5655167ef3837eb104207705593276dc"}], "stats": {"total": 113, "additions": 107, "deletions": 6}, "files": [{"sha": "93ac1f5c02cfc8b16f460c29be5681269ff92c9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8bb37e9ad31d1e78f97d51c6aa75a287f57903eb", "patch": "@@ -1,3 +1,10 @@\n+2012-08-01  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* tree-vrp.c (find_case_label_ranges): New function.\n+\t(vrp_visit_switch_stmt, simplify_switch_using_ranges): Use\n+\tfind_case_label_ranges instead of find_case_label_range.  Handle second\n+\trange.\n+\n 2012-08-01  Michael Matz  <matz@suse.de>\n \n \t* tree-complex.c (init_parameter_lattice_values): Don't call var_ann."}, {"sha": "9a18b222db2ac95a3a68f12d732cd53a45e4893e", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 100, "deletions": 6, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb37e9ad31d1e78f97d51c6aa75a287f57903eb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8bb37e9ad31d1e78f97d51c6aa75a287f57903eb", "patch": "@@ -6754,6 +6754,84 @@ find_case_label_range (gimple stmt, tree min, tree max, size_t *min_idx,\n     }\n }\n \n+/* Searches the case label vector VEC for the ranges of CASE_LABELs that are\n+   used in range VR.  The indices are placed in MIN_IDX1, MAX_IDX, MIN_IDX2 and\n+   MAX_IDX2.  If the ranges of CASE_LABELs are empty then MAX_IDX1 < MIN_IDX1.\n+   Returns true if the default label is not needed.  */\n+\n+static bool\n+find_case_label_ranges (gimple stmt, value_range_t *vr, size_t *min_idx1,\n+\t\t\tsize_t *max_idx1, size_t *min_idx2,\n+\t\t\tsize_t *max_idx2)\n+{\n+  size_t i, j, k, l;\n+  unsigned int n = gimple_switch_num_labels (stmt);\n+  bool take_default;\n+  tree case_low, case_high;\n+  tree min = vr->min, max = vr->max;\n+\n+  gcc_checking_assert (vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE);\n+\n+  take_default = !find_case_label_range (stmt, min, max, &i, &j);\n+\n+  /* Set second range to emtpy.  */\n+  *min_idx2 = 1;\n+  *max_idx2 = 0;\n+\n+  if (vr->type == VR_RANGE)\n+    {\n+      *min_idx1 = i;\n+      *max_idx1 = j;\n+      return !take_default;\n+    }\n+\n+  /* Set first range to all case labels.  */\n+  *min_idx1 = 1;\n+  *max_idx1 = n - 1;\n+\n+  if (i > j)\n+    return false;\n+\n+  /* Make sure all the values of case labels [i , j] are contained in\n+     range [MIN, MAX].  */\n+  case_low = CASE_LOW (gimple_switch_label (stmt, i));\n+  case_high = CASE_HIGH (gimple_switch_label (stmt, j));\n+  if (tree_int_cst_compare (case_low, min) < 0)\n+    i += 1;\n+  if (case_high != NULL_TREE\n+      && tree_int_cst_compare (max, case_high) < 0)\n+    j -= 1;\n+\n+  if (i > j)\n+    return false;\n+\n+  /* If the range spans case labels [i, j], the corresponding anti-range spans\n+     the labels [1, i - 1] and [j + 1, n -  1].  */\n+  k = j + 1;\n+  l = n - 1;\n+  if (k > l)\n+    {\n+      k = 1;\n+      l = 0;\n+    }\n+\n+  j = i - 1;\n+  i = 1;\n+  if (i > j)\n+    {\n+      i = k;\n+      j = l;\n+      k = 1;\n+      l = 0;\n+    }\n+\n+  *min_idx1 = i;\n+  *max_idx1 = j;\n+  *min_idx2 = k;\n+  *max_idx2 = l;\n+  return false;\n+}\n+\n /* Visit switch statement STMT.  If we can determine which edge\n    will be taken out of STMT's basic block, record it in\n    *TAKEN_EDGE_P and return SSA_PROP_INTERESTING.  Otherwise, return\n@@ -6764,7 +6842,7 @@ vrp_visit_switch_stmt (gimple stmt, edge *taken_edge_p)\n {\n   tree op, val;\n   value_range_t *vr;\n-  size_t i = 0, j = 0;\n+  size_t i = 0, j = 0, k, l;\n   bool take_default;\n \n   *taken_edge_p = NULL;\n@@ -6782,12 +6860,13 @@ vrp_visit_switch_stmt (gimple stmt, edge *taken_edge_p)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (vr->type != VR_RANGE\n+  if ((vr->type != VR_RANGE\n+       && vr->type != VR_ANTI_RANGE)\n       || symbolic_range_p (vr))\n     return SSA_PROP_VARYING;\n \n   /* Find the single edge that is taken from the switch expression.  */\n-  take_default = !find_case_label_range (stmt, vr->min, vr->max, &i, &j);\n+  take_default = !find_case_label_ranges (stmt, vr, &i, &j, &k, &l);\n \n   /* Check if the range spans no CASE_LABEL. If so, we only reach the default\n      label */\n@@ -6821,6 +6900,16 @@ vrp_visit_switch_stmt (gimple stmt, edge *taken_edge_p)\n \t      return SSA_PROP_VARYING;\n \t    }\n         }\n+      for (; k <= l; ++k)\n+        {\n+          if (CASE_LABEL (gimple_switch_label (stmt, k)) != CASE_LABEL (val))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  not a single destination for this \"\n+\t\t\t \"range\\n\");\n+\t      return SSA_PROP_VARYING;\n+\t    }\n+        }\n     }\n \n   *taken_edge_p = find_edge (gimple_bb (stmt),\n@@ -8215,18 +8304,20 @@ simplify_switch_using_ranges (gimple stmt)\n   size_t i = 0, j = 0, n, n2;\n   tree vec2;\n   switch_update su;\n+  size_t k = 1, l = 0;\n \n   if (TREE_CODE (op) == SSA_NAME)\n     {\n       vr = get_value_range (op);\n \n       /* We can only handle integer ranges.  */\n-      if (vr->type != VR_RANGE\n+      if ((vr->type != VR_RANGE\n+\t   && vr->type != VR_ANTI_RANGE)\n \t  || symbolic_range_p (vr))\n \treturn false;\n \n       /* Find case label for min/max of the value range.  */\n-      take_default = !find_case_label_range (stmt, vr->min, vr->max, &i, &j);\n+      take_default = !find_case_label_ranges (stmt, vr, &i, &j, &k, &l);\n     }\n   else if (TREE_CODE (op) == INTEGER_CST)\n     {\n@@ -8253,7 +8344,7 @@ simplify_switch_using_ranges (gimple stmt)\n     return false;\n \n   /* Build a new vector of taken case labels.  */\n-  vec2 = make_tree_vec (j - i + 1 + (int)take_default);\n+  vec2 = make_tree_vec (j - i + 1 + l - k + 1 + (int)take_default);\n   n2 = 0;\n \n   /* Add the default edge, if necessary.  */\n@@ -8263,6 +8354,9 @@ simplify_switch_using_ranges (gimple stmt)\n   for (; i <= j; ++i, ++n2)\n     TREE_VEC_ELT (vec2, n2) = gimple_switch_label (stmt, i);\n \n+  for (; k <= l; ++k, ++n2)\n+    TREE_VEC_ELT (vec2, n2) = gimple_switch_label (stmt, k);\n+\n   /* Mark needed edges.  */\n   for (i = 0; i < n2; ++i)\n     {"}]}