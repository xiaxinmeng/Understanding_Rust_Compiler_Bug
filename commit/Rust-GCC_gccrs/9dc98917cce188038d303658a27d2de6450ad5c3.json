{"sha": "9dc98917cce188038d303658a27d2de6450ad5c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRjOTg5MTdjY2UxODgwMzhkMzAzNjU4YTI3ZDJkZTY0NTBhZDVjMw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2011-10-22T07:05:32Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-10-22T07:05:32Z"}, "message": "Convert sparc over to TARGET_SECONDARY_RELOAD.\n\ngcc/\n\n\t* config/sparc/sparc.h (SECONDARY_INPUT_RELOAD_CLASS,\n\tSECONDARY_OUTPUT_RELOAD_CLASS): Delete.\n\t* config/sparc/sparc.c (TARGET_SECONDARY_RELOAD): Redefine.\n\t(sparc_secondary_reload): New function.\n\nFrom-SVN: r180323", "tree": {"sha": "9c75b177564ea7fa4887b9d84aed1b0728edbffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c75b177564ea7fa4887b9d84aed1b0728edbffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dc98917cce188038d303658a27d2de6450ad5c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc98917cce188038d303658a27d2de6450ad5c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc98917cce188038d303658a27d2de6450ad5c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc98917cce188038d303658a27d2de6450ad5c3/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40c4cbcd82d343e9c9c6b9e1bd7ba8ab04e9220d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c4cbcd82d343e9c9c6b9e1bd7ba8ab04e9220d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c4cbcd82d343e9c9c6b9e1bd7ba8ab04e9220d"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "74b3d01cb71f6fb6912c6ed652da4b65b391b2e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc98917cce188038d303658a27d2de6450ad5c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc98917cce188038d303658a27d2de6450ad5c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dc98917cce188038d303658a27d2de6450ad5c3", "patch": "@@ -1,3 +1,10 @@\n+2011-10-22  David S. Miller  <davem@davemloft.net>\n+\n+\t* config/sparc/sparc.h (SECONDARY_INPUT_RELOAD_CLASS,\n+\tSECONDARY_OUTPUT_RELOAD_CLASS): Delete.\n+\t* config/sparc/sparc.c (TARGET_SECONDARY_RELOAD): Redefine.\n+\t(sparc_secondary_reload): New function.\n+\n 2011-10-21  Paul Brook  <paul@codesourcery.com>\n \n \t* config/c6x/c6x.c (c6x_asm_emit_except_personality,"}, {"sha": "5dbb9141c987b6f0b8dbd6e0e14e0e69ed1ca04b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc98917cce188038d303658a27d2de6450ad5c3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc98917cce188038d303658a27d2de6450ad5c3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9dc98917cce188038d303658a27d2de6450ad5c3", "patch": "@@ -500,6 +500,8 @@ static reg_class_t sparc_preferred_reload_class (rtx x, reg_class_t rclass);\n static bool sparc_print_operand_punct_valid_p (unsigned char);\n static void sparc_print_operand (FILE *, rtx, int);\n static void sparc_print_operand_address (FILE *, rtx);\n+static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n+\t\t\t\t\t   enum machine_mode, secondary_reload_info *);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -674,6 +676,9 @@ char sparc_hard_reg_printed[8];\n #undef  TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS sparc_preferred_reload_class\n \n+#undef TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD sparc_secondary_reload\n+\n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE sparc_conditional_register_usage\n \n@@ -11200,4 +11205,45 @@ sparc_expand_vector_init (rtx target, rtx vals)\n   emit_move_insn (target, mem);\n }\n \n+static reg_class_t\n+sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n+\t\t\tenum machine_mode mode, secondary_reload_info *sri)\n+{\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n+\n+  /* We need a temporary when loading/storing a HImode/QImode value\n+     between memory and the FPU registers.  This can happen when combine puts\n+     a paradoxical subreg in a float/fix conversion insn.  */\n+  if (FP_REG_CLASS_P (rclass)\n+      && (mode == HImode || mode == QImode)\n+      && (GET_CODE (x) == MEM\n+\t  || ((GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n+\t      && true_regnum (x) == -1)))\n+    return GENERAL_REGS;\n+\n+  /* On 32-bit we need a temporary when loading/storing a DFmode value\n+     between unaligned memory and the upper FPU registers.  */\n+  if (TARGET_ARCH32\n+      && rclass == EXTRA_FP_REGS\n+      && mode == DFmode\n+      && GET_CODE (x) == MEM\n+      && ! mem_min_alignment (x, 8))\n+    return FP_REGS;\n+\n+  if (((TARGET_CM_MEDANY\n+\t&& symbolic_operand (x, mode))\n+       || (TARGET_CM_EMBMEDANY\n+\t   && text_segment_operand (x, mode)))\n+      && ! flag_pic)\n+    {\n+      if (in_p)\n+\tsri->icode = direct_optab_handler (reload_in_optab, mode);\n+      else\n+\tsri->icode = direct_optab_handler (reload_out_optab, mode);\n+      return NO_REGS;\n+    }\n+\n+  return NO_REGS;\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "9b7835e68588bc01f50ae7d7ca0079330149d21f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc98917cce188038d303658a27d2de6450ad5c3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc98917cce188038d303658a27d2de6450ad5c3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=9dc98917cce188038d303658a27d2de6450ad5c3", "patch": "@@ -1112,54 +1112,6 @@ extern char leaf_reg_remap[];\n #define SPARC_SETHI32_P(X) \\\n   (SPARC_SETHI_P ((unsigned HOST_WIDE_INT) (X) & GET_MODE_MASK (SImode)))\n \n-/* Return the register class of a scratch register needed to load IN into\n-   a register of class CLASS in MODE.\n-\n-   We need a temporary when loading/storing a HImode/QImode value\n-   between memory and the FPU registers.  This can happen when combine puts\n-   a paradoxical subreg in a float/fix conversion insn.\n-\n-   We need a temporary when loading/storing a DFmode value between\n-   unaligned memory and the upper FPU registers.  */\n-\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n-  ((FP_REG_CLASS_P (CLASS)\t\t\t\t\t\\\n-    && ((MODE) == HImode || (MODE) == QImode)\t\t\t\\\n-    && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n-        || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n-            && true_regnum (IN) == -1)))\t\t\t\\\n-   ? GENERAL_REGS\t\t\t\t\t\t\\\n-   : ((CLASS) == EXTRA_FP_REGS && (MODE) == DFmode\t\t\\\n-      && GET_CODE (IN) == MEM && TARGET_ARCH32\t\t\t\\\n-      && ! mem_min_alignment ((IN), 8))\t\t\t\t\\\n-     ? FP_REGS\t\t\t\t\t\t\t\\\n-     : (((TARGET_CM_MEDANY\t\t\t\t\t\\\n-\t  && symbolic_operand ((IN), (MODE)))\t\t\t\\\n-\t || (TARGET_CM_EMBMEDANY\t\t\t\t\\\n-\t     && text_segment_operand ((IN), (MODE))))\t\t\\\n-\t&& !flag_pic)\t\t\t\t\t\t\\\n-       ? GENERAL_REGS\t\t\t\t\t\t\\\n-       : NO_REGS)\n-\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n-  ((FP_REG_CLASS_P (CLASS)\t\t\t\t\t\\\n-     && ((MODE) == HImode || (MODE) == QImode)\t\t\t\\\n-     && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n-         || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n-             && true_regnum (IN) == -1)))\t\t\t\\\n-   ? GENERAL_REGS\t\t\t\t\t\t\\\n-   : ((CLASS) == EXTRA_FP_REGS && (MODE) == DFmode\t\t\\\n-      && GET_CODE (IN) == MEM && TARGET_ARCH32\t\t\t\\\n-      && ! mem_min_alignment ((IN), 8))\t\t\t\t\\\n-     ? FP_REGS\t\t\t\t\t\t\t\\\n-     : (((TARGET_CM_MEDANY\t\t\t\t\t\\\n-\t  && symbolic_operand ((IN), (MODE)))\t\t\t\\\n-\t || (TARGET_CM_EMBMEDANY\t\t\t\t\\\n-\t     && text_segment_operand ((IN), (MODE))))\t\t\\\n-\t&& !flag_pic)\t\t\t\t\t\t\\\n-       ? GENERAL_REGS\t\t\t\t\t\t\\\n-       : NO_REGS)\n-\n /* On SPARC it is not possible to directly move data between\n    GENERAL_REGS and FP_REGS.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\"}]}