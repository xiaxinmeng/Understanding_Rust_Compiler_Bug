{"sha": "a29ca9db50ec94d993207ae9c3a43228fe62a6f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5Y2E5ZGI1MGVjOTRkOTkzMjA3YWU5YzNhNDMyMjhmZTYyYTZmOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-29T23:19:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-29T23:19:51Z"}, "message": "(recog_for_combine): New parm PADDED_SCRATCHES; set it.\n\n(try_combine): Accumulate number of scratches and update max_scratch.\n(simplify_set): Add extra parm to recog_for_combine.\n\nFrom-SVN: r9839", "tree": {"sha": "b77bb9133552d41f23b1b5331e0ae37ca9e924b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b77bb9133552d41f23b1b5331e0ae37ca9e924b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a29ca9db50ec94d993207ae9c3a43228fe62a6f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29ca9db50ec94d993207ae9c3a43228fe62a6f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29ca9db50ec94d993207ae9c3a43228fe62a6f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29ca9db50ec94d993207ae9c3a43228fe62a6f8/comments", "author": null, "committer": null, "parents": [{"sha": "cefb043c9cd10f1805cdeff7e74278b0ac63beb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cefb043c9cd10f1805cdeff7e74278b0ac63beb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cefb043c9cd10f1805cdeff7e74278b0ac63beb6"}], "stats": {"total": 65, "additions": 47, "deletions": 18}, "files": [{"sha": "11c941ab70b9d7a4a59c5be127b69584cbcd73a4", "filename": "gcc/combine.c", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29ca9db50ec94d993207ae9c3a43228fe62a6f8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29ca9db50ec94d993207ae9c3a43228fe62a6f8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a29ca9db50ec94d993207ae9c3a43228fe62a6f8", "patch": "@@ -420,7 +420,7 @@ static int merge_outer_ops\tPROTO((enum rtx_code *, HOST_WIDE_INT *,\n \t\t\t\t       enum machine_mode, int *));\n static rtx simplify_shift_const\tPROTO((rtx, enum rtx_code, enum machine_mode,\n \t\t\t\t       rtx, int));\n-static int recog_for_combine\tPROTO((rtx *, rtx, rtx *));\n+static int recog_for_combine\tPROTO((rtx *, rtx, rtx *, int *));\n static rtx gen_lowpart_for_combine  PROTO((enum machine_mode, rtx));\n static rtx gen_rtx_combine PVPROTO((enum rtx_code code, enum machine_mode mode,\n \t\t\t\t  ...));\n@@ -1217,6 +1217,8 @@ try_combine (i3, i2, i1)\n   int i3_subst_into_i2 = 0;\n   /* Notes that I1, I2 or I3 is a MULT operation.  */\n   int have_mult = 0;\n+  /* Number of clobbers of SCRATCH we had to add.  */\n+  int i3_scratches = 0, i2_scratches = 0, other_scratches = 0;\n \n   int maxreg;\n   rtx temp;\n@@ -1685,7 +1687,8 @@ try_combine (i3, i2, i1)\n   mark_used_regs_combine (newpat);\n \n   /* Is the result of combination a valid instruction?  */\n-  insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+  insn_code_number\n+    = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n \n   /* If the result isn't valid, see if it is a PARALLEL of two SETs where\n      the second SET's destination is a register that is unused.  In that case,\n@@ -1706,7 +1709,8 @@ try_combine (i3, i2, i1)\n       && asm_noperands (newpat) < 0)\n     {\n       newpat = XVECEXP (newpat, 0, 0);\n-      insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+      insn_code_number\n+\t= recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n     }\n \n   else if (insn_code_number < 0 && GET_CODE (newpat) == PARALLEL\n@@ -1719,7 +1723,8 @@ try_combine (i3, i2, i1)\n \t   && asm_noperands (newpat) < 0)\n     {\n       newpat = XVECEXP (newpat, 0, 1);\n-      insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+      insn_code_number\n+\t= recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n     }\n \n   /* If we were combining three insns and the result is a simple SET\n@@ -1788,15 +1793,15 @@ try_combine (i3, i2, i1)\n \t  if (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n \t    SUBST (regno_reg_rtx[REGNO (i2dest)], ni2dest);\n \n-\t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n+\t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes,\n+\t\t\t\t\t      &i2_scratches);\n \n \t  /* If I2 or I3 has multiple SETs, we won't know how to track\n \t     register status, so don't use these insns.  */\n \n \t  if (i2_code_number >= 0 && i2set && i3set)\n-\t    insn_code_number = recog_for_combine (&newi3pat, i3,\n-\t\t\t\t\t\t  &new_i3_notes);\n-\n+\t    insn_code_number = recog_for_combine (&newi3pat, i3, &new_i3_notes,\n+\t\t\t\t\t\t  &i3_scratches); \n \t  if (insn_code_number >= 0)\n \t    newpat = newi3pat;\n \n@@ -1867,12 +1872,14 @@ try_combine (i3, i2, i1)\n \n \t  newi2pat = gen_rtx_combine (SET, VOIDmode, newdest, *split);\n \t  SUBST (*split, newdest);\n-\t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n+\t  i2_code_number\n+\t    = recog_for_combine (&newi2pat, i2, &new_i2_notes, &i2_scratches);\n \n \t  /* If the split point was a MULT and we didn't have one before,\n \t     don't use one now.  */\n \t  if (i2_code_number >= 0 && ! (split_code == MULT && ! have_mult))\n-\t    insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+\t    insn_code_number\n+\t      = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n \t}\n     }\n \n@@ -1926,9 +1933,12 @@ try_combine (i3, i2, i1)\n       newpat = XVECEXP (newpat, 0, 1);\n       SUBST (SET_SRC (newpat),\n \t     gen_lowpart_for_combine (GET_MODE (SET_SRC (newpat)), ni2dest));\n-      i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n+      i2_code_number\n+\t= recog_for_combine (&newi2pat, i2, &new_i2_notes, &i2_scratches);\n+\n       if (i2_code_number >= 0)\n-\tinsn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+\tinsn_code_number\n+\t  = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n \n       if (insn_code_number >= 0)\n \t{\n@@ -2002,9 +2012,12 @@ try_combine (i3, i2, i1)\n       newi2pat = XVECEXP (newpat, 0, 1);\n       newpat = XVECEXP (newpat, 0, 0);\n \n-      i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n+      i2_code_number\n+\t= recog_for_combine (&newi2pat, i2, &new_i2_notes, &i2_scratches);\n+\n       if (i2_code_number >= 0)\n-\tinsn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+\tinsn_code_number\n+\t  = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n     }\n \n   /* If it still isn't recognized, fail and change things back the way they\n@@ -2026,8 +2039,9 @@ try_combine (i3, i2, i1)\n \n       CLEAR_HARD_REG_SET (newpat_used_regs);\n \n-      other_code_number = recog_for_combine (&other_pat, undobuf.other_insn,\n-\t\t\t\t\t     &new_other_notes);\n+      other_code_number\n+\t= recog_for_combine (&other_pat, undobuf.other_insn,\n+\t\t\t     &new_other_notes, &other_scratches);\n \n       if (other_code_number < 0 && ! check_asm_operands (other_pat))\n \t{\n@@ -2329,6 +2343,12 @@ try_combine (i3, i2, i1)\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies);\n \n+    /* If we added any (clobber (scratch)), add them to the max for a\n+       block.  This is a very pessimistic calculation, since we might\n+       have had them already and this might not be the worst block, but\n+       it's not worth doing any better.  */\n+    max_scratch += i3_scratches + i2_scratches + other_scratches;\n+\n     /* If I3 is now an unconditional jump, ensure that it has a \n        BARRIER following it since it may have initially been a\n        conditional jump.  It may also be the last nonnote insn.  */\n@@ -4286,8 +4306,9 @@ simplify_set (x)\n \t      && exact_log2 (mask = nonzero_bits (op0, GET_MODE (op0))) >= 0)\n \t    {\n \t      rtx pat = PATTERN (other_insn), note = 0;\n+\t      int scratches;\n \n-\t      if ((recog_for_combine (&pat, other_insn, &note) < 0\n+\t      if ((recog_for_combine (&pat, other_insn, &note, &scratches) < 0\n \t\t   && ! check_asm_operands (pat)))\n \t\t{\n \t\t  PUT_CODE (*cc_use, old_code);\n@@ -8307,21 +8328,27 @@ simplify_shift_const (x, code, result_mode, varop, count)\n    PNOTES is a pointer to a location where any REG_UNUSED notes added for\n    the CLOBBERs are placed.\n \n+   PADDED_SCRATCHES is set to the number of (clobber (scratch)) patterns\n+   we had to add.\n+\n    The value is the final insn code from the pattern ultimately matched,\n    or -1.  */\n \n static int\n-recog_for_combine (pnewpat, insn, pnotes)\n+recog_for_combine (pnewpat, insn, pnotes, padded_scratches)\n      rtx *pnewpat;\n      rtx insn;\n      rtx *pnotes;\n+     int *padded_scratches;\n {\n   register rtx pat = *pnewpat;\n   int insn_code_number;\n   int num_clobbers_to_add = 0;\n   int i;\n   rtx notes = 0;\n \n+  *padded_scratches = 0;\n+\n   /* If PAT is a PARALLEL, check to see if it contains the CLOBBER\n      we use to indicate that something didn't match.  If we find such a\n      thing, force rejection.  */\n@@ -8383,6 +8410,8 @@ recog_for_combine (pnewpat, insn, pnotes)\n \t  if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) == REG\n \t      && ! reg_dead_at_p (XEXP (XVECEXP (newpat, 0, i), 0), insn))\n \t    return -1;\n+\t  else if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) == SCRATCH)\n+\t    (*padded_scratches)++;\n \t  notes = gen_rtx (EXPR_LIST, REG_UNUSED,\n \t\t\t   XEXP (XVECEXP (newpat, 0, i), 0), notes);\n \t}"}]}