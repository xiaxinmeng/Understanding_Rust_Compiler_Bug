{"sha": "045c12782cc8ccea5dda8e5b703bb794fc759aac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ1YzEyNzgyY2M4Y2NlYTVkZGE4ZTViNzAzYmI3OTRmYzc1OWFhYw==", "commit": {"author": {"name": "Ilya Enkovich", "email": "enkovich.gnu@gmail.com", "date": "2015-11-10T12:06:05Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-11-10T12:06:05Z"}, "message": "internal-fn.c (expand_MASK_LOAD): Adjust to maskload optab changes.\n\ngcc/\n\n\t* internal-fn.c (expand_MASK_LOAD): Adjust to maskload optab changes.\n\t(expand_MASK_STORE): Adjust to maskstore optab changes.\n\t* optabs-query.c (can_vec_mask_load_store_p): Add MASK_MODE arg.\n\t Adjust to maskload, maskstore optab changes.\n\t* optabs-query.h (can_vec_mask_load_store_p): Add MASK_MODE arg.\n\t* optabs.def (maskload_optab): Transform into convert optab.\n\t(maskstore_optab): Likewise.\n\t* tree-if-conv.c (ifcvt_can_use_mask_load_store): Adjust to\n\tcan_vec_mask_load_store_p signature change.\n\t(predicate_mem_writes): Use boolean mask.\n\t* tree-vect-stmts.c (vectorizable_mask_load_store): Adjust to\n\tcan_vec_mask_load_store_p signature change.  Allow invariant masks.\n\t(vectorizable_operation): Ignore type precision for boolean vectors.\n\ngcc/testsuite/\n\n\t* gcc.target/i386/avx2-vec-mask-bit-not.c: New test.\n\nFrom-SVN: r230099", "tree": {"sha": "58e89245d538b87c44e1cedf05f978bb107e276d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58e89245d538b87c44e1cedf05f978bb107e276d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/045c12782cc8ccea5dda8e5b703bb794fc759aac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/045c12782cc8ccea5dda8e5b703bb794fc759aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/045c12782cc8ccea5dda8e5b703bb794fc759aac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/045c12782cc8ccea5dda8e5b703bb794fc759aac/comments", "author": null, "committer": null, "parents": [{"sha": "42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42fd8198b4adabe3aa74e9bb98518a1d137c3aff"}], "stats": {"total": 137, "additions": 105, "deletions": 32}, "files": [{"sha": "a7421a995debad9323f1deb3126d12d23cd02864", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -1,3 +1,19 @@\n+2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* internal-fn.c (expand_MASK_LOAD): Adjust to maskload optab changes.\n+\t(expand_MASK_STORE): Adjust to maskstore optab changes.\n+\t* optabs-query.c (can_vec_mask_load_store_p): Add MASK_MODE arg.\n+\t Adjust to maskload, maskstore optab changes.\n+\t* optabs-query.h (can_vec_mask_load_store_p): Add MASK_MODE arg.\n+\t* optabs.def (maskload_optab): Transform into convert optab.\n+\t(maskstore_optab): Likewise.\n+\t* tree-if-conv.c (ifcvt_can_use_mask_load_store): Adjust to\n+\tcan_vec_mask_load_store_p signature change.\n+\t(predicate_mem_writes): Use boolean mask.\n+\t* tree-vect-stmts.c (vectorizable_mask_load_store): Adjust to\n+\tcan_vec_mask_load_store_p signature change.  Allow invariant masks.\n+\t(vectorizable_operation): Ignore type precision for boolean vectors.\n+\n 2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* expr.c (do_store_flag): Use expand_vec_cmp_expr for mask results."}, {"sha": "79425ea6a0ff4d5e2a1b225f33fe6caca790b34d", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -1889,7 +1889,9 @@ expand_MASK_LOAD (gcall *stmt)\n   create_output_operand (&ops[0], target, TYPE_MODE (type));\n   create_fixed_operand (&ops[1], mem);\n   create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (optab_handler (maskload_optab, TYPE_MODE (type)), 3, ops);\n+  expand_insn (convert_optab_handler (maskload_optab, TYPE_MODE (type),\n+\t\t\t\t      TYPE_MODE (TREE_TYPE (maskt))),\n+\t       3, ops);\n }\n \n static void\n@@ -1912,7 +1914,9 @@ expand_MASK_STORE (gcall *stmt)\n   create_fixed_operand (&ops[0], mem);\n   create_input_operand (&ops[1], reg, TYPE_MODE (type));\n   create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (optab_handler (maskstore_optab, TYPE_MODE (type)), 3, ops);\n+  expand_insn (convert_optab_handler (maskstore_optab, TYPE_MODE (type),\n+\t\t\t\t      TYPE_MODE (TREE_TYPE (maskt))),\n+\t       3, ops);\n }\n \n static void"}, {"sha": "c20597c7bcba480ff40783f565671ad8ccc6f59f", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -466,15 +466,17 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n /* Return true if target supports vector masked load/store for mode.  */\n \n bool\n-can_vec_mask_load_store_p (machine_mode mode, bool is_load)\n+can_vec_mask_load_store_p (machine_mode mode,\n+\t\t\t   machine_mode mask_mode,\n+\t\t\t   bool is_load)\n {\n   optab op = is_load ? maskload_optab : maskstore_optab;\n   machine_mode vmode;\n   unsigned int vector_sizes;\n \n   /* If mode is vector mode, check it directly.  */\n   if (VECTOR_MODE_P (mode))\n-    return optab_handler (op, mode) != CODE_FOR_nothing;\n+    return convert_optab_handler (op, mode, mask_mode) != CODE_FOR_nothing;\n \n   /* Otherwise, return true if there is some vector mode with\n      the mask load/store supported.  */\n@@ -485,7 +487,12 @@ can_vec_mask_load_store_p (machine_mode mode, bool is_load)\n   if (!VECTOR_MODE_P (vmode))\n     return false;\n \n-  if (optab_handler (op, vmode) != CODE_FOR_nothing)\n+  mask_mode = targetm.vectorize.get_mask_mode (GET_MODE_NUNITS (vmode),\n+\t\t\t\t\t       GET_MODE_SIZE (vmode));\n+  if (mask_mode == VOIDmode)\n+    return false;\n+\n+  if (convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n     return true;\n \n   vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n@@ -496,8 +503,10 @@ can_vec_mask_load_store_p (machine_mode mode, bool is_load)\n       if (cur <= GET_MODE_SIZE (mode))\n \tcontinue;\n       vmode = mode_for_vector (mode, cur / GET_MODE_SIZE (mode));\n+      mask_mode = targetm.vectorize.get_mask_mode (GET_MODE_NUNITS (vmode),\n+\t\t\t\t\t\t   cur);\n       if (VECTOR_MODE_P (vmode)\n-\t  && optab_handler (op, vmode) != CODE_FOR_nothing)\n+\t  && convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n \treturn true;\n     }\n   return false;"}, {"sha": "162d2e9a7c3ee58deec3983be4b757b57ec558e7", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -140,7 +140,7 @@ enum insn_code find_widening_optab_handler_and_mode (optab, machine_mode,\n \t\t\t\t\t\t     machine_mode, int,\n \t\t\t\t\t\t     machine_mode *);\n int can_mult_highpart_p (machine_mode, bool);\n-bool can_vec_mask_load_store_p (machine_mode, bool);\n+bool can_vec_mask_load_store_p (machine_mode, machine_mode, bool);\n bool can_compare_and_swap_p (machine_mode, bool);\n bool can_atomic_exchange_p (machine_mode, bool);\n bool lshift_cheap_p (bool);"}, {"sha": "c9e52a96a2578050786c547d3fc852daa918c024", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -63,6 +63,8 @@ OPTAB_CD(vcond_optab, \"vcond$a$b\")\n OPTAB_CD(vcondu_optab, \"vcondu$a$b\")\n OPTAB_CD(vec_cmp_optab, \"vec_cmp$a$b\")\n OPTAB_CD(vec_cmpu_optab, \"vec_cmpu$a$b\")\n+OPTAB_CD(maskload_optab, \"maskload$a$b\")\n+OPTAB_CD(maskstore_optab, \"maskstore$a$b\")\n \n OPTAB_NL(add_optab, \"add$P$a3\", PLUS, \"add\", '3', gen_int_fp_fixed_libfunc)\n OPTAB_NX(add_optab, \"add$F$a3\")\n@@ -268,8 +270,6 @@ OPTAB_D (udot_prod_optab, \"udot_prod$I$a\")\n OPTAB_D (usum_widen_optab, \"widen_usum$I$a3\")\n OPTAB_D (usad_optab, \"usad$I$a\")\n OPTAB_D (ssad_optab, \"ssad$I$a\")\n-OPTAB_D (maskload_optab, \"maskload$a\")\n-OPTAB_D (maskstore_optab, \"maskstore$a\")\n OPTAB_D (vec_extract_optab, \"vec_extract$a\")\n OPTAB_D (vec_init_optab, \"vec_init$a\")\n OPTAB_D (vec_pack_sfix_trunc_optab, \"vec_pack_sfix_trunc_$a\")"}, {"sha": "1ac009f261305218c8a6dc5f588d5f7ad177bf08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -1,3 +1,7 @@\n+2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* gcc.target/i386/avx2-vec-mask-bit-not.c: New test.\n+\n 2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* gcc.dg/vect/slp-cond-5.c: New test."}, {"sha": "0c946ca0eaec0458b52213170fb1e0bb6ffa0fd5", "filename": "gcc/testsuite/gcc.target/i386/avx2-vec-mask-bit-not.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vec-mask-bit-not.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vec-mask-bit-not.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vec-mask-bit-not.c?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-options \"-mavx2 -O3 -fopenmp-simd -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+\n+#define N 1024\n+\n+int a[N], b[N], c[N], d[N], e[N];\n+\n+void\n+test (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    if (!(a[i] > b[i] && c[i] < d[i]))\n+      e[i] = 0;\n+}"}, {"sha": "88b6405a7be355242a306f1d7768cba49ed7da31", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -799,7 +799,7 @@ ifcvt_can_use_mask_load_store (gimple *stmt)\n       || VECTOR_MODE_P (mode))\n     return false;\n \n-  if (can_vec_mask_load_store_p (mode, is_load))\n+  if (can_vec_mask_load_store_p (mode, VOIDmode, is_load))\n     return true;\n \n   return false;\n@@ -2056,8 +2056,9 @@ predicate_mem_writes (loop_p loop)\n \t  {\n \t    tree lhs = gimple_assign_lhs (stmt);\n \t    tree rhs = gimple_assign_rhs1 (stmt);\n-\t    tree ref, addr, ptr, masktype, mask_op0, mask_op1, mask;\n+\t    tree ref, addr, ptr, mask;\n \t    gimple *new_stmt;\n+\t    gimple_seq stmts = NULL;\n \t    int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (lhs)));\n \t    ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n \t    mark_addressable (ref);\n@@ -2070,16 +2071,27 @@ predicate_mem_writes (loop_p loop)\n \t      mask = vect_masks[index];\n \t    else\n \t      {\n-\t\tmasktype = build_nonstandard_integer_type (bitsize, 1);\n-\t\tmask_op0 = build_int_cst (masktype, swap ? 0 : -1);\n-\t\tmask_op1 = build_int_cst (masktype, swap ? -1 : 0);\n-\t\tcond = force_gimple_operand_gsi_1 (&gsi, unshare_expr (cond),\n-\t\t\t\t\t\t   is_gimple_condexpr,\n-\t\t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t\t   true, GSI_SAME_STMT);\n-\t\tmask = fold_build_cond_expr (masktype, unshare_expr (cond),\n-\t\t\t\t\t     mask_op0, mask_op1);\n-\t\tmask = ifc_temp_var (masktype, mask, &gsi);\n+\t\tif (COMPARISON_CLASS_P (cond))\n+\t\t  mask = gimple_build (&stmts, TREE_CODE (cond),\n+\t\t\t\t       boolean_type_node,\n+\t\t\t\t       TREE_OPERAND (cond, 0),\n+\t\t\t\t       TREE_OPERAND (cond, 1));\n+\t\telse\n+\t\t  {\n+\t\t    gcc_assert (TREE_CODE (cond) == SSA_NAME);\n+\t\t    mask = cond;\n+\t\t  }\n+\n+\t\tif (swap)\n+\t\t  {\n+\t\t    tree true_val\n+\t\t      = constant_boolean_node (true, TREE_TYPE (mask));\n+\t\t    mask = gimple_build (&stmts, BIT_XOR_EXPR,\n+\t\t\t\t\t TREE_TYPE (mask), mask, true_val);\n+\t\t  }\n+\t\tgsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+\n+\t\tmask = ifc_temp_var (TREE_TYPE (mask), mask, &gsi);\n \t\t/* Save mask and its size for further use.  */\n \t        vect_sizes.safe_push (bitsize);\n \t\tvect_masks.safe_push (mask);"}, {"sha": "bdf16faff79e141adca335034ac864ab9ba9bcfb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045c12782cc8ccea5dda8e5b703bb794fc759aac/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=045c12782cc8ccea5dda8e5b703bb794fc759aac", "patch": "@@ -1688,6 +1688,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   bool nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree mask_vectype;\n   tree elem_type;\n   gimple *new_stmt;\n   tree dummy;\n@@ -1714,8 +1715,8 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   is_store = gimple_call_internal_fn (stmt) == IFN_MASK_STORE;\n   mask = gimple_call_arg (stmt, 2);\n-  if (TYPE_PRECISION (TREE_TYPE (mask))\n-      != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (vectype))))\n+\n+  if (TREE_CODE (TREE_TYPE (mask)) != BOOLEAN_TYPE)\n     return false;\n \n   /* FORNOW. This restriction should be relaxed.  */\n@@ -1744,6 +1745,18 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_STRIDED_P (stmt_info))\n     return false;\n \n+  if (TREE_CODE (mask) != SSA_NAME)\n+    return false;\n+\n+  if (!vect_is_simple_use (mask, loop_vinfo, &def_stmt, &dt, &mask_vectype))\n+    return false;\n+\n+  if (!mask_vectype)\n+    mask_vectype = get_mask_type_for_scalar_type (TREE_TYPE (vectype));\n+\n+  if (!mask_vectype)\n+    return false;\n+\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple *def_stmt;\n@@ -1775,13 +1788,9 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t : DR_STEP (dr), size_zero_node) <= 0)\n     return false;\n   else if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n-\t   || !can_vec_mask_load_store_p (TYPE_MODE (vectype), !is_store))\n-    return false;\n-\n-  if (TREE_CODE (mask) != SSA_NAME)\n-    return false;\n-\n-  if (!vect_is_simple_use (mask, loop_vinfo, &def_stmt, &dt))\n+\t   || !can_vec_mask_load_store_p (TYPE_MODE (vectype),\n+\t\t\t\t\t  TYPE_MODE (mask_vectype),\n+\t\t\t\t\t  !is_store))\n     return false;\n \n   if (is_store)\n@@ -4688,8 +4697,9 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   /* Most operations cannot handle bit-precision types without extra\n      truncations.  */\n-  if ((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n-       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+  if (!VECTOR_BOOLEAN_TYPE_P (vectype_out)\n+      && (TYPE_PRECISION (TREE_TYPE (scalar_dest))\n+\t  != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n       /* Exception are bitwise binary operations.  */\n       && code != BIT_IOR_EXPR\n       && code != BIT_XOR_EXPR"}]}