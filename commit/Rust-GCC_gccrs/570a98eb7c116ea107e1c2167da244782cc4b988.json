{"sha": "570a98eb7c116ea107e1c2167da244782cc4b988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcwYTk4ZWI3YzExNmVhMTA3ZTFjMjE2N2RhMjQ0NzgyY2M0Yjk4OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-07T20:24:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-07T20:24:08Z"}, "message": "calls.c (expand_call): Do not emit INSN_SETJMP note.\n\n\t* calls.c (expand_call): Do not emit INSN_SETJMP note.\n\t(emit_library_call_value_1): Likewise.\n\t(emit_call_1): Emit REG_SETJMP note.\n\t* cse.c (cse_end_of_basic_block): Use REG_SETJMP instead\n\tof INSN_SETJMP\n\t* cselib.c (cselib_process_insn): Likewise.\n\t* flow.c (propagate_block): Likewise.\n\t* loop.c (find_and_verify_loops): Likewise.\n\t* reload.c (find_equiv_regs): Likewise.\n\t* reload1.c (reload): Likewise.\n\t* resource.c (mark_referenced_resources,\n\tmark_set_resources): Likewise.\n\t* sched-deps (sched_analyze_insn, sched_analyze): Likewise.\n\t* final.c (final_scan_insn): Remove NOTE_INSN_SETJMP.\n\t* haifa-sched.c (unlink_other_notes): Likewise.\n\t(reemit_notes): Likewise.\n\t* sched-ebb.c (sched_ebb): Likewise.\n\t* sched-rgc.c (sched_region): Likewise.\n\t* rtl.c (note_insn_name): Likewise.\n\t(reg_note_name): Add REG_SETJMP\n\t* rtl.h (reg_note): Add REG_SETJMP.\n\t(insn_note): Remove NOTE_INSN_SETJMP.\n\n\t* profile.c (branch_prob): Add fake edges for setjmp.\n\nFrom-SVN: r44700", "tree": {"sha": "60a5182f2490898a51da85e16138b7f79e245443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60a5182f2490898a51da85e16138b7f79e245443"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/570a98eb7c116ea107e1c2167da244782cc4b988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570a98eb7c116ea107e1c2167da244782cc4b988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/570a98eb7c116ea107e1c2167da244782cc4b988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570a98eb7c116ea107e1c2167da244782cc4b988/comments", "author": null, "committer": null, "parents": [{"sha": "ff25793cc1ffe5114b6ce07b44c75698d12ab0b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff25793cc1ffe5114b6ce07b44c75698d12ab0b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff25793cc1ffe5114b6ce07b44c75698d12ab0b2"}], "stats": {"total": 262, "additions": 132, "deletions": 130}, "files": [{"sha": "669297e125c1bd2626e94256384ab3b403b5c151", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -1,3 +1,30 @@\n+Tue Aug  7 22:18:06 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c (expand_call): Do not emit INSN_SETJMP note.\n+\t(emit_library_call_value_1): Likewise.\n+\t(emit_call_1): Emit REG_SETJMP note.\n+\t* cse.c (cse_end_of_basic_block): Use REG_SETJMP instead\n+\tof INSN_SETJMP\n+\t* cselib.c (cselib_process_insn): Likewise.\n+\t* flow.c (propagate_block): Likewise.\n+\t* loop.c (find_and_verify_loops): Likewise.\n+\t* reload.c (find_equiv_regs): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t* resource.c (mark_referenced_resources,\n+\tmark_set_resources): Likewise.\n+\t* sched-deps (sched_analyze_insn, sched_analyze): Likewise.\n+\t* final.c (final_scan_insn): Remove NOTE_INSN_SETJMP.\n+\t* haifa-sched.c (unlink_other_notes): Likewise.\n+\t(reemit_notes): Likewise.\n+\t* sched-ebb.c (sched_ebb): Likewise.\n+\t* sched-rgc.c (sched_region): Likewise.\n+\t* rtl.c (note_insn_name): Likewise.\n+\t(reg_note_name): Add REG_SETJMP\n+\t* rtl.h (reg_note): Add REG_SETJMP.\n+\t(insn_note): Remove NOTE_INSN_SETJMP.\n+\n+\t* profile.c (branch_prob): Add fake edges for setjmp.\n+\n 2001-08-07  Daniel Jacobowitz  <drow@mvista.com>\n \n         * config.gcc: Quote target_cpu_default2 correctly for"}, {"sha": "8206b9cbbb8cc8bd72024887b4ef69d09e562f89", "filename": "gcc/calls.c", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -610,6 +610,10 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n     REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_NORETURN, const0_rtx,\n \t\t\t\t\t       REG_NOTES (call_insn));\n \n+  if (ecf_flags & ECF_RETURNS_TWICE)\n+    REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_SETJMP, const0_rtx,\n+\t\t\t\t\t       REG_NOTES (call_insn));\n+\n   SIBLING_CALL_P (call_insn) = ((ecf_flags & ECF_SIBCALL) != 0);\n \n   /* Restore this now, so that we do defer pops for this call's args\n@@ -3152,9 +3156,9 @@ expand_call (exp, target, ignore)\n \t if nonvolatile values are live.  For functions that cannot return,\n \t inform flow that control does not fall through.  */\n \n-      if ((flags & (ECF_RETURNS_TWICE | ECF_NORETURN | ECF_LONGJMP)) || pass == 0)\n+      if ((flags & (ECF_NORETURN | ECF_LONGJMP)) || pass == 0)\n \t{\n-\t  /* The barrier or NOTE_INSN_SETJMP note must be emitted\n+\t  /* The barrier must be emitted\n \t     immediately after the CALL_INSN.  Some ports emit more\n \t     than just a CALL_INSN above, so we must search for it here.  */\n \n@@ -3167,13 +3171,7 @@ expand_call (exp, target, ignore)\n \t\tabort ();\n \t    }\n \n-\t  if (flags & ECF_RETURNS_TWICE)\n-\t    {\n-\t      emit_note_after (NOTE_INSN_SETJMP, last);\n-\t      current_function_calls_setjmp = 1;\n-\t    }\n-\t  else\n-\t    emit_barrier_after (last);\n+\t  emit_barrier_after (last);\n \t}\n \n       if (flags & ECF_LONGJMP)\n@@ -4086,9 +4084,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      if nonvolatile values are live.  For functions that cannot return,\n      inform flow that control does not fall through.  */\n \n-  if (flags & (ECF_RETURNS_TWICE | ECF_NORETURN | ECF_LONGJMP))\n+  if (flags & (ECF_NORETURN | ECF_LONGJMP))\n     {\n-      /* The barrier or NOTE_INSN_SETJMP note must be emitted\n+      /* The barrier note must be emitted\n \t immediately after the CALL_INSN.  Some ports emit more than\n \t just a CALL_INSN above, so we must search for it here.  */\n \n@@ -4101,13 +4099,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t    abort ();\n \t}\n \n-      if (flags & ECF_RETURNS_TWICE)\n-\t{\n-\t  emit_note_after (NOTE_INSN_SETJMP, last);\n-\t  current_function_calls_setjmp = 1;\n-\t}\n-      else\n-\temit_barrier_after (last);\n+      emit_barrier_after (last);\n     }\n \n   /* Now restore inhibit_defer_pop to its actual original value.  */"}, {"sha": "f5b1afa016ee7e95fd51577e9e4cbf37b346290e", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -6855,8 +6855,8 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n       /* Don't cse over a call to setjmp; on some machines (eg VAX)\n \t the regs restored by the longjmp come from\n \t a later time than the setjmp.  */\n-      if (GET_CODE (p) == NOTE\n-\t  && NOTE_LINE_NUMBER (p) == NOTE_INSN_SETJMP)\n+      if (PREV_INSN (p) && GET_CODE (PREV_INSN (p)) == CALL_INSN\n+\t  && find_reg_note (PREV_INSN (p), REG_SETJMP, NULL))\n \tbreak;\n \n       /* A PARALLEL can have lots of SETs in it,\n@@ -6906,7 +6906,8 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \t  for (q = PREV_INSN (JUMP_LABEL (p)); q; q = PREV_INSN (q))\n \t    if ((GET_CODE (q) != NOTE\n \t\t || NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_END\n-\t\t || NOTE_LINE_NUMBER (q) == NOTE_INSN_SETJMP)\n+\t\t || (PREV_INSN (q) && GET_CODE (PREV_INSN (q)) == CALL_INSN\n+\t\t     && find_reg_note (PREV_INSN (q), REG_SETJMP, NULL)))\n \t\t&& (GET_CODE (q) != CODE_LABEL || LABEL_NUSES (q) != 0))\n \t      break;\n "}, {"sha": "6497de0bbc7b94ff44242af741edf4aef13db81e", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -1254,8 +1254,8 @@ cselib_process_insn (insn)\n \n   /* Forget everything at a CODE_LABEL, a volatile asm, or a setjmp.  */\n   if (GET_CODE (insn) == CODE_LABEL\n-      || (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+      || (GET_CODE (insn) == CALL\n+\t  && find_reg_note (insn, REG_SETJMP, NULL))\n       || (GET_CODE (insn) == INSN\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n \t  && MEM_VOLATILE_P (PATTERN (insn))))"}, {"sha": "d3215adcfafa8f7ab8ec1a187b3727b03371bb6a", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -2011,7 +2011,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tcase NOTE_INSN_LOOP_CONT:\n \tcase NOTE_INSN_LOOP_VTOP:\n \tcase NOTE_INSN_FUNCTION_END:\n-\tcase NOTE_INSN_SETJMP:\n \tcase NOTE_INSN_REPEATED_LINE_NUMBER:\n \tcase NOTE_INSN_RANGE_BEG:\n \tcase NOTE_INSN_RANGE_END:"}, {"sha": "b219ef612d9ac6e75c9d7ad64c97cc76531bf92a", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -5706,8 +5706,8 @@ propagate_block (bb, live, local_set, cond_local_set, flags)\n       /* If this is a call to `setjmp' et al, warn if any\n \t non-volatile datum is live.  */\n       if ((flags & PROP_REG_INFO)\n-\t  && GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+\t  && GET_CODE (insn) == CALL\n+\t  && find_reg_note (insn, REG_SETJMP, NULL))\n \tIOR_REG_SET (regs_live_at_setjmp, pbi->reg_live);\n \n       prev = propagate_one_insn (pbi, insn);"}, {"sha": "46993fbb96eddfe6abf39740226b94dcbbc867c2", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -1071,8 +1071,7 @@ unlink_other_notes (insn, tail)\n \tPREV_INSN (next) = prev;\n \n       /* See sched_analyze to see how these are handled.  */\n-      if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP\n-\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n+      if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_RANGE_BEG\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_RANGE_END\n@@ -1537,7 +1536,7 @@ move_insn1 (insn, last)\n   return insn;\n }\n \n-/* Search INSN for REG_SAVE_NOTE note pairs for NOTE_INSN_SETJMP,\n+/* Search INSN for REG_SAVE_NOTE note pairs for\n    NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into\n    NOTEs.  The REG_SAVE_NOTE note following first one is contains the\n    saved value for NOTE_BLOCK_NUMBER which is useful for\n@@ -1558,15 +1557,8 @@ reemit_notes (insn, last)\n \t{\n \t  enum insn_note note_type = INTVAL (XEXP (note, 0));\n \n-\t  if (note_type == NOTE_INSN_SETJMP)\n-\t    {\n-\t      retval = emit_note_after (NOTE_INSN_SETJMP, insn);\n-\t      CONST_OR_PURE_CALL_P (retval) = CONST_OR_PURE_CALL_P (note);\n-\t      remove_note (insn, note);\n-\t      note = XEXP (note, 1);\n-\t    }\n-\t  else if (note_type == NOTE_INSN_RANGE_BEG\n-                   || note_type == NOTE_INSN_RANGE_END)\n+\t  if (note_type == NOTE_INSN_RANGE_BEG\n+              || note_type == NOTE_INSN_RANGE_END)\n \t    {\n \t      last = emit_note_before (note_type, last);\n \t      remove_note (insn, note);"}, {"sha": "46225bbbefc5b6316587babd407ed9ad4f9fe866", "filename": "gcc/loop.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -2512,19 +2512,6 @@ find_and_verify_loops (f, loops)\n \t    current_loop = next_loop;\n \t    break;\n \n-\t  case NOTE_INSN_SETJMP:\n-\t    /* In this case, we must invalidate our current loop and any\n-\t       enclosing loop.  */\n-\t    for (loop = current_loop; loop; loop = loop->outer)\n-\t      {\n-\t\tloop->invalid = 1;\n-\t\tif (loop_dump_stream)\n-\t\t  fprintf (loop_dump_stream,\n-\t\t\t   \"\\nLoop at %d ignored due to setjmp.\\n\",\n-\t\t\t   INSN_UID (loop->start));\n-\t      }\n-\t    break;\n-\n \t  case NOTE_INSN_LOOP_CONT:\n \t    current_loop->cont = insn;\n \t    break;\n@@ -2545,6 +2532,21 @@ find_and_verify_loops (f, loops)\n \t    break;\n \t  }\n \n+      if (GET_CODE (insn) == CALL\n+\t  && find_reg_note (insn, REG_SETJMP, NULL))\n+\t{\n+\t  /* In this case, we must invalidate our current loop and any\n+\t     enclosing loop.  */\n+\t  for (loop = current_loop; loop; loop = loop->outer)\n+\t    {\n+\t      loop->invalid = 1;\n+\t      if (loop_dump_stream)\n+\t\tfprintf (loop_dump_stream,\n+\t\t\t \"\\nLoop at %d ignored due to setjmp.\\n\",\n+\t\t\t INSN_UID (loop->start));\n+\t    }\n+\t}\n+\n       /* Note that this will mark the NOTE_INSN_LOOP_END note as being in the\n \t enclosing loop, but this doesn't matter.  */\n       uid_loop[INSN_UID (insn)] = current_loop;"}, {"sha": "983df4330a72ee4e253796c79ad77b6b47b3322e", "filename": "gcc/profile.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -544,8 +544,37 @@ branch_prob ()\n       int need_exit_edge = 0, need_entry_edge = 0;\n       int have_exit_edge = 0, have_entry_edge = 0;\n       basic_block bb = BASIC_BLOCK (i);\n+      rtx insn;\n       edge e;\n \n+      /* Add fake edges from entry block to the call insns that may return\n+\t twice.  The CFG is not quite correct then, as call insn plays more\n+\t role of CODE_LABEL, but for our purposes, everything should be OK,\n+\t as we never insert code to the beggining of basic block.  */\n+      for (insn = bb->head; insn != NEXT_INSN (bb->end);\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == CALL_INSN\n+\t      && find_reg_note (insn, REG_SETJMP, NULL))\n+\t    {\n+\t      if (GET_CODE (bb->head) == CODE_LABEL\n+\t\t  || insn != NEXT_INSN (bb->head))\n+\t\t{\n+\t\t  e = split_block (bb, PREV_INSN (insn));\n+\t\t  make_edge (NULL, ENTRY_BLOCK_PTR, e->dest, EDGE_FAKE);\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* We should not get abort here, as call to setjmp should not\n+\t\t     be the very first instruction of function.  */\n+\t\t  if (!i)\n+\t\t    abort ();\n+\t\t  make_edge (NULL, ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n+\t\t}\n+\t    }\n+\t}\n+\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))"}, {"sha": "a569ab8c4a3f1ff4bae7456e387f55160106360b", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -6461,13 +6461,11 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t    for (i = 0; i < valuenregs; ++i)\n \t      if (call_used_regs[valueno + i])\n \t\treturn 0;\n-\t}\n-\n #ifdef NON_SAVING_SETJMP\n-      if (NON_SAVING_SETJMP && GET_CODE (p) == NOTE\n-\t  && NOTE_LINE_NUMBER (p) == NOTE_INSN_SETJMP)\n-\treturn 0;\n+\t  if (NON_SAVING_SETJMP && find_reg_note (p, REG_SETJMP, NULL))\n+\t    return 0;\n #endif\n+\t}\n \n       if (INSN_P (p))\n \t{"}, {"sha": "d405b10ca514077602248c2af8ad807d8b26de78", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -754,16 +754,15 @@ reload (first, global)\n      Also find all paradoxical subregs and find largest such for each pseudo.\n      On machines with small register classes, record hard registers that\n      are used for user variables.  These can never be used for spills.\n-     Also look for a \"constant\" NOTE_INSN_SETJMP.  This means that all\n+     Also look for a \"constant\" REG_SETJMP.  This means that all\n      caller-saved registers must be marked live.  */\n \n   num_eliminable_invariants = 0;\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       rtx set = single_set (insn);\n \n-      if (GET_CODE (insn) == NOTE && CONST_OR_PURE_CALL_P (insn)\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+      if (GET_CODE (insn) == CALL && find_reg_note (insn, REG_SETJMP, NULL))\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t  if (! call_used_regs[i])\n \t    regs_ever_live[i] = 1;"}, {"sha": "7a16e8bc442ff313eb7fc5fd5865c6400764850b", "filename": "gcc/resource.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -326,13 +326,11 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \t  rtx insn = PREV_INSN (x);\n \t  rtx sequence = 0;\n \t  int seq_size = 0;\n-\t  rtx next = NEXT_INSN (x);\n \t  int i;\n \n \t  /* If we are part of a delay slot sequence, point at the SEQUENCE.  */\n \t  if (NEXT_INSN (insn) != x)\n \t    {\n-\t      next = NEXT_INSN (NEXT_INSN (insn));\n \t      sequence = PATTERN (NEXT_INSN (insn));\n \t      seq_size = XVECLEN (sequence, 0);\n \t      if (GET_CODE (sequence) != SEQUENCE)\n@@ -353,16 +351,15 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \t    if (global_regs[i])\n \t      SET_HARD_REG_BIT (res->regs, i);\n \n-\t  /* Check for a NOTE_INSN_SETJMP.  If it exists, then we must\n+\t  /* Check for a REG_SETJMP.  If it exists, then we must\n \t     assume that this call can need any register.\n \n \t     This is done to be more conservative about how we handle setjmp.\n \t     We assume that they both use and set all registers.  Using all\n \t     registers ensures that a register will not be considered dead\n \t     just because it crosses a setjmp call.  A register should be\n \t     considered dead only if the setjmp call returns non-zero.  */\n-\t  if (next && GET_CODE (next) == NOTE\n-\t      && NOTE_LINE_NUMBER (next) == NOTE_INSN_SETJMP)\n+\t  if (find_reg_note (x, REG_SETJMP, NULL))\n \t    SET_HARD_REG_SET (res->regs);\n \n \t  {\n@@ -667,30 +664,22 @@ mark_set_resources (x, res, in_dest, mark_type)\n \n       if (mark_type == MARK_SRC_DEST_CALL)\n \t{\n-\t  rtx next = NEXT_INSN (x);\n-\t  rtx prev = PREV_INSN (x);\n \t  rtx link;\n \n \t  res->cc = res->memory = 1;\n \t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n \t    if (call_used_regs[r] || global_regs[r])\n \t      SET_HARD_REG_BIT (res->regs, r);\n \n-\t  /* If X is part of a delay slot sequence, then NEXT should be\n-\t     the first insn after the sequence.  */\n-\t  if (NEXT_INSN (prev) != x)\n-\t    next = NEXT_INSN (NEXT_INSN (prev));\n-\n \t  for (link = CALL_INSN_FUNCTION_USAGE (x);\n \t       link; link = XEXP (link, 1))\n \t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n \t      mark_set_resources (SET_DEST (XEXP (link, 0)), res, 1,\n \t\t\t\t  MARK_SRC_DEST);\n \n-\t  /* Check for a NOTE_INSN_SETJMP.  If it exists, then we must\n+\t  /* Check for a REG_SETJMP.  If it exists, then we must\n \t     assume that this call can clobber any register.  */\n-\t  if (next && GET_CODE (next) == NOTE\n-\t      && NOTE_LINE_NUMBER (next) == NOTE_INSN_SETJMP)\n+\t  if (find_reg_note (x, REG_SETJMP, NULL))\n \t    SET_HARD_REG_SET (res->regs);\n \t}\n "}, {"sha": "74b58d1f7aba19c4bcdcae79802b3f7c6a370ce3", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -263,7 +263,7 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n   \"NOTE_INSN_BLOCK_BEG\", \"NOTE_INSN_BLOCK_END\",\n   \"NOTE_INSN_LOOP_BEG\", \"NOTE_INSN_LOOP_END\",\n   \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\",\n-  \"NOTE_INSN_FUNCTION_END\", \"NOTE_INSN_SETJMP\",\n+  \"NOTE_INSN_FUNCTION_END\",\n   \"NOTE_INSN_PROLOGUE_END\", \"NOTE_INSN_EPILOGUE_BEG\",\n   \"NOTE_INSN_DELETED_LABEL\", \"NOTE_INSN_FUNCTION_BEG\",\n   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n@@ -281,7 +281,7 @@ const char * const reg_note_name[] =\n   \"REG_EXEC_COUNT\", \"REG_NOALIAS\", \"REG_SAVE_AREA\", \"REG_BR_PRED\",\n   \"REG_FRAME_RELATED_EXPR\", \"REG_EH_CONTEXT\", \"REG_EH_REGION\",\n   \"REG_EH_RETHROW\", \"REG_SAVE_NOTE\", \"REG_MAYBE_DEAD\", \"REG_NORETURN\",\n-  \"REG_NON_LOCAL_GOTO\"\n+  \"REG_NON_LOCAL_GOTO\", \"REG_SETJMP\"\n };\n \n \f"}, {"sha": "92c01336ad249d4bf816d958f02e6f06df41c5b0", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -562,7 +562,11 @@ enum reg_note\n \n   /* Indicates that an indirect jump is a non-local goto instead of a \n      computed goto.  */\n-  REG_NON_LOCAL_GOTO\n+  REG_NON_LOCAL_GOTO,\n+\n+  /* This kind of note is generated at each to `setjmp',\n+     and similar functions that can return twice.  */\n+  REG_SETJMP\n };\n \n /* The base value for branch probability notes.  */\n@@ -660,10 +664,6 @@ enum insn_note\n      off the end of the function body without a return statement.  */\n   NOTE_INSN_FUNCTION_END,\n \n-  /* This kind of note is generated just after each call to `setjmp',\n-     and similar functions that can return twice.  */\n-  NOTE_INSN_SETJMP,\n-\n   /* This marks the point immediately after the last prologue insn.  */\n   NOTE_INSN_PROLOGUE_END,\n "}, {"sha": "0893ee1d544d70b3ff6c3630a0aeeb86684f2df5", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -1017,13 +1017,17 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \n   /* Mark registers CLOBBERED or used by called function.  */\n   if (GET_CODE (insn) == CALL_INSN)\n-    for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-      {\n-\tif (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t  sched_analyze_1 (deps, XEXP (link, 0), insn);\n-\telse\n-\t  sched_analyze_2 (deps, XEXP (link, 0), insn);\n-      }\n+    {\n+      for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+\t{\n+\t  if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t    sched_analyze_1 (deps, XEXP (link, 0), insn);\n+\t  else\n+\t    sched_analyze_2 (deps, XEXP (link, 0), insn);\n+\t}\n+      if (find_reg_note (insn, REG_SETJMP, NULL))\n+\tschedule_barrier_found = 1;\n+    }\n \n   if (GET_CODE (insn) == JUMP_INSN)\n     {\n@@ -1094,8 +1098,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t  if (INTVAL (XEXP (link, 0)) == NOTE_INSN_LOOP_BEG\n \t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_LOOP_END\n \t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_EH_REGION_BEG\n-\t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_EH_REGION_END\n-\t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_SETJMP)\n+\t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_EH_REGION_END)\n \t    schedule_barrier_found = 1;\n \n \t  link = XEXP (link, 1);\n@@ -1277,15 +1280,14 @@ sched_analyze (deps, head, tail)\n \t     past a void call (i.e. it does not explicitly set the hard\n \t     return reg).  */\n \n-\t  /* If this call is followed by a NOTE_INSN_SETJMP, then assume that\n+\t  /* If this call has REG_SETJMP, then assume that\n \t     all registers, not just hard registers, may be clobbered by this\n \t     call.  */\n \n \t  /* Insn, being a CALL_INSN, magically depends on\n \t     `last_function_call' already.  */\n \n-\t  if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == NOTE\n-\t      && NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_SETJMP)\n+\t  if (find_reg_note (insn, REG_SETJMP, NULL))\n \t    {\n \t      for (i = 0; i < deps->max_reg; i++)\n \t\t{\n@@ -1301,16 +1303,6 @@ sched_analyze (deps, head, tail)\n \t\t  free_INSN_LIST_list (&reg_last->uses);\n \t\t}\n \t      reg_pending_sets_all = 1;\n-\n-\t      /* Add a pair of REG_SAVE_NOTEs which we will later\n-\t\t convert back into a NOTE_INSN_SETJMP note.  See\n-\t\t reemit_notes for why we use a pair of NOTEs.  */\n-\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_SAVE_NOTE,\n-\t\t\t\t\t\t  GEN_INT (0),\n-\t\t\t\t\t\t  REG_NOTES (insn));\n-\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_SAVE_NOTE,\n-\t\t\t\t\t\t  GEN_INT (NOTE_INSN_SETJMP),\n-\t\t\t\t\t\t  REG_NOTES (insn));\n \t    }\n \t  else\n \t    {\n@@ -1375,9 +1367,7 @@ sched_analyze (deps, head, tail)\n \t       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END\n-\t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n-\t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n \t{\n \t  rtx rtx_region;\n "}, {"sha": "2ea902904f090561489b84eb7c22ecb8ab5ba6cc", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -236,25 +236,17 @@ schedule_ebb (head, tail)\n      or after the last real insn of the block.  So if the first insn\n      has a REG_SAVE_NOTE which would otherwise be emitted before the\n      insn, it is redundant with the note before the start of the\n-     block, and so we have to take it out.\n-\n-     FIXME: Probably the same thing should be done with REG_SAVE_NOTEs\n-     referencing NOTE_INSN_SETJMP at the end of the block.  */\n+     block, and so we have to take it out.  */\n   if (INSN_P (head))\n     {\n       rtx note;\n \n       for (note = REG_NOTES (head); note; note = XEXP (note, 1))\n \tif (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n \t  {\n-\t    if (INTVAL (XEXP (note, 0)) != NOTE_INSN_SETJMP)\n-\t      {\n-\t\tremove_note (head, note);\n-\t\tnote = XEXP (note, 1);\n-\t\tremove_note (head, note);\n-\t      }\n-\t    else\n-\t      note = XEXP (note, 1);\n+\t    remove_note (head, note);\n+\t    note = XEXP (note, 1);\n+\t    remove_note (head, note);\n \t  }\n     }\n "}, {"sha": "93f7b44bead9dc9352e21fd490bad5536e39070c", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a98eb7c116ea107e1c2167da244782cc4b988/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=570a98eb7c116ea107e1c2167da244782cc4b988", "patch": "@@ -2809,25 +2809,17 @@ schedule_region (rgn)\n  \t or after the last real insn of the block.  So if the first insn\n \t has a REG_SAVE_NOTE which would otherwise be emitted before the\n \t insn, it is redundant with the note before the start of the\n-\t block, and so we have to take it out.\n-\n-\t FIXME: Probably the same thing should be done with REG_SAVE_NOTEs\n-\t referencing NOTE_INSN_SETJMP at the end of the block.  */\n+\t block, and so we have to take it out.  */\n       if (INSN_P (head))\n \t{\n \t  rtx note;\n \n \t  for (note = REG_NOTES (head); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n \t      {\n-\t\tif (INTVAL (XEXP (note, 0)) != NOTE_INSN_SETJMP)\n-\t\t  {\n-\t\t    remove_note (head, note);\n-\t\t    note = XEXP (note, 1);\n-\t\t    remove_note (head, note);\n-\t\t  }\n-\t\telse\n-\t\t  note = XEXP (note, 1);\n+\t\tremove_note (head, note);\n+\t\tnote = XEXP (note, 1);\n+\t\tremove_note (head, note);\n \t      }\n \t}\n "}]}