{"sha": "5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRmYjRkMGYzMzM5NTk1ODgxZmJhODU3YWI1YTRiNTdjNjgxYThlMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-05T01:57:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-05T01:57:42Z"}, "message": "compiler: update iota handling, fix using iota in array length\n    \n    CL 71750 changed the definition of how iota works.  This patch updates\n    gccgo for the new definition.\n    \n    We've been mishandling iota appearing in a type that appears in a\n    const expression, as in `c = len([iota]int{})`.  Correct that by copying\n    type expressions when we copy an expression.  For simplicity only copy\n    when it can change the size of a type, as that is the only case where\n    iota in a type can affect the value of a constant (I think).  This is\n    still a bunch of changes, but almost all boilerplate.\n    \n    Fixes golang/go#22341\n    \n    Reviewed-on: https://go-review.googlesource.com/91475\n\nFrom-SVN: r257379", "tree": {"sha": "336c1452068533453093114132ffd040f836b06a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/336c1452068533453093114132ffd040f836b06a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/comments", "author": null, "committer": null, "parents": [{"sha": "33cdac3baa9e0c8da598d5124ac9196be30a3ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33cdac3baa9e0c8da598d5124ac9196be30a3ccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33cdac3baa9e0c8da598d5124ac9196be30a3ccb"}], "stats": {"total": 347, "additions": 227, "deletions": 120}, "files": [{"sha": "3588a8a7a6ac69c4e741cfc4081738de6aee9245", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "patch": "@@ -1,4 +1,4 @@\n-d9f33a479f8012f7495d197e4b7417cba4d477fa\n+36594b69b94326014c331fe50a5a345ef4f8de16\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "8555c052980812559fc21c62eb36150ce555f6a0", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 133, "deletions": 8, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "patch": "@@ -1928,10 +1928,16 @@ class Integer_expression : public Expression\n   do_copy()\n   {\n     if (this->is_character_constant_)\n-      return Expression::make_character(&this->val_, this->type_,\n+      return Expression::make_character(&this->val_,\n+\t\t\t\t\t(this->type_ == NULL\n+\t\t\t\t\t ? NULL\n+\t\t\t\t\t : this->type_->copy_expressions()),\n \t\t\t\t\tthis->location());\n     else\n-      return Expression::make_integer_z(&this->val_, this->type_,\n+      return Expression::make_integer_z(&this->val_,\n+\t\t\t\t\t(this->type_ == NULL\n+\t\t\t\t\t ? NULL\n+\t\t\t\t\t : this->type_->copy_expressions()),\n \t\t\t\t\tthis->location());\n   }\n \n@@ -2323,7 +2329,10 @@ class Float_expression : public Expression\n \n   Expression*\n   do_copy()\n-  { return Expression::make_float(&this->val_, this->type_,\n+  { return Expression::make_float(&this->val_,\n+\t\t\t\t  (this->type_ == NULL\n+\t\t\t\t   ? NULL\n+\t\t\t\t   : this->type_->copy_expressions()),\n \t\t\t\t  this->location()); }\n \n   Bexpression*\n@@ -2514,7 +2523,10 @@ class Complex_expression : public Expression\n   Expression*\n   do_copy()\n   {\n-    return Expression::make_complex(&this->val_, this->type_,\n+    return Expression::make_complex(&this->val_,\n+\t\t\t\t    (this->type_ == NULL\n+\t\t\t\t     ? NULL\n+\t\t\t\t     : this->type_->copy_expressions()),\n \t\t\t\t    this->location());\n   }\n \n@@ -3420,6 +3432,16 @@ Type_conversion_expression::do_check_types(Gogo*)\n   this->set_is_error();\n }\n \n+// Copy.\n+\n+Expression*\n+Type_conversion_expression::do_copy()\n+{\n+  return new Type_conversion_expression(this->type_->copy_expressions(),\n+\t\t\t\t\tthis->expr_->copy(),\n+\t\t\t\t\tthis->location());\n+}\n+\n // Get the backend representation for a type conversion.\n \n Bexpression*\n@@ -3621,6 +3643,16 @@ Unsafe_type_conversion_expression::do_is_static_initializer() const\n   return false;\n }\n \n+// Copy.\n+\n+Expression*\n+Unsafe_type_conversion_expression::do_copy()\n+{\n+  return new Unsafe_type_conversion_expression(this->type_->copy_expressions(),\n+\t\t\t\t\t       this->expr_->copy(),\n+\t\t\t\t\t       this->location());\n+}\n+\n // Convert to backend representation.\n \n Bexpression*\n@@ -12401,7 +12433,8 @@ Expression*\n Allocation_expression::do_copy()\n {\n   Allocation_expression* alloc =\n-    new Allocation_expression(this->type_, this->location());\n+    new Allocation_expression(this->type_->copy_expressions(),\n+\t\t\t      this->location());\n   if (this->allocate_on_stack_)\n     alloc->set_allocate_on_stack();\n   return alloc;\n@@ -12641,6 +12674,22 @@ Struct_construction_expression::do_check_types(Gogo*)\n   go_assert(pv == this->vals()->end());\n }\n \n+// Copy.\n+\n+Expression*\n+Struct_construction_expression::do_copy()\n+{\n+  Struct_construction_expression* ret =\n+    new Struct_construction_expression(this->type_->copy_expressions(),\n+\t\t\t\t       (this->vals() == NULL\n+\t\t\t\t\t? NULL\n+\t\t\t\t\t: this->vals()->copy()),\n+\t\t\t\t       this->location());\n+  if (this->traverse_order() != NULL)\n+    ret->set_traverse_order(this->traverse_order());\n+  return ret;\n+}\n+\n // Flatten a struct construction expression.  Store the values into\n // temporaries in case they need interface conversion.\n \n@@ -13032,6 +13081,20 @@ Fixed_array_construction_expression::Fixed_array_construction_expression(\n \t\t\t\t  type, indexes, vals, location)\n { go_assert(type->array_type() != NULL && !type->is_slice_type()); }\n \n+\n+// Copy.\n+\n+Expression*\n+Fixed_array_construction_expression::do_copy()\n+{\n+  Type* t = this->type()->copy_expressions();\n+  return new Fixed_array_construction_expression(t, this->indexes(),\n+\t\t\t\t\t\t (this->vals() == NULL\n+\t\t\t\t\t\t  ? NULL\n+\t\t\t\t\t\t  : this->vals()->copy()),\n+\t\t\t\t\t\t this->location());\n+}\n+\n // Return the backend representation for constructing a fixed array.\n \n Bexpression*\n@@ -13166,6 +13229,19 @@ dump_slice_storage_expression(Ast_dump_context* ast_dump_context) const\n   ast_dump_context->dump_expression(this->slice_storage_);\n }\n \n+// Copy.\n+\n+Expression*\n+Slice_construction_expression::do_copy()\n+{\n+  return new Slice_construction_expression(this->type()->copy_expressions(),\n+\t\t\t\t\t   this->indexes(),\n+\t\t\t\t\t   (this->vals() == NULL\n+\t\t\t\t\t    ? NULL\n+\t\t\t\t\t    : this->vals()->copy()),\n+\t\t\t\t\t   this->location());\n+}\n+\n // Return the backend representation for constructing a slice.\n \n Bexpression*\n@@ -13379,6 +13455,18 @@ Map_construction_expression::do_check_types(Gogo*)\n     }\n }\n \n+// Copy.\n+\n+Expression*\n+Map_construction_expression::do_copy()\n+{\n+  return new Map_construction_expression(this->type_->copy_expressions(),\n+\t\t\t\t\t (this->vals_ == NULL\n+\t\t\t\t\t  ? NULL\n+\t\t\t\t\t  : this->vals_->copy()),\n+\t\t\t\t\t this->location());\n+}\n+\n // Return the backend representation for constructing a map.\n \n Bexpression*\n@@ -14058,6 +14146,23 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n   return new Map_construction_expression(type, this->vals_, location);\n }\n \n+// Copy.\n+\n+Expression*\n+Composite_literal_expression::do_copy()\n+{\n+  Composite_literal_expression* ret =\n+    new Composite_literal_expression(this->type_->copy_expressions(),\n+\t\t\t\t     this->depth_, this->has_keys_,\n+\t\t\t\t     (this->vals_ == NULL\n+\t\t\t\t      ? NULL\n+\t\t\t\t      : this->vals_->copy()),\n+\t\t\t\t     this->all_are_names_,\n+\t\t\t\t     this->location());\n+  ret->key_path_ = this->key_path_;\n+  return ret;\n+}\n+\n // Dump ast representation for a composite literal expression.\n \n void\n@@ -14234,6 +14339,16 @@ Type_guard_expression::do_check_types(Gogo*)\n     }\n }\n \n+// Copy.\n+\n+Expression*\n+Type_guard_expression::do_copy()\n+{\n+  return new Type_guard_expression(this->expr_->copy(),\n+\t\t\t\t   this->type_->copy_expressions(),\n+\t\t\t\t   this->location());\n+}\n+\n // Return the backend representation for a type guard expression.\n \n Bexpression*\n@@ -14961,7 +15076,8 @@ class Slice_value_expression : public Expression\n   Expression*\n   do_copy()\n   {\n-    return new Slice_value_expression(this->type_, this->valptr_->copy(),\n+    return new Slice_value_expression(this->type_->copy_expressions(),\n+\t\t\t\t      this->valptr_->copy(),\n                                       this->len_->copy(), this->cap_->copy(),\n                                       this->location());\n   }\n@@ -15222,7 +15338,7 @@ class Interface_value_expression : public Expression\n   Expression*\n   do_copy()\n   {\n-    return new Interface_value_expression(this->type_,\n+    return new Interface_value_expression(this->type_->copy_expressions(),\n                                           this->first_field_->copy(),\n                                           this->obj_->copy(), this->location());\n   }\n@@ -15317,7 +15433,9 @@ class Interface_mtable_expression : public Expression\n   Expression*\n   do_copy()\n   {\n-    return new Interface_mtable_expression(this->itype_, this->type_,\n+    Interface_type* itype = this->itype_->copy_expressions()->interface_type();\n+    return new Interface_mtable_expression(itype,\n+\t\t\t\t\t   this->type_->copy_expressions(),\n                                            this->is_pointer_, this->location());\n   }\n \n@@ -15805,6 +15923,13 @@ Backend_expression::do_traverse(Traverse*)\n   return TRAVERSE_CONTINUE;\n }\n \n+Expression*\n+Backend_expression::do_copy()\n+{\n+  return new Backend_expression(this->bexpr_, this->type_->copy_expressions(),\n+\t\t\t\tthis->location());\n+}\n+\n void\n Backend_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n {"}, {"sha": "d16a284b6b04c766430f7b0c6ee3c4ad11b0480c", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 9, "deletions": 70, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "patch": "@@ -1664,11 +1664,7 @@ class Type_conversion_expression : public Expression\n   do_check_types(Gogo*);\n \n   Expression*\n-  do_copy()\n-  {\n-    return new Type_conversion_expression(this->type_, this->expr_->copy(),\n-\t\t\t\t\t  this->location());\n-  }\n+  do_copy();\n \n   Bexpression*\n   do_get_backend(Translate_context* context);\n@@ -1720,12 +1716,7 @@ class Unsafe_type_conversion_expression : public Expression\n   { this->expr_->determine_type_no_context(); }\n \n   Expression*\n-  do_copy()\n-  {\n-    return new Unsafe_type_conversion_expression(this->type_,\n-\t\t\t\t\t\t this->expr_->copy(),\n-\t\t\t\t\t\t this->location());\n-  }\n+  do_copy();\n \n   Bexpression*\n   do_get_backend(Translate_context*);\n@@ -3430,19 +3421,7 @@ class Composite_literal_expression : public Parser_expression\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   Expression*\n-  do_copy()\n-  {\n-    Composite_literal_expression *ret =\n-      new Composite_literal_expression(this->type_, this->depth_,\n-\t\t\t\t       this->has_keys_,\n-\t\t\t\t       (this->vals_ == NULL\n-\t\t\t\t\t? NULL\n-\t\t\t\t\t: this->vals_->copy()),\n-\t\t\t\t       this->all_are_names_,\n-\t\t\t\t       this->location());\n-    ret->key_path_ = this->key_path_;\n-    return ret;\n-  }\n+  do_copy();\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -3556,18 +3535,7 @@ class Struct_construction_expression : public Expression,\n   do_check_types(Gogo*);\n \n   Expression*\n-  do_copy()\n-  {\n-    Struct_construction_expression* ret =\n-      new Struct_construction_expression(this->type_,\n-\t\t\t\t\t (this->vals() == NULL\n-\t\t\t\t\t  ? NULL\n-\t\t\t\t\t  : this->vals()->copy()),\n-\t\t\t\t\t this->location());\n-    if (this->traverse_order() != NULL)\n-      ret->set_traverse_order(this->traverse_order());\n-    return ret;\n-  }\n+  do_copy();\n \n   Expression*\n   do_flatten(Gogo*, Named_object*, Statement_inserter*);\n@@ -3671,15 +3639,7 @@ class Fixed_array_construction_expression :\n \n  protected:\n   Expression*\n-  do_copy()\n-  {\n-    return new Fixed_array_construction_expression(this->type(),\n-\t\t\t\t\t\t   this->indexes(),\n-\t\t\t\t\t\t   (this->vals() == NULL\n-\t\t\t\t\t\t    ? NULL\n-\t\t\t\t\t\t    : this->vals()->copy()),\n-\t\t\t\t\t\t   this->location());\n-  }\n+  do_copy();\n \n   Bexpression*\n   do_get_backend(Translate_context*);\n@@ -3712,14 +3672,7 @@ class Slice_construction_expression : public Array_construction_expression\n   do_traverse(Traverse* traverse);\n \n   Expression*\n-  do_copy()\n-  {\n-    return new Slice_construction_expression(this->type(), this->indexes(),\n-\t\t\t\t\t     (this->vals() == NULL\n-\t\t\t\t\t      ? NULL\n-\t\t\t\t\t      : this->vals()->copy()),\n-\t\t\t\t\t     this->location());\n-  }\n+  do_copy();\n \n   Bexpression*\n   do_get_backend(Translate_context*);\n@@ -3778,14 +3731,7 @@ class Map_construction_expression : public Expression\n   do_check_types(Gogo*);\n \n   Expression*\n-  do_copy()\n-  {\n-    return new Map_construction_expression(this->type_,\n-\t\t\t\t\t   (this->vals_ == NULL\n-\t\t\t\t\t    ? NULL\n-\t\t\t\t\t    : this->vals_->copy()),\n-\t\t\t\t\t   this->location());\n-  }\n+  do_copy();\n \n   Bexpression*\n   do_get_backend(Translate_context*);\n@@ -3846,11 +3792,7 @@ class Type_guard_expression : public Expression\n   do_check_types(Gogo*);\n \n   Expression*\n-  do_copy()\n-  {\n-    return new Type_guard_expression(this->expr_->copy(), this->type_,\n-\t\t\t\t     this->location());\n-  }\n+  do_copy();\n \n   Bexpression*\n   do_get_backend(Translate_context*);\n@@ -4102,10 +4044,7 @@ class Backend_expression : public Expression\n   { }\n \n   Expression*\n-  do_copy()\n-  {\n-    return new Backend_expression(this->bexpr_, this->type_, this->location());\n-  }\n+  do_copy();\n \n   Bexpression*\n   do_get_backend(Translate_context*)"}, {"sha": "4891e758f792fe72dd42c7a2e32a5159cd9cb5da", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "patch": "@@ -50,7 +50,6 @@ Parse::Parse(Lex* lex, Gogo* gogo)\n     gogo_(gogo),\n     break_stack_(NULL),\n     continue_stack_(NULL),\n-    iota_(0),\n     enclosing_vars_()\n {\n }\n@@ -1407,19 +1406,20 @@ Parse::const_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_CONST));\n   this->advance_token();\n-  this->reset_iota();\n \n+  int iota = 0;\n   Type* last_type = NULL;\n   Expression_list* last_expr_list = NULL;\n \n   if (!this->peek_token()->is_op(OPERATOR_LPAREN))\n-    this->const_spec(&last_type, &last_expr_list);\n+    this->const_spec(iota, &last_type, &last_expr_list);\n   else\n     {\n       this->advance_token();\n       while (!this->peek_token()->is_op(OPERATOR_RPAREN))\n \t{\n-\t  this->const_spec(&last_type, &last_expr_list);\n+\t  this->const_spec(iota, &last_type, &last_expr_list);\n+\t  ++iota;\n \t  if (this->peek_token()->is_op(OPERATOR_SEMICOLON))\n \t    this->advance_token();\n \t  else if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n@@ -1440,7 +1440,7 @@ Parse::const_decl()\n // ConstSpec = IdentifierList [ [ CompleteType ] \"=\" ExpressionList ] .\n \n void\n-Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n+Parse::const_spec(int iota, Type** last_type, Expression_list** last_expr_list)\n {\n   Typed_identifier_list til;\n   this->identifier_list(&til);\n@@ -1492,23 +1492,21 @@ Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n \tpi->set_type(type);\n \n       if (!Gogo::is_sink_name(pi->name()))\n-\tthis->gogo_->add_constant(*pi, *pe, this->iota_value());\n+\tthis->gogo_->add_constant(*pi, *pe, iota);\n       else\n \t{\n \t  static int count;\n \t  char buf[30];\n \t  snprintf(buf, sizeof buf, \".$sinkconst%d\", count);\n \t  ++count;\n \t  Typed_identifier ti(std::string(buf), type, pi->location());\n-\t  Named_object* no = this->gogo_->add_constant(ti, *pe, this->iota_value());\n+\t  Named_object* no = this->gogo_->add_constant(ti, *pe, iota);\n \t  no->const_value()->set_is_sink();\n \t}\n     }\n   if (pe != expr_list->end())\n     go_error_at(this->location(), \"too many initializers\");\n \n-  this->increment_iota();\n-\n   return;\n }\n \n@@ -5838,30 +5836,6 @@ Parse::program()\n     }\n }\n \n-// Reset the current iota value.\n-\n-void\n-Parse::reset_iota()\n-{\n-  this->iota_ = 0;\n-}\n-\n-// Return the current iota value.\n-\n-int\n-Parse::iota_value()\n-{\n-  return this->iota_;\n-}\n-\n-// Increment the current iota value.\n-\n-void\n-Parse::increment_iota()\n-{\n-  ++this->iota_;\n-}\n-\n // Skip forward to a semicolon or OP.  OP will normally be\n // OPERATOR_RPAREN or OPERATOR_RCURLY.  If we find a semicolon, move\n // past it and return.  If we find OP, it will be the next token to"}, {"sha": "f309ee05469a4cba48a5af2db0c28f9791e129a6", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "patch": "@@ -7,7 +7,6 @@\n #ifndef GO_PARSE_H\n #define GO_PARSE_H\n \n-class Set_iota_traverse;\n class Lex;\n class Gogo;\n class Named_object;\n@@ -185,7 +184,7 @@ class Parse\n   void decl(void (Parse::*)(void*, unsigned int), void*, unsigned int pragmas);\n   void list(void (Parse::*)(void*, unsigned int), void*, bool);\n   void const_decl();\n-  void const_spec(Type**, Expression_list**);\n+  void const_spec(int, Type**, Expression_list**);\n   void type_decl(unsigned int pragmas);\n   void type_spec(void*, unsigned int pragmas);\n   void var_decl();\n@@ -280,10 +279,6 @@ class Parse\n   void import_decl();\n   void import_spec(void*, unsigned int pragmas);\n \n-  void reset_iota();\n-  int iota_value();\n-  void increment_iota();\n-\n   // Skip past an error looking for a semicolon or OP.  Return true if\n   // all is well, false if we found EOF.\n   bool\n@@ -319,8 +314,6 @@ class Parse\n   Bc_stack* break_stack_;\n   // A stack of statements for which continue may be used.\n   Bc_stack* continue_stack_;\n-  // The current iota value.\n-  int iota_;\n   // References from the local function to variables defined in\n   // enclosing functions.\n   Enclosing_vars enclosing_vars_;"}, {"sha": "34edf7628352eb7a8cd1359e76fa3c612439427f", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "patch": "@@ -868,6 +868,68 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n   return false;\n }\n \n+// Copy expressions if it may change the size.\n+//\n+// The only type that has an expression is an array type.  The only\n+// types whose size can be changed by the size of an array type are an\n+// array type itself, or a struct type with an array field.\n+Type*\n+Type::copy_expressions()\n+{\n+  // This is run during parsing, so types may not be valid yet.\n+  // We only have to worry about array type literals.\n+  switch (this->classification_)\n+    {\n+    default:\n+      return this;\n+\n+    case TYPE_ARRAY:\n+      {\n+\tArray_type* at = this->array_type();\n+\tif (at->length() == NULL)\n+\t  return this;\n+\tExpression* len = at->length()->copy();\n+\tif (at->length() == len)\n+\t  return this;\n+\treturn Type::make_array_type(at->element_type(), len);\n+      }\n+\n+    case TYPE_STRUCT:\n+      {\n+\tStruct_type* st = this->struct_type();\n+\tconst Struct_field_list* sfl = st->fields();\n+\tif (sfl == NULL)\n+\t  return this;\n+\tbool changed = false;\n+\tStruct_field_list *nsfl = new Struct_field_list();\n+\tfor (Struct_field_list::const_iterator pf = sfl->begin();\n+\t     pf != sfl->end();\n+\t     ++pf)\n+\t  {\n+\t    Type* ft = pf->type()->copy_expressions();\n+\t    Struct_field nf(Typed_identifier((pf->is_anonymous()\n+\t\t\t\t\t      ? \"\"\n+\t\t\t\t\t      : pf->field_name()),\n+\t\t\t\t\t     ft,\n+\t\t\t\t\t     pf->location()));\n+\t    if (pf->has_tag())\n+\t      nf.set_tag(pf->tag());\n+\t    nsfl->push_back(nf);\n+\t    if (ft != pf->type())\n+\t      changed = true;\n+\t  }\n+\tif (!changed)\n+\t  {\n+\t    delete(nsfl);\n+\t    return this;\n+\t  }\n+\treturn Type::make_struct_type(nsfl, st->location());\n+      }\n+    }\n+\n+  go_unreachable();\n+}\n+\n // Return a hash code for the type to be used for method lookup.\n \n unsigned int"}, {"sha": "648773131ca6f43da3a6a466f763fde05bfd17cb", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfb4d0f3339595881fba857ab5a4b57c681a8e3/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=5dfb4d0f3339595881fba857ab5a4b57c681a8e3", "patch": "@@ -916,6 +916,15 @@ class Type\n   is_unsafe_pointer_type() const\n   { return this->points_to() != NULL && this->points_to()->is_void_type(); }\n \n+  // Return a version of this type with any expressions copied, but\n+  // only if copying the expressions will affect the size of the type.\n+  // If there are no such expressions in the type (expressions can\n+  // only occur in array types), just return the same type.  If any\n+  // expressions can not affect the size of the type, just return the\n+  // same type.\n+  Type*\n+  copy_expressions();\n+\n   // Look for field or method NAME for TYPE.  Return an expression for\n   // it, bound to EXPR.\n   static Expression*\n@@ -2444,6 +2453,11 @@ class Struct_type : public Type\n   field_count() const\n   { return this->fields_->size(); }\n \n+  // Location of struct definition.\n+  Location\n+  location() const\n+  { return this->location_; }\n+\n   // Push a new field onto the end of the struct.  This is used when\n   // building a closure variable.\n   void"}]}