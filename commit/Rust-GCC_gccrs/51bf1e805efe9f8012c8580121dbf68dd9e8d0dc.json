{"sha": "51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiZjFlODA1ZWZlOWY4MDEyYzg1ODAxMjFkYmY2OGRkOWU4ZDBkYw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-11-05T20:58:35Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-11-05T20:58:35Z"}, "message": "throw_allocator.h (__throw_value_base): Add move semantic, not throwing.\n\n2012-10-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/ext/throw_allocator.h (__throw_value_base): Add move\n\tsemantic, not throwing.\n\t(__throw_value_limit): Likewise.\n\t(__throw_value_random): Likewise.\n\t* testsuite/util/exception/safety.h: Add validation of C++11\n\tmethods emplace/emplace_front/emplace_back/emplace_hint.\n\t* testsuite/util/testsuite_container_traits.h: Signal emplace\n\tsupport on deque, forward_list, list and vector.\n\t* testsuite/23_containers/deque/requirements/exception/\n\tpropagation_consistent.cc: Remove dg-do run fail.\n\nFrom-SVN: r193184", "tree": {"sha": "c92053601141aee3cf579cb24c61bd122f4db77d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c92053601141aee3cf579cb24c61bd122f4db77d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/comments", "author": null, "committer": null, "parents": [{"sha": "b8435aa9450e6c3b222eab7f1fa875f6238c2b99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8435aa9450e6c3b222eab7f1fa875f6238c2b99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8435aa9450e6c3b222eab7f1fa875f6238c2b99"}], "stats": {"total": 314, "additions": 277, "deletions": 37}, "files": [{"sha": "cf5980750e18d29006df252b104141bef29ef87a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "patch": "@@ -1,3 +1,16 @@\n+2012-10-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/ext/throw_allocator.h (__throw_value_base): Add move\n+\tsemantic, not throwing.\n+\t(__throw_value_limit): Likewise.\n+\t(__throw_value_random): Likewise.\n+\t* testsuite/util/exception/safety.h: Add validation of C++11\n+\tmethods emplace/emplace_front/emplace_back/emplace_hint.\n+\t* testsuite/util/testsuite_container_traits.h: Signal emplace\n+\tsupport on deque, forward_list, list and vector.\n+\t* testsuite/23_containers/deque/requirements/exception/\n+\tpropagation_consistent.cc: Remove dg-do run fail.\n+\n 2012-11-05  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/55215"}, {"sha": "8942232c825c1014101a44801d7cd5f1bd1d195b", "filename": "libstdc++-v3/include/ext/throw_allocator.h", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h?ref=51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "patch": "@@ -1,7 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2005-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -467,6 +466,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       throw_value_base(const throw_value_base& __v) : _M_i(__v._M_i)\n       { throw_conditionally(); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // Shall not throw.\n+      throw_value_base(throw_value_base&&) = default;\n+#endif\n+\n       explicit throw_value_base(const std::size_t __i) : _M_i(__i)\n       { throw_conditionally(); }\n #endif\n@@ -479,6 +483,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // Shall not throw.\n+      throw_value_base&\n+      operator=(throw_value_base&&) = default;\n+#endif\n+\n       throw_value_base&\n       operator++()\n       {\n@@ -568,8 +578,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     throw_value_limit(const throw_value_limit& __other)\n     : base_type(__other._M_i) { }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    throw_value_limit(throw_value_limit&&) = default;\n+#endif\n+\n     explicit throw_value_limit(const std::size_t __i) : base_type(__i) { }\n #endif\n+\n+    throw_value_limit&\n+    operator=(const throw_value_limit& __other)\n+    {\n+      base_type::operator=(__other);\n+      return *this;\n+    }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    throw_value_limit&\n+    operator=(throw_value_limit&&) = default;\n+#endif\n   };\n \n   /// Type throwing via random condition.\n@@ -583,9 +609,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     throw_value_random(const throw_value_random& __other)\n     : base_type(__other._M_i) { }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    throw_value_random(throw_value_random&&) = default;\n+#endif\n \n     explicit throw_value_random(const std::size_t __i) : base_type(__i) { }\n #endif\n+\n+    throw_value_random&\n+    operator=(const throw_value_random& __other)\n+    {\n+      base_type::operator=(__other);\n+      return *this;\n+    }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    throw_value_random&\n+    operator=(throw_value_random&&) = default;\n+#endif\n   };\n \n "}, {"sha": "320084c926b595b66264b5a86535cbb37ba73758", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/exception/propagation_consistent.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fexception%2Fpropagation_consistent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fexception%2Fpropagation_consistent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fexception%2Fpropagation_consistent.cc?ref=51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "patch": "@@ -1,10 +1,9 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-require-cstdint \"\" }\n-// { dg-do run { xfail *-*-* } }\n \n // 2009-09-09  Benjamin Kosnik  <benjamin@redhat.com>\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the"}, {"sha": "12f41c140fabee8249db65071468a1da5151ef8e", "filename": "libstdc++-v3/testsuite/util/exception/safety.h", "status": "modified", "additions": 215, "deletions": 24, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h?ref=51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2009-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -226,17 +226,22 @@ namespace __gnu_test\n \t// compared to the control container.\n \t// NB: Should be equivalent to __test != __control, but\n \t// computed without equivalence operators\n-\tconst size_type szt = std::distance(__test.begin(), __test.end());\n-\tconst size_type szc = std::distance(__control.begin(),\n-\t\t\t\t\t    __control.end());\n-\tbool __equal_size = szt == szc;\n+\tconst size_type szt\n+\t  = std::distance(__test.begin(), __test.end());\n+\tconst size_type szc\n+\t  = std::distance(__control.begin(), __control.end());\n+\n+\tif (szt != szc)\n+\t  throw std::logic_error(\n+\t\t\"setup_base::compare containers size not equal\");\n \n \t// Should test iterator validity before and after exception.\n \tbool __equal_it = std::equal(__test.begin(), __test.end(),\n \t\t\t\t     __control.begin());\n \n-\tif (!__equal_size || !__equal_it)\n-\t  throw std::logic_error(\"setup_base::compare containers not equal\");\n+\tif (!__equal_it)\n+\t  throw std::logic_error(\n+\t\t\"setup_base::compare containers iterators not equal\");\n \n \treturn true;\n       }\n@@ -627,6 +632,96 @@ namespace __gnu_test\n \toperator()(_Tp&, _Tp&) { }\n       };\n \n+    template<typename _Tp, bool = traits<_Tp>::has_push_pop::value\n+\t\t\t\t  && traits<_Tp>::has_emplace::value>\n+      struct emplace_front\n+      {\n+\ttypedef _Tp \t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::value_type    \tvalue_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.emplace_front(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.emplace_front(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+    };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct emplace_front<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_push_pop::value\n+\t\t\t\t  && traits<_Tp>::has_emplace::value \n+\t\t\t\t  && traits<_Tp>::is_reversible::value>\n+      struct emplace_back\n+      {\n+\ttypedef _Tp \t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::value_type    \tvalue_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.emplace_back(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.push_back(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+    };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct emplace_back<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n+\n \n     // Abstract the insert function into two parts:\n     // 1, insert_base_functions == holds function pointer\n@@ -726,9 +821,8 @@ namespace __gnu_test\n \tinsert_base() : _F_insert_point(&container_type::insert_after) { }\n       };\n \n-    template<typename _Tp,\n-\t     bool = traits<_Tp>::has_insert::value,\n-\t     bool = traits<_Tp>::has_insert_after::value>\n+    template<typename _Tp, bool = traits<_Tp>::has_insert::value,\n+\t\t\t   bool = traits<_Tp>::has_insert_after::value>\n       struct insert_point;\n \n     // Specialization for most containers.\n@@ -826,11 +920,12 @@ namespace __gnu_test\n \toperator()(_Tp&, _Tp&) { }\n       };\n \n-    template<typename _Tp,\n-\t     bool = traits<_Tp>::has_emplace::value>\n+    template<typename _Tp, bool = traits<_Tp>::has_emplace::value\n+\t\t\t\t  && (traits<_Tp>::is_associative::value\n+\t\t\t\t      || traits<_Tp>::is_unordered::value)>\n       struct emplace;\n \n-    // Specialization for most containers.\n+    // Specialization for associative and unordered containers.\n     template<typename _Tp>\n       struct emplace<_Tp, true>\n       {\n@@ -875,13 +970,56 @@ namespace __gnu_test\n \toperator()(_Tp&, _Tp&) { }\n       };\n \n-    template<typename _Tp,\n-\t     bool = traits<_Tp>::has_emplace::value>\n-      struct emplace_hint;\n+    template<typename _Tp, bool = traits<_Tp>::has_emplace::value,\n+\t\t\t   bool = traits<_Tp>::is_associative::value\n+\t\t\t\t  || traits<_Tp>::is_unordered::value,\n+\t\t\t   bool = traits<_Tp>::has_insert_after::value>\n+      struct emplace_point;\n \n     // Specialization for most containers.\n     template<typename _Tp>\n-      struct emplace_hint<_Tp, true>\n+      struct emplace_point<_Tp, true, false, false>\n+      {\n+\ttypedef _Tp \t\t\t\t       \tcontainer_type;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.begin();\n+\t      std::advance(i, s);\n+\t      __test.emplace(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.begin();\n+\t      std::advance(i, s);\n+\t      __test.emplace(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+ \t}\n+      };\n+\n+    // Specialization for associative and unordered containers.\n+    template<typename _Tp>\n+      struct emplace_point<_Tp, true, true, false>\n       {\n \ttypedef _Tp \t\t\t\t       \tcontainer_type;\n \ttypedef typename container_type::value_type \tvalue_type;\n@@ -920,9 +1058,52 @@ namespace __gnu_test\n  \t}\n       };\n \n-    // Specialization, empty.\n+    // Specialization for forward_list.\n     template<typename _Tp>\n-      struct emplace_hint<_Tp, false>\n+      struct emplace_point<_Tp, true, false, true>\n+      {\n+\ttypedef _Tp \t\t\t\t       \tcontainer_type;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.before_begin();\n+\t      std::advance(i, s);\n+\t      __test.emplace_after(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.before_begin();\n+\t      std::advance(i, s);\n+\t      __test.emplace_after(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+ \t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp, bool is_associative_or_unordered,\n+\t\t\t   bool has_insert_after>\n+      struct emplace_point<_Tp, false, is_associative_or_unordered,\n+\t\t\t   has_insert_after>\n       {\n \tvoid\n \toperator()(_Tp&) { }\n@@ -1128,7 +1309,9 @@ namespace __gnu_test\n       typedef erase_range<container_type> \t       \terase_range;\n       typedef insert_point<container_type> \t       \tinsert_point;\n       typedef emplace<container_type>\t\t\templace;\n-      typedef emplace_hint<container_type>\t\templace_hint;\n+      typedef emplace_point<container_type>\t\templace_point;\n+      typedef emplace_front<container_type>\t\templace_front;\n+      typedef emplace_back<container_type>\t\templace_back;\n       typedef pop_front<container_type> \t       \tpop_front;\n       typedef pop_back<container_type> \t\t\tpop_back;\n       typedef push_front<container_type> \t       \tpush_front;\n@@ -1146,7 +1329,9 @@ namespace __gnu_test\n       erase_range\t\t_M_eraser;\n       insert_point\t\t_M_insertp;\n       emplace\t\t\t_M_emplace;\n-      emplace_hint\t\t_M_emplaceh;\n+      emplace_point\t\t_M_emplacep;\n+      emplace_front\t\t_M_emplacef;\n+      emplace_back\t\t_M_emplaceb;\n       pop_front\t\t\t_M_popf;\n       pop_back\t\t\t_M_popb;\n       push_front\t       \t_M_pushf;\n@@ -1207,7 +1392,9 @@ namespace __gnu_test\n \t_M_functions.push_back(function_type(base_type::_M_eraser));\n \t_M_functions.push_back(function_type(base_type::_M_insertp));\n \t_M_functions.push_back(function_type(base_type::_M_emplace));\n-\t_M_functions.push_back(function_type(base_type::_M_emplaceh));\n+\t_M_functions.push_back(function_type(base_type::_M_emplacep));\n+\t_M_functions.push_back(function_type(base_type::_M_emplacef));\n+\t_M_functions.push_back(function_type(base_type::_M_emplaceb));\n \t_M_functions.push_back(function_type(base_type::_M_popf));\n \t_M_functions.push_back(function_type(base_type::_M_popb));\n \t_M_functions.push_back(function_type(base_type::_M_pushf));\n@@ -1328,7 +1515,8 @@ namespace __gnu_test\n   // Test strong exception guarantee.\n   // Run through all member functions with a roll-back, consistent\n   // coherent requirement.\n-  // all: member functions insert of a single element, push_back, push_front\n+  // all: member functions insert and emplace of a single element, push_back,\n+  // push_front\n   // unordered: rehash\n   template<typename _Tp>\n     struct propagation_consistent : public test_base<_Tp>\n@@ -1360,9 +1548,12 @@ namespace __gnu_test\n \n \t// Construct containers.\n \tpopulate p(_M_container_control);\n-\tsync();\n \n \t// Construct list of member functions to exercise.\n+\t_M_functions.push_back(function_type(base_type::_M_emplace));\n+\t_M_functions.push_back(function_type(base_type::_M_emplacep));\n+\t_M_functions.push_back(function_type(base_type::_M_emplacef));\n+\t_M_functions.push_back(function_type(base_type::_M_emplaceb));\n \t_M_functions.push_back(function_type(base_type::_M_pushf));\n \t_M_functions.push_back(function_type(base_type::_M_pushb));\n \t_M_functions.push_back(function_type(base_type::_M_insertp));"}, {"sha": "2e253b96a217bd736b43353618023877792e981a", "filename": "libstdc++-v3/testsuite/util/testsuite_container_traits.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bf1e805efe9f8012c8580121dbf68dd9e8d0dc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h?ref=51bf1e805efe9f8012c8580121dbf68dd9e8d0dc", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2009-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -73,6 +73,7 @@ namespace __gnu_test\n       typedef std::true_type\thas_insert;\n       typedef std::true_type\thas_push_pop;\n       typedef std::true_type\thas_size_type_constructor;\n+      typedef std::true_type\thas_emplace;\n     };\n \n   template<typename _Tp1, typename _Tp2>\n@@ -85,6 +86,7 @@ namespace __gnu_test\n       typedef std::true_type\thas_insert_after;\n       typedef std::true_type\thas_push_pop;\n       typedef std::true_type\thas_size_type_constructor;\n+      typedef std::true_type\thas_emplace;\n     };\n \n   template<typename _Tp1, typename _Tp2>\n@@ -98,6 +100,7 @@ namespace __gnu_test\n       typedef std::true_type\thas_insert;\n       typedef std::true_type\thas_push_pop;\n       typedef std::true_type\thas_size_type_constructor;\n+      typedef std::true_type\thas_emplace;\n     };\n \n   template<typename _Tp1, typename _Tp2>\n@@ -111,6 +114,7 @@ namespace __gnu_test\n       typedef std::true_type\thas_throwing_erase;\n       typedef std::true_type\thas_insert;\n       typedef std::true_type\thas_size_type_constructor;\n+      typedef std::true_type\thas_emplace;\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3>\n@@ -148,9 +152,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n       typedef std::true_type\thas_emplace;\n-#endif\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n@@ -164,9 +166,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n       typedef std::true_type\thas_emplace;\n-#endif\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3>\n@@ -179,9 +179,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n       typedef std::true_type\thas_emplace;\n-#endif\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3>\n@@ -194,9 +192,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n       typedef std::true_type\thas_emplace;\n-#endif\n     };\n \n   template<typename _Tp1, typename _Tp2>"}]}