{"sha": "b77029ff250b7a6b0a8f07aa0c4199adca2f4e91", "node_id": "C_kwDOANBUbNoAKGI3NzAyOWZmMjUwYjdhNmIwYThmMDdhYTBjNDE5OWFkY2EyZjRlOTE", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-02-09T01:43:14Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-13T08:04:37Z"}, "message": "[Ada] Implement late initialization rules for type extensions\n\nDefault initialization of a record object is required to initialize any\ncomponents that \"require late initialization\" after other components.\nThis includes the case of a type extension; \"late initialization\"\ncomponents of the parent type are required to be initialized after\nnon-late-init extension components. This is implemented by generalizing\nthe use of an existing init proc parameter. Previously, the init proc\nfor a tagged type took a Boolean parameter indicating whether or not to\ninitialize the Tag component. With this change, this parameter can now\ntake on any of four values indicating whether to perform\n\n   1) Full initialization (including the tag component).\n   2) Full initialization except for the tag component.\n   3) Early (non-tag) initialization only.\n   4) Late (non-tag) initialization only.\n\nWith this change, the init proc for a type extension has the option of\nperforming the early and late portions of the parent's initialization\nvia two separate calls to the parent type's init proc.\n\ngcc/ada/\n\n\t* exp_ch3.ads (Build_Intialization_Call): Add new formal\n\tparameter, Init_Control_Actual, with default value. Clients\n\toutside of package Exp_Ch3 are unaffected.\n\t* exp_ch3.adb (Initialization_Control): new package; support for\n\tthis 4-valued parameter.  The existing Requires_Late_Init\n\tfunction is moved into this new package.\n\t(Build_Initialization_Call): Add new formal parameter for\n\tsubprogram body, use this new formal parameter in generating an\n\tinit proc call.\n\t(Build_Record_Init_Proc): Replace Set_Tag Boolean formal\n\tparameter with 4-valued Init_Control_Formal. Wrap if-statements\n\twith appropriate conditions around tag initialization, early\n\tinitialization, and late initialization statements.\n\t* exp_util.adb (Build_Task_Image_Decl): Avoid problem with\n\tduplicate declarations when an init proc for a type extension\n\tcalls the parent type's init proc twice.", "tree": {"sha": "c650c8bf1f23a0e35e71e18128d51fdcd9aac4f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c650c8bf1f23a0e35e71e18128d51fdcd9aac4f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b6fa643ef03f898a6e7284167fa6d064ba8b524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6fa643ef03f898a6e7284167fa6d064ba8b524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6fa643ef03f898a6e7284167fa6d064ba8b524"}], "stats": {"total": 773, "additions": 529, "deletions": 244}, "files": [{"sha": "d1b33883af1d343760ca9c5ebd49c35af9106767", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 506, "deletions": 235, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b77029ff250b7a6b0a8f07aa0c4199adca2f4e91", "patch": "@@ -184,6 +184,63 @@ package body Exp_Ch3 is\n    --  Treat user-defined stream operations as renaming_as_body if the\n    --  subprogram they rename is not frozen when the type is frozen.\n \n+   package Initialization_Control is\n+\n+      function Requires_Late_Init\n+        (Decl : Node_Id; Rec_Type : Entity_Id) return Boolean;\n+      --  Return True iff the given component declaration requires late\n+      --  initialization, as defined by 3.3.1 (8.1/5).\n+\n+      function Has_Late_Init_Component\n+        (Tagged_Rec_Type : Entity_Id) return Boolean;\n+      --  Return True iff the given tagged record type has at least one\n+      --  component that requires late initialization; this includes\n+      --  components of ancestor types.\n+\n+      type Initialization_Mode is\n+        (Full_Init, Full_Init_Except_Tag, Early_Init_Only, Late_Init_Only);\n+      --  The initialization routine for a tagged type is passed in a\n+      --  formal parameter of this type, indicating what initialization\n+      --  is to be performed. This parameter defaults to Full_Init in all\n+      --  cases except when the init proc of a type extension (let's call\n+      --  that type T2) calls the init proc of its parent (let's call that\n+      --  type T1). In that case, one of the other 3 values will\n+      --  be passed in. In all three of those cases, the Tag component has\n+      --  already been initialized before the call and is therefore not to be\n+      --  modified. T2's init proc will either call T1's init proc\n+      --  once (with Full_Init_Except_Tag as the parameter value) or twice\n+      --  (first with Early_Init_Only, then later with Late_Init_Only),\n+      --  depending on the result returned by Has_Late_Init_Component (T1).\n+      --  In the latter case, the first call does not initialize any\n+      --  components that require late initialization and the second call\n+      --  then performs that deferred initialization.\n+      --  Strictly speaking, the formal parameter subtype is actually Natural\n+      --  but calls will only pass in values corresponding to literals\n+      --  of this enumeration type.\n+\n+      function Make_Mode_Literal\n+        (Loc : Source_Ptr; Mode : Initialization_Mode) return Node_Id\n+      is (Make_Integer_Literal (Loc, Initialization_Mode'Pos (Mode)));\n+      --  Generate an integer literal for a given mode value.\n+\n+      function Tag_Init_Condition\n+        (Loc : Source_Ptr;\n+         Init_Control_Formal : Entity_Id) return Node_Id;\n+      function Early_Init_Condition\n+        (Loc : Source_Ptr;\n+         Init_Control_Formal : Entity_Id) return Node_Id;\n+      function Late_Init_Condition\n+        (Loc : Source_Ptr;\n+         Init_Control_Formal : Entity_Id) return Node_Id;\n+      --  These three functions each return a Boolean expression that\n+      --  can be used to determine whether a given call to the initialization\n+      --  expression for a tagged type should initialize (respectively)\n+      --  the Tag component, the non-Tag components that do not require late\n+      --  initialization, and the components that do require late\n+      --  initialization.\n+\n+   end Initialization_Control;\n+\n    procedure Initialization_Warning (E : Entity_Id);\n    --  If static elaboration of the package is requested, indicate\n    --  when a type does meet the conditions for static initialization. If\n@@ -1447,14 +1504,15 @@ package body Exp_Ch3 is\n    --  end;\n \n    function Build_Initialization_Call\n-     (Loc               : Source_Ptr;\n-      Id_Ref            : Node_Id;\n-      Typ               : Entity_Id;\n-      In_Init_Proc      : Boolean := False;\n-      Enclos_Type       : Entity_Id := Empty;\n-      Discr_Map         : Elist_Id := New_Elmt_List;\n-      With_Default_Init : Boolean := False;\n-      Constructor_Ref   : Node_Id := Empty) return List_Id\n+     (Loc                 : Source_Ptr;\n+      Id_Ref              : Node_Id;\n+      Typ                 : Entity_Id;\n+      In_Init_Proc        : Boolean := False;\n+      Enclos_Type         : Entity_Id := Empty;\n+      Discr_Map           : Elist_Id := New_Elmt_List;\n+      With_Default_Init   : Boolean := False;\n+      Constructor_Ref     : Node_Id := Empty;\n+      Init_Control_Actual : Entity_Id := Empty) return List_Id\n    is\n       Res : constant List_Id := New_List;\n \n@@ -1838,14 +1896,26 @@ package body Exp_Ch3 is\n \n       --  If this is a call to initialize the parent component of a derived\n       --  tagged type, indicate that the tag should not be set in the parent.\n+      --  This is done via the actual parameter value for the Init_Control\n+      --  formal parameter, which is also used to deal with late initialization\n+      --  requirements.\n+      --\n+      --  We pass in Full_Init_Except_Tag unless the caller tells us to do\n+      --  otherwise (by passing in a nonempty Init_Control_Actual parameter).\n \n       if Is_Tagged_Type (Full_Init_Type)\n         and then not Is_CPP_Class (Full_Init_Type)\n         and then Nkind (Id_Ref) = N_Selected_Component\n         and then Chars (Selector_Name (Id_Ref)) = Name_uParent\n       then\n-         Append_To (Args, New_Occurrence_Of (Standard_False, Loc));\n-\n+         declare\n+            use Initialization_Control;\n+         begin\n+            Append_To (Args,\n+              (if Present (Init_Control_Actual)\n+               then Init_Control_Actual\n+               else Make_Mode_Literal (Loc, Full_Init_Except_Tag)));\n+         end;\n       elsif Present (Constructor_Ref) then\n          Append_List_To (Args,\n            New_Copy_List (Parameter_Associations (Constructor_Ref)));\n@@ -1906,8 +1976,9 @@ package body Exp_Ch3 is\n       Counter   : Nat := 0;\n       Proc_Id   : Entity_Id;\n       Rec_Type  : Entity_Id;\n-      Set_Tag   : Entity_Id := Empty;\n-      Has_Late_Init_Comp : Boolean := False; -- set in Build_Init_Statements\n+\n+      Init_Control_Formal : Entity_Id := Empty; -- set in Build_Init_Statements\n+      Has_Late_Init_Comp  : Boolean := False;   -- set in Build_Init_Statements\n \n       function Build_Assignment\n         (Id      : Entity_Id;\n@@ -2532,6 +2603,7 @@ package body Exp_Ch3 is\n          Proc_Spec_Node        : Node_Id;\n          Record_Extension_Node : Node_Id;\n \n+         use Initialization_Control;\n       begin\n          Body_Stmts := New_List;\n          Body_Node := New_Node (N_Subprogram_Body, Loc);\n@@ -2544,21 +2616,27 @@ package body Exp_Ch3 is\n          Append_List_To (Parameters,\n            Build_Discriminant_Formals (Rec_Type, True));\n \n-         --  For tagged types, we add a flag to indicate whether the routine\n-         --  is called to initialize a parent component in the init_proc of\n-         --  a type extension. If the flag is false, we do not set the tag\n-         --  because it has been set already in the extension.\n+         --  For tagged types, we add a parameter to indicate what\n+         --  portion of the object's initialization is to be performed.\n+         --  This is used for two purposes:\n+         --   1)  When a type extension's initialization procedure calls\n+         --       the initialization procedure of the parent type, we do\n+         --       not want the parent to initialize the Tag component;\n+         --       it has been set already.\n+         --   2)  If an ancestor type has at least one component that requires\n+         --       late initialization, then we need to be able to initialize\n+         --       those components separately after initializing any other\n+         --       components.\n \n          if Is_Tagged_Type (Rec_Type) then\n-            Set_Tag := Make_Temporary (Loc, 'P');\n+            Init_Control_Formal := Make_Temporary (Loc, 'P');\n \n             Append_To (Parameters,\n               Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Set_Tag,\n+                Defining_Identifier => Init_Control_Formal,\n                 Parameter_Type =>\n-                  New_Occurrence_Of (Standard_Boolean, Loc),\n-                Expression =>\n-                  New_Occurrence_Of (Standard_True, Loc)));\n+                  New_Occurrence_Of (Standard_Natural, Loc),\n+                Expression => Make_Mode_Literal (Loc, Full_Init)));\n          end if;\n \n          --  Create an extra accessibility parameter to capture the level of\n@@ -2622,22 +2700,45 @@ package body Exp_Ch3 is\n                      declare\n                         Parent_IP : constant Name_Id :=\n                                       Make_Init_Proc_Name (Etype (Rec_Ent));\n-                        Stmt      : Node_Id;\n-                        IP_Call   : Node_Id;\n-                        IP_Stmts  : List_Id;\n-\n+                        Stmt      : Node_Id := First (Stmts);\n+                        IP_Call   : Node_Id := Empty;\n                      begin\n-                        --  Look for a call to the parent IP at the beginning\n-                        --  of Stmts associated with the record extension\n+                        --  Look for a call to the parent IP associated with\n+                        --  the record extension.\n+                        --  The call will be inside not one but two\n+                        --  if-statements (with the same condition). Testing\n+                        --  the same Early_Init condition twice might seem\n+                        --  redundant. However, as soon as we exit this loop,\n+                        --  we are going to hoist the inner if-statement out\n+                        --  of the outer one; the \"redundant\" test was built\n+                        --  in anticipation of this hoisting.\n \n-                        Stmt := First (Stmts);\n-                        IP_Call := Empty;\n                         while Present (Stmt) loop\n-                           if Nkind (Stmt) = N_Procedure_Call_Statement\n-                             and then Chars (Name (Stmt)) = Parent_IP\n-                           then\n-                              IP_Call := Stmt;\n-                              exit;\n+                           if Nkind (Stmt) = N_If_Statement then\n+                              declare\n+                                 Then_Stmt1 : Node_Id :=\n+                                   First (Then_Statements (Stmt));\n+                                 Then_Stmt2 : Node_Id;\n+                              begin\n+                                 while Present (Then_Stmt1) loop\n+                                    if Nkind (Then_Stmt1) = N_If_Statement then\n+                                       Then_Stmt2 :=\n+                                         First (Then_Statements (Then_Stmt1));\n+\n+                                       if Nkind (Then_Stmt2) =\n+                                            N_Procedure_Call_Statement\n+                                         and then Chars (Name (Then_Stmt2)) =\n+                                           Parent_IP\n+                                       then\n+                                          --  IP_Call is a call wrapped in an\n+                                          --  if statement.\n+                                          IP_Call := Then_Stmt1;\n+                                          exit;\n+                                       end if;\n+                                    end if;\n+                                    Next (Then_Stmt1);\n+                                 end loop;\n+                              end;\n                            end if;\n \n                            Next (Stmt);\n@@ -2647,14 +2748,8 @@ package body Exp_Ch3 is\n                         --  statements of this IP routine\n \n                         if Present (IP_Call) then\n-                           IP_Stmts := New_List;\n-                           loop\n-                              Stmt := Remove_Head (Stmts);\n-                              Append_To (IP_Stmts, Stmt);\n-                              exit when Stmt = IP_Call;\n-                           end loop;\n-\n-                           Prepend_List_To (Body_Stmts, IP_Stmts);\n+                           Remove (IP_Call);\n+                           Prepend_List_To (Body_Stmts, New_List (IP_Call));\n                         end if;\n                      end;\n                   end if;\n@@ -2729,7 +2824,8 @@ package body Exp_Ch3 is\n \n                      Elab_List := New_List (\n                        Make_If_Statement (Loc,\n-                         Condition       => New_Occurrence_Of (Set_Tag, Loc),\n+                         Condition       =>\n+                           Tag_Init_Condition (Loc, Init_Control_Formal),\n                          Then_Statements => Init_Tags_List));\n \n                      if Elab_Flag_Needed (Rec_Type) then\n@@ -2755,7 +2851,8 @@ package body Exp_Ch3 is\n                else\n                   Prepend_To (Body_Stmts,\n                     Make_If_Statement (Loc,\n-                      Condition       => New_Occurrence_Of (Set_Tag, Loc),\n+                      Condition =>\n+                        Tag_Init_Condition (Loc, Init_Control_Formal),\n                       Then_Statements => Init_Tags_List));\n                end if;\n \n@@ -2823,11 +2920,18 @@ package body Exp_Ch3 is\n                begin\n                   --  Search for the call to the IP of the parent. We assume\n                   --  that the first init_proc call is for the parent.\n+                  --  It is wrapped in an \"if Early_Init_Condition\"\n+                  --  if-statement.\n \n                   Ins_Nod := First (Body_Stmts);\n                   while Present (Next (Ins_Nod))\n-                    and then (Nkind (Ins_Nod) /= N_Procedure_Call_Statement\n-                               or else not Is_Init_Proc (Name (Ins_Nod)))\n+                    and then\n+                      (Nkind (Ins_Nod) /= N_If_Statement\n+                        or else (Nkind (First (Then_Statements (Ins_Nod)))\n+                                   /= N_Procedure_Call_Statement)\n+                        or else not Is_Init_Proc\n+                                      (Name (First (Then_Statements\n+                                         (Ins_Nod)))))\n                   loop\n                      Next (Ins_Nod);\n                   end loop;\n@@ -2974,34 +3078,31 @@ package body Exp_Ch3 is\n          Decl               : Node_Id;\n          Id                 : Entity_Id;\n          Parent_Stmts       : List_Id;\n-         Stmts              : List_Id;\n+         Parent_Id          : Entity_Id := Empty;\n+         Stmts, Late_Stmts  : List_Id := Empty_List;\n          Typ                : Entity_Id;\n \n-         procedure Increment_Counter (Loc : Source_Ptr);\n+         procedure Increment_Counter\n+           (Loc  : Source_Ptr; Late : Boolean := False);\n          --  Generate an \"increment by one\" statement for the current counter\n-         --  and append it to the list Stmts.\n+         --  and append it to the appropriate statement list.\n \n          procedure Make_Counter (Loc : Source_Ptr);\n          --  Create a new counter for the current component list. The routine\n          --  creates a new defining Id, adds an object declaration and sets\n          --  the Id generator for the next variant.\n \n-         function Requires_Late_Initialization\n-           (Decl     : Node_Id;\n-            Rec_Type : Entity_Id) return Boolean;\n-         --  Return whether the given Decl requires late initialization, as\n-         --  defined by 3.3.1 (8.1/5).\n-\n          -----------------------\n          -- Increment_Counter --\n          -----------------------\n \n-         procedure Increment_Counter (Loc : Source_Ptr) is\n+         procedure Increment_Counter\n+           (Loc  : Source_Ptr; Late : Boolean := False) is\n          begin\n             --  Generate:\n             --    Counter := Counter + 1;\n \n-            Append_To (Stmts,\n+            Append_To ((if Late then Late_Stmts else Stmts),\n               Make_Assignment_Statement (Loc,\n                 Name       => New_Occurrence_Of (Counter_Id, Loc),\n                 Expression =>\n@@ -3038,157 +3139,6 @@ package body Exp_Ch3 is\n                   Make_Integer_Literal (Loc, 0)));\n          end Make_Counter;\n \n-         ----------------------------------\n-         -- Requires_Late_Initialization --\n-         ----------------------------------\n-\n-         function Requires_Late_Initialization\n-           (Decl     : Node_Id;\n-            Rec_Type : Entity_Id) return Boolean\n-         is\n-            References_Current_Instance : Boolean := False;\n-            Has_Access_Discriminant     : Boolean := False;\n-            Has_Internal_Call           : Boolean := False;\n-\n-            function Find_Access_Discriminant\n-              (N : Node_Id) return Traverse_Result;\n-            --  Look for a name denoting an access discriminant\n-\n-            function Find_Current_Instance\n-              (N : Node_Id) return Traverse_Result;\n-            --  Look for a reference to the current instance of the type\n-\n-            function Find_Internal_Call\n-              (N : Node_Id) return Traverse_Result;\n-            --  Look for an internal protected function call\n-\n-            ------------------------------\n-            -- Find_Access_Discriminant --\n-            ------------------------------\n-\n-            function Find_Access_Discriminant\n-              (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Is_Entity_Name (N)\n-                 and then Denotes_Discriminant (N)\n-                 and then Is_Access_Type (Etype (N))\n-               then\n-                  Has_Access_Discriminant := True;\n-                  return Abandon;\n-               else\n-                  return OK;\n-               end if;\n-            end Find_Access_Discriminant;\n-\n-            ---------------------------\n-            -- Find_Current_Instance --\n-            ---------------------------\n-\n-            function Find_Current_Instance\n-              (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Is_Entity_Name (N)\n-                 and then Present (Entity (N))\n-                 and then Is_Current_Instance (N)\n-               then\n-                  References_Current_Instance := True;\n-                  return Abandon;\n-               else\n-                  return OK;\n-               end if;\n-            end Find_Current_Instance;\n-\n-            ------------------------\n-            -- Find_Internal_Call --\n-            ------------------------\n-\n-            function Find_Internal_Call (N : Node_Id) return Traverse_Result is\n-\n-               function Call_Scope (N : Node_Id) return Entity_Id;\n-               --  Return the scope enclosing a given call node N\n-\n-               ----------------\n-               -- Call_Scope --\n-               ----------------\n-\n-               function Call_Scope (N : Node_Id) return Entity_Id is\n-                  Nam : constant Node_Id := Name (N);\n-               begin\n-                  if Nkind (Nam) = N_Selected_Component then\n-                     return Scope (Entity (Prefix (Nam)));\n-                  else\n-                     return Scope (Entity (Nam));\n-                  end if;\n-               end Call_Scope;\n-\n-            begin\n-               if Nkind (N) = N_Function_Call\n-                 and then Call_Scope (N)\n-                            = Corresponding_Concurrent_Type (Rec_Type)\n-               then\n-                  Has_Internal_Call := True;\n-                  return Abandon;\n-               else\n-                  return OK;\n-               end if;\n-            end Find_Internal_Call;\n-\n-            procedure Search_Access_Discriminant is new\n-              Traverse_Proc (Find_Access_Discriminant);\n-\n-            procedure Search_Current_Instance is new\n-              Traverse_Proc (Find_Current_Instance);\n-\n-            procedure Search_Internal_Call is new\n-              Traverse_Proc (Find_Internal_Call);\n-\n-         begin\n-            --  A component of an object is said to require late initialization\n-            --  if:\n-\n-            --  it has an access discriminant value constrained by a per-object\n-            --  expression;\n-\n-            if Has_Access_Constraint (Defining_Identifier (Decl))\n-              and then No (Expression (Decl))\n-            then\n-               return True;\n-\n-            elsif Present (Expression (Decl)) then\n-\n-               --  it has an initialization expression that includes a name\n-               --  denoting an access discriminant;\n-\n-               Search_Access_Discriminant (Expression (Decl));\n-\n-               if Has_Access_Discriminant then\n-                  return True;\n-               end if;\n-\n-               --  or it has an initialization expression that includes a\n-               --  reference to the current instance of the type either by\n-               --  name...\n-\n-               Search_Current_Instance (Expression (Decl));\n-\n-               if References_Current_Instance then\n-                  return True;\n-               end if;\n-\n-               --  ...or implicitly as the target object of a call.\n-\n-               if Is_Protected_Record_Type (Rec_Type) then\n-                  Search_Internal_Call (Expression (Decl));\n-\n-                  if Has_Internal_Call then\n-                     return True;\n-                  end if;\n-               end if;\n-            end if;\n-\n-            return False;\n-         end Requires_Late_Initialization;\n-\n       --  Start of processing for Build_Init_Statements\n \n       begin\n@@ -3256,7 +3206,10 @@ package body Exp_Ch3 is\n             --  Leave any processing of component requiring late initialization\n             --  for the second pass.\n \n-            if Requires_Late_Initialization (Decl, Rec_Type) then\n+            if Initialization_Control.Requires_Late_Init (Decl, Rec_Type) then\n+               if not Has_Late_Init_Comp then\n+                  Late_Stmts := New_List;\n+               end if;\n                Has_Late_Init_Comp := True;\n \n             --  Regular component cases\n@@ -3403,17 +3356,56 @@ package body Exp_Ch3 is\n                elsif not Is_Interface (Typ)\n                  and then Has_Non_Null_Base_Init_Proc (Typ)\n                then\n-                  Actions :=\n-                    Build_Initialization_Call\n-                      (Comp_Loc,\n-                       Make_Selected_Component (Comp_Loc,\n-                         Prefix        =>\n-                           Make_Identifier (Comp_Loc, Name_uInit),\n-                         Selector_Name => New_Occurrence_Of (Id, Comp_Loc)),\n-                       Typ,\n-                       In_Init_Proc => True,\n-                       Enclos_Type  => Rec_Type,\n-                       Discr_Map    => Discr_Map);\n+                  declare\n+                     use Initialization_Control;\n+                     Init_Control_Actual : Node_Id := Empty;\n+                     Is_Parent : constant Boolean := Chars (Id) = Name_uParent;\n+                     Init_Call_Stmts : List_Id;\n+                  begin\n+                     if Is_Parent and then Has_Late_Init_Component (Etype (Id))\n+                     then\n+                        Init_Control_Actual :=\n+                          Make_Mode_Literal (Comp_Loc, Early_Init_Only);\n+                        --  Parent_Id used later in second call to parent's\n+                        --  init proc to initialize late-init components.\n+                        Parent_Id := Id;\n+                     end if;\n+\n+                     Init_Call_Stmts :=\n+                       Build_Initialization_Call\n+                         (Comp_Loc,\n+                          Make_Selected_Component (Comp_Loc,\n+                            Prefix        =>\n+                              Make_Identifier (Comp_Loc, Name_uInit),\n+                            Selector_Name => New_Occurrence_Of (Id, Comp_Loc)),\n+                          Typ,\n+                          In_Init_Proc        => True,\n+                          Enclos_Type         => Rec_Type,\n+                          Discr_Map           => Discr_Map,\n+                          Init_Control_Actual => Init_Control_Actual);\n+\n+                     if Is_Parent then\n+                        --  This is tricky. At first it looks like\n+                        --  we are going to end up with nested\n+                        --  if-statements with the same condition:\n+                        --    if Early_Init_Condition then\n+                        --       if Early_Init_Condition then\n+                        --          Parent_TypeIP (...);\n+                        --       end if;\n+                        --    end if;\n+                        --  But later we will hoist the inner if-statement\n+                        --  out of the outer one; we do this  because the\n+                        --  init-proc call for the _Parent component of a type\n+                        --  extension has to precede any other initialization.\n+                        Actions :=\n+                          New_List (Make_If_Statement (Loc,\n+                            Condition =>\n+                              Early_Init_Condition (Loc, Init_Control_Formal),\n+                            Then_Statements => Init_Call_Stmts));\n+                     else\n+                        Actions := Init_Call_Stmts;\n+                     end if;\n+                  end;\n \n                   Clean_Task_Names (Typ, Proc_Id);\n \n@@ -3443,7 +3435,7 @@ package body Exp_Ch3 is\n                --  DIC here.\n \n                if Has_DIC (Typ)\n-                 and then not Present (Expression (Decl))\n+                 and then No (Expression (Decl))\n                  and then Present (DIC_Procedure (Typ))\n                  and then not Has_Null_Body (DIC_Procedure (Typ))\n \n@@ -3481,7 +3473,6 @@ package body Exp_Ch3 is\n                if Present (Actions) then\n                   if Chars (Id) = Name_uParent then\n                      Append_List_To (Parent_Stmts, Actions);\n-\n                   else\n                      Append_List_To (Stmts, Actions);\n \n@@ -3595,20 +3586,49 @@ package body Exp_Ch3 is\n \n          --  Second pass: components that require late initialization\n \n+         if Present (Parent_Id) then\n+            declare\n+               Parent_Loc : constant Source_Ptr := Sloc (Parent (Parent_Id));\n+               use Initialization_Control;\n+            begin\n+               --  We are building the init proc for a type extension.\n+               --  Call the parent type's init proc a second time, this\n+               --  time to initialize the parent's components that require\n+               --  late initialization.\n+\n+               Append_List_To (Late_Stmts,\n+                 Build_Initialization_Call\n+                   (Loc                  => Parent_Loc,\n+                    Id_Ref               =>\n+                      Make_Selected_Component (Parent_Loc,\n+                        Prefix        => Make_Identifier\n+                                           (Parent_Loc, Name_uInit),\n+                        Selector_Name => New_Occurrence_Of (Parent_Id,\n+                                                            Parent_Loc)),\n+                    Typ                 => Etype (Parent_Id),\n+                    In_Init_Proc        => True,\n+                    Enclos_Type         => Rec_Type,\n+                    Discr_Map           => Discr_Map,\n+                    Init_Control_Actual => Make_Mode_Literal\n+                                             (Parent_Loc, Late_Init_Only)));\n+            end;\n+         end if;\n+\n          if Has_Late_Init_Comp then\n             Decl := First_Non_Pragma (Component_Items (Comp_List));\n             while Present (Decl) loop\n                Comp_Loc := Sloc (Decl);\n                Id := Defining_Identifier (Decl);\n                Typ := Etype (Id);\n \n-               if Requires_Late_Initialization (Decl, Rec_Type) then\n+               if Initialization_Control.Requires_Late_Init (Decl, Rec_Type)\n+               then\n                   if Present (Expression (Decl)) then\n-                     Append_List_To (Stmts,\n+                     Append_List_To (Late_Stmts,\n                        Build_Assignment (Id, Expression (Decl)));\n \n                   elsif Has_Non_Null_Base_Init_Proc (Typ) then\n-                     Append_List_To (Stmts,\n+                     Append_List_To (Late_Stmts,\n                        Build_Initialization_Call (Comp_Loc,\n                          Make_Selected_Component (Comp_Loc,\n                            Prefix        =>\n@@ -3628,10 +3648,10 @@ package body Exp_Ch3 is\n                            Make_Counter (Comp_Loc);\n                         end if;\n \n-                        Increment_Counter (Comp_Loc);\n+                        Increment_Counter (Comp_Loc, Late => True);\n                      end if;\n                   elsif Component_Needs_Simple_Initialization (Typ) then\n-                     Append_List_To (Stmts,\n+                     Append_List_To (Late_Stmts,\n                        Build_Assignment\n                          (Id      => Id,\n                           Default =>\n@@ -3646,7 +3666,8 @@ package body Exp_Ch3 is\n             end loop;\n          end if;\n \n-         --  Process the variant part\n+         --  Process the variant part (incorrectly ignoring late\n+         --  initialization requirements for components therein).\n \n          if Present (Variant_Part (Comp_List)) then\n             declare\n@@ -3681,16 +3702,42 @@ package body Exp_Ch3 is\n             end;\n          end if;\n \n-         --  If no initializations when generated for component declarations\n-         --  corresponding to this Stmts, append a null statement to Stmts to\n-         --  to make it a valid Ada tree.\n+         if No (Init_Control_Formal) then\n+            Append_List_To (Stmts, Late_Stmts);\n \n-         if Is_Empty_List (Stmts) then\n-            Append (Make_Null_Statement (Loc), Stmts);\n-         end if;\n+            --  If no initializations were generated for component declarations\n+            --  and included in Stmts, then append a null statement to Stmts\n+            --  to make it a valid Ada tree.\n \n-         return Stmts;\n+            if Is_Empty_List (Stmts) then\n+               Append (Make_Null_Statement (Loc), Stmts);\n+            end if;\n \n+            return Stmts;\n+         else\n+            declare\n+               use Initialization_Control;\n+\n+               If_Early : constant Node_Id :=\n+                  (if Is_Empty_List (Stmts) then\n+                      Make_Null_Statement (Loc)\n+                   else\n+                      Make_If_Statement (Loc,\n+                        Condition =>\n+                          Early_Init_Condition (Loc, Init_Control_Formal),\n+                        Then_Statements => Stmts));\n+               If_Late : constant Node_Id :=\n+                  (if Is_Empty_List (Late_Stmts) then\n+                      Make_Null_Statement (Loc)\n+                   else\n+                      Make_If_Statement (Loc,\n+                        Condition =>\n+                          Late_Init_Condition (Loc, Init_Control_Formal),\n+                        Then_Statements => Late_Stmts));\n+            begin\n+               return New_List (If_Early, If_Late);\n+            end;\n+         end if;\n       exception\n          when RE_Not_Available =>\n             return Empty_List;\n@@ -9048,6 +9095,230 @@ package body Exp_Ch3 is\n       return Is_RTU (S1, System) or else Is_RTU (S1, Ada);\n    end In_Runtime;\n \n+   package body Initialization_Control is\n+\n+      ------------------------\n+      -- Requires_Late_Init --\n+      ------------------------\n+\n+      function Requires_Late_Init\n+        (Decl     : Node_Id;\n+         Rec_Type : Entity_Id) return Boolean\n+      is\n+         References_Current_Instance : Boolean := False;\n+         Has_Access_Discriminant     : Boolean := False;\n+         Has_Internal_Call           : Boolean := False;\n+\n+         function Find_Access_Discriminant\n+           (N : Node_Id) return Traverse_Result;\n+         --  Look for a name denoting an access discriminant\n+\n+         function Find_Current_Instance\n+           (N : Node_Id) return Traverse_Result;\n+         --  Look for a reference to the current instance of the type\n+\n+         function Find_Internal_Call\n+           (N : Node_Id) return Traverse_Result;\n+         --  Look for an internal protected function call\n+\n+         ------------------------------\n+         -- Find_Access_Discriminant --\n+         ------------------------------\n+\n+         function Find_Access_Discriminant\n+           (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Is_Entity_Name (N)\n+              and then Denotes_Discriminant (N)\n+              and then Is_Access_Type (Etype (N))\n+            then\n+               Has_Access_Discriminant := True;\n+               return Abandon;\n+            else\n+               return OK;\n+            end if;\n+         end Find_Access_Discriminant;\n+\n+         ---------------------------\n+         -- Find_Current_Instance --\n+         ---------------------------\n+\n+         function Find_Current_Instance\n+           (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Is_Entity_Name (N)\n+              and then Present (Entity (N))\n+              and then Is_Current_Instance (N)\n+            then\n+               References_Current_Instance := True;\n+               return Abandon;\n+            else\n+               return OK;\n+            end if;\n+         end Find_Current_Instance;\n+\n+         ------------------------\n+         -- Find_Internal_Call --\n+         ------------------------\n+\n+         function Find_Internal_Call (N : Node_Id) return Traverse_Result is\n+\n+            function Call_Scope (N : Node_Id) return Entity_Id;\n+            --  Return the scope enclosing a given call node N\n+\n+            ----------------\n+            -- Call_Scope --\n+            ----------------\n+\n+            function Call_Scope (N : Node_Id) return Entity_Id is\n+               Nam : constant Node_Id := Name (N);\n+            begin\n+               if Nkind (Nam) = N_Selected_Component then\n+                  return Scope (Entity (Prefix (Nam)));\n+               else\n+                  return Scope (Entity (Nam));\n+               end if;\n+            end Call_Scope;\n+\n+         begin\n+            if Nkind (N) = N_Function_Call\n+              and then Call_Scope (N)\n+                         = Corresponding_Concurrent_Type (Rec_Type)\n+            then\n+               Has_Internal_Call := True;\n+               return Abandon;\n+            else\n+               return OK;\n+            end if;\n+         end Find_Internal_Call;\n+\n+         procedure Search_Access_Discriminant is new\n+           Traverse_Proc (Find_Access_Discriminant);\n+\n+         procedure Search_Current_Instance is new\n+           Traverse_Proc (Find_Current_Instance);\n+\n+         procedure Search_Internal_Call is new\n+           Traverse_Proc (Find_Internal_Call);\n+\n+         --  Start of processing for Requires_Late_Init\n+\n+      begin\n+         --  A component of an object is said to require late initialization\n+         --  if:\n+\n+         --  it has an access discriminant value constrained by a per-object\n+         --  expression;\n+\n+         if Has_Access_Constraint (Defining_Identifier (Decl))\n+           and then No (Expression (Decl))\n+         then\n+            return True;\n+\n+         elsif Present (Expression (Decl)) then\n+\n+            --  it has an initialization expression that includes a name\n+            --  denoting an access discriminant;\n+\n+            Search_Access_Discriminant (Expression (Decl));\n+\n+            if Has_Access_Discriminant then\n+               return True;\n+            end if;\n+\n+            --  or it has an initialization expression that includes a\n+            --  reference to the current instance of the type either by\n+            --  name...\n+\n+            Search_Current_Instance (Expression (Decl));\n+\n+            if References_Current_Instance then\n+               return True;\n+            end if;\n+\n+            --  ...or implicitly as the target object of a call.\n+\n+            if Is_Protected_Record_Type (Rec_Type) then\n+               Search_Internal_Call (Expression (Decl));\n+\n+               if Has_Internal_Call then\n+                  return True;\n+               end if;\n+            end if;\n+         end if;\n+\n+         return False;\n+      end Requires_Late_Init;\n+\n+      -----------------------------\n+      -- Has_Late_Init_Component --\n+      -----------------------------\n+\n+      function Has_Late_Init_Component\n+        (Tagged_Rec_Type : Entity_Id) return Boolean\n+      is\n+         Comp_Id : Entity_Id :=\n+           First_Component (Implementation_Base_Type (Tagged_Rec_Type));\n+      begin\n+         while Present (Comp_Id) loop\n+            if Requires_Late_Init (Decl     => Parent (Comp_Id),\n+                                   Rec_Type => Tagged_Rec_Type)\n+            then\n+               return True; -- found a component that requires late init\n+\n+            elsif Chars (Comp_Id) = Name_uParent\n+              and then Has_Late_Init_Component (Etype (Comp_Id))\n+            then\n+               return True; -- an ancestor type has a late init component\n+            end if;\n+\n+            Next_Component (Comp_Id);\n+         end loop;\n+\n+         return False;\n+      end Has_Late_Init_Component;\n+\n+      ------------------------\n+      -- Tag_Init_Condition --\n+      ------------------------\n+\n+      function Tag_Init_Condition\n+        (Loc : Source_Ptr;\n+         Init_Control_Formal : Entity_Id) return Node_Id is\n+      begin\n+         return Make_Op_Eq (Loc,\n+                  New_Occurrence_Of (Init_Control_Formal, Loc),\n+                  Make_Mode_Literal (Loc, Full_Init));\n+      end Tag_Init_Condition;\n+\n+      --------------------------\n+      -- Early_Init_Condition --\n+      --------------------------\n+\n+      function Early_Init_Condition\n+        (Loc : Source_Ptr;\n+         Init_Control_Formal : Entity_Id) return Node_Id is\n+      begin\n+         return Make_Op_Ne (Loc,\n+                  New_Occurrence_Of (Init_Control_Formal, Loc),\n+                  Make_Mode_Literal (Loc, Late_Init_Only));\n+      end Early_Init_Condition;\n+\n+      -------------------------\n+      -- Late_Init_Condition --\n+      -------------------------\n+\n+      function Late_Init_Condition\n+        (Loc : Source_Ptr;\n+         Init_Control_Formal : Entity_Id) return Node_Id is\n+      begin\n+         return Make_Op_Ne (Loc,\n+                  New_Occurrence_Of (Init_Control_Formal, Loc),\n+                  Make_Mode_Literal (Loc, Early_Init_Only));\n+      end Late_Init_Condition;\n+\n+   end Initialization_Control;\n+\n    ----------------------------\n    -- Initialization_Warning --\n    ----------------------------"}, {"sha": "23fecfd3cb91db762f93623b2ee849c5f05ff112", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=b77029ff250b7a6b0a8f07aa0c4199adca2f4e91", "patch": "@@ -62,14 +62,15 @@ package Exp_Ch3 is\n    --  and the discriminant checking functions are inserted after this node.\n \n    function Build_Initialization_Call\n-     (Loc               : Source_Ptr;\n-      Id_Ref            : Node_Id;\n-      Typ               : Entity_Id;\n-      In_Init_Proc      : Boolean := False;\n-      Enclos_Type       : Entity_Id := Empty;\n-      Discr_Map         : Elist_Id := New_Elmt_List;\n-      With_Default_Init : Boolean := False;\n-      Constructor_Ref   : Node_Id := Empty) return List_Id;\n+     (Loc                 : Source_Ptr;\n+      Id_Ref              : Node_Id;\n+      Typ                 : Entity_Id;\n+      In_Init_Proc        : Boolean := False;\n+      Enclos_Type         : Entity_Id := Empty;\n+      Discr_Map           : Elist_Id := New_Elmt_List;\n+      With_Default_Init   : Boolean := False;\n+      Constructor_Ref     : Node_Id := Empty;\n+      Init_Control_Actual : Entity_Id := Empty) return List_Id;\n    --  Builds a call to the initialization procedure for the base type of Typ,\n    --  passing it the object denoted by Id_Ref, plus additional parameters as\n    --  appropriate for the type (the _Master, for task types, for example).\n@@ -93,6 +94,12 @@ package Exp_Ch3 is\n    --\n    --  Constructor_Ref is a call to a constructor subprogram. It is currently\n    --  used only to support C++ constructors.\n+   --\n+   --  Init_Control_Actual is Empty except in the case where the init proc\n+   --  for a tagged type calls the init proc for its parent type in order\n+   --  to initialize its _Parent component. In that case, it is the\n+   --  actual parameter value corresponding to the Init_Control formal\n+   --  parameter to be used in the call of the parent type's init proc.\n \n    function Build_Variant_Record_Equality\n      (Typ         : Entity_Id;"}, {"sha": "4198ceaa5b3e663cb6295843bfe42ce89ad2899d", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77029ff250b7a6b0a8f07aa0c4199adca2f4e91/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b77029ff250b7a6b0a8f07aa0c4199adca2f4e91", "patch": "@@ -4377,6 +4377,12 @@ package body Exp_Util is\n                    and then\n                  Nkind (Expression (Parent (Id_Ref))) = N_Allocator;\n \n+      Component_Suffix_Index : constant Int :=\n+        (if In_Init_Proc then -1 else 0);\n+      --  If an init proc calls Build_Task_Image_Decls twice for its\n+      --  _Parent component (to split early/late initialization), we don't\n+      --  want two decls with the same name. Hence, the -1 suffix.\n+\n    begin\n       --  If Discard_Names or No_Implicit_Heap_Allocations are in effect,\n       --  generate a dummy declaration only.\n@@ -4418,7 +4424,8 @@ package body Exp_Util is\n          elsif Nkind (Id_Ref) = N_Selected_Component then\n             T_Id :=\n               Make_Defining_Identifier (Loc,\n-                New_External_Name (Chars (Selector_Name (Id_Ref)), 'T'));\n+                New_External_Name (Chars (Selector_Name (Id_Ref)), 'T',\n+                  Suffix_Index => Component_Suffix_Index));\n             Fun := Build_Task_Record_Image (Loc, Id_Ref, Is_Dyn);\n \n          elsif Nkind (Id_Ref) = N_Indexed_Component then"}]}