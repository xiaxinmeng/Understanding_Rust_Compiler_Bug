{"sha": "8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg5MzIzOWRjNGVkMzJiZDNiYjRlMDBkNmU0M2I4NTk1NTRhYjgyYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-02-10T19:19:10Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2007-02-10T19:19:10Z"}, "message": "Makefile.in (libgcc-support, [...]): Add emutls.c.\n\ngcc/ChangeLog:\n* Makefile.in (libgcc-support, libgcc.mvars): Add emutls.c.\n* builtin-types.def (BT_WORD): Make unsigned.\n(BT_FN_VOID_PTR_WORD_WORD_PTR): New.\n* builtins.def (BUILT_IN_EMUTLS_GET_ADDRESS): New.\n(BUILT_IN_EMUTLS_REGISTER_COMMON): New.\n* c-decl.c (grokdeclarator): Don't error if !have_tls.\n* c-parser.c (c_parser_omp_threadprivate): Likewise.\n* dwarf2out.c (loc_descriptor_from_tree_1): Don't do anything for\nemulated tls.\n* expr.c (emutls_var_address): New.\n(expand_expr_real_1): Expand emulated tls.\n(expand_expr_addr_expr_1): Likewise.\n* libgcc-std.ver: Add __emutls_get_address, __emutls_register_common.\n* output.h (emutls_finish): Declare.\n* toplev.c (compile_file): Call it.\n* tree-ssa-address.c (gen_addr_rtx): Check for const-ness of the\naddress before wrapping in CONST.\n* varasm.c (emutls_htab, emutls_object_type): New.\n(EMUTLS_VAR_PREFIX, EMUTLS_TMPL_PREFIX): New.\n(get_emutls_object_name, get_emutls_object_type): New.\n(get_emutls_init_templ_addr, emutls_decl): New.\n(emutls_common_1, emutls_finish): New.\n(assemble_variable): When emulating tls, swap decls; generate\nconstructor for the emutls objects.\n(do_assemble_alias): When emulating tls, swap decl and target name.\n(default_encode_section_info): Don't add SYMBOL_FLAG_TLS_SHIFT\nfor emulated tls.\n* varpool.c (decide_is_variable_needed): Look at force_output.\nRecurse for emulated tls.\n(cgraph_varpool_remove_unreferenced_decls): Remove checks redundant\nwith decide_is_variable_needed.\n* emutls.c: New file.\n* config/sparc/sol2.h (ASM_DECLARE_OBJECT_NAME): Only emit\ntls_object for real tls.\ngcc/cp/ChangeLog:\n* decl.c (grokvardecl): Don't error if !have_tls.\n(grokdeclarator): Likewise.\n* parser.c (cp_parser_omp_threadprivate): Likewise.\ngcc/fortran/ChangeLog:\n* f95-lang.c (gfc_init_builtin_functions): Add __emutls_get_address\nand __emutls_register_common.\n* openmp.c (gfc_match_omp_threadprivate): Don't error if !have_tls.\n* trans-common.c (build_common_decl): Don't check have_tls.\n* trans-decl.c (gfc_finish_var_decl): Likewise.\n* types.def (BT_WORD, BT_FN_PTR_PTR): New.\n(BT_FN_VOID_PTR_WORD_WORD_PTR): New.\ngcc/testsuite/ChangeLog:\n* lib/target-supports.exp (check_effective_target_tls): Redefine\nto mean non-emulated tls.\n* gcc.dg/tls/alias-1.c: Remove tls requirement.\n* gcc.dg/tls/asm-1.c, gcc.dg/tls/debug-1.c, gcc.dg/tls/diag-1.c,\ngcc.dg/tls/diag-2.c, gcc.dg/tls/diag-3.c, gcc.dg/tls/diag-4.c,\ngcc.dg/tls/diag-5.c, gcc.dg/tls/init-1.c, gcc.dg/tls/nonpic-1.c,\ngcc.dg/tls/opt-10.c, gcc.dg/tls/opt-5.c, gcc.dg/tls/opt-6.c,\ngcc.dg/tls/opt-8.c, gcc.dg/tls/opt-9.c, gcc.dg/tls/pic-1.c,\ngcc.dg/tls/struct-1.c, gcc.dg/tls/trivial.c: Likewise.\n\nFrom-SVN: r121800", "tree": {"sha": "19408e7a99094abe8a3e2baccde7b48302195b0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19408e7a99094abe8a3e2baccde7b48302195b0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/comments", "author": null, "committer": null, "parents": [{"sha": "ba9652fcb40c232e43a5d2e96843847932e3784b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9652fcb40c232e43a5d2e96843847932e3784b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9652fcb40c232e43a5d2e96843847932e3784b"}], "stats": {"total": 759, "additions": 677, "deletions": 82}, "files": [{"sha": "22d12f55f10d85ec80e0d1a4df15d518c6acc55a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,3 +1,40 @@\n+2007-02-10  Richard Henderson  <rth@redhat.com>, Jakub Jelinek  <jakub@redhat.com>, Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* Makefile.in (libgcc-support, libgcc.mvars): Add emutls.c.\n+\t* builtin-types.def (BT_WORD): Make unsigned.\n+\t(BT_FN_VOID_PTR_WORD_WORD_PTR): New.\n+\t* builtins.def (BUILT_IN_EMUTLS_GET_ADDRESS): New.\n+\t(BUILT_IN_EMUTLS_REGISTER_COMMON): New.\n+\t* c-decl.c (grokdeclarator): Don't error if !have_tls.\n+\t* c-parser.c (c_parser_omp_threadprivate): Likewise.\n+\t* dwarf2out.c (loc_descriptor_from_tree_1): Don't do anything for\n+\temulated tls.\n+\t* expr.c (emutls_var_address): New.\n+\t(expand_expr_real_1): Expand emulated tls.\n+\t(expand_expr_addr_expr_1): Likewise.\n+\t* libgcc-std.ver: Add __emutls_get_address, __emutls_register_common.\n+\t* output.h (emutls_finish): Declare.\n+\t* toplev.c (compile_file): Call it.\n+\t* tree-ssa-address.c (gen_addr_rtx): Check for const-ness of the\n+\taddress before wrapping in CONST.\n+\t* varasm.c (emutls_htab, emutls_object_type): New.\n+\t(EMUTLS_VAR_PREFIX, EMUTLS_TMPL_PREFIX): New.\n+\t(get_emutls_object_name, get_emutls_object_type): New.\n+\t(get_emutls_init_templ_addr, emutls_decl): New.\n+\t(emutls_common_1, emutls_finish): New.\n+\t(assemble_variable): When emulating tls, swap decls; generate\n+\tconstructor for the emutls objects.\n+\t(do_assemble_alias): When emulating tls, swap decl and target name.\n+\t(default_encode_section_info): Don't add SYMBOL_FLAG_TLS_SHIFT\n+\tfor emulated tls.\n+\t* varpool.c (decide_is_variable_needed): Look at force_output.\n+\tRecurse for emulated tls.\n+\t(cgraph_varpool_remove_unreferenced_decls): Remove checks redundant\n+\twith decide_is_variable_needed.\n+\t* emutls.c: New file.\n+\t* config/sparc/sol2.h (ASM_DECLARE_OBJECT_NAME): Only emit\n+\ttls_object for real tls.\n+\n 2007-02-10  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR rtl-optimization/29599"}, {"sha": "7bb1434b0e9722c1053658f89baad5ee334fa213", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1566,7 +1566,7 @@ GCC_EXTRA_PARTS := $(sort $(EXTRA_MULTILIB_PARTS) $(EXTRA_PARTS))\n \n libgcc-support: libgcc.mvars stmp-int-hdrs $(STMP_FIXPROTO) $(TCONFIG_H) \\\n \t$(MACHMODE_H) $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \\\n-\t$(LIB2ADD_ST) $(LIB2ADDEH) gcov-iov.h $(SFP_MACHINE)\n+\t$(LIB2ADD_ST) $(LIB2ADDEH) $(srcdir)/emutls.c gcov-iov.h $(SFP_MACHINE)\n \n libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs \\\n \t\txgcc$(exeext) stamp-as stamp-collect-ld stamp-nm\n@@ -1578,9 +1578,9 @@ libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs \\\n \techo LIBGCOV = '$(LIBGCOV)' >> tmp-libgcc.mvars\n \techo LIB2ADD = '$(call srcdirify,$(LIB2ADD))' >> tmp-libgcc.mvars\n \techo LIB2ADD_ST = '$(call srcdirify,$(LIB2ADD_ST))' >> tmp-libgcc.mvars\n-\techo LIB2ADDEH = '$(call srcdirify,$(LIB2ADDEH))' >> tmp-libgcc.mvars\n-\techo LIB2ADDEHSTATIC = '$(call srcdirify,$(LIB2ADDEHSTATIC))' >> tmp-libgcc.mvars\n-\techo LIB2ADDEHSHARED = '$(call srcdirify,$(LIB2ADDEHSHARED))' >> tmp-libgcc.mvars\n+\techo LIB2ADDEH = '$(call srcdirify,$(LIB2ADDEH) $(srcdir)/emutls.c)' >> tmp-libgcc.mvars\n+\techo LIB2ADDEHSTATIC = '$(call srcdirify,$(LIB2ADDEHSTATIC) $(srcdir)/emutls.c)' >> tmp-libgcc.mvars\n+\techo LIB2ADDEHSHARED = '$(call srcdirify,$(LIB2ADDEHSHARED) $(srcdir)/emutls.c)' >> tmp-libgcc.mvars\n \techo LIB2_SIDITI_CONV_FUNCS = '$(LIB2_SIDITI_CONV_FUNCS)' >> tmp-libgcc.mvars\n \techo LIBUNWIND = '$(call srcdirify,$(LIBUNWIND))' >> tmp-libgcc.mvars\n \techo SHLIBUNWIND_LINK = '$(SHLIBUNWIND_LINK)' >> tmp-libgcc.mvars"}, {"sha": "ea0ff8e915ec1d948e55e29f25f9b8fbc1ab711f", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -77,7 +77,7 @@ DEF_PRIMITIVE_TYPE (BT_INTMAX, intmax_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINTMAX, uintmax_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINT32, uint32_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINT64, uint64_type_node)\n-DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 0))\n+DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 1))\n DEF_PRIMITIVE_TYPE (BT_FLOAT, float_type_node)\n DEF_PRIMITIVE_TYPE (BT_DOUBLE, double_type_node)\n DEF_PRIMITIVE_TYPE (BT_LONGDOUBLE, long_double_type_node)\n@@ -388,6 +388,8 @@ DEF_FUNCTION_TYPE_4 (BT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_FILEPTR, BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_PTR_WORD_WORD_PTR,\n+\t\t     BT_VOID, BT_PTR, BT_WORD, BT_WORD, BT_PTR)\n \n DEF_FUNCTION_TYPE_5 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING,"}, {"sha": "48c97bf912ee12e737d3cc71f2f9ad35ba0fa5b7", "filename": "gcc/builtins.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions and documentation for the\n    builtins used in the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -729,6 +729,10 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_VPRINTF_CHK, \"__vprintf_chk\", BT_FN_INT_INT_CON\n DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_ENTER, \"profile_func_enter\")\n DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, \"profile_func_exit\")\n \n+/* TLS emulation.  */\n+DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, \"__emutls_get_address\", BT_FN_PTR_PTR, ATTR_CONST_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON, \"__emutls_register_common\", BT_FN_VOID_PTR_WORD_WORD_PTR, ATTR_NOTHROW_LIST)\n+\n /* Synchronization Primitives.  */\n #include \"sync-builtins.def\"\n "}, {"sha": "648c805828d77a2ed41fcc7cb6d7c09af83bb6af", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -4927,14 +4927,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  }\n \n \tif (threadp)\n-\t  {\n-\t    if (targetm.have_tls)\n-\t      DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n-\t    else\n-\t      /* A mere warning is sure to result in improper semantics\n-\t\t at runtime.  Don't bother to allow this to compile.  */\n-\t      error (\"thread-local storage not supported for this target\");\n-\t  }\n+\t  DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n       }\n \n     if (storage_class == csc_extern"}, {"sha": "665b494e231cb2f91139013eda6959ff2522f2b3", "filename": "gcc/c-parser.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -7783,9 +7783,6 @@ c_parser_omp_threadprivate (c_parser *parser)\n   c_parser_consume_pragma (parser);\n   vars = c_parser_omp_var_list_parens (parser, 0, NULL);\n \n-  if (!targetm.have_tls)\n-    sorry (\"threadprivate variables not supported in this target\");\n-\n   /* Mark every variable in VARS to be assigned thread local storage.  */\n   for (t = vars; t; t = TREE_CHAIN (t))\n     {"}, {"sha": "7a79a7d711235dda364519e22fc40f1566546237", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -89,7 +89,7 @@ Boston, MA 02110-1301, USA.  */\n     {\t\t\t\t\t\t\t\t\\\n       HOST_WIDE_INT size;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-      if (DECL_THREAD_LOCAL_P (DECL))\t\t\t\t\\\n+      if (targetm.have_tls && DECL_THREAD_LOCAL_P (DECL))\t\\\n \tASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"tls_object\");\t\\\n       else\t\t\t\t\t\t\t\\\n \tASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\\"}, {"sha": "557391079450ffe95f81465b10dabf561c21de54", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,3 +1,9 @@\n+2007-02-10  Richard Henderson  <rth@redhat.com>, Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* decl.c (grokvardecl): Don't error if !have_tls.\n+\t(grokdeclarator): Likewise.\n+\t* parser.c (cp_parser_omp_threadprivate): Likewise.\n+\n 2007-02-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/30703"}, {"sha": "b6d0e5387f7873d97c37649e97dfbfe376ce068f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -6363,14 +6363,7 @@ grokvardecl (tree type,\n     }\n \n   if (declspecs->specs[(int)ds_thread])\n-    {\n-      if (targetm.have_tls)\n-\tDECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n-      else\n-\t/* A mere warning is sure to result in improper semantics\n-\t   at runtime.  Don't bother to allow this to compile.  */\n-\terror (\"thread-local storage not supported for this target\");\n-    }\n+    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n \n   if (TREE_PUBLIC (decl))\n     {\n@@ -8539,15 +8532,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tDECL_EXTERNAL (decl) = 1;\n \n \t\tif (thread_p)\n-\t\t  {\n-\t\t    if (targetm.have_tls)\n-\t\t      DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n-\t\t    else\n-\t\t      /* A mere warning is sure to result in improper\n-\t\t\t semantics at runtime.  Don't bother to allow this to\n-\t\t\t compile.  */\n-\t\t      error (\"thread-local storage not supported for this target\");\n-\t\t  }\n+\t\t  DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n \t      }\n \t    else\n \t      {"}, {"sha": "8e130b64cfd4af426990e7da882a77b3e4242f68", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -19312,9 +19312,6 @@ cp_parser_omp_threadprivate (cp_parser *parser, cp_token *pragma_tok)\n   vars = cp_parser_omp_var_list (parser, 0, NULL);\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n-  if (!targetm.have_tls)\n-    sorry (\"threadprivate variables not supported in this target\");\n-\n   finish_omp_threadprivate (vars);\n }\n "}, {"sha": "5516f3f2617c1fb490f13e33ceb1dcff48718ae7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -9226,7 +9226,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t  rtx rtl;\n \n \t  /* If this is not defined, we have no way to emit the data.  */\n-\t  if (!targetm.asm_out.output_dwarf_dtprel)\n+\t  if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)\n \t    return 0;\n \n \t  /* The way DW_OP_GNU_push_tls_address is specified, we can only"}, {"sha": "f26d21772e3907607352891f604ca8b6fe13dfc7", "filename": "gcc/emutls.c", "status": "modified", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Femutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Femutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femutls.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -0,0 +1,193 @@\n+/* TLS emulation.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"gthr.h\"\n+\n+typedef unsigned int word __attribute__((mode(word)));\n+typedef unsigned int pointer __attribute__((mode(pointer)));\n+\n+struct __emutls_object\n+{\n+  word size;\n+  word align;\n+  union {\n+    pointer offset;\n+    void *ptr;\n+  } loc;\n+  void *templ;\n+};\n+\n+#ifdef __GTHREADS\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t emutls_mutex = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t emutls_mutex;\n+#endif\n+static __gthread_key_t emutls_key;\n+static pointer emutls_size;\n+\n+static void\n+emutls_destroy (void *ptr)\n+{\n+  void ***arr = (void ***) ptr;\n+  unsigned long int size = (unsigned long int) arr[0];\n+  ++arr;\n+  while (--size)\n+    {\n+      if (*arr)\n+\tfree ((*arr)[-1]);\n+      ++arr;\n+    }\n+  free (ptr);\n+}\n+\n+static void\n+emutls_init (void)\n+{\n+#ifndef __GTHREAD_MUTEX_INIT\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&emutls_mutex);\n+#endif\n+  if (__gthread_key_create (&emutls_key, emutls_destroy) != 0)\n+    abort ();\n+}\n+#endif\n+\n+static void *\n+emutls_alloc (struct __emutls_object *obj)\n+{\n+  void *ptr;\n+  void *ret;\n+\n+  /* We could use here posix_memalign if available and adjust\n+     emutls_destroy accordingly.  */\n+  if (obj->align <= sizeof (void *))\n+    {\n+      ptr = malloc (obj->size + sizeof (void *));\n+      if (ptr == NULL)\n+\tabort ();\n+      ((void **) ptr)[0] = ptr;\n+      ret = ptr + sizeof (void *);\n+    }\n+  else\n+    {\n+      ptr = malloc (obj->size + sizeof (void *) + obj->align - 1);\n+      if (ptr == NULL)\n+\tabort ();\n+      ret = (void *) (((pointer) (ptr + sizeof (void *) + obj->align - 1))\n+\t\t      & ~(pointer)(obj->align - 1));\n+      ((void **) ret)[-1] = ptr;\n+    }\n+\n+  if (obj->templ)\n+    memcpy (ret, obj->templ, obj->size);\n+  else\n+    memset (ret, 0, obj->size);\n+\n+  return ret;\n+}\n+\n+void *\n+__emutls_get_address (struct __emutls_object *obj)\n+{\n+  if (! __gthread_active_p ())\n+    {\n+      if (__builtin_expect (obj->loc.ptr == NULL, 0))\n+\tobj->loc.ptr = emutls_alloc (obj);\n+      return obj->loc.ptr;\n+    }\n+\n+#ifndef __GTHREADS\n+  abort ();\n+#else\n+  pointer offset;\n+\n+  if (__builtin_expect (obj->loc.offset == 0, 0))\n+    {\n+      static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+      __gthread_once (&once, emutls_init);\n+      __gthread_mutex_lock (&emutls_mutex);\n+      offset = ++emutls_size;\n+      obj->loc.offset = offset;\n+      __gthread_mutex_unlock (&emutls_mutex);\n+    }\n+  else\n+    offset = obj->loc.offset;\n+\n+  void **arr = (void **) __gthread_getspecific (emutls_key);\n+  if (__builtin_expect (arr == NULL, 0))\n+    {\n+      pointer size = offset + 32;\n+      arr = calloc (size, sizeof (void *));\n+      if (arr == NULL)\n+\tabort ();\n+      arr[0] = (void *) size;\n+      __gthread_setspecific (emutls_key, (void *) arr);\n+    }\n+  else if (__builtin_expect (offset >= (pointer) arr[0], 0))\n+    {\n+      pointer orig_size = (pointer) arr[0];\n+      pointer size = orig_size * 2;\n+      if (offset >= size)\n+\tsize = offset + 32;\n+      arr = realloc (arr, size * sizeof (void *));\n+      if (arr == NULL)\n+\tabort ();\n+      memset (arr + orig_size, 0, (size - orig_size) * sizeof (void *));\n+      __gthread_setspecific (emutls_key, (void *) arr);\n+    }\n+\n+  void *ret = arr[offset];\n+  if (__builtin_expect (ret == NULL, 0))\n+    {\n+      ret = emutls_alloc (obj);\n+      arr[offset] = ret;\n+    }\n+  return ret;\n+#endif\n+}\n+\n+void\n+__emutls_register_common (struct __emutls_object *obj,\n+\t\t\t  word size, word align, void *templ)\n+{\n+  if (obj->size < size)\n+    {\n+      obj->size = size;\n+      obj->templ = NULL;\n+    }\n+  if (obj->align < align)\n+    obj->align = align;\n+  if (templ && size == obj->size)\n+    obj->templ = templ;\n+}"}, {"sha": "09a67891eef8b3fb95b260d3d50c9052e0930ad0", "filename": "gcc/expr.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -6421,6 +6421,19 @@ highest_pow2_factor_for_target (tree target, tree exp)\n   return MAX (factor, target_align);\n }\n \f\n+/* Return &VAR expression for emulated thread local VAR.  */\n+\n+static tree\n+emutls_var_address (tree var)\n+{\n+  tree emuvar = emutls_decl (var);\n+  tree fn = built_in_decls [BUILT_IN_EMUTLS_GET_ADDRESS];\n+  tree arg = build_fold_addr_expr_with_type (emuvar, ptr_type_node);\n+  tree arglist = build_tree_list (NULL_TREE, arg);\n+  tree call = build_function_call_expr (fn, arglist);\n+  return fold_convert (build_pointer_type (TREE_TYPE (var)), call);\n+}\n+\f\n /* Expands variable VAR.  */\n \n void\n@@ -6549,6 +6562,18 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n       inner = TREE_OPERAND (exp, 0);\n       break;\n \n+    case VAR_DECL:\n+      /* TLS emulation hook - replace __thread VAR's &VAR with\n+\t __emutls_get_address (&_emutls.VAR).  */\n+      if (! targetm.have_tls\n+\t  && TREE_CODE (exp) == VAR_DECL\n+\t  && DECL_THREAD_LOCAL_P (exp))\n+\t{\n+\t  exp = emutls_var_address (exp);\n+\t  return expand_expr (exp, target, tmode, modifier);\n+\t}\n+      /* Fall through.  */\n+\n     default:\n       /* If the object is a DECL, then expand it for its rtl.  Don't bypass\n \t expand_expr, as that can have various side effects; LABEL_DECLs for\n@@ -6924,6 +6949,16 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n \tlayout_decl (exp, 0);\n \n+      /* TLS emulation hook - replace __thread vars with\n+\t *__emutls_get_address (&_emutls.var).  */\n+      if (! targetm.have_tls\n+\t  && TREE_CODE (exp) == VAR_DECL\n+\t  && DECL_THREAD_LOCAL_P (exp))\n+\t{\n+\t  exp = build_fold_indirect_ref (emutls_var_address (exp));\n+\t  return expand_expr_real_1 (exp, target, tmode, modifier, NULL);\n+\t}\n+\n       /* ... fall through ...  */\n \n     case FUNCTION_DECL:"}, {"sha": "a0cf78f670b05c674067826c2a31975af64c8539", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,3 +1,13 @@\n+2007-02-10  Richard Henderson  <rth@redhat.com>, Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* f95-lang.c (gfc_init_builtin_functions): Add __emutls_get_address\n+\tand __emutls_register_common.\n+\t* openmp.c (gfc_match_omp_threadprivate): Don't error if !have_tls.\n+\t* trans-common.c (build_common_decl): Don't check have_tls.\n+\t* trans-decl.c (gfc_finish_var_decl): Likewise.\n+\t* types.def (BT_WORD, BT_FN_PTR_PTR): New.\n+\t(BT_FN_VOID_PTR_WORD_WORD_PTR): New.\n+\n 2007-02-09  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/30512"}, {"sha": "8f9c206c77f58249aa1bf8011a4a5fef15ea7a67", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1136,6 +1136,14 @@ gfc_init_builtin_functions (void)\n \t\t      BUILT_IN_TRAP, NULL, false);\n   TREE_THIS_VOLATILE (built_in_decls[BUILT_IN_TRAP]) = 1;\n \n+  gfc_define_builtin (\"__emutls_get_address\",\n+\t\t      builtin_types[BT_FN_PTR_PTR], BUILT_IN_EMUTLS_GET_ADDRESS,\n+\t\t      \"__emutls_get_address\", true);\n+  gfc_define_builtin (\"__emutls_register_common\",\n+\t\t      builtin_types[BT_FN_VOID_PTR_WORD_WORD_PTR],\n+\t\t      BUILT_IN_EMUTLS_REGISTER_COMMON,\n+\t\t      \"__emutls_register_common\", false);\n+\n   build_common_builtin_nodes ();\n   targetm.init_builtins ();\n }"}, {"sha": "42b5aa15dba7453ffcc71ea0d388f0e07a4554ef", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -469,12 +469,6 @@ gfc_match_omp_threadprivate (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (!targetm.have_tls)\n-    {\n-      sorry (\"threadprivate variables not supported in this target\");\n-      goto cleanup;\n-    }\n-\n   for (;;)\n     {\n       m = gfc_match_symbol (&sym, 0);"}, {"sha": "ea73537471e2fc82c09fe379c940d11160c500c4", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -388,7 +388,7 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n \n       gfc_set_decl_location (decl, &com->where);\n \n-      if (com->threadprivate && targetm.have_tls)\n+      if (com->threadprivate)\n \tDECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n \n       /* Place the back end declaration for this common block in"}, {"sha": "1bf11e30c29a78e8d92947ae35be933917baea1f", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -538,7 +538,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n     TREE_STATIC (decl) = 1;\n \n   /* Handle threadprivate variables.  */\n-  if (sym->attr.threadprivate && targetm.have_tls\n+  if (sym->attr.threadprivate\n       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n }"}, {"sha": "0abd8459d967a6f5e67e41e49fc129d531455c35", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -55,6 +55,7 @@ DEF_PRIMITIVE_TYPE (BT_BOOL, boolean_type_node)\n DEF_PRIMITIVE_TYPE (BT_INT, integer_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINT, unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_LONG, long_integer_type_node)\n+DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 1))\n \n DEF_PRIMITIVE_TYPE (BT_I1, builtin_type_for_size (BITS_PER_UNIT*1, 1))\n DEF_PRIMITIVE_TYPE (BT_I2, builtin_type_for_size (BITS_PER_UNIT*2, 1))\n@@ -81,6 +82,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTR, BT_VOID, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTRPTR, BT_VOID, BT_PTR_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n@@ -113,6 +115,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_OMPFN_PTR_UINT, BT_VOID, BT_PTR_FN_VOID_PTR,\n \n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_PTR_WORD_WORD_PTR,\n+\t\t     BT_VOID, BT_PTR, BT_WORD, BT_WORD, BT_PTR)\n \n DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n                      BT_BOOL, BT_LONG, BT_LONG, BT_LONG,"}, {"sha": "4b707944e80d8818dc4c99c05f50b18ee98401f7", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -280,4 +280,6 @@ GCC_4.3.0 {\n   # byte swapping routines\n   __bswapsi2\n   __bswapdi2\n+  __emutls_get_address\n+  __emutls_register_common\n }"}, {"sha": "4e7ccf61308b74d5d170bacb488fc3ca4d6cd515", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -158,6 +158,9 @@ extern void merge_weak (tree, tree);\n /* Emit any pending weak declarations.  */\n extern void weak_finish (void);\n \n+/* Emit any pending emutls declarations and initializations.  */\n+extern void emutls_finish (void);\n+\n /* Decode an `asm' spec for a declaration as a register name.\n    Return the register number, or -1 if nothing specified,\n    or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,"}, {"sha": "0998a3085222254a053a486f7212ac660330018e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,3 +1,15 @@\n+2007-02-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_tls): Redefine\n+\tto mean non-emulated tls.\n+\t* gcc.dg/tls/alias-1.c: Remove tls requirement.\n+\t* gcc.dg/tls/asm-1.c, gcc.dg/tls/debug-1.c, gcc.dg/tls/diag-1.c,\n+\tgcc.dg/tls/diag-2.c, gcc.dg/tls/diag-3.c, gcc.dg/tls/diag-4.c,\n+\tgcc.dg/tls/diag-5.c, gcc.dg/tls/init-1.c, gcc.dg/tls/nonpic-1.c,\n+\tgcc.dg/tls/opt-10.c, gcc.dg/tls/opt-5.c, gcc.dg/tls/opt-6.c,\n+\tgcc.dg/tls/opt-8.c, gcc.dg/tls/opt-9.c, gcc.dg/tls/pic-1.c,\n+\tgcc.dg/tls/struct-1.c, gcc.dg/tls/trivial.c: Likewise.\n+\n 2007-02-10  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* gcc.dg/tree-ssa/loop-25.c: Verify the result in the profile pass."}, {"sha": "1098190ebd04acb16f6b7a7f690f28048b39601b", "filename": "gcc/testsuite/gcc.dg/tls/alias-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Falias-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Falias-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Falias-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do link } */\n /* { dg-require-alias \"\" } */\n /* { dg-require-visibility \"\" } */\n-/* { dg-require-effective-target tls } */\n /* Test that encode_section_info handles the change from externally\n    defined to locally defined (via hidden).   Extracted from glibc.  */\n "}, {"sha": "476fe7cbb72e5c792cdd0f1a8a15f05081d60d25", "filename": "gcc/testsuite/gcc.dg/tls/asm-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fasm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fasm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fasm-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,4 @@\n /* { dg-options \"-Werror\" } */\n-/* { dg-require-effective-target tls } */\n __thread int i;\n \n int foo ()"}, {"sha": "719f0645771ae608dbe6dbb655163f86f4e74938", "filename": "gcc/testsuite/gcc.dg/tls/debug-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdebug-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdebug-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdebug-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do assemble } */\n /* { dg-options \"-g\" } */\n-/* { dg-require-effective-target tls } */\n \n __thread int i;"}, {"sha": "ae4f3d4a3c28c7e9b21f58724078572f5fc2b020", "filename": "gcc/testsuite/gcc.dg/tls/diag-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,4 @@\n /* Valid __thread specifiers.  */\n-/* { dg-require-effective-target tls } */\n \n __thread int g1;\n extern __thread int g2;"}, {"sha": "5e7e17bee5ab64144f2c64ef8bff08a66fa364f9", "filename": "gcc/testsuite/gcc.dg/tls/diag-2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-2.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,4 @@\n /* Invalid __thread specifiers.  */\n-/* { dg-require-effective-target tls } */\n \n __thread extern int g1;\t\t/* { dg-error \"'__thread' before 'extern'\" } */\n __thread static int g2;\t\t/* { dg-error \"'__thread' before 'static'\" } */"}, {"sha": "f1ce06b70d8f8e6c406a0e19b0fc4a928b89c11c", "filename": "gcc/testsuite/gcc.dg/tls/diag-3.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-3.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,4 @@\n /* Report invalid extern and __thread combinations.  */\n-/* { dg-require-effective-target tls } */\n \n extern int j;\t\t/* { dg-error \"previous declaration\" } */\n __thread int j;\t\t/* { dg-error \"follows non-thread-local\" } */"}, {"sha": "df3705d04ee2f1f3c6f4ff621cff7016ccf1efe9", "filename": "gcc/testsuite/gcc.dg/tls/diag-4.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-4.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,5 @@\n /* Invalid __thread specifiers.  As diag-4.c but some cases in\n    different orders.  */\n-/* { dg-require-effective-target tls } */\n \n __thread typedef int g4;\t/* { dg-error \"'__thread' used with 'typedef'\" } */\n "}, {"sha": "623832c3812f5e6bd5a49af0732fdf013260fadd", "filename": "gcc/testsuite/gcc.dg/tls/diag-5.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fdiag-5.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,4 +1,3 @@\n /* __thread specifiers on empty declarations.  */\n-/* { dg-require-effective-target tls } */\n \n __thread struct foo; /* { dg-warning \"warning: useless '__thread' in empty declaration\" } */"}, {"sha": "97258643bf2807b56996fb09c72f594501489947", "filename": "gcc/testsuite/gcc.dg/tls/init-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Finit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Finit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Finit-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,4 @@\n /* Invalid initializations.  */\n-/* { dg-require-effective-target tls } */\n \n extern __thread int i;\n int *p = &i;\t/* { dg-error \"initializer element is not constant\" } */"}, {"sha": "0896df60b56533c9ca475f02e4c4479d71973450", "filename": "gcc/testsuite/gcc.dg/tls/nonpic-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fnonpic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fnonpic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fnonpic-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -ftls-model=initial-exec\" } */\n-/* { dg-require-effective-target tls } */\n \n extern __thread long e1;\n extern __thread int e2;"}, {"sha": "f31c1fff81627259fd9b1924035beab49c757a44", "filename": "gcc/testsuite/gcc.dg/tls/opt-10.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-10.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-options \"-O3 -fpic\" } */\n-/* { dg-require-effective-target tls } */\n \n /* The web pass was creating unrecognisable pic_load_dot_plus_four insns\n    on ARM.  */"}, {"sha": "d8a686ddb462037366c09972a836caa7e8d0709d", "filename": "gcc/testsuite/gcc.dg/tls/opt-5.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-5.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n-/* { dg-require-effective-target tls } */\n /* Sched1 moved {load_tp} pattern between strlen call and the copy\n    of the hard return value to its pseudo.  This resulted in a\n    reload abort, since the hard register was not spillable.  */"}, {"sha": "de04c1cb3fc494822ef279b9f1fc124919dfbe76", "filename": "gcc/testsuite/gcc.dg/tls/opt-6.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-6.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n-/* { dg-require-effective-target tls } */\n \n extern void abort (void);\n extern void exit (int);"}, {"sha": "dec0eabcb4ce749ebeb4dbb356cc3113bbc800eb", "filename": "gcc/testsuite/gcc.dg/tls/opt-8.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-8.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,7 +1,6 @@\n /* PR 18910 */\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n-/* { dg-require-effective-target tls } */\n \n static __thread void *foo [2];\n void"}, {"sha": "3829c66fc559e93c9b874427d55fedfff8fde0d2", "filename": "gcc/testsuite/gcc.dg/tls/opt-9.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-9.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,7 +1,6 @@\n /* PR 21412 */\n /* { dg-do compile */\n /* { dg-options \"-O2 -fPIC\" } */\n-/* { dg-require-effective-target tls } */\n \n struct S { int x[10]; };\n extern __thread struct S s;"}, {"sha": "f5b020b7db601f4434df35b29720ce607b4a44e9", "filename": "gcc/testsuite/gcc.dg/tls/pic-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fpic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fpic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fpic-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fpic -ftls-model=global-dynamic\" } */\n-/* { dg-require-effective-target tls } */\n \n extern __thread long e1;\n extern __thread int e2;"}, {"sha": "11151236d90716ffb5d54e29afa493560402c186", "filename": "gcc/testsuite/gcc.dg/tls/struct-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fstruct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fstruct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fstruct-1.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -2,7 +2,6 @@\n    to allow addends for @dtpoff relocs or not.  */\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fpic\" } */\n-/* { dg-require-effective-target tls } */\n \n struct S {\n   int s0, s1, s2, s3;"}, {"sha": "1fd70631f33b78379c81232b8e5e8f8ab1094618", "filename": "gcc/testsuite/gcc.dg/tls/trivial.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Ftrivial.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Ftrivial.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Ftrivial.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,3 +1 @@\n-/* { dg-require-effective-target tls } */\n-\n __thread int i;"}, {"sha": "ec63866614e83cc4db6f97463f4f3f7f030ea333", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -384,7 +384,7 @@ proc check_effective_target_pcc_bitfield_type_matters { } {\n     }]\n }\n \n-# Return 1 if thread local storage (TLS) is supported, 0 otherwise.\n+# Return 1 if *native* thread local storage (TLS) is supported, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n@@ -406,11 +406,19 @@ proc check_effective_target_tls {} {\n \tclose $f\n \n \t# Test for thread-local data supported by the platform.\n-\tset comp_output \\\n-\t    [${tool}_target_compile $src $asm assembly \"\"]\n+\tset comp_output [${tool}_target_compile $src $asm assembly \"\"]\n \tfile delete $src\n \tif { [string match \"*not supported*\" $comp_output] } {\n \t    set et_tls_saved 0\n+\t} else {\n+\t    set fd [open $asm r]\n+\t    set text [read $fd]\n+\t    close $fd\n+\t    if { [string match \"*emutls*\" $text]} {\n+\t\tset et_tls_saved 0\n+\t    } else {\n+\t\tset et_tls_saved 1\n+\t    }\n \t}\n \tremove-build-file $asm\n     }"}, {"sha": "4ad6f1d983e5f08bb6c54d67d9b9d4cadc8fd9ba", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1048,11 +1048,14 @@ compile_file (void)\n   if (flag_mudflap)\n     mudflap_finish_file ();\n \n+  /* Likewise for emulated thread-local storage.  */\n+  if (!targetm.have_tls)\n+    emutls_finish ();\n+\n   output_shared_constant_pool ();\n   output_object_blocks ();\n \n   /* Write out any pending weak symbol declarations.  */\n-\n   weak_finish ();\n \n   /* Do dbx symbols.  */"}, {"sha": "ef3bfb7cbfb67b314feb67b6d7838e8b7a09f3ee", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,5 @@\n /* Memory address lowering and addressing mode selection.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2006 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -135,10 +135,15 @@ gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n       act_elem = symbol;\n       if (offset)\n \t{\n-\t  act_elem = gen_rtx_CONST (Pmode,\n-\t\t\t\t    gen_rtx_PLUS (Pmode, act_elem, offset));\n+\t  act_elem = gen_rtx_PLUS (Pmode, act_elem, offset);\n+\n \t  if (offset_p)\n-\t    *offset_p = &XEXP (XEXP (act_elem, 0), 1);\n+\t    *offset_p = &XEXP (act_elem, 1);\n+\n+\t  if (GET_CODE (symbol) == SYMBOL_REF\n+\t      || GET_CODE (symbol) == LABEL_REF\n+\t      || GET_CODE (symbol) == CONST)\n+\t    act_elem = gen_rtx_CONST (Pmode, act_elem);\n \t}\n \n       if (*addr)"}, {"sha": "26e0676d0c22244eb956489e5574516f1493504e", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -4599,6 +4599,7 @@ extern void set_user_assembler_name (tree, const char *);\n extern void process_pending_assemble_externals (void);\n extern void finish_aliases_1 (void);\n extern void finish_aliases_2 (void);\n+extern tree emutls_decl (tree);\n \n /* In stmt.c */\n extern void expand_computed_goto (tree);"}, {"sha": "48aba4e4a16b65349492f874ff4d0f3dd69bd56d", "filename": "gcc/varasm.c", "status": "modified", "additions": 309, "deletions": 2, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,6 +1,6 @@\n /* Output variables, constants and external declarations, for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -53,6 +53,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cgraph.h\"\n #include \"cfglayout.h\"\n #include \"basic-block.h\"\n+#include \"tree-iterator.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -199,6 +200,242 @@ static GTY(()) int anchor_labelno;\n /* A pool of constants that can be shared between functions.  */\n static GTY(()) struct rtx_constant_pool *shared_constant_pool;\n \n+/* TLS emulation.  */\n+\n+static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n+     htab_t emutls_htab;\n+static GTY (()) tree emutls_object_type;\n+\n+#ifndef NO_DOT_IN_LABEL\n+# define EMUTLS_VAR_PREFIX\t\"__emutls_v.\"\n+# define EMUTLS_TMPL_PREFIX\t\"__emutls_t.\"\n+#elif !defined NO_DOLLAR_IN_LABEL\n+# define EMUTLS_VAR_PREFIX\t\"__emutls_v$\"\n+# define EMUTLS_TMPL_PREFIX\t\"__emutls_t$\"\n+#else\n+# define EMUTLS_VAR_PREFIX\t\"__emutls_v_\"\n+# define EMUTLS_TMPL_PREFIX\t\"__emutls_t_\"\n+#endif\n+\n+/* Create an identifier for the struct __emutls_object, given an identifier\n+   of the DECL_ASSEMBLY_NAME of the original object.  */\n+\n+static tree\n+get_emutls_object_name (tree name)\n+{\n+  char *toname = alloca (strlen (IDENTIFIER_POINTER (name))\n+\t\t\t + sizeof (EMUTLS_VAR_PREFIX));\n+  strcpy (toname, EMUTLS_VAR_PREFIX);\n+  strcpy (toname + sizeof (EMUTLS_VAR_PREFIX) - 1, IDENTIFIER_POINTER (name));\n+\n+  return get_identifier (toname);\n+}\n+\n+/* Create the structure for struct __emutls_object.  This should match the\n+   structure at the top of emutls.c, modulo the union there.  */\n+\n+static tree\n+get_emutls_object_type (void)\n+{\n+  tree type, type_name, field, next_field, word_type_node;\n+\n+  type = emutls_object_type;\n+  if (type)\n+    return type;\n+\n+  emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);\n+  type_name = get_identifier (\"__emutls_object\");\n+  type_name = build_decl (TYPE_DECL, type_name, type);\n+  TYPE_NAME (type) = type_name;\n+\n+  field = build_decl (FIELD_DECL, get_identifier (\"__templ\"), ptr_type_node);\n+  DECL_CONTEXT (field) = type;\n+  next_field = field;\n+\n+  field = build_decl (FIELD_DECL, get_identifier (\"__offset\"), ptr_type_node);\n+  DECL_CONTEXT (field) = type;\n+  TREE_CHAIN (field) = next_field;\n+  next_field = field;\n+\n+  word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n+  field = build_decl (FIELD_DECL, get_identifier (\"__align\"), word_type_node);\n+  DECL_CONTEXT (field) = type;\n+  TREE_CHAIN (field) = next_field;\n+  next_field = field;\n+\n+  field = build_decl (FIELD_DECL, get_identifier (\"__size\"), word_type_node);\n+  DECL_CONTEXT (field) = type;\n+  TREE_CHAIN (field) = next_field;\n+\n+  TYPE_FIELDS (type) = field;\n+  layout_type (type);\n+\n+  return type;\n+}\n+\n+/* Create a read-only variable like DECL, with the same DECL_INITIAL.\n+   This will be used for initializing the emulated tls data area.  */\n+\n+static tree\n+get_emutls_init_templ_addr (tree decl)\n+{\n+  tree name, to;\n+  char *toname;\n+\n+  if (!DECL_INITIAL (decl))\n+    return null_pointer_node;\n+\n+  name = DECL_ASSEMBLER_NAME (decl);\n+  toname = alloca (strlen (IDENTIFIER_POINTER (name))\n+\t\t   + sizeof (EMUTLS_TMPL_PREFIX));\n+  strcpy (toname, EMUTLS_TMPL_PREFIX);\n+  strcpy (toname + sizeof (EMUTLS_TMPL_PREFIX) - 1, IDENTIFIER_POINTER (name));\n+  name = get_identifier (toname);\n+\n+  to = build_decl (VAR_DECL, name, TREE_TYPE (decl));\n+  SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n+\n+  DECL_ARTIFICIAL (to) = 1;\n+  TREE_USED (to) = TREE_USED (decl);\n+  TREE_READONLY (to) = 1;\n+  DECL_IGNORED_P (to) = 1;\n+  DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n+  DECL_WEAK (to) = DECL_WEAK (decl);\n+  if (DECL_ONE_ONLY (decl))\n+    {\n+      make_decl_one_only (to);\n+      TREE_STATIC (to) = TREE_STATIC (decl);\n+      TREE_PUBLIC (to) = TREE_PUBLIC (decl);\n+      DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);\n+    }\n+  else\n+    TREE_STATIC (to) = 1;\n+\n+  DECL_INITIAL (to) = DECL_INITIAL (decl);\n+  DECL_INITIAL (decl) = NULL;\n+\n+  varpool_finalize_decl (to);\n+  return build_fold_addr_expr (to);\n+}\n+\n+/* When emulating tls, we use a control structure for use by the runtime.\n+   Create and return this structure.  */\n+\n+tree\n+emutls_decl (tree decl)\n+{\n+  tree name, to;\n+  struct tree_map *h, in;\n+  void **loc;\n+\n+  if (targetm.have_tls || decl == NULL || decl == error_mark_node\n+      || TREE_CODE (decl) != VAR_DECL || ! DECL_THREAD_LOCAL_P (decl))\n+    return decl;\n+\n+  /* Look up the object in the hash; return the control structure if\n+     it has already been created.  */\n+  if (! emutls_htab)\n+    emutls_htab = htab_create_ggc (512, tree_map_hash, tree_map_eq, 0);\n+\n+  name = DECL_ASSEMBLER_NAME (decl);\n+\n+  /* Note that we use the hash of the decl's name, rather than a hash\n+     of the decl's pointer.  In emutls_finish we iterate through the\n+     hash table, and we want this traversal to be predictable.  */\n+  in.hash = htab_hash_string (IDENTIFIER_POINTER (name));\n+  in.from = decl;\n+  loc = htab_find_slot_with_hash (emutls_htab, &in, in.hash, INSERT);\n+  h = *loc;\n+  if (h != NULL)\n+    to = h->to;\n+  else\n+    {\n+      to = build_decl (VAR_DECL, get_emutls_object_name (name),\n+\t\t       get_emutls_object_type ());\n+\n+      h = ggc_alloc (sizeof (struct tree_map));\n+      h->hash = in.hash;\n+      h->from = decl;\n+      h->to = to;\n+      *(struct tree_map **) loc = h;\n+\n+      DECL_ARTIFICIAL (to) = 1;\n+      DECL_IGNORED_P (to) = 1;\n+      TREE_READONLY (to) = 0;\n+\n+      SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n+      if (DECL_ONE_ONLY (decl))\n+\tmake_decl_one_only (to);\n+      DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n+    }\n+\n+  /* Note that these fields may need to be updated from time to time from\n+     the original decl.  Consider:\n+\textern __thread int i;\n+\tint foo() { return i; }\n+\t__thread int i = 1;\n+     in which I goes from external to locally defined and initialized.  */\n+\n+  TREE_STATIC (to) = TREE_STATIC (decl);\n+  TREE_USED (to) = TREE_USED (decl);\n+  TREE_PUBLIC (to) = TREE_PUBLIC (decl);\n+  DECL_EXTERNAL (to) = DECL_EXTERNAL (decl);\n+  DECL_COMMON (to) = DECL_COMMON (decl);\n+  DECL_WEAK (to) = DECL_WEAK (decl);\n+  DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);\n+\n+  return to;\n+}\n+\n+static int\n+emutls_common_1 (void **loc, void *xstmts)\n+{\n+  struct tree_map *h = *(struct tree_map **) loc;\n+  tree args, x, *pstmts = (tree *) xstmts;\n+  tree word_type_node;\n+\n+  if (! DECL_COMMON (h->from)\n+      || (DECL_INITIAL (h->from)\n+\t  && DECL_INITIAL (h->from) != error_mark_node))\n+    return 1;\n+\n+  word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n+\n+  /* The idea was to call get_emutls_init_templ_addr here, but if we\n+     do this and there is an initializer, -fanchor_section loses,\n+     because it would be too late to ensure the template is\n+     output.  */\n+  x = null_pointer_node;\n+  args = tree_cons (NULL, x, NULL);\n+  x = build_int_cst (word_type_node, DECL_ALIGN_UNIT (h->from));\n+  args = tree_cons (NULL, x, args);\n+  x = fold_convert (word_type_node, DECL_SIZE_UNIT (h->from));\n+  args = tree_cons (NULL, x, args);\n+  x = build_fold_addr_expr (h->to);\n+  args = tree_cons (NULL, x, args);\n+\n+  x = built_in_decls[BUILT_IN_EMUTLS_REGISTER_COMMON];\n+  x = build_function_call_expr (x, args);\n+\n+  append_to_statement_list (x, pstmts);\n+  return 1;\n+}\n+\n+void\n+emutls_finish (void)\n+{\n+  tree body = NULL_TREE;\n+\n+  if (emutls_htab == NULL)\n+    return;\n+\n+  htab_traverse_noresize (emutls_htab, emutls_common_1, &body);\n+  if (body == NULL_TREE)\n+    return;\n+\n+  cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);\n+}\n+\n /* Helper routines for maintaining section_htab.  */\n \n static int\n@@ -1733,6 +1970,59 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   rtx decl_rtl, symbol;\n   section *sect;\n \n+  if (! targetm.have_tls\n+      && TREE_CODE (decl) == VAR_DECL\n+      && DECL_THREAD_LOCAL_P (decl))\n+    {\n+      tree to = emutls_decl (decl);\n+\n+      /* If this variable is defined locally, then we need to initialize the\n+         control structure with size and alignment information.  We do this\n+\t at the last moment because tentative definitions can take a locally\n+\t defined but uninitialized variable and initialize it later, which\n+\t would result in incorrect contents.  */\n+      if (! DECL_EXTERNAL (to)\n+\t  && (! DECL_COMMON (to)\n+\t      || (DECL_INITIAL (decl)\n+\t\t  && DECL_INITIAL (decl) != error_mark_node)))\n+\t{\n+\t  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);\n+\t  constructor_elt *elt;\n+\t  tree type = TREE_TYPE (to);\n+\t  tree field = TYPE_FIELDS (type);\n+\n+\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n+\t  elt->index = field;\n+\t  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n+\n+\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n+\t  field = TREE_CHAIN (field);\n+\t  elt->index = field;\n+\t  elt->value = build_int_cst (TREE_TYPE (field),\n+\t\t\t\t      DECL_ALIGN_UNIT (decl));\n+\n+\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n+\t  field = TREE_CHAIN (field);\n+\t  elt->index = field;\n+\t  elt->value = null_pointer_node;\n+\n+\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n+\t  field = TREE_CHAIN (field);\n+\t  elt->index = field;\n+\t  elt->value = get_emutls_init_templ_addr (decl);\n+\n+\t  DECL_INITIAL (to) = build_constructor (type, v);\n+\n+\t  /* Make sure the template is marked as needed early enough.\n+\t     Without this, if the variable is placed in a\n+\t     section-anchored block, the template will only be marked\n+\t     when it's too late.  */\n+\t  record_references_in_initializer (to);\n+\t}\n+\n+      decl = to;\n+    }\n+\n   if (lang_hooks.decls.prepare_assemble_variable)\n     lang_hooks.decls.prepare_assemble_variable (decl);\n \n@@ -4856,6 +5146,14 @@ do_assemble_alias (tree decl, tree target)\n     {\n       ultimate_transparent_alias_target (&target);\n \n+      if (!targetm.have_tls\n+\t  && TREE_CODE (decl) == VAR_DECL\n+\t  && DECL_THREAD_LOCAL_P (decl))\n+\t{\n+\t  decl = emutls_decl (decl);\n+\t  target = get_emutls_object_name (target);\n+\t}\n+\n       if (!TREE_SYMBOL_REFERENCED (target))\n \tweakref_targets = tree_cons (decl, target, weakref_targets);\n \n@@ -4873,6 +5171,14 @@ do_assemble_alias (tree decl, tree target)\n       return;\n     }\n \n+  if (!targetm.have_tls\n+      && TREE_CODE (decl) == VAR_DECL\n+      && DECL_THREAD_LOCAL_P (decl))\n+    {\n+      decl = emutls_decl (decl);\n+      target = get_emutls_object_name (target);\n+    }\n+\n #ifdef ASM_OUTPUT_DEF\n   /* Make name accessible from other files, if appropriate.  */\n \n@@ -5760,7 +6066,8 @@ default_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n     flags |= SYMBOL_FLAG_FUNCTION;\n   if (targetm.binds_local_p (decl))\n     flags |= SYMBOL_FLAG_LOCAL;\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+  if (targetm.have_tls && TREE_CODE (decl) == VAR_DECL\n+      && DECL_THREAD_LOCAL_P (decl))\n     flags |= DECL_TLS_MODEL (decl) << SYMBOL_FLAG_TLS_SHIFT;\n   else if (targetm.in_small_data_p (decl))\n     flags |= SYMBOL_FLAG_SMALL;"}, {"sha": "65c22d491b427c62257a30f1e1b977bde7a62e65", "filename": "gcc/varpool.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8893239dc4ed32bd3bb4e00d6e43b859554ab82a/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=8893239dc4ed32bd3bb4e00d6e43b859554ab82a", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph handling code.\n-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n This file is part of GCC.\n@@ -218,7 +218,7 @@ bool\n decide_is_variable_needed (struct varpool_node *node, tree decl)\n {\n   /* If the user told us it is used, then it must be so.  */\n-  if (node->externally_visible)\n+  if (node->externally_visible || node->force_output)\n     return true;\n   if (!flag_unit_at_a_time\n       && lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n@@ -242,6 +242,17 @@ decide_is_variable_needed (struct varpool_node *node, tree decl)\n       && !DECL_EXTERNAL (decl))\n     return true;\n \n+  /* When emulating tls, we actually see references to the control\n+     variable, rather than the user-level variable.  */\n+  if (!targetm.have_tls\n+      && TREE_CODE (decl) == VAR_DECL\n+      && DECL_THREAD_LOCAL_P (decl))\n+    {\n+      tree control = emutls_decl (decl);\n+      if (decide_is_variable_needed (varpool_node (control), control))\n+\treturn true;\n+    }\n+\n   /* When not reordering top level variables, we have to assume that\n      we are going to keep everything.  */\n   if (flag_unit_at_a_time && flag_toplevel_reorder)\n@@ -374,10 +385,7 @@ varpool_remove_unreferenced_decls (void)\n       node->needed = 0;\n \n       if (node->finalized\n-\t  && ((DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t      || node->force_output\n-\t      || decide_is_variable_needed (node, decl)\n+\t  && (decide_is_variable_needed (node, decl)\n \t      /* ??? Cgraph does not yet rule the world with an iron hand,\n \t\t and does not control the emission of debug information.\n \t\t After a variable has its DECL_RTL set, we must assume that"}]}