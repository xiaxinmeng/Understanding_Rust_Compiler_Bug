{"sha": "b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1NGRhNjZlN2EzMTU1ZGNkODhkNWVjNjhiMWE3NWZiYTFiYmNlZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T13:07:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T13:07:49Z"}, "message": "[multiple changes]\n\n2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): Add code to set attribute\n\tFinalize_Address of the access type's finalization master.\n\t(Expand_N_Allocator): Add code to set attribute Finalize_Address of the\n\taccess type's finalization master. Add a guard to prevent\n\tAssociated_Storage_Pool from being set on .NET/JVM.\n\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Allocator): Add code to set\n\tattribute Finalize_Address of the access type's finalization master.\n\t* exp_ch7.adb (Make_Finalize_Address_Call): New routine.\n\t* exp_ch7.ads (Make_Finalize_Address_Call): New routine.\n\t* rtsfind.ads: Add RE_Set_Finalize_Address to tables RE_Id and\n\tRE_Unit_Table.\n\t* s-finmas.adb: Add with clause for System.Address_Image. Add with and\n\tuse clause for System.IO\n\t(Detach): Relax the assertion, to be reinstated later.\n\t(Finalize): Rewrite the iteration loop to avoid pointer comparison.\n\tRelax the assertion on Finalize_Address, to be reinstated later.\n\t(Is_Empty_List): New routine.\n\t(pm): New debug routine.\n\t(Set_Finalize_Address): New routine.\n\t* s-finmas.ads (pm): New debug routine.\n\t(Set_Finalize_Address): New routine.\n\t* s-stposu.adb (Allocate_Any_Controlled): Code reformatting.\n\n2011-08-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* a-exexpr-gcc.adb (GCC_Exception_Access, GNAT_GCC_Exception_Access):\n\tRemove convention C.\n\n2011-08-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-taprop-vms.adb (Get_Exc_Stack_Addr): Remove.\n\t(Initialize_TCB): Remove Exc_Stack_Ptr initialization.\n\t(Finalize_TCB): Remove its finalization.\n\t(Initialize): Remove assignment of GET_Exc_Stack_Addr\n\t* s-soflin.adb (NT_Exc_Stack): Remove\n\t(Get_Exc_Stack_Addr_NT): Likewise.\n\t(Get_Exc_Stack_Addr_Soft): Likewise.\n\t* s-soflin.ads (Get_Exc_Stack_Addr_NT): Remove.\n\t(Get_Exc_Stack_Addr): Likewise.\n\t(Get_Exc_Stack_Addr_Soft): Likewise\n\t* s-taspri-vms.ads (Exc_Stack_T): Remove.\n\t(Exc_Stack_Ptr_T): Likewise.\n\t(Private_Data): Remove Exc_Stack_Ptr component.\n\n2011-08-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* raise-gcc.c (get_ip_from_context): New function. Factorize code.\n\n2011-08-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* gnat_ugn.texi: Fix aix and x86-solaris info for run-time.\n\n2011-08-29  Geert Bosch  <bosch@adacore.com>\n\n\t* s-gearop.ads (Back_Substitute, Diagonal, Forward_Eliminate,\n\tL2_Norm, Swap_Column): New generic subprograms\n\t* s-gearop.adb (Back_Substitute, Diagonal, Forward_Eliminate,\n\tL2_Norm, Swap_Column): Implement new subprograms in order to\n\teliminate dependency on BLAS and LAPACK libraries in\n\tAda.Numerics.Generic_Real_Arrays and eventually also the complex\n\tversion. Forward_Eliminate/Back_Substitute can be used to put a\n\tmatrix in row echelon or reduced row echelon form using partial\n\tpivoting.\n\t* a-ngrear.adb: (Back_Substitute, Diagonal, Forward_Eleminate,\n\tSwap_Column): Instantiate from System.Generic_Array_Operations.\n\t(\"*\", \"abs\"): Implement by instantiation from Generic_Array_Operations.\n\t(Sqrt): Local function for simple computation of square root without\n\tadding dependencies on Generic_Elementary_Functions.\n\t(Swap): New subprogram to exchange floating point numbers.\n\t(Inverse): Reimplement using Jordan-Gauss elimination.\n\t(Jacobi): New procedure implementing Jacobi's method for computation\n\tof eigensystems, based on Rutishauser's implementation.\n\t(L2_Norm): Implement directly using the inner product.\n\t(Sort_Eigensystem): Sort eigenvalue/eigenvector pairs in order of\n\tdecreasing eigenvalue as required by the Ada RM.\n\t(Swap_Column): New helper procedure for Sort_Eigensystem.\n\tRemove with of System.Generic_Real_BLAS and System.Generic_Real_LAPACK.\n\tAdd with of Ada.Containers.Generic_Anonymous_Array_Sort, for\n\tSort_Eigensystems.\n\n2011-08-29  Thomas Quinot  <quinot@adacore.com>\n\n\t* put_scos.adb (Put_SCOs): Do not emit a newline for an empty\n\tstatements line.\n\nFrom-SVN: r178220", "tree": {"sha": "ecbe2dead819e7af1e373e6b8a742174d0e44087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecbe2dead819e7af1e373e6b8a742174d0e44087"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/comments", "author": null, "committer": null, "parents": [{"sha": "60370fb12798f314c3fd4f8cbb557a4cc9a164c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60370fb12798f314c3fd4f8cbb557a4cc9a164c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60370fb12798f314c3fd4f8cbb557a4cc9a164c1"}], "stats": {"total": 1756, "additions": 1234, "deletions": 522}, "files": [{"sha": "705338e194c7667807874941e7314cf2716547c0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -1,3 +1,90 @@\n+2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Add code to set attribute\n+\tFinalize_Address of the access type's finalization master.\n+\t(Expand_N_Allocator): Add code to set attribute Finalize_Address of the\n+\taccess type's finalization master. Add a guard to prevent\n+\tAssociated_Storage_Pool from being set on .NET/JVM.\n+\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Allocator): Add code to set\n+\tattribute Finalize_Address of the access type's finalization master.\n+\t* exp_ch7.adb (Make_Finalize_Address_Call): New routine.\n+\t* exp_ch7.ads (Make_Finalize_Address_Call): New routine.\n+\t* rtsfind.ads: Add RE_Set_Finalize_Address to tables RE_Id and\n+\tRE_Unit_Table.\n+\t* s-finmas.adb: Add with clause for System.Address_Image. Add with and\n+\tuse clause for System.IO\n+\t(Detach): Relax the assertion, to be reinstated later.\n+\t(Finalize): Rewrite the iteration loop to avoid pointer comparison.\n+\tRelax the assertion on Finalize_Address, to be reinstated later.\n+\t(Is_Empty_List): New routine.\n+\t(pm): New debug routine.\n+\t(Set_Finalize_Address): New routine.\n+\t* s-finmas.ads (pm): New debug routine.\n+\t(Set_Finalize_Address): New routine.\n+\t* s-stposu.adb (Allocate_Any_Controlled): Code reformatting.\n+\n+2011-08-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* a-exexpr-gcc.adb (GCC_Exception_Access, GNAT_GCC_Exception_Access):\n+\tRemove convention C.\n+\n+2011-08-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-taprop-vms.adb (Get_Exc_Stack_Addr): Remove.\n+\t(Initialize_TCB): Remove Exc_Stack_Ptr initialization.\n+\t(Finalize_TCB): Remove its finalization.\n+\t(Initialize): Remove assignment of GET_Exc_Stack_Addr\n+\t* s-soflin.adb (NT_Exc_Stack): Remove\n+\t(Get_Exc_Stack_Addr_NT): Likewise.\n+\t(Get_Exc_Stack_Addr_Soft): Likewise.\n+\t* s-soflin.ads (Get_Exc_Stack_Addr_NT): Remove.\n+\t(Get_Exc_Stack_Addr): Likewise.\n+\t(Get_Exc_Stack_Addr_Soft): Likewise\n+\t* s-taspri-vms.ads (Exc_Stack_T): Remove.\n+\t(Exc_Stack_Ptr_T): Likewise.\n+\t(Private_Data): Remove Exc_Stack_Ptr component.\n+\n+2011-08-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* raise-gcc.c (get_ip_from_context): New function. Factorize code.\n+\n+2011-08-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* gnat_ugn.texi: Fix aix and x86-solaris info for run-time.\n+\n+2011-08-29  Geert Bosch  <bosch@adacore.com>\n+\n+\t* s-gearop.ads (Back_Substitute, Diagonal, Forward_Eliminate,\n+\tL2_Norm, Swap_Column): New generic subprograms\n+\t* s-gearop.adb (Back_Substitute, Diagonal, Forward_Eliminate,\n+\tL2_Norm, Swap_Column): Implement new subprograms in order to\n+\teliminate dependency on BLAS and LAPACK libraries in\n+\tAda.Numerics.Generic_Real_Arrays and eventually also the complex\n+\tversion. Forward_Eliminate/Back_Substitute can be used to put a\n+\tmatrix in row echelon or reduced row echelon form using partial\n+\tpivoting.\n+\t* a-ngrear.adb: (Back_Substitute, Diagonal, Forward_Eleminate,\n+\tSwap_Column): Instantiate from System.Generic_Array_Operations.\n+\t(\"*\", \"abs\"): Implement by instantiation from Generic_Array_Operations.\n+\t(Sqrt): Local function for simple computation of square root without\n+\tadding dependencies on Generic_Elementary_Functions.\n+\t(Swap): New subprogram to exchange floating point numbers.\n+\t(Inverse): Reimplement using Jordan-Gauss elimination.\n+\t(Jacobi): New procedure implementing Jacobi's method for computation\n+\tof eigensystems, based on Rutishauser's implementation.\n+\t(L2_Norm): Implement directly using the inner product.\n+\t(Sort_Eigensystem): Sort eigenvalue/eigenvector pairs in order of\n+\tdecreasing eigenvalue as required by the Ada RM.\n+\t(Swap_Column): New helper procedure for Sort_Eigensystem.\n+\tRemove with of System.Generic_Real_BLAS and System.Generic_Real_LAPACK.\n+\tAdd with of Ada.Containers.Generic_Anonymous_Array_Sort, for\n+\tSort_Eigensystems.\n+\n+2011-08-29  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* put_scos.adb (Put_SCOs): Do not emit a newline for an empty\n+\tstatements line.\n+\n 2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* s-finmas.adb (Finalize): Check Finalize_Address of the master rather"}, {"sha": "1f11227c97103dc6044efcbd0abf1d314b6e945b", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -119,8 +119,8 @@ package body Exception_Propagation is\n    --  alignment below.\n \n    type GCC_Exception_Access is access all Unwind_Exception;\n-   pragma Convention (C, GCC_Exception_Access);\n-   --  Pointer to a GCC exception\n+   --  Pointer to a GCC exception. Do not use convention C as on VMS this\n+   --  would imply the use of 32-bits pointers.\n \n    procedure Unwind_DeleteException (Excp : not null GCC_Exception_Access);\n    pragma Import (C, Unwind_DeleteException, \"_Unwind_DeleteException\");\n@@ -166,7 +166,6 @@ package body Exception_Propagation is\n    --  to maintain anyway.\n \n    type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n-   pragma Convention (C, GNAT_GCC_Exception_Access);\n \n    function To_GCC_Exception is new\n      Unchecked_Conversion (GNAT_GCC_Exception_Access, GCC_Exception_Access);"}, {"sha": "b21f839588ed30f3240f539044c60c31e1298e8b", "filename": "gcc/ada/a-ngrear.adb", "status": "modified", "additions": 452, "deletions": 375, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fa-ngrear.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fa-ngrear.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngrear.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,51 +29,154 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  This version of Generic_Real_Arrays avoids the use of BLAS and LAPACK. One\n+--  reason for this is new Ada 2012 requirements that prohibit algorithms such\n+--  as Strassen's algorithm, which may be used by some BLAS implementations. In\n+--  addition, some platforms lacked suitable compilers to compile the reference\n+--  BLAS/LAPACK implementation. Finally, on many platforms there may be more\n+--  floating point types than supported by BLAS/LAPACK.\n+\n+with Ada.Containers.Generic_Anonymous_Array_Sort; use Ada.Containers;\n+\n with System; use System;\n-with System.Generic_Real_BLAS;\n-with System.Generic_Real_LAPACK;\n with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n \n package body Ada.Numerics.Generic_Real_Arrays is\n \n-   --  Operations involving inner products use BLAS library implementations.\n-   --  This allows larger matrices and vectors to be computed efficiently,\n-   --  taking into account memory hierarchy issues and vector instructions\n-   --  that vary widely between machines.\n-\n-   --  Operations that are defined in terms of operations on the type Real,\n-   --  such as addition, subtraction and scaling, are computed in the canonical\n-   --  way looping over all elements.\n-\n-   --  Operations for solving linear systems and computing determinant,\n-   --  eigenvalues, eigensystem and inverse, are implemented using the\n-   --  LAPACK library.\n+   package Ops renames System.Generic_Array_Operations;\n \n-   package BLAS is\n-      new Generic_Real_BLAS (Real'Base, Real_Vector, Real_Matrix);\n+   function Is_Non_Zero (X : Real'Base) return Boolean is (X /= 0.0);\n \n-   package LAPACK is\n-      new Generic_Real_LAPACK (Real'Base, Real_Vector, Real_Matrix);\n+   procedure Back_Substitute is new Ops.Back_Substitute\n+       (Scalar        => Real'Base,\n+        Matrix        => Real_Matrix,\n+        Is_Non_Zero   => Is_Non_Zero);\n \n-   use BLAS, LAPACK;\n+   function Diagonal is new Ops.Diagonal\n+        (Scalar       => Real'Base,\n+         Vector       => Real_Vector,\n+         Matrix       => Real_Matrix);\n \n-   --  Procedure versions of functions returning unconstrained values.\n-   --  This allows for inlining the function wrapper.\n+   procedure Forward_Eliminate is new Ops.Forward_Eliminate\n+       (Scalar        => Real'Base,\n+        Matrix        => Real_Matrix,\n+        Zero          => 0.0,\n+        One           => 1.0);\n \n-   procedure Eigenvalues (A : Real_Matrix; Values : out Real_Vector);\n-   procedure Inverse   (A : Real_Matrix; R : out Real_Matrix);\n-   procedure Solve     (A : Real_Matrix; X : Real_Vector; B : out Real_Vector);\n-   procedure Solve     (A : Real_Matrix; X : Real_Matrix; B : out Real_Matrix);\n+   procedure Swap_Column is new Ops.Swap_Column\n+       (Scalar        => Real'Base,\n+        Matrix        => Real_Matrix);\n \n-   procedure Transpose is new\n-     Generic_Array_Operations.Transpose\n+   procedure Transpose is new  Ops.Transpose\n        (Scalar        => Real'Base,\n         Matrix        => Real_Matrix);\n \n+   function Is_Symmetric (A : Real_Matrix) return Boolean is\n+     (Transpose (A) = A);\n+   --  Return True iff A is symmetric, see RM G.3.1 (90).\n+\n+   function Is_Tiny (Value, Compared_To : Real) return Boolean is\n+     (abs Compared_To + 100.0 * abs (Value) = abs Compared_To);\n+   --  Return True iff the Value is much smaller in magnitude than the least\n+   --  significant digit of Compared_To.\n+\n+   procedure Jacobi\n+     (A               : Real_Matrix;\n+      Values          : out Real_Vector;\n+      Vectors         : out Real_Matrix;\n+      Compute_Vectors : Boolean := True);\n+   --  Perform Jacobi's eigensystem algorithm on real symmetric matrix A\n+\n+   function Length is new Square_Matrix_Length (Real'Base, Real_Matrix);\n    --  Helper function that raises a Constraint_Error is the argument is\n    --  not a square matrix, and otherwise returns its length.\n \n-   function Length is new Square_Matrix_Length (Real'Base, Real_Matrix);\n+   procedure Rotate (X, Y : in out Real; Sin, Tau : Real);\n+   --  Perform a Givens rotation\n+\n+   procedure Sort_Eigensystem\n+     (Values  : in out Real_Vector;\n+      Vectors : in out Real_Matrix);\n+   --  Sort Values and associated Vectors by decreasing absolute value\n+\n+   procedure Swap (Left, Right : in out Real);\n+   --  Exchange Left and Right.\n+\n+   function Sqrt (X : Real) return Real;\n+   --  Sqrt is implemented locally here, in order to avoid dragging in all of\n+   --  the elementary functions. Speed of the square root is not a big concern\n+   --  here. This also avoids depending on a specific floating point type.\n+\n+   ------------\n+   -- Rotate --\n+   ------------\n+\n+   procedure Rotate (X, Y : in out Real; Sin, Tau : Real) is\n+      Old_X : constant Real := X;\n+      Old_Y : constant Real := Y;\n+   begin\n+      X := Old_X - Sin * (Old_Y + Old_X * Tau);\n+      Y := Old_Y + Sin * (Old_X - Old_Y * Tau);\n+   end Rotate;\n+\n+   ----------\n+   -- Sqrt --\n+   ----------\n+\n+   function Sqrt (X : Real) return Real is\n+      Root, Next : Real;\n+\n+   begin\n+      --  Be defensive: any comparisons with NaN values will yield False.\n+\n+      if not (X > 0.0) then\n+         if X = 0.0 then\n+            return X;\n+\n+         else\n+            raise Argument_Error;\n+         end if;\n+      end if;\n+\n+      --  Compute an initial estimate based on:\n+\n+      --     X = M * R**E and Sqrt (X) = Sqrt (M) * R**(E / 2.0),\n+\n+      --  where M is the mantissa, R is the radix and E the exponent.\n+\n+      --  By ignoring the mantissa and ignoring the case of an odd\n+      --  exponent, we get a final error that is at most R. In other words,\n+      --  the result has about a single bit precision.\n+\n+      Root := Real (Real'Machine_Radix) ** (Real'Exponent (X) / 2);\n+\n+      --  Because of the poor initial estimate, use the Babylonian method of\n+      --  computing the square root, as it is stable for all inputs. Every step\n+      --  will roughly double the precision of the result. Just a few steps\n+      --  suffice in most cases. Eight iterations should give about 2**8 bits\n+      --  of precision.\n+\n+      for J in 1 .. 8 loop\n+         Next := (Root + X / Root) / 2.0;\n+\n+         exit when Root = Next;\n+\n+         Root := Next;\n+      end loop;\n+\n+      return Root;\n+   end Sqrt;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap (Left, Right : in out Real) is\n+      Temp : constant Real := Left;\n+   begin\n+      Left := Right;\n+      Right := Temp;\n+   end Swap;\n \n    --  Instantiating the following subprograms directly would lead to\n    --  name clashes, so use a local package.\n@@ -197,6 +300,45 @@ package body Ada.Numerics.Generic_Real_Arrays is\n            Right_Vector  => Real_Vector,\n            Matrix        => Real_Matrix);\n \n+      function \"*\" is new\n+        Inner_Product\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Vector   => Real_Vector,\n+           Right_Vector  => Real_Vector,\n+           Zero          => 0.0);\n+\n+      function \"*\" is new\n+        Matrix_Vector_Product\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Matrix        => Real_Matrix,\n+           Right_Vector  => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Zero          => 0.0);\n+\n+      function \"*\" is new\n+        Vector_Matrix_Product\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Vector   => Real_Vector,\n+           Matrix        => Real_Matrix,\n+           Result_Vector => Real_Vector,\n+           Zero          => 0.0);\n+\n+      function \"*\" is new\n+        Matrix_Matrix_Product\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Matrix   => Real_Matrix,\n+           Right_Matrix  => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Zero          => 0.0);\n+\n       function \"/\" is new\n         Vector_Scalar_Elementwise_Operation\n           (Left_Scalar   => Real'Base,\n@@ -215,6 +357,13 @@ package body Ada.Numerics.Generic_Real_Arrays is\n            Result_Matrix => Real_Matrix,\n            Operation     => \"/\");\n \n+      function \"abs\" is new\n+        L2_Norm\n+          (Scalar        => Real'Base,\n+           Vector        => Real_Vector,\n+           Inner_Product => \"*\",\n+           Sqrt          => Sqrt);\n+\n       function \"abs\" is new\n         Vector_Elementwise_Operation\n           (X_Scalar      => Real'Base,\n@@ -299,90 +448,22 @@ package body Ada.Numerics.Generic_Real_Arrays is\n \n    --  Vector multiplication\n \n-   function \"*\" (Left, Right : Real_Vector) return Real'Base is\n-   begin\n-      if Left'Length /= Right'Length then\n-         raise Constraint_Error with\n-            \"vectors are of different length in inner product\";\n-      end if;\n-\n-      return dot (Left'Length, X => Left, Y => Right);\n-   end \"*\";\n+   function \"*\" (Left, Right : Real_Vector) return Real'Base\n+      renames Instantiations.\"*\";\n \n    function \"*\" (Left, Right : Real_Vector) return Real_Matrix\n       renames Instantiations.\"*\";\n \n-   function \"*\"\n-     (Left : Real_Vector;\n-      Right : Real_Matrix) return Real_Vector\n-   is\n-      R : Real_Vector (Right'Range (2));\n-\n-   begin\n-      if Left'Length /= Right'Length (1) then\n-         raise Constraint_Error with\n-           \"incompatible dimensions in vector-matrix multiplication\";\n-      end if;\n-\n-      gemv (Trans => No_Trans'Access,\n-            M     => Right'Length (2),\n-            N     => Right'Length (1),\n-            A     => Right,\n-            Ld_A  => Right'Length (2),\n-            X     => Left,\n-            Y     => R);\n-\n-      return R;\n-   end \"*\";\n-\n-   function \"*\"\n-     (Left : Real_Matrix;\n-      Right : Real_Vector) return Real_Vector\n-   is\n-      R : Real_Vector (Left'Range (1));\n-\n-   begin\n-      if Left'Length (2) /= Right'Length then\n-         raise Constraint_Error with\n-            \"incompatible dimensions in matrix-vector multiplication\";\n-      end if;\n-\n-      gemv (Trans => Trans'Access,\n-            M     => Left'Length (2),\n-            N     => Left'Length (1),\n-            A     => Left,\n-            Ld_A  => Left'Length (2),\n-            X     => Right,\n-            Y     => R);\n+   function \"*\" (Left : Real_Vector; Right : Real_Matrix) return Real_Vector\n+      renames Instantiations.\"*\";\n \n-      return R;\n-   end \"*\";\n+   function \"*\" (Left : Real_Matrix; Right : Real_Vector) return Real_Vector\n+      renames Instantiations.\"*\";\n \n    --  Matrix Multiplication\n \n-   function \"*\" (Left, Right : Real_Matrix) return Real_Matrix is\n-      R : Real_Matrix (Left'Range (1), Right'Range (2));\n-\n-   begin\n-      if Left'Length (2) /= Right'Length (1) then\n-         raise Constraint_Error with\n-            \"incompatible dimensions in matrix-matrix multiplication\";\n-      end if;\n-\n-      gemm (Trans_A => No_Trans'Access,\n-            Trans_B => No_Trans'Access,\n-            M       => Right'Length (2),\n-            N       => Left'Length (1),\n-            K       => Right'Length (1),\n-            A       => Right,\n-            Ld_A    => Right'Length (2),\n-            B       => Left,\n-            Ld_B    => Left'Length (2),\n-            C       => R,\n-            Ld_C    => R'Length (2));\n-\n-      return R;\n-   end \"*\";\n+   function \"*\" (Left, Right : Real_Matrix) return Real_Matrix\n+      renames Instantiations.\"*\";\n \n    ---------\n    -- \"/\" --\n@@ -398,10 +479,8 @@ package body Ada.Numerics.Generic_Real_Arrays is\n    -- \"abs\" --\n    -----------\n \n-   function \"abs\" (Right : Real_Vector) return Real'Base is\n-   begin\n-      return nrm2 (Right'Length, Right);\n-   end \"abs\";\n+   function \"abs\" (Right : Real_Vector) return Real'Base\n+      renames Instantiations.\"abs\";\n \n    function \"abs\" (Right : Real_Vector) return Real_Vector\n       renames Instantiations.\"abs\";\n@@ -414,29 +493,14 @@ package body Ada.Numerics.Generic_Real_Arrays is\n    -----------------\n \n    function Determinant (A : Real_Matrix) return Real'Base is\n-      N    : constant Integer := Length (A);\n-      LU   : Real_Matrix (1 .. N, 1 .. N) := A;\n-      Piv  : Integer_Vector (1 .. N);\n-      Info : aliased Integer := -1;\n-      Det  : Real := 1.0;\n+      M : Real_Matrix := A;\n+      B : Real_Matrix (A'Range (1), 1 .. 0);\n+      R : Real'Base;\n \n    begin\n-      getrf (M     => N,\n-             N     => N,\n-             A     => LU,\n-             Ld_A  => N,\n-             I_Piv => Piv,\n-             Info  => Info'Access);\n-\n-      if Info /= 0 then\n-         raise Constraint_Error with \"ill-conditioned matrix\";\n-      end if;\n+      Forward_Eliminate (M, B, R);\n \n-      for J in 1 .. N loop\n-         Det := (if Piv (J) /= J then -Det * LU (J, J) else Det * LU (J, J));\n-      end loop;\n-\n-      return Det;\n+      return R;\n    end Determinant;\n \n    -----------------\n@@ -448,306 +512,319 @@ package body Ada.Numerics.Generic_Real_Arrays is\n       Values  : out Real_Vector;\n       Vectors : out Real_Matrix)\n    is\n-      N      : constant Natural := Length (A);\n-      Tau    : Real_Vector (1 .. N);\n-      L_Work : Real_Vector (1 .. 1);\n-      Info   : aliased Integer;\n-\n-      E : Real_Vector (1 .. N);\n-      pragma Warnings (Off, E);\n-\n    begin\n-      if Values'Length /= N then\n-         raise Constraint_Error with \"wrong length for output vector\";\n-      end if;\n-\n-      if N = 0 then\n-         return;\n-      end if;\n-\n-      --  Initialize working matrix and check for symmetric input matrix\n-\n-      Transpose (A, Vectors);\n+      Jacobi (A, Values, Vectors, Compute_Vectors => True);\n+      Sort_Eigensystem (Values, Vectors);\n+   end Eigensystem;\n \n-      if A /= Vectors then\n-         raise Argument_Error with \"matrix not symmetric\";\n-      end if;\n+   -----------------\n+   -- Eigenvalues --\n+   -----------------\n \n-      --  Compute size of additional working space\n+   function Eigenvalues (A : Real_Matrix) return Real_Vector is\n+      Values  : Real_Vector (A'Range (1));\n+      Vectors : Real_Matrix (1 .. 0, 1 .. 0);\n+   begin\n+      Jacobi (A, Values, Vectors, Compute_Vectors => False);\n+      Sort_Eigensystem (Values, Vectors);\n \n-      sytrd (Uplo   => Lower'Access,\n-             N      => N,\n-             A      => Vectors,\n-             Ld_A   => N,\n-             D      => Values,\n-             E      => E,\n-             Tau    => Tau,\n-             Work   => L_Work,\n-             L_Work => -1,\n-             Info   => Info'Access);\n+      return Values;\n+   end Eigenvalues;\n \n-      declare\n-         Work : Real_Vector (1 .. Integer'Max (Integer (L_Work (1)), 2 * N));\n-         pragma Warnings (Off, Work);\n+   -------------\n+   -- Inverse --\n+   -------------\n \n-         Comp_Z : aliased constant Character := 'V';\n+   function Inverse (A : Real_Matrix) return Real_Matrix is\n+     (Solve (A, Unit_Matrix (Length (A))));\n \n-      begin\n-         --  Reduce matrix to tridiagonal form\n-\n-         sytrd (Uplo   => Lower'Access,\n-                N      => N,\n-                A      => Vectors,\n-                Ld_A   => A'Length (1),\n-                D      => Values,\n-                E      => E,\n-                Tau    => Tau,\n-                Work   => Work,\n-                L_Work => Work'Length,\n-                Info   => Info'Access);\n-\n-         if Info /= 0 then\n-            raise Program_Error;\n-         end if;\n+   ------------\n+   -- Jacobi --\n+   ------------\n \n-         --  Generate the real orthogonal matrix determined by sytrd\n+   procedure Jacobi\n+     (A               : Real_Matrix;\n+      Values          : out Real_Vector;\n+      Vectors         : out Real_Matrix;\n+      Compute_Vectors : Boolean := True)\n+   is\n+      --  This subprogram uses Carl Gustav Jacob Jacobi's iterative method\n+      --  for computing eigenvalues and eigenvectors and is based on\n+      --  Rutishauser's implementation.\n \n-         orgtr (Uplo   => Lower'Access,\n-                N      => N,\n-                A      => Vectors,\n-                Ld_A   => N,\n-                Tau    => Tau,\n-                Work   => Work,\n-                L_Work => Work'Length,\n-                Info   => Info'Access);\n+      --  The given real symmetric matrix is transformed iteratively to\n+      --  diagonal form through a sequence of appropriately chosen elementary\n+      --  orthogonal transformations, called Jacobi rotations here.\n \n-         if Info /= 0 then\n-            raise Program_Error;\n-         end if;\n+      --  The Jacobi method produces a systematic decrease of the sum of the\n+      --  squares of off-diagonal elements. Convergence to zero is quadratic,\n+      --  both for this implementation, as for the classic method that doesn't\n+      --  use row-wise scanning for pivot selection.\n \n-         --  Compute all eigenvalues and eigenvectors using QR algorithm\n+      --  The numerical stability and accuracy of Jacobi's method make it the\n+      --  best choice here, even though for large matrices other methods will\n+      --  be significantly more efficient in both time and space.\n \n-         steqr (Comp_Z => Comp_Z'Access,\n-                N      => N,\n-                D      => Values,\n-                E      => E,\n-                Z      => Vectors,\n-                Ld_Z   => N,\n-                Work   => Work,\n-                Info   => Info'Access);\n+      --  While the eigensystem computations are absolutely foolproof for all\n+      --  real symmetric matrices, in presence of invalid values, or similar\n+      --  exceptional situations it might not. In such cases the results cannot\n+      --  be trusted and Constraint_Error is raised.\n \n-         if Info /= 0 then\n-            raise Constraint_Error with\n-               \"eigensystem computation failed to converge\";\n-         end if;\n-      end;\n-   end Eigensystem;\n+      --  Note: this implementation needs temporary storage for 2 * N + N**2\n+      --        values of type Real.\n \n-   -----------------\n-   -- Eigenvalues --\n-   -----------------\n+      Max_Iterations  : constant := 50;\n \n-   procedure Eigenvalues\n-     (A      : Real_Matrix;\n-      Values : out Real_Vector)\n-   is\n-      N      : constant Natural := Length (A);\n-      L_Work : Real_Vector (1 .. 1);\n-      Info   : aliased Integer;\n+      N               : constant Natural := Length (A);\n \n-      B   : Real_Matrix (1 .. N, 1 .. N);\n-      Tau : Real_Vector (1 .. N);\n-      E   : Real_Vector (1 .. N);\n-      pragma Warnings (Off, B);\n-      pragma Warnings (Off, Tau);\n-      pragma Warnings (Off, E);\n+      subtype Square_Matrix is Real_Matrix (1 .. N, 1 .. N);\n \n-   begin\n-      if Values'Length /= N then\n-         raise Constraint_Error with \"wrong length for output vector\";\n-      end if;\n+      --  In order to annihilate the M (Row, Col) element, the\n+      --  rotation parameters Cos and Sin are computed as\n+      --  follows:\n \n-      if N = 0 then\n-         return;\n-      end if;\n+      --    Theta = Cot (2.0 * Phi)\n+      --          = (Diag (Col) - Diag (Row)) / (2.0 * M (Row, Col))\n \n-      --  Initialize working matrix and check for symmetric input matrix\n+      --  Then Tan (Phi) as the smaller root (in modulus) of\n \n-      Transpose (A, B);\n+      --    T**2 + 2 * T * Theta = 1 (or 0.5 / Theta, if Theta is large)\n \n-      if A /= B then\n-         raise Argument_Error with \"matrix not symmetric\";\n-      end if;\n+      function Compute_Tan (Theta : Real) return Real is\n+         (Real'Copy_Sign (1.0 / (abs Theta + Sqrt (1.0 + Theta**2)), Theta));\n \n-      --  Find size of work area\n+      function Compute_Tan (P, H : Real) return Real is\n+         (if Is_Tiny (P, Compared_To => H) then P / H\n+          else Compute_Tan (Theta => H / (2.0 * P)));\n \n-      sytrd (Uplo   => Lower'Access,\n-             N      => N,\n-             A      => B,\n-             Ld_A   => N,\n-             D      => Values,\n-             E      => E,\n-             Tau    => Tau,\n-             Work   => L_Work,\n-             L_Work => -1,\n-             Info   => Info'Access);\n+      function Sum_Strict_Upper (M : Square_Matrix) return Real;\n+      --  Return the sum of all elements in the strict upper triangle of M\n \n-      declare\n-         Work : Real_Vector (1 .. Integer'Min (Integer (L_Work (1)), 4 * N));\n-         pragma Warnings (Off, Work);\n+      ----------------------\n+      -- Sum_Strict_Upper --\n+      ----------------------\n \n+      function Sum_Strict_Upper (M : Square_Matrix) return Real is\n+         Sum : Real := 0.0;\n       begin\n-         --  Reduce matrix to tridiagonal form\n-\n-         sytrd (Uplo   => Lower'Access,\n-                N      => N,\n-                A      => B,\n-                Ld_A   => A'Length (1),\n-                D      => Values,\n-                E      => E,\n-                Tau    => Tau,\n-                Work   => Work,\n-                L_Work => Work'Length,\n-                Info   => Info'Access);\n-\n-         if Info /= 0 then\n-            raise Constraint_Error;\n-         end if;\n-\n-         --  Compute all eigenvalues using QR algorithm\n-\n-         sterf (N      => N,\n-                D      => Values,\n-                E      => E,\n-                Info   => Info'Access);\n-\n-         if Info /= 0 then\n-            raise Constraint_Error with\n-               \"eigenvalues computation failed to converge\";\n-         end if;\n-      end;\n-   end Eigenvalues;\n-\n-   function Eigenvalues (A : Real_Matrix) return Real_Vector is\n-      R : Real_Vector (A'Range (1));\n-   begin\n-      Eigenvalues (A, R);\n-      return R;\n-   end Eigenvalues;\n-\n-   -------------\n-   -- Inverse --\n-   -------------\n-\n-   procedure Inverse (A : Real_Matrix; R : out Real_Matrix) is\n-      N      : constant Integer := Length (A);\n-      Piv    : Integer_Vector (1 .. N);\n-      L_Work : Real_Vector (1 .. 1);\n-      Info   : aliased Integer := -1;\n+         for Row in 1 .. N - 1 loop\n+            for Col in Row + 1 .. N loop\n+               Sum := Sum + abs M (Row, Col);\n+            end loop;\n+         end loop;\n+\n+         return Sum;\n+      end Sum_Strict_Upper;\n+\n+      M         : Square_Matrix := A; --  Work space for solving eigensystem\n+      Threshold : Real;\n+      Sum       : Real;\n+      Diag      : Real_Vector (1 .. N);\n+      Diag_Adj  : Real_Vector (1 .. N);\n+\n+      --  The vector Diag_Adj indicates the amount of change in each value,\n+      --  while Diag tracks the value itself and Values holds the values as\n+      --  they were at the beginning. As the changes typically will be small\n+      --  compared to the absolute value of Diag, at the end of each iteration\n+      --  Diag is computed as Diag + Diag_Adj thus avoiding accumulating\n+      --  rounding errors. This technique is due to Rutishauser.\n \n    begin\n-      --  All computations are done using column-major order, but this works\n-      --  out fine, because Transpose (Inverse (Transpose (A))) = Inverse (A).\n-\n-      R := A;\n+      if Compute_Vectors\n+         and then (Vectors'Length (1) /= N or else Vectors'Length (2) /= N)\n+      then\n+         raise Constraint_Error with \"incompatible matrix dimensions\";\n \n-      --  Compute LU decomposition\n+      elsif Values'Length /= N then\n+         raise Constraint_Error with \"incompatible vector length\";\n \n-      getrf (M      => N,\n-             N      => N,\n-             A      => R,\n-             Ld_A   => N,\n-             I_Piv  => Piv,\n-             Info   => Info'Access);\n+      elsif not Is_Symmetric (M) then\n+         raise Constraint_Error with \"matrix not symmetric\";\n+      end if;\n \n-      if Info /= 0 then\n-         raise Constraint_Error with \"inverting singular matrix\";\n+      --  Note: Only the locally declared matrix M and vectors (Diag, Diag_Adj)\n+      --        have lower bound equal to 1. The Vectors matrix may have\n+      --        different bounds, so take care indexing elements. Assignment\n+      --        as a whole is fine as sliding is automatic in that case.\n+\n+      Vectors := (if not Compute_Vectors then (1 .. 0 => (1 .. 0 => 0.0))\n+                  else Unit_Matrix (Vectors'Length (1), Vectors'Length (2)));\n+      Values := Diagonal (M);\n+\n+      Sweep : for Iteration in 1 .. Max_Iterations loop\n+\n+         --  The first three iterations, perform rotation for any non-zero\n+         --  element. After this, rotate only for those that are not much\n+         --  smaller than the average off-diagnal element. After the fifth\n+         --  iteration, additionally zero out off-diagonal elements that are\n+         --  very small compared to elements on the diagonal with the same\n+         --  column or row index.\n+\n+         Sum := Sum_Strict_Upper (M);\n+\n+         exit Sweep when Sum = 0.0;\n+\n+         Threshold := (if Iteration < 4 then 0.2 * Sum / Real (N**2) else 0.0);\n+\n+         --  Iterate over all off-diagonal elements, rotating any that have\n+         --  an absolute value that exceeds the threshold.\n+\n+         Diag := Values;\n+         Diag_Adj := (others => 0.0); -- Accumulates adjustments to Diag\n+\n+         for Row in 1 .. N - 1 loop\n+            for Col in Row + 1 .. N loop\n+\n+               --  If, before the rotation M (Row, Col) is tiny compared to\n+               --  Diag (Row) and Diag (Col), rotation is skipped. This is\n+               --  meaningful, as it produces no larger error than would be\n+               --  produced anyhow if the rotation had been performed.\n+               --  Suppress this optimization in the first four sweeps, so\n+               --  that this procedure can be used for computing eigenvectors\n+               --  of perturbed diagonal matrices.\n+\n+               if Iteration > 4\n+                  and then Is_Tiny (M (Row, Col), Compared_To => Diag (Row))\n+                  and then Is_Tiny (M (Row, Col), Compared_To => Diag (Col))\n+               then\n+                  M (Row, Col) := 0.0;\n+\n+               elsif abs M (Row, Col) > Threshold then\n+                  Perform_Rotation : declare\n+                     Tan : constant Real := Compute_Tan (M (Row, Col),\n+                                               Diag (Col) - Diag (Row));\n+                     Cos : constant Real := 1.0 / Sqrt (1.0 + Tan**2);\n+                     Sin : constant Real := Tan * Cos;\n+                     Tau : constant Real := Sin / (1.0 + Cos);\n+                     Adj : constant Real := Tan * M (Row, Col);\n+\n+                  begin\n+                     Diag_Adj (Row) := Diag_Adj (Row) - Adj;\n+                     Diag_Adj (Col) := Diag_Adj (Col) + Adj;\n+                     Diag (Row) := Diag (Row) - Adj;\n+                     Diag (Col) := Diag (Col) + Adj;\n+\n+                     M (Row, Col) := 0.0;\n+\n+                     for J in 1 .. Row - 1 loop        --  1 <= J < Row\n+                        Rotate (M (J, Row), M (J, Col), Sin, Tau);\n+                     end loop;\n+\n+                     for J in Row + 1 .. Col - 1 loop  --  Row < J < Col\n+                        Rotate (M (Row, J), M (J, Col), Sin, Tau);\n+                     end loop;\n+\n+                     for J in Col + 1 .. N loop        --  Col < J <= N\n+                        Rotate (M (Row, J), M (Col, J), Sin, Tau);\n+                     end loop;\n+\n+                     for J in Vectors'Range (1) loop\n+                        Rotate (Vectors (J, Row - 1 + Vectors'First (2)),\n+                                Vectors (J, Col - 1 + Vectors'First (2)),\n+                                Sin, Tau);\n+                     end loop;\n+                  end Perform_Rotation;\n+               end if;\n+            end loop;\n+         end loop;\n+\n+         Values := Values + Diag_Adj;\n+      end loop Sweep;\n+\n+      --  All normal matrices with valid values should converge perfectly.\n+\n+      if Sum /= 0.0 then\n+         raise Constraint_Error with \"eigensystem solution does not converge\";\n       end if;\n+   end Jacobi;\n \n-      --  Determine size of work area\n+   -----------\n+   -- Solve --\n+   -----------\n \n-      getri (N      => N,\n-             A      => R,\n-             Ld_A   => N,\n-             I_Piv  => Piv,\n-             Work   => L_Work,\n-             L_Work => -1,\n-             Info   => Info'Access);\n+   function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector is\n+      N   : constant Natural := Length (A);\n+      MA  : Real_Matrix := A;\n+      MX  : Real_Matrix (A'Range (1), 1 .. 1);\n+      R   : Real_Vector (A'Range (2));\n+      Det : Real'Base;\n \n-      if Info /= 0 then\n-         raise Constraint_Error;\n+   begin\n+      if X'Length /= N then\n+         raise Constraint_Error with \"incompatible vector length\";\n       end if;\n \n-      declare\n-         Work : Real_Vector (1 .. Integer (L_Work (1)));\n-         pragma Warnings (Off, Work);\n+      for J in 0 .. MX'Length (1) - 1 loop\n+         MX (MX'First (1) + J, 1) := X (X'First + J);\n+      end loop;\n \n-      begin\n-         --  Compute inverse from LU decomposition\n-\n-         getri (N      => N,\n-                A      => R,\n-                Ld_A   => N,\n-                I_Piv  => Piv,\n-                Work   => Work,\n-                L_Work => Work'Length,\n-                Info   => Info'Access);\n-\n-         if Info /= 0 then\n-            raise Constraint_Error with \"inverting singular matrix\";\n-         end if;\n+      Forward_Eliminate (MA, MX, Det);\n+      Back_Substitute (MA, MX);\n \n-         --  ??? Should iterate with gerfs, based on implementation advice\n-      end;\n-   end Inverse;\n+      for J in 0 .. R'Length - 1 loop\n+         R (R'First + J) := MX (MX'First (1) + J, 1);\n+      end loop;\n \n-   function Inverse (A : Real_Matrix) return Real_Matrix is\n-      R : Real_Matrix (A'Range (2), A'Range (1));\n-   begin\n-      Inverse (A, R);\n       return R;\n-   end Inverse;\n+   end Solve;\n \n-   -----------\n-   -- Solve --\n-   -----------\n+   function Solve (A, X : Real_Matrix) return Real_Matrix is\n+      N  : constant Natural := Length (A);\n+      MA : Real_Matrix (A'Range (2), A'Range (2));\n+      MB : Real_Matrix (A'Range (2), X'Range (2));\n+      Det : Real'Base;\n \n-   procedure Solve (A : Real_Matrix; X : Real_Vector; B : out Real_Vector) is\n    begin\n-      if Length (A) /= X'Length then\n-         raise Constraint_Error with\n-           \"incompatible matrix and vector dimensions\";\n+      if X'Length (1) /= N then\n+         raise Constraint_Error with \"matrices have unequal number of rows\";\n       end if;\n \n-      --  ??? Should solve directly, is faster and more accurate\n+      for J in 0 .. A'Length (1) - 1 loop\n+         for K in MA'Range (2) loop\n+            MA (MA'First (1) + J, K) := A (A'First (1) + J, K);\n+         end loop;\n+\n+         for K in MB'Range (2) loop\n+            MB (MB'First (1) + J, K) := X (X'First (1) + J, K);\n+         end loop;\n+      end loop;\n+\n+      Forward_Eliminate (MA, MB, Det);\n+      Back_Substitute (MA, MB);\n \n-      B := Inverse (A) * X;\n+      return MB;\n    end Solve;\n \n-   procedure Solve (A : Real_Matrix; X : Real_Matrix; B : out Real_Matrix) is\n-   begin\n-      if Length (A) /= X'Length (1) then\n-         raise Constraint_Error with \"incompatible matrix dimensions\";\n-      end if;\n+   ----------------------\n+   -- Sort_Eigensystem --\n+   ----------------------\n \n-      --  ??? Should solve directly, is faster and more accurate\n+   procedure Sort_Eigensystem\n+     (Values  : in out Real_Vector;\n+      Vectors : in out Real_Matrix)\n+   is\n \n-      B := Inverse (A) * X;\n-   end Solve;\n+      procedure Swap (Left, Right : Integer);\n+      --  Swap Values (Left) with Values (Right), and also swap the\n+      --  corresponding eigenvectors. Note that lowerbounds may differ.\n \n-   function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector is\n-      B : Real_Vector (A'Range (2));\n-   begin\n-      Solve (A, X, B);\n-      return B;\n-   end Solve;\n+      function Less (Left, Right : Integer) return Boolean is\n+        (Values (Left) > Values (Right));\n+      --  Sort by decreasing eigenvalue, see RM G.3.1 (76).\n+\n+      procedure Sort is new Generic_Anonymous_Array_Sort (Integer);\n+      --  Sorts eigenvalues and eigenvectors by decreasing value\n+\n+      procedure Swap (Left, Right : Integer) is\n+      begin\n+         Swap (Values (Left), Values (Right));\n+         Swap_Column (Vectors, Left - Values'First + Vectors'First (2),\n+                               Right - Values'First + Vectors'First (2));\n+      end Swap;\n \n-   function Solve (A, X : Real_Matrix) return Real_Matrix is\n-      B : Real_Matrix (A'Range (2), X'Range (2));\n    begin\n-      Solve (A, X, B);\n-      return B;\n-   end Solve;\n+      Sort (Values'First, Values'Last);\n+   end Sort_Eigensystem;\n \n    ---------------\n    -- Transpose --"}, {"sha": "c4957222e7dd1a4f45f77d6aff156feedccdd573", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -1042,6 +1042,24 @@ package body Exp_Ch4 is\n                          Prefix => New_Reference_To (Temp, Loc))),\n                    Typ => T));\n             end if;\n+\n+            --  Generate:\n+            --    Set_Finalize_Address (<PtrT>FM, <T>FD'Unrestricted_Access);\n+\n+            --  Since .NET/JVM compilers do not support address arithmetic,\n+            --  this call is skipped. The same is done for CodePeer because\n+            --  primitive Finalize_Address is never generated.\n+\n+            if VM_Target = No_VM\n+              and then not CodePeer_Mode\n+              and then Present (Finalization_Master (PtrT))\n+            then\n+               Insert_Action (N,\n+                 Make_Set_Finalize_Address_Call\n+                   (Loc     => Loc,\n+                    Typ     => T,\n+                    Ptr_Typ => PtrT));\n+            end if;\n          end if;\n \n          Rewrite (N, New_Reference_To (Temp, Loc));\n@@ -3342,9 +3360,13 @@ package body Exp_Ch4 is\n       if Ekind (PtrT) = E_Anonymous_Access_Type\n         and then Needs_Finalization (Dtyp)\n       then\n-         --  Anonymous access-to-controlled types allocate on the global pool\n+         --  Anonymous access-to-controlled types allocate on the global pool.\n+         --  Do not set this attribute on .NET/JVM since those targets do not\n+         --  support pools.\n \n-         if No (Associated_Storage_Pool (PtrT)) then\n+         if No (Associated_Storage_Pool (PtrT))\n+           and then VM_Target = No_VM\n+         then\n             Set_Associated_Storage_Pool (PtrT,\n               Get_Global_Pool_For_Access_Type (PtrT));\n          end if;\n@@ -3828,22 +3850,39 @@ package body Exp_Ch4 is\n                       (Obj_Ref => New_Copy_Tree (Init_Arg1),\n                        Typ     => T));\n \n-                  --  Special processing for .NET/JVM, the allocated object is\n-                  --  attached to the finalization master. Generate:\n+                  if Present (Finalization_Master (PtrT)) then\n \n-                  --    Attach (<PtrT>FC, Root_Controlled_Ptr (Init_Arg1));\n+                     --  Special processing for .NET/JVM, the allocated object\n+                     --  is attached to the finalization master. Generate:\n \n-                  --  Types derived from [Limited_]Controlled are the only\n-                  --  ones considered since they have fields Prev and Next.\n+                     --    Attach (<PtrT>FM, Root_Controlled_Ptr (Init_Arg1));\n \n-                  if VM_Target /= No_VM\n-                    and then Present (Finalization_Master (PtrT))\n-                    and then Is_Controlled (T)\n-                  then\n-                     Insert_Action (N,\n-                       Make_Attach_Call\n-                         (Obj_Ref => New_Copy_Tree (Init_Arg1),\n-                          Ptr_Typ => PtrT));\n+                     --  Types derived from [Limited_]Controlled are the only\n+                     --  ones considered since they have fields Prev and Next.\n+\n+                     if VM_Target /= No_VM\n+                       and then Is_Controlled (T)\n+                     then\n+                        Insert_Action (N,\n+                          Make_Attach_Call\n+                            (Obj_Ref => New_Copy_Tree (Init_Arg1),\n+                             Ptr_Typ => PtrT));\n+\n+                     --  Default case, generate:\n+\n+                     --    Set_Finalize_Address\n+                     --      (<PtrT>FM, <T>FD'Unrestricted_Access);\n+\n+                     --  Do not generate the above for CodePeer compilations\n+                     --  because primitive Finalize_Address is never built.\n+\n+                     elsif not CodePeer_Mode then\n+                        Insert_Action (N,\n+                          Make_Set_Finalize_Address_Call\n+                            (Loc     => Loc,\n+                             Typ     => T,\n+                             Ptr_Typ => PtrT));\n+                     end if;\n                   end if;\n                end if;\n "}, {"sha": "8073ff568fd7a96b7f579974d87e0015a6192550", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -7155,6 +7155,33 @@ package body Exp_Ch6 is\n            (Func_Call, Function_Id, Return_Object => Empty);\n       end if;\n \n+      --  If the build-in-place function call returns a controlled object,\n+      --  the finalization master will require a reference to routine\n+      --  Finalize_Address of the designated type. Setting this attribute\n+      --  is done in the same manner to expansion of allocators.\n+\n+      if Needs_Finalization (Result_Subt) then\n+\n+         --  Controlled types with supressed finalization do not need to\n+         --  associate the address of their Finalize_Address primitives with\n+         --  a master since they do not need a master to begin with.\n+\n+         if Is_Library_Level_Entity (Acc_Type)\n+           and then Finalize_Storage_Only (Result_Subt)\n+         then\n+            null;\n+\n+         --  Do not generate the call to Make_Set_Finalize_Address for\n+         --  CodePeer compilations because Finalize_Address is never built.\n+\n+         elsif not CodePeer_Mode then\n+            Insert_Action (Allocator,\n+              Make_Set_Finalize_Address_Call (Loc,\n+                Typ     => Etype (Function_Id),\n+                Ptr_Typ => Acc_Type));\n+         end if;\n+      end if;\n+\n       --  Finally, replace the allocator node with a reference to the result\n       --  of the function call itself (which will effectively be an access\n       --  to the object created by the allocator)."}, {"sha": "62d316631e0d7de51f3ce1e5362781f0be89e423", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -7435,6 +7435,83 @@ package body Exp_Ch7 is\n               Statements => Make_Deep_Record_Body (Finalize_Case, Typ, True)));\n    end Make_Local_Deep_Finalize;\n \n+   ------------------------------------\n+   -- Make_Set_Finalize_Address_Call --\n+   ------------------------------------\n+\n+   function Make_Set_Finalize_Address_Call\n+     (Loc : Source_Ptr;\n+      Typ   : Entity_Id;\n+      Ptr_Typ : Entity_Id) return Node_Id\n+   is\n+      Desig_Typ : constant Entity_Id :=\n+                    Available_View (Designated_Type (Ptr_Typ));\n+      Utyp      : Entity_Id;\n+\n+   begin\n+      --  If the context is a class-wide allocator, we use the class-wide type\n+      --  to obtain the proper Finalize_Address routine.\n+\n+      if Is_Class_Wide_Type (Desig_Typ) then\n+         Utyp := Desig_Typ;\n+\n+      else\n+         Utyp := Typ;\n+\n+         if Is_Private_Type (Utyp) and then Present (Full_View (Utyp)) then\n+            Utyp := Full_View (Utyp);\n+         end if;\n+\n+         if Is_Concurrent_Type (Utyp) then\n+            Utyp := Corresponding_Record_Type (Utyp);\n+         end if;\n+      end if;\n+\n+      Utyp := Underlying_Type (Base_Type (Utyp));\n+\n+      --  Deal with non-tagged derivation of private views. If the parent is\n+      --  now known to be protected, the finalization routine is the one\n+      --  defined on the corresponding record of the ancestor (corresponding\n+      --  records do not automatically inherit operations, but maybe they\n+      --  should???)\n+\n+      if Is_Untagged_Derivation (Typ) then\n+         if Is_Protected_Type (Typ) then\n+            Utyp := Corresponding_Record_Type (Root_Type (Base_Type (Typ)));\n+         else\n+            Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n+\n+            if Is_Protected_Type (Utyp) then\n+               Utyp := Corresponding_Record_Type (Utyp);\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  If the underlying_type is a subtype, we are dealing with the\n+      --  completion of a private type. We need to access the base type and\n+      --  generate a conversion to it.\n+\n+      if Utyp /= Base_Type (Utyp) then\n+         pragma Assert (Is_Private_Type (Typ));\n+\n+         Utyp := Base_Type (Utyp);\n+      end if;\n+\n+      --  Generate:\n+      --    Set_Finalize_Address (<Ptr_Typ>FM, <Utyp>FD'Unrestricted_Access);\n+\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name =>\n+            New_Reference_To (RTE (RE_Set_Finalize_Address), Loc),\n+          Parameter_Associations => New_List (\n+            New_Reference_To (Finalization_Master (Ptr_Typ), Loc),\n+            Make_Attribute_Reference (Loc,\n+              Prefix =>\n+                New_Reference_To (TSS (Utyp, TSS_Finalize_Address), Loc),\n+              Attribute_Name => Name_Unrestricted_Access)));\n+   end Make_Set_Finalize_Address_Call;\n+\n    --------------------------\n    -- Make_Transient_Block --\n    --------------------------"}, {"sha": "1774f69ed78a73ed99f8a9c95de59b2852c21b5e", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -173,6 +173,18 @@ package Exp_Ch7 is\n    --  Create a special version of Deep_Finalize with identifier Nam. The\n    --  routine has state information and can parform partial finalization.\n \n+   function Make_Set_Finalize_Address_Call\n+     (Loc     : Source_Ptr;\n+      Typ     : Entity_Id;\n+      Ptr_Typ : Entity_Id) return Node_Id;\n+   --  Generate the following call:\n+   --\n+   --    Set_Finalize_Address (<Ptr_Typ>FM, <Typ>FD'Unrestricted_Access);\n+   --\n+   --  where Finalize_Address is the corresponding TSS primitive of type Typ\n+   --  and Ptr_Typ is the access type of the related allocation. Loc is the\n+   --  source location of the related allocator.\n+\n    --------------------------------------------\n    -- Task and Protected Object finalization --\n    --------------------------------------------"}, {"sha": "de51c76781eb2f4ab2beebe981dd90df8465a40f", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -21324,6 +21324,10 @@ information about several specific platforms.\n @item @b{ppc-aix}\n @item @code{@ @ }@i{rts-native (default)}\n @item @code{@ @ @ @ }Tasking    @tab native AIX threads\n+@item @code{@ @ @ @ }Exceptions @tab ZCX\n+@*\n+@item @code{@ @ }@i{rts-sjlj}\n+@item @code{@ @ @ @ }Tasking    @tab native AIX threads\n @item @code{@ @ @ @ }Exceptions @tab SJLJ\n @*\n @item @b{ppc-darwin}\n@@ -21366,6 +21370,10 @@ information about several specific platforms.\n @item @b{x86-solaris}\n @item @code{@ @ }@i{rts-native (default)}\n @item @code{@ @ @ @ }Tasking    @tab native Solaris threads\n+@item @code{@ @ @ @ }Exceptions @tab ZCX\n+@*\n+@item @code{@ @ }@i{rts-sjlj}\n+@item @code{@ @ @ @ }Tasking    @tab native Solaris threads library\n @item @code{@ @ @ @ }Exceptions @tab SJLJ\n @*\n @item @b{x86-windows}"}, {"sha": "4706c0045b1843472fd13b39060fc3a8e06b1b23", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -178,7 +178,9 @@ begin\n                         pragma Assert (SCO_Table.Table (Start).C1 = 's');\n                      end loop;\n \n-                     Write_Info_Terminate;\n+                     if Ctr > 0 then\n+                        Write_Info_Terminate;\n+                     end if;\n \n                   --  Statement continuations should not occur since they\n                   --  are supposed to have been handled in the loop above."}, {"sha": "af4a5e5091d1b8c03f7fb0fb2d066d598855da35", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -130,7 +130,7 @@ extern void __gnat_setup_current_excep (_Unwind_Exception *);\n typedef struct\n {\n   _Unwind_Action phase;\n-  char * description;\n+  const char * description;\n } phase_descriptor;\n \n static const phase_descriptor phase_descriptors[]\n@@ -511,21 +511,38 @@ typedef struct\n \n } region_descriptor;\n \n-static void\n-db_region_for (region_descriptor *region, _Unwind_Context *uw_context)\n+/* Extract and adjust the IP (instruction pointer) from an exception\n+   context.  */\n+\n+static _Unwind_Ptr\n+get_ip_from_context (_Unwind_Context *uw_context)\n {\n   int ip_before_insn = 0;\n #ifdef HAVE_GETIPINFO\n   _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);\n #else\n   _Unwind_Ptr ip = _Unwind_GetIP (uw_context);\n #endif\n+  /* Subtract 1 if necessary because GetIPInfo yields a call return address\n+     in this case, while we are interested in information for the call point.\n+     This does not always yield the exact call instruction address but always\n+     brings the IP back within the corresponding region.  */\n   if (!ip_before_insn)\n     ip--;\n \n+  return ip;\n+}\n+\n+static void\n+db_region_for (region_descriptor *region, _Unwind_Context *uw_context)\n+{\n+  _Unwind_Ptr ip;\n+\n   if (! (db_accepted_codes () & DB_REGIONS))\n     return;\n \n+  ip = get_ip_from_context (uw_context);\n+\n   db (DB_REGIONS, \"For ip @ 0x%08x => \", ip);\n \n   if (region->lsda)\n@@ -651,14 +668,7 @@ typedef struct\n static void\n db_action_for (action_descriptor *action, _Unwind_Context *uw_context)\n {\n-  int ip_before_insn = 0;\n-#ifdef HAVE_GETIPINFO\n-  _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);\n-#else\n-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context);\n-#endif\n-  if (!ip_before_insn)\n-    ip--;\n+  _Unwind_Ptr ip = get_ip_from_context (uw_context);\n \n   db (DB_ACTIONS, \"For ip @ 0x%08x => \", ip);\n \n@@ -706,16 +716,7 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n                           region_descriptor *region,\n                           action_descriptor *action)\n {\n-  int ip_before_insn = 0;\n-#ifdef HAVE_GETIPINFO\n-  _Unwind_Ptr call_site = _Unwind_GetIPInfo (uw_context, &ip_before_insn);\n-#else\n-  _Unwind_Ptr call_site = _Unwind_GetIP (uw_context);\n-#endif\n-  /* Subtract 1 if necessary because GetIPInfo returns the actual call site\n-     value + 1 in this case.  */\n-  if (!ip_before_insn)\n-    call_site--;\n+  _Unwind_Ptr call_site = get_ip_from_context (uw_context);\n \n   /* call_site is a direct index into the call-site table, with two special\n      values : -1 for no-action and 0 for \"terminate\".  The latter should never\n@@ -772,18 +773,7 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n                           action_descriptor *action)\n {\n   const unsigned char *p = region->call_site_table;\n-  int ip_before_insn = 0;\n-#ifdef HAVE_GETIPINFO\n-  _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);\n-#else\n-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context);\n-#endif\n-  /* Subtract 1 if necessary because GetIPInfo yields a call return address\n-     in this case, while we are interested in information for the call point.\n-     This does not always yield the exact call instruction address but always\n-     brings the IP back within the corresponding region.  */\n-  if (!ip_before_insn)\n-    ip--;\n+  _Unwind_Ptr ip = get_ip_from_context (uw_context);\n \n   /* Unless we are able to determine otherwise...  */\n   action->kind = nothing;"}, {"sha": "2a0e2deef625668ad9d2b3fb18eebd596632668e", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -801,6 +801,7 @@ package Rtsfind is\n      RE_Finalization_Master,             -- System.Finalization_Masters\n      RE_Finalization_Master_Ptr,         -- System.Finalization_Masters\n      RE_Set_Base_Pool,                   -- System.Finalization_Masters\n+     RE_Set_Finalize_Address,            -- System.Finalization_Masters\n \n      RE_Root_Controlled,                 -- System.Finalization_Root\n      RE_Root_Controlled_Ptr,             -- System.Finalization_Root\n@@ -1987,6 +1988,7 @@ package Rtsfind is\n      RE_Finalization_Master              => System_Finalization_Masters,\n      RE_Finalization_Master_Ptr          => System_Finalization_Masters,\n      RE_Set_Base_Pool                    => System_Finalization_Masters,\n+     RE_Set_Finalize_Address             => System_Finalization_Masters,\n \n      RE_Root_Controlled                  => System_Finalization_Root,\n      RE_Root_Controlled_Ptr              => System_Finalization_Root,"}, {"sha": "857db696b009bff1ec18ae80484688b8855ac361", "filename": "gcc/ada/s-finmas.adb", "status": "modified", "additions": 174, "deletions": 34, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-finmas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-finmas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -30,7 +30,8 @@\n ------------------------------------------------------------------------------\n \n with Ada.Exceptions;          use Ada.Exceptions;\n-\n+with System.Address_Image;\n+with System.IO;               use System.IO;\n with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n \n@@ -84,16 +85,16 @@ package body System.Finalization_Masters is\n \n    procedure Detach (N : not null FM_Node_Ptr) is\n    begin\n-      --  N must be attached to some list\n-\n-      pragma Assert (N.Next /= null and then N.Prev /= null);\n-\n-      Lock_Task.all;\n+      if N.Prev /= null and then N.Next /= null then\n+         Lock_Task.all;\n \n-      N.Prev.Next := N.Next;\n-      N.Next.Prev := N.Prev;\n+         N.Prev.Next := N.Next;\n+         N.Next.Prev := N.Prev;\n+         N.Prev := null;\n+         N.Next := null;\n \n-      Unlock_Task.all;\n+         Unlock_Task.all;\n+      end if;\n \n       --  Note: No need to unlock in case of an exception because the above\n       --  code can never raise one.\n@@ -109,6 +110,20 @@ package body System.Finalization_Masters is\n       Obj_Addr : Address;\n       Raised   : Boolean := False;\n \n+      function Is_Empty_List (L : not null FM_Node_Ptr) return Boolean;\n+      --  Determine whether a list contains only one element, the dummy head\n+\n+      -------------------\n+      -- Is_Empty_List --\n+      -------------------\n+\n+      function Is_Empty_List (L : not null FM_Node_Ptr) return Boolean is\n+      begin\n+         return L.Next = L and then L.Prev = L;\n+      end Is_Empty_List;\n+\n+   --  Start of processing for Finalize\n+\n    begin\n       --  It is possible for multiple tasks to cause the finalization of the\n       --  same master. Let only one task finalize the objects.\n@@ -124,37 +139,29 @@ package body System.Finalization_Masters is\n \n       Master.Finalization_Started := True;\n \n-      --  Skip the dummy head\n+      while not Is_Empty_List (Master.Objects'Unchecked_Access) loop\n+         Curr_Ptr := Master.Objects.Next;\n \n-      Curr_Ptr := Master.Objects.Next;\n-      while Curr_Ptr /= Master.Objects'Unchecked_Access loop\n+         Detach (Curr_Ptr);\n \n-         --  If primitive Finalize_Address is not set, then the expansion of\n-         --  the designated type or that of the allocator failed. This is a\n-         --  serious error.\n-\n-         if Master.Finalize_Address = null then\n-            raise Program_Error\n-              with \"primitive Finalize_Address not available\";\n-         end if;\n+         if Master.Finalize_Address /= null then\n \n-         --  Skip the list header in order to offer proper object layout for\n-         --  finalization and call Finalize_Address.\n+            --  Skip the list header in order to offer proper object layout for\n+            --  finalization and call Finalize_Address.\n \n-         Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n+            Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n \n-         begin\n-            Master.Finalize_Address (Obj_Addr);\n+            begin\n+               Master.Finalize_Address (Obj_Addr);\n \n-         exception\n-            when Fin_Occur : others =>\n-               if not Raised then\n-                  Raised := True;\n-                  Save_Occurrence (Ex_Occur, Fin_Occur);\n-               end if;\n-         end;\n-\n-         Curr_Ptr := Curr_Ptr.Next;\n+            exception\n+               when Fin_Occur : others =>\n+                  if not Raised then\n+                     Raised := True;\n+                     Save_Occurrence (Ex_Occur, Fin_Occur);\n+                  end if;\n+            end;\n+         end if;\n       end loop;\n \n       --  If the finalization of a particular object failed or Finalize_Address\n@@ -195,6 +202,127 @@ package body System.Finalization_Masters is\n       Master.Objects.Prev := Master.Objects'Unchecked_Access;\n    end Initialize;\n \n+   --------\n+   -- pm --\n+   --------\n+\n+   procedure pm (Master : Finalization_Master) is\n+      Head      : constant FM_Node_Ptr := Master.Objects'Unrestricted_Access;\n+      Head_Seen : Boolean := False;\n+      N_Ptr     : FM_Node_Ptr;\n+\n+   begin\n+      --  Output the basic contents of a master\n+\n+      --    Master   : 0x123456789\n+      --    Base_Pool: null <or> 0x123456789\n+      --    Fin_Addr : null <or> 0x123456789\n+      --    Fin_Start: TRUE <or> FALSE\n+\n+      Put (\"Master   : \");\n+      Put_Line (Address_Image (Master'Address));\n+\n+      Put (\"Base_Pool: \");\n+\n+      if Master.Base_Pool = null then\n+         Put_Line (\" null\");\n+      else\n+         Put_Line (Address_Image (Master.Base_Pool'Address));\n+      end if;\n+\n+      Put (\"Fin_Addr : \");\n+\n+      if Master.Finalize_Address = null then\n+         Put_Line (\"null\");\n+      else\n+         Put_Line (Address_Image (Master.Finalize_Address'Address));\n+      end if;\n+\n+      Put (\"Fin_Start: \");\n+      Put_Line (Master.Finalization_Started'Img);\n+\n+      --  Output all chained elements. The format is the following:\n+\n+      --    ^ <or> ? <or> null\n+      --    |Header: 0x123456789 (dummy head)\n+      --    |  Prev: 0x123456789\n+      --    |  Next: 0x123456789\n+      --    V\n+\n+      --  ^ - the current element points back to the correct element\n+      --  ? - the current element points back to an erroneous element\n+      --  n - the current element points back to null\n+\n+      --  Header - the address of the list header\n+      --  Prev   - the address of the list header which the current element\n+      --         - points back to\n+      --  Next   - the address of the list header which the current element\n+      --         - points to\n+      --  (dummy head) - present if dummy head\n+\n+      N_Ptr := Head;\n+      while N_Ptr /= null loop -- Should never be null; we being defensive\n+         Put_Line (\"V\");\n+\n+         --  We see the head initially; we want to exit when we see the head a\n+         --  SECOND time.\n+\n+         if N_Ptr = Head then\n+            exit when Head_Seen;\n+\n+            Head_Seen := True;\n+         end if;\n+\n+         --  The current element is null. This should never happen since the\n+         --  list is circular.\n+\n+         if N_Ptr.Prev = null then\n+            Put_Line (\"null (ERROR)\");\n+\n+         --  The current element points back to the correct element\n+\n+         elsif N_Ptr.Prev.Next = N_Ptr then\n+            Put_Line (\"^\");\n+\n+         --  The current element points to an erroneous element\n+\n+         else\n+            Put_Line (\"? (ERROR)\");\n+         end if;\n+\n+         --  Output the header and fields\n+\n+         Put (\"|Header: \");\n+         Put (Address_Image (N_Ptr.all'Address));\n+\n+         --  Detect the dummy head\n+\n+         if N_Ptr = Head then\n+            Put_Line (\" (dummy head)\");\n+         else\n+            Put_Line (\"\");\n+         end if;\n+\n+         Put (\"|  Prev: \");\n+\n+         if N_Ptr.Prev = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (N_Ptr.Prev.all'Address));\n+         end if;\n+\n+         Put (\"|  Next: \");\n+\n+         if N_Ptr.Next = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (N_Ptr.Next.all'Address));\n+         end if;\n+\n+         N_Ptr := N_Ptr.Next;\n+      end loop;\n+   end pm;\n+\n    -------------------\n    -- Set_Base_Pool --\n    -------------------\n@@ -207,4 +335,16 @@ package body System.Finalization_Masters is\n       Master.Base_Pool := Pool_Ptr;\n    end Set_Base_Pool;\n \n+   --------------------------\n+   -- Set_Finalize_Address --\n+   --------------------------\n+\n+   procedure Set_Finalize_Address\n+     (Master       : in out Finalization_Master;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr)\n+   is\n+   begin\n+      Master.Finalize_Address := Fin_Addr_Ptr;\n+   end Set_Finalize_Address;\n+\n end System.Finalization_Masters;"}, {"sha": "87a607678bcc3556844be6cf99aa46ec4d73d722", "filename": "gcc/ada/s-finmas.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-finmas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-finmas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.ads?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -131,9 +131,17 @@ package System.Finalization_Masters is\n    overriding procedure Initialize (Master : in out Finalization_Master);\n    --  Initialize the dummy head of a finalization master\n \n+   procedure pm (Master : Finalization_Master);\n+   --  Debug routine, outputs the contents of a master\n+\n    procedure Set_Base_Pool\n      (Master   : in out Finalization_Master;\n       Pool_Ptr : Any_Storage_Pool_Ptr);\n    --  Set the underlying pool of a finalization master\n \n+   procedure Set_Finalize_Address\n+     (Master       : in out Finalization_Master;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr);\n+   --  Set the clean up routine of a finalization master\n+\n end System.Finalization_Masters;"}, {"sha": "017392ca6ec67f4105e3208963dccd46266e5069", "filename": "gcc/ada/s-gearop.adb", "status": "modified", "additions": 235, "deletions": 1, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-gearop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-gearop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 2006-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2006-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,27 @@ package body System.Generic_Array_Operations is\n       First : Integer) return Integer;\n    pragma Inline_Always (Check_Unit_Last);\n \n+   --------------\n+   -- Diagonal --\n+   --------------\n+\n+   function Diagonal (A : Matrix) return Vector is\n+\n+      N : constant Natural := Natural'Min (A'Length (1), A'Length (2));\n+      R : Vector (A'First (1) .. A'First (1) + N - 1);\n+\n+   begin\n+      for J in 0 .. N - 1 loop\n+         R (R'First + J) := A (A'First (1) + J, A'First (2) + J);\n+      end loop;\n+\n+      return R;\n+   end Diagonal;\n+\n+   --------------------------\n+   -- Square_Matrix_Length --\n+   --------------------------\n+\n    function Square_Matrix_Length (A : Matrix) return Natural is\n    begin\n       if A'Length (1) /= A'Length (2) then\n@@ -73,6 +94,196 @@ package body System.Generic_Array_Operations is\n       return First + (Order - 1);\n    end Check_Unit_Last;\n \n+   ---------------------\n+   -- Back_Substitute --\n+   ---------------------\n+\n+   procedure Back_Substitute (M, N : in out Matrix) is\n+      pragma Assert (M'First (1) = N'First (1) and then\n+                     M'Last  (1) = N'Last (1));\n+      Max_Col : Integer := M'Last (2);\n+\n+      procedure Sub_Row\n+        (M      : in out Matrix;\n+         Target : Integer;\n+         Source : Integer;\n+         Factor : Scalar);\n+\n+      procedure Sub_Row\n+        (M      : in out Matrix;\n+         Target : Integer;\n+         Source : Integer;\n+         Factor : Scalar) is\n+      begin\n+         for J in M'Range (2) loop\n+            M (Target, J) := M (Target, J) - Factor * M (Source, J);\n+         end loop;\n+      end Sub_Row;\n+\n+   begin\n+      for Row in reverse M'Range (1) loop\n+         Find_Non_Zero : for Col in M'First (2) .. Max_Col loop\n+            if Is_Non_Zero (M (Row, Col)) then\n+               --  Found first non-zero element, so subtract a multiple\n+               --  of this row from all higher rows, to reduce all other\n+               --  elements in this column to zero.\n+\n+               for J in M'First (1) .. Row - 1 loop\n+                  Sub_Row (N, J, Row, (M (J, Col) / M (Row, Col)));\n+                  Sub_Row (M, J, Row, (M (J, Col) / M (Row, Col)));\n+               end loop;\n+\n+               Max_Col := Col - 1;\n+               exit Find_Non_Zero;\n+            end if;\n+         end loop Find_Non_Zero;\n+      end loop;\n+   end Back_Substitute;\n+\n+   -----------------------\n+   -- Forward_Eliminate --\n+   -----------------------\n+\n+   procedure Forward_Eliminate\n+     (M   : in out Matrix;\n+      N   : in out Matrix;\n+      Det : out Scalar)\n+   is\n+      pragma Assert (M'First (1) = N'First (1) and then\n+                     M'Last  (1) = N'Last (1));\n+\n+      function \"abs\" (X : Scalar) return Scalar is\n+        (if X < Zero then Zero - X else X);\n+\n+      procedure Sub_Row\n+        (M : in out Matrix;\n+         Target : Integer;\n+         Source : Integer;\n+         Factor : Scalar);\n+\n+      procedure Divide_Row\n+        (M, N  : in out Matrix;\n+         Row   : Integer;\n+         Scale : Scalar);\n+\n+      procedure Switch_Row\n+        (M, N  : in out Matrix;\n+         Row_1 : Integer;\n+         Row_2 : Integer);\n+\n+      -------------\n+      -- Sub_Row --\n+      -------------\n+\n+      procedure Sub_Row\n+        (M      : in out Matrix;\n+         Target : Integer;\n+         Source : Integer;\n+         Factor : Scalar) is\n+      begin\n+         for J in M'Range (2) loop\n+            M (Target, J) := M (Target, J) - Factor * M (Source, J);\n+         end loop;\n+      end Sub_Row;\n+\n+      ----------------\n+      -- Divide_Row --\n+      ----------------\n+\n+      procedure Divide_Row\n+        (M, N  : in out Matrix;\n+         Row   : Integer;\n+         Scale : Scalar)\n+      is\n+      begin\n+         Det := Det * Scale;\n+\n+         for J in M'Range (2) loop\n+            M (Row, J) := M (Row, J) / Scale;\n+         end loop;\n+\n+         for J in N'Range (2) loop\n+            N (Row - M'First (1) + N'First (1), J)\n+               := N (Row - M'First (1) + N'First (1), J) / Scale;\n+         end loop;\n+      end Divide_Row;\n+\n+      ----------------\n+      -- Switch_Row --\n+      ----------------\n+\n+      procedure Switch_Row\n+        (M, N  : in out Matrix;\n+         Row_1 : Integer;\n+         Row_2 : Integer)\n+      is\n+         procedure Swap (X, Y : in out Scalar);\n+         --  Exchange the values of X and Y\n+\n+         procedure Swap (X, Y : in out Scalar) is\n+            T : constant Scalar := X;\n+         begin\n+            X := Y;\n+            Y := T;\n+         end Swap;\n+\n+      begin\n+         if Row_1 /= Row_2 then\n+            Det := Zero - Det;\n+\n+            for J in M'Range (2) loop\n+               Swap (M (Row_1, J), M (Row_2, J));\n+            end loop;\n+\n+            for J in N'Range (2) loop\n+               Swap (N (Row_1 - M'First (1) + N'First (1), J),\n+                     N (Row_2 - M'First (1) + N'First (1), J));\n+            end loop;\n+         end if;\n+      end Switch_Row;\n+\n+      I   : Integer := M'First (1);\n+\n+   begin -- Forward_Eliminate\n+      Det := One;\n+\n+      for J in M'Range (2) loop\n+         declare\n+            Max_I   : Integer := I;\n+            Max_Abs : Scalar := Zero;\n+         begin\n+            --  Find best pivot in column J, starting in row I.\n+            for K in I .. M'Last (1) loop\n+               declare\n+                  New_Abs : constant Scalar := abs M (K, J);\n+               begin\n+                  if Max_Abs < New_Abs then\n+                     Max_Abs := New_Abs;\n+                     Max_I := K;\n+                  end if;\n+               end;\n+            end loop;\n+\n+            if Zero < Max_Abs then\n+               Switch_Row (M, N, I, Max_I);\n+               Divide_Row (M, N, I, M (I, J));\n+\n+               for U in I + 1 .. M'Last (1) loop\n+                  Sub_Row (N, U, I, M (U, J));\n+                  Sub_Row (M, U, I, M (U, J));\n+               end loop;\n+\n+               exit when I >= M'Last (1);\n+\n+               I := I + 1;\n+\n+            else\n+               Det := Zero; --  Zero, but we don't have literals\n+            end if;\n+         end;\n+      end loop;\n+   end Forward_Eliminate;\n+\n    -------------------\n    -- Inner_Product --\n    -------------------\n@@ -97,6 +308,15 @@ package body System.Generic_Array_Operations is\n       return R;\n    end Inner_Product;\n \n+   -------------\n+   -- L2_Norm --\n+   -------------\n+\n+   function L2_Norm (X : Vector) return Scalar is\n+   begin\n+      return Sqrt (Inner_Product (X, X));\n+   end L2_Norm;\n+\n    ----------------------------------\n    -- Matrix_Elementwise_Operation --\n    ----------------------------------\n@@ -402,6 +622,20 @@ package body System.Generic_Array_Operations is\n       return R;\n    end Outer_Product;\n \n+   -----------------\n+   -- Swap_Column --\n+   -----------------\n+\n+   procedure Swap_Column (A : in out Matrix; Left, Right : Integer) is\n+      Temp : Scalar;\n+   begin\n+      for J in A'Range (1) loop\n+         Temp := A (J, Left);\n+         A (J, Left) := A (J, Right);\n+         A (J, Right) := Temp;\n+      end loop;\n+   end Swap_Column;\n+\n    ---------------\n    -- Transpose --\n    ---------------"}, {"sha": "51e3b92c2017df8d9eba5a83ae262b2d7dc9b2ea", "filename": "gcc/ada/s-gearop.ads", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-gearop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-gearop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.ads?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,6 +32,50 @@\n package System.Generic_Array_Operations is\n pragma Pure (Generic_Array_Operations);\n \n+   ---------------------\n+   -- Back_Substitute --\n+   ---------------------\n+\n+   generic\n+      type Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+      with function \"-\" (Left, Right : Scalar) return Scalar is <>;\n+      with function \"*\" (Left, Right : Scalar) return Scalar is <>;\n+      with function \"/\" (Left, Right : Scalar) return Scalar is <>;\n+      with function Is_Non_Zero (X : Scalar) return Boolean is <>;\n+   procedure Back_Substitute (M, N : in out Matrix);\n+\n+   --------------\n+   -- Diagonal --\n+   --------------\n+\n+   generic\n+      type Scalar is private;\n+      type Vector is array (Integer range <>) of Scalar;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+   function Diagonal (A : Matrix) return Vector;\n+\n+   -----------------------\n+   -- Forward_Eliminate --\n+   -----------------------\n+\n+   --  Use elementary row operations to put square matrix M in row echolon\n+   --  form. Identical row operations are performed on matrix N, must have the\n+   --  same number of rows as M.\n+\n+   generic\n+      type Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+      with function \"-\" (Left, Right : Scalar) return Scalar is <>;\n+      with function \"*\" (Left, Right : Scalar) return Scalar is <>;\n+      with function \"/\" (Left, Right : Scalar) return Scalar is <>;\n+      with function \"<\" (Left, Right : Scalar) return Boolean is <>;\n+      Zero, One : Scalar;\n+   procedure Forward_Eliminate\n+     (M   : in out Matrix;\n+      N   : in out Matrix;\n+      Det : out Scalar);\n+\n    --------------------------\n    -- Square_Matrix_Length --\n    --------------------------\n@@ -242,6 +286,17 @@ pragma Pure (Generic_Array_Operations);\n      (Left  : Left_Vector;\n       Right : Right_Vector) return Result_Scalar;\n \n+   -------------\n+   -- L2_Norm --\n+   -------------\n+\n+   generic\n+      type Scalar is private;\n+      type Vector is array (Integer range <>) of Scalar;\n+      with function Inner_Product (Left, Right : Vector) return Scalar is <>;\n+      with function Sqrt (X : Scalar) return Scalar is <>;\n+   function L2_Norm (X : Vector) return Scalar;\n+\n    -------------------\n    -- Outer_Product --\n    -------------------\n@@ -332,6 +387,15 @@ pragma Pure (Generic_Array_Operations);\n      (Left  : Left_Matrix;\n       Right : Right_Matrix) return Result_Matrix;\n \n+   -----------------\n+   -- Swap_Column --\n+   -----------------\n+\n+   generic\n+      type Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+   procedure Swap_Column (A : in out Matrix; Left, Right : Integer);\n+\n    ---------------\n    -- Transpose --\n    ---------------"}, {"sha": "27f6e54a5752b497db0bc7c07de13dd54584b93e", "filename": "gcc/ada/s-soflin.adb", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-soflin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-soflin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -46,11 +46,6 @@ package body System.Soft_Links is\n \n    package SST renames System.Secondary_Stack;\n \n-   NT_Exc_Stack : array (0 .. 8192) of aliased Character;\n-   for NT_Exc_Stack'Alignment use Standard'Maximum_Alignment;\n-   --  Allocate an exception stack for the main program to use.\n-   --  This is currently only used under VMS.\n-\n    NT_TSD : TSD;\n    --  Note: we rely on the default initialization of NT_TSD\n \n@@ -173,24 +168,6 @@ package body System.Soft_Links is\n       return NT_TSD.Current_Excep'Access;\n    end Get_Current_Excep_NT;\n \n-   ---------------------------\n-   -- Get_Exc_Stack_Addr_NT --\n-   ---------------------------\n-\n-   function Get_Exc_Stack_Addr_NT return Address is\n-   begin\n-      return NT_Exc_Stack (NT_Exc_Stack'Last)'Address;\n-   end Get_Exc_Stack_Addr_NT;\n-\n-   -----------------------------\n-   -- Get_Exc_Stack_Addr_Soft --\n-   -----------------------------\n-\n-   function Get_Exc_Stack_Addr_Soft return Address is\n-   begin\n-      return Get_Exc_Stack_Addr.all;\n-   end Get_Exc_Stack_Addr_Soft;\n-\n    ------------------------\n    -- Get_GNAT_Exception --\n    ------------------------"}, {"sha": "f2d858bce8a4a764c43b0a43d1e717e3fbe17fbf", "filename": "gcc/ada/s-soflin.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-soflin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-soflin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.ads?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -243,9 +243,6 @@ package System.Soft_Links is\n    Get_Sec_Stack_Addr : Get_Address_Call := Get_Sec_Stack_Addr_NT'Access;\n    Set_Sec_Stack_Addr : Set_Address_Call := Set_Sec_Stack_Addr_NT'Access;\n \n-   function Get_Exc_Stack_Addr_NT return Address;\n-   Get_Exc_Stack_Addr : Get_Address_Call := Get_Exc_Stack_Addr_NT'Access;\n-\n    function Get_Current_Excep_NT return EOA;\n \n    Get_Current_Excep : Get_EOA_Call := Get_Current_Excep_NT'Access;\n@@ -389,8 +386,6 @@ package System.Soft_Links is\n    pragma Inline (Get_Sec_Stack_Addr_Soft);\n    pragma Inline (Set_Sec_Stack_Addr_Soft);\n \n-   function Get_Exc_Stack_Addr_Soft return Address;\n-\n    --  The following is a dummy record designed to mimic Communication_Block as\n    --  defined in s-tpobop.ads:\n "}, {"sha": "bf3a87e662f9b5812a551727c834d7b630098776", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -250,14 +250,14 @@ package body System.Storage_Pools.Subpools is\n          N_Ptr := Address_To_FM_Node_Ptr\n                    (N_Addr + Header_And_Padding - Header_Offset);\n \n-         if Master.Finalize_Address = null then\n-            Master.Finalize_Address := Fin_Address;\n-         end if;\n-\n          --  Prepend the allocated object to the finalization master\n \n          Attach (N_Ptr, Master.Objects'Unchecked_Access);\n \n+         if Master.Finalize_Address = null then\n+            Master.Finalize_Address := Fin_Address;\n+         end if;\n+\n          --  Move the address from the hidden list header to the start of the\n          --  object. This operation effectively hides the list header.\n "}, {"sha": "1759c5084c7ca47714dc5aadf59b61c379071d85", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -136,9 +136,6 @@ package body System.Task_Primitives.Operations is\n      new Ada.Unchecked_Conversion\n        (Task_Id, System.Task_Primitives.Task_Address);\n \n-   function Get_Exc_Stack_Addr return Address;\n-   --  Replace System.Soft_Links.Get_Exc_Stack_Addr_NT\n-\n    procedure Timer_Sleep_AST (ID : Address);\n    pragma Convention (C, Timer_Sleep_AST);\n    --  Signal the condition variable when AST fires\n@@ -755,7 +752,6 @@ package body System.Task_Primitives.Operations is\n \n       if Result = 0 then\n          Succeeded := True;\n-         Self_ID.Common.LL.Exc_Stack_Ptr := new Exc_Stack_T;\n \n       else\n          if not Single_Lock then\n@@ -770,15 +766,6 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Initialize_TCB;\n \n-   ------------------------\n-   -- Get_Exc_Stack_Addr --\n-   ------------------------\n-\n-   function Get_Exc_Stack_Addr return Address is\n-   begin\n-      return Self.Common.LL.Exc_Stack_Ptr (Exc_Stack_T'Last)'Address;\n-   end Get_Exc_Stack_Addr;\n-\n    -----------------\n    -- Create_Task --\n    -----------------\n@@ -859,9 +846,6 @@ package body System.Task_Primitives.Operations is\n       procedure Free is new\n         Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n-      procedure Free is new Ada.Unchecked_Deallocation\n-       (Exc_Stack_T, Exc_Stack_Ptr_T);\n-\n    begin\n       if not Single_Lock then\n          Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n@@ -875,7 +859,6 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (T.Common.LL.Exc_Stack_Ptr);\n       Free (Tmp);\n \n       if Is_Self then\n@@ -1247,8 +1230,6 @@ package body System.Task_Primitives.Operations is\n    begin\n       Environment_Task_Id := Environment_Task;\n \n-      SSL.Get_Exc_Stack_Addr := Get_Exc_Stack_Addr'Access;\n-\n       --  Initialize the lock used to synchronize chain of all ATCBs\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);"}, {"sha": "891dee28c9d6f03706fd1ec6e1b4a24a88783d97", "filename": "gcc/ada/s-taspri-vms.ads", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-taspri-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b254da66e7a3155dcd88d5ec68b1a75fba1bbced/gcc%2Fada%2Fs-taspri-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-vms.ads?ref=b254da66e7a3155dcd88d5ec68b1a75fba1bbced", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,10 +78,6 @@ package System.Task_Primitives is\n \n private\n \n-   type Exc_Stack_T is array (0 .. 8192) of aliased Character;\n-   for Exc_Stack_T'Alignment use Standard'Maximum_Alignment;\n-   type Exc_Stack_Ptr_T is access all Exc_Stack_T;\n-\n    type Lock is record\n       L         : aliased System.OS_Interface.pthread_mutex_t;\n       Prio      : Interfaces.C.int;\n@@ -121,9 +117,6 @@ private\n       L : aliased RTS_Lock;\n       --  Protection for all components is lock L\n \n-      Exc_Stack_Ptr : Exc_Stack_Ptr_T;\n-      --  ??? This needs comments\n-\n       AST_Pending : Boolean;\n       --  Used to detect delay and sleep timeouts\n "}]}