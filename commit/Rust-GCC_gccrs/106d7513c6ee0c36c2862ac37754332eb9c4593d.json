{"sha": "106d7513c6ee0c36c2862ac37754332eb9c4593d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA2ZDc1MTNjNmVlMGMzNmMyODYyYWMzNzc1NDMzMmViOWM0NTkzZA==", "commit": {"author": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-07-23T16:02:15Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-07-23T16:02:15Z"}, "message": "Revert r212893:\n\n\tPR target/55701\n\t* config/arm/arm.md (setmem): New pattern.\n\t* config/arm/arm-protos.h (struct tune_params): New fields.\n\t(arm_gen_setmem): New prototype.\n\t* config/arm/arm.c (arm_slowmul_tune): Initialize new fields.\n\t(arm_fastmul_tune, arm_strongarm_tune, arm_xscale_tune): Ditto.\n\t(arm_9e_tune, arm_v6t2_tune, arm_cortex_tune): Ditto.\n\t(arm_cortex_a8_tune, arm_cortex_a7_tune): Ditto.\n\t(arm_cortex_a15_tune, arm_cortex_a53_tune): Ditto.\n\t(arm_cortex_a57_tune, arm_cortex_a5_tune): Ditto.\n\t(arm_cortex_a9_tune, arm_cortex_a12_tune): Ditto.\n\t(arm_v7m_tune, arm_v6m_tune, arm_fa726te_tune): Ditto.\n\t(arm_const_inline_cost): New function.\n\t(arm_block_set_max_insns): New function.\n\t(arm_block_set_non_vect_profit_p): New function.\n\t(arm_block_set_vect_profit_p): New function.\n\t(arm_block_set_unaligned_vect): New function.\n\t(arm_block_set_aligned_vect): New function.\n\t(arm_block_set_unaligned_non_vect): New function.\n\t(arm_block_set_aligned_non_vect): New function.\n\t(arm_block_set_vect, arm_gen_setmem): New functions.\n\n\tPR target/55701\n\t* gcc.target/arm/memset-inline-1.c: New test.\n\t* gcc.target/arm/memset-inline-2.c: New test.\n\t* gcc.target/arm/memset-inline-3.c: New test.\n\t* gcc.target/arm/memset-inline-4.c: New test.\n\t* gcc.target/arm/memset-inline-5.c: New test.\n\t* gcc.target/arm/memset-inline-6.c: New test.\n\t* gcc.target/arm/memset-inline-7.c: New test.\n\t* gcc.target/arm/memset-inline-8.c: New test.\n\t* gcc.target/arm/memset-inline-9.c: New test.\n\n\tRevert r212892:\n\t* config/arm/arm.c (output_move_neon): Handle REG explicitly.\n\nFrom-SVN: r212948", "tree": {"sha": "5f52000ee86743c1a516e449d4811edf32aae916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f52000ee86743c1a516e449d4811edf32aae916"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/106d7513c6ee0c36c2862ac37754332eb9c4593d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106d7513c6ee0c36c2862ac37754332eb9c4593d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106d7513c6ee0c36c2862ac37754332eb9c4593d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106d7513c6ee0c36c2862ac37754332eb9c4593d/comments", "author": null, "committer": null, "parents": [{"sha": "7bf7a695cc3ab52499970f59a019ef4ad6648543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf7a695cc3ab52499970f59a019ef4ad6648543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf7a695cc3ab52499970f59a019ef4ad6648543"}], "stats": {"total": 1223, "additions": 26, "deletions": 1197}, "files": [{"sha": "be5e72abff9ec383aacf31b70cb04481ec1d5e5b", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106d7513c6ee0c36c2862ac37754332eb9c4593d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106d7513c6ee0c36c2862ac37754332eb9c4593d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=106d7513c6ee0c36c2862ac37754332eb9c4593d", "patch": "@@ -278,10 +278,6 @@ struct tune_params\n   /* Prefer 32-bit encoding instead of 16-bit encoding where subset of flags\n      would be set.  */\n   bool disparage_partial_flag_setting_t16_encodings;\n-  /* Prefer to inline string operations like memset by using Neon.  */\n-  bool string_ops_prefer_neon;\n-  /* Maximum number of instructions to inline calls to memset.  */\n-  int max_insns_inline_memset;\n };\n \n extern const struct tune_params *current_tune;\n@@ -294,7 +290,6 @@ extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n #endif /* RTX_CODE */\n \n-extern bool arm_gen_setmem (rtx *);\n extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n extern bool arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n "}, {"sha": "7e62ba5b9ebd4630a942c3016a819389dcab0d5f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 26, "deletions": 590, "changes": 616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106d7513c6ee0c36c2862ac37754332eb9c4593d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106d7513c6ee0c36c2862ac37754332eb9c4593d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=106d7513c6ee0c36c2862ac37754332eb9c4593d", "patch": "@@ -1698,9 +1698,7 @@ const struct tune_params arm_slowmul_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_fastmul_tune =\n@@ -1717,9 +1715,7 @@ const struct tune_params arm_fastmul_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n /* StrongARM has early execution of branches, so a sequence that is worth\n@@ -1739,9 +1735,7 @@ const struct tune_params arm_strongarm_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_xscale_tune =\n@@ -1758,9 +1752,7 @@ const struct tune_params arm_xscale_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_9e_tune =\n@@ -1777,9 +1769,7 @@ const struct tune_params arm_9e_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_v6t2_tune =\n@@ -1796,9 +1786,7 @@ const struct tune_params arm_v6t2_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n /* Generic Cortex tuning.  Use more specific tunings if appropriate.  */\n@@ -1816,9 +1804,7 @@ const struct tune_params arm_cortex_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_cortex_a8_tune =\n@@ -1835,9 +1821,7 @@ const struct tune_params arm_cortex_a8_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_cortex_a7_tune =\n@@ -1854,9 +1838,7 @@ const struct tune_params arm_cortex_a7_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,\t\t\t/* Vectorizer costs.  */\n   false,\t\t\t\t\t/* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_cortex_a15_tune =\n@@ -1873,9 +1855,7 @@ const struct tune_params arm_cortex_a15_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  true, true,                                   /* Prefer 32-bit encodings.  */\n-  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  true, true                                    /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_cortex_a53_tune =\n@@ -1892,9 +1872,7 @@ const struct tune_params arm_cortex_a53_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,\t\t\t/* Vectorizer costs.  */\n   false,\t\t\t\t\t/* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_cortex_a57_tune =\n@@ -1911,9 +1889,7 @@ const struct tune_params arm_cortex_a57_tune =\n   {true, true},                                /* Prefer non short circuit.  */\n   &arm_default_vec_cost,                       /* Vectorizer costs.  */\n   false,                                       /* Prefer Neon for 64-bits bitops.  */\n-  true, true,                                  /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  true, true                                   /* Prefer 32-bit encodings.  */\n };\n \n /* Branches can be dual-issued on Cortex-A5, so conditional execution is\n@@ -1933,9 +1909,7 @@ const struct tune_params arm_cortex_a5_tune =\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_cortex_a9_tune =\n@@ -1952,9 +1926,7 @@ const struct tune_params arm_cortex_a9_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_cortex_a12_tune =\n@@ -1971,9 +1943,7 @@ const struct tune_params arm_cortex_a12_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n /* armv7m tuning.  On Cortex-M4 cores for example, MOVW/MOVT take a single\n@@ -1997,9 +1967,7 @@ const struct tune_params arm_v7m_tune =\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n /* The arm_v6m_tune is duplicated from arm_cortex_tune, rather than\n@@ -2018,9 +1986,7 @@ const struct tune_params arm_v6m_tune =\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n const struct tune_params arm_fa726te_tune =\n@@ -2037,9 +2003,7 @@ const struct tune_params arm_fa726te_tune =\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n   &arm_default_vec_cost,                        /* Vectorizer costs.  */\n   false,                                        /* Prefer Neon for 64-bits bitops.  */\n-  false, false,                                 /* Prefer 32-bit encodings.  */\n-  false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n-  8\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n+  false, false                                  /* Prefer 32-bit encodings.  */\n };\n \n \n@@ -16935,14 +16899,6 @@ arm_const_double_inline_cost (rtx val)\n \t\t\t      NULL_RTX, NULL_RTX, 0, 0));\n }\n \n-/* Cost of loading a SImode constant.  */\n-static inline int\n-arm_const_inline_cost (enum rtx_code code, rtx val)\n-{\n-  return arm_gen_constant (code, SImode, NULL_RTX, INTVAL (val),\n-                           NULL_RTX, NULL_RTX, 1, 0);\n-}\n-\n /* Return true if it is worthwhile to split a 64-bit constant into two\n    32-bit operations.  This is the case if optimizing for size, or\n    if we have load delay slots, or if one 32-bit part can be done with\n@@ -18595,20 +18551,6 @@ output_move_neon (rtx *operands)\n       /* FIXME: Not currently enabled in neon_vector_mem_operand.  */\n       gcc_unreachable ();\n \n-    case REG:\n-      /* We have to use vldm / vstm for too-large modes.  */\n-      if (nregs > 1)\n-\t{\n-\t  if (nregs > 4)\n-\t    templ = \"v%smia%%?\\t%%m0, %%h1\";\n-\t  else\n-\t    templ = \"v%s1.64\\t%%h1, %%A0\";\n-\n-\t  ops[0] = mem;\n-\t  ops[1] = reg;\n-\t  break;\n-\t}\n-      /* Fall through.  */\n     case LABEL_REF:\n     case PLUS:\n       {\n@@ -18642,7 +18584,14 @@ output_move_neon (rtx *operands)\n       }\n \n     default:\n-      gcc_unreachable ();\n+      /* We have to use vldm / vstm for too-large modes.  */\n+      if (nregs > 4)\n+\ttempl = \"v%smia%%?\\t%%m0, %%h1\";\n+      else\n+\ttempl = \"v%s1.64\\t%%h1, %%A0\";\n+\n+      ops[0] = mem;\n+      ops[1] = reg;\n     }\n \n   sprintf (buff, templ, load ? \"ld\" : \"st\");\n@@ -31582,519 +31531,6 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n \n }\n \n-/* Maximum number of instructions to set block of memory.  */\n-static int\n-arm_block_set_max_insns (void)\n-{\n-  if (optimize_function_for_size_p (cfun))\n-    return 4;\n-  else\n-    return current_tune->max_insns_inline_memset;\n-}\n-\n-/* Return TRUE if it's profitable to set block of memory for\n-   non-vectorized case.  VAL is the value to set the memory\n-   with.  LENGTH is the number of bytes to set.  ALIGN is the\n-   alignment of the destination memory in bytes.  UNALIGNED_P\n-   is TRUE if we can only set the memory with instructions\n-   meeting alignment requirements.  USE_STRD_P is TRUE if we\n-   can use strd to set the memory.  */\n-static bool\n-arm_block_set_non_vect_profit_p (rtx val,\n-\t\t\t\t unsigned HOST_WIDE_INT length,\n-\t\t\t\t unsigned HOST_WIDE_INT align,\n-\t\t\t\t bool unaligned_p, bool use_strd_p)\n-{\n-  int num = 0;\n-  /* For leftovers in bytes of 0-7, we can set the memory block using\n-     strb/strh/str with minimum instruction number.  */\n-  const int leftover[8] = {0, 1, 1, 2, 1, 2, 2, 3};\n-\n-  if (unaligned_p)\n-    {\n-      num = arm_const_inline_cost (SET, val);\n-      num += length / align + length % align;\n-    }\n-  else if (use_strd_p)\n-    {\n-      num = arm_const_double_inline_cost (val);\n-      num += (length >> 3) + leftover[length & 7];\n-    }\n-  else\n-    {\n-      num = arm_const_inline_cost (SET, val);\n-      num += (length >> 2) + leftover[length & 3];\n-    }\n-\n-  /* We may be able to combine last pair STRH/STRB into a single STR\n-     by shifting one byte back.  */\n-  if (unaligned_access && length > 3 && (length & 3) == 3)\n-    num--;\n-\n-  return (num <= arm_block_set_max_insns ());\n-}\n-\n-/* Return TRUE if it's profitable to set block of memory for\n-   vectorized case.  LENGTH is the number of bytes to set.\n-   ALIGN is the alignment of destination memory in bytes.\n-   MODE is the vector mode used to set the memory.  */\n-static bool\n-arm_block_set_vect_profit_p (unsigned HOST_WIDE_INT length,\n-\t\t\t     unsigned HOST_WIDE_INT align,\n-\t\t\t     enum machine_mode mode)\n-{\n-  int num;\n-  bool unaligned_p = ((align & 3) != 0);\n-  unsigned int nelt = GET_MODE_NUNITS (mode);\n-\n-  /* Instruction loading constant value.  */\n-  num = 1;\n-  /* Instructions storing the memory.  */\n-  num += (length + nelt - 1) / nelt;\n-  /* Instructions adjusting the address expression.  Only need to\n-     adjust address expression if it's 4 bytes aligned and bytes\n-     leftover can only be stored by mis-aligned store instruction.  */\n-  if (!unaligned_p && (length & 3) != 0)\n-    num++;\n-\n-  /* Store the first 16 bytes using vst1:v16qi for the aligned case.  */\n-  if (!unaligned_p && mode == V16QImode)\n-    num--;\n-\n-  return (num <= arm_block_set_max_insns ());\n-}\n-\n-/* Set a block of memory using vectorization instructions for the\n-   unaligned case.  We fill the first LENGTH bytes of the memory\n-   area starting from DSTBASE with byte constant VALUE.  ALIGN is\n-   the alignment requirement of memory.  Return TRUE if succeeded.  */\n-static bool\n-arm_block_set_unaligned_vect (rtx dstbase,\n-\t\t\t      unsigned HOST_WIDE_INT length,\n-\t\t\t      unsigned HOST_WIDE_INT value,\n-\t\t\t      unsigned HOST_WIDE_INT align)\n-{\n-  unsigned int i, j, nelt_v16, nelt_v8, nelt_mode;\n-  rtx dst, mem;\n-  rtx val_elt, val_vec, reg;\n-  rtx rval[MAX_VECT_LEN];\n-  rtx (*gen_func) (rtx, rtx);\n-  enum machine_mode mode;\n-  unsigned HOST_WIDE_INT v = value;\n-\n-  gcc_assert ((align & 0x3) != 0);\n-  nelt_v8 = GET_MODE_NUNITS (V8QImode);\n-  nelt_v16 = GET_MODE_NUNITS (V16QImode);\n-  if (length >= nelt_v16)\n-    {\n-      mode = V16QImode;\n-      gen_func = gen_movmisalignv16qi;\n-    }\n-  else\n-    {\n-      mode = V8QImode;\n-      gen_func = gen_movmisalignv8qi;\n-    }\n-  nelt_mode = GET_MODE_NUNITS (mode);\n-  gcc_assert (length >= nelt_mode);\n-  /* Skip if it isn't profitable.  */\n-  if (!arm_block_set_vect_profit_p (length, align, mode))\n-    return false;\n-\n-  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n-  mem = adjust_automodify_address (dstbase, mode, dst, 0);\n-\n-  v = sext_hwi (v, BITS_PER_WORD);\n-  val_elt = GEN_INT (v);\n-  for (j = 0; j < nelt_mode; j++)\n-    rval[j] = val_elt;\n-\n-  reg = gen_reg_rtx (mode);\n-  val_vec = gen_rtx_CONST_VECTOR (mode, gen_rtvec_v (nelt_mode, rval));\n-  /* Emit instruction loading the constant value.  */\n-  emit_move_insn (reg, val_vec);\n-\n-  /* Handle nelt_mode bytes in a vector.  */\n-  for (i = 0; (i + nelt_mode <= length); i += nelt_mode)\n-    {\n-      emit_insn ((*gen_func) (mem, reg));\n-      if (i + 2 * nelt_mode <= length)\n-\temit_insn (gen_add2_insn (dst, GEN_INT (nelt_mode)));\n-    }\n-\n-  /* If there are not less than nelt_v8 bytes leftover, we must be in\n-     V16QI mode.  */\n-  gcc_assert ((i + nelt_v8) > length || mode == V16QImode);\n-\n-  /* Handle (8, 16) bytes leftover.  */\n-  if (i + nelt_v8 < length)\n-    {\n-      emit_insn (gen_add2_insn (dst, GEN_INT (length - i)));\n-      /* We are shifting bytes back, set the alignment accordingly.  */\n-      if ((length & 1) != 0 && align >= 2)\n-\tset_mem_align (mem, BITS_PER_UNIT);\n-\n-      emit_insn (gen_movmisalignv16qi (mem, reg));\n-    }\n-  /* Handle (0, 8] bytes leftover.  */\n-  else if (i < length && i + nelt_v8 >= length)\n-    {\n-      if (mode == V16QImode)\n-\t{\n-\t  reg = gen_lowpart (V8QImode, reg);\n-\t  mem = adjust_automodify_address (dstbase, V8QImode, dst, 0);\n-\t}\n-      emit_insn (gen_add2_insn (dst, GEN_INT ((length - i)\n-\t\t\t\t\t      + (nelt_mode - nelt_v8))));\n-      /* We are shifting bytes back, set the alignment accordingly.  */\n-      if ((length & 1) != 0 && align >= 2)\n-\tset_mem_align (mem, BITS_PER_UNIT);\n-\n-      emit_insn (gen_movmisalignv8qi (mem, reg));\n-    }\n-\n-  return true;\n-}\n-\n-/* Set a block of memory using vectorization instructions for the\n-   aligned case.  We fill the first LENGTH bytes of the memory area\n-   starting from DSTBASE with byte constant VALUE.  ALIGN is the\n-   alignment requirement of memory.  Return TRUE if succeeded.  */\n-static bool\n-arm_block_set_aligned_vect (rtx dstbase,\n-\t\t\t    unsigned HOST_WIDE_INT length,\n-\t\t\t    unsigned HOST_WIDE_INT value,\n-\t\t\t    unsigned HOST_WIDE_INT align)\n-{\n-  unsigned int i, j, nelt_v8, nelt_v16, nelt_mode;\n-  rtx dst, addr, mem;\n-  rtx val_elt, val_vec, reg;\n-  rtx rval[MAX_VECT_LEN];\n-  enum machine_mode mode;\n-  unsigned HOST_WIDE_INT v = value;\n-\n-  gcc_assert ((align & 0x3) == 0);\n-  nelt_v8 = GET_MODE_NUNITS (V8QImode);\n-  nelt_v16 = GET_MODE_NUNITS (V16QImode);\n-  if (length >= nelt_v16 && unaligned_access && !BYTES_BIG_ENDIAN)\n-    mode = V16QImode;\n-  else\n-    mode = V8QImode;\n-\n-  nelt_mode = GET_MODE_NUNITS (mode);\n-  gcc_assert (length >= nelt_mode);\n-  /* Skip if it isn't profitable.  */\n-  if (!arm_block_set_vect_profit_p (length, align, mode))\n-    return false;\n-\n-  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n-\n-  v = sext_hwi (v, BITS_PER_WORD);\n-  val_elt = GEN_INT (v);\n-  for (j = 0; j < nelt_mode; j++)\n-    rval[j] = val_elt;\n-\n-  reg = gen_reg_rtx (mode);\n-  val_vec = gen_rtx_CONST_VECTOR (mode, gen_rtvec_v (nelt_mode, rval));\n-  /* Emit instruction loading the constant value.  */\n-  emit_move_insn (reg, val_vec);\n-\n-  i = 0;\n-  /* Handle first 16 bytes specially using vst1:v16qi instruction.  */\n-  if (mode == V16QImode)\n-    {\n-      mem = adjust_automodify_address (dstbase, mode, dst, 0);\n-      emit_insn (gen_movmisalignv16qi (mem, reg));\n-      i += nelt_mode;\n-      /* Handle (8, 16) bytes leftover using vst1:v16qi again.  */\n-      if (i + nelt_v8 < length && i + nelt_v16 > length)\n-\t{\n-\t  emit_insn (gen_add2_insn (dst, GEN_INT (length - nelt_mode)));\n-\t  mem = adjust_automodify_address (dstbase, mode, dst, 0);\n-\t  /* We are shifting bytes back, set the alignment accordingly.  */\n-\t  if ((length & 0x3) == 0)\n-\t    set_mem_align (mem, BITS_PER_UNIT * 4);\n-\t  else if ((length & 0x1) == 0)\n-\t    set_mem_align (mem, BITS_PER_UNIT * 2);\n-\t  else\n-\t    set_mem_align (mem, BITS_PER_UNIT);\n-\n-\t  emit_insn (gen_movmisalignv16qi (mem, reg));\n-\t  return true;\n-\t}\n-      /* Fall through for bytes leftover.  */\n-      mode = V8QImode;\n-      nelt_mode = GET_MODE_NUNITS (mode);\n-      reg = gen_lowpart (V8QImode, reg);\n-    }\n-\n-  /* Handle 8 bytes in a vector.  */\n-  for (; (i + nelt_mode <= length); i += nelt_mode)\n-    {\n-      addr = plus_constant (Pmode, dst, i);\n-      mem = adjust_automodify_address (dstbase, mode, addr, i);\n-      emit_move_insn (mem, reg);\n-    }\n-\n-  /* Handle single word leftover by shifting 4 bytes back.  We can\n-     use aligned access for this case.  */\n-  if (i + UNITS_PER_WORD == length)\n-    {\n-      addr = plus_constant (Pmode, dst, i - UNITS_PER_WORD);\n-      mem = adjust_automodify_address (dstbase, mode,\n-\t\t\t\t       addr, i - UNITS_PER_WORD);\n-      /* We are shifting 4 bytes back, set the alignment accordingly.  */\n-      if (align > UNITS_PER_WORD)\n-\tset_mem_align (mem, BITS_PER_UNIT * UNITS_PER_WORD);\n-\n-      emit_move_insn (mem, reg);\n-    }\n-  /* Handle (0, 4), (4, 8) bytes leftover by shifting bytes back.\n-     We have to use unaligned access for this case.  */\n-  else if (i < length)\n-    {\n-      emit_insn (gen_add2_insn (dst, GEN_INT (length - nelt_mode)));\n-      mem = adjust_automodify_address (dstbase, mode, dst, 0);\n-      /* We are shifting bytes back, set the alignment accordingly.  */\n-      if ((length & 1) == 0)\n-\tset_mem_align (mem, BITS_PER_UNIT * 2);\n-      else\n-\tset_mem_align (mem, BITS_PER_UNIT);\n-\n-      emit_insn (gen_movmisalignv8qi (mem, reg));\n-    }\n-\n-  return true;\n-}\n-\n-/* Set a block of memory using plain strh/strb instructions, only\n-   using instructions allowed by ALIGN on processor.  We fill the\n-   first LENGTH bytes of the memory area starting from DSTBASE\n-   with byte constant VALUE.  ALIGN is the alignment requirement\n-   of memory.  */\n-static bool\n-arm_block_set_unaligned_non_vect (rtx dstbase,\n-\t\t\t\t  unsigned HOST_WIDE_INT length,\n-\t\t\t\t  unsigned HOST_WIDE_INT value,\n-\t\t\t\t  unsigned HOST_WIDE_INT align)\n-{\n-  unsigned int i;\n-  rtx dst, addr, mem;\n-  rtx val_exp, val_reg, reg;\n-  enum machine_mode mode;\n-  HOST_WIDE_INT v = value;\n-\n-  gcc_assert (align == 1 || align == 2);\n-\n-  if (align == 2)\n-    v |= (value << BITS_PER_UNIT);\n-\n-  v = sext_hwi (v, BITS_PER_WORD);\n-  val_exp = GEN_INT (v);\n-  /* Skip if it isn't profitable.  */\n-  if (!arm_block_set_non_vect_profit_p (val_exp, length,\n-\t\t\t\t\talign, true, false))\n-    return false;\n-\n-  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n-  mode = (align == 2 ? HImode : QImode);\n-  val_reg = force_reg (SImode, val_exp);\n-  reg = gen_lowpart (mode, val_reg);\n-\n-  for (i = 0; (i + GET_MODE_SIZE (mode) <= length); i += GET_MODE_SIZE (mode))\n-    {\n-      addr = plus_constant (Pmode, dst, i);\n-      mem = adjust_automodify_address (dstbase, mode, addr, i);\n-      emit_move_insn (mem, reg);\n-    }\n-\n-  /* Handle single byte leftover.  */\n-  if (i + 1 == length)\n-    {\n-      reg = gen_lowpart (QImode, val_reg);\n-      addr = plus_constant (Pmode, dst, i);\n-      mem = adjust_automodify_address (dstbase, QImode, addr, i);\n-      emit_move_insn (mem, reg);\n-      i++;\n-    }\n-\n-  gcc_assert (i == length);\n-  return true;\n-}\n-\n-/* Set a block of memory using plain strd/str/strh/strb instructions,\n-   to permit unaligned copies on processors which support unaligned\n-   semantics for those instructions.  We fill the first LENGTH bytes\n-   of the memory area starting from DSTBASE with byte constant VALUE.\n-   ALIGN is the alignment requirement of memory.  */\n-static bool\n-arm_block_set_aligned_non_vect (rtx dstbase,\n-\t\t\t\tunsigned HOST_WIDE_INT length,\n-\t\t\t\tunsigned HOST_WIDE_INT value,\n-\t\t\t\tunsigned HOST_WIDE_INT align)\n-{\n-  unsigned int i;\n-  rtx dst, addr, mem;\n-  rtx val_exp, val_reg, reg;\n-  unsigned HOST_WIDE_INT v;\n-  bool use_strd_p;\n-\n-  use_strd_p = (length >= 2 * UNITS_PER_WORD && (align & 3) == 0\n-\t\t&& TARGET_LDRD && current_tune->prefer_ldrd_strd);\n-\n-  v = (value | (value << 8) | (value << 16) | (value << 24));\n-  if (length < UNITS_PER_WORD)\n-    v &= (0xFFFFFFFF >> (UNITS_PER_WORD - length) * BITS_PER_UNIT);\n-\n-  if (use_strd_p)\n-    v |= (v << BITS_PER_WORD);\n-  else\n-    v = sext_hwi (v, BITS_PER_WORD);\n-\n-  val_exp = GEN_INT (v);\n-  /* Skip if it isn't profitable.  */\n-  if (!arm_block_set_non_vect_profit_p (val_exp, length,\n-\t\t\t\t\talign, false, use_strd_p))\n-    {\n-      if (!use_strd_p)\n-\treturn false;\n-\n-      /* Try without strd.  */\n-      v = (v >> BITS_PER_WORD);\n-      v = sext_hwi (v, BITS_PER_WORD);\n-      val_exp = GEN_INT (v);\n-      use_strd_p = false;\n-      if (!arm_block_set_non_vect_profit_p (val_exp, length,\n-\t\t\t\t\t    align, false, use_strd_p))\n-\treturn false;\n-    }\n-\n-  i = 0;\n-  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n-  /* Handle double words using strd if possible.  */\n-  if (use_strd_p)\n-    {\n-      val_reg = force_reg (DImode, val_exp);\n-      reg = val_reg;\n-      for (; (i + 8 <= length); i += 8)\n-\t{\n-\t  addr = plus_constant (Pmode, dst, i);\n-\t  mem = adjust_automodify_address (dstbase, DImode, addr, i);\n-\t  emit_move_insn (mem, reg);\n-\t}\n-    }\n-  else\n-    val_reg = force_reg (SImode, val_exp);\n-\n-  /* Handle words.  */\n-  reg = (use_strd_p ? gen_lowpart (SImode, val_reg) : val_reg);\n-  for (; (i + 4 <= length); i += 4)\n-    {\n-      addr = plus_constant (Pmode, dst, i);\n-      mem = adjust_automodify_address (dstbase, SImode, addr, i);\n-      if ((align & 3) == 0)\n-\temit_move_insn (mem, reg);\n-      else\n-\temit_insn (gen_unaligned_storesi (mem, reg));\n-    }\n-\n-  /* Merge last pair of STRH and STRB into a STR if possible.  */\n-  if (unaligned_access && i > 0 && (i + 3) == length)\n-    {\n-      addr = plus_constant (Pmode, dst, i - 1);\n-      mem = adjust_automodify_address (dstbase, SImode, addr, i - 1);\n-      /* We are shifting one byte back, set the alignment accordingly.  */\n-      if ((align & 1) == 0)\n-\tset_mem_align (mem, BITS_PER_UNIT);\n-\n-      /* Most likely this is an unaligned access, and we can't tell at\n-\t compilation time.  */\n-      emit_insn (gen_unaligned_storesi (mem, reg));\n-      return true;\n-    }\n-\n-  /* Handle half word leftover.  */\n-  if (i + 2 <= length)\n-    {\n-      reg = gen_lowpart (HImode, val_reg);\n-      addr = plus_constant (Pmode, dst, i);\n-      mem = adjust_automodify_address (dstbase, HImode, addr, i);\n-      if ((align & 1) == 0)\n-\temit_move_insn (mem, reg);\n-      else\n-\temit_insn (gen_unaligned_storehi (mem, reg));\n-\n-      i += 2;\n-    }\n-\n-  /* Handle single byte leftover.  */\n-  if (i + 1 == length)\n-    {\n-      reg = gen_lowpart (QImode, val_reg);\n-      addr = plus_constant (Pmode, dst, i);\n-      mem = adjust_automodify_address (dstbase, QImode, addr, i);\n-      emit_move_insn (mem, reg);\n-    }\n-\n-  return true;\n-}\n-\n-/* Set a block of memory using vectorization instructions for both\n-   aligned and unaligned cases.  We fill the first LENGTH bytes of\n-   the memory area starting from DSTBASE with byte constant VALUE.\n-   ALIGN is the alignment requirement of memory.  */\n-static bool\n-arm_block_set_vect (rtx dstbase,\n-\t\t    unsigned HOST_WIDE_INT length,\n-\t\t    unsigned HOST_WIDE_INT value,\n-\t\t    unsigned HOST_WIDE_INT align)\n-{\n-  /* Check whether we need to use unaligned store instruction.  */\n-  if (((align & 3) != 0 || (length & 3) != 0)\n-      /* Check whether unaligned store instruction is available.  */\n-      && (!unaligned_access || BYTES_BIG_ENDIAN))\n-    return false;\n-\n-  if ((align & 3) == 0)\n-    return arm_block_set_aligned_vect (dstbase, length, value, align);\n-  else\n-    return arm_block_set_unaligned_vect (dstbase, length, value, align);\n-}\n-\n-/* Expand string store operation.  Firstly we try to do that by using\n-   vectorization instructions, then try with ARM unaligned access and\n-   double-word store if profitable.  OPERANDS[0] is the destination,\n-   OPERANDS[1] is the number of bytes, operands[2] is the value to\n-   initialize the memory, OPERANDS[3] is the known alignment of the\n-   destination.  */\n-bool\n-arm_gen_setmem (rtx *operands)\n-{\n-  rtx dstbase = operands[0];\n-  unsigned HOST_WIDE_INT length;\n-  unsigned HOST_WIDE_INT value;\n-  unsigned HOST_WIDE_INT align;\n-\n-  if (!CONST_INT_P (operands[2]) || !CONST_INT_P (operands[1]))\n-    return false;\n-\n-  length = UINTVAL (operands[1]);\n-  if (length > 64)\n-    return false;\n-\n-  value = (UINTVAL (operands[2]) & 0xFF);\n-  align = UINTVAL (operands[3]);\n-  if (TARGET_NEON && length >= 8\n-      && current_tune->string_ops_prefer_neon\n-      && arm_block_set_vect (dstbase, length, value, align))\n-    return true;\n-\n-  if (!unaligned_access && (align & 3) != 0)\n-    return arm_block_set_unaligned_non_vect (dstbase, length, value, align);\n-\n-  return arm_block_set_aligned_non_vect (dstbase, length, value, align);\n-}\n-\n /* Implement the TARGET_ASAN_SHADOW_OFFSET hook.  */\n \n static unsigned HOST_WIDE_INT"}, {"sha": "bd8ea8f201d7614270d1426c99cd232e2e75fc3c", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106d7513c6ee0c36c2862ac37754332eb9c4593d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106d7513c6ee0c36c2862ac37754332eb9c4593d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=106d7513c6ee0c36c2862ac37754332eb9c4593d", "patch": "@@ -6716,20 +6716,6 @@\n })\n \n \n-(define_expand \"setmemsi\"\n-  [(match_operand:BLK 0 \"general_operand\" \"\")\n-   (match_operand:SI 1 \"const_int_operand\" \"\")\n-   (match_operand:SI 2 \"const_int_operand\" \"\")\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_32BIT\"\n-{\n-  if (arm_gen_setmem (operands))\n-    DONE;\n-\n-  FAIL;\n-})\n-\n-\n ;; Move a block of memory if it is word aligned and MORE than 2 words long.\n ;; We could let this apply for blocks of less than this, but it clobbers so\n ;; many registers that there is then probably a better way."}, {"sha": "ff137b334254a46e9c707e5d6747b382cedb0fbd", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-1.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-1.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,39 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-save-temps -O2 -fno-inline\"  } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-short a[LEN];\n-void\n-foo (void)\n-{\n-    memset (a, -1, 14);\n-    return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  foo ();\n-  check ((signed char *)a, 14, sizeof (a), -1);\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { ! arm_thumb1_ok } } } } */\n-/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "6deaffe232dadd6f3cf889abc286de77f9e9d8e8", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-2.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-2.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,38 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-save-temps -Os -fno-inline\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-short a[LEN];\n-void\n-foo (void)\n-{\n-  memset (a, -1, 14);\n-  return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  foo ();\n-  check ((signed char *)a, 14, sizeof (a), -1);\n-\n-  return 0;\n-}\n-/* { dg-final { scan-assembler \"bl?\\[ \\t\\]*memset\" { target { ! arm_neon } } } } */\n-/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "777639520677f668f7cfd691805c25260d52212f", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-3.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-3.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,40 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-short a[LEN];\n-void\n-foo (void)\n-{\n-    memset (a, -1, 7);\n-    return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  foo ();\n-  check ((signed char *)a, 7, sizeof (a), -1);\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { ! arm_thumb1_ok } } } } */\n-/* { dg-final { scan-assembler-not \"strh\" { target { ! arm_thumb1 } } } } */\n-/* { dg-final { scan-assembler-not \"strb\" { target { ! arm_thumb1 } } } } */"}, {"sha": "381a2c2099bc0a4af41d0e0e1c33db78436a0437", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-4.c", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-4.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,68 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n-/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n-/* { dg-add-options \"arm_neon\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-int a[LEN];\n-int b[LEN];\n-int c[LEN];\n-void\n-foo1 (void)\n-{\n-    memset (a, -1, 8);\n-    return;\n-}\n-\n-void\n-foo2 (void)\n-{\n-  memset (b, 1, 12);\n-  return;\n-}\n-\n-void\n-foo3 (void)\n-{\n-  memset (c, 1, 13);\n-  return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  int i;\n-\n-  foo1 ();\n-  check ((signed char *)a, 8, sizeof (a), -1);\n-\n-  foo2 ();\n-  check ((signed char *)b, 12, sizeof (b), 1);\n-\n-  foo3 ();\n-  check ((signed char *)c, 13, sizeof (c), 1);\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]+memset\" { target { ! arm_thumb1_ok } } } } */\n-/* { dg-final { scan-assembler-times \"vst1\\.8\" 1 { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { scan-assembler \"vstr\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "9107d811a94ffe9b5ec738d803bef8c2e5a4aadf", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-5.c", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-5.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,78 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n-/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n-/* { dg-add-options \"arm_neon\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-int a[LEN];\n-int b[LEN];\n-int c[LEN];\n-int d[LEN];\n-void\n-foo1 (void)\n-{\n-    memset (a, -1, 16);\n-    return;\n-}\n-\n-void\n-foo2 (void)\n-{\n-  memset (b, 1, 25);\n-  return;\n-}\n-\n-void\n-foo3 (void)\n-{\n-  memset (c, -1, 19);\n-  return;\n-}\n-\n-void\n-foo4 (void)\n-{\n-  memset (d, 1, 23);\n-  return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  foo1 ();\n-  check ((signed char *)a, 16, sizeof (a), -1);\n-\n-  foo2 ();\n-  check ((signed char *)b, 25, sizeof (b), 1);\n-\n-  foo3 ();\n-  check ((signed char *)c, 19, sizeof (c), -1);\n-\n-  foo4 ();\n-  check ((signed char *)d, 23, sizeof (d), 1);\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]+memset\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { scan-assembler \"vst1\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { scan-assembler-not \"vstr\"  { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { cleanup-saved-temps } } */\n-"}, {"sha": "fcb2e26a95da4119882a74543b73c56068e6f8c0", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-6.c", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-6.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,68 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n-/* { dg-options \"-save-temps -O2 -fno-inline\" } */\n-/* { dg-add-options \"arm_neon\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-int a[LEN];\n-int b[LEN];\n-int c[LEN];\n-void\n-foo1 (void)\n-{\n-    memset (a, -1, 20);\n-    return;\n-}\n-\n-void\n-foo2 (void)\n-{\n-  memset (b, 1, 24);\n-  return;\n-}\n-\n-void\n-foo3 (void)\n-{\n-  memset (c, -1, 32);\n-  return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  foo1 ();\n-  check ((signed char *)a, 20, sizeof (a), -1);\n-\n-  foo2 ();\n-  check ((signed char *)b, 24, sizeof (b), 1);\n-\n-  foo3 ();\n-  check ((signed char *)c, 32, sizeof (c), -1);\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]+memset\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { scan-assembler-times \"vst1\" 3 { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { scan-assembler-times \"vstr\" 4 { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { cleanup-saved-temps } } */\n-\n-"}, {"sha": "7326c5f857cffe2d8699a1c8a154da652f8e15e1", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-7.c", "status": "removed", "additions": 0, "deletions": 171, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-7.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,171 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-O2\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-short a[LEN];\n-int b[LEN];\n-\n-void\n-init (signed char *arr, int len)\n-{\n-  int i;\n-  for (i = 0; i < len; i++)\n-    arr[i] = 0;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-#define TEST(a,l,v)\t\t\t\\\n-\tinit ((signed char*)(a), sizeof (a));\t\t\\\n-\tmemset ((a), (v), (l));\t\t\t\t\\\n-\tcheck ((signed char *)(a), (l), sizeof (a), (v));\n-int\n-main(void)\n-{\n-  TEST (a, 1, -1);\n-  TEST (a, 2, -1);\n-  TEST (a, 3, -1);\n-  TEST (a, 4, -1);\n-  TEST (a, 5, -1);\n-  TEST (a, 6, -1);\n-  TEST (a, 7, -1);\n-  TEST (a, 8, -1);\n-  TEST (a, 9, 1);\n-  TEST (a, 10, -1);\n-  TEST (a, 11, 1);\n-  TEST (a, 12, -1);\n-  TEST (a, 13, 1);\n-  TEST (a, 14, -1);\n-  TEST (a, 15, 1);\n-  TEST (a, 16, -1);\n-  TEST (a, 17, 1);\n-  TEST (a, 18, -1);\n-  TEST (a, 19, 1);\n-  TEST (a, 20, -1);\n-  TEST (a, 21, 1);\n-  TEST (a, 22, -1);\n-  TEST (a, 23, 1);\n-  TEST (a, 24, -1);\n-  TEST (a, 25, 1);\n-  TEST (a, 26, -1);\n-  TEST (a, 27, 1);\n-  TEST (a, 28, -1);\n-  TEST (a, 29, 1);\n-  TEST (a, 30, -1);\n-  TEST (a, 31, 1);\n-  TEST (a, 32, -1);\n-  TEST (a, 33, 1);\n-  TEST (a, 34, -1);\n-  TEST (a, 35, 1);\n-  TEST (a, 36, -1);\n-  TEST (a, 37, 1);\n-  TEST (a, 38, -1);\n-  TEST (a, 39, 1);\n-  TEST (a, 40, -1);\n-  TEST (a, 41, 1);\n-  TEST (a, 42, -1);\n-  TEST (a, 43, 1);\n-  TEST (a, 44, -1);\n-  TEST (a, 45, 1);\n-  TEST (a, 46, -1);\n-  TEST (a, 47, 1);\n-  TEST (a, 48, -1);\n-  TEST (a, 49, 1);\n-  TEST (a, 50, -1);\n-  TEST (a, 51, 1);\n-  TEST (a, 52, -1);\n-  TEST (a, 53, 1);\n-  TEST (a, 54, -1);\n-  TEST (a, 55, 1);\n-  TEST (a, 56, -1);\n-  TEST (a, 57, 1);\n-  TEST (a, 58, -1);\n-  TEST (a, 59, 1);\n-  TEST (a, 60, -1);\n-  TEST (a, 61, 1);\n-  TEST (a, 62, -1);\n-  TEST (a, 63, 1);\n-  TEST (a, 64, -1);\n-\n-  TEST (b, 1, -1);\n-  TEST (b, 2, -1);\n-  TEST (b, 3, -1);\n-  TEST (b, 4, -1);\n-  TEST (b, 5, -1);\n-  TEST (b, 6, -1);\n-  TEST (b, 7, -1);\n-  TEST (b, 8, -1);\n-  TEST (b, 9, 1);\n-  TEST (b, 10, -1);\n-  TEST (b, 11, 1);\n-  TEST (b, 12, -1);\n-  TEST (b, 13, 1);\n-  TEST (b, 14, -1);\n-  TEST (b, 15, 1);\n-  TEST (b, 16, -1);\n-  TEST (b, 17, 1);\n-  TEST (b, 18, -1);\n-  TEST (b, 19, 1);\n-  TEST (b, 20, -1);\n-  TEST (b, 21, 1);\n-  TEST (b, 22, -1);\n-  TEST (b, 23, 1);\n-  TEST (b, 24, -1);\n-  TEST (b, 25, 1);\n-  TEST (b, 26, -1);\n-  TEST (b, 27, 1);\n-  TEST (b, 28, -1);\n-  TEST (b, 29, 1);\n-  TEST (b, 30, -1);\n-  TEST (b, 31, 1);\n-  TEST (b, 32, -1);\n-  TEST (b, 33, 1);\n-  TEST (b, 34, -1);\n-  TEST (b, 35, 1);\n-  TEST (b, 36, -1);\n-  TEST (b, 37, 1);\n-  TEST (b, 38, -1);\n-  TEST (b, 39, 1);\n-  TEST (b, 40, -1);\n-  TEST (b, 41, 1);\n-  TEST (b, 42, -1);\n-  TEST (b, 43, 1);\n-  TEST (b, 44, -1);\n-  TEST (b, 45, 1);\n-  TEST (b, 46, -1);\n-  TEST (b, 47, 1);\n-  TEST (b, 48, -1);\n-  TEST (b, 49, 1);\n-  TEST (b, 50, -1);\n-  TEST (b, 51, 1);\n-  TEST (b, 52, -1);\n-  TEST (b, 53, 1);\n-  TEST (b, 54, -1);\n-  TEST (b, 55, 1);\n-  TEST (b, 56, -1);\n-  TEST (b, 57, 1);\n-  TEST (b, 58, -1);\n-  TEST (b, 59, 1);\n-  TEST (b, 60, -1);\n-  TEST (b, 61, 1);\n-  TEST (b, 62, -1);\n-  TEST (b, 63, 1);\n-  TEST (b, 64, -1);\n-\n-  return 0;\n-}\n-"}, {"sha": "96c4d798e5b34e3766ce15b4587d69ebe1bbfaf7", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-8.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-8.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,44 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n-/* { dg-options \"-save-temps -O2 -fno-inline\"  } */\n-/* { dg-add-options \"arm_neon\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-short a[LEN];\n-void\n-foo (void)\n-{\n-    memset (a, -1, 14);\n-    return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  foo ();\n-  check ((signed char *)a, 14, sizeof (a), -1);\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { ! arm_thumb1_ok } } } } */\n-/* { dg-final { scan-assembler \"vst1\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { scan-assembler-not \"vstr\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "be9323aae51c694e6357e3c2cc717ee1154def4c", "filename": "gcc/testsuite/gcc.target/arm/memset-inline-9.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf7a695cc3ab52499970f59a019ef4ad6648543/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmemset-inline-9.c?ref=7bf7a695cc3ab52499970f59a019ef4ad6648543", "patch": "@@ -1,42 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mcpu=cortex-a9\" } { \"\" } } */\n-/* { dg-skip-if \"Don't inline memset using neon instructions on cortex-a9\" { *-*-* } { \"-mtune=cortex-a9\" } { \"\" } } */\n-/* { dg-options \"-save-temps -Os -fno-inline\" } */\n-/* { dg-add-options \"arm_neon\" } */\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#define LEN (100)\n-short a[LEN];\n-void\n-foo (void)\n-{\n-  memset (a, -1, 14);\n-  return;\n-}\n-\n-void\n-check (signed char *arr, int idx, int len, int v)\n-{\n-  int i;\n-  for (i = 0; i < idx; i++)\n-    if (arr[i] != v)\n-      abort ();\n-\n-  for (i = idx; i < len; i++)\n-    if (arr[i] != 0)\n-      abort ();\n-}\n-\n-int\n-main(void)\n-{\n-  foo ();\n-  check ((signed char *)a, 14, sizeof (a), -1);\n-\n-  return 0;\n-}\n-/* { dg-final { scan-assembler-not \"bl?\\[ \\t\\]*memset\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { scan-assembler \"vst1\" { target { arm_little_endian && arm_neon } } } } */\n-/* { dg-final { cleanup-saved-temps } } */"}]}