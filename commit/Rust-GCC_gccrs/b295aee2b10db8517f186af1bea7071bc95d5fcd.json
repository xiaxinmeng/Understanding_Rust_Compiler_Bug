{"sha": "b295aee2b10db8517f186af1bea7071bc95d5fcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI5NWFlZTJiMTBkYjg1MTdmMTg2YWYxYmVhNzA3MWJjOTVkNWZjZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-01-01T19:40:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-01-01T19:40:03Z"}, "message": "re PR c/36489 (Warning \"initialized field overwritten\" wrongly triggers with multidimensional arrays)\n\n\tPR c/36489\n\t* c-typeck.c (add_pending_init): Add IMPLICIT argument.  Only\n\twarn about overwriting initializer with side-effects or\n\t-Woverride-init if !IMPLICIT.\n\t(output_init_element): Likewise.  Pass IMPLICIT down to\n\tadd_pending_init.\n\t(process_init_element): Add IMPLICIT argument.  Pass it down\n\tto output_init_element.\n\t(push_init_element, pop_init_level, set_designator): Adjust\n\tprocess_init_element callers.\n\t(set_nonincremental_init, set_nonincremental_init_from_string):\n\tAdjust add_pending_init callers.\n\t(output_pending_init_elements): Adjust output_init_element callers.\n\t* c-tree.h (process_init_element): Adjust prototype.\n\t* c-parser.c (c_parser_initelt, c_parser_initval): Adjust\n\tprocess_init_element callers.\n\n\t* gcc.dg/pr36489.c: New test.\n\nFrom-SVN: r142998", "tree": {"sha": "53fbcd06f068c1f286ce731e58bc68cc5c3d092f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53fbcd06f068c1f286ce731e58bc68cc5c3d092f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b295aee2b10db8517f186af1bea7071bc95d5fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b295aee2b10db8517f186af1bea7071bc95d5fcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b295aee2b10db8517f186af1bea7071bc95d5fcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b295aee2b10db8517f186af1bea7071bc95d5fcd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91a96b33a9b71785d7372b87824a40da43e5384b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a96b33a9b71785d7372b87824a40da43e5384b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a96b33a9b71785d7372b87824a40da43e5384b"}], "stats": {"total": 166, "additions": 119, "deletions": 47}, "files": [{"sha": "949c8e105e647cd4083b73625b69c574ded5981e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b295aee2b10db8517f186af1bea7071bc95d5fcd", "patch": "@@ -1,3 +1,22 @@\n+2009-01-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/36489\n+\t* c-typeck.c (add_pending_init): Add IMPLICIT argument.  Only\n+\twarn about overwriting initializer with side-effects or\n+\t-Woverride-init if !IMPLICIT.\n+\t(output_init_element): Likewise.  Pass IMPLICIT down to\n+\tadd_pending_init.\n+\t(process_init_element): Add IMPLICIT argument.  Pass it down\n+\tto output_init_element.\n+\t(push_init_element, pop_init_level, set_designator): Adjust\n+\tprocess_init_element callers.\n+\t(set_nonincremental_init, set_nonincremental_init_from_string):\n+\tAdjust add_pending_init callers.\n+\t(output_pending_init_elements): Adjust output_init_element callers.\n+\t* c-tree.h (process_init_element): Adjust prototype.\n+\t* c-parser.c (c_parser_initelt, c_parser_initval): Adjust\n+\tprocess_init_element callers.\n+\n 2008-12-31  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* sched-deps.c (sched_analyze_2) [UNSPEC_VOLATILE]: Flush pending"}, {"sha": "99c6c187a1e6060635e8a8b9e48c442872957f8e", "filename": "gcc/c-parser.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=b295aee2b10db8517f186af1bea7071bc95d5fcd", "patch": "@@ -1,6 +1,6 @@\n /* Parser for C and Objective-C.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n    Parser actions based on the old Bison parser; structure somewhat\n@@ -3090,7 +3090,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  init.original_code = ERROR_MARK;\n \t\t  c_parser_error (parser, \"expected identifier\");\n \t\t  c_parser_skip_until_found (parser, CPP_COMMA, NULL);\n-\t\t  process_init_element (init);\n+\t\t  process_init_element (init, false);\n \t\t  return;\n \t\t}\n \t    }\n@@ -3213,7 +3213,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  init.original_code = ERROR_MARK;\n \t\t  c_parser_error (parser, \"expected %<=%>\");\n \t\t  c_parser_skip_until_found (parser, CPP_COMMA, NULL);\n-\t\t  process_init_element (init);\n+\t\t  process_init_element (init, false);\n \t\t  return;\n \t\t}\n \t    }\n@@ -3243,7 +3243,7 @@ c_parser_initval (c_parser *parser, struct c_expr *after)\n \t  && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)\n \tinit = default_function_array_conversion (init);\n     }\n-  process_init_element (init);\n+  process_init_element (init, false);\n }\n \n /* Parse a compound statement (possibly a function body) (C90 6.6.2,"}, {"sha": "395659512ac2759274d3d5623e78bdb7cac9bbcc", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=b295aee2b10db8517f186af1bea7071bc95d5fcd", "patch": "@@ -1,6 +1,7 @@\n /* Definitions for C parsing and type checking.\n    Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -575,7 +576,7 @@ extern void push_init_level (int);\n extern struct c_expr pop_init_level (int);\n extern void set_init_index (tree, tree);\n extern void set_init_label (tree);\n-extern void process_init_element (struct c_expr);\n+extern void process_init_element (struct c_expr, bool);\n extern tree build_compound_literal (tree, tree);\n extern tree c_start_case (tree);\n extern void c_finish_case (tree);"}, {"sha": "35c8d232878353824b00d6b8faf2f6ba3fcd0459", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b295aee2b10db8517f186af1bea7071bc95d5fcd", "patch": "@@ -1,6 +1,6 @@\n /* Build expressions with type checking for C compiler.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -92,11 +92,11 @@ static int spelling_length (void);\n static char *print_spelling (char *);\n static void warning_init (int, const char *);\n static tree digest_init (tree, tree, bool, int);\n-static void output_init_element (tree, bool, tree, tree, int);\n+static void output_init_element (tree, bool, tree, tree, int, bool);\n static void output_pending_init_elements (int);\n static int set_designator (int);\n static void push_range_stack (tree);\n-static void add_pending_init (tree, tree);\n+static void add_pending_init (tree, tree, bool);\n static void set_nonincremental_init (void);\n static void set_nonincremental_init_from_string (tree);\n static tree find_init_member (tree);\n@@ -5389,12 +5389,12 @@ push_init_level (int implicit)\n \t  if ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t       || TREE_CODE (constructor_type) == UNION_TYPE)\n \t      && constructor_fields == 0)\n-\t    process_init_element (pop_init_level (1));\n+\t    process_init_element (pop_init_level (1), true);\n \t  else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n \t\t   && constructor_max_index\n \t\t   && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t       constructor_index))\n-\t    process_init_element (pop_init_level (1));\n+\t    process_init_element (pop_init_level (1), true);\n \t  else\n \t    break;\n \t}\n@@ -5588,7 +5588,7 @@ pop_init_level (int implicit)\n       /* When we come to an explicit close brace,\n \t pop any inner levels that didn't have explicit braces.  */\n       while (constructor_stack->implicit)\n-\tprocess_init_element (pop_init_level (1));\n+\tprocess_init_element (pop_init_level (1), true);\n \n       gcc_assert (!constructor_range_stack);\n     }\n@@ -5747,7 +5747,7 @@ set_designator (int array)\n       /* Designator list starts at the level of closest explicit\n \t braces.  */\n       while (constructor_stack->implicit)\n-\tprocess_init_element (pop_init_level (1));\n+\tprocess_init_element (pop_init_level (1), true);\n       constructor_designated = 1;\n       return 0;\n     }\n@@ -5908,10 +5908,15 @@ set_init_label (tree fieldname)\n \f\n /* Add a new initializer to the tree of pending initializers.  PURPOSE\n    identifies the initializer, either array index or field in a structure.\n-   VALUE is the value of that index or field.  */\n+   VALUE is the value of that index or field.\n+\n+   IMPLICIT is true if value comes from pop_init_level (1),\n+   the new initializer has been merged with the existing one\n+   and thus no warnings should be emitted about overriding an\n+   existing initializer.  */\n \n static void\n-add_pending_init (tree purpose, tree value)\n+add_pending_init (tree purpose, tree value, bool implicit)\n {\n   struct init_node *p, **q, *r;\n \n@@ -5929,10 +5934,13 @@ add_pending_init (tree purpose, tree value)\n \t    q = &p->right;\n \t  else\n \t    {\n-\t      if (TREE_SIDE_EFFECTS (p->value))\n-\t\twarning_init (0, \"initialized field with side-effects overwritten\");\n-\t      else if (warn_override_init)\n-\t\twarning_init (OPT_Woverride_init, \"initialized field overwritten\");\n+\t      if (!implicit)\n+\t\t{\n+\t\t  if (TREE_SIDE_EFFECTS (p->value))\n+\t\t    warning_init (0, \"initialized field with side-effects overwritten\");\n+\t\t  else if (warn_override_init)\n+\t\t    warning_init (OPT_Woverride_init, \"initialized field overwritten\");\n+\t\t}\n \t      p->value = value;\n \t      return;\n \t    }\n@@ -5952,10 +5960,13 @@ add_pending_init (tree purpose, tree value)\n \t    q = &p->right;\n \t  else\n \t    {\n-\t      if (TREE_SIDE_EFFECTS (p->value))\n-\t\twarning_init (0, \"initialized field with side-effects overwritten\");\n-\t      else if (warn_override_init)\n-\t\twarning_init (OPT_Woverride_init, \"initialized field overwritten\");\n+\t      if (!implicit)\n+\t\t{\n+\t\t  if (TREE_SIDE_EFFECTS (p->value))\n+\t\t    warning_init (0, \"initialized field with side-effects overwritten\");\n+\t\t  else if (warn_override_init)\n+\t\t    warning_init (OPT_Woverride_init, \"initialized field overwritten\");\n+\t\t}\n \t      p->value = value;\n \t      return;\n \t    }\n@@ -6140,7 +6151,7 @@ set_nonincremental_init (void)\n     return;\n \n   FOR_EACH_CONSTRUCTOR_ELT (constructor_elements, ix, index, value)\n-    add_pending_init (index, value);\n+    add_pending_init (index, value, false);\n   constructor_elements = 0;\n   if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n@@ -6230,7 +6241,7 @@ set_nonincremental_init_from_string (tree str)\n \t}\n \n       value = build_int_cst_wide (type, val[1], val[0]);\n-      add_pending_init (purpose, value);\n+      add_pending_init (purpose, value, false);\n     }\n \n   constructor_incremental = 0;\n@@ -6303,11 +6314,16 @@ find_init_member (tree field)\n \n    PENDING if non-nil means output pending elements that belong\n    right after this element.  (PENDING is normally 1;\n-   it is 0 while outputting pending elements, to avoid recursion.)  */\n+   it is 0 while outputting pending elements, to avoid recursion.)\n+\n+   IMPLICIT is true if value comes from pop_init_level (1),\n+   the new initializer has been merged with the existing one\n+   and thus no warnings should be emitted about overriding an\n+   existing initializer.  */\n \n static void\n output_init_element (tree value, bool strict_string, tree type, tree field,\n-\t\t     int pending)\n+\t\t     int pending, bool implicit)\n {\n   constructor_elt *celt;\n \n@@ -6386,7 +6402,7 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t  && tree_int_cst_lt (field, constructor_unfilled_index))\n \tset_nonincremental_init ();\n \n-      add_pending_init (field, value);\n+      add_pending_init (field, value, implicit);\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == RECORD_TYPE\n@@ -6412,17 +6428,21 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t    }\n \t}\n \n-      add_pending_init (field, value);\n+      add_pending_init (field, value, implicit);\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE\n \t   && !VEC_empty (constructor_elt, constructor_elements))\n     {\n-      if (TREE_SIDE_EFFECTS (VEC_last (constructor_elt,\n-\t\t\t\t       constructor_elements)->value))\n-\twarning_init (0, \"initialized field with side-effects overwritten\");\n-      else if (warn_override_init)\n-\twarning_init (OPT_Woverride_init, \"initialized field overwritten\");\n+      if (!implicit)\n+\t{\n+\t  if (TREE_SIDE_EFFECTS (VEC_last (constructor_elt,\n+\t\t\t\t\t   constructor_elements)->value))\n+\t    warning_init (0,\n+\t\t\t  \"initialized field with side-effects overwritten\");\n+\t  else if (warn_override_init)\n+\t    warning_init (OPT_Woverride_init, \"initialized field overwritten\");\n+\t}\n \n       /* We can have just one union field set.  */\n       constructor_elements = 0;\n@@ -6493,7 +6513,7 @@ output_pending_init_elements (int all)\n \t\t\t\t  constructor_unfilled_index))\n \t    output_init_element (elt->value, true,\n \t\t\t\t TREE_TYPE (constructor_type),\n-\t\t\t\t constructor_unfilled_index, 0);\n+\t\t\t\t constructor_unfilled_index, 0, false);\n \t  else if (tree_int_cst_lt (constructor_unfilled_index,\n \t\t\t\t    elt->purpose))\n \t    {\n@@ -6546,7 +6566,7 @@ output_pending_init_elements (int all)\n \t    {\n \t      constructor_unfilled_fields = elt->purpose;\n \t      output_init_element (elt->value, true, TREE_TYPE (elt->purpose),\n-\t\t\t\t   elt->purpose, 0);\n+\t\t\t\t   elt->purpose, 0, false);\n \t    }\n \t  else if (tree_int_cst_lt (ctor_unfilled_bitpos, elt_bitpos))\n \t    {\n@@ -6609,10 +6629,15 @@ output_pending_init_elements (int all)\n    to handle a partly-braced initializer.\n \n    Once this has found the correct level for the new element,\n-   it calls output_init_element.  */\n+   it calls output_init_element.\n+\n+   IMPLICIT is true if value comes from pop_init_level (1),\n+   the new initializer has been merged with the existing one\n+   and thus no warnings should be emitted about overriding an\n+   existing initializer.  */\n \n void\n-process_init_element (struct c_expr value)\n+process_init_element (struct c_expr value, bool implicit)\n {\n   tree orig_value = value.value;\n   int string_flag = orig_value != 0 && TREE_CODE (orig_value) == STRING_CST;\n@@ -6653,12 +6678,12 @@ process_init_element (struct c_expr value)\n       if ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t   || TREE_CODE (constructor_type) == UNION_TYPE)\n \t  && constructor_fields == 0)\n-\tprocess_init_element (pop_init_level (1));\n+\tprocess_init_element (pop_init_level (1), true);\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n \t       && (constructor_max_index == 0\n \t\t   || tree_int_cst_lt (constructor_max_index,\n \t\t\t\t       constructor_index)))\n-\tprocess_init_element (pop_init_level (1));\n+\tprocess_init_element (pop_init_level (1), true);\n       else\n \tbreak;\n     }\n@@ -6725,7 +6750,7 @@ process_init_element (struct c_expr value)\n \t    {\n \t      push_member_name (constructor_fields);\n \t      output_init_element (value.value, strict_string,\n-\t\t\t\t   fieldtype, constructor_fields, 1);\n+\t\t\t\t   fieldtype, constructor_fields, 1, implicit);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -6815,7 +6840,7 @@ process_init_element (struct c_expr value)\n \t    {\n \t      push_member_name (constructor_fields);\n \t      output_init_element (value.value, strict_string,\n-\t\t\t\t   fieldtype, constructor_fields, 1);\n+\t\t\t\t   fieldtype, constructor_fields, 1, implicit);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -6865,7 +6890,7 @@ process_init_element (struct c_expr value)\n \t    {\n \t      push_array_bounds (tree_low_cst (constructor_index, 1));\n \t      output_init_element (value.value, strict_string,\n-\t\t\t\t   elttype, constructor_index, 1);\n+\t\t\t\t   elttype, constructor_index, 1, implicit);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \n@@ -6894,7 +6919,7 @@ process_init_element (struct c_expr value)\n \t  /* Now output the actual element.  */\n \t  if (value.value)\n \t    output_init_element (value.value, strict_string,\n-\t\t\t\t elttype, constructor_index, 1);\n+\t\t\t\t elttype, constructor_index, 1, implicit);\n \n \t  constructor_index\n \t    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n@@ -6919,7 +6944,7 @@ process_init_element (struct c_expr value)\n \t{\n \t  if (value.value)\n \t    output_init_element (value.value, strict_string,\n-\t\t\t\t constructor_type, NULL_TREE, 1);\n+\t\t\t\t constructor_type, NULL_TREE, 1, implicit);\n \t  constructor_fields = 0;\n \t}\n \n@@ -6935,14 +6960,14 @@ process_init_element (struct c_expr value)\n \t  while (constructor_stack != range_stack->stack)\n \t    {\n \t      gcc_assert (constructor_stack->implicit);\n-\t      process_init_element (pop_init_level (1));\n+\t      process_init_element (pop_init_level (1), true);\n \t    }\n \t  for (p = range_stack;\n \t       !p->range_end || tree_int_cst_equal (p->index, p->range_end);\n \t       p = p->prev)\n \t    {\n \t      gcc_assert (constructor_stack->implicit);\n-\t      process_init_element (pop_init_level (1));\n+\t      process_init_element (pop_init_level (1), true);\n \t    }\n \n \t  p->index = size_binop (PLUS_EXPR, p->index, bitsize_one_node);"}, {"sha": "001bab0159d03efc755c8134a156a1e476b1ee8f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b295aee2b10db8517f186af1bea7071bc95d5fcd", "patch": "@@ -1,3 +1,8 @@\n+2009-01-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/36489\n+\t* gcc.dg/pr36489.c: New test.\n+\n 2008-12-31  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* gfortran.dg/mapping_2.f90: Fixed testcase."}, {"sha": "5cf221615ec33c46963684731c747ac5b6d33814", "filename": "gcc/testsuite/gcc.dg/pr36489.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36489.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b295aee2b10db8517f186af1bea7071bc95d5fcd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36489.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36489.c?ref=b295aee2b10db8517f186af1bea7071bc95d5fcd", "patch": "@@ -0,0 +1,22 @@\n+/* PR c/36489 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Woverride-init\" } */\n+\n+struct A { int a; int b[3]; };\n+union B { int a; int b[3]; };\n+int t1[10][10]\n+  = { [1][2] = 11, [1][3] = 12 };\n+int t2[10][10]\n+  = { [1][2] = 11, [1] = { [3] = 12 } };\t/* { dg-warning \"initializ\" } */\n+int t3[10][10]\n+  = { [1][2] = 11, [1][2] = 12 };\t\t/* { dg-warning \"initializ\" } */\n+struct A t4[2]\n+  = { [0].b[0] = 1, [0].b[1] = 2, [0].b[2] = 3 };\n+struct A t5[2]\n+  = { [0].b[0] = 1, [0].b[1] = 2, [0].b = { 3 } }; /* { dg-warning \"initializ\" } */\n+union B t6\n+  = { .b[0] = 1, .b[1] = 2, .b[2] = 3 };\n+union B t7\n+  = { .b[0] = 1, .b[1] = 2, .b = { 2 } };\t/* { dg-warning \"initializ\" } */\n+union B t8\n+  = { .b[0] = 1, .b[1] = 2, .b[1] = 3 };\t/* { dg-warning \"initializ\" } */"}]}