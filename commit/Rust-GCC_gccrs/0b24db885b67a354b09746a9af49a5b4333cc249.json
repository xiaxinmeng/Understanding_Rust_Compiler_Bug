{"sha": "0b24db885b67a354b09746a9af49a5b4333cc249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIyNGRiODg1YjY3YTM1NGIwOTc0NmE5YWY0OWE1YjQzMzNjYzI0OQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-04-09T21:39:14Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-04-09T21:39:14Z"}, "message": "simplify-rtx.c (mode_signbit_p): New function to check whether an RTX is an immediate constant that represents...\n\n\n\t* simplify-rtx.c (mode_signbit_p): New function to check whether\n\tan RTX is an immediate constant that represents the most significant\n\tbit of a given machine mode.\n\t(simplify_unary_operation) <NOT>: Optimize ~(X+C) as X ^ ~C, where\n\tC is the sign bit.\n\t(simplify_binary_operation) <PLUS>: Optimize (X^C1) + C2 as X^(C1^C2)\n\twhen C2 is the sign bit.\n\t(simplify_binary_operation) <XOR>: Canonicalize X^C as X+C when C\n\tis the sign bit.  Optimize (X+C1) ^ C2 as X^(C1^C2) when C1 is the\n\tsign bit.\n\n\t* gcc.c-torture/execute/20040409-1.c: New test case.\n\t* gcc.c-torture/execute/20040409-2.c: New test case.\n\t* gcc.c-torture/execute/20040409-3.c: New test case.\n\nFrom-SVN: r80568", "tree": {"sha": "48b3dead6c152c128f09b4ca6fa75231cacb39d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48b3dead6c152c128f09b4ca6fa75231cacb39d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b24db885b67a354b09746a9af49a5b4333cc249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b24db885b67a354b09746a9af49a5b4333cc249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b24db885b67a354b09746a9af49a5b4333cc249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b24db885b67a354b09746a9af49a5b4333cc249/comments", "author": null, "committer": null, "parents": [{"sha": "ce58118c3d596e5732e17cbca57b6e7518b50d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce58118c3d596e5732e17cbca57b6e7518b50d70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce58118c3d596e5732e17cbca57b6e7518b50d70"}], "stats": {"total": 621, "additions": 620, "deletions": 1}, "files": [{"sha": "3a41ae92e071f6dc6ef1ffe03e957b3b750ad0d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b24db885b67a354b09746a9af49a5b4333cc249", "patch": "@@ -1,3 +1,16 @@\n+2004-04-09  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* simplify-rtx.c (mode_signbit_p): New function to check whether\n+\tan RTX is an immediate constant that represents the most significant\n+\tbit of a given machine mode.\n+\t(simplify_unary_operation) <NOT>: Optimize ~(X+C) as X ^ ~C, where\n+\tC is the sign bit.\n+\t(simplify_binary_operation) <PLUS>: Optimize (X^C1) + C2 as X^(C1^C2)\n+\twhen C2 is the sign bit.\n+\t(simplify_binary_operation) <XOR>: Canonicalize X^C as X+C when C\n+\tis the sign bit.  Optimize (X+C1) ^ C2 as X^(C1^C2) when C1 is the\n+\tsign bit.\n+\n 2004-04-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.c (mathfn_built_in): Check TYPE_MAIN_VARIANT, not"}, {"sha": "49f2d37bd15bffa70f865aa9ddf93fc152654ac1", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=0b24db885b67a354b09746a9af49a5b4333cc249", "patch": "@@ -50,6 +50,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n  ((((HOST_WIDE_INT) low) < 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))\n \n static rtx neg_const_int (enum machine_mode, rtx);\n+static bool mode_signbit_p (enum machine_mode, rtx);\n static int simplify_plus_minus_op_data_cmp (const void *, const void *);\n static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx,\n \t\t\t\trtx, int);\n@@ -66,6 +67,39 @@ neg_const_int (enum machine_mode mode, rtx i)\n   return gen_int_mode (- INTVAL (i), mode);\n }\n \n+/* Test whether expression, X, is an immediate constant that represents\n+   the most significant bit of machine mode MODE.  */\n+\n+static bool\n+mode_signbit_p (enum machine_mode mode, rtx x)\n+{\n+  unsigned HOST_WIDE_INT val;\n+  unsigned int width;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return false;\n+\n+  width = GET_MODE_BITSIZE (mode);\n+  if (width == 0)\n+    return false;\n+  \n+  if (width <= HOST_BITS_PER_WIDE_INT\n+      && GET_CODE (x) == CONST_INT)\n+    val = INTVAL (x);\n+  else if (width <= 2 * HOST_BITS_PER_WIDE_INT\n+\t   && GET_CODE (x) == CONST_DOUBLE\n+\t   && CONST_DOUBLE_LOW (x) == 0)\n+    {\n+      val = CONST_DOUBLE_HIGH (x);\n+      width -= HOST_BITS_PER_WIDE_INT;\n+    }\n+  else\n+    return false;\n+\n+  if (width < HOST_BITS_PER_WIDE_INT)\n+    val &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+  return val == ((unsigned HOST_WIDE_INT) 1 << (width - 1));\n+}\n \f\n /* Make a binary operation by properly ordering the operands and\n    seeing if the expression folds.  */\n@@ -912,6 +946,16 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t\t\t\t\t   mode)) != 0)\n \t    return simplify_gen_binary (XOR, mode, XEXP (op, 0), temp);\n \n+\t  /* (not (plus X C)) for signbit C is (xor X D) with D = ~C.  */\n+\t  if (GET_CODE (op) == PLUS\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t      && mode_signbit_p (mode, XEXP (op, 1))\n+\t      && (temp = simplify_unary_operation (NOT, mode,\n+\t\t\t\t\t\t   XEXP (op, 1),\n+\t\t\t\t\t\t   mode)) != 0)\n+\t    return simplify_gen_binary (XOR, mode, XEXP (op, 0), temp);\n+\n+\n \n \t  /* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for\n \t     operands other than 1, but that is not valid.  We could do a\n@@ -1514,6 +1558,17 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t}\n \t    }\n \n+\t  /* (plus (xor X C1) C2) is (xor X (C1^C2)) if C2 is signbit.  */\n+\t  if ((GET_CODE (op1) == CONST_INT\n+\t       || GET_CODE (op1) == CONST_DOUBLE)\n+\t      && GET_CODE (op0) == XOR\n+\t      && (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t\t  || GET_CODE (XEXP (op0, 1)) == CONST_DOUBLE)\n+\t      && mode_signbit_p (mode, op1))\n+\t    return simplify_gen_binary (XOR, mode, XEXP (op0, 0),\n+\t\t\t\t\tsimplify_gen_binary (XOR, mode, op1,\n+\t\t\t\t\t\t\t     XEXP (op0, 1)));\n+\n \t  /* If one of the operands is a PLUS or a MINUS, see if we can\n \t     simplify this by the associative law.\n \t     Don't use the associative law for floating point.\n@@ -1797,9 +1852,27 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n \t\t  == GET_MODE_MASK (mode)))\n \t    return simplify_gen_unary (NOT, mode, op0, mode);\n-\t  if (trueop0 == trueop1 && ! side_effects_p (op0)\n+\t  if (trueop0 == trueop1\n+\t      && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return const0_rtx;\n+\n+\t  /* Canonicalize XOR of the most significant bit to PLUS.  */\n+\t  if ((GET_CODE (op1) == CONST_INT\n+\t       || GET_CODE (op1) == CONST_DOUBLE)\n+\t      && mode_signbit_p (mode, op1))\n+\t    return simplify_gen_binary (PLUS, mode, op0, op1);\n+\t  /* (xor (plus X C1) C2) is (xor X (C1^C2)) if C1 is signbit.  */\n+\t  if ((GET_CODE (op1) == CONST_INT\n+\t       || GET_CODE (op1) == CONST_DOUBLE)\n+\t      && GET_CODE (op0) == PLUS\n+\t      && (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t\t  || GET_CODE (XEXP (op0, 1)) == CONST_DOUBLE)\n+\t      && mode_signbit_p (mode, XEXP (op0, 1)))\n+\t    return simplify_gen_binary (XOR, mode, XEXP (op0, 0),\n+\t\t\t\t\tsimplify_gen_binary (XOR, mode, op1,\n+\t\t\t\t\t\t\t     XEXP (op0, 1)));\n+\t      \n \t  tem = simplify_associative_operation (code, mode, op0, op1);\n \t  if (tem)\n \t    return tem;"}, {"sha": "40d5e47cf99ad453c7533c0baf976b2184eb9a64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b24db885b67a354b09746a9af49a5b4333cc249", "patch": "@@ -1,3 +1,9 @@\n+2004-04-09  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/20040409-1.c: New test case.\n+\t* gcc.c-torture/execute/20040409-2.c: New test case.\n+\t* gcc.c-torture/execute/20040409-3.c: New test case.\n+\n 2004-04-09  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* gcc.dg/20040409-1.c: New test."}, {"sha": "1e81edb365f24e8bbb80150e85ef7d6e3c74a9e1", "filename": "gcc/testsuite/gcc.c-torture/execute/20040409-1.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-1.c?ref=0b24db885b67a354b09746a9af49a5b4333cc249", "patch": "@@ -0,0 +1,142 @@\n+#include <limits.h>\n+\n+extern void abort ();\n+\n+int test1(int x)\n+{\n+  return x ^ INT_MIN;\n+}\n+\n+unsigned int test1u(unsigned int x)\n+{\n+  return x ^ (unsigned int)INT_MIN;\n+}\n+\n+int test2(int x)\n+{\n+  return x + INT_MIN;\n+}\n+\n+unsigned int test2u(unsigned int x)\n+{\n+  return x + (unsigned int)INT_MIN;\n+}\n+\n+int test3(int x)\n+{\n+  return x - INT_MIN;\n+}\n+\n+unsigned int test3u(unsigned int x)\n+{\n+  return x - (unsigned int)INT_MIN;\n+}\n+\n+int test4(int x)\n+{\n+  int y = INT_MIN;\n+  return x ^ y;\n+}\n+\n+unsigned int test4u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  return x ^ y;\n+}\n+\n+int test5(int x)\n+{\n+  int y = INT_MIN;\n+  return x + y;\n+}\n+\n+unsigned int test5u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  return x + y;\n+}\n+\n+int test6(int x)\n+{\n+  int y = INT_MIN;\n+  return x - y;\n+}\n+\n+unsigned int test6u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  return x - y;\n+}\n+\n+\n+\n+void test(int a, int b)\n+{\n+  if (test1(a) != b)\n+    abort();\n+  if (test2(a) != b)\n+    abort();\n+  if (test3(a) != b)\n+    abort();\n+  if (test4(a) != b)\n+    abort();\n+  if (test5(a) != b)\n+    abort();\n+  if (test6(a) != b)\n+    abort();\n+}\n+\n+void testu(unsigned int a, unsigned int b)\n+{\n+  if (test1u(a) != b)\n+    abort();\n+  if (test2u(a) != b)\n+    abort();\n+  if (test3u(a) != b)\n+    abort();\n+  if (test4u(a) != b)\n+    abort();\n+  if (test5u(a) != b)\n+    abort();\n+  if (test6u(a) != b)\n+    abort();\n+}\n+\n+\n+int main()\n+{\n+#if INT_MAX == 2147483647\n+  test(0x00000000,0x80000000);\n+  test(0x80000000,0x00000000);\n+  test(0x12345678,0x92345678);\n+  test(0x92345678,0x12345678);\n+  test(0x7fffffff,0xffffffff);\n+  test(0xffffffff,0x7fffffff);\n+\n+  testu(0x00000000,0x80000000);\n+  testu(0x80000000,0x00000000);\n+  testu(0x12345678,0x92345678);\n+  testu(0x92345678,0x12345678);\n+  testu(0x7fffffff,0xffffffff);\n+  testu(0xffffffff,0x7fffffff);\n+#endif\n+\n+#if INT_MAX == 32767\n+  test(0x0000,0x8000);\n+  test(0x8000,0x0000);\n+  test(0x1234,0x9234);\n+  test(0x9234,0x1234);\n+  test(0x7fff,0xffff);\n+  test(0xffff,0x7fff);\n+\n+  testu(0x0000,0x8000);\n+  testu(0x8000,0x0000);\n+  testu(0x1234,0x9234);\n+  testu(0x9234,0x1234);\n+  testu(0x7fff,0xffff);\n+  testu(0xffff,0x7fff);\n+#endif\n+\n+  return 0;\n+}\n+"}, {"sha": "5bec7ee9218d6d9eb7ae9584688b6946604c3894", "filename": "gcc/testsuite/gcc.c-torture/execute/20040409-2.c", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-2.c?ref=0b24db885b67a354b09746a9af49a5b4333cc249", "patch": "@@ -0,0 +1,243 @@\n+#include <limits.h>\n+\n+extern void abort ();\n+\n+int test1(int x)\n+{\n+  return (x ^ INT_MIN) ^ 0x1234;\n+}\n+\n+unsigned int test1u(unsigned int x)\n+{\n+  return (x ^ (unsigned int)INT_MIN) ^ 0x1234;\n+}\n+\n+int test2(int x)\n+{\n+  return (x ^ 0x1234) ^ INT_MIN;\n+}\n+\n+unsigned int test2u(unsigned int x)\n+{\n+  return (x ^ 0x1234) ^ (unsigned int)INT_MIN;\n+}\n+\n+int test3(int x)\n+{\n+  return (x + INT_MIN) ^ 0x1234;\n+}\n+\n+unsigned int test3u(unsigned int x)\n+{\n+  return (x + (unsigned int)INT_MIN) ^ 0x1234;\n+}\n+\n+int test4(int x)\n+{\n+  return (x ^ 0x1234) + INT_MIN;\n+}\n+\n+unsigned int test4u(unsigned int x)\n+{\n+  return (x ^ 0x1234) + (unsigned int)INT_MIN;\n+}\n+\n+int test5(int x)\n+{\n+  return (x - INT_MIN) ^ 0x1234;\n+}\n+\n+unsigned int test5u(unsigned int x)\n+{\n+  return (x - (unsigned int)INT_MIN) ^ 0x1234;\n+}\n+\n+int test6(int x)\n+{\n+  return (x ^ 0x1234) - INT_MIN;\n+}\n+\n+unsigned int test6u(unsigned int x)\n+{\n+  return (x ^ 0x1234) - (unsigned int)INT_MIN;\n+}\n+\n+int test7(int x)\n+{\n+  int y = INT_MIN;\n+  int z = 0x1234;\n+  return (x ^ y) ^ z;\n+}\n+\n+unsigned int test7u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  unsigned int z = 0x1234;\n+  return (x ^ y) ^ z;\n+}\n+\n+int test8(int x)\n+{\n+  int y = 0x1234;\n+  int z = INT_MIN;\n+  return (x ^ y) ^ z;\n+}\n+\n+unsigned int test8u(unsigned int x)\n+{\n+  unsigned int y = 0x1234;\n+  unsigned int z = (unsigned int)INT_MIN;\n+  return (x ^ y) ^ z;\n+}\n+\n+int test9(int x)\n+{\n+  int y = INT_MIN;\n+  int z = 0x1234;\n+  return (x + y) ^ z;\n+}\n+\n+unsigned int test9u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  unsigned int z = 0x1234;\n+  return (x + y) ^ z;\n+}\n+\n+int test10(int x)\n+{\n+  int y = 0x1234;\n+  int z = INT_MIN;\n+  return (x ^ y) + z;\n+}\n+\n+unsigned int test10u(unsigned int x)\n+{\n+  unsigned int y = 0x1234;\n+  unsigned int z = (unsigned int)INT_MIN;\n+  return (x ^ y) + z;\n+}\n+\n+int test11(int x)\n+{\n+  int y = INT_MIN;\n+  int z = 0x1234;\n+  return (x - y) ^ z;\n+}\n+\n+unsigned int test11u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  unsigned int z = 0x1234;\n+  return (x - y) ^ z;\n+}\n+\n+int test12(int x)\n+{\n+  int y = 0x1234;\n+  int z = INT_MIN;\n+  return (x ^ y) - z;\n+}\n+\n+unsigned int test12u(unsigned int x)\n+{\n+  unsigned int y = 0x1234;\n+  unsigned int z = (unsigned int)INT_MIN;\n+  return (x ^ y) - z;\n+}\n+\n+\n+void test(int a, int b)\n+{\n+  if (test1(a) != b)\n+    abort();\n+  if (test2(a) != b)\n+    abort();\n+  if (test3(a) != b)\n+    abort();\n+  if (test4(a) != b)\n+    abort();\n+  if (test5(a) != b)\n+    abort();\n+  if (test6(a) != b)\n+    abort();\n+  if (test7(a) != b)\n+    abort();\n+  if (test8(a) != b)\n+    abort();\n+  if (test9(a) != b)\n+    abort();\n+  if (test10(a) != b)\n+    abort();\n+  if (test11(a) != b)\n+    abort();\n+  if (test12(a) != b)\n+    abort();\n+}\n+\n+void testu(unsigned int a, unsigned int b)\n+{\n+  if (test1u(a) != b)\n+    abort();\n+  if (test2u(a) != b)\n+    abort();\n+  if (test3u(a) != b)\n+    abort();\n+  if (test4u(a) != b)\n+    abort();\n+  if (test5u(a) != b)\n+    abort();\n+  if (test6u(a) != b)\n+    abort();\n+  if (test7u(a) != b)\n+    abort();\n+  if (test8u(a) != b)\n+    abort();\n+  if (test9u(a) != b)\n+    abort();\n+  if (test10u(a) != b)\n+    abort();\n+  if (test11u(a) != b)\n+    abort();\n+  if (test12u(a) != b)\n+    abort();\n+}\n+\n+\n+int main()\n+{\n+#if INT_MAX == 2147483647\n+  test(0x00000000,0x80001234);\n+  test(0x00001234,0x80000000);\n+  test(0x80000000,0x00001234);\n+  test(0x80001234,0x00000000);\n+  test(0x7fffffff,0xffffedcb);\n+  test(0xffffffff,0x7fffedcb);\n+\n+  testu(0x00000000,0x80001234);\n+  testu(0x00001234,0x80000000);\n+  testu(0x80000000,0x00001234);\n+  testu(0x80001234,0x00000000);\n+  testu(0x7fffffff,0xffffedcb);\n+  testu(0xffffffff,0x7fffedcb);\n+#endif\n+\n+#if INT_MAX == 32767\n+  test(0x0000,0x9234);\n+  test(0x1234,0x8000);\n+  test(0x8000,0x1234);\n+  test(0x9234,0x0000);\n+  test(0x7fff,0xffff);\n+  test(0xffff,0x7fff);\n+\n+  testu(0x0000,0x8000);\n+  testu(0x8000,0x0000);\n+  testu(0x1234,0x9234);\n+  testu(0x9234,0x1234);\n+  testu(0x7fff,0xedcb);\n+  testu(0xffff,0x6dcb);\n+#endif\n+\n+  return 0;\n+}\n+"}, {"sha": "07aa99cee1f29658c8c23e466b743274d4b7b0a7", "filename": "gcc/testsuite/gcc.c-torture/execute/20040409-3.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b24db885b67a354b09746a9af49a5b4333cc249/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040409-3.c?ref=0b24db885b67a354b09746a9af49a5b4333cc249", "patch": "@@ -0,0 +1,142 @@\n+#include <limits.h>\n+\n+extern void abort ();\n+\n+int test1(int x)\n+{\n+  return ~(x ^ INT_MIN);\n+}\n+\n+unsigned int test1u(unsigned int x)\n+{\n+  return ~(x ^ (unsigned int)INT_MIN);\n+}\n+\n+int test2(int x)\n+{\n+  return ~(x + INT_MIN);\n+}\n+\n+unsigned int test2u(unsigned int x)\n+{\n+  return ~(x + (unsigned int)INT_MIN);\n+}\n+\n+int test3(int x)\n+{\n+  return ~(x - INT_MIN);\n+}\n+\n+unsigned int test3u(unsigned int x)\n+{\n+  return ~(x - (unsigned int)INT_MIN);\n+}\n+\n+int test4(int x)\n+{\n+  int y = INT_MIN;\n+  return ~(x ^ y);\n+}\n+\n+unsigned int test4u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  return ~(x ^ y);\n+}\n+\n+int test5(int x)\n+{\n+  int y = INT_MIN;\n+  return ~(x + y);\n+}\n+\n+unsigned int test5u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  return ~(x + y);\n+}\n+\n+int test6(int x)\n+{\n+  int y = INT_MIN;\n+  return ~(x - y);\n+}\n+\n+unsigned int test6u(unsigned int x)\n+{\n+  unsigned int y = (unsigned int)INT_MIN;\n+  return ~(x - y);\n+}\n+\n+\n+\n+void test(int a, int b)\n+{\n+  if (test1(a) != b)\n+    abort();\n+  if (test2(a) != b)\n+    abort();\n+  if (test3(a) != b)\n+    abort();\n+  if (test4(a) != b)\n+    abort();\n+  if (test5(a) != b)\n+    abort();\n+  if (test6(a) != b)\n+    abort();\n+}\n+\n+void testu(unsigned int a, unsigned int b)\n+{\n+  if (test1u(a) != b)\n+    abort();\n+  if (test2u(a) != b)\n+    abort();\n+  if (test3u(a) != b)\n+    abort();\n+  if (test4u(a) != b)\n+    abort();\n+  if (test5u(a) != b)\n+    abort();\n+  if (test6u(a) != b)\n+    abort();\n+}\n+\n+\n+int main()\n+{\n+#if INT_MAX == 2147483647\n+  test(0x00000000,0x7fffffff);\n+  test(0x80000000,0xffffffff);\n+  test(0x12345678,0x6dcba987);\n+  test(0x92345678,0xedcba987);\n+  test(0x7fffffff,0x00000000);\n+  test(0xffffffff,0x80000000);\n+\n+  testu(0x00000000,0x7fffffff);\n+  testu(0x80000000,0xffffffff);\n+  testu(0x12345678,0x6dcba987);\n+  testu(0x92345678,0xedcba987);\n+  testu(0x7fffffff,0x00000000);\n+  testu(0xffffffff,0x80000000);\n+#endif\n+\n+#if INT_MAX == 32767\n+  test(0x0000,0x7fff);\n+  test(0x8000,0xffff);\n+  test(0x1234,0x6dcb);\n+  test(0x9234,0xedcb);\n+  test(0x7fff,0x0000);\n+  test(0xffff,0x8000);\n+\n+  testu(0x0000,0x7fff);\n+  testu(0x8000,0xffff);\n+  testu(0x1234,0x6dcb);\n+  testu(0x9234,0xedcb);\n+  testu(0x7fff,0x0000);\n+  testu(0xffff,0x8000);\n+#endif\n+\n+  return 0;\n+}\n+"}]}