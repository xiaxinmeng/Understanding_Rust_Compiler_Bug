{"sha": "38a37714e672206ae98b499861ec23eaff0909e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhMzc3MTRlNjcyMjA2YWU5OGI0OTk4NjFlYzIzZWFmZjA5MDllMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-04T17:45:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-04T17:45:16Z"}, "message": "re PR c++/20746 ([4.0 only] Incorrect return value for covariant return function returning null ptr)\n\ncp:\n\tPR c++/20746\n\t* method.c (use_thunk): Protect covariant pointer return\n\tadjustments from NULL pointers.\ntestsuite:\n\tPR c++/20746\n\t* g++.dg/abi/covariant5.C: New.\n\nFrom-SVN: r97557", "tree": {"sha": "b1c370ce6f0a73b8b6bd72c7bbb2a3dc0e3f62ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1c370ce6f0a73b8b6bd72c7bbb2a3dc0e3f62ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38a37714e672206ae98b499861ec23eaff0909e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38a37714e672206ae98b499861ec23eaff0909e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38a37714e672206ae98b499861ec23eaff0909e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38a37714e672206ae98b499861ec23eaff0909e0/comments", "author": null, "committer": null, "parents": [{"sha": "6d6f2d0804ab464f43e5f20563948dc85542a50a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d6f2d0804ab464f43e5f20563948dc85542a50a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d6f2d0804ab464f43e5f20563948dc85542a50a"}], "stats": {"total": 84, "additions": 81, "deletions": 3}, "files": [{"sha": "f38b03dda3040945ace093ec80b2d9772c57c944", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=38a37714e672206ae98b499861ec23eaff0909e0", "patch": "@@ -1,3 +1,9 @@\n+2005-04-04  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/20746\n+\t* method.c (use_thunk): Protect covariant pointer return\n+\tadjustments from NULL pointers.\n+\n 2005-04-04  Jan Hubicka  <jh@suse.cz>\n \n \t* decl2.c (finish_objects): Revert my previous patch."}, {"sha": "9036f64c80286a6375941c6086039d107c010b04", "filename": "gcc/cp/method.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=38a37714e672206ae98b499861ec23eaff0909e0", "patch": "@@ -470,10 +470,27 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \tfinish_expr_stmt (t);\n       else\n \t{\n-\t  t = force_target_expr (TREE_TYPE (t), t);\n \t  if (!this_adjusting)\n-\t    t = thunk_adjust (t, /*this_adjusting=*/0,\n-\t\t\t      fixed_offset, virtual_offset);\n+\t    {\n+\t      tree cond = NULL_TREE;\n+\n+\t      if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n+\t\t{\n+\t\t  /* If the return type is a pointer, we need to\n+\t\t     protect against NULL.  We know there will be an\n+\t\t     adjustment, because that's why we're emitting a\n+\t\t     thunk.  */\n+\t\t  t = save_expr (t);\n+\t\t  cond = cp_convert (boolean_type_node, t);\n+\t\t}\n+\t      \n+\t      t = thunk_adjust (t, /*this_adjusting=*/0,\n+\t\t\t\tfixed_offset, virtual_offset);\n+\t      if (cond)\n+\t\tt = build3 (COND_EXPR, TREE_TYPE (t), cond, t,\n+\t\t\t    cp_convert (TREE_TYPE (t), integer_zero_node));\n+\t    }\n+\t  t = force_target_expr (TREE_TYPE (t), t);\n \t  finish_return_stmt (t);\n \t}\n "}, {"sha": "ddb7ae2d5103f0b1fe55a92b1aeaa41b322df02e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=38a37714e672206ae98b499861ec23eaff0909e0", "patch": "@@ -1,5 +1,8 @@\n 2005-04-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\tPR c++/20746\n+\t* g++.dg/abi/covariant5.C: New.\n+\n \tPR debug/20505\n \t* g++.dg/debug/const2.C: New.\n "}, {"sha": "03e55583d03583f24989bb27a35bba3963acabc4", "filename": "gcc/testsuite/g++.dg/abi/covariant5.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a37714e672206ae98b499861ec23eaff0909e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant5.C?ref=38a37714e672206ae98b499861ec23eaff0909e0", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 Apr 2005 <nathan@codesourcery.com>\n+\n+// { dg-do run }\n+\n+// PR 20746: Covariant return pointer could be null.\n+\n+// Origin: yanliu@ca.ibm.com\n+//         nathan@codesourcery.com\n+\n+struct A {\n+  virtual void One ();\n+};\n+struct B  { \n+  virtual B *Two ();\n+  virtual B &Three ();\n+};\n+\n+struct C : A, B\n+{\n+  virtual C *Two (); \n+  virtual C &Three (); \n+};\n+void A::One () {}\n+B *B::Two()    {return this;}\n+B &B::Three()    {return *this;}\n+C *C::Two ()   {return 0;}\n+C &C::Three ()   {return *(C *)0;}\n+\n+B *Foo (B *b)\n+{\n+  return b->Two ();\n+}\n+\n+B &Bar (B *b)\n+{\n+  return b->Three ();\n+}\n+\n+int main ()\n+{\n+  C c;\n+\n+  /* We should not adjust a null pointer.  */\n+  if (Foo (&c))\n+    return 1;\n+  /* But we should adjust a (bogus) null reference.  */\n+  if (!&Bar (&c))\n+    return 2;\n+\n+  return 0;\n+}"}]}