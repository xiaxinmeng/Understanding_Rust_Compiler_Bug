{"sha": "06a3a6db4927eae52a4d3641a0ac551f13303f40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZhM2E2ZGI0OTI3ZWFlNTJhNGQzNjQxYTBhYzU1MWYxMzMwM2Y0MA==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2000-12-05T19:12:20Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-12-05T19:12:20Z"}, "message": "global.c (global_conflicts): Allow for a REG_UNUSED note with a different mode to the REG set in the insn.\n\n* global.c (global_conflicts): Allow for a REG_UNUSED note\nwith a different mode to the REG set in the insn.\n\n* gcc.c-torture/execute/20001203-2.c: New testcase.\n\nFrom-SVN: r38046", "tree": {"sha": "1cc6d53b64fe4875095c73cca99ebc7d2f154ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cc6d53b64fe4875095c73cca99ebc7d2f154ef1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06a3a6db4927eae52a4d3641a0ac551f13303f40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a3a6db4927eae52a4d3641a0ac551f13303f40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a3a6db4927eae52a4d3641a0ac551f13303f40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a3a6db4927eae52a4d3641a0ac551f13303f40/comments", "author": null, "committer": null, "parents": [{"sha": "9c101f4a0fa7eedad44f57e6c32c42a2141b369e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c101f4a0fa7eedad44f57e6c32c42a2141b369e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c101f4a0fa7eedad44f57e6c32c42a2141b369e"}], "stats": {"total": 143, "additions": 139, "deletions": 4}, "files": [{"sha": "d2a3e48ef2d6757f3c41a37338a4ce3ce4173f6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06a3a6db4927eae52a4d3641a0ac551f13303f40", "patch": "@@ -1,3 +1,8 @@\n+2000-12-05  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* global.c (global_conflicts): Allow for a REG_UNUSED note\n+\twith a different mode to the REG set in the insn.\n+\n 2000-12-05  Kaveh R. Ghazi  <ghazi@teal.rutgers.edu>\n \n \t* Makefile.in (fixinc.sh): Pass $WARN_CFLAGS into fixinc dir."}, {"sha": "8aa172a5e36aa9504008c7119f6d9cddff4cdff0", "filename": "gcc/global.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=06a3a6db4927eae52a4d3641a0ac551f13303f40", "patch": "@@ -804,10 +804,13 @@ global_conflicts ()\n \n \t      /* Mark any registers set in INSN and then never used.  */\n \n-\t      while (n_regs_set > 0)\n-\t\tif (find_regno_note (insn, REG_UNUSED,\n-\t\t\t\t     REGNO (regs_set[--n_regs_set])))\n-\t\t  mark_reg_death (regs_set[n_regs_set]);\n+\t      while (n_regs_set-- > 0)\n+\t\t{\n+\t\t  rtx note = find_regno_note (insn, REG_UNUSED,\n+\t\t\t\t\t      REGNO (regs_set[n_regs_set]));\n+\t\t  if (note)\n+\t\t    mark_reg_death (XEXP (note, 0));\n+\t\t}\n \t    }\n \n \t  if (insn == BLOCK_END (b))"}, {"sha": "34ba49e016b1e0f52a78df771ee8d166961c99af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06a3a6db4927eae52a4d3641a0ac551f13303f40", "patch": "@@ -1,3 +1,7 @@\n+2000-12-05  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* gcc.c-torture/execute/20001203-2.c: New testcase.\n+\n 2000-12-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.old-deja/g++.h/spec6.C: Remove some of the XFAILS."}, {"sha": "55d63ffa4a790d7229d56cded21d792241d3a14e", "filename": "gcc/testsuite/gcc.c-torture/execute/20001203-2.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20001203-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a3a6db4927eae52a4d3641a0ac551f13303f40/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20001203-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20001203-2.c?ref=06a3a6db4927eae52a4d3641a0ac551f13303f40", "patch": "@@ -0,0 +1,123 @@\n+struct obstack\n+{\n+  long chunk_size;\n+  struct _obstack_chunk *chunk;\n+  char *object_base;\n+  char *next_free;\n+  char *chunk_limit;\n+  int alignment_mask;\n+  unsigned maybe_empty_object;\n+};\n+\n+struct objfile\n+  {\n+    struct objfile *next;\n+    struct obstack type_obstack;\n+  };\n+\n+struct type\n+  {\n+    unsigned length;\n+    struct objfile *objfile;\n+    short nfields;\n+    struct field\n+      {\n+        union field_location\n+          {\n+            int bitpos;\n+            unsigned long physaddr;\n+            char *physname;\n+          }\n+        loc;\n+        int bitsize;\n+        struct type *type;\n+        char *name;\n+      }\n+     *fields;\n+  };\n+\n+struct type *alloc_type (void);\n+void * xmalloc (unsigned int z);\n+void _obstack_newchunk (struct obstack *o, int i);\n+void get_discrete_bounds (long long *lowp, long long *highp);\n+\n+extern void *memset(void *, int, unsigned int);\n+\n+struct type *\n+create_array_type (struct type *result_type, struct type *element_type)\n+{\n+  long long low_bound, high_bound;\n+  if (result_type == ((void *)0))\n+    {\n+      result_type = alloc_type ();\n+    }\n+  get_discrete_bounds (&low_bound, &high_bound);\n+  (result_type)->length =\n+    (element_type)->length * (high_bound - low_bound + 1);\n+  (result_type)->nfields = 1;\n+  (result_type)->fields =\n+    (struct field *) ((result_type)->objfile != ((void *)0) \n+\t\t      ? (\n+\t\t      {\n+\t\t\tstruct obstack *__h = \n+\t\t\t  (&(result_type)->objfile -> type_obstack);\n+\t\t\t{\n+\t\t\t  struct obstack *__o = (__h);\n+\t\t\t  int __len = ((sizeof (struct field)));\n+\t\t\t  if (__o->chunk_limit - __o->next_free < __len)\n+\t\t\t    _obstack_newchunk (__o, __len); \n+\t\t\t  __o->next_free += __len; (void) 0;\n+\t\t\t};\n+\t\t\t({\n+\t\t\t  struct obstack *__o1 = (__h); \n+\t\t\t  void *value; \n+\t\t\t  value = (void *) __o1->object_base;\n+\t\t\t  if (__o1->next_free == value)\n+\t\t\t    __o1->maybe_empty_object = 1;\n+\t\t\t  __o1->next_free = (((((__o1->next_free) - (char *) 0)\n+\t\t\t\t\t       +__o1->alignment_mask) \n+\t\t\t\t\t      & ~ (__o1->alignment_mask)) \n+\t\t\t\t\t     + (char *) 0);\n+\t\t\t  if (__o1->next_free - (char *)__o1->chunk \n+\t\t\t      > __o1->chunk_limit - (char *)__o1->chunk)\n+\t\t\t    __o1->next_free = __o1->chunk_limit;\n+\t\t\t  __o1->object_base = __o1->next_free; \n+\t\t\t  value;\n+\t\t\t});\n+\t\t      }) : xmalloc (sizeof (struct field)));\n+  return (result_type);\n+}\n+\n+struct type *\n+alloc_type (void)\n+{\n+  abort ();\n+}\n+void * xmalloc (unsigned int z)\n+{\n+  return 0;\n+}\n+void _obstack_newchunk (struct obstack *o, int i)\n+{\n+  abort ();\n+}\n+void\n+get_discrete_bounds (long long *lowp, long long *highp)\n+{\n+  *lowp = 0;\n+  *highp = 2;\n+}\n+\n+int main(void)\n+{\n+  struct type element_type;\n+  struct type result_type;\n+  \n+  memset (&element_type, 0, sizeof (struct type));\n+  memset (&result_type, 0, sizeof (struct type));\n+  element_type.length = 4;\n+  create_array_type (&result_type, &element_type);\n+  if (result_type.length != 12)\n+    abort ();\n+  exit (0);\n+}"}]}