{"sha": "d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRlNmZlY2I4ZmEzZjkxYmYzZGZkMWExMTdlMGY4ZTgzNzk0Mzg1Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-21T09:18:28Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-21T09:18:28Z"}, "message": "vec.h: Update API to separate allocation mechanism from type.\n\n\t* vec.h: Update API to separate allocation mechanism from type.\n\t(VEC_safe_grow): New.\n\t* vec.c (calculate_allocation): New.\n\t(vec_gc_o_reserve, vec_heap_o_reserve): Adjust.\n\t(vec_gc_free, vec_heap_free): Remove.\n\t* gengtype-lex.l (DEF_VEC_): Process mult-argument macros.  Adjust.\n\t(VEC): Likewise.\n\t(mangle_macro_name): New.\n\t(struct macro_def): New.\n\t(struct macro): Add multiple argument values.\n\t(macro_expans_end): New.\n\t(push_macro_expansion):  Chain on new macro. Process multiple\n\targs, create follow on expansion. Return follow on argument.\n\t(macro_input): Deal with multiple arguments.\n\n\t* tree.h: Define VEC(tree,heap) and VEC(tree,gc).\n\t(struct tree_binfo): Adjust.\n\t* basic-block.h: Define VEC(edge,gc).\n\t(struct edge_def): Adjust.\n\t(struct basic_block_def, struct edge_iterator): Likewise.\n\t(ei_container, ei_start_1, ei_last_1): Likewise.\n\t* cfg.c (connect_src, connect_dest): Likewise.\n\t* cfgrtl.c (force_nonfallthru_and_redirect)\n\t* dbxout.c (dbxout_type)\n\t* dwarf2out.c (gen_member_die)\n\t* lambda-code.c: Define VEC(int,gc), VEC(lambda_loop,gc).\n\t(gcc_tree_to_linear_expression): Adjust.\n\t(gcc_loop_to_lambda_loop, gcc_loopnest_to_lambda_loopnest,\n\tlbv_to_gcc_expression, lle_to_gcc_expression,\n\tlambda_loopnest_to_gcc_loopnest, can_convert_to_perfect_nest,\n\tperfect_nestify): Likewise.\n\t* lambda.h (gcc_loopnest_to_lambda_loopnest,\n\tlambda_loopnest_to_gcc_loopnest): Adjust prototypes.\n\t* profile.c (instrument_values): Adjust.\n\t* tree-cfg.c (modified_noreturn_calls): Adjust.\n\t(remove_fallthru_edge): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Adjust.\n\t* tree-flow-inline.h (mark_stmt_modified): Adjust.\n\t* tree-flow.h (modified_noreturn_calls): Adjust.\n\t(tree_on_heap): Remove. (yay!)\n\t(register_new_def): Adjust.\n\t* tree-into-ssa.c: Define VEC(int,heap).\n\t(block_defs_stack): Adjust.\n\t(find_idf, insert_phi_nodes, register_new_def,\n\trewrite_initialize_block, rewrite_finalize_block,\n\tregister_new_update_single, rewrite_update_init_block,\n\trewrite_update_fini_block, rewrite_blocks,\n\tssa_rewrite_finalize_block, ssa_register_new_def,\n\tssa_rewrite_initialize_block, rewrite_ssa_into_ssa): Likewise.\n\t* tree-loop-linear.c (linear_transform_loops): Adjust.\n\t* tree-ssa-alias.c: Define VEC(fieldoff_t,heap).\n\t(push_fields_onto_fieldstack, create_overlap_variables_for): Adjust.\n\t* tree-ssa-dom.c (avail_exprs_stack, block_defs_stack,\n\tstmts_to_rescan, const_and_copies_stack, nonzero_vars_stack,\n\tvrp_variables_stack): Adjust declarations.\n\t(tree_ssa_dominator_optimize): Adjust.\n\t(dom_opt_initialize_block, remove_local_expressions_from_table,\n\trestore_nonzero_vars_to_original_value,\n\trestore_vars_to_original_value,\n\trestore_currdefs_to_original_value, dom_opt_finalize_block,\n\trecord_var_is_nonzero, record_cond, record_const_or_copy_1,\n\toptimize_stmt, update_rhs_and_lookup_avail_expr,\n\tlookup_avail_expr, record_range): Likewise.\n\t* tree-ssa-pre.c: Define VEC(basic_block,heap).\n\t(compute_antic_aux): Adjust.\n\t(inserted_exprs, create_expression_by_pieces,\n\tinsert_into_preds_of_block, eliminate, mark_operand_necessary,\n\tremove_dead_inserted_code, fini_pre): Likewise.\n\t* tree-ssa-propagate.c (interesting_ssa_edges): Adjust.\n\t(varying_ssa_edges, add_ssa_edge, process_ssa_edge_worklist.\n\tssa_prop_init): Likewise.\n\t* tree-ssa.c: Define VEC(bitmap,heap).\n\t(verify_name_tags): Adjust.\n\t* value-prof.c (rtl_divmod_values_to_profile): Adjust.\n\t(insn_prefetch_values_to_profile, rtl_find_values_to_profile,\n\ttree_divmod_values_to_profile, tree_find_values_to_profile,\n\tvalue_profile_transformations): Likewise.\n\t* value-prof.h: Define VEC(histogram_value,heap).\n\t* varasm.c: Remove alias_pair pointer typedef, define\n\tVEC(alias_pair,gc).\n\t(finish_aliases_1, finish_aliases_2, assemble_alias): Adjust.\n\n\t* config/pa/pa.c (typedef extern_symbol): Typedef the structure,\n\tnot a pointer to it.  Create an object vector.\n\t(extern_symbols): Turn into an object vector.\n\t(pa_hpux_asm_output_external, pa_hpux_file_end): Adjust.\n\n\t* cp/cp-tree.h: Adjust for new VEC API.\n\tDefine VEC(tree_pair_s,gc).\n\t(struct save_scope): Adjust.\n\t(struct lang_type_class): Adjust.\n\t(unemitted_tinfo_decls): Adjust.\n\t* cp/class.c (add_method, resort_type_method_vec,\n\tfinish_struct_methods, struct find_final_overrider_data,\n\tdfs_find_final_overrider_pre, find_final_overrider,\n\tget_vcall_index, warn_hidden, walk_subobject_offsets,\n\tcheck_methods, fixup_inline_methods, end_of_class,\n\twarn_about_ambiguous_bases, finish_struct, build_vtbl_initializer,\n\tadd_vcall_offset): Adjust.\n\t* cp/decl.c (xref_basetypes, finish_method): Adjust.\n\t* cp/decl2.c (check_classfn): Adjust.\n\t* cp/init.c (sort_mem_initializers, push_base_cleanups): Adjust.\n\t* cp/method.c (do_build_copy_constructor): Adjust.\n\t* cp/name-lookup.c (new_class_binding, store_binding,\n\tstore_bindings, store_class_bindings): Adjust.\n\t* cp/name-lookup.h: Define VEC(cxx_saved_binding,gc),\n\tVEC(cp_class_binding,gc).\n\t(struct cp_binding_level): Adjust.\n\t* cp/parser.c: Define VEC(cp_token_position,heap).\n\t(struct cp_lexer): Adjust.\n\t(cp_lexer_new_main, cp_lexer_new_from_tokens, cp_lexer_destroy,\n\tcp_lexer_save_tokens): Adjust.\n\t* cp/pt.c (retrieve_specialization,\n\tcheck_explicit_specialization): Adjust.\n\t* cp/rtti.c (unemitted_tinfo_decls): Adjust.\n\t(init_rtti_processing, get_tinfo_decl, get_pseudo_ti_init,\n\tget_pseudo_ti_desc): Adjust.\n\t* cp/search.c (dfs_access_in_type, lookup_conversion_operator,\n\tlookup_fnfields_1, dfs_walk_once, dfs_walk_once_accessible,\n\tdfs_get_pure_virtuals, lookup_conversions_r, binfo_for_vbase): Adjust.\n\t* cp/semantics.c: Define VEC(deferred_access,gc).\n\t(push_deferring_access_checks): Adjust.\n\t* cp/typeck2.c (abstract_virtuals_error): Adjust.\n\nFrom-SVN: r98498", "tree": {"sha": "8e91b85f58e03d07731dc2f61c43d3032ebb939b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e91b85f58e03d07731dc2f61c43d3032ebb939b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/comments", "author": null, "committer": null, "parents": [{"sha": "2412d35ca6436f9c36251b46e765759d36f908ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2412d35ca6436f9c36251b46e765759d36f908ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2412d35ca6436f9c36251b46e765759d36f908ab"}], "stats": {"total": 1832, "additions": 1090, "deletions": 742}, "files": [{"sha": "9772f72785afa3c4501dfa96990897c09247a6db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -1,3 +1,92 @@\n+2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.h: Update API to separate allocation mechanism from type.\n+\t(VEC_safe_grow): New.\n+\t* vec.c (calculate_allocation): New.\n+\t(vec_gc_o_reserve, vec_heap_o_reserve): Adjust.\n+\t(vec_gc_free, vec_heap_free): Remove.\n+\t* gengtype-lex.l (DEF_VEC_): Process mult-argument macros.  Adjust.\n+\t(VEC): Likewise.\n+\t(mangle_macro_name): New.\n+\t(struct macro_def): New.\n+\t(struct macro): Add multiple argument values.\n+\t(macro_expans_end): New.\n+\t(push_macro_expansion):  Chain on new macro. Process multiple\n+\targs, create follow on expansion. Return follow on argument.\n+\t(macro_input): Deal with multiple arguments.\n+\t\n+\t* tree.h: Define VEC(tree,heap) and VEC(tree,gc).\n+\t(struct tree_binfo): Adjust.\n+\t* basic-block.h: Define VEC(edge,gc).\n+\t(struct edge_def): Adjust.\n+\t(struct basic_block_def, struct edge_iterator): Likewise.\n+\t(ei_container, ei_start_1, ei_last_1): Likewise.\n+\t* cfg.c (connect_src, connect_dest): Likewise.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect)\n+\t* dbxout.c (dbxout_type)\n+\t* dwarf2out.c (gen_member_die)\n+\t* lambda-code.c: Define VEC(int,gc), VEC(lambda_loop,gc).\n+\t(gcc_tree_to_linear_expression): Adjust.\n+\t(gcc_loop_to_lambda_loop, gcc_loopnest_to_lambda_loopnest,\n+\tlbv_to_gcc_expression, lle_to_gcc_expression,\n+\tlambda_loopnest_to_gcc_loopnest, can_convert_to_perfect_nest,\n+\tperfect_nestify): Likewise.\n+\t* lambda.h (gcc_loopnest_to_lambda_loopnest,\n+\tlambda_loopnest_to_gcc_loopnest): Adjust prototypes.\n+\t* profile.c (instrument_values): Adjust.\n+\t* tree-cfg.c (modified_noreturn_calls): Adjust.\n+\t(remove_fallthru_edge): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Adjust.\n+\t* tree-flow-inline.h (mark_stmt_modified): Adjust.\n+\t* tree-flow.h (modified_noreturn_calls): Adjust.\n+\t(tree_on_heap): Remove. (yay!)\n+\t(register_new_def): Adjust.\n+\t* tree-into-ssa.c: Define VEC(int,heap).\n+\t(block_defs_stack): Adjust.\n+\t(find_idf, insert_phi_nodes, register_new_def,\n+\trewrite_initialize_block, rewrite_finalize_block,\n+\tregister_new_update_single, rewrite_update_init_block,\n+\trewrite_update_fini_block, rewrite_blocks,\n+\tssa_rewrite_finalize_block, ssa_register_new_def,\n+\tssa_rewrite_initialize_block, rewrite_ssa_into_ssa): Likewise.\n+\t* tree-loop-linear.c (linear_transform_loops): Adjust.\n+\t* tree-ssa-alias.c: Define VEC(fieldoff_t,heap).\n+\t(push_fields_onto_fieldstack, create_overlap_variables_for): Adjust.\n+\t* tree-ssa-dom.c (avail_exprs_stack, block_defs_stack,\n+\tstmts_to_rescan, const_and_copies_stack, nonzero_vars_stack,\n+\tvrp_variables_stack): Adjust declarations.\n+\t(tree_ssa_dominator_optimize): Adjust.\n+\t(dom_opt_initialize_block, remove_local_expressions_from_table,\n+\trestore_nonzero_vars_to_original_value,\n+\trestore_vars_to_original_value,\n+\trestore_currdefs_to_original_value, dom_opt_finalize_block,\n+\trecord_var_is_nonzero, record_cond, record_const_or_copy_1,\n+\toptimize_stmt, update_rhs_and_lookup_avail_expr,\n+\tlookup_avail_expr, record_range): Likewise.\n+\t* tree-ssa-pre.c: Define VEC(basic_block,heap).\n+\t(compute_antic_aux): Adjust.\n+\t(inserted_exprs, create_expression_by_pieces, \n+\tinsert_into_preds_of_block, eliminate, mark_operand_necessary, \n+\tremove_dead_inserted_code, fini_pre): Likewise.\n+\t* tree-ssa-propagate.c (interesting_ssa_edges): Adjust.\n+\t(varying_ssa_edges, add_ssa_edge, process_ssa_edge_worklist. \n+\tssa_prop_init): Likewise.\n+\t* tree-ssa.c: Define VEC(bitmap,heap).\n+\t(verify_name_tags): Adjust.\n+\t* value-prof.c (rtl_divmod_values_to_profile): Adjust.\n+\t(insn_prefetch_values_to_profile, rtl_find_values_to_profile,\n+\ttree_divmod_values_to_profile, tree_find_values_to_profile,\n+\tvalue_profile_transformations): Likewise.\n+\t* value-prof.h: Define VEC(histogram_value,heap).\n+\t* varasm.c: Remove alias_pair pointer typedef, define\n+\tVEC(alias_pair,gc).\n+\t(finish_aliases_1, finish_aliases_2, assemble_alias): Adjust.\n+\t\n+\t* config/pa/pa.c (typedef extern_symbol): Typedef the structure,\n+\tnot a pointer to it.  Create an object vector.\n+\t(extern_symbols): Turn into an object vector.\n+\t(pa_hpux_asm_output_external, pa_hpux_file_end): Adjust.\n+\n 2005-04-21  Sebastian Pop  <pop@cri.ensmp.fr>\n \n \tPR/20742"}, {"sha": "6f295136d29365616ab1593418e9edae635b43de", "filename": "gcc/basic-block.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -145,7 +145,8 @@ struct edge_def GTY(())\n };\n \n typedef struct edge_def *edge;\n-DEF_VEC_GC_P(edge);\n+DEF_VEC_P(edge);\n+DEF_VEC_ALLOC_P(edge,gc);\n \n #define EDGE_FALLTHRU\t\t1\t/* 'Straight line' flow */\n #define EDGE_ABNORMAL\t\t2\t/* Strange flow, like computed\n@@ -220,8 +221,8 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   tree stmt_list;\n \n   /* The edges into and out of the block.  */\n-  VEC(edge) *preds;\n-  VEC(edge) *succs;\n+  VEC(edge,gc) *preds;\n+  VEC(edge,gc) *succs;\n \n   /* The registers that are live on entry to this block.  */\n   bitmap GTY ((skip (\"\"))) global_live_at_start;\n@@ -650,10 +651,10 @@ single_pred (basic_block bb)\n \n typedef struct {\n   unsigned index;\n-  VEC(edge) **container;\n+  VEC(edge,gc) **container;\n } edge_iterator;\n \n-static inline VEC(edge) *\n+static inline VEC(edge,gc) *\n ei_container (edge_iterator i)\n {\n   gcc_assert (i.container);\n@@ -665,7 +666,7 @@ ei_container (edge_iterator i)\n \n /* Return an iterator pointing to the start of an edge vector.  */\n static inline edge_iterator\n-ei_start_1 (VEC(edge) **ev)\n+ei_start_1 (VEC(edge,gc) **ev)\n {\n   edge_iterator i;\n \n@@ -678,7 +679,7 @@ ei_start_1 (VEC(edge) **ev)\n /* Return an iterator pointing to the last element of an edge\n    vector.  */\n static inline edge_iterator\n-ei_last_1 (VEC(edge) **ev)\n+ei_last_1 (VEC(edge,gc) **ev)\n {\n   edge_iterator i;\n "}, {"sha": "85d922eae85ed62846aba77d1a70d30e36998895", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -205,7 +205,7 @@ expunge_block (basic_block b)\n static inline void\n connect_src (edge e)\n {\n-  VEC_safe_push (edge, e->src->succs, e);\n+  VEC_safe_push (edge, gc, e->src->succs, e);\n }\n \n /* Connect E to E->dest.  */\n@@ -214,7 +214,7 @@ static inline void\n connect_dest (edge e)\n {\n   basic_block dest = e->dest;\n-  VEC_safe_push (edge, dest->preds, e);\n+  VEC_safe_push (edge, gc, dest->preds, e);\n   e->dest_idx = EDGE_COUNT (dest->preds) - 1;\n }\n "}, {"sha": "f14e44e05a14125b2de6c7da08085ed29e348ad8", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -1065,7 +1065,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t  \n \t  gcc_assert (found);\n \t  \n-\t  VEC_safe_push (edge, bb->succs, e);\n+\t  VEC_safe_push (edge, gc, bb->succs, e);\n \t  make_single_succ_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n \t}\n     }"}, {"sha": "3e92a16b2a8242117fef04fddd7f0122163de870", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -9022,18 +9022,18 @@ pa_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n    at the end of the file if and only if SYMBOL_REF_REFERENCED_P is true.\n    This avoids putting out names that are never really used.  */\n \n-struct extern_symbol GTY(())\n+typedef struct extern_symbol GTY(())\n {\n   tree decl;\n   const char *name;\n-};\n-typedef struct extern_symbol *extern_symbol;\n+} extern_symbol;\n \n /* Define gc'd vector type for extern_symbol.  */\n-DEF_VEC_GC_P(extern_symbol);\n+DEF_VEC_O(extern_symbol);\n+DEF_VEC_ALLOC_O(extern_symbol,gc);\n \n /* Vector of extern_symbol pointers.  */\n-static GTY(()) VEC(extern_symbol) *extern_symbols;\n+static GTY(()) VEC(extern_symbol,gc) *extern_symbols;\n \n #ifdef ASM_OUTPUT_EXTERNAL_REAL\n /* Mark DECL (name NAME) as an external reference (assembler output\n@@ -9043,12 +9043,11 @@ static GTY(()) VEC(extern_symbol) *extern_symbols;\n void\n pa_hpux_asm_output_external (FILE *file, tree decl, const char *name)\n {\n-  extern_symbol p = ggc_alloc (sizeof (struct extern_symbol));\n+  extern_symbol * p = VEC_safe_push (extern_symbol, gc, extern_symbols, NULL);\n \n   gcc_assert (file == asm_out_file);\n   p->decl = decl;\n   p->name = name;\n-  VEC_safe_push (extern_symbol, extern_symbols, p);\n }\n \n /* Output text required at the end of an assembler file.\n@@ -9059,7 +9058,7 @@ static void\n pa_hpux_file_end (void)\n {\n   unsigned int i;\n-  extern_symbol p;\n+  extern_symbol *p;\n \n   output_deferred_plabels ();\n \n@@ -9072,7 +9071,7 @@ pa_hpux_file_end (void)\n \tASM_OUTPUT_EXTERNAL_REAL (asm_out_file, decl, p->name);\n     }\n \n-  extern_symbols = NULL;\n+  VEC_free (extern_symbol, gc, extern_symbols);\n }\n #endif\n "}, {"sha": "7c9747fad735596f4f9a11aca7af6edef9000d26", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -1,3 +1,42 @@\n+2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h: Adjust for new VEC API.\n+\tDefine VEC(tree_pair_s,gc).\n+\t(struct save_scope): Adjust.\n+\t(struct lang_type_class): Adjust.\n+\t(unemitted_tinfo_decls): Adjust.\n+\t* class.c (add_method, resort_type_method_vec,\n+\tfinish_struct_methods, struct find_final_overrider_data,\n+\tdfs_find_final_overrider_pre, find_final_overrider,\n+\tget_vcall_index, warn_hidden, walk_subobject_offsets,\n+\tcheck_methods, fixup_inline_methods, end_of_class,\n+\twarn_about_ambiguous_bases, finish_struct, build_vtbl_initializer,\n+\tadd_vcall_offset): Adjust.\n+\t* decl.c (xref_basetypes, finish_method): Adjust.\n+\t* decl2.c (check_classfn): Adjust.\n+\t* init.c (sort_mem_initializers, push_base_cleanups): Adjust.\n+\t* method.c (do_build_copy_constructor): Adjust.\n+\t* name-lookup.c (new_class_binding, store_binding, \n+\tstore_bindings, store_class_bindings): Adjust.\n+\t* name-lookup.h: Define VEC(cxx_saved_binding,gc),\n+\tVEC(cp_class_binding,gc).\n+\t(struct cp_binding_level): Adjust.\n+\t* parser.c: Define VEC(cp_token_position,heap).\n+\t(struct cp_lexer): Adjust.\n+\t(cp_lexer_new_main, cp_lexer_new_from_tokens, cp_lexer_destroy,\n+\tcp_lexer_save_tokens): Adjust.\n+\t* pt.c (retrieve_specialization,\n+\tcheck_explicit_specialization): Adjust.\n+\t* rtti.c (unemitted_tinfo_decls): Adjust.\n+\t(init_rtti_processing, get_tinfo_decl, get_pseudo_ti_init,\n+\tget_pseudo_ti_desc): Adjust.\n+\t* search.c (dfs_access_in_type, lookup_conversion_operator,\n+\tlookup_fnfields_1, dfs_walk_once, dfs_walk_once_accessible,\n+\tdfs_get_pure_virtuals, lookup_conversions_r, binfo_for_vbase): Adjust.\n+\t* semantics.c: Define VEC(deferred_access,gc).\n+\t(push_deferring_access_checks): Adjust.\n+\t* typeck2.c (abstract_virtuals_error): Adjust.\n+\n 2005-04-20  Ian Lance Taylor  <ian@airs.com>\n \n \t* cp-tree.def: Add STMT_EXPR."}, {"sha": "2f2bd231a5cc573a07877c7dd00686501854811c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -887,7 +887,7 @@ add_method (tree type, tree method)\n   tree overload;\n   bool template_conv_p = false;\n   bool conv_p;\n-  VEC(tree) *method_vec;\n+  VEC(tree,gc) *method_vec;\n   bool complete_p;\n   bool insert_p = false;\n   tree current_fns;\n@@ -909,7 +909,7 @@ add_method (tree type, tree method)\n \t allocate at least two (for constructors and destructors), and\n \t we're going to end up with an assignment operator at some\n \t point as well.  */\n-      method_vec = VEC_alloc (tree, 8);\n+      method_vec = VEC_alloc (tree, gc, 8);\n       /* Create slots for constructors and destructors.  */\n       VEC_quick_push (tree, method_vec, NULL_TREE);\n       VEC_quick_push (tree, method_vec, NULL_TREE);\n@@ -1052,7 +1052,7 @@ add_method (tree type, tree method)\n     {\n       /* We only expect to add few methods in the COMPLETE_P case, so\n \t just make room for one more method in that case.  */\n-      if (VEC_reserve (tree, method_vec, complete_p ? 1 : -1))\n+      if (VEC_reserve (tree, gc, method_vec, complete_p ? -1 : 1))\n \tCLASSTYPE_METHOD_VEC (type) = method_vec;\n       if (slot == VEC_length (tree, method_vec))\n \tVEC_quick_push (tree, method_vec, overload);\n@@ -1663,7 +1663,7 @@ resort_type_method_vec (void* obj,\n                         gt_pointer_operator new_value,\n                         void* cookie)\n {\n-  VEC(tree) *method_vec = (VEC(tree) *) obj;\n+  VEC(tree,gc) *method_vec = (VEC(tree,gc) *) obj;\n   int len = VEC_length (tree, method_vec);\n   size_t slot;\n   tree fn;\n@@ -1695,7 +1695,7 @@ static void\n finish_struct_methods (tree t)\n {\n   tree fn_fields;\n-  VEC(tree) *method_vec;\n+  VEC(tree,gc) *method_vec;\n   int slot, len;\n \n   method_vec = CLASSTYPE_METHOD_VEC (t);\n@@ -1814,7 +1814,7 @@ typedef struct find_final_overrider_data_s {\n   /* The candidate overriders.  */\n   tree candidates;\n   /* Path to most derived.  */\n-  VEC (tree) *path;\n+  VEC(tree,heap) *path;\n } find_final_overrider_data;\n \n /* Add the overrider along the current path to FFOD->CANDIDATES.\n@@ -1873,7 +1873,7 @@ dfs_find_final_overrider_pre (tree binfo, void *data)\n \n   if (binfo == ffod->declaring_base)\n     dfs_find_final_overrider_1 (binfo, ffod, VEC_length (tree, ffod->path));\n-  VEC_safe_push (tree, ffod->path, binfo);\n+  VEC_safe_push (tree, heap, ffod->path, binfo);\n \n   return NULL_TREE;\n }\n@@ -1922,12 +1922,12 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n   ffod.fn = fn;\n   ffod.declaring_base = binfo;\n   ffod.candidates = NULL_TREE;\n-  ffod.path = VEC_alloc (tree, 30);\n+  ffod.path = VEC_alloc (tree, heap, 30);\n \n   dfs_walk_all (derived, dfs_find_final_overrider_pre,\n \t\tdfs_find_final_overrider_post, &ffod);\n \n-  VEC_free (tree, ffod.path);\n+  VEC_free (tree, heap, ffod.path);\n   \n   /* If there was no winner, issue an error message.  */\n   if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n@@ -1946,7 +1946,7 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n static tree\n get_vcall_index (tree fn, tree type)\n {\n-  VEC (tree_pair_s) *indices = CLASSTYPE_VCALL_INDICES (type);\n+  VEC(tree_pair_s,gc) *indices = CLASSTYPE_VCALL_INDICES (type);\n   tree_pair_p p;\n   unsigned ix;\n \n@@ -2350,7 +2350,7 @@ check_for_override (tree decl, tree ctype)\n void\n warn_hidden (tree t)\n {\n-  VEC(tree) *method_vec = CLASSTYPE_METHOD_VEC (t);\n+  VEC(tree,gc) *method_vec = CLASSTYPE_METHOD_VEC (t);\n   tree fns;\n   size_t i;\n \n@@ -3200,7 +3200,7 @@ walk_subobject_offsets (tree type,\n       if (abi_version_at_least (2) && CLASSTYPE_VBASECLASSES (type))\n \t{\n \t  unsigned ix;\n-\t  VEC (tree) *vbases;\n+\t  VEC(tree,gc) *vbases;\n \n \t  /* Iterate through the virtual base classes of TYPE.  In G++\n \t     3.2, we included virtual bases in the direct base class\n@@ -3678,7 +3678,7 @@ check_methods (tree t)\n \t{\n \t  TYPE_POLYMORPHIC_P (t) = 1;\n \t  if (DECL_PURE_VIRTUAL_P (x))\n-\t    VEC_safe_push (tree, CLASSTYPE_PURE_VIRTUALS (t), x);\n+\t    VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (t), x);\n \t}\n       /* All user-declared destructors are non-trivial.  */\n       if (DECL_DESTRUCTOR_P (x))\n@@ -4202,7 +4202,7 @@ static void\n fixup_inline_methods (tree type)\n {\n   tree method = TYPE_METHODS (type);\n-  VEC (tree) *friends;\n+  VEC(tree,gc) *friends;\n   unsigned ix;\n \n   if (method && TREE_CODE (method) == TREE_VEC)\n@@ -4370,7 +4370,7 @@ static tree\n end_of_class (tree t, int include_virtuals_p)\n {\n   tree result = size_zero_node;\n-  VEC (tree) *vbases;\n+  VEC(tree,gc) *vbases;\n   tree binfo;\n   tree base_binfo;\n   tree offset;\n@@ -4417,7 +4417,7 @@ static void\n warn_about_ambiguous_bases (tree t)\n {\n   int i;\n-  VEC (tree) *vbases;\n+  VEC(tree,gc) *vbases;\n   tree basetype;\n   tree binfo;\n   tree base_binfo;\n@@ -5129,7 +5129,7 @@ finish_struct (tree t, tree attributes)\n       CLASSTYPE_PURE_VIRTUALS (t) = NULL;\n       for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n \tif (DECL_PURE_VIRTUAL_P (x))\n-\t  VEC_safe_push (tree, CLASSTYPE_PURE_VIRTUALS (t), x);\n+\t  VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (t), x);\n       complete_vars (t);\n     }\n   else\n@@ -7130,7 +7130,7 @@ build_vtbl_initializer (tree binfo,\n   vtbl_init_data vid;\n   unsigned ix;\n   tree vbinfo;\n-  VEC (tree) *vbases;\n+  VEC(tree,gc) *vbases;\n   \n   /* Initialize VID.  */\n   memset (&vid, 0, sizeof (vid));\n@@ -7598,7 +7598,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n      offset.  */\n   if (vid->binfo == TYPE_BINFO (vid->derived))\n     {\n-      tree_pair_p elt = VEC_safe_push (tree_pair_s,\n+      tree_pair_p elt = VEC_safe_push (tree_pair_s, gc,\n \t\t\t\t       CLASSTYPE_VCALL_INDICES (vid->derived),\n \t\t\t\t       NULL);\n       elt->purpose = orig_fn;"}, {"sha": "e7bf1106a83344069343b1a77b77f4f9de413126", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -656,7 +656,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n struct saved_scope GTY(())\n {\n-  VEC(cxx_saved_binding) *old_bindings;\n+  VEC(cxx_saved_binding,gc) *old_bindings;\n   tree old_namespace;\n   tree decl_ns_list;\n   tree class_name;\n@@ -972,7 +972,8 @@ typedef struct tree_pair_s GTY (())\n   tree value;\n } tree_pair_s;\n typedef tree_pair_s *tree_pair_p;\n-DEF_VEC_GC_O (tree_pair_s);\n+DEF_VEC_O (tree_pair_s);\n+DEF_VEC_ALLOC_O (tree_pair_s,gc);\n \n /* This is a few header flags for 'struct lang_type'.  Actually,\n    all but the first are used only for lang_type_class; they\n@@ -1059,15 +1060,15 @@ struct lang_type_class GTY(())\n   unsigned dummy : 12;\n \n   tree primary_base;\n-  VEC (tree_pair_s) *vcall_indices;\n+  VEC(tree_pair_s,gc) *vcall_indices;\n   tree vtables;\n   tree typeinfo_var;\n-  VEC (tree) *vbases;\n+  VEC(tree,gc) *vbases;\n   binding_table nested_udts;\n   tree as_base;\n-  VEC (tree) *pure_virtuals;\n+  VEC(tree,gc) *pure_virtuals;\n   tree friend_classes;\n-  VEC (tree) * GTY((reorder (\"resort_type_method_vec\"))) methods;\n+  VEC(tree,gc) * GTY((reorder (\"resort_type_method_vec\"))) methods;\n   tree key_method;\n   tree decl_list;\n   tree template_info;\n@@ -4022,7 +4023,7 @@ extern void finish_repo (void);\n \n /* in rtti.c */\n /* A vector of all tinfo decls that haven't been emitted yet.  */\n-extern GTY(()) VEC(tree) *unemitted_tinfo_decls;\n+extern GTY(()) VEC(tree,gc) *unemitted_tinfo_decls;\n \n extern void init_rtti_processing (void);\n extern tree build_typeid (tree);"}, {"sha": "2a3c30cd71d5106c2158e44eba31ec35372b7b2c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -9340,7 +9340,7 @@ xref_basetypes (tree ref, tree base_list)\n \n   if (max_bases)\n     {\n-      BINFO_BASE_ACCESSES (binfo) = VEC_alloc (tree, max_bases);\n+      BINFO_BASE_ACCESSES (binfo) = VEC_alloc (tree, gc, max_bases);\n       /* An aggregate cannot have baseclasses.  */\n       CLASSTYPE_NON_AGGREGATE (ref) = 1;\n \n@@ -9356,7 +9356,7 @@ xref_basetypes (tree ref, tree base_list)\n \n   if (max_vbases)\n     {\n-      CLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, max_vbases);\n+      CLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, gc, max_vbases);\n \n       if (TYPE_FOR_JAVA (ref))\n \terror (\"Java class %qT cannot have virtual bases\", ref);\n@@ -10866,7 +10866,7 @@ finish_method (tree decl)\n      for String.cc in libg++.  */\n   if (DECL_FRIEND_P (fndecl))\n     {\n-      VEC_safe_push (tree, CLASSTYPE_INLINE_FRIENDS (current_class_type),\n+      VEC_safe_push (tree, gc, CLASSTYPE_INLINE_FRIENDS (current_class_type),\n \t\t     fndecl);\n       decl = void_type_node;\n     }"}, {"sha": "6cc68e249fecc51102aa383c1741c549cbf05e7c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -622,7 +622,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   ix = class_method_index_for_fn (complete_type (ctype), function);\n   if (ix >= 0)\n     {\n-      VEC(tree) *methods = CLASSTYPE_METHOD_VEC (ctype);\n+      VEC(tree,gc) *methods = CLASSTYPE_METHOD_VEC (ctype);\n       tree fndecls, fndecl = 0;\n       bool is_conv_op;\n       tree pushed_scope;"}, {"sha": "0abf1b2587440f6c74d007020630d833495367c1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -465,7 +465,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n   tree base, binfo, base_binfo;\n   tree sorted_inits;\n   tree next_subobject;\n-  VEC (tree) *vbases;\n+  VEC(tree,gc) *vbases;\n   int i;\n   int uses_unions_p;\n \n@@ -2867,7 +2867,7 @@ push_base_cleanups (void)\n   int i;\n   tree member;\n   tree expr;\n-  VEC (tree) *vbases;\n+  VEC(tree,gc) *vbases;\n \n   /* Run destructors for all virtual baseclasses.  */\n   if (CLASSTYPE_VBASECLASSES (current_class_type))"}, {"sha": "7e4e95663801feae3d9a3c1a296aa6e7744ca90f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -537,7 +537,7 @@ do_build_copy_constructor (tree fndecl)\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n       tree binfo, base_binfo;\n-      VEC (tree) *vbases;\n+      VEC(tree,gc) *vbases;\n \n       /* Initialize all the base-classes with the parameter converted\n \t to their type so that we get their copy constructor and not"}, {"sha": "d2cf1ce3ca022f937f7a752d1a16a10f6bc98104", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -306,7 +306,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n     {\n       cp_class_binding *old_base;\n       old_base = VEC_index (cp_class_binding, scope->class_shadowed, 0);\n-      if (VEC_reserve (cp_class_binding, scope->class_shadowed, -1))\n+      if (VEC_reserve (cp_class_binding, gc, scope->class_shadowed, 1))\n \t{\n \t  /* Fixup the current bindings, as they might have moved.  */\n \t  size_t i;\n@@ -325,7 +325,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n       cb = VEC_quick_push (cp_class_binding, scope->class_shadowed, NULL);\n     }\n   else\n-    cb = VEC_safe_push (cp_class_binding, scope->class_shadowed, NULL);\n+    cb = VEC_safe_push (cp_class_binding, gc, scope->class_shadowed, NULL);\n   \n   cb->identifier = name;\n   binding = &cb->base;\n@@ -4741,7 +4741,7 @@ struct saved_scope *scope_chain;\n    *OLD_BINDINGS.  */\n \n static void\n-store_binding (tree id, VEC(cxx_saved_binding) **old_bindings)\n+store_binding (tree id, VEC(cxx_saved_binding,gc) **old_bindings)\n {\n   cxx_saved_binding *saved;\n \n@@ -4753,15 +4753,15 @@ store_binding (tree id, VEC(cxx_saved_binding) **old_bindings)\n   \n   IDENTIFIER_MARKED (id) = 1;\n \n-  saved = VEC_safe_push (cxx_saved_binding, *old_bindings, NULL);\n+  saved = VEC_safe_push (cxx_saved_binding, gc, *old_bindings, NULL);\n   saved->identifier = id;\n   saved->binding = IDENTIFIER_BINDING (id);\n   saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n   IDENTIFIER_BINDING (id) = NULL;\n }\n \n static void\n-store_bindings (tree names, VEC(cxx_saved_binding) **old_bindings)\n+store_bindings (tree names, VEC(cxx_saved_binding,gc) **old_bindings)\n {\n   tree t;\n \n@@ -4784,8 +4784,8 @@ store_bindings (tree names, VEC(cxx_saved_binding) **old_bindings)\n    objects, rather than a TREE_LIST.  */\n \n static void\n-store_class_bindings (VEC(cp_class_binding) *names, \n-\t\t      VEC(cxx_saved_binding) **old_bindings)\n+store_class_bindings (VEC(cp_class_binding,gc) *names, \n+\t\t      VEC(cxx_saved_binding,gc) **old_bindings)\n {\n   size_t i;\n   cp_class_binding *cb;"}, {"sha": "5aeb80b7338e583ee8d21bbfcfde12814702eb90", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -89,7 +89,8 @@ typedef struct cxx_saved_binding GTY(())\n   tree real_type_value;\n } cxx_saved_binding;\n \n-DEF_VEC_GC_O(cxx_saved_binding);\n+DEF_VEC_O(cxx_saved_binding);\n+DEF_VEC_ALLOC_O(cxx_saved_binding,gc);\n \n extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n@@ -145,7 +146,8 @@ typedef struct cp_class_binding GTY(())\n   tree identifier;\n } cp_class_binding;\n \n-DEF_VEC_GC_O(cp_class_binding);\n+DEF_VEC_O(cp_class_binding);\n+DEF_VEC_ALLOC_O(cp_class_binding,gc);\n \n /* For each binding contour we allocate a binding_level structure\n    which records the names defined in that contour.\n@@ -200,7 +202,7 @@ struct cp_binding_level GTY(())\n \n     /* For the binding level corresponding to a class, the entities\n        declared in the class or its base classes.  */\n-    VEC(cp_class_binding) *class_shadowed;\n+    VEC(cp_class_binding,gc) *class_shadowed;\n \n     /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n        is used for all binding levels. The TREE_PURPOSE is the name of"}, {"sha": "cb09fa1995f8157e6605f2ec4d1a171a182abb2a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -66,7 +66,8 @@ typedef struct cp_token GTY (())\n \n /* We use a stack of token pointer for saving token sets.  */\n typedef struct cp_token *cp_token_position;\n-DEF_VEC_MALLOC_P (cp_token_position);\n+DEF_VEC_P (cp_token_position);\n+DEF_VEC_ALLOC_P (cp_token_position,heap);\n \n static const cp_token eof_token =\n {\n@@ -104,7 +105,7 @@ typedef struct cp_lexer GTY (())\n      called.  The top entry is the most recent position at which we\n      began saving tokens.  If the stack is non-empty, we are saving\n      tokens.  */\n-  VEC (cp_token_position) *GTY ((skip)) saved_tokens;\n+  VEC(cp_token_position,heap) *GTY ((skip)) saved_tokens;\n \n   /* True if we should output debugging information.  */\n   bool debugging_p;\n@@ -260,7 +261,8 @@ cp_lexer_new_main (void)\n   /* Initially we are not debugging.  */\n   lexer->debugging_p = false;\n #endif /* ENABLE_CHECKING */\n-  lexer->saved_tokens = VEC_alloc (cp_token_position, CP_SAVED_TOKEN_STACK);\n+  lexer->saved_tokens = VEC_alloc (cp_token_position, heap,\n+\t\t\t\t   CP_SAVED_TOKEN_STACK);\n \t \n   /* Create the buffer.  */\n   alloc = CP_LEXER_BUFFER_SIZE;\n@@ -314,7 +316,8 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n   lexer->next_token = first == last ? (cp_token *)&eof_token : first;\n   lexer->last_token = last;\n   \n-  lexer->saved_tokens = VEC_alloc (cp_token_position, CP_SAVED_TOKEN_STACK);\n+  lexer->saved_tokens = VEC_alloc (cp_token_position, heap,\n+\t\t\t\t   CP_SAVED_TOKEN_STACK);\n \n #ifdef ENABLE_CHECKING\n   /* Initially we are not debugging.  */\n@@ -332,7 +335,7 @@ cp_lexer_destroy (cp_lexer *lexer)\n {\n   if (lexer->buffer)\n     ggc_free (lexer->buffer);\n-  VEC_free (cp_token_position, lexer->saved_tokens);\n+  VEC_free (cp_token_position, heap, lexer->saved_tokens);\n   ggc_free (lexer);\n }\n \n@@ -621,7 +624,8 @@ cp_lexer_save_tokens (cp_lexer* lexer)\n   if (cp_lexer_debugging_p (lexer))\n     fprintf (cp_lexer_debug_stream, \"cp_lexer: saving tokens\\n\");\n \n-  VEC_safe_push (cp_token_position, lexer->saved_tokens, lexer->next_token);\n+  VEC_safe_push (cp_token_position, heap,\n+\t\t lexer->saved_tokens, lexer->next_token);\n }\n \n /* Commit to the portion of the token stream most recently saved.  */"}, {"sha": "aaecabcbc456d322bd953b9307de67b048eeac5f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -822,7 +822,7 @@ retrieve_specialization (tree tmpl, tree args,\n     {\n       tree class_template;\n       tree class_specialization;\n-      VEC(tree) *methods;\n+      VEC(tree,gc) *methods;\n       tree fns;\n       int idx;\n \n@@ -1967,7 +1967,7 @@ check_explicit_specialization (tree declarator,\n \t    }\n \t  else\n \t    {\n-\t      VEC(tree) *methods;\n+\t      VEC(tree,gc) *methods;\n \t      tree ovl;\n \n \t      /* For a type-conversion operator, we cannot do a"}, {"sha": "9368bfee998ac6fd351cb875b5820662089ea981", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -75,7 +75,7 @@ Boston, MA 02111-1307, USA.  */\n #define TINFO_REAL_NAME(NODE) TREE_PURPOSE (NODE)\n \n /* A vector of all tinfo decls that haven't yet been emitted.  */\n-VEC (tree) *unemitted_tinfo_decls;\n+VEC(tree,gc) *unemitted_tinfo_decls;\n \n static tree build_headof (tree);\n static tree ifnonnull (tree, tree);\n@@ -119,7 +119,7 @@ init_rtti_processing (void)\n     = build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n   type_info_ptr_type = build_pointer_type (const_type_info_type_node);\n \n-  unemitted_tinfo_decls = VEC_alloc (tree, 124);\n+  unemitted_tinfo_decls = VEC_alloc (tree, gc, 124);\n   \n   create_tinfo_types ();\n }\n@@ -364,7 +364,7 @@ get_tinfo_decl (tree type)\n       pushdecl_top_level_and_finish (d, NULL_TREE);\n \n       /* Add decl to the global array of tinfo decls.  */\n-      VEC_safe_push (tree, unemitted_tinfo_decls, d);\n+      VEC_safe_push (tree, gc, unemitted_tinfo_decls, d);\n     }\n \n   return d;\n@@ -1003,7 +1003,7 @@ get_pseudo_ti_init (tree type, tree var_desc)\n \t\t      | (CLASSTYPE_DIAMOND_SHAPED_P (type) << 1));\n \t  tree binfo = TYPE_BINFO (type);\n           int nbases = BINFO_N_BASE_BINFOS (binfo);\n-\t  VEC (tree) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n+\t  VEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n           tree base_inits = NULL_TREE;\n           int ix;\n           \n@@ -1152,7 +1152,7 @@ get_pseudo_ti_desc (tree type)\n       else\n \t{\n \t  tree binfo = TYPE_BINFO (type);\n-\t  VEC (tree) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n+\t  VEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n \t  tree base_binfo = BINFO_BASE_BINFO (binfo, 0);\n \t  int num_bases = BINFO_N_BASE_BINFOS (binfo);\n \t  "}, {"sha": "45668a14a94a99acc947fb6b8ed6b8fb885eaa9f", "filename": "gcc/cp/search.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -641,7 +641,7 @@ dfs_access_in_type (tree binfo, void *data)\n \t{\n \t  int i;\n \t  tree base_binfo;\n-\t  VEC (tree) *accesses;\n+\t  VEC(tree,gc) *accesses;\n \t  \n \t  /* Otherwise, scan our baseclasses, and pick the most favorable\n \t     access.  */\n@@ -1314,7 +1314,7 @@ lookup_conversion_operator (tree class_type, tree type)\n     {\n       int i;\n       tree fn;\n-      VEC(tree) *methods = CLASSTYPE_METHOD_VEC (class_type);\n+      VEC(tree,gc) *methods = CLASSTYPE_METHOD_VEC (class_type);\n       \n       for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n \t   VEC_iterate (tree, methods, i, fn); ++i)\n@@ -1345,7 +1345,7 @@ lookup_conversion_operator (tree class_type, tree type)\n int\n lookup_fnfields_1 (tree type, tree name)\n {\n-  VEC(tree) *method_vec;\n+  VEC(tree,gc) *method_vec;\n   tree fn;\n   tree tmp;\n   size_t i;\n@@ -1658,7 +1658,7 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n \t  /* We are at the top of the hierarchy, and can use the\n              CLASSTYPE_VBASECLASSES list for unmarking the virtual\n              bases.  */\n-\t  VEC (tree) *vbases;\n+\t  VEC(tree,gc) *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n \t  \n@@ -1766,7 +1766,7 @@ dfs_walk_once_accessible (tree binfo, bool friends_p,\n \t  /* We are at the top of the hierarchy, and can use the\n              CLASSTYPE_VBASECLASSES list for unmarking the virtual\n              bases.  */\n-\t  VEC (tree) *vbases;\n+\t  VEC(tree,gc) *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n \t  \n@@ -2000,7 +2000,7 @@ dfs_get_pure_virtuals (tree binfo, void *data)\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n \tif (DECL_PURE_VIRTUAL_P (BV_FN (virtuals)))\n-\t  VEC_safe_push (tree, CLASSTYPE_PURE_VIRTUALS (type),\n+\t  VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (type),\n \t\t\t BV_FN (virtuals));\n     }\n \n@@ -2270,7 +2270,7 @@ lookup_conversions_r (tree binfo,\n   tree child_tpl_convs = NULL_TREE;\n   unsigned i;\n   tree base_binfo;\n-  VEC(tree) *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+  VEC(tree,gc) *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n   tree conv;\n \n   /* If we have no conversion operators, then don't look.  */\n@@ -2523,7 +2523,7 @@ binfo_for_vbase (tree base, tree t)\n {\n   unsigned ix;\n   tree binfo;\n-  VEC (tree) *vbases;\n+  VEC(tree,gc) *vbases;\n   \n   for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n        VEC_iterate (tree, vbases, ix, binfo); ix++)"}, {"sha": "20e94223b364bbc1e282c4b334b0559ac6b8b02d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -139,10 +139,11 @@ typedef struct deferred_access GTY(())\n   enum deferring_kind deferring_access_checks_kind;\n   \n } deferred_access;\n-DEF_VEC_GC_O (deferred_access);\n+DEF_VEC_O (deferred_access);\n+DEF_VEC_ALLOC_O (deferred_access,gc);\n \n /* Data for deferred access checking.  */\n-static GTY(()) VEC (deferred_access) *deferred_access_stack;\n+static GTY(()) VEC(deferred_access,gc) *deferred_access_stack;\n static GTY(()) unsigned deferred_access_no_check;\n \n /* Save the current deferred access states and start deferred\n@@ -159,7 +160,7 @@ push_deferring_access_checks (deferring_kind deferring)\n     {\n       deferred_access *ptr;\n \n-      ptr = VEC_safe_push (deferred_access, deferred_access_stack, NULL);\n+      ptr = VEC_safe_push (deferred_access, gc, deferred_access_stack, NULL);\n       ptr->deferred_access_checks = NULL_TREE;\n       ptr->deferring_access_checks_kind = deferring;\n     }"}, {"sha": "81e34d76dbeddc7b86a6e2f787b8f03273e66594", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -235,7 +235,7 @@ complete_type_check_abstract (tree type)\n int\n abstract_virtuals_error (tree decl, tree type)\n {\n-  VEC (tree) *pure;\n+  VEC(tree,gc) *pure;\n   \n   /* This function applies only to classes. Any other entity can never\n      be abstract.  */"}, {"sha": "4cbe16b603faf7c43dae548224c1e3dbe7b1a2d6", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -2063,7 +2063,7 @@ dbxout_type (tree type, int full)\n \t  {\n \t    int i;\n \t    tree child;\n-\t    VEC (tree) *accesses = BINFO_BASE_ACCESSES (binfo);\n+\t    VEC(tree,gc) *accesses = BINFO_BASE_ACCESSES (binfo);\n \t    \n \t    if (use_gnu_debug_info_extensions)\n \t      {"}, {"sha": "1c5ce45cabb07a76f7b2fc1d3ba2eb8e5f52e0cb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -12004,7 +12004,7 @@ gen_member_die (tree type, dw_die_ref context_die)\n   /* First output info about the base classes.  */\n   if (binfo)\n     {\n-      VEC (tree) *accesses = BINFO_BASE_ACCESSES (binfo);\n+      VEC(tree,gc) *accesses = BINFO_BASE_ACCESSES (binfo);\n       int i;\n       tree base;\n "}, {"sha": "f844a5eef1008fb4102f594b9c068cfcd2aa3c29", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 136, "deletions": 45, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -33,8 +33,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define YY_INPUT(BUF,RESULT,SIZE) ((RESULT) = macro_input (BUF,SIZE))\n \n static unsigned macro_input (char *buffer, unsigned);\n-static void push_macro_expansion (const char *, unsigned,\n-\t\t\t\t  const char *, unsigned);\n+static const char *push_macro_expansion (const char *, unsigned,\n+\t\t\t\t\t const char *, unsigned);\n+static char *mangle_macro_name (const char *, unsigned,\n+       \t\t\t        const char *, unsigned);\n static void update_lineno (const char *l, size_t len);\n \n struct fileloc lexer_line;\n@@ -237,33 +239,40 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   return ENT_YACCUNION;\n }\n \n-^\"DEF_VEC_\"[[:alnum:]_]*{WS}?\"(\"{WS}?{ID}{WS}?\")\" {\n+^\"DEF_VEC_\"[[:alnum:]_]*{WS}?\"(\"{WS}?{ID}{WS}?(\",\"{WS}?{ID}{WS}?)*\")\" {\n   char *macro, *arg;\n   unsigned macro_len, arg_len;\n   char *ptr = yytext;\n+  const char *additional;\n   type_p t;\n \n-  /* Locate the macro and argument strings.  */\n-  macro = ptr;\n-  while (*ptr != '(' && !ISSPACE (*ptr))\n-    ptr++;\n-  macro_len = ptr - macro;\n-  while (*ptr == '(' || ISSPACE (*ptr))\n-    ptr++;\n-  arg = ptr;\n-  while (*ptr != ')' && !ISSPACE (*ptr))\n-    ptr++;\n-  arg_len = ptr - arg;\n+  /* Find the macro name.  */\n+  for (macro = ptr; *ptr != '(' && !ISSPACE (*ptr); ptr++)\n+    continue;\n+  for (macro_len = ptr - macro; !(ISALNUM (*ptr) || *ptr == '_'); ptr++)\n+    continue;\n \n-  /* Push the macro for later expansion.  */\n-  push_macro_expansion (macro, macro_len, arg, arg_len);\n+  /* Find the argument(s).  */\n+  for (arg = ptr; *ptr != ')'; ptr++)\n+    continue;\n+  arg_len = ptr - arg;\n \n   /* Create the struct and typedef.  */\n-  ptr = (char *) xmemdup (\"VEC_\", 4, 4 + arg_len + 1);\n-  memcpy (&ptr[4], arg, arg_len);\n-  ptr[4 + arg_len] = 0;\n+  ptr = mangle_macro_name (\"VEC\", 3, arg, arg_len);\n+\n   t = find_structure (ptr, 0);\n   do_typedef (ptr, t, &lexer_line);\n+\n+  /* Push the macro for later expansion.  */\n+  additional = push_macro_expansion (macro, macro_len, arg, arg_len);\n+\n+  if (additional)\n+    {\n+      ptr = mangle_macro_name (ptr, strlen (ptr),\n+\t\t\t       additional, strlen (additional));\n+      t = find_structure (ptr, 0);\n+      do_typedef (ptr, t, &lexer_line);\n+    }\n }\n \n <in_struct>{\n@@ -299,24 +308,23 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   return SCALAR;\n }\n \n-\"VEC\"{WS}?\"(\"{WS}?{ID}{WS}?\")\" {\n+\"VEC\"{WS}?\"(\"{WS}?{ID}{WS}?(\",\"{WS}?{ID}{WS}?)*\")\" {\n   char *macro, *arg;\n   unsigned macro_len, arg_len;\n   char *ptr = yytext;\n \n-  macro = ptr;\n-  while (*ptr != '(' && !ISSPACE (*ptr)) /* )*/\n-    ptr++;\n-  macro_len = ptr - macro;\n-  while (*ptr == '(' || ISSPACE (*ptr))\n-    ptr++;\n-  arg = ptr;\n-  while (*ptr != ')' && !ISSPACE (*ptr))\n-    ptr++;\n+  /* Find the macro name */\n+  for (macro = ptr; *ptr != '(' && !ISSPACE (*ptr); ptr++)\n+    continue;\n+  for (macro_len = ptr - macro; !(ISALNUM(*ptr) || *ptr == '_'); ptr++)\n+    continue;\n+\n+  /* Find the arguments.  */\n+  for (arg = ptr; *ptr != ')'; ptr++)\n+    continue;\n   arg_len = ptr - arg;\n-  ptr = (char *) xmemdup (macro, macro_len, macro_len + arg_len + 2);\n-  ptr[macro_len] = '_';\n-  memcpy (&ptr[macro_len+1], arg, arg_len);\n+\n+  ptr = mangle_macro_name (macro, macro_len, arg, arg_len);\n   yylval.s = ptr;\n   return ID;\n }\n@@ -411,14 +419,43 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n \n /* Deal with the expansion caused by the DEF_VEC_x macros.  */\n \n-typedef struct macro\n+/* Mangle a macro and argument list as done by cpp concatenation in\n+   the compiler proper.  */\n+static char *\n+mangle_macro_name (const char *macro, unsigned macro_len,\n+\t\t   const char *arg, unsigned arg_len)\n+{\n+  char *ptr = (char *) xmemdup (macro, macro_len, macro_len + arg_len + 2);\n+\n+  /* Now copy and concatenate each argument */\n+  while (arg_len)\n+    {\n+      ptr[macro_len++] = '_';\n+      for (; arg_len && (ISALNUM(*arg) || *arg == '_'); arg_len--)\n+        ptr[macro_len++] = *arg++;\n+      for (; arg_len && !(ISALNUM(*arg) || *arg == '_'); arg_len--)\n+        arg++;\n+    }\n+  ptr[macro_len] = 0;\n+\n+  return ptr;\n+}\n+\n+typedef struct macro_def\n {\n   const char *name;\n   const char *expansion;\n+  const char *additional;\n+} macro_def_t;\n+\n+typedef struct macro\n+{\n+  const macro_def_t *def;\n   struct macro *next;\n+  const char *args[10];\n } macro_t;\n \n-static const macro_t macro_defs[] = \n+static const macro_def_t macro_defs[] = \n {\n #define IN_GENGTYPE 1\n #include \"vec.h\"\n@@ -427,11 +464,12 @@ static const macro_t macro_defs[] =\n \n /* Chain of macro expansions to do at end of scanning.  */\n static macro_t *macro_expns;\n+static macro_t *macro_expns_end;\n \n /* Push macro NAME (NAME_LEN) with argument ARG (ARG_LEN) onto the\n    expansion queue.  We ensure NAME is known at this point.  */\n \n-static void\n+static const char *\n push_macro_expansion (const char *name, unsigned name_len,\n \t\t      const char *arg, unsigned arg_len)\n {\n@@ -442,15 +480,51 @@ push_macro_expansion (const char *name, unsigned name_len,\n         && !memcmp (name, macro_defs[ix].name, name_len))\n       {\n         macro_t *expansion = XNEW (macro_t);\n-\n-\texpansion->next = macro_expns;\n-\texpansion->name = (char *) xmemdup (arg, arg_len, arg_len+1);\n-\texpansion->expansion = macro_defs[ix].expansion;\n-\tmacro_expns = expansion;\n-\treturn;\n+        char *args;\n+\tunsigned argno, last_arg;\n+\n+\texpansion->def = &macro_defs[ix];\n+\texpansion->next = NULL;\n+\targs = (char *) xmemdup (arg, arg_len, arg_len+1);\n+\targs[arg_len] = 0;\n+        for (argno = 0; *args;)\n+\t  {\n+   \t    expansion->args[argno++] = args;\n+\t    while (*args && (ISALNUM (*args) || *args == '_'))\n+\t      args++;\n+\t    if (argno == 1)\n+\t      expansion->args[argno++] = \"base\";\n+\t    if (!*args)\n+\t      break;\n+\t    *args++ = 0;\n+\t    while (*args && !(ISALNUM (*args) || *args == '_'))\n+\t      args++;\n+          }\n+\tlast_arg = argno;\n+        for (; argno != 10; argno++)\n+\t  expansion->args[argno] = NULL;\n+\tif (macro_expns_end)\n+          macro_expns_end->next = expansion;\n+\telse\n+\t  macro_expns = expansion;\n+\tmacro_expns_end = expansion;\n+\tif (macro_defs[ix].additional)\n+\t  {\n+\t    macro_t *expn2 = XNEW (macro_t);\n+            memcpy (expn2, expansion, sizeof (*expn2));\n+\t    expansion = expn2;\n+\t    expansion->def += 1;\n+\t    expansion->args[last_arg++] = macro_defs[ix].additional;\n+\t    macro_expns_end->next = expansion;\n+\t    macro_expns_end = expansion;\n+\t  }\n+        if (last_arg > 2 && strcmp (expansion->args[last_arg - 1], \"heap\"))\n+\t  expansion->args[last_arg++] = \"GTY (())\";\n+\treturn macro_defs[ix].additional;\n       }\n   error_at_line (&lexer_line, \"unrecognized macro `%.*s(%.*s)'\",\n \t\t name_len, name, arg_len, arg);\n+  return NULL;\n }\n \n /* Attempt to read some input.  Use fread until we're at the end of\n@@ -472,15 +546,30 @@ macro_input (char *buffer, unsigned size)\n       const char *expn;\n       unsigned len;\n \n-      for (expn = macro_expns->expansion; *expn; expn++)\n+      for (expn = macro_expns->def->expansion; *expn; expn++)\n         {\n \t  if (*expn == '#')\n \t    {\n+\t      int argno;\n+\n+\t      argno = expn[1] - '0';\n+\t      expn += 1;\n+\n+\t      /* Remove inserted space? */\n \t      if (buffer[result-1] == ' ' && buffer[result-2] == '_')\n \t        result--;\n-\t      len = strlen (macro_expns->name);\n-\t      memcpy (&buffer[result], macro_expns->name, len);\n-\t      result += len;\n+\n+\t      /* Insert the argument value */\n+\t      if (macro_expns->args[argno])\n+\t        {\n+\t\t  len = strlen (macro_expns->args[argno]);\n+\t\t  memcpy (&buffer[result], macro_expns->args[argno], len);\n+\t\t  result += len;\n+\t\t}\n+\n+\t      /* Skip next space? */\n+\t      if (expn[1] == ' ' && expn[2] == '_')\n+\t        expn++;\n \t    }\n \t  else\n \t    {\n@@ -492,6 +581,8 @@ macro_input (char *buffer, unsigned size)\n       if (result > size)\n         YY_FATAL_ERROR (\"buffer too small to expand macro\");\n       macro_expns = macro_expns->next;\n+      if (!macro_expns)\n+        macro_expns_end = NULL;\n     }\n   return result;\n }"}, {"sha": "da24e95255e80d768d39abfdd96d92cf814c2a8a", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -115,12 +115,16 @@\n  Fourier-Motzkin elimination is used to compute the bounds of the base space\n  of the lattice.  */\n \n+/* FIXME: I'm sure the vectors used here could be heap allocated.\n+   There certainly should be explicit VEC_frees, either way.  (nathan\n+   2005/04/14) */\n \n-DEF_VEC_GC_P(int);\n+DEF_VEC_P(int);\n+DEF_VEC_ALLOC_P(int,gc);\n \n static bool perfect_nestify (struct loops *, \n-\t\t\t     struct loop *, VEC (tree) *, \n-\t\t\t     VEC (tree) *, VEC (int) *, VEC (tree) *);\n+\t\t\t     struct loop *, VEC(tree,gc) *, \n+\t\t\t     VEC(tree,gc) *, VEC(int,gc) *, VEC(tree,gc) *);\n /* Lattice stuff that is internal to the code generation algorithm.  */\n \n typedef struct\n@@ -1152,8 +1156,8 @@ lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans)\n \n static lambda_linear_expression\n gcc_tree_to_linear_expression (int depth, tree expr,\n-\t\t\t       VEC(tree) *outerinductionvars,\n-\t\t\t       VEC(tree) *invariants, int extra)\n+\t\t\t       VEC(tree,gc) *outerinductionvars,\n+\t\t\t       VEC(tree,gc) *invariants, int extra)\n {\n   lambda_linear_expression lle = NULL;\n   switch (TREE_CODE (expr))\n@@ -1248,12 +1252,12 @@ invariant_in_loop_and_outer_loops (struct loop *loop, tree op)\n \n static lambda_loop\n gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n-\t\t\t VEC (tree) ** invariants,\n+\t\t\t VEC(tree,gc) ** invariants,\n \t\t\t tree * ourinductionvar,\n-\t\t\t VEC (tree) * outerinductionvars,\n-\t\t\t VEC (tree) ** lboundvars,\n-\t\t\t VEC (tree) ** uboundvars,\n-\t\t\t VEC (int) ** steps)\n+\t\t\t VEC(tree,gc) * outerinductionvars,\n+\t\t\t VEC(tree,gc) ** lboundvars,\n+\t\t\t VEC(tree,gc) ** uboundvars,\n+\t\t\t VEC(int,gc) ** steps)\n {\n   tree phi;\n   tree exit_cond;\n@@ -1403,10 +1407,10 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   /* One part of the test may be a loop invariant tree.  */\n   if (TREE_CODE (TREE_OPERAND (test, 1)) == SSA_NAME\n       && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 1)))\n-    VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 1));\n+    VEC_safe_push (tree, gc, *invariants, TREE_OPERAND (test, 1));\n   else if (TREE_CODE (TREE_OPERAND (test, 0)) == SSA_NAME\n \t   && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 0)))\n-    VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 0));\n+    VEC_safe_push (tree, gc, *invariants, TREE_OPERAND (test, 0));\n   \n   /* The non-induction variable part of the test is the upper bound variable.\n    */\n@@ -1438,9 +1442,9 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t\t\t\t\t  *invariants, extra);\n   uboundresult = build (PLUS_EXPR, TREE_TYPE (uboundvar), uboundvar,\n \t\t\tbuild_int_cst (TREE_TYPE (uboundvar), extra));\n-  VEC_safe_push (tree, *uboundvars, uboundresult);\n-  VEC_safe_push (tree, *lboundvars, lboundvar);\n-  VEC_safe_push (int, *steps, stepint);\n+  VEC_safe_push (tree, gc, *uboundvars, uboundresult);\n+  VEC_safe_push (tree, gc, *lboundvars, lboundvar);\n+  VEC_safe_push (int, gc, *steps, stepint);\n   if (!ubound)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1488,7 +1492,9 @@ find_induction_var_from_exit_cond (struct loop *loop)\n   return ivarop;\n }\n \n-DEF_VEC_GC_P(lambda_loop);\n+DEF_VEC_P(lambda_loop);\n+DEF_VEC_ALLOC_P(lambda_loop,gc);\n+\n /* Generate a lambda loopnest from a gcc loopnest LOOP_NEST.\n    Return the new loop nest.  \n    INDUCTIONVARS is a pointer to an array of induction variables for the\n@@ -1499,18 +1505,18 @@ DEF_VEC_GC_P(lambda_loop);\n lambda_loopnest\n gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \t\t\t\t struct loop * loop_nest,\n-\t\t\t\t VEC (tree) **inductionvars,\n-\t\t\t\t VEC (tree) **invariants,\n+\t\t\t\t VEC(tree,gc) **inductionvars,\n+\t\t\t\t VEC(tree,gc) **invariants,\n \t\t\t\t bool need_perfect_nest)\n {\n   lambda_loopnest ret;\n   struct loop *temp;\n   int depth = 0;\n   size_t i;\n-  VEC (lambda_loop) *loops = NULL;\n-  VEC (tree) *uboundvars = NULL;\n-  VEC (tree) *lboundvars  = NULL;\n-  VEC (int) *steps = NULL;\n+  VEC(lambda_loop,gc) *loops = NULL;\n+  VEC(tree,gc) *uboundvars = NULL;\n+  VEC(tree,gc) *lboundvars  = NULL;\n+  VEC(int,gc) *steps = NULL;\n   lambda_loop newloop;\n   tree inductionvar = NULL;\n   \n@@ -1524,8 +1530,8 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \t\t\t\t\t &steps);\n       if (!newloop)\n \treturn NULL;\n-      VEC_safe_push (tree, *inductionvars, inductionvar);\n-      VEC_safe_push (lambda_loop, loops, newloop);\n+      VEC_safe_push (tree, gc, *inductionvars, inductionvar);\n+      VEC_safe_push (lambda_loop, gc, loops, newloop);\n       temp = temp->inner;\n     }\n   if (need_perfect_nest)\n@@ -1559,7 +1565,7 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \n static tree\n lbv_to_gcc_expression (lambda_body_vector lbv, \n-\t\t       tree type, VEC (tree) *induction_vars, \n+\t\t       tree type, VEC(tree,gc) *induction_vars, \n \t\t       tree * stmts_to_insert)\n {\n   tree stmts, stmt, resvar, name;\n@@ -1642,15 +1648,15 @@ static tree\n lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t       lambda_linear_expression offset,\n \t\t       tree type,\n-\t\t       VEC(tree) *induction_vars,\n-\t\t       VEC(tree) *invariants,\n+\t\t       VEC(tree,gc) *induction_vars,\n+\t\t       VEC(tree,gc) *invariants,\n \t\t       enum tree_code wrap, tree * stmts_to_insert)\n {\n   tree stmts, stmt, resvar, name;\n   size_t i;\n   tree_stmt_iterator tsi;\n   tree iv, invar;\n-  VEC(tree) *results = NULL;\n+  VEC(tree,gc) *results = NULL;\n \n   name = NULL_TREE;\n   /* Create a statement list and a linear expression temporary.  */\n@@ -1801,7 +1807,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \t}\n-      VEC_safe_push (tree, results, name);\n+      VEC_safe_push (tree, gc, results, name);\n     }\n \n   /* Again, out of laziness, we don't handle this case yet.  It's not\n@@ -1839,16 +1845,16 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \n void\n lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n-\t\t\t\t VEC(tree) *old_ivs,\n-\t\t\t\t VEC(tree) *invariants,\n+\t\t\t\t VEC(tree,gc) *old_ivs,\n+\t\t\t\t VEC(tree,gc) *invariants,\n \t\t\t\t lambda_loopnest new_loopnest,\n \t\t\t\t lambda_trans_matrix transform)\n {\n \n   struct loop *temp;\n   size_t i = 0;\n   size_t depth = 0;\n-  VEC(tree) *new_ivs = NULL;\n+  VEC(tree,gc) *new_ivs = NULL;\n   tree oldiv;\n   \n   block_stmt_iterator bsi;\n@@ -1883,7 +1889,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       ivvar = create_tmp_var (type, \"lnivtmp\");\n       add_referenced_tmp_var (ivvar);\n \n-      VEC_safe_push (tree, new_ivs, ivvar);\n+      VEC_safe_push (tree, gc, new_ivs, ivvar);\n \n       newloop = LN_LOOPS (new_loopnest)[i];\n \n@@ -2207,7 +2213,7 @@ stmt_uses_op (tree stmt, tree op)\n \n static bool\n can_convert_to_perfect_nest (struct loop *loop,\n-\t\t\t     VEC (tree) *loopivs)\n+\t\t\t     VEC(tree,gc) *loopivs)\n {\n   basic_block *bbs;\n   tree exit_condition, phi;\n@@ -2307,10 +2313,10 @@ can_convert_to_perfect_nest (struct loop *loop,\n static bool\n perfect_nestify (struct loops *loops,\n \t\t struct loop *loop,\n-\t\t VEC (tree) *lbounds,\n-\t\t VEC (tree) *ubounds,\n-\t\t VEC (int) *steps,\n-\t\t VEC (tree) *loopivs)\n+\t\t VEC(tree,gc) *lbounds,\n+\t\t VEC(tree,gc) *ubounds,\n+\t\t VEC(int,gc) *steps,\n+\t\t VEC(tree,gc) *loopivs)\n {\n   basic_block *bbs;\n   tree exit_condition;\n@@ -2325,7 +2331,7 @@ perfect_nestify (struct loops *loops,\n   tree uboundvar;\n   tree stmt;\n   tree oldivvar, ivvar, ivvarinced;\n-  VEC (tree) *phis = NULL;\n+  VEC(tree,gc) *phis = NULL;\n \n   if (!can_convert_to_perfect_nest (loop, loopivs))\n     return false;\n@@ -2339,8 +2345,9 @@ perfect_nestify (struct loops *loops,\n   /* Push the exit phi nodes that we are moving.  */\n   for (phi = phi_nodes (olddest); phi; phi = PHI_CHAIN (phi))\n     {\n-      VEC_safe_push (tree, phis, PHI_RESULT (phi));\n-      VEC_safe_push (tree, phis, PHI_ARG_DEF (phi, 0));\n+      VEC_reserve (tree, gc, phis, 2);\n+      VEC_quick_push (tree, phis, PHI_RESULT (phi));\n+      VEC_quick_push (tree, phis, PHI_ARG_DEF (phi, 0));\n     }\n   e = redirect_edge_and_branch (single_succ_edge (preheaderbb), headerbb);\n "}, {"sha": "6e145ad4ce7cc86ad4711aabb22fdeb1757e66a4", "filename": "gcc/lambda.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -196,11 +196,11 @@ lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix,\n void print_lambda_body_vector (FILE *, lambda_body_vector);\n lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loops *,\n \t\t\t\t\t\t struct loop *,\n-\t\t\t\t\t\t VEC(tree) **,\n-\t\t\t\t\t\t VEC(tree) **,\n+\t\t\t\t\t\t VEC(tree,gc) **,\n+\t\t\t\t\t\t VEC(tree,gc) **,\n \t\t\t\t\t\t bool);\n-void lambda_loopnest_to_gcc_loopnest (struct loop *, VEC(tree) *,\n-\t\t\t\t      VEC(tree) *,\n+void lambda_loopnest_to_gcc_loopnest (struct loop *, VEC(tree,gc) *,\n+\t\t\t\t      VEC(tree,gc) *,\n \t\t\t\t      lambda_loopnest, \n \t\t\t\t      lambda_trans_matrix);\n "}, {"sha": "4ab2553188b45a4dc2a722e6b33cae873e2e719f", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -223,7 +223,7 @@ instrument_values (histogram_values values)\n \t  gcc_unreachable ();\n \t}\n     }\n-  VEC_free (histogram_value, values);\n+  VEC_free (histogram_value, heap, values);\n }\n \f\n "}, {"sha": "17680cfc2f3a9a69e473ac5db9fcc563b25b276c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -110,7 +110,7 @@ static void make_goto_expr_edges (basic_block);\n static edge tree_redirect_edge_and_branch (edge, basic_block);\n static edge tree_try_redirect_by_replacing_jump (edge, basic_block);\n static void split_critical_edges (void);\n-static bool remove_fallthru_edge (VEC(edge) *);\n+static bool remove_fallthru_edge (VEC(edge,gc) *);\n \n /* Various helpers.  */\n static inline bool stmt_starts_bb_p (tree, tree);\n@@ -2015,7 +2015,7 @@ remove_bb (basic_block bb)\n    happens, all the instructions after the call are no longer\n    reachable and must be deleted as dead.  */\n \n-VEC(tree) *modified_noreturn_calls;\n+VEC(tree,gc) *modified_noreturn_calls;\n \n /* Try to remove superfluous control structures.  */\n \n@@ -2172,7 +2172,7 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n /* Remove any fallthru edge from EV.  Return true if an edge was removed.  */\n \n static bool\n-remove_fallthru_edge (VEC(edge) *ev)\n+remove_fallthru_edge (VEC(edge,gc) *ev)\n {\n   edge_iterator ei;\n   edge e;"}, {"sha": "d81c4b8d64c288bd670e22b82acee2327c209574", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -254,7 +254,7 @@ dequeue_and_dump (dump_info_p di)\n     {\n       unsigned ix;\n       tree base;\n-      VEC (tree) *accesses = BINFO_BASE_ACCESSES (t);\n+      VEC(tree,gc) *accesses = BINFO_BASE_ACCESSES (t);\n \n       dump_child (\"type\", BINFO_TYPE (t));\n "}, {"sha": "0199206f02c20b935a3348a6705368ef51513d6b", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -151,7 +151,7 @@ mark_stmt_modified (tree t)\n   if (ann == NULL)\n     ann = create_stmt_ann (t);\n   else if (noreturn_call_p (t))\n-    VEC_safe_push (tree, modified_noreturn_calls, t);\n+    VEC_safe_push (tree, gc, modified_noreturn_calls, t);\n   ann->modified = 1;\n }\n "}, {"sha": "992f08a71c4edda585ed0612ae77347fac446e20", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -340,7 +340,7 @@ union tree_ann_d GTY((desc (\"ann_type ((tree_ann_t)&%h)\")))\n   struct stmt_ann_d GTY((tag (\"STMT_ANN\"))) stmt;\n };\n \n-extern GTY(()) VEC(tree) *modified_noreturn_calls;\n+extern GTY(()) VEC(tree,gc) *modified_noreturn_calls;\n \n typedef union tree_ann_d *tree_ann_t;\n typedef struct var_ann_d *var_ann_t;\n@@ -581,9 +581,6 @@ extern tree make_rename_temp (tree, const char *);\n extern void record_vars (tree);\n extern bool block_may_fallthru (tree block);\n \n-typedef tree tree_on_heap;\n-DEF_VEC_MALLOC_P (tree_on_heap);\n-\n /* In tree-ssa-alias.c  */\n extern void dump_may_aliases_for (FILE *, tree);\n extern void debug_may_aliases_for (tree);\n@@ -623,7 +620,7 @@ extern bool tree_ssa_useless_type_conversion (tree);\n extern bool tree_ssa_useless_type_conversion_1 (tree, tree);\n extern void verify_ssa (bool);\n extern void delete_tree_ssa (void);\n-extern void register_new_def (tree, VEC (tree_on_heap) **);\n+extern void register_new_def (tree, VEC(tree,heap) **);\n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n extern bool stmt_references_memory_p (tree);\n "}, {"sha": "58f5f4cdabfb4458daad35f38af9bb957d7b97c9", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -98,10 +98,13 @@ static htab_t def_blocks;\n \n    - A NULL node at the top entry is used to mark the last node\n      associated with the current block.  */\n-static VEC(tree_on_heap) *block_defs_stack;\n+static VEC(tree,heap) *block_defs_stack;\n \n-/* Basic block vectors used in this file ought to be allocated in the heap.  */\n-DEF_VEC_MALLOC_P(int);\n+/* Basic block vectors used in this file ought to be allocated in the\n+   heap.  We use pointer vector, because ints can be easily passed by\n+   value.  */\n+DEF_VEC_P(int);\n+DEF_VEC_ALLOC_P(int,heap);\n \n /* Set of existing SSA names being replaced by update_ssa.  */\n static sbitmap old_ssa_names;\n@@ -683,10 +686,10 @@ find_idf (bitmap def_blocks, bitmap *dfs)\n {\n   bitmap_iterator bi;\n   unsigned bb_index;\n-  VEC(int) *work_stack;\n+  VEC(int,heap) *work_stack;\n   bitmap phi_insertion_points;\n \n-  work_stack = VEC_alloc (int, n_basic_blocks);\n+  work_stack = VEC_alloc (int, heap, n_basic_blocks);\n   phi_insertion_points = BITMAP_ALLOC (NULL);\n \n   /* Seed the work list with all the blocks in DEF_BLOCKS.  */\n@@ -719,12 +722,12 @@ find_idf (bitmap def_blocks, bitmap *dfs)\n \t  /* Use a safe push because if there is a definition of VAR\n \t     in every basic block, then WORK_STACK may eventually have\n \t     more than N_BASIC_BLOCK entries.  */\n-\t  VEC_safe_push (int, work_stack, bb_index);\n+\t  VEC_safe_push (int, heap, work_stack, bb_index);\n \t  bitmap_set_bit (phi_insertion_points, bb_index);\n \t}\n     }\n \n-  VEC_free (int, work_stack);\n+  VEC_free (int, heap, work_stack);\n \n   return phi_insertion_points;\n }\n@@ -892,7 +895,7 @@ insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n    into the stack pointed by BLOCK_DEFS_P.  */\n \n void\n-register_new_def (tree def, VEC (tree_on_heap) **block_defs_p)\n+register_new_def (tree def, VEC(tree,heap) **block_defs_p)\n {\n   tree var = SSA_NAME_VAR (def);\n   tree currdef;\n@@ -918,7 +921,7 @@ register_new_def (tree def, VEC (tree_on_heap) **block_defs_p)\n      definitions for all the variables defined in the block after a recursive\n      visit to all its immediately dominated blocks.  If there is no current\n      reaching definition, then just record the underlying _DECL node.  */\n-  VEC_safe_push (tree_on_heap, *block_defs_p, currdef ? currdef : var);\n+  VEC_safe_push (tree, heap, *block_defs_p, currdef ? currdef : var);\n \n   /* Set the current reaching definition for VAR to be DEF.  */\n   set_current_def (var, def);\n@@ -963,7 +966,7 @@ rewrite_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n \n   /* Mark the unwind point for this block.  */\n-  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n \n   /* Step 1.  Register new definitions for every PHI node in the block.\n      Conceptually, all the PHI nodes are executed in parallel and each PHI\n@@ -1089,9 +1092,9 @@ rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\tbasic_block bb ATTRIBUTE_UNUSED)\n {\n   /* Restore CURRDEFS to its original state.  */\n-  while (VEC_length (tree_on_heap, block_defs_stack) > 0)\n+  while (VEC_length (tree, block_defs_stack) > 0)\n     {\n-      tree tmp = VEC_pop (tree_on_heap, block_defs_stack);\n+      tree tmp = VEC_pop (tree, block_defs_stack);\n       tree saved_def, var;\n \n       if (tmp == NULL_TREE)\n@@ -1249,8 +1252,9 @@ register_new_update_single (tree new_name, tree old_name)\n      restore the reaching definitions for all the variables\n      defined in the block after a recursive visit to all its\n      immediately dominated blocks.  */\n-  VEC_safe_push (tree_on_heap, block_defs_stack, currdef);\n-  VEC_safe_push (tree_on_heap, block_defs_stack, old_name);\n+  VEC_reserve (tree, heap, block_defs_stack, 2);\n+  VEC_quick_push (tree, block_defs_stack, currdef);\n+  VEC_quick_push (tree, block_defs_stack, old_name);\n \n   /* Set the current reaching definition for OLD_NAME to be\n      NEW_NAME.  */\n@@ -1292,7 +1296,7 @@ rewrite_update_init_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t     bb->index);\n \n   /* Mark the unwind point for this block.  */\n-  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n \n   /* Mark the LHS if any of the arguments flows through an abnormal\n      edge.  */\n@@ -1362,17 +1366,17 @@ static void\n rewrite_update_fini_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t   basic_block bb ATTRIBUTE_UNUSED)\n {\n-  while (VEC_length (tree_on_heap, block_defs_stack) > 0)\n+  while (VEC_length (tree, block_defs_stack) > 0)\n     {\n-      tree var = VEC_pop (tree_on_heap, block_defs_stack);\n+      tree var = VEC_pop (tree, block_defs_stack);\n       tree saved_def;\n       \n       /* NULL indicates the unwind stop point for this block (see\n \t rewrite_update_init_block).  */\n       if (var == NULL)\n \treturn;\n \n-      saved_def = VEC_pop (tree_on_heap, block_defs_stack);\n+      saved_def = VEC_pop (tree, block_defs_stack);\n       set_current_def (var, saved_def);\n     }\n }\n@@ -1603,7 +1607,7 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what, sbitmap blocks)\n   else\n     gcc_unreachable ();\n \n-  block_defs_stack = VEC_alloc (tree_on_heap, 10);\n+  block_defs_stack = VEC_alloc (tree, heap, 10);\n \n   /* Initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n@@ -1629,8 +1633,7 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what, sbitmap blocks)\n       def_blocks = NULL;\n     }\n   \n-  VEC_free (tree_on_heap, block_defs_stack);\n-  block_defs_stack = NULL;\n+  VEC_free (tree, heap, block_defs_stack);\n \n   timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n }\n@@ -2855,15 +2858,15 @@ ssa_rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n   /* Step 5.  Restore the current reaching definition for each variable\n      referenced in the block (in reverse order).  */\n-  while (VEC_length (tree_on_heap, block_defs_stack) > 0)\n+  while (VEC_length (tree, block_defs_stack) > 0)\n     {\n-      tree var = VEC_pop (tree_on_heap, block_defs_stack);\n+      tree var = VEC_pop (tree, block_defs_stack);\n       tree saved_def;\n       \n       if (var == NULL)\n \tbreak;\n \n-      saved_def = VEC_pop (tree_on_heap, block_defs_stack);\n+      saved_def = VEC_pop (tree, block_defs_stack);\n       set_current_def (var, saved_def);\n     }\n }\n@@ -2894,8 +2897,9 @@ ssa_register_new_def (tree var, tree def)\n      later used by the dominator tree callbacks to restore the reaching\n      definitions for all the variables defined in the block after a recursive\n      visit to all its immediately dominated blocks.  */\n-  VEC_safe_push (tree_on_heap, block_defs_stack, currdef);\n-  VEC_safe_push (tree_on_heap, block_defs_stack, var);\n+  VEC_reserve (tree, heap, block_defs_stack, 2);\n+  VEC_quick_push (tree, block_defs_stack, currdef);\n+  VEC_quick_push (tree, block_defs_stack, var);\n \n   /* Set the current reaching definition for VAR to be DEF.  */\n   set_current_def (var, def);\n@@ -2999,7 +3003,7 @@ ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n     fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n \n   /* Mark the unwind point for this block.  */\n-  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n     if (e->flags & EDGE_ABNORMAL)\n@@ -3194,7 +3198,7 @@ rewrite_ssa_into_ssa (void)\n   mark_def_sites_global_data.names_to_rename = snames_to_rename;\n   walk_data.global_data = &mark_def_sites_global_data;\n \n-  block_defs_stack = VEC_alloc (tree_on_heap, 10);\n+  block_defs_stack = VEC_alloc (tree, heap, 10);\n \n   /* We do not have any local data.  */\n   walk_data.block_local_data_size = 0;\n@@ -3284,7 +3288,6 @@ rewrite_ssa_into_ssa (void)\n \n   BITMAP_FREE (to_rename);\n   \n-  VEC_free (tree_on_heap, block_defs_stack);\n-  block_defs_stack = NULL;\n+  VEC_free (tree, heap, block_defs_stack);\n   timevar_pop (TV_TREE_SSA_OTHER);\n }"}, {"sha": "b7e57a63603b0e88365a5a88b494faffb9c7c7d7", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -243,6 +243,9 @@ void\n linear_transform_loops (struct loops *loops)\n {\n   unsigned int i;\n+  VEC(tree,gc) *oldivs = NULL;  /* FIXME:These should really be on the\n+\t\t\t\t   heap.  (nathan 2005/04/15)*/\n+  VEC(tree,gc) *invariants = NULL;  /* FIXME:Likewise. */\n   \n   for (i = 1; i < loops->num; i++)\n     {\n@@ -251,8 +254,6 @@ linear_transform_loops (struct loops *loops)\n       varray_type dependence_relations;\n       struct loop *loop_nest = loops->parray[i];\n       struct loop *temp;\n-      VEC (tree) *oldivs = NULL;\n-      VEC (tree) *invariants = NULL;\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n       bool problem = false;\n@@ -273,6 +274,8 @@ linear_transform_loops (struct loops *loops)\n            } */\n       if (!loop_nest || !loop_nest->inner)\n \tcontinue;\n+      VEC_truncate (tree, oldivs, 0);\n+      VEC_truncate (tree, invariants, 0);\n       depth = 1;\n       for (temp = loop_nest->inner; temp; temp = temp->inner)\n \t{\n@@ -365,11 +368,11 @@ linear_transform_loops (struct loops *loops)\n \t\t\t\t       after, trans);\n       if (dump_file)\n \tfprintf (dump_file, \"Successfully transformed loop.\\n\");\n-      oldivs = NULL;\n-      invariants = NULL;\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }\n+  VEC_free (tree, gc, oldivs);\n+  VEC_free (tree, gc, invariants);\n   scev_reset ();\n   update_ssa (TODO_update_ssa);\n   rewrite_into_loop_closed_ssa (NULL);"}, {"sha": "d78ab53dbc464ed37293dbdc4ac01432191f3b02", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -2791,7 +2791,9 @@ typedef struct fieldoff\n   HOST_WIDE_INT offset;  \n } *fieldoff_t;\n \n-DEF_VEC_MALLOC_P(fieldoff_t);\n+DEF_VEC_P (fieldoff_t);  /* FIXME: This can be a vector of struct\n+\t\t\t    fieldoff objects (nathan 2005/04/15)  */\n+DEF_VEC_ALLOC_P(fieldoff_t,heap);\n \n /* Return the position, in bits, of FIELD_DECL from the beginning of its\n    structure. \n@@ -2816,7 +2818,7 @@ bitpos_of_field (const tree fdecl)\n    than just the immediately containing structure.  */\n \n static void\n-push_fields_onto_fieldstack (tree type, VEC(fieldoff_t) **fieldstack, \n+push_fields_onto_fieldstack (tree type, VEC(fieldoff_t,heap) **fieldstack, \n \t\t\t     HOST_WIDE_INT offset)\n {\n   fieldoff_t pair;\n@@ -2838,15 +2840,15 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_t) **fieldstack,\n \t  pair = xmalloc (sizeof (struct fieldoff));\n \t  pair->field = field;\n \t  pair->offset = offset;\n-\t  VEC_safe_push (fieldoff_t, *fieldstack, pair);\n+\t  VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n \t}\n     }\n   else if (TREE_CODE (field) == FIELD_DECL)\n     {\n       pair = xmalloc (sizeof (struct fieldoff));\n       pair->field = field;\n       pair->offset = offset + bitpos_of_field (field);\n-      VEC_safe_push (fieldoff_t, *fieldstack, pair);\n+      VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n     }\n   for (field = TREE_CHAIN (field); field; field = TREE_CHAIN (field))\n     {\n@@ -2867,15 +2869,15 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_t) **fieldstack,\n \t      pair = xmalloc (sizeof (struct fieldoff));\n \t      pair->field = field;\n \t      pair->offset = offset + bitpos_of_field (field);\n-\t      VEC_safe_push (fieldoff_t, *fieldstack, pair);\n+\t      VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n \t    }\n \t}\n       else\n \t{\n \t  pair = xmalloc (sizeof (struct fieldoff));\n \t  pair->field = field;\n \t  pair->offset = offset + bitpos_of_field (field);\n-\t  VEC_safe_push (fieldoff_t, *fieldstack, pair);\n+\t  VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n \t}\n     }\n }\n@@ -2944,7 +2946,7 @@ fieldoff_compare (const void *pa, const void *pb)\n static void\n create_overlap_variables_for (tree var)\n {\n-  VEC(fieldoff_t) *fieldstack = NULL;\n+  VEC(fieldoff_t,heap) *fieldstack = NULL;\n   used_part_t up;\n   size_t uid = var_ann (var)->uid;\n \n@@ -3019,7 +3021,7 @@ create_overlap_variables_for (tree var)\n \t      fo = VEC_pop (fieldoff_t, fieldstack);\n \t      free (fo);\n \t    }\n-\t  VEC_free (fieldoff_t, fieldstack);\n+\t  VEC_free (fieldoff_t, heap, fieldstack);\n \t  return;\n \t}\n       /* Otherwise, create the variables.  */\n@@ -3109,7 +3111,7 @@ create_overlap_variables_for (tree var)\n \n     }\n \n-  VEC_free (fieldoff_t, fieldstack);\n+  VEC_free (fieldoff_t, heap, fieldstack);\n }\n \n "}, {"sha": "429ba768f5d4bb9ba2834a0a96b5655c83492512", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -94,7 +94,7 @@ static htab_t avail_exprs;\n    (null).  When we finish processing the block, we pop off entries and\n    remove the expressions from the global hash table until we hit the\n    marker.  */\n-static VEC(tree_on_heap) *avail_exprs_stack;\n+static VEC(tree,heap) *avail_exprs_stack;\n \n /* Stack of trees used to restore the global currdefs to its original\n    state after completing optimization of a block and its dominator children.\n@@ -107,7 +107,7 @@ static VEC(tree_on_heap) *avail_exprs_stack;\n \n    A NULL node is used to mark the last node associated with the\n    current block.  */\n-static VEC(tree_on_heap) *block_defs_stack;\n+static VEC(tree,heap) *block_defs_stack;\n \n /* Stack of statements we need to rescan during finalization for newly\n    exposed variables.\n@@ -116,7 +116,7 @@ static VEC(tree_on_heap) *block_defs_stack;\n    expressions are removed from AVAIL_EXPRS.  Else we may change the\n    hash code for an expression and be unable to find/remove it from\n    AVAIL_EXPRS.  */\n-static VEC(tree_on_heap) *stmts_to_rescan;\n+static VEC(tree,heap) *stmts_to_rescan;\n \n /* Structure for entries in the expression hash table.\n \n@@ -148,7 +148,7 @@ struct expr_hash_elt\n \n    A NULL entry is used to mark the end of pairs which need to be\n    restored during finalization of this block.  */\n-static VEC(tree_on_heap) *const_and_copies_stack;\n+static VEC(tree,heap) *const_and_copies_stack;\n \n /* Bitmap of SSA_NAMEs known to have a nonzero value, even if we do not\n    know their exact value.  */\n@@ -159,7 +159,7 @@ static bitmap nonzero_vars;\n \n    A NULL entry is used to mark the end of names needing their \n    entry in NONZERO_VARS cleared during finalization of this block.  */\n-static VEC(tree_on_heap) *nonzero_vars_stack;\n+static VEC(tree,heap) *nonzero_vars_stack;\n \n /* Track whether or not we have changed the control flow graph.  */\n static bool cfg_altered;\n@@ -254,7 +254,7 @@ struct vrp_hash_elt\n    list to determine which variables need their VRP data updated.\n \n    A NULL entry marks the end of the SSA_NAMEs associated with this block.  */\n-static VEC(tree_on_heap) *vrp_variables_stack;\n+static VEC(tree,heap) *vrp_variables_stack;\n \n struct eq_expr_value\n {\n@@ -382,12 +382,12 @@ tree_ssa_dominator_optimize (void)\n   /* Create our hash tables.  */\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n   vrp_data = htab_create (ceil_log2 (num_ssa_names), vrp_hash, vrp_eq, free);\n-  avail_exprs_stack = VEC_alloc (tree_on_heap, 20);\n-  block_defs_stack = VEC_alloc (tree_on_heap, 20);\n-  const_and_copies_stack = VEC_alloc (tree_on_heap, 20);\n-  nonzero_vars_stack = VEC_alloc (tree_on_heap, 20);\n-  vrp_variables_stack = VEC_alloc (tree_on_heap, 20);\n-  stmts_to_rescan = VEC_alloc (tree_on_heap, 20);\n+  avail_exprs_stack = VEC_alloc (tree, heap, 20);\n+  block_defs_stack = VEC_alloc (tree, heap, 20);\n+  const_and_copies_stack = VEC_alloc (tree, heap, 20);\n+  nonzero_vars_stack = VEC_alloc (tree, heap, 20);\n+  vrp_variables_stack = VEC_alloc (tree, heap, 20);\n+  stmts_to_rescan = VEC_alloc (tree, heap, 20);\n   nonzero_vars = BITMAP_ALLOC (NULL);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n@@ -545,12 +545,12 @@ tree_ssa_dominator_optimize (void)\n   BITMAP_FREE (nonzero_vars);\n   BITMAP_FREE (need_eh_cleanup);\n   \n-  VEC_free (tree_on_heap, block_defs_stack);\n-  VEC_free (tree_on_heap, avail_exprs_stack);\n-  VEC_free (tree_on_heap, const_and_copies_stack);\n-  VEC_free (tree_on_heap, nonzero_vars_stack);\n-  VEC_free (tree_on_heap, vrp_variables_stack);\n-  VEC_free (tree_on_heap, stmts_to_rescan);\n+  VEC_free (tree, heap, block_defs_stack);\n+  VEC_free (tree, heap, avail_exprs_stack);\n+  VEC_free (tree, heap, const_and_copies_stack);\n+  VEC_free (tree, heap, nonzero_vars_stack);\n+  VEC_free (tree, heap, vrp_variables_stack);\n+  VEC_free (tree, heap, stmts_to_rescan);\n }\n \n static bool\n@@ -850,11 +850,11 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n-  VEC_safe_push (tree_on_heap, avail_exprs_stack, NULL_TREE);\n-  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n-  VEC_safe_push (tree_on_heap, const_and_copies_stack, NULL_TREE);\n-  VEC_safe_push (tree_on_heap, nonzero_vars_stack, NULL_TREE);\n-  VEC_safe_push (tree_on_heap, vrp_variables_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, avail_exprs_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, nonzero_vars_stack, NULL_TREE);\n+  VEC_safe_push (tree, heap, vrp_variables_stack, NULL_TREE);\n \n   record_equivalences_from_incoming_edge (bb);\n \n@@ -910,10 +910,10 @@ static void\n remove_local_expressions_from_table (void)\n {\n   /* Remove all the expressions made available in this block.  */\n-  while (VEC_length (tree_on_heap, avail_exprs_stack) > 0)\n+  while (VEC_length (tree, avail_exprs_stack) > 0)\n     {\n       struct expr_hash_elt element;\n-      tree expr = VEC_pop (tree_on_heap, avail_exprs_stack);\n+      tree expr = VEC_pop (tree, avail_exprs_stack);\n \n       if (expr == NULL_TREE)\n \tbreak;\n@@ -929,9 +929,9 @@ remove_local_expressions_from_table (void)\n static void\n restore_nonzero_vars_to_original_value (void)\n {\n-  while (VEC_length (tree_on_heap, nonzero_vars_stack) > 0)\n+  while (VEC_length (tree, nonzero_vars_stack) > 0)\n     {\n-      tree name = VEC_pop (tree_on_heap, nonzero_vars_stack);\n+      tree name = VEC_pop (tree, nonzero_vars_stack);\n \n       if (name == NULL)\n \tbreak;\n@@ -947,16 +947,16 @@ restore_nonzero_vars_to_original_value (void)\n static void\n restore_vars_to_original_value (void)\n {\n-  while (VEC_length (tree_on_heap, const_and_copies_stack) > 0)\n+  while (VEC_length (tree, const_and_copies_stack) > 0)\n     {\n       tree prev_value, dest;\n \n-      dest = VEC_pop (tree_on_heap, const_and_copies_stack);\n+      dest = VEC_pop (tree, const_and_copies_stack);\n \n       if (dest == NULL)\n \tbreak;\n \n-      prev_value = VEC_pop (tree_on_heap, const_and_copies_stack);\n+      prev_value = VEC_pop (tree, const_and_copies_stack);\n       SSA_NAME_VALUE (dest) =  prev_value;\n     }\n }\n@@ -967,9 +967,9 @@ static void\n restore_currdefs_to_original_value (void)\n {\n   /* Restore CURRDEFS to its original state.  */\n-  while (VEC_length (tree_on_heap, block_defs_stack) > 0)\n+  while (VEC_length (tree, block_defs_stack) > 0)\n     {\n-      tree tmp = VEC_pop (tree_on_heap, block_defs_stack);\n+      tree tmp = VEC_pop (tree, block_defs_stack);\n       tree saved_def, var;\n \n       if (tmp == NULL_TREE)\n@@ -1050,9 +1050,9 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  /* Push a marker onto the available expression stack so that we\n \t     unwind any expressions related to the TRUE arm before processing\n \t     the false arm below.  */\n-\t  VEC_safe_push (tree_on_heap, avail_exprs_stack, NULL_TREE);\n-\t  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n-\t  VEC_safe_push (tree_on_heap, const_and_copies_stack, NULL_TREE);\n+\t  VEC_safe_push (tree, heap, avail_exprs_stack, NULL_TREE);\n+\t  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n+\t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n \n \t  edge_info = true_edge->aux;\n \n@@ -1154,9 +1154,9 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n      To be efficient, we note which variables have had their values\n      constrained in this block.  So walk over each variable in the\n      VRP_VARIABLEs array.  */\n-  while (VEC_length (tree_on_heap, vrp_variables_stack) > 0)\n+  while (VEC_length (tree, vrp_variables_stack) > 0)\n     {\n-      tree var = VEC_pop (tree_on_heap, vrp_variables_stack);\n+      tree var = VEC_pop (tree, vrp_variables_stack);\n       struct vrp_hash_elt vrp_hash_elt, *vrp_hash_elt_p;\n       void **slot;\n \n@@ -1192,15 +1192,15 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \n   /* If we queued any statements to rescan in this block, then\n      go ahead and rescan them now.  */\n-  while (VEC_length (tree_on_heap, stmts_to_rescan) > 0)\n+  while (VEC_length (tree, stmts_to_rescan) > 0)\n     {\n-      tree stmt = VEC_last (tree_on_heap, stmts_to_rescan);\n+      tree stmt = VEC_last (tree, stmts_to_rescan);\n       basic_block stmt_bb = bb_for_stmt (stmt);\n \n       if (stmt_bb != bb)\n \tbreak;\n \n-      VEC_pop (tree_on_heap, stmts_to_rescan);\n+      VEC_pop (tree, stmts_to_rescan);\n       mark_new_vars_to_rename (stmt);\n     }\n }\n@@ -1436,7 +1436,7 @@ record_var_is_nonzero (tree var)\n \n   /* Record this SSA_NAME so that we can reset the global table\n      when we leave this block.  */\n-  VEC_safe_push (tree_on_heap, nonzero_vars_stack, var);\n+  VEC_safe_push (tree, heap, nonzero_vars_stack, var);\n }\n \n /* Enter a statement into the true/false expression hash table indicating\n@@ -1455,7 +1455,7 @@ record_cond (tree cond, tree value)\n   if (*slot == NULL)\n     {\n       *slot = (void *) element;\n-      VEC_safe_push (tree_on_heap, avail_exprs_stack, cond);\n+      VEC_safe_push (tree, heap, avail_exprs_stack, cond);\n     }\n   else\n     free (element);\n@@ -1594,8 +1594,9 @@ record_const_or_copy_1 (tree x, tree y, tree prev_x)\n {\n   SSA_NAME_VALUE (x) = y;\n \n-  VEC_safe_push (tree_on_heap, const_and_copies_stack, prev_x);\n-  VEC_safe_push (tree_on_heap, const_and_copies_stack, x);\n+  VEC_reserve (tree, heap, const_and_copies_stack, 2);\n+  VEC_quick_push (tree, const_and_copies_stack, prev_x);\n+  VEC_quick_push (tree, const_and_copies_stack, x);\n }\n \n \n@@ -3125,7 +3126,7 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n     }\n \n   if (may_have_exposed_new_symbols)\n-    VEC_safe_push (tree_on_heap, stmts_to_rescan, bsi_stmt (si));\n+    VEC_safe_push (tree, heap, stmts_to_rescan, bsi_stmt (si));\n }\n \n /* Replace the RHS of STMT with NEW_RHS.  If RHS can be found in the\n@@ -3177,7 +3178,7 @@ update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs, bool insert)\n      we found a copy of this statement in the second hash table lookup\n      we want _no_ copies of this statement in BLOCK_AVAIL_EXPRs.  */\n   if (insert)\n-    VEC_pop (tree_on_heap, avail_exprs_stack);\n+    VEC_pop (tree, avail_exprs_stack);\n \n   /* And make sure we record the fact that we modified this\n      statement.  */\n@@ -3253,7 +3254,7 @@ lookup_avail_expr (tree stmt, bool insert)\n   if (*slot == NULL)\n     {\n       *slot = (void *) element;\n-      VEC_safe_push (tree_on_heap, avail_exprs_stack,\n+      VEC_safe_push (tree, heap, avail_exprs_stack,\n \t\t     stmt ? stmt : element->rhs);\n       return NULL_TREE;\n     }\n@@ -3393,7 +3394,7 @@ record_range (tree cond, basic_block bb)\n \tVARRAY_GENERIC_PTR_INIT (*vrp_records_p, 2, \"vrp records\");\n       \n       VARRAY_PUSH_GENERIC_PTR (*vrp_records_p, element);\n-      VEC_safe_push (tree_on_heap, vrp_variables_stack, TREE_OPERAND (cond, 0));\n+      VEC_safe_push (tree, heap, vrp_variables_stack, TREE_OPERAND (cond, 0));\n     }\n }\n "}, {"sha": "0e705c301df6f13372b0eca979a083189d32ae81", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -1112,7 +1112,8 @@ clean (value_set_t set)\n     }\n }\n \n-DEF_VEC_MALLOC_P (basic_block);\n+DEF_VEC_P (basic_block);\n+DEF_VEC_ALLOC_P (basic_block, heap);\n static sbitmap has_abnormal_preds;\n \n /* Compute the ANTIC set for BLOCK.\n@@ -1162,15 +1163,15 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n      them.  */\n   else\n     {\n-      VEC (basic_block) * worklist;\n+      VEC(basic_block, heap) * worklist;\n       edge e;\n       size_t i;\n       basic_block bprime, first;\n       edge_iterator ei;\n \n-      worklist = VEC_alloc (basic_block, 2);\n+      worklist = VEC_alloc (basic_block, heap, EDGE_COUNT (block->succs));\n       FOR_EACH_EDGE (e, ei, block->succs)\n-\tVEC_safe_push (basic_block, worklist, e->dest);\n+\tVEC_quick_push (basic_block, worklist, e->dest);\n       first = VEC_index (basic_block, worklist, 0);\n       set_copy (ANTIC_OUT, ANTIC_IN (first));\n \n@@ -1187,7 +1188,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t      node = next;\n \t    }\n \t}\n-      VEC_free (basic_block, worklist);\n+      VEC_free (basic_block, heap, worklist);\n     }\n \n   /* Generate ANTIC_OUT - TMP_GEN.  */\n@@ -1271,7 +1272,7 @@ compute_antic (void)\n     fprintf (dump_file, \"compute_antic required %d iterations\\n\", num_iterations);\n }\n \n-static VEC(tree_on_heap) *inserted_exprs;\n+static VEC(tree,heap) *inserted_exprs;\n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n    complex.  \n@@ -1367,7 +1368,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tTREE_OPERAND (newexpr, 0) = name;\n \ttsi = tsi_last (stmts);\n \ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n-\tVEC_safe_push (tree_on_heap, inserted_exprs, newexpr);\n+\tVEC_safe_push (tree, heap, inserted_exprs, newexpr);\n \tpre_stats.insertions++;\n \tbreak;\n       }\n@@ -1415,7 +1416,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tNECESSARY (newexpr) = 0;\n \ttsi = tsi_last (stmts);\n \ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n-\tVEC_safe_push (tree_on_heap, inserted_exprs, newexpr);\n+\tVEC_safe_push (tree, heap, inserted_exprs, newexpr);\n \tpre_stats.insertions++;\n \n \tbreak;\n@@ -1533,7 +1534,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n   add_referenced_tmp_var (temp);\n   temp = create_phi_node (temp, block);\n   NECESSARY (temp) = 0; \n-  VEC_safe_push (tree_on_heap, inserted_exprs, temp);\n+  VEC_safe_push (tree, heap, inserted_exprs, temp);\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     add_phi_arg (temp, avail[pred->src->index], pred);\n   \n@@ -2111,10 +2112,11 @@ eliminate (void)\n    this may be a bit faster, and we may want critical edges kept split.  */\n \n /* If OP's defining statement has not already been determined to be necessary,\n-   mark that statement necessary. and place it on the WORKLIST.  */ \n+   mark that statement necessary. Return the stmt, if it is newly\n+   necessary.  */ \n \n-static inline void\n-mark_operand_necessary (tree op, VEC(tree_on_heap) **worklist)\n+static inline tree\n+mark_operand_necessary (tree op)\n {\n   tree stmt;\n \n@@ -2125,10 +2127,10 @@ mark_operand_necessary (tree op, VEC(tree_on_heap) **worklist)\n \n   if (NECESSARY (stmt)\n       || IS_EMPTY_STMT (stmt))\n-    return;\n+    return NULL;\n \n   NECESSARY (stmt) = 1;\n-  VEC_safe_push (tree_on_heap, *worklist, stmt);\n+  return stmt;\n }\n \n /* Because we don't follow exactly the standard PRE algorithm, and decide not\n@@ -2139,18 +2141,19 @@ mark_operand_necessary (tree op, VEC(tree_on_heap) **worklist)\n static void\n remove_dead_inserted_code (void)\n {\n-  VEC (tree_on_heap) *worklist = NULL;\n+  VEC(tree,heap) *worklist = NULL;\n   int i;\n   tree t;\n \n-  for (i = 0; VEC_iterate (tree_on_heap, inserted_exprs, i, t); i++)\n+  worklist = VEC_alloc (tree, heap, VEC_length (tree, inserted_exprs));\n+  for (i = 0; VEC_iterate (tree, inserted_exprs, i, t); i++)\n     {\n       if (NECESSARY (t))\n-\tVEC_safe_push (tree_on_heap, worklist, t);\n+\tVEC_quick_push (tree, worklist, t);\n     }\n-  while (VEC_length (tree_on_heap, worklist) > 0)\n+  while (VEC_length (tree, worklist) > 0)\n     {\n-      t = VEC_pop (tree_on_heap, worklist);\n+      t = VEC_pop (tree, worklist);\n       if (TREE_CODE (t) == PHI_NODE)\n \t{\n \t  /* PHI nodes are somewhat special in that each PHI alternative has\n@@ -2160,11 +2163,17 @@ remove_dead_inserted_code (void)\n \t     predecessor block associated with each PHI alternative as\n \t     necessary.  */\n \t  int k;\n+\n+\t  VEC_reserve (tree, heap, worklist, PHI_NUM_ARGS (t));\n \t  for (k = 0; k < PHI_NUM_ARGS (t); k++)\n             {\n \t      tree arg = PHI_ARG_DEF (t, k);\n \t      if (TREE_CODE (arg) == SSA_NAME)\n-\t\tmark_operand_necessary (arg, &worklist);\n+\t\t{\n+\t\t  arg = mark_operand_necessary (arg);\n+\t\t  if (arg)\n+\t\t    VEC_quick_push (tree, worklist, arg);\n+\t\t}\n \t    }\n \t}\n       else\n@@ -2181,10 +2190,14 @@ remove_dead_inserted_code (void)\n \t     links).  */\n \n \t  FOR_EACH_SSA_TREE_OPERAND (use, t, iter, SSA_OP_ALL_USES)\n-\t    mark_operand_necessary (use, &worklist);\n+\t    {\n+\t      tree n = mark_operand_necessary (use);\n+\t      if (n)\n+\t\tVEC_safe_push (tree, heap, worklist, n);\n+\t    }\n \t}\n     }\n-  for (i = 0; VEC_iterate (tree_on_heap, inserted_exprs, i, t); i++)\n+  for (i = 0; VEC_iterate (tree, inserted_exprs, i, t); i++)\n     {\n       if (!NECESSARY (t))\n \t{\n@@ -2205,7 +2218,7 @@ remove_dead_inserted_code (void)\n \t    }\n \t}\n     }\n-  VEC_free (tree_on_heap, worklist);\n+  VEC_free (tree, heap, worklist);\n }\n /* Initialize data structures used by PRE.  */\n \n@@ -2272,7 +2285,7 @@ fini_pre (bool do_fre)\n   basic_block bb;\n   unsigned int i;\n \n-  VEC_free (tree_on_heap, inserted_exprs);\n+  VEC_free (tree, heap, inserted_exprs);\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (value_set_pool);\n   free_alloc_pool (bitmap_set_pool);"}, {"sha": "24e6b4dbeaa4da7cda41be4da665cdc6378de6cb", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -143,7 +143,7 @@ static sbitmap bb_in_list;\n    definition has changed.  SSA edges are def-use edges in the SSA\n    web.  For each D-U edge, we store the target statement or PHI node\n    U.  */\n-static GTY(()) VEC(tree) *interesting_ssa_edges;\n+static GTY(()) VEC(tree,gc) *interesting_ssa_edges;\n \n /* Identical to INTERESTING_SSA_EDGES.  For performance reasons, the\n    list of SSA edges is split into two.  One contains all SSA edges\n@@ -159,7 +159,7 @@ static GTY(()) VEC(tree) *interesting_ssa_edges;\n    don't use a separate worklist for VARYING edges, we end up with\n    situations where lattice values move from\n    UNDEFINED->INTERESTING->VARYING instead of UNDEFINED->VARYING.  */\n-static GTY(()) VEC(tree) *varying_ssa_edges;\n+static GTY(()) VEC(tree,gc) *varying_ssa_edges;\n \n \n /* Return true if the block worklist empty.  */\n@@ -244,9 +244,9 @@ add_ssa_edge (tree var, bool is_varying)\n \t{\n \t  STMT_IN_SSA_EDGE_WORKLIST (use_stmt) = 1;\n \t  if (is_varying)\n-\t    VEC_safe_push (tree, varying_ssa_edges, use_stmt);\n+\t    VEC_safe_push (tree, gc, varying_ssa_edges, use_stmt);\n \t  else\n-\t    VEC_safe_push (tree, interesting_ssa_edges, use_stmt);\n+\t    VEC_safe_push (tree, gc, interesting_ssa_edges, use_stmt);\n \t}\n     }\n }\n@@ -342,7 +342,7 @@ simulate_stmt (tree stmt)\n    SSA edge is added to it in simulate_stmt.  */\n \n static void\n-process_ssa_edge_worklist (VEC(tree) **worklist)\n+process_ssa_edge_worklist (VEC(tree,gc) **worklist)\n {\n   /* Drain the entire worklist.  */\n   while (VEC_length (tree, *worklist) > 0)\n@@ -462,8 +462,8 @@ ssa_prop_init (void)\n   size_t i;\n \n   /* Worklists of SSA edges.  */\n-  interesting_ssa_edges = VEC_alloc (tree, 20);\n-  varying_ssa_edges = VEC_alloc (tree, 20);\n+  interesting_ssa_edges = VEC_alloc (tree, gc, 20);\n+  varying_ssa_edges = VEC_alloc (tree, gc, 20);\n \n   executable_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (executable_blocks);\n@@ -506,8 +506,8 @@ ssa_prop_init (void)\n static void\n ssa_prop_fini (void)\n {\n-  VEC_free (tree, interesting_ssa_edges);\n-  VEC_free (tree, varying_ssa_edges);\n+  VEC_free (tree, gc, interesting_ssa_edges);\n+  VEC_free (tree, gc, varying_ssa_edges);\n   cfg_blocks = NULL;\n   sbitmap_free (bb_in_list);\n   sbitmap_free (executable_blocks);"}, {"sha": "1538910993e4f03cf67671b88934aba5c4051b57", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -493,7 +493,8 @@ verify_flow_sensitive_alias_info (void)\n   internal_error (\"verify_flow_sensitive_alias_info failed.\");\n }\n \n-DEF_VEC_MALLOC_P (bitmap);\n+DEF_VEC_P (bitmap);\n+DEF_VEC_ALLOC_P (bitmap,heap);\n \n /* Verify that all name tags have different points to sets.\n    This algorithm takes advantage of the fact that every variable with the\n@@ -512,8 +513,8 @@ verify_name_tags (void)\n   size_t i;  \n   size_t j;\n   bitmap first, second;  \n-  VEC (tree) *name_tag_reps = NULL;\n-  VEC (bitmap) *pt_vars_for_reps = NULL;\n+  VEC(tree,heap) *name_tag_reps = NULL;\n+  VEC(bitmap,heap) *pt_vars_for_reps = NULL;\n   bitmap type_aliases = BITMAP_ALLOC (NULL);\n \n   /* First we compute the name tag representatives and their points-to sets.  */\n@@ -539,8 +540,8 @@ verify_name_tags (void)\n       if (pi->pt_vars == NULL)\n \tcontinue;\n \n-      VEC_safe_push (tree, name_tag_reps, ptr);\n-      VEC_safe_push (bitmap, pt_vars_for_reps, pi->pt_vars);\n+      VEC_safe_push (tree, heap, name_tag_reps, ptr);\n+      VEC_safe_push (bitmap, heap, pt_vars_for_reps, pi->pt_vars);\n \n       /* Verify that alias set of PTR's type tag is a superset of the\n \t alias set of PTR's name tag.  */\n@@ -605,7 +606,10 @@ verify_name_tags (void)\n \t}\n     } \n \n-  VEC_free (bitmap, pt_vars_for_reps);\n+  /* We do not have to free the bitmaps or trees in the vectors, as\n+     they are not owned by us.  */\n+  VEC_free (bitmap, heap, pt_vars_for_reps);\n+  VEC_free (tree, heap, name_tag_reps);\n   BITMAP_FREE (type_aliases);\n   return;\n   "}, {"sha": "33d4d29f1ec10c1039a8f212dadb92a700dff9c7", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -158,8 +158,10 @@ extern const unsigned char tree_code_length[];\n \n extern const char *const tree_code_name[];\n \n-/* A garbage collected vector of trees.  */\n-DEF_VEC_GC_P(tree);\n+/* A vectors of trees.  */\n+DEF_VEC_P(tree);\n+DEF_VEC_ALLOC_P(tree,gc);\n+DEF_VEC_ALLOC_P(tree,heap);\n \n \f\n /* Classify which part of the compiler has defined a given builtin function.\n@@ -1853,13 +1855,13 @@ struct tree_binfo GTY (())\n   tree vtable;\n   tree virtuals;\n   tree vptr_field;\n-  VEC(tree) *base_accesses;\n+  VEC(tree,gc) *base_accesses;\n   tree inheritance;\n \n   tree vtt_subvtt;\n   tree vtt_vptr;\n \n-  VEC(tree) base_binfos;\n+  VEC(tree,none) base_binfos;\n };\n \n \f"}, {"sha": "9652c23a1c7f7a1976ca99c4f841435c5326c5cc", "filename": "gcc/value-prof.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -182,7 +182,7 @@ rtl_divmod_values_to_profile (rtx insn, histogram_values *values)\n \t  hist->hvalue.rtl.insn = insn;\n \t  hist->type = HIST_TYPE_POW2;\n \t  hist->hdata.pow2.may_be_other = 1;\n-\t  VEC_safe_push (histogram_value, *values, hist);\n+\t  VEC_safe_push (histogram_value, heap, *values, hist);\n \t}\n \n       /* Check whether the divisor is not in fact a constant.  */\n@@ -194,7 +194,7 @@ rtl_divmod_values_to_profile (rtx insn, histogram_values *values)\n \t  hist->hvalue.rtl.seq = NULL_RTX;\n \t  hist->hvalue.rtl.insn = insn;\n \t  hist->type = HIST_TYPE_SINGLE_VALUE;\n-\t  VEC_safe_push (histogram_value, *values, hist);\n+\t  VEC_safe_push (histogram_value, heap, *values, hist);\n \t}\n \n       /* For mod, check whether it is not often a noop (or replaceable by\n@@ -214,7 +214,7 @@ rtl_divmod_values_to_profile (rtx insn, histogram_values *values)\n \t  hist->type = HIST_TYPE_INTERVAL;\n \t  hist->hdata.intvl.int_start = 0;\n \t  hist->hdata.intvl.steps = 2;\n-\t  VEC_safe_push (histogram_value, *values, hist);\n+\t  VEC_safe_push (histogram_value, heap, *values, hist);\n \t}\n       return;\n \n@@ -305,7 +305,7 @@ insn_prefetch_values_to_profile (rtx insn, histogram_values* values)\n   hist->hvalue.rtl.seq = NULL_RTX;\n   hist->hvalue.rtl.insn = insn;\n   hist->type = HIST_TYPE_CONST_DELTA;\n-  VEC_safe_push (histogram_value, *values, hist);\n+  VEC_safe_push (histogram_value, heap, *values, hist);\n \n   return true;\n }\n@@ -330,19 +330,18 @@ rtl_find_values_to_profile (histogram_values *values)\n {\n   rtx insn;\n   unsigned i, libcall_level;\n+  histogram_value hist;\n \n   life_analysis (NULL, PROP_DEATH_NOTES);\n \n-  *values = VEC_alloc (histogram_value, 0);\n+  *values = NULL;\n   libcall_level = 0;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     rtl_values_to_profile (insn, values);\n   static_values = *values;\n \n-  for (i = 0; i < VEC_length (histogram_value, *values); i++)\n+  for (i = 0; VEC_iterate (histogram_value, *values, i, hist); i++)\n     {\n-      histogram_value hist = VEC_index (histogram_value, *values, i);\n-\n       switch (hist->type)\n \t{\n \tcase HIST_TYPE_INTERVAL:\n@@ -1665,6 +1664,8 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n       op1 = TREE_OPERAND (op, 0);\n       op2 = TREE_OPERAND (op, 1);\n \n+      VEC_reserve (histogram_value, heap, *values, 3);\n+      \n       /* Check for a special case where the divisor is power(s) of 2.\n          This is more aggressive than the RTL version, under the\n \t assumption that later phases will reduce / or % by power of 2\n@@ -1676,7 +1677,7 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n \t  hist->hvalue.tree.stmt = stmt;\n \t  hist->type = HIST_TYPE_POW2;\n \t  hist->hdata.pow2.may_be_other = 1;\n-\t  VEC_safe_push (histogram_value, *values, hist);\n+\t  VEC_quick_push (histogram_value, *values, hist);\n \t}\n \n       /* Check for the case where the divisor is the same value most\n@@ -1687,7 +1688,7 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n \t  hist->hvalue.tree.value = op2;\n \t  hist->hvalue.tree.stmt = stmt;\n \t  hist->type = HIST_TYPE_SINGLE_VALUE;\n-\t  VEC_safe_push (histogram_value, *values, hist);\n+\t  VEC_quick_push (histogram_value, *values, hist);\n \t}\n \n       /* For mod, check whether it is not often a noop (or replaceable by\n@@ -1700,7 +1701,7 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n \t  hist->type = HIST_TYPE_INTERVAL;\n \t  hist->hdata.intvl.int_start = 0;\n \t  hist->hdata.intvl.steps = 2;\n-\t  VEC_safe_push (histogram_value, *values, hist);\n+\t  VEC_quick_push (histogram_value, *values, hist);\n \t}\n       return;\n \n@@ -1725,8 +1726,9 @@ tree_find_values_to_profile (histogram_values *values)\n   block_stmt_iterator bsi;\n   tree stmt;\n   unsigned int i;\n-\n-  *values = VEC_alloc (histogram_value, 0);\n+  histogram_value hist;\n+  \n+  *values = NULL;\n   FOR_EACH_BB (bb)\n     for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n       {\n@@ -1735,10 +1737,8 @@ tree_find_values_to_profile (histogram_values *values)\n       }\n   static_values = *values;\n   \n-  for (i = 0; i < VEC_length (histogram_value, *values); i++)\n+  for (i = 0; VEC_iterate (histogram_value, *values, i, hist); i++)\n     {\n-      histogram_value hist = VEC_index (histogram_value, *values, i);\n-\n       switch (hist->type)\n         {\n \tcase HIST_TYPE_INTERVAL:\n@@ -1817,6 +1817,6 @@ bool\n value_profile_transformations (void)\n {\n   bool retval = (value_prof_hooks->value_profile_transformations) ();\n-  VEC_free (histogram_value, static_values);\n+  VEC_free (histogram_value, heap, static_values);\n   return retval;\n }"}, {"sha": "8121a089c9113681c9aa0443bde7b1819d3555db", "filename": "gcc/value-prof.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -75,9 +75,10 @@ struct histogram_value_t\n \n typedef struct histogram_value_t *histogram_value;\n \n-DEF_VEC_MALLOC_P(histogram_value);\n+DEF_VEC_P(histogram_value);\n+DEF_VEC_ALLOC_P(histogram_value,heap);\n \n-typedef VEC(histogram_value) *histogram_values;\n+typedef VEC(histogram_value,heap) *histogram_values;\n \n /* Hooks registration.  */\n extern void rtl_register_value_prof_hooks (void);"}, {"sha": "6d3f443c8f3fec52cd4eaebd6223444325d4aad6", "filename": "gcc/varasm.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -4426,17 +4426,17 @@ globalize_decl (tree decl)\n    of an alias.  This requires that the decl have been defined.  Aliases\n    that precede their definition have to be queued for later processing.  */\n \n-struct alias_pair GTY(())\n+typedef struct alias_pair GTY(())\n {\n   tree decl;\n   tree target;\n-};\n-typedef struct alias_pair *alias_pair;\n+} alias_pair;\n \n /* Define gc'd vector type.  */\n-DEF_VEC_GC_P(alias_pair);\n+DEF_VEC_O(alias_pair);\n+DEF_VEC_ALLOC_O(alias_pair,gc);\n \n-static GTY(()) VEC(alias_pair) *alias_pairs;\n+static GTY(()) VEC(alias_pair,gc) *alias_pairs;\n \n /* Given an assembly name, find the decl it is associated with.  At the\n    same time, mark it needed for cgraph.  */\n@@ -4534,7 +4534,7 @@ void\n finish_aliases_1 (void)\n {\n   unsigned i;\n-  alias_pair p;\n+  alias_pair *p;\n \n   for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n     {\n@@ -4558,12 +4558,12 @@ void\n finish_aliases_2 (void)\n {\n   unsigned i;\n-  alias_pair p;\n+  alias_pair *p;\n \n   for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n     do_assemble_alias (p->decl, p->target);\n \n-  alias_pairs = NULL;\n+  VEC_truncate (alias_pair, alias_pairs, 0);\n }\n \n /* Emit an assembler directive to make the symbol for DECL an alias to\n@@ -4610,12 +4610,9 @@ assemble_alias (tree decl, tree target)\n     do_assemble_alias (decl, target);\n   else\n     {\n-      alias_pair p;\n-\n-      p = ggc_alloc (sizeof (struct alias_pair));\n+      alias_pair *p = VEC_safe_push (alias_pair, gc, alias_pairs, NULL);\n       p->decl = decl;\n       p->target = target;\n-      VEC_safe_push (alias_pair, alias_pairs, p);\n     }\n }\n "}, {"sha": "67643b5abd29a16a49154517ad0fa8ac99503953", "filename": "gcc/vec.c", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -34,9 +34,54 @@ struct vec_prefix\n   void *vec[1];\n };\n \n-/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n-   0.  If RESERVE < 0 increase the current allocation exponentially.\n-   VEC can be NULL, to create a new vector.  */\n+/* Calculate the new ALLOC value, making sure that abs(RESERVE) slots\n+   are free.  If RESERVE < 0 grow exactly, otherwise grow\n+   exponentially.  */\n+\n+static inline unsigned\n+calculate_allocation (const struct vec_prefix *pfx, int reserve)\n+{\n+  unsigned alloc = 0;\n+  unsigned num = 0;\n+\n+  if (pfx)\n+    {\n+      alloc = pfx->alloc;\n+      num = pfx->num;\n+    }\n+  else if (!reserve)\n+    /* If there's no prefix, and we've not requested anything, then we\n+       will create a NULL vector.  */\n+    return 0;\n+  \n+  /* We must have run out of room.  */\n+  gcc_assert (alloc - num < (unsigned)(reserve < 0 ? -reserve : reserve));\n+  \n+  if (reserve < 0)\n+    /* Exact size.  */\n+    alloc = num + -reserve;\n+  else\n+    {\n+      /* Exponential growth. */\n+      if (!alloc)\n+\talloc = 4;\n+      else if (alloc < 16)\n+\t/* Double when small.  */\n+\talloc = alloc * 2;\n+      else\n+\t/* Grow slower when large.  */\n+\talloc = (alloc * 3 / 2);\n+      \n+      /* If this is still too small, set it to the right size. */\n+      if (alloc < num + reserve)\n+\talloc = num + reserve;\n+    }\n+  return alloc;\n+}\n+\n+/* Ensure there are at least abs(RESERVE) free slots in VEC.  If\n+   RESERVE < 0 grow exactly, else grow exponentially.  As a special\n+   case, if VEC is NULL, and RESERVE is 0, no vector will be created. */\n \n void *\n vec_gc_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n@@ -46,27 +91,19 @@ vec_gc_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n \t\t\t   PASS_MEM_STAT);\n }\n \n-/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n-   0.  If RESERVE < 0, increase the current allocation exponentially.\n-   VEC can be NULL, in which case a new vector is created.  The\n-   vector's trailing array is at VEC_OFFSET offset and consists of\n-   ELT_SIZE sized elements.  */\n+/* As vec_gc_p_reserve, but for object vectors.  The vector's trailing\n+   array is at VEC_OFFSET offset and consists of ELT_SIZE sized\n+   elements.  */\n \n void *\n vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n \t\t   MEM_STAT_DECL)\n {\n   struct vec_prefix *pfx = vec;\n-  unsigned alloc = pfx ? pfx->num : 0;\n-\n-  if (reserve >= 0)\n-    alloc += reserve;\n-  else if (alloc)\n-    alloc *= 2;\n-  else\n-    alloc = 4;\n-\n-  gcc_assert (!pfx || pfx->alloc < alloc);\n+  unsigned alloc = alloc = calculate_allocation (pfx, reserve);\n+  \n+  if (!alloc)\n+    return NULL;\n   \n   vec = ggc_realloc_stat (vec, vec_offset + alloc * elt_size PASS_MEM_STAT);\n   ((struct vec_prefix *)vec)->alloc = alloc;\n@@ -76,17 +113,7 @@ vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n   return vec;\n }\n \n-/* Explicitly release a vector.  */\n-\n-void\n-vec_gc_free (void *vec)\n-{\n-  ggc_free (vec);\n-}\n-\n-/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n-   0.  If RESERVE < 0 increase the current allocation exponentially.\n-   VEC can be NULL, to create a new vector.  */\n+/* As for vec_gc_p_reserve, but for heap allocated vectors.  */\n \n void *\n vec_heap_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n@@ -96,27 +123,17 @@ vec_heap_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n \t\t\t     PASS_MEM_STAT);\n }\n \n-/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n-   0.  If RESERVE < 0, increase the current allocation exponentially.\n-   VEC can be NULL, in which case a new vector is created.  The\n-   vector's trailing array is at VEC_OFFSET offset and consists of\n-   ELT_SIZE sized elements.  */\n+/* As for vec_gc_o_reserve, but for heap allocated vectors.  */\n \n void *\n vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n \t\t    MEM_STAT_DECL)\n {\n   struct vec_prefix *pfx = vec;\n-  unsigned alloc = pfx ? pfx->num : 0;\n-\n-  if (reserve >= 0)\n-    alloc += reserve;\n-  else if (alloc)\n-    alloc *= 2;\n-  else\n-    alloc = 4;\n+  unsigned alloc = calculate_allocation (pfx, reserve);\n \n-  gcc_assert (!pfx || pfx->alloc < alloc);\n+  if (!alloc)\n+    return NULL;\n   \n   vec = xrealloc (vec, vec_offset + alloc * elt_size);\n   ((struct vec_prefix *)vec)->alloc = alloc;\n@@ -126,14 +143,6 @@ vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n   return vec;\n }\n \n-/* Explicitly release a vector.  */\n-\n-void\n-vec_heap_free (void *vec)\n-{\n-  free (vec);\n-}\n-\n #if ENABLE_CHECKING\n /* Issue a vector domain error, and then fall over.  */\n "}, {"sha": "43aeb817d64034c11e5ab242cc3aa5bfd0a97350", "filename": "gcc/vec.h", "status": "modified", "additions": 418, "deletions": 336, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "patch": "@@ -37,7 +37,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    latter case the pointers are dereferenced and the objects copied\n    into the vector.  Therefore, when using a vector of pointers, the\n    objects pointed to must be long lived, but when dealing with a\n-   vector of objects, the source objects need not be.\n+   vector of objects, the source objects need not be.  The vector of\n+   pointers API is also appropriate for small register sized objects\n+   like integers.\n \n    There are both 'index' and 'iterate' accessors.  The iterator\n    returns a boolean iteration condition and updates the iteration\n@@ -63,9 +65,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    vector, if needed.  Reallocation causes an exponential increase in\n    vector size.  If you know you will be adding N elements, it would\n    be more efficient to use the reserve operation before adding the\n-   elements with the 'quick' operation.  You may also use the reserve\n-   operation with a -1 operand, to gain control over exactly when\n-   reallocation occurs.\n+   elements with the 'quick' operation.  This will ensure there are at\n+   least as many elements as you ask for, it will exponentially\n+   increase if there are too few spare slots.  If you want reserve a\n+   specific number of slots, but do not want the exponential increase\n+   (for instance, you know this is the last allocation), use a\n+   negative number for reservation.  You can also create a vector of a\n+   specific size from the get go.\n \n    You should prefer the push and pop operations, as they append and\n    remove from the end of the vector. If you need to remove several\n@@ -74,65 +80,79 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    vector.  There are two remove operations, one which preserves the\n    element ordering 'ordered_remove', and one which does not\n    'unordered_remove'.  The latter function copies the end element\n-   into the removed slot, rather than invoke a memmove operation.\n-   The 'lower_bound' function will determine where to place an item in the\n+   into the removed slot, rather than invoke a memmove operation.  The\n+   'lower_bound' function will determine where to place an item in the\n    array using insert that will maintain sorted order.\n \n-   Both garbage collected and explicitly managed vector types are\n-   creatable.  The allocation mechanism is specified when the type is\n-   defined, and is therefore part of the type.\n+   When a vector type is defined, first a non-memory managed version\n+   is created.  You can then define either or both garbage collected\n+   and heap allocated versions.  The allocation mechanism is specified\n+   when the type is defined, and is therefore part of the type.  If\n+   you need both gc'd and heap allocated versions, you still must have\n+   *exactly* one definition of the common non-memory managed base vector.\n    \n    If you need to directly manipulate a vector, then the 'address'\n    accessor will return the address of the start of the vector.  Also\n    the 'space' predicate will tell you whether there is spare capacity\n    in the vector.  You will not normally need to use these two functions.\n    \n-   Vector types are defined using a DEF_VEC_{GC,MALLOC}_{O,P}(TYPEDEF)\n-   macro, and variables of vector type are declared using a\n-   VEC(TYPEDEF) macro.  The tags GC and MALLOC specify the allocation\n-   method -- garbage collected or explicit malloc/free calls.  The\n-   characters O and P indicate whether TYPEDEF is a pointer (P) or\n-   object (O) type.\n+   Vector types are defined using a DEF_VEC_{O,P}(TYPEDEF) macro, to\n+   get the non-memory allocation version, and then a\n+   DEF_VEC_ALLOC_{O,P}(TYPEDEF,ALLOC) macro to get memory managed\n+   vectors.  Variables of vector type are declared using a\n+   VEC(TYPEDEF,ALLOC) macro.  The ALLOC argument specifies the\n+   allocation strategy, and can be either 'gc' or 'heap' for garbage\n+   collected and heap allocated respectively.  It can be 'none' to get\n+   a vector that must be explicitly allocated (for instance as a\n+   trailing array of another structure).  The characters O and P\n+   indicate whether TYPEDEF is a pointer (P) or object (O) type.  Be\n+   careful to pick the correct one, as you'll get an awkward and\n+   inefficient API if you get the wrong one.  There is a check, which\n+   results in a compile-time warning, for the P versions, but there is\n+   no check for the O versions, as that is not possible in plain C.\n \n    An example of their use would be,\n \n-   DEF_VEC_GC_P(tree);\t// define a gc'd vector of tree pointers.  This must\n-   \t\t\t// appear at file scope.\n+   DEF_VEC_P(tree);   // non-managed tree vector.\n+   DEF_VEC_ALLOC_P(tree,gc);\t// gc'd vector of tree pointers.  This must\n+   \t\t\t        // appear at file scope.\n \n    struct my_struct {\n-     VEC(tree) *v;      // A (pointer to) a vector of tree pointers.\n+     VEC(tree,gc) *v;      // A (pointer to) a vector of tree pointers.\n    };\n \n    struct my_struct *s;\n \n    if (VEC_length(tree,s->v)) { we have some contents }\n-   VEC_safe_push(tree,s->v,decl); // append some decl onto the end\n+   VEC_safe_push(tree,gc,s->v,decl); // append some decl onto the end\n    for (ix = 0; VEC_iterate(tree,s->v,ix,elt); ix++)\n      { do something with elt }\n \n */\n \n /* Macros to invoke API calls.  A single macro works for both pointer\n    and object vectors, but the argument and return types might well be\n-   different.  In each macro, TDEF is the typedef of the vector\n-   elements.  Some of these macros pass the vector, V, by reference\n-   (by taking its address), this is noted in the descriptions.  */\n+   different.  In each macro, T is the typedef of the vector elements,\n+   and A is the allocation strategy.  The allocation strategy is only\n+   present when it is required.  Some of these macros pass the vector,\n+   V, by reference (by taking its address), this is noted in the\n+   descriptions.  */\n \n /* Length of vector\n    unsigned VEC_T_length(const VEC(T) *v);\n \n    Return the number of active elements in V.  V can be NULL, in which\n    case zero is returned.  */\n \n-#define VEC_length(TDEF,V)\t(VEC_OP(TDEF,length)(V))\n+#define VEC_length(T,V)\t(VEC_OP(T,base,length)(VEC_BASE(V)))\n \n /* Get the final element of the vector.\n    T VEC_T_last(VEC(T) *v); // Pointer\n    T *VEC_T_last(VEC(T) *v); // Object\n \n    Return the final element.  If V is empty,  abort.  */\n \n-#define VEC_last(TDEF,V)\t(VEC_OP(TDEF,last)(V VEC_CHECK_INFO))\n+#define VEC_last(T,V)\t(VEC_OP(T,base,last)(VEC_BASE(V) VEC_CHECK_INFO))\n \n /* Index into vector\n    T VEC_T_index(VEC(T) *v, unsigned ix); // Pointer\n@@ -141,7 +161,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Return the IX'th element.  If IX is outside the domain of V,\n    abort.  */\n \n-#define VEC_index(TDEF,V,I)\t(VEC_OP(TDEF,index)(V,I VEC_CHECK_INFO))\n+#define VEC_index(T,V,I) (VEC_OP(T,base,index)(VEC_BASE(V),I VEC_CHECK_INFO))\n \n /* Iterate over vector\n    int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Pointer\n@@ -154,22 +174,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      for (ix = 0; VEC_iterate(T,v,ix,ptr); ix++)\n        continue;  */\n \n-#define VEC_iterate(TDEF,V,I,P)\t(VEC_OP(TDEF,iterate)(V,I,&(P)))\n+#define VEC_iterate(T,V,I,P)\t(VEC_OP(T,base,iterate)(VEC_BASE(V),I,&(P)))\n \n /* Allocate new vector.\n-   VEC(T) *VEC_T_alloc(int reserve);\n+   VEC(T,A) *VEC_T_A_alloc(int reserve);\n \n    Allocate a new vector with space for RESERVE objects.  If RESERVE\n-   is <= 0, a default number of slots are created.  */\n+   is zero, NO vector is created.  */\n \n-#define VEC_alloc(TDEF,A)\t(VEC_OP(TDEF,alloc)(A MEM_STAT_INFO))\n+#define VEC_alloc(T,A,N)\t(VEC_OP(T,A,alloc)(N MEM_STAT_INFO))\n \n /* Free a vector.\n-   void VEC_T_alloc(VEC(T) *&);\n+   void VEC_T_A_free(VEC(T,A) *&);\n \n    Free a vector and set it to NULL.  */\n \n-#define VEC_free(TDEF,V)\t(VEC_OP(TDEF,free)(&V))\n+#define VEC_free(T,A,V)\t(VEC_OP(T,A,free)(&V))\n \n /* Use these to determine the required size and initialization of a\n    vector embedded within another structure (as the final member).\n@@ -179,34 +199,34 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    \n    These allow the caller to perform the memory allocation.  */\n \n-#define VEC_embedded_size(TDEF,A)\t(VEC_OP(TDEF,embedded_size)(A))\n-#define VEC_embedded_init(TDEF,O,A)\t(VEC_OP(TDEF,embedded_init)(O,A))\n+#define VEC_embedded_size(T,N)\t (VEC_OP(T,base,embedded_size)(N))\n+#define VEC_embedded_init(T,O,N) (VEC_OP(T,base,embedded_init)(VEC_BASE(O),N))\n \n /* Determine if a vector has additional capacity.\n    \n    int VEC_T_space (VEC(T) *v,int reserve)\n \n-   If V has space for RESERVE additional entries, return nonzero.  If\n-   RESERVE is < 0, ensure there is at least one space slot.  You\n+   If V has space for RESERVE additional entries, return nonzero.  You\n    usually only need to use this if you are doing your own vector\n    reallocation, for instance on an embedded vector.  This returns\n    nonzero in exactly the same circumstances that VEC_T_reserve\n    will.  */\n \n-#define VEC_space(TDEF,V,R)\t(VEC_OP(TDEF,space)(V,R))\n+#define VEC_space(T,V,R) \\\n+\t(VEC_OP(T,base,space)(VEC_BASE(V),R VEC_CHECK_INFO))\n \n /* Reserve space.\n-   int VEC_T_reserve(VEC(T) *&v, int reserve);\n+   int VEC_T_A_reserve(VEC(T,A) *&v, int reserve);\n \n-   Ensure that V has at least RESERVE slots available, if RESERVE is\n-   >= 0.  If RESERVE < 0, ensure that there is at least one spare\n-   slot.  These differ in their reallocation behavior, the first will\n-   not create additional headroom, but the second mechanism will\n-   perform the usual exponential headroom increase.  Note this can\n-   cause V to be reallocated.  Returns nonzero iff reallocation\n-   actually occurred.  */\n+   Ensure that V has at least abs(RESERVE) slots available.  The\n+   signedness of RESERVE determines the reallocation behavior.  A\n+   negative value will not create additional headroom beyond that\n+   requested.  A positive value will create additional headroom.  Note\n+   this can cause V to be reallocated.  Returns nonzero iff\n+   reallocation actually occurred.  */\n \n-#define VEC_reserve(TDEF,V,R)\t(VEC_OP(TDEF,reserve)(&(V),R MEM_STAT_INFO))\n+#define VEC_reserve(T,A,V,R)\t\\\n+\t(VEC_OP(T,A,reserve)(&(V),R VEC_CHECK_INFO MEM_STAT_INFO))\n \n /* Push object with no reallocation\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n@@ -217,19 +237,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    case NO initialization is performed.  Aborts if there is\n    insufficient space in the vector.  */\n \n-#define VEC_quick_push(TDEF,V,O)\t\\\n-\t(VEC_OP(TDEF,quick_push)(V,O VEC_CHECK_INFO))\n+#define VEC_quick_push(T,V,O)\t\\\n+\t(VEC_OP(T,base,quick_push)(VEC_BASE(V),O VEC_CHECK_INFO))\n \n /* Push object with reallocation\n-   T *VEC_T_safe_push (VEC(T) *&v, T obj); // Pointer\n-   T *VEC_T_safe_push (VEC(T) *&v, T *obj); // Object\n+   T *VEC_T_A_safe_push (VEC(T,A) *&v, T obj); // Pointer\n+   T *VEC_T_A_safe_push (VEC(T,A) *&v, T *obj); // Object\n    \n    Push a new element onto the end, returns a pointer to the slot\n    filled in. For object vectors, the new value can be NULL, in which\n    case NO initialization is performed.  Reallocates V, if needed.  */\n \n-#define VEC_safe_push(TDEF,V,O)\t\t\\\n-\t(VEC_OP(TDEF,safe_push)(&(V),O VEC_CHECK_INFO MEM_STAT_INFO))\n+#define VEC_safe_push(T,A,V,O)\t\t\\\n+\t(VEC_OP(T,A,safe_push)(&(V),O VEC_CHECK_INFO MEM_STAT_INFO))\n \n /* Pop element off end\n    T VEC_T_pop (VEC(T) *v);\t\t// Pointer\n@@ -238,15 +258,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Pop the last element off the end. Returns the element popped, for\n    pointer vectors.  */\n \n-#define VEC_pop(TDEF,V)\t\t\t(VEC_OP(TDEF,pop)(V VEC_CHECK_INFO))\n+#define VEC_pop(T,V)\t(VEC_OP(T,base,pop)(VEC_BASE(V) VEC_CHECK_INFO))\n \n /* Truncate to specific length\n    void VEC_T_truncate (VEC(T) *v, unsigned len);\n    \n-   Set the length as specified.  This is an O(1) operation.  */\n+   Set the length as specified.  The new length must be less than or\n+   equal to the current length.  This is an O(1) operation.  */\n \n-#define VEC_truncate(TDEF,V,I)\t\t\\\n-\t(VEC_OP(TDEF,truncate)(V,I VEC_CHECK_INFO))\n+#define VEC_truncate(T,V,I)\t\t\\\n+\t(VEC_OP(T,base,truncate)(VEC_BASE(V),I VEC_CHECK_INFO))\n+\n+/* Grow to a specific length.\n+   void VEC_T_A_safe_grow (VEC(T,A) *&v, int len);\n+\n+   Grow the vector to a specific length.  The LEN must be as\n+   long or longer than the current length.  The new elements are\n+   uninitialized.  */\n+\n+#define VEC_safe_grow(T,A,V,I)\t\t\\\n+\t(VEC_OP(T,A,grow)(&(V),I VEC_CHECK_INFO))\n \n /* Replace element\n    T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Pointer\n@@ -258,8 +289,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    NULL, in which case no overwriting of the slot is actually\n    performed.  */\n \n-#define VEC_replace(TDEF,V,I,O)\t\t\\\n-\t(VEC_OP(TDEF,replace)(V,I,O VEC_CHECK_INFO))\n+#define VEC_replace(T,V,I,O)\t\t\\\n+\t(VEC_OP(T,base,replace)(VEC_BASE(V),I,O VEC_CHECK_INFO))\n \n /* Insert object with no reallocation\n    T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Pointer\n@@ -270,20 +301,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    NULL, in which case no initialization of the inserted slot takes\n    place. Aborts if there is insufficient space.  */\n \n-#define VEC_quick_insert(TDEF,V,I,O)\t\\\n-\t(VEC_OP(TDEF,quick_insert)(V,I,O VEC_CHECK_INFO))\n+#define VEC_quick_insert(T,V,I,O)\t\\\n+\t(VEC_OP(T,base,quick_insert)(VEC_BASE(V),I,O VEC_CHECK_INFO))\n \n /* Insert object with reallocation\n-   T *VEC_T_safe_insert (VEC(T) *&v, unsigned ix, T val); // Pointer\n-   T *VEC_T_safe_insert (VEC(T) *&v, unsigned ix, T *val); // Object\n+   T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Pointer\n+   T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T *val); // Object\n    \n    Insert an element, VAL, at the IXth position of V. Return a pointer\n    to the slot created.  For vectors of object, the new value can be\n    NULL, in which case no initialization of the inserted slot takes\n    place. Reallocate V, if necessary.  */\n \n-#define VEC_safe_insert(TDEF,V,I,O)\t\\\n-\t(VEC_OP(TDEF,safe_insert)(&(V),I,O VEC_CHECK_INFO MEM_STAT_INFO))\n+#define VEC_safe_insert(T,A,V,I,O)\t\\\n+\t(VEC_OP(T,A,safe_insert)(&(V),I,O VEC_CHECK_INFO MEM_STAT_INFO))\n      \n /* Remove element retaining order\n    T VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Pointer\n@@ -293,8 +324,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    remaining elements is preserved.  For pointer vectors returns the\n    removed object.  This is an O(N) operation due to a memmove.  */\n \n-#define VEC_ordered_remove(TDEF,V,I)\t\\\n-\t(VEC_OP(TDEF,ordered_remove)(V,I VEC_CHECK_INFO))\n+#define VEC_ordered_remove(T,V,I)\t\\\n+\t(VEC_OP(T,base,ordered_remove)(VEC_BASE(V),I VEC_CHECK_INFO))\n \n /* Remove element destroying order\n    T VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Pointer\n@@ -304,16 +335,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    remaining elements is destroyed.  For pointer vectors returns the\n    removed object.  This is an O(1) operation.  */\n \n-#define VEC_unordered_remove(TDEF,V,I)\t\\\n-\t(VEC_OP(TDEF,unordered_remove)(V,I VEC_CHECK_INFO))\n+#define VEC_unordered_remove(T,V,I)\t\\\n+\t(VEC_OP(T,base,unordered_remove)(VEC_BASE(V),I VEC_CHECK_INFO))\n \n /* Get the address of the array of elements\n    T *VEC_T_address (VEC(T) v)\n \n    If you need to directly manipulate the array (for instance, you\n    want to feed it to qsort), use this accessor.  */\n \n-#define VEC_address(TDEF,V)\t\t(VEC_OP(TDEF,address)(V))\n+#define VEC_address(T,V)\t\t(VEC_OP(T,base,address)(VEC_BASE(V)))\n \n /* Find the first index in the vector not less than the object.\n    unsigned VEC_T_lower_bound (VEC(T) *v, const T val, \n@@ -325,25 +356,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    changing the ordering of V.  LESSTHAN is a function that returns\n    true if the first argument is strictly less than the second.  */\n    \n-#define VEC_lower_bound(TDEF,V,O,LT)    \\\n-       (VEC_OP(TDEF,lower_bound)(V,O,LT VEC_CHECK_INFO))\n+#define VEC_lower_bound(T,V,O,LT)    \\\n+       (VEC_OP(T,base,lower_bound)(VEC_BASE(V),O,LT VEC_CHECK_INFO))\n \n #if !IN_GENGTYPE\n /* Reallocate an array of elements with prefix.  */\n extern void *vec_gc_p_reserve (void *, int MEM_STAT_DECL);\n extern void *vec_gc_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n-extern void vec_gc_free (void *);\n+extern void ggc_free (void *);\n+#define vec_gc_free(V) ggc_free (V)\n extern void *vec_heap_p_reserve (void *, int MEM_STAT_DECL);\n extern void *vec_heap_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n-extern void vec_heap_free (void *);\n+#define vec_heap_free(V) free (V)\n \n #if ENABLE_CHECKING\n #define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__\n #define VEC_CHECK_DECL ,const char *file_,unsigned line_,const char *function_\n #define VEC_CHECK_PASS ,file_,line_,function_\n      \n-#define VEC_ASSERT(EXPR,OP,TDEF) \\\n-  (void)((EXPR) ? 0 : (VEC_ASSERT_FAIL(OP,VEC(TDEF)), 0))\n+#define VEC_ASSERT(EXPR,OP,T,A) \\\n+  (void)((EXPR) ? 0 : (VEC_ASSERT_FAIL(OP,VEC(T,A)), 0))\n \n extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n      ATTRIBUTE_NORETURN;\n@@ -352,63 +384,74 @@ extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n #define VEC_CHECK_INFO\n #define VEC_CHECK_DECL\n #define VEC_CHECK_PASS\n-#define VEC_ASSERT(EXPR,OP,TYPE) (void)(EXPR)\n+#define VEC_ASSERT(EXPR,OP,T,A) (void)(EXPR)\n #endif\n \n-#define VEC(TDEF) VEC_##TDEF\n-#define VEC_OP(TDEF,OP) VEC_OP_(VEC(TDEF),OP)\n-#define VEC_OP_(VEC,OP) VEC_OP__(VEC,OP)\n-#define VEC_OP__(VEC,OP) VEC ## _ ## OP\n+#define VEC(T,A) VEC_##T##_##A\n+#define VEC_OP(T,A,OP) VEC_##T##_##A##_##OP\n #else  /* IN_GENGTYPE */\n-#define VEC(TDEF) VEC_ TDEF\n+#define VEC(T,A) VEC_ T _ A\n #define VEC_STRINGIFY(X) VEC_STRINGIFY_(X)\n #define VEC_STRINGIFY_(X) #X\n #undef GTY\n #endif /* IN_GENGTYPE */\n \n-#define VEC_TDEF(TDEF)\t\t\t\t\t\t\t  \\\n-typedef struct VEC (TDEF) GTY(())\t\t\t\t\t  \\\n+/* Base of vector type, not user visible.  */     \n+#define VEC_T(T,B)\t\t\t\t\t\t\t  \\\n+typedef struct VEC(T,B) GTY(())\t\t\t\t \t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   unsigned num;\t\t\t\t\t\t\t\t  \\\n   unsigned alloc;\t\t\t\t\t\t\t  \\\n-  TDEF GTY ((length (\"%h.num\"))) vec[1];\t\t\t\t  \\\n-} VEC (TDEF)\n+  T GTY ((length (\"%h.num\"))) vec[1];\t\t\t\t\t  \\\n+} VEC(T,B)\n+\n+/* Derived vector type, user visible.  */\n+#define VEC_TA(T,B,A,GTY)\t\t\t\t\t\t  \\\n+typedef struct VEC(T,A) GTY\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC(T,B) base;\t\t\t\t\t\t\t  \\\n+} VEC(T,A)\n+\n+/* Convert to base type.  */\n+#define VEC_BASE(P)  ((P) ? &(P)->base : 0)\n \n /* Vector of pointer to object.  */\n #if IN_GENGTYPE\n-{\"DEF_VEC_GC_P\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n-{\"DEF_VEC_MALLOC_P\", \"\", NULL},\n+{\"DEF_VEC_P\", VEC_STRINGIFY (VEC_T(#0,#1)) \";\", \"none\"},\n+{\"DEF_VEC_ALLOC_P\", VEC_STRINGIFY (VEC_TA (#0,#1,#2,#3)) \";\", NULL},\n #else\n-#define DEF_VEC_GC_P(TDEF) DEF_VEC_P(TDEF,gc)\n-#define DEF_VEC_MALLOC_P(TDEF) DEF_VEC_P(TDEF,heap)\n   \n-#define DEF_VEC_P(TDEF,a)\t\t\t\t\t\t  \\\n-VEC_TDEF (TDEF);\t\t\t\t\t\t\t  \\\n+#define DEF_VEC_P(T) \t\t\t\t\t\t\t  \\\n+VEC_T(T,base);\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (TDEF,length)\t\t\t\t  \\\n-     (const VEC (TDEF) *vec_) \t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,must,be_a_pointer_or_integer) (void) \t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  (void)((T)0 == (void *)0);\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)   \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF VEC_OP (TDEF,last)\t\t\t\t\t  \\\n-     (const VEC (TDEF) *vec_ VEC_CHECK_DECL)\t\t\t\t  \\\n+static inline T VEC_OP (T,base,last)\t\t\t\t\t  \\\n+     (const VEC(T,base) *vec_ VEC_CHECK_DECL)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && vec_->num, \"last\", TDEF);\t\t\t\t  \\\n+  VEC_ASSERT (vec_ && vec_->num, \"last\", T, base);\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF VEC_OP (TDEF,index)\t\t\t\t\t  \\\n-     (const VEC (TDEF) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t  \\\n+static inline T VEC_OP (T,base,index)\t\t\t\t\t  \\\n+     (const VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", T, base);\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return vec_->vec[ix_];\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n-     (const VEC (TDEF) *vec_, unsigned ix_, TDEF *ptr)\t\t\t  \\\n+static inline int VEC_OP (T,base,iterate)\t\t\t  \t  \\\n+     (const VEC(T,base) *vec_, unsigned ix_, T *ptr)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n@@ -422,222 +465,237 @@ static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n     }\t\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline VEC (TDEF) *VEC_OP (TDEF,alloc)\t\t\t\t  \\\n-     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC (TDEF) *) vec_##a##_p_reserve (NULL, alloc_ - !alloc_ PASS_MEM_STAT);\\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,free)\t\t\t\t\t  \\\n-     (VEC (TDEF) **vec_)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_##a##_free (*vec_);\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n+static inline size_t VEC_OP (T,base,embedded_size)\t\t\t  \\\n      (int alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return offsetof (VEC(TDEF),vec) + alloc_ * sizeof(TDEF);\t\t  \\\n+  return offsetof (VEC(T,base),vec) + alloc_ * sizeof(T);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n+static inline void VEC_OP (T,base,embedded_init)\t\t\t  \\\n+     (VEC(T,base) *vec_, int alloc_)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   vec_->num = 0;\t\t\t\t\t\t\t  \\\n   vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (TDEF,space)\t       \t\t\t\t  \\\n-     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n+static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n+     (VEC(T,base) *vec_, int alloc_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? ((vec_)->alloc - (vec_)->num\t\t\t\t  \\\n-\t\t >= (unsigned)(alloc_ < 0 ? 1 : alloc_)) : !alloc_;\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (TDEF,reserve)\t       \t\t\t\t  \\\n-     (VEC (TDEF) **vec_, int alloc_ MEM_STAT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (TDEF,space) (*vec_, alloc_);\t\t\t  \\\n-\t\t  \t\t\t\t\t\t\t  \\\n-  if (extend)\t  \t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC (TDEF) *) vec_##a##_p_reserve (*vec_, alloc_ PASS_MEM_STAT);   \\\n-\t\t  \t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\t\t\t\t  \\\n+  return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, TDEF obj_ VEC_CHECK_DECL)\t\t\t  \\\n+static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, T obj_ VEC_CHECK_DECL)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", T, base);\t\t  \\\n   slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n   *slot_ = obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n-     (VEC (TDEF) **vec_, TDEF obj_ VEC_CHECK_DECL MEM_STAT_DECL)       \t  \\\n+static inline T VEC_OP (T,base,pop) (VEC(T,base) *vec_ VEC_CHECK_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_push) (*vec_, obj_ VEC_CHECK_PASS);\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n+  T obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_ VEC_CHECK_DECL)\t    \t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  TDEF obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num, \"pop\", TDEF);\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num, \"pop\", T, base);\t\t\t\t  \\\n   obj_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,truncate)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n+static inline void VEC_OP (T,base,truncate)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", TDEF);\t  \\\n+  VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", T, base);\t  \\\n   if (vec_)\t\t\t\t\t\t\t\t  \\\n     vec_->num = size_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF VEC_OP (TDEF,replace)\t\t  \t     \t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_, TDEF obj_ VEC_CHECK_DECL)\t\t  \\\n+static inline T VEC_OP (T,base,replace)\t\t  \t     \t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  TDEF old_obj_;\t\t\t\t\t\t\t  \\\n+  T old_obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"replace\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"replace\", T, base);\t\t\t  \\\n   old_obj_ = vec_->vec[ix_];\t\t\t\t\t\t  \\\n   vec_->vec[ix_] = obj_;\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return old_obj_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (TDEF,lower_bound)\t\t\t\\\n-     (VEC (TDEF) *vec_, const TDEF obj_, bool (*lessthan_)(const TDEF, const TDEF) VEC_CHECK_DECL) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-   unsigned int len_ = VEC_OP (TDEF, length) (vec_);\t\t\t\\\n-   unsigned int half_, middle_;\t\t\t\t\t\t\\\n-   unsigned int first_ = 0;\t\t\t\t\t\t\\\n-   while (len_ > 0)\t\t\t\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\t\\\n-        TDEF middle_elem_;\t\t\t\t\t\t\\\n-        half_ = len_ >> 1;\t\t\t\t\t\t\\\n-        middle_ = first_;\t\t\t\t\t\t\\\n-        middle_ += half_;\t\t\t\t\t\t\\\n-        middle_elem_ = VEC_OP (TDEF, index) (vec_, middle_ VEC_CHECK_PASS); \\\n-        if (lessthan_ (middle_elem_, obj_))\t\t\t\t\\\n-          {\t\t\t\t\t\t\t\t\\\n-             first_ = middle_;\t\t\t\t\t\t\\\n-             ++first_;\t\t\t\t\t\t\t\\\n-             len_ = len_ - half_ - 1;\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-          len_ = half_;\t\t\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\t\\\n-   return first_;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t\\\n-     (VEC (TDEF) *vec_, unsigned ix_, TDEF obj_ VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", TDEF);\t\t\t  \\\n-  VEC_ASSERT (ix_ <= vec_->num, \"insert\", TDEF);\t\t\t  \\\n+static inline T *VEC_OP (T,base,quick_insert)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", T, base);\t\t  \\\n+  VEC_ASSERT (ix_ <= vec_->num, \"insert\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (TDEF));\t  \\\n+  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (T));\t\t  \\\n   *slot_ = obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n-     (VEC (TDEF) **vec_, unsigned ix_, TDEF obj_ \t\t\t  \\\n-\tVEC_CHECK_DECL MEM_STAT_DECL)\t\t\t\t\t  \\\n+static inline T VEC_OP (T,base,ordered_remove)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_ VEC_CHECK_PASS);\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n+  T obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n-  TDEF obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n   obj_ = *slot_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (TDEF));     \t  \\\n+  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (T));     \t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n+static inline T VEC_OP (T,base,unordered_remove)\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n-  TDEF obj_;\t\t\t\t\t\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n+  T obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n   obj_ = *slot_;\t\t\t\t\t\t\t  \\\n   *slot_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,address)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,base,address)\t\t\t\t  \\\n+     (VEC(T,base) *vec_)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n+     (VEC(T,base) *vec_, const T obj_,\t\t\t\t\t  \\\n+      bool (*lessthan_)(const T, const T) VEC_CHECK_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+   unsigned int len_ = VEC_OP (T,base, length) (vec_);\t\t\t  \\\n+   unsigned int half_, middle_;\t\t\t\t\t\t  \\\n+   unsigned int first_ = 0;\t\t\t\t\t\t  \\\n+   while (len_ > 0)\t\t\t\t\t\t\t  \\\n+     {\t\t\t\t\t\t\t\t\t  \\\n+        T middle_elem_;\t\t\t\t\t\t\t  \\\n+        half_ = len_ >> 1;\t\t\t\t\t\t  \\\n+        middle_ = first_;\t\t\t\t\t\t  \\\n+        middle_ += half_;\t\t\t\t\t\t  \\\n+        middle_elem_ = VEC_OP (T,base,index) (vec_, middle_ VEC_CHECK_PASS); \\\n+        if (lessthan_ (middle_elem_, obj_))\t\t\t\t  \\\n+          {\t\t\t\t\t\t\t\t  \\\n+             first_ = middle_;\t\t\t\t\t\t  \\\n+             ++first_;\t\t\t\t\t\t\t  \\\n+             len_ = len_ - half_ - 1;\t\t\t\t\t  \\\n+          }\t\t\t\t\t\t\t\t  \\\n+        else\t\t\t\t\t\t\t\t  \\\n+          len_ = half_;\t\t\t\t\t\t\t  \\\n+     }\t\t\t\t\t\t\t\t\t  \\\n+   return first_;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+VEC_TA(T,base,none,)\n+  \n+#define DEF_VEC_ALLOC_P(T,A)\t\t\t\t\t\t  \\\n+VEC_TA(T,base,A,);\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline VEC(T,A) *VEC_OP (T,A,alloc)\t\t\t\t  \\\n+     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  /* We must request exact size allocation, hence the negation.  */\t  \\\n+  return (VEC(T,A) *) vec_##A##_p_reserve (NULL, -alloc_ PASS_MEM_STAT);  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n+     (VEC(T,A) **vec_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (*vec_)\t\t\t\t\t\t\t\t  \\\n+    vec_##A##_free (*vec_);\t\t\t\t\t\t  \\\n+  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (T,A,reserve)\t       \t\t\t\t  \\\n+     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_),\t\t\t  \\\n+\t\t\t\t       alloc_ < 0 ? -alloc_ : alloc_\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+\t\t  \t\t\t\t\t\t\t  \\\n+  if (extend)\t  \t\t\t\t\t\t\t  \\\n+    *vec_ = (VEC(T,A) *) vec_##A##_p_reserve (*vec_, alloc_ PASS_MEM_STAT); \\\n+\t\t  \t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n+     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n+\t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n+\t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) - size_ \\\n+\t\t\tVEC_CHECK_PASS PASS_MEM_STAT);\t\t\t  \\\n+  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n+     (VEC(T,A) **vec_, T obj_ VEC_CHECK_DECL MEM_STAT_DECL)       \t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (T,base,quick_push) (VEC_BASE(*vec_), obj_ VEC_CHECK_PASS); \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n+     (VEC(T,A) **vec_, unsigned ix_, T obj_ VEC_CHECK_DECL MEM_STAT_DECL)  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n+ \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n #endif\n \n /* Vector of object.  */\n #if IN_GENGTYPE\n-{\"DEF_VEC_GC_O\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n-{\"DEF_VEC_MALLOC_O\", \"\", NULL},\n+{\"DEF_VEC_O\", VEC_STRINGIFY (VEC_T(#0,#1)) \";\", \"none\"},\n+{\"DEF_VEC_ALLOC_O\", VEC_STRINGIFY (VEC_TA(#0,#1,#2,#3)) \";\", NULL},\n #else\n   \n-#define DEF_VEC_GC_O(TDEF) DEF_VEC_O(TDEF,gc)\n-#define DEF_VEC_MALLOC_O(TDEF) DEF_VEC_O(TDEF,heap)\n-\n-#define DEF_VEC_O(TDEF,a)\t\t\t\t\t\t  \\\n-VEC_TDEF (TDEF);\t\t\t\t\t\t\t  \\\n+#define DEF_VEC_O(T)\t\t\t\t\t\t\t  \\\n+VEC_T(T,base);\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (TDEF,length)\t\t\t\t  \\\n-     (const VEC (TDEF) *vec_) \t\t\t\t\t\t  \\\n+static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,last)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_ VEC_CHECK_DECL)\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,base,last) (VEC(T,base) *vec_ VEC_CHECK_DECL)  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && vec_->num, \"last\", TDEF);\t\t\t\t  \\\n+  VEC_ASSERT (vec_ && vec_->num, \"last\", T, base);\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return &vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,index)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n+static inline T *VEC_OP (T,base,index)\t\t\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", T, base);\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return &vec_->vec[ix_];\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_, TDEF **ptr)\t\t\t  \\\n+static inline int VEC_OP (T,base,iterate)\t\t\t     \t  \\\n+     (VEC(T,base) *vec_, unsigned ix_, T **ptr)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n@@ -651,173 +709,197 @@ static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n     }\t\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline VEC (TDEF) *VEC_OP (TDEF,alloc)      \t\t\t  \\\n-     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC (TDEF) *) vec_##a##_o_reserve (NULL, alloc_ - !alloc_,\t  \\\n-                                       offsetof (VEC(TDEF),vec), sizeof (TDEF)\\\n-                                       PASS_MEM_STAT);\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,free)\t\t\t\t\t  \\\n-     (VEC (TDEF) **vec_)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_##a##_free (*vec_);\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n+static inline size_t VEC_OP (T,base,embedded_size)\t\t\t  \\\n      (int alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return offsetof (VEC(TDEF),vec) + alloc_ * sizeof(TDEF);\t\t  \\\n+  return offsetof (VEC(T,base),vec) + alloc_ * sizeof(T);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n+static inline void VEC_OP (T,base,embedded_init)\t\t\t  \\\n+     (VEC(T,base) *vec_, int alloc_)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   vec_->num = 0;\t\t\t\t\t\t\t  \\\n   vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (TDEF,space)\t       \t\t\t\t  \\\n-     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n+static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n+     (VEC(T,base) *vec_, int alloc_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? ((vec_)->alloc - (vec_)->num\t\t\t\t  \\\n-\t\t >= (unsigned)(alloc_ < 0 ? 1 : alloc_)) : !alloc_;\t  \\\n+  VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\t\t\t\t  \\\n+  return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (TDEF,reserve)\t   \t    \t\t\t  \\\n-     (VEC (TDEF) **vec_, int alloc_ MEM_STAT_DECL)\t\t\t  \\\n+static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, const T *obj_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (TDEF,space) (*vec_, alloc_);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC (TDEF) *) vec_##a##_o_reserve (*vec_, alloc_,\t\t  \\\n-\t\t\t   offsetof (VEC(TDEF),vec), sizeof (TDEF)\t  \\\n-\t\t\t   PASS_MEM_STAT);\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, const TDEF *obj_ VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", T, base);\t\t  \\\n   slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n   if (obj_)\t\t\t\t\t\t\t\t  \\\n     *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n-     (VEC (TDEF) **vec_, const TDEF *obj_ VEC_CHECK_DECL MEM_STAT_DECL)   \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_push) (*vec_, obj_ VEC_CHECK_PASS);\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_ VEC_CHECK_DECL)\t\t\t\t\t  \\\n+static inline void VEC_OP (T,base,pop) (VEC(T,base) *vec_ VEC_CHECK_DECL) \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num, \"pop\", TDEF);\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num, \"pop\", T, base);\t\t\t\t  \\\n   --vec_->num;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,truncate)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n+static inline void VEC_OP (T,base,truncate)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", TDEF);\t  \\\n+  VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", T, base);\t  \\\n   if (vec_)\t\t\t\t\t\t\t\t  \\\n     vec_->num = size_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,replace)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_, const TDEF *obj_ VEC_CHECK_DECL)\t  \\\n+static inline T *VEC_OP (T,base,replace)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_, const T *obj_ VEC_CHECK_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"replace\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"replace\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n   if (obj_)\t\t\t\t\t\t\t\t  \\\n     *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (TDEF,lower_bound)\t\t\t\\\n-     (VEC (TDEF) *vec_, const TDEF *obj_, bool (*lessthan_)(const TDEF *, const TDEF *) VEC_CHECK_DECL) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-   unsigned int len_ = VEC_OP (TDEF, length) (vec_);\t\t\t\\\n-   unsigned int half_, middle_;\t\t\t\t\t\t\\\n-   unsigned int first_ = 0;\t\t\t\t\t\t\\\n-   while (len_ > 0)\t\t\t\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\t\\\n-        TDEF *middle_elem_;\t\t\t\t\t\t\\\n-        half_ = len_ >> 1;\t\t\t\t\t\t\\\n-        middle_ = first_;\t\t\t\t\t\t\\\n-        middle_ += half_;\t\t\t\t\t\t\\\n-        middle_elem_ = VEC_OP (TDEF, index) (vec_, middle_ VEC_CHECK_PASS); \\\n-        if (lessthan_ (middle_elem_, obj_))\t\t\t\t\\\n-          {\t\t\t\t\t\t\t\t\\\n-             first_ = middle_;\t\t\t\t\t\t\\\n-             ++first_;\t\t\t\t\t\t\t\\\n-             len_ = len_ - half_ - 1;\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-          len_ = half_;\t\t\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\t\\\n-   return first_;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t\\\n-     (VEC (TDEF) *vec_, unsigned ix_, const TDEF *obj_ VEC_CHECK_DECL)\t\\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", TDEF);\t\t\t  \\\n-  VEC_ASSERT (ix_ <= vec_->num, \"insert\", TDEF);\t\t\t  \\\n+static inline T *VEC_OP (T,base,quick_insert)\t\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_, const T *obj_ VEC_CHECK_DECL)\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", T, base);\t\t  \\\n+  VEC_ASSERT (ix_ <= vec_->num, \"insert\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (TDEF));\t  \\\n+  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (T));\t\t  \\\n   if (obj_)\t\t\t\t\t\t\t\t  \\\n     *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n-     (VEC (TDEF) **vec_, unsigned ix_, const TDEF *obj_\t\t\t  \\\n- \t\tVEC_CHECK_DECL MEM_STAT_DECL)\t\t\t\t  \\\n+static inline void VEC_OP (T,base,ordered_remove)\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n+  T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_ VEC_CHECK_PASS);\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n+  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (T));\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n+static inline void VEC_OP (T,base,unordered_remove)\t\t\t  \\\n+     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n+  vec_->vec[ix_] = vec_->vec[--vec_->num];\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (TDEF));\t  \\\n+static inline T *VEC_OP (T,base,address)\t\t\t\t  \\\n+     (VEC(T,base) *vec_)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n+static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n+     (VEC(T,base) *vec_, const T *obj_,\t\t\t\t\t  \\\n+      bool (*lessthan_)(const T *, const T *) VEC_CHECK_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+   unsigned int len_ = VEC_OP (T, base, length) (vec_);\t\t\t  \\\n+   unsigned int half_, middle_;\t\t\t\t\t\t  \\\n+   unsigned int first_ = 0;\t\t\t\t\t\t  \\\n+   while (len_ > 0)\t\t\t\t\t\t\t  \\\n+     {\t\t\t\t\t\t\t\t\t  \\\n+        T *middle_elem_;\t\t\t\t\t\t  \\\n+        half_ = len_ >> 1;\t\t\t\t\t\t  \\\n+        middle_ = first_;\t\t\t\t\t\t  \\\n+        middle_ += half_;\t\t\t\t\t\t  \\\n+        middle_elem_ = VEC_OP (T,base,index) (vec_, middle_ VEC_CHECK_PASS); \\\n+        if (lessthan_ (middle_elem_, obj_))\t\t\t\t  \\\n+          {\t\t\t\t\t\t\t\t  \\\n+             first_ = middle_;\t\t\t\t\t\t  \\\n+             ++first_;\t\t\t\t\t\t\t  \\\n+             len_ = len_ - half_ - 1;\t\t\t\t\t  \\\n+          }\t\t\t\t\t\t\t\t  \\\n+        else\t\t\t\t\t\t\t\t  \\\n+          len_ = half_;\t\t\t\t\t\t\t  \\\n+     }\t\t\t\t\t\t\t\t\t  \\\n+   return first_;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+VEC_TA(T,base,none,)\n+\n+#define DEF_VEC_ALLOC_O(T,A)\t\t\t\t\t\t  \\\n+VEC_TA(T,base,A,);\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n+     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n-  vec_->vec[ix_] = vec_->vec[--vec_->num];\t\t\t\t  \\\n+  /* We must request exact size allocation, hence the negation.  */\t  \\\n+  return (VEC(T,A) *) vec_##A##_o_reserve (NULL, -alloc_,\t\t  \\\n+                                           offsetof (VEC(T,A),base.vec),  \\\n+\t\t\t\t\t   sizeof (T)\t\t\t  \\\n+                                           PASS_MEM_STAT);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,address)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n+     (VEC(T,A) **vec_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n+  if (*vec_)\t\t\t\t\t\t\t\t  \\\n+    vec_##A##_free (*vec_);\t\t\t\t\t\t  \\\n+  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n+     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_),\t\t\t  \\\n+\t\t\t\t       alloc_ < 0 ? -alloc_ : alloc_\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (extend)\t\t\t\t\t\t\t\t  \\\n+    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve (*vec_, alloc_,\t\t  \\\n+\t\t\t   \t\t      offsetof (VEC(T,A),base.vec),\\\n+ \t\t\t\t\t      sizeof (T)\t\t  \\\n+\t\t\t   \t\t      PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n+     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n+\t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n+\t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) - size_ \\\n+\t\t\tVEC_CHECK_PASS PASS_MEM_STAT);\t\t\t  \\\n+  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n+     (VEC(T,A) **vec_, const T *obj_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (T,base,quick_push) (VEC_BASE(*vec_), obj_ VEC_CHECK_PASS);  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n+     (VEC(T,A) **vec_, unsigned ix_, const T *obj_\t\t\t  \\\n+ \t\tVEC_CHECK_DECL MEM_STAT_DECL)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi"}]}