{"sha": "aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE5YTdkZDdjMjI1Mjk0N2ZiNmUyOGI4ZGE4YTVjZjhlOWNkZGU4Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-08-05T09:21:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-08-05T09:21:58Z"}, "message": "[multiple changes]\n\n2010-08-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Insert_Actions): If the action appears within a\n\tconditional expression that is already analyzed, insert action further\n\tout.\n\n2010-08-05  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb: Minor reformatting.\n\nFrom-SVN: r162907", "tree": {"sha": "f55992fa388832e857d88c10e21047fc3211650f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f55992fa388832e857d88c10e21047fc3211650f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87/comments", "author": null, "committer": null, "parents": [{"sha": "0d90129062e7e64a15adf3a0ec5120a2cf8ea7ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d90129062e7e64a15adf3a0ec5120a2cf8ea7ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d90129062e7e64a15adf3a0ec5120a2cf8ea7ee"}], "stats": {"total": 101, "additions": 61, "deletions": 40}, "files": [{"sha": "dfe74317bf8ba520564d3a35d36c8e0d6fc59d5f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87", "patch": "@@ -1,3 +1,13 @@\n+2010-08-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Insert_Actions): If the action appears within a\n+\tconditional expression that is already analyzed, insert action further\n+\tout.\n+\n+2010-08-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb: Minor reformatting.\n+\n 2010-08-05  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_ch4.adb: Minor reformatting"}, {"sha": "d60555d2b825f9b4d6a585e250677f49c85be97e", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87", "patch": "@@ -6995,14 +6995,15 @@ package body Exp_Ch4 is\n \n          begin\n             if Safe_In_Place_Array_Op (Lhs, Op1, Op2) then\n-               if N = Op1 and then Nkind (Op2) = N_Op_Not then\n-                  --  (not A) op (not B) can be reduced to a single call\n \n+               --  (not A) op (not B) can be reduced to a single call\n+\n+               if N = Op1 and then Nkind (Op2) = N_Op_Not then\n                   return;\n \n-               elsif N = Op2 and then Nkind (Parent (N)) = N_Op_Xor then\n-                  --  A xor (not B) can also be special-cased\n+               --  A xor (not B) can also be special-cased\n \n+               elsif N = Op2 and then Nkind (Parent (N)) = N_Op_Xor then\n                   return;\n                end if;\n             end if;\n@@ -7274,7 +7275,10 @@ package body Exp_Ch4 is\n \n       --  Arithmetic overflow checks for signed integer/fixed point types\n \n-      if Is_Signed_Integer_Type (Typ) or else Is_Fixed_Point_Type (Typ) then\n+      if Is_Signed_Integer_Type (Typ)\n+           or else\n+         Is_Fixed_Point_Type (Typ)\n+      then\n          Apply_Arithmetic_Overflow_Check (N);\n \n       --  VAX floating-point types case"}, {"sha": "c440852691244dbe41d2536d09cc1ecf203e9c2c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=aa9a7dd7c2252947fb6e28b8da8a5cf8e9cdde87", "patch": "@@ -814,8 +814,8 @@ package body Exp_Util is\n       Stats : constant List_Id := New_List;\n \n    begin\n-      --  For a dynamic task, the name comes from the target variable.\n-      --  For a static one it is a formal of the enclosing init proc.\n+      --  For a dynamic task, the name comes from the target variable. For a\n+      --  static one it is a formal of the enclosing init proc.\n \n       if Dyn then\n          Get_Name_String (Chars (Entity (Prefix (Id_Ref))));\n@@ -1105,8 +1105,8 @@ package body Exp_Util is\n       IR : Node_Id;\n \n    begin\n-      --  An itype reference must only be created if this is a local\n-      --  itype, so that gigi can elaborate it on the proper objstack.\n+      --  An itype reference must only be created if this is a local itype, so\n+      --  that gigi can elaborate it on the proper objstack.\n \n       if Is_Itype (Typ)\n         and then Scope (Typ) = Current_Scope\n@@ -1356,9 +1356,9 @@ package body Exp_Util is\n          pragma Assert (Is_Class_Wide_Type (Unc_Type));\n          null;\n \n-      --  In Ada95, nothing to be done if the type of the expression is\n-      --  limited, because in this case the expression cannot be copied,\n-      --  and its use can only be by reference.\n+      --  In Ada95 nothing to be done if the type of the expression is limited,\n+      --  because in this case the expression cannot be copied, and its use can\n+      --  only be by reference.\n \n       --  In Ada2005, the context can be an object declaration whose expression\n       --  is a function that returns in place. If the nominal subtype has\n@@ -1823,9 +1823,9 @@ package body Exp_Util is\n          if Nkind (Cond) = N_And_Then\n            or else Nkind (Cond) = N_Op_And\n          then\n-            --  Don't ever try to invert a condition that is of the form\n-            --  of an AND or AND THEN (since we are not doing sufficiently\n-            --  general processing to allow this).\n+            --  Don't ever try to invert a condition that is of the form of an\n+            --  AND or AND THEN (since we are not doing sufficiently general\n+            --  processing to allow this).\n \n             if Sens = False then\n                Op  := N_Empty;\n@@ -2002,8 +2002,8 @@ package body Exp_Util is\n             end;\n \n             --  ELSIF part. Condition is known true within the referenced\n-            --  ELSIF, known False in any subsequent ELSIF or ELSE part, and\n-            --  unknown before the ELSE part or after the IF statement.\n+            --  ELSIF, known False in any subsequent ELSIF or ELSE part,\n+            --  and unknown before the ELSE part or after the IF statement.\n \n          elsif Nkind (CV) = N_Elsif_Part then\n \n@@ -2386,12 +2386,19 @@ package body Exp_Util is\n                   ElseX : constant Node_Id := Next (ThenX);\n \n                begin\n-                  --  Actions belong to the then expression, temporarily\n-                  --  place them as Then_Actions of the conditional expr.\n-                  --  They will be moved to the proper place later when\n-                  --  the conditional expression is expanded.\n+                  --  If the enclosing expression is already analyzed, as\n+                  --  is the case for nested elaboration checks, insert the\n+                  --  conditional further out.\n \n-                  if N = ThenX then\n+                  if Analyzed (P) then\n+                     null;\n+\n+                  --  Actions belong to the then expression, temporarily place\n+                  --  them as Then_Actions of the conditional expr. They will\n+                  --  be moved to the proper place later when the conditional\n+                  --  expression is expanded.\n+\n+                  elsif N = ThenX then\n                      if Present (Then_Actions (P)) then\n                         Insert_List_After_And_Analyze\n                           (Last (Then_Actions (P)), Ins_Actions);\n@@ -2427,9 +2434,9 @@ package body Exp_Util is\n                   end if;\n                end;\n \n-            --  Alternative of case expression, we place the action in\n-            --  the Actions field of the case expression alternative, this\n-            --  will be handled when the case expression is expanded.\n+            --  Alternative of case expression, we place the action in the\n+            --  Actions field of the case expression alternative, this will\n+            --  be handled when the case expression is expanded.\n \n             when N_Case_Expression_Alternative =>\n                if Present (Actions (P)) then\n@@ -2464,11 +2471,11 @@ package body Exp_Util is\n                   else\n                      Set_Condition_Actions (P, Ins_Actions);\n \n-                     --  Set the parent of the insert actions explicitly.\n-                     --  This is not a syntactic field, but we need the\n-                     --  parent field set, in particular so that freeze\n-                     --  can understand that it is dealing with condition\n-                     --  actions, and properly insert the freezing actions.\n+                     --  Set the parent of the insert actions explicitly. This\n+                     --  is not a syntactic field, but we need the parent field\n+                     --  set, in particular so that freeze can understand that\n+                     --  it is dealing with condition actions, and properly\n+                     --  insert the freezing actions.\n \n                      Set_Parent (Ins_Actions, P);\n                      Analyze_List (Condition_Actions (P));\n@@ -2574,6 +2581,7 @@ package body Exp_Util is\n                --  subsequent use in the back end: within a package spec the\n                --  loop is part of the elaboration procedure and is only\n                --  elaborated during the second pass.\n+\n                --  If the loop comes from source, or the entity is local to\n                --  the loop itself it must remain within.\n \n@@ -2596,10 +2604,9 @@ package body Exp_Util is\n                   return;\n                end if;\n \n-            --  A special case, N_Raise_xxx_Error can act either as a\n-            --  statement or a subexpression. We tell the difference\n-            --  by looking at the Etype. It is set to Standard_Void_Type\n-            --  in the statement case.\n+            --  A special case, N_Raise_xxx_Error can act either as a statement\n+            --  or a subexpression. We tell the difference by looking at the\n+            --  Etype. It is set to Standard_Void_Type in the statement case.\n \n             when\n                N_Raise_xxx_Error =>\n@@ -2645,9 +2652,9 @@ package body Exp_Util is\n                            Decl : Node_Id;\n \n                         begin\n-                           --  Check whether these actions were generated\n-                           --  by a declaration that is part of the loop_\n-                           --  actions for the component_association.\n+                           --  Check whether these actions were generated by a\n+                           --  declaration that is part of the loop_ actions\n+                           --  for the component_association.\n \n                            Decl := Assoc_Node;\n                            while Present (Decl) loop\n@@ -2855,9 +2862,9 @@ package body Exp_Util is\n \n          if Nkind (Parent (N)) = N_Subunit then\n \n-            --  This is the proper body corresponding to a stub. Insertion\n-            --  must be done at the point of the stub, which is in the decla-\n-            --  rative part of the parent unit.\n+            --  This is the proper body corresponding to a stub. Insertion must\n+            --  be done at the point of the stub, which is in the declarative\n+            --  part of the parent unit.\n \n             P := Corresponding_Stub (Parent (N));\n "}]}