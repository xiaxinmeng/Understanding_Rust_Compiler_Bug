{"sha": "8b3686ed860ccf729560c6d78fee95c2fa42cea5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIzNjg2ZWQ4NjBjY2Y3Mjk1NjBjNmQ3OGZlZTk1YzJmYTQyY2VhNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-05T16:34:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-05T16:34:53Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r688", "tree": {"sha": "3841e6071bc0a5d9fe9cb6bbcdd1f96b8334d552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3841e6071bc0a5d9fe9cb6bbcdd1f96b8334d552"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b3686ed860ccf729560c6d78fee95c2fa42cea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3686ed860ccf729560c6d78fee95c2fa42cea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b3686ed860ccf729560c6d78fee95c2fa42cea5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3686ed860ccf729560c6d78fee95c2fa42cea5/comments", "author": null, "committer": null, "parents": [{"sha": "2aa8f23fc1ac90dcf0ebba82883e17a19022c088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa8f23fc1ac90dcf0ebba82883e17a19022c088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa8f23fc1ac90dcf0ebba82883e17a19022c088"}], "stats": {"total": 176, "additions": 152, "deletions": 24}, "files": [{"sha": "4552cacb2a481eb2c2c30aac4b4d0c7bebb0cfd7", "filename": "gcc/cse.c", "status": "modified", "additions": 134, "deletions": 24, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3686ed860ccf729560c6d78fee95c2fa42cea5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3686ed860ccf729560c6d78fee95c2fa42cea5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8b3686ed860ccf729560c6d78fee95c2fa42cea5", "patch": "@@ -2858,7 +2858,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  break;\n \n \tcase ABS:\n-\t  if (REAL_VALUES_LESS (d, 0.0))\n+\t  if (REAL_VALUE_NEGATIVE (d))\n \t    d = REAL_VALUE_NEGATE (d);\n \t  break;\n \n@@ -3860,7 +3860,9 @@ simplify_relational_operation (code, mode, op0, op1)\n \t    if (CONSTANT_P (op0) && op1 == const0_rtx)\n \t      return const0_rtx;\n #endif\n-\t    if (NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx)\n+\t    if (NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx\n+\t\t/* On some machines, the ap reg can be 0 sometimes.  */\n+\t\t&& op0 != arg_pointer_rtx)\n \t      return const0_rtx;\n \t    break;\n \t  }\n@@ -3871,7 +3873,9 @@ simplify_relational_operation (code, mode, op0, op1)\n \t  if (CONSTANT_P (op0) && op1 == const0_rtx)\n \t    return const_true_rtx;\n #endif\n-\t  if (NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx)\n+\t  if (NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx\n+\t      /* On some machines, the ap reg can be 0 sometimes.  */\n+\t      && op0 != arg_pointer_rtx)\n \t    return const_true_rtx;\n \t  break;\n \n@@ -6577,6 +6581,65 @@ cse_around_loop (loop_start)\n     }\n }\n \f\n+/* Variable used for communications between the next two routines.  */\n+\n+static struct write_data skipped_writes_memory;\n+\n+/* Process one SET of an insn that was skipped.  We ignore CLOBBERs\n+   since they are done elsewhere.  This function is called via note_stores.  */\n+\n+static void\n+invalidate_skipped_set (dest, set)\n+     rtx set;\n+     rtx dest;\n+{\n+  if (GET_CODE (set) == CLOBBER\n+#ifdef HAVE_cc0\n+      || dest == cc0_rtx\n+#endif\n+      || dest == pc_rtx)\n+    return;\n+\n+  if (GET_CODE (dest) == MEM)\n+    note_mem_written (dest, &skipped_writes_memory);\n+\n+  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n+      || (! skipped_writes_memory.all && ! cse_rtx_addr_varies_p (dest)))\n+    invalidate (dest);\n+}\n+\n+/* Invalidate all insns from START up to the end of the function or the\n+   next label.  This called when we wish to CSE around a block that is\n+   conditionally executed.  */\n+\n+static void\n+invalidate_skipped_block (start)\n+     rtx start;\n+{\n+  rtx insn;\n+  int i;\n+  static struct write_data init = {0, 0, 0, 0};\n+  static struct write_data everything = {0, 1, 1, 1};\n+\n+  for (insn = start; insn && GET_CODE (insn) != CODE_LABEL;\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+\n+      skipped_writes_memory = init;\n+\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  invalidate_for_call ();\n+\t  skipped_writes_memory = everything;\n+\t}\n+\n+      note_stores (PATTERN (insn), invalidate_skipped_set);\n+      invalidate_from_clobbers (&skipped_writes_memory, PATTERN (insn));\n+    }\n+}\n+\f\n /* Used for communication between the following two routines; contains a\n    value to be checked for modification.  */\n \n@@ -6706,7 +6769,7 @@ cse_set_around_loop (x, insn, loop_start)\n    The branch path indicates which branches should be followed.  If a non-zero\n    path size is specified, the block should be rescanned and a different set\n    of branches will be taken.  The branch path is only used if\n-   FLAG_CSE_FOLLOW_JUMPS is non-zero.\n+   FLAG_CSE_FOLLOW_JUMPS or FLAG_CSE_SKIP_BLOCKS is non-zero.\n \n    DATA is a pointer to a struct cse_basic_block_data, defined below, that is\n    used to describe the block.  It is filled in with the information about\n@@ -6732,17 +6795,20 @@ struct cse_basic_block_data {\n   struct branch_path {\n     /* The branch insn. */\n     rtx branch;\n-    /* Whether it should be taken or not.  */\n-    enum taken {TAKEN, NOT_TAKEN} status;\n+    /* Whether it should be taken or not.  AROUND is the same as taken\n+       except that it is used when the destination label is not preceded\n+       by a BARRIER.  */\n+    enum taken {TAKEN, NOT_TAKEN, AROUND} status;\n   } path[PATHLENGTH];\n };\n \n void\n-cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n+cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n      rtx insn;\n      struct cse_basic_block_data *data;\n      int follow_jumps;\n      int after_loop;\n+     int skip_blocks;\n {\n   rtx p = insn, q;\n   int nsets = 0;\n@@ -6757,7 +6823,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n      at least one branch must have been taken if PATH_SIZE is non-zero.  */\n   while (path_size > 0)\n     {\n-      if (data->path[path_size - 1].status == TAKEN)\n+      if (data->path[path_size - 1].status != NOT_TAKEN)\n \t{\n \t  data->path[path_size - 1].status = NOT_TAKEN;\n \t  break;\n@@ -6802,15 +6868,15 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n \tnsets += 1;\n \t\n       if (INSN_CUID (p) > high_cuid)\n-        high_cuid = INSN_CUID (p);\n+\thigh_cuid = INSN_CUID (p);\n       if (INSN_CUID (p) < low_cuid)\n-        low_cuid = INSN_CUID(p);\n+\tlow_cuid = INSN_CUID(p);\n \n       /* See if this insn is in our branch path.  If it is and we are to\n \t take it, do so.  */\n       if (path_entry < path_size && data->path[path_entry].branch == p)\n \t{\n-\t  if (data->path[path_entry].status == TAKEN)\n+\t  if (data->path[path_entry].status != NOT_TAKEN)\n \t    p = JUMP_LABEL (p);\n \t  \n \t  /* Point to next entry in path, if any.  */\n@@ -6820,8 +6886,14 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n       /* If this is a conditional jump, we can follow it if -fcse-follow-jumps\n \t was specified, we haven't reached our maximum path length, there are\n \t insns following the target of the jump, this is the only use of the\n-\t jump label, and the target label is preceded by a BARRIER.  */\n-      else if (follow_jumps && path_size < PATHLENGTH - 1\n+\t jump label, and the target label is preceded by a BARRIER.\n+\n+\t Alternatively, we can follow the jump if it branches around a\n+\t block of code and there are no other branches into the block.\n+\t In this case invalidate_skipped_block will be called to invalidate any\n+\t registers set in the block when following the jump.  */\n+\n+      else if ((follow_jumps || skip_blocks) && path_size < PATHLENGTH - 1\n \t       && GET_CODE (p) == JUMP_INSN\n       \t       && GET_CODE (PATTERN (p)) == SET\n \t       && GET_CODE (SET_SRC (PATTERN (p))) == IF_THEN_ELSE\n@@ -6837,7 +6909,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n \n \t  /* If we ran into a BARRIER, this code is an extension of the\n \t     basic block when the branch is taken.  */\n-\t  if (q != 0 && GET_CODE (q) == BARRIER)\n+\t  if (follow_jumps && q != 0 && GET_CODE (q) == BARRIER)\n \t    {\n \t      /* Don't allow ourself to keep walking around an\n \t\t always-executed loop.  */\n@@ -6865,8 +6937,40 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n \t      /* Mark block so we won't scan it again later.  */\n \t      PUT_MODE (NEXT_INSN (p), QImode);\n \t    }\n+\t  /* Detect a branch around a block of code.  */\n+\t  else if (skip_blocks && q != 0 && GET_CODE (q) != CODE_LABEL)\n+\t    {\n+\t      register rtx tmp;\n+\n+\t      if (next_real_insn (q) == next_real_insn (insn))\n+\t\tbreak;\n+\n+\t      for (i = 0; i < path_entry; i++)\n+\t\tif (data->path[i].branch == p)\n+\t\t  break;\n+\n+\t      if (i != path_entry)\n+\t\tbreak;\n+\n+\t      /* This is no_labels_between_p (p, q) with an added check for\n+\t\t reaching the end of a function (in case Q precedes P).  */\n+\t      for (tmp = NEXT_INSN (p); tmp && tmp != q; tmp = NEXT_INSN (tmp))\n+\t\tif (GET_CODE (tmp) == CODE_LABEL)\n+\t\t  break;\n+\t      \n+\t      if (tmp == q)\n+\t\t{\n+\t\t  data->path[path_entry].branch = p;\n+\t\t  data->path[path_entry++].status = AROUND;\n+\n+\t\t  path_size = path_entry;\n+\n+\t\t  p = JUMP_LABEL (p);\n+\t\t  /* Mark block so we won't scan it again later.  */\n+\t\t  PUT_MODE (NEXT_INSN (p), QImode);\n+\t\t}\n+\t    }\n \t}\n-\t\n       p = NEXT_INSN (p);\n     }\n \n@@ -6878,7 +6982,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n   /* If all jumps in the path are not taken, set our path length to zero\n      so a rescan won't be done.  */\n   for (i = path_size - 1; i >= 0; i--)\n-    if (data->path[i].status == TAKEN)\n+    if (data->path[i].status != NOT_TAKEN)\n       break;\n \n   if (i == -1)\n@@ -6998,9 +7102,8 @@ cse_main (f, nregs, after_loop, file)\n   insn = f;\n   while (insn)\n     {\n-      int tem;\n-\n-      cse_end_of_basic_block (insn, &val, flag_cse_follow_jumps, after_loop);\n+      cse_end_of_basic_block (insn, &val, flag_cse_follow_jumps, after_loop,\n+\t\t\t      flag_cse_skip_blocks);\n \n       /* If this basic block was already processed or has no sets, skip it.  */\n       if (val.nsets == 0 || GET_MODE (insn) == QImode)\n@@ -7042,7 +7145,8 @@ cse_main (f, nregs, after_loop, file)\n \t     us a new branch path to investigate.  */\n \t  cse_jumps_altered = 0;\n \t  temp = cse_basic_block (insn, val.last, val.path, ! after_loop);\n-\t  if (cse_jumps_altered == 0 || flag_cse_follow_jumps == 0)\n+\t  if (cse_jumps_altered == 0\n+\t      || (flag_cse_follow_jumps == 0 && flag_cse_skip_blocks == 0))\n \t    insn = temp;\n \n \t  cse_jumps_altered |= old_cse_jumps_altered;\n@@ -7116,9 +7220,14 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t to be taken, do so.  */\n       if (next_branch->branch == insn)\n \t{\n-\t  if (next_branch++->status == TAKEN)\n+\t  enum taken status = next_branch++->status;\n+\t  if (status != NOT_TAKEN)\n \t    {\n-\t      record_jump_equiv (insn, 1);\n+\t      if (status == TAKEN)\n+\t\trecord_jump_equiv (insn, 1);\n+\t      else\n+\t\tinvalidate_skipped_block (NEXT_INSN (insn));\n+\n \t      /* Set the last insn as the jump insn; it doesn't affect cc0.\n \t\t Then follow this branch.  */\n #ifdef HAVE_cc0\n@@ -7200,7 +7309,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n \t  to_usage = 0;\n \t  val.path_size = 0;\n-\t  cse_end_of_basic_block (insn, &val, 0, 0);\n+\t  cse_end_of_basic_block (insn, &val, 0, 0, 0);\n \n \t  /* If the tables we allocated have enough space left\n \t     to handle all the SETs in the next basic block,\n@@ -7230,7 +7339,8 @@ cse_basic_block (from, to, next_branch, around_loop)\n      we can cse into the loop.  Don't do this if we changed the jump\n      structure of a loop unless we aren't going to be following jumps.  */\n \n-  if ((cse_jumps_altered == 0 || flag_cse_follow_jumps == 0)\n+  if ((cse_jumps_altered == 0\n+       || (flag_cse_follow_jumps == 0 && flag_cse_skip_blocks == 0))\n       && around_loop && to != 0\n       && GET_CODE (to) == NOTE && NOTE_LINE_NUMBER (to) == NOTE_INSN_LOOP_END\n       && GET_CODE (PREV_INSN (to)) == JUMP_INSN"}, {"sha": "868b3e3f423db73329ab0814039baeadcc9e729b", "filename": "gcc/flags.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3686ed860ccf729560c6d78fee95c2fa42cea5/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3686ed860ccf729560c6d78fee95c2fa42cea5/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=8b3686ed860ccf729560c6d78fee95c2fa42cea5", "patch": "@@ -192,6 +192,11 @@ extern int flag_unroll_all_loops;\n \n extern int flag_cse_follow_jumps;\n \n+/* Nonzero for -fcse-skip-blocks:\n+   have cse follow a branch around a block.  */\n+\n+extern int flag_cse_skip_blocks;\n+\n /* Nonzero for -fexpensive-optimizations:\n    perform miscellaneous relatively-expensive optimizations.  */\n extern int flag_expensive_optimizations;\n@@ -220,6 +225,13 @@ extern int flag_no_peephole;\n \n extern int flag_volatile;\n \n+/* Nonzero allows GCC to violate some IEEE or ANSI rules regarding math\n+   operations in the interest of optimization.  For example it allows\n+   GCC to assume arguments to sqrt are nonnegative numbers, allowing\n+   faster code for sqrt to be generated. */\n+\n+extern int flag_fast_math;\n+\n /* Nonzero means make functions that look like good inline candidates\n    go inline.  */\n "}, {"sha": "eb1d278931ae7484b47a1de852c1000eac18b060", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3686ed860ccf729560c6d78fee95c2fa42cea5/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3686ed860ccf729560c6d78fee95c2fa42cea5/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8b3686ed860ccf729560c6d78fee95c2fa42cea5", "patch": "@@ -293,6 +293,10 @@ int flag_float_store = 0;\n \n int flag_cse_follow_jumps;\n \n+/* Nonzero for -fcse-skip-blocks:\n+   have cse follow a branch around a block.  */\n+int flag_cse_skip_blocks;\n+\n /* Nonzero for -fexpensive-optimizations:\n    perform miscellaneous relatively-expensive optimizations.  */\n int flag_expensive_optimizations;\n@@ -451,6 +455,7 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"defer-pop\", &flag_defer_pop, 1},\n   {\"omit-frame-pointer\", &flag_omit_frame_pointer, 1},\n   {\"cse-follow-jumps\", &flag_cse_follow_jumps, 1},\n+  {\"cse-skip-blocks\", &flag_cse_skip_blocks, 1},\n   {\"expensive-optimizations\", &flag_expensive_optimizations, 1},\n   {\"thread-jumps\", &flag_thread_jumps, 1},\n   {\"strength-reduce\", &flag_strength_reduce, 1},\n@@ -2593,6 +2598,7 @@ main (argc, argv, envp)\n   if (optimize >= 2)\n     {\n       flag_cse_follow_jumps = 1;\n+      flag_cse_skip_blocks = 1;\n       flag_expensive_optimizations = 1;\n       flag_strength_reduce = 1;\n       flag_rerun_cse_after_loop = 1;"}]}