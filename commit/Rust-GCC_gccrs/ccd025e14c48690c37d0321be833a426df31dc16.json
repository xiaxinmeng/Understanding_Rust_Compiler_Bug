{"sha": "ccd025e14c48690c37d0321be833a426df31dc16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NkMDI1ZTE0YzQ4NjkwYzM3ZDAzMjFiZTgzM2E0MjZkZjMxZGMxNg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-14T16:47:29Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-14T16:47:29Z"}, "message": "re PR target/47440 (Use LCM for vzeroupper insertion)\n\n\tPR target/47440\n\t* config/i386/i386.c (gate_insert_vzeroupper): New function.\n\t(rest_of_handle_insert_vzeroupper): Ditto.\n\t(struct rtl_opt_pass pass_insert_vzeroupper): New.\n\t(ix86_option_override): Register vzeroupper insertion pass here.\n\t(ix86_check_avx256_register): Handle SUBREGs properly.\n\t(ix86_init_machine_status): Remove optimize_mode_switching[AVX_U128]\n\tinitialization.\n\nFrom-SVN: r193503", "tree": {"sha": "9eb889b6be492f22eadd41a5196d71dd58d641e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9eb889b6be492f22eadd41a5196d71dd58d641e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccd025e14c48690c37d0321be833a426df31dc16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd025e14c48690c37d0321be833a426df31dc16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd025e14c48690c37d0321be833a426df31dc16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd025e14c48690c37d0321be833a426df31dc16/comments", "author": null, "committer": null, "parents": [{"sha": "9e81cc8bdec038bfed40030f487580437d2d6f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e81cc8bdec038bfed40030f487580437d2d6f66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e81cc8bdec038bfed40030f487580437d2d6f66"}], "stats": {"total": 83, "additions": 77, "deletions": 6}, "files": [{"sha": "9d31d63164e345c96d977ad671ae1e93ac751a80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd025e14c48690c37d0321be833a426df31dc16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd025e14c48690c37d0321be833a426df31dc16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccd025e14c48690c37d0321be833a426df31dc16", "patch": "@@ -1,3 +1,15 @@\n+2012-11-14  Uros Bizjak  <ubizjak@gmail.com>\n+\t    Vladimir Yakovlev  <vladimir.b.yakovlev@intel.com>\n+\n+\tPR target/47440\n+\t* config/i386/i386.c (gate_insert_vzeroupper): New function.\n+\t(rest_of_handle_insert_vzeroupper): Ditto.\n+\t(struct rtl_opt_pass pass_insert_vzeroupper): New.\n+\t(ix86_option_override): Register vzeroupper insertion pass here.\n+\t(ix86_check_avx256_register): Handle SUBREGs properly.\n+\t(ix86_init_machine_status): Remove optimize_mode_switching[AVX_U128]\n+\tinitialization.\n+\n 2012-11-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure.ac (HAVE_LD_LARGE_TOC): Add AIX test.\n@@ -34,8 +46,8 @@\n \n \t* cgraph.c (insert_new_cgraph_node_version): Use cgraph_get_node\n \tinstead of cgraph_get_create_node.\n-\t* config/i386/i386.c (ix86_get_function_versions_dispatcher): Move ifunc\n-\tnot supported code to the end.\n+\t* config/i386/i386.c (ix86_get_function_versions_dispatcher): Move\n+\tifunc not supported code to the end.\n \n 2012-11-13  Martin Jambor  <mjambor@suse.cz>\n "}, {"sha": "c295849506f23cdca86aa132386191229eff5a4d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd025e14c48690c37d0321be833a426df31dc16/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd025e14c48690c37d0321be833a426df31dc16/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ccd025e14c48690c37d0321be833a426df31dc16", "patch": "@@ -2301,6 +2301,52 @@ static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =\n   \"btver2\"\n };\n \f\n+static bool\n+gate_insert_vzeroupper (void)\n+{\n+  return TARGET_VZEROUPPER;\n+}\n+\n+static unsigned int\n+rest_of_handle_insert_vzeroupper (void)\n+{\n+  int i;\n+\n+  /* vzeroupper instructions are inserted immediately after reload to\n+     account for possible spills from 256bit registers.  The pass\n+     reuses mode switching infrastructure by re-running mode insertion\n+     pass, so disable entities that have already been processed.  */\n+  for (i = 0; i < MAX_386_ENTITIES; i++)\n+    ix86_optimize_mode_switching[i] = 0;\n+\n+  ix86_optimize_mode_switching[AVX_U128] = 1;\n+\n+  /* Call optimize_mode_switching.  */\n+  pass_mode_switching.pass.execute ();\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_insert_vzeroupper =\n+{\n+ {\n+  RTL_PASS,\n+  \"vzeroupper\",\t\t\t\t/* name */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  gate_insert_vzeroupper,\t\t/* gate */\n+  rest_of_handle_insert_vzeroupper,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+ }\n+};\n+\n /* Return true if a red-zone is in use.  */\n \n static inline bool\n@@ -3705,7 +3751,16 @@ ix86_option_override_internal (bool main_args_p)\n static void\n ix86_option_override (void)\n {\n+  static struct register_pass_info insert_vzeroupper_info\n+    = { &pass_insert_vzeroupper.pass, \"reload\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n+\n   ix86_option_override_internal (true);\n+\n+\n+  /* This needs to be done at start up.  It's convenient to do it here.  */\n+  register_pass (&insert_vzeroupper_info);\n }\n \n /* Update register usage after having seen the compiler flags.  */\n@@ -14988,10 +15043,15 @@ output_387_binary_op (rtx insn, rtx *operands)\n /* Check if a 256bit AVX register is referenced inside of EXP.   */\n \n static int\n-ix86_check_avx256_register (rtx *exp, void *data ATTRIBUTE_UNUSED)\n+ix86_check_avx256_register (rtx *pexp, void *data ATTRIBUTE_UNUSED)\n {\n-  if (REG_P (*exp)\n-      && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (*exp)))\n+  rtx exp = *pexp;\n+\n+  if (GET_CODE (exp) == SUBREG)\n+    exp = SUBREG_REG (exp);\n+\n+  if (REG_P (exp)\n+      && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (exp)))\n     return 1;\n \n   return 0;\n@@ -23449,7 +23509,6 @@ ix86_init_machine_status (void)\n   f = ggc_alloc_cleared_machine_function ();\n   f->use_fast_prologue_epilogue_nregs = -1;\n   f->call_abi = ix86_abi;\n-  f->optimize_mode_switching[AVX_U128] = TARGET_VZEROUPPER;\n \n   return f;\n }"}]}