{"sha": "f691d19f9ea8b226618fb4151f76634fa02472a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY5MWQxOWY5ZWE4YjIyNjYxOGZiNDE1MWY3NjYzNGZhMDI0NzJhNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T10:52:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T10:52:21Z"}, "message": "[multiple changes]\n\n2012-07-16  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* ug_words, vms_data.ads: Document VMS qualifiers for -gnatn1/2\n\tswitches.\n\n2012-07-16  Bob Duff  <duff@adacore.com>\n\n\t* sinfo.ads: Minor comment fix.\n\n2012-07-16  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Within_Elaborate_All): Walk the with clauses to\n\tfind pragmas Elaborate_All that may be found in the transitive\n\tclosure of the dependences.\n\nFrom-SVN: r189517", "tree": {"sha": "fe8eec7db48cd1a7df5fca29ad7d51f10ab88bff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe8eec7db48cd1a7df5fca29ad7d51f10ab88bff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f691d19f9ea8b226618fb4151f76634fa02472a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f691d19f9ea8b226618fb4151f76634fa02472a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f691d19f9ea8b226618fb4151f76634fa02472a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f691d19f9ea8b226618fb4151f76634fa02472a4/comments", "author": null, "committer": null, "parents": [{"sha": "b3408631f73de20a78f649af7da59b19580a0d8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3408631f73de20a78f649af7da59b19580a0d8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3408631f73de20a78f649af7da59b19580a0d8c"}], "stats": {"total": 183, "additions": 142, "deletions": 41}, "files": [{"sha": "7634f5974273b31ee955cddbdc177fdd1ca81f8d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f691d19f9ea8b226618fb4151f76634fa02472a4", "patch": "@@ -1,3 +1,18 @@\n+2012-07-16  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* ug_words, vms_data.ads: Document VMS qualifiers for -gnatn1/2\n+\tswitches.\n+\n+2012-07-16  Bob Duff  <duff@adacore.com>\n+\n+\t* sinfo.ads: Minor comment fix.\n+\n+2012-07-16  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Within_Elaborate_All): Walk the with clauses to\n+\tfind pragmas Elaborate_All that may be found in the transitive\n+\tclosure of the dependences.\n+\n 2012-07-16  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_pakd.adb, freeze.adb, sem_util.adb, vms_data.ads: Minor"}, {"sha": "d1b5f7c6b55a4c9f7e336c77e5f7d2f2c0ba828a", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 112, "deletions": 36, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=f691d19f9ea8b226618fb4151f76634fa02472a4", "patch": "@@ -325,11 +325,13 @@ package body Sem_Elab is\n    --  Given two scopes E1 and E2, returns True if E1 is equal to E2, or is one\n    --  of its contained scopes, False otherwise.\n \n-   function Within_Elaborate_All (E : Entity_Id) return Boolean;\n-   --  Before emitting a warning on a scope E for a missing elaborate_all,\n-   --  check whether E may be in the context of a directly visible unit U to\n-   --  which the pragma applies. This prevents spurious warnings when the\n-   --  called entity is renamed within U.\n+   function Within_Elaborate_All\n+     (Unit : Unit_Number_Type;\n+      E    : Entity_Id) return Boolean;\n+   --  Return True if we are within the scope of an Elaborate_All for E, or if\n+   --  we are within the scope of an Elaborate_All for some other unit U, and U\n+   --  with's E. This prevents spurious warnings when the called entity is\n+   --  renamed within U, or in case of generic instances.\n \n    --------------------------------------\n    -- Activate_Elaborate_All_Desirable --\n@@ -831,7 +833,7 @@ package body Sem_Elab is\n             end loop;\n          end if;\n \n-         if Within_Elaborate_All (E_Scope) then\n+         if Within_Elaborate_All (Current_Sem_Unit, E_Scope) then\n             return;\n          end if;\n \n@@ -1229,9 +1231,8 @@ package body Sem_Elab is\n \n       P := Parent (N);\n       while Present (P) loop\n-         if Nkind (P) = N_Parameter_Specification\n-              or else\n-            Nkind (P) = N_Component_Declaration\n+         if Nkind_In (P, N_Parameter_Specification,\n+                         N_Component_Declaration)\n          then\n             return;\n \n@@ -3282,46 +3283,121 @@ package body Sem_Elab is\n    -- Within_Elaborate_All --\n    --------------------------\n \n-   function Within_Elaborate_All (E : Entity_Id) return Boolean is\n-      Item    : Node_Id;\n-      Item2   : Node_Id;\n-      Elab_Id : Entity_Id;\n-      Par     : Node_Id;\n+   function Within_Elaborate_All\n+     (Unit : Unit_Number_Type;\n+      E    : Entity_Id) return Boolean\n+   is\n+      type Unit_Number_Set is array (Main_Unit .. Last_Unit) of Boolean;\n+      pragma Pack (Unit_Number_Set);\n \n-   begin\n-      Item := First (Context_Items (Cunit (Current_Sem_Unit)));\n-      while Present (Item) loop\n-         if Nkind (Item) = N_Pragma\n-           and then Pragma_Name (Item) = Name_Elaborate_All\n-         then\n-            --  Return if some previous error on the pragma itself\n+      Seen : Unit_Number_Set := (others => False);\n+      --  Seen (X) is True after we have seen unit X in the walk. This is used\n+      --  to prevent processing the same unit more than once.\n \n-            if Error_Posted (Item) then\n-               return False;\n+      Result : Boolean := False;\n+\n+      procedure Helper (Unit : Unit_Number_Type);\n+      --  This helper procedure does all the work for Within_Elaborate_All. It\n+      --  walks the dependency graph, and sets Result to True if it finds an\n+      --  appropriate Elaborate_All.\n+\n+      ------------\n+      -- Helper --\n+      ------------\n+\n+      procedure Helper (Unit : Unit_Number_Type) is\n+         CU : constant Node_Id := Cunit (Unit);\n+\n+         Item    : Node_Id;\n+         Item2   : Node_Id;\n+         Elab_Id : Entity_Id;\n+         Par     : Node_Id;\n+\n+      begin\n+         if Seen (Unit) then\n+            return;\n+         else\n+            Seen (Unit) := True;\n+         end if;\n+\n+         --  First, check for Elaborate_Alls on this unit\n+\n+         Item := First (Context_Items (CU));\n+         while Present (Item) loop\n+            if Nkind (Item) = N_Pragma\n+              and then Pragma_Name (Item) = Name_Elaborate_All\n+            then\n+               --  Return if some previous error on the pragma itself\n+\n+               if Error_Posted (Item) then\n+                  return;\n+               end if;\n+\n+               Elab_Id :=\n+                 Entity\n+                   (Expression (First (Pragma_Argument_Associations (Item))));\n+\n+               if E = Elab_Id then\n+                  Result := True;\n+                  return;\n+               end if;\n+\n+               Par := Parent (Unit_Declaration_Node (Elab_Id));\n+\n+               Item2 := First (Context_Items (Par));\n+               while Present (Item2) loop\n+                  if Nkind (Item2) = N_With_Clause\n+                    and then Entity (Name (Item2)) = E\n+                    and then not Limited_Present (Item2)\n+                  then\n+                     Result := True;\n+                     return;\n+                  end if;\n+\n+                  Next (Item2);\n+               end loop;\n             end if;\n \n-            Elab_Id :=\n-              Entity\n-                (Expression (First (Pragma_Argument_Associations (Item))));\n+            Next (Item);\n+         end loop;\n \n-            Par := Parent (Unit_Declaration_Node (Elab_Id));\n+         --  Second, recurse on with's. We could do this as part of the above\n+         --  loop, but it's probably more efficient to have two loops, because\n+         --  the relevant Elaborate_All is likely to be on the initial unit. In\n+         --  other words, we're walking the with's breadth-first. This part is\n+         --  only necessary in the dynamic elaboration model.\n \n-            Item2 := First (Context_Items (Par));\n-            while Present (Item2) loop\n-               if Nkind (Item2) = N_With_Clause\n-                 and then Entity (Name (Item2)) = E\n+         if Dynamic_Elaboration_Checks then\n+            Item := First (Context_Items (CU));\n+            while Present (Item) loop\n+               if Nkind (Item) = N_With_Clause\n+                 and then not Limited_Present (Item)\n                then\n-                  return True;\n+                  --  Note: the following call to Get_Cunit_Unit_Number does a\n+                  --  linear search, which could be slow, but it's OK because\n+                  --  we're about to give a warning anyway. Also, there might\n+                  --  be hundreds of units, but not millions. If it turns out\n+                  --  to be a problem, we could store the Get_Cunit_Unit_Number\n+                  --  in each N_Compilation_Unit node, but that would involve\n+                  --  rearranging N_Compilation_Unit_Aux to make room.\n+\n+                  Helper (Get_Cunit_Unit_Number (Library_Unit (Item)));\n+\n+                  if Result then\n+                     return;\n+                  end if;\n                end if;\n \n-               Next (Item2);\n+               Next (Item);\n             end loop;\n          end if;\n+      end Helper;\n \n-         Next (Item);\n-      end loop;\n+   --  Start of processing for Within_Elaborate_All\n \n-      return False;\n+   begin\n+      Helper (Unit);\n+      return Result;\n    end Within_Elaborate_All;\n \n end Sem_Elab;"}, {"sha": "ec8e9aedeffdada553836e8bd9706019401688ec", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f691d19f9ea8b226618fb4151f76634fa02472a4", "patch": "@@ -5796,18 +5796,21 @@ package Sinfo is\n       --  Unreferenced_In_Spec (Flag7-Sem)\n       --  No_Entities_Ref_In_Spec (Flag8-Sem)\n \n-      --  Note: Limited_Present and Limited_View_Installed give support to\n-      --        Ada 2005 (AI-50217).\n-      --  Similarly, Private_Present gives support to AI-50262.\n+      --  Note: Limited_Present and Limited_View_Installed are used to support\n+      --  the implementation of Ada 2005 (AI-50217).\n+\n+      --  Similarly, Private_Present is used to support the implementation of\n+      --  Ada 2005 (AI-50262).\n \n       ----------------------\n       -- With_Type clause --\n       ----------------------\n \n       --  This is a GNAT extension, used to implement mutually recursive\n       --  types declared in different packages.\n+\n       --  Note: this is now obsolete. The functionality of this construct\n-      --  is now implemented by the Ada 2005 Limited_with_Clause.\n+      --  is now implemented by the Ada 2005 limited_with_clause.\n \n       ---------------------\n       -- 10.2  Body stub --"}, {"sha": "29c4ee0f21e1f8591320cf94d48c897eb163bf9f", "filename": "gcc/ada/ug_words", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fug_words", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fug_words", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fug_words?ref=f691d19f9ea8b226618fb4151f76634fa02472a4", "patch": "@@ -84,6 +84,8 @@ gcc -c          ^ GNAT COMPILE\n -gnatm          ^ /ERROR_LIMIT\n -gnatm2         ^ /ERROR_LIMIT=2\n -gnatn          ^ /INLINE=PRAGMA\n+-gnatn1         ^ /INLINE=PRAGMA_LEVEL_1\n+-gnatn2         ^ /INLINE=PRAGMA_LEVEL_2\n -gnatN          ^ /INLINE=FULL\n -gnato          ^ /CHECKS=OVERFLOW\n -gnatp          ^ /CHECKS=SUPPRESS_ALL"}, {"sha": "80c6eaf641cc47e03e222043882682127a8e7c9d", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691d19f9ea8b226618fb4151f76634fa02472a4/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=f691d19f9ea8b226618fb4151f76634fa02472a4", "patch": "@@ -1826,8 +1826,13 @@ package VMS_Data is\n    --                    (/OPTIMIZE=SOME) or higher (/OPTIMIZE=UNROLL_LOOPS)\n    --                    levels of optimization.\n    --\n-   --        PRAGMA_LEVEL_1/2 not documented ???\n+   --        PRAGMA_LEVEL_1\n+   --                    Direct control of the level of \"Inline\" pragmas\n+   --                    optimization with moderate inlining across modules.\n    --\n+   --        PRAGMA_LEVEL_2\n+   --                    Direct control of the level of \"Inline\" pragmas\n+   --                    optimization with full inlining across modules.\n    --\n    --        FULL        Front end inlining. The front end inlining activated\n    --                    by this switch is generally more extensive, and quite"}]}