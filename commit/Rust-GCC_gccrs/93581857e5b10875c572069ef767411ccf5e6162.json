{"sha": "93581857e5b10875c572069ef767411ccf5e6162", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM1ODE4NTdlNWIxMDg3NWM1NzIwNjllZjc2NzQxMWNjZjVlNjE2Mg==", "commit": {"author": {"name": "Mark Shinwell", "email": "shinwell@codesourcery.com", "date": "2008-06-15T06:29:06Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2008-06-15T06:29:06Z"}, "message": "mips-modes.def: Add V8QI, V4HI and V2SI modes.\n\n2008-06-15  Mark Shinwell  <shinwell@codesourcery.com>\n\t    Nathan Sidwell  <nathan@codesourcery.com>\n\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n\t    Richard Sandiford  <rdsandiford@googlemail.com>\n\t\n\t* config/mips/mips-modes.def: Add V8QI, V4HI and V2SI modes.\n\t* config/mips/mips-protos.h (mips_expand_vector_init): New.\n\t* config/mips/mips-ftypes.def: Add function types for Loongson-2E/2F\n\tbuiltins.\n\t* config/mips/mips.c (mips_split_doubleword_move): Handle new modes.\n\t(mips_hard_regno_mode_ok_p): Allow 64-bit vector modes for Loongson.\n\t(mips_vector_mode_supported_p): Add V2SImode, V4HImode and\n\tV8QImode cases.\n\t(LOONGSON_BUILTIN, LOONGSON_BUILTIN_ALIAS): New.\n\t(CODE_FOR_loongson_packsswh, CODE_FOR_loongson_packsshb,\n\t(CODE_FOR_loongson_packushb, CODE_FOR_loongson_paddw,\n\t(CODE_FOR_loongson_paddh, CODE_FOR_loongson_paddb,\n\t(CODE_FOR_loongson_paddsh, CODE_FOR_loongson_paddsb)\n\t(CODE_FOR_loongson_paddush, CODE_FOR_loongson_paddusb)\n\t(CODE_FOR_loongson_pmaxsh, CODE_FOR_loongson_pmaxub)\n\t(CODE_FOR_loongson_pminsh, CODE_FOR_loongson_pminub)\n\t(CODE_FOR_loongson_pmulhuh, CODE_FOR_loongson_pmulhh)\n\t(CODE_FOR_loongson_biadd, CODE_FOR_loongson_psubw)\n\t(CODE_FOR_loongson_psubh, CODE_FOR_loongson_psubb)\n\t(CODE_FOR_loongson_psubsh, CODE_FOR_loongson_psubsb)\n\t(CODE_FOR_loongson_psubush, CODE_FOR_loongson_psubusb)\n\t(CODE_FOR_loongson_punpckhbh, CODE_FOR_loongson_punpckhhw)\n\t(CODE_FOR_loongson_punpckhwd, CODE_FOR_loongson_punpcklbh)\n\t(CODE_FOR_loongson_punpcklhw, CODE_FOR_loongson_punpcklwd): New.\n\t(mips_builtins): Add Loongson builtins.\n\t(mips_loongson_2ef_bdesc): New.\n\t(mips_bdesc_arrays): Add mips_loongson_2ef_bdesc.\n\t(mips_builtin_vector_type): Handle unsigned versions of vector modes.\n\t(MIPS_ATYPE_UQI, MIPS_ATYPE_UDI, MIPS_ATYPE_V2SI, MIPS_ATYPE_UV2SI)\n\t(MIPS_ATYPE_V4HI, MIPS_ATYPE_UV4HI, MIPS_ATYPE_V8QI, MIPS_ATYPE_UV8QI):\n\tNew.\n\t(mips_expand_vector_init): New.\n\t* config/mips/mips.h (HAVE_LOONGSON_VECTOR_MODES): New.\n\t(TARGET_CPU_CPP_BUILTINS): Define __mips_loongson_vector_rev\n\tif appropriate.\n\t* config/mips/mips.md: Add unspec numbers for Loongson\n\tbuiltins.  Include loongson.md.\n\t(MOVE64): Include Loongson vector modes.\n\t(SPLITF): Include Loongson vector modes.\n\t(HALFMODE): Handle Loongson vector modes.\n\t* config/mips/loongson.md: New.\n\t* config/mips/loongson.h: New.\n\t* config.gcc: Add loongson.h header for mips*-*-* targets.\n\t* doc/extend.texi (MIPS Loongson Built-in Functions): New.\n\n2008-06-15  Mark Shinwell  <shinwell@codesourcery.com>\n\n\t* lib/target-supports.exp (check_effective_target_mips_loongson): New.\n\t* gcc.target/mips/loongson-simd.c: New.\n\nCo-Authored-By: Maxim Kuvyrkov <maxim@codesourcery.com>\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com>\nCo-Authored-By: Richard Sandiford <rdsandiford@googlemail.com>\n\nFrom-SVN: r136800", "tree": {"sha": "79e85ed4cf20018db2f54c614c571cf27e619564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79e85ed4cf20018db2f54c614c571cf27e619564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93581857e5b10875c572069ef767411ccf5e6162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93581857e5b10875c572069ef767411ccf5e6162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93581857e5b10875c572069ef767411ccf5e6162", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93581857e5b10875c572069ef767411ccf5e6162/comments", "author": null, "committer": null, "parents": [{"sha": "2454e4f698496b88bd22cc51daee22e8dae29b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2454e4f698496b88bd22cc51daee22e8dae29b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2454e4f698496b88bd22cc51daee22e8dae29b37"}], "stats": {"total": 3595, "additions": 3588, "deletions": 7}, "files": [{"sha": "8dd6b1cbc0befa6eccbb9a7205d1607e64645d62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -1,3 +1,53 @@\n+2008-06-15  Mark Shinwell  <shinwell@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\t    Richard Sandiford  <rdsandiford@googlemail.com>\n+\t\n+\t* config/mips/mips-modes.def: Add V8QI, V4HI and V2SI modes.\n+\t* config/mips/mips-protos.h (mips_expand_vector_init): New.\n+\t* config/mips/mips-ftypes.def: Add function types for Loongson-2E/2F\n+\tbuiltins.\n+\t* config/mips/mips.c (mips_split_doubleword_move): Handle new modes.\n+\t(mips_hard_regno_mode_ok_p): Allow 64-bit vector modes for Loongson.\n+\t(mips_vector_mode_supported_p): Add V2SImode, V4HImode and\n+\tV8QImode cases.\n+\t(LOONGSON_BUILTIN, LOONGSON_BUILTIN_ALIAS): New.\n+\t(CODE_FOR_loongson_packsswh, CODE_FOR_loongson_packsshb,\n+\t(CODE_FOR_loongson_packushb, CODE_FOR_loongson_paddw,\n+\t(CODE_FOR_loongson_paddh, CODE_FOR_loongson_paddb,\n+\t(CODE_FOR_loongson_paddsh, CODE_FOR_loongson_paddsb)\n+\t(CODE_FOR_loongson_paddush, CODE_FOR_loongson_paddusb)\n+\t(CODE_FOR_loongson_pmaxsh, CODE_FOR_loongson_pmaxub)\n+\t(CODE_FOR_loongson_pminsh, CODE_FOR_loongson_pminub)\n+\t(CODE_FOR_loongson_pmulhuh, CODE_FOR_loongson_pmulhh)\n+\t(CODE_FOR_loongson_biadd, CODE_FOR_loongson_psubw)\n+\t(CODE_FOR_loongson_psubh, CODE_FOR_loongson_psubb)\n+\t(CODE_FOR_loongson_psubsh, CODE_FOR_loongson_psubsb)\n+\t(CODE_FOR_loongson_psubush, CODE_FOR_loongson_psubusb)\n+\t(CODE_FOR_loongson_punpckhbh, CODE_FOR_loongson_punpckhhw)\n+\t(CODE_FOR_loongson_punpckhwd, CODE_FOR_loongson_punpcklbh)\n+\t(CODE_FOR_loongson_punpcklhw, CODE_FOR_loongson_punpcklwd): New.\n+\t(mips_builtins): Add Loongson builtins.\n+\t(mips_loongson_2ef_bdesc): New.\n+\t(mips_bdesc_arrays): Add mips_loongson_2ef_bdesc.\n+\t(mips_builtin_vector_type): Handle unsigned versions of vector modes.\n+\t(MIPS_ATYPE_UQI, MIPS_ATYPE_UDI, MIPS_ATYPE_V2SI, MIPS_ATYPE_UV2SI)\n+\t(MIPS_ATYPE_V4HI, MIPS_ATYPE_UV4HI, MIPS_ATYPE_V8QI, MIPS_ATYPE_UV8QI):\n+\tNew.\n+\t(mips_expand_vector_init): New.\n+\t* config/mips/mips.h (HAVE_LOONGSON_VECTOR_MODES): New.\n+\t(TARGET_CPU_CPP_BUILTINS): Define __mips_loongson_vector_rev\n+\tif appropriate.\n+\t* config/mips/mips.md: Add unspec numbers for Loongson\n+\tbuiltins.  Include loongson.md.\n+\t(MOVE64): Include Loongson vector modes.\n+\t(SPLITF): Include Loongson vector modes.\n+\t(HALFMODE): Handle Loongson vector modes.\n+\t* config/mips/loongson.md: New.\n+\t* config/mips/loongson.h: New.\n+\t* config.gcc: Add loongson.h header for mips*-*-* targets.\n+\t* doc/extend.texi (MIPS Loongson Built-in Functions): New.\n+\n 2008-06-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config.gcc (arc-*-elf*, avr-*-*, fr30-*-elf, frv-*-elf,"}, {"sha": "8c8a66a67726cc04caeca885191704cd1d0d29a7", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -307,6 +307,7 @@ m68k-*-*)\n mips*-*-*)\n \tcpu_type=mips\n \tneed_64bit_hwint=yes\n+\textra_headers=\"loongson.h\"\n \t;;\n powerpc*-*-*)\n \tcpu_type=rs6000"}, {"sha": "c742edeeb3f4a0a7cfcdb37a74024ba17d2848d9", "filename": "gcc/config/mips/loongson.h", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Floongson.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Floongson.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Floongson.h?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -0,0 +1,693 @@\n+/* Intrinsics for ST Microelectronics Loongson-2E/2F SIMD operations.\n+\n+   Copyright (C) 2008 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+#ifndef _GCC_LOONGSON_H\n+#define _GCC_LOONGSON_H\n+\n+#if !defined(__mips_loongson_vector_rev)\n+# error \"You must select -march=loongson2e or -march=loongson2f to use loongson.h\"\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdint.h>\n+\n+/* Vectors of unsigned bytes, halfwords and words.  */\n+typedef uint8_t uint8x8_t __attribute__((vector_size (8)));\n+typedef uint16_t uint16x4_t __attribute__((vector_size (8)));\n+typedef uint32_t uint32x2_t __attribute__((vector_size (8)));\n+\n+/* Vectors of signed bytes, halfwords and words.  */\n+typedef int8_t int8x8_t __attribute__((vector_size (8)));\n+typedef int16_t int16x4_t __attribute__((vector_size (8)));\n+typedef int32_t int32x2_t __attribute__((vector_size (8)));\n+\n+/* SIMD intrinsics.\n+   Unless otherwise noted, calls to the functions below will expand into\n+   precisely one machine instruction, modulo any moves required to\n+   satisfy register allocation constraints.  */\n+\n+/* Pack with signed saturation.  */\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+packsswh (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_packsswh (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+packsshb (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_packsshb (s, t);\n+}\n+\n+/* Pack with unsigned saturation.  */\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+packushb (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_packushb (s, t);\n+}\n+\n+/* Vector addition, treating overflow by wraparound.  */\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+paddw_u (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_paddw_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+paddh_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_paddh_u (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+paddb_u (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_paddb_u (s, t);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+paddw_s (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_paddw_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+paddh_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_paddh_s (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+paddb_s (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_paddb_s (s, t);\n+}\n+\n+/* Addition of doubleword integers, treating overflow by wraparound.  */\n+__extension__ static __inline uint64_t __attribute__ ((__always_inline__))\n+paddd_u (uint64_t s, uint64_t t)\n+{\n+  return __builtin_loongson_paddd_u (s, t);\n+}\n+\n+__extension__ static __inline int64_t __attribute__ ((__always_inline__))\n+paddd_s (int64_t s, int64_t t)\n+{\n+  return __builtin_loongson_paddd_s (s, t);\n+}\n+\n+/* Vector addition, treating overflow by signed saturation.  */\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+paddsh (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_paddsh (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+paddsb (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_paddsb (s, t);\n+}\n+\n+/* Vector addition, treating overflow by unsigned saturation.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+paddush (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_paddush (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+paddusb (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_paddusb (s, t);\n+}\n+\n+/* Logical AND NOT.  */\n+__extension__ static __inline uint64_t __attribute__ ((__always_inline__))\n+pandn_ud (uint64_t s, uint64_t t)\n+{\n+  return __builtin_loongson_pandn_ud (s, t);\n+}\n+\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+pandn_uw (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_pandn_uw (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pandn_uh (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pandn_uh (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pandn_ub (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_pandn_ub (s, t);\n+}\n+\n+__extension__ static __inline int64_t __attribute__ ((__always_inline__))\n+pandn_sd (int64_t s, int64_t t)\n+{\n+  return __builtin_loongson_pandn_sd (s, t);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+pandn_sw (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_pandn_sw (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pandn_sh (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pandn_sh (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+pandn_sb (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_pandn_sb (s, t);\n+}\n+\n+/* Average.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pavgh (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pavgh (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pavgb (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_pavgb (s, t);\n+}\n+\n+/* Equality test.  */\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+pcmpeqw_u (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_pcmpeqw_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pcmpeqh_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pcmpeqh_u (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pcmpeqb_u (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_pcmpeqb_u (s, t);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+pcmpeqw_s (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_pcmpeqw_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pcmpeqh_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pcmpeqh_s (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+pcmpeqb_s (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_pcmpeqb_s (s, t);\n+}\n+\n+/* Greater-than test.  */\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+pcmpgtw_u (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_pcmpgtw_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pcmpgth_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pcmpgth_u (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pcmpgtb_u (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_pcmpgtb_u (s, t);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+pcmpgtw_s (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_pcmpgtw_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pcmpgth_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pcmpgth_s (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+pcmpgtb_s (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_pcmpgtb_s (s, t);\n+}\n+\n+/* Extract halfword.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pextrh_u (uint16x4_t s, int field /* 0--3 */)\n+{\n+  return __builtin_loongson_pextrh_u (s, field);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pextrh_s (int16x4_t s, int field /* 0--3 */)\n+{\n+  return __builtin_loongson_pextrh_s (s, field);\n+}\n+\n+/* Insert halfword.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pinsrh_0_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_0_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pinsrh_1_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_1_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pinsrh_2_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_2_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pinsrh_3_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_3_u (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pinsrh_0_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_0_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pinsrh_1_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_1_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pinsrh_2_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_2_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pinsrh_3_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pinsrh_3_s (s, t);\n+}\n+\n+/* Multiply and add.  */\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+pmaddhw (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pmaddhw (s, t);\n+}\n+\n+/* Maximum of signed halfwords.  */\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pmaxsh (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pmaxsh (s, t);\n+}\n+\n+/* Maximum of unsigned bytes.  */\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pmaxub (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_pmaxub (s, t);\n+}\n+\n+/* Minimum of signed halfwords.  */\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pminsh (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pminsh (s, t);\n+}\n+\n+/* Minimum of unsigned bytes.  */\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pminub (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_pminub (s, t);\n+}\n+\n+/* Move byte mask.  */\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pmovmskb_u (uint8x8_t s)\n+{\n+  return __builtin_loongson_pmovmskb_u (s);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+pmovmskb_s (int8x8_t s)\n+{\n+  return __builtin_loongson_pmovmskb_s (s);\n+}\n+\n+/* Multiply unsigned integers and store high result.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pmulhuh (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_pmulhuh (s, t);\n+}\n+\n+/* Multiply signed integers and store high result.  */\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pmulhh (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pmulhh (s, t);\n+}\n+\n+/* Multiply signed integers and store low result.  */\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pmullh (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_pmullh (s, t);\n+}\n+\n+/* Multiply unsigned word integers.  */\n+__extension__ static __inline int64_t __attribute__ ((__always_inline__))\n+pmuluw (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_pmuluw (s, t);\n+}\n+\n+/* Absolute difference.  */\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+pasubub (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_pasubub (s, t);\n+}\n+\n+/* Sum of unsigned byte integers.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+biadd (uint8x8_t s)\n+{\n+  return __builtin_loongson_biadd (s);\n+}\n+\n+/* Sum of absolute differences.\n+   Note that this intrinsic expands into two machine instructions:\n+   PASUBUB followed by BIADD.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+psadbh (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_psadbh (s, t);\n+}\n+\n+/* Shuffle halfwords.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+pshufh_u (uint16x4_t dest, uint16x4_t s, uint8_t order)\n+{\n+  return __builtin_loongson_pshufh_u (dest, s, order);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+pshufh_s (int16x4_t dest, int16x4_t s, uint8_t order)\n+{\n+  return __builtin_loongson_pshufh_s (dest, s, order);\n+}\n+\n+/* Shift left logical.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+psllh_u (uint16x4_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psllh_u (s, amount);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+psllh_s (int16x4_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psllh_s (s, amount);\n+}\n+\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+psllw_u (uint32x2_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psllw_u (s, amount);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+psllw_s (int32x2_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psllw_s (s, amount);\n+}\n+\n+/* Shift right logical.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+psrlh_u (uint16x4_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psrlh_u (s, amount);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+psrlh_s (int16x4_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psrlh_s (s, amount);\n+}\n+\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+psrlw_u (uint32x2_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psrlw_u (s, amount);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+psrlw_s (int32x2_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psrlw_s (s, amount);\n+}\n+\n+/* Shift right arithmetic.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+psrah_u (uint16x4_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psrah_u (s, amount);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+psrah_s (int16x4_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psrah_s (s, amount);\n+}\n+\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+psraw_u (uint32x2_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psraw_u (s, amount);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+psraw_s (int32x2_t s, uint8_t amount)\n+{\n+  return __builtin_loongson_psraw_s (s, amount);\n+}\n+\n+/* Vector subtraction, treating overflow by wraparound.  */\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+psubw_u (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_psubw_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+psubh_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_psubh_u (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+psubb_u (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_psubb_u (s, t);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+psubw_s (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_psubw_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+psubh_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_psubh_s (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+psubb_s (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_psubb_s (s, t);\n+}\n+\n+/* Subtraction of doubleword integers, treating overflow by wraparound.  */\n+__extension__ static __inline uint64_t __attribute__ ((__always_inline__))\n+psubd_u (uint64_t s, uint64_t t)\n+{\n+  return __builtin_loongson_psubd_u (s, t);\n+}\n+\n+__extension__ static __inline int64_t __attribute__ ((__always_inline__))\n+psubd_s (int64_t s, int64_t t)\n+{\n+  return __builtin_loongson_psubd_s (s, t);\n+}\n+\n+/* Vector subtraction, treating overflow by signed saturation.  */\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+psubsh (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_psubsh (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+psubsb (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_psubsb (s, t);\n+}\n+\n+/* Vector subtraction, treating overflow by unsigned saturation.  */\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+psubush (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_psubush (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+psubusb (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_psubusb (s, t);\n+}\n+\n+/* Unpack high data.  */\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+punpckhwd_u (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_punpckhwd_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+punpckhhw_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_punpckhhw_u (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+punpckhbh_u (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_punpckhbh_u (s, t);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+punpckhwd_s (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_punpckhwd_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+punpckhhw_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_punpckhhw_s (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+punpckhbh_s (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_punpckhbh_s (s, t);\n+}\n+\n+/* Unpack low data.  */\n+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))\n+punpcklwd_u (uint32x2_t s, uint32x2_t t)\n+{\n+  return __builtin_loongson_punpcklwd_u (s, t);\n+}\n+\n+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n+punpcklhw_u (uint16x4_t s, uint16x4_t t)\n+{\n+  return __builtin_loongson_punpcklhw_u (s, t);\n+}\n+\n+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))\n+punpcklbh_u (uint8x8_t s, uint8x8_t t)\n+{\n+  return __builtin_loongson_punpcklbh_u (s, t);\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+punpcklwd_s (int32x2_t s, int32x2_t t)\n+{\n+  return __builtin_loongson_punpcklwd_s (s, t);\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+punpcklhw_s (int16x4_t s, int16x4_t t)\n+{\n+  return __builtin_loongson_punpcklhw_s (s, t);\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+punpcklbh_s (int8x8_t s, int8x8_t t)\n+{\n+  return __builtin_loongson_punpcklbh_s (s, t);\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "5177ae477dc8385ef50fe07acc83d761b5ae90dd", "filename": "gcc/config/mips/loongson.md", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Floongson.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Floongson.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Floongson.md?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -0,0 +1,437 @@\n+;; Machine description for ST Microelectronics Loongson-2E/2F.\n+;; Copyright (C) 2008 Free Software Foundation, Inc.\n+;; Contributed by CodeSourcery.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Mode iterators and attributes.\n+\n+;; 64-bit vectors of bytes.\n+(define_mode_iterator VB [V8QI])\n+\n+;; 64-bit vectors of halfwords.\n+(define_mode_iterator VH [V4HI])\n+\n+;; 64-bit vectors of words.\n+(define_mode_iterator VW [V2SI])\n+\n+;; 64-bit vectors of halfwords and bytes.\n+(define_mode_iterator VHB [V4HI V8QI])\n+\n+;; 64-bit vectors of words and halfwords.\n+(define_mode_iterator VWH [V2SI V4HI])\n+\n+;; 64-bit vectors of words, halfwords and bytes.\n+(define_mode_iterator VWHB [V2SI V4HI V8QI])\n+\n+;; 64-bit vectors of words, halfwords and bytes; and DImode.\n+(define_mode_iterator VWHBDI [V2SI V4HI V8QI DI])\n+\n+;; The Loongson instruction suffixes corresponding to the modes in the\n+;; VWHBDI iterator.\n+(define_mode_attr V_suffix [(V2SI \"w\") (V4HI \"h\") (V8QI \"b\") (DI \"d\")])\n+\n+;; Given a vector type T, the mode of a vector half the size of T\n+;; and with the same number of elements.\n+(define_mode_attr V_squash [(V2SI \"V2HI\") (V4HI \"V4QI\")])\n+\n+;; Given a vector type T, the mode of a vector the same size as T\n+;; but with half as many elements.\n+(define_mode_attr V_stretch_half [(V2SI \"DI\") (V4HI \"V2SI\") (V8QI \"V4HI\")])\n+\n+;; The Loongson instruction suffixes corresponding to the transformation\n+;; expressed by V_stretch_half.\n+(define_mode_attr V_stretch_half_suffix [(V2SI \"wd\") (V4HI \"hw\") (V8QI \"bh\")])\n+\n+;; Given a vector type T, the mode of a vector the same size as T\n+;; but with twice as many elements.\n+(define_mode_attr V_squash_double [(V2SI \"V4HI\") (V4HI \"V8QI\")])\n+\n+;; The Loongson instruction suffixes corresponding to the conversions\n+;; specified by V_half_width.\n+(define_mode_attr V_squash_double_suffix [(V2SI \"wh\") (V4HI \"hb\")])\n+\n+;; Move patterns.\n+\n+;; Expander to legitimize moves involving values of vector modes.\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:VWHB 0)\n+\t(match_operand:VWHB 1))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  if (mips_legitimize_move (<MODE>mode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+;; Handle legitimized moves between values of vector modes.\n+(define_insn \"mov<mode>_internal\"\n+  [(set (match_operand:VWHB 0 \"nonimmediate_operand\" \"=m,f,d,f,  d,  m,  d\")\n+\t(match_operand:VWHB 1 \"move_operand\"          \"f,m,f,dYG,dYG,dYG,m\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\" \"fpstore,fpload,mfc,mtc,move,store,load\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+;; Initialization of a vector.\n+\n+(define_expand \"vec_init<mode>\"\n+  [(set (match_operand:VWHB 0 \"register_operand\")\n+\t(match_operand 1 \"\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vector_init (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; Instruction patterns for SIMD instructions.\n+\n+;; Pack with signed saturation.\n+(define_insn \"vec_pack_ssat_<mode>\"\n+  [(set (match_operand:<V_squash_double> 0 \"register_operand\" \"=f\")\n+        (vec_concat:<V_squash_double>\n+\t (ss_truncate:<V_squash>\n+\t  (match_operand:VWH 1 \"register_operand\" \"f\"))\n+\t (ss_truncate:<V_squash>\n+\t  (match_operand:VWH 2 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"packss<V_squash_double_suffix>\\t%0,%1,%2\")\n+\n+;; Pack with unsigned saturation.\n+(define_insn \"vec_pack_usat_<mode>\"\n+  [(set (match_operand:<V_squash_double> 0 \"register_operand\" \"=f\")\n+        (vec_concat:<V_squash_double>\n+\t (us_truncate:<V_squash>\n+\t  (match_operand:VH 1 \"register_operand\" \"f\"))\n+\t (us_truncate:<V_squash>\n+\t  (match_operand:VH 2 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"packus<V_squash_double_suffix>\\t%0,%1,%2\")\n+\n+;; Addition, treating overflow by wraparound.\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+        (plus:VWHB (match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:VWHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"padd<V_suffix>\\t%0,%1,%2\")\n+\n+;; Addition of doubleword integers stored in FP registers.\n+;; Overflow is treated by wraparound.\n+;; We use 'unspec' instead of 'plus' here to avoid clash with\n+;; mips.md::add<mode>3.  If 'plus' was used, then such instruction\n+;; would be recognized as adddi3 and reload would make it use\n+;; GPRs instead of FPRs.\n+(define_insn \"loongson_paddd\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+        (unspec:DI [(match_operand:DI 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:DI 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PADDD))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"paddd\\t%0,%1,%2\")\n+\n+;; Addition, treating overflow by signed saturation.\n+(define_insn \"ssadd<mode>3\"\n+  [(set (match_operand:VHB 0 \"register_operand\" \"=f\")\n+        (ss_plus:VHB (match_operand:VHB 1 \"register_operand\" \"f\")\n+\t\t     (match_operand:VHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"padds<V_suffix>\\t%0,%1,%2\")\n+\n+;; Addition, treating overflow by unsigned saturation.\n+(define_insn \"usadd<mode>3\"\n+  [(set (match_operand:VHB 0 \"register_operand\" \"=f\")\n+        (us_plus:VHB (match_operand:VHB 1 \"register_operand\" \"f\")\n+\t\t     (match_operand:VHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"paddus<V_suffix>\\t%0,%1,%2\")\n+\n+;; Logical AND NOT.\n+(define_insn \"loongson_pandn_<V_suffix>\"\n+  [(set (match_operand:VWHBDI 0 \"register_operand\" \"=f\")\n+        (and:VWHBDI\n+\t (not:VWHBDI (match_operand:VWHBDI 1 \"register_operand\" \"f\"))\n+\t (match_operand:VWHBDI 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pandn\\t%0,%1,%2\")\n+\n+;; Average.\n+(define_insn \"loongson_pavg<V_suffix>\"\n+  [(set (match_operand:VHB 0 \"register_operand\" \"=f\")\n+        (unspec:VHB [(match_operand:VHB 1 \"register_operand\" \"f\")\n+\t\t     (match_operand:VHB 2 \"register_operand\" \"f\")]\n+\t\t    UNSPEC_LOONGSON_PAVG))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pavg<V_suffix>\\t%0,%1,%2\")\n+\n+;; Equality test.\n+(define_insn \"loongson_pcmpeq<V_suffix>\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+        (unspec:VWHB [(match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:VWHB 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_LOONGSON_PCMPEQ))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pcmpeq<V_suffix>\\t%0,%1,%2\")\n+\n+;; Greater-than test.\n+(define_insn \"loongson_pcmpgt<V_suffix>\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+        (unspec:VWHB [(match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:VWHB 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_LOONGSON_PCMPGT))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pcmpgt<V_suffix>\\t%0,%1,%2\")\n+\n+;; Extract halfword.\n+(define_insn \"loongson_pextr<V_suffix>\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+ \t\t    (match_operand:SI 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PEXTR))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pextr<V_suffix>\\t%0,%1,%2\")\n+\n+;; Insert halfword.\n+(define_insn \"loongson_pinsr<V_suffix>_0\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PINSR_0))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pinsr<V_suffix>_0\\t%0,%1,%2\")\n+\n+(define_insn \"loongson_pinsr<V_suffix>_1\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PINSR_1))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pinsr<V_suffix>_1\\t%0,%1,%2\")\n+\n+(define_insn \"loongson_pinsr<V_suffix>_2\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PINSR_2))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pinsr<V_suffix>_2\\t%0,%1,%2\")\n+\n+(define_insn \"loongson_pinsr<V_suffix>_3\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PINSR_3))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pinsr<V_suffix>_3\\t%0,%1,%2\")\n+\n+;; Multiply and add packed integers.\n+(define_insn \"loongson_pmadd<V_stretch_half_suffix>\"\n+  [(set (match_operand:<V_stretch_half> 0 \"register_operand\" \"=f\")\n+        (unspec:<V_stretch_half> [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t\t\t  (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t\t\t UNSPEC_LOONGSON_PMADD))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmadd<V_stretch_half_suffix>\\t%0,%1,%2\")\n+\n+;; Maximum of signed halfwords.\n+(define_insn \"smax<mode>3\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (smax:VH (match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t (match_operand:VH 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmaxs<V_suffix>\\t%0,%1,%2\")\n+\n+;; Maximum of unsigned bytes.\n+(define_insn \"umax<mode>3\"\n+  [(set (match_operand:VB 0 \"register_operand\" \"=f\")\n+        (umax:VB (match_operand:VB 1 \"register_operand\" \"f\")\n+\t\t (match_operand:VB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmaxu<V_suffix>\\t%0,%1,%2\")\n+\n+;; Minimum of signed halfwords.\n+(define_insn \"smin<mode>3\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (smin:VH (match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t (match_operand:VH 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmins<V_suffix>\\t%0,%1,%2\")\n+\n+;; Minimum of unsigned bytes.\n+(define_insn \"umin<mode>3\"\n+  [(set (match_operand:VB 0 \"register_operand\" \"=f\")\n+        (umin:VB (match_operand:VB 1 \"register_operand\" \"f\")\n+\t\t (match_operand:VB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pminu<V_suffix>\\t%0,%1,%2\")\n+\n+;; Move byte mask.\n+(define_insn \"loongson_pmovmsk<V_suffix>\"\n+  [(set (match_operand:VB 0 \"register_operand\" \"=f\")\n+        (unspec:VB [(match_operand:VB 1 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PMOVMSK))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmovmsk<V_suffix>\\t%0,%1\")\n+\n+;; Multiply unsigned integers and store high result.\n+(define_insn \"umul<mode>3_highpart\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PMULHU))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmulhu<V_suffix>\\t%0,%1,%2\")\n+\n+;; Multiply signed integers and store high result.\n+(define_insn \"smul<mode>3_highpart\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PMULH))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmulh<V_suffix>\\t%0,%1,%2\")\n+\n+;; Multiply signed integers and store low result.\n+(define_insn \"loongson_pmull<V_suffix>\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PMULL))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmull<V_suffix>\\t%0,%1,%2\")\n+\n+;; Multiply unsigned word integers.\n+(define_insn \"loongson_pmulu<V_suffix>\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+        (unspec:DI [(match_operand:VW 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VW 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PMULU))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pmulu<V_suffix>\\t%0,%1,%2\")\n+\n+;; Absolute difference.\n+(define_insn \"loongson_pasubub\"\n+  [(set (match_operand:VB 0 \"register_operand\" \"=f\")\n+        (unspec:VB [(match_operand:VB 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VB 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PASUBUB))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pasubub\\t%0,%1,%2\")\n+\n+;; Sum of unsigned byte integers.\n+(define_insn \"reduc_uplus_<mode>\"\n+  [(set (match_operand:<V_stretch_half> 0 \"register_operand\" \"=f\")\n+        (unspec:<V_stretch_half> [(match_operand:VB 1 \"register_operand\" \"f\")]\n+\t\t\t\t UNSPEC_LOONGSON_BIADD))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"biadd\\t%0,%1\")\n+\n+;; Sum of absolute differences.\n+(define_insn \"loongson_psadbh\"\n+  [(set (match_operand:<V_stretch_half> 0 \"register_operand\" \"=f\")\n+        (unspec:<V_stretch_half> [(match_operand:VB 1 \"register_operand\" \"f\")\n+\t\t\t\t  (match_operand:VB 2 \"register_operand\" \"f\")]\n+\t\t\t\t UNSPEC_LOONGSON_PSADBH))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pasubub\\t%0,%1,%2;biadd\\t%0,%0\")\n+\n+;; Shuffle halfwords.\n+(define_insn \"loongson_pshufh\"\n+  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:VH 2 \"register_operand\" \"f\")\n+\t\t    (match_operand:SI 3 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PSHUFH))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pshufh\\t%0,%2,%3\")\n+\n+;; Shift left logical.\n+(define_insn \"loongson_psll<V_suffix>\"\n+  [(set (match_operand:VWH 0 \"register_operand\" \"=f\")\n+        (ashift:VWH (match_operand:VWH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"psll<V_suffix>\\t%0,%1,%2\")\n+\n+;; Shift right arithmetic.\n+(define_insn \"loongson_psra<V_suffix>\"\n+  [(set (match_operand:VWH 0 \"register_operand\" \"=f\")\n+        (ashiftrt:VWH (match_operand:VWH 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"psra<V_suffix>\\t%0,%1,%2\")\n+\n+;; Shift right logical.\n+(define_insn \"loongson_psrl<V_suffix>\"\n+  [(set (match_operand:VWH 0 \"register_operand\" \"=f\")\n+        (lshiftrt:VWH (match_operand:VWH 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"psrl<V_suffix>\\t%0,%1,%2\")\n+\n+;; Subtraction, treating overflow by wraparound.\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+        (minus:VWHB (match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:VWHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"psub<V_suffix>\\t%0,%1,%2\")\n+\n+;; Subtraction of doubleword integers stored in FP registers.\n+;; Overflow is treated by wraparound.\n+;; See loongson_paddd for the reason we use 'unspec' rather than\n+;; 'minus' here.\n+(define_insn \"loongson_psubd\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+        (unspec:DI [(match_operand:DI 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:DI 2 \"register_operand\" \"f\")]\n+\t\t   UNSPEC_LOONGSON_PSUBD))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"psubd\\t%0,%1,%2\")\n+\n+;; Subtraction, treating overflow by signed saturation.\n+(define_insn \"sssub<mode>3\"\n+  [(set (match_operand:VHB 0 \"register_operand\" \"=f\")\n+        (ss_minus:VHB (match_operand:VHB 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:VHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"psubs<V_suffix>\\t%0,%1,%2\")\n+\n+;; Subtraction, treating overflow by unsigned saturation.\n+(define_insn \"ussub<mode>3\"\n+  [(set (match_operand:VHB 0 \"register_operand\" \"=f\")\n+        (us_minus:VHB (match_operand:VHB 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:VHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"psubus<V_suffix>\\t%0,%1,%2\")\n+\n+;; Unpack high data.\n+(define_insn \"vec_interleave_high<mode>\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+        (unspec:VWHB [(match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:VWHB 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_LOONGSON_PUNPCKH))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpckh<V_stretch_half_suffix>\\t%0,%1,%2\")\n+\n+;; Unpack low data.\n+(define_insn \"vec_interleave_low<mode>\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+        (unspec:VWHB [(match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:VWHB 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_LOONGSON_PUNPCKL))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpckl<V_stretch_half_suffix>\\t%0,%1,%2\")"}, {"sha": "8ae54ebe26399871f33506e7ce961d8f0607affb", "filename": "gcc/config/mips/mips-ftypes.def", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -66,6 +66,24 @@ DEF_MIPS_FTYPE (1, (SF, SF))\n DEF_MIPS_FTYPE (2, (SF, SF, SF))\n DEF_MIPS_FTYPE (1, (SF, V2SF))\n \n+DEF_MIPS_FTYPE (2, (UDI, UDI, UDI))\n+DEF_MIPS_FTYPE (2, (UDI, UV2SI, UV2SI))\n+\n+DEF_MIPS_FTYPE (2, (UV2SI, UV2SI, UQI))\n+DEF_MIPS_FTYPE (2, (UV2SI, UV2SI, UV2SI))\n+\n+DEF_MIPS_FTYPE (2, (UV4HI, UV4HI, UQI))\n+DEF_MIPS_FTYPE (2, (UV4HI, UV4HI, USI))\n+DEF_MIPS_FTYPE (3, (UV4HI, UV4HI, UV4HI, UQI))\n+DEF_MIPS_FTYPE (3, (UV4HI, UV4HI, UV4HI, USI))\n+DEF_MIPS_FTYPE (2, (UV4HI, UV4HI, UV4HI))\n+DEF_MIPS_FTYPE (1, (UV4HI, UV8QI))\n+DEF_MIPS_FTYPE (2, (UV4HI, UV8QI, UV8QI))\n+\n+DEF_MIPS_FTYPE (2, (UV8QI, UV4HI, UV4HI))\n+DEF_MIPS_FTYPE (1, (UV8QI, UV8QI))\n+DEF_MIPS_FTYPE (2, (UV8QI, UV8QI, UV8QI))\n+\n DEF_MIPS_FTYPE (1, (V2HI, SI))\n DEF_MIPS_FTYPE (2, (V2HI, SI, SI))\n DEF_MIPS_FTYPE (3, (V2HI, SI, SI, SI))\n@@ -81,12 +99,27 @@ DEF_MIPS_FTYPE (2, (V2SF, V2SF, V2SF))\n DEF_MIPS_FTYPE (3, (V2SF, V2SF, V2SF, INT))\n DEF_MIPS_FTYPE (4, (V2SF, V2SF, V2SF, V2SF, V2SF))\n \n+DEF_MIPS_FTYPE (2, (V2SI, V2SI, UQI))\n+DEF_MIPS_FTYPE (2, (V2SI, V2SI, V2SI))\n+DEF_MIPS_FTYPE (2, (V2SI, V4HI, V4HI))\n+\n+DEF_MIPS_FTYPE (2, (V4HI, V2SI, V2SI))\n+DEF_MIPS_FTYPE (2, (V4HI, V4HI, UQI))\n+DEF_MIPS_FTYPE (2, (V4HI, V4HI, USI))\n+DEF_MIPS_FTYPE (2, (V4HI, V4HI, V4HI))\n+DEF_MIPS_FTYPE (3, (V4HI, V4HI, V4HI, UQI))\n+DEF_MIPS_FTYPE (3, (V4HI, V4HI, V4HI, USI))\n+\n DEF_MIPS_FTYPE (1, (V4QI, SI))\n DEF_MIPS_FTYPE (2, (V4QI, V2HI, V2HI))\n DEF_MIPS_FTYPE (1, (V4QI, V4QI))\n DEF_MIPS_FTYPE (2, (V4QI, V4QI, SI))\n DEF_MIPS_FTYPE (2, (V4QI, V4QI, V4QI))\n \n+DEF_MIPS_FTYPE (2, (V8QI, V4HI, V4HI))\n+DEF_MIPS_FTYPE (1, (V8QI, V8QI))\n+DEF_MIPS_FTYPE (2, (V8QI, V8QI, V8QI))\n+\n DEF_MIPS_FTYPE (2, (VOID, SI, SI))\n DEF_MIPS_FTYPE (2, (VOID, V2HI, V2HI))\n DEF_MIPS_FTYPE (2, (VOID, V4QI, V4QI))"}, {"sha": "d1617aed83fda2a0c555da9d40fe1bf94dad8ed3", "filename": "gcc/config/mips/mips-modes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-modes.def?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -26,6 +26,7 @@ RESET_FLOAT_FORMAT (DF, mips_double_format);\n FLOAT_MODE (TF, 16, mips_quad_format);\n \n /* Vector modes.  */\n+VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\n VECTOR_MODES (INT, 4);        /*            V4QI V2HI */\n "}, {"sha": "b79b83a0bcbe90f29a41e7a4332c24f783cfb267", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -303,4 +303,6 @@ union mips_gen_fn_ptrs\n extern void mips_expand_atomic_qihi (union mips_gen_fn_ptrs,\n \t\t\t\t     rtx, rtx, rtx, rtx);\n \n+extern void mips_expand_vector_init (rtx, rtx);\n+\n #endif /* ! GCC_MIPS_PROTOS_H */"}, {"sha": "cd94ac15e5abe23695cf3b3a13d3a09423ce0543", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 217, "deletions": 5, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -3532,6 +3532,12 @@ mips_split_doubleword_move (rtx dest, rtx src)\n \temit_insn (gen_move_doubleword_fprdf (dest, src));\n       else if (!TARGET_64BIT && GET_MODE (dest) == V2SFmode)\n \temit_insn (gen_move_doubleword_fprv2sf (dest, src));\n+      else if (!TARGET_64BIT && GET_MODE (dest) == V2SImode)\n+\temit_insn (gen_move_doubleword_fprv2si (dest, src));\n+      else if (!TARGET_64BIT && GET_MODE (dest) == V4HImode)\n+\temit_insn (gen_move_doubleword_fprv4hi (dest, src));\n+      else if (!TARGET_64BIT && GET_MODE (dest) == V8QImode)\n+\temit_insn (gen_move_doubleword_fprv8qi (dest, src));\n       else if (TARGET_64BIT && GET_MODE (dest) == TFmode)\n \temit_insn (gen_move_doubleword_fprtf (dest, src));\n       else\n@@ -8960,6 +8966,14 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n       if (mode == TFmode && ISA_HAS_8CC)\n \treturn true;\n \n+      /* Allow 64-bit vector modes for Loongson-2E/2F.  */\n+      if (TARGET_LOONGSON_VECTORS\n+\t  && (mode == V2SImode\n+\t      || mode == V4HImode\n+\t      || mode == V8QImode\n+\t      || mode == DImode))\n+\treturn true;\n+\n       if (class == MODE_FLOAT\n \t  || class == MODE_COMPLEX_FLOAT\n \t  || class == MODE_VECTOR_FLOAT)\n@@ -9323,6 +9337,11 @@ mips_vector_mode_supported_p (enum machine_mode mode)\n     case V4UQQmode:\n       return TARGET_DSP;\n \n+    case V2SImode:\n+    case V4HImode:\n+    case V8QImode:\n+      return TARGET_LOONGSON_VECTORS;\n+\n     default:\n       return false;\n     }\n@@ -10192,6 +10211,7 @@ AVAIL_NON_MIPS16 (dsp, TARGET_DSP)\n AVAIL_NON_MIPS16 (dspr2, TARGET_DSPR2)\n AVAIL_NON_MIPS16 (dsp_32, !TARGET_64BIT && TARGET_DSP)\n AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)\n+AVAIL_NON_MIPS16 (loongson, TARGET_LOONGSON_VECTORS)\n \n /* Construct a mips_builtin_description from the given arguments.\n \n@@ -10288,13 +10308,63 @@ AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)\n   MIPS_BUILTIN (bposge, f, \"bposge\" #VALUE,\t\t\t\t\\\n \t\tMIPS_BUILTIN_BPOSGE ## VALUE, MIPS_SI_FTYPE_VOID, AVAIL)\n \n+/* Define a Loongson MIPS_BUILTIN_DIRECT function __builtin_loongson_<FN_NAME>\n+   for instruction CODE_FOR_loongson_<INSN>.  FUNCTION_TYPE is a\n+   builtin_description field.  */\n+#define LOONGSON_BUILTIN_ALIAS(INSN, FN_NAME, FUNCTION_TYPE)\t\t\\\n+  { CODE_FOR_loongson_ ## INSN, 0, \"__builtin_loongson_\" #FN_NAME,\t\\\n+    MIPS_BUILTIN_DIRECT, FUNCTION_TYPE, mips_builtin_avail_loongson }\n+\n+/* Define a Loongson MIPS_BUILTIN_DIRECT function __builtin_loongson_<INSN>\n+   for instruction CODE_FOR_loongson_<INSN>.  FUNCTION_TYPE is a\n+   builtin_description field.  */\n+#define LOONGSON_BUILTIN(INSN, FUNCTION_TYPE)\t\t\t\t\\\n+  LOONGSON_BUILTIN_ALIAS (INSN, INSN, FUNCTION_TYPE)\n+\n+/* Like LOONGSON_BUILTIN, but add _<SUFFIX> to the end of the function name.\n+   We use functions of this form when the same insn can be usefully applied\n+   to more than one datatype.  */\n+#define LOONGSON_BUILTIN_SUFFIX(INSN, SUFFIX, FUNCTION_TYPE)\t\t\\\n+  LOONGSON_BUILTIN_ALIAS (INSN, INSN ## _ ## SUFFIX, FUNCTION_TYPE)\n+\n #define CODE_FOR_mips_sqrt_ps CODE_FOR_sqrtv2sf2\n #define CODE_FOR_mips_addq_ph CODE_FOR_addv2hi3\n #define CODE_FOR_mips_addu_qb CODE_FOR_addv4qi3\n #define CODE_FOR_mips_subq_ph CODE_FOR_subv2hi3\n #define CODE_FOR_mips_subu_qb CODE_FOR_subv4qi3\n #define CODE_FOR_mips_mul_ph CODE_FOR_mulv2hi3\n \n+#define CODE_FOR_loongson_packsswh CODE_FOR_vec_pack_ssat_v2si\n+#define CODE_FOR_loongson_packsshb CODE_FOR_vec_pack_ssat_v4hi\n+#define CODE_FOR_loongson_packushb CODE_FOR_vec_pack_usat_v4hi\n+#define CODE_FOR_loongson_paddw CODE_FOR_addv2si3\n+#define CODE_FOR_loongson_paddh CODE_FOR_addv4hi3\n+#define CODE_FOR_loongson_paddb CODE_FOR_addv8qi3\n+#define CODE_FOR_loongson_paddsh CODE_FOR_ssaddv4hi3\n+#define CODE_FOR_loongson_paddsb CODE_FOR_ssaddv8qi3\n+#define CODE_FOR_loongson_paddush CODE_FOR_usaddv4hi3\n+#define CODE_FOR_loongson_paddusb CODE_FOR_usaddv8qi3\n+#define CODE_FOR_loongson_pmaxsh CODE_FOR_smaxv4hi3\n+#define CODE_FOR_loongson_pmaxub CODE_FOR_umaxv8qi3\n+#define CODE_FOR_loongson_pminsh CODE_FOR_sminv4hi3\n+#define CODE_FOR_loongson_pminub CODE_FOR_uminv8qi3\n+#define CODE_FOR_loongson_pmulhuh CODE_FOR_umulv4hi3_highpart\n+#define CODE_FOR_loongson_pmulhh CODE_FOR_smulv4hi3_highpart\n+#define CODE_FOR_loongson_biadd CODE_FOR_reduc_uplus_v8qi\n+#define CODE_FOR_loongson_psubw CODE_FOR_subv2si3\n+#define CODE_FOR_loongson_psubh CODE_FOR_subv4hi3\n+#define CODE_FOR_loongson_psubb CODE_FOR_subv8qi3\n+#define CODE_FOR_loongson_psubsh CODE_FOR_sssubv4hi3\n+#define CODE_FOR_loongson_psubsb CODE_FOR_sssubv8qi3\n+#define CODE_FOR_loongson_psubush CODE_FOR_ussubv4hi3\n+#define CODE_FOR_loongson_psubusb CODE_FOR_ussubv8qi3\n+#define CODE_FOR_loongson_punpckhbh CODE_FOR_vec_interleave_highv8qi\n+#define CODE_FOR_loongson_punpckhhw CODE_FOR_vec_interleave_highv4hi\n+#define CODE_FOR_loongson_punpckhwd CODE_FOR_vec_interleave_highv2si\n+#define CODE_FOR_loongson_punpcklbh CODE_FOR_vec_interleave_lowv8qi\n+#define CODE_FOR_loongson_punpcklhw CODE_FOR_vec_interleave_lowv4hi\n+#define CODE_FOR_loongson_punpcklwd CODE_FOR_vec_interleave_lowv2si\n+\n static const struct mips_builtin_description mips_builtins[] = {\n   DIRECT_BUILTIN (pll_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),\n   DIRECT_BUILTIN (pul_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),\n@@ -10471,7 +10541,108 @@ static const struct mips_builtin_description mips_builtins[] = {\n   DIRECT_BUILTIN (dpaqx_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),\n   DIRECT_BUILTIN (dpaqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),\n   DIRECT_BUILTIN (dpsqx_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),\n-  DIRECT_BUILTIN (dpsqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32)\n+  DIRECT_BUILTIN (dpsqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),\n+\n+  /* Builtin functions for ST Microelectronics Loongson-2E/2F cores.  */\n+  LOONGSON_BUILTIN (packsswh, MIPS_V4HI_FTYPE_V2SI_V2SI),\n+  LOONGSON_BUILTIN (packsshb, MIPS_V8QI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (packushb, MIPS_UV8QI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (paddw, u, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN_SUFFIX (paddh, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (paddb, u, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (paddw, s, MIPS_V2SI_FTYPE_V2SI_V2SI),\n+  LOONGSON_BUILTIN_SUFFIX (paddh, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (paddb, s, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN_SUFFIX (paddd, u, MIPS_UDI_FTYPE_UDI_UDI),\n+  LOONGSON_BUILTIN_SUFFIX (paddd, s, MIPS_DI_FTYPE_DI_DI),\n+  LOONGSON_BUILTIN (paddsh, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (paddsb, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN (paddush, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN (paddusb, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_d, pandn_ud, MIPS_UDI_FTYPE_UDI_UDI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_w, pandn_uw, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_h, pandn_uh, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_b, pandn_ub, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_d, pandn_sd, MIPS_DI_FTYPE_DI_DI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_w, pandn_sw, MIPS_V2SI_FTYPE_V2SI_V2SI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_h, pandn_sh, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_ALIAS (pandn_b, pandn_sb, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN (pavgh, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN (pavgb, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpeqw, u, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpeqh, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpeqb, u, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpeqw, s, MIPS_V2SI_FTYPE_V2SI_V2SI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpeqh, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpeqb, s, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpgtw, u, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpgth, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpgtb, u, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpgtw, s, MIPS_V2SI_FTYPE_V2SI_V2SI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpgth, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pcmpgtb, s, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pextrh, u, MIPS_UV4HI_FTYPE_UV4HI_USI),\n+  LOONGSON_BUILTIN_SUFFIX (pextrh, s, MIPS_V4HI_FTYPE_V4HI_USI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_0, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_1, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_2, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_3, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_0, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_1, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_2, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (pinsrh_3, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (pmaddhw, MIPS_V2SI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (pmaxsh, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (pmaxub, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN (pminsh, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (pminub, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pmovmskb, u, MIPS_UV8QI_FTYPE_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pmovmskb, s, MIPS_V8QI_FTYPE_V8QI),\n+  LOONGSON_BUILTIN (pmulhuh, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN (pmulhh, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (pmullh, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (pmuluw, MIPS_UDI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN (pasubub, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN (biadd, MIPS_UV4HI_FTYPE_UV8QI),\n+  LOONGSON_BUILTIN (psadbh, MIPS_UV4HI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (pshufh, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (pshufh, s, MIPS_V4HI_FTYPE_V4HI_V4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psllh, u, MIPS_UV4HI_FTYPE_UV4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psllh, s, MIPS_V4HI_FTYPE_V4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psllw, u, MIPS_UV2SI_FTYPE_UV2SI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psllw, s, MIPS_V2SI_FTYPE_V2SI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psrah, u, MIPS_UV4HI_FTYPE_UV4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psrah, s, MIPS_V4HI_FTYPE_V4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psraw, u, MIPS_UV2SI_FTYPE_UV2SI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psraw, s, MIPS_V2SI_FTYPE_V2SI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psrlh, u, MIPS_UV4HI_FTYPE_UV4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psrlh, s, MIPS_V4HI_FTYPE_V4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psrlw, u, MIPS_UV2SI_FTYPE_UV2SI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psrlw, s, MIPS_V2SI_FTYPE_V2SI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (psubw, u, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN_SUFFIX (psubh, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (psubb, u, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (psubw, s, MIPS_V2SI_FTYPE_V2SI_V2SI),\n+  LOONGSON_BUILTIN_SUFFIX (psubh, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (psubb, s, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN_SUFFIX (psubd, u, MIPS_UDI_FTYPE_UDI_UDI),\n+  LOONGSON_BUILTIN_SUFFIX (psubd, s, MIPS_DI_FTYPE_DI_DI),\n+  LOONGSON_BUILTIN (psubsh, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN (psubsb, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN (psubush, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN (psubusb, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (punpckhbh, u, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (punpckhhw, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (punpckhwd, u, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN_SUFFIX (punpckhbh, s, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN_SUFFIX (punpckhhw, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (punpckhwd, s, MIPS_V2SI_FTYPE_V2SI_V2SI),\n+  LOONGSON_BUILTIN_SUFFIX (punpcklbh, u, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n+  LOONGSON_BUILTIN_SUFFIX (punpcklhw, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI),\n+  LOONGSON_BUILTIN_SUFFIX (punpcklwd, u, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n+  LOONGSON_BUILTIN_SUFFIX (punpcklbh, s, MIPS_V8QI_FTYPE_V8QI_V8QI),\n+  LOONGSON_BUILTIN_SUFFIX (punpcklhw, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n+  LOONGSON_BUILTIN_SUFFIX (punpcklwd, s, MIPS_V2SI_FTYPE_V2SI_V2SI)\n };\n \n /* MODE is a vector mode whose elements have type TYPE.  Return the type\n@@ -10480,11 +10651,17 @@ static const struct mips_builtin_description mips_builtins[] = {\n static tree\n mips_builtin_vector_type (tree type, enum machine_mode mode)\n {\n-  static tree types[(int) MAX_MACHINE_MODE];\n+  static tree types[2 * (int) MAX_MACHINE_MODE];\n+  int mode_index;\n \n-  if (types[(int) mode] == NULL_TREE)\n-    types[(int) mode] = build_vector_type_for_mode (type, mode);\n-  return types[(int) mode];\n+  mode_index = (int) mode;\n+\n+  if (TREE_CODE (type) == INTEGER_TYPE && TYPE_UNSIGNED (type))\n+    mode_index += MAX_MACHINE_MODE;\n+\n+  if (types[mode_index] == NULL_TREE)\n+    types[mode_index] = build_vector_type_for_mode (type, mode);\n+  return types[mode_index];\n }\n \n /* Source-level argument types.  */\n@@ -10493,16 +10670,27 @@ mips_builtin_vector_type (tree type, enum machine_mode mode)\n #define MIPS_ATYPE_POINTER ptr_type_node\n \n /* Standard mode-based argument types.  */\n+#define MIPS_ATYPE_UQI unsigned_intQI_type_node\n #define MIPS_ATYPE_SI intSI_type_node\n #define MIPS_ATYPE_USI unsigned_intSI_type_node\n #define MIPS_ATYPE_DI intDI_type_node\n+#define MIPS_ATYPE_UDI unsigned_intDI_type_node\n #define MIPS_ATYPE_SF float_type_node\n #define MIPS_ATYPE_DF double_type_node\n \n /* Vector argument types.  */\n #define MIPS_ATYPE_V2SF mips_builtin_vector_type (float_type_node, V2SFmode)\n #define MIPS_ATYPE_V2HI mips_builtin_vector_type (intHI_type_node, V2HImode)\n+#define MIPS_ATYPE_V2SI mips_builtin_vector_type (intSI_type_node, V2SImode)\n #define MIPS_ATYPE_V4QI mips_builtin_vector_type (intQI_type_node, V4QImode)\n+#define MIPS_ATYPE_V4HI mips_builtin_vector_type (intHI_type_node, V4HImode)\n+#define MIPS_ATYPE_V8QI mips_builtin_vector_type (intQI_type_node, V8QImode)\n+#define MIPS_ATYPE_UV2SI\t\t\t\t\t\\\n+  mips_builtin_vector_type (unsigned_intSI_type_node, V2SImode)\n+#define MIPS_ATYPE_UV4HI\t\t\t\t\t\\\n+  mips_builtin_vector_type (unsigned_intHI_type_node, V4HImode)\n+#define MIPS_ATYPE_UV8QI\t\t\t\t\t\\\n+  mips_builtin_vector_type (unsigned_intQI_type_node, V8QImode)\n \n /* MIPS_FTYPE_ATYPESN takes N MIPS_FTYPES-like type codes and lists\n    their associated MIPS_ATYPEs.  */\n@@ -12618,6 +12806,30 @@ mips_conditional_register_usage (void)\n     }\n }\n \n+/* Initialize vector TARGET to VALS.  */\n+\n+void\n+mips_expand_vector_init (rtx target, rtx vals)\n+{\n+  enum machine_mode mode;\n+  enum machine_mode inner;\n+  unsigned int i, n_elts;\n+  rtx mem;\n+\n+  mode = GET_MODE (target);\n+  inner = GET_MODE_INNER (mode);\n+  n_elts = GET_MODE_NUNITS (mode);\n+\n+  gcc_assert (VECTOR_MODE_P (mode));\n+\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  for (i = 0; i < n_elts; i++)\n+    emit_move_insn (adjust_address_nv (mem, inner, i * GET_MODE_SIZE (inner)),\n+                    XVECEXP (vals, 0, i));\n+\n+  emit_move_insn (target, mem);\n+}\n+\n /* When generating MIPS16 code, we want to allocate $24 (T_REG) before\n    other registers for instructions for which it is possible.  This\n    encourages the compiler to use CMP in cases where an XOR would"}, {"sha": "74c079a7d4a64ae75b798ba7a9fcbc8413c41d77", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -267,6 +267,12 @@ enum mips_code_readable_setting {\n \t\t\t\t     || mips_tune == PROCESSOR_74KF3_2)\n #define TUNE_20KC\t\t    (mips_tune == PROCESSOR_20KC)\n \n+/* Whether vector modes and intrinsics for ST Microelectronics\n+   Loongson-2E/2F processors should be enabled.  In o32 pairs of\n+   floating-point registers provide 64-bit values.  */\n+#define TARGET_LOONGSON_VECTORS\t    (TARGET_HARD_FLOAT_ABI\t\t\\\n+\t\t\t\t     && TARGET_LOONGSON_2EF)\n+\n /* True if the pre-reload scheduler should try to create chains of\n    multiply-add or multiply-subtract instructions.  For example,\n    suppose we have:\n@@ -497,6 +503,10 @@ enum mips_code_readable_setting {\n \t  builtin_define_std (\"MIPSEL\");\t\t\t\t\\\n \t  builtin_define (\"_MIPSEL\");\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n+                                                                        \\\n+      /* Whether Loongson vector modes are enabled.  */                 \\\n+      if (TARGET_LOONGSON_VECTORS)\t\t\t\t\t\\\n+        builtin_define (\"__mips_loongson_vector_rev\");                  \\\n \t\t\t\t\t\t\t\t\t\\\n       /* Macros dependent on the C dialect.  */\t\t\t\t\\\n       if (preprocessing_asm_p ())\t\t\t\t\t\\"}, {"sha": "ac1dc60dc814cda94cb6792b1ace774f85c9bb2e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -215,6 +215,30 @@\n    (UNSPEC_DPAQX_SA_W_PH\t446)\n    (UNSPEC_DPSQX_S_W_PH\t\t447)\n    (UNSPEC_DPSQX_SA_W_PH\t448)\n+\n+   ;; ST Microelectronics Loongson-2E/2F.\n+   (UNSPEC_LOONGSON_PAVG\t500)\n+   (UNSPEC_LOONGSON_PCMPEQ\t501)\n+   (UNSPEC_LOONGSON_PCMPGT\t502)\n+   (UNSPEC_LOONGSON_PEXTR\t503)\n+   (UNSPEC_LOONGSON_PINSR_0\t504)\n+   (UNSPEC_LOONGSON_PINSR_1\t505)\n+   (UNSPEC_LOONGSON_PINSR_2\t506)\n+   (UNSPEC_LOONGSON_PINSR_3\t507)\n+   (UNSPEC_LOONGSON_PMADD\t508)\n+   (UNSPEC_LOONGSON_PMOVMSK\t509)\n+   (UNSPEC_LOONGSON_PMULHU\t510)\n+   (UNSPEC_LOONGSON_PMULH\t511)\n+   (UNSPEC_LOONGSON_PMULL\t512)\n+   (UNSPEC_LOONGSON_PMULU\t513)\n+   (UNSPEC_LOONGSON_PASUBUB\t514)\n+   (UNSPEC_LOONGSON_BIADD\t515)\n+   (UNSPEC_LOONGSON_PSADBH\t516)\n+   (UNSPEC_LOONGSON_PSHUFH\t517)\n+   (UNSPEC_LOONGSON_PUNPCKH\t518)\n+   (UNSPEC_LOONGSON_PUNPCKL\t519)\n+   (UNSPEC_LOONGSON_PADDD\t520)\n+   (UNSPEC_LOONGSON_PSUBD\t521)\n   ]\n )\n \n@@ -500,7 +524,11 @@\n \n ;; 64-bit modes for which we provide move patterns.\n (define_mode_iterator MOVE64\n-  [DI DF (V2SF \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\")])\n+  [DI DF\n+   (V2SF \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\")\n+   (V2SI \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\")\n+   (V4HI \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\")\n+   (V8QI \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\")])\n \n ;; 128-bit modes for which we provide move patterns on 64-bit targets.\n (define_mode_iterator MOVE128 [TI TF])\n@@ -527,6 +555,9 @@\n   [(DF \"!TARGET_64BIT && TARGET_DOUBLE_FLOAT\")\n    (DI \"!TARGET_64BIT && TARGET_DOUBLE_FLOAT\")\n    (V2SF \"!TARGET_64BIT && TARGET_PAIRED_SINGLE_FLOAT\")\n+   (V2SI \"!TARGET_64BIT && TARGET_LOONGSON_VECTORS\")\n+   (V4HI \"!TARGET_64BIT && TARGET_LOONGSON_VECTORS\")\n+   (V8QI \"!TARGET_64BIT && TARGET_LOONGSON_VECTORS\")\n    (TF \"TARGET_64BIT && TARGET_FLOAT64\")])\n \n ;; In GPR templates, a string like \"<d>subu\" will expand to \"subu\" in the\n@@ -579,7 +610,9 @@\n \n ;; This attribute gives the integer mode that has half the size of\n ;; the controlling mode.\n-(define_mode_attr HALFMODE [(DF \"SI\") (DI \"SI\") (V2SF \"SI\") (TF \"DI\")])\n+(define_mode_attr HALFMODE [(DF \"SI\") (DI \"SI\") (V2SF \"SI\")\n+\t\t\t    (V2SI \"SI\") (V4HI \"SI\") (V8QI \"SI\")\n+\t\t\t    (TF \"DI\")])\n \n ;; This attribute works around the early SB-1 rev2 core \"F2\" erratum:\n ;;\n@@ -6435,3 +6468,6 @@\n \n ; MIPS fixed-point instructions.\n (include \"mips-fixed.md\")\n+\n+; ST-Microelectronics Loongson-2E/2F-specific patterns.\n+(include \"loongson.md\")"}, {"sha": "3fb51ccf4c56f4c1e897974f2fc5958db824a17d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -6788,6 +6788,7 @@ instructions, but allow the compiler to schedule those calls.\n * X86 Built-in Functions::\n * MIPS DSP Built-in Functions::\n * MIPS Paired-Single Support::\n+* MIPS Loongson Built-in Functions::\n * PowerPC AltiVec Built-in Functions::\n * SPARC VIS Built-in Functions::\n * SPU Built-in Functions::\n@@ -8667,6 +8668,132 @@ value is the upper one.  The opposite order applies to big-endian targets.\n For example, the code above will set the lower half of @code{a} to\n @code{1.5} on little-endian targets and @code{9.1} on big-endian targets.\n \n+@node MIPS Loongson Built-in Functions\n+@subsection MIPS Loongson Built-in Functions\n+\n+GCC provides intrinsics to access the SIMD instructions provided by the\n+ST Microelectronics Loongson-2E and -2F processors.  These intrinsics,\n+available after inclusion of the @code{loongson.h} header file,\n+operate on the following 64-bit vector types:\n+\n+@itemize\n+@item @code{uint8x8_t}, a vector of eight unsigned 8-bit integers;\n+@item @code{uint16x4_t}, a vector of four unsigned 16-bit integers;\n+@item @code{uint32x2_t}, a vector of two unsigned 32-bit integers;\n+@item @code{int8x8_t}, a vector of eight signed 8-bit integers;\n+@item @code{int16x4_t}, a vector of four signed 16-bit integers;\n+@item @code{int32x2_t}, a vector of two signed 32-bit integers.\n+@end itemize\n+\n+The intrinsics provided are listed below; each is named after the\n+machine instruction to which it corresponds, with suffixes added as\n+appropriate to distinguish intrinsics that expand to the same machine\n+instruction yet have different argument types.  Refer to the architecture\n+documentation for a description of the functionality of each\n+instruction.\n+\n+@smallexample\n+int16x4_t packsswh (int32x2_t s, int32x2_t t);\n+int8x8_t packsshb (int16x4_t s, int16x4_t t);\n+uint8x8_t packushb (uint16x4_t s, uint16x4_t t);\n+uint32x2_t paddw_u (uint32x2_t s, uint32x2_t t);\n+uint16x4_t paddh_u (uint16x4_t s, uint16x4_t t);\n+uint8x8_t paddb_u (uint8x8_t s, uint8x8_t t);\n+int32x2_t paddw_s (int32x2_t s, int32x2_t t);\n+int16x4_t paddh_s (int16x4_t s, int16x4_t t);\n+int8x8_t paddb_s (int8x8_t s, int8x8_t t);\n+uint64_t paddd_u (uint64_t s, uint64_t t);\n+int64_t paddd_s (int64_t s, int64_t t);\n+int16x4_t paddsh (int16x4_t s, int16x4_t t);\n+int8x8_t paddsb (int8x8_t s, int8x8_t t);\n+uint16x4_t paddush (uint16x4_t s, uint16x4_t t);\n+uint8x8_t paddusb (uint8x8_t s, uint8x8_t t);\n+uint64_t pandn_ud (uint64_t s, uint64_t t);\n+uint32x2_t pandn_uw (uint32x2_t s, uint32x2_t t);\n+uint16x4_t pandn_uh (uint16x4_t s, uint16x4_t t);\n+uint8x8_t pandn_ub (uint8x8_t s, uint8x8_t t);\n+int64_t pandn_sd (int64_t s, int64_t t);\n+int32x2_t pandn_sw (int32x2_t s, int32x2_t t);\n+int16x4_t pandn_sh (int16x4_t s, int16x4_t t);\n+int8x8_t pandn_sb (int8x8_t s, int8x8_t t);\n+uint16x4_t pavgh (uint16x4_t s, uint16x4_t t);\n+uint8x8_t pavgb (uint8x8_t s, uint8x8_t t);\n+uint32x2_t pcmpeqw_u (uint32x2_t s, uint32x2_t t);\n+uint16x4_t pcmpeqh_u (uint16x4_t s, uint16x4_t t);\n+uint8x8_t pcmpeqb_u (uint8x8_t s, uint8x8_t t);\n+int32x2_t pcmpeqw_s (int32x2_t s, int32x2_t t);\n+int16x4_t pcmpeqh_s (int16x4_t s, int16x4_t t);\n+int8x8_t pcmpeqb_s (int8x8_t s, int8x8_t t);\n+uint32x2_t pcmpgtw_u (uint32x2_t s, uint32x2_t t);\n+uint16x4_t pcmpgth_u (uint16x4_t s, uint16x4_t t);\n+uint8x8_t pcmpgtb_u (uint8x8_t s, uint8x8_t t);\n+int32x2_t pcmpgtw_s (int32x2_t s, int32x2_t t);\n+int16x4_t pcmpgth_s (int16x4_t s, int16x4_t t);\n+int8x8_t pcmpgtb_s (int8x8_t s, int8x8_t t);\n+uint16x4_t pextrh_u (uint16x4_t s, int field);\n+int16x4_t pextrh_s (int16x4_t s, int field);\n+uint16x4_t pinsrh_0_u (uint16x4_t s, uint16x4_t t);\n+uint16x4_t pinsrh_1_u (uint16x4_t s, uint16x4_t t);\n+uint16x4_t pinsrh_2_u (uint16x4_t s, uint16x4_t t);\n+uint16x4_t pinsrh_3_u (uint16x4_t s, uint16x4_t t);\n+int16x4_t pinsrh_0_s (int16x4_t s, int16x4_t t);\n+int16x4_t pinsrh_1_s (int16x4_t s, int16x4_t t);\n+int16x4_t pinsrh_2_s (int16x4_t s, int16x4_t t);\n+int16x4_t pinsrh_3_s (int16x4_t s, int16x4_t t);\n+int32x2_t pmaddhw (int16x4_t s, int16x4_t t);\n+int16x4_t pmaxsh (int16x4_t s, int16x4_t t);\n+uint8x8_t pmaxub (uint8x8_t s, uint8x8_t t);\n+int16x4_t pminsh (int16x4_t s, int16x4_t t);\n+uint8x8_t pminub (uint8x8_t s, uint8x8_t t);\n+uint8x8_t pmovmskb_u (uint8x8_t s);\n+int8x8_t pmovmskb_s (int8x8_t s);\n+uint16x4_t pmulhuh (uint16x4_t s, uint16x4_t t);\n+int16x4_t pmulhh (int16x4_t s, int16x4_t t);\n+int16x4_t pmullh (int16x4_t s, int16x4_t t);\n+int64_t pmuluw (uint32x2_t s, uint32x2_t t);\n+uint8x8_t pasubub (uint8x8_t s, uint8x8_t t);\n+uint16x4_t biadd (uint8x8_t s);\n+uint16x4_t psadbh (uint8x8_t s, uint8x8_t t);\n+uint16x4_t pshufh_u (uint16x4_t dest, uint16x4_t s, uint8_t order);\n+int16x4_t pshufh_s (int16x4_t dest, int16x4_t s, uint8_t order);\n+uint16x4_t psllh_u (uint16x4_t s, uint8_t amount);\n+int16x4_t psllh_s (int16x4_t s, uint8_t amount);\n+uint32x2_t psllw_u (uint32x2_t s, uint8_t amount);\n+int32x2_t psllw_s (int32x2_t s, uint8_t amount);\n+uint16x4_t psrlh_u (uint16x4_t s, uint8_t amount);\n+int16x4_t psrlh_s (int16x4_t s, uint8_t amount);\n+uint32x2_t psrlw_u (uint32x2_t s, uint8_t amount);\n+int32x2_t psrlw_s (int32x2_t s, uint8_t amount);\n+uint16x4_t psrah_u (uint16x4_t s, uint8_t amount);\n+int16x4_t psrah_s (int16x4_t s, uint8_t amount);\n+uint32x2_t psraw_u (uint32x2_t s, uint8_t amount);\n+int32x2_t psraw_s (int32x2_t s, uint8_t amount);\n+uint32x2_t psubw_u (uint32x2_t s, uint32x2_t t);\n+uint16x4_t psubh_u (uint16x4_t s, uint16x4_t t);\n+uint8x8_t psubb_u (uint8x8_t s, uint8x8_t t);\n+int32x2_t psubw_s (int32x2_t s, int32x2_t t);\n+int16x4_t psubh_s (int16x4_t s, int16x4_t t);\n+int8x8_t psubb_s (int8x8_t s, int8x8_t t);\n+uint64_t psubd_u (uint64_t s, uint64_t t);\n+int64_t psubd_s (int64_t s, int64_t t);\n+int16x4_t psubsh (int16x4_t s, int16x4_t t);\n+int8x8_t psubsb (int8x8_t s, int8x8_t t);\n+uint16x4_t psubush (uint16x4_t s, uint16x4_t t);\n+uint8x8_t psubusb (uint8x8_t s, uint8x8_t t);\n+uint32x2_t punpckhwd_u (uint32x2_t s, uint32x2_t t);\n+uint16x4_t punpckhhw_u (uint16x4_t s, uint16x4_t t);\n+uint8x8_t punpckhbh_u (uint8x8_t s, uint8x8_t t);\n+int32x2_t punpckhwd_s (int32x2_t s, int32x2_t t);\n+int16x4_t punpckhhw_s (int16x4_t s, int16x4_t t);\n+int8x8_t punpckhbh_s (int8x8_t s, int8x8_t t);\n+uint32x2_t punpcklwd_u (uint32x2_t s, uint32x2_t t);\n+uint16x4_t punpcklhw_u (uint16x4_t s, uint16x4_t t);\n+uint8x8_t punpcklbh_u (uint8x8_t s, uint8x8_t t);\n+int32x2_t punpcklwd_s (int32x2_t s, int32x2_t t);\n+int16x4_t punpcklhw_s (int16x4_t s, int16x4_t t);\n+int8x8_t punpcklbh_s (int8x8_t s, int8x8_t t);\n+@end smallexample\n+\n @menu\n * Paired-Single Arithmetic::\n * Paired-Single Built-in Functions::"}, {"sha": "95a49dc246d65fc0e5112676415bec5122706990", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -1,3 +1,8 @@\n+2008-06-15  Mark Shinwell  <shinwell@codesourcery.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_mips_loongson): New.\n+\t* gcc.target/mips/loongson-simd.c: New.\n+\n 2008-06-14  Simon Martin  <simartin@users.sourceforge.net>\n \n \tPR c++/35320"}, {"sha": "e4cae5ea61df8e5c0cd37724e3290d5a44039283", "filename": "gcc/testsuite/gcc.target/mips/loongson-simd.c", "status": "added", "additions": 1963, "deletions": 0, "changes": 1963, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Floongson-simd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Floongson-simd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Floongson-simd.c?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -0,0 +1,1963 @@\n+/* Test cases for ST Microelectronics Loongson-2E/2F SIMD intrinsics.\n+   Copyright (C) 2008 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target mips_loongson } */\n+\n+#include \"loongson.h\"\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+typedef union { int32x2_t v; int32_t a[2]; } int32x2_encap_t;\n+typedef union { int16x4_t v; int16_t a[4]; } int16x4_encap_t;\n+typedef union { int8x8_t v; int8_t a[8]; } int8x8_encap_t;\n+typedef union { uint32x2_t v; uint32_t a[2]; } uint32x2_encap_t;\n+typedef union { uint16x4_t v; uint16_t a[4]; } uint16x4_encap_t;\n+typedef union { uint8x8_t v; uint8_t a[8]; } uint8x8_encap_t;\n+\n+#define UINT16x4_MAX USHRT_MAX\n+#define UINT8x8_MAX UCHAR_MAX\n+#define INT8x8_MAX SCHAR_MAX\n+#define INT16x4_MAX SHRT_MAX\n+#define INT32x2_MAX INT_MAX\n+\n+static void test_packsswh (void)\n+{\n+  int32x2_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = INT16x4_MAX - 2;\n+  s.a[1] = INT16x4_MAX - 1;\n+  t.a[0] = INT16x4_MAX;\n+  t.a[1] = INT16x4_MAX + 1;\n+  r.v = packsswh (s.v, t.v);\n+  assert (r.a[0] == INT16x4_MAX - 2);\n+  assert (r.a[1] == INT16x4_MAX - 1);\n+  assert (r.a[2] == INT16x4_MAX);\n+  assert (r.a[3] == INT16x4_MAX);\n+}\n+\n+static void test_packsshb (void)\n+{\n+  int16x4_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = INT8x8_MAX - 6;\n+  s.a[1] = INT8x8_MAX - 5;\n+  s.a[2] = INT8x8_MAX - 4;\n+  s.a[3] = INT8x8_MAX - 3;\n+  t.a[0] = INT8x8_MAX - 2;\n+  t.a[1] = INT8x8_MAX - 1;\n+  t.a[2] = INT8x8_MAX;\n+  t.a[3] = INT8x8_MAX + 1;\n+  r.v = packsshb (s.v, t.v);\n+  assert (r.a[0] == INT8x8_MAX - 6);\n+  assert (r.a[1] == INT8x8_MAX - 5);\n+  assert (r.a[2] == INT8x8_MAX - 4);\n+  assert (r.a[3] == INT8x8_MAX - 3);\n+  assert (r.a[4] == INT8x8_MAX - 2);\n+  assert (r.a[5] == INT8x8_MAX - 1);\n+  assert (r.a[6] == INT8x8_MAX);\n+  assert (r.a[7] == INT8x8_MAX);\n+}\n+\n+static void test_packushb (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = UINT8x8_MAX - 6;\n+  s.a[1] = UINT8x8_MAX - 5;\n+  s.a[2] = UINT8x8_MAX - 4;\n+  s.a[3] = UINT8x8_MAX - 3;\n+  t.a[0] = UINT8x8_MAX - 2;\n+  t.a[1] = UINT8x8_MAX - 1;\n+  t.a[2] = UINT8x8_MAX;\n+  t.a[3] = UINT8x8_MAX + 1;\n+  r.v = packushb (s.v, t.v);\n+  assert (r.a[0] == UINT8x8_MAX - 6);\n+  assert (r.a[1] == UINT8x8_MAX - 5);\n+  assert (r.a[2] == UINT8x8_MAX - 4);\n+  assert (r.a[3] == UINT8x8_MAX - 3);\n+  assert (r.a[4] == UINT8x8_MAX - 2);\n+  assert (r.a[5] == UINT8x8_MAX - 1);\n+  assert (r.a[6] == UINT8x8_MAX);\n+  assert (r.a[7] == UINT8x8_MAX);\n+}\n+\n+static void test_paddw_u (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint32x2_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 2;\n+  t.a[0] = 3;\n+  t.a[1] = 4;\n+  r.v = paddw_u (s.v, t.v);\n+  assert (r.a[0] == 4);\n+  assert (r.a[1] == 6);\n+}\n+\n+static void test_paddw_s (void)\n+{\n+  int32x2_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = -2;\n+  s.a[1] = -1;\n+  t.a[0] = 3;\n+  t.a[1] = 4;\n+  r.v = paddw_s (s.v, t.v);\n+  assert (r.a[0] == 1);\n+  assert (r.a[1] == 3);\n+}\n+\n+static void test_paddh_u (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 2;\n+  s.a[2] = 3;\n+  s.a[3] = 4;\n+  t.a[0] = 5;\n+  t.a[1] = 6;\n+  t.a[2] = 7;\n+  t.a[3] = 8;\n+  r.v = paddh_u (s.v, t.v);\n+  assert (r.a[0] == 6);\n+  assert (r.a[1] == 8);\n+  assert (r.a[2] == 10);\n+  assert (r.a[3] == 12);\n+}\n+\n+static void test_paddh_s (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -10;\n+  s.a[1] = -20;\n+  s.a[2] = -30;\n+  s.a[3] = -40;\n+  t.a[0] = 1;\n+  t.a[1] = 2;\n+  t.a[2] = 3;\n+  t.a[3] = 4;\n+  r.v = paddh_s (s.v, t.v);\n+  assert (r.a[0] == -9);\n+  assert (r.a[1] == -18);\n+  assert (r.a[2] == -27);\n+  assert (r.a[3] == -36);\n+}\n+\n+static void test_paddb_u (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 2;\n+  s.a[2] = 3;\n+  s.a[3] = 4;\n+  s.a[4] = 5;\n+  s.a[5] = 6;\n+  s.a[6] = 7;\n+  s.a[7] = 8;\n+  t.a[0] = 9;\n+  t.a[1] = 10;\n+  t.a[2] = 11;\n+  t.a[3] = 12;\n+  t.a[4] = 13;\n+  t.a[5] = 14;\n+  t.a[6] = 15;\n+  t.a[7] = 16;\n+  r.v = paddb_u (s.v, t.v);\n+  assert (r.a[0] == 10);\n+  assert (r.a[1] == 12);\n+  assert (r.a[2] == 14);\n+  assert (r.a[3] == 16);\n+  assert (r.a[4] == 18);\n+  assert (r.a[5] == 20);\n+  assert (r.a[6] == 22);\n+  assert (r.a[7] == 24);\n+}\n+\n+static void test_paddb_s (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -10;\n+  s.a[1] = -20;\n+  s.a[2] = -30;\n+  s.a[3] = -40;\n+  s.a[4] = -50;\n+  s.a[5] = -60;\n+  s.a[6] = -70;\n+  s.a[7] = -80;\n+  t.a[0] = 1;\n+  t.a[1] = 2;\n+  t.a[2] = 3;\n+  t.a[3] = 4;\n+  t.a[4] = 5;\n+  t.a[5] = 6;\n+  t.a[6] = 7;\n+  t.a[7] = 8;\n+  r.v = paddb_s (s.v, t.v);\n+  assert (r.a[0] == -9);\n+  assert (r.a[1] == -18);\n+  assert (r.a[2] == -27);\n+  assert (r.a[3] == -36);\n+  assert (r.a[4] == -45);\n+  assert (r.a[5] == -54);\n+  assert (r.a[6] == -63);\n+  assert (r.a[7] == -72);\n+}\n+\n+static void test_paddd_u (void)\n+{\n+  uint64_t d = 123456;\n+  uint64_t e = 789012;\n+  uint64_t r;\n+  r = paddd_u (d, e);\n+  assert (r == 912468);\n+}\n+\n+static void test_paddd_s (void)\n+{\n+  int64_t d = 123456;\n+  int64_t e = -789012;\n+  int64_t r;\n+  r = paddd_s (d, e);\n+  assert (r == -665556);\n+}\n+\n+static void test_paddsh (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = 0;\n+  s.a[2] = 1;\n+  s.a[3] = 2;\n+  t.a[0] = INT16x4_MAX;\n+  t.a[1] = INT16x4_MAX;\n+  t.a[2] = INT16x4_MAX;\n+  t.a[3] = INT16x4_MAX;\n+  r.v = paddsh (s.v, t.v);\n+  assert (r.a[0] == INT16x4_MAX - 1);\n+  assert (r.a[1] == INT16x4_MAX);\n+  assert (r.a[2] == INT16x4_MAX);\n+  assert (r.a[3] == INT16x4_MAX);\n+}\n+\n+static void test_paddsb (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -6;\n+  s.a[1] = -5;\n+  s.a[2] = -4;\n+  s.a[3] = -3;\n+  s.a[4] = -2;\n+  s.a[5] = -1;\n+  s.a[6] = 0;\n+  s.a[7] = 1;\n+  t.a[0] = INT8x8_MAX;\n+  t.a[1] = INT8x8_MAX;\n+  t.a[2] = INT8x8_MAX;\n+  t.a[3] = INT8x8_MAX;\n+  t.a[4] = INT8x8_MAX;\n+  t.a[5] = INT8x8_MAX;\n+  t.a[6] = INT8x8_MAX;\n+  t.a[7] = INT8x8_MAX;\n+  r.v = paddsb (s.v, t.v);\n+  assert (r.a[0] == INT8x8_MAX - 6);\n+  assert (r.a[1] == INT8x8_MAX - 5);\n+  assert (r.a[2] == INT8x8_MAX - 4);\n+  assert (r.a[3] == INT8x8_MAX - 3);\n+  assert (r.a[4] == INT8x8_MAX - 2);\n+  assert (r.a[5] == INT8x8_MAX - 1);\n+  assert (r.a[6] == INT8x8_MAX);\n+  assert (r.a[7] == INT8x8_MAX);\n+}\n+\n+static void test_paddush (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 0;\n+  s.a[1] = 1;\n+  s.a[2] = 0;\n+  s.a[3] = 1;\n+  t.a[0] = UINT16x4_MAX;\n+  t.a[1] = UINT16x4_MAX;\n+  t.a[2] = UINT16x4_MAX;\n+  t.a[3] = UINT16x4_MAX;\n+  r.v = paddush (s.v, t.v);\n+  assert (r.a[0] == UINT16x4_MAX);\n+  assert (r.a[1] == UINT16x4_MAX);\n+  assert (r.a[2] == UINT16x4_MAX);\n+  assert (r.a[3] == UINT16x4_MAX);\n+}\n+\n+static void test_paddusb (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 0;\n+  s.a[1] = 1;\n+  s.a[2] = 0;\n+  s.a[3] = 1;\n+  s.a[4] = 0;\n+  s.a[5] = 1;\n+  s.a[6] = 0;\n+  s.a[7] = 1;\n+  t.a[0] = UINT8x8_MAX;\n+  t.a[1] = UINT8x8_MAX;\n+  t.a[2] = UINT8x8_MAX;\n+  t.a[3] = UINT8x8_MAX;\n+  t.a[4] = UINT8x8_MAX;\n+  t.a[5] = UINT8x8_MAX;\n+  t.a[6] = UINT8x8_MAX;\n+  t.a[7] = UINT8x8_MAX;\n+  r.v = paddusb (s.v, t.v);\n+  assert (r.a[0] == UINT8x8_MAX);\n+  assert (r.a[1] == UINT8x8_MAX);\n+  assert (r.a[2] == UINT8x8_MAX);\n+  assert (r.a[3] == UINT8x8_MAX);\n+  assert (r.a[4] == UINT8x8_MAX);\n+  assert (r.a[5] == UINT8x8_MAX);\n+  assert (r.a[6] == UINT8x8_MAX);\n+  assert (r.a[7] == UINT8x8_MAX);\n+}\n+\n+static void test_pandn_ud (void)\n+{\n+  uint64_t d1 = 0x0000ffff0000ffffull;\n+  uint64_t d2 = 0x0000ffff0000ffffull;\n+  uint64_t r;\n+  r = pandn_ud (d1, d2);\n+  assert (r == 0);\n+}\n+\n+static void test_pandn_sd (void)\n+{\n+  int64_t d1 = (int64_t) 0x0000000000000000ull;\n+  int64_t d2 = (int64_t) 0xfffffffffffffffeull;\n+  int64_t r;\n+  r = pandn_sd (d1, d2);\n+  assert (r == -2);\n+}\n+\n+static void test_pandn_uw (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint32x2_encap_t r;\n+  s.a[0] = 0xffffffff;\n+  s.a[1] = 0x00000000;\n+  t.a[0] = 0x00000000;\n+  t.a[1] = 0xffffffff;\n+  r.v = pandn_uw (s.v, t.v);\n+  assert (r.a[0] == 0x00000000);\n+  assert (r.a[1] == 0xffffffff);\n+}\n+\n+static void test_pandn_sw (void)\n+{\n+  int32x2_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = 0xffffffff;\n+  s.a[1] = 0x00000000;\n+  t.a[0] = 0xffffffff;\n+  t.a[1] = 0xfffffffe;\n+  r.v = pandn_sw (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == -2);\n+}\n+\n+static void test_pandn_uh (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 0xffff;\n+  s.a[1] = 0x0000;\n+  s.a[2] = 0xffff;\n+  s.a[3] = 0x0000;\n+  t.a[0] = 0x0000;\n+  t.a[1] = 0xffff;\n+  t.a[2] = 0x0000;\n+  t.a[3] = 0xffff;\n+  r.v = pandn_uh (s.v, t.v);\n+  assert (r.a[0] == 0x0000);\n+  assert (r.a[1] == 0xffff);\n+  assert (r.a[2] == 0x0000);\n+  assert (r.a[3] == 0xffff);\n+}\n+\n+static void test_pandn_sh (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = 0xffff;\n+  s.a[1] = 0x0000;\n+  s.a[2] = 0xffff;\n+  s.a[3] = 0x0000;\n+  t.a[0] = 0xffff;\n+  t.a[1] = 0xfffe;\n+  t.a[2] = 0xffff;\n+  t.a[3] = 0xfffe;\n+  r.v = pandn_sh (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == -2);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == -2);\n+}\n+\n+static void test_pandn_ub (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 0xff;\n+  s.a[1] = 0x00;\n+  s.a[2] = 0xff;\n+  s.a[3] = 0x00;\n+  s.a[4] = 0xff;\n+  s.a[5] = 0x00;\n+  s.a[6] = 0xff;\n+  s.a[7] = 0x00;\n+  t.a[0] = 0x00;\n+  t.a[1] = 0xff;\n+  t.a[2] = 0x00;\n+  t.a[3] = 0xff;\n+  t.a[4] = 0x00;\n+  t.a[5] = 0xff;\n+  t.a[6] = 0x00;\n+  t.a[7] = 0xff;\n+  r.v = pandn_ub (s.v, t.v);\n+  assert (r.a[0] == 0x00);\n+  assert (r.a[1] == 0xff);\n+  assert (r.a[2] == 0x00);\n+  assert (r.a[3] == 0xff);\n+  assert (r.a[4] == 0x00);\n+  assert (r.a[5] == 0xff);\n+  assert (r.a[6] == 0x00);\n+  assert (r.a[7] == 0xff);\n+}\n+\n+static void test_pandn_sb (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = 0xff;\n+  s.a[1] = 0x00;\n+  s.a[2] = 0xff;\n+  s.a[3] = 0x00;\n+  s.a[4] = 0xff;\n+  s.a[5] = 0x00;\n+  s.a[6] = 0xff;\n+  s.a[7] = 0x00;\n+  t.a[0] = 0xff;\n+  t.a[1] = 0xfe;\n+  t.a[2] = 0xff;\n+  t.a[3] = 0xfe;\n+  t.a[4] = 0xff;\n+  t.a[5] = 0xfe;\n+  t.a[6] = 0xff;\n+  t.a[7] = 0xfe;\n+  r.v = pandn_sb (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == -2);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == -2);\n+  assert (r.a[4] == 0);\n+  assert (r.a[5] == -2);\n+  assert (r.a[6] == 0);\n+  assert (r.a[7] == -2);\n+}\n+\n+static void test_pavgh (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 2;\n+  s.a[2] = 3;\n+  s.a[3] = 4;\n+  t.a[0] = 5;\n+  t.a[1] = 6;\n+  t.a[2] = 7;\n+  t.a[3] = 8;\n+  r.v = pavgh (s.v, t.v);\n+  assert (r.a[0] == 3);\n+  assert (r.a[1] == 4);\n+  assert (r.a[2] == 5);\n+  assert (r.a[3] == 6);\n+}\n+\n+static void test_pavgb (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 2;\n+  s.a[2] = 3;\n+  s.a[3] = 4;\n+  s.a[4] = 1;\n+  s.a[5] = 2;\n+  s.a[6] = 3;\n+  s.a[7] = 4;\n+  t.a[0] = 5;\n+  t.a[1] = 6;\n+  t.a[2] = 7;\n+  t.a[3] = 8;\n+  t.a[4] = 5;\n+  t.a[5] = 6;\n+  t.a[6] = 7;\n+  t.a[7] = 8;\n+  r.v = pavgb (s.v, t.v);\n+  assert (r.a[0] == 3);\n+  assert (r.a[1] == 4);\n+  assert (r.a[2] == 5);\n+  assert (r.a[3] == 6);\n+  assert (r.a[4] == 3);\n+  assert (r.a[5] == 4);\n+  assert (r.a[6] == 5);\n+  assert (r.a[7] == 6);\n+}\n+\n+static void test_pcmpeqw_u (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint32x2_encap_t r;\n+  s.a[0] = 42;\n+  s.a[1] = 43;\n+  t.a[0] = 43;\n+  t.a[1] = 43;\n+  r.v = pcmpeqw_u (s.v, t.v);\n+  assert (r.a[0] == 0x00000000);\n+  assert (r.a[1] == 0xffffffff);\n+}\n+\n+static void test_pcmpeqh_u (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 42;\n+  s.a[1] = 43;\n+  s.a[2] = 42;\n+  s.a[3] = 43;\n+  t.a[0] = 43;\n+  t.a[1] = 43;\n+  t.a[2] = 43;\n+  t.a[3] = 43;\n+  r.v = pcmpeqh_u (s.v, t.v);\n+  assert (r.a[0] == 0x0000);\n+  assert (r.a[1] == 0xffff);\n+  assert (r.a[2] == 0x0000);\n+  assert (r.a[3] == 0xffff);\n+}\n+\n+static void test_pcmpeqb_u (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 42;\n+  s.a[1] = 43;\n+  s.a[2] = 42;\n+  s.a[3] = 43;\n+  s.a[4] = 42;\n+  s.a[5] = 43;\n+  s.a[6] = 42;\n+  s.a[7] = 43;\n+  t.a[0] = 43;\n+  t.a[1] = 43;\n+  t.a[2] = 43;\n+  t.a[3] = 43;\n+  t.a[4] = 43;\n+  t.a[5] = 43;\n+  t.a[6] = 43;\n+  t.a[7] = 43;\n+  r.v = pcmpeqb_u (s.v, t.v);\n+  assert (r.a[0] == 0x00);\n+  assert (r.a[1] == 0xff);\n+  assert (r.a[2] == 0x00);\n+  assert (r.a[3] == 0xff);\n+  assert (r.a[4] == 0x00);\n+  assert (r.a[5] == 0xff);\n+  assert (r.a[6] == 0x00);\n+  assert (r.a[7] == 0xff);\n+}\n+\n+static void test_pcmpeqw_s (void)\n+{\n+  int32x2_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = -42;\n+  s.a[1] = -42;\n+  t.a[0] = 42;\n+  t.a[1] = -42;\n+  r.v = pcmpeqw_s (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == -1);\n+}\n+\n+static void test_pcmpeqh_s (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -42;\n+  s.a[1] = -42;\n+  s.a[2] = -42;\n+  s.a[3] = -42;\n+  t.a[0] = 42;\n+  t.a[1] = -42;\n+  t.a[2] = 42;\n+  t.a[3] = -42;\n+  r.v = pcmpeqh_s (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == -1);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == -1);\n+}\n+\n+static void test_pcmpeqb_s (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -42;\n+  s.a[1] = -42;\n+  s.a[2] = -42;\n+  s.a[3] = -42;\n+  s.a[4] = -42;\n+  s.a[5] = -42;\n+  s.a[6] = -42;\n+  s.a[7] = -42;\n+  t.a[0] = 42;\n+  t.a[1] = -42;\n+  t.a[2] = 42;\n+  t.a[3] = -42;\n+  t.a[4] = 42;\n+  t.a[5] = -42;\n+  t.a[6] = 42;\n+  t.a[7] = -42;\n+  r.v = pcmpeqb_s (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == -1);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == -1);\n+  assert (r.a[4] == 0);\n+  assert (r.a[5] == -1);\n+  assert (r.a[6] == 0);\n+  assert (r.a[7] == -1);\n+}\n+\n+static void test_pcmpgtw_u (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint32x2_encap_t r;\n+  s.a[0] = 42;\n+  s.a[1] = 43;\n+  t.a[0] = 43;\n+  t.a[1] = 42;\n+  r.v = pcmpgtw_u (s.v, t.v);\n+  assert (r.a[0] == 0x00000000);\n+  assert (r.a[1] == 0xffffffff);\n+}\n+\n+static void test_pcmpgth_u (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 40;\n+  s.a[1] = 41;\n+  s.a[2] = 42;\n+  s.a[3] = 43;\n+  t.a[0] = 40;\n+  t.a[1] = 41;\n+  t.a[2] = 43;\n+  t.a[3] = 42;\n+  r.v = pcmpgth_u (s.v, t.v);\n+  assert (r.a[0] == 0x0000);\n+  assert (r.a[1] == 0x0000);\n+  assert (r.a[2] == 0x0000);\n+  assert (r.a[3] == 0xffff);\n+}\n+\n+static void test_pcmpgtb_u (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 40;\n+  s.a[1] = 41;\n+  s.a[2] = 42;\n+  s.a[3] = 43;\n+  s.a[4] = 44;\n+  s.a[5] = 45;\n+  s.a[6] = 46;\n+  s.a[7] = 47;\n+  t.a[0] = 48;\n+  t.a[1] = 47;\n+  t.a[2] = 46;\n+  t.a[3] = 45;\n+  t.a[4] = 44;\n+  t.a[5] = 43;\n+  t.a[6] = 42;\n+  t.a[7] = 41;\n+  r.v = pcmpgtb_u (s.v, t.v);\n+  assert (r.a[0] == 0x00);\n+  assert (r.a[1] == 0x00);\n+  assert (r.a[2] == 0x00);\n+  assert (r.a[3] == 0x00);\n+  assert (r.a[4] == 0x00);\n+  assert (r.a[5] == 0xff);\n+  assert (r.a[6] == 0xff);\n+  assert (r.a[7] == 0xff);\n+}\n+\n+static void test_pcmpgtw_s (void)\n+{\n+  int32x2_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = 42;\n+  s.a[1] = -42;\n+  t.a[0] = -42;\n+  t.a[1] = -42;\n+  r.v = pcmpgtw_s (s.v, t.v);\n+  assert (r.a[0] == -1);\n+  assert (r.a[1] == 0);\n+}\n+\n+static void test_pcmpgth_s (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -42;\n+  s.a[1] = -42;\n+  s.a[2] = -42;\n+  s.a[3] = -42;\n+  t.a[0] = 42;\n+  t.a[1] = 43;\n+  t.a[2] = 44;\n+  t.a[3] = -43;\n+  r.v = pcmpgth_s (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == -1);\n+}\n+\n+static void test_pcmpgtb_s (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -42;\n+  s.a[1] = -42;\n+  s.a[2] = -42;\n+  s.a[3] = -42;\n+  s.a[4] = 42;\n+  s.a[5] = 42;\n+  s.a[6] = 42;\n+  s.a[7] = 42;\n+  t.a[0] = -45;\n+  t.a[1] = -44;\n+  t.a[2] = -43;\n+  t.a[3] = -42;\n+  t.a[4] = 42;\n+  t.a[5] = 43;\n+  t.a[6] = 41;\n+  t.a[7] = 40;\n+  r.v = pcmpgtb_s (s.v, t.v);\n+  assert (r.a[0] == -1);\n+  assert (r.a[1] == -1);\n+  assert (r.a[2] == -1);\n+  assert (r.a[3] == 0);\n+  assert (r.a[4] == 0);\n+  assert (r.a[5] == 0);\n+  assert (r.a[6] == -1);\n+  assert (r.a[7] == -1);\n+}\n+\n+static void test_pextrh_u (void)\n+{\n+  uint16x4_encap_t s;\n+  uint16x4_encap_t r;\n+  s.a[0] = 40;\n+  s.a[1] = 41;\n+  s.a[2] = 42;\n+  s.a[3] = 43;\n+  r.v = pextrh_u (s.v, 1);\n+  assert (r.a[0] == 41);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+}\n+\n+static void test_pextrh_s (void)\n+{\n+  int16x4_encap_t s;\n+  int16x4_encap_t r;\n+  s.a[0] = -40;\n+  s.a[1] = -41;\n+  s.a[2] = -42;\n+  s.a[3] = -43;\n+  r.v = pextrh_s (s.v, 2);\n+  assert (r.a[0] == -42);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+}\n+\n+static void test_pinsrh_0123_u (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 42;\n+  s.a[1] = 0;\n+  s.a[2] = 0;\n+  s.a[3] = 0;\n+  t.a[0] = 0;\n+  t.a[1] = 0;\n+  t.a[2] = 0;\n+  t.a[3] = 0;\n+  r.v = pinsrh_0_u (t.v, s.v);\n+  r.v = pinsrh_1_u (r.v, s.v);\n+  r.v = pinsrh_2_u (r.v, s.v);\n+  r.v = pinsrh_3_u (r.v, s.v);\n+  assert (r.a[0] == 42);\n+  assert (r.a[1] == 42);\n+  assert (r.a[2] == 42);\n+  assert (r.a[3] == 42);\n+}\n+\n+static void test_pinsrh_0123_s (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -42;\n+  s.a[1] = 0;\n+  s.a[2] = 0;\n+  s.a[3] = 0;\n+  t.a[0] = 0;\n+  t.a[1] = 0;\n+  t.a[2] = 0;\n+  t.a[3] = 0;\n+  r.v = pinsrh_0_s (t.v, s.v);\n+  r.v = pinsrh_1_s (r.v, s.v);\n+  r.v = pinsrh_2_s (r.v, s.v);\n+  r.v = pinsrh_3_s (r.v, s.v);\n+  assert (r.a[0] == -42);\n+  assert (r.a[1] == -42);\n+  assert (r.a[2] == -42);\n+  assert (r.a[3] == -42);\n+}\n+\n+static void test_pmaddhw (void)\n+{\n+  int16x4_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = -5;\n+  s.a[1] = -4;\n+  s.a[2] = -3;\n+  s.a[3] = -2;\n+  t.a[0] = 10;\n+  t.a[1] = 11;\n+  t.a[2] = 12;\n+  t.a[3] = 13;\n+  r.v = pmaddhw (s.v, t.v);\n+  assert (r.a[0] == (-5*10 + -4*11));\n+  assert (r.a[1] == (-3*12 + -2*13));\n+}\n+\n+static void test_pmaxsh (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -20;\n+  s.a[1] = 40;\n+  s.a[2] = -10;\n+  s.a[3] = 50;\n+  t.a[0] = 20;\n+  t.a[1] = -40;\n+  t.a[2] = 10;\n+  t.a[3] = -50;\n+  r.v = pmaxsh (s.v, t.v);\n+  assert (r.a[0] == 20);\n+  assert (r.a[1] == 40);\n+  assert (r.a[2] == 10);\n+  assert (r.a[3] == 50);\n+}\n+\n+static void test_pmaxub (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 10;\n+  s.a[1] = 20;\n+  s.a[2] = 30;\n+  s.a[3] = 40;\n+  s.a[4] = 50;\n+  s.a[5] = 60;\n+  s.a[6] = 70;\n+  s.a[7] = 80;\n+  t.a[0] = 80;\n+  t.a[1] = 70;\n+  t.a[2] = 60;\n+  t.a[3] = 50;\n+  t.a[4] = 40;\n+  t.a[5] = 30;\n+  t.a[6] = 20;\n+  t.a[7] = 10;\n+  r.v = pmaxub (s.v, t.v);\n+  assert (r.a[0] == 80);\n+  assert (r.a[1] == 70);\n+  assert (r.a[2] == 60);\n+  assert (r.a[3] == 50);\n+  assert (r.a[4] == 50);\n+  assert (r.a[5] == 60);\n+  assert (r.a[6] == 70);\n+  assert (r.a[7] == 80);\n+}\n+\n+static void test_pminsh (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -20;\n+  s.a[1] = 40;\n+  s.a[2] = -10;\n+  s.a[3] = 50;\n+  t.a[0] = 20;\n+  t.a[1] = -40;\n+  t.a[2] = 10;\n+  t.a[3] = -50;\n+  r.v = pminsh (s.v, t.v);\n+  assert (r.a[0] == -20);\n+  assert (r.a[1] == -40);\n+  assert (r.a[2] == -10);\n+  assert (r.a[3] == -50);\n+}\n+\n+static void test_pminub (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 10;\n+  s.a[1] = 20;\n+  s.a[2] = 30;\n+  s.a[3] = 40;\n+  s.a[4] = 50;\n+  s.a[5] = 60;\n+  s.a[6] = 70;\n+  s.a[7] = 80;\n+  t.a[0] = 80;\n+  t.a[1] = 70;\n+  t.a[2] = 60;\n+  t.a[3] = 50;\n+  t.a[4] = 40;\n+  t.a[5] = 30;\n+  t.a[6] = 20;\n+  t.a[7] = 10;\n+  r.v = pminub (s.v, t.v);\n+  assert (r.a[0] == 10);\n+  assert (r.a[1] == 20);\n+  assert (r.a[2] == 30);\n+  assert (r.a[3] == 40);\n+  assert (r.a[4] == 40);\n+  assert (r.a[5] == 30);\n+  assert (r.a[6] == 20);\n+  assert (r.a[7] == 10);\n+}\n+\n+static void test_pmovmskb_u (void)\n+{\n+  uint8x8_encap_t s;\n+  uint8x8_encap_t r;\n+  s.a[0] = 0xf0;\n+  s.a[1] = 0x40;\n+  s.a[2] = 0xf0;\n+  s.a[3] = 0x40;\n+  s.a[4] = 0xf0;\n+  s.a[5] = 0x40;\n+  s.a[6] = 0xf0;\n+  s.a[7] = 0x40;\n+  r.v = pmovmskb_u (s.v);\n+  assert (r.a[0] == 0x55);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+  assert (r.a[4] == 0);\n+  assert (r.a[5] == 0);\n+  assert (r.a[6] == 0);\n+  assert (r.a[7] == 0);\n+}\n+\n+static void test_pmovmskb_s (void)\n+{\n+  int8x8_encap_t s;\n+  int8x8_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = 1;\n+  s.a[2] = -1;\n+  s.a[3] = 1;\n+  s.a[4] = -1;\n+  s.a[5] = 1;\n+  s.a[6] = -1;\n+  s.a[7] = 1;\n+  r.v = pmovmskb_s (s.v);\n+  assert (r.a[0] == 0x55);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+  assert (r.a[4] == 0);\n+  assert (r.a[5] == 0);\n+  assert (r.a[6] == 0);\n+  assert (r.a[7] == 0);\n+}\n+\n+static void test_pmulhuh (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 0xff00;\n+  s.a[1] = 0xff00;\n+  s.a[2] = 0xff00;\n+  s.a[3] = 0xff00;\n+  t.a[0] = 16;\n+  t.a[1] = 16;\n+  t.a[2] = 16;\n+  t.a[3] = 16;\n+  r.v = pmulhuh (s.v, t.v);\n+  assert (r.a[0] == 0x000f);\n+  assert (r.a[1] == 0x000f);\n+  assert (r.a[2] == 0x000f);\n+  assert (r.a[3] == 0x000f);\n+}\n+\n+static void test_pmulhh (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = 0x0ff0;\n+  s.a[1] = 0x0ff0;\n+  s.a[2] = 0x0ff0;\n+  s.a[3] = 0x0ff0;\n+  t.a[0] = -16*16;\n+  t.a[1] = -16*16;\n+  t.a[2] = -16*16;\n+  t.a[3] = -16*16;\n+  r.v = pmulhh (s.v, t.v);\n+  assert (r.a[0] == -16);\n+  assert (r.a[1] == -16);\n+  assert (r.a[2] == -16);\n+  assert (r.a[3] == -16);\n+}\n+\n+static void test_pmullh (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = 0x0ff0;\n+  s.a[1] = 0x0ff0;\n+  s.a[2] = 0x0ff0;\n+  s.a[3] = 0x0ff0;\n+  t.a[0] = -16*16;\n+  t.a[1] = -16*16;\n+  t.a[2] = -16*16;\n+  t.a[3] = -16*16;\n+  r.v = pmullh (s.v, t.v);\n+  assert (r.a[0] == 4096);\n+  assert (r.a[1] == 4096);\n+  assert (r.a[2] == 4096);\n+  assert (r.a[3] == 4096);\n+}\n+\n+static void test_pmuluw (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint64_t r;\n+  s.a[0] = 0xdeadbeef;\n+  s.a[1] = 0;\n+  t.a[0] = 0x0f00baaa;\n+  t.a[1] = 0;\n+  r = pmuluw (s.v, t.v);\n+  assert (r == 0xd0cd08e1d1a70b6ull);\n+}\n+\n+static void test_pasubub (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 10;\n+  s.a[1] = 20;\n+  s.a[2] = 30;\n+  s.a[3] = 40;\n+  s.a[4] = 50;\n+  s.a[5] = 60;\n+  s.a[6] = 70;\n+  s.a[7] = 80;\n+  t.a[0] = 80;\n+  t.a[1] = 70;\n+  t.a[2] = 60;\n+  t.a[3] = 50;\n+  t.a[4] = 40;\n+  t.a[5] = 30;\n+  t.a[6] = 20;\n+  t.a[7] = 10;\n+  r.v = pasubub (s.v, t.v);\n+  assert (r.a[0] == 70);\n+  assert (r.a[1] == 50);\n+  assert (r.a[2] == 30);\n+  assert (r.a[3] == 10);\n+  assert (r.a[4] == 10);\n+  assert (r.a[5] == 30);\n+  assert (r.a[6] == 50);\n+  assert (r.a[7] == 70);\n+}\n+\n+static void test_biadd (void)\n+{\n+  uint8x8_encap_t s;\n+  uint16x4_encap_t r;\n+  s.a[0] = 10;\n+  s.a[1] = 20;\n+  s.a[2] = 30;\n+  s.a[3] = 40;\n+  s.a[4] = 50;\n+  s.a[5] = 60;\n+  s.a[6] = 70;\n+  s.a[7] = 80;\n+  r.v = biadd (s.v);\n+  assert (r.a[0] == 360);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+}\n+\n+static void test_psadbh (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 10;\n+  s.a[1] = 20;\n+  s.a[2] = 30;\n+  s.a[3] = 40;\n+  s.a[4] = 50;\n+  s.a[5] = 60;\n+  s.a[6] = 70;\n+  s.a[7] = 80;\n+  t.a[0] = 80;\n+  t.a[1] = 70;\n+  t.a[2] = 60;\n+  t.a[3] = 50;\n+  t.a[4] = 40;\n+  t.a[5] = 30;\n+  t.a[6] = 20;\n+  t.a[7] = 10;\n+  r.v = psadbh (s.v, t.v);\n+  assert (r.a[0] == 0x0140);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+}\n+\n+static void test_pshufh_u (void)\n+{\n+  uint16x4_encap_t s;\n+  uint16x4_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 2;\n+  s.a[2] = 3;\n+  s.a[3] = 4;\n+  r.a[0] = 0;\n+  r.a[1] = 0;\n+  r.a[2] = 0;\n+  r.a[3] = 0;\n+  r.v = pshufh_u (r.v, s.v, 0xe5);\n+  assert (r.a[0] == 2);\n+  assert (r.a[1] == 2);\n+  assert (r.a[2] == 3);\n+  assert (r.a[3] == 4);\n+}\n+\n+static void test_pshufh_s (void)\n+{\n+  int16x4_encap_t s;\n+  int16x4_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = 2;\n+  s.a[2] = -3;\n+  s.a[3] = 4;\n+  r.a[0] = 0;\n+  r.a[1] = 0;\n+  r.a[2] = 0;\n+  r.a[3] = 0;\n+  r.v = pshufh_s (r.v, s.v, 0xe5);\n+  assert (r.a[0] == 2);\n+  assert (r.a[1] == 2);\n+  assert (r.a[2] == -3);\n+  assert (r.a[3] == 4);\n+}\n+\n+static void test_psllh_u (void)\n+{\n+  uint16x4_encap_t s;\n+  uint16x4_encap_t r;\n+  s.a[0] = 0xffff;\n+  s.a[1] = 0xffff;\n+  s.a[2] = 0xffff;\n+  s.a[3] = 0xffff;\n+  r.v = psllh_u (s.v, 1);\n+  assert (r.a[0] == 0xfffe);\n+  assert (r.a[1] == 0xfffe);\n+  assert (r.a[2] == 0xfffe);\n+  assert (r.a[3] == 0xfffe);\n+}\n+\n+static void test_psllw_u (void)\n+{\n+  uint32x2_encap_t s;\n+  uint32x2_encap_t r;\n+  s.a[0] = 0xffffffff;\n+  s.a[1] = 0xffffffff;\n+  r.v = psllw_u (s.v, 2);\n+  assert (r.a[0] == 0xfffffffc);\n+  assert (r.a[1] == 0xfffffffc);\n+}\n+\n+static void test_psllh_s (void)\n+{\n+  int16x4_encap_t s;\n+  int16x4_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = -1;\n+  s.a[2] = -1;\n+  s.a[3] = -1;\n+  r.v = psllh_s (s.v, 1);\n+  assert (r.a[0] == -2);\n+  assert (r.a[1] == -2);\n+  assert (r.a[2] == -2);\n+  assert (r.a[3] == -2);\n+}\n+\n+static void test_psllw_s (void)\n+{\n+  int32x2_encap_t s;\n+  int32x2_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = -1;\n+  r.v = psllw_s (s.v, 2);\n+  assert (r.a[0] == -4);\n+  assert (r.a[1] == -4);\n+}\n+\n+static void test_psrah_u (void)\n+{\n+  uint16x4_encap_t s;\n+  uint16x4_encap_t r;\n+  s.a[0] = 0xffef;\n+  s.a[1] = 0xffef;\n+  s.a[2] = 0xffef;\n+  s.a[3] = 0xffef;\n+  r.v = psrah_u (s.v, 1);\n+  assert (r.a[0] == 0xfff7);\n+  assert (r.a[1] == 0xfff7);\n+  assert (r.a[2] == 0xfff7);\n+  assert (r.a[3] == 0xfff7);\n+}\n+\n+static void test_psraw_u (void)\n+{\n+  uint32x2_encap_t s;\n+  uint32x2_encap_t r;\n+  s.a[0] = 0xffffffef;\n+  s.a[1] = 0xffffffef;\n+  r.v = psraw_u (s.v, 1);\n+  assert (r.a[0] == 0xfffffff7);\n+  assert (r.a[1] == 0xfffffff7);\n+}\n+\n+static void test_psrah_s (void)\n+{\n+  int16x4_encap_t s;\n+  int16x4_encap_t r;\n+  s.a[0] = -2;\n+  s.a[1] = -2;\n+  s.a[2] = -2;\n+  s.a[3] = -2;\n+  r.v = psrah_s (s.v, 1);\n+  assert (r.a[0] == -1);\n+  assert (r.a[1] == -1);\n+  assert (r.a[2] == -1);\n+  assert (r.a[3] == -1);\n+}\n+\n+static void test_psraw_s (void)\n+{\n+  int32x2_encap_t s;\n+  int32x2_encap_t r;\n+  s.a[0] = -2;\n+  s.a[1] = -2;\n+  r.v = psraw_s (s.v, 1);\n+  assert (r.a[0] == -1);\n+  assert (r.a[1] == -1);\n+}\n+\n+static void test_psrlh_u (void)\n+{\n+  uint16x4_encap_t s;\n+  uint16x4_encap_t r;\n+  s.a[0] = 0xffef;\n+  s.a[1] = 0xffef;\n+  s.a[2] = 0xffef;\n+  s.a[3] = 0xffef;\n+  r.v = psrlh_u (s.v, 1);\n+  assert (r.a[0] == 0x7ff7);\n+  assert (r.a[1] == 0x7ff7);\n+  assert (r.a[2] == 0x7ff7);\n+  assert (r.a[3] == 0x7ff7);\n+}\n+\n+static void test_psrlw_u (void)\n+{\n+  uint32x2_encap_t s;\n+  uint32x2_encap_t r;\n+  s.a[0] = 0xffffffef;\n+  s.a[1] = 0xffffffef;\n+  r.v = psrlw_u (s.v, 1);\n+  assert (r.a[0] == 0x7ffffff7);\n+  assert (r.a[1] == 0x7ffffff7);\n+}\n+\n+static void test_psrlh_s (void)\n+{\n+  int16x4_encap_t s;\n+  int16x4_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = -1;\n+  s.a[2] = -1;\n+  s.a[3] = -1;\n+  r.v = psrlh_s (s.v, 1);\n+  assert (r.a[0] == INT16x4_MAX);\n+  assert (r.a[1] == INT16x4_MAX);\n+  assert (r.a[2] == INT16x4_MAX);\n+  assert (r.a[3] == INT16x4_MAX);\n+}\n+\n+static void test_psrlw_s (void)\n+{\n+  int32x2_encap_t s;\n+  int32x2_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = -1;\n+  r.v = psrlw_s (s.v, 1);\n+  assert (r.a[0] == INT32x2_MAX);\n+  assert (r.a[1] == INT32x2_MAX);\n+}\n+\n+static void test_psubw_u (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint32x2_encap_t r;\n+  s.a[0] = 3;\n+  s.a[1] = 4;\n+  t.a[0] = 2;\n+  t.a[1] = 1;\n+  r.v = psubw_u (s.v, t.v);\n+  assert (r.a[0] == 1);\n+  assert (r.a[1] == 3);\n+}\n+\n+static void test_psubw_s (void)\n+{\n+  int32x2_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = -2;\n+  s.a[1] = -1;\n+  t.a[0] = 3;\n+  t.a[1] = -4;\n+  r.v = psubw_s (s.v, t.v);\n+  assert (r.a[0] == -5);\n+  assert (r.a[1] == 3);\n+}\n+\n+static void test_psubh_u (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 5;\n+  s.a[1] = 6;\n+  s.a[2] = 7;\n+  s.a[3] = 8;\n+  t.a[0] = 1;\n+  t.a[1] = 2;\n+  t.a[2] = 3;\n+  t.a[3] = 4;\n+  r.v = psubh_u (s.v, t.v);\n+  assert (r.a[0] == 4);\n+  assert (r.a[1] == 4);\n+  assert (r.a[2] == 4);\n+  assert (r.a[3] == 4);\n+}\n+\n+static void test_psubh_s (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -10;\n+  s.a[1] = -20;\n+  s.a[2] = -30;\n+  s.a[3] = -40;\n+  t.a[0] = 1;\n+  t.a[1] = 2;\n+  t.a[2] = 3;\n+  t.a[3] = 4;\n+  r.v = psubh_s (s.v, t.v);\n+  assert (r.a[0] == -11);\n+  assert (r.a[1] == -22);\n+  assert (r.a[2] == -33);\n+  assert (r.a[3] == -44);\n+}\n+\n+static void test_psubb_u (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 10;\n+  s.a[1] = 11;\n+  s.a[2] = 12;\n+  s.a[3] = 13;\n+  s.a[4] = 14;\n+  s.a[5] = 15;\n+  s.a[6] = 16;\n+  s.a[7] = 17;\n+  t.a[0] = 1;\n+  t.a[1] = 2;\n+  t.a[2] = 3;\n+  t.a[3] = 4;\n+  t.a[4] = 5;\n+  t.a[5] = 6;\n+  t.a[6] = 7;\n+  t.a[7] = 8;\n+  r.v = psubb_u (s.v, t.v);\n+  assert (r.a[0] == 9);\n+  assert (r.a[1] == 9);\n+  assert (r.a[2] == 9);\n+  assert (r.a[3] == 9);\n+  assert (r.a[4] == 9);\n+  assert (r.a[5] == 9);\n+  assert (r.a[6] == 9);\n+  assert (r.a[7] == 9);\n+}\n+\n+static void test_psubb_s (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -10;\n+  s.a[1] = -20;\n+  s.a[2] = -30;\n+  s.a[3] = -40;\n+  s.a[4] = -50;\n+  s.a[5] = -60;\n+  s.a[6] = -70;\n+  s.a[7] = -80;\n+  t.a[0] = 1;\n+  t.a[1] = 2;\n+  t.a[2] = 3;\n+  t.a[3] = 4;\n+  t.a[4] = 5;\n+  t.a[5] = 6;\n+  t.a[6] = 7;\n+  t.a[7] = 8;\n+  r.v = psubb_s (s.v, t.v);\n+  assert (r.a[0] == -11);\n+  assert (r.a[1] == -22);\n+  assert (r.a[2] == -33);\n+  assert (r.a[3] == -44);\n+  assert (r.a[4] == -55);\n+  assert (r.a[5] == -66);\n+  assert (r.a[6] == -77);\n+  assert (r.a[7] == -88);\n+}\n+\n+static void test_psubd_u (void)\n+{\n+  uint64_t d = 789012;\n+  uint64_t e = 123456;\n+  uint64_t r;\n+  r = psubd_u (d, e);\n+  assert (r == 665556);\n+}\n+\n+static void test_psubd_s (void)\n+{\n+  int64_t d = 123456;\n+  int64_t e = -789012;\n+  int64_t r;\n+  r = psubd_s (d, e);\n+  assert (r == 912468);\n+}\n+\n+static void test_psubsh (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = 0;\n+  s.a[2] = 1;\n+  s.a[3] = 2;\n+  t.a[0] = -INT16x4_MAX;\n+  t.a[1] = -INT16x4_MAX;\n+  t.a[2] = -INT16x4_MAX;\n+  t.a[3] = -INT16x4_MAX;\n+  r.v = psubsh (s.v, t.v);\n+  assert (r.a[0] == INT16x4_MAX - 1);\n+  assert (r.a[1] == INT16x4_MAX);\n+  assert (r.a[2] == INT16x4_MAX);\n+  assert (r.a[3] == INT16x4_MAX);\n+}\n+\n+static void test_psubsb (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -6;\n+  s.a[1] = -5;\n+  s.a[2] = -4;\n+  s.a[3] = -3;\n+  s.a[4] = -2;\n+  s.a[5] = -1;\n+  s.a[6] = 0;\n+  s.a[7] = 1;\n+  t.a[0] = -INT8x8_MAX;\n+  t.a[1] = -INT8x8_MAX;\n+  t.a[2] = -INT8x8_MAX;\n+  t.a[3] = -INT8x8_MAX;\n+  t.a[4] = -INT8x8_MAX;\n+  t.a[5] = -INT8x8_MAX;\n+  t.a[6] = -INT8x8_MAX;\n+  t.a[7] = -INT8x8_MAX;\n+  r.v = psubsb (s.v, t.v);\n+  assert (r.a[0] == INT8x8_MAX - 6);\n+  assert (r.a[1] == INT8x8_MAX - 5);\n+  assert (r.a[2] == INT8x8_MAX - 4);\n+  assert (r.a[3] == INT8x8_MAX - 3);\n+  assert (r.a[4] == INT8x8_MAX - 2);\n+  assert (r.a[5] == INT8x8_MAX - 1);\n+  assert (r.a[6] == INT8x8_MAX);\n+  assert (r.a[7] == INT8x8_MAX);\n+}\n+\n+static void test_psubush (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 0;\n+  s.a[1] = 1;\n+  s.a[2] = 2;\n+  s.a[3] = 3;\n+  t.a[0] = 1;\n+  t.a[1] = 1;\n+  t.a[2] = 3;\n+  t.a[3] = 3;\n+  r.v = psubush (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+}\n+\n+static void test_psubusb (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 0;\n+  s.a[1] = 1;\n+  s.a[2] = 2;\n+  s.a[3] = 3;\n+  s.a[4] = 4;\n+  s.a[5] = 5;\n+  s.a[6] = 6;\n+  s.a[7] = 7;\n+  t.a[0] = 1;\n+  t.a[1] = 1;\n+  t.a[2] = 3;\n+  t.a[3] = 3;\n+  t.a[4] = 5;\n+  t.a[5] = 5;\n+  t.a[6] = 7;\n+  t.a[7] = 7;\n+  r.v = psubusb (s.v, t.v);\n+  assert (r.a[0] == 0);\n+  assert (r.a[1] == 0);\n+  assert (r.a[2] == 0);\n+  assert (r.a[3] == 0);\n+  assert (r.a[4] == 0);\n+  assert (r.a[5] == 0);\n+  assert (r.a[6] == 0);\n+  assert (r.a[7] == 0);\n+}\n+\n+static void test_punpckhbh_s (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = -3;\n+  s.a[2] = -5;\n+  s.a[3] = -7;\n+  s.a[4] = -9;\n+  s.a[5] = -11;\n+  s.a[6] = -13;\n+  s.a[7] = -15;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  t.a[2] = 6;\n+  t.a[3] = 8;\n+  t.a[4] = 10;\n+  t.a[5] = 12;\n+  t.a[6] = 14;\n+  t.a[7] = 16;\n+  r.v = punpckhbh_s (s.v, t.v);\n+  assert (r.a[0] == -9);\n+  assert (r.a[1] == 10);\n+  assert (r.a[2] == -11);\n+  assert (r.a[3] == 12);\n+  assert (r.a[4] == -13);\n+  assert (r.a[5] == 14);\n+  assert (r.a[6] == -15);\n+  assert (r.a[7] == 16);\n+}\n+\n+static void test_punpckhbh_u (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  s.a[2] = 5;\n+  s.a[3] = 7;\n+  s.a[4] = 9;\n+  s.a[5] = 11;\n+  s.a[6] = 13;\n+  s.a[7] = 15;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  t.a[2] = 6;\n+  t.a[3] = 8;\n+  t.a[4] = 10;\n+  t.a[5] = 12;\n+  t.a[6] = 14;\n+  t.a[7] = 16;\n+  r.v = punpckhbh_u (s.v, t.v);\n+  assert (r.a[0] == 9);\n+  assert (r.a[1] == 10);\n+  assert (r.a[2] == 11);\n+  assert (r.a[3] == 12);\n+  assert (r.a[4] == 13);\n+  assert (r.a[5] == 14);\n+  assert (r.a[6] == 15);\n+  assert (r.a[7] == 16);\n+}\n+\n+static void test_punpckhhw_s (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = 3;\n+  s.a[2] = -5;\n+  s.a[3] = 7;\n+  t.a[0] = -2;\n+  t.a[1] = 4;\n+  t.a[2] = -6;\n+  t.a[3] = 8;\n+  r.v = punpckhhw_s (s.v, t.v);\n+  assert (r.a[0] == -5);\n+  assert (r.a[1] == -6);\n+  assert (r.a[2] == 7);\n+  assert (r.a[3] == 8);\n+}\n+\n+static void test_punpckhhw_u (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  s.a[2] = 5;\n+  s.a[3] = 7;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  t.a[2] = 6;\n+  t.a[3] = 8;\n+  r.v = punpckhhw_u (s.v, t.v);\n+  assert (r.a[0] == 5);\n+  assert (r.a[1] == 6);\n+  assert (r.a[2] == 7);\n+  assert (r.a[3] == 8);\n+}\n+\n+static void test_punpckhwd_s (void)\n+{\n+  int32x2_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  t.a[0] = 2;\n+  t.a[1] = -4;\n+  r.v = punpckhwd_s (s.v, t.v);\n+  assert (r.a[0] == 3);\n+  assert (r.a[1] == -4);\n+}\n+\n+static void test_punpckhwd_u (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint32x2_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  r.v = punpckhwd_u (s.v, t.v);\n+  assert (r.a[0] == 3);\n+  assert (r.a[1] == 4);\n+}\n+\n+static void test_punpcklbh_s (void)\n+{\n+  int8x8_encap_t s, t;\n+  int8x8_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = -3;\n+  s.a[2] = -5;\n+  s.a[3] = -7;\n+  s.a[4] = -9;\n+  s.a[5] = -11;\n+  s.a[6] = -13;\n+  s.a[7] = -15;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  t.a[2] = 6;\n+  t.a[3] = 8;\n+  t.a[4] = 10;\n+  t.a[5] = 12;\n+  t.a[6] = 14;\n+  t.a[7] = 16;\n+  r.v = punpcklbh_s (s.v, t.v);\n+  assert (r.a[0] == -1);\n+  assert (r.a[1] == 2);\n+  assert (r.a[2] == -3);\n+  assert (r.a[3] == 4);\n+  assert (r.a[4] == -5);\n+  assert (r.a[5] == 6);\n+  assert (r.a[6] == -7);\n+  assert (r.a[7] == 8);\n+}\n+\n+static void test_punpcklbh_u (void)\n+{\n+  uint8x8_encap_t s, t;\n+  uint8x8_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  s.a[2] = 5;\n+  s.a[3] = 7;\n+  s.a[4] = 9;\n+  s.a[5] = 11;\n+  s.a[6] = 13;\n+  s.a[7] = 15;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  t.a[2] = 6;\n+  t.a[3] = 8;\n+  t.a[4] = 10;\n+  t.a[5] = 12;\n+  t.a[6] = 14;\n+  t.a[7] = 16;\n+  r.v = punpcklbh_u (s.v, t.v);\n+  assert (r.a[0] == 1);\n+  assert (r.a[1] == 2);\n+  assert (r.a[2] == 3);\n+  assert (r.a[3] == 4);\n+  assert (r.a[4] == 5);\n+  assert (r.a[5] == 6);\n+  assert (r.a[6] == 7);\n+  assert (r.a[7] == 8);\n+}\n+\n+static void test_punpcklhw_s (void)\n+{\n+  int16x4_encap_t s, t;\n+  int16x4_encap_t r;\n+  s.a[0] = -1;\n+  s.a[1] = 3;\n+  s.a[2] = -5;\n+  s.a[3] = 7;\n+  t.a[0] = -2;\n+  t.a[1] = 4;\n+  t.a[2] = -6;\n+  t.a[3] = 8;\n+  r.v = punpcklhw_s (s.v, t.v);\n+  assert (r.a[0] == -1);\n+  assert (r.a[1] == -2);\n+  assert (r.a[2] == 3);\n+  assert (r.a[3] == 4);\n+}\n+\n+static void test_punpcklhw_u (void)\n+{\n+  uint16x4_encap_t s, t;\n+  uint16x4_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  s.a[2] = 5;\n+  s.a[3] = 7;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  t.a[2] = 6;\n+  t.a[3] = 8;\n+  r.v = punpcklhw_u (s.v, t.v);\n+  assert (r.a[0] == 1);\n+  assert (r.a[1] == 2);\n+  assert (r.a[2] == 3);\n+  assert (r.a[3] == 4);\n+}\n+\n+static void test_punpcklwd_s (void)\n+{\n+  int32x2_encap_t s, t;\n+  int32x2_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  t.a[0] = -2;\n+  t.a[1] = 4;\n+  r.v = punpcklwd_s (s.v, t.v);\n+  assert (r.a[0] == 1);\n+  assert (r.a[1] == -2);\n+}\n+\n+static void test_punpcklwd_u (void)\n+{\n+  uint32x2_encap_t s, t;\n+  uint32x2_encap_t r;\n+  s.a[0] = 1;\n+  s.a[1] = 3;\n+  t.a[0] = 2;\n+  t.a[1] = 4;\n+  r.v = punpcklwd_u (s.v, t.v);\n+  assert (r.a[0] == 1);\n+  assert (r.a[1] == 2);\n+}\n+\n+int main (void)\n+{\n+  test_packsswh ();\n+  test_packsshb ();\n+  test_packushb ();\n+  test_paddw_u ();\n+  test_paddw_s ();\n+  test_paddh_u ();\n+  test_paddh_s ();\n+  test_paddb_u ();\n+  test_paddb_s ();\n+  test_paddd_u ();\n+  test_paddd_s ();\n+  test_paddsh ();\n+  test_paddsb ();\n+  test_paddush ();\n+  test_paddusb ();\n+  test_pandn_ud ();\n+  test_pandn_sd ();\n+  test_pandn_uw ();\n+  test_pandn_sw ();\n+  test_pandn_uh ();\n+  test_pandn_sh ();\n+  test_pandn_ub ();\n+  test_pandn_sb ();\n+  test_pavgh ();\n+  test_pavgb ();\n+  test_pcmpeqw_u ();\n+  test_pcmpeqh_u ();\n+  test_pcmpeqb_u ();\n+  test_pcmpeqw_s ();\n+  test_pcmpeqh_s ();\n+  test_pcmpeqb_s ();\n+  test_pcmpgtw_u ();\n+  test_pcmpgth_u ();\n+  test_pcmpgtb_u ();\n+  test_pcmpgtw_s ();\n+  test_pcmpgth_s ();\n+  test_pcmpgtb_s ();\n+  test_pextrh_u ();\n+  test_pextrh_s ();\n+  test_pinsrh_0123_u ();\n+  test_pinsrh_0123_s ();\n+  test_pmaddhw ();\n+  test_pmaxsh ();\n+  test_pmaxub ();\n+  test_pminsh ();\n+  test_pminub ();\n+  test_pmovmskb_u ();\n+  test_pmovmskb_s ();\n+  test_pmulhuh ();\n+  test_pmulhh ();\n+  test_pmullh ();\n+  test_pmuluw ();\n+  test_pasubub ();\n+  test_biadd ();\n+  test_psadbh ();\n+  test_pshufh_u ();\n+  test_pshufh_s ();\n+  test_psllh_u ();\n+  test_psllw_u ();\n+  test_psllh_s ();\n+  test_psllw_s ();\n+  test_psrah_u ();\n+  test_psraw_u ();\n+  test_psrah_s ();\n+  test_psraw_s ();\n+  test_psrlh_u ();\n+  test_psrlw_u ();\n+  test_psrlh_s ();\n+  test_psrlw_s ();\n+  test_psubw_u ();\n+  test_psubw_s ();\n+  test_psubh_u ();\n+  test_psubh_s ();\n+  test_psubb_u ();\n+  test_psubb_s ();\n+  test_psubd_u ();\n+  test_psubd_s ();\n+  test_psubsh ();\n+  test_psubsb ();\n+  test_psubush ();\n+  test_psubusb ();\n+  test_punpckhbh_s ();\n+  test_punpckhbh_u ();\n+  test_punpckhhw_s ();\n+  test_punpckhhw_u ();\n+  test_punpckhwd_s ();\n+  test_punpckhwd_u ();\n+  test_punpcklbh_s ();\n+  test_punpcklbh_u ();\n+  test_punpcklhw_s ();\n+  test_punpcklhw_u ();\n+  test_punpcklwd_s ();\n+  test_punpcklwd_u ();\n+  return 0;\n+}"}, {"sha": "30804858a42b170e1e8ea580b6c6cc0dce821e2b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93581857e5b10875c572069ef767411ccf5e6162/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=93581857e5b10875c572069ef767411ccf5e6162", "patch": "@@ -1249,6 +1249,17 @@ proc check_effective_target_arm_neon_hw { } {\n     } \"-mfpu=neon -mfloat-abi=softfp\"]\n }\n \n+# Return 1 if this a Loongson-2E or -2F target using an ABI that supports\n+# the Loongson vector modes.\n+\n+proc check_effective_target_mips_loongson { } {\n+    return [check_no_compiler_messages loongson assembly {\n+\t#if !defined(__mips_loongson_vector_rev)\n+\t#error FOO\n+\t#endif\n+    }]\n+}\n+\n # Return 1 if this is a PowerPC target with floating-point registers.\n \n proc check_effective_target_powerpc_fprs { } {"}]}