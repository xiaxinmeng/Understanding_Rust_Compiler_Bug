{"sha": "6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwMzE4NGU4MWMwYjZhOGIxZjRlMDcyZTBjMzJkOWJiODZmY2MxNQ==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2016-11-23T18:36:41Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2016-11-23T18:36:41Z"}, "message": "OpenMP offloading to NVPTX: libgomp changes\n\n\t* Makefile.am (libgomp_la_SOURCES): Add atomic.c, icv.c, icv-device.c.\n\t* Makefile.in. Regenerate.\n\t* configure.ac [nvptx*-*-*] (libgomp_use_pthreads): Set and use it...\n\t(LIBGOMP_USE_PTHREADS): ...here; new define.\n\t* configure: Regenerate.\n\t* config.h.in: Likewise.\n\t* config/posix/affinity.c: Move to...\n\t* affinity.c: ...here (new file).  Guard use of Pthreads-specific\n\tinterface by LIBGOMP_USE_PTHREADS. \n\t* critical.c: Split out GOMP_atomic_{start,end} into...\n\t* atomic.c: ...here (new file).\n\t* env.c: Split out ICV definitions into...\n\t* icv.c: ...here (new file) and...\n\t* icv-device.c: ...here. New file.\n\t* config/linux/lock.c (gomp_init_lock_30): Move to generic lock.c.\n\t(gomp_destroy_lock_30): Ditto.\n\t(gomp_set_lock_30): Ditto.\n\t(gomp_unset_lock_30): Ditto.\n\t(gomp_test_lock_30): Ditto.\n\t(gomp_init_nest_lock_30): Ditto.\n\t(gomp_destroy_nest_lock_30): Ditto.\n\t(gomp_set_nest_lock_30): Ditto.\n\t(gomp_unset_nest_lock_30): Ditto.\n\t(gomp_test_nest_lock_30): Ditto.\n\t* lock.c: New.\n\t* config/nvptx/lock.c: New.\n\t* config/nvptx/bar.c: New.\n\t* config/nvptx/bar.h: New.\n\t* config/nvptx/doacross.h: New.\n\t* config/nvptx/error.c: New.\n\t* config/nvptx/icv-device.c: New.\n\t* config/nvptx/mutex.h: New.\n\t* config/nvptx/pool.h: New.\n\t* config/nvptx/proc.c: New.\n\t* config/nvptx/ptrlock.h: New.\n\t* config/nvptx/sem.h: New.\n\t* config/nvptx/simple-bar.h: New.\n\t* config/nvptx/target.c: New.\n\t* config/nvptx/task.c: New.\n\t* config/nvptx/team.c: New.\n\t* config/nvptx/time.c: New.\n\t* config/posix/simple-bar.h: New.\n\t* libgomp.h: Guard pthread.h inclusion.  Include simple-bar.h.\n\t(gomp_num_teams_var): Declare.\n\t(struct gomp_thread_pool): Change threads_dock member to\n\tgomp_simple_barrier_t.\n\t[__nvptx__] (gomp_thread): New implementation.\n\t(gomp_thread_attr): Guard by LIBGOMP_USE_PTHREADS.\n\t(gomp_thread_destructor): Ditto.\n\t(gomp_init_thread_affinity): Ditto.\n\t* team.c: Guard uses of Pthreads-specific interfaces by\n\tLIBGOMP_USE_PTHREADS.  Adjust all uses of threads_dock.\n\t(gomp_free_thread) [__nvptx__]: Do not call 'free'.\n\n\t* config/nvptx/alloc.c: Delete.\n\t* config/nvptx/barrier.c: Ditto.\n\t* config/nvptx/fortran.c: Ditto.\n\t* config/nvptx/iter.c: Ditto.\n\t* config/nvptx/iter_ull.c: Ditto.\n\t* config/nvptx/loop.c: Ditto.\n\t* config/nvptx/loop_ull.c: Ditto.\n\t* config/nvptx/ordered.c: Ditto.\n\t* config/nvptx/parallel.c: Ditto.\n\t* config/nvptx/priority_queue.c: Ditto.\n\t* config/nvptx/sections.c: Ditto.\n\t* config/nvptx/single.c: Ditto.\n\t* config/nvptx/splay-tree.c: Ditto.\n\t* config/nvptx/work.c: Ditto.\n\n\t* testsuite/libgomp.fortran/fortran.exp (lang_link_flags): Pass\n\t-foffload=-lgfortran in addition to -lgfortran.\n\t* testsuite/libgomp.oacc-fortran/fortran.exp (lang_link_flags): Ditto.\n\n\t* plugin/plugin-nvptx.c: Include <limits.h>.\n\t(struct targ_fn_descriptor): Add new fields.\n\t(struct ptx_device): Ditto.  Set them...\n\t(nvptx_open_device): ...here.\n\t(nvptx_adjust_launch_bounds): New.\n\t(nvptx_host2dev): Allow NULL 'nvthd'.\n\t(nvptx_dev2host): Ditto.\n\t(GOMP_OFFLOAD_get_caps): Add GOMP_OFFLOAD_CAP_OPENMP_400.\n\t(link_ptx): Adjust log sizes.\n\t(nvptx_host2dev): Allow NULL 'nvthd'.\n\t(nvptx_dev2host): Ditto.\n\t(nvptx_set_clocktick): New.  Use it...\n\t(GOMP_OFFLOAD_load_image): ...here.  Set new targ_fn_descriptor\n\tfields.\n\t(GOMP_OFFLOAD_dev2dev): New.\n\t(nvptx_adjust_launch_bounds): New.\n\t(nvptx_stacks_size): New.\n\t(nvptx_stacks_alloc): New.\n\t(nvptx_stacks_free): New.\n\t(GOMP_OFFLOAD_run): New.\n\t(GOMP_OFFLOAD_async_run): New (stub).\n\nCo-Authored-By: Dmitry Melnik <dm@ispras.ru>\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r242789", "tree": {"sha": "afbc9d83e9693712185a8afd9d6593f23eef2734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afbc9d83e9693712185a8afd9d6593f23eef2734"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6251fe936f3eab1542c1581646254e4bae0f6688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6251fe936f3eab1542c1581646254e4bae0f6688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6251fe936f3eab1542c1581646254e4bae0f6688"}], "stats": {"total": 2661, "additions": 2214, "deletions": 447}, "files": [{"sha": "2e15500df4326e8a03c3a98612f84d1db4e8ceb5", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -1,3 +1,99 @@\n+2016-11-23  Alexander Monakov  <amonakov@ispras.ru>\n+            Jakub Jelinek  <jakub@redhat.com>\n+\t    Dmitry Melnik  <dm@ispras.ru>\n+\n+\t* Makefile.am (libgomp_la_SOURCES): Add atomic.c, icv.c, icv-device.c.\n+\t* Makefile.in. Regenerate.\n+\t* configure.ac [nvptx*-*-*] (libgomp_use_pthreads): Set and use it...\n+\t(LIBGOMP_USE_PTHREADS): ...here; new define.\n+\t* configure: Regenerate.\n+\t* config.h.in: Likewise.\n+\t* config/posix/affinity.c: Move to...\n+\t* affinity.c: ...here (new file).  Guard use of Pthreads-specific\n+\tinterface by LIBGOMP_USE_PTHREADS. \n+\t* critical.c: Split out GOMP_atomic_{start,end} into...\n+\t* atomic.c: ...here (new file).\n+\t* env.c: Split out ICV definitions into...\n+\t* icv.c: ...here (new file) and...\n+\t* icv-device.c: ...here. New file.\n+\t* config/linux/lock.c (gomp_init_lock_30): Move to generic lock.c.\n+\t(gomp_destroy_lock_30): Ditto.\n+\t(gomp_set_lock_30): Ditto.\n+\t(gomp_unset_lock_30): Ditto.\n+\t(gomp_test_lock_30): Ditto.\n+\t(gomp_init_nest_lock_30): Ditto.\n+\t(gomp_destroy_nest_lock_30): Ditto.\n+\t(gomp_set_nest_lock_30): Ditto.\n+\t(gomp_unset_nest_lock_30): Ditto.\n+\t(gomp_test_nest_lock_30): Ditto.\n+\t* lock.c: New.\n+\t* config/nvptx/lock.c: New.\n+\t* config/nvptx/bar.c: New.\n+\t* config/nvptx/bar.h: New.\n+\t* config/nvptx/doacross.h: New.\n+\t* config/nvptx/error.c: New.\n+\t* config/nvptx/icv-device.c: New.\n+\t* config/nvptx/mutex.h: New.\n+\t* config/nvptx/pool.h: New.\n+\t* config/nvptx/proc.c: New.\n+\t* config/nvptx/ptrlock.h: New.\n+\t* config/nvptx/sem.h: New.\n+\t* config/nvptx/simple-bar.h: New.\n+\t* config/nvptx/target.c: New.\n+\t* config/nvptx/task.c: New.\n+\t* config/nvptx/team.c: New.\n+\t* config/nvptx/time.c: New.\n+\t* config/posix/simple-bar.h: New.\n+\t* libgomp.h: Guard pthread.h inclusion.  Include simple-bar.h.\n+\t(gomp_num_teams_var): Declare.\n+\t(struct gomp_thread_pool): Change threads_dock member to\n+\tgomp_simple_barrier_t.\n+\t[__nvptx__] (gomp_thread): New implementation.\n+\t(gomp_thread_attr): Guard by LIBGOMP_USE_PTHREADS.\n+\t(gomp_thread_destructor): Ditto.\n+\t(gomp_init_thread_affinity): Ditto.\n+\t* team.c: Guard uses of Pthreads-specific interfaces by\n+\tLIBGOMP_USE_PTHREADS.  Adjust all uses of threads_dock.\n+\t(gomp_free_thread) [__nvptx__]: Do not call 'free'.\n+\t* config/nvptx/alloc.c: Delete.\n+\t* config/nvptx/barrier.c: Ditto.\n+\t* config/nvptx/fortran.c: Ditto.\n+\t* config/nvptx/iter.c: Ditto.\n+\t* config/nvptx/iter_ull.c: Ditto.\n+\t* config/nvptx/loop.c: Ditto.\n+\t* config/nvptx/loop_ull.c: Ditto.\n+\t* config/nvptx/ordered.c: Ditto.\n+\t* config/nvptx/parallel.c: Ditto.\n+\t* config/nvptx/priority_queue.c: Ditto.\n+\t* config/nvptx/sections.c: Ditto.\n+\t* config/nvptx/single.c: Ditto.\n+\t* config/nvptx/splay-tree.c: Ditto.\n+\t* config/nvptx/work.c: Ditto.\n+\t* testsuite/libgomp.fortran/fortran.exp (lang_link_flags): Pass\n+\t-foffload=-lgfortran in addition to -lgfortran.\n+\t* testsuite/libgomp.oacc-fortran/fortran.exp (lang_link_flags): Ditto.\n+\t* plugin/plugin-nvptx.c: Include <limits.h>.\n+\t(struct targ_fn_descriptor): Add new fields.\n+\t(struct ptx_device): Ditto.  Set them...\n+\t(nvptx_open_device): ...here.\n+\t(nvptx_adjust_launch_bounds): New.\n+\t(nvptx_host2dev): Allow NULL 'nvthd'.\n+\t(nvptx_dev2host): Ditto.\n+\t(GOMP_OFFLOAD_get_caps): Add GOMP_OFFLOAD_CAP_OPENMP_400.\n+\t(link_ptx): Adjust log sizes.\n+\t(nvptx_host2dev): Allow NULL 'nvthd'.\n+\t(nvptx_dev2host): Ditto.\n+\t(nvptx_set_clocktick): New.  Use it...\n+\t(GOMP_OFFLOAD_load_image): ...here.  Set new targ_fn_descriptor\n+\tfields.\n+\t(GOMP_OFFLOAD_dev2dev): New.\n+\t(nvptx_adjust_launch_bounds): New.\n+\t(nvptx_stacks_size): New.\n+\t(nvptx_stacks_alloc): New.\n+\t(nvptx_stacks_free): New.\n+\t(GOMP_OFFLOAD_run): New.\n+\t(GOMP_OFFLOAD_async_run): New (stub).\n+\n 2016-11-23  Martin Jambor  <mjambor@suse.cz>\n \n \t* testsuite/libgomp.hsa.c/bits-insns.c: New test."}, {"sha": "4090336a773f8a8d1a4cc2367be516be0f27d1e4", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -58,12 +58,12 @@ libgomp_la_LDFLAGS = $(libgomp_version_info) $(libgomp_version_script) \\\n libgomp_la_DEPENDENCIES = $(libgomp_version_dep)\n libgomp_la_LINK = $(LINK) $(libgomp_la_LDFLAGS)\n \n-libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n-\titer_ull.c loop.c loop_ull.c ordered.c parallel.c sections.c single.c \\\n-\ttask.c team.c work.c lock.c mutex.c proc.c sem.c bar.c ptrlock.c \\\n-\ttime.c fortran.c affinity.c target.c splay-tree.c libgomp-plugin.c \\\n-\toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c oacc-async.c \\\n-\toacc-plugin.c oacc-cuda.c priority_queue.c\n+libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c error.c \\\n+\ticv.c icv-device.c iter.c iter_ull.c loop.c loop_ull.c ordered.c \\\n+\tparallel.c sections.c single.c task.c team.c work.c lock.c mutex.c \\\n+\tproc.c sem.c bar.c ptrlock.c time.c fortran.c affinity.c target.c \\\n+\tsplay-tree.c libgomp-plugin.c oacc-parallel.c oacc-host.c oacc-init.c \\\n+\toacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c\n \n include $(top_srcdir)/plugin/Makefrag.am\n "}, {"sha": "e62daec25e0993c19870ab021a0e11bea2f134ff", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -150,14 +150,14 @@ libgomp_plugin_nvptx_la_LINK = $(LIBTOOL) --tag=CC \\\n @PLUGIN_NVPTX_TRUE@\t$(toolexeclibdir)\n libgomp_la_LIBADD =\n @USE_FORTRAN_TRUE@am__objects_1 = openacc.lo\n-am_libgomp_la_OBJECTS = alloc.lo barrier.lo critical.lo env.lo \\\n-\terror.lo iter.lo iter_ull.lo loop.lo loop_ull.lo ordered.lo \\\n-\tparallel.lo sections.lo single.lo task.lo team.lo work.lo \\\n-\tlock.lo mutex.lo proc.lo sem.lo bar.lo ptrlock.lo time.lo \\\n-\tfortran.lo affinity.lo target.lo splay-tree.lo \\\n-\tlibgomp-plugin.lo oacc-parallel.lo oacc-host.lo oacc-init.lo \\\n-\toacc-mem.lo oacc-async.lo oacc-plugin.lo oacc-cuda.lo \\\n-\tpriority_queue.lo $(am__objects_1)\n+am_libgomp_la_OBJECTS = alloc.lo atomic.lo barrier.lo critical.lo \\\n+\tenv.lo error.lo icv.lo icv-device.lo iter.lo iter_ull.lo \\\n+\tloop.lo loop_ull.lo ordered.lo parallel.lo sections.lo \\\n+\tsingle.lo task.lo team.lo work.lo lock.lo mutex.lo proc.lo \\\n+\tsem.lo bar.lo ptrlock.lo time.lo fortran.lo affinity.lo \\\n+\ttarget.lo splay-tree.lo libgomp-plugin.lo oacc-parallel.lo \\\n+\toacc-host.lo oacc-init.lo oacc-mem.lo oacc-async.lo \\\n+\toacc-plugin.lo oacc-cuda.lo priority_queue.lo $(am__objects_1)\n libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n@@ -400,13 +400,14 @@ libgomp_la_LDFLAGS = $(libgomp_version_info) $(libgomp_version_script) \\\n \n libgomp_la_DEPENDENCIES = $(libgomp_version_dep)\n libgomp_la_LINK = $(LINK) $(libgomp_la_LDFLAGS)\n-libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n-\titer_ull.c loop.c loop_ull.c ordered.c parallel.c sections.c \\\n-\tsingle.c task.c team.c work.c lock.c mutex.c proc.c sem.c \\\n-\tbar.c ptrlock.c time.c fortran.c affinity.c target.c \\\n-\tsplay-tree.c libgomp-plugin.c oacc-parallel.c oacc-host.c \\\n-\toacc-init.c oacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c \\\n-\tpriority_queue.c $(am__append_3)\n+libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \\\n+\terror.c icv.c icv-device.c iter.c iter_ull.c loop.c loop_ull.c \\\n+\tordered.c parallel.c sections.c single.c task.c team.c work.c \\\n+\tlock.c mutex.c proc.c sem.c bar.c ptrlock.c time.c fortran.c \\\n+\taffinity.c target.c splay-tree.c libgomp-plugin.c \\\n+\toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c \\\n+\toacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n+\t$(am__append_3)\n \n # Nvidia PTX OpenACC plugin.\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_version_info = -version-info $(libtool_VERSION)\n@@ -571,12 +572,15 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/affinity.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atomic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bar.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/barrier.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/critical.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/env.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fortran.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icv-device.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter_ull.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp-plugin.Plo@am__quote@"}, {"sha": "3549e54b67c32510ebf6f31da7662d21bd15709a", "filename": "libgomp/affinity.c", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Faffinity.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -32,12 +32,14 @@ gomp_init_affinity (void)\n {\n }\n \n+#ifdef LIBGOMP_USE_PTHREADS\n void\n gomp_init_thread_affinity (pthread_attr_t *attr, unsigned int place)\n {\n   (void) attr;\n   (void) place;\n }\n+#endif\n \n void **\n gomp_affinity_alloc (unsigned long count, bool quiet)", "previous_filename": "libgomp/config/posix/affinity.c"}, {"sha": "bad0736e21ee4317f7417ebf7946cf82e3734dfb", "filename": "libgomp/atomic.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fatomic.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright (C) 2005-2016 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains helpers for the ATOMIC construct.  */\n+\n+#include \"libgomp.h\"\n+\n+/* This mutex is used when atomic operations don't exist for the target\n+   in the mode requested.  The result is not globally atomic, but works so\n+   long as all parallel references are within #pragma omp atomic directives.\n+   According to responses received from omp@openmp.org, appears to be within\n+   spec.  Which makes sense, since that's how several other compilers\n+   handle this situation as well.  */\n+\n+static gomp_mutex_t atomic_lock;\n+\n+void\n+GOMP_atomic_start (void)\n+{\n+  gomp_mutex_lock (&atomic_lock);\n+}\n+\n+void\n+GOMP_atomic_end (void)\n+{\n+  gomp_mutex_unlock (&atomic_lock);\n+}\n+\n+#if !GOMP_MUTEX_INIT_0\n+static void __attribute__((constructor))\n+initialize_atomic (void)\n+{\n+  gomp_mutex_init (&atomic_lock);\n+}\n+#endif"}, {"sha": "b54dd87c2a676b99e52684eadc8637b0d56290d2", "filename": "libgomp/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -115,6 +115,9 @@\n /* Define to 1 if GNU symbol versioning is used for libgomp. */\n #undef LIBGOMP_GNU_SYMBOL_VERSIONING\n \n+/* Define to 1 if libgomp should use POSIX threads. */\n+#undef LIBGOMP_USE_PTHREADS\n+\n /* Define to the sub-directory in which libtool stores uninstalled libraries.\n    */\n #undef LT_OBJDIR"}, {"sha": "07845c98ad1e0ff0728ded342fbe518f61978309", "filename": "libgomp/config/linux/lock.c", "status": "modified", "additions": 2, "deletions": 92, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Flinux%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Flinux%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Flock.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -32,98 +32,8 @@\n #include <sys/syscall.h>\n #include \"wait.h\"\n \n-\n-/* The internal gomp_mutex_t and the external non-recursive omp_lock_t\n-   have the same form.  Re-use it.  */\n-\n-void\n-gomp_init_lock_30 (omp_lock_t *lock)\n-{\n-  gomp_mutex_init (lock);\n-}\n-\n-void\n-gomp_destroy_lock_30 (omp_lock_t *lock)\n-{\n-  gomp_mutex_destroy (lock);\n-}\n-\n-void\n-gomp_set_lock_30 (omp_lock_t *lock)\n-{\n-  gomp_mutex_lock (lock);\n-}\n-\n-void\n-gomp_unset_lock_30 (omp_lock_t *lock)\n-{\n-  gomp_mutex_unlock (lock);\n-}\n-\n-int\n-gomp_test_lock_30 (omp_lock_t *lock)\n-{\n-  int oldval = 0;\n-\n-  return __atomic_compare_exchange_n (lock, &oldval, 1, false,\n-\t\t\t\t      MEMMODEL_ACQUIRE, MEMMODEL_RELAXED);\n-}\n-\n-void\n-gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  memset (lock, '\\0', sizeof (*lock));\n-}\n-\n-void\n-gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-}\n-\n-void\n-gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  void *me = gomp_icv (true);\n-\n-  if (lock->owner != me)\n-    {\n-      gomp_mutex_lock (&lock->lock);\n-      lock->owner = me;\n-    }\n-\n-  lock->count++;\n-}\n-\n-void\n-gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  if (--lock->count == 0)\n-    {\n-      lock->owner = NULL;\n-      gomp_mutex_unlock (&lock->lock);\n-    }\n-}\n-\n-int\n-gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  void *me = gomp_icv (true);\n-  int oldval;\n-\n-  if (lock->owner == me)\n-    return ++lock->count;\n-\n-  oldval = 0;\n-  if (__atomic_compare_exchange_n (&lock->lock, &oldval, 1, false,\n-\t\t\t\t   MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n-    {\n-      lock->owner = me;\n-      lock->count = 1;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n+/* Reuse the generic implementation in terms of gomp_mutex_t.  */\n+#include \"../../lock.c\"\n \n #ifdef LIBGOMP_GNU_SYMBOL_VERSIONING\n /* gomp_mutex_* can be safely locked in one thread and"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/alloc.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Falloc.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "820affb27b7e96d6ec1760f2b4a7c1873657f9f9", "filename": "libgomp/config/nvptx/bar.c", "status": "modified", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fbar.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,206 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is an NVPTX specific implementation of a barrier synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and bar.sync instruction.  */\n+\n+#include <limits.h>\n+#include \"libgomp.h\"\n+\n+\n+void\n+gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      bar->awaited = bar->total;\n+      __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,\n+\t\t\tMEMMODEL_RELEASE);\n+    }\n+  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+}\n+\n+void\n+gomp_barrier_wait (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+/* Like gomp_barrier_wait, except that if the encountering thread\n+   is not the last one to hit the barrier, it returns immediately.\n+   The intended usage is that a thread which intends to gomp_barrier_destroy\n+   this barrier calls gomp_barrier_wait, while all other threads\n+   call gomp_barrier_wait_last.  When gomp_barrier_wait returns,\n+   the barrier can be safely destroyed.  */\n+\n+void\n+gomp_barrier_wait_last (gomp_barrier_t *bar)\n+{\n+  /* Deferring to gomp_barrier_wait does not use the optimization opportunity\n+     allowed by the interface contract for all-but-last participants.  The\n+     original implementation in config/linux/bar.c handles this better.  */\n+  gomp_barrier_wait (bar);\n+}\n+\n+void\n+gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n+{\n+  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+}\n+\n+void\n+gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  unsigned int generation, gen;\n+\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~BAR_WAS_LAST;\n+\t}\n+      else\n+\t{\n+\t  state &= ~BAR_CANCELLED;\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n+\t  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+\t  return;\n+\t}\n+    }\n+\n+  generation = state;\n+  state &= ~BAR_CANCELLED;\n+  do\n+    {\n+      asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t}\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n+    }\n+  while (gen != state + BAR_INCR);\n+}\n+\n+void\n+gomp_team_barrier_wait (gomp_barrier_t *bar)\n+{\n+  gomp_team_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+void\n+gomp_team_barrier_wait_final (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_state_t state = gomp_barrier_wait_final_start (bar);\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    bar->awaited_final = bar->total;\n+  gomp_team_barrier_wait_end (bar, state);\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n+\t\t\t\t   gomp_barrier_state_t state)\n+{\n+  unsigned int generation, gen;\n+\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      /* BAR_CANCELLED should never be set in state here, because\n+\t cancellation means that at least one of the threads has been\n+\t cancelled, thus on a cancellable barrier we should never see\n+\t all threads to arrive.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~BAR_WAS_LAST;\n+\t}\n+      else\n+\t{\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n+\t  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+\t  return false;\n+\t}\n+    }\n+\n+  if (__builtin_expect (state & BAR_CANCELLED, 0))\n+    return true;\n+\n+  generation = state;\n+  do\n+    {\n+      asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+      if (__builtin_expect (gen & BAR_CANCELLED, 0))\n+\treturn true;\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t}\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n+    }\n+  while (gen != state + BAR_INCR);\n+\n+  return false;\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel (gomp_barrier_t *bar)\n+{\n+  return gomp_team_barrier_wait_cancel_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+void\n+gomp_team_barrier_cancel (struct gomp_team *team)\n+{\n+  gomp_mutex_lock (&team->task_lock);\n+  if (team->barrier.generation & BAR_CANCELLED)\n+    {\n+      gomp_mutex_unlock (&team->task_lock);\n+      return;\n+    }\n+  team->barrier.generation |= BAR_CANCELLED;\n+  gomp_mutex_unlock (&team->task_lock);\n+  gomp_team_barrier_wake (&team->barrier, INT_MAX);\n+}"}, {"sha": "757edf1d7ebf4e223f02081f4ae17f2be63ab0bd", "filename": "libgomp/config/nvptx/bar.h", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fbar.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,166 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is an NVPTX specific implementation of a barrier synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and bar.sync instruction.  */\n+\n+#ifndef GOMP_BARRIER_H\n+#define GOMP_BARRIER_H 1\n+\n+#include \"mutex.h\"\n+\n+typedef struct\n+{\n+  unsigned total;\n+  unsigned generation;\n+  unsigned awaited;\n+  unsigned awaited_final;\n+} gomp_barrier_t;\n+\n+typedef unsigned int gomp_barrier_state_t;\n+\n+/* The generation field contains a counter in the high bits, with a few\n+   low bits dedicated to flags.  Note that TASK_PENDING and WAS_LAST can\n+   share space because WAS_LAST is never stored back to generation.  */\n+#define BAR_TASK_PENDING\t1\n+#define BAR_WAS_LAST\t\t1\n+#define BAR_WAITING_FOR_TASK\t2\n+#define BAR_CANCELLED\t\t4\n+#define BAR_INCR\t\t8\n+\n+static inline void gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n+{\n+  bar->total = count;\n+  bar->awaited = count;\n+  bar->awaited_final = count;\n+  bar->generation = 0;\n+}\n+\n+static inline void gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)\n+{\n+  __atomic_add_fetch (&bar->awaited, count - bar->total, MEMMODEL_ACQ_REL);\n+  bar->total = count;\n+}\n+\n+static inline void gomp_barrier_destroy (gomp_barrier_t *bar)\n+{\n+}\n+\n+extern void gomp_barrier_wait (gomp_barrier_t *);\n+extern void gomp_barrier_wait_last (gomp_barrier_t *);\n+extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);\n+extern void gomp_team_barrier_wait (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_final (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_end (gomp_barrier_t *,\n+\t\t\t\t\tgomp_barrier_state_t);\n+extern bool gomp_team_barrier_wait_cancel (gomp_barrier_t *);\n+extern bool gomp_team_barrier_wait_cancel_end (gomp_barrier_t *,\n+\t\t\t\t\t       gomp_barrier_state_t);\n+extern void gomp_team_barrier_wake (gomp_barrier_t *, int);\n+struct gomp_team;\n+extern void gomp_team_barrier_cancel (struct gomp_team *);\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n+  /* A memory barrier is needed before exiting from the various forms\n+     of gomp_barrier_wait, to satisfy OpenMP API version 3.1 section\n+     2.8.6 flush Construct, which says there is an implicit flush during\n+     a barrier region.  This is a convenient place to add the barrier,\n+     so we use MEMMODEL_ACQ_REL here rather than MEMMODEL_ACQUIRE.  */\n+  if (__atomic_add_fetch (&bar->awaited, -1, MEMMODEL_ACQ_REL) == 0)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_cancel_start (gomp_barrier_t *bar)\n+{\n+  return gomp_barrier_wait_start (bar);\n+}\n+\n+/* This is like gomp_barrier_wait_start, except it decrements\n+   bar->awaited_final rather than bar->awaited and should be used\n+   for the gomp_team_end barrier only.  */\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_final_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n+  /* See above gomp_barrier_wait_start comment.  */\n+  if (__atomic_add_fetch (&bar->awaited_final, -1, MEMMODEL_ACQ_REL) == 0)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline bool\n+gomp_barrier_last_thread (gomp_barrier_state_t state)\n+{\n+  return state & BAR_WAS_LAST;\n+}\n+\n+/* All the inlines below must be called with team->task_lock\n+   held.  */\n+\n+static inline void\n+gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation |= BAR_TASK_PENDING;\n+}\n+\n+static inline void\n+gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation &= ~BAR_TASK_PENDING;\n+}\n+\n+static inline void\n+gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  bar->generation |= BAR_WAITING_FOR_TASK;\n+}\n+\n+static inline bool\n+gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  return (bar->generation & BAR_WAITING_FOR_TASK) != 0;\n+}\n+\n+static inline bool\n+gomp_team_barrier_cancelled (gomp_barrier_t *bar)\n+{\n+  return __builtin_expect ((bar->generation & BAR_CANCELLED) != 0, 0);\n+}\n+\n+static inline void\n+gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  bar->generation = (state & -BAR_INCR) + BAR_INCR;\n+}\n+\n+#endif /* GOMP_BARRIER_H */"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/barrier.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fbarrier.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fbarrier.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fbarrier.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "fd011d492bd9e53b7b7e121b31f8f5d4d2695d4e", "filename": "libgomp/config/nvptx/doacross.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fdoacross.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fdoacross.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fdoacross.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,60 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the NVPTX implementation of doacross spinning.  */\n+\n+#ifndef GOMP_DOACROSS_H\n+#define GOMP_DOACROSS_H 1\n+\n+#include \"libgomp.h\"\n+\n+static int zero;\n+\n+static inline int\n+cpu_relax (void)\n+{\n+  int r;\n+  /* Here we need a long-latency operation to make the current warp yield.\n+     We could use ld.cv, uncached load from system (host) memory, but that\n+     would require allocating locked memory in the plugin.  Alternatively,\n+     we can use ld.cg, which evicts from L1 and caches in L2.  */\n+  asm volatile (\"ld.cg.s32 %0, [%1];\" : \"=r\" (r) : \"i\" (&zero) : \"memory\");\n+  return r;\n+}\n+\n+static inline void doacross_spin (unsigned long *addr, unsigned long expected,\n+\t\t\t\t  unsigned long cur)\n+{\n+  /* Prevent compiler from optimizing based on bounds of containing object.  */\n+  asm (\"\" : \"+r\" (addr));\n+  do\n+    {\n+      int i = cpu_relax ();\n+      cur = addr[i];\n+    }\n+  while (cur <= expected);\n+}\n+\n+#endif /* GOMP_DOACROSS_H */"}, {"sha": "f3e74cd9449b5545fb67574659d629cf09c71982", "filename": "libgomp/config/nvptx/error.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ferror.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains routines used to signal errors.  On NVPTX, we have\n+   one default output stream (stdout), so redirect everything there.  */\n+\n+#include \"libgomp.h\"\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#undef vfprintf\n+#undef fputs\n+#undef fputc\n+\n+#define vfprintf(stream, fmt, list) vprintf (fmt, list)\n+#define fputs(s, stream) printf (\"%s\", s)\n+#define fputc(c, stream) printf (\"%c\", c)\n+\n+#include \"../../error.c\""}, {"sha": "831ba110e9538a9f6db3b5883b1d0a2372188bbd", "filename": "libgomp/config/nvptx/icv-device.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,74 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file defines OpenMP API entry points that accelerator targets are\n+   expected to replace.  */\n+\n+#include \"libgomp.h\"\n+\n+void\n+omp_set_default_device (int device_num __attribute__((unused)))\n+{\n+}\n+\n+int\n+omp_get_default_device (void)\n+{\n+  return 0;\n+}\n+\n+int\n+omp_get_num_devices (void)\n+{\n+  return 0;\n+}\n+\n+int\n+omp_get_num_teams (void)\n+{\n+  return gomp_num_teams_var + 1;\n+}\n+\n+int\n+omp_get_team_num (void)\n+{\n+  int ctaid;\n+  asm (\"mov.u32 %0, %%ctaid.x;\" : \"=r\" (ctaid));\n+  return ctaid;\n+}\n+\n+int\n+omp_is_initial_device (void)\n+{\n+  /* NVPTX is an accelerator-only target.  */\n+  return 0;\n+}\n+\n+ialias (omp_set_default_device)\n+ialias (omp_get_default_device)\n+ialias (omp_get_num_devices)\n+ialias (omp_get_num_teams)\n+ialias (omp_get_team_num)\n+ialias (omp_is_initial_device)"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/iter.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fiter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fiter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fiter.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/iter_ull.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fiter_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fiter_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fiter_ull.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "7731704c6fb5033c60c2a9b77e349264531e770c", "filename": "libgomp/config/nvptx/lock.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Flock.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is a NVPTX specific implementation of the public OpenMP locking\n+   primitives.  */\n+\n+/* Reuse the generic implementation in terms of gomp_mutex_t.  */\n+#include \"../../lock.c\"\n+\n+ialias (omp_init_lock)\n+ialias (omp_init_nest_lock)\n+ialias (omp_destroy_lock)\n+ialias (omp_destroy_nest_lock)\n+ialias (omp_set_lock)\n+ialias (omp_set_nest_lock)\n+ialias (omp_unset_lock)\n+ialias (omp_unset_nest_lock)\n+ialias (omp_test_lock)\n+ialias (omp_test_nest_lock)"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/loop.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Floop.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/loop_ull.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Floop_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Floop_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Floop_ull.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "e408ca72933a45e1cf9e7ad7b4bf6bc94c7ff033", "filename": "libgomp/config/nvptx/mutex.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fmutex.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,60 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is an NVPTX specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and busy waiting.  */\n+\n+#ifndef GOMP_MUTEX_H\n+#define GOMP_MUTEX_H 1\n+\n+typedef int gomp_mutex_t;\n+\n+#define GOMP_MUTEX_INIT_0 1\n+\n+static inline void\n+gomp_mutex_init (gomp_mutex_t *mutex)\n+{\n+  *mutex = 0;\n+}\n+\n+static inline void\n+gomp_mutex_destroy (gomp_mutex_t *mutex)\n+{\n+}\n+\n+static inline void\n+gomp_mutex_lock (gomp_mutex_t *mutex)\n+{\n+  while (__sync_lock_test_and_set (mutex, 1))\n+    /* spin */ ;\n+}\n+\n+static inline void\n+gomp_mutex_unlock (gomp_mutex_t *mutex)\n+{\n+  __sync_lock_release (mutex);\n+}\n+#endif /* GOMP_MUTEX_H */"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/ordered.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fordered.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fordered.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fordered.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/parallel.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fparallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fparallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fparallel.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "70e233c7caa770c90a2092547b629914eb5155ae", "filename": "libgomp/config/nvptx/pool.h", "status": "renamed", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fpool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fpool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fpool.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -1,8 +1,5 @@\n-/* OpenACC Runtime Fortran wrapper routines\n-\n-   Copyright (C) 2014-2016 Free Software Foundation, Inc.\n-\n-   Contributed by Mentor Embedded.\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n \n    This file is part of the GNU Offloading and Multi Processing Library\n    (libgomp).\n@@ -26,15 +23,27 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n-/* Temporary hack; this will be provided by libgfortran.  */\n+/* This is the NVPTX implementation of the thread pool management\n+   for libgomp.  This type is private to the library.  */\n+\n+#ifndef GOMP_POOL_H\n+#define GOMP_POOL_H 1\n+\n+#include \"libgomp.h\"\n+\n+/* Get the thread pool.  */\n+\n+static inline struct gomp_thread_pool *\n+gomp_get_thread_pool (struct gomp_thread *thr, unsigned nthreads)\n+{\n+  /* NVPTX is running with a fixed pool of pre-started threads.  */\n+  return thr->thread_pool;\n+}\n \n-extern void _gfortran_abort (void);\n+static inline void\n+gomp_release_thread_pool (struct gomp_thread_pool *pool)\n+{\n+  /* Do nothing.  */\n+}\n \n-__asm__ (\"// BEGIN GLOBAL FUNCTION DECL: _gfortran_abort\\n\"\n-\t \".visible .func _gfortran_abort;\\n\"\n-\t \"// BEGIN GLOBAL FUNCTION DEF: _gfortran_abort\\n\"\n-\t \".visible .func _gfortran_abort\\n\"\n-\t \"{\\n\"\n-\t \"trap;\\n\"\n-\t \"ret;\\n\"\n-\t \"}\\n\");\n+#endif /* GOMP_POOL_H */", "previous_filename": "libgomp/config/nvptx/fortran.c"}, {"sha": "63aecd249fb5b2c13b37fc4a68aad06a415cf5f0", "filename": "libgomp/config/nvptx/priority_queue.c", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fpriority_queue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fpriority_queue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fpriority_queue.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688", "patch": "@@ -1 +0,0 @@\n-/* Empty stub for omp task priority support.  */"}, {"sha": "8c1c366466085219e6f61ee975102158ccf839fd", "filename": "libgomp/config/nvptx/proc.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fproc.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains system specific routines related to counting\n+   online processors and dynamic load balancing.  */\n+\n+#include \"libgomp.h\"\n+\n+unsigned\n+gomp_dynamic_max_threads (void)\n+{\n+  return gomp_icv (false)->nthreads_var;\n+}\n+\n+int\n+omp_get_num_procs (void)\n+{\n+  return gomp_icv (false)->nthreads_var;\n+}"}, {"sha": "c2eae75720d7f9c2ac97abf6e41a00dcee0fdf6a", "filename": "libgomp/config/nvptx/ptrlock.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fptrlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fptrlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fptrlock.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,73 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is an NVPTX specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and busy waiting.\n+\n+   A ptrlock has four states:\n+   0/NULL Initial\n+   1      Owned by me, I get to write a pointer to ptrlock.\n+   2      Some thread is waiting on the ptrlock.\n+   >2     Ptrlock contains a valid pointer.\n+   It is not valid to gain the ptrlock and then write a NULL to it.  */\n+\n+#ifndef GOMP_PTRLOCK_H\n+#define GOMP_PTRLOCK_H 1\n+\n+typedef void *gomp_ptrlock_t;\n+\n+static inline void gomp_ptrlock_init (gomp_ptrlock_t *ptrlock, void *ptr)\n+{\n+  *ptrlock = ptr;\n+}\n+\n+static inline void *gomp_ptrlock_get (gomp_ptrlock_t *ptrlock)\n+{\n+  uintptr_t v = (uintptr_t) __atomic_load_n (ptrlock, MEMMODEL_ACQUIRE);\n+  if (v > 2)\n+    return (void *) v;\n+\n+  if (v == 0\n+      && __atomic_compare_exchange_n (ptrlock, &v, 1, false,\n+\t\t\t\t      MEMMODEL_ACQUIRE, MEMMODEL_ACQUIRE))\n+    return NULL;\n+\n+  while (v == 1)\n+    v = (uintptr_t) __atomic_load_n (ptrlock, MEMMODEL_ACQUIRE);\n+\n+  return (void *) v;\n+}\n+\n+static inline void gomp_ptrlock_set (gomp_ptrlock_t *ptrlock, void *ptr)\n+{\n+  __atomic_store_n (ptrlock, ptr, MEMMODEL_RELEASE);\n+}\n+\n+static inline void gomp_ptrlock_destroy (gomp_ptrlock_t *ptrlock)\n+{\n+}\n+\n+#endif /* GOMP_PTRLOCK_H */"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/sections.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fsections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fsections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fsections.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "82c0dfbf7e09caa63b5bddaca96dc6d03d1efa6a", "filename": "libgomp/config/nvptx/sem.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fsem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fsem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fsem.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,65 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is an NVPTX specific implementation of a semaphore synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   semaphore implementation uses atomic instructions and busy waiting.  */\n+\n+#ifndef GOMP_SEM_H\n+#define GOMP_SEM_H 1\n+\n+typedef int gomp_sem_t;\n+\n+static inline void\n+gomp_sem_init (gomp_sem_t *sem, int value)\n+{\n+  *sem = value;\n+}\n+\n+static inline void\n+gomp_sem_destroy (gomp_sem_t *sem)\n+{\n+}\n+\n+static inline void\n+gomp_sem_wait (gomp_sem_t *sem)\n+{\n+  int count = __atomic_load_n (sem, MEMMODEL_ACQUIRE);\n+  for (;;)\n+    {\n+      while (count == 0)\n+\tcount = __atomic_load_n (sem, MEMMODEL_ACQUIRE);\n+      if (__atomic_compare_exchange_n (sem, &count, count - 1, false,\n+\t\t\t\t       MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n+\treturn;\n+    }\n+}\n+\n+static inline void\n+gomp_sem_post (gomp_sem_t *sem)\n+{\n+  (void) __atomic_add_fetch (sem, 1, MEMMODEL_RELEASE);\n+}\n+#endif /* GOMP_SEM_H */"}, {"sha": "e7b56d98826bf7a1f948f3da7b3d05f278771ffe", "filename": "libgomp/config/nvptx/simple-bar.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fsimple-bar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fsimple-bar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fsimple-bar.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,70 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is a simplified barrier that is suitable for thread pool\n+   synchronizaton.  Only a subset of full barrier API (bar.h) is exposed.\n+   Here in the NVPTX-specific implementation, we expect that thread pool\n+   corresponds to a PTX CTA (thread block).  */\n+\n+#ifndef GOMP_SIMPLE_BARRIER_H\n+#define GOMP_SIMPLE_BARRIER_H 1\n+\n+typedef struct\n+{\n+  unsigned count;\n+} gomp_simple_barrier_t;\n+\n+static inline void\n+gomp_simple_barrier_init (gomp_simple_barrier_t *bar, unsigned count)\n+{\n+  bar->count = count * 32;\n+}\n+\n+/* Unused on NVPTX.\n+static inline void\n+gomp_simple_barrier_reinit (gomp_simple_barrier_t *bar, unsigned count)\n+{\n+  bar->count = count * 32;\n+}\n+*/\n+\n+static inline void\n+gomp_simple_barrier_destroy (gomp_simple_barrier_t *bar)\n+{\n+}\n+\n+static inline void\n+gomp_simple_barrier_wait (gomp_simple_barrier_t *bar)\n+{\n+  asm volatile (\"bar.sync 0, %0;\" : : \"r\" (bar->count) : \"memory\");\n+}\n+\n+static inline void\n+gomp_simple_barrier_wait_last (gomp_simple_barrier_t *bar)\n+{\n+  asm volatile (\"bar.arrive 0, %0;\" : : \"r\" (bar->count) : \"memory\");\n+}\n+\n+#endif /* GOMP_SIMPLE_BARRIER_H */"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/single.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fsingle.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/splay-tree.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fsplay-tree.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "38ea7f7aa68d9b7e4cdc81336db2c92f07ba2c4d", "filename": "libgomp/config/nvptx/target.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ftarget.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,49 @@\n+/* Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgomp.h\"\n+#include <limits.h>\n+\n+void\n+GOMP_teams (unsigned int num_teams, unsigned int thread_limit)\n+{\n+  if (thread_limit)\n+    {\n+      struct gomp_task_icv *icv = gomp_icv (true);\n+      icv->thread_limit_var\n+\t= thread_limit > INT_MAX ? UINT_MAX : thread_limit;\n+    }\n+  unsigned int num_blocks, block_id;\n+  asm (\"mov.u32 %0, %%nctaid.x;\" : \"=r\" (num_blocks));\n+  asm (\"mov.u32 %0, %%ctaid.x;\" : \"=r\" (block_id));\n+  if (!num_teams || num_teams >= num_blocks)\n+    num_teams = num_blocks;\n+  else if (block_id >= num_teams)\n+    {\n+      gomp_free_thread (nvptx_thrs);\n+      asm (\"exit;\");\n+    }\n+  gomp_num_teams_var = num_teams - 1;\n+}"}, {"sha": "c183716c94e54514d1e119f276c6ac20c61a712c", "filename": "libgomp/config/nvptx/task.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ftask.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file handles the maintainence of tasks in response to task\n+   creation and termination.  */\n+\n+#ifdef __nvptx_softstack__\n+\n+#include \"libgomp.h\"\n+\n+/* NVPTX is an accelerator-only target, so this should never be called.  */\n+\n+bool\n+gomp_target_task_fn (void *data)\n+{\n+  __builtin_unreachable ();\n+}\n+\n+#include \"../../task.c\"\n+\n+#endif"}, {"sha": "f7b5e3e81b5c6ed165a8fa9e026425dc516e38e9", "filename": "libgomp/config/nvptx/team.c", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fteam.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,178 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file handles maintainance of threads on NVPTX.  */\n+\n+#if defined __nvptx_softstack__ && defined __nvptx_unisimt__\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct gomp_thread *nvptx_thrs __attribute__((shared,nocommon));\n+\n+static void gomp_thread_start (struct gomp_thread_pool *);\n+\n+\n+/* This externally visible function handles target region entry.  It\n+   sets up a per-team thread pool and transfers control by calling FN (FN_DATA)\n+   in the master thread or gomp_thread_start in other threads.\n+\n+   The name of this function is part of the interface with the compiler: for\n+   each target region, GCC emits a PTX .kernel function that sets up soft-stack\n+   and uniform-simt state and calls this function, passing in FN the original\n+   function outlined for the target region.  */\n+\n+void\n+gomp_nvptx_main (void (*fn) (void *), void *fn_data)\n+{\n+  int tid, ntids;\n+  asm (\"mov.u32 %0, %%tid.y;\" : \"=r\" (tid));\n+  asm (\"mov.u32 %0, %%ntid.y;\" : \"=r\" (ntids));\n+  if (tid == 0)\n+    {\n+      gomp_global_icv.nthreads_var = ntids;\n+      /* Starting additional threads is not supported.  */\n+      gomp_global_icv.dyn_var = true;\n+\n+      nvptx_thrs = alloca (ntids * sizeof (*nvptx_thrs));\n+      memset (nvptx_thrs, 0, ntids * sizeof (*nvptx_thrs));\n+\n+      struct gomp_thread_pool *pool = alloca (sizeof (*pool));\n+      pool->threads = alloca (ntids * sizeof (*pool->threads));\n+      for (tid = 0; tid < ntids; tid++)\n+\tpool->threads[tid] = nvptx_thrs + tid;\n+      pool->threads_size = ntids;\n+      pool->threads_used = ntids;\n+      pool->threads_busy = 1;\n+      pool->last_team = NULL;\n+      gomp_simple_barrier_init (&pool->threads_dock, ntids);\n+\n+      nvptx_thrs[0].thread_pool = pool;\n+      asm (\"bar.sync 0;\");\n+      fn (fn_data);\n+\n+      gomp_free_thread (nvptx_thrs);\n+    }\n+  else\n+    {\n+      asm (\"bar.sync 0;\");\n+      gomp_thread_start (nvptx_thrs[0].thread_pool);\n+    }\n+}\n+\n+/* This function contains the idle loop in which a thread waits\n+   to be called up to become part of a team.  */\n+\n+static void\n+gomp_thread_start (struct gomp_thread_pool *pool)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  gomp_sem_init (&thr->release, 0);\n+  thr->thread_pool = pool;\n+\n+  do\n+    {\n+      gomp_simple_barrier_wait (&pool->threads_dock);\n+      if (!thr->fn)\n+\tcontinue;\n+      thr->fn (thr->data);\n+      thr->fn = NULL;\n+\n+      struct gomp_task *task = thr->task;\n+      gomp_team_barrier_wait_final (&thr->ts.team->barrier);\n+      gomp_finish_task (task);\n+    }\n+  /* Work around an NVIDIA driver bug: when generating sm_50 machine code,\n+     it can trash stack pointer R1 in loops lacking exit edges.  Add a cheap\n+     artificial exit that the driver would not be able to optimize out.  */\n+  while (nvptx_thrs);\n+}\n+\n+/* Launch a team.  */\n+\n+void\n+gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n+\t\t unsigned flags, struct gomp_team *team)\n+{\n+  struct gomp_thread *thr, *nthr;\n+  struct gomp_task *task;\n+  struct gomp_task_icv *icv;\n+  struct gomp_thread_pool *pool;\n+  unsigned long nthreads_var;\n+\n+  thr = gomp_thread ();\n+  pool = thr->thread_pool;\n+  task = thr->task;\n+  icv = task ? &task->icv : &gomp_global_icv;\n+\n+  /* Always save the previous state, even if this isn't a nested team.\n+     In particular, we should save any work share state from an outer\n+     orphaned work share construct.  */\n+  team->prev_ts = thr->ts;\n+\n+  thr->ts.team = team;\n+  thr->ts.team_id = 0;\n+  ++thr->ts.level;\n+  if (nthreads > 1)\n+    ++thr->ts.active_level;\n+  thr->ts.work_share = &team->work_shares[0];\n+  thr->ts.last_work_share = NULL;\n+  thr->ts.single_count = 0;\n+  thr->ts.static_trip = 0;\n+  thr->task = &team->implicit_task[0];\n+  nthreads_var = icv->nthreads_var;\n+  gomp_init_task (thr->task, task, icv);\n+  team->implicit_task[0].icv.nthreads_var = nthreads_var;\n+\n+  if (nthreads == 1)\n+    return;\n+\n+  /* Release existing idle threads.  */\n+  for (unsigned i = 1; i < nthreads; ++i)\n+    {\n+      nthr = pool->threads[i];\n+      nthr->ts.team = team;\n+      nthr->ts.work_share = &team->work_shares[0];\n+      nthr->ts.last_work_share = NULL;\n+      nthr->ts.team_id = i;\n+      nthr->ts.level = team->prev_ts.level + 1;\n+      nthr->ts.active_level = thr->ts.active_level;\n+      nthr->ts.single_count = 0;\n+      nthr->ts.static_trip = 0;\n+      nthr->task = &team->implicit_task[i];\n+      gomp_init_task (nthr->task, task, icv);\n+      team->implicit_task[i].icv.nthreads_var = nthreads_var;\n+      nthr->fn = fn;\n+      nthr->data = data;\n+      team->ordered_release[i] = &nthr->release;\n+    }\n+\n+  gomp_simple_barrier_wait (&pool->threads_dock);\n+}\n+\n+#include \"../../team.c\"\n+#endif"}, {"sha": "88fb13050c0b3b5bb6be106c064389894ef05bfd", "filename": "libgomp/config/nvptx/time.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ftime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fnvptx%2Ftime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ftime.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,49 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Dmitry Melnik <dm@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file implements timer routines for NVPTX.  It uses the %clock64 cycle\n+   counter.  */\n+\n+#include \"libgomp.h\"\n+\n+/* This is set from host in plugin-nvptx.c.  */\n+double __nvptx_clocktick = 0;\n+\n+double\n+omp_get_wtime (void)\n+{\n+  uint64_t clock;\n+  asm (\"mov.u64 %0, %%clock64;\" : \"=r\" (clock));\n+  return clock * __nvptx_clocktick;\n+}\n+\n+double\n+omp_get_wtick (void)\n+{\n+  return __nvptx_clocktick;\n+}\n+\n+ialias (omp_get_wtime)\n+ialias (omp_get_wtick)"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgomp/config/nvptx/work.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fwork.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251fe936f3eab1542c1581646254e4bae0f6688/libgomp%2Fconfig%2Fnvptx%2Fwork.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fwork.c?ref=6251fe936f3eab1542c1581646254e4bae0f6688"}, {"sha": "b77491c19f062ee38e702d446f6ca6895348d427", "filename": "libgomp/config/posix/simple-bar.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fposix%2Fsimple-bar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfig%2Fposix%2Fsimple-bar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fsimple-bar.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,69 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is a simplified barrier that is suitable for thread pool\n+   synchronizaton.  Only a subset of full barrier API (bar.h) is exposed.  */\n+\n+#ifndef GOMP_SIMPLE_BARRIER_H\n+#define GOMP_SIMPLE_BARRIER_H 1\n+\n+#include \"bar.h\"\n+\n+typedef struct\n+{\n+  gomp_barrier_t bar;\n+} gomp_simple_barrier_t;\n+\n+static inline void\n+gomp_simple_barrier_init (gomp_simple_barrier_t *bar, unsigned count)\n+{\n+  gomp_barrier_init (&bar->bar, count);\n+}\n+\n+static inline void\n+gomp_simple_barrier_reinit (gomp_simple_barrier_t *bar, unsigned count)\n+{\n+  gomp_barrier_reinit (&bar->bar, count);\n+}\n+\n+static inline void\n+gomp_simple_barrier_destroy (gomp_simple_barrier_t *bar)\n+{\n+  gomp_barrier_destroy (&bar->bar);\n+}\n+\n+static inline void\n+gomp_simple_barrier_wait (gomp_simple_barrier_t *bar)\n+{\n+  gomp_barrier_wait (&bar->bar);\n+}\n+\n+static inline void\n+gomp_simple_barrier_wait_last (gomp_simple_barrier_t *bar)\n+{\n+  gomp_barrier_wait_last (&bar->bar);\n+}\n+\n+#endif /* GOMP_SIMPLE_BARRIER_H */"}, {"sha": "a61f1351ae1a7fdfc29805e0ee35befdf2257099", "filename": "libgomp/configure", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -15070,6 +15070,7 @@ case \"$host\" in\n     ;;\n   nvptx*-*-*)\n     # NVPTX does not support Pthreads, has its own code replacement.\n+    libgomp_use_pthreads=no\n     ;;\n   *)\n     # Check to see if -pthread or -lpthread is needed.  Prefer the former.\n@@ -15115,6 +15116,12 @@ rm -f core conftest.err conftest.$ac_objext \\\n     conftest$ac_exeext conftest.$ac_ext\n esac\n \n+if test x$libgomp_use_pthreads != xno; then\n+\n+$as_echo \"#define LIBGOMP_USE_PTHREADS 1\" >>confdefs.h\n+\n+fi\n+\n # Plugins for offload execution, configure.ac fragment.  -*- mode: autoconf -*-\n #\n # Copyright (C) 2014-2016 Free Software Foundation, Inc."}, {"sha": "5f1db7e1e0e0dd160ed190fac48fc1af61523e69", "filename": "libgomp/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -181,6 +181,7 @@ case \"$host\" in\n     ;;\n   nvptx*-*-*)\n     # NVPTX does not support Pthreads, has its own code replacement.\n+    libgomp_use_pthreads=no\n     ;;\n   *)\n     # Check to see if -pthread or -lpthread is needed.  Prefer the former.\n@@ -202,6 +203,11 @@ case \"$host\" in\n        [AC_MSG_ERROR([Pthreads are required to build libgomp])])])\n esac\n \n+if test x$libgomp_use_pthreads != xno; then\n+  AC_DEFINE(LIBGOMP_USE_PTHREADS, 1,\n+            [Define to 1 if libgomp should use POSIX threads.])\n+fi\n+\n m4_include([plugin/configfrag.ac])\n \n # Check for functions needed."}, {"sha": "cd520dbe5b388fa87e0860f0bee5779772c303d1", "filename": "libgomp/critical.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fcritical.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fcritical.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fcritical.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -115,33 +115,11 @@ GOMP_critical_name_end (void **pptr)\n   gomp_mutex_unlock (plock);\n }\n \n-/* This mutex is used when atomic operations don't exist for the target\n-   in the mode requested.  The result is not globally atomic, but works so\n-   long as all parallel references are within #pragma omp atomic directives.\n-   According to responses received from omp@openmp.org, appears to be within\n-   spec.  Which makes sense, since that's how several other compilers \n-   handle this situation as well.  */\n-\n-static gomp_mutex_t atomic_lock;\n-\n-void\n-GOMP_atomic_start (void)\n-{\n-  gomp_mutex_lock (&atomic_lock);\n-}\n-\n-void\n-GOMP_atomic_end (void)\n-{\n-  gomp_mutex_unlock (&atomic_lock);\n-}\n-\n #if !GOMP_MUTEX_INIT_0\n static void __attribute__((constructor))\n initialize_critical (void)\n {\n   gomp_mutex_init (&default_lock);\n-  gomp_mutex_init (&atomic_lock);\n #ifndef HAVE_SYNC_BUILTINS\n   gomp_mutex_init (&create_lock_lock);\n #endif"}, {"sha": "7ba7663da9aeccde4a3f1fcb5f2b91988c5c143d", "filename": "libgomp/env.c", "status": "modified", "additions": 2, "deletions": 268, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -23,8 +23,8 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n-/* This file defines the OpenMP internal control variables, and arranges\n-   for them to be initialized from environment variables at startup.  */\n+/* This file arranges for OpenMP internal control variables to be initialized\n+   from environment variables at startup.  */\n \n #include \"libgomp.h\"\n #include \"libgomp_f.h\"\n@@ -55,35 +55,6 @@\n # define strtoull(ptr, eptr, base) strtoul (ptr, eptr, base)\n #endif\n \n-struct gomp_task_icv gomp_global_icv = {\n-  .nthreads_var = 1,\n-  .thread_limit_var = UINT_MAX,\n-  .run_sched_var = GFS_DYNAMIC,\n-  .run_sched_chunk_size = 1,\n-  .default_device_var = 0,\n-  .dyn_var = false,\n-  .nest_var = false,\n-  .bind_var = omp_proc_bind_false,\n-  .target_data = NULL\n-};\n-\n-unsigned long gomp_max_active_levels_var = INT_MAX;\n-bool gomp_cancel_var = false;\n-int gomp_max_task_priority_var = 0;\n-#ifndef HAVE_SYNC_BUILTINS\n-gomp_mutex_t gomp_managed_threads_lock;\n-#endif\n-unsigned long gomp_available_cpus = 1, gomp_managed_threads = 1;\n-unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n-unsigned long *gomp_nthreads_var_list, gomp_nthreads_var_list_len;\n-char *gomp_bind_var_list;\n-unsigned long gomp_bind_var_list_len;\n-void **gomp_places_list;\n-unsigned long gomp_places_list_len;\n-int gomp_debug_var;\n-char *goacc_device_type;\n-int goacc_device_num;\n-\n /* Parse the OMP_SCHEDULE environment variable.  */\n \n static void\n@@ -1302,240 +1273,3 @@ initialize_env (void)\n \n   goacc_runtime_initialize ();\n }\n-\n-\f\n-/* The public OpenMP API routines that access these variables.  */\n-\n-void\n-omp_set_num_threads (int n)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (true);\n-  icv->nthreads_var = (n > 0 ? n : 1);\n-}\n-\n-void\n-omp_set_dynamic (int val)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (true);\n-  icv->dyn_var = val;\n-}\n-\n-int\n-omp_get_dynamic (void)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (false);\n-  return icv->dyn_var;\n-}\n-\n-void\n-omp_set_nested (int val)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (true);\n-  icv->nest_var = val;\n-}\n-\n-int\n-omp_get_nested (void)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (false);\n-  return icv->nest_var;\n-}\n-\n-void\n-omp_set_schedule (omp_sched_t kind, int chunk_size)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (true);\n-  switch (kind)\n-    {\n-    case omp_sched_static:\n-      if (chunk_size < 1)\n-\tchunk_size = 0;\n-      icv->run_sched_chunk_size = chunk_size;\n-      break;\n-    case omp_sched_dynamic:\n-    case omp_sched_guided:\n-      if (chunk_size < 1)\n-\tchunk_size = 1;\n-      icv->run_sched_chunk_size = chunk_size;\n-      break;\n-    case omp_sched_auto:\n-      break;\n-    default:\n-      return;\n-    }\n-  icv->run_sched_var = kind;\n-}\n-\n-void\n-omp_get_schedule (omp_sched_t *kind, int *chunk_size)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (false);\n-  *kind = icv->run_sched_var;\n-  *chunk_size = icv->run_sched_chunk_size;\n-}\n-\n-int\n-omp_get_max_threads (void)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (false);\n-  return icv->nthreads_var;\n-}\n-\n-int\n-omp_get_thread_limit (void)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (false);\n-  return icv->thread_limit_var > INT_MAX ? INT_MAX : icv->thread_limit_var;\n-}\n-\n-void\n-omp_set_max_active_levels (int max_levels)\n-{\n-  if (max_levels >= 0)\n-    gomp_max_active_levels_var = max_levels;\n-}\n-\n-int\n-omp_get_max_active_levels (void)\n-{\n-  return gomp_max_active_levels_var;\n-}\n-\n-int\n-omp_get_cancellation (void)\n-{\n-  return gomp_cancel_var;\n-}\n-\n-int\n-omp_get_max_task_priority (void)\n-{\n-  return gomp_max_task_priority_var;\n-}\n-\n-omp_proc_bind_t\n-omp_get_proc_bind (void)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (false);\n-  return icv->bind_var;\n-}\n-\n-void\n-omp_set_default_device (int device_num)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (true);\n-  icv->default_device_var = device_num >= 0 ? device_num : 0;\n-}\n-\n-int\n-omp_get_default_device (void)\n-{\n-  struct gomp_task_icv *icv = gomp_icv (false);\n-  return icv->default_device_var;\n-}\n-\n-int\n-omp_get_num_devices (void)\n-{\n-  return gomp_get_num_devices ();\n-}\n-\n-int\n-omp_get_num_teams (void)\n-{\n-  /* Hardcoded to 1 on host, MIC, HSAIL?  Maybe variable on PTX.  */\n-  return 1;\n-}\n-\n-int\n-omp_get_team_num (void)\n-{\n-  /* Hardcoded to 0 on host, MIC, HSAIL?  Maybe variable on PTX.  */\n-  return 0;\n-}\n-\n-int\n-omp_is_initial_device (void)\n-{\n-  /* Hardcoded to 1 on host, should be 0 on MIC, HSAIL, PTX.  */\n-  return 1;\n-}\n-\n-int\n-omp_get_initial_device (void)\n-{\n-  return GOMP_DEVICE_HOST_FALLBACK;\n-}\n-\n-int\n-omp_get_num_places (void)\n-{\n-  return gomp_places_list_len;\n-}\n-\n-int\n-omp_get_place_num (void)\n-{\n-  if (gomp_places_list == NULL)\n-    return -1;\n-\n-  struct gomp_thread *thr = gomp_thread ();\n-  if (thr->place == 0)\n-    gomp_init_affinity ();\n-\n-  return (int) thr->place - 1;\n-}\n-\n-int\n-omp_get_partition_num_places (void)\n-{\n-  if (gomp_places_list == NULL)\n-    return 0;\n-\n-  struct gomp_thread *thr = gomp_thread ();\n-  if (thr->place == 0)\n-    gomp_init_affinity ();\n-\n-  return thr->ts.place_partition_len;\n-}\n-\n-void\n-omp_get_partition_place_nums (int *place_nums)\n-{\n-  if (gomp_places_list == NULL)\n-    return;\n-\n-  struct gomp_thread *thr = gomp_thread ();\n-  if (thr->place == 0)\n-    gomp_init_affinity ();\n-\n-  unsigned int i;\n-  for (i = 0; i < thr->ts.place_partition_len; i++)\n-    *place_nums++ = thr->ts.place_partition_off + i;\n-}\n-\n-ialias (omp_set_dynamic)\n-ialias (omp_set_nested)\n-ialias (omp_set_num_threads)\n-ialias (omp_get_dynamic)\n-ialias (omp_get_nested)\n-ialias (omp_set_schedule)\n-ialias (omp_get_schedule)\n-ialias (omp_get_max_threads)\n-ialias (omp_get_thread_limit)\n-ialias (omp_set_max_active_levels)\n-ialias (omp_get_max_active_levels)\n-ialias (omp_get_cancellation)\n-ialias (omp_get_proc_bind)\n-ialias (omp_set_default_device)\n-ialias (omp_get_default_device)\n-ialias (omp_get_num_devices)\n-ialias (omp_get_num_teams)\n-ialias (omp_get_team_num)\n-ialias (omp_is_initial_device)\n-ialias (omp_get_initial_device)\n-ialias (omp_get_max_task_priority)\n-ialias (omp_get_num_places)\n-ialias (omp_get_place_num)\n-ialias (omp_get_partition_num_places)\n-ialias (omp_get_partition_place_nums)"}, {"sha": "9bbc0b9b7678216be884b00bb99bcd3b1d29eb54", "filename": "libgomp/icv-device.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv-device.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,77 @@\n+/* Copyright (C) 2005-2016 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file defines OpenMP API entry points that accelerator targets are\n+   expected to replace.  */\n+\n+#include \"libgomp.h\"\n+\n+void\n+omp_set_default_device (int device_num)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->default_device_var = device_num >= 0 ? device_num : 0;\n+}\n+\n+int\n+omp_get_default_device (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->default_device_var;\n+}\n+\n+int\n+omp_get_num_devices (void)\n+{\n+  return gomp_get_num_devices ();\n+}\n+\n+int\n+omp_get_num_teams (void)\n+{\n+  /* Hardcoded to 1 on host, MIC, HSAIL?  Maybe variable on PTX.  */\n+  return 1;\n+}\n+\n+int\n+omp_get_team_num (void)\n+{\n+  /* Hardcoded to 0 on host, MIC, HSAIL?  Maybe variable on PTX.  */\n+  return 0;\n+}\n+\n+int\n+omp_is_initial_device (void)\n+{\n+  /* Hardcoded to 1 on host, should be 0 on MIC, HSAIL, PTX.  */\n+  return 1;\n+}\n+\n+ialias (omp_set_default_device)\n+ialias (omp_get_default_device)\n+ialias (omp_get_num_devices)\n+ialias (omp_get_num_teams)\n+ialias (omp_get_team_num)\n+ialias (omp_is_initial_device)"}, {"sha": "e58b961558e8681c5936cd37ed99549038026358", "filename": "libgomp/icv.c", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ficv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ficv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,248 @@\n+/* Copyright (C) 2005-2016 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file defines the OpenMP internal control variables and associated\n+   OpenMP API entry points.  */\n+\n+#include \"libgomp.h\"\n+#include \"gomp-constants.h\"\n+#include <limits.h>\n+\n+struct gomp_task_icv gomp_global_icv = {\n+  .nthreads_var = 1,\n+  .thread_limit_var = UINT_MAX,\n+  .run_sched_var = GFS_DYNAMIC,\n+  .run_sched_chunk_size = 1,\n+  .default_device_var = 0,\n+  .dyn_var = false,\n+  .nest_var = false,\n+  .bind_var = omp_proc_bind_false,\n+  .target_data = NULL\n+};\n+\n+unsigned long gomp_max_active_levels_var = INT_MAX;\n+bool gomp_cancel_var = false;\n+int gomp_max_task_priority_var = 0;\n+#ifndef HAVE_SYNC_BUILTINS\n+gomp_mutex_t gomp_managed_threads_lock;\n+#endif\n+unsigned long gomp_available_cpus = 1, gomp_managed_threads = 1;\n+unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n+unsigned long *gomp_nthreads_var_list, gomp_nthreads_var_list_len;\n+char *gomp_bind_var_list;\n+unsigned long gomp_bind_var_list_len;\n+void **gomp_places_list;\n+unsigned long gomp_places_list_len;\n+int gomp_debug_var;\n+unsigned int gomp_num_teams_var;\n+char *goacc_device_type;\n+int goacc_device_num;\n+\n+void\n+omp_set_num_threads (int n)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->nthreads_var = (n > 0 ? n : 1);\n+}\n+\n+void\n+omp_set_dynamic (int val)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->dyn_var = val;\n+}\n+\n+int\n+omp_get_dynamic (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->dyn_var;\n+}\n+\n+void\n+omp_set_nested (int val)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->nest_var = val;\n+}\n+\n+int\n+omp_get_nested (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->nest_var;\n+}\n+\n+void\n+omp_set_schedule (omp_sched_t kind, int chunk_size)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  switch (kind)\n+    {\n+    case omp_sched_static:\n+      if (chunk_size < 1)\n+\tchunk_size = 0;\n+      icv->run_sched_chunk_size = chunk_size;\n+      break;\n+    case omp_sched_dynamic:\n+    case omp_sched_guided:\n+      if (chunk_size < 1)\n+\tchunk_size = 1;\n+      icv->run_sched_chunk_size = chunk_size;\n+      break;\n+    case omp_sched_auto:\n+      break;\n+    default:\n+      return;\n+    }\n+  icv->run_sched_var = kind;\n+}\n+\n+void\n+omp_get_schedule (omp_sched_t *kind, int *chunk_size)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  *kind = icv->run_sched_var;\n+  *chunk_size = icv->run_sched_chunk_size;\n+}\n+\n+int\n+omp_get_max_threads (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->nthreads_var;\n+}\n+\n+int\n+omp_get_thread_limit (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->thread_limit_var > INT_MAX ? INT_MAX : icv->thread_limit_var;\n+}\n+\n+void\n+omp_set_max_active_levels (int max_levels)\n+{\n+  if (max_levels >= 0)\n+    gomp_max_active_levels_var = max_levels;\n+}\n+\n+int\n+omp_get_max_active_levels (void)\n+{\n+  return gomp_max_active_levels_var;\n+}\n+\n+int\n+omp_get_cancellation (void)\n+{\n+  return gomp_cancel_var;\n+}\n+\n+int\n+omp_get_max_task_priority (void)\n+{\n+  return gomp_max_task_priority_var;\n+}\n+\n+omp_proc_bind_t\n+omp_get_proc_bind (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->bind_var;\n+}\n+\n+int\n+omp_get_initial_device (void)\n+{\n+  return GOMP_DEVICE_HOST_FALLBACK;\n+}\n+\n+int\n+omp_get_num_places (void)\n+{\n+  return gomp_places_list_len;\n+}\n+\n+int\n+omp_get_place_num (void)\n+{\n+  if (gomp_places_list == NULL)\n+    return -1;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (thr->place == 0)\n+    gomp_init_affinity ();\n+\n+  return (int) thr->place - 1;\n+}\n+\n+int\n+omp_get_partition_num_places (void)\n+{\n+  if (gomp_places_list == NULL)\n+    return 0;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (thr->place == 0)\n+    gomp_init_affinity ();\n+\n+  return thr->ts.place_partition_len;\n+}\n+\n+void\n+omp_get_partition_place_nums (int *place_nums)\n+{\n+  if (gomp_places_list == NULL)\n+    return;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (thr->place == 0)\n+    gomp_init_affinity ();\n+\n+  unsigned int i;\n+  for (i = 0; i < thr->ts.place_partition_len; i++)\n+    *place_nums++ = thr->ts.place_partition_off + i;\n+}\n+\n+ialias (omp_set_dynamic)\n+ialias (omp_set_nested)\n+ialias (omp_set_num_threads)\n+ialias (omp_get_dynamic)\n+ialias (omp_get_nested)\n+ialias (omp_set_schedule)\n+ialias (omp_get_schedule)\n+ialias (omp_get_max_threads)\n+ialias (omp_get_thread_limit)\n+ialias (omp_set_max_active_levels)\n+ialias (omp_get_max_active_levels)\n+ialias (omp_get_cancellation)\n+ialias (omp_get_proc_bind)\n+ialias (omp_get_initial_device)\n+ialias (omp_get_max_task_priority)\n+ialias (omp_get_num_places)\n+ialias (omp_get_place_num)\n+ialias (omp_get_partition_num_places)\n+ialias (omp_get_partition_place_nums)"}, {"sha": "c86ac3d8778b4cee4b1fcc5c67e7715b7ad3a01f", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -45,7 +45,9 @@\n #include \"gstdint.h\"\n #include \"libgomp-plugin.h\"\n \n+#ifdef HAVE_PTHREAD_H\n #include <pthread.h>\n+#endif\n #include <stdbool.h>\n #include <stdlib.h>\n #include <stdarg.h>\n@@ -122,6 +124,7 @@ struct htab;\n #include \"sem.h\"\n #include \"mutex.h\"\n #include \"bar.h\"\n+#include \"simple-bar.h\"\n #include \"ptrlock.h\"\n \n \n@@ -360,6 +363,7 @@ extern char *gomp_bind_var_list;\n extern unsigned long gomp_bind_var_list_len;\n extern void **gomp_places_list;\n extern unsigned long gomp_places_list_len;\n+extern unsigned int gomp_num_teams_var;\n extern int gomp_debug_var;\n extern int goacc_device_num;\n extern char *goacc_device_type;\n@@ -626,8 +630,8 @@ struct gomp_thread_pool\n   /* Number of threads running in this contention group.  */\n   unsigned long threads_busy;\n \n-  /* This barrier holds and releases threads waiting in threads.  */\n-  gomp_barrier_t threads_dock;\n+  /* This barrier holds and releases threads waiting in thread pools.  */\n+  gomp_simple_barrier_t threads_dock;\n };\n \n enum gomp_cancel_kind\n@@ -642,7 +646,15 @@ enum gomp_cancel_kind\n \n /* ... and here is that TLS data.  */\n \n-#if defined HAVE_TLS || defined USE_EMUTLS\n+#if defined __nvptx__\n+extern struct gomp_thread *nvptx_thrs __attribute__((shared));\n+static inline struct gomp_thread *gomp_thread (void)\n+{\n+  int tid;\n+  asm (\"mov.u32 %0, %%tid.y;\" : \"=r\" (tid));\n+  return nvptx_thrs + tid;\n+}\n+#elif defined HAVE_TLS || defined USE_EMUTLS\n extern __thread struct gomp_thread gomp_tls_data;\n static inline struct gomp_thread *gomp_thread (void)\n {\n@@ -671,17 +683,21 @@ static inline struct gomp_task_icv *gomp_icv (bool write)\n     return &gomp_global_icv;\n }\n \n+#ifdef LIBGOMP_USE_PTHREADS\n /* The attributes to be used during thread creation.  */\n extern pthread_attr_t gomp_thread_attr;\n \n extern pthread_key_t gomp_thread_destructor;\n+#endif\n \n /* Function prototypes.  */\n \n /* affinity.c */\n \n extern void gomp_init_affinity (void);\n+#ifdef LIBGOMP_USE_PTHREADS\n extern void gomp_init_thread_affinity (pthread_attr_t *, unsigned int);\n+#endif\n extern void **gomp_affinity_alloc (unsigned long, bool);\n extern void gomp_affinity_init_place (void *);\n extern bool gomp_affinity_add_cpus (void *, unsigned long, unsigned long,"}, {"sha": "783bd77dd90b7c0f7c7620f3e21aa3382d90d55a", "filename": "libgomp/lock.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flock.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -0,0 +1,123 @@\n+/* Copyright (C) 2005-2016 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is a generic implementation of the public OpenMP locking primitives in\n+   terms of internal gomp_mutex_t.  It is not meant to be compiled on its own.\n+   It is #include'd from config/{linux,nvptx}/lock.c.  */\n+\n+#include <string.h>\n+#include \"libgomp.h\"\n+\n+/* The internal gomp_mutex_t and the external non-recursive omp_lock_t\n+   have the same form.  Re-use it.  */\n+\n+void\n+gomp_init_lock_30 (omp_lock_t *lock)\n+{\n+  gomp_mutex_init (lock);\n+}\n+\n+void\n+gomp_destroy_lock_30 (omp_lock_t *lock)\n+{\n+  gomp_mutex_destroy (lock);\n+}\n+\n+void\n+gomp_set_lock_30 (omp_lock_t *lock)\n+{\n+  gomp_mutex_lock (lock);\n+}\n+\n+void\n+gomp_unset_lock_30 (omp_lock_t *lock)\n+{\n+  gomp_mutex_unlock (lock);\n+}\n+\n+int\n+gomp_test_lock_30 (omp_lock_t *lock)\n+{\n+  int oldval = 0;\n+\n+  return __atomic_compare_exchange_n (lock, &oldval, 1, false,\n+\t\t\t\t      MEMMODEL_ACQUIRE, MEMMODEL_RELAXED);\n+}\n+\n+void\n+gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  memset (lock, '\\0', sizeof (*lock));\n+}\n+\n+void\n+gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+}\n+\n+void\n+gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      gomp_mutex_lock (&lock->lock);\n+      lock->owner = me;\n+    }\n+\n+  lock->count++;\n+}\n+\n+void\n+gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  if (--lock->count == 0)\n+    {\n+      lock->owner = NULL;\n+      gomp_mutex_unlock (&lock->lock);\n+    }\n+}\n+\n+int\n+gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+  int oldval;\n+\n+  if (lock->owner == me)\n+    return ++lock->count;\n+\n+  oldval = 0;\n+  if (__atomic_compare_exchange_n (&lock->lock, &oldval, 1, false,\n+\t\t\t\t   MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n+    {\n+      lock->owner = me;\n+      lock->count = 1;\n+      return 1;\n+    }\n+\n+  return 0;\n+}"}, {"sha": "ca33c51db5aeeeab1ed12f5610d6899e4a428224", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 203, "deletions": 10, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -41,6 +41,7 @@\n #include <cuda.h>\n #include <stdbool.h>\n #include <stdint.h>\n+#include <limits.h>\n #include <string.h>\n #include <stdio.h>\n #include <unistd.h>\n@@ -274,6 +275,8 @@ struct targ_fn_descriptor\n {\n   CUfunction fn;\n   const struct targ_fn_launch *launch;\n+  int regs_per_thread;\n+  int max_threads_per_block;\n };\n \n /* A loaded PTX image.  */\n@@ -307,8 +310,12 @@ struct ptx_device\n   bool overlap;\n   bool map;\n   bool concur;\n-  int  mode;\n   bool mkern;\n+  int  mode;\n+  int clock_khz;\n+  int num_sms;\n+  int regs_per_block;\n+  int regs_per_sm;\n \n   struct ptx_image_data *images;  /* Images loaded on device.  */\n   pthread_mutex_t image_lock;     /* Lock for above list.  */\n@@ -658,6 +665,39 @@ nvptx_open_device (int n)\n \t\t  &pi, CU_DEVICE_ATTRIBUTE_INTEGRATED, dev);\n   ptx_dev->mkern = pi;\n \n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_CLOCK_RATE, dev);\n+  ptx_dev->clock_khz = pi;\n+\n+  CUDA_CALL_ERET (NULL,  cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, dev);\n+  ptx_dev->num_sms = pi;\n+\n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, dev);\n+  ptx_dev->regs_per_block = pi;\n+\n+  /* CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82 is defined only\n+     in CUDA 6.0 and newer.  */\n+  r = cuDeviceGetAttribute (&pi, 82, dev);\n+  /* Fallback: use limit of registers per block, which is usually equal.  */\n+  if (r == CUDA_ERROR_INVALID_VALUE)\n+    pi = ptx_dev->regs_per_block;\n+  else if (r != CUDA_SUCCESS)\n+    {\n+      GOMP_PLUGIN_error (\"cuDeviceGetAttribute error: %s\", cuda_error (r));\n+      return NULL;\n+    }\n+  ptx_dev->regs_per_sm = pi;\n+\n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_WARP_SIZE, dev);\n+  if (pi != 32)\n+    {\n+      GOMP_PLUGIN_error (\"Only warp size 32 is supported\");\n+      return NULL;\n+    }\n+\n   r = cuDeviceGetAttribute (&async_engines,\n \t\t\t    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, dev);\n   if (r != CUDA_SUCCESS)\n@@ -725,10 +765,8 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n   CUjit_option opts[6];\n   void *optvals[6];\n   float elapsed = 0.0;\n-#define LOGSIZE 8192\n-  char elog[LOGSIZE];\n-  char ilog[LOGSIZE];\n-  unsigned long logsize = LOGSIZE;\n+  char elog[1024];\n+  char ilog[16384];\n   CUlinkState linkstate;\n   CUresult r;\n   void *linkout;\n@@ -741,13 +779,13 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n   optvals[1] = &ilog[0];\n \n   opts[2] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n-  optvals[2] = (void *) logsize;\n+  optvals[2] = (void *) sizeof ilog;\n \n   opts[3] = CU_JIT_ERROR_LOG_BUFFER;\n   optvals[3] = &elog[0];\n \n   opts[4] = CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;\n-  optvals[4] = (void *) logsize;\n+  optvals[4] = (void *) sizeof elog;\n \n   opts[5] = CU_JIT_LOG_VERBOSE;\n   optvals[5] = (void *) 1;\n@@ -1164,7 +1202,7 @@ nvptx_host2dev (void *d, const void *h, size_t s)\n     }\n \n #ifndef DISABLE_ASYNC\n-  if (nvthd->current_stream != nvthd->ptx_dev->null_stream)\n+  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)\n     {\n       CUevent *e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n       CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n@@ -1220,7 +1258,7 @@ nvptx_dev2host (void *h, const void *d, size_t s)\n     }\n \n #ifndef DISABLE_ASYNC\n-  if (nvthd->current_stream != nvthd->ptx_dev->null_stream)\n+  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)\n     {\n       CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n       CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n@@ -1518,7 +1556,7 @@ GOMP_OFFLOAD_get_name (void)\n unsigned int\n GOMP_OFFLOAD_get_caps (void)\n {\n-  return GOMP_OFFLOAD_CAP_OPENACC_200;\n+  return GOMP_OFFLOAD_CAP_OPENACC_200 | GOMP_OFFLOAD_CAP_OPENMP_400;\n }\n \n int\n@@ -1588,6 +1626,23 @@ GOMP_OFFLOAD_version (void)\n   return GOMP_VERSION;\n }\n \n+/* Initialize __nvptx_clocktick, if present in MODULE.  */\n+\n+static void\n+nvptx_set_clocktick (CUmodule module, struct ptx_device *dev)\n+{\n+  CUdeviceptr dptr;\n+  CUresult r = cuModuleGetGlobal (&dptr, NULL, module, \"__nvptx_clocktick\");\n+  if (r == CUDA_ERROR_NOT_FOUND)\n+    return;\n+  if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuModuleGetGlobal error: %s\", cuda_error (r));\n+  double __nvptx_clocktick = 1e-3 / dev->clock_khz;\n+  r = cuMemcpyHtoD (dptr, &__nvptx_clocktick, sizeof (__nvptx_clocktick));\n+  if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuMemcpyHtoD error: %s\", cuda_error (r));\n+}\n+\n /* Load the (partial) program described by TARGET_DATA to device\n    number ORD.  Allocate and return TARGET_TABLE.  */\n \n@@ -1648,12 +1703,19 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   for (i = 0; i < fn_entries; i++, targ_fns++, targ_tbl++)\n     {\n       CUfunction function;\n+      int nregs, mthrs;\n \n       CUDA_CALL_ERET (-1, cuModuleGetFunction, &function, module,\n \t\t      fn_descs[i].fn);\n+      CUDA_CALL_ERET (-1, cuFuncGetAttribute, &nregs,\n+\t\t      CU_FUNC_ATTRIBUTE_NUM_REGS, function);\n+      CUDA_CALL_ERET (-1, cuFuncGetAttribute, &mthrs,\n+\t\t      CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, function);\n \n       targ_fns->fn = function;\n       targ_fns->launch = &fn_descs[i];\n+      targ_fns->regs_per_thread = nregs;\n+      targ_fns->max_threads_per_block = mthrs;\n \n       targ_tbl->start = (uintptr_t) targ_fns;\n       targ_tbl->end = targ_tbl->start + 1;\n@@ -1671,6 +1733,8 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n       targ_tbl->end = targ_tbl->start + bytes;\n     }\n \n+  nvptx_set_clocktick (module, dev);\n+\n   return fn_entries + var_entries;\n }\n \n@@ -1736,6 +1800,15 @@ GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n \t  && nvptx_host2dev (dst, src, n));\n }\n \n+bool\n+GOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)\n+{\n+  struct ptx_device *ptx_dev = ptx_devices[ord];\n+  CUDA_CALL (cuMemcpyDtoDAsync, (CUdeviceptr) dst, (CUdeviceptr) src, n,\n+\t\t\t\tptx_dev->null_stream->stream);\n+  return true;\n+}\n+\n void (*device_run) (int n, void *fn_ptr, void *vars) = NULL;\n \n void\n@@ -1857,3 +1930,123 @@ GOMP_OFFLOAD_openacc_set_cuda_stream (int async, void *stream)\n {\n   return nvptx_set_cuda_stream (async, stream);\n }\n+\n+/* Adjust launch dimensions: pick good values for number of blocks and warps\n+   and ensure that number of warps does not exceed CUDA limits as well as GCC's\n+   own limits.  */\n+\n+static void\n+nvptx_adjust_launch_bounds (struct targ_fn_descriptor *fn,\n+\t\t\t    struct ptx_device *ptx_dev,\n+\t\t\t    int *teams_p, int *threads_p)\n+{\n+  int max_warps_block = fn->max_threads_per_block / 32;\n+  /* Maximum 32 warps per block is an implementation limit in NVPTX backend\n+     and libgcc, which matches documented limit of all GPUs as of 2015.  */\n+  if (max_warps_block > 32)\n+    max_warps_block = 32;\n+  if (*threads_p <= 0)\n+    *threads_p = 8;\n+  if (*threads_p > max_warps_block)\n+    *threads_p = max_warps_block;\n+\n+  int regs_per_block = fn->regs_per_thread * 32 * *threads_p;\n+  /* This is an estimate of how many blocks the device can host simultaneously.\n+     Actual limit, which may be lower, can be queried with \"occupancy control\"\n+     driver interface (since CUDA 6.0).  */\n+  int max_blocks = ptx_dev->regs_per_sm / regs_per_block * ptx_dev->num_sms;\n+  if (*teams_p <= 0 || *teams_p > max_blocks)\n+    *teams_p = max_blocks;\n+}\n+\n+/* Return the size of per-warp stacks (see gcc -msoft-stack) to use for OpenMP\n+   target regions.  */\n+\n+static size_t\n+nvptx_stacks_size ()\n+{\n+  return 128 * 1024;\n+}\n+\n+/* Return contiguous storage for NUM stacks, each SIZE bytes.  */\n+\n+static void *\n+nvptx_stacks_alloc (size_t size, int num)\n+{\n+  CUdeviceptr stacks;\n+  CUresult r = cuMemAlloc (&stacks, size * num);\n+  if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuMemAlloc error: %s\", cuda_error (r));\n+  return (void *) stacks;\n+}\n+\n+/* Release storage previously allocated by nvptx_stacks_alloc.  */\n+\n+static void\n+nvptx_stacks_free (void *p, int num)\n+{\n+  CUresult r = cuMemFree ((CUdeviceptr) p);\n+  if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuMemFree error: %s\", cuda_error (r));\n+}\n+\n+void\n+GOMP_OFFLOAD_run (int ord, void *tgt_fn, void *tgt_vars, void **args)\n+{\n+  CUfunction function = ((struct targ_fn_descriptor *) tgt_fn)->fn;\n+  CUresult r;\n+  struct ptx_device *ptx_dev = ptx_devices[ord];\n+  const char *maybe_abort_msg = \"(perhaps abort was called)\";\n+  int teams = 0, threads = 0;\n+\n+  if (!args)\n+    GOMP_PLUGIN_fatal (\"No target arguments provided\");\n+  while (*args)\n+    {\n+      intptr_t id = (intptr_t) *args++, val;\n+      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)\n+\tval = (intptr_t) *args++;\n+      else\n+        val = id >> GOMP_TARGET_ARG_VALUE_SHIFT;\n+      if ((id & GOMP_TARGET_ARG_DEVICE_MASK) != GOMP_TARGET_ARG_DEVICE_ALL)\n+\tcontinue;\n+      val = val > INT_MAX ? INT_MAX : val;\n+      id &= GOMP_TARGET_ARG_ID_MASK;\n+      if (id == GOMP_TARGET_ARG_NUM_TEAMS)\n+\tteams = val;\n+      else if (id == GOMP_TARGET_ARG_THREAD_LIMIT)\n+\tthreads = val;\n+    }\n+  nvptx_adjust_launch_bounds (tgt_fn, ptx_dev, &teams, &threads);\n+\n+  size_t stack_size = nvptx_stacks_size ();\n+  void *stacks = nvptx_stacks_alloc (stack_size, teams * threads);\n+  void *fn_args[] = {tgt_vars, stacks, (void *) stack_size};\n+  size_t fn_args_size = sizeof fn_args;\n+  void *config[] = {\n+    CU_LAUNCH_PARAM_BUFFER_POINTER, fn_args,\n+    CU_LAUNCH_PARAM_BUFFER_SIZE, &fn_args_size,\n+    CU_LAUNCH_PARAM_END\n+  };\n+  r = cuLaunchKernel (function,\n+\t\t      teams, 1, 1,\n+\t\t      32, threads, 1,\n+\t\t      0, ptx_dev->null_stream->stream, NULL, config);\n+  if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuLaunchKernel error: %s\", cuda_error (r));\n+\n+  r = cuCtxSynchronize ();\n+  if (r == CUDA_ERROR_LAUNCH_FAILED)\n+    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s %s\\n\", cuda_error (r),\n+\t\t       maybe_abort_msg);\n+  else if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s\", cuda_error (r));\n+  nvptx_stacks_free (stacks, teams * threads);\n+}\n+\n+void\n+GOMP_OFFLOAD_async_run (int ord, void *tgt_fn, void *tgt_vars, void **args,\n+\t\t\tvoid *async_data)\n+{\n+  GOMP_PLUGIN_fatal (\"GOMP_OFFLOAD_async_run unimplemented\");\n+}"}, {"sha": "e301345166275dbb6233a5a9ee8e38d2d4eec65c", "filename": "libgomp/team.c", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -31,6 +31,7 @@\n #include <stdlib.h>\n #include <string.h>\n \n+#ifdef LIBGOMP_USE_PTHREADS\n /* This attribute contains PTHREAD_CREATE_DETACHED.  */\n pthread_attr_t gomp_thread_attr;\n \n@@ -110,7 +111,7 @@ gomp_thread_start (void *xdata)\n     {\n       pool->threads[thr->ts.team_id] = thr;\n \n-      gomp_barrier_wait (&pool->threads_dock);\n+      gomp_simple_barrier_wait (&pool->threads_dock);\n       do\n \t{\n \t  struct gomp_team *team = thr->ts.team;\n@@ -120,7 +121,7 @@ gomp_thread_start (void *xdata)\n \t  gomp_team_barrier_wait_final (&team->barrier);\n \t  gomp_finish_task (task);\n \n-\t  gomp_barrier_wait (&pool->threads_dock);\n+\t  gomp_simple_barrier_wait (&pool->threads_dock);\n \n \t  local_fn = thr->fn;\n \t  local_data = thr->data;\n@@ -134,6 +135,7 @@ gomp_thread_start (void *xdata)\n   thr->task = NULL;\n   return NULL;\n }\n+#endif\n \n static inline struct gomp_team *\n get_last_team (unsigned nthreads)\n@@ -224,11 +226,17 @@ gomp_free_pool_helper (void *thread_pool)\n   struct gomp_thread *thr = gomp_thread ();\n   struct gomp_thread_pool *pool\n     = (struct gomp_thread_pool *) thread_pool;\n-  gomp_barrier_wait_last (&pool->threads_dock);\n+  gomp_simple_barrier_wait_last (&pool->threads_dock);\n   gomp_sem_destroy (&thr->release);\n   thr->thread_pool = NULL;\n   thr->task = NULL;\n+#ifdef LIBGOMP_USE_PTHREADS\n   pthread_exit (NULL);\n+#elif defined(__nvptx__)\n+  asm (\"exit;\");\n+#else\n+#error gomp_free_pool_helper must terminate the thread\n+#endif\n }\n \n /* Free a thread pool and release its threads. */\n@@ -250,12 +258,12 @@ gomp_free_thread (void *arg __attribute__((unused)))\n \t      nthr->data = pool;\n \t    }\n \t  /* This barrier undocks threads docked on pool->threads_dock.  */\n-\t  gomp_barrier_wait (&pool->threads_dock);\n+\t  gomp_simple_barrier_wait (&pool->threads_dock);\n \t  /* And this waits till all threads have called gomp_barrier_wait_last\n \t     in gomp_free_pool_helper.  */\n-\t  gomp_barrier_wait (&pool->threads_dock);\n+\t  gomp_simple_barrier_wait (&pool->threads_dock);\n \t  /* Now it is safe to destroy the barrier and free the pool.  */\n-\t  gomp_barrier_destroy (&pool->threads_dock);\n+\t  gomp_simple_barrier_destroy (&pool->threads_dock);\n \n #ifdef HAVE_SYNC_BUILTINS\n \t  __sync_fetch_and_add (&gomp_managed_threads,\n@@ -266,10 +274,12 @@ gomp_free_thread (void *arg __attribute__((unused)))\n \t  gomp_mutex_unlock (&gomp_managed_threads_lock);\n #endif\n \t}\n-      free (pool->threads);\n       if (pool->last_team)\n \tfree_team (pool->last_team);\n+#ifndef __nvptx__\n+      free (pool->threads);\n       free (pool);\n+#endif\n       thr->thread_pool = NULL;\n     }\n   if (thr->ts.level == 0 && __builtin_expect (thr->ts.team != NULL, 0))\n@@ -284,6 +294,7 @@ gomp_free_thread (void *arg __attribute__((unused)))\n \n /* Launch a team.  */\n \n+#ifdef LIBGOMP_USE_PTHREADS\n void\n gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \t\t unsigned flags, struct gomp_team *team)\n@@ -429,15 +440,15 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n       else if (old_threads_used == 0)\n \t{\n \t  n = 0;\n-\t  gomp_barrier_init (&pool->threads_dock, nthreads);\n+\t  gomp_simple_barrier_init (&pool->threads_dock, nthreads);\n \t}\n       else\n \t{\n \t  n = old_threads_used;\n \n \t  /* Increase the barrier threshold to make sure all new\n \t     threads arrive before the team is released.  */\n-\t  gomp_barrier_reinit (&pool->threads_dock, nthreads);\n+\t  gomp_simple_barrier_reinit (&pool->threads_dock, nthreads);\n \t}\n \n       /* Not true yet, but soon will be.  We're going to release all\n@@ -670,8 +681,8 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \t\t threads and all the threads we're going to let die\n \t\t arrive before the team is released.  */\n \t      if (affinity_count)\n-\t\tgomp_barrier_reinit (&pool->threads_dock,\n-\t\t\t\t     nthreads + affinity_count);\n+\t\tgomp_simple_barrier_reinit (&pool->threads_dock,\n+\t\t\t\t\t    nthreads + affinity_count);\n \t    }\n \t}\n \n@@ -812,7 +823,10 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n     pthread_attr_destroy (&thread_attr);\n \n  do_release:\n-  gomp_barrier_wait (nested ? &team->barrier : &pool->threads_dock);\n+  if (nested)\n+    gomp_barrier_wait (&team->barrier);\n+  else\n+    gomp_simple_barrier_wait (&pool->threads_dock);\n \n   /* Decrease the barrier threshold to match the number of threads\n      that should arrive back at the end of this team.  The extra\n@@ -830,7 +844,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n       if (affinity_count)\n \tdiff = -affinity_count;\n \n-      gomp_barrier_reinit (&pool->threads_dock, nthreads);\n+      gomp_simple_barrier_reinit (&pool->threads_dock, nthreads);\n \n #ifdef HAVE_SYNC_BUILTINS\n       __sync_fetch_and_add (&gomp_managed_threads, diff);\n@@ -844,6 +858,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n       && team->prev_ts.place_partition_len > 64)\n     free (affinity_thr);\n }\n+#endif\n \n \n /* Terminate the current team.  This is only to be called by the master\n@@ -919,6 +934,7 @@ gomp_team_end (void)\n     }\n }\n \n+#ifdef LIBGOMP_USE_PTHREADS\n \n /* Constructors for this file.  */\n \n@@ -943,6 +959,7 @@ team_destructor (void)\n      crashes.  */\n   pthread_key_delete (gomp_thread_destructor);\n }\n+#endif\n \n struct gomp_task_icv *\n gomp_new_icv (void)\n@@ -951,6 +968,8 @@ gomp_new_icv (void)\n   struct gomp_task *task = gomp_malloc (sizeof (struct gomp_task));\n   gomp_init_task (task, NULL, &gomp_global_icv);\n   thr->task = task;\n+#ifdef LIBGOMP_USE_PTHREADS\n   pthread_setspecific (gomp_thread_destructor, thr);\n+#endif\n   return &task->icv;\n }"}, {"sha": "d848ed4d47feb5b531c57282b033d4e774374046", "filename": "libgomp/testsuite/libgomp.fortran/fortran.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ffortran.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ffortran.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ffortran.exp?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -7,7 +7,7 @@ global ALWAYS_CFLAGS\n \n set shlib_ext [get_shlib_extension]\n set lang_library_path\t\"../libgfortran/.libs\"\n-set lang_link_flags\t\"-lgfortran\"\n+set lang_link_flags\t\"-lgfortran -foffload=-lgfortran\"\n if [info exists lang_include_flags] then {\n     unset lang_include_flags\n }"}, {"sha": "663c9323b727b28248e6701e5e6a0da5b5cf7845", "filename": "libgomp/testsuite/libgomp.oacc-fortran/fortran.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffortran.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffortran.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffortran.exp?ref=6103184e81c0b6a8b1f4e072e0c32d9bb86fcc15", "patch": "@@ -9,7 +9,7 @@ global ALWAYS_CFLAGS\n \n set shlib_ext [get_shlib_extension]\n set lang_library_path\t\"../libgfortran/.libs\"\n-set lang_link_flags\t\"-lgfortran\"\n+set lang_link_flags\t\"-lgfortran -foffload=-lgfortran\"\n if [info exists lang_include_flags] then {\n     unset lang_include_flags\n }"}]}