{"sha": "9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEyYWUwOGIwMmQxODVhMTFlM2U1MjVlMTAwYmE2MzdjZTgxYzdmZg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-07-12T16:41:25Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-07-13T08:14:40Z"}, "message": "cris: Add new pass eliminating compares after delay-slot-filling\n\nDelayed-branch-slot-filling a.k.a. reorg or dbr, often causes\nopportunities for more compare-elimination than were visible for\nthe cmpelim pass.  With cc0, these were caught by the\nelimination pass run in \"final\", thus the missed opportunities\nis a regression.  A simple reorg-aware pass run just after reorg\nhandles most of them, if not all.  I chose to keep the \"mach2\"\npass identifier string I copy-pasted from the SPARC port instead\nof inventing one like \"postdbr_cmpelim\".  Note the gap in numbers\nin the test-case file names.\n\ngcc:\n\tPR target/93372\n\t* config/cris/cris-passes.def: New file.\n\t* config/cris/t-cris (PASSES_EXTRA): Add cris-passes.def.\n\t* config/cris/cris.c: Add infrastructure bits and pass execute\n\tfunction cris_postdbr_cmpelim.\n\t* config/cris/cris-protos.h (make_pass_cris_postdbr_cmpelim): Declare.\n\ngcc/testsuite:\n\t* gcc.target/cris/pr93372-44.c, gcc.target/cris/pr93372-46.c: New.", "tree": {"sha": "7e98f9dd3d9cee797158c3957bdee30cdd163b31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e98f9dd3d9cee797158c3957bdee30cdd163b31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "881fb2091cf0609f7a6e3454a3b6f23062943b7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881fb2091cf0609f7a6e3454a3b6f23062943b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881fb2091cf0609f7a6e3454a3b6f23062943b7e"}], "stats": {"total": 255, "additions": 255, "deletions": 0}, "files": [{"sha": "db3c74d49788cf5b4ef03acc092b2eadc0877f82", "filename": "gcc/config/cris/cris-passes.def", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Fcris-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Fcris-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-passes.def?ref=9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "patch": "@@ -0,0 +1,20 @@\n+/* Description of target passes for Visium.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+INSERT_PASS_AFTER (pass_delay_slots, 1, pass_cris_postdbr_cmpelim);"}, {"sha": "053bba90df46623d7fd7b09e6f784ab3dae00c27", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "patch": "@@ -60,3 +60,5 @@ extern int cris_fatal (char *);\n extern int cris_initial_elimination_offset (int, int);\n \n extern void cris_init_expanders (void);\n+\n+extern rtl_opt_pass *make_pass_cris_postdbr_cmpelim (gcc::context *);"}, {"sha": "59cbceef7a4f5754077becc6594211e86e3ce1aa", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "patch": "@@ -51,6 +51,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"tm-constrs.h\"\n #include \"builtins.h\"\n+#include \"cfgrtl.h\"\n+#include \"tree-pass.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -129,6 +131,8 @@ static void cris_asm_output_mi_thunk\n static void cris_file_start (void);\n static void cris_init_libfuncs (void);\n \n+static unsigned int cris_postdbr_cmpelim (void);\n+\n static reg_class_t cris_preferred_reload_class (rtx, reg_class_t);\n \n static int cris_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n@@ -298,6 +302,204 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n+namespace {\n+\n+const pass_data pass_data_cris_postdbr_cmpelim =\n+{\n+  RTL_PASS, /* type */\n+  \"mach2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_MACH_DEP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_cris_postdbr_cmpelim : public rtl_opt_pass\n+{\n+public:\n+  pass_cris_postdbr_cmpelim (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_cris_postdbr_cmpelim, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *)\n+    {\n+      return cris_postdbr_cmpelim ();\n+    }\n+\n+  /* No use running this if reorg and cmpelim aren't both run.  */\n+  virtual bool gate (function *)\n+    {\n+      return\n+\toptimize > 0\n+\t&& flag_delayed_branch\n+\t&& flag_compare_elim_after_reload;\n+    }\n+};\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_cris_postdbr_cmpelim (gcc::context *ctxt)\n+{\n+  return new pass_cris_postdbr_cmpelim (ctxt);\n+}\n+\n+/* \"Cheap version\" of cmpelim, making use of the opportunities opened up\n+   by reorg.\n+\n+   Go through the insns of a function and look at each actual compare\n+   insn; considering only those that compare a register to 0.  If the\n+   previous CC-affecting insn sets the compared register or if a move\n+   reads from it, try to change that into a CC-setting move and try to\n+   have it recognized.  Bail at labels or non-matching insns that\n+   clobber the compared register.  If successful, delete the compare.\n+\n+   Also, reorg isn't up to date regarding data-flow handling, so we\n+   can't go beyond classic RTL scanning.  */\n+\n+static unsigned int\n+cris_postdbr_cmpelim ()\n+{\n+  rtx_insn *insn;\n+  rtx_insn *next;\n+  rtx_insn *prev_cc_setter = 0;\n+  rtx_insn *prev_cc_outer = 0;\n+  rtx dccr = gen_rtx_REG (CCmode, CRIS_CC0_REGNUM);\n+\n+  /* Now look for compares in the insn stream.  */\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      rtx_insn *outer_insn = insn;\n+      rtx pat = PATTERN (insn);\n+\n+      next = NEXT_INSN (outer_insn);\n+\n+      /* Forget previous state when we see a label; we can't track or\n+\t merge its state.  */\n+      if (LABEL_P (insn))\n+\t{\n+\t  prev_cc_setter = 0;\n+\t  continue;\n+\t}\n+\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      /* Consider filled delay slots; there might be a comparison there.\n+\t It's only the second insn in a sequence that is interesting.  */\n+      if (GET_CODE (pat) == SEQUENCE)\n+\tinsn = as_a <rtx_insn *> XVECEXP (pat, 0, 1);\n+      /* The \"else\" eliminates temptations to consider an insn in a\n+\t delay slot for elimination; it can only be a prev_cc_setter.  */\n+      else if (prev_cc_setter != 0 && GET_CODE (pat) == SET)\n+\t{\n+\t  rtx dest = SET_DEST (pat);\n+\t  rtx src = SET_SRC (pat);\n+\t  rtx prev_set;\n+\n+\t  if (REG_P (dest)\n+\t      && REGNO (dest) == CRIS_CC0_REGNUM\n+\t      && GET_CODE (src) == COMPARE\n+\t      && REG_P (XEXP (src, 0))\n+\t      && XEXP (src, 1) == const0_rtx\n+\t      && (prev_set = single_set (prev_cc_setter)) != 0)\n+\t    {\n+\t      /* We have a candidate, and a prev_cc_setter to inspect.  */\n+\t      rtx reg = XEXP (src, 0);\n+\t      rtx prev_dest = SET_DEST (prev_set);\n+\t      rtx prev_src = SET_SRC (prev_set);\n+\t      bool src_same = rtx_equal_p (prev_src, reg);\n+\n+\t      /* If the prev_cc_setter isn't a simple SET, or if the\n+\t\t compared register is modified in prev_cc_setter without\n+\t\t being the destination, or if it's modified between\n+\t\t prev_cc_setter (equal to or contained in prev_cc_outer)\n+\t\t and this insn, then we can't use the flags result.  And\n+\t\t of course, the SET_DEST of prev_cc_setter (the main\n+\t\t interest, not dccr) has to be the same register and\n+\t\t mode we're interested in - or the SET_SRC.  We've\n+\t\t already checked that the compared register isn't\n+\t\t changed in-between.  */\n+\t      if (REG_P (prev_dest)\n+\t\t  && ! reg_set_p (reg, prev_src)\n+\t\t  && ! reg_set_between_p (reg, prev_cc_outer, outer_insn)\n+\t\t  && (src_same || rtx_equal_p (prev_dest, reg)))\n+\t\t{\n+\t\t  machine_mode ccmode = GET_MODE (src);\n+\t\t  rtx modeadjusted_dccr\n+\t\t    = (ccmode == CCmode ? dccr\n+\t\t       : gen_rtx_REG (CCmode, CRIS_CC0_REGNUM));\n+\t\t  rtx compare\n+\t\t    /* We don't need to copy_rtx pat: we're going to\n+\t\t       delete that insn. */\n+\t\t    = (src_same ? pat\n+\t\t       : gen_rtx_SET (modeadjusted_dccr,\n+\t\t\t\t      gen_rtx_COMPARE (ccmode,\n+\t\t\t\t\t\t       copy_rtx (prev_src),\n+\t\t\t\t\t\t       const0_rtx)));\n+\n+\t\t  /* Replace tentatively, the prev_set combo that is\n+\t\t     ((set d s) (clobber dccr)) with\n+\t\t     ((cmp s 0) (set d s)) where (cmp s 0) is the\n+\t\t     compare we're looking at, and validate it or fail\n+\t\t     the whole thing.  First replace the ((set d s) ...)\n+\t\t     with ((cmp s 0) ...)).  */\n+\t\t  validate_change (prev_cc_setter,\n+\t\t\t\t   &XVECEXP (PATTERN (prev_cc_setter),\n+\t\t\t\t\t     0, 0), compare, true);\n+\n+\t\t  /* Then the clobber with the (set d s).  */\n+\t\t  validate_change (prev_cc_setter,\n+\t\t\t\t   &XVECEXP (PATTERN (prev_cc_setter),\n+\t\t\t\t\t     0, 1), prev_set, true);\n+\n+\t\t  if (apply_change_group ())\n+\t\t    {\n+\t\t      delete_insn (insn);\n+\n+\t\t      /* We eliminated the compare.  Then we must go to\n+\t\t\t the next insn: we can't consider the eliminated\n+\t\t\t insn for the next prev_cc_setter.\n+\n+\t\t\t FIXME: if later insns still match, we could do\n+\t\t\t the delete_insn part only, for them.  But, it\n+\t\t\t seems rare that reorg would manage to move a\n+\t\t\t second CC-clobber to another delay-slot,\n+\t\t\t leaving two identical compares (and presumably\n+\t\t\t users).  */\n+\t\t      prev_cc_setter = 0;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      }\n+\t}\n+\n+      if (reg_set_p (dccr, insn))\n+\t{\n+\t  rtx pat = PATTERN (insn);\n+\n+\t  prev_cc_setter = 0;\n+\n+\t  /* Make sure we can use it later on, otherwise forget it.\n+\t     Don't look too close, we're going to pass a lot of these.\n+\t     Just make sure the structure is that we can work with. */\n+\t  if (GET_CODE (pat) == PARALLEL\n+\t      && XVECLEN (pat, 0) == 2\n+\t      && GET_CODE (XVECEXP (pat, 0, 1)) == CLOBBER)\n+\t    {\n+\t      prev_cc_setter = insn;\n+\t      prev_cc_outer = outer_insn;\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Helper for cris_load_multiple_op and cris_ret_movem_op.  */\n \n bool"}, {"sha": "eb4411ede5621a798d97b411ddccc98bbcf8ec53", "filename": "gcc/config/cris/t-cris", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Ft-cris", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Fconfig%2Fcris%2Ft-cris", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Ft-cris?ref=9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "patch": "@@ -24,3 +24,5 @@\n # The makefile macros etc. are included in the order found in the\n # section \"Target Fragment\" in the gcc info-files (or the paper copy) of\n # \"Using and Porting GCC\"\n+\n+PASSES_EXTRA += $(srcdir)/config/cris/cris-passes.def"}, {"sha": "5bd35d120872f988d9be6221c7e16671f8c534ec", "filename": "gcc/testsuite/gcc.target/cris/pr93372-44.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Ftestsuite%2Fgcc.target%2Fcris%2Fpr93372-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Ftestsuite%2Fgcc.target%2Fcris%2Fpr93372-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fcris%2Fpr93372-44.c?ref=9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-not {\\tcmp|\\ttest} } } */\n+\n+extern void foo(void);\n+unsigned int x (unsigned int a, unsigned int b, unsigned int *c)\n+{\n+  unsigned int y = a & 15;\n+  unsigned int z = y + b;\n+  if (y == 0)\n+    *c = z;\n+  return z;\n+}"}, {"sha": "5d7c0301318f91ed13846075a6f2aa890a1cbfc4", "filename": "gcc/testsuite/gcc.target/cris/pr93372-46.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Ftestsuite%2Fgcc.target%2Fcris%2Fpr93372-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2ae08b02d185a11e3e525e100ba637ce81c7ff/gcc%2Ftestsuite%2Fgcc.target%2Fcris%2Fpr93372-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fcris%2Fpr93372-46.c?ref=9a2ae08b02d185a11e3e525e100ba637ce81c7ff", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=v10\" } */\n+/* { dg-final { scan-assembler-not {\\tnop} } } */\n+/* { dg-final { scan-assembler-times {\\tcmp|\\ttest|\\tmove.d \\$r10,\\$r} 1 } } */\n+\n+/* We either have a move from \"a\" to some other register or a compare. */\n+\n+extern void foo(void);\n+unsigned int x (unsigned int a, unsigned int b, unsigned int *c, unsigned int *d)\n+{\n+  unsigned int z = __builtin_clz(b);\n+  if (a != 0)\n+    *c = a;\n+  *d = a;\n+  return z;\n+}"}]}