{"sha": "72fb810db9de1e8abdabefdb524567ad2691568e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJmYjgxMGRiOWRlMWU4YWJkYWJlZmRiNTI0NTY3YWQyNjkxNTY4ZQ==", "commit": {"author": {"name": "Jose Ruiz", "email": "ruiz@adacore.com", "date": "2007-06-06T10:46:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:46:22Z"}, "message": "s-taprob.adb (Unlock): Change the ceiling priority of the underlying lock, if needed.\n\n2007-04-20  Jose Ruiz  <ruiz@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-taprob.adb (Unlock): Change the ceiling priority of the underlying\n\tlock, if needed.\n\n\t* s-taprop.ads (Set_Ceiling): Add this procedure to change the ceiling\n\tpriority associated to a lock.\n\n\t* s-tpoben.adb ([Vulnerable_]Complete_Task, Lock_Entries): Relax\n\tassertion to take into account case of no abort restriction.\n\t(Initialize_Protection_Entries): Add initialization for the field\n\tNew_Ceiling associated to the protected object.\n\t(Unlock_Entries): Change the ceiling priority of the underlying lock, if\n\tneeded.\n\n\t* s-solita.adb (Get_Current_Excep): Moved back to s-tasini/s-tarest,\n\tsince this function needs to be set consistently with Update_Exception.\n\n\t* s-tarest.adb (Get_Current_Excep): Moved back to s-tasini/s-tarest,\n\tsince this function needs to be set consistently with Update_Exception.\n\n\t* s-taskin.ads: Update comments on\n\tInterrupt_Server_Blocked_On_Event_Flag.\n\t(Unbind_Handler): Fix handling of server_task wakeup\n\t(Server_Task): Set self's state so that Unbind_Handler can take\n\tappropriate actions.\n\t(Common_ATCB): Now use a constant from System.Parameters to determine\n\tthe max size of the Task_Image field.\n\n\t* s-tassta.adb (Task_Wrapper): Now pass the overflow guard to the\n\tInitialize_Analyzer function.\n\t([Vulnerable_]Complete_Task, Lock_Entries): Relax assertion to\n\ttake into account case of no abort restriction.\n\t([Vulnerable_]Complete_Master): Modify assertion.\n\n\t* s-tataat.adb (Finalize): Use the nestable versions of\n\tDefer/Undefer_Abort.\n\n\t* s-tpobop.adb (Protected_Entry_Call): Relax assertion.\n\n\t* s-tpobop.ads: Update comments.\n\n\t* s-tposen.adb (Protected_Single_Entry_Call): Call Lock_Entry instead\n\tof locking the object manually, to avoid inconsistencies between\n\tLock/Unlock_Entry assertions.\n\n\t* s-interr.ads, s-interr.adb (Server_Task): Fix race condition when\n\tterminating\n\tapplication and System.Parameters.No_Abort is True.\n\tUpdate comments on Interrupt_Server_Blocked_On_Event_Flag.\n\t(Unbind_Handler): Fix handling of server_task wakeup\n\t(Server_Task): Set self's state so that Unbind_Handler can take\n\tappropriate actions.\n\nFrom-SVN: r125458", "tree": {"sha": "b73f1b3b905e546cc52e9c05f08a94134ce134ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b73f1b3b905e546cc52e9c05f08a94134ce134ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72fb810db9de1e8abdabefdb524567ad2691568e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72fb810db9de1e8abdabefdb524567ad2691568e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72fb810db9de1e8abdabefdb524567ad2691568e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72fb810db9de1e8abdabefdb524567ad2691568e/comments", "author": {"login": "JoseRuizAdaCore", "id": 22770339, "node_id": "MDQ6VXNlcjIyNzcwMzM5", "avatar_url": "https://avatars.githubusercontent.com/u/22770339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoseRuizAdaCore", "html_url": "https://github.com/JoseRuizAdaCore", "followers_url": "https://api.github.com/users/JoseRuizAdaCore/followers", "following_url": "https://api.github.com/users/JoseRuizAdaCore/following{/other_user}", "gists_url": "https://api.github.com/users/JoseRuizAdaCore/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoseRuizAdaCore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoseRuizAdaCore/subscriptions", "organizations_url": "https://api.github.com/users/JoseRuizAdaCore/orgs", "repos_url": "https://api.github.com/users/JoseRuizAdaCore/repos", "events_url": "https://api.github.com/users/JoseRuizAdaCore/events{/privacy}", "received_events_url": "https://api.github.com/users/JoseRuizAdaCore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9f3a4b07df15081483fd4caa5d1e29266917fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f3a4b07df15081483fd4caa5d1e29266917fa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f3a4b07df15081483fd4caa5d1e29266917fa3"}], "stats": {"total": 346, "additions": 226, "deletions": 120}, "files": [{"sha": "f5eb510558a59abb03606302a03afb24d20dc7e9", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -120,7 +120,7 @@ with System.Tasking.Initialization;\n with System.Parameters;\n --  used for Single_Lock\n \n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package body System.Interrupts is\n \n@@ -133,7 +133,7 @@ package body System.Interrupts is\n    package IMNG renames System.Interrupt_Management;\n    package IMOP renames System.Interrupt_Management.Operations;\n \n-   function To_System is new Unchecked_Conversion\n+   function To_System is new Ada.Unchecked_Conversion\n      (Ada.Task_Identification.Task_Id, Task_Id);\n \n    -----------------\n@@ -220,16 +220,16 @@ package body System.Interrupts is\n    --  Holds the task and entry index (if any) for each interrupt\n \n    Blocked : array (Interrupt_ID'Range) of Boolean := (others => False);\n-   pragma Volatile_Components (Blocked);\n+   pragma Atomic_Components (Blocked);\n    --  True iff the corresponding interrupt is blocked in the process level\n \n    Ignored : array (Interrupt_ID'Range) of Boolean := (others => False);\n-   pragma Volatile_Components (Ignored);\n+   pragma Atomic_Components (Ignored);\n    --  True iff the corresponding interrupt is blocked in the process level\n \n    Last_Unblocker :\n      array (Interrupt_ID'Range) of Task_Id := (others => Null_Task);\n-   pragma Volatile_Components (Last_Unblocker);\n+   pragma Atomic_Components (Last_Unblocker);\n    --  Holds the ID of the last Task which Unblocked this Interrupt.\n    --  It contains Null_Task if no tasks have ever requested the\n    --  Unblocking operation or the Interrupt is currently Blocked.\n@@ -567,7 +567,7 @@ package body System.Interrupts is\n          Handler_Addr : System.Address;\n       end record;\n \n-      function To_Fat_Ptr is new Unchecked_Conversion\n+      function To_Fat_Ptr is new Ada.Unchecked_Conversion\n         (Parameterless_Handler, Fat_Ptr);\n \n       Ptr : R_Link;\n@@ -762,25 +762,41 @@ package body System.Interrupts is\n       --------------------\n \n       procedure Unbind_Handler (Interrupt : Interrupt_ID) is\n+         Server : System.Tasking.Task_Id;\n       begin\n          if not Blocked (Interrupt) then\n-\n             --  Currently, there is a Handler or an Entry attached and\n             --  corresponding Server_Task is waiting on \"sigwait.\"\n             --  We have to wake up the Server_Task and make it\n             --  wait on condition variable by sending an\n             --  Abort_Task_Interrupt\n \n-            POP.Abort_Task (Server_ID (Interrupt));\n+            Server := Server_ID (Interrupt);\n \n-            --  Make sure corresponding Server_Task is out of its own\n-            --  sigwait state.\n+            case Server.Common.State is\n+               when Interrupt_Server_Idle_Sleep |\n+                    Interrupt_Server_Blocked_Interrupt_Sleep\n+               =>\n+                  POP.Wakeup (Server, Server.Common.State);\n \n-            Ret_Interrupt :=\n-              Interrupt_ID (IMOP.Interrupt_Wait (Intwait_Mask'Access));\n+               when Interrupt_Server_Blocked_On_Event_Flag =>\n+                  POP.Abort_Task (Server);\n+\n+                  --  Make sure corresponding Server_Task is out of its\n+                  --  own sigwait state.\n \n-            pragma Assert\n-              (Ret_Interrupt = Interrupt_ID (IMNG.Abort_Task_Interrupt));\n+                  Ret_Interrupt :=\n+                    Interrupt_ID (IMOP.Interrupt_Wait (Intwait_Mask'Access));\n+                  pragma Assert\n+                    (Ret_Interrupt = Interrupt_ID (IMNG.Abort_Task_Interrupt));\n+\n+               when Runnable =>\n+                  null;\n+\n+               when others =>\n+                  pragma Assert (False);\n+                  null;\n+            end case;\n \n             IMOP.Install_Default_Action (IMNG.Interrupt_ID (Interrupt));\n \n@@ -1120,7 +1136,7 @@ package body System.Interrupts is\n                   IMOP.Thread_Block_Interrupt (IMNG.Interrupt_ID (Interrupt));\n \n                   if User_Handler (Interrupt).H /= null\n-                    or else  User_Entry (Interrupt).T /= Null_Task\n+                    or else User_Entry (Interrupt).T /= Null_Task\n                   then\n                      --  This is the case where the Server_Task is waiting\n                      --  on \"sigwait.\" Wake it up by sending an\n@@ -1325,14 +1341,23 @@ package body System.Interrupts is\n             --  from status change (Unblocked -> Blocked). If that is not\n             --  the case, we should exceute the attached Procedure or Entry.\n \n+            Self_ID.Common.State := Interrupt_Server_Blocked_On_Event_Flag;\n             POP.Unlock (Self_ID);\n \n             if Single_Lock then\n                POP.Unlock_RTS;\n             end if;\n \n+            --  Avoid race condition when terminating application and\n+            --  System.Parameters.No_Abort is True.\n+\n+            if Parameters.No_Abort and then Self_ID.Pending_Action then\n+               Initialization.Do_Pending_Action (Self_ID);\n+            end if;\n+\n             Ret_Interrupt :=\n               Interrupt_ID (IMOP.Interrupt_Wait (Intwait_Mask'Access));\n+            Self_ID.Common.State := Runnable;\n \n             if Ret_Interrupt = Interrupt_ID (IMNG.Abort_Task_Interrupt) then\n \n@@ -1458,7 +1483,7 @@ begin\n    --  process during the RTS start up. (See processing in s-inmaop.adb). Pass\n    --  the Interrupt_Mask of the environment task to the Interrupt_Manager.\n \n-   --  Note : At this point we know that all tasks are masked for non-reserved\n+   --  Note: At this point we know that all tasks are masked for non-reserved\n    --  signals. Only the Interrupt_Manager will have masks set up differently\n    --  inheriting the original environment task's mask.\n "}, {"sha": "6481fc2bd0672de971c5ae5e81ce3b9f2241b497", "filename": "gcc/ada/s-interr.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.ads?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -209,7 +209,7 @@ package System.Interrupts is\n      (Handler_Addr : System.Address);\n    --  This routine should be called by the compiler to allow the handler be\n    --  used as an Interrupt Handler. That means call this procedure for each\n-   --  pragma Interrup_Handler providing the address of the handler (not\n+   --  pragma Interrupt_Handler providing the address of the handler (not\n    --  including the pointer to the actual PO, this way this routine is called\n    --  only once for each type definition of PO).\n "}, {"sha": "62fd01b5011725b2e5fb4c2f543f963cb6595eea", "filename": "gcc/ada/s-solita.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-solita.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-solita.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -85,9 +85,6 @@ package body System.Soft_Links.Tasking is\n    procedure Set_Sec_Stack_Addr (Addr : Address);\n    --  Get/Set location of current task's secondary stack\n \n-   function Get_Current_Excep return SSL.EOA;\n-   --  Task-safe version of SSL.Get_Current_Excep\n-\n    procedure Timed_Delay_T (Time : Duration; Mode : Integer);\n    --  Task-safe version of SSL.Timed_Delay\n \n@@ -98,11 +95,6 @@ package body System.Soft_Links.Tasking is\n    -- Soft-Link Get Bodies --\n    --------------------------\n \n-   function Get_Current_Excep return SSL.EOA is\n-   begin\n-      return STPO.Self.Common.Compiler_Data.Current_Excep'Access;\n-   end Get_Current_Excep;\n-\n    function Get_Jmpbuf_Address return  Address is\n    begin\n       return STPO.Self.Common.Compiler_Data.Jmpbuf_Address;\n@@ -217,7 +209,6 @@ package body System.Soft_Links.Tasking is\n          SSL.Set_Jmpbuf_Address       := Set_Jmpbuf_Address'Access;\n          SSL.Get_Sec_Stack_Addr       := Get_Sec_Stack_Addr'Access;\n          SSL.Set_Sec_Stack_Addr       := Set_Sec_Stack_Addr'Access;\n-         SSL.Get_Current_Excep        := Get_Current_Excep'Access;\n          SSL.Timed_Delay              := Timed_Delay_T'Access;\n          SSL.Task_Termination_Handler := Task_Termination_Handler_T'Access;\n "}, {"sha": "603d9a268d77b036cdd29f58a1b7931270455e07", "filename": "gcc/ada/s-taprob.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-taprob.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-taprob.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprob.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -40,6 +40,7 @@ with System.Task_Primitives.Operations;\n --  used for Write_Lock\n --           Unlock\n --           Self\n+--           Set_Ceiling\n \n with System.Parameters;\n --  used for Runtime_Traces\n@@ -55,6 +56,13 @@ package body System.Tasking.Protected_Objects is\n    use System.Task_Primitives.Operations;\n    use System.Traces;\n \n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n+   Locking_Policy : Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+\n    -------------------------\n    -- Finalize_Protection --\n    -------------------------\n@@ -255,6 +263,18 @@ package body System.Tasking.Protected_Objects is\n          end;\n       end if;\n \n+      --  Before releasing the mutex we must actually update its ceiling\n+      --  priority if it has been changed.\n+\n+      if Object.New_Ceiling /= Object.Ceiling then\n+         if Locking_Policy = 'C' then\n+            System.Task_Primitives.Operations.Set_Ceiling\n+              (Object.L'Access, Object.New_Ceiling);\n+         end if;\n+\n+         Object.Ceiling := Object.New_Ceiling;\n+      end if;\n+\n       Unlock (Object.L'Access);\n \n       if Parameters.Runtime_Traces then"}, {"sha": "79996b7656708f3108d259be08ab84054c2d1c27", "filename": "gcc/ada/s-taprop.ads", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop.ads?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -138,11 +138,13 @@ package System.Task_Primitives.Operations is\n    --  more details.\n \n    procedure Initialize_Lock\n-     (Prio : System.Any_Priority; L : not null access Lock);\n+     (Prio : System.Any_Priority;\n+      L    : not null access Lock);\n    procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level);\n+     (L     : not null access RTS_Lock;\n+      Level : Lock_Level);\n    pragma Inline (Initialize_Lock);\n-   --  Initialize a lock object.\n+   --  Initialize a lock object\n    --\n    --  For Lock, Prio is the ceiling priority associated with the lock. For\n    --  RTS_Lock, the ceiling is implicitly Priority'Last.\n@@ -158,9 +160,9 @@ package System.Task_Primitives.Operations is\n    --  unless the lock object has been initialized and has not since been\n    --  finalized.\n    --\n-   --  Initialization of the per-task lock is implicit in Create_Task.\n+   --  Initialization of the per-task lock is implicit in Create_Task\n    --\n-   --  These operations raise Storage_Error if a lack of storage is detected.\n+   --  These operations raise Storage_Error if a lack of storage is detected\n \n    procedure Finalize_Lock (L : not null access Lock);\n    procedure Finalize_Lock (L : not null access RTS_Lock);\n@@ -169,9 +171,11 @@ package System.Task_Primitives.Operations is\n    --  corresponding Initialize_Lock operation.\n \n    procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean);\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean);\n    procedure Write_Lock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False);\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False);\n    procedure Write_Lock\n      (T : ST.Task_Id);\n    pragma Inline (Write_Lock);\n@@ -198,7 +202,8 @@ package System.Task_Primitives.Operations is\n    --  per-task lock is implicit in Exit_Task.\n \n    procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean);\n+     (L                 : not null access Lock;\n+      Ceiling_Violation : out Boolean);\n    pragma Inline (Read_Lock);\n    --  Lock a lock object for read access. After this operation returns,\n    --  the calling task has non-exclusive read permission for the logical\n@@ -223,11 +228,12 @@ package System.Task_Primitives.Operations is\n    procedure Unlock\n      (L : not null access Lock);\n    procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False);\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False);\n    procedure Unlock\n      (T : ST.Task_Id);\n    pragma Inline (Unlock);\n-   --  Unlock a locked lock object.\n+   --  Unlock a locked lock object\n    --\n    --  The effect is undefined unless the calling task holds read or write\n    --  permission for the lock L, and L is the lock object most recently\n@@ -251,12 +257,11 @@ package System.Task_Primitives.Operations is\n    --  done at interrupt priority. In general, it is not acceptable to give\n    --  all RTS locks interrupt priority, since that whould give terrible\n    --  performance on systems where this has the effect of masking hardware\n-   --  interrupts, though we could get away with allowing\n-   --  Interrupt_Priority'last where we are layered on an OS that does not\n-   --  allow us to mask interrupts. Ideally, we would like to raise\n-   --  Program_Error back at the original point of the RTS call, but this\n-   --  would require a lot of detailed analysis and recoding, with almost\n-   --  certain performance penalties.\n+   --  interrupts, though we could get away allowing Interrupt_Priority'last\n+   --  where we are layered on an OS that does not allow us to mask interrupts.\n+   --  Ideally, we would like to raise Program_Error back at the original point\n+   --  of the RTS call, but this would require a lot of detailed analysis and\n+   --  recoding, with almost certain performance penalties.\n \n    --  For POSIX systems, we considered just skipping setting priority ceiling\n    --  on RTS locks. This would mean there is no ceiling violation, but we\n@@ -286,6 +291,18 @@ package System.Task_Primitives.Operations is\n \n    --  For now, we will just shut down the system if there is ceiling violation\n \n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority);\n+   pragma Inline (Set_Ceiling);\n+   --  Change the ceiling priority associated to the lock\n+   --\n+   --  The effect is undefined unless the calling task holds read or write\n+   --  permission for the lock L, and L is the lock object most recently\n+   --  locked by the calling task for which the calling task still holds\n+   --  read or write permission. (That is, matching pairs of Lock and Unlock\n+   --  operations on each lock object must be properly nested.)\n+\n    procedure Yield (Do_Yield : Boolean := True);\n    pragma Inline (Yield);\n    --  Yield the processor. Add the calling task to the tail of the ready\n@@ -326,15 +343,15 @@ package System.Task_Primitives.Operations is\n    -- Extensions --\n    ----------------\n \n-   --  Whoever calls either of the Sleep routines is responsible\n-   --  for checking for pending aborts before the call.\n-   --  Pending priority changes are handled internally.\n+   --  Whoever calls either of the Sleep routines is responsible for checking\n+   --  for pending aborts before the call. Pending priority changes are handled\n+   --  internally.\n \n    procedure Sleep\n      (Self_ID : ST.Task_Id;\n       Reason  : System.Tasking.Task_States);\n    pragma Inline (Sleep);\n-   --  Wait until the current task, T,  is signaled to wake up.\n+   --  Wait until the current task, T,  is signaled to wake up\n    --\n    --  precondition:\n    --    The calling task is holding its own ATCB lock\n@@ -400,8 +417,8 @@ package System.Task_Primitives.Operations is\n    --  setup/cleared upon entrance/exit of RTS while maintaining a single\n    --  thread of control in the RTS. Since we intend these routines to be used\n    --  for implementing the Single_Lock RTS, Lock_RTS should follow the first\n-   --  Defer_Abortion operation entering RTS. In the same fashion Unlock_RTS\n-   --  should preceed the last Undefer_Abortion exiting RTS.\n+   --  Defer_Abort operation entering RTS. In the same fashion Unlock_RTS\n+   --  should preceed the last Undefer_Abort exiting RTS.\n    --\n    --  These routines also replace the functions Lock/Unlock_All_Tasks_List\n "}, {"sha": "cfe075835398a9690e2dc14fda9307392febbf2d", "filename": "gcc/ada/s-tarest.adb", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -93,6 +93,9 @@ package body System.Tasking.Restricted.Stages is\n    -- Tasking versions of services needed by non-tasking programs --\n    -----------------------------------------------------------------\n \n+   function Get_Current_Excep return SSL.EOA;\n+   --  Task-safe version of SSL.Get_Current_Excep\n+\n    procedure Task_Lock;\n    --  Locks out other tasks. Preceding a section of code by Task_Lock and\n    --  following it by Task_Unlock creates a critical region. This is used\n@@ -126,6 +129,15 @@ package body System.Tasking.Restricted.Stages is\n    --  installing tasking versions of certain operations used by the compiler.\n    --  Init_RTS is called during elaboration.\n \n+   -----------------------\n+   -- Get_Current_Excep --\n+   -----------------------\n+\n+   function Get_Current_Excep return SSL.EOA is\n+   begin\n+      return STPO.Self.Common.Compiler_Data.Current_Excep'Access;\n+   end Get_Current_Excep;\n+\n    ---------------\n    -- Task_Lock --\n    ---------------\n@@ -616,9 +628,10 @@ package body System.Tasking.Restricted.Stages is\n       --  Notify that the tasking run time has been elaborated so that\n       --  the tasking version of the soft links can be used.\n \n-      SSL.Lock_Task   := Task_Lock'Access;\n-      SSL.Unlock_Task := Task_Unlock'Access;\n-      SSL.Adafinal    := Finalize_Global_Tasks'Access;\n+      SSL.Lock_Task         := Task_Lock'Access;\n+      SSL.Unlock_Task       := Task_Unlock'Access;\n+      SSL.Adafinal          := Finalize_Global_Tasks'Access;\n+      SSL.Get_Current_Excep := Get_Current_Excep'Access;\n \n       --  Initialize the tasking soft links (if not done yet) that are common\n       --  to the full and the restricted run times."}, {"sha": "dad836c824c5eb13edf61bd9c6d436dbefea8ace", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,7 +55,7 @@ with System.Task_Primitives;\n with System.Stack_Usage;\n --  used for Stack_Analyzer\n \n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package System.Tasking is\n    pragma Preelaborate;\n@@ -128,8 +128,10 @@ package System.Tasking is\n    --  This is the compiler interface version of this function. Do not call\n    --  from the run-time system.\n \n-   function To_Task_Id is new Unchecked_Conversion (System.Address, Task_Id);\n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n+   function To_Task_Id is\n+     new Ada.Unchecked_Conversion (System.Address, Task_Id);\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n    -----------------------\n    -- Enumeration types --\n@@ -200,8 +202,8 @@ package System.Tasking is\n       --  The task has been held by Asynchronous_Task_Control.Hold_Task\n \n       Interrupt_Server_Blocked_On_Event_Flag\n-      --  The task has been blocked on a system call waiting for the\n-      --  completion event.\n+      --  The task has been blocked on a system call waiting for a\n+      --  completion event/signal to occur.\n      );\n \n    type Call_Modes is\n@@ -473,7 +475,7 @@ package System.Tasking is\n       --  are invoked from protected actions. pragma Atomic is used because it\n       --  can be read/written from protected interrupt handlers.\n \n-      Task_Image : String (1 .. 32);\n+      Task_Image : String (1 .. System.Parameters.Max_Task_Image_Length);\n       --  Hold a string that provides a readable id for task,\n       --  built from the variable of which it is a value or component.\n \n@@ -991,8 +993,8 @@ package System.Tasking is\n       --  this value.\n \n       Deferral_Level : Natural := 1;\n-      --  This is the number of times that Defer_Abortion has been called by\n-      --  this task without a matching Undefer_Abortion call. Abortion is only\n+      --  This is the number of times that Defer_Abort has been called by\n+      --  this task without a matching Undefer_Abort call. Abortion is only\n       --  allowed when this zero. It is initially 1, to protect the task at\n       --  startup.\n \n@@ -1065,6 +1067,7 @@ package System.Tasking is\n    --  documentation, mention T, and describe Success ???\n \n private\n+\n    Null_Task : constant Task_Id := null;\n \n    type Activation_Chain is limited record"}, {"sha": "28284322f8d5e74d3aa1b5d20f68aec4a358a590", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -66,7 +66,6 @@ with System.Tasking.Initialization;\n --  Used for Remove_From_All_Tasks_List\n --           Defer_Abort\n --           Undefer_Abort\n---           Initialization.Poll_Base_Priority_Change\n --           Finalize_Attributes_Link\n --           Initialize_Attributes_Link\n \n@@ -102,7 +101,7 @@ with System.Standard_Library;\n with System.Traces.Tasking;\n --  Used for Send_Trace_Info\n \n-with Unchecked_Deallocation;\n+with Ada.Unchecked_Deallocation;\n --  To recover from failure of ATCB initialization\n \n with System.Stack_Usage;\n@@ -129,7 +128,7 @@ package body System.Tasking.Stages is\n    -----------------------\n \n    procedure Free is new\n-     Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+     Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_Id);\n    --  This procedure outputs the task specific message for exception\n@@ -179,7 +178,7 @@ package body System.Tasking.Stages is\n    --  For tasks created by an allocator that fails, due to an exception,\n    --  it is called from Expunge_Unactivated_Tasks.\n    --\n-   --  It is also called from Unchecked_Deallocation, for objects that\n+   --  It is also called from Ada.Unchecked_Deallocation, for objects that\n    --  are or contain tasks.\n    --\n    --  Different code is used at master completion, in Terminate_Dependents,\n@@ -387,7 +386,7 @@ package body System.Tasking.Stages is\n       Write_Lock (Self_ID);\n       Self_ID.Common.State := Activator_Sleep;\n \n-      C :=  Chain_Access.T_ID;\n+      C := Chain_Access.T_ID;\n       while C /= null loop\n          Write_Lock (C);\n \n@@ -411,7 +410,6 @@ package body System.Tasking.Stages is\n       --  unsafe to abort any of these tasks until the count goes to zero.\n \n       loop\n-         Initialization.Poll_Base_Priority_Change (Self_ID);\n          exit when Self_ID.Common.Wait_Count = 0;\n          Sleep (Self_ID, Activator_Sleep);\n       end loop;\n@@ -472,7 +470,9 @@ package body System.Tasking.Stages is\n    procedure Complete_Master is\n       Self_ID : constant Task_Id := STPO.Self;\n    begin\n-      pragma Assert (Self_ID.Deferral_Level > 0);\n+      pragma Assert\n+        (Self_ID.Deferral_Level > 0\n+          or else not System.Restrictions.Abort_Allowed);\n       Vulnerable_Complete_Master (Self_ID);\n    end Complete_Master;\n \n@@ -486,7 +486,9 @@ package body System.Tasking.Stages is\n       Self_ID  : constant Task_Id := STPO.Self;\n \n    begin\n-      pragma Assert (Self_ID.Deferral_Level > 0);\n+      pragma Assert\n+        (Self_ID.Deferral_Level > 0\n+          or else not System.Restrictions.Abort_Allowed);\n \n       Vulnerable_Complete_Task (Self_ID);\n \n@@ -953,9 +955,7 @@ package body System.Tasking.Stages is\n           Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n           SSE.Storage_Offset (Parameters.Sec_Stack_Ratio) / 100;\n \n-      Secondary_Stack :\n-        aliased SSE.Storage_Array\n-           (1 .. Secondary_Stack_Size);\n+      Secondary_Stack : aliased SSE.Storage_Array (1 .. Secondary_Stack_Size);\n \n       pragma Warnings (Off);\n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n@@ -969,6 +969,9 @@ package body System.Tasking.Stages is\n       Size :\n         Natural := Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size);\n \n+      Overflow_Guard : Natural;\n+      --  Size of the overflow guard, used by dynamic stack usage analysis\n+\n       pragma Warnings (On);\n       --  Address of secondary stack. In the fixed secondary stack case, this\n       --  value is not modified, causing a warning, hence the bracketing with\n@@ -1004,6 +1007,10 @@ package body System.Tasking.Stages is\n       --  master relationship. If the handler is found, its pointer is stored\n       --  in TH.\n \n+      ------------------------------\n+      -- Search_Fall_Back_Handler --\n+      ------------------------------\n+\n       procedure Search_Fall_Back_Handler (ID : Task_Id) is\n       begin\n          --  If there is a fall back handler, store its pointer for later\n@@ -1030,11 +1037,13 @@ package body System.Tasking.Stages is\n       --  Assume a size of the stack taken at this stage\n \n       if Size < Small_Stack_Limit then\n-         Size := Size - Small_Overflow_Guard;\n+         Overflow_Guard := Small_Overflow_Guard;\n       else\n-         Size := Size - Big_Overflow_Guard;\n+         Overflow_Guard := Big_Overflow_Guard;\n       end if;\n \n+      Size := Size - Overflow_Guard;\n+\n       if not Parameters.Sec_Stack_Dynamic then\n          Self_ID.Common.Compiler_Data.Sec_Stack_Addr :=\n            Secondary_Stack'Address;\n@@ -1048,6 +1057,7 @@ package body System.Tasking.Stages is\n                               Self_ID.Common.Task_Image\n                                 (1 .. Self_ID.Common.Task_Image_Len),\n                               Size,\n+                              Overflow_Guard,\n                               SSE.To_Integer (Bottom_Of_Stack'Address));\n          STPO.Unlock_RTS;\n          Fill_Stack (Self_ID.Common.Analyzer);\n@@ -1225,7 +1235,7 @@ package body System.Tasking.Stages is\n    --  since the operation Task_Unlock continued to access the ATCB after\n    --  unlocking, after which the parent was observed to race ahead, deallocate\n    --  the ATCB, and then reallocate it to another task. The call to\n-   --  Undefer_Abortion in Task_Unlock by the \"terminated\" task was overwriting\n+   --  Undefer_Abort in Task_Unlock by the \"terminated\" task was overwriting\n    --  the data of the new task that reused the ATCB! To solve this problem, we\n    --  introduced the new operation Final_Task_Unlock.\n \n@@ -1334,7 +1344,7 @@ package body System.Tasking.Stages is\n       use System.Standard_Library;\n \n       function To_Address is new\n-        Unchecked_Conversion (Task_Id, System.Address);\n+        Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n       function Tailored_Exception_Information\n         (E : Exception_Occurrence) return String;\n@@ -1492,7 +1502,9 @@ package body System.Tasking.Stages is\n         (Debug.Trace (Self_ID, \"V_Complete_Master\", 'C'));\n \n       pragma Assert (Self_ID.Common.Wait_Count = 0);\n-      pragma Assert (Self_ID.Deferral_Level > 0);\n+      pragma Assert\n+        (Self_ID.Deferral_Level > 0\n+          or else not System.Restrictions.Abort_Allowed);\n \n       --  Count how many active dependent tasks this master currently\n       --  has, and record this in Wait_Count.\n@@ -1559,7 +1571,6 @@ package body System.Tasking.Stages is\n       Write_Lock (Self_ID);\n \n       loop\n-         Initialization.Poll_Base_Priority_Change (Self_ID);\n          exit when Self_ID.Common.Wait_Count = 0;\n \n          --  Here is a difference as compared to Complete_Master\n@@ -1659,7 +1670,6 @@ package body System.Tasking.Stages is\n          Write_Lock (Self_ID);\n \n          loop\n-            Initialization.Poll_Base_Priority_Change (Self_ID);\n             exit when Self_ID.Common.Wait_Count = 0;\n             Sleep (Self_ID, Master_Phase_2_Sleep);\n          end loop;\n@@ -1813,7 +1823,9 @@ package body System.Tasking.Stages is\n \n    procedure Vulnerable_Complete_Task (Self_ID : Task_Id) is\n    begin\n-      pragma Assert (Self_ID.Deferral_Level > 0);\n+      pragma Assert\n+        (Self_ID.Deferral_Level > 0\n+          or else not System.Restrictions.Abort_Allowed);\n       pragma Assert (Self_ID = Self);\n       pragma Assert (Self_ID.Master_Within = Self_ID.Master_of_Task + 1\n                        or else\n@@ -1869,7 +1881,7 @@ package body System.Tasking.Stages is\n \n    --  For tasks created by elaboration of task object declarations it\n    --  is called from the finalization code of the Task_Wrapper procedure.\n-   --  It is also called from Unchecked_Deallocation, for objects that\n+   --  It is also called from Ada.Unchecked_Deallocation, for objects that\n    --  are or contain tasks.\n \n    procedure Vulnerable_Free_Task (T : Task_Id) is"}, {"sha": "1c672769e7f04fbaf299935259117631398af346", "filename": "gcc/ada/s-tataat.adb", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tataat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tataat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2006, AdaCore                     --\n+--                     Copyright (C) 1995-2007, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,14 +41,14 @@ with System.Tasking.Initialization;\n --  used for Defer_Abort\n --           Undefer_Abort\n \n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package body System.Tasking.Task_Attributes is\n \n    use Task_Primitives.Operations;\n    use Tasking.Initialization;\n \n-   function To_Access_Address is new Unchecked_Conversion\n+   function To_Access_Address is new Ada.Unchecked_Conversion\n      (Access_Node, Access_Address);\n    --  Store pointer to indirect attribute list\n \n@@ -61,10 +61,15 @@ package body System.Tasking.Task_Attributes is\n       Self_Id        : constant Task_Id := Self;\n \n    begin\n-      Defer_Abort (Self_Id);\n+      --  Defer abort. Note that we use the nestable versions of Defer_Abort\n+      --  and Undefer_Abort, because abort can already deferred when this is\n+      --  called during finalization, which would cause an assert failure\n+      --  in Defer_Abort.\n+\n+      Defer_Abort_Nestable (Self_Id);\n       Lock_RTS;\n \n-      --  Remove this instantiation from the list of all instantiations.\n+      --  Remove this instantiation from the list of all instantiations\n \n       declare\n          P : Access_Instance;\n@@ -85,7 +90,8 @@ package body System.Tasking.Task_Attributes is\n       end;\n \n       if X.Index /= 0 then\n-         --  Free location of this attribute, for reuse.\n+\n+         --  Free location of this attribute, for reuse\n \n          In_Use := In_Use and not (2**Natural (X.Index));\n \n@@ -140,7 +146,7 @@ package body System.Tasking.Task_Attributes is\n          X.Deallocate.all (Q);\n       end loop;\n \n-      Undefer_Abort (Self_Id);\n+      Undefer_Abort_Nestable (Self_Id);\n \n    exception\n       when others =>"}, {"sha": "b3efad52af155de250523c1ddae29028e72e285f", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,6 +54,7 @@ with System.Task_Primitives.Operations;\n --           Unlock\n --           Get_Priority\n --           Wakeup\n+--           Set_Ceiling\n \n with System.Tasking.Initialization;\n --  Used for Defer_Abort,\n@@ -64,6 +65,9 @@ pragma Elaborate_All (System.Tasking.Initialization);\n --  This insures that tasking is initialized if any protected objects are\n --  created.\n \n+with System.Restrictions;\n+--  Used for Abort_Allowed\n+\n with System.Parameters;\n --  Used for Single_Lock\n \n@@ -216,13 +220,15 @@ package body System.Tasking.Protected_Objects.Entries is\n       Initialization.Defer_Abort (Self_ID);\n       Initialize_Lock (Init_Priority, Object.L'Access);\n       Initialization.Undefer_Abort (Self_ID);\n-      Object.Ceiling := System.Any_Priority (Init_Priority);\n-      Object.Owner := Null_Task;\n-      Object.Compiler_Info := Compiler_Info;\n-      Object.Pending_Action := False;\n+\n+      Object.Ceiling          := System.Any_Priority (Init_Priority);\n+      Object.New_Ceiling      := System.Any_Priority (Init_Priority);\n+      Object.Owner            := Null_Task;\n+      Object.Compiler_Info    := Compiler_Info;\n+      Object.Pending_Action   := False;\n       Object.Call_In_Progress := null;\n-      Object.Entry_Bodies := Entry_Bodies;\n-      Object.Find_Body_Index :=  Find_Body_Index;\n+      Object.Entry_Bodies     := Entry_Bodies;\n+      Object.Find_Body_Index  := Find_Body_Index;\n \n       for E in Object.Entry_Queues'Range loop\n          Object.Entry_Queues (E).Head := null;\n@@ -235,7 +241,8 @@ package body System.Tasking.Protected_Objects.Entries is\n    ------------------\n \n    procedure Lock_Entries\n-     (Object : Protection_Entries_Access; Ceiling_Violation : out Boolean)\n+     (Object            : Protection_Entries_Access;\n+      Ceiling_Violation : out Boolean)\n    is\n    begin\n       if Object.Finalized then\n@@ -264,7 +271,10 @@ package body System.Tasking.Protected_Objects.Entries is\n       --  generated calls must be protected with cleanup handlers to ensure\n       --  that abort is undeferred in all cases.\n \n-      pragma Assert (STPO.Self.Deferral_Level > 0);\n+      pragma Assert\n+        (STPO.Self.Deferral_Level > 0\n+          or else not Restrictions.Abort_Allowed);\n+\n       Write_Lock (Object.L'Access, Ceiling_Violation);\n \n       --  We are entering in a protected action, so that we increase the\n@@ -401,6 +411,18 @@ package body System.Tasking.Protected_Objects.Entries is\n          end;\n       end if;\n \n+      --  Before releasing the mutex we must actually update its ceiling\n+      --  priority if it has been changed.\n+\n+      if Object.New_Ceiling /= Object.Ceiling then\n+         if Locking_Policy = 'C' then\n+            System.Task_Primitives.Operations.Set_Ceiling\n+              (Object.L'Access, Object.New_Ceiling);\n+         end if;\n+\n+         Object.Ceiling := Object.New_Ceiling;\n+      end if;\n+\n       Unlock (Object.L'Access);\n    end Unlock_Entries;\n "}, {"sha": "867e51c8f8125f99c830e99bd8e901bd32f413e7", "filename": "gcc/ada/s-tpobop.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -562,7 +562,7 @@ package body System.Tasking.Protected_Objects.Operations is\n       Mode                : Call_Modes;\n       Block               : out Communication_Block)\n    is\n-      Self_ID             : constant Task_Id  := STPO.Self;\n+      Self_ID             : constant Task_Id := STPO.Self;\n       Entry_Call          : Entry_Call_Link;\n       Initially_Abortable : Boolean;\n       Ceiling_Violation   : Boolean;\n@@ -591,14 +591,17 @@ package body System.Tasking.Protected_Objects.Operations is\n            (Program_Error'Identity, \"potentially blocking operation\");\n       end if;\n \n-      Initialization.Defer_Abort (Self_ID);\n+      --  Self_ID.Deferral_Level should be 0, except when called from Finalize,\n+      --  where abort is already deferred.\n+\n+      Initialization.Defer_Abort_Nestable (Self_ID);\n       Lock_Entries (Object, Ceiling_Violation);\n \n       if Ceiling_Violation then\n \n          --  Failed ceiling check\n \n-         Initialization.Undefer_Abort (Self_ID);\n+         Initialization.Undefer_Abort_Nestable (Self_ID);\n          raise Program_Error;\n       end if;\n \n@@ -651,7 +654,7 @@ package body System.Tasking.Protected_Objects.Operations is\n \n          Block.Enqueued := False;\n          Block.Cancelled := Entry_Call.State = Cancelled;\n-         Initialization.Undefer_Abort (Self_ID);\n+         Initialization.Undefer_Abort_Nestable (Self_ID);\n          Entry_Calls.Check_Exception (Self_ID, Entry_Call);\n          return;\n \n@@ -698,7 +701,7 @@ package body System.Tasking.Protected_Objects.Operations is\n          null;\n       end if;\n \n-      Initialization.Undefer_Abort (Self_ID);\n+      Initialization.Undefer_Abort_Nestable (Self_ID);\n       Entry_Calls.Check_Exception (Self_ID, Entry_Call);\n    end Protected_Entry_Call;\n "}, {"sha": "7c0a5714c1a7531d8295eaa16bddabd6bd96a0f8", "filename": "gcc/ada/s-tpobop.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tpobop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tpobop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.ads?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -88,9 +88,9 @@ package System.Tasking.Protected_Objects.Operations is\n       Timeout               : Duration;\n       Mode                  : Delay_Modes;\n       Entry_Call_Successful : out Boolean);\n-      --  Same as the Protected_Entry_Call but with time-out specified.\n-      --  This routines is used when we do not use ATC mechanism to implement\n-      --  timed entry calls.\n+   --  Same as the Protected_Entry_Call but with time-out specified.\n+   --  This routines is used when we do not use ATC mechanism to implement\n+   --  timed entry calls.\n \n    procedure Service_Entries (Object : Entries.Protection_Entries_Access);\n    pragma Inline (Service_Entries);"}, {"sha": "38554fa53e3629f9a2d3c2fdb475a7598c28366a", "filename": "gcc/ada/s-tposen.adb", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tposen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72fb810db9de1e8abdabefdb524567ad2691568e/gcc%2Fada%2Fs-tposen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.adb?ref=72fb810db9de1e8abdabefdb524567ad2691568e", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---         Copyright (C) 1998-2005, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -548,10 +548,8 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Uninterpreted_Data : System.Address;\n       Mode               : Call_Modes)\n    is\n-      Self_Id           : constant Task_Id := STPO.Self;\n-      Entry_Call        : Entry_Call_Record renames Self_Id.Entry_Calls (1);\n-      Ceiling_Violation : Boolean;\n-\n+      Self_Id    : constant Task_Id := STPO.Self;\n+      Entry_Call : Entry_Call_Record renames Self_Id.Entry_Calls (1);\n    begin\n       --  If pragma Detect_Blocking is active then Program_Error must be\n       --  raised if this potentially blocking operation is called from a\n@@ -564,11 +562,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n            (Program_Error'Identity, \"potentially blocking operation\");\n       end if;\n \n-      STPO.Write_Lock (Object.L'Access, Ceiling_Violation);\n-\n-      if Ceiling_Violation then\n-         raise Program_Error;\n-      end if;\n+      Lock_Entry (Object);\n \n       Entry_Call.Mode := Mode;\n       Entry_Call.State := Now_Abortable;"}]}