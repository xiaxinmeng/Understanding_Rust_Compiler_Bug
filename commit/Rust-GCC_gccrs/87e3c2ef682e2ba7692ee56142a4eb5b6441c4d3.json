{"sha": "87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlM2MyZWY2ODJlMmJhNzY5MmVlNTYxNDJhNGViNWI2NDQxYzRkMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-18T12:12:59Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-22T15:26:57Z"}, "message": "c++: duplicate alias templates with decltype [PR 99425]\n\nThis failure was ultimately from incorrect handling of alias\ntemplates, but required a specific set of occurrences to happen in the\nspecialization hash table.  This cleans up the specialization\nstreaming to add alias instantiations at the same point as other\ninstantiations.  I also removed some unneeded global variables dealing\nwith mapping of duplicate decl contexts.\n\n\tPR c++/99425\n\tgcc/cp/\n\t* cp-tree.h (map_context_from, map_context_to): Delete.\n\t(add_mergeable_specialization): Add is_alias parm.\n\t* pt.c (add_mergeable_specialization): Add is_alias parm, add them.\n\t* module.cc (map_context_from, map_context_to): Delete.\n\t(trees_in::decl_value): Add specializations later, adjust call.\n\tDrop useless alias lookup. Set duplicate fn parm context.\n\t(check_mergeable_decl): Drop context mapping.\n\t(trees_in::is_matching_decl): Likewise.\n\t(trees_in::read_function_def): Drop parameter context adjustment\n\there.\n\tgcc/testsuite/\n\t* g++.dg/modules/pr99425-1.h: New.\n\t* g++.dg/modules/pr99425-1_a.H: New.\n\t* g++.dg/modules/pr99425-1_b.H: New.\n\t* g++.dg/modules/pr99425-1_c.C: New.\n\t* g++.dg/modules/pr99425-2_a.X: New.\n\t* g++.dg/modules/pr99425-2_b.X: New.\n\t* g++.dg/template/pr99425.C: New.", "tree": {"sha": "81c3b97add2b26466f93f5a2fa226b30258d91aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81c3b97add2b26466f93f5a2fa226b30258d91aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "150a829accd76ddd73c20628774cb0781f6e8bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150a829accd76ddd73c20628774cb0781f6e8bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150a829accd76ddd73c20628774cb0781f6e8bfe"}], "stats": {"total": 228, "additions": 159, "deletions": 69}, "files": [{"sha": "e68e3905f80a6d4d2c7202dd54ba489b17e795a7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -5444,10 +5444,6 @@ extern int comparing_specializations;\n    FIXME we should always do this except during deduction/ordering.  */\n extern int comparing_dependent_aliases;\n \n-/* When comparing specializations permit context _FROM to match _TO.  */\n-extern tree map_context_from;\n-extern tree map_context_to;\n-\n /* In parser.c.  */\n \n /* Nonzero if we are parsing an unevaluated operand: an operand to\n@@ -7241,7 +7237,8 @@ extern void walk_specializations\t\t(bool,\n \t\t\t\t\t\t void *);\n extern tree match_mergeable_specialization\t(bool is_decl, spec_entry *);\n extern unsigned get_mergeable_specialization_flags (tree tmpl, tree spec);\n-extern void add_mergeable_specialization        (bool is_decl, spec_entry *,\n+extern void add_mergeable_specialization        (bool is_decl, bool is_alias,\n+\t\t\t\t\t\t spec_entry *,\n \t\t\t\t\t\t tree outer, unsigned);\n extern tree add_outermost_template_args\t\t(tree, tree);\n extern tree add_extra_args\t\t\t(tree, tree);"}, {"sha": "ad3b7d53451abf12c8b9cb6679be2ff8aadbb510", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 29, "deletions": 53, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -279,11 +279,6 @@ static inline tree identifier (const cpp_hashnode *node)\n   return HT_IDENT_TO_GCC_IDENT (HT_NODE (const_cast<cpp_hashnode *> (node)));\n }\n \n-/* During duplicate detection we need to tell some comparators that\n-   these are equivalent.  */\n-tree map_context_from;\n-tree map_context_to;\n-\n /* Id for dumping module information.  */\n int module_dump_id;\n \n@@ -8074,16 +8069,6 @@ trees_in::decl_value ()\n \n       if (spec.spec)\n \tset_constraints (decl, spec.spec);\n-      if (mk & MK_template_mask\n-\t  || mk == MK_partial)\n-\t{\n-\t  /* Add to specialization tables now that constraints etc are\n-\t     added.  */\n-\t  bool is_type = mk == MK_partial || !(mk & MK_tmpl_decl_mask);\n-\n-\t  spec.spec = is_type ? type : mk & MK_tmpl_tmpl_mask ? inner : decl;\n-\t  add_mergeable_specialization (!is_type, &spec, decl, spec_flags);\n-\t}\n \n       if (TREE_CODE (decl) == INTEGER_CST && !TREE_OVERFLOW (decl))\n \t{\n@@ -8111,28 +8096,25 @@ trees_in::decl_value ()\n \t/* Set the TEMPLATE_DECL's type.  */\n \tTREE_TYPE (decl) = TREE_TYPE (inner);\n \n+      if (mk & MK_template_mask\n+\t  || mk == MK_partial)\n+\t{\n+\t  /* Add to specialization tables now that constraints etc are\n+\t     added.  */\n+\t  bool is_type = mk == MK_partial || !(mk & MK_tmpl_decl_mask);\n+\n+\t  spec.spec = is_type ? type : mk & MK_tmpl_tmpl_mask ? inner : decl;\n+\t  add_mergeable_specialization (!is_type,\n+\t\t\t\t\t!is_type && mk & MK_tmpl_alias_mask,\n+\t\t\t\t\t&spec, decl, spec_flags);\n+\t}\n+\n       if (NAMESPACE_SCOPE_P (decl)\n \t  && (mk == MK_named || mk == MK_unique\n \t      || mk == MK_enum || mk == MK_friend_spec)\n \t  && !(VAR_OR_FUNCTION_DECL_P (decl) && DECL_LOCAL_DECL_P (decl)))\n \tadd_module_namespace_decl (CP_DECL_CONTEXT (decl), decl);\n \n-      /* The late insertion of an alias here or an implicit member\n-         (next block), is ok, because we ensured that all imports were\n-         loaded up before we started this cluster.  Thus an insertion\n-         from some other import cannot have happened between the\n-         merged insertion above and these insertions down here.  */\n-      if (mk == MK_alias_spec)\n-\t{\n-\t  /* Insert into type table.  */\n-\t  tree ti = DECL_TEMPLATE_INFO (inner);\n-\t  spec_entry elt = \n-\t    {TI_TEMPLATE (ti), TI_ARGS (ti), TREE_TYPE (inner)};\n-\t  tree texist = match_mergeable_specialization (false, &elt);\n-\t  if (texist)\n-\t    set_overrun ();\n-\t}\n-\n       if (DECL_ARTIFICIAL (decl)\n \t  && TREE_CODE (decl) == FUNCTION_DECL\n \t  && !DECL_TEMPLATE_INFO (decl)\n@@ -8176,6 +8158,14 @@ trees_in::decl_value ()\n       if (!is_matching_decl (existing, decl, is_typedef))\n \tunmatched_duplicate (existing);\n \n+      if (inner && TREE_CODE (inner) == FUNCTION_DECL)\n+\t{\n+\t  tree e_inner = STRIP_TEMPLATE (existing);\n+\t  for (auto parm = DECL_ARGUMENTS (inner);\n+\t       parm; parm = DECL_CHAIN (parm))\n+\t    DECL_CONTEXT (parm) = e_inner;\n+\t}\n+\n       /* And our result is the existing node.  */\n       decl = existing;\n     }\n@@ -8186,7 +8176,7 @@ trees_in::decl_value ()\n       if (!e)\n \t{\n \t  spec.spec = inner;\n-\t  add_mergeable_specialization (true, &spec, decl, spec_flags);\n+\t  add_mergeable_specialization (true, false, &spec, decl, spec_flags);\n \t}\n       else if (e != existing)\n \tset_overrun ();\n@@ -10378,8 +10368,9 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t    {\n \t      if (mk & MK_tmpl_alias_mask)\n \t\t/* It should be in both tables.  */\n-\t\tgcc_assert (match_mergeable_specialization (false, entry)\n-\t\t\t    == TREE_TYPE (existing));\n+\t\tgcc_checking_assert\n+\t\t  (match_mergeable_specialization (false, entry)\n+\t\t   == TREE_TYPE (existing));\n \t      else if (mk & MK_tmpl_tmpl_mask)\n \t\texisting = DECL_TI_TEMPLATE (existing);\n \t    }\n@@ -10392,7 +10383,7 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t    }\n \n \t  /* The walkabout should have found ourselves.  */\n-\t  gcc_assert (existing == decl);\n+\t  gcc_checking_assert (existing == decl);\n \t}\n     }\n   else if (mk != MK_unique)\n@@ -10622,8 +10613,6 @@ check_mergeable_decl (merge_kind mk, tree decl, tree ovl, merge_key const &key)\n \t  break;\n \n \tcase FUNCTION_DECL:\n-\t  map_context_from = d_inner;\n-\t  map_context_to = m_inner;\n \t  if (tree m_type = TREE_TYPE (m_inner))\n \t    if ((!key.ret\n \t\t || same_type_p (key.ret, fndecl_declared_return_type (m_inner)))\n@@ -10647,7 +10636,6 @@ check_mergeable_decl (merge_kind mk, tree decl, tree ovl, merge_key const &key)\n \t\tif (cp_tree_equal (key.constraints, m_reqs))\n \t\t  found = match;\n \t      }\n-\t  map_context_from = map_context_to = NULL_TREE;\n \t  break;\n \n \tcase TYPE_DECL:\n@@ -11022,12 +11010,6 @@ trees_in::is_matching_decl (tree existing, tree decl, bool is_typedef)\n       gcc_checking_assert (TREE_CODE (e_inner) == TREE_CODE (d_inner));\n     }\n \n-  gcc_checking_assert (!map_context_from);\n-  /* This mapping requres the new decl on the lhs and the existing\n-     entity on the rhs of the comparitors below.  */\n-  map_context_from = d_inner;\n-  map_context_to = e_inner;\n-\n   if (TREE_CODE (d_inner) == FUNCTION_DECL)\n     {\n       tree e_ret = fndecl_declared_return_type (existing);\n@@ -11104,7 +11086,6 @@ trees_in::is_matching_decl (tree existing, tree decl, bool is_typedef)\n   else if (!cp_tree_equal (TREE_TYPE (decl), TREE_TYPE (existing)))\n     {\n     mismatch:\n-      map_context_from = map_context_to = NULL_TREE;\n       if (DECL_IS_UNDECLARED_BUILTIN (existing))\n \t/* Just like duplicate_decls, presum the user knows what\n \t   they're doing in overriding a builtin.   */\n@@ -11121,8 +11102,6 @@ trees_in::is_matching_decl (tree existing, tree decl, bool is_typedef)\n \t}\n     }\n \n-  map_context_from = map_context_to = NULL_TREE;\n-\n   if (DECL_IS_UNDECLARED_BUILTIN (existing)\n       && !DECL_IS_UNDECLARED_BUILTIN (decl))\n     {\n@@ -11463,10 +11442,6 @@ trees_in::read_function_def (tree decl, tree maybe_template)\n   tree maybe_dup = odr_duplicate (maybe_template, DECL_SAVED_TREE (decl));\n   bool installing = maybe_dup && !DECL_SAVED_TREE (decl);\n \n-  if (maybe_dup)\n-    for (auto parm = DECL_ARGUMENTS (maybe_dup); parm; parm = DECL_CHAIN (parm))\n-      DECL_CONTEXT (parm) = decl;\n-\n   if (int wtag = i ())\n     {\n       int tag = 1;\n@@ -12881,10 +12856,11 @@ specialization_add (bool decl_p, spec_entry *entry, void *data_)\n \t\t\t   || DECL_CLASS_TEMPLATE_P (entry->tmpl));\n \n        /* Only alias templates can appear in both tables (and\n-\t  if they're in the type table they must also be in the decl table).  */\n+\t  if they're in the type table they must also be in the decl\n+\t  table).  */\n        gcc_checking_assert\n \t (!match_mergeable_specialization (true, entry)\n-\t  == (decl_p || !DECL_ALIAS_TEMPLATE_P (entry->tmpl)));\n+\t  == !DECL_ALIAS_TEMPLATE_P (entry->tmpl));\n     }\n   else if (VAR_OR_FUNCTION_DECL_P (entry->spec))\n     gcc_checking_assert (!DECL_LOCAL_DECL_P (entry->spec));"}, {"sha": "2736bb43299e9d156175951fb79e6e9a2f2d98e5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -30009,25 +30009,41 @@ get_mergeable_specialization_flags (tree tmpl, tree decl)\n    get_mergeable_specialization_flags.  */\n \n void\n-add_mergeable_specialization (bool decl_p, spec_entry *elt,\n+add_mergeable_specialization (bool decl_p, bool alias_p, spec_entry *elt,\n \t\t\t      tree decl, unsigned flags)\n {\n-  hash_table<spec_hasher> *specializations\n-    = decl_p ? decl_specializations : type_specializations;\n-\n   hashval_t hash = spec_hasher::hash (elt);\n-  auto *slot = specializations->find_slot_with_hash (elt, hash, INSERT);\n-\n-  /* We don't distinguish different constrained partial type\n-     specializations, so there could be duplicates.  Everything else\n-     must be new.   */\n-  if (!(flags & 2 && *slot))\n+  if (decl_p)\n     {\n-      gcc_checking_assert (!*slot);\n+      auto *slot = decl_specializations->find_slot_with_hash (elt, hash, INSERT);\n \n+      gcc_checking_assert (!*slot);\n       auto entry = ggc_alloc<spec_entry> ();\n       *entry = *elt;\n       *slot = entry;\n+\n+      if (alias_p)\n+\t{\n+\t  elt->spec = TREE_TYPE (elt->spec);\n+\t  gcc_checking_assert (elt->spec);\n+\t}\n+    }\n+\n+  if (!decl_p || alias_p)\n+    {\n+      auto *slot = type_specializations->find_slot_with_hash (elt, hash, INSERT);\n+\n+      /* We don't distinguish different constrained partial type\n+\t specializations, so there could be duplicates.  Everything else\n+\t must be new.   */\n+      if (!(flags & 2 && *slot))\n+\t{\n+\t  gcc_checking_assert (!*slot);\n+\n+\t  auto entry = ggc_alloc<spec_entry> ();\n+\t  *entry = *elt;\n+\t  *slot = entry;\n+\t}\n     }\n \n   if (flags & 1)"}, {"sha": "de167a64331a6d08d2b53d20253fb387de6b6e43", "filename": "gcc/testsuite/g++.dg/modules/pr99425-1.h", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1.h?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -0,0 +1,11 @@\n+template<typename T>\n+struct make_signed \n+{\n+  using type = int;\n+};\n+\n+template<typename S>\n+using make_signed_t = typename make_signed<S>::type;\n+\n+template<typename U>\n+auto ssize (U &parm) -> make_signed_t<decltype(parm.call())>;"}, {"sha": "6117d4a182cb2b54dfae7e5d843575927056ca15", "filename": "gcc/testsuite/g++.dg/modules/pr99425-1_a.H", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_a.H?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -0,0 +1,4 @@\n+// PR 99425 alias dependent specializations\n+// { dg-additional-options {-fmodule-header} }\n+// { dg-module-cmi {} }\n+#include \"pr99425-1.h\""}, {"sha": "98303a0c68727d351c097806ea6919466622ed9d", "filename": "gcc/testsuite/g++.dg/modules/pr99425-1_b.H", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_b.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_b.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_b.H?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -0,0 +1,19 @@\n+// { dg-additional-options {-fmodule-header -fdump-lang-module-alias} }\n+// { dg-module-cmi {} }\n+\n+#include \"pr99425-1.h\"\n+\n+import \"pr99425-1_a.H\";\n+\n+struct Cont\n+{\n+  int call ();\n+};\n+\n+inline void widget (Cont parm)\n+{\n+  ssize (parm);\n+}\n+\n+// { dg-final { scan-lang-dump {Read:-[0-9]*'s alias spec merge key \\(new\\) type_decl:'::make_signed_t'\\n  ...  Read:-[0-9]*'s type spec merge key \\(new\\) type_decl:'::make_signed'\\n  Read:-1's named merge key \\(matched\\) template_decl:'::template ssize'} module } }\n+"}, {"sha": "28ef3a1ff3048606711144308ae897e00914af26", "filename": "gcc/testsuite/g++.dg/modules/pr99425-1_c.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-1_c.C?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -0,0 +1,11 @@\n+// { dg-additional-options {-fmodules-ts -fdump-lang-module-alias} }\n+import \"pr99425-1_a.H\";\n+import \"pr99425-1_b.H\";\n+\n+void frob (Cont parm)\n+{\n+  ssize (parm);\n+}\n+\n+// { dg-final { scan-lang-dump {Read:-1's named merge key \\(new\\) template_decl:'::template ssize'} module } }\n+// { dg-final { scan-lang-dump {Read:-1's named merge key \\(matched\\) template_decl:'::template ssize'} module } }"}, {"sha": "9a44dc335671a790311d7b74536cbe66df97508b", "filename": "gcc/testsuite/g++.dg/modules/pr99425-2_a.X", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-2_a.X", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-2_a.X", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-2_a.X?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -0,0 +1,7 @@\n+// PR 99425 template aliases can cause equivalences in the hash\n+// tables, and for extra excitement be reordered on rehash.\n+\n+// { dg-additional-options {-x c++-system-header stdexcept -fmodules-ts} }\n+// { dg-prune-output {linker input file unused} }\n+\n+No! DO NOT COMPILE;"}, {"sha": "5e453542cd17cb84976da774ee53835fa27c76c7", "filename": "gcc/testsuite/g++.dg/modules/pr99425-2_b.X", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-2_b.X", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-2_b.X", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99425-2_b.X?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -0,0 +1,4 @@\n+// { dg-additional-options {-x c++-system-header mutex -fmodules-ts} }\n+// { dg-prune-output {linker input file unused} }\n+\n+No! DO NOT COMPILE;"}, {"sha": "fd49c86b74ca3f66cd175c842a61669e0e7a6c3d", "filename": "gcc/testsuite/g++.dg/template/pr99425.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr99425.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr99425.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr99425.C?ref=87e3c2ef682e2ba7692ee56142a4eb5b6441c4d3", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile { target c++20 } }\n+// a potential fix for 99425 generated an ICE here.\n+\n+template<typename _Tp>\n+struct is_nothrow_destructible;\n+\n+template<typename _Tp>\n+struct common_reference;\n+\n+template<typename _Tp>\n+concept same_as\n+  = true;\n+\n+template<typename _Sent, typename _Iter>\n+concept sentinel_for\n+  = same_as<common_reference<_Sent>>\n+  && is_nothrow_destructible<_Iter>::value;\n+\n+template<typename _Tp>\n+concept __member_end\n+  = requires (_Tp& __t)\n+  {\n+    { true }\n+    -> sentinel_for<decltype(__t)>;\n+  };\n+\n+template<typename _Tp>\n+concept __adl_end\n+  = requires (_Tp& __t)\n+  {\n+    { true }\n+    -> sentinel_for<decltype(__t)>;\n+  };\n+\n+template<typename _Tp>\n+requires __member_end<_Tp> || __adl_end<_Tp>\n+  void\n+  Bar (_Tp&& __t)\n+{\n+}\n+\n+void test03 ()\n+{\n+  Bar (1); // { dg-error \"no matching function\" }\n+}"}]}