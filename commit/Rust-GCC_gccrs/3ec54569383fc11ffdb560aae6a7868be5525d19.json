{"sha": "3ec54569383fc11ffdb560aae6a7868be5525d19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VjNTQ1NjkzODNmYzExZmZkYjU2MGFhZTZhNzg2OGJlNTUyNWQxOQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T12:10:30Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T12:10:30Z"}, "message": "[multiple changes]\n\n2017-11-09  Pascal Obry  <obry@adacore.com>\n\n\t* libgnarl/s-taprop__mingw.adb: On Windows, initialize the thead handle\n\tonly for foreign threads.  We initialize the thread handle only if not\n\tyet initialized. This happens in Enter_Task for foreign threads only.\n\tBut for native threads (Ada tasking) we do want to keep the real\n\thandle (from Create_Task) to be able to free the corresponding\n\tresources in Finalize_TCB (CloseHandle).\n\n2017-11-09  Yannick Moy  <moy@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Default initialize P_Type,\n\tP_Base_Type.\n\t(Error_Attr_P): Fix name in pragma No_Return.\n\t(Unexpected_Argument): Add pragma No_Return.\n\t(Placement_Error): Add pragma No_Return.\n\n2017-11-09  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Elab_Flag_Needed): Elaboration flag not needed when the\n\tdispatch table is statically built.\n\t(Make_DT): Declare constant the Interface_Table object associated with\n\tan statically built dispatch table. For this purpose the Offset_To_Top\n\tvalue of each interface is computed using the dummy object.\n\t* exp_ch3.adb (Build_Init_Procedure): Do not generate code initializing\n\tthe Offset_To_Top field of secondary dispatch tables when the dispatch\n\ttable is statically built.\n\t(Initialize_Tag): Do not generate calls to Register_Interface_Offset\n\twhen the dispatch table is statically built.\n\t* doc/gnat_rm/standard_and_implementation_defined_restrictions.rst:\n\tDocument the new GNAT restriction Static_Dispatch_Tables.\n\t* gnat_rm.texi: Regenerate.\n\n2017-11-09  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Delta_Record_Aggregate): Reorder declarations\n\tto avoid a dormant bug.\n\n2017-11-09  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* init.c: Define missing __gnat_alternate_stack for QNX. Set it to 0,\n\tas such capability is not available on the OS.\n\t* link.c: Make sure linker options for QNX are correct.\n\t* libgnarl/s-osinte__qnx.ads: Add some missing bindings to pthread.\n\t* libgnarl/s-taprop__qnx.adb: New, derived from s-taprop__posix.adb. This brings\n\tin particular a workaround with locks priority ceiling where a higher\n\tpriority task is allowed to lock a lower ceiling priority lock. This\n\talso fixes the scheduling of FIFO tasks when the priority of a task is\n\tlowered.\n\t* libgnat/system-qnx-aarch64.ads: Fix priority ranges.\n\n2017-11-09  Yannick Moy  <moy@adacore.com>\n\n\t* erroutc.adb (Output_Error_Msgs): Justify CodePeer false positive\n\tmessage.\n\t* gnatbind.adb (Scan_Bind_Arg): Simplify test to remove always true\n\tcondition.\n\t* namet.adb (Copy_One_Character): Add assumption for static analysis,\n\tas knowledge that Hex(2) is in the range 0..255 is too complex for\n\tCodePeer.\n\t(Finalize): Add assumption for static analysis, as the fact that there\n\tare symbols in the table depends on a global invariant at this point in\n\tthe program.\n\t* set_targ.adb (Check_Spaces): Justify CodePeer false positive message.\n\t* stylesw.adb (Save_Style_Check_Options): Rewrite to avoid test always\n\ttrue.\n\nFrom-SVN: r254573", "tree": {"sha": "df3d3c2d38f9e33c6d76942ad5a05d20abb8af83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df3d3c2d38f9e33c6d76942ad5a05d20abb8af83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ec54569383fc11ffdb560aae6a7868be5525d19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec54569383fc11ffdb560aae6a7868be5525d19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec54569383fc11ffdb560aae6a7868be5525d19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec54569383fc11ffdb560aae6a7868be5525d19/comments", "author": null, "committer": null, "parents": [{"sha": "6214b83bf1b6d05c9ff3bdb419975851bc131b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6214b83bf1b6d05c9ff3bdb419975851bc131b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6214b83bf1b6d05c9ff3bdb419975851bc131b97"}], "stats": {"total": 2471, "additions": 2005, "deletions": 466}, "files": [{"sha": "acf85c6e9d64073089c8ce540f1505b202913a25", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -1,3 +1,70 @@\n+2017-11-09  Pascal Obry  <obry@adacore.com>\n+\n+\t* libgnarl/s-taprop__mingw.adb: On Windows, initialize the thead handle\n+\tonly for foreign threads.  We initialize the thread handle only if not\n+\tyet initialized. This happens in Enter_Task for foreign threads only.\n+\tBut for native threads (Ada tasking) we do want to keep the real\n+\thandle (from Create_Task) to be able to free the corresponding\n+\tresources in Finalize_TCB (CloseHandle).\n+\n+2017-11-09  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Default initialize P_Type,\n+\tP_Base_Type.\n+\t(Error_Attr_P): Fix name in pragma No_Return.\n+\t(Unexpected_Argument): Add pragma No_Return.\n+\t(Placement_Error): Add pragma No_Return.\n+\n+2017-11-09  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Elab_Flag_Needed): Elaboration flag not needed when the\n+\tdispatch table is statically built.\n+\t(Make_DT): Declare constant the Interface_Table object associated with\n+\tan statically built dispatch table. For this purpose the Offset_To_Top\n+\tvalue of each interface is computed using the dummy object.\n+\t* exp_ch3.adb (Build_Init_Procedure): Do not generate code initializing\n+\tthe Offset_To_Top field of secondary dispatch tables when the dispatch\n+\ttable is statically built.\n+\t(Initialize_Tag): Do not generate calls to Register_Interface_Offset\n+\twhen the dispatch table is statically built.\n+\t* doc/gnat_rm/standard_and_implementation_defined_restrictions.rst:\n+\tDocument the new GNAT restriction Static_Dispatch_Tables.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2017-11-09  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Delta_Record_Aggregate): Reorder declarations\n+\tto avoid a dormant bug.\n+\n+2017-11-09  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* init.c: Define missing __gnat_alternate_stack for QNX. Set it to 0,\n+\tas such capability is not available on the OS.\n+\t* link.c: Make sure linker options for QNX are correct.\n+\t* libgnarl/s-osinte__qnx.ads: Add some missing bindings to pthread.\n+\t* libgnarl/s-taprop__qnx.adb: New, derived from s-taprop__posix.adb. This brings\n+\tin particular a workaround with locks priority ceiling where a higher\n+\tpriority task is allowed to lock a lower ceiling priority lock. This\n+\talso fixes the scheduling of FIFO tasks when the priority of a task is\n+\tlowered.\n+\t* libgnat/system-qnx-aarch64.ads: Fix priority ranges.\n+\n+2017-11-09  Yannick Moy  <moy@adacore.com>\n+\n+\t* erroutc.adb (Output_Error_Msgs): Justify CodePeer false positive\n+\tmessage.\n+\t* gnatbind.adb (Scan_Bind_Arg): Simplify test to remove always true\n+\tcondition.\n+\t* namet.adb (Copy_One_Character): Add assumption for static analysis,\n+\tas knowledge that Hex(2) is in the range 0..255 is too complex for\n+\tCodePeer.\n+\t(Finalize): Add assumption for static analysis, as the fact that there\n+\tare symbols in the table depends on a global invariant at this point in\n+\tthe program.\n+\t* set_targ.adb (Check_Spaces): Justify CodePeer false positive message.\n+\t* stylesw.adb (Save_Style_Check_Options): Rewrite to avoid test always\n+\ttrue.\n+\n 2017-11-09  Javier Miranda  <miranda@adacore.com>\n \n \t* libgnat/s-rident.ads (Static_Dispatch_Tables): New restriction name."}, {"sha": "2174636e4c567cf2916a61c360f88b909e5ea383", "filename": "gcc/ada/doc/gnat_rm/standard_and_implementation_defined_restrictions.rst", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -988,6 +988,13 @@ appear, and that no wide or wide wide string or character literals\n appear in the program (that is literals representing characters not in\n type ``Character``).\n \n+Static_Dispatch_Tables\n+----------------------\n+.. index:: Static_Dispatch_Tables\n+\n+[GNAT] This restriction ensures at compile time that all the artifacts\n+associated with dispatch tables can be placed in read-only memory.\n+\n SPARK_05\n --------\n .. index:: SPARK_05"}, {"sha": "a14037c13802da0faaf102815cb885273f087c15", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -512,6 +512,9 @@ package body Erroutc is\n                   --  so now we output a tab to match up with the text.\n \n                   if Src (P) = ASCII.HT then\n+                     pragma Annotate\n+                       (CodePeer, False_Positive, \"validity check\",\n+                        \"Src(P) is initialized at this point\");\n                      Write_Char (ASCII.HT);\n                      P := P + 1;\n "}, {"sha": "5d295e7942b48a617b2ce6eb119e1bc7001db893", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -2544,6 +2544,7 @@ package body Exp_Ch3 is\n                  and then Has_Interfaces (Rec_Type)\n                then\n                   declare\n+                     Elab_List              : List_Id := New_List;\n                      Elab_Sec_DT_Stmts_List : constant List_Id := New_List;\n \n                   begin\n@@ -2555,24 +2556,30 @@ package body Exp_Ch3 is\n                         Fixed_Comps    => True,\n                         Variable_Comps => False);\n \n-                     Append_To (Elab_Sec_DT_Stmts_List,\n-                       Make_Assignment_Statement (Loc,\n-                         Name       =>\n-                           New_Occurrence_Of\n-                             (Access_Disp_Table_Elab_Flag (Rec_Type), Loc),\n-                         Expression =>\n-                           New_Occurrence_Of (Standard_False, Loc)));\n-\n-                     Prepend_List_To (Body_Stmts, New_List (\n+                     Elab_List := New_List (\n                        Make_If_Statement (Loc,\n                          Condition       => New_Occurrence_Of (Set_Tag, Loc),\n-                         Then_Statements => Init_Tags_List),\n+                         Then_Statements => Init_Tags_List));\n+\n+                     if Elab_Flag_Needed (Rec_Type) then\n+                        Append_To (Elab_Sec_DT_Stmts_List,\n+                          Make_Assignment_Statement (Loc,\n+                            Name       =>\n+                              New_Occurrence_Of\n+                                (Access_Disp_Table_Elab_Flag (Rec_Type),\n+                                 Loc),\n+                            Expression =>\n+                              New_Occurrence_Of (Standard_False, Loc)));\n+\n+                        Append_To (Elab_List,\n+                          Make_If_Statement (Loc,\n+                            Condition       =>\n+                              New_Occurrence_Of\n+                                (Access_Disp_Table_Elab_Flag (Rec_Type), Loc),\n+                            Then_Statements => Elab_Sec_DT_Stmts_List));\n+                     end if;\n \n-                       Make_If_Statement (Loc,\n-                         Condition       =>\n-                           New_Occurrence_Of\n-                             (Access_Disp_Table_Elab_Flag (Rec_Type), Loc),\n-                         Then_Statements => Elab_Sec_DT_Stmts_List)));\n+                     Prepend_List_To (Body_Stmts, Elab_List);\n                   end;\n                else\n                   Prepend_To (Body_Stmts,\n@@ -8588,7 +8595,9 @@ package body Exp_Ch3 is\n             --       Offset_Value => n,\n             --       Offset_Func  => null);\n \n-            if RTE_Available (RE_Register_Interface_Offset) then\n+            if not Building_Static_Secondary_DT (Typ)\n+              and then RTE_Available (RE_Register_Interface_Offset)\n+            then\n                Append_To (Stmts_List,\n                  Make_Procedure_Call_Statement (Loc,\n                    Name                   =>"}, {"sha": "cab27bbf0436025ab874108d4eb743dcf59780f4", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -677,7 +677,8 @@ package body Exp_Disp is\n    begin\n       return Ada_Version >= Ada_2005\n         and then not Is_Interface (Typ)\n-        and then Has_Interfaces (Typ);\n+        and then Has_Interfaces (Typ)\n+        and then not Building_Static_DT (Typ);\n    end Elab_Flag_Needed;\n \n    -----------------------------\n@@ -5513,11 +5514,23 @@ package body Exp_Disp is\n \n          else\n             declare\n-               TSD_Ifaces_List : constant List_Id := New_List;\n-               Elmt       : Elmt_Id;\n-               Sec_DT_Tag : Node_Id;\n+               TSD_Ifaces_List  : constant List_Id := New_List;\n+               Elmt             : Elmt_Id;\n+               Ifaces_List      : Elist_Id;\n+               Ifaces_Comp_List : Elist_Id;\n+               Ifaces_Tag_List  : Elist_Id;\n+               Offset_To_Top    : Node_Id;\n+               Sec_DT_Tag       : Node_Id;\n \n             begin\n+               --  Collect interfaces information if we need to compute the\n+               --  offset to the top using the dummy object.\n+\n+               if Present (Dummy_Object) then\n+                  Collect_Interfaces_Info (Typ,\n+                    Ifaces_List, Ifaces_Comp_List, Ifaces_Tag_List);\n+               end if;\n+\n                AI := First_Elmt (Typ_Ifaces);\n                while Present (AI) loop\n                   if Is_Ancestor (Node (AI), Typ, Use_Full_View => True) then\n@@ -5552,6 +5565,46 @@ package body Exp_Disp is\n                                          Loc);\n                   end if;\n \n+                  --  For static dispatch tables compute Offset_To_Top using\n+                  --  the dummy object.\n+\n+                  if Present (Dummy_Object) then\n+                     declare\n+                        Iface            : constant Node_Id := Node (AI);\n+                        Iface_Comp       : Node_Id := Empty;\n+                        Iface_Comp_Elmt  : Elmt_Id;\n+                        Iface_Elmt       : Elmt_Id;\n+\n+                     begin\n+                        Iface_Elmt      := First_Elmt (Ifaces_List);\n+                        Iface_Comp_Elmt := First_Elmt (Ifaces_Comp_List);\n+\n+                        while Present (Iface_Elmt) loop\n+                           if Node (Iface_Elmt) = Iface then\n+                              Iface_Comp := Node (Iface_Comp_Elmt);\n+                              exit;\n+                           end if;\n+\n+                           Next_Elmt (Iface_Elmt);\n+                           Next_Elmt (Iface_Comp_Elmt);\n+                        end loop;\n+                        pragma Assert (Present (Iface_Comp));\n+\n+                        Offset_To_Top :=\n+                          Make_Op_Minus (Loc,\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix         =>\n+                                Make_Selected_Component (Loc,\n+                                  Prefix        =>\n+                                    New_Occurrence_Of (Dummy_Object, Loc),\n+                                  Selector_Name =>\n+                                    New_Occurrence_Of (Iface_Comp, Loc)),\n+                              Attribute_Name => Name_Position));\n+                     end;\n+                  else\n+                     Offset_To_Top := Make_Integer_Literal (Loc, 0);\n+                  end if;\n+\n                   Append_To (TSD_Ifaces_List,\n                      Make_Aggregate (Loc,\n                        Expressions => New_List (\n@@ -5569,7 +5622,7 @@ package body Exp_Disp is\n \n                         --  Offset_To_Top_Value\n \n-                        Make_Integer_Literal (Loc, 0),\n+                        Offset_To_Top,\n \n                         --  Offset_To_Top_Func\n \n@@ -5589,17 +5642,15 @@ package body Exp_Disp is\n                Set_Is_Statically_Allocated (ITable,\n                  Is_Library_Level_Tagged_Type (Typ));\n \n-               --  The table of interfaces is not constant; its slots are\n-               --  filled at run time by the IP routine using attribute\n-               --  'Position to know the location of the tag components\n-               --  (and this attribute cannot be safely used before the\n-               --  object is initialized).\n+               --  The table of interfaces is constant if we are building a\n+               --  static dispatch table; otherwise is not constant because\n+               --  its slots are filled at run time by the IP routine.\n \n                Append_To (Result,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => ITable,\n                    Aliased_Present     => True,\n-                   Constant_Present    => False,\n+                   Constant_Present    => Present (Dummy_Object),\n                    Object_Definition   =>\n                      Make_Subtype_Indication (Loc,\n                        Subtype_Mark =>"}, {"sha": "21c195d21c1d39056c4d83320ad02a7dc96d437e", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 349, "deletions": 337, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=3ec54569383fc11ffdb560aae6a7868be5525d19"}, {"sha": "4f5197d82bde94a0ff2c3fa92c1e8cf741f8bdad", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -330,9 +330,7 @@ procedure Gnatbind is\n       then\n          Output_File_Name_Seen := True;\n \n-         if Argv'Length = 0\n-           or else (Argv'Length >= 1 and then Argv (1) = '-')\n-         then\n+         if Argv'Length = 0 or else Argv (1) = '-' then\n             Fail (\"output File_Name missing after -o\");\n \n          else"}, {"sha": "608f41fd748f2a2361210ee7a5775fa763931b76", "filename": "gcc/ada/init.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -2568,6 +2568,10 @@ __gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n \t\t   (__sigtramphandler_t *)&__gnat_map_signal);\n }\n \n+/* This must be in keeping with System.OS_Interface.Alternate_Stack_Size.  */\n+/* sigaltstack is currently not supported by QNX7 */\n+char __gnat_alternate_stack[0];\n+\n void\n __gnat_install_handler (void)\n {"}, {"sha": "14416cc7ab7cc98521f639698c680e86a6ccbc8b", "filename": "gcc/ada/libgnarl/s-osinte__qnx.ads", "status": "modified", "additions": 77, "deletions": 80, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnarl%2Fs-osinte__qnx.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnarl%2Fs-osinte__qnx.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-osinte__qnx.ads?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -141,7 +141,7 @@ package System.OS_Interface is\n       SIGKILL, SIGSTOP);\n       --  These two signals actually can't be masked (POSIX won't allow it)\n \n-   Reserved : constant Signal_Set := (SIGKILL, SIGSTOP, SIGSEGV);\n+   Reserved : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP, SIGSEGV);\n \n    type sigset_t is private;\n \n@@ -160,18 +160,18 @@ package System.OS_Interface is\n    function sigemptyset (set : access sigset_t) return int;\n    pragma Import (C, sigemptyset, \"sigemptyset\");\n \n-   type union_type_3 is new String (1 .. 116);\n+   type pad7 is array (1 .. 7) of int;\n    type siginfo_t is record\n       si_signo : int;\n       si_code  : int;\n       si_errno : int;\n-      X_data   : union_type_3;\n+      X_data   : pad7;\n    end record;\n    pragma Convention (C, siginfo_t);\n \n    type struct_sigaction is record\n       sa_handler  : System.Address;\n-      sa_flags    : Interfaces.C.int;\n+      sa_flags    : int;\n       sa_mask     : sigset_t;\n    end record;\n    pragma Convention (C, struct_sigaction);\n@@ -228,19 +228,13 @@ package System.OS_Interface is\n    function To_Timespec (D : Duration) return timespec;\n    pragma Inline (To_Timespec);\n \n-   function sysconf (name : int) return long;\n-   pragma Import (C, sysconf);\n-\n-   SC_CLK_TCK          : constant := 2;\n-   SC_NPROCESSORS_ONLN : constant := 84;\n-\n    -------------------------\n    -- Priority Scheduling --\n    -------------------------\n \n-   SCHED_OTHER : constant := 3;\n    SCHED_FIFO  : constant := 1;\n    SCHED_RR    : constant := 2;\n+   SCHED_OTHER : constant := 3;\n \n    function To_Target_Priority\n      (Prio : System.Any_Priority) return Interfaces.C.int\n@@ -270,12 +264,9 @@ package System.OS_Interface is\n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n \n-   type pthread_t is new unsigned_long;\n+   type pthread_t is new int;\n    subtype Thread_Id is pthread_t;\n \n-   function To_pthread_t is\n-     new Ada.Unchecked_Conversion (unsigned_long, pthread_t);\n-\n    type pthread_mutex_t      is limited private;\n    type pthread_cond_t       is limited private;\n    type pthread_attr_t       is limited private;\n@@ -285,8 +276,11 @@ package System.OS_Interface is\n \n    PTHREAD_CREATE_DETACHED : constant := 1;\n \n-   PTHREAD_SCOPE_PROCESS : constant := 4;\n-   PTHREAD_SCOPE_SYSTEM  : constant := 0;\n+   PTHREAD_SCOPE_PROCESS  : constant := 4;\n+   PTHREAD_SCOPE_SYSTEM   : constant := 0;\n+\n+   PTHREAD_INHERIT_SCHED  : constant := 0;\n+   PTHREAD_EXPLICIT_SCHED : constant := 2;\n \n    --  Read/Write lock not supported on Android.\n \n@@ -306,15 +300,16 @@ package System.OS_Interface is\n \n    function sigaltstack\n      (ss  : not null access stack_t;\n-      oss : access stack_t) return int;\n-   pragma Import (C, sigaltstack, \"sigaltstack\");\n+      oss : access stack_t) return int\n+   is (0);\n+   --  Not supported on QNX\n \n    Alternate_Stack : aliased System.Address;\n    --  Dummy definition: alternate stack not available due to missing\n-   --  sigaltstack\n+   --  sigaltstack in QNX\n \n    Alternate_Stack_Size : constant := 0;\n-   --  This must be in keeping with init.c:__gnat_alternate_stack\n+   --  This must be kept in sync with init.c:__gnat_alternate_stack\n \n    Stack_Base_Available : constant Boolean := False;\n    --  Indicates whether the stack base is available on this target\n@@ -327,10 +322,10 @@ package System.OS_Interface is\n    pragma Import (C, Get_Page_Size, \"getpagesize\");\n    --  Returns the size of a page\n \n-   PROT_NONE  : constant := 0;\n-   PROT_READ  : constant := 1;\n-   PROT_WRITE : constant := 2;\n-   PROT_EXEC  : constant := 4;\n+   PROT_NONE  : constant := 16#00_00#;\n+   PROT_READ  : constant := 16#01_00#;\n+   PROT_WRITE : constant := 16#02_00#;\n+   PROT_EXEC  : constant := 16#04_00#;\n    PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n    PROT_ON    : constant := PROT_READ;\n    PROT_OFF   : constant := PROT_ALL;\n@@ -358,10 +353,7 @@ package System.OS_Interface is\n      (how  : int;\n       set  : access sigset_t;\n       oset : access sigset_t) return int;\n-   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n-   --  pthread_sigmask maybe be broken due to mismatch between sigset_t and\n-   --  kernel_sigset_t, substitute sigprocmask temporarily.  ???\n-   --  pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n \n    --------------------------\n    -- POSIX.1c  Section 11 --\n@@ -389,6 +381,12 @@ package System.OS_Interface is\n    function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n    pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n \n+   function pthread_mutex_setprioceiling\n+     (mutex       : access pthread_mutex_t;\n+      prioceiling : int;\n+      old_ceiling : access int) return int;\n+   pragma Import (C, pthread_mutex_setprioceiling);\n+\n    function pthread_condattr_init\n      (attr : access pthread_condattr_t) return int;\n    pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n@@ -432,14 +430,36 @@ package System.OS_Interface is\n \n    function pthread_mutexattr_setprotocol\n      (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int is (0);\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_getprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : access int) return int;\n+   pragma Import (C, pthread_mutexattr_getprotocol);\n \n    function pthread_mutexattr_setprioceiling\n      (attr        : access pthread_mutexattr_t;\n-      prioceiling : int) return int is (0);\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   function pthread_mutexattr_getprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : access int) return int;\n+   pragma Import (C, pthread_mutexattr_getprioceiling);\n+\n+   function pthread_mutex_getprioceiling\n+     (attr        : access pthread_mutex_t;\n+      prioceiling : access int) return int;\n+   pragma Import (C, pthread_mutex_getprioceiling);\n+\n+   type pad8 is array (1 .. 8) of int;\n+   pragma Convention (C, pad8);\n \n    type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n+      sched_priority    : int := 0;  --  scheduling priority\n+      sched_curpriority : int := 0;\n+      reserved          : pad8 := (others => 0);\n    end record;\n    pragma Convention (C, struct_sched_param);\n \n@@ -449,6 +469,27 @@ package System.OS_Interface is\n       param  : access struct_sched_param) return int;\n    pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n \n+   function pthread_getschedparam\n+     (thread : pthread_t;\n+      policy : access int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_getschedparam, \"pthread_getschedparam\");\n+\n+   function pthread_setschedprio\n+     (thread   : pthread_t;\n+      priority : int) return int;\n+   pragma Import (C, pthread_setschedprio);\n+\n+   function pthread_attr_setschedparam\n+     (attr   : access pthread_attr_t;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_attr_setschedparam);\n+\n+   function pthread_attr_setinheritsched\n+     (attr         : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n    function pthread_attr_setscope\n      (attr  : access pthread_attr_t;\n       scope : int) return int;\n@@ -478,13 +519,12 @@ package System.OS_Interface is\n    function pthread_attr_setdetachstate\n      (attr        : access pthread_attr_t;\n       detachstate : int) return int;\n-   pragma Import\n-     (C, pthread_attr_setdetachstate, \"pthread_attr_setdetachstate\");\n+   pragma Import (C, pthread_attr_setdetachstate);\n \n    function pthread_attr_setstacksize\n      (attr      : access pthread_attr_t;\n       stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n+   pragma Import (C, pthread_attr_setstacksize);\n \n    function pthread_create\n      (thread        : access pthread_t;\n@@ -522,53 +562,10 @@ package System.OS_Interface is\n       destructor : destructor_pointer) return int;\n    pragma Import (C, pthread_key_create, \"pthread_key_create\");\n \n-   CPU_SETSIZE : constant := 1_024;\n-   --  Size of the cpu_set_t mask on most linux systems (SUSE 11 uses 4_096).\n-   --  This is kept for backward compatibility (System.Task_Info uses it), but\n-   --  the run-time library does no longer rely on static masks, using\n-   --  dynamically allocated masks instead.\n-\n-   type bit_field is array (1 .. CPU_SETSIZE) of Boolean;\n-   for bit_field'Size use CPU_SETSIZE;\n-   pragma Pack (bit_field);\n-   pragma Convention (C, bit_field);\n-\n-   type cpu_set_t is record\n-      bits : bit_field;\n-   end record;\n-   pragma Convention (C, cpu_set_t);\n-\n-   type cpu_set_t_ptr is access all cpu_set_t;\n-   --  In the run-time library we use this pointer because the size of type\n-   --  cpu_set_t varies depending on the glibc version. Hence, objects of type\n-   --  cpu_set_t are allocated dynamically using the number of processors\n-   --  available in the target machine (value obtained at execution time).\n-\n-   function CPU_ALLOC (count : size_t) return cpu_set_t_ptr;\n-   pragma Import (C, CPU_ALLOC, \"__gnat_cpu_alloc\");\n-   --  Wrapper around the CPU_ALLOC C macro\n-\n-   function CPU_ALLOC_SIZE (count : size_t) return size_t;\n-   pragma Import (C, CPU_ALLOC_SIZE, \"__gnat_cpu_alloc_size\");\n-   --  Wrapper around the CPU_ALLOC_SIZE C macro\n-\n-   procedure CPU_FREE (cpuset : cpu_set_t_ptr);\n-   pragma Import (C, CPU_FREE, \"__gnat_cpu_free\");\n-   --  Wrapper around the CPU_FREE C macro\n-\n-   procedure CPU_ZERO (count : size_t; cpuset : cpu_set_t_ptr);\n-   pragma Import (C, CPU_ZERO, \"__gnat_cpu_zero\");\n-   --  Wrapper around the CPU_ZERO_S C macro\n-\n-   procedure CPU_SET (cpu : int; count : size_t; cpuset : cpu_set_t_ptr);\n-   pragma Import (C, CPU_SET, \"__gnat_cpu_set\");\n-   --  Wrapper around the CPU_SET_S C macro\n-\n private\n \n-   type sigset_t is new Interfaces.C.unsigned_long;\n+   type sigset_t is array (1 .. 2) of Interfaces.Unsigned_32;\n    pragma Convention (C, sigset_t);\n-   for sigset_t'Alignment use Interfaces.C.unsigned_long'Alignment;\n \n    type pid_t is new int;\n \n@@ -615,6 +612,6 @@ private\n    pragma Convention (C, pthread_cond_t);\n    for pthread_cond_t'Alignment use unsigned_long_long_t'Alignment;\n \n-   type pthread_key_t is new unsigned;\n+   type pthread_key_t is new int;\n \n end System.OS_Interface;"}, {"sha": "8517bbe86ec718dad802b9af4a45d21ac6b54c0a", "filename": "gcc/ada/libgnarl/s-taprop__mingw.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnarl%2Fs-taprop__mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnarl%2Fs-taprop__mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__mingw.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -796,7 +796,17 @@ package body System.Task_Primitives.Operations is\n          raise Invalid_CPU_Number;\n       end if;\n \n-      Self_ID.Common.LL.Thread    := GetCurrentThread;\n+      --  Initialize the thread here only if not set. This is done for a\n+      --  foreign task but is not needed when a real thread-id is already\n+      --  set in Create_Task. Note that we do want to keep the real thread-id\n+      --  as it is the only way to free the associated resource. Another way\n+      --  to say this is that a pseudo thread-id from a foreign thread won't\n+      --  allow for freeing resources.\n+\n+      if Self_ID.Common.LL.Thread = Null_Thread_Id then\n+         Self_ID.Common.LL.Thread := GetCurrentThread;\n+      end if;\n+\n       Self_ID.Common.LL.Thread_Id := GetCurrentThreadId;\n \n       Get_Stack_Bounds"}, {"sha": "9689b676a1bebd30aee2e58bd8ab65277f54dbe9", "filename": "gcc/ada/libgnarl/s-taprop__qnx.adb", "status": "added", "additions": 1355, "deletions": 0, "changes": 1355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -0,0 +1,1355 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a POSIX-like version of this package\n+\n+--  This package contains all the GNULL primitives that interface directly with\n+--  the underlying OS.\n+\n+--  Note: this file can only be used for POSIX compliant systems that implement\n+--  SCHED_FIFO and Ceiling Locking correctly.\n+\n+--  For configurations where SCHED_FIFO and priority ceiling are not a\n+--  requirement, this file can also be used (e.g AiX threads)\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during tasking\n+--  operations. It causes infinite loops and other problems.\n+\n+with Ada.Unchecked_Conversion;\n+\n+with Interfaces.C;\n+\n+with System.Tasking.Debug;\n+with System.Interrupt_Management;\n+with System.OS_Constants;\n+with System.OS_Primitives;\n+with System.Task_Info;\n+\n+with System.Soft_Links;\n+--  We use System.Soft_Links instead of System.Tasking.Initialization\n+--  because the later is a higher level package that we shouldn't depend on.\n+--  For example when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Stages.\n+\n+package body System.Task_Primitives.Operations is\n+\n+   package OSC renames System.OS_Constants;\n+   package SSL renames System.Soft_Links;\n+\n+   use System.Tasking.Debug;\n+   use System.Tasking;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.Parameters;\n+   use System.OS_Primitives;\n+\n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task\n+\n+   Locking_Policy : Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+   --  Value of the pragma Locking_Policy:\n+   --    'C' for Ceiling_Locking\n+   --    'I' for Inherit_Locking\n+   --    ' ' for none.\n+\n+   Unblocked_Signal_Mask : aliased sigset_t;\n+   --  The set of signals that should unblocked in all tasks\n+\n+   --  The followings are internal configuration constants needed\n+\n+   Next_Serial_Number : Task_Serial_Number := 100;\n+   --  We start at 100, to reserve some special values for\n+   --  using in error checking.\n+\n+   Time_Slice_Val : Integer;\n+   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n+\n+   Dispatching_Policy : Character;\n+   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+\n+   Foreign_Task_Elaborated : aliased Boolean := True;\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n+\n+   Use_Alternate_Stack : constant Boolean := Alternate_Stack_Size /= 0;\n+   --  Whether to use an alternate signal stack for stack overflows\n+\n+   Abort_Handler_Installed : Boolean := False;\n+   --  True if a handler for the abort signal is installed\n+\n+   type RTS_Lock_Ptr is not null access all RTS_Lock;\n+\n+   function Init_Mutex (L : RTS_Lock_Ptr; Prio : Any_Priority) return int;\n+   --  Initialize the mutex L. If Ceiling_Support is True, then set the ceiling\n+   --  to Prio. Returns 0 for success, or ENOMEM for out-of-memory.\n+\n+   function Get_Policy (Prio : System.Any_Priority) return Character;\n+   pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n+   --  Get priority specific dispatching policy\n+\n+   --------------------\n+   -- Local Packages --\n+   --------------------\n+\n+   package Specific is\n+\n+      procedure Initialize (Environment_Task : Task_Id);\n+      pragma Inline (Initialize);\n+      --  Initialize various data needed by this package\n+\n+      function Is_Valid_Task return Boolean;\n+      pragma Inline (Is_Valid_Task);\n+      --  Does executing thread have a TCB?\n+\n+      procedure Set (Self_Id : Task_Id);\n+      pragma Inline (Set);\n+      --  Set the self id for the current task\n+\n+      function Self return Task_Id;\n+      pragma Inline (Self);\n+      --  Return a pointer to the Ada Task Control Block of the calling task\n+\n+   end Specific;\n+\n+   package body Specific is separate;\n+   --  The body of this package is target specific\n+\n+   package Monotonic is\n+\n+      function Monotonic_Clock return Duration;\n+      pragma Inline (Monotonic_Clock);\n+      --  Returns an absolute time, represented as an offset relative to some\n+      --  unspecified starting point, typically system boot time.  This clock\n+      --  is not affected by discontinuous jumps in the system time.\n+\n+      function RT_Resolution return Duration;\n+      pragma Inline (RT_Resolution);\n+      --  Returns resolution of the underlying clock used to implement RT_Clock\n+\n+      procedure Timed_Sleep\n+        (Self_ID  : ST.Task_Id;\n+         Time     : Duration;\n+         Mode     : ST.Delay_Modes;\n+         Reason   : System.Tasking.Task_States;\n+         Timedout : out Boolean;\n+         Yielded  : out Boolean);\n+      --  Combination of Sleep (above) and Timed_Delay\n+\n+      procedure Timed_Delay\n+        (Self_ID : ST.Task_Id;\n+         Time    : Duration;\n+         Mode    : ST.Delay_Modes);\n+      --  Implement the semantics of the delay statement.\n+      --  The caller should be abort-deferred and should not hold any locks.\n+\n+   end Monotonic;\n+\n+   package body Monotonic is separate;\n+\n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n+   ---------------------------------\n+   -- Support for foreign threads --\n+   ---------------------------------\n+\n+   function Register_Foreign_Thread\n+     (Thread         : Thread_Id;\n+      Sec_Stack_Size : Size_Type := Unspecified_Size) return Task_Id;\n+   --  Allocate and initialize a new ATCB for the current Thread. The size of\n+   --  the secondary stack can be optionally specified.\n+\n+   function Register_Foreign_Thread\n+     (Thread         : Thread_Id;\n+      Sec_Stack_Size : Size_Type := Unspecified_Size)\n+     return Task_Id is separate;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Abort_Handler (Sig : Signal);\n+   --  Signal handler used to implement asynchronous abort.\n+   --  See also comment before body, below.\n+\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n+\n+   function GNAT_pthread_condattr_setup\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C,\n+     GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n+\n+   -------------------\n+   -- Abort_Handler --\n+   -------------------\n+\n+   --  Target-dependent binding of inter-thread Abort signal to the raising of\n+   --  the Abort_Signal exception.\n+\n+   --  The technical issues and alternatives here are essentially the\n+   --  same as for raising exceptions in response to other signals\n+   --  (e.g. Storage_Error). See code and comments in the package body\n+   --  System.Interrupt_Management.\n+\n+   --  Some implementations may not allow an exception to be propagated out of\n+   --  a handler, and others might leave the signal or interrupt that invoked\n+   --  this handler masked after the exceptional return to the application\n+   --  code.\n+\n+   --  GNAT exceptions are originally implemented using setjmp()/longjmp(). On\n+   --  most UNIX systems, this will allow transfer out of a signal handler,\n+   --  which is usually the only mechanism available for implementing\n+   --  asynchronous handlers of this kind. However, some systems do not\n+   --  restore the signal mask on longjmp(), leaving the abort signal masked.\n+\n+   procedure Abort_Handler (Sig : Signal) is\n+      pragma Unreferenced (Sig);\n+\n+      T       : constant Task_Id := Self;\n+      Old_Set : aliased sigset_t;\n+\n+      Result : Interfaces.C.int;\n+      pragma Warnings (Off, Result);\n+\n+   begin\n+      --  It's not safe to raise an exception when using GCC ZCX mechanism.\n+      --  Note that we still need to install a signal handler, since in some\n+      --  cases (e.g. shutdown of the Server_Task in System.Interrupts) we\n+      --  need to send the Abort signal to a task.\n+\n+      if ZCX_By_Default then\n+         return;\n+      end if;\n+\n+      if T.Deferral_Level = 0\n+        and then T.Pending_ATC_Level < T.ATC_Nesting_Level and then\n+        not T.Aborting\n+      then\n+         T.Aborting := True;\n+\n+         --  Make sure signals used for RTS internal purpose are unmasked\n+\n+         Result := pthread_sigmask (SIG_UNBLOCK,\n+           Unblocked_Signal_Mask'Access, Old_Set'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Standard'Abort_Signal;\n+      end if;\n+   end Abort_Handler;\n+\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n+\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n+      Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n+      Page_Size  : Address;\n+      Res        : Interfaces.C.int;\n+\n+   begin\n+      if Stack_Base_Available then\n+\n+         --  Compute the guard page address\n+\n+         Page_Size := Address (Get_Page_Size);\n+         Res :=\n+           mprotect\n+             (Stack_Base - (Stack_Base mod Page_Size) + Page_Size,\n+              size_t (Page_Size),\n+              prot => (if On then PROT_ON else PROT_OFF));\n+         pragma Assert (Res = 0);\n+      end if;\n+   end Stack_Guard;\n+\n+   --------------------\n+   -- Get_Thread_Id  --\n+   --------------------\n+\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_Id renames Specific.Self;\n+\n+   ----------------\n+   -- Init_Mutex --\n+   ----------------\n+\n+   function Init_Mutex (L : RTS_Lock_Ptr; Prio : Any_Priority) return int\n+   is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : int;\n+      Result_2   : aliased int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         return Result;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_mutexattr_getprotocol\n+           (Attributes'Access, Result_2'Access);\n+         if Result_2 /= PTHREAD_PRIO_PROTECT then\n+            raise Program_Error with \"setprotocol failed\";\n+         end if;\n+\n+         Result := pthread_mutexattr_setprioceiling\n+            (Attributes'Access, To_Target_Priority (Prio));\n+         pragma Assert (Result = 0);\n+\n+      elsif Locking_Policy = 'I' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      Result_2 := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result_2 = 0);\n+\n+      return Result;\n+   end Init_Mutex;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore raising Storage_Error in the following\n+   --  routines should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : not null access Lock)\n+   is\n+   begin\n+      if Init_Mutex (L.WO'Access, Prio) = ENOMEM then\n+         raise Storage_Error with \"Failed to allocate a lock\";\n+      end if;\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock\n+     (L : not null access RTS_Lock; Level : Lock_Level)\n+   is\n+      pragma Unreferenced (Level);\n+\n+   begin\n+      if Init_Mutex (L.all'Access, Any_Priority'Last) = ENOMEM then\n+         raise Storage_Error with \"Failed to allocate a lock\";\n+      end if;\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : not null access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L.WO'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : not null access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+   is\n+      Self    : constant pthread_t := pthread_self;\n+      Result  : int;\n+      Policy  : aliased int;\n+      Ceiling : aliased int;\n+      Sched   : aliased struct_sched_param;\n+\n+   begin\n+      Result := pthread_mutex_lock (L.WO'Access);\n+\n+      --  The cause of EINVAL is a priority ceiling violation\n+\n+      Ceiling_Violation := Result = EINVAL;\n+      pragma Assert (Result = 0 or else Ceiling_Violation);\n+\n+      --  Workaround bug in QNX on ceiling locks: tasks with priority higher\n+      --  than the ceiling priority don't receive EINVAL upon trying to lock.\n+      if Result = 0 then\n+         Result := pthread_getschedparam (Self, Policy'Access, Sched'Access);\n+         pragma Assert (Result = 0);\n+         Result := pthread_mutex_getprioceiling (L.WO'Access, Ceiling'Access);\n+         pragma Assert (Result = 0);\n+\n+         --  Ceiling = 0 means no Ceiling Priority policy is set on this mutex\n+         --  Else, Ceiling < current priority means Ceiling violation\n+         --  (otherwise the current priority == ceiling)\n+         if Ceiling > 0 and then Ceiling < Sched.sched_curpriority then\n+            Ceiling_Violation := True;\n+            Result := pthread_mutex_unlock (L.WO'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+      end if;\n+   end Write_Lock;\n+\n+   procedure Write_Lock\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : not null access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (L.WO'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock\n+     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Unlock;\n+\n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_setprioceiling\n+        (L.WO'Access, To_Target_Priority (Prio), null);\n+      pragma Assert (Result = 0);\n+   end Set_Ceiling;\n+\n+   -----------\n+   -- Sleep --\n+   -----------\n+\n+   procedure Sleep\n+     (Self_ID : Task_Id;\n+      Reason  : System.Tasking.Task_States)\n+   is\n+      pragma Unreferenced (Reason);\n+\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n+\n+      --  EINTR is not considered a failure\n+\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_Id;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean) renames Monotonic.Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so we assume the\n+   --  caller is abort-deferred but is holding no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID : Task_Id;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes) renames Monotonic.Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration renames Monotonic.Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration renames Monotonic.RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n+      pragma Unreferenced (Reason);\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+      Result : Interfaces.C.int;\n+      pragma Unreferenced (Result);\n+   begin\n+      if Do_Yield then\n+         Result := sched_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   procedure Set_Priority\n+     (T                   : Task_Id;\n+      Prio                : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      pragma Unreferenced (Loss_Of_Inheritance);\n+      Result : Interfaces.C.int;\n+      Old    : constant System.Any_Priority := T.Common.Current_Priority;\n+\n+   begin\n+      T.Common.Current_Priority := Prio;\n+      Result := pthread_setschedprio\n+        (T.Common.LL.Thread, To_Target_Priority (Prio));\n+      pragma Assert (Result = 0);\n+\n+      if T.Common.LL.Thread = Pthread_Self\n+        and then Old > Prio\n+      then\n+         --  When lowering the priority via a pthread_setschedprio, QNX ensures\n+         --  that the running thread remains in the head of the FIFO for tne\n+         --  new priority. Annex D expects the thread to be requeued so let's\n+         --  yield to the other threads of the same priority.\n+         Result := sched_yield;\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_Id) is\n+   begin\n+      Self_ID.Common.LL.Thread := pthread_self;\n+      Self_ID.Common.LL.LWP := lwp_self;\n+\n+      Specific.Set (Self_ID);\n+\n+      if Use_Alternate_Stack then\n+         declare\n+            Stack  : aliased stack_t;\n+            Result : Interfaces.C.int;\n+         begin\n+            Stack.ss_sp    := Self_ID.Common.Task_Alternate_Stack;\n+            Stack.ss_size  := Alternate_Stack_Size;\n+            Stack.ss_flags := 0;\n+            Result := sigaltstack (Stack'Access, null);\n+            pragma Assert (Result = 0);\n+         end;\n+      end if;\n+   end Enter_Task;\n+\n+   -------------------\n+   -- Is_Valid_Task --\n+   -------------------\n+\n+   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;\n+\n+   -----------------------------\n+   -- Register_Foreign_Thread --\n+   -----------------------------\n+\n+   function Register_Foreign_Thread return Task_Id is\n+   begin\n+      if Is_Valid_Task then\n+         return Self;\n+      else\n+         return Register_Foreign_Thread (pthread_self);\n+      end if;\n+   end Register_Foreign_Thread;\n+\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean)\n+   is\n+      Result     : Interfaces.C.int;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+\n+   begin\n+      --  Give the task a unique serial number\n+\n+      Self_ID.Serial_Number := Next_Serial_Number;\n+      Next_Serial_Number := Next_Serial_Number + 1;\n+      pragma Assert (Next_Serial_Number /= 0);\n+\n+      if not Single_Lock then\n+         Result := Init_Mutex (Self_ID.Common.LL.L'Access, Any_Priority'Last);\n+         pragma Assert (Result = 0);\n+\n+         if Result /= 0 then\n+            Succeeded := False;\n+            return;\n+         end if;\n+      end if;\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_Id;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      Attributes               : aliased pthread_attr_t;\n+      Adjusted_Stack_Size      : Interfaces.C.size_t;\n+      Page_Size                : constant Interfaces.C.size_t :=\n+                                   Interfaces.C.size_t (Get_Page_Size);\n+      Sched_Param              : aliased struct_sched_param;\n+      Result                   : Interfaces.C.int;\n+\n+      Priority_Specific_Policy : constant Character := Get_Policy (Priority);\n+      --  Upper case first character of the policy name corresponding to the\n+      --  task as set by a Priority_Specific_Dispatching pragma.\n+\n+      function Thread_Body_Access is new\n+        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+\n+   begin\n+      Adjusted_Stack_Size :=\n+         Interfaces.C.size_t (Stack_Size + Alternate_Stack_Size);\n+\n+      if Stack_Base_Available then\n+\n+         --  If Stack Checking is supported then allocate 2 additional pages:\n+\n+         --  In the worst case, stack is allocated at something like\n+         --  N * Get_Page_Size - epsilon, we need to add the size for 2 pages\n+         --  to be sure the effective stack size is greater than what\n+         --  has been asked.\n+\n+         Adjusted_Stack_Size := Adjusted_Stack_Size + 2 * Page_Size;\n+      end if;\n+\n+      --  Round stack size as this is required by some OSes (Darwin)\n+\n+      Adjusted_Stack_Size := Adjusted_Stack_Size + Page_Size - 1;\n+      Adjusted_Stack_Size :=\n+        Adjusted_Stack_Size - Adjusted_Stack_Size mod Page_Size;\n+\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result :=\n+        pthread_attr_setdetachstate\n+          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      pragma Assert (Result = 0);\n+\n+      Result :=\n+        pthread_attr_setstacksize\n+          (Attributes'Access, Adjusted_Stack_Size);\n+      pragma Assert (Result = 0);\n+\n+      --  Set thread priority\n+      T.Common.Current_Priority := Priority;\n+      Sched_Param.sched_priority := To_Target_Priority (Priority);\n+\n+      Result := pthread_attr_setinheritsched\n+        (Attributes'Access, PTHREAD_EXPLICIT_SCHED);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_attr_setschedparam\n+        (Attributes'Access, Sched_Param'Access);\n+      pragma Assert (Result = 0);\n+\n+      if Time_Slice_Supported\n+        and then (Dispatching_Policy = 'R'\n+                  or else Priority_Specific_Policy = 'R'\n+                  or else Time_Slice_Val > 0)\n+      then\n+         Result := pthread_attr_setschedpolicy\n+           (Attributes'Access, SCHED_RR);\n+\n+      elsif Dispatching_Policy = 'F'\n+        or else Priority_Specific_Policy = 'F'\n+        or else Time_Slice_Val = 0\n+      then\n+         Result := pthread_attr_setschedpolicy\n+           (Attributes'Access, SCHED_FIFO);\n+\n+      else\n+         Result := pthread_attr_setschedpolicy\n+           (Attributes'Access, SCHED_OTHER);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      --  Note: the use of Unrestricted_Access in the following call is needed\n+      --  because otherwise we have an error of getting a access-to-volatile\n+      --  value which points to a non-volatile object. But in this case it is\n+      --  safe to do this, since we know we have no problems with aliasing and\n+      --  Unrestricted_Access bypasses this check.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Unrestricted_Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+\n+      ATCB_Allocation.Free_ATCB (T);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      --  Mark this task as unknown, so that if Self is called, it won't\n+      --  return a dangling pointer.\n+\n+      Specific.Set (null);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if Abort_Handler_Installed then\n+         Result :=\n+           pthread_kill\n+             (T.Common.LL.Thread,\n+              Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      --  Initialize internal state (always to False (RM D.10 (6)))\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         --  Storage_Error is propagated as intended if the allocation of the\n+         --  underlying OS entities fails.\n+\n+         raise Storage_Error;\n+\n+      else\n+         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_condattr_destroy (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         --  Storage_Error is propagated as intended if the allocation of the\n+         --  underlying OS entities fails.\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      SSL.Abort_Undefer.all;\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in (RM D.10(9)). Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      SSL.Abort_Undefer.all;\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (RM D.10(10)).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         SSL.Abort_Undefer.all;\n+\n+         raise Program_Error;\n+\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+\n+            loop\n+               --  Loop in case pthread_cond_wait returns earlier than expected\n+               --  (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n+         end if;\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         SSL.Abort_Undefer.all;\n+      end if;\n+   end Suspend_Until_True;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy version\n+\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (Self_ID);\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (Self_ID);\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_Id is\n+   begin\n+      return Environment_Task_Id;\n+   end Environment_Task;\n+\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n+\n+   procedure Lock_RTS is\n+   begin\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n+\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n+\n+   procedure Unlock_RTS is\n+   begin\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_Id;\n+      Thread_Self : Thread_Id) return Boolean\n+   is\n+      pragma Unreferenced (T, Thread_Self);\n+   begin\n+      return False;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_Id;\n+      Thread_Self : Thread_Id) return Boolean\n+   is\n+      pragma Unreferenced (T, Thread_Self);\n+   begin\n+      return False;\n+   end Resume_Task;\n+\n+   --------------------\n+   -- Stop_All_Tasks --\n+   --------------------\n+\n+   procedure Stop_All_Tasks is\n+   begin\n+      null;\n+   end Stop_All_Tasks;\n+\n+   ---------------\n+   -- Stop_Task --\n+   ---------------\n+\n+   function Stop_Task (T : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (T);\n+   begin\n+      return False;\n+   end Stop_Task;\n+\n+   -------------------\n+   -- Continue_Task --\n+   -------------------\n+\n+   function Continue_Task (T : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (T);\n+   begin\n+      return False;\n+   end Continue_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_Id) is\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Tmp_Set : aliased sigset_t;\n+      Result  : Interfaces.C.int;\n+\n+      function State\n+        (Int : System.Interrupt_Management.Interrupt_ID) return Character;\n+      pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+      --  Get interrupt state.  Defined in a-init.c\n+      --  The input argument is the interrupt number,\n+      --  and the result is one of the following:\n+\n+      Default : constant Character := 's';\n+      --    'n'   this interrupt not set by any Interrupt_State pragma\n+      --    'u'   Interrupt_State pragma set state to User\n+      --    'r'   Interrupt_State pragma set state to Runtime\n+      --    's'   Interrupt_State pragma set state to System (use \"default\"\n+      --           system handler)\n+\n+   begin\n+      Environment_Task_Id := Environment_Task;\n+\n+      Interrupt_Management.Initialize;\n+\n+      --  Prepare the set of signals that should unblocked in all tasks\n+\n+      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      for J in Interrupt_Management.Interrupt_ID loop\n+         if System.Interrupt_Management.Keep_Unmasked (J) then\n+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      --  Initialize the lock used to synchronize chain of all ATCBs\n+\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n+\n+      Specific.Initialize (Environment_Task);\n+\n+      if Use_Alternate_Stack then\n+         Environment_Task.Common.Task_Alternate_Stack :=\n+           Alternate_Stack'Address;\n+      end if;\n+\n+      --  Make environment task known here because it doesn't go through\n+      --  Activate_Tasks, which does it for all other tasks.\n+\n+      Known_Tasks (Known_Tasks'First) := Environment_Task;\n+      Environment_Task.Known_Tasks_Index := Known_Tasks'First;\n+\n+      Enter_Task (Environment_Task);\n+\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n+      then\n+         act.sa_flags := 0;\n+         act.sa_handler := Abort_Handler'Address;\n+\n+         Result := sigemptyset (Tmp_Set'Access);\n+         pragma Assert (Result = 0);\n+         act.sa_mask := Tmp_Set;\n+\n+         Result :=\n+           sigaction\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n+         pragma Assert (Result = 0);\n+         Abort_Handler_Installed := True;\n+      end if;\n+   end Initialize;\n+\n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n+\n+end System.Task_Primitives.Operations;"}, {"sha": "4cb1c1be0910a5708a94cc64b0ef205f15ce75f3", "filename": "gcc/ada/libgnat/system-qnx-aarch64.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -95,20 +95,22 @@ package System is\n \n    --  Priority-related Declarations (RM D.1)\n \n+   --  System priority is Ada priority + 1, so lies in the range 1 .. 63.\n+   --\n    --  If the scheduling policy is SCHED_FIFO or SCHED_RR the runtime makes use\n    --  of the entire range provided by the system.\n    --\n    --  If the scheduling policy is SCHED_OTHER the only valid system priority\n    --  is 1 and other values are simply ignored.\n \n-   Max_Priority           : constant Positive := 62;\n-   Max_Interrupt_Priority : constant Positive := 63;\n+   Max_Priority           : constant Positive := 61;\n+   Max_Interrupt_Priority : constant Positive := 62;\n \n-   subtype Any_Priority       is Integer      range  0 .. 63;\n-   subtype Priority           is Any_Priority range  0 .. 62;\n-   subtype Interrupt_Priority is Any_Priority range 63 .. 63;\n+   subtype Any_Priority       is Integer      range  0 .. 62;\n+   subtype Priority           is Any_Priority range  0 .. 61;\n+   subtype Interrupt_Priority is Any_Priority range 62 .. 62;\n \n-   Default_Priority : constant Priority := 31;\n+   Default_Priority : constant Priority := 30;\n \n private\n "}, {"sha": "99fa000e73bfda5310b5095767189de65eb0d256", "filename": "gcc/ada/link.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -105,6 +105,7 @@ const char *__gnat_default_libgcc_subdir = \"lib\";\n \n #elif defined (__FreeBSD__) || defined (__DragonFly__) \\\n    || defined (__NetBSD__) || defined (__OpenBSD__)\n+   || defined (__QNX__)\n const char *__gnat_object_file_option = \"-Wl,@\";\n const char *__gnat_run_path_option = \"-Wl,-rpath,\";\n char __gnat_shared_libgnat_default = STATIC;"}, {"sha": "153c79b33c5598b34e7a2de9870a207d08918be4", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -258,7 +258,13 @@ package body Namet is\n                   --  simply use their normal representation.\n \n                else\n-                  Insert_Character (Character'Val (Hex (2)));\n+                  declare\n+                     W2 : constant Word := Hex (2);\n+                  begin\n+                     pragma Assume (W2 <= 255);\n+                     --  Add assumption to facilitate static analysis\n+                     Insert_Character (Character'Val (W2));\n+                  end;\n                end if;\n \n             --  WW (wide wide character insertion)\n@@ -753,6 +759,9 @@ package body Namet is\n \n       Write_Eol;\n       Write_Str (\"Average number of probes for lookup = \");\n+      pragma Assume (Nsyms /= 0);\n+      --  Add assumption to facilitate static analysis. Here Nsyms cannot be\n+      --  zero because many symbols are added to the table by default.\n       Probes := Probes / Nsyms;\n       Write_Int (Probes / 200);\n       Write_Char ('.');"}, {"sha": "72bd856e9334640f4ded096262ad96a4bdced3d3", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -2877,7 +2877,14 @@ package body Sem_Aggr is\n    -- Resolve_Delta_Record_Aggregate --\n    ------------------------------------\n \n-   procedure Resolve_Delta_Record_Aggregate (N   : Node_Id; Typ : Entity_Id) is\n+   procedure Resolve_Delta_Record_Aggregate (N : Node_Id; Typ : Entity_Id) is\n+\n+      --  Variables used to verify that discriminant-dependent components\n+      --  appear in the same variant.\n+\n+      Comp_Ref : Entity_Id;\n+      Variant  : Node_Id;\n+\n       procedure Check_Variant (Id : Entity_Id);\n       --  If a given component of the delta aggregate appears in a variant\n       --  part, verify that it is within the same variant as that of previous\n@@ -2900,17 +2907,13 @@ package body Sem_Aggr is\n \n       procedure Check_Variant (Id : Entity_Id) is\n          Comp         : Entity_Id;\n-         Comp_Ref     : Entity_Id;\n          Comp_Variant : Node_Id;\n-         Variant      : Node_Id;\n \n       begin\n          if not Has_Discriminants (Typ) then\n             return;\n          end if;\n \n-         Variant := Empty;\n-\n          Comp := First_Entity (Typ);\n          while Present (Comp) loop\n             exit when Chars (Comp) = Chars (Id);\n@@ -3027,6 +3030,8 @@ package body Sem_Aggr is\n    --  Start of processing for Resolve_Delta_Record_Aggregate\n \n    begin\n+      Variant := Empty;\n+\n       Assoc := First (Deltas);\n       while Present (Assoc) loop\n          Choice := First (Choice_List (Assoc));"}, {"sha": "cc4e39c50d87145e6f495ee29786a1235c80ee51", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -231,10 +231,10 @@ package body Sem_Attr is\n       E1      : Node_Id;\n       E2      : Node_Id;\n \n-      P_Type : Entity_Id;\n+      P_Type : Entity_Id := Empty;\n       --  Type of prefix after analysis\n \n-      P_Base_Type : Entity_Id;\n+      P_Base_Type : Entity_Id := Empty;\n       --  Base type of prefix after analysis\n \n       -----------------------\n@@ -419,7 +419,7 @@ package body Sem_Attr is\n       --  required error messages.\n \n       procedure Error_Attr_P (Msg : String);\n-      pragma No_Return (Error_Attr);\n+      pragma No_Return (Error_Attr_P);\n       --  Like Error_Attr, but error is posted at the start of the prefix\n \n       procedure Legal_Formal_Attribute;\n@@ -446,7 +446,9 @@ package body Sem_Attr is\n       --  node in the aspect case).\n \n       procedure Unexpected_Argument (En : Node_Id);\n-      --  Signal unexpected attribute argument (En is the argument)\n+      pragma No_Return (Unexpected_Argument);\n+      --  Signal unexpected attribute argument (En is the argument), and then\n+      --  raises Bad_Attribute to avoid any further semantic processing.\n \n       procedure Validate_Non_Static_Attribute_Function_Call;\n       --  Called when processing an attribute that is a function call to a\n@@ -1108,8 +1110,10 @@ package body Sem_Attr is\n          --  node Nod is within enclosing node Encl_Nod.\n \n          procedure Placement_Error;\n+         pragma No_Return (Placement_Error);\n          --  Emit a general error when the attributes does not appear in a\n-         --  postcondition-like aspect or pragma.\n+         --  postcondition-like aspect or pragma, and then raises Bad_Attribute\n+         --  to avoid any further semantic processing.\n \n          ------------------------------\n          -- Check_Placement_In_Check --"}, {"sha": "81297610ea26422ca696e7ba99111fcdef731708", "filename": "gcc/ada/set_targ.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -604,6 +604,10 @@ package body Set_Targ is\n       procedure Check_Spaces is\n       begin\n          if N > Buflen or else Buffer (N) /= ' ' then\n+            pragma Annotate\n+              (CodePeer, False_Positive, \"condition predetermined\",\n+               \"N may be less than Buflen when calling Check_Spaces\");\n+\n             FailN (\"missing space for\");\n          end if;\n "}, {"sha": "e851a2466b81ff22f39987ce9b09c9f3ebdf1570", "filename": "gcc/ada/stylesw.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fstylesw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec54569383fc11ffdb560aae6a7868be5525d19/gcc%2Fada%2Fstylesw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.adb?ref=3ec54569383fc11ffdb560aae6a7868be5525d19", "patch": "@@ -161,7 +161,8 @@ package body Stylesw is\n       if Style_Check_Comments then\n          if Style_Check_Comments_Spacing = 2 then\n             Add ('c', Style_Check_Comments);\n-         elsif Style_Check_Comments_Spacing = 1 then\n+         else\n+            pragma Assert (Style_Check_Comments_Spacing = 1);\n             Add ('C', Style_Check_Comments);\n          end if;\n       end if;"}]}