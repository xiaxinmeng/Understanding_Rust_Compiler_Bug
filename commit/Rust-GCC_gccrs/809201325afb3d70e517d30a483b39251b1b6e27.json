{"sha": "809201325afb3d70e517d30a483b39251b1b6e27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5MjAxMzI1YWZiM2Q3MGU1MTdkMzBhNDgzYjM5MjUxYjFiNmUyNw==", "commit": {"author": {"name": "Michael Eager", "email": "eager@gcc.gnu.org", "date": "2010-09-30T18:21:57Z"}, "committer": {"name": "Michael Eager", "email": "eager@gcc.gnu.org", "date": "2010-09-30T18:21:57Z"}, "message": "Check in support for Xilinx MicroBlaze processor.\n\nFrom-SVN: r164756", "tree": {"sha": "3e6ddc920dca714da86387abe482505839030906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e6ddc920dca714da86387abe482505839030906"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/809201325afb3d70e517d30a483b39251b1b6e27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809201325afb3d70e517d30a483b39251b1b6e27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809201325afb3d70e517d30a483b39251b1b6e27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809201325afb3d70e517d30a483b39251b1b6e27/comments", "author": null, "committer": null, "parents": [{"sha": "51be162e8ebb3b173c7f93c7719a7bc6192cbc42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51be162e8ebb3b173c7f93c7719a7bc6192cbc42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51be162e8ebb3b173c7f93c7719a7bc6192cbc42"}], "stats": {"total": 9143, "additions": 9137, "deletions": 6}, "files": [{"sha": "189496bb95cde668a174105abc19cc6533a1e54c", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -1,3 +1,8 @@\n+2010-09-30  Michael Eager  <eager@eagercon.com>\n+\n+\t* configure.ac (microblaze): Add target-libssp to noconfigdirs.\n+\t* configure: Regenerate.\n+\n 2010-09-28  Michael Eager  <eager@eagercon.com>\n \n \t* MAINTAINERS (CPU Port Maintainers): Add myself for MicroBlaze port."}, {"sha": "3a512490d61bdb61cddbdf61137a891cd976c106", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -3650,7 +3650,7 @@ case \"${target}\" in\n     noconfigdirs=\"$noconfigdirs ld binutils gprof target-libgloss ${libgcj}\"\n     ;;\n   microblaze*)\n-    noconfigdirs=\"$noconfigdirs gprof ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs gprof target-libssp ${libgcj}\"\n     ;;\n   mips*-sde-elf*)\n     skipdirs=\"$skipdirs target-libiberty\""}, {"sha": "6ef9df672612724b981619d04b457d6ddc8eb992", "filename": "configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -887,7 +887,7 @@ case \"${target}\" in\n     noconfigdirs=\"$noconfigdirs ld binutils gprof target-libgloss ${libgcj}\"\n     ;;\n   microblaze*)\n-    noconfigdirs=\"$noconfigdirs gprof ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs gprof target-libssp ${libgcj}\"\n     ;;\n   mips*-sde-elf*)\n     skipdirs=\"$skipdirs target-libiberty\""}, {"sha": "a196f7da6205eebfb249d8e34883152158f6f572", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -1,3 +1,27 @@\n+2010-09-30  Michael Eager  <eager@eagercon.com>\n+\n+\t* extend.texi (interrupt_handler): Add MicroBlaze to list.\n+\t(save_volatiles): Describe option for MicroBlaze.\n+\t* invoke.texi: Add MicroBlaze Options.\n+\t* contrib.texi: Add acknowledgment. \n+\t* md.texi: Add MicroBlaze d and z constraints.\n+\t* install.texi: Add microblaze-*-elf.\n+\t* configure.ac: Add microblaze-*-* to target list.\n+\t* configure: Regenerate.\n+\t* config.gcc: Add microblaze*-*-*, microblaze*-linux*.\n+\t* config/microblaze/microblaze-protos.h: New.\n+\t* config/microblaze/crti.s: New.\n+\t* config/microblaze/predicates.md: New.\n+\t* config/microblaze/linux.h: New.\n+\t* config/microblaze/microblaze.md: New.\n+\t* config/microblaze/constraints.md: New.\n+\t* config/microblaze/crtn.s: New.\n+\t* config/microblaze/microblaze.opt: New.\n+\t* config/microblaze/microblaze-c.c: New.\n+\t* config/microblaze/t-microblaze: New.\n+\t* config/microblaze/microblaze.c: New.\n+\t* config/microblaze/microblaze.h: New.\n+\n 2010-09-30  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* c-parser.c (c_parser_objc_methodprotolist): Amend preceding comment,\n@@ -905,6 +929,7 @@\n \tunconditionally if TODO_rebuild_alias is set, else only when optimizing\n \tif TODO_update_address_taken is set.\n \n+>>>>>>> .r164755\n 2010-09-23  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/arm/arm.h (OUTPUT_ADDR_CONST_EXTRA): Remove."}, {"sha": "3eb7ff673550d143827ea6bc0cdfd68fe569d15b", "filename": "gcc/config.gcc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -350,6 +350,10 @@ m32r*-*-*)\n m68k-*-*)\n \textra_headers=math-68881.h\n \t;;\n+microblaze*-*-*)\n+        cpu_type=microblaze\n+\textra_options=\"${extra_options} g.opt\"\n+        ;;\n mips*-*-*)\n \tcpu_type=mips\n \tneed_64bit_hwint=yes\n@@ -1757,6 +1761,19 @@ mep-*-*)\n \tfi\n \tuse_gcc_stdint=wrap\n \t;;\n+microblaze*-linux*)\n+\ttm_file=\"${tm_file} dbxelf.h linux.h microblaze/linux.h\"\n+\tc_target_objs=\"${c_target_objs} microblaze-c.o\"\n+\tcxx_target_objs=\"${cxx_target_objs} microblaze-c.o\"\n+\ttmake_file=\"${tmake_file} t-slibgcc-elf-ver t-slibgcc-nolc-override t-linux microblaze/t-microblaze\"\n+        extra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o crtbeginT.o\"\n+\t;;\n+microblaze*-*-*)\n+        tm_file=\"${tm_file} dbxelf.h\"\n+\tc_target_objs=\"${c_target_objs} microblaze-c.o\"\n+\tcxx_target_objs=\"${cxx_target_objs} microblaze-c.o\"\n+        tmake_file=\"${tmake_file} microblaze/t-microblaze\"\n+        ;;\n mips-sgi-irix6.5*)\n \ttm_file=\"elfos.h ${tm_file} mips/iris6.h\"\n \ttmake_file=\"mips/t-iris mips/t-iris6 mips/t-slibgcc-irix\""}, {"sha": "2abe30190167e43736475db3c780fe2e9f1a6be8", "filename": "gcc/config/microblaze/constraints.md", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fconstraints.md?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,72 @@\n+;; Constraint definitions for Xilinx MicroBlaze processors.\n+;; Copyright 2010 Free Software Foundation, Inc.\n+\n+;; Contributed by Michael Eager <eager@eagercon.com>.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>. \n+\n+(define_register_constraint \"d\" \"GR_REGS\"\n+  \"A general register.\")\n+\n+(define_register_constraint \"z\" \"ST_REGS\"\n+  \"A status register.\")\n+\n+;; Define integer constraints\n+\n+(define_constraint \"I\"\n+  \"A signed 16-bit constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_OPERAND (ival)\")))\n+\n+(define_constraint \"J\"\n+  \"Integer zero.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"M\"\n+  \"A constant which needs two instructions to load.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"LARGE_OPERAND (ival)\")))\n+\n+(define_constraint \"N\"\n+  \"A constant in the range -65535 to -1 (inclusive).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT) (ival + 0xffff) < 0xffff\")))\n+\n+(define_constraint \"P\"\n+  \"A constant in the range 1 to 65535 (inclusive).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival > 0 && ival < 0x10000\")))\n+\n+;; Define floating point constraints\n+\n+(define_constraint \"G\"\n+  \"Floating-point zero.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Define memory constraints\n+\n+(define_memory_constraint \"R\"\n+  \"Memory operand which fits in single instruction.\"\n+  (and (match_code \"mem\")\n+       (match_test \"simple_memory_operand (op, GET_MODE (op))\")))\n+\n+(define_memory_constraint \"T\"\n+  \"Double word operand.\"\n+  (and (match_code \"mem\")\n+       (match_test \"double_memory_operand (op, GET_MODE (op))\")))"}, {"sha": "3944443b437d0a72281a196b19cfc0426dd6189e", "filename": "gcc/config/microblaze/crti.s", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fcrti.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fcrti.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fcrti.s?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,39 @@\n+/* crti.s for __init, __fini\n+   This file supplies the prologue for __init and __fini routines \n+\n+   Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+   Contributed by Michael Eager <eager@eagercon.com>.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+ \n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+    .section .init, \"ax\"\n+    .global __init\n+    .align 2\n+__init: \n+    addik   r1, r1, -8\n+    sw      r15, r0, r1\n+\n+    .section .fini, \"ax\"\n+    .global __fini\n+    .align 2\n+__fini: \n+    addik   r1, r1, -8\n+    sw      r15, r0, r1"}, {"sha": "7970dee1c931e25b9b00de98905c1ea39629b66c", "filename": "gcc/config/microblaze/crtn.s", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fcrtn.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fcrtn.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fcrtn.s?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,35 @@\n+/* crtn.s for __init, __fini\n+   This file supplies the epilogue for __init and __fini routines \n+\n+   Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+   Contributed by Michael Eager <eager@eagercon.com>.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+ \n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+    .section .init, \"ax\"\n+    lw      r15, r0, r1\n+    rtsd    r15, 8 \n+    addik   r1, r1, 8\n+\n+    .section .fini, \"ax\"\n+    lw      r15, r0, r1\n+    rtsd    r15, 8 \n+    addik   r1, r1, 8    "}, {"sha": "adf5fcccf386d6e79d5517df96d7b6c3a560487b", "filename": "gcc/config/microblaze/linux.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Flinux.h?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,35 @@\n+/* Definitions for MicroBlaze running Linux.\n+   Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   Contributed by Michael Eager <eager@eagercon.com>.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+#define DYNAMIC_LINKER \"/lib/ld.so.1\"\n+#undef  SUBTARGET_EXTRA_SPECS\n+#define SUBTARGET_EXTRA_SPECS \\\n+  { \"dynamic_linker\", DYNAMIC_LINKER }\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"%{shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      %{!dynamic-linker:-dynamic-linker %(dynamic_linker)}} \\\n+    %{static:-static}}\"\n+"}, {"sha": "3b0059e71c778a2c677e0c7a39b5221fb7a1f50b", "filename": "gcc/config/microblaze/microblaze-c.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-c.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,93 @@\n+/* Subroutines used for the C front end for Xilinx MicroBlaze.\n+   Copyright 2010 Free Software Foundation, Inc.\n+\n+   Contributed by Michael Eager <eager@eagercon.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"cpplib.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-common.h\"\n+#include \"toplev.h\"\n+#include \"tm_p.h\"\n+#include \"target.h\"\n+\n+#define builtin_define(TXT) cpp_define (pfile, TXT)\n+#define builtin_assert(TXT) cpp_assert (pfile, TXT)\n+\n+/* Define preprocessor symbols for MicroBlaze.  \n+   Symbols which do not start with __ are deprecated.  */\n+\n+void \n+microblaze_cpp_define (cpp_reader *pfile)\n+{\n+  builtin_assert (\"cpu=microblaze\");\n+  builtin_assert (\"machine=microblaze\");\n+  builtin_define (\"__MICROBLAZE__\");\n+  if (!TARGET_SOFT_MUL) \n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_MUL\");\n+      builtin_define (\"__HAVE_HW_MUL__\");\n+    }\n+  if (TARGET_MULTIPLY_HIGH)\n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_MUL_HIGH\");\n+      builtin_define (\"__HAVE_HW_MUL_HIGH__\");\n+    }\n+  if (!TARGET_SOFT_DIV)\n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_DIV\");\n+      builtin_define (\"__HAVE_HW_DIV__\");\n+    }\n+  if (TARGET_BARREL_SHIFT)\n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_BSHIFT\");\n+      builtin_define (\"__HAVE_HW_BSHIFT__\");\n+    }\n+  if (TARGET_PATTERN_COMPARE)\n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_PCMP\");\n+      builtin_define (\"__HAVE_HW_PCMP__\");\n+    }\n+  if (TARGET_HARD_FLOAT)\n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_FPU\");\n+      builtin_define (\"__HAVE_HW_FPU__\");\n+    }\n+  if (TARGET_FLOAT_CONVERT)\n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_FPU_CONVERT\");\n+      builtin_define (\"__HAVE_HW_FPU_CONVERT__\");\n+    }\n+  if (TARGET_FLOAT_SQRT)\n+    {\n+      if (!flag_iso)\n+        builtin_define (\"HAVE_HW_FPU_SQRT\");\n+      builtin_define (\"__HAVE_HW_FPU_SQRT__\");\n+    }\n+}  "}, {"sha": "ca8ca6e8dc3b2a6f8ddd0fff8e2243febec09f90", "filename": "gcc/config/microblaze/microblaze-protos.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,64 @@\n+/* Definitions of target machine for GNU compiler, for Xilinx MicroBlaze.\n+   Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   Contributed by Michael Eager <eager@eagercon.com>.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_MICROBLAZE_PROTOS_H\n+#define GCC_MICROBLAZE_PROTOS_H\n+\n+#ifdef RTX_CODE\n+extern int pic_address_needs_scratch (rtx);\n+extern void expand_block_move        (rtx *);\n+extern void microblaze_expand_prologue (void);\n+extern void microblaze_expand_epilogue (void);\n+extern void override_options (void);\n+extern int microblaze_expand_shift (rtx *);\n+extern bool microblaze_expand_move (enum machine_mode, rtx *);\n+extern bool microblaze_expand_block_move (rtx, rtx, rtx, rtx);\n+extern void microblaze_expand_divide (rtx *);\n+extern void microblaze_expand_conditional_branch (enum machine_mode, rtx *); \n+extern void microblaze_expand_conditional_branch_sf (rtx *); \n+extern int microblaze_can_use_return_insn (void);\n+extern int microblaze_const_double_ok (rtx, enum machine_mode);\n+extern void print_operand (FILE *, rtx, int);\n+extern void print_operand_address (FILE *, rtx);\n+extern void init_cumulative_args (CUMULATIVE_ARGS *,tree, rtx);\n+extern bool microblaze_legitimate_address_p (enum machine_mode, rtx, bool);\n+extern int microblaze_is_interrupt_handler (void);\n+extern rtx microblaze_return_addr (int, rtx);\n+extern int simple_memory_operand (rtx, enum machine_mode);\n+extern int double_memory_operand (rtx, enum machine_mode);\n+\n+extern int microblaze_regno_ok_for_base_p (int, int);\n+extern HOST_WIDE_INT microblaze_initial_elimination_offset (int, int);\n+extern void microblaze_declare_object (FILE *, const char *, const char *,\n+   const char *, int);\n+extern void microblaze_asm_output_ident (FILE *, const char *);\n+#endif  /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t  tree, int);\n+extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+#endif /* TREE_CODE */\n+\n+/* Declare functions in microblaze-c.c.  */\n+extern void microblaze_cpp_define (struct cpp_reader *); \n+\n+#endif  /* GCC_MICROBLAZE_PROTOS_H */"}, {"sha": "d600c80040218647c8be42a9ca9ba79310632a96", "filename": "gcc/config/microblaze/microblaze.c", "status": "added", "additions": 3037, "deletions": 0, "changes": 3037, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=809201325afb3d70e517d30a483b39251b1b6e27"}, {"sha": "c7bf756034b878cd5cfbbde7de3109f1302ba93d", "filename": "gcc/config/microblaze/microblaze.h", "status": "added", "additions": 952, "deletions": 0, "changes": 952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,952 @@\n+/* Definitions of target machine for GNU compiler for Xilinx MicroBlaze.\n+   Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+   Contributed by Michael Eager <eager@eagercon.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Standard GCC variables that we reference.  */\n+\n+/* MicroBlaze external variables defined in microblaze.c.  */\n+\n+/* Which pipeline to schedule for.  */\n+enum pipeline_type\n+{\n+  MICROBLAZE_PIPE_3 = 0,\n+  MICROBLAZE_PIPE_5 = 1\n+};\n+\n+#define MICROBLAZE_MASK_NO_UNSAFE_DELAY         0x00000001\n+\n+/* print_operand punctuation chars */\n+extern char microblaze_print_operand_punct[];\n+\n+/* # bytes of data/sdata cutoff */\n+extern int microblaze_section_threshold;\n+\n+/* Map register # to debug register # */\n+extern int microblaze_dbx_regno[];\n+\n+extern int microblaze_no_unsafe_delay;\n+extern enum pipeline_type microblaze_pipe;\n+\n+#define OBJECT_FORMAT_ELF\n+\n+/* Default target_flags if no switches are specified  */\n+#define TARGET_DEFAULT      (MASK_SOFT_MUL | MASK_SOFT_DIV | MASK_SOFT_FLOAT)\n+\n+/* What is the default setting for -mcpu= . We set it to v4.00.a even though \n+   we are actually ahead. This is safest version that has generate code \n+   compatible for the original ISA */\n+#define MICROBLAZE_DEFAULT_CPU      \"v4.00.a\"\n+\n+/* Macros to decide whether certain features are available or not,\n+   depending on the instruction set architecture level.  */\n+\n+#undef SWITCH_TAKES_ARG\n+#define SWITCH_TAKES_ARG(CHAR)\t\t\t\t\t\t\\\n+  (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n+\n+/*  We can debug without having a frame pointer.  */\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+#define DRIVER_SELF_SPECS    \t\t\t\t\\\n+\t\"%{mxl-soft-mul:%<mno-xl-soft-mul}\", \t\t\\\n+\t\"%{mno-xl-barrel-shift:%<mxl-barrel-shift}\", \t\\\n+\t\"%{mno-xl-pattern-compare:%<mxl-pattern-compare}\", \\\n+\t\"%{mxl-soft-div:%<mno-xl-soft-div}\", \t\t\\\n+\t\"%{msoft-float:%<mhard-float}\"\n+\n+/* Tell collect what flags to pass to nm.  */\n+#ifndef NM_FLAGS\n+#define NM_FLAGS \"-Bn\"\n+#endif\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#define TARGET_CPU_CPP_BUILTINS() microblaze_cpp_define (pfile)\n+\n+/* Assembler specs.  */\n+\n+#define TARGET_ASM_SPEC \"%{v}\"\n+\n+#define ASM_SPEC \"\\\n+%{microblaze1} \\\n+%(target_asm_spec)\"\n+\n+/* Extra switches sometimes passed to the linker.  */\n+/* -xl-mode-xmdstub translated to -Zxl-mode-xmdstub -- deprecated.  */\n+\n+#define LINK_SPEC \"%{shared:-shared} -N -relax \\\n+  %{Zxl-mode-xmdstub:-defsym _TEXT_START_ADDR=0x800} \\\n+  %{mxl-mode-xmdstub:-defsym _TEXT_START_ADDR=0x800} \\\n+  %{mxl-gp-opt:%{G*}} %{!mxl-gp-opt: -G 0} \\\n+  %{!Wl,-T*: %{!T*: -dT xilinx.ld%s}}\"\n+\n+/* Specs for the compiler proper  */\n+\n+#ifndef CC1_SPEC\n+#define CC1_SPEC \" \\\n+%{G*} %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \\\n+%{save-temps: } \\\n+%(subtarget_cc1_spec) \\\n+%{mxl-multiply-high:-mcpu=v6.00.a} \\\n+\"\n+#endif\n+\n+#define EXTRA_SPECS\t\t\t\t\t\t\t\\\n+  { \"target_asm_spec\", TARGET_ASM_SPEC },\t\t\t\t\\\n+  SUBTARGET_EXTRA_SPECS\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define MICROBLAZE_VERSION MICROBLAZE_DEFAULT_CPU\n+\n+#ifndef MACHINE_TYPE\n+#define MACHINE_TYPE \"MicroBlaze/ELF\"\n+#endif\n+\n+#ifndef TARGET_VERSION_INTERNAL\n+#define TARGET_VERSION_INTERNAL(STREAM)\t\t\t\t\t\\\n+  fprintf (STREAM, \" %s %s\", MACHINE_TYPE, MICROBLAZE_VERSION)\n+#endif\n+\n+#ifndef TARGET_VERSION\n+#define TARGET_VERSION TARGET_VERSION_INTERNAL (stderr)\n+#endif\n+\n+/* Local compiler-generated symbols must have a prefix that the assembler\n+   understands.   */\n+\n+#ifndef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX\t\"$\"\n+#endif\n+\n+/* fixed registers.  */\n+#define MB_ABI_BASE_REGNUM                   0\n+#define MB_ABI_STACK_POINTER_REGNUM          1\n+#define MB_ABI_GPRO_REGNUM                   2\n+#define MB_ABI_GPRW_REGNUM                  13\n+#define MB_ABI_INTR_RETURN_ADDR_REGNUM      14\n+#define MB_ABI_SUB_RETURN_ADDR_REGNUM       15\n+#define MB_ABI_DEBUG_RETURN_ADDR_REGNUM     16\n+#define MB_ABI_EXCEPTION_RETURN_ADDR_REGNUM 17\n+#define MB_ABI_ASM_TEMP_REGNUM              18\t\n+/* This is our temp register.  */\n+#define MB_ABI_FRAME_POINTER_REGNUM         19\n+#define MB_ABI_PIC_ADDR_REGNUM              20\n+#define MB_ABI_PIC_FUNC_REGNUM              21\n+/* Volatile registers.  */\n+#define MB_ABI_INT_RETURN_VAL_REGNUM         3\n+#define MB_ABI_INT_RETURN_VAL2_REGNUM        4\n+#define MB_ABI_FIRST_ARG_REGNUM              5\n+#define MB_ABI_LAST_ARG_REGNUM              10\n+#define MB_ABI_MAX_ARG_REGS                 (MB_ABI_LAST_ARG_REGNUM \t\\\n+\t\t\t\t\t     - MB_ABI_FIRST_ARG_REGNUM + 1)\n+#define MB_ABI_STATIC_CHAIN_REGNUM           3\n+#define MB_ABI_TEMP1_REGNUM                 11\n+#define MB_ABI_TEMP2_REGNUM                 12\n+#define MB_ABI_MSR_SAVE_REG                 11\t\n+/* Volatile register used to save MSR in interrupt handlers.  */\n+\n+\n+/* Debug stuff.  */\n+\n+/* How to renumber registers for dbx and gdb.  */\n+#define DBX_REGISTER_NUMBER(REGNO) microblaze_dbx_regno[(REGNO)]\n+\n+/* Generate DWARF exception handling info.  */\n+#define DWARF2_UNWIND_INFO 1\n+\n+/* Don't generate .loc operations.  */\n+#define DWARF2_ASM_LINE_DEBUG_INFO 0\n+\n+/* The DWARF 2 CFA column which tracks the return address.  */\n+#define DWARF_FRAME_RETURN_COLUMN \\\n+\t(GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)\n+\n+/* Initial state of return address on entry to func = R15.\n+   Actually, the RA is at R15+8, but gcc doesn't know how \n+   to generate this. \n+   NOTE:  GDB has a workaround and expects this incorrect value.\n+   If this is fixed, a corresponding fix to GDB is needed.  */\n+#define INCOMING_RETURN_ADDR_RTX  \t\t\t\\\n+  gen_rtx_REG (VOIDmode, GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)\n+\n+/* Use DWARF 2 debugging information by default.  */\n+#define DWARF2_DEBUGGING_INFO\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* Target machine storage layout */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN 1\n+#define BITS_PER_UNIT           8\n+#define BITS_PER_WORD           32\n+#define UNITS_PER_WORD          4\n+#define MIN_UNITS_PER_WORD      4\n+#define INT_TYPE_SIZE           32\n+#define SHORT_TYPE_SIZE         16\n+#define LONG_TYPE_SIZE          32\n+#define LONG_LONG_TYPE_SIZE     64\n+#define FLOAT_TYPE_SIZE         32\n+#define DOUBLE_TYPE_SIZE        64\n+#define LONG_DOUBLE_TYPE_SIZE   64\n+#define POINTER_SIZE            32\n+#define PARM_BOUNDARY           32\n+#define FUNCTION_BOUNDARY       32\n+#define EMPTY_FIELD_BOUNDARY    32\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+#define BIGGEST_ALIGNMENT       32\n+#define STRICT_ALIGNMENT        1\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\t\\\n+  ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)\t\\\n+   && (ALIGN) < BITS_PER_WORD\t\t\t\t\t\t\\\n+\t? BITS_PER_WORD\t\t\t\t\t\t\t\\\n+\t: (ALIGN))\n+\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  ((((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\t\\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN)     \t\t\t\t\\\n+    (((TREE_CODE (TYPE) == ARRAY_TYPE \t\t\t\t\t\\\n+       && TYPE_MODE (TREE_TYPE (TYPE)) == QImode)\t\t\t\\\n+     && (ALIGN) < BITS_PER_WORD) ? BITS_PER_WORD : (ALIGN))\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+#define LOAD_EXTEND_OP(MODE)  ZERO_EXTEND\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4)\t\t\\\n+    (MODE) = SImode;\n+\n+/* Standard register usage.  */\n+\n+/* On the MicroBlaze, we have 32 integer registers */\n+\n+#define FIRST_PSEUDO_REGISTER 36\n+\n+#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  1, 1, 1, 1 \t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  1, 1, 1, 1\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define GP_REG_FIRST    0\n+#define GP_REG_LAST     31\n+#define GP_REG_NUM      (GP_REG_LAST - GP_REG_FIRST + 1)\n+#define GP_DBX_FIRST    0\n+\n+#define ST_REG\t\t32\n+#define AP_REG_NUM      33\n+#define RAP_REG_NUM     34\n+#define FRP_REG_NUM     35\n+\n+#define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n+#define ST_REG_P(REGNO) ((REGNO) == ST_REG)\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+\t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode\n+   MODE.  In 32 bit mode, require that DImode and DFmode be in even\n+   registers.  For DImode, this makes some of the insns easier to\n+   write, since you don't have to worry about a DImode value in\n+   registers 3 & 4, producing a result in 4 & 5.\n+\n+   To make the code simpler HARD_REGNO_MODE_OK now just references an\n+   array built in override_options.  Because machmodes.h is not yet\n+   included before this file is processed, the MODE bound can't be\n+   expressed here.  */\n+extern char microblaze_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+            microblaze_hard_regno_mode_ok[ (int)(MODE) ][ (REGNO)]\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n+    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n+       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\n+#define STACK_POINTER_REGNUM   (GP_REG_FIRST + MB_ABI_STACK_POINTER_REGNUM)\n+\n+#define STACK_POINTER_OFFSET   FIRST_PARM_OFFSET(FNDECL)\n+\n+/* Base register for access to local variables of the function.  We\n+   pretend that the frame pointer is\n+   MB_ABI_INTR_RETURN_ADDR_REGNUM, and then eliminate it\n+   to HARD_FRAME_POINTER_REGNUM.  We can get away with this because\n+   rMB_ABI_INTR_RETUREN_ADDR_REGNUM is a fixed\n+   register(return address for interrupt), and will not be used for\n+   anything else.  */\n+   \n+#define FRAME_POINTER_REGNUM \t\tFRP_REG_NUM\n+#define HARD_FRAME_POINTER_REGNUM       \\\n+        (GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM)\n+#define ARG_POINTER_REGNUM\t\tAP_REG_NUM\n+#define RETURN_ADDRESS_POINTER_REGNUM\tRAP_REG_NUM\n+#define STATIC_CHAIN_REGNUM             \\\n+        (GP_REG_FIRST + MB_ABI_STATIC_CHAIN_REGNUM)\n+\n+/* registers used in prologue/epilogue code when the stack frame\n+   is larger than 32K bytes.  These registers must come from the\n+   scratch register set, and not used for passing and returning\n+   arguments and any other information used in the calling sequence\n+   (such as pic).  */\n+\n+#define MICROBLAZE_TEMP1_REGNUM         \\\n+        (GP_REG_FIRST + MB_ABI_TEMP1_REGNUM)\n+\n+#define MICROBLAZE_TEMP2_REGNUM         \\\n+        (GP_REG_FIRST + MB_ABI_TEMP2_REGNUM)\n+\n+#define NO_FUNCTION_CSE                 1\n+\n+#define PIC_OFFSET_TABLE_REGNUM         \\\n+        (flag_pic ? (GP_REG_FIRST + MB_ABI_PIC_ADDR_REGNUM) : \\\n+        INVALID_REGNUM)\n+\n+enum reg_class\n+{\n+  NO_REGS,\t\t\t/* no registers in set.  */\n+  GR_REGS,\t\t\t/* integer registers.  */\n+  ST_REGS,\t\t\t/* status register.  */\n+  ALL_REGS,\t\t\t/* all registers.  */\n+  LIM_REG_CLASSES\t\t/* max value + 1.  */\n+};\n+\n+#define N_REG_CLASSES \t\t(int) LIM_REG_CLASSES\n+\n+#define GENERAL_REGS \t\tGR_REGS\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ST_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000 },\t\t/* no registers.  */\t\t\\\n+  { 0xffffffff, 0x00000000 },\t\t/* integer registers.  */\t\\\n+  { 0x00000000, 0x00000001 },\t\t/* status registers.  */\t\\\n+  { 0xffffffff, 0x0000000f }\t\t/* all registers.  */\t\t\\\n+}\n+\n+extern enum reg_class microblaze_regno_to_class[];\n+\n+#define REGNO_REG_CLASS(REGNO) \t\tmicroblaze_regno_to_class[ (REGNO) ]\n+\n+#define BASE_REG_CLASS  \t\tGR_REGS\n+\n+#define INDEX_REG_CLASS \t\tGR_REGS\n+\n+#define GR_REG_CLASS_P(CLASS) \t\t((CLASS) == GR_REGS)\n+\n+/* REGISTER AND CONSTANT CLASSES */\n+\n+#define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n+#define LARGE_INT(X) (INTVAL (X) >= 0x80000000 && INTVAL (X) <= 0xffffffff)\n+#define PLT_ADDR_P(X) (GET_CODE (X) == UNSPEC && XINT (X,1) == UNSPEC_PLT)\n+/* Test for a valid operand for a call instruction.\n+   Don't allow the arg pointer register or virtual regs\n+   since they may change into reg + const, which the patterns\n+   can't handle yet.  */\n+#define CALL_INSN_OP(X) (CONSTANT_ADDRESS_P (X) \\\n+                         || (GET_CODE (X) == REG && X != arg_pointer_rtx\\\n+                             && ! (REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+                             && REGNO (X) <= LAST_VIRTUAL_REGISTER)))\n+\n+/* True if VALUE is a signed 16-bit number.  */\n+#define SMALL_OPERAND(VALUE) \t\t\t\t\t\t\\\n+  ((unsigned HOST_WIDE_INT) (VALUE) + 0x8000 < 0x10000)\n+\n+/* Constant which cannot be loaded in one instruction.  */\n+#define LARGE_OPERAND(VALUE)\t\t\t\t\t\t\\\n+  ((((VALUE) & ~0x0000ffff) != 0)\t\t\t\t\t\\\n+   && (((VALUE) & ~0x0000ffff) != ~0x0000ffff)\t\t\t\t\\\n+   && (((VALUE) & 0x0000ffff) != 0\t\t\t\t\t\\\n+       || (((VALUE) & ~2147483647) != 0\t\t\t\t\t\\\n+\t   && ((VALUE) & ~2147483647) != ~2147483647)))\n+\t\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n+  ((CLASS) != ALL_REGS\t\t\t\t\t\t\t\\\n+   ? (CLASS)\t\t\t\t\t\t\t\\\n+   : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\t\\\n+      ? (GR_REGS)\t\t\t\\\n+      : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\\n+\t  || GET_MODE (X) == VOIDmode)\t\t\t\t\t\\\n+\t ? (GR_REGS) : (CLASS))))\n+\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_INT)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  ((GET_MODE_SIZE (MODE) + (UNITS_PER_WORD) - 1) / (UNITS_PER_WORD))\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Changed the starting frame offset to including the new link stuff */\n+#define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n+   (crtl->outgoing_args_size + FIRST_PARM_OFFSET(FNDECL))\n+\n+/* The return address for the current frame is in r31 if this is a leaf\n+   function.  Otherwise, it is on the stack.  It is at a variable offset\n+   from sp/fp/ap, so we define a fake hard register rap which is a\n+   poiner to the return address on the stack.  This always gets eliminated\n+   during reload to be either the frame pointer or the stack pointer plus\n+   an offset.  */\n+\n+#define RETURN_ADDR_RTX(count, frame)\t\t\t\\\n+  microblaze_return_addr(count,frame)\n+\n+extern struct microblaze_frame_info current_frame_info;\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { ARG_POINTER_REGNUM,   GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM},\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, \t\t\t\t\t\\\n+   GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM},\t\t\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, \t\t\t\t\t\\\n+   GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM},\t\t\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { FRAME_POINTER_REGNUM, GP_REG_FIRST + MB_ABI_FRAME_POINTER_REGNUM}}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t \\\n+        (OFFSET) = microblaze_initial_elimination_offset ((FROM), (TO))\n+\n+#define ACCUMULATE_OUTGOING_ARGS        1\n+\n+#define FIRST_PARM_OFFSET(FNDECL)\t\t(UNITS_PER_WORD)\n+\n+#define ARG_POINTER_CFA_OFFSET(FNDECL)\t\t0\n+\n+#define REG_PARM_STACK_SPACE(FNDECL)  \t\t(MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD)\n+\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE)\t1\n+\n+#define STACK_BOUNDARY\t\t\t\t32\n+\n+#define NUM_OF_ARGS\t\t\t\t6\n+\n+#define GP_RETURN\t\t\t\t(GP_REG_FIRST + MB_ABI_INT_RETURN_VAL_REGNUM)\n+\n+#define GP_ARG_FIRST\t\t\t\t(GP_REG_FIRST + MB_ABI_FIRST_ARG_REGNUM)\n+#define GP_ARG_LAST\t\t\t\t(GP_REG_FIRST + MB_ABI_LAST_ARG_REGNUM)\n+\n+#define MAX_ARGS_IN_REGISTERS\t\t\tMB_ABI_MAX_ARG_REGS\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n+  gen_rtx_REG (\t\t\t\t\t\t\t\t\\\n+\t   ((GET_MODE_CLASS (MODE) != MODE_INT\t\t\t\t\\\n+\t     || GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n+\t    ? (MODE)\t\t\t\t\t\t\t\\\n+\t    : SImode), GP_RETURN)\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the MicroBlaze, R2 R3 are the only register thus used.\n+   Currently, R2 are only implemented  here (C has no complex type)  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N)\t\t((N) == GP_RETURN)\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t\t\t(((N) >= GP_ARG_FIRST && (N) <= GP_ARG_LAST))\n+\n+typedef struct microblaze_args\n+{\n+  int gp_reg_found;\t\t/* whether a gp register was found yet */\n+  int arg_number;\t\t/* argument number */\n+  int arg_words;\t\t/* # total words the arguments take */\n+  int fp_arg_words;\t\t/* # words for FP args */\n+  int last_arg_fp;\t\t/* nonzero if last arg was FP (EABI only) */\n+  int fp_code;\t\t\t/* Mode of FP arguments */\n+  int num_adjusts;\t\t/* number of adjustments made */\n+  /* Adjustments made to args pass in regs.  */\n+  /* ??? The size is doubled to work around a bug in the code that sets the \n+     adjustments in function_arg.  */\n+  struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS * 2];\n+} CUMULATIVE_ARGS;\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS)\t\\\n+  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg( &CUM, MODE, TYPE, NAMED)\n+\n+#define NO_PROFILE_COUNTERS\t\t\t1\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) { \\\n+  {                                        \\\n+    fprintf (FILE, \"\\tbrki\\tr16,_mcount\\n\");           \\\n+  }                                                    \\\n+ }\n+\n+#define EXIT_IGNORE_STACK\t\t\t1\n+\n+#define TRAMPOLINE_SIZE\t\t\t\t(32 + 8)\n+\n+#define TRAMPOLINE_ALIGNMENT\t\t\t32\n+\n+#define REGNO_OK_FOR_BASE_P(regno)\t\tmicroblaze_regno_ok_for_base_p ((regno), 1)\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)\t\tmicroblaze_regno_ok_for_base_p ((regno), 1)\n+\n+#ifndef REG_OK_STRICT\n+#define REG_STRICT_FLAG\t\t\t\t0\n+#else\n+#define REG_STRICT_FLAG\t\t\t\t1\n+#endif\n+\n+#define REG_OK_FOR_BASE_P(X)    \\\n+  microblaze_regno_ok_for_base_p (REGNO (X), REG_STRICT_FLAG)\n+\n+#define REG_OK_FOR_INDEX_P(X)   \\\n+  microblaze_regno_ok_for_base_p (REGNO (X), REG_STRICT_FLAG)\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+\n+/* Identify valid constant addresses.  Exclude if PIC addr which \n+   needs scratch register.  */\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+    || GET_CODE (X) == CONST_INT \t\t                        \\\n+    || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+\t&& ! (flag_pic && pic_address_needs_scratch (X))))\n+\n+/* Define this, so that when PIC, reload won't try to reload invalid\n+   addresses which require two reload registers.  */\n+#define LEGITIMATE_PIC_OPERAND_P(X)  (!pic_address_needs_scratch (X))\n+\n+/* At present, GAS doesn't understand li.[sd], so don't allow it\n+   to be generated at present.  */\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n+  (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n+    || microblaze_const_double_ok (X, GET_MODE (X)))\n+\n+#define CASE_VECTOR_MODE\t\t\t(SImode)\n+\n+#ifndef DEFAULT_SIGNED_CHAR\n+#define DEFAULT_SIGNED_CHAR\t\t\t1\n+#endif\n+\n+#define MOVE_MAX\t\t\t\t4\n+#define MAX_MOVE_MAX\t\t\t\t8\n+\n+#define SLOW_BYTE_ACCESS\t\t\t1\n+\n+/* sCOND operations return 1.  */\n+#define STORE_FLAG_VALUE\t\t\t1\n+\n+#define SHIFT_COUNT_TRUNCATED\t\t\t1\n+\n+/* This results in inefficient code for 64 bit to 32 conversions.\n+   Something needs to be done about this.  Perhaps not use any 32 bit\n+   instructions?  Perhaps use PROMOTE_MODE?  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n+\n+#define Pmode SImode\n+\n+#define FUNCTION_MODE   SImode\n+\n+/* Mode should alwasy be SImode */\n+#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\t\\\n+  ( GR_REG_CLASS_P (FROM) && GR_REG_CLASS_P (TO) ? 2 \t\t\\\n+   : (FROM) == ST_REGS && GR_REG_CLASS_P (TO) ? 4\t\t\\\n+   : 12)\n+\n+#define MEMORY_MOVE_COST(MODE,CLASS,TO_P) \\\n+  (4 + memory_move_secondary_cost ((MODE), (CLASS), (TO_P)))\n+\n+#define BRANCH_COST(speed_p, predictable_p)\t2\n+\n+/* Control the assembler format that we output.  */\n+#define ASM_APP_ON \" #APP\\n\"\n+#define ASM_APP_OFF \" #NO_APP\\n\"\n+\n+#define REGISTER_NAMES {\t\t\t\t\t\t\\\n+  \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",\t\t\\\n+  \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",\t\\\n+  \"r16\",  \"r17\",  \"r18\",  \"r19\",  \"r20\",  \"r21\",  \"r22\",  \"r23\",\t\\\n+  \"r24\",  \"r25\",  \"r26\",  \"r27\",  \"r28\",  \"r29\",  \"r30\",  \"r31\",\t\\\n+  \"rmsr\", \"$ap\",  \"$rap\", \"$frp\" }\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"r0\",\t 0 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r1\",\t 1 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r2\",\t 2 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r3\",\t 3 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r4\",\t 4 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r5\",\t 5 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r6\",\t 6 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r7\",\t 7 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r8\",\t 8 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r9\",\t 9 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r10\",\t10 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r11\",\t11 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r12\",\t12 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r13\",\t13 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r14\",\t14 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r15\",\t15 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r16\",\t16 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r17\",\t17 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r18\",\t18 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r19\",\t19 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r20\",\t20 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r21\",\t21 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r22\",\t22 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r23\",\t23 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r24\",\t24 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r25\",\t25 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r26\",\t26 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r27\",\t27 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r28\",\t28 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r29\",\t29 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r30\",\t30 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"r31\",\t31 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"rmsr\",     ST_REG}\t\t\t\t\t\t\t\\\n+}\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) microblaze_print_operand_punct[CODE]\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+/* ASM_OUTPUT_ALIGNED_COMMON and ASM_OUTPUT_ALIGNED_LOCAL\n+\n+   Unfortunately, we still need to set the section explicitly. Somehow,\n+   our binutils assign .comm and .lcomm variables to the \"current\" section \n+   in the assembly file, rather than where they implicitly belong. We need to\n+   remove this explicit setting in GCC when binutils can understand sections\n+   better.  */\n+#undef\tASM_OUTPUT_ALIGNED_COMMON\n+#define\tASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (SIZE > 0 && SIZE <= microblaze_section_threshold                  \\\n+      && TARGET_XLGPOPT)                                               \\\n+    {                                                                   \\\n+      switch_to_section (sbss_section);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      switch_to_section (bss_section);\t\t\t\t\t\\\n+    }                                                                   \\\n+  fprintf (FILE, \"%s\", COMMON_ASM_OP);                                  \\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",\t\t\\\n+           (SIZE), (ALIGN) / BITS_PER_UNIT);                            \\\n+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define\tASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (SIZE > 0 && SIZE <= microblaze_section_threshold                  \\\n+      && TARGET_XLGPOPT)                                               \\\n+    {                                                                   \\\n+      switch_to_section (sbss_section);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      switch_to_section (bss_section);\t\t\t\t\t\\\n+    }                                                                   \\\n+  fprintf (FILE, \"%s\", LCOMMON_ASM_OP);                                 \\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",\t\t\\\n+           (SIZE), (ALIGN) / BITS_PER_UNIT);                            \\\n+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\t\\\n+} while (0)\n+\n+#define\tASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n+} while (0)\n+\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)                     \\\n+{                                                                       \\\n+}\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\t\t\\\n+  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long)(NUM))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n+  fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n+\t   \".gpword\",                                                   \\\n+\t   LOCAL_LABEL_PREFIX, VALUE)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic == 2)                                               \\\n+    fprintf (STREAM, \"\\t%s\\t%sL%d@GOTOFF\\n\",                            \\\n+\t     \".gpword\",                                                 \\\n+\t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n+  else                                                                  \\\n+    fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n+\t     \".gpword\",                                                 \\\n+\t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n+} while (0)\n+\n+#define ASM_OUTPUT_ALIGN(STREAM,LOG)\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\", (LOG))\n+\n+#define ASM_OUTPUT_SKIP(STREAM,SIZE)\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.space\\t%lu\\n\", (SIZE))\n+\n+#define ASCII_DATA_ASM_OP\t\t\"\\t.ascii\\t\"\n+#define STRING_ASM_OP\t\t\t\"\\t.asciz\\t\"\n+\n+#define ASM_OUTPUT_IDENT(FILE, STRING)\t\t\t\t\t\\\n+  microblaze_asm_output_ident (FILE, STRING)\n+\n+/* Default to -G 8 */\n+#ifndef MICROBLAZE_DEFAULT_GVALUE\n+#define MICROBLAZE_DEFAULT_GVALUE 8\n+#endif\n+\n+/* Given a decl node or constant node, choose the section to output it in\n+   and select that section.  */\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\t\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* How to start an assembler comment.\n+   The leading space is important (the microblaze assembler requires it).  */\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START\t\t\" #\"\n+#endif\n+\n+#define BSS_VAR         1\n+#define SBSS_VAR        2\n+#define DATA_VAR        4\n+#define SDATA_VAR       5\n+#define RODATA_VAR      6\n+#define SDATA2_VAR      7\n+\n+/* These definitions are used in with the shift_type flag in the rtl.  */\n+#define SHIFT_CONST     1\n+#define SHIFT_REG       2\n+#define USE_ADDK        3\n+\n+/* Handle interrupt attribute.  */\n+extern int interrupt_handler;\n+extern int save_volatiles;\n+\n+#define INTERRUPT_HANDLER_NAME \"_interrupt_handler\"\n+\n+/* These #define added for C++.  */\n+#define UNALIGNED_SHORT_ASM_OP          \".data16\"\n+#define UNALIGNED_INT_ASM_OP            \".data32\"\n+#define UNALIGNED_DOUBLE_INT_ASM_OP     \".data8\"\n+\n+#define ASM_BYTE_OP                     \".data8\"\n+\n+/* The following #defines are used in the headers files. Always retain these.  */\n+\n+/* Added for declaring size at the end of the function.  */\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        char label[256];\t\t\t\t\t\t\\\n+\tstatic int labelno;\t\t\t\t\t\t\\\n+\tlabelno++;\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n+        (*targetm.asm_out.internal_label) (FILE, \"Lfe\", labelno);\t\\\n+\tfprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, label);\t\t\t\t\t\\\n+        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define GLOBAL_ASM_OP\t\t\t\"\\t.globl\\t\"\n+#define TYPE_ASM_OP\t\t\t\"\\t.type\\t\"\n+#define SIZE_ASM_OP\t\t\t\"\\t.size\\t\"\n+#define COMMON_ASM_OP\t\t\t\"\\t.comm\\t\"\n+#define LCOMMON_ASM_OP\t\t\t\"\\t.lcomm\\t\"\n+\n+#define MAX_OFILE_ALIGNMENT\t\t(32768*8)\n+\n+#define TYPE_OPERAND_FMT        \t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", TYPE_ASM_OP);\t\t\t         \t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    microblaze_declare_object (FILE, NAME, \"\", \":\\n\", 0);\t\t\t\\\n+  } while (0)\n+\n+#undef ASM_FINISH_DECLARE_OBJECT\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t         \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\", int_size_in_bytes (TREE_TYPE (DECL)));  \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n+#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)                            \\\n+ do { fputc ( '\\t', FILE);                                            \\\n+      assemble_name (FILE, LABEL1);                                   \\\n+      fputs ( \" = \", FILE);                                           \\\n+      assemble_name (FILE, LABEL2);                                   \\\n+      fputc ( '\\n', FILE);                                            \\\n+ } while (0)\n+\n+#define ASM_WEAKEN_LABEL(FILE,NAME) \t\t\t\t\t\\\n+ do { fputs (\"\\t.weakext\\t\", FILE);\t\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\t\\\n+      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n+    } while (0)\n+\n+#define MAKE_DECL_ONE_ONLY(DECL)\t(DECL_WEAK (DECL) = 1)\n+#undef UNIQUE_SECTION_P\n+#define UNIQUE_SECTION_P(DECL)\t\t(DECL_ONE_ONLY (DECL))\n+\n+#undef TARGET_ASM_NAMED_SECTION\n+#define TARGET_ASM_NAMED_SECTION        default_elf_asm_named_section\n+\n+/* Define the strings to put out for each section in the object file.  \n+   \n+   Note: For ctors/dtors, we want to give these sections the SHF_WRITE \n+   attribute to allow shared libraries to patch/resolve addresses into \n+   these locations.  On Microblaze, there is no concept of shared libraries \n+   yet, so this is for future use.  */\n+#define TEXT_SECTION_ASM_OP\t\"\\t.text\"\n+#define DATA_SECTION_ASM_OP\t\"\\t.data\"\n+#define READONLY_DATA_SECTION_ASM_OP    \\\n+                                \"\\t.rodata\"\n+#define BSS_SECTION_ASM_OP      \"\\t.bss\"\n+#define CTORS_SECTION_ASM_OP    \"\\t.section\\t.ctors,\\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP    \"\\t.section\\t.dtors,\\\"aw\\\"\"\n+#define INIT_SECTION_ASM_OP     \"\\t.section\\t.init,\\\"ax\\\"\"\n+#define FINI_SECTION_ASM_OP     \"\\t.section\\t.fini,\\\"ax\\\"\"\n+\n+#define SDATA_SECTION_ASM_OP\t\"\\t.sdata\"\t/* Small RW initialized data   */\n+#define SDATA2_SECTION_ASM_OP\t\"\\t.sdata2\"\t/* Small RO initialized data   */\n+#define SBSS_SECTION_ASM_OP     \"\\t.sbss\"\t/* Small RW uninitialized data */\n+#define SBSS2_SECTION_ASM_OP    \"\\t.sbss2\"\t/* Small RO uninitialized data */\n+\n+#define HOT_TEXT_SECTION_NAME   \".text.hot\"\n+#define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \\\n+                                \".text.unlikely\"\n+\n+/* We do this to save a few 10s of code space that would be taken up\n+   by the call_FUNC () wrappers, used by the generic CRT_CALL_STATIC_FUNCTION\n+   definition in crtstuff.c.  */\n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)\t\\\n+    asm ( SECTION_OP \"\\n\"                               \\\n+          \"\\tbrlid   r15, \" #FUNC \"\\n\\t nop\\n\"         \\\n+          TEXT_SECTION_ASM_OP);\n+\n+/* We need to group -lm as well, since some Newlib math functions \n+   reference __errno!  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+\"%{!nostdlib: \\\n+%{pg:-start-group -lxilprofile -lgloss -lxil -lc -lm -end-group } \\\n+%{!pg:-start-group -lgloss -lxil -lc -lm -end-group }} \"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#define STARTFILE_EXECUTABLE_SPEC   \"crt0.o%s crti.o%s crtbegin.o%s\"\n+#define STARTFILE_XMDSTUB_SPEC      \"crt1.o%s crti.o%s crtbegin.o%s\"\n+#define STARTFILE_BOOTSTRAP_SPEC    \"crt2.o%s crti.o%s crtbegin.o%s\"\n+#define STARTFILE_NOVECTORS_SPEC    \"crt3.o%s crti.o%s crtbegin.o%s\"\n+#define STARTFILE_CRTINIT_SPEC      \"%{!pg: %{!mno-clearbss: crtinit.o%s} \\\n+%{mno-clearbss: sim-crtinit.o%s}} \\\n+%{pg: %{!mno-clearbss: pgcrtinit.o%s} %{mno-clearbss: sim-pgcrtinit.o%s}}\"\n+\n+#define STARTFILE_DEFAULT_SPEC      STARTFILE_EXECUTABLE_SPEC\n+\n+#undef SUBTARGET_EXTRA_SPECS\n+#define\tSUBTARGET_EXTRA_SPECS\t\t\t\t\t\t\\\n+  { \"startfile_executable\",\tSTARTFILE_EXECUTABLE_SPEC },\t\t\\\n+  { \"startfile_xmdstub\",\tSTARTFILE_XMDSTUB_SPEC },\t\t\\\n+  { \"startfile_bootstrap\",\tSTARTFILE_BOOTSTRAP_SPEC },\t\t\\\n+  { \"startfile_novectors\",\tSTARTFILE_NOVECTORS_SPEC },\t\t\\\n+  { \"startfile_crtinit\",        STARTFILE_CRTINIT_SPEC },               \\\n+  { \"startfile_default\",\tSTARTFILE_DEFAULT_SPEC },\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC  \"\\\n+%{Zxl-mode-executable   : %(startfile_executable)  ; \\\n+  mxl-mode-executable   : %(startfile_executable)  ; \\\n+  Zxl-mode-xmdstub      : %(startfile_xmdstub)     ; \\\n+  mxl-mode-xmdstub      : %(startfile_xmdstub)     ; \\\n+  Zxl-mode-bootstrap    : %(startfile_bootstrap)   ; \\\n+  mxl-mode-bootstrap    : %(startfile_bootstrap)   ; \\\n+  Zxl-mode-novectors    : %(startfile_novectors)   ; \\\n+  mxl-mode-novectors    : %(startfile_novectors)   ; \\\n+  Zxl-mode-xilkernel    : %(startfile_xilkernel)   ; \\\n+  mxl-mode-xilkernel    : %(startfile_xilkernel)   ; \\\n+                        : %(startfile_default)       \\\n+} \\\n+%(startfile_crtinit)\""}, {"sha": "19b77f9bc219074bf292b3f6aec4cad9bd508548", "filename": "gcc/config/microblaze/microblaze.md", "status": "added", "additions": 2231, "deletions": 0, "changes": 2231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,2231 @@\n+;; microblaze.md -- Machine description for Xilinx MicroBlaze processors.\n+;; Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+;; Contributed by Michael Eager <eager@eagercon.com>.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+(include \"constraints.md\")\n+(include \"predicates.md\")\n+\n+;;----------------------------------------------------\n+;; Constants\n+;;----------------------------------------------------\n+(define_constants [\n+  (R_SP        1)       ;; Stack pointer reg\n+  (R_SR       15)       ;; Sub-routine return addr reg\n+  (R_IR       14)       ;; Interrupt return addr reg\n+  (R_DR       16)       ;; Debug trap return addr reg\n+  (R_ER       17)       ;; Exception return addr reg\n+  (R_TMP      18)       ;; Assembler temporary reg\n+  (R_GOT      20)       ;; GOT ptr reg\n+  (MB_PIPE_3   0)       ;; Microblaze 3-stage pipeline \n+  (MB_PIPE_5   1)       ;; Microblaze 5-stage pipeline \n+  (UNSPEC_SET_GOT       101)    ;;\n+  (UNSPEC_GOTOFF        102)    ;; GOT offset\n+  (UNSPEC_PLT           103)    ;; jump table\n+  (UNSPEC_CMP\t\t104)    ;; signed compare\n+  (UNSPEC_CMPU\t\t105)    ;; unsigned compare\n+])\n+\n+\n+;;----------------------------------------------------\n+;; Instruction Attributes\n+;;----------------------------------------------------\n+\n+;; Classification of each insn.\n+;; branch\tconditional branch\n+;; jump\t\tunconditional jump\n+;; call\t\tunconditional call\n+;; load\t\tload instruction(s)\n+;; store\tstore instruction(s)\n+;; move\t\tdata movement within same register set\n+;; arith\tinteger arithmetic instruction\n+;; darith\tdouble precision integer arithmetic instructions\n+;; imul\t\tinteger multiply\n+;; idiv\t\tinteger divide\n+;; icmp\t\tinteger compare\n+;; Xfadd\t\tfloating point add/subtract\n+;; Xfmul\t\tfloating point multiply\n+;; Xfmadd\tfloating point multiply-add\n+;; Xfdiv\t\tfloating point divide\n+;; Xfabs\t\tfloating point absolute value\n+;; Xfneg\t\tfloating point negation\n+;; Xfcmp\t\tfloating point compare\n+;; Xfcvt\t\tfloating point convert\n+;; Xfsqrt\tfloating point square root\n+;; multi\tmultiword sequence (or user asm statements)\n+;; nop\t\tno operation\n+;; bshift \tShift operations\n+\n+(define_attr \"type\"\n+  \"unknown,branch,jump,call,load,store,move,arith,darith,imul,idiv,icmp,multi,nop,no_delay_arith,no_delay_load,no_delay_store,no_delay_imul,no_delay_move,bshift,fadd,frsub,fmul,fdiv,fcmp,fsl,fsqrt,fcvt\"\n+  (const_string \"unknown\"))\n+\n+;; Main data type used by the insn\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,SF,DF\" (const_string \"unknown\"))\n+\n+;; # instructions (4 bytes each)\n+(define_attr \"length\" \"\" (const_int 4))\n+\n+;;----------------------------------------------------\n+;; Attribute describing the processor.  \n+;;----------------------------------------------------\n+\n+;; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; whether or not generating calls to position independent functions\n+(define_attr \"abicalls\" \"no,yes\"\n+  (const (symbol_ref \"microblaze_abicalls_attr\")))\n+\n+;;----------------------------------------------------------------\n+;; Microblaze DFA Pipeline description\n+;;----------------------------------------------------------------\n+                  \n+;;-----------------------------------------------------------------\n+/*\n+   This is description of pipeline hazards based on DFA.  The\n+   following constructions can be used for this:\n+\n+   o define_cpu_unit string [string]) describes a cpu functional unit\n+     (separated by comma).\n+\n+     1st operand: Names of cpu function units.\n+     2nd operand: Name of automaton (see comments for\n+     DEFINE_AUTOMATON).\n+\n+     All define_reservations and define_cpu_units should have unique\n+     names which can not be \"nothing\".\n+\n+   o (exclusion_set string string) means that each CPU function unit\n+     in the first string can not be reserved simultaneously with each\n+     unit whose name is in the second string and vise versa.  CPU\n+     units in the string are separated by commas. For example, it is\n+     useful for description CPU with fully pipelined floating point\n+     functional unit which can execute simultaneously only single\n+     floating point insns or only double floating point insns.\n+\n+   o (presence_set string string) means that each CPU function unit in\n+     the first string can not be reserved unless at least one of units\n+     whose names are in the second string is reserved.  This is an\n+     asymmetric relation.  CPU units in the string are separated by\n+     commas.  For example, it is useful for description that slot1 is\n+     reserved after slot0 reservation for a VLIW processor.\n+\n+   o (absence_set string string) means that each CPU function unit in\n+     the first string can not be reserved only if each unit whose name\n+     is in the second string is not reserved.  This is an asymmetric\n+     relation (actually exclusion set is analogous to this one but it\n+     is symmetric).  CPU units in the string are separated by commas.\n+     For example, it is useful for description that slot0 can not be\n+     reserved after slot1 or slot2 reservation for a VLIW processor.\n+\n+   o (define_bypass number out_insn_names in_insn_names) names bypass with\n+     given latency (the first number) from insns given by the first\n+     string (see define_insn_reservation) into insns given by the\n+     second string.  Insn names in the strings are separated by\n+     commas.\n+\n+   o (define_automaton string) describes names of an automaton\n+     generated and used for pipeline hazards recognition.  The names\n+     are separated by comma.  Actually it is possibly to generate the\n+     single automaton but unfortunately it can be very large.  If we\n+     use more one automata, the summary size of the automata usually\n+     is less than the single one.  The automaton name is used in\n+     define_cpu_unit.  All automata should have unique names.\n+\n+   o (define_reservation string string) names reservation (the first\n+     string) of cpu functional units (the 2nd string).  Sometimes unit\n+     reservations for different insns contain common parts.  In such\n+     case, you describe common part and use one its name (the 1st\n+     parameter) in regular expression in define_insn_reservation.  All\n+     define_reservations, define results and define_cpu_units should\n+     have unique names which can not be \"nothing\".\n+\n+   o (define_insn_reservation name default_latency condition regexpr)\n+     describes reservation of cpu functional units (the 3nd operand)\n+     for instruction which is selected by the condition (the 2nd\n+     parameter).  The first parameter is used for output of debugging\n+     information.  The reservations are described by a regular\n+     expression according the following syntax:\n+\n+       regexp = regexp \",\" oneof\n+              | oneof\n+\n+       oneof = oneof \"|\" allof\n+             | allof\n+\n+       allof = allof \"+\" repeat\n+             | repeat\n+\n+       repeat = element \"*\" number\n+              | element\n+\n+       element = cpu_function_name\n+               | reservation_name\n+               | result_name\n+               | \"nothing\"\n+               | \"(\" regexp \")\"\n+\n+       1. \",\" is used for describing start of the next cycle in\n+          reservation.\n+\n+       2. \"|\" is used for describing the reservation described by the\n+          first regular expression *or* the reservation described by\n+          the second regular expression *or* etc.\n+\n+       3. \"+\" is used for describing the reservation described by the\n+          first regular expression *and* the reservation described by\n+          the second regular expression *and* etc.\n+\n+       4. \"*\" is used for convenience and simply means sequence in\n+          which the regular expression are repeated NUMBER times with\n+          cycle advancing (see \",\").\n+\n+       5. cpu function unit name which means reservation.\n+\n+       6. reservation name -- see define_reservation.\n+\n+       7. string \"nothing\" means no units reservation.\n+\n+*/\n+;;-----------------------------------------------------------------\n+\n+\n+;;----------------------------------------------------------------\n+;; Microblaze 5-stage pipeline description (v5.00.a and later)\n+;;----------------------------------------------------------------                 \n+                    \n+(define_automaton   \"mbpipe_5\")\n+(define_cpu_unit    \"mb_issue,mb_iu,mb_wb,mb_fpu,mb_fpu_2,mb_mul,mb_mul_2,mb_div,mb_div_2,mb_bs,mb_bs_2\" \"mbpipe_5\")\n+\n+(define_insn_reservation \"mb-integer\" 1 \n+  (and (eq_attr \"type\" \"branch,jump,call,arith,darith,icmp,nop,no_delay_arith\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_iu,mb_wb\")\n+\n+(define_insn_reservation \"mb-special-move\" 2\n+  (and (eq_attr \"type\" \"move\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_iu*2,mb_wb\")\n+\n+(define_insn_reservation \"mb-mem-load\" 3\n+  (and (eq_attr \"type\" \"load,no_delay_load\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_iu,mb_wb\")\n+\n+(define_insn_reservation \"mb-mem-store\" 1\n+  (and (eq_attr \"type\" \"store,no_delay_store\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_iu,mb_wb\")\n+\n+(define_insn_reservation \"mb-mul\" 3\n+  (and (eq_attr \"type\" \"imul,no_delay_imul\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_mul,mb_mul_2*2,mb_wb\")\n+\n+(define_insn_reservation \"mb-div\" 34            \n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+    \"mb_issue,mb_div,mb_div_2*33,mb_wb\")\n+\n+(define_insn_reservation \"mb-bs\" 2 \n+  (and (eq_attr \"type\" \"bshift\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+   \"mb_issue,mb_bs,mb_bs_2,mb_wb\")\n+\n+(define_insn_reservation \"mb-fpu-add-sub-mul\" 6\n+  (and (eq_attr \"type\" \"fadd,frsub,fmul\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_fpu,mb_fpu_2*5,mb_wb\")\n+\n+(define_insn_reservation \"mb-fpu-fcmp\" 3\n+  (and (eq_attr \"type\" \"fcmp\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_fpu,mb_fpu*2,mb_wb\")\n+\n+(define_insn_reservation \"mb-fpu-div\" 30\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_fpu,mb_fpu_2*29,mb_wb\")\n+\n+(define_insn_reservation \"mb-fpu-sqrt\" 30\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_fpu,mb_fpu_2*29,mb_wb\")\n+\n+(define_insn_reservation \"mb-fpu-fcvt\" 4\n+  (and (eq_attr \"type\" \"fcvt\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_5)))\n+  \"mb_issue,mb_fpu,mb_fpu_2*3,mb_wb\")\n+\n+;;----------------------------------------------------------------\n+;; Microblaze 3-stage pipeline description (for v4.00.a and earlier)\n+;;----------------------------------------------------------------\n+\n+(define_automaton   \"mbpipe_3\")\n+(define_cpu_unit    \"mb3_iu\" \"mbpipe_3\")\n+\n+(define_insn_reservation \"mb3-integer\" 1 \n+  (and (eq_attr \"type\" \"branch,jump,call,arith,darith,icmp,nop,no_delay_arith\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-special-move\" 2\n+  (and (eq_attr \"type\" \"move\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu*2\")\n+\n+(define_insn_reservation \"mb3-mem-load\" 2\n+  (and (eq_attr \"type\" \"load,no_delay_load\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-mem-store\" 1\n+  (and (eq_attr \"type\" \"store,no_delay_store\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-mul\" 3\n+  (and (eq_attr \"type\" \"imul,no_delay_imul\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-div\" 34            \n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+    \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-bs\" 2 \n+  (and (eq_attr \"type\" \"bshift\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+   \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-fpu-add-sub-mul\" 6\n+  (and (eq_attr \"type\" \"fadd,frsub,fmul\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-fpu-fcmp\" 3\n+  (and (eq_attr \"type\" \"fcmp\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-fpu-div\" 30\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-fpu-sqrt\" 30\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(define_insn_reservation \"mb3-fpu-fcvt\" 4\n+  (and (eq_attr \"type\" \"fcvt\")\n+       (eq (symbol_ref  \"microblaze_pipe\") (const_int MB_PIPE_3)))\n+  \"mb3_iu\")\n+\n+(automata_option \"v\")\n+(automata_option \"time\")\n+(automata_option \"progress\")\n+\n+;;----------------------------------------------------------------\n+;; Microblaze delay slot description\n+;;----------------------------------------------------------------\n+(define_delay (eq_attr \"type\" \"branch,call,jump\")\n+  [(and (eq_attr \"type\" \"!branch,call,jump,icmp,multi,no_delay_arith,no_delay_load,no_delay_store,no_delay_imul,no_delay_move,darith\") \n+        (ior (eq (symbol_ref \"microblaze_no_unsafe_delay\") (const_int 0))\n+             (eq_attr \"type\" \"!fadd,frsub,fmul,fdiv,fcmp,store,load\")\n+             ))\n+  (nil) (nil)])\n+\n+\n+;;----------------------------------------------------------------\n+;; Microblaze FPU\n+;;----------------------------------------------------------------\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+        (plus:SF (match_operand:SF 1 \"register_operand\" \"d\")\n+                 (match_operand:SF 2 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fadd\\t%0,%1,%2\"\n+  [(set_attr \"type\"     \"fadd\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+        (minus:SF (match_operand:SF 1 \"register_operand\" \"d\")\n+                  (match_operand:SF 2 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"frsub\\t%0,%2,%1\"\n+  [(set_attr \"type\"     \"frsub\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+        (mult:SF (match_operand:SF 1 \"register_operand\" \"d\")\n+                 (match_operand:SF 2 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fmul\\t%0,%1,%2\"\n+  [(set_attr \"type\"     \"fmul\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4\")])\n+\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+        (div:SF (match_operand:SF 1 \"register_operand\" \"d\")\n+                (match_operand:SF 2 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fdiv\\t%0,%2,%1\"\n+  [(set_attr \"type\"     \"fdiv\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4\")])\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+        (sqrt:SF (match_operand:SF 1 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FLOAT_SQRT\"\n+  \"fsqrt\\t%0,%1\"\n+  [(set_attr \"type\"     \"fsqrt\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4\")])\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+        (float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FLOAT_CONVERT\"\n+  \"flt\\t%0,%1\"\n+  [(set_attr \"type\"     \"fcvt\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4\")])\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (fix:SI (match_operand:SF 1 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FLOAT_CONVERT\"\n+  \"fint\\t%0,%1\"\n+  [(set_attr \"type\"     \"fcvt\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4\")])\n+\n+;;----------------------------------------------------------------\n+;; Add\n+;;----------------------------------------------------------------\n+\n+;; Add 2 SImode integers [ src1 = reg ; src2 = arith ; dest = reg ]\n+;; Leave carry as is\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%dJ,dJ,dJ\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"d,I,i\")))]\n+  \"\"\n+  \"@\n+   addk\\t%0,%z1,%2\n+   addik\\t%0,%z1,%2\n+   addik\\t%0,%z1,%2\"\n+  [(set_attr \"type\"\t\"arith,arith,no_delay_arith\")\n+  (set_attr \"mode\"\t\"SI,SI,SI\")\n+  (set_attr \"length\"\t\"4,4,8\")])\n+\n+;;----------------------------------------------------------------\n+;; Double Precision Additions\n+;;----------------------------------------------------------------\n+\n+;; reg_DI_dest = reg_DI_src1 + DI_src2\n+\n+;; Adding 2 DI operands in register or reg/imm\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%d,d,d\")\n+\t\t (match_operand:DI 2 \"arith_operand32\" \"d,P,N\")))]\n+  \"\"\n+  \"@\n+  add\\t%L0,%L1,%L2\\;addc\\t%M0,%M1,%M2\n+  addi\\t%L0,%L1,%2\\;addc\\t%M0,%M1,r0\n+  addi\\t%L0,%L1,%2\\;addc\\t%M0,%M1,r0\\;addi\\t%M0,%M0,-1\"\n+  [(set_attr \"type\"\t\"darith\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"\t\"8,8,12\")])\n+\n+;;----------------------------------------------------------------\n+;; Subtraction\n+;;----------------------------------------------------------------\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(minus:SI (match_operand:SI 1 \"arith_operand\" \"d,d\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"d,n\")))]\n+  \"\"\n+  \"@\n+   rsubk\\t%0,%2,%z1\n+   addik\\t%0,%z1,-%2\"\n+  [(set_attr \"type\"\t\"arith,no_delay_arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4,8\")])\n+\n+\n+;;----------------------------------------------------------------\n+;; Double Precision Subtraction\n+;;----------------------------------------------------------------\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t  (match_operand:DI 2 \"arith_operand32\" \"d\")))]\n+  \"\"\n+  \"@\n+   rsub\\t%L0,%L2,%L1\\;rsubc\\t%M0,%M2,%M1\"\n+  [(set_attr \"type\"\t\"darith\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"\t\"8\")])\n+\n+\n+;;----------------------------------------------------------------\n+;; Multiplication\n+;;----------------------------------------------------------------\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"d,I,i\")))]\n+  \"!TARGET_SOFT_MUL\"\n+  \"@\n+  mul\\t%0,%1,%2\n+  muli\\t%0,%1,%2\n+  muli\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"imul,imul,no_delay_imul\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4,4,8\")])\n+\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+        (mult:DI\n+         (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+         (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"!TARGET_SOFT_MUL && TARGET_MULTIPLY_HIGH\"\n+  \"mul\\t%L0,%1,%2\\;mulh\\t%M0,%1,%2\"\n+  [(set_attr \"type\"     \"no_delay_arith\")\n+   (set_attr \"mode\"     \"DI\")\n+   (set_attr \"length\"   \"8\")])\n+\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+        (mult:DI\n+         (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+         (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"!TARGET_SOFT_MUL && TARGET_MULTIPLY_HIGH\"\n+  \"mul\\t%L0,%1,%2\\;mulhu\\t%M0,%1,%2\"\n+  [(set_attr \"type\"     \"no_delay_arith\")\n+   (set_attr \"mode\"     \"DI\")\n+   (set_attr \"length\"   \"8\")])\n+\n+(define_insn \"usmulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+        (mult:DI\n+         (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+         (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"!TARGET_SOFT_MUL && TARGET_MULTIPLY_HIGH\"\n+  \"mul\\t%L0,%1,%2\\;mulhsu\\t%M0,%2,%1\"\n+  [(set_attr \"type\"     \"no_delay_arith\")\n+   (set_attr \"mode\"     \"DI\")\n+   (set_attr \"length\"   \"8\")])\n+\n+(define_insn \"*smulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (truncate:SI\n+         (lshiftrt:DI\n+          (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\"  \"d\"))\n+                   (sign_extend:DI (match_operand:SI 2 \"register_operand\"  \"d\")))\n+          (const_int 32))))]\n+  \"!TARGET_SOFT_MUL && TARGET_MULTIPLY_HIGH\"\n+  \"mulh\\t%0,%1,%2\"\n+  [(set_attr \"type\"     \"imul\")\n+  (set_attr \"mode\"      \"SI\")\n+  (set_attr \"length\"    \"4\")])\n+\n+(define_insn \"*umulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\"                            \"=d\")\n+        (truncate:SI\n+         (lshiftrt:DI\n+          (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\"  \"d\"))\n+                   (zero_extend:DI (match_operand:SI 2 \"register_operand\"  \"d\"))\n+)\n+          (const_int 32))))]\n+  \"!TARGET_SOFT_MUL && TARGET_MULTIPLY_HIGH\"\n+  \"mulhu\\t%0,%1,%2\"\n+  [(set_attr \"type\"     \"imul\")\n+  (set_attr \"mode\"      \"SI\")\n+  (set_attr \"length\"    \"4\")])\n+\n+(define_insn \"*usmulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\"                            \"=d\")\n+        (truncate:SI\n+         (lshiftrt:DI\n+          (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\"  \"d\"))\n+                   (sign_extend:DI (match_operand:SI 2 \"register_operand\"  \"d\"))\n+)\n+          (const_int 32))))]\n+  \"!TARGET_SOFT_MUL && TARGET_MULTIPLY_HIGH\"\n+  \"mulhsu\\t%0,%2,%1\"\n+  [(set_attr \"type\"     \"imul\")\n+  (set_attr \"mode\"      \"SI\")\n+  (set_attr \"length\"    \"4\")])\n+\n+\n+;;----------------------------------------------------------------\n+;; Division and remainder\n+;;----------------------------------------------------------------\n+(define_expand \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                (match_operand:SI 2 \"register_operand\" \"d\")))\n+  ]\n+  \"(!TARGET_SOFT_DIV) || (TARGET_BARREL_SHIFT && TARGET_SMALL_DIVIDES)\"\n+  {\n+    if (TARGET_SOFT_DIV && TARGET_BARREL_SHIFT && TARGET_SMALL_DIVIDES) \n+      { \n+        microblaze_expand_divide (operands);\n+        DONE;\n+      } \n+    else if (!TARGET_SOFT_DIV) \n+      {\n+        emit_insn (gen_divsi3_internal (operands[0], operands[1], operands[2]));\n+        DONE;\n+      }\n+  }     \n+)\n+\n+\n+(define_insn \"divsi3_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n+  ]\n+  \"!TARGET_SOFT_DIV\"\n+  \"idiv\\t%0,%2,%1\"\n+  [(set_attr \"type\"\t\"idiv\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")]\n+)\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                 (match_operand:SI 2 \"register_operand\" \"d\")))\n+  ]\n+  \"!TARGET_SOFT_DIV\"\n+  \"idivu\\t%0,%2,%1\"\n+  [(set_attr \"type\"\t\"idiv\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+\n+;;----------------------------------------------------------------\n+;; Negation and one's complement\n+;;----------------------------------------------------------------\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"rsubk\\t%0,%1,r0\"\n+  [(set_attr \"type\"\t\"arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"rsub\\t%L0,%L1,r0\\;rsubc\\t%M0,%M1,r0\"\n+  [(set_attr \"type\"\t\"darith\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"\t\"8\")])\n+\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"xori\\t%0,%1,-1\"\n+  [(set_attr \"type\"\t\"arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"*one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"nor\\t%M0,r0,%M1\\;nor\\t%L0,r0,%L1\"\n+  [(set_attr \"type\"\t\"darith\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"    \"8\")]\n+)\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n+  \"reload_completed \n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\"\n+\n+  [(set (subreg:SI (match_dup 0) 0) (not:SI (subreg:SI (match_dup 1) 0)))\n+  (set (subreg:SI (match_dup 0) 4) (not:SI (subreg:SI (match_dup 1) 4)))]\n+  \"\")\n+\n+\n+;;----------------------------------------------------------------\n+;; Logical\n+;;----------------------------------------------------------------\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+\t(and:SI (match_operand:SI 1 \"arith_operand\" \"%d,d,d,d\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"d,I,i,M\")))]\n+  \"\"\n+  \"@\n+   and\\t%0,%1,%2\n+   andi\\t%0,%1,%2 #and1\n+   andi\\t%0,%1,%2 #and2\n+   andi\\t%0,%1,%2 #and3\"\n+  [(set_attr \"type\"\t\"arith,arith,no_delay_arith,no_delay_arith\")\n+  (set_attr \"mode\"\t\"SI,SI,SI,SI\")\n+  (set_attr \"length\"\t\"4,8,8,8\")])\n+\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"and\\t%M0,%M1,%M2\\;and\\t%L0,%L1,%L2\"\n+  [(set_attr \"type\"\t\"darith\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"    \"8\")])\n+\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n+  \"reload_completed \n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n+   && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n+\n+  [(set (subreg:SI (match_dup 0) 0) (and:SI (subreg:SI (match_dup 1) 0) \n+\t\t\t\t\t    (subreg:SI (match_dup 2) 0)))\n+  (set (subreg:SI (match_dup 0) 4) (and:SI (subreg:SI (match_dup 1) 4) \n+\t\t\t\t\t   (subreg:SI (match_dup 2) 4)))]\n+  \"\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"%d,d,d,d\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"d,I,M,i\")))]\n+  \"\"\n+  \"@\n+   or\\t%0,%1,%2\n+   ori\\t%0,%1,%2\n+   ori\\t%0,%1,%2\n+   ori\\t%0,%1,%2\" \n+  [(set_attr \"type\"\t\"arith,no_delay_arith,no_delay_arith,no_delay_arith\")\n+  (set_attr \"mode\"\t\"SI,SI,SI,SI\")\n+  (set_attr \"length\"\t\"4,8,8,8\")])\n+\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"or\\t%M0,%M1,%M2\\;or\\t%L0,%L1,%L2\"\n+  [(set_attr \"type\"\t\"darith\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"    \"8\")]\n+)\n+\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n+  \"reload_completed \n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n+   && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n+\n+  [(set (subreg:SI (match_dup 0) 0) (ior:SI (subreg:SI (match_dup 1) 0) \n+\t\t\t\t\t    (subreg:SI (match_dup 2) 0)))\n+  (set (subreg:SI (match_dup 0) 4) (ior:SI (subreg:SI (match_dup 1) 4) \n+\t\t\t\t\t   (subreg:SI (match_dup 2) 4)))]\n+  \"\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"%d,d,d\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"d,I,i\")))]\n+  \"\"\n+  \"@\n+   xor\\t%0,%1,%2\n+   xori\\t%0,%1,%2\n+   xori\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith,arith,no_delay_arith\")\n+  (set_attr \"mode\"\t\"SI,SI,SI\")\n+  (set_attr \"length\"\t\"4,8,8\")])\n+\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"xor\\t%M0,%M1,%M2\\;xor\\t%L0,%L1,%L2\"\n+  [(set_attr \"type\"\t\"darith\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"    \"8\")]\n+)\n+\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n+  \"reload_completed \n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n+   && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n+\n+  [(set (subreg:SI (match_dup 0) 0) (xor:SI (subreg:SI (match_dup 1) 0) \n+\t\t\t\t\t    (subreg:SI (match_dup 2) 0)))\n+  (set (subreg:SI (match_dup 0) 4) (xor:SI (subreg:SI (match_dup 1) 4) \n+\t\t\t\t\t   (subreg:SI (match_dup 2) 4)))]\n+  \"\")\n+\n+;;----------------------------------------------------------------\n+;; Zero extension\n+;;----------------------------------------------------------------\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  \"\"\n+  \"@\n+  andi\\t%0,%1,0xffff\n+  lhu%i1\\t%0,%1\n+  lhu%i1\\t%0,%1\"\n+  [(set_attr \"type\"\t\"no_delay_arith,load,no_delay_load\")\n+  (set_attr \"mode\"\t\"SI,SI,SI\")\n+  (set_attr \"length\"\t\"8,4,8\")])\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d,d\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  \"\"\n+  \"@\n+  andi\\t%0,%1,0x00ff\n+  lbu%i1\\t%0,%1\n+  lbu%i1\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith,load,no_delay_load\")\n+  (set_attr \"mode\"\t\"HI\")\n+  (set_attr \"length\"\t\"4,4,8\")])\n+  \n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  \"\"\n+  \"@\n+  andi\\t%0,%1,0x00ff\n+  lbu%i1\\t%0,%1\n+  lbu%i1\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith,load,no_delay_load\")\n+  (set_attr \"mode\"\t\"SI,SI,SI\")\n+  (set_attr \"length\"\t\"4,4,8\")])\n+\n+;;----------------------------------------------------------------\n+;; Sign extension\n+;;----------------------------------------------------------------\n+\n+;; basic Sign Extend Operations\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"sext8\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"sext16\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+;; Those for integer source operand are ordered\n+;; widest source type first.\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n+\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  \"\"\n+  { \n+     if (which_alternative == 0)\n+       output_asm_insn (\"addk\\t%D0,r0,%1\", operands);\n+     else\n+       output_asm_insn (\"lw%i1\\t%D0,%1\", operands);\n+\n+     output_asm_insn (\"add\\t%0,%D0,%D0\", operands);\n+     output_asm_insn (\"addc\\t%0,r0,r0\", operands);\n+     output_asm_insn (\"beqi\\t%0,.+8\", operands);\n+     return \"addi\\t%0,r0,0xffffffff\";\n+  }\n+  [(set_attr \"type\"\t\"multi,multi,multi\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"\t\"20,20,20\")])\n+\n+;;----------------------------------------------------------------\n+;; Data movement\n+;;----------------------------------------------------------------\n+\n+;; 64-bit integer moves\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    /* If operands[1] is a constant address illegal for pic, then we need to\n+       handle it just like microblaze_legitimize_address does.  */\n+    if (flag_pic && pic_address_needs_scratch (operands[1]))\n+    {\n+        rtx temp = force_reg (DImode, XEXP (XEXP (operands[1], 0), 0));\n+        rtx temp2 = XEXP (XEXP (operands[1], 0), 1);\n+        emit_move_insn (operands[0], gen_rtx_PLUS (DImode, temp, temp2));\n+        DONE;\n+    }\n+\n+\n+    if ((reload_in_progress | reload_completed) == 0\n+        && !register_operand (operands[0], DImode)\n+        && !register_operand (operands[1], DImode)\n+        && (((GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 0)\n+\t       && operands[1] != CONST0_RTX (DImode))))\n+    {\n+\n+      rtx temp = force_reg (DImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+  }\n+)\n+\n+\n+\n+(define_insn \"*movdi_internal\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m\")\n+\t(match_operand:DI 1 \"general_operand\"      \" d,i,J,R,m,d,d\"))]\n+  \"\"\n+  { \n+    switch (which_alternative)\n+    {\n+      case 0:\n+        return \"addk\\t%0,%1\\n\\taddk\\t%D0,%d1\";\n+      case 1:\n+\treturn \"addik\\t%0,r0,%h1\\n\\taddik\\t%D0,r0,%j1 #li => la\";\n+      case 2:\n+\t  return \"addk\\t%0,r0,r0\\n\\taddk\\t%D0,r0,r0\";\n+      case 3:\n+      case 4:\n+        if (reg_mentioned_p (operands[0], operands[1]))\n+          return \"lwi\\t%D0,%o1\\n\\tlwi\\t%0,%1\";\n+\telse\n+\t  return \"lwi\\t%0,%1\\n\\tlwi\\t%D0,%o1\";\n+      case 5:\n+      case 6:\n+        return \"swi\\t%1,%0\\n\\tswi\\t%D1,%o0\";\n+    }\n+    return \"unreachable\";\n+  }\n+  [(set_attr \"type\"\t\"no_delay_move,no_delay_arith,no_delay_arith,no_delay_load,no_delay_load,no_delay_store,no_delay_store\")\n+  (set_attr \"mode\"\t\"DI\")\n+  (set_attr \"length\"   \"8,8,8,8,12,8,12\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"register_operand\" \"\"))]\n+  \"reload_completed \n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1])) \n+   && (REGNO(operands[0]) == (REGNO(operands[1]) + 1))\"\n+\n+  [(set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))\n+  (set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"register_operand\" \"\"))]\n+  \"reload_completed \n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1])) \n+   && (REGNO (operands[0]) != (REGNO (operands[1]) + 1))\"\n+\n+  [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))\n+  (set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))]\n+  \"\")\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (microblaze_expand_move (SImode, operands)) DONE;\n+  }\n+)\n+\n+;; Added for status resgisters \n+(define_insn \"movsi_status\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,z\")\n+        (match_operand:SI 1 \"register_operand\" \"z,d,d\"))]\n+  \"interrupt_handler\"\n+  \"@\n+\tmfs\\t%0,%1  #mfs\n+\taddk\\t%0,%1,r0 #add movsi\n+\tmts\\t%0,%1  #mts\"\t\n+  [(set_attr \"type\" \"move\")\n+  (set_attr \"mode\" \"SI\")\n+  (set_attr \"length\" \"12\")])\n+\n+;; This move will be not be moved to delay slot.\t\n+(define_insn \"*movsi_internal3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"J,I,Mnis\"))]\n+  \"(register_operand (operands[0], SImode) && \n+           (GET_CODE (operands[1]) == CONST_INT && \n+                 (INTVAL (operands[1]) <= 32767 && INTVAL (operands[1]) >= -32768)))\"  \n+  \"@\n+   addk\\t%0,r0,r0\n+   addik\\t%0,r0,%1\\t# %X1\n+   addik\\t%0,r0,%1\\t# %X1\"\n+  [(set_attr \"type\"\t\"arith,arith,no_delay_arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+;; This move may be used for PLT label operand\n+(define_insn \"*movsi_internal5_pltop\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(match_operand:SI 1 \"call_insn_operand\" \"\"))]\n+  \"(register_operand (operands[0], Pmode) && \n+           PLT_ADDR_P (operands[1]))\"\n+  { \n+     gcc_unreachable ();\n+  }\n+  [(set_attr \"type\"\t\"load\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"*movsi_internal2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,   d,d,R, T\")\n+\t(match_operand:SI 1 \"move_operand\"         \" d,I,Mnis,R,m,dJ,dJ\"))]\n+  \"(register_operand (operands[0], SImode)\n+    || register_operand (operands[1], SImode) \n+    || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\n+    && (flag_pic != 2 || (GET_CODE (operands[1]) != SYMBOL_REF \n+                         && GET_CODE (operands[1]) != LABEL_REF))\"\n+  \"@\n+   addk\\t%0,%1,r0\n+   addik\\t%0,r0,%1\\t# %X1\n+   addik\\t%0,%a1\n+   lw%i1\\t%0,%1\n+   lw%i1\\t%0,%1\n+   sw%i0\\t%z1,%0\n+   sw%i0\\t%z1,%0\"\n+  [(set_attr \"type\"\t\"load,load,no_delay_load,load,no_delay_load,store,no_delay_store\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4,4,8,4,8,4,8\")])\n+\n+\n+;; 16-bit Integer moves\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if ((reload_in_progress | reload_completed) == 0\n+        && !register_operand (operands[0], HImode)\n+        && !register_operand (operands[1], HImode)\n+        && ((GET_CODE (operands[1]) != CONST_INT\n+  \t    || INTVAL (operands[1]) != 0)))\n+    {\n+        rtx temp = force_reg (HImode, operands[1]);\n+        emit_move_insn (operands[0], temp);\n+        DONE;\n+    }\n+  }\n+)\n+\n+(define_insn \"*movhi_internal2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m\")\n+\t(match_operand:HI 1 \"general_operand\"       \"I,d,R,m,dJ,dJ\"))]\n+  \"\"\n+  \"@\n+   addik\\t%0,r0,%1\\t# %X1\n+   addk\\t%0,%1,r0\n+   lhui\\t%0,%1\n+   lhui\\t%0,%1\n+   sh%i0\\t%z1,%0\n+   sh%i0\\t%z1,%0\"\n+  [(set_attr \"type\"\t\"arith,move,load,no_delay_load,store,no_delay_store\")\n+  (set_attr \"mode\"\t\"HI\")\n+  (set_attr \"length\"\t\"4,4,4,8,8,8\")])\n+\n+;; 8-bit Integer moves\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if ((reload_in_progress | reload_completed) == 0\n+        && !register_operand (operands[0], QImode)\n+        && !register_operand (operands[1], QImode)\n+        && ((GET_CODE (operands[1]) != CONST_INT\n+            || INTVAL (operands[1]) != 0)))\n+    {\n+        rtx temp = force_reg (QImode, operands[1]);\n+        emit_move_insn (operands[0], temp);\n+        DONE;\n+    }\n+  }\n+)\n+\n+(define_insn \"*movqi_internal2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m\")\n+\t(match_operand:QI 1 \"general_operand\"       \"J,I,d,R,m,dJ,dJ\"))]\n+  \"\"\n+  \"@\n+   addk\\t%0,r0,%z1\n+   addik\\t%0,r0,%1\\t# %X1\n+   addk\\t%0,%1,r0\n+   lbu%i1\\t%0,%1\n+   lbu%i1\\t%0,%1\n+   sb%i0\\t%z1,%0\n+   sbi\\t%z1,%0\"\n+  [(set_attr \"type\"\t\"arith,arith,move,load,no_delay_load,store,no_delay_store\")\n+  (set_attr \"mode\"\t\"QI\")\n+  (set_attr \"length\"\t\"4,4,8,4,8,4,8\")])\n+\n+;; Block moves, see microblaze.c for more details.\n+;; Argument 0 is the destination\n+;; Argument 1 is the source\n+;; Argument 2 is the length\n+;; Argument 3 is the alignment\n+ \n+(define_expand \"movmemsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\")\n+\t\t   (match_operand:BLK 1 \"general_operand\"))\n+\t      (use (match_operand:SI 2 \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\"))])]\n+  \"\"\n+  {\n+    if (microblaze_expand_block_move (operands[0], operands[1], \n+\t\t\t\t      operands[2], operands[3]))\n+        DONE;\n+    else  \n+        FAIL;\n+  }\n+)\n+\n+;; 32-bit floating point moves\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if ((reload_in_progress | reload_completed) == 0\n+        && !register_operand (operands[0], SFmode)\n+        && !register_operand (operands[1], SFmode)\n+        && ( ((GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 0)\n+                 && operands[1] != CONST0_RTX (SFmode))))\n+    {\n+        rtx temp = force_reg (SFmode, operands[1]);\n+        emit_move_insn (operands[0], temp);\n+        DONE;\n+    }\n+  }\n+)\n+\n+;; Applies to both TARGET_SOFT_FLOAT and TARGET_HARD_FLOAT\n+;;\n+(define_insn \"*movsf_internal\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m\")\n+        (match_operand:SF 1 \"general_operand\" \"G,d,R,F,m,d,d\"))]\n+  \"(register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode)\n+       || operands[1] == CONST0_RTX (SFmode))\"\n+  \"@\n+   addk\\t%0,r0,r0\n+   addk\\t%0,%1,r0\n+   lw%i1\\t%0,%1\n+   addik\\t%0,r0,%F1\n+   lw%i1\\t%0,%1\n+   sw%i0\\t%z1,%0\n+   swi\\t%z1,%0\"\n+  [(set_attr \"type\"     \"move,no_delay_load,load,no_delay_load,no_delay_load,store,no_delay_store\")\n+  (set_attr \"mode\"      \"SF\")\n+  (set_attr \"length\"    \"4,4,4,4,4,4,4\")])\n+\n+;; 64-bit floating point moves\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (flag_pic == 2) {\n+      if (GET_CODE (operands[1]) == MEM \n+          && !microblaze_legitimate_address_p (DFmode, XEXP (operands[1],0), 0))\n+      {\n+        rtx ptr_reg;\n+        rtx result;\n+        ptr_reg = force_reg (Pmode, XEXP (operands[1],0));\n+        result = gen_rtx_MEM (DFmode, ptr_reg);\n+        emit_move_insn (operands[0], result);\n+        DONE;\n+      }\n+    }\n+    if ((reload_in_progress | reload_completed) == 0\n+        && !register_operand (operands[0], DFmode)\n+        && !register_operand (operands[1], DFmode)\n+        && (((GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 0)\n+                 && operands[1] != CONST0_RTX (DFmode))))\n+    {\n+        rtx temp = force_reg (DFmode, operands[1]);\n+        emit_move_insn (operands[0], temp);\n+        DONE;\n+    }\n+  }\n+)\n+\n+;; movdf_internal\n+;; Applies to both TARGET_SOFT_FLOAT and TARGET_HARD_FLOAT\n+;;\n+(define_insn \"*movdf_internal\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,d,d,To\")\n+        (match_operand:DF 1 \"general_operand\" \"dG,o,F,T,d\"))]\n+  \"\"\n+  {\n+    switch (which_alternative)\n+    {\n+      case 0:\n+\treturn \"addk\\t%0,r0,r0\\n\\taddk\\t%D0,r0,r0\";\n+      case 1:\n+      case 3:\n+\tif (reg_mentioned_p (operands[0], operands[1]))\n+          return \"lwi\\t%D0,%o1\\n\\tlwi\\t%0,%1\";\n+        else\n+\t  return \"lwi\\t%0,%1\\n\\tlwi\\t%D0,%o1\";\n+      case 2:\n+      {\n+\treturn \"addik\\t%0,r0,%h1 \\n\\taddik\\t%D0,r0,%j1 #Xfer Lo\";\n+      }\n+      case 4:\n+\treturn \"swi\\t%1,%0\\n\\tswi\\t%D1,%o0\";\n+    }\n+    gcc_unreachable ();\n+  }\n+  [(set_attr \"type\"     \"no_delay_move,no_delay_load,no_delay_load,no_delay_load,no_delay_store\")\n+  (set_attr \"mode\"      \"DF\")\n+  (set_attr \"length\"    \"4,8,8,16,8\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n+   && (REGNO (operands[0]) == (REGNO (operands[1]) + 1))\"\n+  [(set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))\n+  (set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n+   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n+   && (REGNO (operands[0]) != (REGNO (operands[1]) + 1))\"\n+  [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))\n+  (set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))]\n+  \"\")\n+\n+;;----------------------------------------------------------------\n+;; Shifts\n+;;----------------------------------------------------------------\n+\n+;;----------------------------------------------------------------\n+;; 32-bit left shifts\n+;;----------------------------------------------------------------\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"\")))]\n+  \"\"\n+  { \n+    /* Avoid recursion for trivial cases. */\n+    if (!((GET_CODE (operands [2]) == CONST_INT) && (INTVAL (operands[2]) == 1)))\n+      if (microblaze_expand_shift (operands))\n+        DONE;\n+  }\n+)\n+\n+;; Irrespective of if we have a barrel-shifter or not, we want to match \n+;; shifts by 1 with a special pattern. When a barrel shifter is present, \n+;; saves a cycle. If not, allows us to annotate the instruction for delay \n+;; slot optimization\n+(define_insn \"*ashlsi3_byone\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                   (match_operand:SI 2 \"arith_operand\"    \"I\")))] \n+  \"(INTVAL (operands[2]) == 1)\"\n+  \"addk\\t%0,%1,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")]\n+)\n+\n+;; Barrel shift left\n+(define_insn \"ashlsi3_bshift\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                   (match_operand:SI 2 \"arith_operand\"    \"I,d\")))]\n+  \"TARGET_BARREL_SHIFT\"\n+  \"@\n+  bslli\\t%0,%1,%2\n+  bsll\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"bshift,bshift\")\n+  (set_attr \"mode\"\t\"SI,SI\")\n+  (set_attr \"length\"\t\"4,4\")]\n+)\n+\n+;; The following patterns apply when there is no barrel shifter present\n+\n+(define_insn \"*ashlsi3_with_mul_delay\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"I\")))] \n+  \"!TARGET_SOFT_MUL \n+   && ((1 << INTVAL (operands[2])) <= 32767 && (1 << INTVAL (operands[2])) >= -32768)\"\n+  \"muli\\t%0,%1,%m2\"\n+  ;; This MUL will not generate an imm. Can go into a delay slot.\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")]\n+)\n+\n+(define_insn \"*ashlsi3_with_mul_nodelay\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"I\")))] \n+  \"!TARGET_SOFT_MUL\"\n+  \"muli\\t%0,%1,%m2\"\n+  ;; This MUL will generate an IMM. Cannot go into a delay slot\n+  [(set_attr \"type\"\t\"no_delay_arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"8\")]\n+)\n+\n+(define_insn \"*ashlsi3_with_size_opt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (ashift:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"(INTVAL (operands[2]) > 5 && optimize_size)\"\n+  {\n+    operands[3] = gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM);\n+\n+    output_asm_insn (\"ori\\t%3,r0,%2\", operands);\n+    if (REGNO (operands[0]) != REGNO (operands[1]))\n+        output_asm_insn (\"addk\\t%0,%1,r0\", operands);\n+\n+    output_asm_insn (\"addik\\t%3,%3,-1\", operands);\n+    output_asm_insn (\"bneid\\t%3,.-4\", operands);\n+    return \"addk\\t%0,%0,%0\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+   (set_attr \"mode\"    \"SI\")\n+   (set_attr \"length\"  \"20\")]\n+)\n+\n+(define_insn \"*ashlsi3_with_rotate\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (ashift:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"(INTVAL (operands[2]) > 17 && !optimize_size)\"\n+  {\n+    int i, nshift;\n+    \n+    nshift = INTVAL (operands[2]);\n+    operands[3] = gen_int_mode (0xFFFFFFFF << nshift, SImode);\n+\n+    /* We do one extra shift so that the first bit (carry) coming into the MSB\n+       will be masked out */\n+    output_asm_insn (\"src\\t%0,%1\", operands);\n+    for (i = 0; i < (32 - nshift); i++)\n+       output_asm_insn (\"src\\t%0,%0\", operands);\n+\n+    return \"andi\\t%0,%0,%3\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+  (set_attr \"mode\"     \"SI\")\n+  (set_attr \"length\"   \"80\")]\n+)\n+\n+(define_insn \"*ashlsi_inline\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (ashift:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"\"\n+  {\n+    int i;\n+    int nshift = INTVAL (operands[2]);\n+    if (REGNO (operands[0]) != REGNO (operands[1]))\n+      output_asm_insn (\"addk\\t%0,r0,%1\", operands);\n+    output_asm_insn (\"addk\\t%0,%1,%1\", operands);\n+    for (i = 0; i < (nshift - 2); i++)\n+      output_asm_insn (\"addk\\t%0,%0,%0\", operands);\n+    return \"addk\\t%0,%0,%0\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+  (set_attr \"mode\"     \"SI\")\n+  (set_attr \"length\"   \"124\")]\n+)\n+\n+(define_insn \"*ashlsi_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (ashift:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  {\n+    operands[3] = gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM);\n+    output_asm_insn (\"andi\\t%3,%2,31\", operands);\n+    if (REGNO (operands[0]) != REGNO (operands[1])) \n+      output_asm_insn (\"addk\\t%0,r0,%1\", operands);\n+    /* Exit the loop if zero shift. */\n+    output_asm_insn (\"beqid\\t%3,.+20\", operands);\n+    /* Emit the loop.  */\n+    output_asm_insn (\"addk\\t%0,%0,r0\", operands);\n+    output_asm_insn (\"addik\\t%3,%3,-1\", operands);\n+    output_asm_insn (\"bneid\\t%3,.-4\", operands);\n+    return \"addk\\t%0,%0,%0\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+  (set_attr \"mode\"     \"SI\")\n+  (set_attr \"length\"   \"28\")]\n+)\n+\n+\n+;;----------------------------------------------------------------\n+;; 32-bit right shifts\n+;;----------------------------------------------------------------\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                     (match_operand:SI 2 \"arith_operand\" \"\")))]\n+  \"\"\n+  {\n+    /* Avoid recursion for trivial cases. */\n+    if (!((GET_CODE (operands [2]) == CONST_INT) && (INTVAL (operands[2]) == 1)))\n+      if (microblaze_expand_shift (operands))\n+        DONE;\n+  }\n+)\n+\n+;; Irrespective of if we have a barrel-shifter or not, we want to match \n+;; shifts by 1 with a special pattern. When a barrel shifter is present, \n+;; saves a cycle. If not, allows us to annotate the instruction for delay \n+;; slot optimization\n+(define_insn \"*ashrsi3_byone\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                     (match_operand:SI 2 \"arith_operand\"    \"I\")))] \n+  \"(INTVAL (operands[2]) == 1)\"\n+  \"sra\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")]\n+)\n+\n+;; Barrel shift right logical\n+(define_insn \"*ashrsi3_bshift\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                     (match_operand:SI 2 \"arith_operand\"    \"I,d\")))]\n+  \"TARGET_BARREL_SHIFT\"\n+  \"@\n+  bsrai\\t%0,%1,%2\n+  bsra\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"bshift,bshift\")\n+  (set_attr \"mode\"\t\"SI,SI\")\n+  (set_attr \"length\"\t\"4,4\")]\n+)\n+\n+(define_insn \"*ashrsi_inline\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"\"\n+  {\n+    int i;\n+    int nshift = INTVAL (operands[2]);\n+    if (REGNO (operands[0]) != REGNO (operands[1]))\n+      output_asm_insn (\"addk\\t%0,r0,%1\", operands);\n+    output_asm_insn (\"sra\\t%0,%1\", operands);\n+    for (i = 0; i < (nshift - 2); i++)\n+      output_asm_insn (\"sra\\t%0,%0\", operands);\n+    return \"sra\\t%0,%0\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+  (set_attr \"mode\"     \"SI\")\n+  (set_attr \"length\"   \"124\")]\n+)\n+\n+(define_insn \"*ashlri_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  {\n+    operands[3] = gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM);\n+    output_asm_insn (\"andi\\t%3,%2,31\", operands);\n+    if (REGNO (operands[0]) != REGNO (operands[1])) \n+      output_asm_insn (\"addk\\t%0,r0,%1\", operands);\n+    /* Exit the loop if zero shift. */\n+    output_asm_insn (\"beqid\\t%3,.+20\", operands);\n+    /* Emit the loop.  */\n+    output_asm_insn (\"addk\\t%0,%0,r0\", operands);\n+    output_asm_insn (\"addik\\t%3,%3,-1\", operands);\n+    output_asm_insn (\"bneid\\t%3,.-4\", operands);\n+    return \"sra\\t%0,%0\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+  (set_attr \"mode\"     \"SI\")\n+  (set_attr \"length\"   \"28\")]\n+)\n+\n+;;----------------------------------------------------------------\n+;; 32-bit right shifts (logical)\n+;;----------------------------------------------------------------\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                     (match_operand:SI 2 \"arith_operand\" \"\")))]\n+  \"\"\n+  {\n+    /* Avoid recursion for trivial cases. */\n+    if (!((GET_CODE (operands [2]) == CONST_INT) && (INTVAL (operands[2]) == 1)))\n+      if (microblaze_expand_shift (operands))\n+        DONE;\n+  }\n+)\n+\n+;; Irrespective of if we have a barrel-shifter or not, we want to match \n+;; shifts by 1 with a special pattern. When a barrel shifter is present, \n+;; saves a cycle. If not, allows us to annotate the instruction for delay \n+;; slot optimization\n+(define_insn \"*lshrsi3_byone\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                     (match_operand:SI 2 \"arith_operand\"    \"I\")))] \n+  \"(INTVAL (operands[2]) == 1)\"\n+  \"srl\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")]\n+)\n+\n+;; Barrel shift right logical\n+(define_insn \"*lshrsi3_bshift\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                     (match_operand:SI 2 \"arith_operand\"    \"I,d\")))]\n+  \"TARGET_BARREL_SHIFT\"\n+  \"@\n+  bsrli\\t%0,%1,%2\n+  bsrl\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"bshift,bshift\")\n+  (set_attr \"mode\"\t\"SI,SI\")\n+  (set_attr \"length\"\t\"4,4\")]\n+)\n+\n+(define_insn \"*lshrsi_inline\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"\"\n+  {\n+    int i;\n+    int nshift = INTVAL (operands[2]);\n+    if (REGNO (operands[0]) != REGNO (operands[1]))\n+      output_asm_insn (\"addk\\t%0,r0,%1\", operands);\n+    output_asm_insn (\"srl\\t%0,%1\", operands);\n+    for (i = 0; i < (nshift - 2); i++)\n+      output_asm_insn (\"srl\\t%0,%0\", operands);\n+    return \"srl\\t%0,%0\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+  (set_attr \"mode\"     \"SI\")\n+  (set_attr \"length\"   \"124\")]\n+)\n+\n+(define_insn \"*lshlri_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+       (lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"d\")\n+                   (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  {\n+    operands[3] = gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM);\n+    output_asm_insn (\"andi\\t%3,%2,31\", operands);\n+    if (REGNO (operands[0]) != REGNO (operands[1])) \n+      output_asm_insn (\"addk\\t%0,r0,%1\", operands);\n+    /* Exit the loop if zero shift. */\n+    output_asm_insn (\"beqid\\t%3,.+20\", operands);\n+    /* Emit the loop.  */\n+    output_asm_insn (\"addk\\t%0,%0,r0\", operands);\n+    output_asm_insn (\"addik\\t%3,%3,-1\", operands);\n+    output_asm_insn (\"bneid\\t%3,.-4\", operands);\n+    return \"srl\\t%0,%0\";\n+  }\n+  [(set_attr \"type\"    \"multi\")\n+  (set_attr \"mode\"     \"SI\")\n+  (set_attr \"length\"   \"28\")]\n+)\n+\n+;;----------------------------------------------------------------\n+;; Setting a register from an integer comparison. \n+;;----------------------------------------------------------------\n+(define_expand \"cstoresi4\"\n+   [(set (match_operand:SI 0 \"register_operand\")\n+        (match_operator:SI 1 \"ordered_comparison_operator\"\n+\t      [(match_operand:SI 2 \"register_operand\")\n+\t       (match_operand:SI 3 \"register_operand\")]))]\n+  \"TARGET_PATTERN_COMPARE\"\n+  \"if (GET_CODE (operand1) != EQ && GET_CODE (operand1) != NE) \n+     FAIL;\n+  \"\n+)\n+\n+(define_insn \"seq_internal_pat\" \n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(eq:SI \n+\t       (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"TARGET_PATTERN_COMPARE\"\n+  \"pcmpeq\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")]\n+)              \n+\n+(define_insn \"sne_internal_pat\" \n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ne:SI \n+\t       (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"TARGET_PATTERN_COMPARE\"\n+  \"pcmpne\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")]\n+)              \n+\n+(define_insn \"signed_compare\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec\n+\t\t[(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")] UNSPEC_CMP))]\n+  \"\"\n+  \"cmp\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"unsigned_compare\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec \n+\t\t[(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")] UNSPEC_CMPU))]\n+  \"\"\n+  \"cmpu\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+  (set_attr \"mode\"\t\"SI\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+;;----------------------------------------------------------------\n+;; Setting a register from an floating point comparison. \n+;;----------------------------------------------------------------\n+(define_insn \"cstoresf4\"\n+   [(set (match_operand:SI 0 \"register_operand\")\n+        (match_operator:SI 1 \"ordered_comparison_operator\"\n+\t      [(match_operand:SF 2 \"register_operand\")\n+\t       (match_operand:SF 3 \"register_operand\")]))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fcmp.%C1\\t%0,%3,%2\"\n+  [(set_attr \"type\"     \"fcmp\")\n+   (set_attr \"mode\"      \"SF\")\n+   (set_attr \"length\"    \"4\")]\n+)\n+\n+;;----------------------------------------------------------------\n+;; Conditional branches\n+;;----------------------------------------------------------------\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:SI 1 \"register_operand\")\n+\t\t        (match_operand:SI 2 \"arith_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  microblaze_expand_conditional_branch (SImode, operands);\n+  DONE;\n+})\n+\n+(define_expand \"cbranchsf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:SI 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:SF 1 \"register_operand\")\n+\t\t        (match_operand:SF 2 \"register_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  microblaze_expand_conditional_branch_sf (operands);\n+  DONE;\n+\n+})\n+\n+;; Used to implement comparison instructions\n+(define_expand \"condjump\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 0)\n+\t\t      (label_ref (match_operand 1))\n+\t\t      (pc)))])\n+\n+(define_insn \"branch_zero\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:SI 0 \"ordered_comparison_operator\"\n+  \t\t\t\t [(match_operand:SI 1 \"register_operand\" \"d\")\n+                                  (const_int 0)])\n+                      (match_operand:SI 2 \"pc_or_label_operand\" \"\")\n+                      (match_operand:SI 3 \"pc_or_label_operand\" \"\")))\n+  ]\n+  \"\"\n+  {\n+    if (operands[3] == pc_rtx) \n+      return \"b%C0i%?\\t%z1,%2\";\n+    else \n+      return \"b%N0i%?\\t%z1,%3\";\n+  }\n+  [(set_attr \"type\"\t\"branch\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"4\")]\n+)\n+\n+;;----------------------------------------------------------------\n+;; Unconditional branches\n+;;----------------------------------------------------------------\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  {\n+    if (GET_CODE (operands[0]) == REG)\n+        return \"br%?\\t%0\";\n+    else\t\n+        return \"bri%?\\t%l0\";\n+  }\n+  [(set_attr \"type\"\t\"jump\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"d\"))]\n+  \"\"\n+  {\n+    rtx dest = operands[0];\n+    if (GET_CODE (dest) != REG || GET_MODE (dest) != Pmode)\n+      operands[0] = copy_to_mode_reg (Pmode, dest);\n+\n+    emit_jump_insn (gen_indirect_jump_internal1 (operands[0]));\n+    DONE;\n+  }\n+)\n+\n+;; Indirect jumps. Jump to register values. Assuming absolute jumps\n+\n+(define_insn \"indirect_jump_internal1\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))]\n+  \"\"\n+  \"bra%?\\t%0\"\n+  [(set_attr \"type\"\t\"jump\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_expand \"tablejump\"\n+  [(set (pc)\n+\t(match_operand 0 \"register_operand\" \"d\"))\n+  (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  {\n+    gcc_assert (GET_MODE (operands[0]) == Pmode);\n+\n+    if (!flag_pic)\n+      emit_jump_insn (gen_tablejump_internal1 (operands[0], operands[1]));\n+    else\n+      emit_jump_insn (gen_tablejump_internal3 (operands[0], operands[1]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"tablejump_internal1\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"d\"))\n+  (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"bra%?\\t%0 \"\n+  [(set_attr \"type\"\t\"jump\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_expand \"tablejump_internal3\"\n+  [(parallel [(set (pc)\n+\t\t   (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t    (label_ref:SI (match_operand:SI 1 \"\" \"\"))))\n+             (use (label_ref:SI (match_dup 1)))])]\n+  \"\"\n+  \"\"\n+)\n+\n+;; need to change for MicroBlaze PIC\n+(define_insn \"\"\n+ [(set (pc)\n+\t(plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t (label_ref:SI (match_operand 1 \"\" \"\"))))\n+  (use (label_ref:SI (match_dup 1)))]\n+ \"next_active_insn (insn) != 0\n+  && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n+  && PREV_INSN (next_active_insn (insn)) == operands[1]\n+  && flag_pic\"\n+  {\n+    output_asm_insn (\"addk\\t%0,%0,r20\",operands);\n+    return \"bra%?\\t%0\";\n+}\n+ [(set_attr \"type\"\t\"jump\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_expand \"tablejump_internal4\"\n+  [(parallel [(set (pc)\n+\t\t   (plus:DI (match_operand:DI 0 \"register_operand\" \"d\")\n+\t\t\t    (label_ref:DI (match_operand:SI 1 \"\" \"\"))))\n+             (use (label_ref:DI (match_dup 1)))])]\n+  \"\"\n+  \"\"\n+)\n+\n+;;----------------------------------------------------------------\n+;; Function prologue/epilogue and stack allocation\n+;;----------------------------------------------------------------\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  {\n+      microblaze_expand_prologue ();\n+      DONE;\n+  }\n+)\n+\n+(define_expand \"epilogue\"\n+  [(use (const_int 0))]\n+  \"\"\n+  {\n+      microblaze_expand_epilogue ();\n+      DONE;\n+  }\n+)\n+\n+;; An insn to allocate new stack space for dynamic use (e.g., alloca).\n+;; We copy the return address, decrement the stack pointer and save the \n+;; return address again at the new stack top \n+\n+(define_expand \"allocate_stack\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(minus (reg 1) (match_operand 1 \"register_operand\" \"\")))\n+   (set (reg 1)\n+\t(minus (reg 1) (match_dup 1)))]\n+  \"\"\n+  { \n+    rtx retaddr = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n+    rtx rtmp    = gen_rtx_REG (SImode, R_TMP);\n+    rtx neg_op0;\n+\n+    emit_move_insn (rtmp, retaddr);\n+    if (GET_CODE (operands[1]) != CONST_INT)\n+    {\n+        neg_op0 = gen_reg_rtx (Pmode);\n+\temit_insn (gen_negsi2 (neg_op0, operands[1]));\n+    } else\n+        neg_op0 = GEN_INT (- INTVAL (operands[1]));\n+\n+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, neg_op0));\n+    emit_move_insn (gen_rtx_MEM (Pmode, stack_pointer_rtx), rtmp);\n+    emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n+    emit_insn (gen_rtx_CLOBBER (SImode, rtmp));\n+    DONE;\n+  }\n+)\n+\n+;; Trivial return.  Make it look like a normal return insn as that\n+;; allows jump optimizations to work better .\n+(define_insn \"return\"\n+  [(return)]\n+  \"microblaze_can_use_return_insn ()\"\n+  { \n+    if (microblaze_is_interrupt_handler ())\n+        return \"rtid\\tr14, 0\\;%#\";\n+    else\n+        return \"rtsd\\tr15, 8\\;%#\";\n+  }\n+  [(set_attr \"type\"\t\"jump\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+;; Normal return.\n+;; We match any mode for the return address, so that this will work with\n+;; both 32 bit and 64 bit targets.\n+\n+(define_insn \"return_internal\"\n+  [(parallel [(use (match_operand:SI 0 \"register_operand\" \"\"))\n+              (return)])]\n+  \"\"\n+  {\t\n+    if (microblaze_is_interrupt_handler ())\n+        return \"rtid\\tr14,0 \\;%#\";\n+    else\n+        return \"rtsd\\tr15,8 \\;%#\";\n+  }\n+  [(set_attr \"type\"\t\"jump\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+\n+;; Block any insns from across this point\n+;; Useful to group sequences together.\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\"\t\"unknown\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"0\")])\n+\n+  \n+;;----------------------------------------------------------------\n+;; Function calls\n+;;----------------------------------------------------------------\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand 0 \"memory_operand\" \"m\")\n+\t\t    (match_operand 1 \"\" \"i\"))\n+             (clobber (reg:SI R_SR))\n+             (use (match_operand 2 \"\" \"\"))\n+             (use (match_operand 3 \"\" \"\"))])]\n+  \"\"\n+  {\n+    rtx addr = XEXP (operands[0], 0);\n+\n+    if (flag_pic == 2 && GET_CODE (addr) == SYMBOL_REF \n+\t&& !SYMBOL_REF_LOCAL_P (addr)) \n+      {\n+        rtx temp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_PLT);\n+        XEXP (operands[0], 0) = temp;\n+      }\n+    \n+    if ((GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n+\t|| !call_insn_operand (addr, VOIDmode))\n+      XEXP (operands[0], 0) = copy_to_mode_reg (Pmode, addr);\n+\n+    if (GET_CODE (XEXP (operands[0], 0)) == UNSPEC)\n+      emit_call_insn (gen_call_internal_plt0 (operands[0], operands[1],\n+                        gen_rtx_REG (SImode, \n+\t\t\t\t     GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM),\n+                               \t     pic_offset_table_rtx));\n+    else\n+      emit_call_insn (gen_call_internal0 (operands[0], operands[1],\n+                        gen_rtx_REG (SImode, \n+\t\t\t\t     GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)));\n+\n+        DONE;\n+  }\n+)\n+\n+(define_expand \"call_internal0\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+             (clobber (match_operand:SI 2 \"\" \"\"))])]\n+  \"\"\n+  {\n+  }\n+)\n+ \n+(define_expand \"call_internal_plt0\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+             (clobber (match_operand:SI 2 \"\" \"\"))\n+             (use (match_operand:SI 3 \"\" \"\"))])]\n+  \"\"\n+  {\n+  }\n+)\n+ \n+(define_insn \"call_internal_plt\"\n+  [(call (mem (match_operand:SI 0 \"call_insn_plt_operand\" \"\"))\n+\t (match_operand:SI 1 \"\" \"i\"))\n+  (clobber (reg:SI R_SR))\n+  (use (reg:SI R_GOT))]\n+  \"flag_pic\"\n+  {\n+    register rtx target2 = gen_rtx_REG (Pmode, \n+\t\t\t      GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM);\n+    gen_rtx_CLOBBER (VOIDmode, target2);\n+    return \"brlid\\tr15,%0\\;%#\";\n+  }\n+  [(set_attr \"type\"\t\"call\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"call_internal1\"\n+  [(call (mem (match_operand:SI 0 \"call_insn_operand\" \"ri\"))\n+\t (match_operand:SI 1 \"\" \"i\"))\n+  (clobber (reg:SI R_SR))]\n+  \"\"\n+  {\n+    register rtx target = operands[0];\n+    register rtx target2 = gen_rtx_REG (Pmode,\n+\t\t\t      GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM);\n+    if (GET_CODE (target) == SYMBOL_REF) {\n+        gen_rtx_CLOBBER (VOIDmode, target2);\n+        return \"brlid\\tr15,%0\\;%#\";\n+    } else if (GET_CODE (target) == CONST_INT)\n+        return \"la\\t%@,r0,%0\\;brald\\tr15,%@\\;%#\";\n+    else if (GET_CODE (target) == REG)\n+        return \"brald\\tr15,%0\\;%#\";\t\n+    else {\n+        fprintf (stderr,\"Unsupported call insn\\n\");\n+        return NULL;\n+    }\n+  }\n+  [(set_attr \"type\"\t\"call\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+;; calls.c now passes a fourth argument, make saber happy\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=d\")\n+\t\t   (call (match_operand 1 \"memory_operand\" \"m\")\n+\t\t\t (match_operand 2 \"\" \"i\")))\n+             (clobber (reg:SI R_SR))\n+             (use (match_operand 3 \"\" \"\"))])] ;; next_arg_reg\n+  \"\"\n+  {\n+    rtx addr = XEXP (operands[1], 0);\n+\n+    if (flag_pic == 2 && GET_CODE (addr) == SYMBOL_REF\n+\t&& !SYMBOL_REF_LOCAL_P (addr)) \n+      {\n+        rtx temp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_PLT);\n+        XEXP (operands[1], 0) = temp;\n+      }\n+\n+    if ((GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n+        || !call_insn_operand (addr, VOIDmode))\n+      XEXP (operands[1], 0) = copy_to_mode_reg (Pmode, addr);\n+\n+    if (GET_CODE (XEXP (operands[1], 0)) == UNSPEC)\n+      emit_call_insn (gen_call_value_intern_plt0 (operands[0], operands[1], \n+\t\t\toperands[2],\n+                        gen_rtx_REG (SImode, \n+\t\t\t\t     GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM),\n+\t\t\t\t     pic_offset_table_rtx));\n+    else\n+      emit_call_insn (gen_call_value_internal (operands[0], operands[1], \n+\t\t\toperands[2],\n+                        gen_rtx_REG (SImode, \n+\t\t\t\t     GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM)));\n+\n+    DONE;\n+  }\n+)\n+\n+\n+(define_expand \"call_value_internal\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+             (clobber (match_operand:SI 3 \"\" \"\"))\n+             ])]\n+  \"\"\n+  {}\n+)\n+\n+(define_expand \"call_value_intern_plt0\"\n+  [(parallel[(set (match_operand 0 \"\" \"\")\n+                  (call (match_operand 1 \"\" \"\")\n+                        (match_operand 2 \"\" \"\")))\n+             (clobber (match_operand:SI 3 \"\" \"\"))\n+             (use (match_operand:SI 4 \"\" \"\"))])]\n+  \"flag_pic\"\n+  {}\n+)\n+\n+(define_insn \"call_value_intern_plt\"\n+  [(set (match_operand:VOID 0 \"register_operand\" \"=d\")\n+        (call (mem (match_operand:SI 1 \"call_insn_plt_operand\" \"\"))\n+              (match_operand:SI 2 \"\" \"i\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))\n+   (use (match_operand:SI 4 \"register_operand\"))]\n+  \"flag_pic\"\n+  { \n+    register rtx target2=gen_rtx_REG (Pmode,GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM);\n+\n+    gen_rtx_CLOBBER (VOIDmode,target2);\n+    return \"brlid\\tr15,%1\\;%#\";\n+  }\n+  [(set_attr \"type\"\t\"call\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"call_value_intern\"\n+  [(set (match_operand:VOID 0 \"register_operand\" \"=d\")\n+        (call (mem (match_operand:VOID 1 \"call_insn_operand\" \"ri\"))\n+              (match_operand:SI 2 \"\" \"i\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n+  \"\"\n+  { \n+    register rtx target = operands[1];\n+    register rtx target2=gen_rtx_REG (Pmode,GP_REG_FIRST + MB_ABI_SUB_RETURN_ADDR_REGNUM);\n+\n+    if (GET_CODE (target) == SYMBOL_REF){\n+\tgen_rtx_CLOBBER (VOIDmode,target2);\n+\treturn \"brlid\\tr15,%1\\;%#\";\n+    }\n+    else if (GET_CODE (target) == CONST_INT)\n+        return \"la\\t%@,r0,%1\\;brald\\tr15,%@\\;%#\";\n+    else if (GET_CODE (target) == REG)\n+        return \"brald\\tr15,%1\\;%#\";\t\n+    else \n+        return \"Unsupported call insn\\n\";\n+  }\n+  [(set_attr \"type\"\t\"call\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+\n+;; Call subroutine returning any type.\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+             (match_operand 1 \"\" \"\")\n+             (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  {\n+    if (operands[0])\t\t/* silence statement not reached warnings */\n+    {\n+        int i;\n+\n+        emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+        for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+\t{\n+\t    rtx set = XVECEXP (operands[2], 0, i);\n+\t    emit_move_insn (SET_DEST (set), SET_SRC (set));\n+\t}\n+\n+        emit_insn (gen_blockage ());\n+        DONE;\n+      }\n+  }\n+)\n+\n+;;----------------------------------------------------------------\n+;; Misc.\n+;;----------------------------------------------------------------\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\"\t\"nop\")\n+  (set_attr \"mode\"\t\"none\")\n+  (set_attr \"length\"\t\"4\")])\n+\n+;; The insn to set GOT. The hardcoded number \"8\" accounts for $pc difference\n+;; between \"mfs\" and \"addik\" instructions.\n+(define_insn \"set_got\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+    (unspec:SI [(const_int 0)] UNSPEC_SET_GOT))]\n+  \"\"\n+  \"mfs\\t%0,rpc\\n\\taddik\\t%0,%0,_GLOBAL_OFFSET_TABLE_+8\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"12\")])\n+"}, {"sha": "45b2b170bc943e544f3cba58009cdbe54b764f64", "filename": "gcc/config/microblaze/microblaze.opt", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.opt?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,97 @@\n+; Options for the MicroBlaze port of the compiler\n+;\n+; Copyright 2009, 2010 Free Software Foundation, Inc.\n+;\n+; Contributed by Michael Eager <eager@eagercon.com>.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.  */\n+\n+msoft-float\n+Target Report RejectNegative Mask(SOFT_FLOAT)\n+Use software emulation for floating point (default)\n+\n+mhard-float\n+Target Report RejectNegative InverseMask(SOFT_FLOAT, HARD_FLOAT)\n+Use hardware floating point instructions\n+\n+msmall-divides\n+Target Mask(SMALL_DIVIDES)\n+Use table lookup optimization for small signed integer divisions\n+\n+mcpu=\n+Target RejectNegative Joined Var(microblaze_select_cpu)\n+-mcpu=PROCESSOR\t\tUse features of and schedule code for given CPU\n+\n+mmemcpy\n+Target Mask(MEMCPY)\n+Don't optimize block moves, use memcpy\n+\n+mxl-soft-mul\n+Target Mask(SOFT_MUL)\n+Use the soft multiply emulation (default)\n+\n+mxl-soft-div\n+Target Mask(SOFT_DIV)\n+Use the software emulation for divides (default)\n+\n+mxl-barrel-shift\n+Target Mask(BARREL_SHIFT)\n+Use the hardware barrel shifter instead of emulation\n+\n+mxl-pattern-compare\n+Target Mask(PATTERN_COMPARE)\n+Use pattern compare instructions\n+\n+mxl-stack-check\n+Target Mask(STACK_CHECK)\n+Check for stack overflow at runtime\n+\n+mxl-gp-opt\n+Target Mask(XLGPOPT)\n+Use GP relative sdata/sbss sections\n+\n+mno-clearbss\n+Target RejectNegative\n+Clear the BSS to zero and place zero initialized in BSS\n+\n+mxl-multiply-high\n+Target Mask(MULTIPLY_HIGH)\n+Use multiply high instructions for high part of 32x32 multiply\n+\n+mxl-float-convert\n+Target Mask(FLOAT_CONVERT)\n+Use hardware floating point converstion instructions\n+\n+mxl-float-sqrt\n+Target Mask(FLOAT_SQRT)\n+Use hardware floating point square root instruction\n+\n+mxl-mode-executable\n+Target Mask(XL_MODE_EXECUTABLE)\n+Description for mxl-mode-executable\n+\n+mxl-mode-xmdstub\n+Target Mask(XL_MODE_XMDSTUB)\n+Description for mxl-mode-xmdstub\n+\n+mxl-mode-bootstrap\n+Target Mask(XL_MODE_BOOTSTRAP)\n+Description for mxl-mode-bootstrap\n+\n+mxl-mode-novectors\n+Target Mask(XL_MODE_NOVECTORS)\n+Description for mxl-mode-novectors"}, {"sha": "ea2f1f0805f80c27f18b54aa2cfa0881ad26162f", "filename": "gcc/config/microblaze/predicates.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,64 @@\n+;; Predicate definitions for Xilinx MicroBlaze\n+;; Copyright 2009, 2010 Free Software Foundation, Inc.\n+;;\n+;; Contributed by Michael Eager <eager@eagercon.com>.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  \n+\n+\n+;; Return whether OP can be used as an operands in arithmetic.\n+(define_predicate \"arith_operand\"\n+  (ior (match_code \"const_int,const_double\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"arith_operand32\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int,const_double\")\n+\t    (match_test \"LARGE_INT (op)\"))))\n+\n+(define_predicate \"const_0_operand\"\n+  (and (match_code \"const_int,const_double\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n+;; Return whether OP is a register or the constant 0.\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"const_0_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;;  Return if the operand is either the PC or a label_ref.  \n+(define_special_predicate \"pc_or_label_operand\"\n+  (ior (match_code \"pc,label_ref\")\n+       (and (match_code \"symbol_ref\")\n+            (match_test \"!(strcmp ((XSTR (op, 0)), \\\"_stack_overflow_exit\\\"))\"))))\n+\n+;; Test for valid call operand\n+(define_predicate \"call_insn_operand\"\n+  (match_test \"CALL_INSN_OP (op)\"))\n+\n+;; Return if OPERAND is valid as a source operand for a move instruction.\n+(define_predicate \"move_operand\"\n+  (and (\n+     not (\n+       and (match_code \"plus\")\n+           (not (match_test \"(GET_CODE (XEXP (op, 0)) == REG) ^ (GET_CODE (XEXP (op,1)) == REG)\"))\n+\t )\n+       )\n+       (match_operand 0 \"general_operand\")))\n+\n+;; Test for valid PIC call operand\n+(define_predicate \"call_insn_plt_operand\"\n+  (match_test \"PLT_ADDR_P (op)\"))"}, {"sha": "021dbbe3e76db1f1d300df33bfc2e98f08e99bea", "filename": "gcc/config/microblaze/t-microblaze", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Ft-microblaze", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfig%2Fmicroblaze%2Ft-microblaze", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Ft-microblaze?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,33 @@\n+# For C++ crtstuff\n+EXTRA_MULTILIB_PARTS = crtbegin$(objext) crtend$(objext)\n+\n+EXTRA_PARTS += crti$(objext) crtn$(objext)\n+\n+MULTILIB_OPTIONS = mxl-barrel-shift mno-xl-soft-mul mxl-multiply-high\n+MULTILIB_DIRNAMES = bs m mh\n+MULTILIB_EXCEPTIONS = *mxl-barrel-shift/mxl-multiply-high mxl-multiply-high\n+\n+# Extra files\n+microblaze-c.o: $(srcdir)/config/microblaze/microblaze-c.c \\\n+    $(srcdir)/config/microblaze/microblaze-protos.h \\\n+    $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) $(TM_P_H) $(TREE_H) errors.h $(TM_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t$(srcdir)/config/microblaze/microblaze-c.c\n+\n+# Build soft FP routines. \n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# Assemble startup files\n+$(T)crti$(objext): $(srcdir)/config/microblaze/crti.s\n+\t$(GCC_FOR_TARGET) -c $(srcdir)/config/microblaze/crti.s -o $(T)crti$(objext)\n+\n+$(T)crtn$(objext): $(srcdir)/config/microblaze/crtn.s\n+\t$(GCC_FOR_TARGET) -c $(srcdir)/config/microblaze/crtn.s -o $(T)crtn$(objext)"}, {"sha": "c828627c05e0de7ddb5caf783f2d76b5a821554c", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -24484,7 +24484,7 @@ case \"$target\" in\n   i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* \\\n   | x86_64*-*-* | hppa*-*-* | arm*-*-* \\\n   | xstormy16*-*-* | cris-*-* | crisv32-*-* | xtensa*-*-* | bfin-*-* | score*-*-* \\\n-  | spu-*-* | fido*-*-* | m32c-*-*)\n+  | spu-*-* | fido*-*-* | m32c-*-* | microblaze-*-*)\n     insn=\"nop\"\n     ;;\n   ia64*-*-* | s390*-*-*)"}, {"sha": "0e68b3033f7c3d2e26f1810600f4efea642364f1", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -3745,7 +3745,7 @@ case \"$target\" in\n   i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* \\\n   | x86_64*-*-* | hppa*-*-* | arm*-*-* \\\n   | xstormy16*-*-* | cris-*-* | crisv32-*-* | xtensa*-*-* | bfin-*-* | score*-*-* \\\n-  | spu-*-* | fido*-*-* | m32c-*-*)\n+  | spu-*-* | fido*-*-* | m32c-*-* | microblaze-*-*)\n     insn=\"nop\"\n     ;;\n   ia64*-*-* | s390*-*-*)"}, {"sha": "aae1146ae534175df25632bcbbe5e1e2bb861624", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -238,6 +238,9 @@ architecture, libio maintenance, and early math work.\n @item\n Zdenek Dvorak for a new loop unroller and various fixes.\n \n+@item\n+Michael Eager for his work on the Xilinx MicroBlaze port.\n+\n @item\n Richard Earnshaw for his ongoing work with the ARM@.\n "}, {"sha": "2785553ed8eb7bac5ac5202c90050185a7d40740", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -2534,8 +2534,8 @@ interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute\n is present.\n \n-Note, interrupt handlers for the Blackfin, H8/300, H8/300H, H8S, and\n-SH processors can be specified via the @code{interrupt_handler} attribute.\n+Note, interrupt handlers for the Blackfin, H8/300, H8/300H, H8S, MicroBlaze,\n+and SH processors can be specified via the @code{interrupt_handler} attribute.\n \n Note, on the AVR, interrupts will be enabled inside the function.\n \n@@ -3134,6 +3134,14 @@ Use this attribute on the Blackfin, H8/300, H8/300H, and H8S to indicate that\n all registers except the stack pointer should be saved in the prologue\n regardless of whether they are used or not.\n \n+@item save_volatiles\n+@cindex save volatile registers on the MicroBlaze\n+Use this attribute on the MicroBlaze to indicate that the function is\n+an interrupt handler.  All volatile registers (in addition to non-volatile \n+registers) will be saved in the function prologue.  If the function is a leaf \n+function, only volatiles used by the function are saved.  A normal function \n+return is generated instead of a return from interrupt.  \n+\n @item section (\"@var{section-name}\")\n @cindex @code{section} function attribute\n Normally, the compiler places the code it generates in the @code{text} section."}, {"sha": "f4f4a154399db2448c50c53ad4b6d8be22c130a6", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -2952,6 +2952,8 @@ information are.\n @item\n @uref{#mep-x-elf,,mep-*-elf}\n @item\n+@uref{#microblaze-x-elf,,microblaze-*-elf}\n+@item\n @uref{#mips-x-x,,mips-*-*}\n @item\n @uref{#mips-sgi-irix5,,mips-sgi-irix5}\n@@ -3819,6 +3821,13 @@ original ABI by configuring for @samp{m68k-uclinuxoldabi} or\n Toshiba Media embedded Processor.\n This configuration is intended for embedded systems.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{microblaze-x-elf}microblaze-*-elf\n+Xilinx MicroBlaze processor.\n+This configuration is intended for embedded systems.\n+\n @html\n <hr />\n @end html"}, {"sha": "449bc0c6bbfef33f7f4375b64371a667027946ab", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -683,6 +683,13 @@ Objective-C and Objective-C++ Dialects}.\n -mmult -mno-opts -mrepeat -ms -msatur -msdram -msim -msimnovec -mtf @gol\n -mtiny=@var{n}}\n \n+@emph{MicroBlaze Options}\n+@gccoptlist{-msoft-float -mhard-float -msmall-divides -mcpu=@var{cpu} @gol\n+-mmemcpy -mxl-soft-mul -mxl-soft-div -mxl-barrel-shift @gol\n+-mxl-pattern-compare -mxl-stack-check -mxl-gp-opt -mno-clearbss @gol\n+-mxl-multiply-high -mxl-float-convert -mxl-float-sqrt @gol\n+-mxl-mode-@var{app-model}}\n+\n @emph{MIPS Options}\n @gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol\n -mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2 @gol\n@@ -9828,6 +9835,7 @@ platform.\n * M68hc1x Options::\n * MCore Options::\n * MeP Options::\n+* MicroBlaze Options::\n * MIPS Options::\n * MMIX Options::\n * MN10300 Options::\n@@ -13811,6 +13819,104 @@ register.  The default for this option is 4, but note that there's a\n \n @end table\n \n+@node MicroBlaze Options\n+@subsection MicroBlaze Options\n+@cindex MicroBlaze Options\n+\n+@table @gcctabopt\n+\n+@item -msoft-float\n+@opindex msoft-float\n+Use software emulation for floating point (default).\n+\n+@item -mhard-float\n+@opindex mhard-float\n+Use hardware floating point instructions.\n+\n+@item -mmemcpy\n+@opindex mmemcpy\n+Do not optimize block moves, use @code{memcpy}.\n+\n+@item -mno-clearbss\n+@opindex mno-clearbss\n+This option is deprecated.  Use @option{-fno-zero-initialized-in-bss} instead.\n+\n+@item -mcpu=@var{cpu-type}\n+@opindex mcpu=\n+Use features of and schedule code for given CPU.\n+Supported values are in the format @samp{v@var{X}.@var{YY}.@var{Z}}, \n+where @var{X} is a major version, @var{YY} is the minor version, and \n+@var{Z} is compatiblity code.  Example values are @samp{v3.00.a}, \n+@samp{v4.00.b}, @samp{v5.00.a}, @samp{v5.00.b}, @samp{v5.00.b}, @samp{v6.00.a}. \n+\n+@item -mxl-soft-mul\n+@opindex mxl-soft-mul\n+Use software multiply emulation (default).\n+\n+@item -mxl-soft-div\n+@opindex mxl-soft-div\n+Use software emulation for divides (default).\n+\n+@item -mxl-barrel-shift\n+@opindex mxl-barrel-shift\n+Use the hardware barrel shifter.\n+\n+@item -mxl-pattern-compare\n+@opindex mxl-pattern-compare\n+Use pattern compare instructions.\n+\n+@item -msmall-divides\n+@opindex msmall-divides\n+Use table lookup optimization for small signed integer divisions.\n+\n+@item -mxl-stack-check\n+@opindex mxl-stack-check\n+This option is deprecated.  Use -fstack-check instead.\n+\n+@item -mxl-gp-opt\n+@opindex mxl-gp-opt\n+Use GP relative sdata/sbss sections.\n+\n+@item -mxl-multiply-high\n+@opindex mxl-multiply-high\n+Use multiply high instructions for high part of 32x32 multiply.\n+\n+@item -mxl-float-convert\n+@opindex mxl-float-convert\n+Use hardware floating point converstion instructions.\n+\n+@item -mxl-float-sqrt\n+@opindex mxl-float-sqrt\n+Use hardware floating point square root instruction.\n+\n+@item -mxl-mode-@var{app-model}\n+Select application model @var{app-model}.  Valid models are \n+@table @samp\n+@item executable\n+normal executable (default), uses startup code @file{crt0.o}.\n+\n+@item xmdstub\n+for use with Xilinx Microprocessor Debugger (XMD) based \n+software intrusive debug agent called xmdstub. This uses startup file \n+@file{crt1.o} and sets the start address of the program to be 0x800.\n+\n+@item bootstrap\n+for applications that are loaded using a bootloader.\n+This model uses startup file @file{crt2.o} which does not contain a processor \n+reset vector handler. This is suitable for transferring control on a \n+processor reset to the bootloader rather than the application.\n+\n+@item novectors\n+for applications that do not require any of the \n+MicroBlaze vectors. This option may be useful for applications running\n+within a monitoring application. This model uses @file{crt3.o} as a startup file.\n+@end table\n+\n+Option @option{-xl-mode-@var{app-model}} is a deprecated alias for \n+@option{-mxl-mode-@var{app-model}}.\n+\n+@end table\n+\n @node MIPS Options\n @subsection MIPS Options\n @cindex MIPS options"}, {"sha": "1bbdcd017273909e835e0b75515ea7e514d79493", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -2677,7 +2677,15 @@ A register indirect address without offset.\n @item Z\n Symbolic references to the control bus.\n \n+@end table\n \n+@item MicroBlaze---@file{config/microblaze/constraints.md}\n+@table @code\n+@item d\n+A general register (@code{r0} to @code{r31}).\n+\n+@item z\n+A status register (@code{rmsr}, @code{$fcc1} to @code{$fcc7}).\n \n @end table\n "}, {"sha": "fd164d46872a1c30ea1d0f76b5da7906ee7865a5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -1,3 +1,41 @@\n+2010-09-30  Michael Eager  <eager@eagercon.com>\n+\n+\t* gcc.c-torture/execute/cmpsi-2.c: New testcase.\n+\t* gcc.c-torture/execute/cmpsf-1.c: Ditto.\n+\t* gcc.target/microblaze/microblaze.exp: Ditto.\n+\t* gcc.target/microblaze/others/string_cst1.c: Ditto.\n+\t* gcc.target/microblaze/others/string_cst2.c: Ditto.\n+\t* gcc.target/microblaze/others/data_var1.c: Ditto.\n+\t* gcc.target/microblaze/others/data_var2.c: Ditto.\n+\t* gcc.target/microblaze/others/data_var3.c: Ditto.\n+\t* gcc.target/microblaze/others/string_cst1_gpopt.c:: Ditto.\n+\t* gcc.target/microblaze/others/strings1.c:: Ditto.\n+\t* gcc.target/microblaze/others/string_cst2_gpopt.c: Ditto.\n+\t* gcc.target/microblaze/others/interrupt_handler_leaf.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var1.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var2.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var3.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var4.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var5.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var6.c: Ditto.\n+\t* gcc.target/microblaze/isa/fsqrt.c: Ditto.\n+\t* gcc.target/microblaze/isa/pcmp.c: Ditto.\n+\t* gcc.target/microblaze/isa/nofloat.c: Ditto.\n+\t* gcc.target/microblaze/isa/fcvt.c: Ditto.\n+\t* gcc.target/microblaze/isa/float.c: Ditto.\n+\t* gcc.target/microblaze/isa/mulh.c: Ditto.\n+\t* gcc.target/microblaze/isa/fcmp1.c: Ditto.\n+\t* gcc.target/microblaze/isa/mul-bshift-pcmp.c: Ditto.\n+\t* gcc.target/microblaze/isa/fcmp2.c: Ditto.\n+\t* gcc.target/microblaze/isa/fcmp3.c: Ditto.\n+\t* gcc.target/microblaze/isa/mul-bshift.c: Ditto.\n+\t* gcc.target/microblaze/isa/mulh-bshift-pcmp.c: Ditto.\n+\t* gcc.target/microblaze/isa/bshift.c: Ditto.\n+\t* gcc.target/microblaze/isa/nofcmp.c: Ditto.\n+\t* gcc.target/microblaze/isa/div.c: Ditto.\n+\t* gcc.target/microblaze/isa/vanilla.c: Ditto.\n+\t* gcc.target/microblaze/isa/mul.c: Ditto.\n+\n 2010-09-30  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tmerge from FSF 'apple/trunk' branch.\n@@ -348,6 +386,7 @@\n \tPR fortran/45744\n \t* gfortran.dg/dependency_36.f90:  New test.\n \n+>>>>>>> .r164755\n 2010-09-23  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/pad-1.c: Remove -S from dg-options."}, {"sha": "f5438a171d207a27cfdf59c3fa92c214c822420b", "filename": "gcc/testsuite/gcc.c-torture/execute/cmpsf-1.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcmpsf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcmpsf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcmpsf-1.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,169 @@\n+#include <limits.h>\n+\n+#define F 140\n+#define T 13\n+\n+feq (float x, float y)\n+{\n+  if (x == y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fne (float x, float y)\n+{\n+  if (x != y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+flt (float x, float y)\n+{\n+  if (x < y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fge (float x, float y)\n+{\n+  if (x >= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fgt (float x, float y)\n+{\n+  if (x > y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fle (float x, float y)\n+{\n+  if (x <= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+float args[] =\n+{\n+  0.0F,\n+  1.0F,\n+  -1.0F, \n+  FLOAT_MAX,\n+  FLOAT_MIN,\n+  0.0000000000001F,\n+  123456789.0F,\n+  -987654321.0F\n+};\n+\n+int correct_results[] =\n+{\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, T, F, F, T,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T\n+};\n+\n+int\n+main (void)\n+{\n+  int i, j, *res = correct_results;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      long arg0 = args[i];\n+      for (j = 0; j < 8; j++)\n+\t{\n+\t  long arg1 = args[j];\n+\n+\t  if (feq (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fne (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (flt (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fge (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fgt (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fle (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fltu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fgeu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fgtu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fleu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t}\n+    }\n+  exit (0);\n+}"}, {"sha": "cf58b9e7f935b779e95341f1c4446a1c75fdd024", "filename": "gcc/testsuite/gcc.c-torture/execute/cmpsi-2.c", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcmpsi-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcmpsi-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcmpsi-2.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,199 @@\n+#define F 140\n+#define T 13\n+\n+feq (long x, long y)\n+{\n+  if (x == y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fne (long x, long y)\n+{\n+  if (x != y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+flt (long x, long y)\n+{\n+  if (x < y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fge (long x, long y)\n+{\n+  if (x >= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fgt (long x, long y)\n+{\n+  if (x > y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fle (long x, long y)\n+{\n+  if (x <= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fltu (long x, long y)\n+{\n+  if (x < y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fgeu (long x, long y)\n+{\n+  if (x >= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fgtu (long x, long y)\n+{\n+  if (x > y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fleu (long x, long y)\n+{\n+  if (x <= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+long args[] =\n+{\n+  0L,\n+  1L,\n+  -1L,\n+  0x7fffffffL,\n+  0x80000000L,\n+  0x80000001L,\n+  0x1A3F2373L,\n+  0x93850E92L\n+};\n+\n+int correct_results[] =\n+{\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, T, F, F, T,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  T, F, F, T, F, T, F, T, F, T,\n+  F, T, F, T, T, F, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, T, F, F, T, T, F, F, T,\n+  F, T, T, F, F, T, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, F, T, T, F, F, T, T, F,\n+  F, T, T, F, F, T, F, T, T, F,\n+  T, F, F, T, F, T, F, T, F, T\n+};\n+\n+int\n+main (void)\n+{\n+  int i, j, *res = correct_results;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      long arg0 = args[i];\n+      for (j = 0; j < 8; j++)\n+\t{\n+\t  long arg1 = args[j];\n+\n+\t  if (feq (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fne (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (flt (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fge (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fgt (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fle (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fltu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fgeu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fgtu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fleu (arg0, arg1) != *res++)\n+\t    abort ();\n+\t}\n+    }\n+  exit (0);\n+}"}, {"sha": "64cf1e2e59e0a4f2d206235d2b6df0a3ab830c26", "filename": "gcc/testsuite/gcc.target/microblaze/isa/bshift.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fbshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fbshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fbshift.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mxl-barrel-shift\" } */\n+\n+volatile int m1, m2, m3;\n+volatile unsigned int u1, u2, u3;\n+volatile long l1, l2;\n+volatile long long llp;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler-not \"mul\\tr\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler-not \"muli\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler-not \"mulh\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhu\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhsu\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler \"bslli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler \"bsll\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler \"bsrai\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler \"bsra\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler-not \"pcmpne\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler-not \"pcmpeq\" } } */\n+    return (m1 == m2);\n+\n+}\n+"}, {"sha": "25ee42ce5c8d0be61ed0aa30be45a902bc13abe8", "filename": "gcc/testsuite/gcc.target/microblaze/isa/div.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fdiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fdiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fdiv.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mno-xl-soft-div\" } */\n+\n+volatile int m1, m2, m3;\n+volatile long l1, l2;\n+volatile long long llp;\n+volatile unsigned int u1, u2, u3;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler-not \"mul\\tr\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler-not \"muli\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler-not \"mulh\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhu\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhsu\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler-not \"bslli\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsll\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler-not \"bsrai\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsra\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler-not \"pcmpne\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler-not \"pcmpeq\" } } */\n+    return (m1 == m2);\n+}\n+"}, {"sha": "4041a2413918cd7e141d1c47dbc0b189880ab120", "filename": "gcc/testsuite/gcc.target/microblaze/isa/fcmp1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp1.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mhard-float\" } */\n+\n+volatile float f1, f2, f3;\n+\n+void float_func () \n+{\n+  /* { dg-final { scan-assembler \"fcmp\\.(le|gt)\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    if (f2 <= f3) \n+        print (\"le\");\n+}"}, {"sha": "3902b839db914876eeb6951dbbecfbc30170864d", "filename": "gcc/testsuite/gcc.target/microblaze/isa/fcmp2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp2.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mhard-float\" } */\n+\n+volatile float f1, f2, f3;\n+\n+void float_func () \n+{\n+  /* { dg-final { scan-assembler \"fcmp\\.(lt|ge)\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    if (f2 < f3) \n+        print (\"lt\");\n+}"}, {"sha": "8555974dda5cf63da8fc522af8f4ba4afea97c86", "filename": "gcc/testsuite/gcc.target/microblaze/isa/fcmp3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcmp3.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mhard-float\" } */\n+\n+volatile float f1, f2, f3;\n+\n+void float_func () \n+{\n+  /* { dg-final { scan-assembler \"fcmp\\.(eq|ne)\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    if (f2 == f3) \n+        print (\"eq\");\n+}"}, {"sha": "ee057c1b6ac2844fc56112516dbec78a7c18d850", "filename": "gcc/testsuite/gcc.target/microblaze/isa/fcvt.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffcvt.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mhard-float -mxl-float-convert\" } */\n+\n+int float_func (float f) \n+{\n+  /* { dg-final { scan-assembler \"flt\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+   return f;\n+}\n+\n+\n+float int_func (int i) \n+{\n+  /* { dg-final { scan-assembler \"fint\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+   return i;\n+}\n+\n+\n+float uint_func (unsigned int i) \n+{\n+  /* { dg-final { scan-assembler \"fint\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+   return i;\n+}"}, {"sha": "f5ef3186cdd800e0e18306d22420b72fc3cbd9ed", "filename": "gcc/testsuite/gcc.target/microblaze/isa/float.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffloat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffloat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffloat.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mhard-float\" } */\n+\n+volatile float f1, f2, f3;\n+\n+void float_func () \n+{\n+  /* { dg-final { scan-assembler \"fmul\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    f1 = f2 * f3;\n+\n+  /* { dg-final { scan-assembler \"fadd\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    f1 = f2 + f3;\n+\n+  /* { dg-final { scan-assembler \"frsub\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    f1 = f2 - f3;\n+\n+  /* { dg-final { scan-assembler \"fdiv\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    f1 = f2 / f3;\n+}"}, {"sha": "4c2466e4a555d84d6f343a15bbeebaa0bbc4528a", "filename": "gcc/testsuite/gcc.target/microblaze/isa/fsqrt.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffsqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffsqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Ffsqrt.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mhard-float -mxl-float-sqrt\" } */\n+#include <math.h>\n+\n+float sqrt_func (float f) \n+{\n+  /* { dg-final { scan-assembler \"fsqrt\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    return sqrtf (f);\n+}\n+\n+"}, {"sha": "ce186314e6a1d03cc52bc38647a40011d2038a8d", "filename": "gcc/testsuite/gcc.target/microblaze/isa/mul-bshift-pcmp.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul-bshift-pcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul-bshift-pcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul-bshift-pcmp.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mxl-barrel-shift -mno-xl-soft-mul -mxl-pattern-compare\" } */\n+\n+volatile int m1, m2, m3;\n+volatile unsigned int u1, u2, u3;\n+volatile long l1, l2;\n+volatile long long llp;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler \"mul\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler \"muli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),(0x\\[0-9a-fA-F]+|\\[+-]*\\[0-9]+)\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler-not \"mulh\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhu\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhsu\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler \"bslli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler \"bsll\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler \"bsrai\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler \"bsra\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler \"pcmpne\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler \"pcmpeq\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    return (m1 == m2);\n+\n+}\n+"}, {"sha": "76d174ec7c3c96b480a2b7d60325b55b3b99ebc0", "filename": "gcc/testsuite/gcc.target/microblaze/isa/mul-bshift.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul-bshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul-bshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul-bshift.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mxl-barrel-shift -mno-xl-soft-mul\" } */\n+\n+volatile int m1, m2, m3;\n+volatile unsigned int u1, u2, u3;\n+volatile long l1, l2;\n+volatile long long llp;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler \"mul\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler \"muli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),(0x\\[0-9a-fA-F]+|\\[+-]*\\[0-9]+)\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler-not \"mulh\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhu\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhsu\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler \"bslli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler \"bsll\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler \"bsrai\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler \"bsra\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler-not \"pcmpne\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler-not \"pcmpeq\" } } */\n+    return (m1 == m2);\n+\n+}\n+"}, {"sha": "d2a6bec61e2ac7cc42197353d0716a84cfcb757a", "filename": "gcc/testsuite/gcc.target/microblaze/isa/mul.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmul.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mno-xl-soft-mul\" } */\n+\n+volatile int m1, m2, m3;\n+volatile long l1, l2;\n+volatile long long llp;\n+volatile unsigned int u1, u2, u3;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler \"mul\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler \"muli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),(0x\\[0-9a-fA-F]+|\\[+-]*\\[0-9]+)\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler-not \"mulh\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhu\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhsu\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler-not \"bslli\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsll\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler-not \"bsrai\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsra\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler-not \"pcmpne\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler-not \"pcmpeq\" } } */\n+    return (m1 == m2);\n+}\n+"}, {"sha": "a15983af117945ce7a22f5ea814200fa1ae20e9e", "filename": "gcc/testsuite/gcc.target/microblaze/isa/mulh-bshift-pcmp.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmulh-bshift-pcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmulh-bshift-pcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmulh-bshift-pcmp.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mxl-barrel-shift -mno-xl-soft-mul -mxl-pattern-compare -mxl-multiply-high\" } */\n+\n+volatile int m1, m2, m3;\n+volatile unsigned int u1, u2, u3;\n+volatile long l1, l2;\n+volatile long long llp;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler \"mul\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler \"muli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),(0x\\[0-9a-fA-F]+|\\[+-]*\\[0-9]+)\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler \"mulh\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    llp = (long long)l1 * l2;\n+\n+  /* { dg-final { scan-assembler \"mulhu\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    ullp = (unsigned long long)ul1 * ul2;\n+\n+  /* { dg-final { scan-assembler \"mulhsu\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    llp = (long long)l1 * ul2;        \n+\n+  /* { dg-final { scan-assembler \"bslli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler \"bsll\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler \"bsrai\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),25\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler \"bsra\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler \"pcmpne\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler \"pcmpeq\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    return (m1 == m2);\n+\n+}\n+"}, {"sha": "6e0cc3ac4708498674b20e3d6dcaee31a1ac93bc", "filename": "gcc/testsuite/gcc.target/microblaze/isa/mulh.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmulh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmulh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fmulh.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mno-xl-soft-mul -mxl-multiply-high\" } */\n+\n+volatile int m1, m2, m3;\n+volatile unsigned int u1, u2, u3;\n+volatile long l1, l2;\n+volatile long long llp;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler \"mul\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler \"muli\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),(0x\\[0-9a-fA-F]+|\\[+-]*\\[0-9]+)\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler \"mulh\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler \"mulhu\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler \"mulhsu\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1])\\[^0-9]\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler-not \"bslli\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsll\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler-not \"bsrai\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsra\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler-not \"pcmpne\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler-not \"pcmpeq\" } } */\n+    return (m1 == m2);\n+\n+}\n+"}, {"sha": "ebfb170ecee56f9831135f1e98c8f1b09fbd14ea", "filename": "gcc/testsuite/gcc.target/microblaze/isa/nofcmp.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fnofcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fnofcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fnofcmp.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a \" } */\n+\n+volatile float f1, f2, f3;\n+\n+void float_func () \n+{\n+    /* { dg-final { scan-assembler-not \"fcmp\" } } */\n+    if (f2 <= f3) \n+        print (\"le\");\n+    else if (f2 == f3) \n+        print (\"eq\");\n+    else if (f2 < f3) \n+        print (\"lt\");\n+    else if (f2 > f3) \n+        print (\"gt\");\n+    else if (f2 >= f3) \n+        print (\"ge\");\n+    else if (f2 != f3) \n+        print (\"ne\");\n+    \n+}"}, {"sha": "647da3cfe240020b9b174b3ef9b10a8a3f264800", "filename": "gcc/testsuite/gcc.target/microblaze/isa/nofloat.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fnofloat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fnofloat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fnofloat.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -msoft-float\" } */\n+\n+volatile float f1, f2, f3;\n+\n+void float_func () \n+{\n+  /* { dg-final { scan-assembler-not \"fmul\" } } */\n+    f1 = f2 * f3;\n+\n+  /* { dg-final { scan-assembler-not \"fadd\" } } */\n+    f1 = f2 + f3;\n+\n+  /* { dg-final { scan-assembler-not \"frsub\" } } */\n+    f1 = f2 - f3;\n+\n+  /* { dg-final { scan-assembler-not \"fdiv\" } } */\n+    f1 = f2 / f3;\n+\n+}"}, {"sha": "aea79572103c0afea949b33b16c9c01b7995532c", "filename": "gcc/testsuite/gcc.target/microblaze/isa/pcmp.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fpcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fpcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fpcmp.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mxl-pattern-compare\" } */\n+\n+volatile int m1, m2, m3;\n+volatile long l1, l2;\n+volatile long long llp;\n+volatile unsigned int u1, u2, u3;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler-not \"mul\\tr\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler-not \"muli\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler-not \"mulh\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhu\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhsu\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler-not \"bslli\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsll\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler-not \"bsrai\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsra\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler \"pcmpne\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler \"pcmpeq\" } } */\n+    return (m1 == m2);\n+}\n+"}, {"sha": "1d6ba807b12f11db449cc8da6b5ec4b932c6a650", "filename": "gcc/testsuite/gcc.target/microblaze/isa/vanilla.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fvanilla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fvanilla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fisa%2Fvanilla.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-options \"-O3 -mcpu=v6.00.a -mcpu=v6.00.a\" } */\n+\n+volatile int m1, m2, m3;\n+volatile long l1, l2;\n+volatile long long llp;\n+volatile unsigned int u1, u2, u3;\n+\n+volatile unsigned long ul1, ul2;\n+volatile unsigned long long ullp;\n+\n+int test_mul () {\n+\n+  /* { dg-final { scan-assembler-not \"mul\\tr\" } } */\n+    m1 = m2 * m3 ;\n+\n+  /* { dg-final { scan-assembler-not \"muli\" } } */\n+    m3 = m1 * 1234 ;    \n+\n+  /* { dg-final { scan-assembler-not \"mulh\" } } */\n+    llp = ((long long)l1 * l2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhu\" } } */\n+    ullp = ((unsigned long long)ul1 * ul2);\n+\n+  /* { dg-final { scan-assembler-not \"mulhsu\" } } */\n+    llp = ((long long)l1 * ul2);        \n+\n+  /* { dg-final { scan-assembler-not \"bslli\" } } */\n+    m3 = m2 << 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsll\" } } */\n+    m2 = m1 << m3;\n+\n+  /* { dg-final { scan-assembler-not \"bsrai\" } } */\n+    m3 = m2 >> 25;\n+\n+  /* { dg-final { scan-assembler-not \"bsra\" } } */\n+    m2 = m1 >> m3;\n+\n+  /* { dg-final { scan-assembler-not \"idiv\" } } */\n+    m1 = m2 / m1;\n+\n+  /* { dg-final { scan-assembler-not \"idivu\" } } */\n+    u1 = u2 / u3;    \n+\n+  /* { dg-final { scan-assembler-not \"pcmpne\" } } */\n+    m3 = (m3 != m1);\n+\n+  /* { dg-final { scan-assembler-not \"pcmpeq\" } } */\n+    return (m1 == m2);\n+}\n+\n+\n+\n+volatile float f1, f2, f3;\n+\n+void float_func () \n+{\n+  /* { dg-final { scan-assembler-not \"fmul\" } } */\n+    f1 = f2 * f3;\n+\n+  /* { dg-final { scan-assembler-not \"fadd\" } } */\n+    f1 = f2 + f3;\n+\n+  /* { dg-final { scan-assembler-not \"frsub\" } } */\n+    f1 = f2 - f3;\n+\n+  /* { dg-final { scan-assembler-not \"fdiv\" } } */\n+    f1 = f2 / f3;\n+\n+}\n+\n+void float_cmp_func () \n+{\n+    /* { dg-final { scan-assembler-not \"fcmp\" } } */\n+    if (f2 <= f3) \n+        print (\"le\");\n+    else if (f2 == f3) \n+        print (\"eq\");\n+    else if (f2 < f3) \n+        print (\"lt\");\n+    else if (f2 > f3) \n+        print (\"gt\");\n+    else if (f2 >= f3) \n+        print (\"ge\");\n+    else if (f2 != f3) \n+        print (\"ne\");\n+    \n+}"}, {"sha": "a8994e91f1c9c30663f7e56cf003f4367c8ffc9d", "filename": "gcc/testsuite/gcc.target/microblaze/microblaze.exp", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fmicroblaze.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fmicroblaze.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fmicroblaze.exp?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,62 @@\n+#   Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+# MicroBlaze test driver that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't a MicroBlaze target.\n+if { ![istarget microblaze*-*-*] } then {\n+  return\n+}\n+\n+# Don't execute when we are testing some configuration of GCC or G++.\n+# This we figure out by looking at target_config_cflags which needs to be \"\" for microblaze.exp\n+if { $target_config_cflags != \"\" } {\n+  return \n+}\n+\n+global TORTURE_OPTIONS\n+set TORTURE_OPTIONS [list \\\n+                         { -O0 } \\\n+                         { -O1 } \\\n+                         { -O2 } \\\n+                         { -O3 } \\\n+                         { -Os } ]\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+set default_c_flags \"\" \n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/isa/*.\\[cSi\\]]] \\\n+${default_c_flags} \"\"\n+\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/others/*.\\[cSi\\]]] \\\n+    \"-mcpu=v6.00.a\" \n+\n+\n+# All done.\n+dg-finish"}, {"sha": "15b85ca7780835c5743580f07ccafc9fce4cc976", "filename": "gcc/testsuite/gcc.target/microblaze/others/data_var1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var1.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-final { scan-assembler \"\\.bss*\" } } */\n+int global;\n+\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r0\" } } */\n+    return global;\n+}"}, {"sha": "9fb7347bab4cd67815e506dd5e507cc20a94dfea", "filename": "gcc/testsuite/gcc.target/microblaze/others/data_var2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var2.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-final { scan-assembler \"\\.data*\" } } */\n+int global = 10;\n+\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r0\" } } */\n+    return global;\n+}"}, {"sha": "2b3f064108b1c350e5c1cbb8629b04ad2f9722a5", "filename": "gcc/testsuite/gcc.target/microblaze/others/data_var3.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var3.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-final { scan-assembler \"\\.rodata*\" } } */\n+const int global = 10;\n+\n+int testfunc ()\n+{\n+    return global;\n+}"}, {"sha": "9d068d05e073e56f82cd621cc40905ff8d97b534", "filename": "gcc/testsuite/gcc.target/microblaze/others/interrupt_handler_leaf.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Finterrupt_handler_leaf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Finterrupt_handler_leaf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Finterrupt_handler_leaf.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,10 @@\n+int leaf_func () __attribute__ ((interrupt_handler));\n+volatile int intr_occurred;\n+\n+int leaf_func ()\n+{\n+\n+  /* { dg-final { scan-assembler \"rtid\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),0\" } } */\n+  /* { dg-final { scan-assembler-not \"rtsd\" } } */    \n+    intr_occurred += 1;\n+}"}, {"sha": "2337f5a1e78671d359426b2bafdb29391b6ff3ec", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var1.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-mxl-gp-opt\" } */\n+\n+/* { dg-final { scan-assembler \"\\.sbss\\[^2]+\" } } */\n+typedef int Boolean;\n+volatile Boolean global = 0;\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    return global;\n+}\n+\n+int main ()\n+{\n+\n+}"}, {"sha": "1c91d004305f39a5848e7393778090fe000a39cc", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var2.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-mxl-gp-opt\" } */\n+\n+/* { dg-final { scan-assembler \"\\.sdata\\[^2]+\" } } */\n+int global = 10;\n+\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    return global;\n+}"}, {"sha": "07c80041c72e0395a0a7204a0fec871402f26a12", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var3.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-mxl-gp-opt\" } */\n+\n+extern int a;\n+\n+/* { dg-final { scan-assembler \"\\.sdata2\" } } */\n+const int global1 = 10;\n+extern const int global2;\n+\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r2\" } } */\n+    return global2 + global1;\n+}"}, {"sha": "4dfa337d53844cc160100da2723775998779042a", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var4.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-mxl-gp-opt -G 16\" } */\n+\n+/* { dg-final { scan-assembler \"\\.sbss\\[^2]+\" } } */\n+struct test_s {\n+    int a;\n+    int b;\n+    int c;\n+    int d;\n+} global; \n+\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    return global.a;\n+}"}, {"sha": "5c61962bf4e28d282bc93374d7170407cfdbb0db", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var5.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-mxl-gp-opt -G 16\" } */\n+\n+/* { dg-final { scan-assembler \"\\.sdata\\[^2]+\" } } */\n+struct test_s {\n+    int a;\n+    int b;\n+    int c;\n+    int d;\n+} global = { 1, 2, 3, 4 }; \n+\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    return global.a;\n+}"}, {"sha": "0c8fe431f5d0f8a1ee5675ececed358bc2b23dbe", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var6.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-mxl-gp-opt -G 16\" } */\n+\n+struct test_s {\n+    int a;\n+    int b;\n+    int c;\n+    int d;\n+};\n+\n+/* { dg-final { scan-assembler \"\\.sdata2\" } } */\n+const struct test_s global1 = { 1, 2, 3, 4};\n+extern const struct test_s global2;\n+\n+int testfunc ()\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r2\" } } */\n+    return global2.a + global1.a;\n+}"}, {"sha": "2a74f4ce721ce7b83b97b585015525b0fd33e23a", "filename": "gcc/testsuite/gcc.target/microblaze/others/string_cst1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,12 @@\n+#include <string.h>\n+\n+/* { dg-final { scan-assembler \"\\.rodata*\" } } */\n+/* { dg-final { scan-assembler \"\\.data*\" } } */\n+\n+char *string1 = \"string1\";\n+\n+int testfunc (char *cptr)\n+{\n+/* { dg-final { scan-assembler-not \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    strcpy (string1, cptr);\n+}"}, {"sha": "5b5d3db18df502637ea491de119cbcd835ed4348", "filename": "gcc/testsuite/gcc.target/microblaze/others/string_cst1_gpopt.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1_gpopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1_gpopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1_gpopt.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-mxl-gp-opt\" } */\n+\n+#include <string.h>\n+\n+/* { dg-final { scan-assembler \"\\.rodata*\" } } */\n+/* { dg-final { scan-assembler \"\\.sdata\\[^2]+\" } } */\n+char *string1 = \"string1\";\n+\n+int testfunc (char *cptr)\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    strcpy (string1, cptr);\n+}"}, {"sha": "c375339dcd13e23ca188b6438e2d3077690a55b7", "filename": "gcc/testsuite/gcc.target/microblaze/others/string_cst2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,13 @@\n+#include <string.h>\n+\n+/* { dg-final { scan-assembler \"\\.rodata*\" } } */\n+/* { dg-final { scan-assembler \"\\.data*\" } } */\n+const char *string1 = \"string1\";\n+\n+char* testfunc (char *cptr)\n+{\n+/* { dg-final { scan-assembler-not \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    strcpy (cptr, string1);\n+\n+    return cptr;\n+}"}, {"sha": "057e8c4479bb247dc683cfccac0801b02e5b7ed4", "filename": "gcc/testsuite/gcc.target/microblaze/others/string_cst2_gpopt.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2_gpopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2_gpopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2_gpopt.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-mxl-gp-opt\" } */\n+\n+#include <string.h>\n+\n+/* { dg-final { scan-assembler \"\\.rodata*\" } } */\n+/* { dg-final { scan-assembler \"\\.sdata\\[^2]+\" } } */\n+const char *string1 = \"string1\";\n+\n+char* testfunc (char *cptr)\n+{\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r13\" } } */\n+    strcpy (cptr, string1);\n+\n+    return cptr;\n+}"}, {"sha": "7a63faf79f22768ac279bd0ae074d8c6703713e1", "filename": "gcc/testsuite/gcc.target/microblaze/others/strings1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstrings1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstrings1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstrings1.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-O3\" } */\n+\n+#include <string.h>\n+\n+/* { dg-final { scan-assembler \"\\.rodata*\" } } */\n+extern void somefunc (char *);\n+int testfunc ()\n+{\n+    char string2[80];\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r0,.LC*\" } } */    \n+    strcpy (string2, \"hello\");\n+    somefunc (string2);\n+}"}, {"sha": "f51809630154ab372ce140d130e50280ac9827b2", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -1,3 +1,10 @@\n+2010-09-30  Michael Eager  <eager@eagercon.com>\n+\n+\t* config.host: Add microblaze*-*-*.\n+\t* config/microblaze/{divsi3.asm,divsi3_table.c,moddi3.asm,modsi3.asm,\n+\tmuldi3_hard.asm,mulsi3.asm,stack_overflow_exit.asm,t-microblaze,\n+\tudivsi3.asm,umodsi3.asm}:  New.\n+\n 2010-09-28  Ian Lance Taylor  <iant@google.com>\n \n \t* configure.ac: Adjust CFI test to test assembler directly rather\n@@ -22,6 +29,7 @@\n \t* config.host (i[34567]86-*-linux* and friends): Add t-stack and\n \ti386/t-stack-i386 to tmake_file.\n \n+>>>>>>> .r164755\n 2010-09-21  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* Makefile.in (libgcc-extra-parts):  Check for static archives and"}, {"sha": "f2d1983c87435b30c709d15f6395b6fc71346572", "filename": "libgcc/config.host", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -107,6 +107,9 @@ m68k-*-*)\n \t;;\n mep*-*-*)\n \t;;\n+microblaze*-*-*)\n+\tcpu_type=microblaze\n+\t;;\n mips*-*-*)\n \tcpu_type=mips\n \t;;\n@@ -399,6 +402,9 @@ mcore-*-elf)\n \t;;\n mcore-*-pe*)\n \t;;\n+microblaze*-*-*)\n+        tmake_file=\"microblaze/t-microblaze\"\n+\t;;\n mips-sgi-irix[56]*)\n \t;;\n mips*-*-netbsd*)\t\t\t# NetBSD/mips, either endian."}, {"sha": "7d888b32e8d6e3ccf43556e5a30460a2c2ab50c2", "filename": "libgcc/config/microblaze/divsi3.asm", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fdivsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fdivsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fdivsi3.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,96 @@\n+###################################-\n+# \n+#  Copyright 2009, 2010 Free Software Foundation, Inc.\n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>. \n+#\n+#  divsi3.asm \n+# \n+#  Divide operation for 32 bit integers.\n+#\tInput :\tDividend in Reg r5\n+#\t\tDivisor in Reg r6\n+#\tOutput: Result in Reg r3\n+# \n+#######################################\n+\t\n+\t.globl\t__divsi3\n+\t.ent\t__divsi3\n+\t.type\t__divsi3,@function\n+__divsi3:\n+\t.frame\tr1,0,r15\t\n+\n+\tADDIK   r1,r1,-16\n+\tSWI     r28,r1,0\n+\tSWI     r29,r1,4\n+\tSWI     r30,r1,8\n+\tSWI     r31,r1,12\n+\n+\tBEQI    r6,$LaDiv_By_Zero       # Div_by_Zero   # Division Error\n+\tBEQI    r5,$LaResult_Is_Zero    # Result is Zero \n+\tBGEID   r5,$LaR5_Pos \n+\tXOR     r28,r5,r6               # Get the sign of the result\n+\tRSUBI   r5,r5,0                 # Make r5 positive\n+$LaR5_Pos:\n+\tBGEI    r6,$LaR6_Pos\n+\tRSUBI   r6,r6,0                 # Make r6 positive\n+$LaR6_Pos:\n+\tADDIK   r30,r0,0                # Clear mod\n+\tADDIK   r3,r0,0                 # clear div\n+\tADDIK   r29,r0,32               # Initialize the loop count\n+\n+        # First part try to find the first '1' in the r5\n+$LaDIV0: \n+        BLTI    r5,$LaDIV2              # This traps r5 == 0x80000000 \n+$LaDIV1:\n+\tADD     r5,r5,r5                # left shift logical r5\n+\tBGTID   r5,$LaDIV1       \n+\tADDIK   r29,r29,-1\n+$LaDIV2:\n+\tADD     r5,r5,r5                # left shift logical  r5 get the '1' into the Carry\n+\tADDC    r30,r30,r30             # Move that bit into the Mod register\n+\tRSUB    r31,r6,r30              # Try to subtract (r30 a r6)\n+\tBLTI    r31,$LaMOD_TOO_SMALL\n+\tOR      r30,r0,r31              # Move the r31 to mod since the result was positive\n+\tADDIK   r3,r3,1\n+$LaMOD_TOO_SMALL:\n+\tADDIK   r29,r29,-1\n+\tBEQi    r29,$LaLOOP_END\n+\tADD     r3,r3,r3                # Shift in the '1' into div\n+\tBRI     $LaDIV2                 # Div2\n+$LaLOOP_END:\n+\tBGEI    r28,$LaRETURN_HERE\n+\tBRID    $LaRETURN_HERE\n+\tRSUBI   r3,r3,0                 # Negate the result\n+$LaDiv_By_Zero:\n+$LaResult_Is_Zero:\n+\tOR      r3,r0,r0 # set result to 0\n+$LaRETURN_HERE:\n+# Restore values of CSRs and that of r3 and the divisor and the dividend\n+\tLWI     r28,r1,0\n+\tLWI     r29,r1,4\n+\tLWI     r30,r1,8\n+\tLWI     r31,r1,12\n+\tRTSD    r15,8\n+\tADDIK   r1,r1,16\n+.end __divsi3\n+\t.size\t__divsi3, . - __divsi3\n+"}, {"sha": "d37f2aee57ce80897d11403343fad39266848301", "filename": "libgcc/config/microblaze/divsi3_table.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fdivsi3_table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fdivsi3_table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fdivsi3_table.c?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,62 @@\n+/*  Table for software lookup divide for Xilinx MicroBlaze.\n+ \n+   Copyright 2009, 2010 Free Software Foundation, Inc.\n+\n+   Contributed by Michael Eager <eager@eagercon.com>.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+ \n+unsigned char _divsi3_table[] =\n+{\n+       0,   0/1,   0/2,   0/3,   0/4,   0/5,   0/6,   0/7, \n+     0/8,   0/9,  0/10,  0/11,  0/12,  0/13,  0/14,  0/15,\n+       0,   1/1,   1/2,   1/3,   1/4,   1/5,   1/6,   1/7, \n+     1/8,   1/9,  1/10,  1/11,  1/12,  1/13,  1/14,  1/15,\n+       0,   2/1,   2/2,   2/3,   2/4,   2/5,   2/6,   2/7, \n+     2/8,   2/9,  2/10,  2/11,  2/12,  2/13,  2/14,  2/15,\n+       0,   3/1,   3/2,   3/3,   3/4,   3/5,   3/6,   3/7, \n+     3/8,   3/9,  3/10,  3/11,  3/12,  3/13,  3/14,  3/15,\n+       0,   4/1,   4/2,   4/3,   4/4,   4/5,   4/6,   4/7, \n+     4/8,   4/9,  4/10,  4/11,  4/12,  4/13,  4/14,  4/15,\n+       0,   5/1,   5/2,   5/3,   5/4,   5/5,   5/6,   5/7, \n+     5/8,   5/9,  5/10,  5/11,  5/12,  5/13,  5/14,  5/15,\n+       0,   6/1,   6/2,   6/3,   6/4,   6/5,   6/6,   6/7, \n+     6/8,   6/9,  6/10,  6/11,  6/12,  6/13,  6/14,  6/15,\n+       0,   7/1,   7/2,   7/3,   7/4,   7/5,   7/6,   7/7, \n+     7/8,   7/9,  7/10,  7/11,  7/12,  7/13,  7/14,  7/15,\n+       0,   8/1,   8/2,   8/3,   8/4,   8/5,   8/6,   8/7, \n+     8/8,   8/9,  8/10,  8/11,  8/12,  8/13,  8/14,  8/15,\n+       0,   9/1,   9/2,   9/3,   9/4,   9/5,   9/6,   9/7, \n+     9/8,   9/9,  9/10,  9/11,  9/12,  9/13,  9/14,  9/15,\n+       0,  10/1,  10/2,  10/3,  10/4,  10/5,  10/6,  10/7, \n+    10/8,  10/9, 10/10, 10/11, 10/12, 10/13, 10/14, 10/15,\n+       0,  11/1,  11/2,  11/3,  11/4,  11/5,  11/6,  11/7, \n+    11/8,  11/9, 11/10, 11/11, 11/12, 11/13, 11/14, 11/15,\n+       0,  12/1,  12/2,  12/3,  12/4,  12/5,  12/6,  12/7, \n+    12/8,  12/9, 12/10, 12/11, 12/12, 12/13, 12/14, 12/15,\n+       0,  13/1,  13/2,  13/3,  13/4,  13/5,  13/6,  13/7, \n+    13/8,  13/9, 13/10, 13/11, 13/12, 13/13, 13/14, 13/15,\n+       0,  14/1,  14/2,  14/3,  14/4,  14/5,  14/6,  14/7, \n+    14/8,  14/9, 14/10, 14/11, 14/12, 14/13, 14/14, 14/15,\n+       0,  15/1,  15/2,  15/3,  15/4,  15/5,  15/6,  15/7, \n+    15/8,  15/9, 15/10, 15/11, 15/12, 15/13, 15/14, 15/15,\n+};\n+"}, {"sha": "4923b45ffeb602a230dfbdd8fa655db35d7ac4c6", "filename": "libgcc/config/microblaze/moddi3.asm", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmoddi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmoddi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fmoddi3.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,115 @@\n+###################################\n+# \n+#  Copyright 2009, 2010 Free Software Foundation, Inc.\n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>. \n+#\n+#  modsi3.asm \n+# \n+#  modulo operation for 64 bit integers.\n+# \n+#######################################\n+\n+\n+\t.globl\t__moddi3\n+\t.ent\t__moddi3\n+__moddi3:\n+\t.frame\tr1,0,r15\t\n+\n+#Change the stack pointer value and Save callee saved regs\n+\taddik\tr1,r1,-24\n+\tswi\tr25,r1,0\n+\tswi\tr26,r1,4\n+\tswi\tr27,r1,8\t# used for sign\n+\tswi\tr28,r1,12\t# used for loop count\n+\tswi\tr29,r1,16\t# Used for div value High\n+\tswi\tr30,r1,20\t# Used for div value Low\n+\n+#Check for Zero Value in the divisor/dividend\n+\tOR\tr9,r5,r6\t\t\t# Check for the op1 being zero\n+\tBEQID\tr9,$LaResult_Is_Zero\t\t# Result is zero\n+\tOR\tr9,r7,r8\t\t\t# Check for the dividend being zero\n+\tBEQI\tr9,$LaDiv_By_Zero\t        # Div_by_Zero   # Division Error\n+\tBGEId\tr5,$La1_Pos \n+\tXOR\tr27,r5,r7\t\t\t# Get the sign of the result\n+\tRSUBI\tr6,r6,0\t\t\t\t# Make dividend positive\n+\tRSUBIC\tr5,r5,0\t\t\t\t# Make dividend positive\n+$La1_Pos:\n+\tBGEI\tr7,$La2_Pos\n+\tRSUBI\tr8,r8,0\t\t\t\t# Make Divisor Positive\n+\tRSUBIC\tr9,r9,0\t\t\t\t# Make Divisor Positive\n+$La2_Pos:\n+\tADDIK\tr4,r0,0\t\t\t\t# Clear mod low\n+\tADDIK\tr3,r0,0                \t        # Clear mod high\n+\tADDIK\tr29,r0,0\t\t\t# clear div high\n+\tADDIK\tr30,r0,0\t\t\t# clear div low\n+\tADDIK\tr28,r0,64\t\t\t# Initialize the loop count\n+   # First part try to find the first '1' in the r5/r6\n+$LaDIV1:\n+\tADD\tr6,r6,r6\n+\tADDC\tr5,r5,r5\t\t\t# left shift logical r5\n+\tBGEID\tr5,$LaDIV1\t\t\t\n+\tADDIK\tr28,r28,-1\n+$LaDIV2:\n+\tADD\tr6,r6,r6\n+\tADDC\tr5,r5,r5\t# left shift logical r5/r6 get the '1' into the Carry\n+\tADDC\tr4,r4,r4\t# Move that bit into the Mod register\n+\tADDC\tr3,r3,r3\t# Move carry into high mod register\n+\trsub\tr18,r7,r3\t# Compare the High Parts of Mod and Divisor\n+\tbnei\tr18,$L_High_EQ\n+\trsub\tr18,r6,r4\t# Compare Low Parts only if Mod[h] == Divisor[h]\n+$L_High_EQ:\t\n+\trSUB\tr26,r8,r4\t# Subtract divisor[L] from Mod[L]\n+\trsubc\tr25,r7,r3\t# Subtract divisor[H] from Mod[H]\n+\tBLTi\tr25,$LaMOD_TOO_SMALL\n+\tOR\tr3,r0,r25\t# move r25 to mod [h]\n+\tOR\tr4,r0,r26\t# move r26 to mod [l]\n+\tADDI\tr30,r30,1\n+\tADDC\tr29,r29,r0\n+$LaMOD_TOO_SMALL:\n+\tADDIK\tr28,r28,-1\n+\tBEQi\tr28,$LaLOOP_END\n+\tADD\tr30,r30,r30\t\t# Shift in the '1' into div [low]\n+\tADDC\tr29,r29,r29\t\t# Move the carry generated into high\n+\tBRI\t$LaDIV2   # Div2\n+$LaLOOP_END:\n+\tBGEI\tr27,$LaRETURN_HERE\n+\trsubi\tr30,r30,0\n+\trsubc\tr29,r29,r0\n+\tBRI\t$LaRETURN_HERE\n+$LaDiv_By_Zero:\n+$LaResult_Is_Zero:\n+\tor\tr29,r0,r0\t# set result to 0 [High]\n+\tor\tr30,r0,r0\t# set result to 0 [Low]\n+$LaRETURN_HERE:\n+# Restore values of CSRs and that of r29 and the divisor and the dividend\n+\t\n+\tlwi\tr25,r1,0\n+\tlwi\tr26,r1,4\n+\tlwi\tr27,r1,8\n+\tlwi\tr28,r1,12\n+\tlwi\tr29,r1,16\n+\tlwi\tr30,r1,20\n+\trtsd\tr15,8\n+\taddik r1,r1,24\n+        .end __moddi3\n+\t"}, {"sha": "cae95c8bc6393e2c845079518474add102b9010b", "filename": "libgcc/config/microblaze/modsi3.asm", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmodsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmodsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fmodsi3.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,93 @@\n+###################################\n+# \n+#  Copyright 2009, 2010 Free Software Foundation, Inc.\n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>. \n+# \n+#  modsi3.asm \n+# \n+#  modulo operation for 32 bit integers.\n+#\tInput :\top1 in Reg r5\n+#\t\top2 in Reg r6\n+#\tOutput: op1 mod op2 in Reg r3\n+# \n+#######################################\n+\n+\t.globl\t__modsi3\n+\t.ent\t__modsi3\n+\t.type\t__modsi3,@function\n+__modsi3:\n+\t.frame\tr1,0,r15\t\n+\n+\taddik\tr1,r1,-16\n+\tswi\tr28,r1,0\n+\tswi\tr29,r1,4\n+\tswi\tr30,r1,8\n+\tswi\tr31,r1,12\n+\n+\tBEQI\tr6,$LaDiv_By_Zero       # Div_by_Zero   # Division Error\n+\tBEQI\tr5,$LaResult_Is_Zero    # Result is Zero \n+\tBGEId\tr5,$LaR5_Pos \n+\tADD\tr28,r5,r0               # Get the sign of the result [ Depends only on the first arg]\n+\tRSUBI\tr5,r5,0\t                # Make r5 positive\n+$LaR5_Pos:\n+\tBGEI\tr6,$LaR6_Pos\n+\tRSUBI\tr6,r6,0\t    # Make r6 positive\n+$LaR6_Pos:\n+\tADDIK\tr3,r0,0      # Clear mod\n+\tADDIK\tr30,r0,0     # clear div\n+\tADDIK\tr29,r0,32    # Initialize the loop count\n+   # First part try to find the first '1' in the r5\n+$LaDIV1:\n+\tADD\tr5,r5,r5         # left shift logical r5\n+\tBGEID\tr5,$LaDIV1       #\n+\tADDIK\tr29,r29,-1\n+$LaDIV2:\n+\tADD\tr5,r5,r5         # left shift logical  r5 get the '1' into the Carry\n+\tADDC\tr3,r3,r3         # Move that bit into the Mod register\n+\trSUB\tr31,r6,r3        # Try to subtract (r30 a r6)\n+\tBLTi\tr31,$LaMOD_TOO_SMALL\n+\tOR\tr3,r0,r31       # Move the r31 to mod since the result was positive\n+\tADDIK\tr30,r30,1\n+$LaMOD_TOO_SMALL:\n+\tADDIK\tr29,r29,-1\n+\tBEQi\tr29,$LaLOOP_END\n+\tADD\tr30,r30,r30         # Shift in the '1' into div\n+\tBRI\t$LaDIV2          # Div2\n+$LaLOOP_END:\n+\tBGEI\tr28,$LaRETURN_HERE\n+\tBRId\t$LaRETURN_HERE\n+\trsubi\tr3,r3,0 # Negate the result\n+$LaDiv_By_Zero:\n+$LaResult_Is_Zero:\n+\tor\tr3,r0,r0        # set result to 0 [Both mod as well as div are 0]\n+$LaRETURN_HERE:\n+# Restore values of CSRs and that of r3 and the divisor and the dividend\n+\tlwi\tr28,r1,0\n+\tlwi\tr29,r1,4\n+\tlwi\tr30,r1,8\n+\tlwi\tr31,r1,12\n+\trtsd\tr15,8\n+\taddik\tr1,r1,16\n+        .end __modsi3\n+\t.size\t__modsi3, . - __modsi3\n+"}, {"sha": "0499e2a550bbe617048688e028ef89d84d3fc39b", "filename": "libgcc/config/microblaze/muldi3_hard.asm", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmuldi3_hard.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmuldi3_hard.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fmuldi3_hard.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,144 @@\n+###################################- \n+# \n+#  Copyright 2009, 2010 Free Software Foundation, Inc.\n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>. \n+# \n+#  muldi3_hard.asm \n+# \n+#  Multiply operation for 64 bit integers, for devices with hard multiply\n+#\tInput :\tOperand1[H] in Reg r5\n+#\t\tOperand1[L] in Reg r6\t\t\n+#\t\tOperand2[H] in Reg r7\n+#\t\tOperand2[L] in Reg r8\t\n+#\tOutput: Result[H] in Reg r3\n+#\t\tResult[L] in Reg r4\t\n+# \n+#  Explaination:\n+#\n+# \tBoth the input numbers are divided into 16 bit number as follows\n+#\t\top1 = A B C D\n+# \t\top2 = E F G H\n+#\tresult =    D * H \n+#\t\t + (C * H + D * G) << 16\n+#\t\t + (B * H + C * G + D * F) << 32\n+#\t\t + (A * H + B * G + C * F + D * E) << 48 \n+#\n+# \tOnly 64 bits of the output are considered\n+#\n+#######################################\n+\n+\t.globl\tmuldi3_hardproc\n+\t.ent\tmuldi3_hardproc\n+muldi3_hardproc:\n+\taddi\tr1,r1,-40\n+\n+#  Save the input operands on the caller's stack\n+\tswi\tr5,r1,44\n+\tswi\tr6,r1,48\n+\tswi\tr7,r1,52\n+\tswi\tr8,r1,56\n+\n+# Store all the callee saved registers \n+\tsw\tr20,r1,r0\n+\tswi\tr21,r1,4\n+\tswi\tr22,r1,8\n+\tswi\tr23,r1,12\n+\tswi\tr24,r1,16\n+\tswi\tr25,r1,20\n+\tswi\tr26,r1,24\n+\tswi\tr27,r1,28\n+\n+# Load all the 16 bit values for A thru H\n+\tlhui\tr20,r1,44   # A\n+\tlhui\tr21,r1,46   # B\n+\tlhui\tr22,r1,48   # C\n+\tlhui\tr23,r1,50   # D\n+\tlhui\tr24,r1,52   # E\n+\tlhui\tr25,r1,54   # F\n+\tlhui\tr26,r1,56   # G\n+\tlhui\tr27,r1,58   # H\n+\n+# D * H ==> LSB of the result on stack ==> Store1\n+\tmul\tr9,r23,r27\n+\tswi\tr9,r1,36    # Pos2 and Pos3\n+\n+# Hi (Store1) + C * H + D * G ==> Store2 ==> Pos1 and Pos2\n+# Store the carry generated in position 2 for Pos 3\n+\tlhui\tr11,r1,36   # Pos2\n+\tmul\tr9,r22,r27   # C * H\n+\tmul\tr10,r23,r26  # D * G\n+\tadd\tr9,r9,r10\n+\taddc\tr12,r0,r0\n+\tadd\tr9,r9,r11\n+\taddc\tr12,r12,r0    # Store the Carry\n+\tshi\tr9,r1,36    # Store Pos2\n+\tswi\tr9,r1,32 \n+\tlhui\tr11,r1,32\n+\tshi\tr11,r1,34   # Store Pos1\n+\n+# Hi (Store2) + B * H + C * G + D * F ==> Store3 ==> Pos0 and Pos1\n+\tmul\tr9,r21,r27  # B * H\n+\tmul\tr10,r22,r26 # C * G\n+\tmul\tr7,r23,r25 # D * F\t\n+\tadd\tr9,r9,r11\n+\tadd\tr9,r9,r10\n+\tadd\tr9,r9,r7\n+\tswi\tr9,r1,32   # Pos0 and Pos1\n+\n+# Hi (Store3) + A * H + B * G + C * F + D * E ==> Store3 ==> Pos0\n+\tlhui\tr11,r1,32  # Pos0\n+\tmul\tr9,r20,r27  # A * H\n+\tmul\tr10,r21,r26 # B * G\n+\tmul\tr7,r22,r25 # C * F\n+\tmul\tr8,r23,r24 # D * E\n+\tadd\tr9,r9,r11\n+\tadd \tr9,r9,r10\n+\tadd\tr9,r9,r7\n+\tadd\tr9,r9,r8\n+\tsext16\tr9,r9       # Sign extend the MSB\n+\tshi\tr9,r1,32\n+\n+# Move results to r3 and r4\n+\tlhui\tr3,r1,32\n+\tadd\tr3,r3,r12\n+\tshi\tr3,r1,32\n+\tlwi\tr3,r1,32  # Hi Part\n+\tlwi\tr4,r1,36  # Lo Part\n+\n+# Restore Callee saved registers\n+\tlw\tr20,r1,r0\n+\tlwi\tr21,r1,4\n+\tlwi\tr22,r1,8\n+\tlwi\tr23,r1,12\n+\tlwi\tr24,r1,16\n+\tlwi\tr25,r1,20\n+\tlwi\tr26,r1,24\n+\tlwi\tr27,r1,28\n+\n+# Restore Frame and return\t\n+\trtsd\tr15,8\n+\taddi\tr1,r1,40\n+\n+.end muldi3_hardproc \n+\t\n+"}, {"sha": "03fe0288df8668efd741e6f22547a10d2470c473", "filename": "libgcc/config/microblaze/mulsi3.asm", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmulsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fmulsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fmulsi3.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,69 @@\n+###################################-*-asm*- \n+# \n+#  Copyright 2009, 2010 Free Software Foundation, Inc.\n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>. \n+# \n+#  mulsi3.asm \n+# \n+#  Multiply operation for 32 bit integers.\n+#\tInput :\tOperand1 in Reg r5\n+#\t\tOperand2 in Reg r6\n+#\tOutput: Result [op1 * op2] in Reg r3\n+# \n+#######################################\n+\n+\t.globl\t__mulsi3\n+\t.ent\t__mulsi3\n+\t.type\t__mulsi3,@function\n+__mulsi3:\n+\t.frame\tr1,0,r15\n+\tadd\tr3,r0,r0\n+\tBEQI\tr5,$L_Result_Is_Zero      # Multiply by Zero\n+\tBEQI\tr6,$L_Result_Is_Zero      # Multiply by Zero\n+\tBGEId\tr5,$L_R5_Pos \n+\tXOR\tr4,r5,r6                  # Get the sign of the result\n+\tRSUBI\tr5,r5,0\t                  # Make r5 positive\n+$L_R5_Pos:\n+\tBGEI\tr6,$L_R6_Pos\n+\tRSUBI\tr6,r6,0\t                  # Make r6 positive\n+$L_R6_Pos:\t\n+\tbri\t$L1\n+$L2:\t\n+\tadd\tr5,r5,r5\n+$L1:\t\n+\tsrl\tr6,r6\n+\taddc\tr7,r0,r0\n+\tbeqi\tr7,$L2\n+\tbneid\tr6,$L2\n+\tadd\tr3,r3,r5\t\n+\tblti\tr4,$L_NegateResult\t\t\t\n+\trtsd\tr15,8\n+\tnop\n+$L_NegateResult:\n+\trtsd\tr15,8\n+\trsub\tr3,r3,r0\n+$L_Result_Is_Zero:\n+\trtsd\tr15,8\n+\taddi\tr3,r0,0\n+\t.end __mulsi3\n+\t.size\t__mulsi3, . - __mulsi3"}, {"sha": "30b31f0a5bac3244adf05d464018d360a8e09307", "filename": "libgcc/config/microblaze/stack_overflow_exit.asm", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fstack_overflow_exit.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fstack_overflow_exit.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fstack_overflow_exit.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,61 @@\n+###################################-*-asm*- \n+# \n+#    Copyright 2009 Free Software Foundation, Inc.\n+# \n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>.  \n+# \n+#  stack_overflow_exit.asm\n+# \n+#  Checks for stack overflows and sets the global variable \n+#  stack_overflow_error with the value of current stack pointer\n+#\n+#  This routine exits from the program\n+# \n+#######################################\n+\n+\t.globl\t_stack_overflow_error\n+\t.data\n+\t.align\t2\n+\t.type\t_stack_overflow_error,@object\n+\t.size\t_stack_overflow_error,4\n+_stack_overflow_error:\n+\t.data32\t0\n+\n+\t.text \n+\t.globl\t_stack_overflow_exit\t\n+\t.ent\t_stack_overflow_exit\n+\t.type\t_stack_overflow_exit,@function\n+\n+_stack_overflow_exit:\n+#ifdef __PIC__\n+\tmfs\tr20,rpc\n+\taddik\tr20,r20,_GLOBAL_OFFSET_TABLE_+8\n+\tswi\tr1,r20,_stack_overflow_error@GOTOFF\n+\tbri\texit@PLT\n+#else\n+\tswi\tr1,r0,_stack_overflow_error\n+\tbri\texit\n+#endif\n+\n+\t.end \t_stack_overflow_exit\n+\t.size\t_stack_overflow_exit,. - _stack_overflow_exit"}, {"sha": "85fc8d39d8a2fd84b7e6b36af0feda1750b308e4", "filename": "libgcc/config/microblaze/t-microblaze", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Ft-microblaze", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Ft-microblaze", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Ft-microblaze?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,12 @@\n+LIB2ADD += \\\n+        $(srcdir)/config/microblaze/divsi3.asm \\\n+        $(srcdir)/config/microblaze/moddi3.asm \\\n+        $(srcdir)/config/microblaze/modsi3.asm \\\n+        $(srcdir)/config/microblaze/muldi3_hard.asm \\\n+        $(srcdir)/config/microblaze/mulsi3.asm \\\n+        $(srcdir)/config/microblaze/stack_overflow_exit.asm \\\n+        $(srcdir)/config/microblaze/udivsi3.asm \\\n+        $(srcdir)/config/microblaze/umodsi3.asm \\\n+        $(srcdir)/config/microblaze/divsi3_table.c\n+\n+MULTILIB_OPTIONS = mxl-barrel-shift mno-xl-soft-mul mxl-multiply-high"}, {"sha": "879cd349ca7eee8e70ae17c4d343f806b0d2dc87", "filename": "libgcc/config/microblaze/udivsi3.asm", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fudivsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fudivsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fudivsi3.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,103 @@\n+###################################-\n+# \n+#  Copyright 2009, 2010 Free Software Foundation, Inc.\n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>. \n+# \n+#  udivsi3.asm \n+# \n+#  Unsigned divide operation.\n+#\tInput :\tDivisor in Reg r5\n+#\t\tDividend in Reg r6\n+#\tOutput: Result in Reg r3\n+# \n+#######################################\n+\t\n+\t.globl\t__udivsi3\n+\t.ent\t__udivsi3\n+\t.type\t__udivsi3,@function\n+__udivsi3:\n+\t.frame\tr1,0,r15\t\n+\n+\tADDIK   r1,r1,-12\n+    \tSWI     r29,r1,0\n+\tSWI     r30,r1,4\n+\tSWI     r31,r1,8\n+\n+\tBEQI    r6,$LaDiv_By_Zero           # Div_by_Zero   # Division Error\n+\tBEQID   r5,$LaResult_Is_Zero        # Result is Zero \n+\tADDIK   r30,r0,0                    # Clear mod\n+\tADDIK   r29,r0,32                   # Initialize the loop count\n+\n+        # Check if r6 and r5 are equal # if yes, return 1\n+\tRSUB \tr18,r5,r6\n+\tBEQID\tr18,$LaRETURN_HERE\n+\tADDIK\tr3,r0,1\n+\n+        # Check if (uns)r6 is greater than (uns)r5. In that case, just return 0\n+\tXOR\tr18,r5,r6\n+\tBGEID\tr18,16\n+\tADD\tr3,r0,r0                    # We would anyways clear r3\n+\tBLTI\tr6,$LaRETURN_HERE           # r6[bit 31 = 1] hence is greater\n+\tBRI\t$LCheckr6\n+\tRSUB\tr18,r6,r5                   # MICROBLAZEcmp\n+\tBLTI\tr18,$LaRETURN_HERE\n+\n+        # If r6 [bit 31] is set, then return result as 1\n+$LCheckr6:\n+\tBGTI\tr6,$LaDIV0\n+\tBRID\t$LaRETURN_HERE\n+\tADDIK\tr3,r0,1\n+\n+        # First part try to find the first '1' in the r5\n+$LaDIV0:\n+\tBLTI    r5,$LaDIV2\t\n+$LaDIV1:\n+\tADD     r5,r5,r5                    # left shift logical r5\n+\tBGTID   r5,$LaDIV1       \n+\tADDIK   r29,r29,-1\n+$LaDIV2:\n+\tADD     r5,r5,r5                    # left shift logical  r5 get the '1' into the Carry\n+\tADDC    r30,r30,r30                 # Move that bit into the Mod register\n+\tRSUB    r31,r6,r30                  # Try to subtract (r30 a r6)\n+    \tBLTI    r31,$LaMOD_TOO_SMALL\n+\tOR      r30,r0,r31                  # Move the r31 to mod since the result was positive\n+\tADDIK   r3,r3,1\n+$LaMOD_TOO_SMALL:\n+\tADDIK   r29,r29,-1\n+\tBEQi    r29,$LaLOOP_END\n+\tADD     r3,r3,r3 # Shift in the '1' into div\n+\tBRI     $LaDIV2   # Div2\n+$LaLOOP_END:\n+\tBRI     $LaRETURN_HERE\n+$LaDiv_By_Zero:\n+$LaResult_Is_Zero:\n+\tOR      r3,r0,r0 # set result to 0\n+$LaRETURN_HERE:\n+        # Restore values of CSRs and that of r3 and the divisor and the dividend\n+\tLWI     r29,r1,0\n+\tLWI     r30,r1,4\n+\tLWI     r31,r1,8\n+\tRTSD    r15,8\n+\tADDIK   r1,r1,12\n+        .end __udivsi3\n+\t.size\t__udivsi3, . - __udivsi3"}, {"sha": "f7fd00879659410e8a657a0b2ebbe2cdcdebfd93", "filename": "libgcc/config/microblaze/umodsi3.asm", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fumodsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libgcc%2Fconfig%2Fmicroblaze%2Fumodsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmicroblaze%2Fumodsi3.asm?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,106 @@\n+###################################\n+# \n+#  Copyright 2009, 2010 Free Software Foundation, Inc.\n+#\n+#  Contributed by Michael Eager <eager@eagercon.com>.\n+#\n+#  This file is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by the\n+#  Free Software Foundation; either version 3, or (at your option) any\n+#  later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#  License for more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>. \n+# \n+#  umodsi3.asm \n+#\n+#  Unsigned modulo operation for 32 bit integers.\n+#\tInput :\top1 in Reg r5\n+#\t\top2 in Reg r6\n+#\tOutput: op1 mod op2 in Reg r3\n+# \n+#######################################\n+\t\n+\t.globl\t__umodsi3\n+\t.ent\t__umodsi3\n+\t.type\t__umodsi3,@function\n+__umodsi3:\n+\t.frame\tr1,0,r15\t\n+\n+\taddik\tr1,r1,-12\n+\tswi\tr29,r1,0\n+\tswi\tr30,r1,4\n+\tswi\tr31,r1,8\n+\n+\tBEQI\tr6,$LaDiv_By_Zero         # Div_by_Zero   # Division Error\n+\tBEQId\tr5,$LaResult_Is_Zero     # Result is Zero \n+\tADDIK \tr3,r0,0                  # Clear div\n+\tADDIK \tr30,r0,0     \t# clear mod\n+\tADDIK \tr29,r0,32       # Initialize the loop count\n+\n+# Check if r6 and r5 are equal # if yes, return 0\n+\trsub \tr18,r5,r6\n+\tbeqi\tr18,$LaRETURN_HERE\n+\n+# Check if (uns)r6 is greater than (uns)r5. In that case, just return r5\n+\txor\tr18,r5,r6\n+\tbgeid\tr18,16\n+\taddik\tr3,r5,0\n+\tblti\tr6,$LaRETURN_HERE\n+\tbri\t$LCheckr6\n+\trsub\tr18,r5,r6 # MICROBLAZEcmp\n+\tbgti\tr18,$LaRETURN_HERE\n+\n+# If r6 [bit 31] is set, then return result as r5-r6\n+$LCheckr6:\n+\tbgtid\tr6,$LaDIV0\n+\taddik\tr3,r0,0\n+\taddik\tr18,r0,0x7fffffff\n+\tand\tr5,r5,r18\n+\tand \tr6,r6,r18\n+\tbrid\t$LaRETURN_HERE\n+\trsub\tr3,r6,r5\n+# First part: try to find the first '1' in the r5\n+$LaDIV0:\n+\tBLTI\tr5,$LaDIV2\n+$LaDIV1:\n+\tADD \tr5,r5,r5     # left shift logical r5\n+\tBGEID \tr5,$LaDIV1   #\n+\tADDIK \tr29,r29,-1\n+$LaDIV2:\n+\tADD \tr5,r5,r5     # left shift logical  r5 get the '1' into the Carry\n+\tADDC \tr3,r3,r3     # Move that bit into the Mod register\n+\trSUB \tr31,r6,r3    # Try to subtract (r3 a r6)\n+\tBLTi \tr31,$LaMOD_TOO_SMALL\n+\tOR  \tr3,r0,r31    # Move the r31 to mod since the result was positive\n+\tADDIK \tr30,r30,1\n+$LaMOD_TOO_SMALL:\n+\tADDIK \tr29,r29,-1\n+\tBEQi \tr29,$LaLOOP_END\n+\tADD \tr30,r30,r30 # Shift in the '1' into div\n+\tBRI \t$LaDIV2     # Div2\n+$LaLOOP_END:\n+\tBRI \t$LaRETURN_HERE\n+$LaDiv_By_Zero:\n+$LaResult_Is_Zero:\n+\tor \tr3,r0,r0   # set result to 0\n+$LaRETURN_HERE:\n+# Restore values of CSRs and that of r3 and the divisor and the dividend\n+\tlwi \tr29,r1,0\n+\tlwi \tr30,r1,4\n+\tlwi \tr31,r1,8\n+\trtsd \tr15,8\n+\taddik \tr1,r1,12\n+.end __umodsi3\n+\t.size\t__umodsi3, . - __umodsi3"}, {"sha": "8e98ba074b58fbc50b756b5f52a16e94e7f7a880", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -1,3 +1,8 @@\n+2010-09-30  Michael Eager  <eager@eagercon.com>\n+\n+\t* config/cpu/microblaze/cpu_defines.h: New. Define\n+\t_GLIBCXX_NO_VERBOSE_TERMINATE for MicroBlaze.\n+\n 2010-09-29  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/Makefile.am: Add debug/forward_list.\n@@ -75,6 +80,7 @@\n \t* configure: Regenerate.\n \t* include/Makefile.in: Likewise.\n \n+>>>>>>> .r164755\n 2010-09-22  David Krauss  <potswa@mac.com>\n \n \tPR libstdc++/45628"}, {"sha": "452e6d84d9c9bb361d9cb60539e2191bad975856", "filename": "libstdc++-v3/config/cpu/microblaze/cpu_defines.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809201325afb3d70e517d30a483b39251b1b6e27/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fmicroblaze%2Fcpu_defines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809201325afb3d70e517d30a483b39251b1b6e27/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fmicroblaze%2Fcpu_defines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fmicroblaze%2Fcpu_defines.h?ref=809201325afb3d70e517d30a483b39251b1b6e27", "patch": "@@ -0,0 +1,34 @@\n+// Specific definitions for Xilinx MicroBlaze platforms  -*- C++ -*-\n+\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+//\n+// Contributed by Michael Eager <eager@eagercon.com>.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_CPU_DEFINES\n+#define _GLIBCXX_CPU_DEFINES 1\n+\n+// Optimize memory size for embedded systems\n+//   -- Use abort for eh terminate\n+#define _GLIBCXX_NO_VERBOSE_TERMINATE 1\n+\n+#endif"}]}