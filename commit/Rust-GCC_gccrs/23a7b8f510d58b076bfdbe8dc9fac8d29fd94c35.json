{"sha": "23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNhN2I4ZjUxMGQ1OGIwNzZiZmRiZThkYzlmYWM4ZDI5ZmQ5NGMzNQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-07T15:43:15Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-07T15:43:15Z"}, "message": "constants.c (find_methodref_index): When the class is an interface...\n\na\n\t* constants.c (find_methodref_index):  When the class is an interface,\n\tgenerate CONSTANT_InterfaceMethodref instead of a CONSTANT_MethodRef.\n\t* decl.c (finit_identifier_node):  Use \"$finit$\", rather than\n\t\"<finit>\" (which Sun's verifier rejects).\n\t* parse.y (maybe_generate_finit):  Leave out meaningless final flag.\n\t(generate_field_initialization_code):  Removed.\n\t(fix_constructors)  Don't add call to $finit$ here (wrong order).\n\t(patch_method_invocation):  Add $finit$ call here.\n\t* java-tree.h (CALL_USING_SUPER):  New macro.\n\t* parse.y (patch_invoke):  Remove im local variable.\n \t(patch_method_invocation, patch_invoke):  Don't pass super parameter.\n\t(patch_invoke):  Use CALL_USING_SUPER instead of from_super parameter.\n\t(resolve_qualified_expression_name):  Maybe set CALL_USING_SUPER.\n\t* jcf-write.c (get_access_flags):  Fix typo ACC_PUBLIC -> ACC_FINAL.\n\t* parse.y (java_complete_tree):  Don't complain about unreachable\n\tstatement if it is empty_stmt_node.\n\t* jcf-write.c (find_constant_wide):  New function.\n\t(push_long_const):  Use find_constant_wide.\n\t* jcf-write.c (generate_bytecode_insn):  Fix bug in switch handling.\n\t(generate_bytecode_insn):  Use correct dup variant for MODIFY_EXPR.\n\tAdd \"redundant\" NOTE_PUSH/NOTE_POP uses so code_SP_max gets set.\n\tEmit invokeinterface when calling an interface method.\n\tEmit invokespecial also when calling super or private methods.\n\t* jcf-write.c (generate_classfile):  Emit ConstantValue attributes.\n\nFrom-SVN: r24162", "tree": {"sha": "c10b08c42f7c6cf0925f6a6c25cf6a30df6cdfa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c10b08c42f7c6cf0925f6a6c25cf6a30df6cdfa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35/comments", "author": null, "committer": null, "parents": [{"sha": "157412f5c7ef3d9fe1200f5c7aaca3cd608bdaad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157412f5c7ef3d9fe1200f5c7aaca3cd608bdaad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/157412f5c7ef3d9fe1200f5c7aaca3cd608bdaad"}], "stats": {"total": 100, "additions": 79, "deletions": 21}, "files": [{"sha": "18567fb90b7ef2585df5bc52003af9442440ec7f", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 79, "deletions": 21, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35", "patch": "@@ -546,7 +546,7 @@ get_access_flags (decl)\n   if (CLASS_PUBLIC (decl))  /* same as FIELD_PUBLIC and METHOD_PUBLIC */\n     flags |= ACC_PUBLIC;\n   if (CLASS_FINAL (decl))  /* same as FIELD_FINAL and METHOD_FINAL */\n-    flags |= ACC_PUBLIC;\n+    flags |= ACC_FINAL;\n   if (isfield || TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       if (TREE_PROTECTED (decl))\n@@ -571,8 +571,6 @@ get_access_flags (decl)\n \tflags |= ACC_NATIVE;\n       if (METHOD_STATIC (decl))\n \tflags |= ACC_STATIC;\n-      if (METHOD_FINAL (decl))\n-\tflags |= ACC_FINAL;\n       if (METHOD_SYNCHRONIZED (decl))\n \tflags |= ACC_SYNCHRONIZED;\n       if (METHOD_ABSTRACT (decl))\n@@ -663,6 +661,17 @@ push_int_const (i, state)\n     }\n }\n \n+static int\n+find_constant_wide (lo, hi, state)\n+     HOST_WIDE_INT lo, hi;\n+     struct jcf_partial *state;\n+{\n+  HOST_WIDE_INT w1, w2;\n+  lshift_double (lo, hi, -32, 64, &w1, &w2, 1);\n+  return find_constant2 (&state->cpool, CONSTANT_Long,\n+\t\t\t w1 & 0xFFFFFFFF, lo & 0xFFFFFFFF);\n+ }\n+\n /* Push 64-bit long constant on VM stack.\n    Caller is responsible for doing NOTE_PUSH. */\n \n@@ -683,13 +692,7 @@ push_long_const (lo, hi, state)\n         OP1 (OPCODE_i2l);\n       }\n   else\n-    {\n-      HOST_WIDE_INT w1, w2;\n-      lshift_double (lo, hi, -32, 64, &w1, &w2, 1);\n-      hi = find_constant2 (&state->cpool, CONSTANT_Long,\n-\t\t\t   w1 & 0xFFFFFFFF, lo & 0xFFFFFFFF);\n-      push_constant2 (hi, state);\n-    }\n+    push_constant2 (find_constant_wide (lo, hi, state), state);\n }\n \n static void\n@@ -1441,9 +1444,10 @@ generate_bytecode_insns (exp, target, state)\n \tgenerate_bytecode_insns (TREE_OPERAND (exp, 1), IGNORE_TARGET, state);\n \tbody_last = state->last_block;\n \n+\tswitch_instruction = gen_jcf_label (state);\n+\tdefine_jcf_label (switch_instruction, state);\n \tif (sw_state.default_label == NULL)\n \t  sw_state.default_label = gen_jcf_label (state);\n-\tswitch_instruction = get_jcf_label_here (state);\n \n \tif (sw_state.num_cases <= 1)\n \t  {\n@@ -1711,6 +1715,7 @@ generate_bytecode_insns (exp, target, state)\n       {\n \ttree lhs = TREE_OPERAND (exp, 0);\n \ttree rhs = TREE_OPERAND (exp, 1);\n+\tint offset = 0;\n \n \t/* See if we can use the iinc instruction. */\n \tif ((TREE_CODE (lhs) == VAR_DECL || TREE_CODE (lhs) == PARM_DECL)\n@@ -1749,15 +1754,24 @@ generate_bytecode_insns (exp, target, state)\n \t  }\n \n \tif (TREE_CODE (lhs) == COMPONENT_REF)\n-\t  generate_bytecode_insns (TREE_OPERAND (lhs, 0), STACK_TARGET, state);\n+\t  {\n+\t    generate_bytecode_insns (TREE_OPERAND (lhs, 0),\n+\t\t\t\t     STACK_TARGET, state);\n+\t    offset = 1;\n+\t  }\n \telse if (TREE_CODE (lhs) == ARRAY_REF)\n \t  {\n-\t    generate_bytecode_insns (TREE_OPERAND(lhs, 0), STACK_TARGET, state);\n-\t    generate_bytecode_insns (TREE_OPERAND(lhs, 1), STACK_TARGET, state);\n+\t    generate_bytecode_insns (TREE_OPERAND(lhs, 0),\n+\t\t\t\t     STACK_TARGET, state);\n+\t    generate_bytecode_insns (TREE_OPERAND(lhs, 1),\n+\t\t\t\t     STACK_TARGET, state);\n+\t    offset = 2;\n \t  }\n+\telse\n+\t  offset = 0;\n \tgenerate_bytecode_insns (rhs, STACK_TARGET, state);\n \tif (target != IGNORE_TARGET)\n-\t  emit_dup (TYPE_IS_WIDE (type) ? 2 : 1 , 1, state);\n+\t  emit_dup (TYPE_IS_WIDE (type) ? 2 : 1 , offset, state);\n \texp = lhs;\n       }\n       /* FALLTHOUGH */\n@@ -1849,7 +1863,9 @@ generate_bytecode_insns (exp, target, state)\n \t  RESERVE (2);\n \t  if (is_long)\n \t    OP1 (OPCODE_i2l);\n+\t  NOTE_PUSH (1 + is_long);\n \t  OP1 (OPCODE_ixor + is_long);\n+\t  NOTE_POP (1 + is_long);\n \t}\n       break;\n     case NEGATE_EXPR:\n@@ -2005,19 +2021,22 @@ generate_bytecode_insns (exp, target, state)\n     case NEW_CLASS_EXPR:\n       {\n \ttree class = TREE_TYPE (TREE_TYPE (exp));\n+\tint need_result = target != IGNORE_TARGET;\n \tint index = find_class_constant (&state->cpool, class);\n \tRESERVE (4);\n \tOP1 (OPCODE_new);\n \tOP2 (index);\n-\tOP1 (OPCODE_dup);\n-\tNOTE_PUSH (1);\n+\tif (need_result)\n+\t  OP1 (OPCODE_dup);\n+\tNOTE_PUSH (1 + need_result);\n       }\n       /* ... fall though ... */\n     case CALL_EXPR:\n       {\n \ttree f = TREE_OPERAND (exp, 0);\n \ttree x = TREE_OPERAND (exp, 1);\n \tint save_SP = state->code_SP;\n+\tint nargs;\n \tif (TREE_CODE (f) == ADDR_EXPR)\n \t  f = TREE_OPERAND (f, 0);\n \tif (f == soft_newarray_node)\n@@ -2084,15 +2103,25 @@ generate_bytecode_insns (exp, target, state)\n \t  {\n \t    generate_bytecode_insns (TREE_VALUE (x), STACK_TARGET, state);\n \t  }\n+\tnargs = state->code_SP - save_SP;\n \tstate->code_SP = save_SP;\n+\tif (TREE_CODE (exp) == NEW_CLASS_EXPR)\n+\t  NOTE_POP (1);  /* Pop implicit this. */\n \tif (TREE_CODE (f) == FUNCTION_DECL && DECL_CONTEXT (f) != NULL_TREE)\n \t  {\n \t    int index = find_methodref_index (&state->cpool, f);\n-\t    RESERVE (3);\n-\t    if (DECL_CONSTRUCTOR_P (f))\n+\t    int interface = 0;\n+\t    RESERVE (5);\n+\t    if (DECL_CONSTRUCTOR_P (f) || CALL_USING_SUPER (exp)\n+\t\t|| METHOD_PRIVATE (f))\n \t      OP1 (OPCODE_invokespecial);\n \t    else if (METHOD_STATIC (f))\n \t      OP1 (OPCODE_invokestatic);\n+\t    else if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (f))))\n+\t      {\n+\t\tOP1 (OPCODE_invokeinterface);\n+\t\tinterface = 1;\n+\t      }\n \t    else\n \t      OP1 (OPCODE_invokevirtual);\n \t    OP2 (index);\n@@ -2105,6 +2134,11 @@ generate_bytecode_insns (exp, target, state)\n \t\telse\n \t\t  NOTE_PUSH (size);\n \t      }\n+\t    if (interface)\n+\t      {\n+\t\tOP1 (nargs);\n+\t\tOP1 (0);\n+\t      }\n \t    break;\n \t  }\n       }\n@@ -2390,15 +2424,39 @@ generate_classfile (clas, state)\n \n   for (part = TYPE_FIELDS (clas);  part;  part = TREE_CHAIN (part))\n     {\n+      int have_value;\n       if (DECL_NAME (part) == NULL_TREE)\n \tcontinue;\n       ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, DECL_NAME (part));  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, build_java_signature (TREE_TYPE (part)));\n       PUT2(i);\n-      PUT2 (0);  /* attributes_count */\n-      /* FIXME - emit ConstantValue attribute when appropriate */\n+      have_value = DECL_INITIAL (part) != NULL_TREE && FIELD_STATIC (part);\n+      PUT2 (have_value);  /* attributes_count */\n+      if (have_value)\n+\t{\n+\t  tree init = DECL_INITIAL (part);\n+\t  static tree ConstantValue_node = NULL_TREE;\n+\t  ptr = append_chunk (NULL, 8, state);\n+\t  if (ConstantValue_node == NULL_TREE)\n+\t    ConstantValue_node = get_identifier (\"ConstantValue\");\n+\t  i = find_utf8_constant (&state->cpool, ConstantValue_node);\n+\t  PUT2 (i);  /* attribute_name_index */\n+\t  PUT4 (2); /* attribute_length */\n+\t  if (TREE_CODE (init) == INTEGER_CST)\n+\t    {\n+\t      if (TYPE_PRECISION (TREE_TYPE (part)) <= 32)\n+\t\ti = find_constant1 (&state->cpool, CONSTANT_Integer,\n+\t\t\t\t    TREE_INT_CST_LOW (init) & 0xFFFFFFFF);\n+\t      else\n+\t\ti = find_constant_wide (TREE_INT_CST_LOW (init),\n+\t\t\t\t\tTREE_INT_CST_HIGH (init), state);\n+\t    }\n+\t  else\n+\t    fatal (\"unimplemented ConstantValue\");\n+\t  PUT2 (i);\n+\t}\n       fields_count++;\n     }\n   ptr = fields_count_ptr;  PUT2 (fields_count);"}]}