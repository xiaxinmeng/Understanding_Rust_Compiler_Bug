{"sha": "9c8860c3701461d8f2ee6f875ea63d9b5c76baaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM4ODYwYzM3MDE0NjFkOGYyZWU2Zjg3NWVhNjNkOWI1Yzc2YmFhYQ==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "drow@mvista.com", "date": "2003-09-15T20:16:32Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2003-09-15T20:16:32Z"}, "message": "floatformat.c (floatformat_is_valid): New function.\n\n\t* floatformat.c (floatformat_is_valid): New function.\n\t(get_field, put_field): Correct comments.\n\nFrom-SVN: r71405", "tree": {"sha": "fbfe4a7c48eb4a3ee838d9034a3ceeb16aedd6a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbfe4a7c48eb4a3ee838d9034a3ceeb16aedd6a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa/comments", "author": null, "committer": null, "parents": [{"sha": "0d66a8212c145b418e7286380f0ecc7e55a197d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d66a8212c145b418e7286380f0ecc7e55a197d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d66a8212c145b418e7286380f0ecc7e55a197d2"}], "stats": {"total": 44, "additions": 41, "deletions": 3}, "files": [{"sha": "a70872eea118558edafe5d6117e9f61e95721b77", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=9c8860c3701461d8f2ee6f875ea63d9b5c76baaa", "patch": "@@ -1,3 +1,8 @@\n+2003-09-15  Daniel Jacobowitz  <drow@mvista.com>\n+\n+\t* floatformat.c (floatformat_is_valid): New function.\n+\t(get_field, put_field): Correct comments.\n+\n 2003-09-06  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* fibheap.c (fibheap_replace_key_data): Change type of OKEY to"}, {"sha": "b892dbea40ef89cc57a2c67aacc3819d585a48ad", "filename": "libiberty/floatformat.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa/libiberty%2Ffloatformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8860c3701461d8f2ee6f875ea63d9b5c76baaa/libiberty%2Ffloatformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffloatformat.c?ref=9c8860c3701461d8f2ee6f875ea63d9b5c76baaa", "patch": "@@ -1,5 +1,5 @@\n /* IEEE floating point support routines, for GDB, the GNU Debugger.\n-   Copyright (C) 1991, 1994, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1994, 1999, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GDB.\n \n@@ -149,7 +149,7 @@ static unsigned long get_field PARAMS ((unsigned char *,\n \t\t\t\t\tunsigned int,\n \t\t\t\t\tunsigned int));\n \n-/* Extract a field which starts at START and is LEN bytes long.  DATA and\n+/* Extract a field which starts at START and is LEN bits long.  DATA and\n    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */\n static unsigned long\n get_field (data, order, total_len, start, len)\n@@ -273,7 +273,7 @@ static void put_field PARAMS ((unsigned char *, enum floatformat_byteorders,\n \t\t\t       unsigned int,\n \t\t\t       unsigned long));\n \n-/* Set a field which starts at START and is LEN bytes long.  DATA and\n+/* Set a field which starts at START and is LEN bits long.  DATA and\n    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */\n static void\n put_field (data, order, total_len, start, len, stuff_to_put)\n@@ -404,6 +404,39 @@ floatformat_from_double (fmt, from, to)\n     }\n }\n \n+/* Return non-zero iff the data at FROM is a valid number in format FMT.  */\n+\n+int\n+floatformat_is_valid (fmt, from)\n+     const struct floatformat *fmt;\n+     char *from;\n+{\n+  if (fmt == &floatformat_i387_ext)\n+    {\n+      /* In the i387 double-extended format, if the exponent is all\n+\t ones, then the integer bit must be set.  If the exponent\n+\t is neither 0 nor ~0, the intbit must also be set.  Only\n+\t if the exponent is zero can it be zero, and then it must\n+\t be zero.  */\n+      unsigned long exponent, int_bit;\n+      unsigned char *ufrom = (unsigned char *) from;\n+\n+      exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,\n+\t\t\t    fmt->exp_start, fmt->exp_len);\n+      int_bit = get_field (ufrom, fmt->byteorder, fmt->totalsize,\n+\t\t\t   fmt->man_start, 1);\n+\n+      if ((exponent == 0) != (int_bit == 0))\n+\treturn 0;\n+      else\n+\treturn 1;\n+    }\n+\n+  /* Other formats with invalid representations should be added\n+     here.  */\n+  return 1;\n+}\n+\n \n #ifdef IEEE_DEBUG\n "}]}