{"sha": "f6592a9e2cdd63133763f8b9171e2b6051db2393", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1OTJhOWUyY2RkNjMxMzM3NjNmOGI5MTcxZTJiNjA1MWRiMjM5Mw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-02-01T17:34:44Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-02-01T17:34:44Z"}, "message": "deque.tcc: Wrap overlong lines...\n\n2004-02-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/deque.tcc: Wrap overlong lines, constify\n\ta few variables, reformat according to the coding standards.\n\t* include/bits/list.tcc: Likewise.\n\t* include/bits/stl_deque.h: Likewise.\n\t* include/bits/stl_function.h: Likewise.\n\t* include/bits/stl_iterator.h: Likewise.\n\t* include/bits/stl_iterator_base_funcs.h: Likewise.\n\t* include/bits/stl_iterator_base_types.h: Likewise.\n\t* include/bits/stl_list.h: Likewise.\n\t* include/bits/stl_map.h: Likewise.\n\t* include/bits/stl_multimap.h: Likewise.\n\t* include/bits/stl_multiset.h: Likewise.\n\t* include/bits/stl_relops.h: Likewise.\n\t* include/bits/stl_set.h: Likewise.\n\nFrom-SVN: r77077", "tree": {"sha": "30dbd6c4b642ec970f0c5f0418819a48ba2d77ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30dbd6c4b642ec970f0c5f0418819a48ba2d77ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6592a9e2cdd63133763f8b9171e2b6051db2393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6592a9e2cdd63133763f8b9171e2b6051db2393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6592a9e2cdd63133763f8b9171e2b6051db2393", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6592a9e2cdd63133763f8b9171e2b6051db2393/comments", "author": null, "committer": null, "parents": [{"sha": "e0a24727f28754045955bb801d664ef123c0568a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a24727f28754045955bb801d664ef123c0568a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0a24727f28754045955bb801d664ef123c0568a"}], "stats": {"total": 7636, "additions": 4032, "deletions": 3604}, "files": [{"sha": "ed6d807544dd5ce7c6d1979ac760939c755a42cd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,3 +1,20 @@\n+2004-02-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/deque.tcc: Wrap overlong lines, constify\n+\ta few variables, reformat according to the coding standards.\n+\t* include/bits/list.tcc: Likewise.\n+\t* include/bits/stl_deque.h: Likewise.\n+\t* include/bits/stl_function.h: Likewise.\n+\t* include/bits/stl_iterator.h: Likewise.\n+\t* include/bits/stl_iterator_base_funcs.h: Likewise.\n+\t* include/bits/stl_iterator_base_types.h: Likewise.\n+\t* include/bits/stl_list.h: Likewise.\n+\t* include/bits/stl_map.h: Likewise.\n+\t* include/bits/stl_multimap.h: Likewise.\n+\t* include/bits/stl_multiset.h: Likewise.\n+\t* include/bits/stl_relops.h: Likewise.\n+\t* include/bits/stl_set.h: Likewise.\n+\n 2004-02-01  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/stl_bvector.h: Wrap overlong lines, constify"}, {"sha": "2f26edfb3af8eb98403a3bd5fdf1b3a4a428b9a8", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 287, "deletions": 280, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Deque implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -70,16 +70,17 @@ namespace __gnu_norm\n     {\n       const size_type __len = size();\n       if (&__x != this)\n-      {\n-        if (__len >= __x.size())\n-          erase(std::copy(__x.begin(), __x.end(), this->_M_start), this->_M_finish);\n-        else\n-        {\n-          const_iterator __mid = __x.begin() + difference_type(__len);\n-          std::copy(__x.begin(), __mid, this->_M_start);\n-          insert(this->_M_finish, __mid, __x.end());\n-        }\n-      }\n+\t{\n+\t  if (__len >= __x.size())\n+\t    erase(std::copy(__x.begin(), __x.end(), this->_M_start),\n+\t\t  this->_M_finish);\n+\t  else\n+\t    {\n+\t      const_iterator __mid = __x.begin() + difference_type(__len);\n+\t      std::copy(__x.begin(), __mid, this->_M_start);\n+\t      insert(this->_M_finish, __mid, __x.end());\n+\t    }\n+\t}\n       return *this;\n     }        \n   \n@@ -89,17 +90,17 @@ namespace __gnu_norm\n     insert(iterator position, const value_type& __x)\n     {\n       if (position._M_cur == this->_M_start._M_cur)\n-      {\n-        push_front(__x);\n-        return this->_M_start;\n-      }\n+\t{\n+\t  push_front(__x);\n+\t  return this->_M_start;\n+\t}\n       else if (position._M_cur == this->_M_finish._M_cur)\n-      {\n-        push_back(__x);\n-        iterator __tmp = this->_M_finish;\n-        --__tmp;\n-        return __tmp;\n-      }\n+\t{\n+\t  push_back(__x);\n+\t  iterator __tmp = this->_M_finish;\n+\t  --__tmp;\n+\t  return __tmp;\n+\t}\n       else\n         return _M_insert_aux(position, __x);\n     }\n@@ -113,15 +114,15 @@ namespace __gnu_norm\n       ++__next;\n       size_type __index = __position - this->_M_start;\n       if (__index < (size() >> 1))\n-      {\n-        std::copy_backward(this->_M_start, __position, __next);\n-        pop_front();\n-      }\n+\t{\n+\t  std::copy_backward(this->_M_start, __position, __next);\n+\t  pop_front();\n+\t}\n       else\n-      {\n-        std::copy(__next, this->_M_finish, __position);\n-        pop_back();\n-      }\n+\t{\n+\t  std::copy(__next, this->_M_finish, __position);\n+\t  pop_back();\n+\t}\n       return this->_M_start + __index;\n     }\n   \n@@ -131,33 +132,33 @@ namespace __gnu_norm\n     erase(iterator __first, iterator __last)\n     {\n       if (__first == this->_M_start && __last == this->_M_finish)\n-      {\n-        clear();\n-        return this->_M_finish;\n-      }\n+\t{\n+\t  clear();\n+\t  return this->_M_finish;\n+\t}\n       else\n-      {\n-        difference_type __n = __last - __first;\n-        difference_type __elems_before = __first - this->_M_start;\n-        if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n-        {\n-          std::copy_backward(this->_M_start, __first, __last);\n-          iterator __new_start = this->_M_start + __n;\n-          std::_Destroy(this->_M_start, __new_start);\n-          _M_destroy_nodes(this->_M_start._M_node, __new_start._M_node);\n-          this->_M_start = __new_start;\n-        }\n-        else\n-        {\n-          std::copy(__last, this->_M_finish, __first);\n-          iterator __new_finish = this->_M_finish - __n;\n-          std::_Destroy(__new_finish, this->_M_finish);\n-          _M_destroy_nodes(__new_finish._M_node + 1,\n-\t\t\t   this->_M_finish._M_node + 1);\n-          this->_M_finish = __new_finish;\n-        }\n-        return this->_M_start + __elems_before;\n-      }\n+\t{\n+\t  const difference_type __n = __last - __first;\n+\t  const difference_type __elems_before = __first - this->_M_start;\n+\t  if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n+\t    {\n+\t      std::copy_backward(this->_M_start, __first, __last);\n+\t      iterator __new_start = this->_M_start + __n;\n+\t      std::_Destroy(this->_M_start, __new_start);\n+\t      _M_destroy_nodes(this->_M_start._M_node, __new_start._M_node);\n+\t      this->_M_start = __new_start;\n+\t    }\n+\t  else\n+\t    {\n+\t      std::copy(__last, this->_M_finish, __first);\n+\t      iterator __new_finish = this->_M_finish - __n;\n+\t      std::_Destroy(__new_finish, this->_M_finish);\n+\t      _M_destroy_nodes(__new_finish._M_node + 1,\n+\t\t\t       this->_M_finish._M_node + 1);\n+\t      this->_M_finish = __new_finish;\n+\t    }\n+\t  return this->_M_start + __elems_before;\n+\t}\n     }\n     \n   template <typename _Tp, typename _Alloc> \n@@ -168,28 +169,29 @@ namespace __gnu_norm\n       for (_Map_pointer __node = this->_M_start._M_node + 1;\n            __node < this->_M_finish._M_node;\n            ++__node)\n-      {\n-        std::_Destroy(*__node, *__node + _S_buffer_size());\n-        _M_deallocate_node(*__node);\n-      }\n+\t{\n+\t  std::_Destroy(*__node, *__node + _S_buffer_size());\n+\t  _M_deallocate_node(*__node);\n+\t}\n     \n       if (this->_M_start._M_node != this->_M_finish._M_node)\n-      {\n-        std::_Destroy(this->_M_start._M_cur, this->_M_start._M_last);\n-        std::_Destroy(this->_M_finish._M_first, this->_M_finish._M_cur);\n-        _M_deallocate_node(this->_M_finish._M_first);\n-      }\n+\t{\n+\t  std::_Destroy(this->_M_start._M_cur, this->_M_start._M_last);\n+\t  std::_Destroy(this->_M_finish._M_first, this->_M_finish._M_cur);\n+\t  _M_deallocate_node(this->_M_finish._M_first);\n+\t}\n       else\n         std::_Destroy(this->_M_start._M_cur, this->_M_finish._M_cur);\n-    \n+      \n       this->_M_finish = this->_M_start;\n     }\n     \n   template <typename _Tp, class _Alloc>\n     template <typename _InputIterator>\n       void\n       deque<_Tp,_Alloc>\n-      ::_M_assign_aux(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n+      ::_M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t      input_iterator_tag)\n       {\n         iterator __cur = begin();\n         for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n@@ -206,34 +208,34 @@ namespace __gnu_norm\n     _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n     {\n       if (__pos._M_cur == this->_M_start._M_cur)\n-      {\n-        iterator __new_start = _M_reserve_elements_at_front(__n);\n-        try\n-          {\n-            std::uninitialized_fill(__new_start, this->_M_start, __x);\n-            this->_M_start = __new_start;\n-          }\n-        catch(...)\n-          {\n-            _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n-            __throw_exception_again;\n-          }\n-      }\n+\t{\n+\t  iterator __new_start = _M_reserve_elements_at_front(__n);\n+\t  try\n+\t    {\n+\t      std::uninitialized_fill(__new_start, this->_M_start, __x);\n+\t      this->_M_start = __new_start;\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n       else if (__pos._M_cur == this->_M_finish._M_cur)\n-      {\n-        iterator __new_finish = _M_reserve_elements_at_back(__n);\n-        try\n-          {\n-            std::uninitialized_fill(this->_M_finish, __new_finish, __x);\n-            this->_M_finish = __new_finish;\n-          }\n-        catch(...)\n-          {\n-            _M_destroy_nodes(this->_M_finish._M_node + 1,\n-\t\t\t     __new_finish._M_node + 1);    \n-            __throw_exception_again;\n-          }\n-      }\n+\t{\n+\t  iterator __new_finish = _M_reserve_elements_at_back(__n);\n+\t  try\n+\t    {\n+\t      std::uninitialized_fill(this->_M_finish, __new_finish, __x);\n+\t      this->_M_finish = __new_finish;\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t\t       __new_finish._M_node + 1);    \n+\t      __throw_exception_again;\n+\t    }\n+\t}\n       else \n         _M_insert_aux(__pos, __n, __x);\n     }\n@@ -288,7 +290,7 @@ namespace __gnu_norm\n       _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                           forward_iterator_tag)\n       {\n-        size_type __n = std::distance(__first, __last);\n+        const size_type __n = std::distance(__first, __last);\n         this->_M_initialize_map(__n);\n       \n         _Map_pointer __cur_node;\n@@ -389,9 +391,7 @@ namespace __gnu_norm\n       _M_range_insert_aux(iterator __pos,\n                           _InputIterator __first, _InputIterator __last,\n                           input_iterator_tag)\n-      {\n-        std::copy(__first, __last, std::inserter(*this, __pos));\n-      }\n+      { std::copy(__first, __last, std::inserter(*this, __pos)); }\n     \n   template <typename _Tp, typename _Alloc>\n     template <typename _ForwardIterator>\n@@ -403,34 +403,34 @@ namespace __gnu_norm\n       {\n         size_type __n = std::distance(__first, __last);\n         if (__pos._M_cur == this->_M_start._M_cur)\n-        {\n-          iterator __new_start = _M_reserve_elements_at_front(__n);\n-          try\n-            {\n-              std::uninitialized_copy(__first, __last, __new_start);\n-              this->_M_start = __new_start;\n-            }\n-          catch(...)\n-            {\n-              _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n-              __throw_exception_again;\n-            }\n-        }\n+\t  {\n+\t    iterator __new_start = _M_reserve_elements_at_front(__n);\n+\t    try\n+\t      {\n+\t\tstd::uninitialized_copy(__first, __last, __new_start);\n+\t\tthis->_M_start = __new_start;\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\t_M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t\t__throw_exception_again;\n+\t      }\n+\t  }\n         else if (__pos._M_cur == this->_M_finish._M_cur)\n-        {\n-          iterator __new_finish = _M_reserve_elements_at_back(__n);\n-          try\n-            {\n-              std::uninitialized_copy(__first, __last, this->_M_finish);\n-              this->_M_finish = __new_finish;\n-            }\n-          catch(...)\n-            {\n-              _M_destroy_nodes(this->_M_finish._M_node + 1,\n-\t\t\t       __new_finish._M_node + 1);\n-              __throw_exception_again;\n-            }\n-        }\n+\t  {\n+\t    iterator __new_finish = _M_reserve_elements_at_back(__n);\n+\t    try\n+\t      {\n+\t\tstd::uninitialized_copy(__first, __last, this->_M_finish);\n+\t\tthis->_M_finish = __new_finish;\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\t_M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t\t\t __new_finish._M_node + 1);\n+\t\t__throw_exception_again;\n+\t      }\n+\t  }\n         else\n           _M_insert_aux(__pos, __first, __last, __n);\n       }\n@@ -443,27 +443,27 @@ namespace __gnu_norm\n       difference_type __index = __pos - this->_M_start;\n       value_type __x_copy = __x; // XXX copy\n       if (static_cast<size_type>(__index) < size() / 2)\n-      {\n-        push_front(front());\n-        iterator __front1 = this->_M_start;\n-        ++__front1;\n-        iterator __front2 = __front1;\n-        ++__front2;\n-        __pos = this->_M_start + __index;\n-        iterator __pos1 = __pos;\n-        ++__pos1;\n-        std::copy(__front2, __pos1, __front1);\n-      }\n+\t{\n+\t  push_front(front());\n+\t  iterator __front1 = this->_M_start;\n+\t  ++__front1;\n+\t  iterator __front2 = __front1;\n+\t  ++__front2;\n+\t  __pos = this->_M_start + __index;\n+\t  iterator __pos1 = __pos;\n+\t  ++__pos1;\n+\t  std::copy(__front2, __pos1, __front1);\n+\t}\n       else\n-      {\n-        push_back(back());\n-        iterator __back1 = this->_M_finish;\n-        --__back1;\n-        iterator __back2 = __back1;\n-        --__back2;\n-        __pos = this->_M_start + __index;\n-        std::copy_backward(__pos, __back2, __back1);\n-      }\n+\t{\n+\t  push_back(back());\n+\t  iterator __back1 = this->_M_finish;\n+\t  --__back1;\n+\t  iterator __back2 = __back1;\n+\t  --__back2;\n+\t  __pos = this->_M_start + __index;\n+\t  std::copy_backward(__pos, __back2, __back1);\n+\t}\n       *__pos = __x_copy;\n       return __pos;\n     }\n@@ -477,69 +477,73 @@ namespace __gnu_norm\n       size_type __length = this->size();\n       value_type __x_copy = __x;\n       if (__elems_before < difference_type(__length / 2))\n-      {\n-        iterator __new_start = _M_reserve_elements_at_front(__n);\n-        iterator __old_start = this->_M_start;\n-        __pos = this->_M_start + __elems_before;\n-        try\n-          {\n-            if (__elems_before >= difference_type(__n))\n-            {\n-              iterator __start_n = this->_M_start + difference_type(__n);\n-              std::uninitialized_copy(this->_M_start, __start_n, __new_start);\n-              this->_M_start = __new_start;\n-              std::copy(__start_n, __pos, __old_start);\n-              fill(__pos - difference_type(__n), __pos, __x_copy);\n-            }\n-            else\n-            {\n-              std::__uninitialized_copy_fill(this->_M_start, __pos, __new_start, \n-\t\t\t\t\t     this->_M_start, __x_copy);\n-              this->_M_start = __new_start;\n-              std::fill(__old_start, __pos, __x_copy);\n-            }\n-          }\n-        catch(...)\n-          { \n-            _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n-            __throw_exception_again;\n-          }\n-      }\n+\t{\n+\t  iterator __new_start = _M_reserve_elements_at_front(__n);\n+\t  iterator __old_start = this->_M_start;\n+\t  __pos = this->_M_start + __elems_before;\n+\t  try\n+\t    {\n+\t      if (__elems_before >= difference_type(__n))\n+\t\t{\n+\t\t  iterator __start_n = this->_M_start + difference_type(__n);\n+\t\t  std::uninitialized_copy(this->_M_start, __start_n,\n+\t\t\t\t\t  __new_start);\n+\t\t  this->_M_start = __new_start;\n+\t\t  std::copy(__start_n, __pos, __old_start);\n+\t\t  fill(__pos - difference_type(__n), __pos, __x_copy);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  std::__uninitialized_copy_fill(this->_M_start, __pos,\n+\t\t\t\t\t\t __new_start, \n+\t\t\t\t\t\t this->_M_start, __x_copy);\n+\t\t  this->_M_start = __new_start;\n+\t\t  std::fill(__old_start, __pos, __x_copy);\n+\t\t}\n+\t    }\n+\t  catch(...)\n+\t    { \n+\t      _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n       else\n-      {\n-        iterator __new_finish = _M_reserve_elements_at_back(__n);\n-        iterator __old_finish = this->_M_finish;\n-        const difference_type __elems_after = \n-          difference_type(__length) - __elems_before;\n-        __pos = this->_M_finish - __elems_after;\n-        try\n-          {\n-            if (__elems_after > difference_type(__n))\n-            {\n-              iterator __finish_n = this->_M_finish - difference_type(__n);\n-              std::uninitialized_copy(__finish_n, this->_M_finish, this->_M_finish);\n-              this->_M_finish = __new_finish;\n-              std::copy_backward(__pos, __finish_n, __old_finish);\n-              std::fill(__pos, __pos + difference_type(__n), __x_copy);\n-            }\n-            else\n-            {\n-              std::__uninitialized_fill_copy(this->_M_finish,\n-\t\t\t\t\t     __pos + difference_type(__n),\n-\t\t\t\t\t     __x_copy, __pos, this->_M_finish);\n-              this->_M_finish = __new_finish;\n-              std::fill(__pos, __old_finish, __x_copy);\n-            }\n-          }\n-        catch(...)\n-          { \n-            _M_destroy_nodes(this->_M_finish._M_node + 1,\n-\t\t\t     __new_finish._M_node + 1);\n-            __throw_exception_again;\n-          }\n-      }\n+\t{\n+\t  iterator __new_finish = _M_reserve_elements_at_back(__n);\n+\t  iterator __old_finish = this->_M_finish;\n+\t  const difference_type __elems_after = \n+\t    difference_type(__length) - __elems_before;\n+\t  __pos = this->_M_finish - __elems_after;\n+\t  try\n+\t    {\n+\t      if (__elems_after > difference_type(__n))\n+\t\t{\n+\t\t  iterator __finish_n = this->_M_finish - difference_type(__n);\n+\t\t  std::uninitialized_copy(__finish_n, this->_M_finish,\n+\t\t\t\t\t  this->_M_finish);\n+\t\t  this->_M_finish = __new_finish;\n+\t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n+\t\t  std::fill(__pos, __pos + difference_type(__n), __x_copy);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  std::__uninitialized_fill_copy(this->_M_finish,\n+\t\t\t\t\t\t __pos + difference_type(__n),\n+\t\t\t\t\t\t __x_copy, __pos,\n+\t\t\t\t\t\t this->_M_finish);\n+\t\t  this->_M_finish = __new_finish;\n+\t\t  std::fill(__pos, __old_finish, __x_copy);\n+\t\t}\n+\t    }\n+\t  catch(...)\n+\t    { \n+\t      _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t\t       __new_finish._M_node + 1);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n     }\n-    \n+  \n   template <typename _Tp, typename _Alloc>\n     template <typename _ForwardIterator>\n       void\n@@ -551,36 +555,37 @@ namespace __gnu_norm\n         const difference_type __elemsbefore = __pos - this->_M_start;\n         size_type __length = size();\n         if (static_cast<size_type>(__elemsbefore) < __length / 2)\n-        {\n-          iterator __new_start = _M_reserve_elements_at_front(__n);\n-          iterator __old_start = this->_M_start;\n-          __pos = this->_M_start + __elemsbefore;\n-          try\n-            {\n-              if (__elemsbefore >= difference_type(__n))\n-              {\n-                iterator __start_n = this->_M_start + difference_type(__n); \n-                std::uninitialized_copy(this->_M_start, __start_n, __new_start);\n-                this->_M_start = __new_start;\n-                std::copy(__start_n, __pos, __old_start);\n-                std::copy(__first, __last, __pos - difference_type(__n));\n-              }\n-              else\n-              {\n-                _ForwardIterator __mid = __first;\n-                std::advance(__mid, difference_type(__n) - __elemsbefore);\n-                std::__uninitialized_copy_copy(this->_M_start, __pos,\n-\t\t\t\t\t       __first, __mid, __new_start);\n-                this->_M_start = __new_start;\n-                std::copy(__mid, __last, __old_start);\n-              }\n-            }\n-          catch(...)\n-            {\n-              _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n-              __throw_exception_again;\n-            }\n-        }\n+\t  {\n+\t    iterator __new_start = _M_reserve_elements_at_front(__n);\n+\t    iterator __old_start = this->_M_start;\n+\t    __pos = this->_M_start + __elemsbefore;\n+\t    try\n+\t      {\n+\t\tif (__elemsbefore >= difference_type(__n))\n+\t\t  {\n+\t\t    iterator __start_n = this->_M_start + difference_type(__n); \n+\t\t    std::uninitialized_copy(this->_M_start, __start_n,\n+\t\t\t\t\t    __new_start);\n+\t\t    this->_M_start = __new_start;\n+\t\t    std::copy(__start_n, __pos, __old_start);\n+\t\t    std::copy(__first, __last, __pos - difference_type(__n));\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    _ForwardIterator __mid = __first;\n+\t\t    std::advance(__mid, difference_type(__n) - __elemsbefore);\n+\t\t    std::__uninitialized_copy_copy(this->_M_start, __pos,\n+\t\t\t\t\t\t   __first, __mid, __new_start);\n+\t\t    this->_M_start = __new_start;\n+\t\t    std::copy(__mid, __last, __old_start);\n+\t\t  }\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\t_M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t\t__throw_exception_again;\n+\t      }\n+\t  }\n         else\n         {\n           iterator __new_finish = _M_reserve_elements_at_back(__n);\n@@ -591,24 +596,25 @@ namespace __gnu_norm\n           try\n             {\n               if (__elemsafter > difference_type(__n))\n-              {\n-                iterator __finish_n = this->_M_finish - difference_type(__n);\n-                std::uninitialized_copy(__finish_n,\n-\t\t\t\t\tthis->_M_finish,\n-\t\t\t\t\tthis->_M_finish);\n-                this->_M_finish = __new_finish;\n-                std::copy_backward(__pos, __finish_n, __old_finish);\n-                std::copy(__first, __last, __pos);\n-              }\n+\t\t{\n+\t\t  iterator __finish_n = this->_M_finish - difference_type(__n);\n+\t\t  std::uninitialized_copy(__finish_n,\n+\t\t\t\t\t  this->_M_finish,\n+\t\t\t\t\t  this->_M_finish);\n+\t\t  this->_M_finish = __new_finish;\n+\t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n+\t\t  std::copy(__first, __last, __pos);\n+\t\t}\n               else\n-              {\n-                _ForwardIterator __mid = __first;\n-                std::advance(__mid, __elemsafter);\n-                std::__uninitialized_copy_copy(__mid, __last, __pos,\n-\t\t\t\t\t       this->_M_finish, this->_M_finish);\n-                this->_M_finish = __new_finish;\n-                std::copy(__first, __mid, __pos);\n-              }\n+\t\t{\n+\t\t  _ForwardIterator __mid = __first;\n+\t\t  std::advance(__mid, __elemsafter);\n+\t\t  std::__uninitialized_copy_copy(__mid, __last, __pos,\n+\t\t\t\t\t\t this->_M_finish,\n+\t\t\t\t\t\t this->_M_finish);\n+\t\t  this->_M_finish = __new_finish;\n+\t\t  std::copy(__first, __mid, __pos);\n+\t\t}\n             }\n           catch(...)\n             {\n@@ -625,7 +631,7 @@ namespace __gnu_norm\n     _M_new_elements_at_front(size_type __new_elems)\n     {\n       size_type __new_nodes\n-          = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n+\t= (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n       _M_reserve_map_at_front(__new_nodes);\n       size_type __i;\n       try\n@@ -674,39 +680,40 @@ namespace __gnu_norm\n     \n       _Map_pointer __new_nstart;\n       if (this->_M_map_size > 2 * __new_num_nodes)\n-      {\n-        __new_nstart\n-\t  = this->_M_map + (this->_M_map_size - __new_num_nodes) / 2 \n-\t  + (__add_at_front ? __nodes_to_add : 0);\n-        if (__new_nstart < this->_M_start._M_node)\n-          std::copy(this->_M_start._M_node,\n+\t{\n+\t  __new_nstart = this->_M_map + (this->_M_map_size\n+\t\t\t\t\t - __new_num_nodes) / 2 \n+\t                 + (__add_at_front ? __nodes_to_add : 0);\n+\t  if (__new_nstart < this->_M_start._M_node)\n+\t    std::copy(this->_M_start._M_node,\n \t\t    this->_M_finish._M_node + 1,\n \t\t    __new_nstart);\n-        else\n-          std::copy_backward(this->_M_start._M_node,\n-\t\t\t     this->_M_finish._M_node + 1, \n-\t\t\t     __new_nstart + __old_num_nodes);\n-      }\n+\t  else\n+\t    std::copy_backward(this->_M_start._M_node,\n+\t\t\t       this->_M_finish._M_node + 1, \n+\t\t\t       __new_nstart + __old_num_nodes);\n+\t}\n       else\n-      {\n-        size_type __new_map_size = \n-          this->_M_map_size + std::max(this->_M_map_size, __nodes_to_add) + 2;\n-    \n-        _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);\n-        __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n-                             + (__add_at_front ? __nodes_to_add : 0);\n-        std::copy(this->_M_start._M_node,\n-\t\t  this->_M_finish._M_node + 1,\n-\t\t  __new_nstart);\n-        _M_deallocate_map(this->_M_map, this->_M_map_size);\n-    \n-        this->_M_map = __new_map;\n-        this->_M_map_size = __new_map_size;\n-      }\n+\t{\n+\t  size_type __new_map_size = this->_M_map_size\n+\t                             + std::max(this->_M_map_size,\n+\t\t\t\t\t\t__nodes_to_add) + 2;\n     \n+\t  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);\n+\t  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n+\t                 + (__add_at_front ? __nodes_to_add : 0);\n+\t  std::copy(this->_M_start._M_node,\n+\t\t    this->_M_finish._M_node + 1,\n+\t\t    __new_nstart);\n+\t  _M_deallocate_map(this->_M_map, this->_M_map_size);\n+\t  \n+\t  this->_M_map = __new_map;\n+\t  this->_M_map_size = __new_map_size;\n+\t}\n+      \n       this->_M_start._M_set_node(__new_nstart);\n       this->_M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n     }\n } // namespace __gnu_norm\n-  \n+\n #endif"}, {"sha": "2c3e670d3b0beba764c2faef5121a71874cc681c", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // List implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -120,18 +120,18 @@ namespace __gnu_norm\n     operator=(const list& __x)\n     {\n       if (this != &__x)\n-      {\n-        iterator __first1 = begin();\n-        iterator __last1 = end();\n-        const_iterator __first2 = __x.begin();\n-        const_iterator __last2 = __x.end();\n-        while (__first1 != __last1 && __first2 != __last2)\n-          *__first1++ = *__first2++;\n-        if (__first2 == __last2)\n-          erase(__first1, __last1);\n-        else\n-          insert(__last1, __first2, __last2);\n-      }\n+\t{\n+\t  iterator __first1 = begin();\n+\t  iterator __last1 = end();\n+\t  const_iterator __first2 = __x.begin();\n+\t  const_iterator __last2 = __x.end();\n+\t  while (__first1 != __last1 && __first2 != __last2)\n+\t    *__first1++ = *__first2++;\n+\t  if (__first2 == __last2)\n+\t    erase(__first1, __last1);\n+\t  else\n+\t    insert(__last1, __first2, __last2);\n+\t}\n       return *this;\n     }\n   \n@@ -191,7 +191,8 @@ namespace __gnu_norm\n     {\n       iterator __first = begin();\n       iterator __last = end();\n-      if (__first == __last) return;\n+      if (__first == __last)\n+\treturn;\n       iterator __next = __first;\n       while (++__next != __last)\n       {\n@@ -245,19 +246,21 @@ namespace __gnu_norm\n         list * __counter;\n \n         do\n-        {\n-          __carry.splice(__carry.begin(), *this, begin());\n-\n-          for(__counter = &__tmp[0];\n-              (__counter != __fill) && !__counter->empty();\n-              ++__counter)\n-          {\n-            __counter->merge(__carry);\n-            __carry.swap(*__counter);\n-          }\n-          __carry.swap(*__counter);\n-          if (__counter == __fill) ++__fill;\n-        } while ( !empty() );\n+\t  {\n+\t    __carry.splice(__carry.begin(), *this, begin());\n+\t    \n+\t    for(__counter = &__tmp[0];\n+\t\t(__counter != __fill) && !__counter->empty();\n+\t\t++__counter)\n+\t      {\n+\t\t__counter->merge(__carry);\n+\t\t__carry.swap(*__counter);\n+\t      }\n+\t    __carry.swap(*__counter);\n+\t    if (__counter == __fill)\n+\t      ++__fill;\n+\t  }\n+\twhile ( !empty() );\n \n         for (__counter =  &__tmp[1]; __counter != __fill; ++__counter)\n           __counter->merge( *(__counter-1) );\n@@ -277,7 +280,8 @@ namespace __gnu_norm\n         {\n           iterator __next = __first;\n           ++__next;\n-          if (__pred(*__first)) _M_erase(__first);\n+          if (__pred(*__first))\n+\t    _M_erase(__first);\n           __first = __next;\n         }\n       }\n@@ -332,39 +336,41 @@ namespace __gnu_norm\n   \n   template<typename _Tp, typename _Alloc>\n     template <typename _StrictWeakOrdering>\n-    void\n-    list<_Tp,_Alloc>::\n-    sort(_StrictWeakOrdering __comp)\n-    {\n-      // Do nothing if the list has length 0 or 1.\n-      if (this->_M_node._M_next != &this->_M_node && \n-\t  this->_M_node._M_next->_M_next != &this->_M_node)\n+      void\n+      list<_Tp,_Alloc>::\n+      sort(_StrictWeakOrdering __comp)\n       {\n-        list __carry;\n-        list __tmp[64];\n-        list * __fill = &__tmp[0];\n-        list * __counter;\n-\n-        do\n-        {\n-          __carry.splice(__carry.begin(), *this, begin());\n-\n-          for(__counter = &__tmp[0];\n-              (__counter != __fill) && !__counter->empty();\n-              ++__counter)\n-          {\n-            __counter->merge(__carry, __comp);\n-            __carry.swap(*__counter);\n-          }\n-          __carry.swap(*__counter);\n-          if (__counter == __fill) ++__fill;\n-        } while ( !empty() );\n-        \n-        for (__counter =  &__tmp[1]; __counter != __fill; ++__counter)\n-          __counter->merge( *(__counter-1), __comp );\n-        swap( *(__fill-1) );\n+\t// Do nothing if the list has length 0 or 1.\n+\tif (this->_M_node._M_next != &this->_M_node\n+\t    && this->_M_node._M_next->_M_next != &this->_M_node)\n+\t  {\n+\t    list __carry;\n+\t    list __tmp[64];\n+\t    list * __fill = &__tmp[0];\n+\t    list * __counter;\n+\t    \n+\t    do\n+\t      {\n+\t\t__carry.splice(__carry.begin(), *this, begin());\n+\t\t\n+\t\tfor(__counter = &__tmp[0];\n+\t\t    (__counter != __fill) && !__counter->empty();\n+\t\t    ++__counter)\n+\t\t  {\n+\t\t    __counter->merge(__carry, __comp);\n+\t\t    __carry.swap(*__counter);\n+\t\t  }\n+\t\t__carry.swap(*__counter);\n+\t\tif (__counter == __fill)\n+\t\t  ++__fill;\n+\t      }\n+\t    while ( !empty() );\n+\t    \n+\t    for (__counter =  &__tmp[1]; __counter != __fill; ++__counter)\n+\t      __counter->merge( *(__counter-1), __comp );\n+\t    swap( *(__fill-1) );\n+\t  }\n       }\n-    }\n } // namespace __gnu_norm\n \n #endif /* _LIST_TCC */"}, {"sha": "20e6179efe53a26f92e1653893091c7cf5d4c8fc", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 1103, "deletions": 1071, "changes": 2174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Deque implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -98,239 +98,244 @@ namespace __gnu_norm\n   */\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     struct _Deque_iterator\n-  {\n-    typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n-    typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-    static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n-  \n-    typedef random_access_iterator_tag iterator_category;\n-    typedef _Tp                        value_type;\n-    typedef _Ptr                       pointer;\n-    typedef _Ref                       reference;\n-    typedef size_t                     size_type;\n-    typedef ptrdiff_t                  difference_type;\n-    typedef _Tp**                      _Map_pointer;\n-    typedef _Deque_iterator            _Self;\n-  \n-    _Tp* _M_cur;\n-    _Tp* _M_first;\n-    _Tp* _M_last;\n-    _Map_pointer _M_node;\n-  \n-    _Deque_iterator(_Tp* __x, _Map_pointer __y) \n+    {\n+      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n+      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n+\n+      static size_t _S_buffer_size()\n+      { return __deque_buf_size(sizeof(_Tp)); }\n+  \n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp                        value_type;\n+      typedef _Ptr                       pointer;\n+      typedef _Ref                       reference;\n+      typedef size_t                     size_type;\n+      typedef ptrdiff_t                  difference_type;\n+      typedef _Tp**                      _Map_pointer;\n+      typedef _Deque_iterator            _Self;\n+  \n+      _Tp* _M_cur;\n+      _Tp* _M_first;\n+      _Tp* _M_last;\n+      _Map_pointer _M_node;\n+      \n+      _Deque_iterator(_Tp* __x, _Map_pointer __y) \n       : _M_cur(__x), _M_first(*__y),\n         _M_last(*__y + _S_buffer_size()), _M_node(__y) {}\n-    _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}\n-    _Deque_iterator(const iterator& __x)\n+\n+      _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}\n+\n+      _Deque_iterator(const iterator& __x)\n       : _M_cur(__x._M_cur), _M_first(__x._M_first), \n         _M_last(__x._M_last), _M_node(__x._M_node) {}\n   \n-    reference operator*() const { return *_M_cur; }\n-    pointer operator->() const { return _M_cur; }\n-  \n-    _Self& operator++() {\n-      ++_M_cur;\n-      if (_M_cur == _M_last) {\n-        _M_set_node(_M_node + 1);\n-        _M_cur = _M_first;\n+      reference\n+      operator*() const\n+      { return *_M_cur; }\n+\n+      pointer\n+      operator->() const\n+      { return _M_cur; }\n+      \n+      _Self&\n+      operator++()\n+      {\n+\t++_M_cur;\n+\tif (_M_cur == _M_last)\n+\t  {\n+\t    _M_set_node(_M_node + 1);\n+\t    _M_cur = _M_first;\n+\t  }\n+\treturn *this; \n       }\n-      return *this; \n-    }\n-    _Self operator++(int)  {\n-      _Self __tmp = *this;\n-      ++*this;\n-      return __tmp;\n-    }\n-  \n-    _Self& operator--() {\n-      if (_M_cur == _M_first) {\n-        _M_set_node(_M_node - 1);\n-        _M_cur = _M_last;\n+\n+      _Self\n+      operator++(int)\n+      {\n+\t_Self __tmp = *this;\n+\t++*this;\n+\treturn __tmp;\n       }\n-      --_M_cur;\n-      return *this;\n-    }\n-    _Self operator--(int) {\n-      _Self __tmp = *this;\n-      --*this;\n-      return __tmp;\n-    }\n-  \n-    _Self& operator+=(difference_type __n)\n-    {\n-      difference_type __offset = __n + (_M_cur - _M_first);\n-      if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))\n-        _M_cur += __n;\n-      else {\n-        difference_type __node_offset =\n-          __offset > 0 ? __offset / difference_type(_S_buffer_size())\n-                     : -difference_type((-__offset - 1) / _S_buffer_size()) - 1;\n-        _M_set_node(_M_node + __node_offset);\n-        _M_cur = _M_first + \n-          (__offset - __node_offset * difference_type(_S_buffer_size()));\n+      \n+      _Self&\n+      operator--()\n+      {\n+\tif (_M_cur == _M_first)\n+\t  {\n+\t    _M_set_node(_M_node - 1);\n+\t    _M_cur = _M_last;\n+\t  }\n+\t--_M_cur;\n+\treturn *this;\n+      }\n+      \n+      _Self\n+      operator--(int)\n+      {\n+\t_Self __tmp = *this;\n+\t--*this;\n+\treturn __tmp;\n+      }\n+      \n+      _Self&\n+      operator+=(difference_type __n)\n+      {\n+\tconst difference_type __offset = __n + (_M_cur - _M_first);\n+\tif (__offset >= 0 && __offset < difference_type(_S_buffer_size()))\n+\t  _M_cur += __n;\n+\telse\n+\t  {\n+\t    const difference_type __node_offset =\n+\t      __offset > 0 ? __offset / difference_type(_S_buffer_size())\n+\t                   : -difference_type((-__offset - 1)\n+\t\t\t\t\t      / _S_buffer_size()) - 1;\n+\t    _M_set_node(_M_node + __node_offset);\n+\t    _M_cur = _M_first + (__offset - __node_offset\n+\t\t\t\t * difference_type(_S_buffer_size()));\n+\t  }\n+\treturn *this;\n       }\n-      return *this;\n-    }\n   \n-    _Self operator+(difference_type __n) const\n-    {\n-      _Self __tmp = *this;\n-      return __tmp += __n;\n-    }\n+      _Self\n+      operator+(difference_type __n) const\n+      {\n+\t_Self __tmp = *this;\n+\treturn __tmp += __n;\n+      }\n   \n-    _Self& operator-=(difference_type __n) { return *this += -__n; }\n+      _Self&\n+      operator-=(difference_type __n)\n+      { return *this += -__n; }\n    \n-    _Self operator-(difference_type __n) const {\n-      _Self __tmp = *this;\n-      return __tmp -= __n;\n-    }\n+      _Self\n+      operator-(difference_type __n) const\n+      {\n+\t_Self __tmp = *this;\n+\treturn __tmp -= __n;\n+      }\n   \n-    reference operator[](difference_type __n) const { return *(*this + __n); }\n+      reference\n+      operator[](difference_type __n) const\n+      { return *(*this + __n); }\n   \n-    /** @if maint\n-     *  Prepares to traverse new_node.  Sets everything except _M_cur, which\n-     *  should therefore be set by the caller immediately afterwards, based on\n-     *  _M_first and _M_last.\n-     *  @endif\n-    */\n-    void\n-    _M_set_node(_Map_pointer __new_node)\n-    {\n-      _M_node = __new_node;\n-      _M_first = *__new_node;\n-      _M_last = _M_first + difference_type(_S_buffer_size());\n-    }\n-  };\n+      /** @if maint\n+       *  Prepares to traverse new_node.  Sets everything except _M_cur, which\n+       *  should therefore be set by the caller immediately afterwards, based on\n+       *  _M_first and _M_last.\n+       *  @endif\n+       */\n+      void\n+      _M_set_node(_Map_pointer __new_node)\n+      {\n+\t_M_node = __new_node;\n+\t_M_first = *__new_node;\n+\t_M_last = _M_first + difference_type(_S_buffer_size());\n+      }\n+    };\n   \n   // Note: we also provide overloads whose operands are of the same type in\n   // order to avoid ambiguous overload resolution when std::rel_ops operators\n   // are in scope (for additional details, see libstdc++/3628)\n   template<typename _Tp, typename _Ref, typename _Ptr>\n-  inline bool\n-  operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n-  \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n-  {\n-    return __x._M_cur == __y._M_cur;\n-  }\n+    inline bool\n+    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n+\t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n+    { return __x._M_cur == __y._M_cur; }\n   \n   template<typename _Tp, typename _RefL, typename _PtrL,\n-                          typename _RefR, typename _PtrR>\n-  inline bool\n-  operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n-  \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n-  {\n-    return __x._M_cur == __y._M_cur;\n-  }\n+\t   typename _RefR, typename _PtrR>\n+    inline bool\n+    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n+\t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+    { return __x._M_cur == __y._M_cur; }\n   \n   template<typename _Tp, typename _Ref, typename _Ptr>\n-  inline bool\n-  operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n-  \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n-  {\n-    return !(__x == __y);\n-  }\n+    inline bool\n+    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n+\t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n+    { return !(__x == __y); }\n   \n   template<typename _Tp, typename _RefL, typename _PtrL,\n-                          typename _RefR, typename _PtrR>\n-  inline bool\n-  operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n-  \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n-  {\n-    return !(__x == __y);\n-  }\n+\t   typename _RefR, typename _PtrR>\n+    inline bool\n+    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n+\t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+    { return !(__x == __y); }\n   \n   template<typename _Tp, typename _Ref, typename _Ptr>\n-  inline bool\n-  operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n-  \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n-  {\n-    return (__x._M_node == __y._M_node) ? \n-      (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);\n-  }\n+    inline bool\n+    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n+\t      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n+    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n+                                          : (__x._M_node < __y._M_node); }\n   \n   template<typename _Tp, typename _RefL, typename _PtrL,\n-                          typename _RefR, typename _PtrR>\n-  inline bool\n-  operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n-  \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n-  {\n-    return (__x._M_node == __y._M_node) ? \n-      (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);\n-  }\n+\t   typename _RefR, typename _PtrR>\n+    inline bool\n+    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n+\t      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n+\t                                  : (__x._M_node < __y._M_node); }\n   \n   template<typename _Tp, typename _Ref, typename _Ptr>\n-  inline bool\n-  operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n-  \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n-  {\n-    return __y < __x;\n-  }\n+    inline bool\n+    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n+\t      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n+    { return __y < __x; }\n   \n   template<typename _Tp, typename _RefL, typename _PtrL,\n-                          typename _RefR, typename _PtrR>\n-  inline bool\n-  operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n-  \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n-  {\n-    return __y < __x;\n-  }\n+\t   typename _RefR, typename _PtrR>\n+    inline bool\n+    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n+\t      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+    { return __y < __x; }\n   \n   template<typename _Tp, typename _Ref, typename _Ptr>\n-  inline bool\n-  operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n-  \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n-  {\n-    return !(__y < __x);\n-  }\n+    inline bool\n+    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n+\t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n+    { return !(__y < __x); }\n   \n   template<typename _Tp, typename _RefL, typename _PtrL,\n-                          typename _RefR, typename _PtrR>\n-  inline bool\n-  operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n-  \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n-  {\n-    return !(__y < __x);\n-  }\n+\t   typename _RefR, typename _PtrR>\n+    inline bool\n+    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n+\t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+    { return !(__y < __x); }\n   \n   template<typename _Tp, typename _Ref, typename _Ptr>\n-  inline bool\n-  operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n-  \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n-  {\n-    return !(__x < __y);\n-  }\n+    inline bool\n+    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n+\t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n+    { return !(__x < __y); }\n   \n   template<typename _Tp, typename _RefL, typename _PtrL,\n-                          typename _RefR, typename _PtrR>\n-  inline bool\n-  operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n-  \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n-  {\n-    return !(__x < __y);\n-  }\n+\t   typename _RefR, typename _PtrR>\n+    inline bool\n+    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n+\t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+    { return !(__x < __y); }\n   \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // According to the resolution of DR179 not only the various comparison\n   // operators but also operator- must accept mixed iterator/const_iterator\n   // parameters.\n   template<typename _Tp, typename _RefL, typename _PtrL,\n-                          typename _RefR, typename _PtrR>\n-  inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type\n-  operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n-  \t  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n-  {\n-    return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type\n-      (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size()) *\n-      (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first) +\n-      (__y._M_last - __y._M_cur);\n-  }\n+\t   typename _RefR, typename _PtrR>\n+    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type\n+    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n+\t      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+    {\n+      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type\n+\t(_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())\n+\t* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)\n+\t+ (__y._M_last - __y._M_cur);\n+    }\n   \n   template<typename _Tp, typename _Ref, typename _Ptr>\n-  inline _Deque_iterator<_Tp, _Ref, _Ptr>\n-  operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n-  {\n-    return __x + __n;\n-  }\n+    inline _Deque_iterator<_Tp, _Ref, _Ptr>\n+    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n+    { return __x + __n; }\n   \n   /**\n    *  @if maint\n@@ -347,59 +352,58 @@ namespace __gnu_norm\n   template<typename _Tp, typename _Alloc>\n     class _Deque_base\n     : public _Alloc\n-  {\n-  public:\n-    typedef _Alloc                                     allocator_type;\n-    allocator_type get_allocator() const\n+    {\n+    public:\n+      typedef _Alloc                  allocator_type;\n+\n+      allocator_type\n+      get_allocator() const\n       { return *static_cast<const _Alloc*>(this); }\n \n-    typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-    typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-  \n-    _Deque_base(const allocator_type& __a, size_t __num_elements)\n+      typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+      typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+      \n+      _Deque_base(const allocator_type& __a, size_t __num_elements)\n       : _Alloc(__a), _M_start(), _M_finish()\n       { _M_initialize_map(__num_elements); }\n-    _Deque_base(const allocator_type& __a) \n-      : _Alloc(__a), _M_start(), _M_finish() {}\n-    ~_Deque_base();    \n \n-  protected:\n-    typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n-    _Map_alloc_type _M_get_map_allocator() const\n+      _Deque_base(const allocator_type& __a) \n+      : _Alloc(__a), _M_start(), _M_finish() { }\n+\n+      ~_Deque_base();    \n+\n+    protected:\n+      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n+      _Map_alloc_type _M_get_map_allocator() const\n       { return _Map_alloc_type(this->get_allocator()); }\n \n-    _Tp*\n-    _M_allocate_node()\n-    {\n-      return _Alloc::allocate(__deque_buf_size(sizeof(_Tp)));\n-    }\n-  \n-    void\n-    _M_deallocate_node(_Tp* __p)\n-    {\n-      _Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n-    }\n-  \n-    _Tp**\n-    _M_allocate_map(size_t __n) \n+      _Tp*\n+      _M_allocate_node()\n+      { return _Alloc::allocate(__deque_buf_size(sizeof(_Tp))); }\n+      \n+      void\n+      _M_deallocate_node(_Tp* __p)\n+      { _Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }\n+      \n+      _Tp**\n+      _M_allocate_map(size_t __n)\n       { return _M_get_map_allocator().allocate(__n); }\n   \n-    void\n-    _M_deallocate_map(_Tp** __p, size_t __n) \n+      void\n+      _M_deallocate_map(_Tp** __p, size_t __n) \n       { _M_get_map_allocator().deallocate(__p, __n); }\n-\n-  protected:\n-    void _M_initialize_map(size_t);\n-    void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n-    void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n-    enum { _S_initial_map_size = 8 };\n-  \n-    _Tp** _M_map;\n-    size_t _M_map_size;\n-    iterator _M_start;\n-    iterator _M_finish;\n-  };\n-  \n+      \n+    protected:\n+      void _M_initialize_map(size_t);\n+      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n+      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n+      enum { _S_initial_map_size = 8 };\n+      \n+      _Tp** _M_map;\n+      size_t _M_map_size;\n+      iterator _M_start;\n+      iterator _M_finish;\n+    };\n   \n   template<typename _Tp, typename _Alloc>\n   _Deque_base<_Tp,_Alloc>::~_Deque_base()\n@@ -422,64 +426,64 @@ namespace __gnu_norm\n    *  @endif\n   */\n   template<typename _Tp, typename _Alloc>\n-  void\n-  _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n-  {\n-    size_t __num_nodes = \n-      __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;\n-  \n-    this->_M_map_size\n-      = std::max((size_t) _S_initial_map_size, __num_nodes + 2);\n-    this->_M_map = _M_allocate_map(this->_M_map_size);\n+    void\n+    _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n+    {\n+      size_t __num_nodes = __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;\n+      \n+      this->_M_map_size = std::max((size_t) _S_initial_map_size,\n+\t\t\t\t   __num_nodes + 2);\n+      this->_M_map = _M_allocate_map(this->_M_map_size);\n   \n-    // For \"small\" maps (needing less than _M_map_size nodes), allocation\n-    // starts in the middle elements and grows outwards.  So nstart may be the\n-    // beginning of _M_map, but for small maps it may be as far in as _M_map+3.\n+      // For \"small\" maps (needing less than _M_map_size nodes), allocation\n+      // starts in the middle elements and grows outwards.  So nstart may be\n+      // the beginning of _M_map, but for small maps it may be as far in as\n+      // _M_map+3.\n   \n-    _Tp** __nstart = this->_M_map + (this->_M_map_size - __num_nodes) / 2;\n-    _Tp** __nfinish = __nstart + __num_nodes;\n+      _Tp** __nstart = this->_M_map + (this->_M_map_size - __num_nodes) / 2;\n+      _Tp** __nfinish = __nstart + __num_nodes;\n       \n-    try \n-      { _M_create_nodes(__nstart, __nfinish); }\n-    catch(...)\n-      {\n-        _M_deallocate_map(this->_M_map, this->_M_map_size);\n-        this->_M_map = 0;\n-        this->_M_map_size = 0;\n-        __throw_exception_again;\n-      }\n-    \n-    _M_start._M_set_node(__nstart);\n-    _M_finish._M_set_node(__nfinish - 1);\n-    _M_start._M_cur = _M_start._M_first;\n-    _M_finish._M_cur = _M_finish._M_first +\n-                       __num_elements % __deque_buf_size(sizeof(_Tp));\n-  }\n+      try \n+\t{ _M_create_nodes(__nstart, __nfinish); }\n+      catch(...)\n+\t{\n+\t  _M_deallocate_map(this->_M_map, this->_M_map_size);\n+\t  this->_M_map = 0;\n+\t  this->_M_map_size = 0;\n+\t  __throw_exception_again;\n+\t}\n+      \n+      _M_start._M_set_node(__nstart);\n+      _M_finish._M_set_node(__nfinish - 1);\n+      _M_start._M_cur = _M_start._M_first;\n+      _M_finish._M_cur = _M_finish._M_first + __num_elements\n+\t                 % __deque_buf_size(sizeof(_Tp));\n+    }\n   \n   template<typename _Tp, typename _Alloc>\n-  void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n-  {\n-    _Tp** __cur;\n-    try\n-      {\n-        for (__cur = __nstart; __cur < __nfinish; ++__cur)\n-          *__cur = this->_M_allocate_node();\n-      }\n-    catch(...)\n-      { \n-        _M_destroy_nodes(__nstart, __cur);\n-        __throw_exception_again; \n-      }\n-  }\n+    void\n+    _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n+    {\n+      _Tp** __cur;\n+      try\n+\t{\n+\t  for (__cur = __nstart; __cur < __nfinish; ++__cur)\n+\t    *__cur = this->_M_allocate_node();\n+\t}\n+      catch(...)\n+\t{ \n+\t  _M_destroy_nodes(__nstart, __cur);\n+\t  __throw_exception_again; \n+\t}\n+    }\n   \n   template<typename _Tp, typename _Alloc>\n-  void\n-  _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n-  {\n-    for (_Tp** __n = __nstart; __n < __nfinish; ++__n)\n-      _M_deallocate_node(*__n);\n-  }\n-  \n+    void\n+    _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n+    {\n+      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)\n+\t_M_deallocate_node(*__n);\n+    }\n   \n   /**\n    *  @brief  A standard container using fixed-size memory allocation and\n@@ -567,820 +571,851 @@ namespace __gnu_norm\n   */\n   template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     class deque : protected _Deque_base<_Tp, _Alloc>\n-  {\n-    // concept requirements\n-    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-  \n-    typedef _Deque_base<_Tp, _Alloc>           _Base;\n-  \n-  public:\n-    typedef _Tp                                value_type;\n-    typedef value_type*                        pointer;\n-    typedef const value_type*                  const_pointer;\n-    typedef typename _Base::iterator           iterator;\n-    typedef typename _Base::const_iterator     const_iterator;\n-    typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n-    typedef std::reverse_iterator<iterator>         reverse_iterator;\n-    typedef value_type&                        reference;\n-    typedef const value_type&                  const_reference;\n-    typedef size_t                             size_type;\n-    typedef ptrdiff_t                          difference_type;\n-    typedef typename _Base::allocator_type     allocator_type;\n-  \n-  protected:\n-    typedef pointer*                           _Map_pointer;\n-    static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n-  \n-    // Functions controlling memory layout, and nothing else.\n-    using _Base::_M_initialize_map;\n-    using _Base::_M_create_nodes;\n-    using _Base::_M_destroy_nodes;\n-    using _Base::_M_allocate_node;\n-    using _Base::_M_deallocate_node;\n-    using _Base::_M_allocate_map;\n-    using _Base::_M_deallocate_map;\n-  \n-    /** @if maint\n-     *  A total of four data members accumulated down the heirarchy.\n-     *  @endif\n-    */\n-    using _Base::_M_map;\n-    using _Base::_M_map_size;\n-    using _Base::_M_start;\n-    using _Base::_M_finish;\n-  \n-  public:\n-    // [23.2.1.1] construct/copy/destroy\n-    // (assign() and get_allocator() are also listed in this section)\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    deque(const allocator_type& __a = allocator_type()) \n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+\t\n+      typedef _Deque_base<_Tp, _Alloc>           _Base;\n+      \n+    public:\n+      typedef _Tp                                value_type;\n+      typedef value_type*                        pointer;\n+      typedef const value_type*                  const_pointer;\n+      typedef typename _Base::iterator           iterator;\n+      typedef typename _Base::const_iterator     const_iterator;\n+      typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>         reverse_iterator;\n+      typedef value_type&                        reference;\n+      typedef const value_type&                  const_reference;\n+      typedef size_t                             size_type;\n+      typedef ptrdiff_t                          difference_type;\n+      typedef typename _Base::allocator_type     allocator_type;\n+      \n+    protected:\n+      typedef pointer*                           _Map_pointer;\n+      \n+      static size_t _S_buffer_size()\n+      { return __deque_buf_size(sizeof(_Tp)); }\n+      \n+      // Functions controlling memory layout, and nothing else.\n+      using _Base::_M_initialize_map;\n+      using _Base::_M_create_nodes;\n+      using _Base::_M_destroy_nodes;\n+      using _Base::_M_allocate_node;\n+      using _Base::_M_deallocate_node;\n+      using _Base::_M_allocate_map;\n+      using _Base::_M_deallocate_map;\n+      \n+      /** @if maint\n+       *  A total of four data members accumulated down the heirarchy.\n+       *  @endif\n+       */\n+      using _Base::_M_map;\n+      using _Base::_M_map_size;\n+      using _Base::_M_start;\n+      using _Base::_M_finish;\n+      \n+    public:\n+      // [23.2.1.1] construct/copy/destroy\n+      // (assign() and get_allocator() are also listed in this section)\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      deque(const allocator_type& __a = allocator_type()) \n       : _Base(__a, 0) {}\n   \n-    /**\n-     *  @brief  Create a %deque with copies of an exemplar element.\n-     *  @param  n  The number of elements to initially create.\n-     *  @param  value  An element to copy.\n-     * \n-     *  This constructor fills the %deque with @a n copies of @a value.\n-    */\n-    deque(size_type __n, const value_type& __value,\n-          const allocator_type& __a = allocator_type())\n+      /**\n+       *  @brief  Create a %deque with copies of an exemplar element.\n+       *  @param  n  The number of elements to initially create.\n+       *  @param  value  An element to copy.\n+       * \n+       *  This constructor fills the %deque with @a n copies of @a value.\n+       */\n+      deque(size_type __n, const value_type& __value,\n+\t    const allocator_type& __a = allocator_type())\n       : _Base(__a, __n)\n       { _M_fill_initialize(__value); }\n   \n-    /**\n-     *  @brief  Create a %deque with default elements.\n-     *  @param  n  The number of elements to initially create.\n-     * \n-     *  This constructor fills the %deque with @a n copies of a\n-     *  default-constructed element.\n-    */\n-    explicit\n-    deque(size_type __n)\n+      /**\n+       *  @brief  Create a %deque with default elements.\n+       *  @param  n  The number of elements to initially create.\n+       * \n+       *  This constructor fills the %deque with @a n copies of a\n+       *  default-constructed element.\n+       */\n+      explicit\n+      deque(size_type __n)\n       : _Base(allocator_type(), __n)\n       { _M_fill_initialize(value_type()); }\n   \n-    /**\n-     *  @brief  %Deque copy constructor.\n-     *  @param  x  A %deque of identical element and allocator types.\n-     * \n-     *  The newly-created %deque uses a copy of the allocation object used\n-     *  by @a x.\n-    */\n-    deque(const deque& __x)\n+      /**\n+       *  @brief  %Deque copy constructor.\n+       *  @param  x  A %deque of identical element and allocator types.\n+       * \n+       *  The newly-created %deque uses a copy of the allocation object used\n+       *  by @a x.\n+       */\n+      deque(const deque& __x)\n       : _Base(__x.get_allocator(), __x.size()) \n       { std::uninitialized_copy(__x.begin(), __x.end(), this->_M_start); }\n   \n-    /**\n-     *  @brief  Builds a %deque from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     * \n-     *  Create a %deque consisting of copies of the elements from [first,last).\n-     *\n-     *  If the iterators are forward, bidirectional, or random-access, then\n-     *  this will call the elements' copy constructor N times (where N is\n-     *  distance(first,last)) and do no memory reallocation.  But if only\n-     *  input iterators are used, then this will do at most 2N calls to the\n-     *  copy constructor, and logN memory reallocations.\n-    */\n-    template<typename _InputIterator>\n-      deque(_InputIterator __first, _InputIterator __last,\n-            const allocator_type& __a = allocator_type())\n-        : _Base(__a)\n+      /**\n+       *  @brief  Builds a %deque from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       * \n+       *  Create a %deque consisting of copies of the elements from [first,\n+       *  last).\n+       *\n+       *  If the iterators are forward, bidirectional, or random-access, then\n+       *  this will call the elements' copy constructor N times (where N is\n+       *  distance(first,last)) and do no memory reallocation.  But if only\n+       *  input iterators are used, then this will do at most 2N calls to the\n+       *  copy constructor, and logN memory reallocations.\n+       */\n+      template<typename _InputIterator>\n+        deque(_InputIterator __first, _InputIterator __last,\n+\t      const allocator_type& __a = allocator_type())\n+\t: _Base(__a)\n+        {\n+\t  // Check whether it's an integral type.  If so, it's not an iterator.\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_initialize_dispatch(__first, __last, _Integral());\n+\t}\n+  \n+      /**\n+       *  The dtor only erases the elements, and note that if the elements\n+       *  themselves are pointers, the pointed-to memory is not touched in any\n+       *  way.  Managing the pointer is the user's responsibilty.\n+       */\n+      ~deque()\n+      { std::_Destroy(this->_M_start, this->_M_finish); }\n+  \n+      /**\n+       *  @brief  %Deque assignment operator.\n+       *  @param  x  A %deque of identical element and allocator types.\n+       * \n+       *  All the elements of @a x are copied, but unlike the copy constructor,\n+       *  the allocator object is not copied.\n+       */\n+      deque&\n+      operator=(const deque& __x);\n+  \n+      /**\n+       *  @brief  Assigns a given value to a %deque.\n+       *  @param  n  Number of elements to be assigned.\n+       *  @param  val  Value to be assigned.\n+       *\n+       *  This function fills a %deque with @a n copies of the given value.\n+       *  Note that the assignment completely changes the %deque and that the\n+       *  resulting %deque's size is the same as the number of elements assigned.\n+       *  Old data may be lost.\n+       */\n+      void\n+      assign(size_type __n, const value_type& __val)\n+      { _M_fill_assign(__n, __val); }\n+  \n+      /**\n+       *  @brief  Assigns a range to a %deque.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function fills a %deque with copies of the elements in the\n+       *  range [first,last).\n+       *\n+       *  Note that the assignment completely changes the %deque and that the\n+       *  resulting %deque's size is the same as the number of elements\n+       *  assigned.  Old data may be lost.\n+       */\n+      template<typename _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_assign_dispatch(__first, __last, _Integral());\n+\t}\n+  \n+      /// Get a copy of the memory allocation object.\n+      allocator_type\n+      get_allocator() const\n+      { return _Base::get_allocator(); }\n+      \n+      // iterators\n+      /**\n+       *  Returns a read/write iterator that points to the first element in the\n+       *  %deque.  Iteration is done in ordinary element order.\n+       */\n+      iterator\n+      begin()\n+      { return this->_M_start; }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %deque.  Iteration is done in ordinary element order.\n+       */\n+      const_iterator\n+      begin() const\n+      { return this->_M_start; }\n+      \n+      /**\n+       *  Returns a read/write iterator that points one past the last element in\n+       *  the %deque.  Iteration is done in ordinary element order.\n+       */\n+      iterator\n+      end()\n+      { return this->_M_finish; }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %deque.  Iteration is done in ordinary element order.\n+       */\n+      const_iterator\n+      end() const\n+      { return this->_M_finish; }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to the last element\n+       *  in the %deque.  Iteration is done in reverse element order.\n+       */\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(this->_M_finish); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to the\n+       *  last element in the %deque.  Iteration is done in reverse element\n+       *  order.\n+       */\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(this->_M_finish); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to one before the\n+       *  first element in the %deque.  Iteration is done in reverse element\n+       *  order.\n+       */\n+      reverse_iterator\n+      rend() { return reverse_iterator(this->_M_start); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to one\n+       *  before the first element in the %deque.  Iteration is done in reverse\n+       *  element order.\n+       */\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(this->_M_start); }\n+      \n+      // [23.2.1.2] capacity\n+      /**  Returns the number of elements in the %deque.  */\n+      size_type\n+      size() const\n+      { return this->_M_finish - this->_M_start; }\n+      \n+      /**  Returns the size() of the largest possible %deque.  */\n+      size_type\n+      max_size() const\n+      { return size_type(-1); }\n+      \n+      /**\n+       *  @brief  Resizes the %deque to the specified number of elements.\n+       *  @param  new_size  Number of elements the %deque should contain.\n+       *  @param  x  Data with which new elements should be populated.\n+       *\n+       *  This function will %resize the %deque to the specified number of\n+       *  elements.  If the number is smaller than the %deque's current size the\n+       *  %deque is truncated, otherwise the %deque is extended and new elements\n+       *  are populated with given data.\n+       */\n+      void\n+      resize(size_type __new_size, const value_type& __x)\n       {\n-        // Check whether it's an integral type.  If so, it's not an iterator.\n-        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_initialize_dispatch(__first, __last, _Integral());\n+\tconst size_type __len = size();\n+\tif (__new_size < __len) \n+\t  erase(this->_M_start + __new_size, this->_M_finish);\n+\telse\n+\t  insert(this->_M_finish, __new_size - __len, __x);\n       }\n-  \n-    /**\n-     *  The dtor only erases the elements, and note that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n-    */\n-    ~deque() { std::_Destroy(this->_M_start, this->_M_finish); }\n-  \n-    /**\n-     *  @brief  %Deque assignment operator.\n-     *  @param  x  A %deque of identical element and allocator types.\n-     * \n-     *  All the elements of @a x are copied, but unlike the copy constructor,\n-     *  the allocator object is not copied.\n-    */\n-    deque&\n-    operator=(const deque& __x);\n-  \n-    /**\n-     *  @brief  Assigns a given value to a %deque.\n-     *  @param  n  Number of elements to be assigned.\n-     *  @param  val  Value to be assigned.\n-     *\n-     *  This function fills a %deque with @a n copies of the given value.\n-     *  Note that the assignment completely changes the %deque and that the\n-     *  resulting %deque's size is the same as the number of elements assigned.\n-     *  Old data may be lost.\n-    */\n-    void\n-    assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n-  \n-    /**\n-     *  @brief  Assigns a range to a %deque.\n-     *  @param  first  An input iterator.\n-     *  @param  last   An input iterator.\n-     *\n-     *  This function fills a %deque with copies of the elements in the\n-     *  range [first,last).\n-     *\n-     *  Note that the assignment completely changes the %deque and that the\n-     *  resulting %deque's size is the same as the number of elements assigned.\n-     *  Old data may be lost.\n-    */\n-    template<typename _InputIterator>\n+      \n+      /**\n+       *  @brief  Resizes the %deque to the specified number of elements.\n+       *  @param  new_size  Number of elements the %deque should contain.\n+       *\n+       *  This function will resize the %deque to the specified number of\n+       *  elements.  If the number is smaller than the %deque's current size the\n+       *  %deque is truncated, otherwise the %deque is extended and new elements\n+       *  are default-constructed.\n+       */\n       void\n-      assign(_InputIterator __first, _InputIterator __last)\n+      resize(size_type new_size)\n+      { resize(new_size, value_type()); }\n+  \n+      /**\n+       *  Returns true if the %deque is empty.  (Thus begin() would equal end().)\n+       */\n+      bool\n+      empty() const\n+      { return this->_M_finish == this->_M_start; }\n+  \n+      // element access\n+      /**\n+       *  @brief  Subscript access to the data contained in the %deque.\n+       *  @param  n  The index of the element for which data should be accessed.\n+       *  @return  Read/write reference to data.\n+       *\n+       *  This operator allows for easy, array-style, data access.\n+       *  Note that data access with this operator is unchecked and out_of_range\n+       *  lookups are not defined. (For checked lookups see at().)\n+       */\n+      reference\n+      operator[](size_type __n)\n+      { return this->_M_start[difference_type(__n)]; }\n+      \n+      /**\n+       *  @brief  Subscript access to the data contained in the %deque.\n+       *  @param  n  The index of the element for which data should be accessed.\n+       *  @return  Read-only (constant) reference to data.\n+       *\n+       *  This operator allows for easy, array-style, data access.\n+       *  Note that data access with this operator is unchecked and out_of_range\n+       *  lookups are not defined. (For checked lookups see at().)\n+       */\n+      const_reference\n+      operator[](size_type __n) const\n+      { return this->_M_start[difference_type(__n)]; }\n+  \n+    protected:\n+      /// @if maint Safety check used only from at().  @endif\n+      void\n+      _M_range_check(size_type __n) const\n       {\n-        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_assign_dispatch(__first, __last, _Integral());\n+\tif (__n >= this->size())\n+\t  __throw_out_of_range(__N(\"deque::_M_range_check\"));\n       }\n-  \n-    /// Get a copy of the memory allocation object.\n-    allocator_type\n-    get_allocator() const { return _Base::get_allocator(); }\n-  \n-    // iterators\n-    /**\n-     *  Returns a read/write iterator that points to the first element in the\n-     *  %deque.  Iteration is done in ordinary element order.\n-    */\n-    iterator\n-    begin() { return this->_M_start; }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points to the first element\n-     *  in the %deque.  Iteration is done in ordinary element order.\n-    */\n-    const_iterator\n-    begin() const { return this->_M_start; }\n-  \n-    /**\n-     *  Returns a read/write iterator that points one past the last element in\n-     *  the %deque.  Iteration is done in ordinary element order.\n-    */\n-    iterator\n-    end() { return this->_M_finish; }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points one past the last\n-     *  element in the %deque.  Iteration is done in ordinary element order.\n-    */\n-    const_iterator\n-    end() const { return this->_M_finish; }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to the last element in\n-     *  the %deque.  Iteration is done in reverse element order.\n-    */\n-    reverse_iterator\n-    rbegin() { return reverse_iterator(this->_M_finish); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to the last\n-     *  element in the %deque.  Iteration is done in reverse element order.\n-    */\n-    const_reverse_iterator\n-    rbegin() const { return const_reverse_iterator(this->_M_finish); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to one before the\n-     *  first element in the %deque.  Iteration is done in reverse element\n-     *  order.\n-    */\n-    reverse_iterator\n-    rend() { return reverse_iterator(this->_M_start); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to one\n-     *  before the first element in the %deque.  Iteration is done in reverse\n-     *  element order.\n-    */\n-    const_reverse_iterator\n-    rend() const { return const_reverse_iterator(this->_M_start); }\n-  \n-    // [23.2.1.2] capacity\n-    /**  Returns the number of elements in the %deque.  */\n-    size_type\n-    size() const { return this->_M_finish - this->_M_start; }\n-  \n-    /**  Returns the size() of the largest possible %deque.  */\n-    size_type\n-    max_size() const { return size_type(-1); }\n-  \n-    /**\n-     *  @brief  Resizes the %deque to the specified number of elements.\n-     *  @param  new_size  Number of elements the %deque should contain.\n-     *  @param  x  Data with which new elements should be populated.\n-     *\n-     *  This function will %resize the %deque to the specified number of\n-     *  elements.  If the number is smaller than the %deque's current size the\n-     *  %deque is truncated, otherwise the %deque is extended and new elements\n-     *  are populated with given data.\n-    */\n-    void\n-    resize(size_type __new_size, const value_type& __x)\n-    {\n-      const size_type __len = size();\n-      if (__new_size < __len) \n-        erase(this->_M_start + __new_size, this->_M_finish);\n-      else\n-        insert(this->_M_finish, __new_size - __len, __x);\n-    }\n-  \n-    /**\n-     *  @brief  Resizes the %deque to the specified number of elements.\n-     *  @param  new_size  Number of elements the %deque should contain.\n-     *\n-     *  This function will resize the %deque to the specified number of\n-     *  elements.  If the number is smaller than the %deque's current size the\n-     *  %deque is truncated, otherwise the %deque is extended and new elements\n-     *  are default-constructed.\n-    */\n-    void\n-    resize(size_type new_size) { resize(new_size, value_type()); }\n-  \n-    /**\n-     *  Returns true if the %deque is empty.  (Thus begin() would equal end().)\n-    */\n-    bool empty() const { return this->_M_finish == this->_M_start; }\n-  \n-    // element access\n-    /**\n-     *  @brief  Subscript access to the data contained in the %deque.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read/write reference to data.\n-     *\n-     *  This operator allows for easy, array-style, data access.\n-     *  Note that data access with this operator is unchecked and out_of_range\n-     *  lookups are not defined. (For checked lookups see at().)\n-    */\n-    reference\n-    operator[](size_type __n) { return this->_M_start[difference_type(__n)]; }\n-  \n-    /**\n-     *  @brief  Subscript access to the data contained in the %deque.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read-only (constant) reference to data.\n-     *\n-     *  This operator allows for easy, array-style, data access.\n-     *  Note that data access with this operator is unchecked and out_of_range\n-     *  lookups are not defined. (For checked lookups see at().)\n-    */\n-    const_reference\n-    operator[](size_type __n) const {\n-      return this->_M_start[difference_type(__n)];\n-    }\n-  \n-  protected:\n-    /// @if maint Safety check used only from at().  @endif\n-    void\n-    _M_range_check(size_type __n) const\n-    {\n-      if (__n >= this->size())\n-        __throw_out_of_range(__N(\"deque::_M_range_check\"));\n-    }\n-  \n-  public:\n-    /**\n-     *  @brief  Provides access to the data contained in the %deque.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read/write reference to data.\n-     *  @throw  std::out_of_range  If @a n is an invalid index.\n-     *\n-     *  This function provides for safer data access.  The parameter is first\n-     *  checked that it is in the range of the deque.  The function throws\n-     *  out_of_range if the check fails.\n-    */\n-    reference\n-    at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n-  \n-    /**\n-     *  @brief  Provides access to the data contained in the %deque.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read-only (constant) reference to data.\n-     *  @throw  std::out_of_range  If @a n is an invalid index.\n-     *\n-     *  This function provides for safer data access.  The parameter is first\n-     *  checked that it is in the range of the deque.  The function throws\n-     *  out_of_range if the check fails.\n-    */\n-    const_reference\n-    at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the first element of the\n-     *  %deque.\n-    */\n-    reference\n-    front() { return *this->_M_start; }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the first\n-     *  element of the %deque.\n-    */\n-    const_reference\n-    front() const { return *this->_M_start; }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the last element of the\n-     *  %deque.\n-    */\n-    reference\n-    back()\n-    {\n-      iterator __tmp = this->_M_finish;\n-      --__tmp;\n-      return *__tmp;\n-    }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the last\n-     *  element of the %deque.\n-    */\n-    const_reference\n-    back() const\n-    {\n-      const_iterator __tmp = this->_M_finish;\n-      --__tmp;\n-      return *__tmp;\n-    }\n-  \n-    // [23.2.1.2] modifiers\n-    /**\n-     *  @brief  Add data to the front of the %deque.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical stack operation.  The function creates an element at\n-     *  the front of the %deque and assigns the given data to it.  Due to the\n-     *  nature of a %deque this operation can be done in constant time.\n-    */\n-    void\n-    push_front(const value_type& __x) \n-    {\n-      if (this->_M_start._M_cur != this->_M_start._M_first) {\n-        std::_Construct(this->_M_start._M_cur - 1, __x);\n-        --this->_M_start._M_cur;\n-      }\n-      else\n-        _M_push_front_aux(__x);\n-    }\n-  \n-    /**\n-     *  @brief  Add data to the end of the %deque.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical stack operation.  The function creates an element at\n-     *  the end of the %deque and assigns the given data to it.  Due to the\n-     *  nature of a %deque this operation can be done in constant time.\n-    */\n-    void\n-    push_back(const value_type& __x)\n-    {\n-      if (this->_M_finish._M_cur != this->_M_finish._M_last - 1) {\n-        std::_Construct(this->_M_finish._M_cur, __x);\n-        ++this->_M_finish._M_cur;\n+      \n+    public:\n+      /**\n+       *  @brief  Provides access to the data contained in the %deque.\n+       *  @param  n  The index of the element for which data should be accessed.\n+       *  @return  Read/write reference to data.\n+       *  @throw  std::out_of_range  If @a n is an invalid index.\n+       *\n+       *  This function provides for safer data access.  The parameter is first\n+       *  checked that it is in the range of the deque.  The function throws\n+       *  out_of_range if the check fails.\n+       */\n+      reference\n+      at(size_type __n)\n+      { _M_range_check(__n); return (*this)[__n]; }\n+      \n+      /**\n+       *  @brief  Provides access to the data contained in the %deque.\n+       *  @param  n  The index of the element for which data should be accessed.\n+       *  @return  Read-only (constant) reference to data.\n+       *  @throw  std::out_of_range  If @a n is an invalid index.\n+       *\n+       *  This function provides for safer data access.  The parameter is first\n+       *  checked that it is in the range of the deque.  The function throws\n+       *  out_of_range if the check fails.\n+       */\n+      const_reference\n+      at(size_type __n) const\n+      {\n+\t_M_range_check(__n);\n+\treturn (*this)[__n];\n       }\n-      else\n-        _M_push_back_aux(__x);\n-    }\n-  \n-    /**\n-     *  @brief  Removes first element.\n-     *\n-     *  This is a typical stack operation.  It shrinks the %deque by one.\n-     *\n-     *  Note that no data is returned, and if the first element's data is\n-     *  needed, it should be retrieved before pop_front() is called.\n-    */\n-    void\n-    pop_front()\n-    {\n-      if (this->_M_start._M_cur != this->_M_start._M_last - 1) {\n-        std::_Destroy(this->_M_start._M_cur);\n-        ++this->_M_start._M_cur;\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the first element of the\n+       *  %deque.\n+       */\n+      reference\n+      front()\n+      { return *this->_M_start; }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the first\n+       *  element of the %deque.\n+       */\n+      const_reference\n+      front() const\n+      { return *this->_M_start; }\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the last element of the\n+       *  %deque.\n+       */\n+      reference\n+      back()\n+      {\n+\titerator __tmp = this->_M_finish;\n+\t--__tmp;\n+\treturn *__tmp;\n       }\n-      else \n-        _M_pop_front_aux();\n-    }\n-  \n-    /**\n-     *  @brief  Removes last element.\n-     *\n-     *  This is a typical stack operation.  It shrinks the %deque by one.\n-     *\n-     *  Note that no data is returned, and if the last element's data is\n-     *  needed, it should be retrieved before pop_back() is called.\n-    */\n-    void\n-    pop_back()\n-    {\n-      if (this->_M_finish._M_cur != this->_M_finish._M_first) {\n-        --this->_M_finish._M_cur;\n-        std::_Destroy(this->_M_finish._M_cur);\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the last\n+       *  element of the %deque.\n+       */\n+      const_reference\n+      back() const\n+      {\n+\tconst_iterator __tmp = this->_M_finish;\n+\t--__tmp;\n+\treturn *__tmp;\n       }\n-      else\n-        _M_pop_back_aux();\n-    }\n-  \n-    /**\n-     *  @brief  Inserts given value into %deque before specified iterator.\n-     *  @param  position  An iterator into the %deque.\n-     *  @param  x  Data to be inserted.\n-     *  @return  An iterator that points to the inserted data.\n-     *\n-     *  This function will insert a copy of the given value before the specified\n-     *  location.\n-    */\n-    iterator\n-    insert(iterator position, const value_type& __x);\n-  \n-    /**\n-     *  @brief  Inserts a number of copies of given data into the %deque.\n-     *  @param  position  An iterator into the %deque.\n-     *  @param  n  Number of elements to be inserted.\n-     *  @param  x  Data to be inserted.\n-     *\n-     *  This function will insert a specified number of copies of the given data\n-     *  before the location specified by @a position.\n-    */\n-    void\n-    insert(iterator __position, size_type __n, const value_type& __x)\n-    { _M_fill_insert(__position, __n, __x); }\n-  \n-    /**\n-     *  @brief  Inserts a range into the %deque.\n-     *  @param  position  An iterator into the %deque.\n-     *  @param  first  An input iterator.\n-     *  @param  last   An input iterator.\n-     *\n-     *  This function will insert copies of the data in the range [first,last)\n-     *  into the %deque before the location specified by @a pos.  This is\n-     *  known as \"range insert.\"\n-    */\n-    template<typename _InputIterator>\n+      \n+      // [23.2.1.2] modifiers\n+      /**\n+       *  @brief  Add data to the front of the %deque.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical stack operation.  The function creates an element at\n+       *  the front of the %deque and assigns the given data to it.  Due to the\n+       *  nature of a %deque this operation can be done in constant time.\n+       */\n       void\n-      insert(iterator __position, _InputIterator __first, _InputIterator __last)\n+      push_front(const value_type& __x) \n       {\n-        // Check whether it's an integral type.  If so, it's not an iterator.\n-        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_insert_dispatch(__position, __first, __last, _Integral());\n+\tif (this->_M_start._M_cur != this->_M_start._M_first)\n+\t  {\n+\t    std::_Construct(this->_M_start._M_cur - 1, __x);\n+\t    --this->_M_start._M_cur;\n+\t  }\n+\telse\n+\t  _M_push_front_aux(__x);\n       }\n-  \n-    /**\n-     *  @brief  Remove element at given position.\n-     *  @param  position  Iterator pointing to element to be erased.\n-     *  @return  An iterator pointing to the next element (or end()).\n-     *\n-     *  This function will erase the element at the given position and thus\n-     *  shorten the %deque by one.\n-     *\n-     *  The user is cautioned that\n-     *  this function only erases the element, and that if the element is itself\n-     *  a pointer, the pointed-to memory is not touched in any way.  Managing\n-     *  the pointer is the user's responsibilty.\n-    */\n-    iterator\n-    erase(iterator __position);\n-  \n-    /**\n-     *  @brief  Remove a range of elements.\n-     *  @param  first  Iterator pointing to the first element to be erased.\n-     *  @param  last  Iterator pointing to one past the last element to be\n-     *                erased.\n-     *  @return  An iterator pointing to the element pointed to by @a last\n-     *           prior to erasing (or end()).\n-     *\n-     *  This function will erase the elements in the range [first,last) and\n-     *  shorten the %deque accordingly.\n-     *\n-     *  The user is cautioned that\n-     *  this function only erases the elements, and that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n-    */\n-    iterator\n-    erase(iterator __first, iterator __last);\n-  \n-    /**\n-     *  @brief  Swaps data with another %deque.\n-     *  @param  x  A %deque of the same element and allocator types.\n-     *\n-     *  This exchanges the elements between two deques in constant time.\n-     *  (Four pointers, so it should be quite fast.)\n-     *  Note that the global std::swap() function is specialized such that\n-     *  std::swap(d1,d2) will feed to this function.\n-    */\n-    void\n-    swap(deque& __x)\n-    {\n-      std::swap(this->_M_start, __x._M_start);\n-      std::swap(this->_M_finish, __x._M_finish);\n-      std::swap(this->_M_map, __x._M_map);\n-      std::swap(this->_M_map_size, __x._M_map_size);\n-    }\n-  \n-    /**\n-     *  Erases all the elements.  Note that this function only erases the\n-     *  elements, and that if the elements themselves are pointers, the\n-     *  pointed-to memory is not touched in any way.  Managing the pointer is\n-     *  the user's responsibilty.\n-    */\n-    void clear(); \n-  \n-  protected:\n-    // Internal constructor functions follow.\n-  \n-    // called by the range constructor to implement [23.1.1]/9\n-    template<typename _Integer>\n+      \n+      /**\n+       *  @brief  Add data to the end of the %deque.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical stack operation.  The function creates an element at\n+       *  the end of the %deque and assigns the given data to it.  Due to the\n+       *  nature of a %deque this operation can be done in constant time.\n+       */\n       void\n-      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+      push_back(const value_type& __x)\n       {\n-        _M_initialize_map(__n);\n-        _M_fill_initialize(__x);\n+\tif (this->_M_finish._M_cur != this->_M_finish._M_last - 1)\n+\t  {\n+\t    std::_Construct(this->_M_finish._M_cur, __x);\n+\t    ++this->_M_finish._M_cur;\n+\t  }\n+\telse\n+\t  _M_push_back_aux(__x);\n       }\n   \n-    // called by the range constructor to implement [23.1.1]/9\n-    template<typename _InputIterator>\n+      /**\n+       *  @brief  Removes first element.\n+       *\n+       *  This is a typical stack operation.  It shrinks the %deque by one.\n+       *\n+       *  Note that no data is returned, and if the first element's data is\n+       *  needed, it should be retrieved before pop_front() is called.\n+       */\n       void\n-      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n-                             __false_type)\n+      pop_front()\n       {\n-        typedef typename iterator_traits<_InputIterator>::iterator_category\n-                         _IterCategory;\n-        _M_range_initialize(__first, __last, _IterCategory());\n+\tif (this->_M_start._M_cur != this->_M_start._M_last - 1)\n+\t  {\n+\t    std::_Destroy(this->_M_start._M_cur);\n+\t    ++this->_M_start._M_cur;\n+\t  }\n+\telse \n+\t  _M_pop_front_aux();\n       }\n-  \n-    // called by the second initialize_dispatch above\n-    //@{\n-    /**\n-     *  @if maint\n-     *  @brief Fills the deque with whatever is in [first,last).\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *  @return   Nothing.\n-     *\n-     *  If the iterators are actually forward iterators (or better), then the\n-     *  memory layout can be done all at once.  Else we move forward using\n-     *  push_back on each value from the iterator.\n-     *  @endif\n-    */\n-    template<typename _InputIterator>\n+      \n+      /**\n+       *  @brief  Removes last element.\n+       *\n+       *  This is a typical stack operation.  It shrinks the %deque by one.\n+       *\n+       *  Note that no data is returned, and if the last element's data is\n+       *  needed, it should be retrieved before pop_back() is called.\n+       */\n       void\n-      _M_range_initialize(_InputIterator __first, _InputIterator __last,\n-                          input_iterator_tag);\n-  \n-    // called by the second initialize_dispatch above\n-    template<typename _ForwardIterator>\n+      pop_back()\n+      {\n+\tif (this->_M_finish._M_cur != this->_M_finish._M_first)\n+\t  {\n+\t    --this->_M_finish._M_cur;\n+\t    std::_Destroy(this->_M_finish._M_cur);\n+\t  }\n+\telse\n+\t  _M_pop_back_aux();\n+      }\n+      \n+      /**\n+       *  @brief  Inserts given value into %deque before specified iterator.\n+       *  @param  position  An iterator into the %deque.\n+       *  @param  x  Data to be inserted.\n+       *  @return  An iterator that points to the inserted data.\n+       *\n+       *  This function will insert a copy of the given value before the\n+       *  specified location.\n+       */\n+      iterator\n+      insert(iterator position, const value_type& __x);\n+      \n+      /**\n+       *  @brief  Inserts a number of copies of given data into the %deque.\n+       *  @param  position  An iterator into the %deque.\n+       *  @param  n  Number of elements to be inserted.\n+       *  @param  x  Data to be inserted.\n+       *\n+       *  This function will insert a specified number of copies of the given\n+       *  data before the location specified by @a position.\n+       */\n       void\n-      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n-                          forward_iterator_tag);\n-    //@}\n-  \n-    /**\n-     *  @if maint\n-     *  @brief Fills the %deque with copies of value.\n-     *  @param  value  Initial value.\n-     *  @return   Nothing.\n-     *  @pre _M_start and _M_finish have already been initialized, but none of\n-     *       the %deque's elements have yet been constructed.\n-     *\n-     *  This function is called only when the user provides an explicit size\n-     *  (with or without an explicit exemplar value).\n-     *  @endif\n-    */\n-    void\n-    _M_fill_initialize(const value_type& __value);\n-  \n-  \n-    // Internal assign functions follow.  The *_aux functions do the actual\n-    // assignment work for the range versions.\n-  \n-    // called by the range assign to implement [23.1.1]/9\n-    template<typename _Integer>\n+      insert(iterator __position, size_type __n, const value_type& __x)\n+      { _M_fill_insert(__position, __n, __x); }\n+      \n+      /**\n+       *  @brief  Inserts a range into the %deque.\n+       *  @param  position  An iterator into the %deque.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function will insert copies of the data in the range [first,last)\n+       *  into the %deque before the location specified by @a pos.  This is\n+       *  known as \"range insert.\"\n+       */\n+      template<typename _InputIterator>\n+        void\n+        insert(iterator __position, _InputIterator __first,\n+\t       _InputIterator __last)\n+        {\n+\t  // Check whether it's an integral type.  If so, it's not an iterator.\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_insert_dispatch(__position, __first, __last, _Integral());\n+\t}\n+      \n+      /**\n+       *  @brief  Remove element at given position.\n+       *  @param  position  Iterator pointing to element to be erased.\n+       *  @return  An iterator pointing to the next element (or end()).\n+       *\n+       *  This function will erase the element at the given position and thus\n+       *  shorten the %deque by one.\n+       *\n+       *  The user is cautioned that\n+       *  this function only erases the element, and that if the element is\n+       *  itself a pointer, the pointed-to memory is not touched in any way.\n+       *  Managing the pointer is the user's responsibilty.\n+       */\n+      iterator\n+      erase(iterator __position);\n+      \n+      /**\n+       *  @brief  Remove a range of elements.\n+       *  @param  first  Iterator pointing to the first element to be erased.\n+       *  @param  last  Iterator pointing to one past the last element to be\n+       *                erased.\n+       *  @return  An iterator pointing to the element pointed to by @a last\n+       *           prior to erasing (or end()).\n+       *\n+       *  This function will erase the elements in the range [first,last) and\n+       *  shorten the %deque accordingly.\n+       *\n+       *  The user is cautioned that\n+       *  this function only erases the elements, and that if the elements\n+       *  themselves are pointers, the pointed-to memory is not touched in any\n+       *  way.  Managing the pointer is the user's responsibilty.\n+       */\n+      iterator\n+      erase(iterator __first, iterator __last);\n+  \n+      /**\n+       *  @brief  Swaps data with another %deque.\n+       *  @param  x  A %deque of the same element and allocator types.\n+       *\n+       *  This exchanges the elements between two deques in constant time.\n+       *  (Four pointers, so it should be quite fast.)\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(d1,d2) will feed to this function.\n+       */\n       void\n-      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+      swap(deque& __x)\n       {\n-        _M_fill_assign(static_cast<size_type>(__n),\n-                       static_cast<value_type>(__val));\n+\tstd::swap(this->_M_start, __x._M_start);\n+\tstd::swap(this->_M_finish, __x._M_finish);\n+\tstd::swap(this->_M_map, __x._M_map);\n+\tstd::swap(this->_M_map_size, __x._M_map_size);\n       }\n-  \n-    // called by the range assign to implement [23.1.1]/9\n-    template<typename _InputIterator>\n+      \n+      /**\n+       *  Erases all the elements.  Note that this function only erases the\n+       *  elements, and that if the elements themselves are pointers, the\n+       *  pointed-to memory is not touched in any way.  Managing the pointer is\n+       *  the user's responsibilty.\n+       */\n+      void clear(); \n+      \n+    protected:\n+      // Internal constructor functions follow.\n+      \n+      // called by the range constructor to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+        {\n+\t  _M_initialize_map(__n);\n+\t  _M_fill_initialize(__x);\n+\t}\n+      \n+      // called by the range constructor to implement [23.1.1]/9\n+      template<typename _InputIterator>\n+        void\n+        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t       __false_type)\n+        {\n+\t  typedef typename iterator_traits<_InputIterator>::iterator_category\n+\t    _IterCategory;\n+\t  _M_range_initialize(__first, __last, _IterCategory());\n+\t}\n+  \n+      // called by the second initialize_dispatch above\n+      //@{\n+      /**\n+       *  @if maint\n+       *  @brief Fills the deque with whatever is in [first,last).\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *  @return   Nothing.\n+       *\n+       *  If the iterators are actually forward iterators (or better), then the\n+       *  memory layout can be done all at once.  Else we move forward using\n+       *  push_back on each value from the iterator.\n+       *  @endif\n+       */\n+      template<typename _InputIterator>\n+        void  \n+        _M_range_initialize(_InputIterator __first, _InputIterator __last,\n+\t\t\t    input_iterator_tag);\n+  \n+      // called by the second initialize_dispatch above\n+      template<typename _ForwardIterator>\n+        void \n+        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\t    forward_iterator_tag);\n+      //@}\n+      \n+      /**\n+       *  @if maint\n+       *  @brief Fills the %deque with copies of value.\n+       *  @param  value  Initial value.\n+       *  @return   Nothing.\n+       *  @pre _M_start and _M_finish have already been initialized, but none of\n+       *       the %deque's elements have yet been constructed.\n+       *\n+       *  This function is called only when the user provides an explicit size\n+       *  (with or without an explicit exemplar value).\n+       *  @endif\n+       */\n       void\n-      _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)\n+      _M_fill_initialize(const value_type& __value);\n+      \n+      // Internal assign functions follow.  The *_aux functions do the actual\n+      // assignment work for the range versions.\n+      \n+      // called by the range assign to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+        {\n+\t  _M_fill_assign(static_cast<size_type>(__n),\n+\t\t\t static_cast<value_type>(__val));\n+\t}\n+  \n+      // called by the range assign to implement [23.1.1]/9\n+      template<typename _InputIterator>\n+        void\n+        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t   __false_type)\n+        {\n+\t  typedef typename iterator_traits<_InputIterator>::iterator_category\n+\t    _IterCategory;\n+\t  _M_assign_aux(__first, __last, _IterCategory());\n+\t}\n+  \n+      // called by the second assign_dispatch above\n+      template<typename _InputIterator>\n+        void\n+        _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t      input_iterator_tag);\n+  \n+      // called by the second assign_dispatch above\n+      template<typename _ForwardIterator>\n+        void\n+        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t      forward_iterator_tag)\n+        {\n+\t  const size_type __len = std::distance(__first, __last);\n+\t  if (__len > size())\n+\t    {\n+\t      _ForwardIterator __mid = __first;\n+\t      std::advance(__mid, size());\n+\t      std::copy(__first, __mid, begin());\n+\t      insert(end(), __mid, __last);\n+\t    }\n+\t  else\n+\t    erase(std::copy(__first, __last, begin()), end());\n+\t}\n+  \n+      // Called by assign(n,t), and the range assign when it turns out to be the\n+      // same thing.\n+      void\n+      _M_fill_assign(size_type __n, const value_type& __val)\n       {\n-        typedef typename iterator_traits<_InputIterator>::iterator_category\n-                         _IterCategory;\n-        _M_assign_aux(__first, __last, _IterCategory());\n+\tif (__n > size())\n+\t  {\n+\t    std::fill(begin(), end(), __val);\n+\t    insert(end(), __n - size(), __val);\n+\t  }\n+\telse\n+\t  {\n+\t    erase(begin() + __n, end());\n+\t    std::fill(begin(), end(), __val);\n+\t  }\n       }\n   \n-    // called by the second assign_dispatch above\n-    template<typename _InputIterator>\n+      //@{\n+      /**\n+       *  @if maint\n+       *  @brief Helper functions for push_* and pop_*.\n+       *  @endif\n+       */\n+      void _M_push_back_aux(const value_type&);\n+      void _M_push_front_aux(const value_type&);\n+      void _M_pop_back_aux();\n+      void _M_pop_front_aux();\n+      //@}\n+    \n+      // Internal insert functions follow.  The *_aux functions do the actual\n+      // insertion work when all shortcuts fail.\n+  \n+      // called by the range insert to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_insert_dispatch(iterator __pos,\n+\t\t\t   _Integer __n, _Integer __x, __true_type)\n+        {\n+\t  _M_fill_insert(__pos, static_cast<size_type>(__n),\n+\t\t\t static_cast<value_type>(__x));\n+\t}\n+  \n+      // called by the range insert to implement [23.1.1]/9\n+      template<typename _InputIterator>\n+        void\n+        _M_insert_dispatch(iterator __pos,\n+\t\t\t   _InputIterator __first, _InputIterator __last,\n+\t\t\t   __false_type)\n+        {\n+\t  typedef typename iterator_traits<_InputIterator>::iterator_category\n+\t    _IterCategory;\n+          _M_range_insert_aux(__pos, __first, __last, _IterCategory());\n+\t}\n+  \n+      // called by the second insert_dispatch above\n+      template<typename _InputIterator>\n+        void\n+        _M_range_insert_aux(iterator __pos, _InputIterator __first,\n+\t\t\t    _InputIterator __last, input_iterator_tag);\n+  \n+      // called by the second insert_dispatch above\n+      template<typename _ForwardIterator>\n+        void\n+        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n+\t\t\t    _ForwardIterator __last, forward_iterator_tag);\n+  \n+      // Called by insert(p,n,x), and the range insert when it turns out to be\n+      // the same thing.  Can use fill functions in optimal situations,\n+      // otherwise passes off to insert_aux(p,n,x).\n       void\n-      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-                    input_iterator_tag);\n+      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n   \n-    // called by the second assign_dispatch above\n-    template<typename _ForwardIterator>\n-      void\n-      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                    forward_iterator_tag)\n-      {\n-        size_type __len = std::distance(__first, __last);\n-        if (__len > size()) {\n-          _ForwardIterator __mid = __first;\n-          std::advance(__mid, size());\n-          std::copy(__first, __mid, begin());\n-          insert(end(), __mid, __last);\n-        }\n-        else\n-          erase(std::copy(__first, __last, begin()), end());\n-      }\n+      // called by insert(p,x)\n+      iterator\n+      _M_insert_aux(iterator __pos, const value_type& __x);\n   \n-    // Called by assign(n,t), and the range assign when it turns out to be the\n-    // same thing.\n-    void\n-    _M_fill_assign(size_type __n, const value_type& __val)\n-    {\n-      if (__n > size())\n+      // called by insert(p,n,x) via fill_insert\n+      void\n+      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n+  \n+      // called by range_insert_aux for forward iterators\n+      template<typename _ForwardIterator>\n+        void\n+        _M_insert_aux(iterator __pos, \n+\t\t      _ForwardIterator __first, _ForwardIterator __last,\n+\t\t      size_type __n);\n+  \n+      //@{\n+      /**\n+       *  @if maint\n+       *  @brief Memory-handling helpers for the previous internal insert\n+       *         functions.\n+       *  @endif\n+       */\n+      iterator\n+      _M_reserve_elements_at_front(size_type __n)\n       {\n-        std::fill(begin(), end(), __val);\n-        insert(end(), __n - size(), __val);\n+\tconst size_type __vacancies = this->_M_start._M_cur\n+\t                              - this->_M_start._M_first;\n+\tif (__n > __vacancies)\n+\t  _M_new_elements_at_front(__n - __vacancies);\n+\treturn this->_M_start - difference_type(__n);\n       }\n-      else\n+      \n+      iterator\n+      _M_reserve_elements_at_back(size_type __n)\n       {\n-        erase(begin() + __n, end());\n-        std::fill(begin(), end(), __val);\n+\tconst size_type __vacancies = (this->_M_finish._M_last\n+\t\t\t\t       - this->_M_finish._M_cur) - 1;\n+\tif (__n > __vacancies)\n+\t  _M_new_elements_at_back(__n - __vacancies);\n+\treturn this->_M_finish + difference_type(__n);\n       }\n-    }\n-  \n-  \n-    //@{\n-    /**\n-     *  @if maint\n-     *  @brief Helper functions for push_* and pop_*.\n-     *  @endif\n-    */\n-    void _M_push_back_aux(const value_type&);\n-    void _M_push_front_aux(const value_type&);\n-    void _M_pop_back_aux();\n-    void _M_pop_front_aux();\n-    //@}\n-  \n-  \n-    // Internal insert functions follow.  The *_aux functions do the actual\n-    // insertion work when all shortcuts fail.\n-  \n-    // called by the range insert to implement [23.1.1]/9\n-    template<typename _Integer>\n+      \n+      void\n+      _M_new_elements_at_front(size_type __new_elements);\n+      \n+      void\n+      _M_new_elements_at_back(size_type __new_elements);\n+      //@}\n+      \n+      \n+      //@{\n+      /**\n+       *  @if maint\n+       *  @brief Memory-handling helpers for the major %map.\n+       *\n+       *  Makes sure the _M_map has space for new nodes.  Does not actually add\n+       *  the nodes.  Can invalidate _M_map pointers.  (And consequently, %deque\n+       *  iterators.)\n+       *  @endif\n+       */\n       void\n-      _M_insert_dispatch(iterator __pos,\n-                         _Integer __n, _Integer __x, __true_type)\n+      _M_reserve_map_at_back (size_type __nodes_to_add = 1)\n       {\n-        _M_fill_insert(__pos, static_cast<size_type>(__n),\n-                       static_cast<value_type>(__x));\n+\tif (__nodes_to_add + 1 > this->_M_map_size\n+\t    - (this->_M_finish._M_node - this->_M_map))\n+\t  _M_reallocate_map(__nodes_to_add, false);\n       }\n   \n-    // called by the range insert to implement [23.1.1]/9\n-    template<typename _InputIterator>\n       void\n-      _M_insert_dispatch(iterator __pos,\n-                         _InputIterator __first, _InputIterator __last,\n-                         __false_type)\n+      _M_reserve_map_at_front (size_type __nodes_to_add = 1)\n       {\n-        typedef typename iterator_traits<_InputIterator>::iterator_category\n-                         _IterCategory;\n-        _M_range_insert_aux(__pos, __first, __last, _IterCategory());\n+\tif (__nodes_to_add > size_type(this->_M_start._M_node - this->_M_map))\n+\t  _M_reallocate_map(__nodes_to_add, true);\n       }\n   \n-    // called by the second insert_dispatch above\n-    template<typename _InputIterator>\n-      void\n-      _M_range_insert_aux(iterator __pos, _InputIterator __first,\n-                          _InputIterator __last, input_iterator_tag);\n-  \n-    // called by the second insert_dispatch above\n-    template<typename _ForwardIterator>\n       void\n-      _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n-                          _ForwardIterator __last, forward_iterator_tag);\n-  \n-    // Called by insert(p,n,x), and the range insert when it turns out to be\n-    // the same thing.  Can use fill functions in optimal situations, otherwise\n-    // passes off to insert_aux(p,n,x).\n-    void\n-    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n-  \n-    // called by insert(p,x)\n-    iterator\n-    _M_insert_aux(iterator __pos, const value_type& __x);\n-  \n-    // called by insert(p,n,x) via fill_insert\n-    void\n-    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n-  \n-    // called by range_insert_aux for forward iterators\n-    template<typename _ForwardIterator>\n-      void\n-      _M_insert_aux(iterator __pos, \n-                    _ForwardIterator __first, _ForwardIterator __last,\n-                    size_type __n);\n-  \n-    //@{\n-    /**\n-     *  @if maint\n-     *  @brief Memory-handling helpers for the previous internal insert\n-     *         functions.\n-     *  @endif\n-    */\n-    iterator\n-    _M_reserve_elements_at_front(size_type __n)\n-    {\n-      size_type __vacancies = this->_M_start._M_cur - this->_M_start._M_first;\n-      if (__n > __vacancies) \n-        _M_new_elements_at_front(__n - __vacancies);\n-      return this->_M_start - difference_type(__n);\n-    }\n-  \n-    iterator\n-    _M_reserve_elements_at_back(size_type __n)\n-    {\n-      size_type __vacancies\n-\t= (this->_M_finish._M_last - this->_M_finish._M_cur) - 1;\n-      if (__n > __vacancies)\n-        _M_new_elements_at_back(__n - __vacancies);\n-      return this->_M_finish + difference_type(__n);\n-    }\n-  \n-    void\n-    _M_new_elements_at_front(size_type __new_elements);\n-  \n-    void\n-    _M_new_elements_at_back(size_type __new_elements);\n-    //@}\n-  \n-  \n-    //@{\n-    /**\n-     *  @if maint\n-     *  @brief Memory-handling helpers for the major %map.\n-     *\n-     *  Makes sure the _M_map has space for new nodes.  Does not actually add\n-     *  the nodes.  Can invalidate _M_map pointers.  (And consequently, %deque\n-     *  iterators.)\n-     *  @endif\n-    */\n-    void\n-    _M_reserve_map_at_back (size_type __nodes_to_add = 1)\n-    {\n-      if (__nodes_to_add + 1 \n-\t  > this->_M_map_size - (this->_M_finish._M_node - this->_M_map))\n-        _M_reallocate_map(__nodes_to_add, false);\n-    }\n-  \n-    void\n-    _M_reserve_map_at_front (size_type __nodes_to_add = 1)\n-    {\n-      if (__nodes_to_add > size_type(this->_M_start._M_node - this->_M_map))\n-        _M_reallocate_map(__nodes_to_add, true);\n-    }\n-  \n-    void\n-    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n-    //@}\n-  };\n+      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n+      //@}\n+    };\n   \n   \n   /**\n@@ -1394,12 +1429,11 @@ namespace __gnu_norm\n    *  and if corresponding elements compare equal.\n   */\n   template<typename _Tp, typename _Alloc>\n-  inline bool operator==(const deque<_Tp, _Alloc>& __x,\n+    inline bool\n+    operator==(const deque<_Tp, _Alloc>& __x,\n                          const deque<_Tp, _Alloc>& __y)\n-  {\n-    return __x.size() == __y.size() &&\n-           std::equal(__x.begin(), __x.end(), __y.begin());\n-  }\n+    { return __x.size() == __y.size()\n+             && std::equal(__x.begin(), __x.end(), __y.begin()); }\n   \n   /**\n    *  @brief  Deque ordering relation.\n@@ -1413,47 +1447,45 @@ namespace __gnu_norm\n    *  See std::lexicographical_compare() for how the determination is made.\n   */\n   template<typename _Tp, typename _Alloc>\n-  inline bool operator<(const deque<_Tp, _Alloc>& __x,\n-                        const deque<_Tp, _Alloc>& __y)\n-  {\n-    return lexicographical_compare(__x.begin(), __x.end(), \n-                                   __y.begin(), __y.end());\n-  }\n+    inline bool\n+    operator<(const deque<_Tp, _Alloc>& __x,\n+\t      const deque<_Tp, _Alloc>& __y)\n+    { return lexicographical_compare(__x.begin(), __x.end(), \n+\t\t\t\t     __y.begin(), __y.end()); }\n   \n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>\n-  inline bool operator!=(const deque<_Tp, _Alloc>& __x,\n-                         const deque<_Tp, _Alloc>& __y) {\n-    return !(__x == __y);\n-  }\n+    inline bool\n+    operator!=(const deque<_Tp, _Alloc>& __x,\n+\t       const deque<_Tp, _Alloc>& __y)\n+    { return !(__x == __y); }\n   \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n-  inline bool operator>(const deque<_Tp, _Alloc>& __x,\n-                        const deque<_Tp, _Alloc>& __y) {\n-    return __y < __x;\n-  }\n+    inline bool\n+    operator>(const deque<_Tp, _Alloc>& __x,\n+\t      const deque<_Tp, _Alloc>& __y)\n+    { return __y < __x; }\n   \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n-  inline bool operator<=(const deque<_Tp, _Alloc>& __x,\n-                         const deque<_Tp, _Alloc>& __y) {\n-    return !(__y < __x);\n-  }\n+    inline bool\n+    operator<=(const deque<_Tp, _Alloc>& __x,\n+\t       const deque<_Tp, _Alloc>& __y)\n+    { return !(__y < __x); }\n   \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n-  inline bool operator>=(const deque<_Tp, _Alloc>& __x,\n-                         const deque<_Tp, _Alloc>& __y) {\n-    return !(__x < __y);\n-  }\n+    inline bool\n+    operator>=(const deque<_Tp, _Alloc>& __x,\n+\t       const deque<_Tp, _Alloc>& __y)\n+    { return !(__x < __y); }\n   \n   /// See std::deque::swap().\n   template<typename _Tp, typename _Alloc>\n-  inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n-  {\n-    __x.swap(__y);\n-  }\n+    inline void\n+    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n+    { __x.swap(__y); }\n } // namespace __gnu_norm\n   \n #endif /* _DEQUE_H */"}, {"sha": "f7ddffc347cd7802ebe4b1899595a2a10040dd13", "filename": "libstdc++-v3/include/bits/stl_function.h", "status": "modified", "additions": 803, "deletions": 659, "changes": 1462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Functor implementations -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -63,668 +63,812 @@\n \n namespace std\n {\n-// 20.3.1 base classes\n-/** @defgroup s20_3_1_base Functor Base Classes\n- *  Function objects, or @e functors, are objects with an @c operator()\n- *  defined and accessible.  They can be passed as arguments to algorithm\n- *  templates and used in place of a function pointer.  Not only is the\n- *  resulting expressiveness of the library increased, but the generated\n- *  code can be more efficient than what you might write by hand.  When we\n- *  refer to \"functors,\" then, generally we include function pointers in\n- *  the description as well.\n- *\n- *  Often, functors are only created as temporaries passed to algorithm\n- *  calls, rather than being created as named variables.\n- *\n- *  Two examples taken from the standard itself follow.  To perform a\n- *  by-element addition of two vectors @c a and @c b containing @c double,\n- *  and put the result in @c a, use\n- *  \\code\n- *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());\n- *  \\endcode\n- *  To negate every element in @c a, use\n- *  \\code\n- *  transform(a.begin(), a.end(), a.begin(), negate<double>());\n- *  \\endcode\n- *  The addition and negation functions will be inlined directly.\n- *\n- *  The standard functiors are derived from structs named @c unary_function\n- *  and @c binary_function.  These two classes contain nothing but typedefs,\n- *  to aid in generic (template) programming.  If you write your own\n- *  functors, you might consider doing the same.\n- *\n- *  @{\n-*/\n-/**\n- *  This is one of the @link s20_3_1_base functor base classes@endlink.\n-*/\n-template <class _Arg, class _Result>\n-struct unary_function {\n-  typedef _Arg argument_type;   ///< @c argument_type is the type of the argument (no surprises here)\n-  typedef _Result result_type;  ///< @c result_type is the return type\n-};\n-\n-/**\n- *  This is one of the @link s20_3_1_base functor base classes@endlink.\n-*/\n-template <class _Arg1, class _Arg2, class _Result>\n-struct binary_function {\n-  typedef _Arg1 first_argument_type;   ///< the type of the first argument (no surprises here)\n-  typedef _Arg2 second_argument_type;  ///< the type of the second argument\n-  typedef _Result result_type;         ///< type of the return type\n-};      \n-/** @}  */\n-\n-// 20.3.2 arithmetic\n-/** @defgroup s20_3_2_arithmetic Arithmetic Classes\n- *  Because basic math often needs to be done during an algorithm, the library\n- *  provides functors for those operations.  See the documentation for\n- *  @link s20_3_1_base the base classes@endlink for examples of their use.\n- *\n- *  @{\n-*/\n-/// One of the @link s20_3_2_arithmetic math functors@endlink.\n-template <class _Tp>\n-struct plus : public binary_function<_Tp,_Tp,_Tp> {\n-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }\n-};\n-\n-/// One of the @link s20_3_2_arithmetic math functors@endlink.\n-template <class _Tp>\n-struct minus : public binary_function<_Tp,_Tp,_Tp> {\n-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }\n-};\n-\n-/// One of the @link s20_3_2_arithmetic math functors@endlink.\n-template <class _Tp>\n-struct multiplies : public binary_function<_Tp,_Tp,_Tp> {\n-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }\n-};\n-\n-/// One of the @link s20_3_2_arithmetic math functors@endlink.\n-template <class _Tp>\n-struct divides : public binary_function<_Tp,_Tp,_Tp> {\n-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }\n-};\n-\n-/// One of the @link s20_3_2_arithmetic math functors@endlink.\n-template <class _Tp>\n-struct modulus : public binary_function<_Tp,_Tp,_Tp> \n-{\n-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }\n-};\n-\n-/// One of the @link s20_3_2_arithmetic math functors@endlink.\n-template <class _Tp>\n-struct negate : public unary_function<_Tp,_Tp> \n-{\n-  _Tp operator()(const _Tp& __x) const { return -__x; }\n-};\n-/** @}  */\n-\n-// 20.3.3 comparisons\n-/** @defgroup s20_3_3_comparisons Comparison Classes\n- *  The library provides six wrapper functors for all the basic comparisons\n- *  in C++, like @c <.\n- *\n- *  @{\n-*/\n-/// One of the @link s20_3_3_comparisons comparison functors@endlink.\n-template <class _Tp>\n-struct equal_to : public binary_function<_Tp,_Tp,bool> \n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }\n-};\n-\n-/// One of the @link s20_3_3_comparisons comparison functors@endlink.\n-template <class _Tp>\n-struct not_equal_to : public binary_function<_Tp,_Tp,bool> \n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }\n-};\n-\n-/// One of the @link s20_3_3_comparisons comparison functors@endlink.\n-template <class _Tp>\n-struct greater : public binary_function<_Tp,_Tp,bool> \n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }\n-};\n-\n-/// One of the @link s20_3_3_comparisons comparison functors@endlink.\n-template <class _Tp>\n-struct less : public binary_function<_Tp,_Tp,bool> \n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }\n-};\n-\n-/// One of the @link s20_3_3_comparisons comparison functors@endlink.\n-template <class _Tp>\n-struct greater_equal : public binary_function<_Tp,_Tp,bool>\n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }\n-};\n-\n-/// One of the @link s20_3_3_comparisons comparison functors@endlink.\n-template <class _Tp>\n-struct less_equal : public binary_function<_Tp,_Tp,bool> \n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }\n-};\n-/** @}  */\n-\n-// 20.3.4 logical operations\n-/** @defgroup s20_3_4_logical Boolean Operations Classes\n- *  Here are wrapper functors for Boolean operations:  @c &&, @c ||, and @c !.\n- *\n- *  @{\n-*/\n-/// One of the @link s20_3_4_logical Boolean operations functors@endlink.\n-template <class _Tp>\n-struct logical_and : public binary_function<_Tp,_Tp,bool>\n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }\n-};\n+  // 20.3.1 base classes\n+  /** @defgroup s20_3_1_base Functor Base Classes\n+   *  Function objects, or @e functors, are objects with an @c operator()\n+   *  defined and accessible.  They can be passed as arguments to algorithm\n+   *  templates and used in place of a function pointer.  Not only is the\n+   *  resulting expressiveness of the library increased, but the generated\n+   *  code can be more efficient than what you might write by hand.  When we\n+   *  refer to \"functors,\" then, generally we include function pointers in\n+   *  the description as well.\n+   *\n+   *  Often, functors are only created as temporaries passed to algorithm\n+   *  calls, rather than being created as named variables.\n+   *\n+   *  Two examples taken from the standard itself follow.  To perform a\n+   *  by-element addition of two vectors @c a and @c b containing @c double,\n+   *  and put the result in @c a, use\n+   *  \\code\n+   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());\n+   *  \\endcode\n+   *  To negate every element in @c a, use\n+   *  \\code\n+   *  transform(a.begin(), a.end(), a.begin(), negate<double>());\n+   *  \\endcode\n+   *  The addition and negation functions will be inlined directly.\n+   *\n+   *  The standard functiors are derived from structs named @c unary_function\n+   *  and @c binary_function.  These two classes contain nothing but typedefs,\n+   *  to aid in generic (template) programming.  If you write your own\n+   *  functors, you might consider doing the same.\n+   *\n+   *  @{\n+   */\n+  /**\n+   *  This is one of the @link s20_3_1_base functor base classes@endlink.\n+   */\n+  template <class _Arg, class _Result>\n+    struct unary_function\n+    {\n+      typedef _Arg argument_type;   ///< @c argument_type is the type of the\n+                                    ///     argument (no surprises here)\n+\n+      typedef _Result result_type;  ///< @c result_type is the return type\n+    };\n+\n+  /**\n+   *  This is one of the @link s20_3_1_base functor base classes@endlink.\n+   */\n+  template <class _Arg1, class _Arg2, class _Result>\n+    struct binary_function\n+    {\n+      typedef _Arg1 first_argument_type;   ///< the type of the first argument\n+                                           ///  (no surprises here)\n+\n+      typedef _Arg2 second_argument_type;  ///< the type of the second argument\n+      typedef _Result result_type;         ///< type of the return type\n+    };      \n+  /** @}  */\n+\n+  // 20.3.2 arithmetic\n+  /** @defgroup s20_3_2_arithmetic Arithmetic Classes\n+   *  Because basic math often needs to be done during an algorithm, the library\n+   *  provides functors for those operations.  See the documentation for\n+   *  @link s20_3_1_base the base classes@endlink for examples of their use.\n+   *\n+   *  @{\n+   */\n+  /// One of the @link s20_3_2_arithmetic math functors@endlink.\n+  template <class _Tp>\n+    struct plus : public binary_function<_Tp,_Tp,_Tp>\n+    { \n+      _Tp\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x + __y; }\n+    };\n+\n+  /// One of the @link s20_3_2_arithmetic math functors@endlink.\n+  template <class _Tp>\n+    struct minus : public binary_function<_Tp,_Tp,_Tp>\n+    {\n+      _Tp\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x - __y; }\n+    };\n+\n+  /// One of the @link s20_3_2_arithmetic math functors@endlink.\n+  template <class _Tp>\n+    struct multiplies : public binary_function<_Tp,_Tp,_Tp>\n+    {\n+      _Tp\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x * __y; }\n+    };\n+\n+  /// One of the @link s20_3_2_arithmetic math functors@endlink.\n+  template <class _Tp>\n+    struct divides : public binary_function<_Tp,_Tp,_Tp>\n+    {\n+      _Tp\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x / __y; }\n+    };\n+\n+  /// One of the @link s20_3_2_arithmetic math functors@endlink.\n+  template <class _Tp>\n+    struct modulus : public binary_function<_Tp,_Tp,_Tp> \n+    {\n+      _Tp\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x % __y; }\n+    };\n+\n+  /// One of the @link s20_3_2_arithmetic math functors@endlink.\n+  template <class _Tp>\n+    struct negate : public unary_function<_Tp,_Tp> \n+    {\n+      _Tp\n+      operator()(const _Tp& __x) const\n+      { return -__x; }\n+    };\n+  /** @}  */\n+\n+  // 20.3.3 comparisons\n+  /** @defgroup s20_3_3_comparisons Comparison Classes\n+   *  The library provides six wrapper functors for all the basic comparisons\n+   *  in C++, like @c <.\n+   *\n+   *  @{\n+   */\n+  /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n+  template <class _Tp>\n+    struct equal_to : public binary_function<_Tp,_Tp,bool> \n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x == __y; }\n+    };\n+\n+  /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n+  template <class _Tp>\n+    struct not_equal_to : public binary_function<_Tp,_Tp,bool> \n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x != __y; }\n+    };\n+\n+  /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n+  template <class _Tp>\n+    struct greater : public binary_function<_Tp,_Tp,bool> \n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x > __y; }\n+    };\n+\n+  /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n+  template <class _Tp>\n+    struct less : public binary_function<_Tp,_Tp,bool> \n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x < __y; }\n+    };\n+\n+  /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n+  template <class _Tp>\n+    struct greater_equal : public binary_function<_Tp,_Tp,bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x >= __y; }\n+    };\n+\n+  /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n+  template <class _Tp>\n+    struct less_equal : public binary_function<_Tp,_Tp,bool> \n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x <= __y; }\n+    };\n+  /** @}  */\n+  \n+  // 20.3.4 logical operations\n+  /** @defgroup s20_3_4_logical Boolean Operations Classes\n+   *  Here are wrapper functors for Boolean operations:  @c &&, @c ||, and @c !.\n+   *\n+   *  @{\n+   */\n+  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.\n+  template <class _Tp>\n+    struct logical_and : public binary_function<_Tp,_Tp,bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x && __y; }\n+    };\n+\n+  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.\n+  template <class _Tp>\n+    struct logical_or : public binary_function<_Tp,_Tp,bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x || __y; }\n+    };\n+\n+  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.\n+  template <class _Tp>\n+    struct logical_not : public unary_function<_Tp,bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x) const\n+      { return !__x; }\n+    };\n+  /** @}  */\n+\n+  // 20.3.5 negators\n+  /** @defgroup s20_3_5_negators Negators\n+   *  The functions @c not1 and @c not2 each take a predicate functor\n+   *  and return an instance of @c unary_negate or\n+   *  @c binary_negate, respectively.  These classes are functors whose\n+   *  @c operator() performs the stored predicate function and then returns\n+   *  the negation of the result.\n+   *\n+   *  For example, given a vector of integers and a trivial predicate,\n+   *  \\code\n+   *  struct IntGreaterThanThree\n+   *    : public std::unary_function<int, bool>\n+   *  {\n+   *      bool operator() (int x) { return x > 3; }\n+   *  };\n+   *  \n+   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));\n+   *  \\endcode\n+   *  The call to @c find_if will locate the first index (i) of @c v for which\n+   *  \"!(v[i] > 3)\" is true.\n+   *\n+   *  The not1/unary_negate combination works on predicates taking a single\n+   *  argument.  The not2/binary_negate combination works on predicates which\n+   *  take two arguments.\n+   *\n+   *  @{\n+   */\n+  /// One of the @link s20_3_5_negators negation functors@endlink.\n+  template <class _Predicate>\n+    class unary_negate\n+    : public unary_function<typename _Predicate::argument_type, bool>\n+    {\n+    protected:\n+      _Predicate _M_pred;\n+    public:\n+      explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}\n+      \n+      bool\n+      operator()(const typename _Predicate::argument_type& __x) const\n+      { return !_M_pred(__x); }\n+    };\n+\n+  /// One of the @link s20_3_5_negators negation functors@endlink.\n+  template <class _Predicate>\n+    inline unary_negate<_Predicate> \n+    not1(const _Predicate& __pred)\n+    { return unary_negate<_Predicate>(__pred); }\n+\n+  /// One of the @link s20_3_5_negators negation functors@endlink.\n+  template <class _Predicate> \n+    class binary_negate \n+    : public binary_function<typename _Predicate::first_argument_type,\n+\t\t\t     typename _Predicate::second_argument_type,\n+\t\t\t     bool>\n+    {\n+    protected:\n+      _Predicate _M_pred;\n+    public:\n+      explicit binary_negate(const _Predicate& __x)\n+\t: _M_pred(__x) { }\n+\n+      bool\n+      operator()(const typename _Predicate::first_argument_type& __x, \n+\t\t const typename _Predicate::second_argument_type& __y) const\n+      { return !_M_pred(__x, __y); }\n+    };\n+\n+  /// One of the @link s20_3_5_negators negation functors@endlink.\n+  template <class _Predicate>\n+    inline binary_negate<_Predicate> \n+    not2(const _Predicate& __pred)\n+    { return binary_negate<_Predicate>(__pred); }\n+  /** @}  */\n+  \n+  // 20.3.6 binders\n+  /** @defgroup s20_3_6_binder Binder Classes\n+   *  Binders turn functions/functors with two arguments into functors with\n+   *  a single argument, storing an argument to be applied later.  For\n+   *  example, an variable @c B of type @c binder1st is constructed from a\n+   *  functor @c f and an argument @c x.  Later, B's @c operator() is called\n+   *  with a single argument @c y.  The return value is the value of @c f(x,y).\n+   *  @c B can be \"called\" with various arguments (y1, y2, ...) and will in\n+   *  turn call @c f(x,y1), @c f(x,y2), ...\n+   *\n+   *  The function @c bind1st is provided to save some typing.  It takes the\n+   *  function and an argument as parameters, and returns an instance of\n+   *  @c binder1st.\n+   *\n+   *  The type @c binder2nd and its creator function @c bind2nd do the same\n+   *  thing, but the stored argument is passed as the second parameter instead\n+   *  of the first, e.g., @c bind2nd(std::minus<float>,1.3) will create a\n+   *  functor whose @c operator() accepts a floating-point number, subtracts\n+   *  1.3 from it, and returns the result.  (If @c bind1st had been used,\n+   *  the functor would perform \"1.3 - x\" instead.\n+   *\n+   *  Creator-wrapper functions like @c bind1st are intended to be used in\n+   *  calling algorithms.  Their return values will be temporary objects.\n+   *  (The goal is to not require you to type names like\n+   *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the\n+   *  return value from @c bind1st(std::plus<int>,5).\n+   *\n+   *  These become more useful when combined with the composition functions.\n+   *\n+   *  @{\n+   */\n+  /// One of the @link s20_3_6_binder binder functors@endlink.\n+  template <class _Operation> \n+    class binder1st\n+    : public unary_function<typename _Operation::second_argument_type,\n+\t\t\t    typename _Operation::result_type>\n+    {\n+    protected:\n+      _Operation op;\n+      typename _Operation::first_argument_type value;\n+    public:\n+      binder1st(const _Operation& __x,\n+\t\tconst typename _Operation::first_argument_type& __y)\n+\t: op(__x), value(__y) {}\n+\n+      typename _Operation::result_type\n+      operator()(const typename _Operation::second_argument_type& __x) const\n+      { return op(value, __x); }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 109.  Missing binders for non-const sequence elements\n+      typename _Operation::result_type\n+      operator()(typename _Operation::second_argument_type& __x) const\n+      { return op(value, __x); }\n+    };\n+\n+  /// One of the @link s20_3_6_binder binder functors@endlink.\n+  template <class _Operation, class _Tp>\n+    inline binder1st<_Operation> \n+    bind1st(const _Operation& __fn, const _Tp& __x) \n+    {\n+      typedef typename _Operation::first_argument_type _Arg1_type;\n+      return binder1st<_Operation>(__fn, _Arg1_type(__x));\n+    }\n \n-/// One of the @link s20_3_4_logical Boolean operations functors@endlink.\n-template <class _Tp>\n-struct logical_or : public binary_function<_Tp,_Tp,bool>\n-{\n-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }\n-};\n+  /// One of the @link s20_3_6_binder binder functors@endlink.\n+  template <class _Operation> \n+    class binder2nd\n+    : public unary_function<typename _Operation::first_argument_type,\n+\t\t\t    typename _Operation::result_type>\n+    {\n+    protected:\n+      _Operation op;\n+      typename _Operation::second_argument_type value;\n+    public:\n+      binder2nd(const _Operation& __x,\n+\t\tconst typename _Operation::second_argument_type& __y) \n+\t: op(__x), value(__y) {}\n+\n+      typename _Operation::result_type\n+      operator()(const typename _Operation::first_argument_type& __x) const\n+      { return op(__x, value); }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 109.  Missing binders for non-const sequence elements\n+      typename _Operation::result_type\n+      operator()(typename _Operation::first_argument_type& __x) const\n+      { return op(__x, value); }\n+    };\n+\n+  /// One of the @link s20_3_6_binder binder functors@endlink.\n+  template <class _Operation, class _Tp>\n+    inline binder2nd<_Operation> \n+    bind2nd(const _Operation& __fn, const _Tp& __x) \n+    {\n+      typedef typename _Operation::second_argument_type _Arg2_type;\n+      return binder2nd<_Operation>(__fn, _Arg2_type(__x));\n+    }\n+  /** @}  */\n+  \n+  // 20.3.7 adaptors pointers functions\n+  /** @defgroup s20_3_7_adaptors Adaptors for pointers to functions\n+   *  The advantage of function objects over pointers to functions is that\n+   *  the objects in the standard library declare nested typedefs describing\n+   *  their argument and result types with uniform names (e.g., @c result_type\n+   *  from the base classes @c unary_function and @c binary_function).\n+   *  Sometimes those typedefs are required, not just optional.\n+   *\n+   *  Adaptors are provided to turn pointers to unary (single-argument) and\n+   *  binary (double-argument) functions into function objects.  The\n+   *  long-winded functor @c pointer_to_unary_function is constructed with a\n+   *  function pointer @c f, and its @c operator() called with argument @c x\n+   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same\n+   *  thing, but with a double-argument @c f and @c operator().\n+   *\n+   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs\n+   *  an instance of the appropriate functor.\n+   *\n+   *  @{\n+   */\n+  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n+  template <class _Arg, class _Result>\n+    class pointer_to_unary_function : public unary_function<_Arg, _Result>\n+    {\n+    protected:\n+      _Result (*_M_ptr)(_Arg);\n+    public:\n+      pointer_to_unary_function() {}\n+      \n+      explicit pointer_to_unary_function(_Result (*__x)(_Arg))\n+      : _M_ptr(__x) {}\n \n-/// One of the @link s20_3_4_logical Boolean operations functors@endlink.\n-template <class _Tp>\n-struct logical_not : public unary_function<_Tp,bool>\n-{\n-  bool operator()(const _Tp& __x) const { return !__x; }\n-};\n-/** @}  */\n-\n-// 20.3.5 negators\n-/** @defgroup s20_3_5_negators Negators\n- *  The functions @c not1 and @c not2 each take a predicate functor\n- *  and return an instance of @c unary_negate or\n- *  @c binary_negate, respectively.  These classes are functors whose\n- *  @c operator() performs the stored predicate function and then returns\n- *  the negation of the result.\n- *\n- *  For example, given a vector of integers and a trivial predicate,\n- *  \\code\n- *  struct IntGreaterThanThree\n- *    : public std::unary_function<int, bool>\n- *  {\n- *      bool operator() (int x) { return x > 3; }\n- *  };\n- *  \n- *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));\n- *  \\endcode\n- *  The call to @c find_if will locate the first index (i) of @c v for which\n- *  \"!(v[i] > 3)\" is true.\n- *\n- *  The not1/unary_negate combination works on predicates taking a single\n- *  argument.  The not2/binary_negate combination works on predicates which\n- *  take two arguments.\n- *\n- *  @{\n-*/\n-/// One of the @link s20_3_5_negators negation functors@endlink.\n-template <class _Predicate>\n-class unary_negate\n-  : public unary_function<typename _Predicate::argument_type, bool> {\n-protected:\n-  _Predicate _M_pred;\n-public:\n-  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}\n-  bool operator()(const typename _Predicate::argument_type& __x) const {\n-    return !_M_pred(__x);\n-  }\n-};\n-\n-/// One of the @link s20_3_5_negators negation functors@endlink.\n-template <class _Predicate>\n-inline unary_negate<_Predicate> \n-not1(const _Predicate& __pred)\n-{\n-  return unary_negate<_Predicate>(__pred);\n-}\n-\n-/// One of the @link s20_3_5_negators negation functors@endlink.\n-template <class _Predicate> \n-class binary_negate \n-  : public binary_function<typename _Predicate::first_argument_type,\n-                           typename _Predicate::second_argument_type,\n-                           bool> {\n-protected:\n-  _Predicate _M_pred;\n-public:\n-  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}\n-  bool operator()(const typename _Predicate::first_argument_type& __x, \n-                  const typename _Predicate::second_argument_type& __y) const\n-  {\n-    return !_M_pred(__x, __y); \n-  }\n-};\n-\n-/// One of the @link s20_3_5_negators negation functors@endlink.\n-template <class _Predicate>\n-inline binary_negate<_Predicate> \n-not2(const _Predicate& __pred)\n-{\n-  return binary_negate<_Predicate>(__pred);\n-}\n-/** @}  */\n-\n-// 20.3.6 binders\n-/** @defgroup s20_3_6_binder Binder Classes\n- *  Binders turn functions/functors with two arguments into functors with\n- *  a single argument, storing an argument to be applied later.  For\n- *  example, an variable @c B of type @c binder1st is constructed from a functor\n- *  @c f and an argument @c x.  Later, B's @c operator() is called with a\n- *  single argument @c y.  The return value is the value of @c f(x,y).\n- *  @c B can be \"called\" with various arguments (y1, y2, ...) and will in\n- *  turn call @c f(x,y1), @c f(x,y2), ...\n- *\n- *  The function @c bind1st is provided to save some typing.  It takes the\n- *  function and an argument as parameters, and returns an instance of\n- *  @c binder1st.\n- *\n- *  The type @c binder2nd and its creator function @c bind2nd do the same\n- *  thing, but the stored argument is passed as the second parameter instead\n- *  of the first, e.g., @c bind2nd(std::minus<float>,1.3) will create a\n- *  functor whose @c operator() accepts a floating-point number, subtracts\n- *  1.3 from it, and returns the result.  (If @c bind1st had been used,\n- *  the functor would perform \"1.3 - x\" instead.\n- *\n- *  Creator-wrapper functions like @c bind1st are intended to be used in\n- *  calling algorithms.  Their return values will be temporary objects.\n- *  (The goal is to not require you to type names like\n- *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the\n- *  return value from @c bind1st(std::plus<int>,5).\n- *\n- *  These become more useful when combined with the composition functions.\n- *\n- *  @{\n-*/\n-/// One of the @link s20_3_6_binder binder functors@endlink.\n-template <class _Operation> \n-class binder1st\n-  : public unary_function<typename _Operation::second_argument_type,\n-                          typename _Operation::result_type> {\n-protected:\n-  _Operation op;\n-  typename _Operation::first_argument_type value;\n-public:\n-  binder1st(const _Operation& __x,\n-            const typename _Operation::first_argument_type& __y)\n-      : op(__x), value(__y) {}\n-  typename _Operation::result_type\n-  operator()(const typename _Operation::second_argument_type& __x) const {\n-    return op(value, __x); \n-  }\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 109.  Missing binders for non-const sequence elements\n-  typename _Operation::result_type\n-  operator()(typename _Operation::second_argument_type& __x) const {\n-    return op(value, __x); \n-  }\n-};\n-\n-/// One of the @link s20_3_6_binder binder functors@endlink.\n-template <class _Operation, class _Tp>\n-inline binder1st<_Operation> \n-bind1st(const _Operation& __fn, const _Tp& __x) \n-{\n-  typedef typename _Operation::first_argument_type _Arg1_type;\n-  return binder1st<_Operation>(__fn, _Arg1_type(__x));\n-}\n-\n-/// One of the @link s20_3_6_binder binder functors@endlink.\n-template <class _Operation> \n-class binder2nd\n-  : public unary_function<typename _Operation::first_argument_type,\n-                          typename _Operation::result_type> {\n-protected:\n-  _Operation op;\n-  typename _Operation::second_argument_type value;\n-public:\n-  binder2nd(const _Operation& __x,\n-            const typename _Operation::second_argument_type& __y) \n-      : op(__x), value(__y) {}\n-  typename _Operation::result_type\n-  operator()(const typename _Operation::first_argument_type& __x) const {\n-    return op(__x, value); \n-  }\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 109.  Missing binders for non-const sequence elements\n-  typename _Operation::result_type\n-  operator()(typename _Operation::first_argument_type& __x) const {\n-    return op(__x, value); \n-  }\n-};\n-\n-/// One of the @link s20_3_6_binder binder functors@endlink.\n-template <class _Operation, class _Tp>\n-inline binder2nd<_Operation> \n-bind2nd(const _Operation& __fn, const _Tp& __x) \n-{\n-  typedef typename _Operation::second_argument_type _Arg2_type;\n-  return binder2nd<_Operation>(__fn, _Arg2_type(__x));\n-}\n-/** @}  */\n-\n-// 20.3.7 adaptors pointers functions\n-/** @defgroup s20_3_7_adaptors Adaptors for pointers to functions\n- *  The advantage of function objects over pointers to functions is that\n- *  the objects in the standard library declare nested typedefs describing\n- *  their argument and result types with uniform names (e.g., @c result_type\n- *  from the base classes @c unary_function and @c binary_function).\n- *  Sometimes those typedefs are required, not just optional.\n- *\n- *  Adaptors are provided to turn pointers to unary (single-argument) and\n- *  binary (double-argument) functions into function objects.  The long-winded\n- *  functor @c pointer_to_unary_function is constructed with a function\n- *  pointer @c f, and its @c operator() called with argument @c x returns\n- *  @c f(x).  The functor @c pointer_to_binary_function does the same thing,\n- *  but with a double-argument @c f and @c operator().\n- *\n- *  The function @c ptr_fun takes a pointer-to-function @c f and constructs\n- *  an instance of the appropriate functor.\n- *\n- *  @{\n-*/\n-/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n-template <class _Arg, class _Result>\n-class pointer_to_unary_function : public unary_function<_Arg, _Result> {\n-protected:\n-  _Result (*_M_ptr)(_Arg);\n-public:\n-  pointer_to_unary_function() {}\n-  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}\n-  _Result operator()(_Arg __x) const { return _M_ptr(__x); }\n-};\n-\n-/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n-template <class _Arg, class _Result>\n-inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))\n-{\n-  return pointer_to_unary_function<_Arg, _Result>(__x);\n-}\n-\n-/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n-template <class _Arg1, class _Arg2, class _Result>\n-class pointer_to_binary_function : \n-  public binary_function<_Arg1,_Arg2,_Result> {\n-protected:\n-    _Result (*_M_ptr)(_Arg1, _Arg2);\n-public:\n-    pointer_to_binary_function() {}\n-    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) \n+      _Result\n+      operator()(_Arg __x) const\n+      { return _M_ptr(__x); }\n+    };\n+\n+  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n+  template <class _Arg, class _Result>\n+    inline pointer_to_unary_function<_Arg, _Result>\n+    ptr_fun(_Result (*__x)(_Arg))\n+    { return pointer_to_unary_function<_Arg, _Result>(__x); }\n+\n+  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n+  template <class _Arg1, class _Arg2, class _Result>\n+    class pointer_to_binary_function\n+      : public binary_function<_Arg1, _Arg2, _Result>\n+    {\n+    protected:\n+      _Result (*_M_ptr)(_Arg1, _Arg2);\n+    public:\n+      pointer_to_binary_function() {}\n+\n+      explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) \n       : _M_ptr(__x) {}\n-    _Result operator()(_Arg1 __x, _Arg2 __y) const {\n-      return _M_ptr(__x, __y);\n-    }\n-};\n-\n-/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n-template <class _Arg1, class _Arg2, class _Result>\n-inline pointer_to_binary_function<_Arg1,_Arg2,_Result> \n-ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {\n-  return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__x);\n-}\n-/** @}  */\n-\n-template <class _Tp>\n-struct _Identity : public unary_function<_Tp,_Tp> {\n-  _Tp& operator()(_Tp& __x) const { return __x; }\n-  const _Tp& operator()(const _Tp& __x) const { return __x; }\n-};\n-\n-template <class _Pair>\n-struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {\n-  typename _Pair::first_type& operator()(_Pair& __x) const {\n-    return __x.first;\n-  }\n-  const typename _Pair::first_type& operator()(const _Pair& __x) const {\n-    return __x.first;\n-  }\n-};\n-\n-template <class _Pair>\n-struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>\n-{\n-  typename _Pair::second_type& operator()(_Pair& __x) const {\n-    return __x.second;\n-  }\n-  const typename _Pair::second_type& operator()(const _Pair& __x) const {\n-    return __x.second;\n-  }\n-};\n-\n-// 20.3.8 adaptors pointers members\n-/** @defgroup s20_3_8_memadaptors Adaptors for pointers to members\n- *  There are a total of 16 = 2^4 function objects in this family.\n- *   (1) Member functions taking no arguments vs member functions taking\n- *        one argument.\n- *   (2) Call through pointer vs call through reference.\n- *   (3) Member function with void return type vs member function with\n- *       non-void return type.\n- *   (4) Const vs non-const member function.\n- *\n- *  Note that choice (3) is nothing more than a workaround: according\n- *   to the draft, compilers should handle void and non-void the same way.\n- *   This feature is not yet widely implemented, though.  You can only use\n- *   member functions returning void if your compiler supports partial\n- *   specialization.\n- *\n- *  All of this complexity is in the function objects themselves.  You can\n- *   ignore it by using the helper function mem_fun and mem_fun_ref,\n- *   which create whichever type of adaptor is appropriate.\n- *\n- *  @{\n-*/\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp>\n-class mem_fun_t : public unary_function<_Tp*,_Ret> {\n-public:\n-  explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}\n-  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }\n-private:\n-  _Ret (_Tp::*_M_f)();\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp>\n-class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {\n-public:\n-  explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}\n-  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }\n-private:\n-  _Ret (_Tp::*_M_f)() const;\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp>\n-class mem_fun_ref_t : public unary_function<_Tp,_Ret> {\n-public:\n-  explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}\n-  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }\n-private:\n-  _Ret (_Tp::*_M_f)();\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp>\n-class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {\n-public:\n-  explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}\n-  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }\n-private:\n-  _Ret (_Tp::*_M_f)() const;\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp, class _Arg>\n-class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {\n-public:\n-  explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n-  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }\n-private:\n-  _Ret (_Tp::*_M_f)(_Arg);\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp, class _Arg>\n-class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {\n-public:\n-  explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n-  _Ret operator()(const _Tp* __p, _Arg __x) const\n-    { return (__p->*_M_f)(__x); }\n-private:\n-  _Ret (_Tp::*_M_f)(_Arg) const;\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp, class _Arg>\n-class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {\n-public:\n-  explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n-  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }\n-private:\n-  _Ret (_Tp::*_M_f)(_Arg);\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Ret, class _Tp, class _Arg>\n-class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {\n-public:\n-  explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n-  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }\n-private:\n-  _Ret (_Tp::*_M_f)(_Arg) const;\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp>\n-class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {\n-public:\n-  explicit mem_fun_t(void (_Tp::*__pf)()) : _M_f(__pf) {}\n-  void operator()(_Tp* __p) const { (__p->*_M_f)(); }\n-private:\n-  void (_Tp::*_M_f)();\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp>\n-class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*,void> {\n-public:\n-  explicit const_mem_fun_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}\n-  void operator()(const _Tp* __p) const { (__p->*_M_f)(); }\n-private:\n-  void (_Tp::*_M_f)() const;\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp>\n-class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {\n-public:\n-  explicit mem_fun_ref_t(void (_Tp::*__pf)()) : _M_f(__pf) {}\n-  void operator()(_Tp& __r) const { (__r.*_M_f)(); }\n-private:\n-  void (_Tp::*_M_f)();\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp>\n-class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {\n-public:\n-  explicit const_mem_fun_ref_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}\n-  void operator()(const _Tp& __r) const { (__r.*_M_f)(); }\n-private:\n-  void (_Tp::*_M_f)() const;\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp, class _Arg>\n-class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*,_Arg,void> {\n-public:\n-  explicit mem_fun1_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n-  void operator()(_Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }\n-private:\n-  void (_Tp::*_M_f)(_Arg);\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp, class _Arg>\n-class const_mem_fun1_t<void, _Tp, _Arg> \n-  : public binary_function<const _Tp*,_Arg,void> {\n-public:\n-  explicit const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n-  void operator()(const _Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }\n-private:\n-  void (_Tp::*_M_f)(_Arg) const;\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp, class _Arg>\n-class mem_fun1_ref_t<void, _Tp, _Arg>\n-  : public binary_function<_Tp,_Arg,void> {\n-public:\n-  explicit mem_fun1_ref_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n-  void operator()(_Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }\n-private:\n-  void (_Tp::*_M_f)(_Arg);\n-};\n-\n-/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n-template <class _Tp, class _Arg>\n-class const_mem_fun1_ref_t<void, _Tp, _Arg>\n-  : public binary_function<_Tp,_Arg,void> {\n-public:\n-  explicit const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n-  void operator()(const _Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }\n-private:\n-  void (_Tp::*_M_f)(_Arg) const;\n-};\n-\n-\n-// Mem_fun adaptor helper functions.  There are only two:\n-// mem_fun and mem_fun_ref.\n-\n-template <class _Ret, class _Tp>\n-inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)())\n-  { return mem_fun_t<_Ret,_Tp>(__f); }\n-\n-template <class _Ret, class _Tp>\n-inline const_mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)() const)\n-  { return const_mem_fun_t<_Ret,_Tp>(__f); }\n-\n-template <class _Ret, class _Tp>\n-inline mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)()) \n-  { return mem_fun_ref_t<_Ret,_Tp>(__f); }\n-\n-template <class _Ret, class _Tp>\n-inline const_mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)\n-  { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))\n-  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)\n-  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))\n-  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n-mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)\n-  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n-\n-/** @}  */\n \n+      _Result\n+      operator()(_Arg1 __x, _Arg2 __y) const\n+      { return _M_ptr(__x, __y); }\n+    };\n+\n+  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n+  template <class _Arg1, class _Arg2, class _Result>\n+    inline pointer_to_binary_function<_Arg1, _Arg2, _Result> \n+    ptr_fun(_Result (*__x)(_Arg1, _Arg2))\n+    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }\n+  /** @}  */\n+  \n+  template <class _Tp>\n+    struct _Identity : public unary_function<_Tp,_Tp>\n+    {\n+      _Tp&\n+      operator()(_Tp& __x) const\n+      { return __x; }\n+      \n+      const _Tp&\n+      operator()(const _Tp& __x) const\n+      { return __x; }\n+    };\n+\n+  template <class _Pair>\n+    struct _Select1st : public unary_function<_Pair,\n+\t\t\t\t\t      typename _Pair::first_type>\n+    {\n+      typename _Pair::first_type&\n+      operator()(_Pair& __x) const\n+      { return __x.first; }\n+      \n+      const typename _Pair::first_type&\n+      operator()(const _Pair& __x) const\n+      { return __x.first; }\n+    };\n+\n+  template <class _Pair>\n+    struct _Select2nd : public unary_function<_Pair,\n+\t\t\t\t\t      typename _Pair::second_type>\n+    {\n+      typename _Pair::second_type&\n+      operator()(_Pair& __x) const\n+      { return __x.second; }\n+      \n+      const typename _Pair::second_type&\n+      operator()(const _Pair& __x) const\n+      { return __x.second; }\n+    };\n+\n+  // 20.3.8 adaptors pointers members\n+  /** @defgroup s20_3_8_memadaptors Adaptors for pointers to members\n+   *  There are a total of 16 = 2^4 function objects in this family.\n+   *   (1) Member functions taking no arguments vs member functions taking\n+   *        one argument.\n+   *   (2) Call through pointer vs call through reference.\n+   *   (3) Member function with void return type vs member function with\n+   *       non-void return type.\n+   *   (4) Const vs non-const member function.\n+   *\n+   *  Note that choice (3) is nothing more than a workaround: according\n+   *   to the draft, compilers should handle void and non-void the same way.\n+   *   This feature is not yet widely implemented, though.  You can only use\n+   *   member functions returning void if your compiler supports partial\n+   *   specialization.\n+   *\n+   *  All of this complexity is in the function objects themselves.  You can\n+   *   ignore it by using the helper function mem_fun and mem_fun_ref,\n+   *   which create whichever type of adaptor is appropriate.\n+   *\n+   *  @{\n+   */\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp>\n+    class mem_fun_t : public unary_function<_Tp*, _Ret>\n+    {\n+    public:\n+      explicit mem_fun_t(_Ret (_Tp::*__pf)())\n+      : _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(_Tp* __p) const\n+      { return (__p->*_M_f)(); }\n+    private:\n+      _Ret (_Tp::*_M_f)();\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp>\n+    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>\n+    {\n+    public:\n+      explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const)\n+\t: _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(const _Tp* __p) const\n+      { return (__p->*_M_f)(); }\n+    private:\n+      _Ret (_Tp::*_M_f)() const;\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp>\n+    class mem_fun_ref_t : public unary_function<_Tp, _Ret>\n+    {\n+    public:\n+      explicit mem_fun_ref_t(_Ret (_Tp::*__pf)())\n+\t: _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(_Tp& __r) const\n+      { return (__r.*_M_f)(); }\n+    private:\n+      _Ret (_Tp::*_M_f)();\n+  };\n+  \n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp>\n+    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>\n+    {\n+    public:\n+      explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)\n+      : _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(const _Tp& __r) const\n+      { return (__r.*_M_f)(); }\n+    private:\n+      _Ret (_Tp::*_M_f)() const;\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp, class _Arg>\n+    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>\n+    {\n+    public:\n+      explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) \n+      : _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(_Tp* __p, _Arg __x) const\n+      { return (__p->*_M_f)(__x); }\n+    private:\n+      _Ret (_Tp::*_M_f)(_Arg);\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp, class _Arg>\n+    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>\n+    {\n+    public:\n+      explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)\n+      : _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(const _Tp* __p, _Arg __x) const\n+      { return (__p->*_M_f)(__x); }\n+    private:\n+      _Ret (_Tp::*_M_f)(_Arg) const;\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp, class _Arg>\n+    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>\n+    {\n+    public:\n+      explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))\n+      : _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(_Tp& __r, _Arg __x) const\n+      { return (__r.*_M_f)(__x); }\n+    private:\n+      _Ret (_Tp::*_M_f)(_Arg);\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Ret, class _Tp, class _Arg>\n+    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>\n+    {\n+    public:\n+      explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)\n+      : _M_f(__pf) {}\n+\n+      _Ret\n+      operator()(const _Tp& __r, _Arg __x) const\n+      { return (__r.*_M_f)(__x); }\n+    private:\n+      _Ret (_Tp::*_M_f)(_Arg) const;\n+    };\n+  \n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp>\n+    class mem_fun_t<void, _Tp> : public unary_function<_Tp*, void>\n+    {\n+    public:\n+      explicit mem_fun_t(void (_Tp::*__pf)())\n+      : _M_f(__pf) {}\n+\n+      void\n+      operator()(_Tp* __p) const\n+      { (__p->*_M_f)(); }\n+    private:\n+      void (_Tp::*_M_f)();\n+    };\n+  \n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp>\n+    class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*, void>\n+    {\n+    public:\n+      explicit const_mem_fun_t(void (_Tp::*__pf)() const)\n+      : _M_f(__pf) {}\n+\n+      void\n+      operator()(const _Tp* __p) const\n+      { (__p->*_M_f)(); }\n+    private:\n+      void (_Tp::*_M_f)() const;\n+    };\n+  \n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp>\n+    class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>\n+    {\n+    public:\n+      explicit mem_fun_ref_t(void (_Tp::*__pf)())\n+      : _M_f(__pf) {}\n+\n+      void\n+      operator()(_Tp& __r) const\n+      { (__r.*_M_f)(); }\n+    private:\n+      void (_Tp::*_M_f)();\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp>\n+    class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>\n+    {\n+    public:\n+      explicit const_mem_fun_ref_t(void (_Tp::*__pf)() const)\n+      : _M_f(__pf) {}\n+\n+      void\n+      operator()(const _Tp& __r)\n+\tconst { (__r.*_M_f)(); }\n+    private:\n+      void (_Tp::*_M_f)() const;\n+    };\n+  \n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp, class _Arg>\n+    class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*, _Arg, void>\n+    {\n+    public:\n+      explicit mem_fun1_t(void (_Tp::*__pf)(_Arg))\n+      : _M_f(__pf) {}\n+    \n+      void\n+      operator()(_Tp* __p, _Arg __x) const\n+      { (__p->*_M_f)(__x); }\n+    private:\n+      void (_Tp::*_M_f)(_Arg);\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp, class _Arg>\n+    class const_mem_fun1_t<void, _Tp, _Arg> \n+    : public binary_function<const _Tp*, _Arg, void>\n+    {\n+    public:\n+      explicit const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const)\n+\t: _M_f(__pf) {}\n+      \n+      void\n+      operator()(const _Tp* __p, _Arg __x) const\n+      { (__p->*_M_f)(__x); }\n+    private:\n+      void (_Tp::*_M_f)(_Arg) const;\n+    };\n+  \n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp, class _Arg>\n+    class mem_fun1_ref_t<void, _Tp, _Arg>\n+    : public binary_function<_Tp, _Arg, void>\n+    {\n+    public:\n+      explicit mem_fun1_ref_t(void (_Tp::*__pf)(_Arg))\n+      : _M_f(__pf) {}\n+\n+      void\n+      operator()(_Tp& __r, _Arg __x) const\n+      { (__r.*_M_f)(__x); }\n+    private:\n+      void (_Tp::*_M_f)(_Arg);\n+    };\n+\n+  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n+  template <class _Tp, class _Arg>\n+    class const_mem_fun1_ref_t<void, _Tp, _Arg>\n+    : public binary_function<_Tp, _Arg, void>\n+    {\n+    public:\n+      explicit const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const)\n+      : _M_f(__pf) {}\n+\n+      void\n+      operator()(const _Tp& __r, _Arg __x) const\n+      { (__r.*_M_f)(__x); }\n+    private:\n+      void (_Tp::*_M_f)(_Arg) const;\n+    };\n+\n+  // Mem_fun adaptor helper functions.  There are only two:\n+  // mem_fun and mem_fun_ref.\n+  template <class _Ret, class _Tp>\n+    inline mem_fun_t<_Ret,_Tp>\n+    mem_fun(_Ret (_Tp::*__f)())\n+    { return mem_fun_t<_Ret,_Tp>(__f); }\n+\n+  template <class _Ret, class _Tp>\n+    inline const_mem_fun_t<_Ret,_Tp>\n+    mem_fun(_Ret (_Tp::*__f)() const)\n+    { return const_mem_fun_t<_Ret,_Tp>(__f); }\n+  \n+  template <class _Ret, class _Tp>\n+    inline mem_fun_ref_t<_Ret,_Tp>\n+    mem_fun_ref(_Ret (_Tp::*__f)()) \n+    { return mem_fun_ref_t<_Ret,_Tp>(__f); }\n+\n+  template <class _Ret, class _Tp>\n+    inline const_mem_fun_ref_t<_Ret,_Tp>\n+    mem_fun_ref(_Ret (_Tp::*__f)() const)\n+    { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }\n+\n+  template <class _Ret, class _Tp, class _Arg>\n+    inline mem_fun1_t<_Ret,_Tp,_Arg>\n+    mem_fun(_Ret (_Tp::*__f)(_Arg))\n+    { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n+\n+  template <class _Ret, class _Tp, class _Arg>\n+    inline const_mem_fun1_t<_Ret,_Tp,_Arg>\n+    mem_fun(_Ret (_Tp::*__f)(_Arg) const)\n+    { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n+\n+  template <class _Ret, class _Tp, class _Arg>\n+    inline mem_fun1_ref_t<_Ret,_Tp,_Arg>\n+    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))\n+    { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n+\n+  template <class _Ret, class _Tp, class _Arg>\n+    inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n+    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)\n+    { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n+\n+  /** @}  */\n+  \n } // namespace std\n \n #endif /* _FUNCTION_H */"}, {"sha": "ce1e1ed00dd0acf03b05a0d4333b0282470ab17b", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 107, "deletions": 81, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Iterators -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -137,7 +137,8 @@ namespace std\n        *  @return  @c current, the %iterator used for underlying work.\n       */\n       iterator_type \n-      base() const { return current; }\n+      base() const\n+      { return current; }\n \n       /**\n        *  @return  TODO\n@@ -157,7 +158,8 @@ namespace std\n        *  @doctodo\n       */\n       pointer \n-      operator->() const { return &(operator*()); }\n+      operator->() const\n+      { return &(operator*()); }\n \n       /**\n        *  @return  TODO\n@@ -256,7 +258,8 @@ namespace std\n        *  @doctodo\n       */\n       reference \n-      operator[](difference_type __n) const { return *(*this + __n); }  \n+      operator[](difference_type __n) const\n+      { return *(*this + __n); }  \n     }; \n  \n   //@{\n@@ -364,15 +367,18 @@ namespace std\n \n       /// Simply returns *this.\n       back_insert_iterator& \n-      operator*() { return *this; }\n+      operator*()\n+      { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n       back_insert_iterator& \n-      operator++() { return *this; }\n+      operator++()\n+      { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n       back_insert_iterator\n-      operator++(int) { return *this; }\n+      operator++(int)\n+      { return *this; }\n     };\n \n   /**\n@@ -435,15 +441,18 @@ namespace std\n \n       /// Simply returns *this.\n       front_insert_iterator& \n-      operator*() { return *this; }\n+      operator*()\n+      { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n       front_insert_iterator& \n-      operator++() { return *this; }\n+      operator++()\n+      { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n       front_insert_iterator \n-      operator++(int) { return *this; }\n+      operator++(int)\n+      { return *this; }\n     };\n \n   /**\n@@ -528,15 +537,18 @@ namespace std\n \n       /// Simply returns *this.\n       insert_iterator& \n-      operator*() { return *this; }\n+      operator*()\n+      { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n       insert_iterator& \n-      operator++() { return *this; }\n+      operator++()\n+      { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n       insert_iterator& \n-      operator++(int) { return *this; }\n+      operator++(int)\n+      { return *this; }\n     };\n   \n   /**\n@@ -578,12 +590,12 @@ namespace __gnu_cxx\n       \n     public:\n       typedef typename iterator_traits<_Iterator>::iterator_category\n-                                                               iterator_category;\n+                                                             iterator_category;\n       typedef typename iterator_traits<_Iterator>::value_type  value_type;\n       typedef typename iterator_traits<_Iterator>::difference_type \t\n-      \t\t\t\t\t\t\t       difference_type;\n-      typedef typename iterator_traits<_Iterator>::reference   reference;\n-      typedef typename iterator_traits<_Iterator>::pointer     pointer;\n+                                                             difference_type;\n+      typedef typename iterator_traits<_Iterator>::reference reference;\n+      typedef typename iterator_traits<_Iterator>::pointer   pointer;\n \n       __normal_iterator() : _M_current(_Iterator()) { }\n \n@@ -592,28 +604,41 @@ namespace __gnu_cxx\n \n       // Allow iterator to const_iterator conversion\n       template<typename _Iter>\n-      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)\n+        inline __normal_iterator(const __normal_iterator<_Iter,\n+\t\t\t\t _Container>& __i)\n \t: _M_current(__i.base()) { }\n \n       // Forward iterator requirements\n       reference\n-      operator*() const { return *_M_current; }\n+      operator*() const\n+      { return *_M_current; }\n       \n       pointer\n-      operator->() const { return _M_current; }\n+      operator->() const\n+      { return _M_current; }\n       \n       __normal_iterator&\n-      operator++() { ++_M_current; return *this; }\n+      operator++()\n+      {\n+\t++_M_current;\n+\treturn *this;\n+      }\n       \n       __normal_iterator\n-      operator++(int) { return __normal_iterator(_M_current++); }\n+      operator++(int)\n+      { return __normal_iterator(_M_current++); }\n       \n       // Bidirectional iterator requirements\n       __normal_iterator&\n-      operator--() { --_M_current; return *this; }\n+      operator--()\n+      {\n+\t--_M_current;\n+\treturn *this;\n+      }\n       \n       __normal_iterator\n-      operator--(int) { return __normal_iterator(_M_current--); }\n+      operator--(int)\n+      { return __normal_iterator(_M_current--); }\n       \n       // Random access iterator requirements\n       reference\n@@ -637,7 +662,8 @@ namespace __gnu_cxx\n       { return __normal_iterator(_M_current - __n); }\n       \n       const _Iterator& \n-      base() const { return _M_current; }\n+      base() const\n+      { return _M_current; }\n     };\n \n   // Note: In what follows, the left- and right-hand-side iterators are\n@@ -650,93 +676,93 @@ namespace __gnu_cxx\n   \n   // Forward iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-  inline bool\n-  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n-\t     const __normal_iterator<_IteratorR, _Container>& __rhs)\n-  { return __lhs.base() == __rhs.base(); }\n+    inline bool\n+    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() == __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n-  inline bool\n-  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,\n-             const __normal_iterator<_Iterator, _Container>& __rhs)\n-  { return __lhs.base() == __rhs.base(); }\n+    inline bool\n+    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() == __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-  inline bool\n-  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n-\t     const __normal_iterator<_IteratorR, _Container>& __rhs)\n-  { return __lhs.base() != __rhs.base(); }\n+    inline bool\n+    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() != __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n-  inline bool\n-  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,\n-             const __normal_iterator<_Iterator, _Container>& __rhs)\n-  { return __lhs.base() != __rhs.base(); }\n+    inline bool\n+    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() != __rhs.base(); }\n \n   // Random access iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-  inline bool \n-  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n-\t    const __normal_iterator<_IteratorR, _Container>& __rhs)\n-  { return __lhs.base() < __rhs.base(); }\n+    inline bool \n+    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() < __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n-  inline bool\n-  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\n-             const __normal_iterator<_Iterator, _Container>& __rhs)\n-  { return __lhs.base() < __rhs.base(); }\n+    inline bool\n+    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\t      const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() < __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-  inline bool\n-  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n-\t    const __normal_iterator<_IteratorR, _Container>& __rhs)\n-  { return __lhs.base() > __rhs.base(); }\n+    inline bool\n+    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() > __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n-  inline bool\n-  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,\n-\t    const __normal_iterator<_Iterator, _Container>& __rhs)\n-  { return __lhs.base() > __rhs.base(); }\n+    inline bool\n+    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\t      const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() > __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-  inline bool\n-  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n-\t     const __normal_iterator<_IteratorR, _Container>& __rhs)\n-  { return __lhs.base() <= __rhs.base(); }\n+    inline bool\n+    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() <= __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n-  inline bool\n-  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,\n-\t     const __normal_iterator<_Iterator, _Container>& __rhs)\n-  { return __lhs.base() <= __rhs.base(); }\n+    inline bool\n+    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() <= __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-  inline bool\n-  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n-\t     const __normal_iterator<_IteratorR, _Container>& __rhs)\n-  { return __lhs.base() >= __rhs.base(); }\n+    inline bool\n+    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() >= __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n-  inline bool\n-  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,\n-\t     const __normal_iterator<_Iterator, _Container>& __rhs)\n-  { return __lhs.base() >= __rhs.base(); }\n+    inline bool\n+    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() >= __rhs.base(); }\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // According to the resolution of DR179 not only the various comparison\n   // operators but also operator- must accept mixed iterator/const_iterator\n   // parameters.\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-  inline typename __normal_iterator<_IteratorL, _Container>::difference_type\n-  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n-\t     const __normal_iterator<_IteratorR, _Container>& __rhs)\n-  { return __lhs.base() - __rhs.base(); }\n+    inline typename __normal_iterator<_IteratorL, _Container>::difference_type\n+    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() - __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n-  inline __normal_iterator<_Iterator, _Container>\n-  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,\n-\t    const __normal_iterator<_Iterator, _Container>& __i)\n-  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }\n+    inline __normal_iterator<_Iterator, _Container>\n+    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type\n+\t      __n, const __normal_iterator<_Iterator, _Container>& __i)\n+    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }\n } // namespace __gnu_cxx\n \n #endif "}, {"sha": "c933ee0c2bee393120ebdc2c2e90124a10cb1143", "filename": "libstdc++-v3/include/bits/stl_iterator_base_funcs.h", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Functions used by iterators -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -78,9 +78,11 @@ namespace std\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n   \n       typename iterator_traits<_InputIterator>::difference_type __n = 0;\n-      while (__first != __last) {\n-        ++__first; ++__n;\n-      }\n+      while (__first != __last)\n+\t{\n+\t  ++__first;\n+\t  ++__n;\n+\t}\n       return __n;\n     }\n   \n@@ -90,7 +92,8 @@ namespace std\n                random_access_iterator_tag)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n+      __glibcxx_function_requires(_RandomAccessIteratorConcept<\n+\t\t\t\t  _RandomAccessIterator>)\n       return __last - __first;\n     }\n   \n@@ -111,7 +114,8 @@ namespace std\n     distance(_InputIterator __first, _InputIterator __last)\n     {\n       // concept requirements -- taken care of in __distance\n-      return std::__distance(__first, __last, std::__iterator_category(__first));\n+      return std::__distance(__first, __last,\n+\t\t\t     std::__iterator_category(__first));\n     }\n   \n   template<typename _InputIterator, typename _Distance>\n@@ -120,7 +124,8 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n-      while (__n--) ++__i;\n+      while (__n--)\n+\t++__i;\n     }\n   \n   template<typename _BidirectionalIterator, typename _Distance>\n@@ -129,8 +134,8 @@ namespace std\n               bidirectional_iterator_tag)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>)\n-  \n+      __glibcxx_function_requires(_BidirectionalIteratorConcept<\n+\t\t\t\t  _BidirectionalIterator>)\n       if (__n > 0)\n         while (__n--) ++__i;\n       else\n@@ -143,7 +148,8 @@ namespace std\n               random_access_iterator_tag)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n+      __glibcxx_function_requires(_RandomAccessIteratorConcept<\n+\t\t\t\t  _RandomAccessIterator>)\n       __i += __n;\n     }\n   "}, {"sha": "5054340e46f1e7686a641a8a8f2135509905650b", "filename": "libstdc++-v3/include/bits/stl_iterator_base_types.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Types used in iterator implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -82,9 +82,11 @@ namespace std\n   struct output_iterator_tag {};\n   /// Forward iterators support a superset of input iterator operations.\n   struct forward_iterator_tag : public input_iterator_tag {};\n-  /// Bidirectional iterators support a superset of forward iterator operations.\n+  /// Bidirectional iterators support a superset of forward iterator\n+  /// operations.\n   struct bidirectional_iterator_tag : public forward_iterator_tag {};\n-  /// Random-access iterators support a superset of bidirectional iterator operations.\n+  /// Random-access iterators support a superset of bidirectional iterator\n+  /// operations.\n   struct random_access_iterator_tag : public bidirectional_iterator_tag {};\n   //@}\n "}, {"sha": "546369b369ccc8c2dc7a8316d47e981ede8558f4", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -94,7 +94,6 @@ namespace __gnu_norm\n       _Tp _M_data;                ///< User's data.\n     };\n   \n-  \n   /**\n    *  @brief A list::iterator.\n    *\n@@ -325,7 +324,6 @@ namespace __gnu_norm\n       }\n     };\n   \n-  \n   /**\n    *  @brief A standard container with linear time access to elements,\n    *  and fixed time insertion/deletion at any point in the sequence.\n@@ -573,23 +571,26 @@ namespace __gnu_norm\n   \n       /// Get a copy of the memory allocation object.\n       allocator_type\n-      get_allocator() const { return _Base::get_allocator(); }\n+      get_allocator() const\n+      { return _Base::get_allocator(); }\n       \n       // iterators\n       /**\n        *  Returns a read/write iterator that points to the first element in the\n        *  %list.  Iteration is done in ordinary element order.\n        */\n       iterator\n-      begin() { return this->_M_node._M_next; }\n+      begin()\n+      { return this->_M_node._M_next; }\n       \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n        *  first element in the %list.  Iteration is done in ordinary\n        *  element order.\n        */\n       const_iterator\n-      begin() const { return this->_M_node._M_next; }\n+      begin() const\n+      { return this->_M_node._M_next; }\n       \n       /**\n        *  Returns a read/write iterator that points one past the last\n@@ -605,31 +606,35 @@ namespace __gnu_norm\n        *  element order.\n        */\n       const_iterator\n-      end() const { return &this->_M_node; }\n+      end() const\n+      { return &this->_M_node; }\n       \n       /**\n        *  Returns a read/write reverse iterator that points to the last\n        *  element in the %list.  Iteration is done in reverse element\n        *  order.\n        */\n       reverse_iterator\n-      rbegin() { return reverse_iterator(end()); }\n+      rbegin()\n+      { return reverse_iterator(end()); }\n       \n       /**\n        *  Returns a read-only (constant) reverse iterator that points to\n        *  the last element in the %list.  Iteration is done in reverse\n        *  element order.\n        */\n       const_reverse_iterator\n-      rbegin() const { return const_reverse_iterator(end()); }\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n       \n       /**\n        *  Returns a read/write reverse iterator that points to one\n        *  before the first element in the %list.  Iteration is done in\n        *  reverse element order.\n        */\n       reverse_iterator\n-      rend() { return reverse_iterator(begin()); }\n+      rend()\n+      { return reverse_iterator(begin()); }\n       \n       /**\n        *  Returns a read-only (constant) reverse iterator that points to one\n@@ -646,15 +651,18 @@ namespace __gnu_norm\n        *  end().)\n        */\n       bool\n-      empty() const { return this->_M_node._M_next == &this->_M_node; }\n+      empty() const\n+      { return this->_M_node._M_next == &this->_M_node; }\n       \n       /**  Returns the number of elements in the %list.  */\n       size_type\n-      size() const { return std::distance(begin(), end()); }\n+      size() const\n+      { return std::distance(begin(), end()); }\n       \n       /**  Returns the size() of the largest possible %list.  */\n       size_type\n-      max_size() const { return size_type(-1); }\n+      max_size() const\n+      { return size_type(-1); }\n       \n       /**\n        *  @brief Resizes the %list to the specified number of elements.\n@@ -679,36 +687,41 @@ namespace __gnu_norm\n        *  and new elements are default-constructed.\n        */\n       void\n-      resize(size_type __new_size) { this->resize(__new_size, value_type()); }\n+      resize(size_type __new_size)\n+      { this->resize(__new_size, value_type()); }\n       \n       // element access\n       /**\n        *  Returns a read/write reference to the data at the first\n        *  element of the %list.\n        */\n       reference\n-      front() { return *begin(); }\n+      front()\n+      { return *begin(); }\n       \n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %list.\n        */\n       const_reference\n-      front() const { return *begin(); }\n+      front() const\n+      { return *begin(); }\n       \n       /**\n        *  Returns a read/write reference to the data at the last element\n        *  of the %list.\n        */\n       reference\n-      back() { return *(--end()); }\n+      back()\n+      { return *(--end()); }\n       \n       /**\n        *  Returns a read-only (constant) reference to the data at the last\n        *  element of the %list.\n        */\n       const_reference\n-      back() const { return *(--end()); }\n+      back() const\n+      { return *(--end()); }\n       \n       // [23.2.2.3] modifiers\n       /**\n@@ -722,7 +735,8 @@ namespace __gnu_norm\n        *  references.\n        */\n       void\n-      push_front(const value_type& __x) { this->_M_insert(begin(), __x); }\n+      push_front(const value_type& __x)\n+      { this->_M_insert(begin(), __x); }\n   \n       /**\n        *  @brief  Removes first element.\n@@ -737,7 +751,8 @@ namespace __gnu_norm\n        *  called.\n        */\n       void\n-      pop_front() { this->_M_erase(begin()); }\n+      pop_front()\n+      { this->_M_erase(begin()); }\n       \n       /**\n        *  @brief  Add data to the end of the %list.\n@@ -750,7 +765,8 @@ namespace __gnu_norm\n        *  references.\n        */\n       void\n-      push_back(const value_type& __x) { this->_M_insert(end(), __x); }\n+      push_back(const value_type& __x)\n+      { this->_M_insert(end(), __x); }\n       \n       /**\n        *  @brief  Removes last element.\n@@ -764,7 +780,8 @@ namespace __gnu_norm\n        *  is needed, it should be retrieved before pop_back() is called.\n        */\n       void\n-      pop_back() { this->_M_erase(this->_M_node._M_prev); }\n+      pop_back()\n+      { this->_M_erase(this->_M_node._M_prev); }\n       \n       /**\n        *  @brief  Inserts given value into %list before specified iterator.\n@@ -876,7 +893,8 @@ namespace __gnu_norm\n        *  function.\n        */\n       void\n-      swap(list& __x) { _List_node_base::swap(this->_M_node,__x._M_node); }\n+      swap(list& __x)\n+      { _List_node_base::swap(this->_M_node,__x._M_node); }\n   \n       /**\n        *  Erases all the elements.  Note that this function only erases\n@@ -922,7 +940,8 @@ namespace __gnu_norm\n       {\n \titerator __j = __i;\n \t++__j;\n-\tif (__position == __i || __position == __j) return;\n+\tif (__position == __i || __position == __j)\n+\t  return;\n \tthis->_M_transfer(__position, __i, __j);\n       }\n   \n@@ -1037,7 +1056,8 @@ namespace __gnu_norm\n        *  Reverse the order of elements in the list in linear time.\n        */\n       void\n-      reverse() { this->_M_node.reverse(); }\n+      reverse()\n+      { this->_M_node.reverse(); }\n   \n       /**\n        *  @brief  Sort the elements.\n@@ -1118,16 +1138,13 @@ namespace __gnu_norm\n       // Moves the elements from [first,last) before position.\n       void\n       _M_transfer(iterator __position, iterator __first, iterator __last)\n-      {\n-        __position._M_node->transfer(__first._M_node,__last._M_node);\n-      }\n+      { __position._M_node->transfer(__first._M_node,__last._M_node); }\n \n       // Inserts new element at position given and with value given.\n       void\n       _M_insert(iterator __position, const value_type& __x)\n       {\n         _Node* __tmp = _M_create_node(__x);\n-\n         __tmp->hook(__position._M_node);\n       }\n \n@@ -1142,7 +1159,6 @@ namespace __gnu_norm\n       }\n     };\n   \n-  \n   /**\n    *  @brief  List equality comparison.\n    *  @param  x  A %list.\n@@ -1167,7 +1183,7 @@ namespace __gnu_norm\n \t{\n \t  ++__i1;\n \t  ++__i2;\n-      }\n+\t}\n       return __i1 == __end1 && __i2 == __end2;\n     }\n   \n@@ -1185,10 +1201,8 @@ namespace __gnu_norm\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-    {\n-      return std::lexicographical_compare(__x.begin(), __x.end(),\n-\t\t\t\t\t  __y.begin(), __y.end());\n-    }\n+    { return std::lexicographical_compare(__x.begin(), __x.end(),\n+\t\t\t\t\t  __y.begin(), __y.end()); }\n   \n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>"}, {"sha": "e86f4888af99a561eb6adcac75fd88cea7f8de25", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 517, "deletions": 484, "changes": 1001, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Map implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -89,503 +89,536 @@ namespace __gnu_norm\n   template <typename _Key, typename _Tp, typename _Compare = less<_Key>,\n             typename _Alloc = allocator<pair<const _Key, _Tp> > >\n     class map\n-  {\n-    // concept requirements\n-    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-    __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+\t__glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n+\t\t\t\t  _BinaryFunctionConcept)\n   \n-  public:\n-    typedef _Key                                          key_type;\n-    typedef _Tp                                           mapped_type;\n-    typedef pair<const _Key, _Tp>                         value_type;\n-    typedef _Compare                                      key_compare;\n+\tpublic:\n+      typedef _Key                                          key_type;\n+      typedef _Tp                                           mapped_type;\n+      typedef pair<const _Key, _Tp>                         value_type;\n+      typedef _Compare                                      key_compare;\n   \n-    class value_compare\n+      class value_compare\n       : public binary_function<value_type, value_type, bool>\n       {\n-        friend class map<_Key,_Tp,_Compare,_Alloc>;\n+\tfriend class map<_Key,_Tp,_Compare,_Alloc>;\n       protected:\n-        _Compare comp;\n-        value_compare(_Compare __c) : comp(__c) {}\n+\t_Compare comp;\n+\t\n+\tvalue_compare(_Compare __c)\n+\t  : comp(__c) { }\n+\t\n       public:\n-        bool operator()(const value_type& __x, const value_type& __y) const\n-        { return comp(__x.first, __y.first); }\n+\tbool operator()(const value_type& __x, const value_type& __y) const\n+\t{ return comp(__x.first, __y.first); }\n       };\n   \n-  private:\n-    /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n-    typedef _Rb_tree<key_type, value_type,\n-                     _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n-    /// @if maint  The actual tree structure.  @endif\n-    _Rep_type _M_t;\n-  \n-  public:\n-    // many of these are specified differently in ISO, but the following are\n-    // \"functionally equivalent\"\n-    typedef typename _Rep_type::allocator_type            allocator_type;\n-    typedef typename _Rep_type::reference                 reference;\n-    typedef typename _Rep_type::const_reference           const_reference;\n-    typedef typename _Rep_type::iterator                  iterator;\n-    typedef typename _Rep_type::const_iterator            const_iterator;\n-    typedef typename _Rep_type::size_type                 size_type;\n-    typedef typename _Rep_type::difference_type           difference_type;\n-    typedef typename _Rep_type::pointer                   pointer;\n-    typedef typename _Rep_type::const_pointer             const_pointer;\n-    typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n-    typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n-  \n-  \n-    // [23.3.1.1] construct/copy/destroy\n-    // (get_allocator() is normally listed in this section, but seems to have\n-    // been accidentally omitted in the printed standard)\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    map() : _M_t(_Compare(), allocator_type()) { }\n-  \n-    // for some reason this was made a separate function\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    map(const _Compare& __comp, const allocator_type& __a = allocator_type())\n+    private:\n+      /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n+      typedef _Rb_tree<key_type, value_type,\n+\t\t       _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+      /// @if maint  The actual tree structure.  @endif\n+      _Rep_type _M_t;\n+      \n+    public:\n+      // many of these are specified differently in ISO, but the following are\n+      // \"functionally equivalent\"\n+      typedef typename _Rep_type::allocator_type           allocator_type;\n+      typedef typename _Rep_type::reference                reference;\n+      typedef typename _Rep_type::const_reference          const_reference;\n+      typedef typename _Rep_type::iterator                 iterator;\n+      typedef typename _Rep_type::const_iterator           const_iterator;\n+      typedef typename _Rep_type::size_type                size_type;\n+      typedef typename _Rep_type::difference_type          difference_type;\n+      typedef typename _Rep_type::pointer                  pointer;\n+      typedef typename _Rep_type::const_pointer            const_pointer;\n+      typedef typename _Rep_type::reverse_iterator         reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator   const_reverse_iterator;\n+      \n+      // [23.3.1.1] construct/copy/destroy\n+      // (get_allocator() is normally listed in this section, but seems to have\n+      // been accidentally omitted in the printed standard)\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      map()\n+      : _M_t(_Compare(), allocator_type()) { }\n+      \n+      // for some reason this was made a separate function\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      map(const _Compare& __comp, const allocator_type& __a = allocator_type())\n       : _M_t(__comp, __a) { }\n   \n-    /**\n-     *  @brief  Map copy constructor.\n-     *  @param  x  A %map of identical element and allocator types.\n-     *\n-     *  The newly-created %map uses a copy of the allocation object used\n-     *  by @a x.\n-    */\n-    map(const map& __x)\n+      /**\n+       *  @brief  Map copy constructor.\n+       *  @param  x  A %map of identical element and allocator types.\n+       *\n+       *  The newly-created %map uses a copy of the allocation object used\n+       *  by @a x.\n+       */\n+      map(const map& __x)\n       : _M_t(__x._M_t) { }\n   \n-    /**\n-     *  @brief  Builds a %map from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *\n-     *  Create a %map consisting of copies of the elements from [first,last).\n-     *  This is linear in N if the range is already sorted, and NlogN\n-     *  otherwise (where N is distance(first,last)).\n-    */\n-    template <typename _InputIterator>\n-      map(_InputIterator __first, _InputIterator __last)\n-      : _M_t(_Compare(), allocator_type())\n-      { _M_t.insert_unique(__first, __last); }\n-  \n-    /**\n-     *  @brief  Builds a %map from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *  @param  comp  A comparison functor.\n-     *  @param  a  An allocator object.\n-     *\n-     *  Create a %map consisting of copies of the elements from [first,last).\n-     *  This is linear in N if the range is already sorted, and NlogN\n-     *  otherwise (where N is distance(first,last)).\n-    */\n-    template <typename _InputIterator>\n-      map(_InputIterator __first, _InputIterator __last,\n-          const _Compare& __comp, const allocator_type& __a = allocator_type())\n-      : _M_t(__comp, __a)\n-      { _M_t.insert_unique(__first, __last); }\n-  \n-    // FIXME There is no dtor declared, but we should have something generated\n-    // by Doxygen.  I don't know what tags to add to this paragraph to make\n-    // that happen:\n-    /**\n-     *  The dtor only erases the elements, and note that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n-    */\n-  \n-    /**\n-     *  @brief  Map assignment operator.\n-     *  @param  x  A %map of identical element and allocator types.\n-     *\n-     *  All the elements of @a x are copied, but unlike the copy constructor,\n-     *  the allocator object is not copied.\n-    */\n-    map&\n-    operator=(const map& __x)\n-    {\n-      _M_t = __x._M_t;\n-      return *this;\n-    }\n-  \n-    /// Get a copy of the memory allocation object.\n-    allocator_type\n-    get_allocator() const { return _M_t.get_allocator(); }\n-  \n-    // iterators\n-    /**\n-     *  Returns a read/write iterator that points to the first pair in the %map.\n-     *  Iteration is done in ascending order according to the keys.\n-    */\n-    iterator\n-    begin() { return _M_t.begin(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points to the first pair\n-     *  in the %map.  Iteration is done in ascending order according to the\n-     *  keys.\n-    */\n-    const_iterator\n-    begin() const { return _M_t.begin(); }\n-  \n-    /**\n-     *  Returns a read/write iterator that points one past the last pair in the\n-     *  %map.  Iteration is done in ascending order according to the keys.\n-    */\n-    iterator\n-    end() { return _M_t.end(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points one past the last\n-     *  pair in the %map.  Iteration is done in ascending order according to the\n-     *  keys.\n-    */\n-    const_iterator\n-    end() const { return _M_t.end(); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to the last pair in\n-     *  the %map.  Iteration is done in descending order according to the keys.\n-    */\n-    reverse_iterator\n-    rbegin() { return _M_t.rbegin(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to the last\n-     *  pair in the %map.  Iteration is done in descending order according to\n-     *  the keys.\n-    */\n-    const_reverse_iterator\n-    rbegin() const { return _M_t.rbegin(); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to one before the\n-     *  first pair in the %map.  Iteration is done in descending order according\n-     *  to the keys.\n-    */\n-    reverse_iterator\n-    rend() { return _M_t.rend(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to one\n-     *  before the first pair in the %map.  Iteration is done in descending\n-     *  order according to the keys.\n-    */\n-    const_reverse_iterator\n-    rend() const { return _M_t.rend(); }\n-  \n-    // capacity\n-    /** Returns true if the %map is empty.  (Thus begin() would equal end().) */\n-    bool\n-    empty() const { return _M_t.empty(); }\n-  \n-    /** Returns the size of the %map.  */\n-    size_type\n-    size() const { return _M_t.size(); }\n-  \n-    /** Returns the maximum size of the %map.  */\n-    size_type\n-    max_size() const { return _M_t.max_size(); }\n-  \n-    // [23.3.1.2] element access\n-    /**\n-     *  @brief  Subscript ( @c [] ) access to %map data.\n-     *  @param  k  The key for which data should be retrieved.\n-     *  @return  A reference to the data of the (key,data) %pair.\n-     *\n-     *  Allows for easy lookup with the subscript ( @c [] ) operator.  Returns\n-     *  data associated with the key specified in subscript.  If the key does\n-     *  not exist, a pair with that key is created using default values, which\n-     *  is then returned.\n-     *\n-     *  Lookup requires logarithmic time.\n-    */\n-    mapped_type&\n-    operator[](const key_type& __k)\n-    {\n-      // concept requirements\n-      __glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)\n-  \n-      iterator __i = lower_bound(__k);\n-      // __i->first is greater than or equivalent to __k.\n-      if (__i == end() || key_comp()(__k, (*__i).first))\n+      /**\n+       *  @brief  Builds a %map from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *\n+       *  Create a %map consisting of copies of the elements from [first,last).\n+       *  This is linear in N if the range is already sorted, and NlogN\n+       *  otherwise (where N is distance(first,last)).\n+       */\n+      template <typename _InputIterator>\n+        map(_InputIterator __first, _InputIterator __last)\n+\t: _M_t(_Compare(), allocator_type())\n+        { _M_t.insert_unique(__first, __last); }\n+  \n+      /**\n+       *  @brief  Builds a %map from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *  @param  comp  A comparison functor.\n+       *  @param  a  An allocator object.\n+       *\n+       *  Create a %map consisting of copies of the elements from [first,last).\n+       *  This is linear in N if the range is already sorted, and NlogN\n+       *  otherwise (where N is distance(first,last)).\n+       */\n+      template <typename _InputIterator>\n+        map(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp, const allocator_type& __a = allocator_type())\n+\t: _M_t(__comp, __a)\n+        { _M_t.insert_unique(__first, __last); }\n+  \n+      // FIXME There is no dtor declared, but we should have something generated\n+      // by Doxygen.  I don't know what tags to add to this paragraph to make\n+      // that happen:\n+      /**\n+       *  The dtor only erases the elements, and note that if the elements\n+       *  themselves are pointers, the pointed-to memory is not touched in any\n+       *  way.  Managing the pointer is the user's responsibilty.\n+       */\n+      \n+      /**\n+       *  @brief  Map assignment operator.\n+       *  @param  x  A %map of identical element and allocator types.\n+       *\n+       *  All the elements of @a x are copied, but unlike the copy constructor,\n+       *  the allocator object is not copied.\n+       */\n+      map&\n+      operator=(const map& __x)\n+      {\n+\t_M_t = __x._M_t;\n+\treturn *this;\n+      }\n+      \n+      /// Get a copy of the memory allocation object.\n+      allocator_type\n+      get_allocator() const\n+      { return _M_t.get_allocator(); }\n+      \n+      // iterators\n+      /**\n+       *  Returns a read/write iterator that points to the first pair in the \n+       *  %map.\n+       *  Iteration is done in ascending order according to the keys.\n+       */\n+      iterator\n+      begin()\n+      { return _M_t.begin(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first pair\n+       *  in the %map.  Iteration is done in ascending order according to the\n+       *  keys.\n+       */\n+      const_iterator\n+      begin() const\n+      { return _M_t.begin(); }\n+  \n+      /**\n+       *  Returns a read/write iterator that points one past the last pair in\n+       *  the %map.  Iteration is done in ascending order according to the keys.\n+       */\n+      iterator\n+      end()\n+      { return _M_t.end(); }\n+  \n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  pair in the %map.  Iteration is done in ascending order according to\n+       *  the keys.\n+       */\n+      const_iterator\n+      end() const\n+      { return _M_t.end(); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to the last pair in\n+       *  the %map.  Iteration is done in descending order according to the\n+       *  keys.\n+       */\n+      reverse_iterator\n+      rbegin()\n+      { return _M_t.rbegin(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to the\n+       *  last pair in the %map.  Iteration is done in descending order\n+       *  according to the keys.\n+       */\n+      const_reverse_iterator\n+      rbegin() const\n+      { return _M_t.rbegin(); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to one before the\n+       *  first pair in the %map.  Iteration is done in descending order\n+       *  according to the keys.\n+       */\n+      reverse_iterator\n+      rend()\n+      { return _M_t.rend(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to one\n+       *  before the first pair in the %map.  Iteration is done in descending\n+       *  order according to the keys.\n+       */\n+      const_reverse_iterator\n+      rend() const\n+      { return _M_t.rend(); }\n+      \n+      // capacity\n+      /** Returns true if the %map is empty.  (Thus begin() would equal\n+       *  end().)\n+      */\n+      bool\n+      empty() const\n+      { return _M_t.empty(); }\n+      \n+      /** Returns the size of the %map.  */\n+      size_type\n+      size() const\n+      { return _M_t.size(); }\n+      \n+      /** Returns the maximum size of the %map.  */\n+      size_type\n+      max_size() const\n+      { return _M_t.max_size(); }\n+      \n+      // [23.3.1.2] element access\n+      /**\n+       *  @brief  Subscript ( @c [] ) access to %map data.\n+       *  @param  k  The key for which data should be retrieved.\n+       *  @return  A reference to the data of the (key,data) %pair.\n+       *\n+       *  Allows for easy lookup with the subscript ( @c [] ) operator.  Returns\n+       *  data associated with the key specified in subscript.  If the key does\n+       *  not exist, a pair with that key is created using default values, which\n+       *  is then returned.\n+       *\n+       *  Lookup requires logarithmic time.\n+       */\n+      mapped_type&\n+      operator[](const key_type& __k)\n+      {\n+\t// concept requirements\n+\t__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)\n+\t\n+\titerator __i = lower_bound(__k);\n+\t// __i->first is greater than or equivalent to __k.\n+\tif (__i == end() || key_comp()(__k, (*__i).first))\n         __i = insert(__i, value_type(__k, mapped_type()));\n-      return (*__i).second;\n-    }\n-  \n-    // modifiers\n-    /**\n-     *  @brief Attempts to insert a std::pair into the %map.\n-     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-     *             pairs).\n-     *  @return  A pair, of which the first element is an iterator that points\n-     *           to the possibly inserted pair, and the second is a bool that\n-     *           is true if the pair was actually inserted.\n-     *\n-     *  This function attempts to insert a (key, value) %pair into the %map.\n-     *  A %map relies on unique keys and thus a %pair is only inserted if its\n-     *  first element (the key) is not already present in the %map.\n-     *\n-     *  Insertion requires logarithmic time.\n-    */\n-    pair<iterator,bool>\n-    insert(const value_type& __x)\n-    { return _M_t.insert_unique(__x); }\n-  \n-    /**\n-     *  @brief Attempts to insert a std::pair into the %map.\n-     *  @param  position  An iterator that serves as a hint as to where the\n-     *                    pair should be inserted.\n-     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-     *             pairs).\n-     *  @return  An iterator that points to the element with key of @a x (may\n-     *           or may not be the %pair passed in).\n-     *\n-     *  This function is not concerned about whether the insertion took place,\n-     *  and thus does not return a boolean like the single-argument\n-     *  insert() does.  Note that the first parameter is only a hint and can\n-     *  potentially improve the performance of the insertion process.  A bad\n-     *  hint would cause no gains in efficiency.\n-     *\n-     *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n-     *  for more on \"hinting\".\n-     *\n-     *  Insertion requires logarithmic time (if the hint is not taken).\n-    */\n-    iterator\n-    insert(iterator position, const value_type& __x)\n-    { return _M_t.insert_unique(position, __x); }\n-  \n-    /**\n-     *  @brief A template function that attemps to insert a range of elements.\n-     *  @param  first  Iterator pointing to the start of the range to be\n-     *                 inserted.\n-     *  @param  last  Iterator pointing to the end of the range.\n-     *\n-     *  Complexity similar to that of the range constructor.\n-    */\n-    template <typename _InputIterator>\n+\treturn (*__i).second;\n+      }\n+      \n+      // modifiers\n+      /**\n+       *  @brief Attempts to insert a std::pair into the %map.\n+       *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+       *             pairs).\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted pair, and the second is a bool that\n+       *           is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to insert a (key, value) %pair into the %map.\n+       *  A %map relies on unique keys and thus a %pair is only inserted if its\n+       *  first element (the key) is not already present in the %map.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      pair<iterator,bool>\n+      insert(const value_type& __x)\n+      { return _M_t.insert_unique(__x); }\n+      \n+      /**\n+       *  @brief Attempts to insert a std::pair into the %map.\n+       *  @param  position  An iterator that serves as a hint as to where the\n+       *                    pair should be inserted.\n+       *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+       *             pairs).\n+       *  @return  An iterator that points to the element with key of @a x (may\n+       *           or may not be the %pair passed in).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument\n+       *  insert() does.  Note that the first parameter is only a hint and can\n+       *  potentially improve the performance of the insertion process.  A bad\n+       *  hint would cause no gains in efficiency.\n+       *\n+       *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+       *  for more on \"hinting\".\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      iterator\n+      insert(iterator position, const value_type& __x)\n+      { return _M_t.insert_unique(position, __x); }\n+  \n+      /**\n+       *  @brief A template function that attemps to insert a range of elements.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 inserted.\n+       *  @param  last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template <typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        { _M_t.insert_unique(__first, __last); }\n+  \n+      /**\n+       *  @brief Erases an element from a %map.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from a %map.  Note that this function only erases the element, and\n+       *  that if the element is itself a pointer, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's responsibilty.\n+       */\n       void\n-      insert(_InputIterator __first, _InputIterator __last)\n-      { _M_t.insert_unique(__first, __last); }\n-  \n-    /**\n-     *  @brief Erases an element from a %map.\n-     *  @param  position  An iterator pointing to the element to be erased.\n-     *\n-     *  This function erases an element, pointed to by the given iterator, from\n-     *  a %map.  Note that this function only erases the element, and that if\n-     *  the element is itself a pointer, the pointed-to memory is not touched\n-     *  in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    void\n-    erase(iterator __position) { _M_t.erase(__position); }\n-  \n-    /**\n-     *  @brief Erases elements according to the provided key.\n-     *  @param  x  Key of element to be erased.\n-     *  @return  The number of elements erased.\n-     *\n-     *  This function erases all the elements located by the given key from\n-     *  a %map.\n-     *  Note that this function only erases the element, and that if\n-     *  the element is itself a pointer, the pointed-to memory is not touched\n-     *  in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    size_type\n-    erase(const key_type& __x) { return _M_t.erase(__x); }\n-  \n-    /**\n-     *  @brief Erases a [first,last) range of elements from a %map.\n-     *  @param  first  Iterator pointing to the start of the range to be erased.\n-     *  @param  last  Iterator pointing to the end of the range to be erased.\n-     *\n-     *  This function erases a sequence of elements from a %map.\n-     *  Note that this function only erases the element, and that if\n-     *  the element is itself a pointer, the pointed-to memory is not touched\n-     *  in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    void\n-    erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n-  \n-    /**\n-     *  @brief  Swaps data with another %map.\n-     *  @param  x  A %map of the same element and allocator types.\n-     *\n-     *  This exchanges the elements between two maps in constant time.\n-     *  (It is only swapping a pointer, an integer, and an instance of\n-     *  the @c Compare type (which itself is often stateless and empty), so it\n-     *  should be quite fast.)\n-     *  Note that the global std::swap() function is specialized such that\n-     *  std::swap(m1,m2) will feed to this function.\n-    */\n-    void\n-    swap(map& __x) { _M_t.swap(__x._M_t); }\n-  \n-    /**\n-     *  Erases all elements in a %map.  Note that this function only erases\n-     *  the elements, and that if the elements themselves are pointers, the\n-     *  pointed-to memory is not touched in any way.  Managing the pointer is\n-     *  the user's responsibilty.\n-    */\n-    void\n-    clear() { _M_t.clear(); }\n-  \n-    // observers\n-    /**\n-     *  Returns the key comparison object out of which the %map was constructed.\n-    */\n-    key_compare\n-    key_comp() const { return _M_t.key_comp(); }\n-  \n-    /**\n-     *  Returns a value comparison object, built from the key comparison\n-     *  object out of which the %map was constructed.\n-    */\n-    value_compare\n-    value_comp() const { return value_compare(_M_t.key_comp()); }\n-  \n-    // [23.3.1.3] map operations\n-    /**\n-     *  @brief Tries to locate an element in a %map.\n-     *  @param  x  Key of (key, value) %pair to be located.\n-     *  @return  Iterator pointing to sought-after element, or end() if not\n-     *           found.\n-     *\n-     *  This function takes a key and tries to locate the element with which\n-     *  the key matches.  If successful the function returns an iterator\n-     *  pointing to the sought after %pair.  If unsuccessful it returns the\n-     *  past-the-end ( @c end() ) iterator.\n-    */\n-    iterator\n-    find(const key_type& __x) { return _M_t.find(__x); }\n-  \n-    /**\n-     *  @brief Tries to locate an element in a %map.\n-     *  @param  x  Key of (key, value) %pair to be located.\n-     *  @return  Read-only (constant) iterator pointing to sought-after\n-     *           element, or end() if not found.\n-     *\n-     *  This function takes a key and tries to locate the element with which\n-     *  the key matches.  If successful the function returns a constant iterator\n-     *  pointing to the sought after %pair. If unsuccessful it returns the\n-     *  past-the-end ( @c end() ) iterator.\n-    */\n-    const_iterator\n-    find(const key_type& __x) const { return _M_t.find(__x); }\n-  \n-    /**\n-     *  @brief  Finds the number of elements with given key.\n-     *  @param  x  Key of (key, value) pairs to be located.\n-     *  @return  Number of elements with specified key.\n-     *\n-     *  This function only makes sense for multimaps; for map the result will\n-     *  either be 0 (not present) or 1 (present).\n-    */\n-    size_type\n-    count(const key_type& __x) const\n-    { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n-  \n-    /**\n-     *  @brief Finds the beginning of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Iterator pointing to first element equal to or greater\n-     *           than key, or end().\n-     *\n-     *  This function returns the first element of a subsequence of elements\n-     *  that matches the given key.  If unsuccessful it returns an iterator\n-     *  pointing to the first element that has a greater value than given key\n-     *  or end() if no such element exists.\n-    */\n-    iterator\n-    lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds the beginning of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Read-only (constant) iterator pointing to first element\n-     *           equal to or greater than key, or end().\n-     *\n-     *  This function returns the first element of a subsequence of elements\n-     *  that matches the given key.  If unsuccessful it returns an iterator\n-     *  pointing to the first element that has a greater value than given key\n-     *  or end() if no such element exists.\n-    */\n-    const_iterator\n-    lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds the end of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return Iterator pointing to the first element\n-     *          greater than key, or end().\n-    */\n-    iterator\n-    upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds the end of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Read-only (constant) iterator pointing to first iterator\n-     *           greater than key, or end().\n-    */\n-    const_iterator\n-    upper_bound(const key_type& __x) const\n-    { return _M_t.upper_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pairs to be located.\n-     *  @return  Pair of iterators that possibly points to the subsequence\n-     *           matching given key.\n-     *\n-     *  This function is equivalent to\n-     *  @code\n-     *    std::make_pair(c.lower_bound(val),\n-     *                   c.upper_bound(val))\n-     *  @endcode\n-     *  (but is faster than making the calls separately).\n-     *\n-     *  This function probably only makes sense for multimaps.\n-    */\n-    pair<iterator,iterator>\n-    equal_range(const key_type& __x)\n-    { return _M_t.equal_range(__x); }\n-  \n-    /**\n-     *  @brief Finds a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pairs to be located.\n-     *  @return  Pair of read-only (constant) iterators that possibly points to\n-     *           the subsequence matching given key.\n-     *\n-     *  This function is equivalent to\n-     *  @code\n-     *    std::make_pair(c.lower_bound(val),\n-     *                   c.upper_bound(val))\n-     *  @endcode\n-     *  (but is faster than making the calls separately).\n-     *\n-     *  This function probably only makes sense for multimaps.\n-    */\n-    pair<const_iterator,const_iterator>\n-    equal_range(const key_type& __x) const\n-    { return _M_t.equal_range(__x); }\n-  \n-    template <typename _K1, typename _T1, typename _C1, typename _A1>\n-    friend bool operator== (const map<_K1,_T1,_C1,_A1>&,\n-                            const map<_K1,_T1,_C1,_A1>&);\n-    template <typename _K1, typename _T1, typename _C1, typename _A1>\n-    friend bool operator< (const map<_K1,_T1,_C1,_A1>&,\n-                           const map<_K1,_T1,_C1,_A1>&);\n-  };\n-  \n+      erase(iterator __position)\n+      { _M_t.erase(__position); }\n+  \n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  x  Key of element to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all the elements located by the given key from\n+       *  a %map.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      size_type\n+      erase(const key_type& __x)\n+      { return _M_t.erase(__x); }\n+      \n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %map.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *\n+       *  This function erases a sequence of elements from a %map.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      void\n+      erase(iterator __first, iterator __last)\n+      { _M_t.erase(__first, __last); }\n+      \n+      /**\n+       *  @brief  Swaps data with another %map.\n+       *  @param  x  A %map of the same element and allocator types.\n+       *\n+       *  This exchanges the elements between two maps in constant time.\n+       *  (It is only swapping a pointer, an integer, and an instance of\n+       *  the @c Compare type (which itself is often stateless and empty), so it\n+       *  should be quite fast.)\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(m1,m2) will feed to this function.\n+       */\n+      void\n+      swap(map& __x)\n+      { _M_t.swap(__x._M_t); }\n+  \n+      /**\n+       *  Erases all elements in a %map.  Note that this function only erases\n+       *  the elements, and that if the elements themselves are pointers, the\n+       *  pointed-to memory is not touched in any way.  Managing the pointer is\n+       *  the user's responsibilty.\n+       */\n+      void\n+      clear()\n+      { _M_t.clear(); }\n+  \n+      // observers\n+      /**\n+       *  Returns the key comparison object out of which the %map was\n+       *  constructed.\n+       */\n+      key_compare\n+      key_comp() const\n+      { return _M_t.key_comp(); }\n+      \n+      /**\n+       *  Returns a value comparison object, built from the key comparison\n+       *  object out of which the %map was constructed.\n+       */\n+      value_compare\n+      value_comp() const\n+      { return value_compare(_M_t.key_comp()); }\n+      \n+      // [23.3.1.3] map operations\n+      /**\n+       *  @brief Tries to locate an element in a %map.\n+       *  @param  x  Key of (key, value) %pair to be located.\n+       *  @return  Iterator pointing to sought-after element, or end() if not\n+       *           found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after %pair.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_t.find(__x); }\n+  \n+      /**\n+       *  @brief Tries to locate an element in a %map.\n+       *  @param  x  Key of (key, value) %pair to be located.\n+       *  @return  Read-only (constant) iterator pointing to sought-after\n+       *           element, or end() if not found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns a constant\n+       *  iterator pointing to the sought after %pair. If unsuccessful it\n+       *  returns the past-the-end ( @c end() ) iterator.\n+       */\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_t.find(__x); }\n+      \n+      /**\n+       *  @brief  Finds the number of elements with given key.\n+       *  @param  x  Key of (key, value) pairs to be located.\n+       *  @return  Number of elements with specified key.\n+       *\n+       *  This function only makes sense for multimaps; for map the result will\n+       *  either be 0 (not present) or 1 (present).\n+       */\n+      size_type\n+      count(const key_type& __x) const\n+      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n+  \n+      /**\n+       *  @brief Finds the beginning of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Iterator pointing to first element equal to or greater\n+       *           than key, or end().\n+       *\n+       *  This function returns the first element of a subsequence of elements\n+       *  that matches the given key.  If unsuccessful it returns an iterator\n+       *  pointing to the first element that has a greater value than given key\n+       *  or end() if no such element exists.\n+       */\n+      iterator\n+      lower_bound(const key_type& __x)\n+      { return _M_t.lower_bound(__x); }\n+      \n+      /**\n+       *  @brief Finds the beginning of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Read-only (constant) iterator pointing to first element\n+       *           equal to or greater than key, or end().\n+       *\n+       *  This function returns the first element of a subsequence of elements\n+       *  that matches the given key.  If unsuccessful it returns an iterator\n+       *  pointing to the first element that has a greater value than given key\n+       *  or end() if no such element exists.\n+       */\n+      const_iterator\n+      lower_bound(const key_type& __x) const\n+      { return _M_t.lower_bound(__x); }\n+      \n+      /**\n+       *  @brief Finds the end of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return Iterator pointing to the first element\n+       *          greater than key, or end().\n+       */\n+      iterator\n+      upper_bound(const key_type& __x)\n+      { return _M_t.upper_bound(__x); }\n+      \n+      /**\n+       *  @brief Finds the end of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Read-only (constant) iterator pointing to first iterator\n+       *           greater than key, or end().\n+       */\n+      const_iterator\n+      upper_bound(const key_type& __x) const\n+      { return _M_t.upper_bound(__x); }\n+      \n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pairs to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       *\n+       *  This function is equivalent to\n+       *  @code\n+       *    std::make_pair(c.lower_bound(val),\n+       *                   c.upper_bound(val))\n+       *  @endcode\n+       *  (but is faster than making the calls separately).\n+       *\n+       *  This function probably only makes sense for multimaps.\n+       */\n+      pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      { return _M_t.equal_range(__x); }\n+  \n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pairs to be located.\n+       *  @return  Pair of read-only (constant) iterators that possibly points\n+       *           to the subsequence matching given key.\n+       *\n+       *  This function is equivalent to\n+       *  @code\n+       *    std::make_pair(c.lower_bound(val),\n+       *                   c.upper_bound(val))\n+       *  @endcode\n+       *  (but is faster than making the calls separately).\n+       *\n+       *  This function probably only makes sense for multimaps.\n+       */\n+      pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      { return _M_t.equal_range(__x); }\n+      \n+      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+      friend bool operator== (const map<_K1,_T1,_C1,_A1>&,\n+\t\t\t      const map<_K1,_T1,_C1,_A1>&);\n+      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+      friend bool operator< (const map<_K1,_T1,_C1,_A1>&,\n+\t\t\t     const map<_K1,_T1,_C1,_A1>&);\n+    };\n   \n   /**\n    *  @brief  Map equality comparison."}, {"sha": "cfd28ef3ad7158dbcc6177191220fac93fb26e64", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 487, "deletions": 448, "changes": 935, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // Multimap implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -103,466 +103,507 @@ namespace __gnu_norm\n   */\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     class multimap\n-  {\n-    // concept requirements\n-    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-    __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n-  \n-  public:\n-    typedef _Key                                          key_type;\n-    typedef _Tp                                           mapped_type;\n-    typedef pair<const _Key, _Tp>                         value_type;\n-    typedef _Compare                                      key_compare;\n-  \n-    class value_compare\n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n+\t\t\t\t_BinaryFunctionConcept)\n+\t\n+    public:\n+      typedef _Key                                          key_type;\n+      typedef _Tp                                           mapped_type;\n+      typedef pair<const _Key, _Tp>                         value_type;\n+      typedef _Compare                                      key_compare;\n+      \n+      class value_compare\n       : public binary_function<value_type, value_type, bool>\n       {\n-        friend class multimap<_Key,_Tp,_Compare,_Alloc>;\n+\tfriend class multimap<_Key,_Tp,_Compare,_Alloc>;\n       protected:\n-        _Compare comp;\n-        value_compare(_Compare __c) : comp(__c) {}\n+\t_Compare comp;\n+\t\n+\tvalue_compare(_Compare __c)\n+\t  : comp(__c) { }\n+\t\n       public:\n-        bool operator()(const value_type& __x, const value_type& __y) const\n-        { return comp(__x.first, __y.first); }\n-    };\n-  \n-  private:\n-    /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n-    typedef _Rb_tree<key_type, value_type,\n-                    _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n-    /// @if maint  The actual tree structure.  @endif\n-    _Rep_type _M_t;\n-  \n-  public:\n-    // many of these are specified differently in ISO, but the following are\n-    // \"functionally equivalent\"\n-    typedef typename _Rep_type::allocator_type            allocator_type;\n-    typedef typename _Rep_type::reference                 reference;\n-    typedef typename _Rep_type::const_reference           const_reference;\n-    typedef typename _Rep_type::iterator                  iterator;\n-    typedef typename _Rep_type::const_iterator            const_iterator;\n-    typedef typename _Rep_type::size_type                 size_type;\n-    typedef typename _Rep_type::difference_type           difference_type;\n-    typedef typename _Rep_type::pointer                   pointer;\n-    typedef typename _Rep_type::const_pointer             const_pointer;\n-    typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n-    typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n-  \n-  \n-    // [23.3.2] construct/copy/destroy\n-    // (get_allocator() is also listed in this section)\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    multimap() : _M_t(_Compare(), allocator_type()) { }\n-  \n-    // for some reason this was made a separate function\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    multimap(const _Compare& __comp, const allocator_type& __a = allocator_type())\n+\tbool operator()(const value_type& __x, const value_type& __y) const\n+\t{ return comp(__x.first, __y.first); }\n+      };\n+      \n+    private:\n+      /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n+      typedef _Rb_tree<key_type, value_type,\n+\t\t       _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+      /// @if maint  The actual tree structure.  @endif\n+      _Rep_type _M_t;\n+  \n+    public:\n+      // many of these are specified differently in ISO, but the following are\n+      // \"functionally equivalent\"\n+      typedef typename _Rep_type::allocator_type         allocator_type;\n+      typedef typename _Rep_type::reference              reference;\n+      typedef typename _Rep_type::const_reference        const_reference;\n+      typedef typename _Rep_type::iterator               iterator;\n+      typedef typename _Rep_type::const_iterator         const_iterator;\n+      typedef typename _Rep_type::size_type              size_type;\n+      typedef typename _Rep_type::difference_type        difference_type;\n+      typedef typename _Rep_type::pointer                pointer;\n+      typedef typename _Rep_type::const_pointer          const_pointer;\n+      typedef typename _Rep_type::reverse_iterator       reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+  \n+  \n+      // [23.3.2] construct/copy/destroy\n+      // (get_allocator() is also listed in this section)\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      multimap()\n+      : _M_t(_Compare(), allocator_type()) { }\n+  \n+      // for some reason this was made a separate function\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      multimap(const _Compare& __comp,\n+\t       const allocator_type& __a = allocator_type())\n       : _M_t(__comp, __a) { }\n   \n-    /**\n-     *  @brief  %Multimap copy constructor.\n-     *  @param  x  A %multimap of identical element and allocator types.\n-     *\n-     *  The newly-created %multimap uses a copy of the allocation object used\n-     *  by @a x.\n-    */\n-    multimap(const multimap& __x)\n+      /**\n+       *  @brief  %Multimap copy constructor.\n+       *  @param  x  A %multimap of identical element and allocator types.\n+       *\n+       *  The newly-created %multimap uses a copy of the allocation object used\n+       *  by @a x.\n+       */\n+      multimap(const multimap& __x)\n       : _M_t(__x._M_t) { }\n   \n-    /**\n-     *  @brief  Builds a %multimap from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *\n-     *  Create a %multimap consisting of copies of the elements from\n-     *  [first,last).  This is linear in N if the range is already sorted,\n-     *  and NlogN otherwise (where N is distance(first,last)).\n-    */\n-    template <typename _InputIterator>\n-      multimap(_InputIterator __first, _InputIterator __last)\n-        : _M_t(_Compare(), allocator_type())\n+      /**\n+       *  @brief  Builds a %multimap from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *\n+       *  Create a %multimap consisting of copies of the elements from\n+       *  [first,last).  This is linear in N if the range is already sorted,\n+       *  and NlogN otherwise (where N is distance(first,last)).\n+       */\n+      template <typename _InputIterator>\n+        multimap(_InputIterator __first, _InputIterator __last)\n+\t: _M_t(_Compare(), allocator_type())\n         { _M_t.insert_equal(__first, __last); }\n   \n-    /**\n-     *  @brief  Builds a %multimap from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *  @param  comp  A comparison functor.\n-     *  @param  a  An allocator object.\n-     *\n-     *  Create a %multimap consisting of copies of the elements from\n-     *  [first,last).  This is linear in N if the range is already sorted,\n-     *  and NlogN otherwise (where N is distance(first,last)).\n-    */\n-    template <typename _InputIterator>\n-      multimap(_InputIterator __first, _InputIterator __last,\n-               const _Compare& __comp,\n-               const allocator_type& __a = allocator_type())\n+      /**\n+       *  @brief  Builds a %multimap from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *  @param  comp  A comparison functor.\n+       *  @param  a  An allocator object.\n+       *\n+       *  Create a %multimap consisting of copies of the elements from\n+       *  [first,last).  This is linear in N if the range is already sorted,\n+       *  and NlogN otherwise (where N is distance(first,last)).\n+       */\n+      template <typename _InputIterator>\n+        multimap(_InputIterator __first, _InputIterator __last,\n+\t\t const _Compare& __comp,\n+\t\t const allocator_type& __a = allocator_type())\n         : _M_t(__comp, __a)\n         { _M_t.insert_equal(__first, __last); }\n   \n-    // FIXME There is no dtor declared, but we should have something generated\n-    // by Doxygen.  I don't know what tags to add to this paragraph to make\n-    // that happen:\n-    /**\n-     *  The dtor only erases the elements, and note that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n-    */\n-  \n-    /**\n-     *  @brief  %Multimap assignment operator.\n-     *  @param  x  A %multimap of identical element and allocator types.\n-     *\n-     *  All the elements of @a x are copied, but unlike the copy constructor,\n-     *  the allocator object is not copied.\n-    */\n-    multimap&\n-    operator=(const multimap& __x)\n-    {\n-      _M_t = __x._M_t;\n-      return *this;\n-    }\n-  \n-    /// Get a copy of the memory allocation object.\n-    allocator_type\n-    get_allocator() const { return _M_t.get_allocator(); }\n-  \n-    // iterators\n-    /**\n-     *  Returns a read/write iterator that points to the first pair in the\n-     *  %multimap.  Iteration is done in ascending order according to the keys.\n-    */\n-    iterator\n-    begin() { return _M_t.begin(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points to the first pair\n-     *  in the %multimap.  Iteration is done in ascending order according to the\n-     *  keys.\n-    */\n-    const_iterator\n-    begin() const { return _M_t.begin(); }\n-  \n-    /**\n-     *  Returns a read/write iterator that points one past the last pair in the\n-     *  %multimap.  Iteration is done in ascending order according to the keys.\n-    */\n-    iterator\n-    end() { return _M_t.end(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points one past the last\n-     *  pair in the %multimap.  Iteration is done in ascending order according\n-     *  to the keys.\n-    */\n-    const_iterator\n-    end() const { return _M_t.end(); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to the last pair in\n-     *  the %multimap.  Iteration is done in descending order according to the\n-     *  keys.\n-    */\n-    reverse_iterator\n-    rbegin() { return _M_t.rbegin(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to the last\n-     *  pair in the %multimap.  Iteration is done in descending order according\n-     *  to the keys.\n-    */\n-    const_reverse_iterator\n-    rbegin() const { return _M_t.rbegin(); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to one before the\n-     *  first pair in the %multimap.  Iteration is done in descending order\n-     *  according to the keys.\n-    */\n-    reverse_iterator\n-    rend() { return _M_t.rend(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to one\n-     *  before the first pair in the %multimap.  Iteration is done in descending\n-     *  order according to the keys.\n-    */\n-    const_reverse_iterator\n-    rend() const { return _M_t.rend(); }\n-  \n-    // capacity\n-    /** Returns true if the %multimap is empty.  */\n-    bool\n-    empty() const { return _M_t.empty(); }\n-  \n-    /** Returns the size of the %multimap.  */\n-    size_type\n-    size() const { return _M_t.size(); }\n-  \n-    /** Returns the maximum size of the %multimap.  */\n-    size_type\n-    max_size() const { return _M_t.max_size(); }\n-  \n-    // modifiers\n-    /**\n-     *  @brief Inserts a std::pair into the %multimap.\n-     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-     *             pairs).\n-     *  @return An iterator that points to the inserted (key,value) pair.\n-     *\n-     *  This function inserts a (key, value) pair into the %multimap.  Contrary\n-     *  to a std::map the %multimap does not rely on unique keys and thus\n-     *  multiple pairs with the same key can be inserted.\n-     *\n-     *  Insertion requires logarithmic time.\n-    */\n-    iterator\n-    insert(const value_type& __x) { return _M_t.insert_equal(__x); }\n-  \n-    /**\n-     *  @brief Inserts a std::pair into the %multimap.\n-     *  @param  position  An iterator that serves as a hint as to where the\n-     *                    pair should be inserted.\n-     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-     *             pairs).\n-     *  @return An iterator that points to the inserted (key,value) pair.\n-     *\n-     *  This function inserts a (key, value) pair into the %multimap.  Contrary\n-     *  to a std::map the %multimap does not rely on unique keys and thus\n-     *  multiple pairs with the same key can be inserted.\n-     *  Note that the first parameter is only a hint and can potentially\n-     *  improve the performance of the insertion process.  A bad hint would\n-     *  cause no gains in efficiency.\n-     *\n-     *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n-     *  for more on \"hinting\".\n-     *\n-     *  Insertion requires logarithmic time (if the hint is not taken).\n-    */\n-    iterator\n-    insert(iterator __position, const value_type& __x)\n-    { return _M_t.insert_equal(__position, __x); }\n+      // FIXME There is no dtor declared, but we should have something generated\n+      // by Doxygen.  I don't know what tags to add to this paragraph to make\n+      // that happen:\n+      /**\n+       *  The dtor only erases the elements, and note that if the elements\n+       *  themselves are pointers, the pointed-to memory is not touched in any\n+       *  way.  Managing the pointer is the user's responsibilty.\n+       */\n+  \n+      /**\n+       *  @brief  %Multimap assignment operator.\n+       *  @param  x  A %multimap of identical element and allocator types.\n+       *\n+       *  All the elements of @a x are copied, but unlike the copy constructor,\n+       *  the allocator object is not copied.\n+       */\n+      multimap&\n+      operator=(const multimap& __x)\n+      {\n+\t_M_t = __x._M_t;\n+\treturn *this;\n+      }\n+      \n+      /// Get a copy of the memory allocation object.\n+      allocator_type\n+      get_allocator() const\n+      { return _M_t.get_allocator(); }\n+      \n+      // iterators\n+      /**\n+       *  Returns a read/write iterator that points to the first pair in the\n+       *  %multimap.  Iteration is done in ascending order according to the\n+       *  keys.\n+       */\n+      iterator\n+      begin()\n+      { return _M_t.begin(); }\n+  \n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first pair\n+       *  in the %multimap.  Iteration is done in ascending order according to\n+       *  the keys.\n+       */\n+      const_iterator\n+      begin() const\n+      { return _M_t.begin(); }\n+      \n+      /**\n+       *  Returns a read/write iterator that points one past the last pair in\n+       *  the %multimap.  Iteration is done in ascending order according to the\n+       *  keys.\n+       */\n+      iterator\n+      end()\n+      { return _M_t.end(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  pair in the %multimap.  Iteration is done in ascending order according\n+       *  to the keys.\n+       */\n+      const_iterator\n+      end() const\n+      { return _M_t.end(); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to the last pair in\n+       *  the %multimap.  Iteration is done in descending order according to the\n+       *  keys.\n+       */\n+      reverse_iterator\n+      rbegin()\n+      { return _M_t.rbegin(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to the\n+       *  last pair in the %multimap.  Iteration is done in descending order\n+       *  according to the keys.\n+       */\n+      const_reverse_iterator\n+      rbegin() const\n+      { return _M_t.rbegin(); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to one before the\n+       *  first pair in the %multimap.  Iteration is done in descending order\n+       *  according to the keys.\n+       */\n+      reverse_iterator\n+      rend()\n+      { return _M_t.rend(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to one\n+       *  before the first pair in the %multimap.  Iteration is done in\n+       *  descending order according to the keys.\n+       */\n+      const_reverse_iterator\n+      rend() const\n+      { return _M_t.rend(); }\n+      \n+      // capacity\n+      /** Returns true if the %multimap is empty.  */\n+      bool\n+      empty() const\n+      { return _M_t.empty(); }\n+      \n+      /** Returns the size of the %multimap.  */\n+      size_type\n+      size() const\n+      { return _M_t.size(); }\n+      \n+      /** Returns the maximum size of the %multimap.  */\n+      size_type\n+      max_size() const\n+      { return _M_t.max_size(); }\n+      \n+      // modifiers\n+      /**\n+       *  @brief Inserts a std::pair into the %multimap.\n+       *  @param  x  Pair to be inserted (see std::make_pair for easy creation\n+       *             of pairs).\n+       *  @return An iterator that points to the inserted (key,value) pair.\n+       *\n+       *  This function inserts a (key, value) pair into the %multimap. \n+       *  Contrary to a std::map the %multimap does not rely on unique keys and\n+       *  thus multiple pairs with the same key can be inserted.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      iterator\n+      insert(const value_type& __x)\n+      { return _M_t.insert_equal(__x); }\n+  \n+      /**\n+       *  @brief Inserts a std::pair into the %multimap.\n+       *  @param  position  An iterator that serves as a hint as to where the\n+       *                    pair should be inserted.\n+       *  @param  x  Pair to be inserted (see std::make_pair for easy creation\n+       *             of pairs).\n+       *  @return An iterator that points to the inserted (key,value) pair.\n+       *\n+       *  This function inserts a (key, value) pair into the %multimap. \n+       *  Contrary to a std::map the %multimap does not rely on unique keys and\n+       *  thus multiple pairs with the same key can be inserted.\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process.  A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+       *  for more on \"hinting\".\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      iterator\n+      insert(iterator __position, const value_type& __x)\n+      { return _M_t.insert_equal(__position, __x); }\n+      \n+      /**\n+       *  @brief A template function that attemps to insert a range of elements.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 inserted.\n+       *  @param  last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template <typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        { _M_t.insert_equal(__first, __last); }\n   \n-    /**\n-     *  @brief A template function that attemps to insert a range of elements.\n-     *  @param  first  Iterator pointing to the start of the range to be\n-     *                 inserted.\n-     *  @param  last  Iterator pointing to the end of the range.\n-     *\n-     *  Complexity similar to that of the range constructor.\n-    */\n-    template <typename _InputIterator>\n+      /**\n+       *  @brief Erases an element from a %multimap.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from a %multimap.  Note that this function only erases the element,\n+       *  and that if the element is itself a pointer, the pointed-to memory is\n+       *  not touched in any way.  Managing the pointer is the user's\n+       *  responsibilty.\n+       */\n       void\n-      insert(_InputIterator __first, _InputIterator __last)\n-      { _M_t.insert_equal(__first, __last); }\n-  \n-    /**\n-     *  @brief Erases an element from a %multimap.\n-     *  @param  position  An iterator pointing to the element to be erased.\n-     *\n-     *  This function erases an element, pointed to by the given iterator, from\n-     *  a %multimap.  Note that this function only erases the element, and that\n-     *  if the element is itself a pointer, the pointed-to memory is not\n-     *  touched in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    void\n-    erase(iterator __position) { _M_t.erase(__position); }\n-  \n-    /**\n-     *  @brief Erases elements according to the provided key.\n-     *  @param  x  Key of element to be erased.\n-     *  @return  The number of elements erased.\n-     *\n-     *  This function erases all elements located by the given key from a\n-     *  %multimap.\n-     *  Note that this function only erases the element, and that if\n-     *  the element is itself a pointer, the pointed-to memory is not touched\n-     *  in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    size_type\n-    erase(const key_type& __x) { return _M_t.erase(__x); }\n-  \n-    /**\n-     *  @brief Erases a [first,last) range of elements from a %multimap.\n-     *  @param  first  Iterator pointing to the start of the range to be erased.\n-     *  @param  last  Iterator pointing to the end of the range to be erased.\n-     *\n-     *  This function erases a sequence of elements from a %multimap.\n-     *  Note that this function only erases the elements, and that if\n-     *  the elements themselves are pointers, the pointed-to memory is not\n-     *  touched in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    void\n-    erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n-  \n-    /**\n-     *  @brief  Swaps data with another %multimap.\n-     *  @param  x  A %multimap of the same element and allocator types.\n-     *\n-     *  This exchanges the elements between two multimaps in constant time.\n-     *  (It is only swapping a pointer, an integer, and an instance of\n-     *  the @c Compare type (which itself is often stateless and empty), so it\n-     *  should be quite fast.)\n-     *  Note that the global std::swap() function is specialized such that\n-     *  std::swap(m1,m2) will feed to this function.\n-    */\n-    void\n-    swap(multimap& __x) { _M_t.swap(__x._M_t); }\n-  \n-    /**\n-     *  Erases all elements in a %multimap.  Note that this function only erases\n-     *  the elements, and that if the elements themselves are pointers, the\n-     *  pointed-to memory is not touched in any way.  Managing the pointer is\n-     *  the user's responsibilty.\n-    */\n-    void\n-    clear() { _M_t.clear(); }\n-  \n-    // observers\n-    /**\n-     *  Returns the key comparison object out of which the %multimap\n-     *  was constructed.\n-    */\n-    key_compare\n-    key_comp() const { return _M_t.key_comp(); }\n-  \n-    /**\n-     *  Returns a value comparison object, built from the key comparison\n-     *  object out of which the %multimap was constructed.\n-    */\n-    value_compare\n-    value_comp() const { return value_compare(_M_t.key_comp()); }\n-  \n-    // multimap operations\n-    /**\n-     *  @brief Tries to locate an element in a %multimap.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Iterator pointing to sought-after element,\n-     *           or end() if not found.\n-     *\n-     *  This function takes a key and tries to locate the element with which\n-     *  the key matches.  If successful the function returns an iterator\n-     *  pointing to the sought after %pair.  If unsuccessful it returns the\n-     *  past-the-end ( @c end() ) iterator.\n-    */\n-    iterator\n-    find(const key_type& __x) { return _M_t.find(__x); }\n-  \n-    /**\n-     *  @brief Tries to locate an element in a %multimap.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Read-only (constant) iterator pointing to sought-after\n-     *           element, or end() if not found.\n-     *\n-     *  This function takes a key and tries to locate the element with which\n-     *  the key matches.  If successful the function returns a constant iterator\n-     *  pointing to the sought after %pair.  If unsuccessful it returns the\n-     *  past-the-end ( @c end() ) iterator.\n-    */\n-    const_iterator\n-    find(const key_type& __x) const { return _M_t.find(__x); }\n-  \n-    /**\n-     *  @brief Finds the number of elements with given key.\n-     *  @param  x  Key of (key, value) pairs to be located.\n-     *  @return Number of elements with specified key.\n-    */\n-    size_type\n-    count(const key_type& __x) const { return _M_t.count(__x); }\n-  \n-    /**\n-     *  @brief Finds the beginning of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Iterator pointing to first element equal to or greater\n-     *           than key, or end().\n-     *\n-     *  This function returns the first element of a subsequence of elements\n-     *  that matches the given key.  If unsuccessful it returns an iterator\n-     *  pointing to the first element that has a greater value than given key\n-     *  or end() if no such element exists.\n-    */\n-    iterator\n-    lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds the beginning of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Read-only (constant) iterator pointing to first element\n-     *           equal to or greater than key, or end().\n-     *\n-     *  This function returns the first element of a subsequence of elements\n-     *  that matches the given key.  If unsuccessful the iterator will point\n-     *  to the next greatest element or, if no such greater element exists, to\n-     *  end().\n-    */\n-    const_iterator\n-    lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds the end of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return Iterator pointing to the first element\n-     *          greater than key, or end().\n-    */\n-    iterator\n-    upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds the end of a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pair to be located.\n-     *  @return  Read-only (constant) iterator pointing to first iterator\n-     *           greater than key, or end().\n-    */\n-    const_iterator\n-    upper_bound(const key_type& __x) const { return _M_t.upper_bound(__x); }\n-  \n-    /**\n-     *  @brief Finds a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pairs to be located.\n-     *  @return  Pair of iterators that possibly points to the subsequence\n-     *           matching given key.\n-     *\n-     *  This function is equivalent to\n-     *  @code\n-     *    std::make_pair(c.lower_bound(val),\n-     *                   c.upper_bound(val))\n-     *  @endcode\n-     *  (but is faster than making the calls separately).\n-    */\n-    pair<iterator,iterator>\n-    equal_range(const key_type& __x) { return _M_t.equal_range(__x); }\n-  \n-    /**\n-     *  @brief Finds a subsequence matching given key.\n-     *  @param  x  Key of (key, value) pairs to be located.\n-     *  @return  Pair of read-only (constant) iterators that possibly points to\n-     *           the subsequence matching given key.\n-     *\n-     *  This function is equivalent to\n-     *  @code\n-     *    std::make_pair(c.lower_bound(val),\n-     *                   c.upper_bound(val))\n-     *  @endcode\n-     *  (but is faster than making the calls separately).\n-    */\n-    pair<const_iterator,const_iterator>\n-    equal_range(const key_type& __x) const { return _M_t.equal_range(__x); }\n-  \n-    template <typename _K1, typename _T1, typename _C1, typename _A1>\n-    friend bool operator== (const multimap<_K1,_T1,_C1,_A1>&,\n-                            const multimap<_K1,_T1,_C1,_A1>&);\n-    template <typename _K1, typename _T1, typename _C1, typename _A1>\n-    friend bool operator< (const multimap<_K1,_T1,_C1,_A1>&,\n-                           const multimap<_K1,_T1,_C1,_A1>&);\n+      erase(iterator __position)\n+      { _M_t.erase(__position); }\n+      \n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  x  Key of element to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all elements located by the given key from a\n+       *  %multimap.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      size_type\n+      erase(const key_type& __x)\n+      { return _M_t.erase(__x); }\n+  \n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %multimap.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *\n+       *  This function erases a sequence of elements from a %multimap.\n+       *  Note that this function only erases the elements, and that if\n+       *  the elements themselves are pointers, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      void\n+      erase(iterator __first, iterator __last)\n+      { _M_t.erase(__first, __last); }\n+      \n+      /**\n+       *  @brief  Swaps data with another %multimap.\n+       *  @param  x  A %multimap of the same element and allocator types.\n+       *\n+       *  This exchanges the elements between two multimaps in constant time.\n+       *  (It is only swapping a pointer, an integer, and an instance of\n+       *  the @c Compare type (which itself is often stateless and empty), so it\n+       *  should be quite fast.)\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(m1,m2) will feed to this function.\n+       */\n+      void\n+      swap(multimap& __x)\n+      { _M_t.swap(__x._M_t); }\n+      \n+      /**\n+       *  Erases all elements in a %multimap.  Note that this function only\n+       *  erases the elements, and that if the elements themselves are pointers,\n+       *  the pointed-to memory is not touched in any way.  Managing the pointer\n+       *  is the user's responsibilty.\n+       */\n+      void\n+      clear()\n+      { _M_t.clear(); }\n+      \n+      // observers\n+      /**\n+       *  Returns the key comparison object out of which the %multimap\n+       *  was constructed.\n+       */\n+      key_compare\n+      key_comp() const\n+      { return _M_t.key_comp(); }\n+      \n+      /**\n+       *  Returns a value comparison object, built from the key comparison\n+       *  object out of which the %multimap was constructed.\n+       */\n+      value_compare\n+      value_comp() const\n+      { return value_compare(_M_t.key_comp()); }\n+      \n+      // multimap operations\n+      /**\n+       *  @brief Tries to locate an element in a %multimap.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Iterator pointing to sought-after element,\n+       *           or end() if not found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after %pair.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_t.find(__x); }\n+      \n+      /**\n+       *  @brief Tries to locate an element in a %multimap.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Read-only (constant) iterator pointing to sought-after\n+       *           element, or end() if not found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns a constant\n+       *  iterator pointing to the sought after %pair.  If unsuccessful it\n+       *  returns the past-the-end ( @c end() ) iterator.\n+       */\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_t.find(__x); }\n+      \n+      /**\n+       *  @brief Finds the number of elements with given key.\n+       *  @param  x  Key of (key, value) pairs to be located.\n+       *  @return Number of elements with specified key.\n+       */\n+      size_type\n+      count(const key_type& __x) const\n+      { return _M_t.count(__x); }\n+      \n+      /**\n+       *  @brief Finds the beginning of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Iterator pointing to first element equal to or greater\n+       *           than key, or end().\n+       *\n+       *  This function returns the first element of a subsequence of elements\n+       *  that matches the given key.  If unsuccessful it returns an iterator\n+       *  pointing to the first element that has a greater value than given key\n+       *  or end() if no such element exists.\n+       */\n+      iterator\n+      lower_bound(const key_type& __x)\n+      { return _M_t.lower_bound(__x); }\n+  \n+      /**\n+       *  @brief Finds the beginning of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Read-only (constant) iterator pointing to first element\n+       *           equal to or greater than key, or end().\n+       *\n+       *  This function returns the first element of a subsequence of elements\n+       *  that matches the given key.  If unsuccessful the iterator will point\n+       *  to the next greatest element or, if no such greater element exists, to\n+       *  end().\n+       */\n+      const_iterator\n+      lower_bound(const key_type& __x) const\n+      { return _M_t.lower_bound(__x); }\n+      \n+      /**\n+       *  @brief Finds the end of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return Iterator pointing to the first element\n+       *          greater than key, or end().\n+       */\n+      iterator\n+      upper_bound(const key_type& __x)\n+      { return _M_t.upper_bound(__x); }\n+      \n+      /**\n+       *  @brief Finds the end of a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pair to be located.\n+       *  @return  Read-only (constant) iterator pointing to first iterator\n+       *           greater than key, or end().\n+       */\n+      const_iterator\n+      upper_bound(const key_type& __x) const\n+      { return _M_t.upper_bound(__x); }\n+  \n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pairs to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       *\n+       *  This function is equivalent to\n+       *  @code\n+       *    std::make_pair(c.lower_bound(val),\n+       *                   c.upper_bound(val))\n+       *  @endcode\n+       *  (but is faster than making the calls separately).\n+       */\n+      pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      { return _M_t.equal_range(__x); }\n+  \n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  x  Key of (key, value) pairs to be located.\n+       *  @return  Pair of read-only (constant) iterators that possibly points\n+       *           to the subsequence matching given key.\n+       *\n+       *  This function is equivalent to\n+       *  @code\n+       *    std::make_pair(c.lower_bound(val),\n+       *                   c.upper_bound(val))\n+       *  @endcode\n+       *  (but is faster than making the calls separately).\n+       */\n+      pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      { return _M_t.equal_range(__x); }\n+  \n+      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+        friend bool\n+        operator== (const multimap<_K1,_T1,_C1,_A1>&,\n+\t\t    const multimap<_K1,_T1,_C1,_A1>&);\n+      \n+      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+        friend bool\n+        operator< (const multimap<_K1,_T1,_C1,_A1>&,\n+\t\t   const multimap<_K1,_T1,_C1,_A1>&);\n   };\n-  \n-  \n+    \n   /**\n    *  @brief  Multimap equality comparison.\n    *  @param  x  A %multimap.\n@@ -577,9 +618,7 @@ namespace __gnu_norm\n     inline bool\n     operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-    {\n-      return __x._M_t == __y._M_t;\n-    }\n+    { return __x._M_t == __y._M_t; }\n   \n   /**\n    *  @brief  Multimap ordering relation."}, {"sha": "c72d9938ddc0bfa45a6e6c8b4e4ecadd3fc58b18", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 419, "deletions": 371, "changes": 790, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -66,19 +66,18 @@\n namespace __gnu_norm\n {\n \n-// Forward declaration of operators < and ==, needed for friend declaration.\n+  // Forward declaration of operators < and ==, needed for friend declaration.\n+  template <class _Key, class _Compare = less<_Key>,\n+\t    class _Alloc = allocator<_Key> >\n+  class multiset;\n \n-template <class _Key, class _Compare = less<_Key>,\n-          class _Alloc = allocator<_Key> >\n-class multiset;\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n-                       const multiset<_Key,_Compare,_Alloc>& __y);\n+  template <class _Key, class _Compare, class _Alloc>\n+  inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t\t\t const multiset<_Key,_Compare,_Alloc>& __y);\n \n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n-                      const multiset<_Key,_Compare,_Alloc>& __y);\n+  template <class _Key, class _Compare, class _Alloc>\n+  inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t\t\tconst multiset<_Key,_Compare,_Alloc>& __y);\n \n   /**\n    *  @brief A standard container made up of elements, which can be retrieved\n@@ -101,379 +100,428 @@ inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n    *  @endif\n   */\n   template <class _Key, class _Compare, class _Alloc>\n-  class multiset\n-  {\n-    // concept requirements\n-    __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n-    __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n-\n-  public:\n-    \n-    // typedefs:\n-    \n-    typedef _Key     key_type;\n-    typedef _Key     value_type;\n-    typedef _Compare key_compare;\n-    typedef _Compare value_compare;\n-\n-  private:\n-    /// @if maint  This turns a red-black tree into a [multi]set.  @endif\n-    typedef _Rb_tree<key_type, value_type, \n-\t\t     _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n-    /// @if maint  The actual tree structure.  @endif\n-    _Rep_type _M_t;\n-\n-  public:\n-    typedef typename _Alloc::pointer pointer;\n-    typedef typename _Alloc::const_pointer const_pointer;\n-    typedef typename _Alloc::reference reference;\n-    typedef typename _Alloc::const_reference const_reference;\n-    typedef typename _Rep_type::const_iterator iterator;\n-    typedef typename _Rep_type::const_iterator const_iterator;\n-    typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n-    typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-    typedef typename _Rep_type::size_type size_type;\n-    typedef typename _Rep_type::difference_type difference_type;\n-    typedef typename _Rep_type::allocator_type allocator_type;\n+    class multiset\n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n+      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n+\t\t\t\t_BinaryFunctionConcept)\n+\t\n+    public:\n+      // typedefs:\n+      typedef _Key     key_type;\n+      typedef _Key     value_type;\n+      typedef _Compare key_compare;\n+      typedef _Compare value_compare;\n+      \n+    private:\n+      /// @if maint  This turns a red-black tree into a [multi]set.  @endif\n+      typedef _Rb_tree<key_type, value_type, \n+\t\t       _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n+      /// @if maint  The actual tree structure.  @endif\n+      _Rep_type _M_t;\n+\n+    public:\n+      typedef typename _Alloc::pointer pointer;\n+      typedef typename _Alloc::const_pointer const_pointer;\n+      typedef typename _Alloc::reference reference;\n+      typedef typename _Alloc::const_reference const_reference;\n+      typedef typename _Rep_type::const_iterator iterator;\n+      typedef typename _Rep_type::const_iterator const_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+      typedef typename _Rep_type::size_type size_type;\n+      typedef typename _Rep_type::difference_type difference_type;\n+      typedef typename _Rep_type::allocator_type allocator_type;\n \n     // allocation/deallocation\n-\n+      \n     /**\n      *  @brief  Default constructor creates no elements.\n-    */\n-    multiset() : _M_t(_Compare(), allocator_type()) {}\n-    explicit multiset(const _Compare& __comp,\n-\t\t      const allocator_type& __a = allocator_type())\n-      : _M_t(__comp, __a) {}\n-\n-    /**\n-     *  @brief  Builds a %multiset from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *\n-     *  Create a %multiset consisting of copies of the elements from\n-     *  [first,last).  This is linear in N if the range is already sorted,\n-     *  and NlogN otherwise (where N is distance(first,last)).\n-    */\n-    template <class _InputIterator>\n-    multiset(_InputIterator __first, _InputIterator __last)\n-      : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_equal(__first, __last); }\n-\n-    /**\n-     *  @brief  Builds a %multiset from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *  @param  comp  A comparison functor.\n-     *  @param  a  An allocator object.\n-     *\n-     *  Create a %multiset consisting of copies of the elements from\n-     *  [first,last).  This is linear in N if the range is already sorted,\n-     *  and NlogN otherwise (where N is distance(first,last)).\n-    */\n-    template <class _InputIterator>\n-    multiset(_InputIterator __first, _InputIterator __last,\n-\t     const _Compare& __comp,\n-\t     const allocator_type& __a = allocator_type())\n-      : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-\n-    /**\n-     *  @brief  %Multiset copy constructor.\n-     *  @param  x  A %multiset of identical element and allocator types.\n-     *\n-     *  The newly-created %multiset uses a copy of the allocation object used\n-     *  by @a x.\n-    */\n-    multiset(const multiset<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n-\n-    /**\n-     *  @brief  %Multiset assignment operator.\n-     *  @param  x  A %multiset of identical element and allocator types.\n-     *\n-     *  All the elements of @a x are copied, but unlike the copy constructor,\n-     *  the allocator object is not copied.\n-    */\n-    multiset<_Key,_Compare,_Alloc>&\n-    operator=(const multiset<_Key,_Compare,_Alloc>& __x) {\n-      _M_t = __x._M_t; \n-      return *this;\n-    }\n-\n-    // accessors:\n-\n-    ///  Returns the comparison object.\n-    key_compare key_comp() const { return _M_t.key_comp(); }\n-    ///  Returns the comparison object.\n-    value_compare value_comp() const { return _M_t.key_comp(); }\n-    ///  Returns the memory allocation object.\n-    allocator_type get_allocator() const { return _M_t.get_allocator(); }\n-\n-    /**\n-     *  Returns a read/write iterator that points to the first element in the\n-     *  %multiset.  Iteration is done in ascending order according to the\n-     *  keys.\n-     */\n-    iterator begin() const { return _M_t.begin(); }\n-\n-    /**\n-     *  Returns a read/write iterator that points one past the last element in\n-     *  the %multiset.  Iteration is done in ascending order according to the\n-     *  keys.\n-     */\n-    iterator end() const { return _M_t.end(); }\n-\n-    /**\n-     *  Returns a read/write reverse iterator that points to the last element\n-     *  in the %multiset.  Iteration is done in descending order according to\n-     *  the keys.\n-     */\n-    reverse_iterator rbegin() const { return _M_t.rbegin(); } \n-    \n-    /**\n-     *  Returns a read/write reverse iterator that points to the last element\n-     *  in the %multiset.  Iteration is done in descending order according to\n-     *  the keys.\n-     */\n-    reverse_iterator rend() const { return _M_t.rend(); }\n-\n-    ///  Returns true if the %set is empty.\n-    bool empty() const { return _M_t.empty(); }\n-\n-    ///  Returns the size of the %set.\n-    size_type size() const { return _M_t.size(); }\n-\n-    ///  Returns the maximum size of the %set.\n-    size_type max_size() const { return _M_t.max_size(); }\n-\n-    /**\n-     *  @brief  Swaps data with another %multiset.\n-     *  @param  x  A %multiset of the same element and allocator types.\n-     *\n-     *  This exchanges the elements between two multisets in constant time.\n-     *  (It is only swapping a pointer, an integer, and an instance of the @c\n-     *  Compare type (which itself is often stateless and empty), so it should\n-     *  be quite fast.)\n-     *  Note that the global std::swap() function is specialized such that\n-     *  std::swap(s1,s2) will feed to this function.\n      */\n-    void swap(multiset<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n-\n-    // insert/erase\n-    /**\n-     *  @brief Inserts an element into the %multiset.\n-     *  @param  x  Element to be inserted.\n-     *  @return An iterator that points to the inserted element.\n-     *\n-     *  This function inserts an element into the %multiset.  Contrary\n-     *  to a std::set the %multiset does not rely on unique keys and thus\n-     *  multiple copies of the same element can be inserted.\n-     *\n-     *  Insertion requires logarithmic time.\n-    */\n-    iterator insert(const value_type& __x) { \n-      return _M_t.insert_equal(__x);\n-    }\n-\n-    /**\n-     *  @brief Inserts an element into the %multiset.\n-     *  @param  position  An iterator that serves as a hint as to where the\n-     *                    element should be inserted.\n-     *  @param  x  Element to be inserted.\n-     *  @return An iterator that points to the inserted element.\n-     *\n-     *  This function inserts an element into the %multiset.  Contrary\n-     *  to a std::set the %multiset does not rely on unique keys and thus\n-     *  multiple copies of the same element can be inserted.\n-     *\n-     *  Note that the first parameter is only a hint and can potentially\n-     *  improve the performance of the insertion process.  A bad hint would\n-     *  cause no gains in efficiency.\n-     *\n-     *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n-     *  for more on \"hinting\".\n-     *\n-     *  Insertion requires logarithmic time (if the hint is not taken).\n-    */\n-    iterator insert(iterator __position, const value_type& __x) {\n-      typedef typename _Rep_type::iterator _Rep_iterator;\n-      return _M_t.insert_equal((_Rep_iterator&)__position, __x);\n-    }\n-\n-    /**\n-     *  @brief A template function that attemps to insert a range of elements.\n-     *  @param  first  Iterator pointing to the start of the range to be\n-     *                 inserted.\n-     *  @param  last  Iterator pointing to the end of the range.\n-     *\n-     *  Complexity similar to that of the range constructor.\n-    */\n-    template <class _InputIterator>\n-    void insert(_InputIterator __first, _InputIterator __last) {\n-      _M_t.insert_equal(__first, __last);\n-    }\n-\n-    /**\n-     *  @brief Erases an element from a %multiset.\n-     *  @param  position  An iterator pointing to the element to be erased.\n-     *\n-     *  This function erases an element, pointed to by the given iterator,\n-     *  from a %multiset.  Note that this function only erases the element,\n-     *  and that if the element is itself a pointer, the pointed-to memory is\n-     *  not touched in any way.  Managing the pointer is the user's\n-     *  responsibilty.\n-    */\n-    void erase(iterator __position) { \n-      typedef typename _Rep_type::iterator _Rep_iterator;\n-      _M_t.erase((_Rep_iterator&)__position); \n-    }\n-\n-    /**\n-     *  @brief Erases elements according to the provided key.\n-     *  @param  x  Key of element to be erased.\n-     *  @return  The number of elements erased.\n-     *\n-     *  This function erases all elements located by the given key from a\n-     *  %multiset.\n-     *  Note that this function only erases the element, and that if\n-     *  the element is itself a pointer, the pointed-to memory is not touched\n-     *  in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    size_type erase(const key_type& __x) { \n-      return _M_t.erase(__x); \n-    }\n-\n-    /**\n-     *  @brief Erases a [first,last) range of elements from a %multiset.\n-     *  @param  first  Iterator pointing to the start of the range to be erased.\n-     *  @param  last  Iterator pointing to the end of the range to be erased.\n-     *\n-     *  This function erases a sequence of elements from a %multiset.\n-     *  Note that this function only erases the elements, and that if\n-     *  the elements themselves are pointers, the pointed-to memory is not\n-     *  touched in any way.  Managing the pointer is the user's responsibilty.\n-    */\n-    void erase(iterator __first, iterator __last) { \n-      typedef typename _Rep_type::iterator _Rep_iterator;\n-      _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n-    }\n-\n-    /**\n-     *  Erases all elements in a %multiset.  Note that this function only\n-     *  erases the elements, and that if the elements themselves are pointers,\n-     *  the pointed-to memory is not touched in any way.  Managing the pointer\n-     *  is the user's responsibilty.\n-    */\n-    void clear() { _M_t.clear(); }\n-\n-    // multiset operations:\n-\n-    /**\n-     *  @brief Finds the number of elements with given key.\n-     *  @param  x  Key of elements to be located.\n-     *  @return Number of elements with specified key.\n-    */\n-    size_type count(const key_type& __x) const { return _M_t.count(__x); }\n-\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 214.  set::find() missing const overload\n-    //@{\n-    /**\n-     *  @brief Tries to locate an element in a %set.\n-     *  @param  x  Element to be located.\n-     *  @return  Iterator pointing to sought-after element, or end() if not\n-     *           found.\n-     *\n-     *  This function takes a key and tries to locate the element with which\n-     *  the key matches.  If successful the function returns an iterator\n-     *  pointing to the sought after element.  If unsuccessful it returns the\n-     *  past-the-end ( @c end() ) iterator.\n-     */\n-    iterator find(const key_type& __x) { return _M_t.find(__x); }\n-    const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n-    //@}\n-\n-    //@{\n-    /**\n-     *  @brief Finds the beginning of a subsequence matching given key.\n-     *  @param  x  Key to be located.\n-     *  @return  Iterator pointing to first element equal to or greater\n-     *           than key, or end().\n-     *\n-     *  This function returns the first element of a subsequence of elements\n-     *  that matches the given key.  If unsuccessful it returns an iterator\n-     *  pointing to the first element that has a greater value than given key\n-     *  or end() if no such element exists.\n-     */\n-    iterator lower_bound(const key_type& __x) {\n-      return _M_t.lower_bound(__x);\n-    }\n-    const_iterator lower_bound(const key_type& __x) const {\n-      return _M_t.lower_bound(__x);\n-    }\n-    //@}\n-\n-    //@{\n-    /**\n-     *  @brief Finds the end of a subsequence matching given key.\n-     *  @param  x  Key to be located.\n-     *  @return Iterator pointing to the first element\n-     *          greater than key, or end().\n-     */\n-    iterator upper_bound(const key_type& __x) {\n-      return _M_t.upper_bound(__x);\n-    }\n-    const_iterator upper_bound(const key_type& __x) const {\n-      return _M_t.upper_bound(__x);\n-    }\n-    //@}\n-\n-    //@{\n-    /**\n-     *  @brief Finds a subsequence matching given key.\n-     *  @param  x  Key to be located.\n-     *  @return  Pair of iterators that possibly points to the subsequence\n-     *           matching given key.\n-     *\n-     *  This function is equivalent to\n-     *  @code\n-     *    std::make_pair(c.lower_bound(val),\n-     *                   c.upper_bound(val))\n-     *  @endcode\n-     *  (but is faster than making the calls separately).\n-     *\n-     *  This function probably only makes sense for multisets.\n-     */\n-    pair<iterator,iterator> equal_range(const key_type& __x) {\n-      return _M_t.equal_range(__x);\n-    }\n-    pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n-      return _M_t.equal_range(__x);\n-    }\n-\n-    template <class _K1, class _C1, class _A1>\n-    friend bool operator== (const multiset<_K1,_C1,_A1>&,\n-\t\t\t    const multiset<_K1,_C1,_A1>&);\n-    template <class _K1, class _C1, class _A1>\n-    friend bool operator< (const multiset<_K1,_C1,_A1>&,\n-\t\t\t   const multiset<_K1,_C1,_A1>&);\n-  };\n+      multiset()\n+      : _M_t(_Compare(), allocator_type()) { }\n+\n+      explicit multiset(const _Compare& __comp,\n+\t\t\tconst allocator_type& __a = allocator_type())\n+      : _M_t(__comp, __a) { }\n+\n+      /**\n+       *  @brief  Builds a %multiset from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *\n+       *  Create a %multiset consisting of copies of the elements from\n+       *  [first,last).  This is linear in N if the range is already sorted,\n+       *  and NlogN otherwise (where N is distance(first,last)).\n+       */\n+      template <class _InputIterator>\n+        multiset(_InputIterator __first, _InputIterator __last)\n+\t: _M_t(_Compare(), allocator_type())\n+        { _M_t.insert_equal(__first, __last); }\n+\n+      /**\n+       *  @brief  Builds a %multiset from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *  @param  comp  A comparison functor.\n+       *  @param  a  An allocator object.\n+       *\n+       *  Create a %multiset consisting of copies of the elements from\n+       *  [first,last).  This is linear in N if the range is already sorted,\n+       *  and NlogN otherwise (where N is distance(first,last)).\n+       */\n+      template <class _InputIterator>\n+        multiset(_InputIterator __first, _InputIterator __last,\n+\t\t const _Compare& __comp,\n+\t\t const allocator_type& __a = allocator_type())\n+\t: _M_t(__comp, __a)\n+        { _M_t.insert_equal(__first, __last); }\n+\n+      /**\n+       *  @brief  %Multiset copy constructor.\n+       *  @param  x  A %multiset of identical element and allocator types.\n+       *\n+       *  The newly-created %multiset uses a copy of the allocation object used\n+       *  by @a x.\n+       */\n+      multiset(const multiset<_Key,_Compare,_Alloc>& __x)\n+      : _M_t(__x._M_t) { }\n+\n+      /**\n+       *  @brief  %Multiset assignment operator.\n+       *  @param  x  A %multiset of identical element and allocator types.\n+       *\n+       *  All the elements of @a x are copied, but unlike the copy constructor,\n+       *  the allocator object is not copied.\n+       */\n+      multiset<_Key,_Compare,_Alloc>&\n+      operator=(const multiset<_Key,_Compare,_Alloc>& __x)\n+      {\n+\t_M_t = __x._M_t; \n+\treturn *this;\n+      }\n+      \n+      // accessors:\n+      \n+      ///  Returns the comparison object.\n+      key_compare\n+      key_comp() const\n+      { return _M_t.key_comp(); }\n+      ///  Returns the comparison object.\n+      value_compare\n+      value_comp() const\n+      { return _M_t.key_comp(); }\n+      ///  Returns the memory allocation object.\n+      allocator_type\n+      get_allocator() const\n+      { return _M_t.get_allocator(); }\n+      \n+      /**\n+       *  Returns a read/write iterator that points to the first element in the\n+       *  %multiset.  Iteration is done in ascending order according to the\n+       *  keys.\n+       */\n+      iterator\n+      begin() const\n+      { return _M_t.begin(); }\n+\n+      /**\n+       *  Returns a read/write iterator that points one past the last element in\n+       *  the %multiset.  Iteration is done in ascending order according to the\n+       *  keys.\n+       */\n+      iterator\n+      end() const\n+      { return _M_t.end(); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to the last element\n+       *  in the %multiset.  Iteration is done in descending order according to\n+       *  the keys.\n+       */\n+      reverse_iterator\n+      rbegin() const\n+      { return _M_t.rbegin(); } \n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to the last element\n+       *  in the %multiset.  Iteration is done in descending order according to\n+       *  the keys.\n+       */\n+      reverse_iterator\n+      rend() const\n+      { return _M_t.rend(); }\n+      \n+      ///  Returns true if the %set is empty.\n+      bool\n+      empty() const\n+      { return _M_t.empty(); }\n+      \n+      ///  Returns the size of the %set.\n+      size_type\n+      size() const\n+      { return _M_t.size(); }\n+      \n+      ///  Returns the maximum size of the %set.\n+      size_type\n+      max_size() const\n+      { return _M_t.max_size(); }\n+      \n+      /**\n+       *  @brief  Swaps data with another %multiset.\n+       *  @param  x  A %multiset of the same element and allocator types.\n+       *\n+       *  This exchanges the elements between two multisets in constant time.\n+       *  (It is only swapping a pointer, an integer, and an instance of the @c\n+       *  Compare type (which itself is often stateless and empty), so it should\n+       *  be quite fast.)\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(s1,s2) will feed to this function.\n+       */\n+      void\n+      swap(multiset<_Key,_Compare,_Alloc>& __x)\n+      { _M_t.swap(__x._M_t); }\n+      \n+      // insert/erase\n+      /**\n+       *  @brief Inserts an element into the %multiset.\n+       *  @param  x  Element to be inserted.\n+       *  @return An iterator that points to the inserted element.\n+       *\n+       *  This function inserts an element into the %multiset.  Contrary\n+       *  to a std::set the %multiset does not rely on unique keys and thus\n+       *  multiple copies of the same element can be inserted.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      iterator\n+      insert(const value_type& __x)\n+      { return _M_t.insert_equal(__x); }\n+      \n+      /**\n+       *  @brief Inserts an element into the %multiset.\n+       *  @param  position  An iterator that serves as a hint as to where the\n+       *                    element should be inserted.\n+       *  @param  x  Element to be inserted.\n+       *  @return An iterator that points to the inserted element.\n+       *\n+       *  This function inserts an element into the %multiset.  Contrary\n+       *  to a std::set the %multiset does not rely on unique keys and thus\n+       *  multiple copies of the same element can be inserted.\n+       *\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process.  A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+       *  for more on \"hinting\".\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      iterator\n+      insert(iterator __position, const value_type& __x)\n+      {\n+\ttypedef typename _Rep_type::iterator _Rep_iterator;\n+\treturn _M_t.insert_equal((_Rep_iterator&)__position, __x);\n+      }\n+\n+      /**\n+       *  @brief A template function that attemps to insert a range of elements.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 inserted.\n+       *  @param  last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template <class _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        { _M_t.insert_equal(__first, __last); }\n+\n+      /**\n+       *  @brief Erases an element from a %multiset.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from a %multiset.  Note that this function only erases the element,\n+       *  and that if the element is itself a pointer, the pointed-to memory is\n+       *  not touched in any way.  Managing the pointer is the user's\n+       *  responsibilty.\n+       */\n+      void\n+      erase(iterator __position)\n+      { \n+\ttypedef typename _Rep_type::iterator _Rep_iterator;\n+\t_M_t.erase((_Rep_iterator&)__position); \n+      }\n+      \n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  x  Key of element to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all elements located by the given key from a\n+       *  %multiset.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      size_type\n+      erase(const key_type& __x)\n+      { return _M_t.erase(__x); }\n+      \n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %multiset.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *\n+       *  This function erases a sequence of elements from a %multiset.\n+       *  Note that this function only erases the elements, and that if\n+       *  the elements themselves are pointers, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      void\n+      erase(iterator __first, iterator __last)\n+      { \n+\ttypedef typename _Rep_type::iterator _Rep_iterator;\n+\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n+      }\n+      \n+      /**\n+       *  Erases all elements in a %multiset.  Note that this function only\n+       *  erases the elements, and that if the elements themselves are pointers,\n+       *  the pointed-to memory is not touched in any way.  Managing the pointer\n+       *  is the user's responsibilty.\n+       */\n+      void\n+      clear()\n+      { _M_t.clear(); }\n+      \n+      // multiset operations:\n+      \n+      /**\n+       *  @brief Finds the number of elements with given key.\n+       *  @param  x  Key of elements to be located.\n+       *  @return Number of elements with specified key.\n+       */\n+      size_type\n+      count(const key_type& __x) const\n+      { return _M_t.count(__x); }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214.  set::find() missing const overload\n+      //@{\n+      /**\n+       *  @brief Tries to locate an element in a %set.\n+       *  @param  x  Element to be located.\n+       *  @return  Iterator pointing to sought-after element, or end() if not\n+       *           found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after element.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_t.find(__x); }\n+      \n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_t.find(__x); }\n+      //@}\n+      \n+      //@{\n+      /**\n+       *  @brief Finds the beginning of a subsequence matching given key.\n+       *  @param  x  Key to be located.\n+       *  @return  Iterator pointing to first element equal to or greater\n+       *           than key, or end().\n+       *\n+       *  This function returns the first element of a subsequence of elements\n+       *  that matches the given key.  If unsuccessful it returns an iterator\n+       *  pointing to the first element that has a greater value than given key\n+       *  or end() if no such element exists.\n+       */\n+      iterator\n+      lower_bound(const key_type& __x)\n+      { return _M_t.lower_bound(__x); }\n+      \n+      const_iterator\n+      lower_bound(const key_type& __x) const\n+      { return _M_t.lower_bound(__x); }\n+      //@}\n+      \n+      //@{\n+      /**\n+       *  @brief Finds the end of a subsequence matching given key.\n+       *  @param  x  Key to be located.\n+       *  @return Iterator pointing to the first element\n+       *          greater than key, or end().\n+       */\n+      iterator\n+      upper_bound(const key_type& __x)\n+      { return _M_t.upper_bound(__x); }\n+      \n+      const_iterator\n+      upper_bound(const key_type& __x) const\n+      { return _M_t.upper_bound(__x); }\n+      //@}\n+      \n+      //@{\n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  x  Key to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       *\n+       *  This function is equivalent to\n+       *  @code\n+       *    std::make_pair(c.lower_bound(val),\n+       *                   c.upper_bound(val))\n+       *  @endcode\n+       *  (but is faster than making the calls separately).\n+       *\n+       *  This function probably only makes sense for multisets.\n+       */\n+      pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      { return _M_t.equal_range(__x); }\n+      \n+      pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      { return _M_t.equal_range(__x); }\n+      \n+      template <class _K1, class _C1, class _A1>\n+        friend bool\n+        operator== (const multiset<_K1,_C1,_A1>&,\n+\t\t    const multiset<_K1,_C1,_A1>&);\n+\n+      template <class _K1, class _C1, class _A1>\n+        friend bool\n+        operator< (const multiset<_K1,_C1,_A1>&,\n+\t\t   const multiset<_K1,_C1,_A1>&);\n+    };\n \n   /**\n    *  @brief  Multiset equality comparison.\n    *  @param  x  A %multiset.\n    *  @param  y  A %multiset of the same type as @a x.\n    *  @return  True iff the size and elements of the multisets are equal.\n    *\n-   *  This is an equivalence relation.  It is linear in the size of the multisets.\n+   *  This is an equivalence relation.  It is linear in the size of the\n+   *  multisets.\n    *  Multisets are considered equivalent if their sizes are equal, and if\n    *  corresponding elements compare equal.\n   */\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n     operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n-  { return __x._M_t == __y._M_t; }\n-\n+    { return __x._M_t == __y._M_t; }\n+  \n   /**\n    *  @brief  Multiset ordering relation.\n    *  @param  x  A %multiset.\n@@ -489,42 +537,42 @@ inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n     inline bool\n     operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n \t      const multiset<_Key,_Compare,_Alloc>& __y)\n-  { return __x._M_t < __y._M_t; }\n+    { return __x._M_t < __y._M_t; }\n \n   ///  Returns !(x == y).\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n     operator!=(const multiset<_Key,_Compare,_Alloc>& __x, \n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n-  { return !(__x == __y); }\n+    { return !(__x == __y); }\n \n   ///  Returns y < x.\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n     operator>(const multiset<_Key,_Compare,_Alloc>& __x, \n \t      const multiset<_Key,_Compare,_Alloc>& __y)\n-  { return __y < __x; }\n+    { return __y < __x; }\n \n   ///  Returns !(y < x)\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n     operator<=(const multiset<_Key,_Compare,_Alloc>& __x, \n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n-  { return !(__y < __x); }\n+    { return !(__y < __x); }\n \n   ///  Returns !(x < y)\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n     operator>=(const multiset<_Key,_Compare,_Alloc>& __x, \n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n-  { return !(__x < __y); }\n+    { return !(__x < __y); }\n \n   /// See std::multiset::swap().\n   template <class _Key, class _Compare, class _Alloc>\n     inline void\n     swap(multiset<_Key,_Compare,_Alloc>& __x, \n \t multiset<_Key,_Compare,_Alloc>& __y)\n-  { __x.swap(__y); }\n+    { __x.swap(__y); }\n \n } // namespace __gnu_norm\n "}, {"sha": "812679ccd6e1652004b18a94820b15d9e44666d8", "filename": "libstdc++-v3/include/bits/stl_relops.h", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -1,6 +1,6 @@\n // std::rel_ops implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -75,61 +75,61 @@ namespace std\n {\n   namespace rel_ops\n   {\n-      /** @namespace std::rel_ops\n-       *  @brief  The generated relational operators are sequestered here.\n-       */\n+    /** @namespace std::rel_ops\n+     *  @brief  The generated relational operators are sequestered here.\n+     */\n+    \n+    /**\n+     *  @brief Defines @c != for arbitrary types, in terms of @c ==.\n+     *  @param  x  A thing.\n+     *  @param  y  Another thing.\n+     *  @return   x != y\n+     *\n+     *  This function uses @c == to determine its result.\n+     */\n+    template <class _Tp>\n+      inline bool\n+      operator!=(const _Tp& __x, const _Tp& __y)\n+      { return !(__x == __y); }\n \n-/**\n- *  @brief Defines @c != for arbitrary types, in terms of @c ==.\n- *  @param  x  A thing.\n- *  @param  y  Another thing.\n- *  @return   x != y\n- *\n- *  This function uses @c == to determine its result.\n-*/\n-template <class _Tp>\n-inline bool operator!=(const _Tp& __x, const _Tp& __y) {\n-  return !(__x == __y);\n-}\n+    /**\n+     *  @brief Defines @c > for arbitrary types, in terms of @c <.\n+     *  @param  x  A thing.\n+     *  @param  y  Another thing.\n+     *  @return   x > y\n+     *\n+     *  This function uses @c < to determine its result.\n+     */\n+    template <class _Tp>\n+      inline bool\n+      operator>(const _Tp& __x, const _Tp& __y)\n+      { return __y < __x; }\n \n-/**\n- *  @brief Defines @c > for arbitrary types, in terms of @c <.\n- *  @param  x  A thing.\n- *  @param  y  Another thing.\n- *  @return   x > y\n- *\n- *  This function uses @c < to determine its result.\n-*/\n-template <class _Tp>\n-inline bool operator>(const _Tp& __x, const _Tp& __y) {\n-  return __y < __x;\n-}\n+    /**\n+     *  @brief Defines @c <= for arbitrary types, in terms of @c <.\n+     *  @param  x  A thing.\n+     *  @param  y  Another thing.\n+     *  @return   x <= y\n+     *\n+     *  This function uses @c < to determine its result.\n+     */\n+    template <class _Tp>\n+      inline bool\n+      operator<=(const _Tp& __x, const _Tp& __y)\n+      { return !(__y < __x); }\n \n-/**\n- *  @brief Defines @c <= for arbitrary types, in terms of @c <.\n- *  @param  x  A thing.\n- *  @param  y  Another thing.\n- *  @return   x <= y\n- *\n- *  This function uses @c < to determine its result.\n-*/\n-template <class _Tp>\n-inline bool operator<=(const _Tp& __x, const _Tp& __y) {\n-  return !(__y < __x);\n-}\n-\n-/**\n- *  @brief Defines @c >= for arbitrary types, in terms of @c <.\n- *  @param  x  A thing.\n- *  @param  y  Another thing.\n- *  @return   x >= y\n- *\n- *  This function uses @c < to determine its result.\n-*/\n-template <class _Tp>\n-inline bool operator>=(const _Tp& __x, const _Tp& __y) {\n-  return !(__x < __y);\n-}\n+    /**\n+     *  @brief Defines @c >= for arbitrary types, in terms of @c <.\n+     *  @param  x  A thing.\n+     *  @param  y  Another thing.\n+     *  @return   x >= y\n+     *\n+     *  This function uses @c < to determine its result.\n+     */\n+    template <class _Tp>\n+      inline bool\n+      operator>=(const _Tp& __x, const _Tp& __y)\n+      { return !(__x < __y); }\n \n   } // namespace rel_ops\n } // namespace std"}, {"sha": "1e45f99df67967ea71d12ee619aaf45f64a8fe62", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 105, "deletions": 51, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6592a9e2cdd63133763f8b9171e2b6051db2393/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=f6592a9e2cdd63133763f8b9171e2b6051db2393", "patch": "@@ -108,7 +108,8 @@ namespace __gnu_norm\n     {\n       // concept requirements\n       __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n-      __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n+      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n+\t\t\t\t_BinaryFunctionConcept)\n \t\n \tpublic:\n       // typedefs:\n@@ -142,7 +143,8 @@ namespace __gnu_norm\n \n       // allocation/deallocation\n       ///  Default constructor creates no elements.\n-      set() : _M_t(_Compare(), allocator_type()) {}\n+      set()\n+      : _M_t(_Compare(), allocator_type()) {}\n \n       /**\n        *  @brief  Default constructor creates no elements.\n@@ -152,7 +154,7 @@ namespace __gnu_norm\n        */\n       explicit set(const _Compare& __comp,\n \t\t   const allocator_type& __a = allocator_type())\n-\t: _M_t(__comp, __a) {}\n+      : _M_t(__comp, __a) {}\n \n       /**\n        *  @brief  Builds a %set from a range.\n@@ -164,9 +166,9 @@ namespace __gnu_norm\n        *  otherwise (where N is distance(first,last)).\n        */\n       template<class _InputIterator>\n-      set(_InputIterator __first, _InputIterator __last)\n-\t: _M_t(_Compare(), allocator_type())\n-      { _M_t.insert_unique(__first, __last); }\n+        set(_InputIterator __first, _InputIterator __last)\n+        : _M_t(_Compare(), allocator_type())\n+        { _M_t.insert_unique(__first, __last); }\n \n       /**\n        *  @brief  Builds a %set from a range.\n@@ -180,10 +182,11 @@ namespace __gnu_norm\n        *  otherwise (where N is distance(first,last)).\n        */\n       template<class _InputIterator>\n-      set(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n-\t  const allocator_type& __a = allocator_type())\n+        set(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp,\n+\t    const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, __a)\n-      { _M_t.insert_unique(__first, __last); }\n+        { _M_t.insert_unique(__first, __last); }\n \n       /**\n        *  @brief  Set copy constructor.\n@@ -192,7 +195,8 @@ namespace __gnu_norm\n        *  The newly-created %set uses a copy of the allocation object used\n        *  by @a x.\n        */\n-      set(const set<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+      set(const set<_Key,_Compare,_Alloc>& __x)\n+      : _M_t(__x._M_t) { }\n       \n       /**\n        *  @brief  Set assignment operator.\n@@ -201,7 +205,8 @@ namespace __gnu_norm\n        *  All the elements of @a x are copied, but unlike the copy constructor,\n        *  the allocator object is not copied.\n        */\n-      set<_Key,_Compare,_Alloc>& operator=(const set<_Key, _Compare, _Alloc>& __x)\n+      set<_Key,_Compare,_Alloc>&\n+      operator=(const set<_Key, _Compare, _Alloc>& __x)\n       { \n \t_M_t = __x._M_t; \n \treturn *this;\n@@ -210,45 +215,66 @@ namespace __gnu_norm\n       // accessors:\n \n       ///  Returns the comparison object with which the %set was constructed.\n-      key_compare key_comp() const { return _M_t.key_comp(); }\n+      key_compare\n+      key_comp() const\n+      { return _M_t.key_comp(); }\n       ///  Returns the comparison object with which the %set was constructed.\n-      value_compare value_comp() const { return _M_t.key_comp(); }\n+      value_compare\n+      value_comp() const\n+      { return _M_t.key_comp(); }\n       ///  Returns the allocator object with which the %set was constructed.\n-      allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+      allocator_type\n+      get_allocator() const\n+      { return _M_t.get_allocator(); }\n \n       /**\n        *  Returns a read/write iterator that points to the first element in the\n        *  %set.  Iteration is done in ascending order according to the keys.\n        */\n-      iterator begin() const { return _M_t.begin(); }\n+      iterator\n+      begin() const\n+      { return _M_t.begin(); }\n \n       /**\n        *  Returns a read/write iterator that points one past the last element in\n        *  the %set.  Iteration is done in ascending order according to the keys.\n        */\n-      iterator end() const { return _M_t.end(); }\n+      iterator\n+      end() const\n+      { return _M_t.end(); }\n \n       /**\n-       *  Returns a read/write reverse iterator that points to the last element in\n-       *  the %set.  Iteration is done in descending order according to the keys.\n+       *  Returns a read/write reverse iterator that points to the last element\n+       *  in the %set.  Iteration is done in descending order according to the\n+       *  keys.\n        */\n-      reverse_iterator rbegin() const { return _M_t.rbegin(); } \n+      reverse_iterator\n+      rbegin() const\n+      { return _M_t.rbegin(); } \n \n       /**\n-       *  Returns a read-only (constant) reverse iterator that points to the last\n-       *  pair in the %map.  Iteration is done in descending order according to\n-       *  the keys.\n+       *  Returns a read-only (constant) reverse iterator that points to the\n+       *  last pair in the %map.  Iteration is done in descending order\n+       *  according to the keys.\n        */\n-      reverse_iterator rend() const { return _M_t.rend(); }\n+      reverse_iterator\n+      rend() const\n+      { return _M_t.rend(); }\n \n       ///  Returns true if the %set is empty.\n-      bool empty() const { return _M_t.empty(); }\n+      bool\n+      empty() const\n+      { return _M_t.empty(); }\n \n       ///  Returns the size of the %set.\n-      size_type size() const { return _M_t.size(); }\n+      size_type\n+      size() const\n+      { return _M_t.size(); }\n \n       ///  Returns the maximum size of the %set.\n-      size_type max_size() const { return _M_t.max_size(); }\n+      size_type\n+      max_size() const\n+      { return _M_t.max_size(); }\n \n       /**\n        *  @brief  Swaps data with another %set.\n@@ -261,25 +287,28 @@ namespace __gnu_norm\n        *  Note that the global std::swap() function is specialized such that\n        *  std::swap(s1,s2) will feed to this function.\n        */\n-      void swap(set<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n+      void\n+      swap(set<_Key,_Compare,_Alloc>& __x)\n+      { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n       /**\n        *  @brief Attempts to insert an element into the %set.\n        *  @param  x  Element to be inserted.\n        *  @return  A pair, of which the first element is an iterator that points\n-       *           to the possibly inserted element, and the second is a bool that\n-       *           is true if the element was actually inserted.\n+       *           to the possibly inserted element, and the second is a bool\n+       *           that is true if the element was actually inserted.\n        *\n        *  This function attempts to insert an element into the %set.  A %set\n        *  relies on unique keys and thus an element is only inserted if it is\n        *  not already present in the %set.\n        *\n        *  Insertion requires logarithmic time.\n        */\n-      pair<iterator,bool> insert(const value_type& __x)\n+      pair<iterator,bool>\n+      insert(const value_type& __x)\n       { \n-\tpair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x); \n+\tpair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x);\n \treturn pair<iterator, bool>(__p.first, __p.second);\n       }\n \n@@ -302,7 +331,8 @@ namespace __gnu_norm\n        *\n        *  Insertion requires logarithmic time (if the hint is not taken).\n        */\n-      iterator insert(iterator __position, const value_type& __x)\n+      iterator\n+      insert(iterator __position, const value_type& __x)\n       {\n \ttypedef typename _Rep_type::iterator _Rep_iterator;\n \treturn _M_t.insert_unique((_Rep_iterator&)__position, __x);\n@@ -317,7 +347,8 @@ namespace __gnu_norm\n        *  Complexity similar to that of the range constructor.\n        */\n       template<class _InputIterator>\n-      void insert(_InputIterator __first, _InputIterator __last)\n+      void\n+      insert(_InputIterator __first, _InputIterator __last)\n       { _M_t.insert_unique(__first, __last); }\n       \n       /**\n@@ -329,7 +360,8 @@ namespace __gnu_norm\n        *  that if the element is itself a pointer, the pointed-to memory is not\n        *  touched in any way.  Managing the pointer is the user's responsibilty.\n        */\n-      void erase(iterator __position)\n+      void\n+      erase(iterator __position)\n       { \n \ttypedef typename _Rep_type::iterator _Rep_iterator;\n \t_M_t.erase((_Rep_iterator&)__position); \n@@ -346,19 +378,22 @@ namespace __gnu_norm\n        *  the element is itself a pointer, the pointed-to memory is not touched\n        *  in any way.  Managing the pointer is the user's responsibilty.\n        */\n-      size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+      size_type\n+      erase(const key_type& __x) { return _M_t.erase(__x); }\n \n       /**\n        *  @brief Erases a [first,last) range of elements from a %set.\n-       *  @param  first  Iterator pointing to the start of the range to be erased.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n        *  @param  last  Iterator pointing to the end of the range to be erased.\n        *\n        *  This function erases a sequence of elements from a %set.\n        *  Note that this function only erases the element, and that if\n        *  the element is itself a pointer, the pointed-to memory is not touched\n        *  in any way.  Managing the pointer is the user's responsibilty.\n        */\n-      void erase(iterator __first, iterator __last)\n+      void\n+      erase(iterator __first, iterator __last)\n       {\n \ttypedef typename _Rep_type::iterator _Rep_iterator;\n \t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n@@ -370,7 +405,9 @@ namespace __gnu_norm\n        *  pointed-to memory is not touched in any way.  Managing the pointer is\n        *  the user's responsibilty.\n        */\n-      void clear() { _M_t.clear(); }\n+      void\n+      clear()\n+      { _M_t.clear(); }\n \n       // set operations:\n \n@@ -382,7 +419,8 @@ namespace __gnu_norm\n        *  This function only makes sense for multisets; for set the result will\n        *  either be 0 (not present) or 1 (present).\n        */\n-      size_type count(const key_type& __x) const\n+      size_type\n+      count(const key_type& __x) const\n       { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -399,8 +437,13 @@ namespace __gnu_norm\n        *  pointing to the sought after element.  If unsuccessful it returns the\n        *  past-the-end ( @c end() ) iterator.\n        */\n-      iterator find(const key_type& __x) { return _M_t.find(__x); }\n-      const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_t.find(__x); }\n+\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_t.find(__x); }\n       //@}\n \n       //@{\n@@ -415,9 +458,12 @@ namespace __gnu_norm\n        *  pointing to the first element that has a greater value than given key\n        *  or end() if no such element exists.\n        */\n-      iterator lower_bound(const key_type& __x)\n+      iterator\n+      lower_bound(const key_type& __x)\n       { return _M_t.lower_bound(__x); }\n-      const_iterator lower_bound(const key_type& __x) const\n+      \n+      const_iterator\n+      lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n       //@}\n \n@@ -428,9 +474,12 @@ namespace __gnu_norm\n        *  @return Iterator pointing to the first element\n        *          greater than key, or end().\n        */\n-      iterator upper_bound(const key_type& __x)\n+      iterator\n+      upper_bound(const key_type& __x)\n       { return _M_t.upper_bound(__x); }\n-      const_iterator upper_bound(const key_type& __x) const\n+\n+      const_iterator\n+      upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n       //@}\n \n@@ -450,16 +499,22 @@ namespace __gnu_norm\n        *\n        *  This function probably only makes sense for multisets.\n        */\n-      pair<iterator,iterator> equal_range(const key_type& __x)\n+      pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n-      pair<const_iterator,const_iterator> equal_range(const key_type& __x) const\n+      \n+      pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n       //@}\n \n       template<class _K1, class _C1, class _A1>\n-      friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n+        friend bool\n+        operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n+      \n       template<class _K1, class _C1, class _A1>\n-      friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n+        friend bool\n+        operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n     };\n \n \n@@ -508,8 +563,7 @@ namespace __gnu_norm\n     inline bool\n     operator>(const set<_Key,_Compare,_Alloc>& __x, \n \t      const set<_Key,_Compare,_Alloc>& __y)\n-  { return __y < __x; }\n-\n+    { return __y < __x; }\n \n   ///  Returns !(y < x)\n   template<class _Key, class _Compare, class _Alloc>"}]}