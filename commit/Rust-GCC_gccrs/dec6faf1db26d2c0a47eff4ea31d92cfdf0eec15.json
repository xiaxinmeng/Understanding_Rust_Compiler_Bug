{"sha": "dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVjNmZhZjFkYjI2ZDJjMGE0N2VmZjRlYTMxZDkyY2ZkZjBlZWMxNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-15T14:33:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-15T14:33:46Z"}, "message": "[multiple changes]\n\n2011-12-15  Vincent Pucci  <pucci@adacore.com>\n\n\t* aspects.adb, aspects.ads Aspect_Dimension and\n\tAspect_Dimension_System added\n\t* exp_ch6.adb (Expand_Call): Expand_Put_Call_With_Dimension_String\n\tcase added\n\t* gcc-interface/Make-lang.in: s-llflex, sem_dim added.\n\t* impunit.adb :s-diflio and s-diinio defined as GNAT Defined\n\tAdditions to System.\n\t* Makefile.rtl: s-diflio, s-diinio and s-llflex added\n\t* par-prag.adb, sem_prag.adb: Pragma_Dimension removed\n\t* rtsfind.ads: Expon_LLF added\n\t* sem_aggr.adb (Resolve_Aggregate): handles aggregate for\n\tAspect_Dimension case\n\t* sem_attr.adb (Resolve_Attribute): analyze dimension for\n\tattribute\n\t* sem_ch10.adb (Analyze_With_Clause): Avoid the warning messages\n\tdue to the use of a GNAT library for Dimension packages\n\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n\tAspect_Dimension and Aspect_Dimension_System cases added\n\t(Check_Aspect_At_Freeze_Point): Aspect_Dimension and\n\tAspect_Dimension_System cases added\n\t* sem_ch2.adb (Analyze_Identifier): analyze dimension for\n\tidentifier\n\t* sem_ch3.adb (Analyze_Component_Declaration): analyze dimension\n\tfor component declaration (Analyze_Object_Declaration): analyze\n\tdimension for object declaration (Analyze_Subtype_Declaration):\n\tanalyze dimension for subtype declaration\n\t* sem_ch4.adb (Operator_Check): checks exponent is a rational\n\tfor dimensioned operand for a N_Op_Expon\n\t* sem_ch5.adb (Analyze_Assignment): analyze dimension for\n\tassignment (Analyze_Statements): removal of dimensions in all\n\tstatements\n\t* sem_ch6.adb (Analyze_Return_Statement): analyze dimension for\n\treturn statement\n\t* sem_ch8.adb (Analyze_Object_Renaming): analyze dimension for\n\tobject renaming\n\t* sem_dim.adb, sem_dim.ads (Analyze_Aspect_Dimension):\n\tanalyze the expression for aspect dimension and store the\n\tvalues in a Htable.\n\t(Analyze_Aspect_Dimension_System): analyze\n\tthe expression for aspect dimension system and store the new\n\tsystem in a Table.\n\t(Analyze_Dimension): propagates dimension\n\t(Expand_Put_Call_With_Dimension_String): add the dimension\n\tstring as a suffix of the numeric value in the output\n\t(Has_Dimension): return True if the node has a dimension\n\t(Remove_Dimension_In_Declaration): removal of dimension in the\n\texpression of the declaration.\n\t(Remove_Dimension_In_Statement): removal of dimension in statement\n\t* sem_res.adb (Resolve): analyze dimension if the node\n\thas already been analyzed.\n\t(Resolve_Arithmetic_Op): analyze\n\tdimension for arithmetic op.\n\t(Resolve_Call): analyze dimension for function call.\n\t(Resolve_Comparison_Op): analyze dimension for comparison op.\n\t(Resolve_Equality_Op): analyze dimension for equality op.\n\t(Resolve_Indexed_Component): analyze dimension for indexed component.\n\t(Resolve_Op_Expon): analyze dimension for op expon.\n\t(Resolve_Selected_Component): analyze dimension\n\tfor selected component.\n\t(Resolve_Slice): analyze dimension for slice.\n\t(Resolve_Unary_Op): analyze dimension for unary op\n\t(Resolve_Type_Conversion): analyze dimension for type conversion\n\t(Resolve_Unchecked_Type_Conversion): analyze dimension for\n\tunchecked type conversion\n\t* snames.ads-tmpl Name_Dimension, Name_Dimension_System,\n\tName_Dim_Float_IO, Name_Dim_Integer_IO,\n\tName_Generic_Elementary_Functions, Name_Sqrt added.\n\tPragma_Dimension removed\n\t* s-diflio.adb, s-diflio.ads New GNAT library generic package\n\tfor dimensioned float type IO\n\t* s-diinio.adb, s-diinio.ads New GNAT library generic package\n\tfor dimensioned integer type IO\n\t* s-llflex.ads (Expon_LLF): exponentiation routine for long long\n\tfloats operand and exponent\n\n2011-12-15  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aggr.adb: Minor comment addition.\n\n2011-12-15  Bob Duff  <duff@adacore.com>\n\n\t* s-tasren.adb (Task_Count): Do not call Yield; E'Count is not a\n\ttask dispatching point.\n\t* s-taprop-mingw.adb (Yield): Do not yield if Do_Yield is False.\n\nFrom-SVN: r182368", "tree": {"sha": "20975a66444ac1e00f9193125dafa7c1e23e8fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20975a66444ac1e00f9193125dafa7c1e23e8fe7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/comments", "author": null, "committer": null, "parents": [{"sha": "ca814625c9cd6487a70ef1449941cfac575858e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca814625c9cd6487a70ef1449941cfac575858e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca814625c9cd6487a70ef1449941cfac575858e2"}], "stats": {"total": 3548, "additions": 3513, "deletions": 35}, "files": [{"sha": "ffc91dee40927cf04341f1500dcc6f8c777347f0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -1,3 +1,90 @@\n+2011-12-15  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* aspects.adb, aspects.ads Aspect_Dimension and\n+\tAspect_Dimension_System added\n+\t* exp_ch6.adb (Expand_Call): Expand_Put_Call_With_Dimension_String\n+\tcase added\n+\t* gcc-interface/Make-lang.in: s-llflex, sem_dim added.\n+\t* impunit.adb :s-diflio and s-diinio defined as GNAT Defined\n+\tAdditions to System.\n+\t* Makefile.rtl: s-diflio, s-diinio and s-llflex added\n+\t* par-prag.adb, sem_prag.adb: Pragma_Dimension removed\n+\t* rtsfind.ads: Expon_LLF added\n+\t* sem_aggr.adb (Resolve_Aggregate): handles aggregate for\n+\tAspect_Dimension case\n+\t* sem_attr.adb (Resolve_Attribute): analyze dimension for\n+\tattribute\n+\t* sem_ch10.adb (Analyze_With_Clause): Avoid the warning messages\n+\tdue to the use of a GNAT library for Dimension packages\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n+\tAspect_Dimension and Aspect_Dimension_System cases added\n+\t(Check_Aspect_At_Freeze_Point): Aspect_Dimension and\n+\tAspect_Dimension_System cases added\n+\t* sem_ch2.adb (Analyze_Identifier): analyze dimension for\n+\tidentifier\n+\t* sem_ch3.adb (Analyze_Component_Declaration): analyze dimension\n+\tfor component declaration (Analyze_Object_Declaration): analyze\n+\tdimension for object declaration (Analyze_Subtype_Declaration):\n+\tanalyze dimension for subtype declaration\n+\t* sem_ch4.adb (Operator_Check): checks exponent is a rational\n+\tfor dimensioned operand for a N_Op_Expon\n+\t* sem_ch5.adb (Analyze_Assignment): analyze dimension for\n+\tassignment (Analyze_Statements): removal of dimensions in all\n+\tstatements\n+\t* sem_ch6.adb (Analyze_Return_Statement): analyze dimension for\n+\treturn statement\n+\t* sem_ch8.adb (Analyze_Object_Renaming): analyze dimension for\n+\tobject renaming\n+\t* sem_dim.adb, sem_dim.ads (Analyze_Aspect_Dimension):\n+\tanalyze the expression for aspect dimension and store the\n+\tvalues in a Htable.\n+\t(Analyze_Aspect_Dimension_System): analyze\n+\tthe expression for aspect dimension system and store the new\n+\tsystem in a Table.\n+\t(Analyze_Dimension): propagates dimension\n+\t(Expand_Put_Call_With_Dimension_String): add the dimension\n+\tstring as a suffix of the numeric value in the output\n+\t(Has_Dimension): return True if the node has a dimension\n+\t(Remove_Dimension_In_Declaration): removal of dimension in the\n+\texpression of the declaration.\n+\t(Remove_Dimension_In_Statement): removal of dimension in statement\n+\t* sem_res.adb (Resolve): analyze dimension if the node\n+\thas already been analyzed.\n+\t(Resolve_Arithmetic_Op): analyze\n+\tdimension for arithmetic op.\n+\t(Resolve_Call): analyze dimension for function call.\n+\t(Resolve_Comparison_Op): analyze dimension for comparison op.\n+\t(Resolve_Equality_Op): analyze dimension for equality op.\n+\t(Resolve_Indexed_Component): analyze dimension for indexed component.\n+\t(Resolve_Op_Expon): analyze dimension for op expon.\n+\t(Resolve_Selected_Component): analyze dimension\n+\tfor selected component.\n+\t(Resolve_Slice): analyze dimension for slice.\n+\t(Resolve_Unary_Op): analyze dimension for unary op\n+\t(Resolve_Type_Conversion): analyze dimension for type conversion\n+\t(Resolve_Unchecked_Type_Conversion): analyze dimension for\n+\tunchecked type conversion\n+\t* snames.ads-tmpl Name_Dimension, Name_Dimension_System,\n+\tName_Dim_Float_IO, Name_Dim_Integer_IO,\n+\tName_Generic_Elementary_Functions, Name_Sqrt added.\n+\tPragma_Dimension removed\n+\t* s-diflio.adb, s-diflio.ads New GNAT library generic package\n+\tfor dimensioned float type IO\n+\t* s-diinio.adb, s-diinio.ads New GNAT library generic package\n+\tfor dimensioned integer type IO\n+\t* s-llflex.ads (Expon_LLF): exponentiation routine for long long\n+\tfloats operand and exponent\n+\n+2011-12-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_aggr.adb: Minor comment addition.\n+\n+2011-12-15  Bob Duff  <duff@adacore.com>\n+\n+\t* s-tasren.adb (Task_Count): Do not call Yield; E'Count is not a\n+\ttask dispatching point.\n+\t* s-taprop-mingw.adb (Yield): Do not yield if Do_Yield is False.\n+\n 2011-12-15  Robert Dewar  <dewar@adacore.com>\n \n \t* sigtramp-ppcvxw.c, sigtramp.h: Fix header."}, {"sha": "e04a5ff87b4c351d6cf140da8e6002fb13ecde8f", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -504,6 +504,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-crc32$(objext)  \\\n   s-crtl$(objext)   \\\n   s-crtrun$(objext) \\\n+  s-diflio$(objext) \\\n+  s-diinio$(objext) \\\n   s-direio$(objext) \\\n   s-dsaser$(objext) \\\n   s-excdeb$(objext) \\\n@@ -554,6 +556,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-imgwch$(objext) \\\n   s-imgwiu$(objext) \\\n   s-io$(objext)     \\\n+  s-llflex$(objext) \\\n   s-maccod$(objext) \\\n   s-mantis$(objext) \\\n   s-mastop$(objext) \\"}, {"sha": "8dc9a12bccb8d5efa0458c147898da1142de3339", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -240,6 +240,8 @@ package body Aspects is\n     Aspect_Default_Component_Value      => Aspect_Default_Component_Value,\n     Aspect_Default_Iterator             => Aspect_Default_Iterator,\n     Aspect_Default_Value                => Aspect_Default_Value,\n+    Aspect_Dimension                    => Aspect_Dimension,\n+    Aspect_Dimension_System             => Aspect_Dimension_System,\n     Aspect_Discard_Names                => Aspect_Discard_Names,\n     Aspect_Dispatching_Domain           => Aspect_Dispatching_Domain,\n     Aspect_Dynamic_Predicate            => Aspect_Predicate,"}, {"sha": "b701fe529dfc72f0ea8af2096b4cfff87ab56106", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -54,6 +54,8 @@ package Aspects is\n       Aspect_Default_Component_Value,\n       Aspect_Default_Iterator,\n       Aspect_Default_Value,\n+      Aspect_Dimension,\n+      Aspect_Dimension_System,\n       Aspect_Dispatching_Domain,\n       Aspect_Dynamic_Predicate,\n       Aspect_External_Tag,\n@@ -232,6 +234,8 @@ package Aspects is\n                         Aspect_Default_Component_Value => Expression,\n                         Aspect_Default_Iterator        => Name,\n                         Aspect_Default_Value           => Expression,\n+                        Aspect_Dimension               => Expression,\n+                        Aspect_Dimension_System        => Expression,\n                         Aspect_Dispatching_Domain      => Expression,\n                         Aspect_Dynamic_Predicate       => Expression,\n                         Aspect_External_Tag            => Expression,\n@@ -293,6 +297,8 @@ package Aspects is\n      Aspect_Default_Iterator             => Name_Default_Iterator,\n      Aspect_Default_Value                => Name_Default_Value,\n      Aspect_Default_Component_Value      => Name_Default_Component_Value,\n+     Aspect_Dimension                    => Name_Dimension,\n+     Aspect_Dimension_System             => Name_Dimension_System,\n      Aspect_Discard_Names                => Name_Discard_Names,\n      Aspect_Dispatching_Domain           => Name_Dispatching_Domain,\n      Aspect_Dynamic_Predicate            => Name_Dynamic_Predicate,"}, {"sha": "7a55ad8b14d6747879ac143a03945f48b2a2168f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -60,9 +60,10 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n-with Sem_Eval; use Sem_Eval;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n+with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_SCIL; use Sem_SCIL;\n@@ -2103,6 +2104,20 @@ package body Exp_Ch6 is\n    --  Start of processing for Expand_Call\n \n    begin\n+      --  Expand the procedure call if the first actual has a dimension and if\n+      --  the procedure is Put (Ada 2012).\n+\n+      if Ada_Version >= Ada_2012\n+        and then Nkind (Call_Node) = N_Procedure_Call_Statement\n+        and then Present (Parameter_Associations (Call_Node))\n+      then\n+         Expand_Put_Call_With_Dimension_String (Call_Node);\n+      end if;\n+\n+      --  Remove the dimensions of every parameters in call\n+\n+      Remove_Dimension_In_Call (N);\n+\n       --  Ignore if previous error\n \n       if Nkind (Call_Node) in N_Has_Etype"}, {"sha": "a79c0541c2c410aa86a2b72de506a6bea47d71b6", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -304,6 +304,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/s-htable.o\t\\\n  ada/s-imenne.o\t\\\n  ada/s-imgenu.o\t\\\n+ ada/s-llflex.o \\\n  ada/s-mastop.o\t\\\n  ada/s-memory.o\t\\\n  ada/s-os_lib.o\t\\\n@@ -353,6 +354,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/sem_ch7.o\t\\\n  ada/sem_ch8.o\t\\\n  ada/sem_ch9.o\t\\\n+ ada/sem_dim.o  \\\n  ada/sem_disp.o\t\\\n  ada/sem_dist.o\t\\\n  ada/sem_elab.o\t\\\n@@ -4307,6 +4309,9 @@ ada/sem_ch9.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \\\n    ada/warnsw.ads ada/widechar.ads \n \n+ada/sem_dim.o : ada/sem_util.ads ada/sem_util.adb ada/nmake.ads \\\n+   ada/nmake.adb\n+\n ada/sem_disp.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n    ada/atree.adb ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads \\"}, {"sha": "49a44adf7238b02ccc0a8aee0d3ce77cf483a6f9", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -366,6 +366,8 @@ package body Impunit is\n \n     (\"s-addima\", F),  -- System.Address_Image\n     (\"s-assert\", F),  -- System.Assertions\n+    (\"s-diflio\", F),  -- System.Dim_Float_IO\n+    (\"s-diinio\", F),  -- System.Dim_Integer_IO\n     (\"s-memory\", F),  -- System.Memory\n     (\"s-parint\", F),  -- System.Partition_Interface\n     (\"s-pooglo\", F),  -- System.Pool_Global"}, {"sha": "b3d029f3e4016490cb61c9fdd957d2c57a6f896c", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -1126,7 +1126,6 @@ begin\n            Pragma_Debug_Policy                   |\n            Pragma_Detect_Blocking                |\n            Pragma_Default_Storage_Pool           |\n-           Pragma_Dimension                      |\n            Pragma_Disable_Atomic_Synchronization |\n            Pragma_Discard_Names                  |\n            Pragma_Dispatching_Domain             |"}, {"sha": "64d1056606767230673c28f5a04db46fcb880a31", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -262,6 +262,7 @@ package Rtsfind is\n       System_Img_Uns,\n       System_Img_WChar,\n       System_Interrupts,\n+      System_Long_Long_Float_Expon,\n       System_Machine_Code,\n       System_Mantissa,\n       System_Memcop,\n@@ -866,6 +867,8 @@ package Rtsfind is\n      RE_Static_Interrupt_Protection,     -- System.Interrupts\n      RE_System_Interrupt_Id,             -- System.Interrupts\n \n+     RE_Expon_LLF,                       -- System.Long_Long_Float_Expon\n+\n      RE_Asm_Insn,                        -- System.Machine_Code\n      RE_Asm_Input_Operand,               -- System.Machine_Code\n      RE_Asm_Output_Operand,              -- System.Machine_Code\n@@ -2066,6 +2069,8 @@ package Rtsfind is\n      RE_Static_Interrupt_Protection      => System_Interrupts,\n      RE_System_Interrupt_Id              => System_Interrupts,\n \n+     RE_Expon_LLF                        => System_Long_Long_Float_Expon,\n+\n      RE_Asm_Insn                         => System_Machine_Code,\n      RE_Asm_Input_Operand                => System_Machine_Code,\n      RE_Asm_Output_Operand               => System_Machine_Code,"}, {"sha": "7a14b8f1f94baf051a34f70e28bb49334bb41055", "filename": "gcc/ada/s-diflio.adb", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diflio.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                    S Y S T E M . D I M _ F L O A T _ I O                 --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Dim_Float_IO is\n+\n+   package Num_Dim_Float_IO is new Ada.Text_IO.Float_IO (Num_Dim_Float);\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num_Dim_Float;\n+      Unit : String := \"\";\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Num_Dim_Float_IO.Put (File, Item, Fore, Aft, Exp);\n+      Ada.Text_IO.Put (File, Unit);\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num_Dim_Float;\n+      Unit : String := \"\";\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Num_Dim_Float_IO.Put (Item, Fore, Aft, Exp);\n+      Ada.Text_IO.Put (Unit);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num_Dim_Float;\n+      Unit : String := \"\";\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Num_Dim_Float_IO.Put (To, Item, Aft, Exp);\n+      To := To & Unit;\n+   end Put;\n+\n+end System.Dim_Float_IO;"}, {"sha": "e70dc499633e66d0cd399d0250f5ca3dca27ff4b", "filename": "gcc/ada/s-diflio.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diflio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diflio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diflio.ads?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                    S Y S T E M . D I M _ F L O A T _ I O                 --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note that this package should only be instantiated with a float dimensioned\n+--  type.\n+\n+--  This package is a generic package that provides IO facilities for float\n+--  dimensioned types.\n+\n+--  Note that there is a default string parameter in every Put routine\n+--  rewritten at compile time to output the corresponding dimensions as a\n+--  suffix of the numeric value.\n+\n+with Ada.Text_IO; use Ada.Text_IO;\n+\n+generic\n+   type Num_Dim_Float is digits <>;\n+\n+package System.Dim_Float_IO is\n+\n+   Default_Fore : Field := 2;\n+   Default_Aft  : Field := Num_Dim_Float'Digits - 1;\n+   Default_Exp  : Field := 3;\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num_Dim_Float;\n+      Unit : String := \"\";\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp);\n+\n+   procedure Put\n+     (Item : Num_Dim_Float;\n+      Unit : String := \"\";\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp);\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num_Dim_Float;\n+      Unit : String := \"\";\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp);\n+\n+   pragma Inline (Put);\n+\n+end System.Dim_Float_IO;"}, {"sha": "b530942aeb6fbc1a6205b6cbaf4d1e60df211d46", "filename": "gcc/ada/s-diinio.adb", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diinio.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                  S Y S T E M . D I M _ I N T E G E R _ I O               --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Dim_Integer_IO is\n+\n+   package Num_Dim_Integer_IO is new Ada.Text_IO.Integer_IO (Num_Dim_Integer);\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num_Dim_Integer;\n+      Unit : String := \"\";\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+\n+   is\n+   begin\n+      Num_Dim_Integer_IO.Put (File, Item, Width, Base);\n+      Ada.Text_IO.Put (File, Unit);\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num_Dim_Integer;\n+      Unit : String := \"\";\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+\n+   is\n+   begin\n+      Num_Dim_Integer_IO.Put (Item, Width, Base);\n+      Ada.Text_IO.Put (Unit);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num_Dim_Integer;\n+      Unit : String := \"\";\n+      Base  : Number_Base := Default_Base)\n+\n+   is\n+   begin\n+      Num_Dim_Integer_IO.Put (To, Item, Base);\n+      To := To & Unit;\n+   end Put;\n+\n+end System.Dim_Integer_IO;"}, {"sha": "2325cea36bb47a716cb39218bb5f75e4d2369f97", "filename": "gcc/ada/s-diinio.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diinio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-diinio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diinio.ads?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -0,0 +1,73 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                  S Y S T E M . D I M _ I N T E G E R _ I O               --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note that this package should only be instantiated with an integer\n+--  dimensioned type\n+\n+--  This package is a generic package that provides IO facilities for integer\n+--  dimensioned types.\n+\n+--  Note that there is a default string parameter in every Put routine\n+--  rewritten at compile time to output the corresponding dimensions as a\n+--  suffix of the numeric value.\n+\n+with Ada.Text_IO; use Ada.Text_IO;\n+\n+generic\n+   type Num_Dim_Integer is range <>;\n+\n+package System.Dim_Integer_IO is\n+\n+   Default_Width : Field := Num_Dim_Integer'Width;\n+   Default_Base  : Number_Base := 10;\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num_Dim_Integer;\n+      Unit : String := \"\";\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base);\n+\n+   procedure Put\n+     (Item : Num_Dim_Integer;\n+      Unit : String := \"\";\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base);\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num_Dim_Integer;\n+      Unit : String := \"\";\n+      Base  : Number_Base := Default_Base);\n+\n+   pragma Inline (Put);\n+\n+end System.Dim_Integer_IO;"}, {"sha": "2ff301f04884e6fa0cd37436daa2b4f4dd0bb14a", "filename": "gcc/ada/s-llflex.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-llflex.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-llflex.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-llflex.ads?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -0,0 +1,42 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--          S Y S T E M . L O N G _ L O N G _ F L O A T _ E X P O N         --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains an instantiation of the functions \"**\" and Sqrt\n+--  between two long long floats.\n+\n+with Ada.Numerics.Long_Long_Elementary_Functions;\n+\n+package System.Long_Long_Float_Expon is\n+\n+   function Expon_LLF (Left, Right : Long_Long_Float) return Long_Long_Float\n+     renames Ada.Numerics.Long_Long_Elementary_Functions.\"**\";\n+\n+end System.Long_Long_Float_Expon;"}, {"sha": "0a976a4e8b15471150f62d6d407f8d6d8896f2b6", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -710,10 +710,9 @@ package body System.Task_Primitives.Operations is\n       --  Moreover, CXD8002 appears to pass on Windows (although we do not\n       --  guarantee full Annex D compliance on Windows in any case).\n \n-      --  What is not clear is why we now call SwitchToThread in the False\n-      --  case. Other versions don't do that, is it necessary???\n-\n-      SwitchToThread;\n+      if Do_Yield then\n+         SwitchToThread;\n+      end if;\n    end Yield;\n \n    ------------------"}, {"sha": "04da4919c3f24cea993e875f46f2eb41e2abbdee", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -1069,10 +1069,6 @@ package body System.Tasking.Rendezvous is\n \n       Initialization.Undefer_Abort (Self_Id);\n \n-      --  Call Yield to let other tasks get a chance to run as this is a\n-      --  potential dispatching point.\n-\n-      Yield (Do_Yield => False);\n       return Return_Count;\n    end Task_Count;\n "}, {"sha": "e70333cc7e621915aa578c4e19ffe50ba4bd6d83", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -1691,6 +1691,11 @@ package body Sem_Aggr is\n             end if;\n          end if;\n \n+         --  If an aggregate component has a type with predicates, an explicit\n+         --  predicate check must be applied, as for an assignment statement,\n+         --  because the aggegate might not be expanded into individual\n+         --  component assignments.\n+\n          if Present (Predicate_Function (Component_Typ)) then\n             Apply_Predicate_Check (Expr, Component_Typ);\n          end if;\n@@ -3297,6 +3302,11 @@ package body Sem_Aggr is\n             Aggregate_Constraint_Checks (Expr, Expr_Type);\n          end if;\n \n+         --  If an aggregate component has a type with predicates, an explicit\n+         --  predicate check must be applied, as for an assignment statement,\n+         --  because the aggegate might not be expanded into individual\n+         --  component assignments.\n+\n          if Present (Predicate_Function (Expr_Type)) then\n             Apply_Predicate_Check (Expr, Expr_Type);\n          end if;"}, {"sha": "6e1493afbba93d78b033ff36b2330eb248c4af76", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -52,6 +52,7 @@ with Sem_Cat;  use Sem_Cat;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n@@ -9165,6 +9166,7 @@ package body Sem_Attr is\n \n       --  Finally perform static evaluation on the attribute reference\n \n+      Analyze_Dimension (N);\n       Eval_Attribute (N);\n    end Resolve_Attribute;\n "}, {"sha": "31bbd130903d1387adb8b0b842ac6188252253a9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -46,6 +46,7 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n@@ -1476,6 +1477,15 @@ package body Sem_Ch13 is\n \n                   goto Continue;\n                end;\n+\n+               when Aspect_Dimension =>\n+                  Analyze_Aspect_Dimension (N, Id, Expr);\n+                  goto Continue;\n+\n+               when Aspect_Dimension_System =>\n+                  Analyze_Aspect_Dimension_System (N, Id, Expr);\n+                  goto Continue;\n+\n             end case;\n \n             --  If a delay is required, we delay the freeze (not much point in\n@@ -6046,6 +6056,11 @@ package body Sem_Ch13 is\n               Aspect_Static_Predicate  |\n               Aspect_Type_Invariant    =>\n             T := Standard_Boolean;\n+\n+         when Aspect_Dimension |\n+              Aspect_Dimension_System =>\n+            raise Program_Error;\n+\n       end case;\n \n       --  Do the preanalyze call\n@@ -8777,8 +8792,8 @@ package body Sem_Ch13 is\n             Source : constant Entity_Id  := T.Source;\n             Target : constant Entity_Id  := T.Target;\n \n-            Source_Siz : Uint;\n-            Target_Siz : Uint;\n+            Source_Siz    : Uint;\n+            Target_Siz    : Uint;\n \n          begin\n             --  This validation check, which warns if we have unequal sizes for"}, {"sha": "efa965eb94148c823e8ab86cc6b49bec35b0a781", "filename": "gcc/ada/sem_ch2.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -30,6 +30,7 @@ with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Dim;  use Sem_Dim;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n with Uintp;    use Uintp;\n@@ -75,6 +76,8 @@ package body Sem_Ch2 is\n       else\n          Find_Direct_Name (N);\n       end if;\n+\n+      Analyze_Dimension (N);\n    end Analyze_Identifier;\n \n    -----------------------------"}, {"sha": "9070b4505e96c87013ebd1ba47577406dc933b21", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -56,6 +56,7 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n@@ -2036,6 +2037,7 @@ package body Sem_Ch3 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n+      Analyze_Dimension (N);\n    end Analyze_Component_Declaration;\n \n    --------------------------\n@@ -2089,6 +2091,11 @@ package body Sem_Ch3 is\n          --  Complete analysis of declaration\n \n          Analyze (D);\n+\n+         --  Removal of the dimension in the expression for object & component\n+         --  declaration.\n+\n+         Remove_Dimension_In_Declaration (D);\n          Next_Node := Next (D);\n \n          if No (Freeze_From) then\n@@ -3773,6 +3780,7 @@ package body Sem_Ch3 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n+      Analyze_Dimension (N);\n    end Analyze_Object_Declaration;\n \n    ---------------------------\n@@ -4571,6 +4579,7 @@ package body Sem_Ch3 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n+      Analyze_Dimension (N);\n    end Analyze_Subtype_Declaration;\n \n    --------------------------------"}, {"sha": "bd56eeff0349110307bb1e6fcf04465aff79c480", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -50,6 +50,7 @@ with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n@@ -6040,8 +6041,16 @@ package body Sem_Ch4 is\n                 First_Subtype (Base_Type (Etype (R))) /= Standard_Integer\n               and then Base_Type (Etype (R)) /= Universal_Integer\n             then\n-               Error_Msg_NE\n-                 (\"exponent must be of type Natural, found}\", R, Etype (R));\n+               if Ada_Version >= Ada_2012\n+                 and then Is_Dimensioned_Type (Etype (L))\n+               then\n+                  Error_Msg_NE\n+                    (\"exponent for dimensioned type must be a Rational\" &\n+                     \", found}\", R, Etype (R));\n+               else\n+                  Error_Msg_NE\n+                    (\"exponent must be of type Natural, found}\", R, Etype (R));\n+               end if;\n                return;\n             end if;\n "}, {"sha": "62df0de17b1f784351a607eff7ad154317e50d27", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -47,6 +47,7 @@ with Sem_Case; use Sem_Case;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n@@ -839,6 +840,7 @@ package body Sem_Ch5 is\n             Set_Last_Assignment (Ent, Lhs);\n          end if;\n       end;\n+      Analyze_Dimension (N);\n    end Analyze_Assignment;\n \n    -----------------------------\n@@ -2731,6 +2733,10 @@ package body Sem_Ch5 is\n       S := First (L);\n       while Present (S) loop\n          Analyze (S);\n+\n+         --  Remove dimension in all statements\n+\n+         Remove_Dimension_In_Statement (S);\n          Next (S);\n       end loop;\n "}, {"sha": "dbb4bb86e39367375a46b595683bd0b34fe0caa5", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -60,6 +60,7 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n@@ -1529,6 +1530,8 @@ package body Sem_Ch6 is\n \n       Kill_Current_Values (Last_Assignment_Only => True);\n       Check_Unreachable_Code (N);\n+\n+      Analyze_Dimension (N);\n    end Analyze_Return_Statement;\n \n    -------------------------------------"}, {"sha": "79fe3680e199f2be8667905ecb98c679bdfc35a8", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -53,6 +53,7 @@ with Sem_Ch4;  use Sem_Ch4;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n@@ -1215,6 +1216,7 @@ package body Sem_Ch8 is\n       end if;\n \n       Set_Renamed_Object (Id, Nam);\n+      Analyze_Dimension (N);\n    end Analyze_Object_Renaming;\n \n    ------------------------------"}, {"sha": "b0691695b72108722f64da9fdbc15797291b6277", "filename": "gcc/ada/sem_dim.adb", "status": "added", "additions": 2779, "deletions": 0, "changes": 2779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -0,0 +1,2779 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ D I M                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Aspects;  use Aspects;\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Namet.Sp; use Namet.Sp;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Stringt;  use Stringt;\n+with Table;\n+with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+with Urealp;   use Urealp;\n+\n+with GNAT.HTable;\n+\n+package body Sem_Dim is\n+\n+   --  Maximum number of dimensions in a dimension system\n+\n+   Max_Dimensions : constant Int := 7;\n+\n+   --  Dim_Id values are used to identify dimensions in a dimension system\n+   --  Note that the highest value of Dim_Id is Max_Dimensions\n+\n+   subtype Dim_Id is Pos range 1 .. Max_Dimensions;\n+\n+   --  Record type for dimension system\n+   --  A dimension system is defined by the number and the names of its\n+   --  dimensions and its base type.\n+\n+   subtype N_Of_Dimensions is Int range 0 .. Max_Dimensions;\n+\n+   No_Dimensions : constant N_Of_Dimensions := N_Of_Dimensions'First;\n+\n+   type Name_Array is array (Dim_Id) of Name_Id;\n+\n+   No_Names : constant Name_Array := (others => No_Name);\n+\n+   --  The symbols are used for IO purposes\n+\n+   type Symbol_Array is array (Dim_Id) of String_Id;\n+\n+   No_Symbols : constant Symbol_Array := (others => No_String);\n+\n+   type Dimension_System is record\n+      Base_Type : Node_Id;\n+      Names     : Name_Array;\n+      N_Of_Dims : N_Of_Dimensions;\n+      Symbols   : Symbol_Array;\n+   end record;\n+\n+   No_Dimension_System : constant Dimension_System :=\n+                           (Empty, No_Names, No_Dimensions, No_Symbols);\n+\n+   --  Dim_Sys_Id values are used to identify dimension system in the Table\n+   --  Note that the special value No_Dim_Sys has no corresponding component in\n+   --  the Table since it represents no dimension system.\n+\n+   subtype Dim_Sys_Id is Nat;\n+\n+   No_Dim_Sys : constant Dim_Sys_Id := Dim_Sys_Id'First;\n+\n+   --  The following table records every dimension system\n+\n+   package Dim_Systems is new Table.Table (\n+     Table_Component_Type => Dimension_System,\n+     Table_Index_Type     => Dim_Sys_Id,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 5,\n+     Table_Increment      => 5,\n+     Table_Name           => \"Dim_Systems\");\n+\n+   --  Rational (definitions & operations)\n+\n+   type Whole is new Int;\n+   subtype Positive_Whole is Whole range 1 .. Whole'Last;\n+\n+   type Rational is record\n+      Numerator   : Whole;\n+      Denominator : Positive_Whole;\n+   end record;\n+\n+   Zero_Rational : constant Rational := (0, 1);\n+\n+   --  Rational constructors\n+\n+   function \"+\" (Right : Whole) return Rational;\n+   function \"/\" (Left, Right : Whole) return Rational;\n+   function GCD (Left, Right : Whole) return Int;\n+   function Reduce (X : Rational) return Rational;\n+\n+   --  Unary operator for Rational\n+\n+   function \"-\" (Right : Rational) return Rational;\n+\n+   --  Rational operations for Rationals\n+\n+   function \"+\" (Left, Right : Rational) return Rational;\n+   function \"-\" (Left, Right : Rational) return Rational;\n+   function \"*\" (Left, Right : Rational) return Rational;\n+\n+   --  Operation between Rational and Int\n+\n+   function \"*\" (Left : Rational; Right : Whole) return Rational;\n+\n+   ---------\n+   -- GCD --\n+   ---------\n+\n+   function GCD (Left, Right : Whole) return Int is\n+      L : Whole := Left;\n+      R : Whole := Right;\n+\n+   begin\n+      while R /= 0 loop\n+         L := L mod R;\n+\n+         if L = 0 then\n+            return Int (R);\n+         end if;\n+\n+         R := R mod L;\n+      end loop;\n+\n+      return Int (L);\n+   end GCD;\n+\n+   ------------\n+   -- Reduce --\n+   ------------\n+\n+   function Reduce (X : Rational) return Rational is\n+   begin\n+      if X.Numerator = 0 then\n+         return Zero_Rational;\n+      end if;\n+\n+      declare\n+         G : constant Int := GCD (X.Numerator, X.Denominator);\n+\n+      begin\n+         return Rational'(Numerator   => Whole (Int (X.Numerator) / G),\n+                          Denominator => Whole (Int (X.Denominator) / G));\n+      end;\n+   end Reduce;\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (Right : Whole) return Rational is\n+   begin\n+      return (Right, 1);\n+   end \"+\";\n+\n+   function \"+\" (Left, Right : Rational) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right.Denominator +\n+                                       Left.Denominator * Right.Numerator,\n+                      Denominator => Left.Denominator * Right.Denominator);\n+\n+   begin\n+      return Reduce (R);\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (Right : Rational) return Rational is\n+   begin\n+      return Rational'(Numerator   => -Right.Numerator,\n+                       Denominator => Right.Denominator);\n+   end \"-\";\n+\n+   function \"-\" (Left, Right : Rational) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right.Denominator -\n+                                       Left.Denominator * Right.Numerator,\n+                      Denominator => Left.Denominator * Right.Denominator);\n+\n+   begin\n+      return Reduce (R);\n+   end \"-\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\" (Left, Right : Rational) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right.Numerator,\n+                      Denominator => Left.Denominator * Right.Denominator);\n+\n+   begin\n+      return Reduce (R);\n+   end \"*\";\n+\n+   function \"*\" (Left : Rational; Right : Whole) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right,\n+                      Denominator => Left.Denominator);\n+\n+   begin\n+      return Reduce (R);\n+   end \"*\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (Left, Right : Whole) return  Rational is\n+      R : constant Int := abs Int (Right);\n+      L : Int          := Int (Left);\n+\n+   begin\n+      if Right < 0 then\n+         L := -L;\n+      end if;\n+\n+      return Reduce (Rational'(Numerator   => Whole (L),\n+                               Denominator => Whole (R)));\n+   end \"/\";\n+\n+   --  Hash Table for aspect dimension.\n+\n+   --  The following table provides a relation between nodes and its dimension\n+   --  (if not dimensionless). If a node is not stored in the Hash Table, the\n+   --  node is considered to be dimensionless.\n+   --  A dimension is represented by an array of Max_Dimensions Rationals.\n+   --  If the corresponding dimension system has less than Max_Dimensions\n+   --  dimensions, the array is filled by as many as Zero_Rationals needed to\n+   --  complete the array.\n+\n+   --  Here is a list of nodes that can have entries in this Htable:\n+\n+   --  N_Attribute_Reference\n+   --  N_Defining_Identifier\n+   --  N_Function_Call\n+   --  N_Identifier\n+   --  N_Indexed_Component\n+   --  N_Integer_Literal\n+   --  N_Op_Abs\n+   --  N_Op_Add\n+   --  N_Op_Divide\n+   --  N_Op_Expon\n+   --  N_Op_Minus\n+   --  N_Op_Mod\n+   --  N_Op_Multiply\n+   --  N_Op_Plus\n+   --  N_Op_Rem\n+   --  N_Op_Subtract\n+   --  N_Qualified_Expression\n+   --  N_Real_Literal\n+   --  N_Selected_Component\n+   --  N_Slice\n+   --  N_Type_Conversion\n+   --  N_Unchecked_Type_Conversion\n+\n+   type Dimensions is array (Dim_Id) of Rational;\n+\n+   Zero_Dimensions : constant Dimensions := (others => Zero_Rational);\n+\n+   type AD_Hash_Range is range 0 .. 511;\n+\n+   function AD_Hash (F : Node_Id) return AD_Hash_Range;\n+\n+   function AD_Hash (F : Node_Id) return AD_Hash_Range is\n+   begin\n+      return AD_Hash_Range (F mod 512);\n+   end AD_Hash;\n+\n+   --  Node_Id --> Dimensions\n+\n+   package Aspect_Dimension_Hash_Table is new\n+     GNAT.HTable.Simple_HTable\n+       (Header_Num => AD_Hash_Range,\n+        Element    => Dimensions,\n+        No_Element => Zero_Dimensions,\n+        Key        => Node_Id,\n+        Hash       => AD_Hash,\n+        Equal      => \"=\");\n+\n+   --  Table to record the string of each subtype declaration\n+   --  Note that this table is only used for IO purposes\n+\n+   --  Entity_Id --> String_Id\n+\n+   package Aspect_Dimension_String_Id_Hash_Table is new\n+     GNAT.HTable.Simple_HTable\n+       (Header_Num => AD_Hash_Range,\n+        Element    => String_Id,\n+        No_Element => No_String,\n+        Key        => Entity_Id,\n+        Hash       => AD_Hash,\n+        Equal      => \"=\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Analyze_Dimension_Assignment_Statement (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for assignment statement\n+\n+   procedure Analyze_Dimension_Binary_Op (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for binary operators\n+\n+   procedure Analyze_Dimension_Component_Declaration (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for component declaration\n+\n+   procedure Analyze_Dimension_Extended_Return_Statement (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for extended return statement\n+\n+   procedure Analyze_Dimension_Function_Call (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for function call\n+\n+   procedure Analyze_Dimension_Has_Etype (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for N_Has_Etype nodes:\n+   --  N_Attribute_Reference\n+   --  N_Indexed_Component\n+   --  N_Qualified_Expression\n+   --  N_Selected_Component\n+   --  N_Slice\n+   --  N_Type_Conversion\n+   --  N_Unchecked_Type_Conversion\n+\n+   procedure Analyze_Dimension_Identifier (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for identifier\n+\n+   procedure Analyze_Dimension_Object_Declaration (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for object declaration\n+\n+   procedure Analyze_Dimension_Object_Renaming_Declaration (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for object renaming declaration\n+\n+   procedure Analyze_Dimension_Simple_Return_Statement (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for simple return statement\n+\n+   procedure Analyze_Dimension_Subtype_Declaration (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for subtype declaration\n+\n+   procedure Analyze_Dimension_Unary_Op (N : Node_Id);\n+   --  Subroutine of Analyze_Dimension for unary operators\n+\n+   procedure Copy_Dimensions (From, To : Node_Id);\n+   --  Propagate dimensions between two nodes\n+\n+   procedure Create_Rational_From_Expr (Expr : Node_Id; R : in out Rational);\n+   --  Given an expression, creates a rational number\n+\n+   procedure Eval_Op_Expon_With_Rational_Exponent\n+     (N   : Node_Id;\n+      Rat : Rational);\n+   --  Evaluate the Expon if the exponent is a rational and the operand has a\n+   --  dimension.\n+\n+   function From_Dimension_To_String_Id\n+     (Dims : Dimensions;\n+      Sys  : Dim_Sys_Id) return String_Id;\n+   --  Given a dimension vector and a dimension system, return the proper\n+   --  string of symbols.\n+\n+   function Get_Dimensions (N : Node_Id) return Dimensions;\n+   --  Return the dimensions for the corresponding node\n+\n+   function Get_Dimensions_String_Id (E : Entity_Id) return String_Id;\n+   --  Return the String_Id of dimensions for the corresponding entity\n+\n+   function Get_Dimension_System_Id (E : Entity_Id) return Dim_Sys_Id;\n+   --  Return the Dim_Id of the corresponding dimension system\n+\n+   procedure Move_Dimensions (From, To : Node_Id);\n+   --  Move Dimensions from 'From' to 'To'. Only called when 'From' has a\n+   --  dimension.\n+\n+   function Permits_Dimensions (N : Node_Id) return Boolean;\n+   --  Return True if a node can have a dimension\n+\n+   function Present (Dim : Dimensions) return Boolean;\n+   --  Return True if Dim is not equal to Zero_Dimensions.\n+\n+   procedure Remove_Dimensions (N : Node_Id);\n+   --  Remove the node from the HTable\n+\n+   procedure Set_Dimensions (N : Node_Id; Dims : Dimensions);\n+   --  Store the dimensions of N in the Hash_Table for Dimensions\n+\n+   procedure Set_Dimensions_String_Id (E : Entity_Id; Str : String_Id);\n+   --  Store the string of dimensions of E in the Hash_Table for String_Id\n+\n+   ------------------------------\n+   -- Analyze_Aspect_Dimension --\n+   ------------------------------\n+\n+   --  with Dimension => DIMENSION_FOR_SUBTYPE\n+   --  DIMENSION_FOR_SUBTYPE ::= (DIMENSION_STRING, DIMENSION_RATIONALS)\n+   --  DIMENSION_RATIONALS ::=\n+   --    RATIONAL,  {, RATIONAL}\n+   --  | RATIONAL {, RATIONAL}, others => RATIONAL\n+   --  | DISCRETE_CHOICE_LIST => RATIONAL\n+\n+   --  (see Analyze_Aspect_Dimension_System for DIMENSION_STRING grammar)\n+\n+   procedure Analyze_Aspect_Dimension\n+     (N    : Node_Id;\n+      Id   : Node_Id;\n+      Expr : Node_Id)\n+   is\n+      Def_Id   : constant Entity_Id := Defining_Identifier (N);\n+      N_Kind   : constant Node_Kind := Nkind (N);\n+      Analyzed : array (Dimensions'Range) of Boolean := (others => False);\n+      --  This array has been defined in order to deals with Others_Choice\n+      --  It is a reminder of the dimensions in the aggregate that have already\n+      --  been analyzed.\n+\n+      Choice      : Node_Id;\n+      Comp_Expr   : Node_Id;\n+      Comp_Assn   : Node_Id;\n+      Dim         : Dim_Id;\n+      Dims        : Dimensions := Zero_Dimensions;\n+      Dim_Str_Lit : Node_Id;\n+      D_Sys       : Dim_Sys_Id := No_Dim_Sys;\n+      N_Of_Dims   : N_Of_Dimensions;\n+      Str         : String_Id := No_String;\n+\n+      function Check_Identifier_Is_Dimension\n+        (Id    : Node_Id;\n+         D_Sys : Dim_Sys_Id) return Boolean;\n+      --  Return True if the identifier name is the name of a dimension in the\n+      --  dimension system D_Sys.\n+\n+      function Check_Compile_Time_Known_Expressions_In_Aggregate\n+        (Expr : Node_Id) return Boolean;\n+      --  Check that each expression in the aggregate is known at compile time\n+\n+      function Check_Number_Dimensions_Aggregate\n+        (Expr      : Node_Id;\n+         D_Sys     : Dim_Sys_Id;\n+         N_Of_Dims : N_Of_Dimensions) return Boolean;\n+      --  This routine checks the number of dimensions in the aggregate.\n+\n+      function Corresponding_Dimension_System (N : Node_Id) return Dim_Sys_Id;\n+      --  Return the Dim_Sys_Id of the corresponding dimension system\n+\n+      function Corresponding_Etype_Has_Dimensions (N : Node_Id) return Boolean;\n+      --  Return True if the Etype of N has a dimension\n+\n+      function Get_Dimension_Id\n+        (Id    : Node_Id;\n+         D_Sys : Dim_Sys_Id) return Dim_Id;\n+      --  Given an identifier and the Dim_Sys_Id of the dimension system in the\n+      --  Table, returns the Dim_Id that has the same name as the identifier.\n+\n+      ------------------------------------\n+      -- Corresponding_Dimension_System --\n+      ------------------------------------\n+\n+      function Corresponding_Dimension_System\n+        (N : Node_Id) return Dim_Sys_Id\n+      is\n+         B_Typ   : Node_Id;\n+         Sub_Ind : Node_Id;\n+      begin\n+         --  Aspect_Dimension can only apply for subtypes\n+\n+         --  Look for the dimension system corresponding to this\n+         --  Aspect_Dimension.\n+\n+         if Nkind (N) = N_Subtype_Declaration then\n+            Sub_Ind := Subtype_Indication (N);\n+\n+            if Nkind (Sub_Ind) /= N_Subtype_Indication then\n+               B_Typ := Etype (Sub_Ind);\n+               return Get_Dimension_System_Id (B_Typ);\n+\n+            else\n+               return No_Dim_Sys;\n+            end if;\n+\n+         else\n+            return No_Dim_Sys;\n+         end if;\n+      end Corresponding_Dimension_System;\n+\n+      ----------------------------------------\n+      -- Corresponding_Etype_Has_Dimensions --\n+      ----------------------------------------\n+\n+      function Corresponding_Etype_Has_Dimensions\n+        (N : Node_Id) return Boolean\n+      is\n+         Dims_Typ : Dimensions;\n+         Typ      : Entity_Id;\n+\n+      begin\n+\n+         --  Check the type is dimensionless before assigning a dimension\n+\n+         if Nkind (N) = N_Subtype_Declaration then\n+            declare\n+               Sub : constant Node_Id := Subtype_Indication (N);\n+\n+            begin\n+               if Nkind (Sub) /= N_Subtype_Indication then\n+                  Typ := Etype (Sub);\n+               else\n+                  Typ := Etype (Subtype_Mark (Sub));\n+               end if;\n+\n+               Dims_Typ := Get_Dimensions (Typ);\n+               return Present (Dims_Typ);\n+            end;\n+\n+         else\n+            return False;\n+         end if;\n+      end Corresponding_Etype_Has_Dimensions;\n+\n+      ---------------------------------------\n+      -- Check_Number_Dimensions_Aggregate --\n+      ---------------------------------------\n+\n+      function Check_Number_Dimensions_Aggregate\n+        (Expr      : Node_Id;\n+         D_Sys     : Dim_Sys_Id;\n+         N_Of_Dims : N_Of_Dimensions) return Boolean\n+      is\n+         Assoc       : Node_Id;\n+         Choice      : Node_Id;\n+         Comp_Expr   : Node_Id;\n+         N_Dims_Aggr : Int := No_Dimensions;\n+         --  The number of dimensions in this aggregate\n+\n+      begin\n+         --  Check the size of the aggregate match with the size of the\n+         --  corresponding dimension system.\n+\n+         Comp_Expr := First (Expressions (Expr));\n+\n+         --  Skip the first argument in the aggregate since it's a character or\n+         --  a string and not a dimension value.\n+\n+         Next (Comp_Expr);\n+\n+         if Present (Component_Associations (Expr)) then\n+\n+            --  If the aggregate is a positional aggregate with an\n+            --  Others_Choice, the number of expressions must be less than or\n+            --  equal to N_Of_Dims - 1.\n+\n+            if Present (Comp_Expr) then\n+               N_Dims_Aggr := List_Length (Expressions (Expr)) - 1;\n+               return N_Dims_Aggr <= N_Of_Dims - 1;\n+\n+            --  If the aggregate is a named aggregate, N_Dims_Aggr is used to\n+            --  count all the dimensions referenced by the aggregate.\n+\n+            else\n+               Assoc := First (Component_Associations (Expr));\n+\n+               while Present (Assoc) loop\n+                  if Nkind (Assoc) = N_Range then\n+                     Choice := First (Choices (Assoc));\n+\n+                     declare\n+                        HB     : constant Node_Id := High_Bound (Choice);\n+                        LB     : constant Node_Id := Low_Bound (Choice);\n+                        LB_Dim : Dim_Id;\n+                        HB_Dim : Dim_Id;\n+\n+                     begin\n+                        if not Check_Identifier_Is_Dimension (HB, D_Sys)\n+                          or else not Check_Identifier_Is_Dimension (LB, D_Sys)\n+                        then\n+                           return False;\n+                        end if;\n+\n+                        HB_Dim := Get_Dimension_Id (HB, D_Sys);\n+                        LB_Dim := Get_Dimension_Id (LB, D_Sys);\n+\n+                        N_Dims_Aggr := N_Dims_Aggr + HB_Dim - LB_Dim +  1;\n+                     end;\n+\n+                  else\n+                     N_Dims_Aggr :=\n+                       N_Dims_Aggr + List_Length (Choices (Assoc));\n+                  end if;\n+\n+                  Next (Assoc);\n+               end loop;\n+\n+               --  Check whether an Others_Choice is present or not\n+\n+               if Nkind\n+                    (First (Choices (Last (Component_Associations (Expr))))) =\n+                     N_Others_Choice\n+               then\n+                  return N_Dims_Aggr <= N_Of_Dims;\n+               else\n+                  return N_Dims_Aggr = N_Of_Dims;\n+               end if;\n+            end if;\n+\n+         --  If the aggregate is a positional aggregate without Others_Choice,\n+         --  the number of expressions must match the number of dimensions in\n+         --  the dimension system.\n+\n+         else\n+            N_Dims_Aggr := List_Length (Expressions (Expr)) - 1;\n+            return N_Dims_Aggr = N_Of_Dims;\n+         end if;\n+      end Check_Number_Dimensions_Aggregate;\n+\n+      -----------------------------------\n+      -- Check_Identifier_Is_Dimension --\n+      -----------------------------------\n+\n+      function Check_Identifier_Is_Dimension\n+        (Id    : Node_Id;\n+         D_Sys : Dim_Sys_Id) return Boolean\n+      is\n+         Na_Id     : constant Name_Id := Chars (Id);\n+         Dim_Name1 : Name_Id;\n+         Dim_Name2 : Name_Id;\n+\n+      begin\n+\n+         for Dim1 in Dim_Id'Range loop\n+            Dim_Name1 := Dim_Systems.Table (D_Sys).Names (Dim1);\n+\n+            if Dim_Name1 = Na_Id then\n+               return True;\n+            end if;\n+\n+            if Dim1 = Max_Dimensions then\n+\n+               --  Check for possible misspelling\n+\n+               Error_Msg_N (\"& is not a dimension argument for aspect%\", Id);\n+\n+               for Dim2 in Dim_Id'Range loop\n+                  Dim_Name2 := Dim_Systems.Table (D_Sys).Names (Dim2);\n+\n+                  if Is_Bad_Spelling_Of (Na_Id, Dim_Name2) then\n+                     Error_Msg_Name_1 := Dim_Name2;\n+                     Error_Msg_N (\"\\possible misspelling of%\", Id);\n+                     exit;\n+                  end if;\n+               end loop;\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end Check_Identifier_Is_Dimension;\n+\n+      ----------------------\n+      -- Get_Dimension_Id --\n+      ----------------------\n+\n+      --  Given an identifier, returns the correponding position of the\n+      --  dimension in the dimension system.\n+\n+      function Get_Dimension_Id\n+        (Id    : Node_Id;\n+         D_Sys : Dim_Sys_Id) return Dim_Id\n+      is\n+         Na_Id    : constant Name_Id := Chars (Id);\n+         Dim      : Dim_Id;\n+         Dim_Name : Name_Id;\n+\n+      begin\n+         for D in Dim_Id'Range loop\n+            Dim_Name := Dim_Systems.Table (D_Sys).Names (D);\n+\n+            if Dim_Name = Na_Id then\n+               Dim := D;\n+            end if;\n+\n+         end loop;\n+\n+         return Dim;\n+      end Get_Dimension_Id;\n+\n+      -------------------------------------------------------\n+      -- Check_Compile_Time_Known_Expressions_In_Aggregate --\n+      -------------------------------------------------------\n+\n+      function Check_Compile_Time_Known_Expressions_In_Aggregate\n+        (Expr : Node_Id) return Boolean\n+      is\n+         Comp_Assn : Node_Id;\n+         Comp_Expr : Node_Id;\n+\n+      begin\n+         Comp_Expr := First (Expressions (Expr));\n+         Next (Comp_Expr);\n+\n+         while Present (Comp_Expr) loop\n+\n+            --  First, analyze the expression\n+\n+            Analyze_And_Resolve (Comp_Expr);\n+            if not Compile_Time_Known_Value (Comp_Expr) then\n+               return False;\n+            end if;\n+\n+            Next (Comp_Expr);\n+         end loop;\n+\n+         Comp_Assn := First (Component_Associations (Expr));\n+\n+         while Present (Comp_Assn) loop\n+            Comp_Expr := Expression (Comp_Assn);\n+\n+            --  First, analyze the expression\n+\n+            Analyze_And_Resolve (Comp_Expr);\n+\n+            if not Compile_Time_Known_Value (Comp_Expr) then\n+               return False;\n+            end if;\n+\n+            Next (Comp_Assn);\n+         end loop;\n+\n+         return True;\n+      end Check_Compile_Time_Known_Expressions_In_Aggregate;\n+\n+   --  Start of processing for Analyze_Aspect_Dimension\n+\n+   begin\n+      --  Syntax checking\n+\n+      Error_Msg_Name_1 := Chars (Id);\n+\n+      if N_Kind /= N_Subtype_Declaration then\n+         Error_Msg_N (\"aspect% doesn't apply here\", N);\n+         return;\n+      end if;\n+\n+      if Nkind (Expr) /= N_Aggregate then\n+         Error_Msg_N (\"wrong syntax for aspect%\", Expr);\n+         return;\n+      end if;\n+\n+      D_Sys := Corresponding_Dimension_System (N);\n+\n+      if D_Sys = No_Dim_Sys then\n+         Error_Msg_N (\"dimension system not found for aspect%\", N);\n+         return;\n+      end if;\n+\n+      if Corresponding_Etype_Has_Dimensions (N) then\n+         Error_Msg_N (\"corresponding type already has a dimension\", N);\n+         return;\n+      end if;\n+\n+      --  Check the first expression is a string or a character literal and\n+      --  skip it.\n+\n+      Dim_Str_Lit := First (Expressions (Expr));\n+\n+      if not Present (Dim_Str_Lit)\n+        or else not Nkind_In (Dim_Str_Lit,\n+                              N_String_Literal,\n+                              N_Character_Literal)\n+      then\n+         Error_Msg_N\n+           (\"wrong syntax for aspect%: first argument in the aggregate must \" &\n+            \"be a character or a string\",\n+            Expr);\n+         return;\n+      end if;\n+\n+      Comp_Expr := Next (Dim_Str_Lit);\n+\n+      --  Check the number of dimensions match with the dimension system\n+\n+      N_Of_Dims := Dim_Systems.Table (D_Sys).N_Of_Dims;\n+\n+      if not Check_Number_Dimensions_Aggregate (Expr, D_Sys, N_Of_Dims) then\n+         Error_Msg_N (\"wrong number of dimensions for aspect%\", Expr);\n+         return;\n+      end if;\n+\n+      Dim := Dim_Id'First;\n+      Comp_Assn := First (Component_Associations (Expr));\n+\n+      if Present (Comp_Expr) then\n+\n+         if List_Length (Component_Associations (Expr)) > 1 then\n+            Error_Msg_N (\"named association cannot follow \" &\n+                         \"positional association for aspect%\", Expr);\n+            return;\n+         end if;\n+\n+         if Present (Comp_Assn)\n+           and then Nkind (First (Choices (Comp_Assn))) /= N_Others_Choice\n+         then\n+            Error_Msg_N (\"named association cannot follow \" &\n+                         \"positional association for aspect%\", Expr);\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Check each expression in the aspect Dimension aggregate is known at\n+      --  compile time.\n+\n+      if not Check_Compile_Time_Known_Expressions_In_Aggregate (Expr) then\n+         Error_Msg_N (\"wrong syntax for aspect%\", Expr);\n+         return;\n+      end if;\n+\n+      --  Get the dimension values and store them in the Hash_Table\n+\n+      --  Positional aggregate case\n+\n+      while Present (Comp_Expr) loop\n+         if Is_Integer_Type (Def_Id) then\n+            Dims (Dim) := +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n+         else\n+            Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n+         end if;\n+\n+         Analyzed (Dim) := True;\n+\n+         exit when Dim = Max_Dimensions;\n+\n+         Dim := Dim + 1;\n+         Next (Comp_Expr);\n+      end loop;\n+\n+      --  Named aggregate case\n+\n+      while Present (Comp_Assn) loop\n+         Comp_Expr := Expression (Comp_Assn);\n+         Choice := First (Choices (Comp_Assn));\n+\n+         if List_Length (Choices (Comp_Assn)) = 1 then\n+\n+            --  N_Identifier case\n+\n+            if Nkind (Choice) = N_Identifier then\n+\n+               if not Check_Identifier_Is_Dimension (Choice, D_Sys) then\n+                  return;\n+               end if;\n+\n+               Dim := Get_Dimension_Id (Choice, D_Sys);\n+\n+               if Is_Integer_Type (Def_Id) then\n+                  Dims (Dim) := +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n+               else\n+                  Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n+               end if;\n+\n+               Analyzed (Dim) := True;\n+\n+            --  N_Range case\n+\n+            elsif Nkind (Choice) = N_Range then\n+               declare\n+                  HB     : constant Node_Id := High_Bound (Choice);\n+                  LB     : constant Node_Id := Low_Bound (Choice);\n+                  LB_Dim : constant Dim_Id  := Get_Dimension_Id (LB, D_Sys);\n+                  HB_Dim : constant Dim_Id  := Get_Dimension_Id (HB, D_Sys);\n+\n+               begin\n+                  for Dim in LB_Dim .. HB_Dim loop\n+                     if Is_Integer_Type (Def_Id) then\n+                        Dims (Dim) :=\n+                          +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n+                     else\n+                        Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n+                     end if;\n+\n+                     Analyzed (Dim) := True;\n+                  end loop;\n+               end;\n+\n+            --  N_Others_Choice case\n+\n+            elsif Nkind (Choice) = N_Others_Choice then\n+\n+               --  Check the Others_Choice is alone and last in the aggregate\n+\n+               if Present (Next (Comp_Assn)) then\n+                  Error_Msg_N\n+                    (\"OTHERS must appear alone and last in expression \" &\n+                     \"for aspect%\", Choice);\n+                  return;\n+               end if;\n+\n+               --  End the filling of Dims by the Others_Choice value\n+               --  If N_Of_Dims < Max_Dimensions then only the\n+               --  positions that haven't been already analyzed from\n+               --  Dim_Id'First to N_Of_Dims are filled.\n+\n+               for Dim in Dim_Id'First .. N_Of_Dims loop\n+                  if not Analyzed (Dim) then\n+                     if Is_Integer_Type (Def_Id) then\n+                        Dims (Dim) :=\n+                          +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n+                     else\n+                        Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n+                     end if;\n+                  end if;\n+               end loop;\n+\n+            else\n+               Error_Msg_N (\"wrong syntax for aspect%\", Id);\n+            end if;\n+\n+         else\n+            while Present (Choice) loop\n+               if Nkind (Choice) = N_Identifier then\n+\n+                  if not Check_Identifier_Is_Dimension (Choice, D_Sys) then\n+                     return;\n+                  end if;\n+\n+                  Dim := Get_Dimension_Id (Choice, D_Sys);\n+\n+                  if Is_Integer_Type (Def_Id) then\n+                     Dims (Dim) := +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n+                  else\n+                     Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n+                  end if;\n+\n+                  Analyzed (Dim) := True;\n+                  Next (Choice);\n+               else\n+                  Error_Msg_N (\"wrong syntax for aspect%\", Id);\n+               end if;\n+            end loop;\n+         end if;\n+\n+         Next (Comp_Assn);\n+      end loop;\n+\n+      --  Create the string of dimensions\n+\n+      if Nkind (Dim_Str_Lit) = N_Character_Literal then\n+         Start_String;\n+         Store_String_Char (UI_To_CC (Char_Literal_Value (Dim_Str_Lit)));\n+         Str := End_String;\n+      else\n+         Str := Strval (Dim_Str_Lit);\n+      end if;\n+\n+      --  Store the dimensions in the Hash Table if not all equal to zero and\n+      --  string is empty.\n+\n+      if not Present (Dims) then\n+         if String_Length (Str) = 0 then\n+            Error_Msg_N\n+              (\"?dimension values all equal to zero for aspect%\", Expr);\n+            return;\n+         end if;\n+      else\n+         Set_Dimensions (Def_Id, Dims);\n+      end if;\n+\n+      --  Store the string in the Hash Table\n+      --  When the string is empty, don't store the string in the Hash Table\n+\n+      if Str /= No_String\n+        and then String_Length (Str) /= 0\n+      then\n+         Set_Dimensions_String_Id (Def_Id, Str);\n+      end if;\n+   end Analyze_Aspect_Dimension;\n+\n+   -------------------------------------\n+   -- Analyze_Aspect_Dimension_System --\n+   -------------------------------------\n+\n+   --    with Dimension_System => DIMENSION_PAIRS\n+   --  DIMENSION_PAIRS ::=\n+   --    (DIMENSION_PAIR\n+   --      [, DIMENSION_PAIR]\n+   --      [, DIMENSION_PAIR]\n+   --      [, DIMENSION_PAIR]\n+   --      [, DIMENSION_PAIR]\n+   --      [, DIMENSION_PAIR]\n+   --      [, DIMENSION_PAIR])\n+   --  DIMENSION_PAIR ::= (DIMENSION_IDENTIFIER, DIMENSION_STRING)\n+   --  DIMENSION_IDENTIFIER ::= IDENTIFIER\n+   --  DIMENSION_STRING ::= STRING_LITERAL | CHARACTER_LITERAL\n+\n+   procedure Analyze_Aspect_Dimension_System\n+     (N    : Node_Id;\n+      Id   : Node_Id;\n+      Expr : Node_Id)\n+   is\n+      Dim_Name   : Node_Id;\n+      Dim_Node   : Node_Id;\n+      Dim_Symbol : Node_Id;\n+      D_Sys      : Dimension_System := No_Dimension_System;\n+      Names      : Name_Array := No_Names;\n+      N_Of_Dims  : N_Of_Dimensions;\n+      Symbols    : Symbol_Array := No_Symbols;\n+\n+      function Derived_From_Numeric_Type (N : Node_Id) return Boolean;\n+      --  Return True if the node is a derived type declaration from any\n+      --  numeric type.\n+\n+      function Check_Dimension_System_Syntax (N : Node_Id) return Boolean;\n+      --  Return True if the expression is an aggregate of names\n+\n+      function Check_Number_Of_Dimensions (Expr : Node_Id) return Boolean;\n+      --  Return True if the number of dimensions in the corresponding\n+      --  dimension is positive and lower than Max_Dimensions.\n+\n+      -------------------------------\n+      -- Derived_From_Numeric_Type --\n+      -------------------------------\n+\n+      function Derived_From_Numeric_Type (N : Node_Id) return Boolean is\n+      begin\n+         case (Nkind (N)) is\n+            when N_Full_Type_Declaration =>\n+               declare\n+                  T_Def : constant Node_Id := Type_Definition (N);\n+                  Ent   : Entity_Id;\n+\n+               begin\n+                  --  Check that the node is a derived type declaration from\n+                  --  a numeric type.\n+\n+                  if Nkind (T_Def) /= N_Derived_Type_Definition then\n+                     return False;\n+                  else\n+                     Ent := Entity (Subtype_Indication (T_Def));\n+\n+                     if Is_Numeric_Type (Ent) then\n+                        return True;\n+                     else\n+                        return False;\n+                     end if;\n+                  end if;\n+               end;\n+\n+            when others => return False;\n+         end case;\n+      end Derived_From_Numeric_Type;\n+\n+      -----------------------------------\n+      -- Check_Dimension_System_Syntax --\n+      -----------------------------------\n+\n+      --  Check that the expression of aspect Dimension_System is an aggregate\n+      --  which contains pairs of identifier and string or character literal.\n+\n+      function Check_Dimension_System_Syntax (N : Node_Id) return Boolean is\n+         Dim_Node : Node_Id;\n+         Expr_Dim : Node_Id;\n+      begin\n+         --  Chek that the aggregate is a positional array\n+\n+         if Present (Component_Associations (N)) then\n+            return False;\n+         else\n+            Dim_Node := First (Expressions (N));\n+\n+            --  Check that each component of the aggregate is an aggregate\n+\n+            while Present (Dim_Node) loop\n+\n+               --  Verify that the aggregate is a pair of identifier and string\n+               --  or character literal.\n+\n+               if Nkind (Dim_Node) = N_Aggregate then\n+                  if not Present (Expressions (Dim_Node)) then\n+                     return False;\n+                  end if;\n+\n+                  if Present (Component_Associations (Dim_Node)) then\n+                     return False;\n+                  end if;\n+\n+                  --  First expression in the aggregate\n+\n+                  Expr_Dim := First (Expressions (Dim_Node));\n+\n+                  if Nkind (Expr_Dim) /= N_Identifier then\n+                     return False;\n+                  end if;\n+\n+                  --  Second expression in the aggregate\n+\n+                  Next (Expr_Dim);\n+\n+                  if not Nkind_In (Expr_Dim,\n+                                   N_String_Literal,\n+                                   N_Character_Literal)\n+                  then\n+                     return False;\n+                  end if;\n+\n+                  --  If the aggregate has a third expression, return False\n+\n+                  Next (Expr_Dim);\n+\n+                  if Present (Expr_Dim) then\n+                     return False;\n+                  end if;\n+               else\n+                  return False;\n+               end if;\n+\n+               Next (Dim_Node);\n+            end loop;\n+\n+            return True;\n+         end if;\n+      end Check_Dimension_System_Syntax;\n+\n+      --------------------------------\n+      -- Check_Number_Of_Dimensions --\n+      --------------------------------\n+\n+      function Check_Number_Of_Dimensions (Expr : Node_Id) return Boolean is\n+         List_Expr : constant List_Id := Expressions (Expr);\n+\n+      begin\n+         if List_Length (List_Expr) < Dim_Id'First\n+           or else List_Length (List_Expr) > Max_Dimensions then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Check_Number_Of_Dimensions;\n+\n+   --  Start of processing for Analyze_Aspect_Dimension_System\n+\n+   begin\n+      Error_Msg_Name_1 := Chars (Id);\n+\n+      --  Syntax checking\n+\n+      if Nkind (Expr) /= N_Aggregate then\n+         Error_Msg_N (\"wrong syntax for aspect%\", Expr);\n+         return;\n+      end if;\n+\n+      if not Derived_From_Numeric_Type (N) then\n+         Error_Msg_N (\"aspect% only apply for type derived from numeric type\",\n+                      Id);\n+         return;\n+      end if;\n+\n+      if not Check_Dimension_System_Syntax (Expr) then\n+         Error_Msg_N (\"wrong syntax for aspect%\", Expr);\n+         return;\n+      end if;\n+\n+      if not Check_Number_Of_Dimensions (Expr) then\n+         Error_Msg_N (\"wrong number of dimensions for aspect%\", Expr);\n+         return;\n+      end if;\n+\n+      --  Number of dimensions in the system\n+\n+      N_Of_Dims := List_Length (Expressions (Expr));\n+\n+      --  Create the new dimension system\n+\n+      D_Sys.Base_Type := N;\n+      Dim_Node := First (Expressions (Expr));\n+\n+      for Dim in Dim_Id'First .. N_Of_Dims loop\n+         Dim_Name := First (Expressions (Dim_Node));\n+         Names (Dim) := Chars (Dim_Name);\n+         Dim_Symbol := Next (Dim_Name);\n+\n+         --  N_Character_Literal case\n+\n+         if Nkind (Dim_Symbol) = N_Character_Literal then\n+            Start_String;\n+            Store_String_Char (UI_To_CC (Char_Literal_Value (Dim_Symbol)));\n+            Symbols (Dim) := End_String;\n+\n+         --  N_String_Literal case\n+\n+         else\n+            Symbols (Dim) := Strval (Dim_Symbol);\n+         end if;\n+\n+         Next (Dim_Node);\n+      end loop;\n+\n+      D_Sys.Names     := Names;\n+      D_Sys.N_Of_Dims := N_Of_Dims;\n+      D_Sys.Symbols   := Symbols;\n+\n+      --  Store the dimension system in the Table\n+\n+      Dim_Systems.Append (D_Sys);\n+   end Analyze_Aspect_Dimension_System;\n+\n+   -----------------------\n+   -- Analyze_Dimension --\n+   -----------------------\n+\n+   --  This dispatch routine propagates dimensions for each node\n+\n+   procedure Analyze_Dimension (N : Node_Id) is\n+   begin\n+      --  Aspect is an Ada 2012 feature\n+\n+      if Ada_Version < Ada_2012 then\n+         return;\n+      end if;\n+\n+      case Nkind (N) is\n+\n+         when N_Assignment_Statement =>\n+            Analyze_Dimension_Assignment_Statement (N);\n+\n+         when N_Subtype_Declaration =>\n+            Analyze_Dimension_Subtype_Declaration (N);\n+\n+         when N_Object_Declaration =>\n+            Analyze_Dimension_Object_Declaration (N);\n+\n+         when N_Object_Renaming_Declaration =>\n+            Analyze_Dimension_Object_Renaming_Declaration (N);\n+\n+         when N_Component_Declaration =>\n+            Analyze_Dimension_Component_Declaration (N);\n+\n+         when N_Binary_Op =>\n+            Analyze_Dimension_Binary_Op (N);\n+\n+         when N_Unary_Op =>\n+            Analyze_Dimension_Unary_Op (N);\n+\n+         when N_Identifier =>\n+            Analyze_Dimension_Identifier (N);\n+\n+         when N_Attribute_Reference       |\n+              N_Indexed_Component         |\n+              N_Qualified_Expression      |\n+              N_Selected_Component        |\n+              N_Slice                     |\n+              N_Type_Conversion           |\n+              N_Unchecked_Type_Conversion =>\n+            Analyze_Dimension_Has_Etype (N);\n+\n+         when N_Function_Call =>\n+            Analyze_Dimension_Function_Call (N);\n+\n+         when N_Extended_Return_Statement =>\n+            Analyze_Dimension_Extended_Return_Statement (N);\n+\n+         when N_Simple_Return_Statement =>\n+            Analyze_Dimension_Simple_Return_Statement (N);\n+\n+         when others => null;\n+\n+      end case;\n+   end Analyze_Dimension;\n+\n+   --------------------------------------------\n+   -- Analyze_Dimension_Assignment_Statement --\n+   --------------------------------------------\n+\n+   procedure Analyze_Dimension_Assignment_Statement (N : Node_Id) is\n+      Lhs     : constant Node_Id    := Name (N);\n+      Dim_Lhs : constant Dimensions := Get_Dimensions (Lhs);\n+      Rhs     : constant Node_Id    := Expression (N);\n+      Dim_Rhs : constant Dimensions := Get_Dimensions (Rhs);\n+\n+      procedure Analyze_Dimensions_In_Assignment\n+        (Dim_Lhs : Dimensions;\n+         Dim_Rhs : Dimensions);\n+      --  Subroutine to perform the dimensionnality checking for assignment\n+\n+      --------------------------------------\n+      -- Analyze_Dimensions_In_Assignment --\n+      --------------------------------------\n+\n+      procedure Analyze_Dimensions_In_Assignment\n+        (Dim_Lhs : Dimensions;\n+         Dim_Rhs : Dimensions)\n+      is\n+      begin\n+         --  Check the lhs and the rhs have the same dimension\n+\n+         if not Present (Dim_Lhs) then\n+\n+            if Present (Dim_Rhs) then\n+               Error_Msg_N (\"?dimensions missmatch in assignment\", N);\n+            end if;\n+         else\n+\n+            if Dim_Lhs /= Dim_Rhs then\n+               Error_Msg_N (\"?dimensions missmatch in assignment\", N);\n+            end if;\n+\n+         end if;\n+      end Analyze_Dimensions_In_Assignment;\n+\n+   --  Start of processing for Analyze_Dimension_Assignment\n+\n+   begin\n+      Analyze_Dimensions_In_Assignment (Dim_Lhs, Dim_Rhs);\n+   end Analyze_Dimension_Assignment_Statement;\n+\n+   ---------------------------------\n+   -- Analyze_Dimension_Binary_Op --\n+   ---------------------------------\n+\n+   procedure Analyze_Dimension_Binary_Op (N : Node_Id) is\n+      N_Kind : constant Node_Kind := Nkind (N);\n+\n+   begin\n+      if Nkind_In (N_Kind, N_Op_Add, N_Op_Expon, N_Op_Subtract)\n+        or else N_Kind in N_Multiplying_Operator\n+        or else N_Kind in N_Op_Compare\n+      then\n+         declare\n+            L                 : constant Node_Id := Left_Opnd (N);\n+            L_Dims            : constant Dimensions := Get_Dimensions (L);\n+            L_Has_Dimensions  : constant Boolean := Present (L_Dims);\n+            R                 : constant Node_Id := Right_Opnd (N);\n+            R_Dims            : constant Dimensions := Get_Dimensions (R);\n+            R_Has_Dimensions  : constant Boolean := Present (R_Dims);\n+            Dims              : Dimensions := Zero_Dimensions;\n+\n+         begin\n+\n+            if Nkind_In (N, N_Op_Add, N_Op_Mod, N_Op_Rem, N_Op_Subtract) then\n+               Error_Msg_Name_1 := Chars (N);\n+\n+               --  Check both operands dimension\n+\n+               if L_Has_Dimensions and R_Has_Dimensions then\n+\n+                  --  If dimensions missmatch\n+\n+                  if L_Dims /= R_Dims then\n+                     Error_Msg_N\n+                       (\"?both operands for operation% must have same \" &\n+                        \"dimension\", N);\n+                  else\n+                     Set_Dimensions (N, L_Dims);\n+                  end if;\n+\n+               elsif not L_Has_Dimensions and R_Has_Dimensions then\n+                  Error_Msg_N\n+                    (\"?both operands for operation% must have same dimension\",\n+                     N);\n+\n+               elsif L_Has_Dimensions and not R_Has_Dimensions then\n+                  Error_Msg_N\n+                    (\"?both operands for operation% must have same dimension\",\n+                     N);\n+\n+               end if;\n+\n+            elsif Nkind_In (N_Kind, N_Op_Multiply, N_Op_Divide) then\n+\n+               if L_Has_Dimensions and R_Has_Dimensions then\n+\n+                  --  Get both operands dimension and add them\n+\n+                  if N_Kind = N_Op_Multiply then\n+                     for Dim in Dimensions'Range loop\n+                        Dims (Dim) := L_Dims (Dim) + R_Dims (Dim);\n+                     end loop;\n+\n+                  --  Get both operands dimension and subtract them\n+\n+                  else\n+                     for Dim in Dimensions'Range loop\n+                        Dims (Dim) := L_Dims (Dim) - R_Dims (Dim);\n+                     end loop;\n+                  end if;\n+\n+               elsif L_Has_Dimensions and not R_Has_Dimensions then\n+                  Dims := L_Dims;\n+\n+               elsif not L_Has_Dimensions and R_Has_Dimensions then\n+\n+                  if N_Kind = N_Op_Multiply then\n+                     Dims := R_Dims;\n+                  else\n+                     for Dim in R_Dims'Range loop\n+                        Dims (Dim) := -R_Dims (Dim);\n+                     end loop;\n+                  end if;\n+               end if;\n+\n+               if Present (Dims) then\n+                  Set_Dimensions (N, Dims);\n+               end if;\n+\n+            --  N_Op_Expon\n+            --  Propagation of the dimension and evaluation of the result if\n+            --  the exponent is a rational and if the operand has a dimension.\n+\n+            elsif N_Kind = N_Op_Expon then\n+               declare\n+                  Rat : Rational := Zero_Rational;\n+\n+               begin\n+                  --  Check exponent is dimensionless\n+\n+                  if R_Has_Dimensions then\n+                     Error_Msg_N\n+                      (\"?right operand cannot have a dimension for&\",\n+                       Identifier (N));\n+\n+                  else\n+                     --  Check the left operand is not dimensionless\n+\n+                     --  Note that the value of the exponent must be know at\n+                     --  compile time. Otherwise, the exponentiation evaluation\n+                     --  will return an error message.\n+\n+                     if Get_Dimension_System_Id\n+                          (Base_Type (Etype (L))) /= No_Dim_Sys\n+                       and then Compile_Time_Known_Value (R)\n+                     then\n+                        --  Real exponent case\n+\n+                        if Is_Real_Type (Etype (L)) then\n+                           --  Define the exponent as a Rational number\n+\n+                           Create_Rational_From_Expr (R, Rat);\n+\n+                           if L_Has_Dimensions then\n+                              for Dim in Dimensions'Range loop\n+                                 Dims (Dim) := L_Dims (Dim) * Rat;\n+                              end loop;\n+\n+                              if Present (Dims) then\n+                                 Set_Dimensions (N, Dims);\n+                              end if;\n+                           end if;\n+\n+                           --  Evaluate the operator with rational exponent\n+\n+                           --  Eval_Op_Expon_With_Rational_Exponent (N, Rat);\n+\n+                        --  Integer exponent case\n+\n+                        else\n+                           for Dim in Dimensions'Range loop\n+                              Dims (Dim) :=\n+                                L_Dims (Dim) *\n+                                 Whole (UI_To_Int (Expr_Value (R)));\n+                           end loop;\n+\n+                           if Present (Dims) then\n+                              Set_Dimensions (N, Dims);\n+                           end if;\n+                        end if;\n+                     end if;\n+                  end if;\n+               end;\n+\n+            --  For relational operations, only a dimension checking is\n+            --  performed.\n+            --  No propagation\n+\n+            elsif N_Kind in N_Op_Compare then\n+               Error_Msg_Name_1 := Chars (N);\n+\n+               if (L_Has_Dimensions or R_Has_Dimensions)\n+                  and then L_Dims /= R_Dims\n+               then\n+                  Error_Msg_N\n+                    (\"?both operands for operation% must have same dimension\",\n+                     N);\n+               end if;\n+            end if;\n+\n+            Remove_Dimensions (L);\n+            Remove_Dimensions (R);\n+         end;\n+      end if;\n+   end Analyze_Dimension_Binary_Op;\n+\n+   ---------------------------------------------\n+   -- Analyze_Dimension_Component_Declaration --\n+   ---------------------------------------------\n+\n+   procedure Analyze_Dimension_Component_Declaration (N : Node_Id) is\n+      Expr   : constant Node_Id   := Expression (N);\n+      Id     : constant Entity_Id := Defining_Identifier (N);\n+      E_Typ  : constant Entity_Id := Etype (Id);\n+      Dim_T  : constant Dimensions := Get_Dimensions (E_Typ);\n+      Dim_E  : Dimensions;\n+\n+   begin\n+      if Present (Dim_T) then\n+\n+         --  If the component type has a dimension and there is no expression,\n+         --  propagates the dimension.\n+\n+         if Present (Expr) then\n+            Dim_E := Get_Dimensions (Expr);\n+\n+            if Present (Dim_E) then\n+               --  Return an error if the dimension of the expression and the\n+               --  dimension of the type missmatch.\n+\n+               if Dim_E /= Dim_T then\n+                  Error_Msg_N (\"?dimensions missmatch in object \" &\n+                               \"declaration\", N);\n+               end if;\n+\n+            --  If the expression is dimensionless\n+\n+            else\n+               Error_Msg_N\n+                 (\"?dimensions missmatch in component declaration\", N);\n+            end if;\n+\n+         --  For every other cases, propagate the dimensions\n+\n+         else\n+            Copy_Dimensions (E_Typ, Id);\n+         end if;\n+      end if;\n+   end Analyze_Dimension_Component_Declaration;\n+\n+   -------------------------------------------------\n+   -- Analyze_Dimension_Extended_Return_Statement --\n+   -------------------------------------------------\n+\n+   procedure Analyze_Dimension_Extended_Return_Statement (N : Node_Id) is\n+      Obj_Decls : constant List_Id := Return_Object_Declarations (N);\n+      R_Ent     : constant Entity_Id := Return_Statement_Entity (N);\n+      R_Etyp    : constant Entity_Id := Etype (Return_Applies_To (R_Ent));\n+      Dims_R    : constant Dimensions := Get_Dimensions (R_Etyp);\n+      Dims_Obj  : Dimensions;\n+      Obj_Decl  : Node_Id;\n+      Obj_Id    : Entity_Id;\n+\n+   begin\n+      if Present (Obj_Decls) then\n+         Obj_Decl := First (Obj_Decls);\n+\n+         while Present (Obj_Decl) loop\n+            if Nkind (Obj_Decl) = N_Object_Declaration then\n+               Obj_Id := Defining_Identifier (Obj_Decl);\n+\n+               if Is_Return_Object (Obj_Id) then\n+                  Dims_Obj := Get_Dimensions (Obj_Id);\n+\n+                  if Dims_R /= Dims_Obj then\n+                     Error_Msg_N (\"?dimensions missmatch in return statement\",\n+                                  N);\n+                     return;\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next (Obj_Decl);\n+         end loop;\n+      end if;\n+   end Analyze_Dimension_Extended_Return_Statement;\n+\n+   -------------------------------------\n+   -- Analyze_Dimension_Function_Call --\n+   -------------------------------------\n+\n+   procedure Analyze_Dimension_Function_Call (N : Node_Id) is\n+      Name_Call  : constant Node_Id := Name (N);\n+      Par_Ass    : constant List_Id := Parameter_Associations (N);\n+      Dims       : Dimensions;\n+      Dims_Param : Dimensions;\n+      Param      : Node_Id;\n+\n+      function Is_Elementary_Function_Call (N : Node_Id) return Boolean;\n+      --  Return True if the call is a call of an elementary function (see\n+      --  Ada.Numerics.Generic_Elementary_Functions).\n+\n+      ---------------------------------\n+      -- Is_Elementary_Function_Call --\n+      ---------------------------------\n+\n+      function Is_Elementary_Function_Call (N : Node_Id) return Boolean is\n+         Ent : Entity_Id;\n+\n+      begin\n+         --  Note that the node must come from source\n+\n+         if Comes_From_Source (N)\n+           and then Is_Entity_Name (Name_Call)\n+         then\n+            Ent := Entity (Name_Call);\n+\n+            --  Check the procedure is defined in an instantiation of a generic\n+            --  package.\n+\n+            if Is_Generic_Instance (Scope (Ent)) then\n+               Ent := Cunit_Entity (Get_Source_Unit (Ent));\n+\n+               --  Check the name of the generic package is\n+               --  Generic_Elementary_Functions\n+\n+               if Is_Library_Level_Entity (Ent)\n+                 and then Chars (Ent) = Name_Generic_Elementary_Functions\n+               then\n+                  return True;\n+               end if;\n+            end if;\n+         end if;\n+\n+         return False;\n+      end Is_Elementary_Function_Call;\n+\n+   --  Start of processing for Analyze_Dimension_Function_Call\n+\n+   begin\n+      --  Elementary function case\n+\n+      if Is_Elementary_Function_Call (N) then\n+\n+         --  Sqrt function call case\n+\n+         if Chars (Name_Call) = Name_Sqrt then\n+            Dims := Get_Dimensions (First (Par_Ass));\n+\n+            if Present (Dims) then\n+               for Dim in Dims'Range loop\n+                  Dims (Dim) := Dims (Dim) * (1, 2);\n+               end loop;\n+\n+               Set_Dimensions (N, Dims);\n+            end if;\n+\n+         --  All other functions in Ada.Numerics.Generic_Elementary_Functions\n+         --  Note that all parameters here should be dimensionless\n+\n+         else\n+            Param := First (Par_Ass);\n+\n+            while Present (Param) loop\n+               Dims_Param := Get_Dimensions (Param);\n+\n+               if Present (Dims_Param) then\n+                  Error_Msg_Name_1 := Chars (Name_Call);\n+                  Error_Msg_N\n+                    (\"?parameter should be dimensionless for elementary \" &\n+                     \"function%\",\n+                      Param);\n+                  return;\n+               end if;\n+\n+               Next (Param);\n+            end loop;\n+         end if;\n+\n+      --  General case\n+\n+      else\n+         Analyze_Dimension_Has_Etype (N);\n+      end if;\n+   end Analyze_Dimension_Function_Call;\n+\n+   ---------------------------------\n+   -- Analyze_Dimension_Has_Etype --\n+   ---------------------------------\n+\n+   procedure Analyze_Dimension_Has_Etype (N : Node_Id) is\n+      E_Typ  : constant Entity_Id := Etype (N);\n+      Dims   : constant Dimensions := Get_Dimensions (E_Typ);\n+      N_Kind : constant Node_Kind := Nkind (N);\n+\n+   begin\n+      --  Propagation of the dimensions from the type\n+\n+      if Present (Dims) then\n+         Set_Dimensions (N, Dims);\n+      end if;\n+\n+      --  Removal of dimensions in expression\n+\n+      if Nkind_In (N_Kind, N_Attribute_Reference, N_Indexed_Component) then\n+         declare\n+            Expr  : Node_Id;\n+            Exprs : constant List_Id := Expressions (N);\n+\n+         begin\n+            if Present (Exprs) then\n+               Expr := First (Exprs);\n+\n+               while Present (Expr) loop\n+                  Remove_Dimensions (Expr);\n+                  Next (Expr);\n+               end loop;\n+            end if;\n+         end;\n+\n+      elsif Nkind_In\n+              (N_Kind,\n+                 N_Qualified_Expression,\n+                 N_Type_Conversion,\n+                 N_Unchecked_Type_Conversion)\n+      then\n+         Remove_Dimensions (Expression (N));\n+\n+      elsif N_Kind = N_Selected_Component then\n+         Remove_Dimensions (Selector_Name (N));\n+      end if;\n+   end Analyze_Dimension_Has_Etype;\n+\n+   ----------------------------------\n+   -- Analyze_Dimension_Identifier --\n+   ----------------------------------\n+\n+   procedure Analyze_Dimension_Identifier (N : Node_Id) is\n+      Ent  : constant Entity_Id := Entity (N);\n+      Dims : constant Dimensions := Get_Dimensions (Ent);\n+\n+   begin\n+      if Present (Dims) then\n+         Set_Dimensions (N, Dims);\n+      else\n+         Analyze_Dimension_Has_Etype (N);\n+      end if;\n+   end Analyze_Dimension_Identifier;\n+\n+   ------------------------------------------\n+   -- Analyze_Dimension_Object_Declaration --\n+   ------------------------------------------\n+\n+   procedure Analyze_Dimension_Object_Declaration (N : Node_Id) is\n+      Expr   : constant Node_Id   := Expression (N);\n+      Id     : constant Entity_Id := Defining_Identifier (N);\n+      E_Typ  : constant Entity_Id := Etype (Id);\n+      Dim_T  : constant Dimensions := Get_Dimensions (E_Typ);\n+      Dim_E  : Dimensions;\n+\n+   begin\n+      if Present (Dim_T) then\n+         --  Expression is present\n+\n+         if Present (Expr) then\n+            Dim_E := Get_Dimensions (Expr);\n+\n+            if Present (Dim_E) then\n+               --  Return an error if the dimension of the expression and the\n+               --  dimension of the type missmatch.\n+\n+               if Dim_E /= Dim_T then\n+                  Error_Msg_N (\"?dimensions missmatch in object \" &\n+                               \"declaration\", N);\n+               end if;\n+\n+            --  If the expression is dimensionless\n+\n+            else\n+               --  If the node is not a real constant or an integer constant\n+               --  (depending on the dimensioned numeric type), return an error\n+               --  message.\n+\n+               if not Nkind_In\n+                        (Original_Node (Expr),\n+                         N_Real_Literal,\n+                         N_Integer_Literal)\n+               then\n+                  Error_Msg_N (\"?dimensions missmatch in object \" &\n+                               \"declaration\", N);\n+               end if;\n+            end if;\n+\n+         --  For every other cases, propagate the dimensions\n+\n+         else\n+            Copy_Dimensions (E_Typ, Id);\n+         end if;\n+      end if;\n+   end Analyze_Dimension_Object_Declaration;\n+\n+   ---------------------------------------------------\n+   -- Analyze_Dimension_Object_Renaming_Declaration --\n+   ---------------------------------------------------\n+\n+   procedure Analyze_Dimension_Object_Renaming_Declaration (N : Node_Id) is\n+      Id       : constant Entity_Id := Defining_Identifier (N);\n+      Ren_Id   : constant Node_Id   := Name (N);\n+      E_Typ    : constant Entity_Id := Etype (Ren_Id);\n+      Dims_Typ : constant Dimensions := Get_Dimensions (E_Typ);\n+\n+   begin\n+      if Present (Dims_Typ) then\n+         Copy_Dimensions (E_Typ, Id);\n+      end if;\n+   end Analyze_Dimension_Object_Renaming_Declaration;\n+\n+   -----------------------------------------------\n+   -- Analyze_Dimension_Simple_Return_Statement --\n+   -----------------------------------------------\n+\n+   procedure Analyze_Dimension_Simple_Return_Statement (N : Node_Id) is\n+      Expr      : constant Node_Id := Expression (N);\n+      Dims_Expr : constant Dimensions := Get_Dimensions (Expr);\n+      R_Ent     : constant Entity_Id := Return_Statement_Entity (N);\n+      R_Etyp    : constant Entity_Id := Etype (Return_Applies_To (R_Ent));\n+      Dims_R    : constant Dimensions := Get_Dimensions (R_Etyp);\n+\n+   begin\n+      if Dims_R /= Dims_Expr then\n+         Error_Msg_N (\"?dimensions missmatch in return statement\", N);\n+         Remove_Dimensions (Expr);\n+      end if;\n+   end Analyze_Dimension_Simple_Return_Statement;\n+\n+   -------------------------------------------\n+   -- Analyze_Dimension_Subtype_Declaration --\n+   -------------------------------------------\n+\n+   procedure Analyze_Dimension_Subtype_Declaration (N : Node_Id) is\n+      Ent      : constant Entity_Id := Defining_Identifier (N);\n+      Dims_Ent : constant Dimensions := Get_Dimensions (Ent);\n+      E_Typ    : Node_Id;\n+\n+   begin\n+      if Nkind (Subtype_Indication (N)) /= N_Subtype_Indication then\n+         E_Typ := Etype (Subtype_Indication (N));\n+         declare\n+            Dims_Typ : constant Dimensions := Get_Dimensions (E_Typ);\n+\n+         begin\n+            if Present (Dims_Typ) then\n+\n+               --  If the subtype already has a dimension (from\n+               --  Aspect_Dimension), it cannot inherit a dimension from its\n+               --  subtype.\n+\n+               if Present (Dims_Ent) then\n+                  Error_Msg_N (\"?subtype& already has a dimension\", N);\n+\n+               else\n+                  Set_Dimensions (Ent, Dims_Typ);\n+                  Set_Dimensions_String_Id\n+                    (Ent, Get_Dimensions_String_Id (E_Typ));\n+               end if;\n+            end if;\n+         end;\n+\n+      else\n+         E_Typ := Etype (Subtype_Mark (Subtype_Indication (N)));\n+         declare\n+            Dims_Typ : constant Dimensions := Get_Dimensions (E_Typ);\n+\n+         begin\n+            if Present (Dims_Typ) then\n+\n+               --  If the subtype already has a dimension (from\n+               --  Aspect_Dimension), it cannot inherit a dimension from its\n+               --  subtype.\n+\n+               if Present (Dims_Ent) then\n+                  Error_Msg_N (\"?subtype& already has a dimension\", N);\n+\n+               else\n+                  Set_Dimensions (Ent, Dims_Typ);\n+                  Set_Dimensions_String_Id\n+                    (Ent, Get_Dimensions_String_Id (E_Typ));\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+   end Analyze_Dimension_Subtype_Declaration;\n+\n+   --------------------------------\n+   -- Analyze_Dimension_Unary_Op --\n+   --------------------------------\n+\n+   procedure Analyze_Dimension_Unary_Op (N : Node_Id) is\n+   begin\n+      case Nkind (N) is\n+         when N_Op_Plus | N_Op_Minus | N_Op_Abs =>\n+            declare\n+               R : constant Node_Id := Right_Opnd (N);\n+\n+            begin\n+               --  Propagate the dimension if the operand is not dimensionless\n+\n+               Move_Dimensions (R, N);\n+            end;\n+\n+         when others => null;\n+\n+      end case;\n+   end Analyze_Dimension_Unary_Op;\n+\n+   ---------------------\n+   -- Copy_Dimensions --\n+   ---------------------\n+\n+   procedure Copy_Dimensions (From, To : Node_Id) is\n+      Dims : constant Dimensions := Aspect_Dimension_Hash_Table.Get (From);\n+\n+   begin\n+      --  Propagate the dimension from one node to another\n+\n+      pragma Assert (Permits_Dimensions (To));\n+      pragma Assert (Present (Dims));\n+      Aspect_Dimension_Hash_Table.Set (To, Dims);\n+   end Copy_Dimensions;\n+\n+   -------------------------------\n+   -- Create_Rational_From_Expr --\n+   -------------------------------\n+\n+   procedure Create_Rational_From_Expr (Expr : Node_Id; R : in out Rational) is\n+      Or_N         : constant Node_Id := Original_Node (Expr);\n+      Left         : Node_Id;\n+      Left_Int     : Int;\n+      Ltype        : Entity_Id;\n+      Right        : Node_Id;\n+      Right_Int    : Int;\n+      R_Opnd_Minus : Node_Id;\n+      Rtype        : Entity_Id;\n+\n+   begin\n+      --  A rational number is any number that can be expressed as the quotient\n+      --  or fraction a/b of two integers, with the denominator b not equal to\n+      --  zero.\n+\n+      --  Check the expression is either a division of two integers or an\n+      --  integer itself. The check applies to the original node since the\n+      --  node could have already been rewritten.\n+\n+      --  Numerator is positive\n+\n+      if Nkind (Or_N) = N_Op_Divide then\n+         Left  := Left_Opnd (Or_N);\n+         Ltype := Etype (Left);\n+         Right := Right_Opnd (Or_N);\n+         Rtype := Etype (Right);\n+\n+         if Is_Integer_Type (Ltype)\n+           and then Is_Integer_Type (Rtype)\n+         then\n+            Left_Int  := UI_To_Int (Expr_Value (Left));\n+            Right_Int := UI_To_Int (Expr_Value (Right));\n+\n+            --  Verify that the denominator of the rational is positive\n+\n+            if Right_Int > 0 then\n+\n+               if Left_Int mod Right_Int = 0 then\n+                  R := +Whole (UI_To_Int (Expr_Value (Expr)));\n+               else\n+                  R := Whole (Left_Int) / Whole (Right_Int);\n+               end if;\n+\n+            else\n+               Error_Msg_N\n+                 (\"denominator in a rational number must be positive\", Right);\n+            end if;\n+\n+         else\n+            Error_Msg_N (\"must be a rational\", Expr);\n+         end if;\n+\n+      --  Numerator is negative\n+\n+      elsif Nkind (Or_N) = N_Op_Minus\n+        and then Nkind (Original_Node (Right_Opnd (Or_N))) = N_Op_Divide\n+      then\n+         R_Opnd_Minus := Original_Node (Right_Opnd (Or_N));\n+         Left  := Left_Opnd (R_Opnd_Minus);\n+         Ltype := Etype (Left);\n+         Right := Right_Opnd (R_Opnd_Minus);\n+         Rtype := Etype (Right);\n+\n+         if Is_Integer_Type (Ltype)\n+           and then Is_Integer_Type (Rtype)\n+         then\n+            Left_Int  := UI_To_Int (Expr_Value (Left));\n+            Right_Int := UI_To_Int (Expr_Value (Right));\n+\n+            --  Verify that the denominator of the rational is positive\n+\n+            if Right_Int > 0 then\n+\n+               if Left_Int mod Right_Int = 0 then\n+                  R := +Whole (-UI_To_Int (Expr_Value (Expr)));\n+               else\n+                  R := Whole (-Left_Int) / Whole (Right_Int);\n+               end if;\n+\n+            else\n+               Error_Msg_N\n+                 (\"denominator in a rational number must be positive\", Right);\n+            end if;\n+\n+         else\n+            Error_Msg_N (\"must be a rational\", Expr);\n+         end if;\n+\n+      --  Integer case\n+\n+      else\n+         if Is_Integer_Type (Etype (Expr)) then\n+            Right_Int := UI_To_Int (Expr_Value (Expr));\n+            R         :=  +Whole (Right_Int);\n+         else\n+            Error_Msg_N (\"must be a rational\", Expr);\n+         end if;\n+      end if;\n+   end Create_Rational_From_Expr;\n+\n+   ----------------------------------------\n+   -- Eval_Op_Expon_For_Dimensioned_Type --\n+   ----------------------------------------\n+\n+   --  Eval the expon operator for dimensioned type\n+\n+   --  Note that if the exponent is an integer (denominator equals to 1) the\n+   --  node is not evaluated here and must be evaluated by the Eval_Op_Expon\n+   --  routine.\n+\n+   procedure Eval_Op_Expon_For_Dimensioned_Type\n+     (N : Node_Id;\n+      B_Typ : Entity_Id)\n+   is\n+      R   : constant Node_Id := Right_Opnd (N);\n+      Rat : Rational := Zero_Rational;\n+\n+   begin\n+      if Compile_Time_Known_Value (R)\n+        and then Is_Real_Type (B_Typ)\n+      then\n+         Create_Rational_From_Expr (R, Rat);\n+         Eval_Op_Expon_With_Rational_Exponent (N, Rat);\n+      end if;\n+   end Eval_Op_Expon_For_Dimensioned_Type;\n+\n+   ------------------------------------------\n+   -- Eval_Op_Expon_With_Rational_Exponent --\n+   ------------------------------------------\n+\n+   --  For dimensioned operand in exponentiation, exponent is allowed to be a\n+   --  Rational and not only an Integer like for dimensionless operands. For\n+   --  that particular case, the left operand is rewritten as a function call\n+   --  using the function Expon_LLF from s-llflex.ads.\n+\n+   procedure Eval_Op_Expon_With_Rational_Exponent\n+     (N   : Node_Id;\n+      Rat : Rational)\n+   is\n+      Dims         : constant Dimensions := Get_Dimensions (N);\n+      L            : constant Node_Id := Left_Opnd (N);\n+      Etyp         : constant Entity_Id := Etype (L);\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Actual_1     : Node_Id;\n+      Actual_2     : Node_Id;\n+      Base_Typ     : Entity_Id;\n+      Dim_Value    : Rational;\n+      List_Of_Dims : List_Id;\n+      New_Aspect   : Node_Id;\n+      New_Aspects  : List_Id;\n+      New_E        : Entity_Id;\n+      New_N        : Node_Id;\n+      New_Typ_L    : Node_Id;\n+      Sys          : Dim_Sys_Id;\n+\n+   begin\n+      --  If Rat.Denominator = 1 that means the exponent is an Integer so\n+      --  nothing has to be changed.\n+      --  Note that the node must come from source\n+\n+      if Comes_From_Source (N)\n+        and then Rat.Denominator /= 1\n+      then\n+         Base_Typ := Base_Type (Etyp);\n+\n+         --  Case when the operand is not dimensionless\n+\n+         if Present (Dims) then\n+\n+            --  Get the corresponding Dim_Sys_Id to know the exact number of\n+            --  dimensions in the system.\n+\n+            Sys := Get_Dimension_System_Id (Base_Typ);\n+\n+            --  Step 1: Generation of a new subtype with the proper dimensions\n+\n+            --  In order to rewrite the operator as a function call, a new\n+            --  subtype with an aspect dimension using the dimensions of the\n+            --  node has to be created.\n+\n+            --  Generate:\n+\n+            --  Base_Typ  : constant Entity_Id := Base_Type (Etyp);\n+            --  Sys       : constant Dim_Sys_Id :=\n+            --               Get_Dimension_System_Id (Base_Typ);\n+            --  N_Dims    : constant N_Of_Dimensions :=\n+            --               Dim_Systems.Table (Sys).N_Of_Dims;\n+            --  Dim_Value : Rational;\n+\n+            --  Aspect_Dim_Expr : List;\n+\n+            --  Append (\"\", Aspect_Dim_Expr);\n+\n+            --  for Dim in Dims'First .. N_Dims loop\n+            --     Dim_Value := Dims (Dim);\n+            --     if Dim_Value.Denominator /= 1 then\n+            --        Append (Dim_Value.Numerator / Dim_Value.Denominator,\n+            --                Aspect_Dim_Expr);\n+            --     else\n+            --        Append (Dim_Value.Numerator, Aspect_Dim_Expr);\n+            --     end if;\n+            --  end loop;\n+\n+            --  subtype T is Base_Typ with Dimension => Aspect_Dim_Expr;\n+\n+            --  Step 1a: Generate the aggregate for the new Aspect_dimension\n+\n+            New_Aspects  := Empty_List;\n+            List_Of_Dims := New_List;\n+\n+            Append (Make_String_Literal (Loc, No_String), List_Of_Dims);\n+\n+            for Dim in Dims'First .. Dim_Systems.Table (Sys).N_Of_Dims loop\n+               Dim_Value := Dims (Dim);\n+               if Dim_Value.Denominator /= 1 then\n+                  Append (\n+                     Make_Op_Divide (Loc,\n+                       Left_Opnd  =>\n+                         Make_Integer_Literal (Loc,\n+                           Int (Dim_Value.Numerator)),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc,\n+                           Int (Dim_Value.Denominator))),\n+                     List_Of_Dims);\n+               else\n+                  Append (\n+                    Make_Integer_Literal (Loc,\n+                      Int (Dim_Value.Numerator)),\n+                    List_Of_Dims);\n+               end if;\n+            end loop;\n+\n+            --  Step 1b: Create the new Aspect_Dimension\n+\n+            New_Aspect :=\n+              Make_Aspect_Specification (Loc,\n+                Identifier =>\n+                  Make_Identifier (Loc, Name_Dimension),\n+                Expression =>\n+                  Make_Aggregate (Loc,\n+                    Expressions => List_Of_Dims));\n+\n+            --  Step 1c: New identifier for the subtype\n+\n+            New_E := Make_Temporary (Loc, 'T');\n+            Set_Is_Internal (New_E);\n+\n+            --  Step 1d: Declaration of the new subtype\n+\n+            New_Typ_L :=\n+               Make_Subtype_Declaration (Loc,\n+                  Defining_Identifier => New_E,\n+                  Subtype_Indication  =>\n+                     New_Occurrence_Of (Base_Typ, Loc));\n+\n+            Append (New_Aspect, New_Aspects);\n+            Set_Parent (New_Aspects, New_Typ_L);\n+            Set_Aspect_Specifications (New_Typ_L, New_Aspects);\n+\n+            Analyze (New_Typ_L);\n+\n+         --  Case where the operand is dimensionless\n+\n+         else\n+            New_E := Base_Typ;\n+         end if;\n+\n+         --  Step 2: Generation of the function call\n+\n+         --  Generate:\n+\n+         --  Actual_1 := Long_Long_Float (L),\n+\n+         --  Actual_2 := Long_Long_Float (Rat.Numerator) /\n+         --                Long_Long_Float (Rat.Denominator);\n+\n+         --  (T (Expon_LLF (Actual_1, Actual_2)));\n+\n+         --  --  where T is the subtype declared in step 1\n+\n+         --  -- The node is rewritten as a type conversion\n+\n+         --  Step 2a: Creation of the two parameters for function Expon_LLF\n+\n+         Actual_1 :=\n+           Make_Type_Conversion (Loc,\n+             Subtype_Mark => New_Reference_To (Standard_Long_Long_Float, Loc),\n+             Expression   => Relocate_Node (L));\n+\n+         Actual_2 :=\n+           Make_Op_Divide (Loc,\n+             Left_Opnd  =>\n+               Make_Real_Literal (Loc,\n+                 UR_From_Uint (UI_From_Int (Int (Rat.Numerator)))),\n+             Right_Opnd =>\n+               Make_Real_Literal (Loc,\n+                 UR_From_Uint (UI_From_Int (Int (Rat.Denominator)))));\n+\n+         --  Step 2b: New Node N\n+\n+         New_N :=\n+            Make_Type_Conversion (Loc,\n+              Subtype_Mark => New_Reference_To (New_E, Loc),\n+              Expression   =>\n+                Make_Function_Call (Loc,\n+                  Name => New_Reference_To (RTE (RE_Expon_LLF), Loc),\n+                  Parameter_Associations => New_List (\n+                    Actual_1, Actual_2)));\n+\n+         --  Step 3: Rewitten of N\n+\n+         Rewrite (N, New_N);\n+         Set_Etype (N, New_E);\n+         Analyze_And_Resolve (N, New_E);\n+      end if;\n+   end Eval_Op_Expon_With_Rational_Exponent;\n+\n+   -------------------------------------------\n+   -- Expand_Put_Call_With_Dimension_String --\n+   -------------------------------------------\n+\n+   --  For procedure Put defined in System.Dim_Float_IO and\n+   --  System.Dim_Integer_IO, the default string parameter must be rewritten to\n+   --  include the dimension symbols in the output of a dimensioned object.\n+\n+   --  There are two different cases:\n+\n+   --  1) If the parameter is a variable, the default string parameter is\n+   --  replaced by the string defined in the aspect Dimension of the subtype.\n+   --  For instance if the user wants to output a speed:\n+\n+   --  subtype Speed is Mks_Type with Dimension =>\n+   --    (\"speed\", Meter => 1, Second => -1, others => 0);\n+   --  v : Speed := 2.1 * m * s**(-1);\n+\n+   --  Put (v) returns:\n+   --  > 2.1 speed\n+\n+   --  2) If the parameter is an expression, the procedure\n+   --  Expand_Put_Call_With_Dimension_String creates the string (for instance\n+   --  \"m.s**(-1)\") and rewrites the default string parameter of Put with the\n+   --  corresponding the String_Id.\n+\n+   procedure Expand_Put_Call_With_Dimension_String (N : Node_Id) is\n+      Actuals      : constant List_Id := Parameter_Associations (N);\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Name_Call    : constant Node_Id := Name (N);\n+      Actual       : Node_Id;\n+      Base_Typ     : Node_Id;\n+      Char_Pack    : Name_Id;\n+      Dims         : Dimensions;\n+      Etyp         : Entity_Id;\n+      First_Actual : Node_Id;\n+      New_Par_Ass  : List_Id;\n+      New_Str_Lit  : Node_Id;\n+      Sys          : Dim_Sys_Id;\n+\n+      function Is_Procedure_Put_Call (N : Node_Id) return Boolean;\n+      --  Return True if the current call is a call of an instantiation of a\n+      --  procedure Put defined in the package System.Dim_Float_IO and\n+      --  System.Dim_Integer_IO.\n+\n+      function Is_Procedure_Put_Call (N : Node_Id) return Boolean is\n+         Name_Call : constant Node_Id := Name (N);\n+         Ent       : Entity_Id;\n+\n+      begin\n+         --  There are three different Put routine in each generic package\n+         --  Check that the current procedure call is one of them\n+\n+         if Is_Entity_Name (Name_Call) then\n+            Ent := Entity (Name_Call);\n+\n+            --  Check that the name of the procedure is Put\n+\n+            if Chars (Name_Call) /= Name_Put then\n+               return False;\n+            end if;\n+\n+            --  Check the procedure is defined in an instantiation of a\n+            --  generic package.\n+\n+            if Is_Generic_Instance (Scope (Ent)) then\n+               Ent := Cunit_Entity (Get_Source_Unit (Ent));\n+\n+               --  Verify that the generic package is System.Dim_Float_IO or\n+               --  System.Dim_Integer_IO.\n+\n+               if Is_Library_Level_Entity (Ent) then\n+                  Char_Pack := Chars (Ent);\n+\n+                  if Char_Pack = Name_Dim_Float_IO\n+                    or else Char_Pack = Name_Dim_Integer_IO\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+            end if;\n+         end if;\n+\n+         return False;\n+      end Is_Procedure_Put_Call;\n+\n+   --  Start of processing for Expand_Put_Call_With_Dimension_String\n+\n+   begin\n+      if Is_Procedure_Put_Call (N) then\n+\n+         --  Get the first parameter\n+\n+         First_Actual := First (Actuals);\n+\n+         --  Case when the Put routine has four (integer case) or five (float\n+         --  case) parameters.\n+\n+         if List_Length (Actuals) = 5\n+           or else List_Length (Actuals) = 4\n+         then\n+            Actual := Next (First_Actual);\n+\n+            if Nkind (Actual) = N_Parameter_Association then\n+\n+               --  Get the dimensions and the corresponding dimension system\n+               --  from the first actual.\n+\n+               Actual := First_Actual;\n+            end if;\n+\n+         --  Case when the Put routine has six parameters\n+\n+         else\n+            Actual := Next (First_Actual);\n+         end if;\n+\n+         Base_Typ := Base_Type (Etype (Actual));\n+         Sys := Get_Dimension_System_Id (Base_Typ);\n+\n+         if Sys /= No_Dim_Sys then\n+            Dims := Get_Dimensions (Actual);\n+            Etyp := Etype (Actual);\n+\n+            --  Add the string as a suffix of the value if the subtype has a\n+            --  string of dimensions or if the parameter is not dimensionless.\n+\n+            if Present (Dims)\n+              or else Get_Dimensions_String_Id (Etyp) /= No_String\n+            then\n+               New_Par_Ass := New_List;\n+\n+               --  Add to the list First_Actual and Actual if they differ\n+\n+               if Actual /= First_Actual then\n+                  Append (New_Copy (First_Actual), New_Par_Ass);\n+               end if;\n+\n+               Append (New_Copy (Actual), New_Par_Ass);\n+\n+               --  Look to the next parameter\n+\n+               Next (Actual);\n+\n+               --  Check if the type of N is a subtype that has a string of\n+               --  dimensions in Aspect_Dimension_String_Id_Hash_Table.\n+\n+               if Get_Dimensions_String_Id (Etyp) /= No_String then\n+                  Start_String;\n+\n+                  --  Put a space between the value and the dimension\n+\n+                  Store_String_Char (' ');\n+                  Store_String_Chars (Get_Dimensions_String_Id (Etyp));\n+                  New_Str_Lit :=\n+                    Make_String_Literal (Loc, End_String);\n+\n+               --  Rewrite the String_Literal of the second actual with the\n+               --  new String_Id created by the routine\n+               --  From_Dimension_To_String.\n+\n+               else\n+                  New_Str_Lit :=\n+                    Make_String_Literal (Loc,\n+                      From_Dimension_To_String_Id (Dims, Sys));\n+               end if;\n+\n+               Append (New_Str_Lit, New_Par_Ass);\n+\n+               --  Rewrite the procedure call with the new list of parameters\n+\n+               Rewrite (N,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Copy (Name_Call),\n+                   Parameter_Associations => New_Par_Ass));\n+\n+               Analyze (N);\n+            end if;\n+         end if;\n+      end if;\n+   end Expand_Put_Call_With_Dimension_String;\n+\n+   ---------------------------------\n+   -- From_Dimension_To_String_Id --\n+   ---------------------------------\n+\n+   --  Given a dimension vector and the corresponding dimension system, create\n+   --  a String_Id to output the dimension symbols corresponding to the\n+   --  dimensions Dims.\n+\n+   function From_Dimension_To_String_Id\n+     (Dims : Dimensions;\n+      Sys  : Dim_Sys_Id) return String_Id\n+   is\n+      Dim_Rat          : Rational;\n+      First_Dim_In_Str : Boolean := True;\n+\n+   begin\n+      --  Initialization of the new String_Id\n+\n+      Start_String;\n+\n+      --  Put a space between the value and the dimensions\n+\n+      Store_String_Char (' ');\n+\n+      for Dim in Dimensions'Range loop\n+\n+         Dim_Rat := Dims (Dim);\n+         if Dim_Rat /= Zero_Rational then\n+\n+            if First_Dim_In_Str then\n+               First_Dim_In_Str := False;\n+            else\n+               Store_String_Char ('.');\n+            end if;\n+\n+            --  Positive dimension case\n+\n+            if Dim_Rat.Numerator > 0 then\n+\n+               if Dim_Systems.Table (Sys).Symbols (Dim) = No_String then\n+                  Store_String_Chars\n+                    (Get_Name_String (Dim_Systems.Table (Sys).Names (Dim)));\n+               else\n+                  Store_String_Chars (Dim_Systems.Table (Sys).Symbols (Dim));\n+               end if;\n+\n+               --  Integer case\n+\n+               if Dim_Rat.Denominator = 1 then\n+\n+                  if Dim_Rat.Numerator /= 1 then\n+                     Store_String_Chars (\"**\");\n+                     Store_String_Int (Int (Dim_Rat.Numerator));\n+                  end if;\n+\n+               --  Rational case when denominator /= 1\n+\n+               else\n+                  Store_String_Chars (\"**\");\n+                  Store_String_Char ('(');\n+                  Store_String_Int (Int (Dim_Rat.Numerator));\n+                  Store_String_Char ('/');\n+                  Store_String_Int (Int (Dim_Rat.Denominator));\n+                  Store_String_Char (')');\n+               end if;\n+\n+            --  Negative dimension case\n+\n+            else\n+               if Dim_Systems.Table (Sys).Symbols (Dim) = No_String then\n+                  Store_String_Chars\n+                    (Get_Name_String (Dim_Systems.Table (Sys).Names (Dim)));\n+               else\n+                  Store_String_Chars (Dim_Systems.Table (Sys).Symbols (Dim));\n+               end if;\n+\n+               Store_String_Chars (\"**\");\n+               Store_String_Char ('(');\n+               Store_String_Char ('-');\n+               Store_String_Int (Int (-Dim_Rat.Numerator));\n+\n+               --  Integer case\n+\n+               if Dim_Rat.Denominator = 1 then\n+                  Store_String_Char (')');\n+\n+               --  Rational case when denominator /= 1\n+\n+               else\n+                  Store_String_Char ('/');\n+                  Store_String_Int (Int (Dim_Rat.Denominator));\n+                  Store_String_Char (')');\n+               end if;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      return End_String;\n+   end From_Dimension_To_String_Id;\n+\n+   --------------------\n+   -- Get_Dimensions --\n+   --------------------\n+\n+   function Get_Dimensions (N : Node_Id) return Dimensions is\n+   begin\n+      return Aspect_Dimension_Hash_Table.Get (N);\n+   end Get_Dimensions;\n+\n+   ------------------------------\n+   -- Get_Dimensions_String_Id --\n+   ------------------------------\n+\n+   function Get_Dimensions_String_Id (E : Entity_Id) return String_Id is\n+   begin\n+      return Aspect_Dimension_String_Id_Hash_Table.Get (E);\n+   end Get_Dimensions_String_Id;\n+\n+   -----------------------------\n+   -- Get_Dimension_System_Id --\n+   -----------------------------\n+\n+   function Get_Dimension_System_Id (E : Entity_Id) return Dim_Sys_Id is\n+      D_Sys : Dim_Sys_Id := No_Dim_Sys;\n+\n+   begin\n+      --  Scan the Table in order to find N\n+\n+      for Dim_Sys in 1 .. Dim_Systems.Last loop\n+         if Parent (E) = Dim_Systems.Table (Dim_Sys).Base_Type then\n+            D_Sys := Dim_Sys;\n+         end if;\n+      end loop;\n+\n+      return D_Sys;\n+   end Get_Dimension_System_Id;\n+\n+   --------------------------\n+   -- Is_Dimensioned_Type --\n+   --------------------------\n+\n+   function Is_Dimensioned_Type (E : Entity_Id) return Boolean\n+   is\n+   begin\n+      if Get_Dimension_System_Id (E) /= No_Dim_Sys then\n+         return True;\n+      end if;\n+\n+      return False;\n+   end Is_Dimensioned_Type;\n+\n+   ---------------------\n+   -- Move_Dimensions --\n+   ---------------------\n+\n+   procedure Move_Dimensions (From, To : Node_Id) is\n+      Dims : constant Dimensions := Get_Dimensions (From);\n+\n+   begin\n+      --  Copy the dimension of 'From to 'To' and remove the dimension of\n+      --  'From'.\n+\n+      if Present (Dims) then\n+         Set_Dimensions (To, Dims);\n+         Remove_Dimensions (From);\n+      end if;\n+   end Move_Dimensions;\n+\n+   ------------------------\n+   -- Permits_Dimensions --\n+   ------------------------\n+\n+   --  Here is the list of node that permits a dimension\n+\n+   Dimensions_Permission : constant array (Node_Kind) of Boolean :=\n+     (N_Attribute_Reference       => True,\n+      N_Defining_Identifier       => True,\n+      N_Function_Call             => True,\n+      N_Identifier                => True,\n+      N_Indexed_Component         => True,\n+      N_Integer_Literal           => True,\n+\n+      N_Op_Abs                    => True,\n+      N_Op_Add                    => True,\n+      N_Op_Divide                 => True,\n+      N_Op_Expon                  => True,\n+      N_Op_Minus                  => True,\n+      N_Op_Mod                    => True,\n+      N_Op_Multiply               => True,\n+      N_Op_Plus                   => True,\n+      N_Op_Rem                    => True,\n+      N_Op_Subtract               => True,\n+\n+      N_Qualified_Expression      => True,\n+      N_Real_Literal              => True,\n+      N_Selected_Component        => True,\n+      N_Slice                     => True,\n+      N_Type_Conversion           => True,\n+      N_Unchecked_Type_Conversion => True,\n+\n+      others                      => False);\n+\n+   function Permits_Dimensions (N : Node_Id) return Boolean is\n+   begin\n+      return Dimensions_Permission (Nkind (N));\n+   end Permits_Dimensions;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (Dim : Dimensions) return Boolean is\n+   begin\n+      return Dim /= Zero_Dimensions;\n+   end Present;\n+\n+   -----------------------\n+   -- Remove_Dimensions --\n+   -----------------------\n+\n+   procedure Remove_Dimensions (N : Node_Id) is\n+      Dims : constant Dimensions := Get_Dimensions (N);\n+\n+   begin\n+      if Present (Dims) then\n+         Aspect_Dimension_Hash_Table.Remove (N);\n+      end if;\n+   end Remove_Dimensions;\n+\n+   ------------------------------\n+   -- Remove_Dimension_In_Call --\n+   ------------------------------\n+\n+   procedure Remove_Dimension_In_Call (N : Node_Id) is\n+      Actual  : Node_Id;\n+      Par_Ass : constant List_Id := Parameter_Associations (N);\n+\n+   begin\n+      if Ada_Version < Ada_2012 then\n+         return;\n+      end if;\n+\n+      if Present (Par_Ass) then\n+         Actual := First (Par_Ass);\n+\n+         while Present (Actual) loop\n+            Remove_Dimensions (Actual);\n+            Next (Actual);\n+         end loop;\n+      end if;\n+   end Remove_Dimension_In_Call;\n+\n+   -------------------------------------\n+   -- Remove_Dimension_In_Declaration --\n+   -------------------------------------\n+\n+   --  Removal of dimension in expressions of N_Object_Declaration and\n+   --  N_Component_Declaration as part of the Analyze_Declarations routine\n+   --  (see package Sem_Ch3).\n+\n+   procedure Remove_Dimension_In_Declaration (D : Node_Id) is\n+   begin\n+      if Ada_Version < Ada_2012 then\n+         return;\n+      end if;\n+\n+      if Nkind_In (D, N_Object_Declaration, N_Component_Declaration) then\n+         if Present (Expression (D)) then\n+            Remove_Dimensions (Expression (D));\n+         end if;\n+      end if;\n+   end Remove_Dimension_In_Declaration;\n+\n+   -----------------------------------\n+   -- Remove_Dimension_In_Statement --\n+   -----------------------------------\n+\n+   --  Removal of dimension in statement as part of the Analyze_Statements\n+   --  routine (see package Sem_Ch5).\n+\n+   procedure Remove_Dimension_In_Statement (S : Node_Id) is\n+      S_Kind : constant Node_Kind := Nkind (S);\n+\n+   begin\n+      if Ada_Version < Ada_2012 then\n+         return;\n+      end if;\n+\n+      --  Remove dimension in parameter specifications for accept statement\n+\n+      if S_Kind = N_Accept_Statement then\n+         declare\n+            Param : Node_Id := First (Parameter_Specifications (S));\n+\n+         begin\n+            while Present (Param) loop\n+               Remove_Dimensions (Param);\n+               Next (Param);\n+            end loop;\n+         end;\n+\n+      --  Remove dimension of name and expression in assignments\n+\n+      elsif S_Kind = N_Assignment_Statement then\n+         Remove_Dimensions (Expression (S));\n+         Remove_Dimensions (Name (S));\n+      end if;\n+   end Remove_Dimension_In_Statement;\n+\n+   --------------------\n+   -- Set_Dimensions --\n+   --------------------\n+\n+   procedure Set_Dimensions (N : Node_Id; Dims : Dimensions) is\n+   begin\n+      pragma Assert (Permits_Dimensions (N));\n+      pragma Assert (Present (Dims));\n+      Aspect_Dimension_Hash_Table.Set (N, Dims);\n+   end Set_Dimensions;\n+\n+   ------------------------------\n+   -- Set_Dimensions_String_Id --\n+   ------------------------------\n+\n+   procedure Set_Dimensions_String_Id (E : Entity_Id; Str : String_Id) is\n+   begin\n+      Aspect_Dimension_String_Id_Hash_Table.Set (E, Str);\n+   end Set_Dimensions_String_Id;\n+\n+end Sem_Dim;"}, {"sha": "8089f43216076443a4b638e97025eda035cd1400", "filename": "gcc/ada/sem_dim.ads", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.ads?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -0,0 +1,150 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ D I M                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This new package of the GNAT compiler has been created in order to enable\n+--  any user of the GNAT compiler to deal with physical issues.\n+\n+--  Indeed, the user is now able to create his own dimension system and to\n+--  assign a dimension, defined from the MKS system (package System.Dim_Mks)\n+--  or his own dimension systems, with any item and to run operations with\n+--  dimensionned entities.\n+--  In that case, a dimensionnality checking will be performed at compile time.\n+--  If no dimension has been assigned, the compiler assumes that the item is\n+--  dimensionless.\n+\n+-----------------------------\n+-- Aspect_Dimension_System --\n+-----------------------------\n+\n+--  In order to enable the user to create his own dimension system, a new\n+--  aspect: Aspect_Dimension_System has been created.\n+--  Note that this aspect applies for type declaration of type derived from any\n+--  numeric type.\n+\n+--  It defines the names of each dimension.\n+\n+----------------------\n+-- Aspect_Dimension --\n+----------------------\n+\n+--  This new aspect applies for subtype and object declarations in order to\n+--  define new dimensions.\n+--  Using this aspect, the user is able to create new subtype/object with any\n+--  dimension needed.\n+--  Note that the base type of the subtype/object must be the type that defines\n+--  the corresponding dimension system.\n+\n+--  The expression of this aspect is an aggregate of rational values for each\n+--  dimension in the corresponding dimension system.\n+\n+-------------------------------------------\n+-- Dimensionality checking & propagation --\n+-------------------------------------------\n+\n+--  For each node (when needed), a dimension analysis (Analyze_Dimension) is\n+--  performed as part of the Resolution routine or the Analysis routine if no\n+--  Resolution.\n+\n+--  The dimension analysis is divided into two phases:\n+\n+--  Phase 1: dimension checking\n+\n+--  Phase 2: propagation of dimensions\n+\n+--  Depending on the node kind, either none, one phase or two phases are\n+--  executed.\n+--  Phase 2 is called only when the node allows a dimension (see body of\n+--  Sem_Dim to get the list of nodes that permit dimensions).\n+\n+------------------\n+-- Dimension_IO --\n+------------------\n+\n+--  This section contains the routine used for IO purposes.\n+\n+with Types; use Types;\n+\n+package Sem_Dim is\n+\n+   -----------------------------\n+   -- Aspect_Dimension_System --\n+   -----------------------------\n+\n+   procedure Analyze_Aspect_Dimension_System\n+     (N    : Node_Id;\n+      Id   : Node_Id;\n+      Expr : Node_Id);\n+   --  Analyzes the aggregate of Aspect_Dimension_System\n+\n+   ----------------------\n+   -- Aspect_Dimension --\n+   ----------------------\n+\n+   procedure Analyze_Aspect_Dimension\n+     (N : Node_Id;\n+      Id : Node_Id;\n+      Expr : Node_Id);\n+   --  Analyzes the aggregate of Aspect_Dimension and attaches the\n+   --  corresponding dimension to N.\n+\n+   -------------------------------------------\n+   -- Dimensionality checking & propagation --\n+   -------------------------------------------\n+\n+   procedure Analyze_Dimension (N : Node_Id);\n+   --  Performs a dimension analysis and propagates dimension between nodes\n+   --  when needed.\n+\n+   procedure Eval_Op_Expon_For_Dimensioned_Type\n+     (N : Node_Id;\n+      B_Typ : Entity_Id);\n+   --  Eval the Expon operator for dimensioned type with rational exponent\n+\n+   function Is_Dimensioned_Type (E : Entity_Id) return Boolean;\n+   --  Return True if the type is a dimensioned type (i.e: a type which has an\n+   --  aspect Dimension_System)\n+\n+   procedure Remove_Dimension_In_Call (N : Node_Id);\n+   --  At the end of the Expand_Call routine, remove the dimensions of every\n+   --  parameters in the call N.\n+\n+   procedure Remove_Dimension_In_Declaration (D : Node_Id);\n+   --  At the end of Analyze_Declarations routine (see Sem_Ch3), removes the\n+   --  dimension of the expression for each declaration.\n+\n+   procedure Remove_Dimension_In_Statement (S : Node_Id);\n+   --  At the end of the Analyze_Statements routine (see Sem_Ch5), removes the\n+   --  dimension for every statements.\n+\n+   ------------------\n+   -- Dimension_IO --\n+   ------------------\n+\n+   procedure Expand_Put_Call_With_Dimension_String (N : Node_Id);\n+   --  Expansion of Put call (from package System.Dim_Float_IO and\n+   --  System.Dim_Integer_IO) for a dimensioned object in order to add the\n+   --  dimension symbols as a suffix of the numeric value.\n+\n+end Sem_Dim;"}, {"sha": "49460d00b9600dbf700cc817d9aa28a397cc8b6d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -8062,24 +8062,6 @@ package body Sem_Prag is\n \n             Default_Pool := Expression (Arg1);\n \n-         ---------------\n-         -- Dimension --\n-         ---------------\n-\n-         when Pragma_Dimension =>\n-            GNAT_Pragma;\n-            Check_Arg_Count (4);\n-            Check_No_Identifiers;\n-            Check_Arg_Is_Local_Name (Arg1);\n-\n-            if not Is_Type (Arg1) then\n-               Error_Pragma (\"first argument for pragma% must be subtype\");\n-            end if;\n-\n-            Check_Arg_Is_Static_Expression (Arg2, Standard_Integer);\n-            Check_Arg_Is_Static_Expression (Arg3, Standard_Integer);\n-            Check_Arg_Is_Static_Expression (Arg4, Standard_Integer);\n-\n          ------------------------------------\n          -- Disable_Atomic_Synchronization --\n          ------------------------------------\n@@ -14956,7 +14938,6 @@ package body Sem_Prag is\n       Pragma_Debug_Policy                   =>  0,\n       Pragma_Detect_Blocking                => -1,\n       Pragma_Default_Storage_Pool           => -1,\n-      Pragma_Dimension                      => -1,\n       Pragma_Disable_Atomic_Synchronization => -1,\n       Pragma_Discard_Names                  =>  0,\n       Pragma_Dispatching_Domain             => -1,"}, {"sha": "55a5e3659046c09227ae4a0979545ce641265ad8", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -57,6 +57,7 @@ with Sem_Ch4;  use Sem_Ch4;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n@@ -2010,6 +2011,7 @@ package body Sem_Res is\n \n       if Analyzed (N) then\n          Debug_A_Exit (\"resolving  \", N, \"  (done, already analyzed)\");\n+         Analyze_Dimension (N);\n          return;\n \n       --  Return if type = Any_Type (previous error encountered)\n@@ -4878,6 +4880,7 @@ package body Sem_Res is\n       end if;\n \n       Generate_Operator_Reference (N, Typ);\n+      Analyze_Dimension (N);\n       Eval_Arithmetic_Op (N);\n \n       --  In SPARK, a multiplication or division with operands of fixed point\n@@ -5808,6 +5811,10 @@ package body Sem_Res is\n          end;\n       end if;\n \n+      --  dimension analysis\n+\n+      Analyze_Dimension (N);\n+\n       --  All done, evaluate call and deal with elaboration issues\n \n       Eval_Call (N);\n@@ -6004,6 +6011,7 @@ package body Sem_Res is\n       --  Evaluate the relation (note we do this after the above check since\n       --  this Eval call may change N to True/False.\n \n+      Analyze_Dimension (N);\n       Eval_Relational_Op (N);\n    end Resolve_Comparison_Op;\n \n@@ -6889,6 +6897,7 @@ package body Sem_Res is\n            or else Is_Intrinsic_Subprogram\n                      (Corresponding_Equality (Entity (N)))\n          then\n+            Analyze_Dimension (N);\n             Eval_Relational_Op (N);\n \n          elsif Nkind (N) = N_Op_Ne\n@@ -7143,6 +7152,8 @@ package body Sem_Res is\n          end loop;\n       end if;\n \n+      Analyze_Dimension (N);\n+\n       --  Do not generate the warning on suspicious index if we are analyzing\n       --  package Ada.Tags; otherwise we will report the warning with the\n       --  Prims_Ptr field of the dispatch table.\n@@ -7998,6 +8009,24 @@ package body Sem_Res is\n \n       Set_Etype (N, B_Typ);\n       Generate_Operator_Reference (N, B_Typ);\n+\n+      Analyze_Dimension (N);\n+\n+      --  Evaluate the Expon operator for dimensioned type with rational\n+      --  exponent.\n+\n+      if Ada_Version >= Ada_2012\n+        and then Is_Dimensioned_Type (B_Typ)\n+      then\n+         Eval_Op_Expon_For_Dimensioned_Type (N, B_Typ);\n+\n+         --  Skip the Eval_Op_Expon if the node has already been evaluated\n+\n+         if Nkind (N) = N_Type_Conversion then\n+            return;\n+         end if;\n+      end if;\n+\n       Eval_Op_Expon (N);\n \n       --  Set overflow checking bit. Much cleverer code needed here eventually\n@@ -8196,6 +8225,7 @@ package body Sem_Res is\n          Set_Etype (N, Etype (Expr));\n       end if;\n \n+      Analyze_Dimension (N);\n       Eval_Qualified_Expression (N);\n    end Resolve_Qualified_Expression;\n \n@@ -8629,6 +8659,7 @@ package body Sem_Res is\n          Error_Msg_N (\"?\\may cause unexpected accesses to atomic object\",\n                       Prefix (N));\n       end if;\n+      Analyze_Dimension (N);\n    end Resolve_Selected_Component;\n \n    -------------------\n@@ -8940,6 +8971,7 @@ package body Sem_Res is\n          Warn_On_Suspicious_Index (Name, High_Bound (Drange));\n       end if;\n \n+      Analyze_Dimension (N);\n       Eval_Slice (N);\n    end Resolve_Slice;\n \n@@ -9346,6 +9378,8 @@ package body Sem_Res is\n          Check_SPARK_Restriction (\"object required\", Operand);\n       end if;\n \n+      Analyze_Dimension (N);\n+\n       --  Note: we do the Eval_Type_Conversion call before applying the\n       --  required checks for a subtype conversion. This is important, since\n       --  both are prepared under certain circumstances to change the type\n@@ -9629,6 +9663,7 @@ package body Sem_Res is\n \n       Check_Unset_Reference (R);\n       Generate_Operator_Reference (N, B_Typ);\n+      Analyze_Dimension (N);\n       Eval_Unary_Op (N);\n \n       --  Set overflow checking bit. Much cleverer code needed here eventually\n@@ -9795,6 +9830,7 @@ package body Sem_Res is\n       --  Resolve operand using its own type\n \n       Resolve (Operand, Opnd_Type);\n+      Analyze_Dimension (N);\n       Eval_Unchecked_Conversion (N);\n    end Resolve_Unchecked_Type_Conversion;\n "}, {"sha": "dd2e5948d3ccf33da3b4571423d46a533c6b689f", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "patch": "@@ -139,6 +139,8 @@ package Snames is\n \n    Name_Default_Value                  : constant Name_Id := N + $;\n    Name_Default_Component_Value        : constant Name_Id := N + $;\n+   Name_Dimension                      : constant Name_Id := N + $;\n+   Name_Dimension_System               : constant Name_Id := N + $;\n    Name_Dynamic_Predicate              : constant Name_Id := N + $;\n    Name_Post                           : constant Name_Id := N + $;\n    Name_Pre                            : constant Name_Id := N + $;\n@@ -219,6 +221,14 @@ package Snames is\n    subtype Text_IO_Package_Name is Name_Id\n      range First_Text_IO_Package .. Last_Text_IO_Package;\n \n+   --  Names used by the analyzer and expander for aspect Dimension and\n+   --  Dimension_System to deal with Sqrt and IO routines.\n+\n+   Name_Dim_Float_IO                 : constant Name_Id := N + $; -- Ada 12\n+   Name_Dim_Integer_IO               : constant Name_Id := N + $; -- Ada 12\n+   Name_Generic_Elementary_Functions : constant Name_Id := N + $; -- Ada 12\n+   Name_Sqrt                         : constant Name_Id := N + $; -- Ada 12\n+\n    --  Some miscellaneous names used for error detection/recovery\n \n    Name_Const                          : constant Name_Id := N + $;\n@@ -447,7 +457,6 @@ package Snames is\n    Name_CPP_Vtable                     : constant Name_Id := N + $; -- GNAT\n    Name_CPU                            : constant Name_Id := N + $; -- Ada 12\n    Name_Debug                          : constant Name_Id := N + $; -- GNAT\n-   Name_Dimension                      : constant Name_Id := N + $; -- GNAT\n    Name_Elaborate                      : constant Name_Id := N + $; -- Ada 83\n    Name_Elaborate_All                  : constant Name_Id := N + $;\n    Name_Elaborate_Body                 : constant Name_Id := N + $;\n@@ -1610,7 +1619,6 @@ package Snames is\n       Pragma_CPP_Vtable,\n       Pragma_CPU,\n       Pragma_Debug,\n-      Pragma_Dimension,\n       Pragma_Elaborate,\n       Pragma_Elaborate_All,\n       Pragma_Elaborate_Body,"}]}