{"sha": "6eb47b98291138b27e13cc8da738cd3d08ea80a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmViNDdiOTgyOTExMzhiMjdlMTNjYzhkYTczOGNkM2QwOGVhODBhMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-05-11T21:30:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-05-11T21:30:18Z"}, "message": "re PR c++/48948 ([C++0x] constexpr friend function cannot be defined in-class)\n\n\tPR c++/48948\n\t* semantics.c (validate_constexpr_fundecl): Defer checking if\n\tan argument type is being defined.\n\t(is_valid_constexpr_fn): Add defer_ok parm.\n\t(cxx_eval_call_expression): Adjust.\n\t(check_deferred_constexpr_decls): New.\n\t(literal_type_p): Make sure type isn't being defined.\n\t(ensure_literal_type_for_constexpr_object): Handle type being defined.\n\t* cp-tree.h: Declare check_deferred_constexpr_decls.\n\t* decl.c (grokfndecl): Call validate_constexpr_fundecl here.\n\t(start_preparsed_function, cp_finish_decl): Not here.\n\t* class.c (finalize_literal_type_property): Don't call\n\tvalidate_constexpr_fundecl.\n\t(finish_struct): Call check_deferred_constexpr_decls.\n\t* pt.c (tsubst_decl): Call validate_constexpr_fundecl.\n\t(instantiate_class_template): Call check_deferred_constexpr_decls.\n\nFrom-SVN: r173683", "tree": {"sha": "4fd40e140cf8b453b9b67a51b9e7b85ac05df507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fd40e140cf8b453b9b67a51b9e7b85ac05df507"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eb47b98291138b27e13cc8da738cd3d08ea80a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eb47b98291138b27e13cc8da738cd3d08ea80a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eb47b98291138b27e13cc8da738cd3d08ea80a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eb47b98291138b27e13cc8da738cd3d08ea80a0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c5283a738132562b7711278a09d3bd09239b7be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c5283a738132562b7711278a09d3bd09239b7be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c5283a738132562b7711278a09d3bd09239b7be"}], "stats": {"total": 175, "additions": 137, "deletions": 38}, "files": [{"sha": "94f218179d68f29f02c9c22a34a10aa32f9c7ce2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -1,5 +1,22 @@\n 2011-05-11  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/48948\n+\t* semantics.c (validate_constexpr_fundecl): Defer checking if\n+\tan argument type is being defined.\n+\t(is_valid_constexpr_fn): Add defer_ok parm.\n+\t(cxx_eval_call_expression): Adjust.\n+\t(check_deferred_constexpr_decls): New.\n+\t(literal_type_p): Make sure type isn't being defined.\n+\t(ensure_literal_type_for_constexpr_object): Handle type being defined.\n+\t* cp-tree.h: Declare check_deferred_constexpr_decls.\n+\t* decl.c (grokfndecl): Call validate_constexpr_fundecl here.\n+\t(start_preparsed_function, cp_finish_decl): Not here.\n+\t* class.c (finalize_literal_type_property): Don't call\n+\tvalidate_constexpr_fundecl.\n+\t(finish_struct): Call check_deferred_constexpr_decls.\n+\t* pt.c (tsubst_decl): Call validate_constexpr_fundecl.\n+\t(instantiate_class_template): Call check_deferred_constexpr_decls.\n+\n \t* semantics.c (validate_constexpr_fundecl): Check DECL_TEMPLATE_INFO\n \trather than DECL_TEMPLATE_INSTANTIATION.\n \t(cxx_eval_call_expression): Likewise."}, {"sha": "938d52201e3e0f2b23023d1f3d17f9d8e67728d1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -4578,8 +4578,6 @@ type_requires_array_cookie (tree type)\n static void\n finalize_literal_type_property (tree t)\n {\n-  tree fn;\n-\n   if (cxx_dialect < cxx0x\n       || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n       /* FIXME These constraints seem unnecessary; remove from standard.\n@@ -4589,11 +4587,6 @@ finalize_literal_type_property (tree t)\n   else if (CLASSTYPE_LITERAL_P (t) && !TYPE_HAS_TRIVIAL_DFLT (t)\n \t   && !TYPE_HAS_CONSTEXPR_CTOR (t))\n     CLASSTYPE_LITERAL_P (t) = false;\n-\n-  for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n-    if (DECL_DECLARED_CONSTEXPR_P (fn)\n-\t&& TREE_CODE (fn) != TEMPLATE_DECL)\n-      validate_constexpr_fundecl (fn);\n }\n \n /* Check the validity of the bases and members declared in T.  Add any\n@@ -5834,6 +5827,8 @@ finish_struct (tree t, tree attributes)\n   else\n     error (\"trying to finish struct, but kicked out due to previous parse errors\");\n \n+  check_deferred_constexpr_decls ();\n+\n   if (processing_template_decl && at_function_scope_p ())\n     add_stmt (build_min (TAG_DEFN, t));\n "}, {"sha": "ec59346be45778499039eb9464c0bbf9fb5770f2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -5325,6 +5325,7 @@ extern void finish_handler_parms\t\t(tree, tree);\n extern void finish_handler\t\t\t(tree);\n extern void finish_cleanup\t\t\t(tree, tree);\n extern bool literal_type_p (tree);\n+extern void check_deferred_constexpr_decls (void);\n extern tree validate_constexpr_fundecl (tree);\n extern tree register_constexpr_fundef (tree, tree);\n extern bool check_constexpr_ctor_body (tree, tree);"}, {"sha": "87be1120e54448995a5a54eedf6fd276afbcbd8c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -5911,13 +5911,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t}\n     }\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      /* For members, defer until finalize_literal_type_property.  */\n-      && (!DECL_CLASS_SCOPE_P (decl)\n-\t  || !TYPE_BEING_DEFINED (DECL_CONTEXT (decl))))\n-    validate_constexpr_fundecl (decl);\n-\n-  else if (!ensure_literal_type_for_constexpr_object (decl))\n+  if (!ensure_literal_type_for_constexpr_object (decl))\n     DECL_DECLARED_CONSTEXPR_P (decl) = 0;\n \n   if (init && TREE_CODE (decl) == FUNCTION_DECL)\n@@ -7206,7 +7200,10 @@ grokfndecl (tree ctype,\n   if (inlinep)\n     DECL_DECLARED_INLINE_P (decl) = 1;\n   if (inlinep & 2)\n-    DECL_DECLARED_CONSTEXPR_P (decl) = true;\n+    {\n+      DECL_DECLARED_CONSTEXPR_P (decl) = true;\n+      validate_constexpr_fundecl (decl);\n+    }\n \n   DECL_EXTERNAL (decl) = 1;\n   if (quals && TREE_CODE (type) == FUNCTION_TYPE)\n@@ -12524,10 +12521,6 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tmaybe_apply_pragma_weak (decl1);\n     }\n \n-  /* constexpr functions must have literal argument types and\n-     literal return type.  */\n-  validate_constexpr_fundecl (decl1);\n-\n   /* Reset this in case the call to pushdecl changed it.  */\n   current_function_decl = decl1;\n "}, {"sha": "50ed18034436f91b1017c288f6920abcbee33f40", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -8594,6 +8594,8 @@ instantiate_class_template_1 (tree type)\n   pop_deferring_access_checks ();\n   pop_tinst_level ();\n \n+  check_deferred_constexpr_decls ();\n+\n   /* The vtable for a template class can be emitted in any translation\n      unit in which the class is instantiated.  When there is no key\n      method, however, finish_struct_1 will already have added TYPE to\n@@ -9740,6 +9742,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (DECL_DEFAULTED_OUTSIDE_CLASS_P (r)\n \t    && !processing_template_decl)\n \t  defaulted_late_check (r);\n+\tvalidate_constexpr_fundecl (r);\n \n \tapply_late_template_attributes (&r, DECL_ATTRIBUTES (r), 0,\n \t\t\t\t\targs, complain, in_decl);"}, {"sha": "ffabad1802ca66d5b29615b8a7721634dc108d1e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -5336,7 +5336,11 @@ literal_type_p (tree t)\n       || TREE_CODE (t) == REFERENCE_TYPE)\n     return true;\n   if (CLASS_TYPE_P (t))\n-    return CLASSTYPE_LITERAL_P (t);\n+    {\n+      /* We can't answer this question until the class is complete.  */\n+      gcc_assert (!TYPE_BEING_DEFINED (t) || errorcount);\n+      return CLASSTYPE_LITERAL_P (complete_type (t));\n+    }\n   if (TREE_CODE (t) == ARRAY_TYPE)\n     return literal_type_p (strip_array_types (t));\n   return false;\n@@ -5350,13 +5354,17 @@ ensure_literal_type_for_constexpr_object (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n   if (TREE_CODE (decl) == VAR_DECL && DECL_DECLARED_CONSTEXPR_P (decl)\n-      && !processing_template_decl\n-      /* The call to complete_type is just for initializer_list.  */\n-      && !literal_type_p (complete_type (type)))\n+      && !processing_template_decl)\n     {\n-      error (\"the type %qT of constexpr variable %qD is not literal\",\n-             type, decl);\n-      return NULL;\n+      if (CLASS_TYPE_P (type) && TYPE_BEING_DEFINED (type))\n+\t/* Don't complain here, we'll complain about incompleteness\n+\t   when we try to initialize the variable.  */;\n+      else if (!literal_type_p (type))\n+\t{\n+\t  error (\"the type %qT of constexpr variable %qD is not literal\",\n+\t\t type, decl);\n+\t  return NULL;\n+\t}\n     }\n   return decl;\n }\n@@ -5409,15 +5417,22 @@ retrieve_constexpr_fundef (tree fun)\n }\n \n /* Check whether the parameter and return types of FUN are valid for a\n-   constexpr function, and complain if COMPLAIN.  */\n+   constexpr function, and complain if COMPLAIN.  If DEFER_OK is true,\n+   return -1 if we can't tell yet because some of the types are still being\n+   defined.  */\n \n-static bool\n-is_valid_constexpr_fn (tree fun, bool complain)\n+static int\n+is_valid_constexpr_fn (tree fun, bool complain, bool defer_ok)\n {\n+#define IF_NON_LITERAL(TYPE)\t\t\t\t\t\t\\\n+  if (defer_ok && CLASS_TYPE_P (TYPE) && TYPE_BEING_DEFINED (TYPE))\t\\\n+    return -1;\t\t\t\t\t\t\t\t\\\n+  else if (!literal_type_p (TYPE))\n+\n   tree parm = FUNCTION_FIRST_USER_PARM (fun);\n   bool ret = true;\n   for (; parm != NULL; parm = TREE_CHAIN (parm))\n-    if (!literal_type_p (TREE_TYPE (parm)))\n+    IF_NON_LITERAL (TREE_TYPE (parm))\n       {\n \tret = false;\n \tif (complain)\n@@ -5428,26 +5443,59 @@ is_valid_constexpr_fn (tree fun, bool complain)\n   if (!DECL_CONSTRUCTOR_P (fun))\n     {\n       tree rettype = TREE_TYPE (TREE_TYPE (fun));\n-      if (!literal_type_p (rettype))\n+      IF_NON_LITERAL (rettype)\n \t{\n \t  ret = false;\n \t  if (complain)\n \t    error (\"invalid return type %qT of constexpr function %q+D\",\n \t\t   rettype, fun);\n \t}\n \n-      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun)\n-\t  && !CLASSTYPE_LITERAL_P (DECL_CONTEXT (fun)))\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun))\n \t{\n-\t  ret = false;\n-\t  if (complain)\n-\t    error (\"enclosing class of %q+#D is not a literal type\", fun);\n+\t  IF_NON_LITERAL (DECL_CONTEXT (fun))\n+\t    {\n+\t      ret = false;\n+\t      if (complain)\n+\t\terror (\"enclosing class of %q+#D is not a literal type\", fun);\n+\t    }\n \t}\n     }\n \n   return ret;\n }\n \n+/* We can't check the parameter and return types of a constexpr function\n+   for literality until any open classes are complete, so we defer checking\n+   of any constexpr functions declared in a class.  */\n+\n+static GTY(()) VEC(tree,gc) *deferred_constexpr_decls;\n+\n+void\n+check_deferred_constexpr_decls (void)\n+{\n+  unsigned i;\n+  tree fn;\n+\n+  /* Some of the deferred decls might still need to be deferred,\n+     so move the vector out of the way.  */\n+  VEC(tree,gc) *vec = deferred_constexpr_decls;\n+  deferred_constexpr_decls = NULL;\n+\n+  FOR_EACH_VEC_ELT (tree, vec, i, fn)\n+    validate_constexpr_fundecl (fn);\n+\n+  if (deferred_constexpr_decls == NULL)\n+    {\n+      /* If we didn't need to re-defer any, keep the same vector.  */\n+      VEC_truncate (tree, vec, 0);\n+      deferred_constexpr_decls = vec;\n+    }\n+  else\n+    /* Otherwise, discard the old vector.  */\n+    release_tree_vector (vec);\n+}\n+\n /* Return non-null if FUN certainly designates a valid constexpr function\n    declaration.  Otherwise return NULL.  Issue appropriate diagnostics\n    if necessary.  Note that we only check the declaration, not the body\n@@ -5456,13 +5504,22 @@ is_valid_constexpr_fn (tree fun, bool complain)\n tree\n validate_constexpr_fundecl (tree fun)\n {\n+  int valid;\n+\n   if (processing_template_decl || !DECL_DECLARED_CONSTEXPR_P (fun))\n     return NULL;\n   else if (DECL_CLONED_FUNCTION_P (fun))\n     /* We already checked the original function.  */\n     return fun;\n \n-  if (!is_valid_constexpr_fn (fun, !DECL_TEMPLATE_INFO (fun)))\n+  valid = is_valid_constexpr_fn (fun, !DECL_TEMPLATE_INFO (fun),\n+\t\t\t\t /*defer_ok=*/true);\n+  if (valid < 0)\n+    {\n+      VEC_safe_push (tree, gc, deferred_constexpr_decls, fun);\n+      return NULL;\n+    }\n+  else if (valid == 0)\n     {\n       DECL_DECLARED_CONSTEXPR_P (fun) = false;\n       return NULL;\n@@ -6079,7 +6136,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n \t  if (DECL_TEMPLATE_INFO (fun)\n \t      && DECL_DECLARED_CONSTEXPR_P (DECL_TEMPLATE_RESULT\n \t\t\t\t\t    (DECL_TI_TEMPLATE (fun))))\n-\t    is_valid_constexpr_fn (fun, true);\n+\t    is_valid_constexpr_fn (fun, true, /*defer_ok=*/false);\n \t}\n       *non_constant_p = true;\n       return t;"}, {"sha": "d6f1b4cde9348e49769e4b7d1b57e5b0083d0b23", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -1,5 +1,8 @@\n 2011-05-11  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/cpp0x/constexpr-friend.C: New.\n+\t* g++.dg/cpp0x/constexpr-incomplete1.C: New.\n+\n \t* g++.dg/cpp0x/sfinae22.C: New.\n \n 2011-05-11  Tobias Burnus  <burnus@net-b.de>"}, {"sha": "f1d9ccee790cd88f7f7cdda82f0aa2ecea5c9dbb", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-friend.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/48948\n+// { dg-options -std=c++0x }\n+\n+struct A { A(); };\n+\n+struct B {\n+  friend constexpr int f(B) { return 0; } // OK\n+  friend constexpr int f(A) { return 0; } // { dg-error \"constexpr\" }\n+};\n+\n+template <class T>\n+struct C\n+{\n+  friend constexpr int f(C) { return 0; }\n+  friend constexpr int g(C, A) { return 0; } // { dg-error \"double\" }\n+  constexpr int m(C) { return 0; }\n+  constexpr int m(A) { return 0; } // { dg-error \"double\" }\n+};\n+\n+constexpr int i = f(C<int>());\n+constexpr int j = C<int>().m(C<int>());\n+constexpr int k = C<double>().m(A()); // { dg-error \"not a constexpr function\" }\n+constexpr int l = g(C<double>(),A()); // { dg-error \"not a constexpr function\" }"}, {"sha": "3f40e29aec0771ff5698f29e7adea7dbaef3192f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-incomplete1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-incomplete1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb47b98291138b27e13cc8da738cd3d08ea80a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-incomplete1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-incomplete1.C?ref=6eb47b98291138b27e13cc8da738cd3d08ea80a0", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  static constexpr A a = 1;\t// { dg-error \"incomplete\" }\n+  constexpr A(int i) { }\n+};"}]}