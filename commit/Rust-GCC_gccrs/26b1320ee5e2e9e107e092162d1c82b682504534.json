{"sha": "26b1320ee5e2e9e107e092162d1c82b682504534", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZiMTMyMGVlNWUyZTllMTA3ZTA5MjE2MmQxYzgyYjY4MjUwNDUzNA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-06-17T14:19:04Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-06-17T14:19:04Z"}, "message": "PR libstdc++/90281 Fix string conversions for filesystem::path\n\nFix several bugs in the encoding conversions for filesystem::path that\nprevent conversion of Unicode characters outside the Basic Multilingual\nPlane, and prevent returning basic_string specializations with\nalternative allocator types.\n\nThe std::codecvt_utf8 class template is not suitable for UTF-16\nconversions because it uses UCS-2 instead. For conversions between UTF-8\nand UTF-16 either std::codecvt<C, char, mbstate> or\ncodecvt_utf8_utf16<C> must be used.\n\nThe __str_codecvt_in and __str_codecvt_out utilities do not\nreturn false on a partial conversion (e.g. for invalid or incomplete\nUnicode input). Add new helpers that treat partial conversions as\nerrors, and use them for all filesystem::path conversions.\n\n\tPR libstdc++/90281 Fix string conversions for filesystem::path\n\t* include/bits/fs_path.h (u8path) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]:\n\tUse codecvt_utf8_utf16 instead of codecvt_utf8. Use\n\t__str_codecvt_in_all to fail for partial conversions and throw on\n\terror.\n\t[!_GLIBCXX_FILESYSTEM_IS_WINDOWS && _GLIBCXX_USE_CHAR8_T]\n\t(path::_Cvt<char8_t>): Add explicit specialization.\n\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_wconvert): Remove\n\toverloads.\n\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_convert): Use\n\tif-constexpr instead of dispatching to _S_wconvert. Use codecvt\n\tinstead of codecvt_utf8. Use __str_codecvt_in_all and\n\t__str_codecvt_out_all.\n\t[!_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_convert): Use\n\tcodecvt instead of codecvt_utf8. Use __str_codecvt_out_all.\n\t(path::_S_str_convert) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n\tcodecvt_utf8_utf16 instead of codecvt_utf8. Construct return values\n\twith allocator. Use __str_codecvt_out_all. Fallthrough to POSIX code\n\tafter converting to UTF-8.\n\t(path::_S_str_convert): Use codecvt instead of codecvt_utf8. Use\n\t__str_codecvt_in_all.\n\t(path::string): Fix initialization of string types with different\n\tallocators.\n\t(path::u8string) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n\tcodecvt_utf8_utf16 instead of codecvt_utf8. Use __str_codecvt_out_all.\n\t* include/bits/locale_conv.h (__do_str_codecvt): Reorder static and\n\truntime conditions.\n\t(__str_codecvt_out_all, __str_codecvt_in_all): New functions that\n\treturn false for partial conversions.\n\t* include/experimental/bits/fs_path.h (u8path):\n\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Implement correctly for mingw.\n\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_wconvert): Add\n\tmissing handling for char8_t. Use codecvt and codecvt_utf8_utf16\n\tinstead of codecvt_utf8. Use __str_codecvt_in_all and\n\t__str_codecvt_out_all.\n\t[!_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_convert): Use\n\tcodecvt instead of codecvt_utf8. Use __str_codecvt_out_all.\n\t(path::string) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n\tcodecvt_utf8_utf16 instead of codecvt_utf8. Construct return values\n\twith allocator. Use __str_codecvt_out_all and __str_codecvt_in_all.\n\t(path::string) [!_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n\t__str_codecvt_in_all.\n\t(path::u8string) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n\tcodecvt_utf8_utf16 instead of codecvt_utf8. Use __str_codecvt_out_all.\n\t* src/c++17/fs_path.cc (path::_S_convert_loc): Use\n\t__str_codecvt_in_all.\n\t* src/filesystem/path.cc (path::_S_convert_loc): Likewise.\n\t* testsuite/27_io/filesystem/path/construct/90281.cc: New test.\n\t* testsuite/27_io/filesystem/path/factory/u8path.cc: New test.\n\t* testsuite/27_io/filesystem/path/native/string.cc: Test with empty\n\tstrings and with Unicode characters outside the basic multilingual\n\tplane.\n\t* testsuite/27_io/filesystem/path/native/alloc.cc: New test.\n\t* testsuite/experimental/filesystem/path/construct/90281.cc: New test.\n\t* testsuite/experimental/filesystem/path/factory/u8path.cc: New test.\n\t* testsuite/experimental/filesystem/path/native/alloc.cc: New test.\n\t* testsuite/experimental/filesystem/path/native/string.cc: Test with\n\tempty strings and with Unicode characters outside the basic\n\tmultilingual plane.\n\nFrom-SVN: r272385", "tree": {"sha": "4a56946748990bfb63e818d0c143f2b10a1c2018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a56946748990bfb63e818d0c143f2b10a1c2018"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26b1320ee5e2e9e107e092162d1c82b682504534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b1320ee5e2e9e107e092162d1c82b682504534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b1320ee5e2e9e107e092162d1c82b682504534", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b1320ee5e2e9e107e092162d1c82b682504534/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41d93b16cac5b348b7883e259f7880b4a0addc23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41d93b16cac5b348b7883e259f7880b4a0addc23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41d93b16cac5b348b7883e259f7880b4a0addc23"}], "stats": {"total": 904, "additions": 737, "deletions": 167}, "files": [{"sha": "f05970ede20fb4eac2306000b28c71cfae2668f0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -1,3 +1,65 @@\n+2019-06-17  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/90281 Fix string conversions for filesystem::path\n+\t* include/bits/fs_path.h (u8path) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]:\n+\tUse codecvt_utf8_utf16 instead of codecvt_utf8. Use\n+\t__str_codecvt_in_all to fail for partial conversions and throw on\n+\terror.\n+\t[!_GLIBCXX_FILESYSTEM_IS_WINDOWS && _GLIBCXX_USE_CHAR8_T]\n+\t(path::_Cvt<char8_t>): Add explicit specialization.\n+\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_wconvert): Remove\n+\toverloads.\n+\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_convert): Use\n+\tif-constexpr instead of dispatching to _S_wconvert. Use codecvt\n+\tinstead of codecvt_utf8. Use __str_codecvt_in_all and\n+\t__str_codecvt_out_all.\n+\t[!_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_convert): Use\n+\tcodecvt instead of codecvt_utf8. Use __str_codecvt_out_all.\n+\t(path::_S_str_convert) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n+\tcodecvt_utf8_utf16 instead of codecvt_utf8. Construct return values\n+\twith allocator. Use __str_codecvt_out_all. Fallthrough to POSIX code\n+\tafter converting to UTF-8.\n+\t(path::_S_str_convert): Use codecvt instead of codecvt_utf8. Use\n+\t__str_codecvt_in_all.\n+\t(path::string): Fix initialization of string types with different\n+\tallocators.\n+\t(path::u8string) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n+\tcodecvt_utf8_utf16 instead of codecvt_utf8. Use __str_codecvt_out_all.\n+\t* include/bits/locale_conv.h (__do_str_codecvt): Reorder static and\n+\truntime conditions.\n+\t(__str_codecvt_out_all, __str_codecvt_in_all): New functions that\n+\treturn false for partial conversions.\n+\t* include/experimental/bits/fs_path.h (u8path):\n+\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Implement correctly for mingw.\n+\t[_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_wconvert): Add\n+\tmissing handling for char8_t. Use codecvt and codecvt_utf8_utf16\n+\tinstead of codecvt_utf8. Use __str_codecvt_in_all and\n+\t__str_codecvt_out_all.\n+\t[!_GLIBCXX_FILESYSTEM_IS_WINDOWS] (path::_Cvt::_S_convert): Use\n+\tcodecvt instead of codecvt_utf8. Use __str_codecvt_out_all.\n+\t(path::string) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n+\tcodecvt_utf8_utf16 instead of codecvt_utf8. Construct return values\n+\twith allocator. Use __str_codecvt_out_all and __str_codecvt_in_all.\n+\t(path::string) [!_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n+\t__str_codecvt_in_all.\n+\t(path::u8string) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Use\n+\tcodecvt_utf8_utf16 instead of codecvt_utf8. Use __str_codecvt_out_all.\n+\t* src/c++17/fs_path.cc (path::_S_convert_loc): Use\n+\t__str_codecvt_in_all.\n+\t* src/filesystem/path.cc (path::_S_convert_loc): Likewise.\n+\t* testsuite/27_io/filesystem/path/construct/90281.cc: New test.\n+\t* testsuite/27_io/filesystem/path/factory/u8path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/native/string.cc: Test with empty\n+\tstrings and with Unicode characters outside the basic multilingual\n+\tplane.\n+\t* testsuite/27_io/filesystem/path/native/alloc.cc: New test.\n+\t* testsuite/experimental/filesystem/path/construct/90281.cc: New test.\n+\t* testsuite/experimental/filesystem/path/factory/u8path.cc: New test.\n+\t* testsuite/experimental/filesystem/path/native/alloc.cc: New test.\n+\t* testsuite/experimental/filesystem/path/native/string.cc: Test with\n+\tempty strings and with Unicode characters outside the basic\n+\tmultilingual plane.\n+\n 2019-06-17  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \t    Jonathan Wakely  <jwakely@redhat.com>\n "}, {"sha": "0a8ab0de2ffb0b18d63a445105648ef2fa053d08", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 86, "deletions": 96, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -628,22 +628,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     -> decltype(filesystem::path(__first, __last, std::locale::classic()))\n     {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-      codecvt_utf8<path::value_type> __cvt;\n+      // XXX This assumes native wide encoding is UTF-16.\n+      std::codecvt_utf8_utf16<path::value_type> __cvt;\n       path::string_type __tmp;\n       if constexpr (is_pointer_v<_InputIterator>)\n \t{\n-\t  if (__str_codecvt_in(__first, __last, __tmp, __cvt))\n+\t  if (__str_codecvt_in_all(__first, __last, __tmp, __cvt))\n \t    return path{ __tmp };\n \t}\n       else\n \t{\n \t  const std::string __u8str{__first, __last};\n \t  const char* const __ptr = __u8str.data();\n-\t  if (__str_codecvt_in(__ptr, __ptr + __u8str.size(), __tmp, __cvt))\n+\t  if (__str_codecvt_in_all(__ptr, __ptr + __u8str.size(), __tmp, __cvt))\n \t    return path{ __tmp };\n \t}\n-      return {};\n+      _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t    \"Cannot convert character sequence\",\n+\t    std::make_error_code(errc::illegal_byte_sequence)));\n #else\n+      // This assumes native normal encoding is UTF-8.\n       return path{ __first, __last };\n #endif\n     }\n@@ -723,72 +727,68 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t{ return string_type{__first, __last}; }\n     };\n \n+#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS  && defined _GLIBCXX_USE_CHAR8_T\n+  // For POSIX converting from char8_t to char is also 'noconv'\n+  template<>\n+    struct path::_Cvt<char8_t>\n+    {\n+      template<typename _Iter>\n+\tstatic string_type\n+\t_S_convert(_Iter __first, _Iter __last)\n+\t{ return string_type(__first, __last); }\n+    };\n+#endif\n+\n   template<typename _CharT>\n     struct path::_Cvt\n     {\n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n       static string_type\n-      _S_wconvert(const char* __f, const char* __l, true_type)\n+      _S_convert(const _CharT* __f, const _CharT* __l)\n       {\n-\tusing _Cvt = std::codecvt<wchar_t, char, mbstate_t>;\n-\tconst auto& __cvt = std::use_facet<_Cvt>(std::locale{});\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n \tstd::wstring __wstr;\n-\tif (__str_codecvt_in(__f, __l, __wstr, __cvt))\n-\t    return __wstr;\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"Cannot convert character sequence\",\n-\t      std::make_error_code(errc::illegal_byte_sequence)));\n-      }\n-\n-      static string_type\n-      _S_wconvert(const _CharT* __f, const _CharT* __l, false_type)\n-      {\n-\tstd::codecvt_utf8<_CharT> __cvt;\n-\tstd::string __str;\n-\tif (__str_codecvt_out(__f, __l, __str, __cvt))\n+\tif constexpr (is_same_v<_CharT, char>)\n \t  {\n-\t    const char* __f2 = __str.data();\n-\t    const char* __l2 = __f2 + __str.size();\n-\t    std::codecvt_utf8<wchar_t> __wcvt;\n-\t    std::wstring __wstr;\n-\t    if (__str_codecvt_in(__f2, __l2, __wstr, __wcvt))\n+\t    struct _UCvt : std::codecvt<wchar_t, char, std::mbstate_t>\n+\t    { } __cvt;\n+\t    if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))\n \t      return __wstr;\n \t  }\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"Cannot convert character sequence\",\n-\t      std::make_error_code(errc::illegal_byte_sequence)));\n-      }\n-\n-      static string_type\n-      _S_convert(const _CharT* __f, const _CharT* __l)\n-      {\n-\treturn _S_wconvert(__f, __l, is_same<_CharT, char>{});\n-      }\n-#else\n-      static string_type\n-      _S_convert(const _CharT* __f, const _CharT* __l)\n-      {\n #ifdef _GLIBCXX_USE_CHAR8_T\n-\tif constexpr (is_same_v<_CharT, char8_t>)\n+\telse if constexpr (is_same_v<_CharT, char8_t>)\n \t  {\n-\t    string_type __str(__f, __l);\n-\t    return __str;\n+\t    const char* __f2 = (const char*)__f;\n+\t    const char* __l2 = (const char*)__l;\n+\t    std::codecvt_utf8_utf16<wchar_t> __wcvt;\n+\t    if (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n+\t      return __wstr;\n \t  }\n-\telse\n-\t  {\n #endif\n-\t    std::codecvt_utf8<_CharT> __cvt;\n+\telse // char16_t or char32_t\n+\t  {\n+\t    struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n+\t    { } __cvt;\n \t    std::string __str;\n-\t    if (__str_codecvt_out(__f, __l, __str, __cvt))\n-\t      return __str;\n-#ifdef _GLIBCXX_USE_CHAR8_T\n+\t    if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n+\t      {\n+\t\tconst char* __f2 = __str.data();\n+\t\tconst char* __l2 = __f2 + __str.size();\n+\t\tstd::codecvt_utf8_utf16<wchar_t> __wcvt;\n+\t\tif (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n+\t\t  return __wstr;\n+\t      }\n \t  }\n+#else // ! windows\n+\tstruct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n+\t{ } __cvt;\n+\tstd::string __str;\n+\tif (__str_codecvt_out_all(__f, __l, __str, __cvt))\n+\t  return __str;\n #endif\n \t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t      \"Cannot convert character sequence\",\n \t      std::make_error_code(errc::illegal_byte_sequence)));\n       }\n-#endif\n \n       static string_type\n       _S_convert(_CharT* __f, _CharT* __l)\n@@ -971,61 +971,51 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     std::basic_string<_CharT, _Traits, _Allocator>\n     path::_S_str_convert(const string_type& __str, const _Allocator& __a)\n     {\n-      if (__str.size() == 0)\n-\treturn std::basic_string<_CharT, _Traits, _Allocator>(__a);\n+      static_assert(!is_same_v<_CharT, value_type>);\n \n-      const value_type* __first = __str.data();\n-      const value_type* __last = __first + __str.size();\n+      using _WString = basic_string<_CharT, _Traits, _Allocator>;\n+\n+      if (__str.size() == 0)\n+\treturn _WString(__a);\n \n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      // First convert native string from UTF-16 to to UTF-8.\n+      // XXX This assumes that the execution wide-character set is UTF-16.\n+      std::codecvt_utf8_utf16<value_type> __cvt;\n+\n       using _CharAlloc = __alloc_rebind<_Allocator, char>;\n       using _String = basic_string<char, char_traits<char>, _CharAlloc>;\n-      using _WString = basic_string<_CharT, _Traits, _Allocator>;\n-\n-      // use codecvt_utf8<wchar_t> to convert native string to UTF-8\n-      codecvt_utf8<value_type> __cvt;\n       _String __u8str{_CharAlloc{__a}};\n-      if (__str_codecvt_out(__first, __last, __u8str, __cvt))\n-\t{\n-\t  if constexpr (is_same_v<_CharT, char>)\n-\t    return __u8str;\n-#ifdef _GLIBCXX_USE_CHAR8_T\n-\t  else if constexpr (is_same_v<_CharT, char8_t>)\n-\t    {\n-\t      const char* __f = __u8str.data();\n-\t      const char* __l = __f + __u8str.size();\n-\t      _WString __wstr(__f, __l);\n-\t      return __wstr;\n-\t    }\n-#endif\n-\t  else\n-\t    {\n-\t      _WString __wstr;\n-\t      // use codecvt_utf8<_CharT> to convert UTF-8 to wide string\n-\t      codecvt_utf8<_CharT> __cvt;\n-\t      const char* __f = __u8str.data();\n-\t      const char* __l = __f + __u8str.size();\n-\t      if (__str_codecvt_in(__f, __l, __wstr, __cvt))\n-\t\treturn __wstr;\n-\t    }\n-\t}\n+      const value_type* __wfirst = __str.data();\n+      const value_type* __wlast = __wfirst + __str.size();\n+      if (__str_codecvt_out_all(__wfirst, __wlast, __u8str, __cvt)) {\n+      if constexpr (is_same_v<_CharT, char>)\n+\treturn __u8str; // XXX assumes native ordinary encoding is UTF-8.\n+      else {\n+\n+      const char* __first = __u8str.data();\n+      const char* __last = __first + __u8str.size();\n #else\n+      const value_type* __first = __str.data();\n+      const value_type* __last = __first + __str.size();\n+#endif\n+\n+      // Convert UTF-8 string to requested format.\n #ifdef _GLIBCXX_USE_CHAR8_T\n       if constexpr (is_same_v<_CharT, char8_t>)\n-\t{\n-\t  basic_string<_CharT, _Traits, _Allocator> __wstr{__first, __last, __a};\n-\t  return __wstr;\n-\t}\n+\treturn _WString(__first, __last, __a);\n       else\n-\t{\n #endif\n-\t  codecvt_utf8<_CharT> __cvt;\n-\t  basic_string<_CharT, _Traits, _Allocator> __wstr{__a};\n-\t  if (__str_codecvt_in(__first, __last, __wstr, __cvt))\n+\t{\n+\t  // Convert UTF-8 to wide string.\n+\t  _WString __wstr(__a);\n+\t  struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;\n+\t  if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))\n \t    return __wstr;\n-#ifdef _GLIBCXX_USE_CHAR8_T\n \t}\n-#endif\n+\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      } }\n #endif\n       _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t    \"Cannot convert character sequence\",\n@@ -1038,7 +1028,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     path::string(const _Allocator& __a) const\n     {\n       if constexpr (is_same_v<_CharT, value_type>)\n-\treturn { _M_pathname, __a };\n+\treturn { _M_pathname.c_str(), _M_pathname.length(), __a };\n       else\n \treturn _S_str_convert<_CharT, _Traits>(_M_pathname, __a);\n     }\n@@ -1060,11 +1050,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n     std::string __str;\n-    // convert from native encoding to UTF-8\n-    codecvt_utf8<value_type> __cvt;\n+    // convert from native wide encoding (assumed to be UTF-16) to UTF-8\n+    std::codecvt_utf8_utf16<value_type> __cvt;\n     const value_type* __first = _M_pathname.data();\n     const value_type* __last = __first + _M_pathname.size();\n-    if (__str_codecvt_out(__first, __last, __str, __cvt))\n+    if (__str_codecvt_out_all(__first, __last, __str, __cvt))\n       return __str;\n     _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t  \"Cannot convert character sequence\","}, {"sha": "b29954590e0b054dce6775940b72446c3c8ff460", "filename": "libstdc++-v3/include/bits/locale_conv.h", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -86,23 +86,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return false;\n \t}\n \n-      if (__result == codecvt_base::noconv)\n-\t{\n-\t  // The codecvt facet will only return noconv when the types are\n-\t  // the same, so avoid instantiating basic_string::assign otherwise\n-\t  if _GLIBCXX17_CONSTEXPR (is_same<typename _Codecvt::intern_type,\n-\t\t\t\t\t   typename _Codecvt::extern_type>())\n-\t    {\n-\t      __outstr.assign(__first, __last);\n-\t      __count = __last - __first;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  __outstr.resize(__outchars);\n-\t  __count = __next - __first;\n-\t}\n+      // The codecvt facet will only return noconv when the types are\n+      // the same, so avoid instantiating basic_string::assign otherwise\n+      if _GLIBCXX17_CONSTEXPR (is_same<typename _Codecvt::intern_type,\n+\t\t\t\t       typename _Codecvt::extern_type>())\n+\tif (__result == codecvt_base::noconv)\n+\t  {\n+\t    __outstr.assign(__first, __last);\n+\t    __count = __last - __first;\n+\t    return true;\n+\t  }\n \n+      __outstr.resize(__outchars);\n+      __count = __next - __first;\n       return true;\n     }\n \n@@ -124,6 +120,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t      __count, __fn);\n     }\n \n+  // As above, but with no __count parameter\n   template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n     inline bool\n     __str_codecvt_in(const char* __first, const char* __last,\n@@ -135,6 +132,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);\n     }\n \n+  // As above, but returns false for partial conversion\n+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n+    inline bool\n+    __str_codecvt_in_all(const char* __first, const char* __last,\n+\t\t\t basic_string<_CharT, _Traits, _Alloc>& __outstr,\n+\t\t\t const codecvt<_CharT, char, _State>& __cvt)\n+    {\n+      _State __state = {};\n+      size_t __n;\n+      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n)\n+\t&& (__n == (__last - __first));\n+    }\n+\n   // Convert wide character string to narrow.\n   template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n     inline bool\n@@ -153,6 +163,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t      __count, __fn);\n     }\n \n+  // As above, but with no __count parameter\n   template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n     inline bool\n     __str_codecvt_out(const _CharT* __first, const _CharT* __last,\n@@ -164,6 +175,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);\n     }\n \n+  // As above, but returns false for partial conversions\n+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n+    inline bool\n+    __str_codecvt_out_all(const _CharT* __first, const _CharT* __last,\n+\t\t\t  basic_string<char, _Traits, _Alloc>& __outstr,\n+\t\t\t  const codecvt<_CharT, char, _State>& __cvt)\n+    {\n+      _State __state = {};\n+      size_t __n;\n+      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n)\n+\t&& (__n == (__last - __first));\n+    }\n+\n #ifdef _GLIBCXX_USE_CHAR8_T\n \n   // Convert wide character string to narrow."}, {"sha": "a3655f616f27584ba8c65cc76269dbe6dbabf8e1", "filename": "libstdc++-v3/include/experimental/bits/fs_path.h", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -580,28 +580,38 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     }\n \n   /// Create a path from a UTF-8-encoded sequence of char\n-  // TODO constrain with _Path<Source> and __value_type_is_char\n-  template<typename _Source>\n+  // TODO constrain with _Path<InputIterator, InputIterator> and __value_type_is_char\n+  template<typename _InputIterator>\n     inline path\n-    u8path(const _Source& __source)\n+    u8path(_InputIterator __first, _InputIterator __last)\n     {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-      return path{ path::string_type{__source} };\n+      // XXX This assumes native wide encoding is UTF-16.\n+      std::codecvt_utf8_utf16<path::value_type> __cvt;\n+      path::string_type __tmp;\n+      const std::string __u8str{__first, __last};\n+      const char* const __ptr = __u8str.data();\n+      if (__str_codecvt_in_all(__ptr, __ptr + __u8str.size(), __tmp, __cvt))\n+\treturn path{ __tmp };\n+      _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t    \"Cannot convert character sequence\",\n+\t    std::make_error_code(errc::illegal_byte_sequence)));\n #else\n-      return path{ __source };\n+      return path{ __first, __last };\n #endif\n     }\n \n   /// Create a path from a UTF-8-encoded sequence of char\n-  // TODO constrain with _Path<InputIterator, InputIterator> and __value_type_is_char\n-  template<typename _InputIterator>\n+  // TODO constrain with _Path<Source> and __value_type_is_char\n+  template<typename _Source>\n     inline path\n-    u8path(_InputIterator __first, _InputIterator __last)\n+    u8path(const _Source& __source)\n     {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-      return path{ path::string_type{__first, __last} };\n+      std::string __s = path::_S_string_from_iter(__source);\n+      return filesystem::u8path(__s.data(), __s.data() + __s.size());\n #else\n-      return path{ __first, __last };\n+      return path{ __source };\n #endif\n     }\n \n@@ -668,7 +678,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \tusing _Cvt = std::codecvt<wchar_t, char, mbstate_t>;\n \tconst auto& __cvt = std::use_facet<_Cvt>(std::locale{});\n \tstd::wstring __wstr;\n-\tif (__str_codecvt_in(__f, __l, __wstr, __cvt))\n+\tif (__str_codecvt_in_all(__f, __l, __wstr, __cvt))\n \t    return __wstr;\n \t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t      \"Cannot convert character sequence\",\n@@ -678,20 +688,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       static string_type\n       _S_wconvert(const _CharT* __f, const _CharT* __l, false_type)\n       {\n-\tstd::codecvt_utf8<_CharT> __cvt;\n-\tstd::string __str;\n-\tif (__str_codecvt_out(__f, __l, __str, __cvt))\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+\tif constexpr (is_same<_CharT, char8_t>::value)\n+\t  return _S_wconvert((const char*)__f, (const char*)__l, true_type());\n+\telse\n+#endif\n \t  {\n-\t    const char* __f2 = __str.data();\n-\t    const char* __l2 = __f2 + __str.size();\n-\t    std::codecvt_utf8<wchar_t> __wcvt;\n-\t    std::wstring __wstr;\n-\t    if (__str_codecvt_in(__f2, __l2, __wstr, __wcvt))\n-\t      return __wstr;\n+\t    struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n+\t    { } __cvt;\n+\t    std::string __str;\n+\t    if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n+\t      {\n+\t\tconst char* __f2 = __str.data();\n+\t\tconst char* __l2 = __f2 + __str.size();\n+\t\tstd::codecvt_utf8_utf16<wchar_t> __wcvt;\n+\t\tstd::wstring __wstr;\n+\t\tif (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n+\t\t  return __wstr;\n+\t      }\n+\t    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t\t  \"Cannot convert character sequence\",\n+\t\t  std::make_error_code(errc::illegal_byte_sequence)));\n \t  }\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"Cannot convert character sequence\",\n-\t      std::make_error_code(errc::illegal_byte_sequence)));\n       }\n \n       static string_type\n@@ -705,16 +723,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       {\n #ifdef _GLIBCXX_USE_CHAR8_T\n \tif constexpr (is_same<_CharT, char8_t>::value)\n-\t  {\n-\t    string_type __str(__f, __l);\n-\t    return __str;\n-\t  }\n+\t  return string_type(__f, __l);\n \telse\n \t  {\n #endif\n-\t    std::codecvt_utf8<_CharT> __cvt;\n+\t    struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n+\t    { } __cvt;\n \t    std::string __str;\n-\t    if (__str_codecvt_out(__f, __l, __str, __cvt))\n+\t    if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n \t      return __str;\n #ifdef _GLIBCXX_USE_CHAR8_T\n \t  }\n@@ -887,18 +903,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       if (is_same<_CharT, value_type>::value)\n \treturn { _M_pathname.begin(), _M_pathname.end(), __a };\n \n+      using _WString = basic_string<_CharT, _Traits, _Allocator>;\n+\n       const value_type* __first = _M_pathname.data();\n       const value_type* __last = __first + _M_pathname.size();\n \n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n       using _CharAlloc = __alloc_rebind<_Allocator, char>;\n       using _String = basic_string<char, char_traits<char>, _CharAlloc>;\n-      using _WString = basic_string<_CharT, _Traits, _Allocator>;\n \n-      // use codecvt_utf8<wchar_t> to convert native string to UTF-8\n-      codecvt_utf8<value_type> __cvt;\n+      // First convert native string from UTF-16 to to UTF-8.\n+      // XXX This assumes that the execution wide-character set is UTF-16.\n+      codecvt_utf8_utf16<value_type> __cvt;\n       _String __u8str{_CharAlloc{__a}};\n-      if (__str_codecvt_out(__first, __last, __u8str, __cvt))\n+      if (__str_codecvt_out_all(__first, __last, __u8str, __cvt))\n \t{\n \t  struct\n \t  {\n@@ -916,41 +934,35 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t          return std::__addressof(__to);\n \t        }\n \t      else\n-\t        {\n #endif\n-\t          // use codecvt_utf8<_CharT> to convert UTF-8 to wide string\n-\t          codecvt_utf8<_CharT> __cvt;\n+\t        {\n+\t          // Convert UTF-8 to wide string.\n+\t          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n+\t\t  { } __cvt;\n \t          const char* __f = __from.data();\n \t          const char* __l = __f + __from.size();\n-\t          if (__str_codecvt_in(__f, __l, __to, __cvt))\n+\t          if (__str_codecvt_in_all(__f, __l, __to, __cvt))\n \t\t    return std::__addressof(__to);\n-#ifdef _GLIBCXX_USE_CHAR8_T\n \t        }\n-#endif\n \t      return nullptr;\n \t    }\n \t  } __dispatch;\n-\t  _WString __wstr;\n+\t  _WString __wstr(__a);\n \t  if (auto* __p = __dispatch(__u8str, __wstr, is_same<_CharT, char>{}))\n \t    return *__p;\n \t}\n #else\n #ifdef _GLIBCXX_USE_CHAR8_T\n       if constexpr (is_same<_CharT, char8_t>::value)\n-        {\n-          basic_string<_CharT, _Traits, _Allocator> __wstr{__first, __last, __a};\n-          return __wstr;\n-        }\n+          return _WString(__first, __last, __a);\n       else\n-        {\n #endif\n-          codecvt_utf8<_CharT> __cvt;\n-          basic_string<_CharT, _Traits, _Allocator> __wstr{__a};\n-          if (__str_codecvt_in(__first, __last, __wstr, __cvt))\n+        {\n+          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;\n+          _WString __wstr(__a);\n+          if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))\n \t    return __wstr;\n-#ifdef _GLIBCXX_USE_CHAR8_T\n         }\n-#endif\n #endif\n       _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t    \"Cannot convert character sequence\",\n@@ -974,11 +986,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n     std::string __str;\n-    // convert from native encoding to UTF-8\n-    codecvt_utf8<value_type> __cvt;\n+    // convert from native wide encoding (assumed to be UTF-16) to UTF-8\n+    std::codecvt_utf8_utf16<value_type> __cvt;\n     const value_type* __first = _M_pathname.data();\n     const value_type* __last = __first + _M_pathname.size();\n-    if (__str_codecvt_out(__first, __last, __str, __cvt))\n+    if (__str_codecvt_out_all(__first, __last, __str, __cvt))\n       return __str;\n     _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t  \"Cannot convert character sequence\","}, {"sha": "82ac736f82a07d2cd78a9ce9c24b13dcaf6f5d56", "filename": "libstdc++-v3/src/c++17/fs_path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_path.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -1894,7 +1894,7 @@ path::_S_convert_loc(const char* __first, const char* __last,\n #if _GLIBCXX_USE_WCHAR_T\n   auto& __cvt = std::use_facet<codecvt<wchar_t, char, mbstate_t>>(__loc);\n   basic_string<wchar_t> __ws;\n-  if (!__str_codecvt_in(__first, __last, __ws, __cvt))\n+  if (!__str_codecvt_in_all(__first, __last, __ws, __cvt))\n     _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t  \"Cannot convert character sequence\",\n \t  std::make_error_code(errc::illegal_byte_sequence)));"}, {"sha": "edf7c67c01b9404f7aad8c23333d460e2b299237", "filename": "libstdc++-v3/src/filesystem/path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -500,7 +500,7 @@ path::_S_convert_loc(const char* __first, const char* __last,\n #if _GLIBCXX_USE_WCHAR_T\n   auto& __cvt = std::use_facet<codecvt<wchar_t, char, mbstate_t>>(__loc);\n   basic_string<wchar_t> __ws;\n-  if (!__str_codecvt_in(__first, __last, __ws, __cvt))\n+  if (!__str_codecvt_in_all(__first, __last, __ws, __cvt))\n     _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t  \"Cannot convert character sequence\",\n \t  std::make_error_code(errc::illegal_byte_sequence)));"}, {"sha": "e0d10e56e8c0b559b59322792313bc10d97b751e", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/construct/90281.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2F90281.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2F90281.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2F90281.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::filesystem;\n+\n+template<typename C = fs::path::value_type>\n+const C* code_units()\n+{\n+  if constexpr (std::is_same_v<C, char>)\n+    return \"\\xf0\\x9d\\x84\\x9e\";\n+  else\n+    return L\"\\xD834\\xDD1E\";\n+}\n+\n+// PR libstdc++/90281\n+void\n+test01()\n+{\n+  const fs::path::string_type expected = code_units();\n+\n+  fs::path p8 = fs::u8path(u8\"\\U0001D11E\");\n+  VERIFY( p8.native() == expected );\n+  fs::path p16(u\"\\U0001D11E\");\n+  VERIFY( p16.native() == expected );\n+  fs::path p32(U\"\\U0001D11E\");\n+  VERIFY( p32.native() == expected );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "aff722b586758c6cc163c64ea558add87952d006", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/factory/u8path.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Ffactory%2Fu8path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Ffactory%2Fu8path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Ffactory%2Fu8path.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  fs::path p = fs::u8path(\"\");\n+  VERIFY( p.empty() );\n+\n+  p = fs::u8path(\"filename\");\n+  VERIFY( p.u8string() == u8\"filename\" );\n+\n+  p = fs::u8path(\"\\xf0\\x9d\\x84\\x9e\");\n+  VERIFY( p.u8string() == u8\"\\U0001D11E\" );\n+}\n+\n+void\n+test02()\n+{\n+  // These calls to u8path are undefined, because they fail to meet the\n+  // requirement that the input is valid UTF-8 data. For Windows u8path\n+  // will fail. For POSIX constructing an invalid path appears to work,\n+  // but will fail when converted to a different encoding.\n+\n+  try {\n+    auto p = fs::u8path(\"\\xf0\\x9d\"); // incomplete surrogate pair\n+    p.u16string();\n+    VERIFY( false );\n+  } catch(const fs::filesystem_error&) {\n+  }\n+\n+  try {\n+    auto p = fs::u8path(\"\\xf0\"); // incomplete multibyte character\n+    p.u16string();\n+    VERIFY( false );\n+  } catch(const fs::filesystem_error&) {\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "bdb52a20e143bbf108abd913a93ee8c7de8b0dff", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/native/alloc.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Falloc.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -0,0 +1,92 @@\n+// Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <filesystem>\n+#include <string>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+template<typename C>\n+  using alloc = __gnu_test::uneq_allocator<C>;\n+\n+void\n+test01()\n+{\n+  using namespace std::filesystem;\n+  path p;\n+\n+  auto str = p.string<char>(alloc<char>(1));\n+  VERIFY( str == \"\" );\n+  VERIFY( str.get_allocator() == alloc<char>(1) );\n+\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+  auto str8 = p.string<char8_t>(alloc<char8_t>(1));\n+  VERIFY( str8 == u8\"\" );\n+  VERIFY( str8.get_allocator() == alloc<char8_t>(1) );\n+#endif\n+\n+  auto strw = p.string<wchar_t>(alloc<wchar_t>(2));\n+  VERIFY( strw == L\"\" );\n+  VERIFY( strw.get_allocator() == alloc<wchar_t>(2) );\n+\n+  auto str16 = p.string<char16_t>(alloc<char16_t>(3));\n+  VERIFY( str16 == u\"\" );\n+  VERIFY( str16.get_allocator() == alloc<char16_t>(3) );\n+\n+  auto str32 = p.string<char32_t>(alloc<char32_t>(4));\n+  VERIFY( str32 == U\"\" );\n+  VERIFY( str32.get_allocator() == alloc<char32_t>(4) );\n+}\n+\n+void\n+test02()\n+{\n+  using namespace std::filesystem;\n+  path p = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+  auto str = p.string<char>(alloc<char>(1));\n+  VERIFY( str == \"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str.get_allocator() == alloc<char>(1) );\n+\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+  auto str8 = p.string<char8_t>(alloc<char8_t>(1));\n+  VERIFY( str8 == u8\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str8.get_allocator() == alloc<char8_t>(1) );\n+#endif\n+\n+  auto strw = p.string<wchar_t>(alloc<wchar_t>(2));\n+  VERIFY( strw == L\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( strw.get_allocator() == alloc<wchar_t>(2) );\n+\n+  auto str16 = p.string<char16_t>(alloc<char16_t>(3));\n+  VERIFY( str16 == u\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str16.get_allocator() == alloc<char16_t>(3) );\n+\n+  auto str32 = p.string<char32_t>(alloc<char32_t>(4));\n+  VERIFY( str32 == U\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str32.get_allocator() == alloc<char32_t>(4) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "2ed58e379ef79fcb750ee6da1ddec6e44f02d0c2", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/native/string.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -62,9 +62,36 @@ test02()\n   VERIFY( str32 == p.u32string() );\n }\n \n+void\n+test03()\n+{\n+  std::filesystem::path p;\n+  auto str8 = p.u8string();\n+  VERIFY( str8 == u8\"\" );\n+  auto str16 = p.u16string();\n+  VERIFY( str16 == u\"\" );\n+  auto str32 = p.u32string();\n+  VERIFY( str32 == U\"\" );\n+}\n+\n+void\n+test04()\n+{\n+  // PR libstdc++/90281\n+  auto p = std::filesystem::u8path(\"\\xf0\\x9d\\x84\\x9e\");\n+  auto str8 = p.u8string();\n+  VERIFY( str8 == u8\"\\U0001D11E\" );\n+  auto str16 = p.u16string();\n+  VERIFY( str16 == u\"\\U0001D11E\" );\n+  auto str32 = p.u32string();\n+  VERIFY( str32 == U\"\\U0001D11E\" );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test03();\n+  test04();\n }"}, {"sha": "3640b00ec53ff9a13a58a2f66ba313fc32d6f06c", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/construct/90281.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2F90281.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2F90281.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2F90281.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-lstdc++fs\" }\n+// { dg-do run { target c++11 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::experimental::filesystem;\n+\n+template<bool B = std::is_same<fs::path::value_type, char>::value>\n+typename std::enable_if<B, const char*>::type\n+code_units()\n+{ return \"\\xf0\\x9d\\x84\\x9e\"; }\n+\n+template<bool B = std::is_same<fs::path::value_type, wchar_t>::value>\n+typename std::enable_if<B, const wchar_t*>::type\n+code_units()\n+{ return L\"\\xD834\\xDD1E\"; }\n+\n+// PR libstdc++/90281\n+void\n+test01()\n+{\n+  const fs::path::string_type expected = code_units();\n+\n+  fs::path p8 = fs::u8path(u8\"\\U0001D11E\");\n+  VERIFY( p8.native() == expected );\n+  fs::path p16(u\"\\U0001D11E\");\n+  VERIFY( p16.native() == expected );\n+  fs::path p32(U\"\\U0001D11E\");\n+  VERIFY( p32.native() == expected );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "bdeb3946a15f677aa2286b7ce6f03fb0dc70e2c6", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/factory/u8path.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Ffactory%2Fu8path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Ffactory%2Fu8path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Ffactory%2Fu8path.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-lstdc++fs\" }\n+// { dg-do run { target c++11 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::experimental::filesystem;\n+\n+void\n+test01()\n+{\n+  fs::path p = fs::u8path(\"\");\n+  VERIFY( p.empty() );\n+\n+  p = fs::u8path(\"filename\");\n+  VERIFY( p.u8string() == u8\"filename\" );\n+\n+  p = fs::u8path(\"\\xf0\\x9d\\x84\\x9e\");\n+  VERIFY( p.u8string() == u8\"\\U0001D11E\" );\n+}\n+\n+void\n+test02()\n+{\n+  // These calls to u8path are undefined, because they fail to meet the\n+  // requirement that the input is valid UTF-8 data. For Windows u8path\n+  // will fail. For POSIX constructing an invalid path appears to work,\n+  // but will fail when converted to a different encoding.\n+\n+  try {\n+    auto p = fs::u8path(\"\\xf0\\x9d\"); // incomplete surrogate pair\n+    p.u16string();\n+    VERIFY( false );\n+  } catch(const fs::filesystem_error&) {\n+  }\n+\n+  try {\n+    auto p = fs::u8path(\"\\xf0\"); // incomplete multibyte character\n+    p.u16string();\n+    VERIFY( false );\n+  } catch(const fs::filesystem_error&) {\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "ef9ea67928fb6797a6bacbafba880e22a2d8a4f0", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/native/alloc.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnative%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnative%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnative%2Falloc.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-lstdc++fs\" }\n+// { dg-do run { target c++11 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <string>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+template<typename C>\n+  using alloc = __gnu_test::uneq_allocator<C>;\n+\n+void\n+test01()\n+{\n+  using namespace std::experimental::filesystem;\n+  path p;\n+\n+  auto str = p.string<char>(alloc<char>(1));\n+  VERIFY( str == \"\" );\n+  VERIFY( str.get_allocator() == alloc<char>(1) );\n+\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+  auto str8 = p.string<char8_t>(alloc<char8_t>(1));\n+  VERIFY( str8 == u8\"\" );\n+  VERIFY( str8.get_allocator() == alloc<char8_t>(1) );\n+#endif\n+\n+  auto strw = p.string<wchar_t>(alloc<wchar_t>(2));\n+  VERIFY( strw == L\"\" );\n+  VERIFY( strw.get_allocator() == alloc<wchar_t>(2) );\n+\n+  auto str16 = p.string<char16_t>(alloc<char16_t>(3));\n+  VERIFY( str16 == u\"\" );\n+  VERIFY( str16.get_allocator() == alloc<char16_t>(3) );\n+\n+  auto str32 = p.string<char32_t>(alloc<char32_t>(4));\n+  VERIFY( str32 == U\"\" );\n+  VERIFY( str32.get_allocator() == alloc<char32_t>(4) );\n+}\n+\n+void\n+test02()\n+{\n+  using namespace std::experimental::filesystem;\n+  path p = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+  auto str = p.string<char>(alloc<char>(1));\n+  VERIFY( str == \"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str.get_allocator() == alloc<char>(1) );\n+\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+  auto str8 = p.string<char8_t>(alloc<char8_t>(1));\n+  VERIFY( str8 == u8\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str8.get_allocator() == alloc<char8_t>(1) );\n+#endif\n+\n+  auto strw = p.string<wchar_t>(alloc<wchar_t>(2));\n+  VERIFY( strw == L\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( strw.get_allocator() == alloc<wchar_t>(2) );\n+\n+  auto str16 = p.string<char16_t>(alloc<char16_t>(3));\n+  VERIFY( str16 == u\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str16.get_allocator() == alloc<char16_t>(3) );\n+\n+  auto str32 = p.string<char32_t>(alloc<char32_t>(4));\n+  VERIFY( str32 == U\"abcdefghijklmnopqrstuvwxyz\" );\n+  VERIFY( str32.get_allocator() == alloc<char32_t>(4) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "b78ba2b1dbf8b6fefa89c2b0ba45057216b17b9f", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/native/string.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b1320ee5e2e9e107e092162d1c82b682504534/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc?ref=26b1320ee5e2e9e107e092162d1c82b682504534", "patch": "@@ -63,9 +63,36 @@ test02()\n   VERIFY( str32 == p.u32string() );\n }\n \n+void\n+test03()\n+{\n+  std::experimental::filesystem::path p;\n+  auto str8 = p.u8string();\n+  VERIFY( str8 == u8\"\" );\n+  auto str16 = p.u16string();\n+  VERIFY( str16 == u\"\" );\n+  auto str32 = p.u32string();\n+  VERIFY( str32 == U\"\" );\n+}\n+\n+void\n+test04()\n+{\n+  // PR libstdc++/90281\n+  auto p = std::experimental::filesystem::u8path(\"\\xf0\\x9d\\x84\\x9e\");\n+  auto str8 = p.u8string();\n+  VERIFY( str8 == u8\"\\U0001D11E\" );\n+  auto str16 = p.u16string();\n+  VERIFY( str16 == u\"\\U0001D11E\" );\n+  auto str32 = p.u32string();\n+  VERIFY( str32 == U\"\\U0001D11E\" );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test03();\n+  test04();\n }"}]}