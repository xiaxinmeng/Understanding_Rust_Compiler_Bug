{"sha": "58b29fa3426e8b7ad37e5849b14c4152f0c2abb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThiMjlmYTM0MjZlOGI3YWQzN2U1ODQ5YjE0YzQxNTJmMGMyYWJiMQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-02-12T15:12:21Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-02-12T15:12:21Z"}, "message": "trans-array.c (gfc_get_proc_ifc_for_expr): New function.\n\n\t* trans-array.c (gfc_get_proc_ifc_for_expr): New function.\n\t(gfc_walk_elemental_function_args): Move code to\n\tgfc_get_proc_ifc_for_expr and call it.\n\nFrom-SVN: r184139", "tree": {"sha": "8ce2fd42260e0bf235e613ee4366567df490bd65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ce2fd42260e0bf235e613ee4366567df490bd65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1/comments", "author": null, "committer": null, "parents": [{"sha": "12e3c3961436e0bc19f7fcbf7dd5ba6d556b0803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e3c3961436e0bc19f7fcbf7dd5ba6d556b0803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12e3c3961436e0bc19f7fcbf7dd5ba6d556b0803"}], "stats": {"total": 58, "additions": 40, "deletions": 18}, "files": [{"sha": "6883032022fcac6e7b3e99f6a317085224969168", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=58b29fa3426e8b7ad37e5849b14c4152f0c2abb1", "patch": "@@ -1,3 +1,9 @@\n+2012-02-12  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_get_proc_ifc_for_expr): New function.\n+\t(gfc_walk_elemental_function_args): Move code to\n+\tgfc_get_proc_ifc_for_expr and call it.\n+\n 2012-02-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52151"}, {"sha": "ac39fdf8a23898a56aa2fdfe6ea4c11d130fb080", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b29fa3426e8b7ad37e5849b14c4152f0c2abb1/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=58b29fa3426e8b7ad37e5849b14c4152f0c2abb1", "patch": "@@ -8426,6 +8426,36 @@ gfc_reverse_ss (gfc_ss * ss)\n }\n \n \n+/* Given an expression refering to a procedure, return the symbol of its\n+   interface.  We can't get the procedure symbol directly as we have to handle\n+   the case of (deferred) type-bound procedures.  */\n+\n+gfc_symbol *\n+gfc_get_proc_ifc_for_expr (gfc_expr *procedure_ref)\n+{\n+  gfc_symbol *sym;\n+  gfc_ref *ref;\n+\n+  if (procedure_ref == NULL)\n+    return NULL;\n+\n+  /* Normal procedure case.  */\n+  sym = procedure_ref->symtree->n.sym;\n+\n+  /* Typebound procedure case.  */\n+  for (ref = procedure_ref->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t  && ref->u.c.component->attr.proc_pointer)\n+\tsym = ref->u.c.component->ts.interface;\n+      else\n+\tsym = NULL;\n+    }\n+\n+  return sym;\n+}\n+\n+\n /* Walk the arguments of an elemental function.\n    PROC_EXPR is used to check whether an argument is permitted to be absent.  If\n    it is NULL, we don't do the check and the argument is assumed to be present.\n@@ -8435,6 +8465,7 @@ gfc_ss *\n gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n \t\t\t\t  gfc_expr *proc_expr, gfc_ss_type type)\n {\n+  gfc_symbol *proc_ifc;\n   gfc_formal_arglist *dummy_arg;\n   int scalar;\n   gfc_ss *head;\n@@ -8444,24 +8475,9 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n   head = gfc_ss_terminator;\n   tail = NULL;\n \n-  if (proc_expr)\n-    {\n-      gfc_ref *ref;\n-\n-      /* Normal procedure case.  */\n-      dummy_arg = proc_expr->symtree->n.sym->formal;\n-\n-      /* Typebound procedure case.  */\n-      for (ref = proc_expr->ref; ref; ref = ref->next)\n-\t{\n-\t  if (ref->type == REF_COMPONENT\n-\t      && ref->u.c.component->attr.proc_pointer\n-\t      && ref->u.c.component->ts.interface)\n-\t    dummy_arg = ref->u.c.component->ts.interface->formal;\n-\t  else\n-\t    dummy_arg = NULL;\n-\t}\n-    }\n+  proc_ifc = gfc_get_proc_ifc_for_expr (proc_expr);\n+  if (proc_ifc)\n+    dummy_arg = proc_ifc->formal;\n   else\n     dummy_arg = NULL;\n "}]}