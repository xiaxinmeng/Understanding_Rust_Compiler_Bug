{"sha": "301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAxZDAzYWY4YTNjYmY1MWU3OWZmMzVjMWFhNzFhNmYzNTM3MDljNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2001-12-17T15:05:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2001-12-17T15:05:40Z"}, "message": "target.h (asm_out.byte_op, [...]): New fields.\n\n\t* target.h (asm_out.byte_op, asm_out.aligned_op, asm_out.unaligned_op,\n\tasm_out.integer): New fields.\n\t* target-def.h (TARGET_ASM_BYTE_OP, TARGET_ASM_ALIGNED_[HSDT]I_OP,\n\tTARGET_ASM_UNALIGNED_[HSDT]I_OP, TARGET_ASM_INTEGER): New initialisers.\n\t(TARGET_ASM_ALIGNED_INT_OP, TARGET_ASM_UNALIGNED_INT_OP): Collect\n\tthe individual initialisers together.\n\t(TARGET_ASM_OUT): Add the new initialisers.\n\t* output.h (assemble_integer): Return bool.\n\t(integer_asm_op): Declare.\n\t(default_assemble_integer): Declare.\n\t(assemble_aligned_integer): New interface to assemble_integer.\n\t* varasm.c (integer_asm_op): New function to select pseudo-op.\n\t(default_assemble_integer): Default implementation of asm_out.integer.\n\t(assemble_integer): Use the new target hook.  Split objects into\n\twords or bytes if the target hook fails.  Return bool.\n\t* doc/tm.texi (ASM_OUTPUT_CHAR, ASM_OUTPUT_BYTE, ASM_OUTPUT_SHORT,\n\tASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT, ASM_OUTPUT_QUADRUPLE_INT,\n\tUNALIGNED_SHORT_ASM_OP,\tUNALIGNED_INT_ASM_OP,\n\tUNALIGNED_DOUBLE_INT_ASM_OP): Undocument.\n\tDocument new target hooks.\n\n\t* defaults.h (ASM_OUTPUT_ADDR_VEC_ELT): Use integer_asm_op.\n\t* dwarf2asm.c (unaligned_integer_asm_op): Remove.\n\t(dw2_assemble_integer): New.\n\t(dw2_asm_output_data, dw2_asm_output_delta, dw2_asm_output_offset,\n\tdw2_asm_output_pcrel, dw2_asm_output_addr, dw2_asm_output_addr_rtx,\n\tdw2_asm_output_encoded_addr_rtx): Use it.\n\t(dw2_asm_output_nstring): Use assemble_integer for the null terminator.\n\t(dw2_asm_output_data_uleb128, dw2_asm_output_data_sleb128): Use\n\tinteger_asm_op to get the byte pseudo-op.  Use assemble_integer\n        if it returns NULL.\n\t* dwarf2asm.h (dw2_assemble_integer): Declare.\n\t* dwarfout.c: Include dwarf2asm.h.  Use dwarf2 functions for the\n\tdefault\timplementation of most macros.\n\t(output_unsigned_leb128): Use dw2_asm_output_data.\n\t(output_signed_leb128, dwarfout_source_line): Likewise.\n\t(output_reg_number): Use dw2_assemble_integer.\n\t(generate_macinfo_entry): Separate the type and offset arguments.\n\tUse assemble_integer to write the value.\n\t(dwarfout_start_source_file): Update generate_macinfo_entry usage.\n\t(dwarfout_end_source_file, dwarfout_define, dwarfout_undef): Likewise.\n\t* final.c (output_addr_const): Don't put brackets round a subtracted\n\tsymbol value or \".\".\n\t* halfpic.c (half_pic_finish): Use assemble_aligned_integer.\n\n\t* config/1750a/1750a.c (assemble_integer_1750a): New,\n\t* config/alpha/alpha.h (literal_section): Avoid ASM_OUTPUT_INT.\n\t* config/arc/arc.c (arc_assemble_integer): New.\n\t* config/arc/arc.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n\t* config/arm/arm.c (arm_poke_function_name): Likewise.\n\t(arm_assemble_integer): New, extracted from...\n\t* config/arm/arm.h (OUTPUT_INT_ADDR_CONST): ...here, now removed.\n\t(ARM_TRAMPOLINE_TEMPLATE, ARM_FUNCTION_PROFILER): Avoid ASM_OUTPUT_INT.\n\t(ARM_FUNCTION_PROFILER): Likewise.\n\t* config/avr/avr-protos.h (asm_output_byte): Remove.\n\t(asm_output_char, asm_output_short): Remove.\n\t* config/avr/avr.c (avr_assemble_integer): New.\n\t(asm_output_byte, asm_output_char, asm_output_short): Remove.\n\t* config/clipper/clipper.h (ASM_LONG): Remove.\n\t* config/dsp16xx/dsp16xx-protos.h (asm_output_long): Remove.\n\t* config/dsp16xx/dsp16xx.c (asm_output_long): Remove.\n\t* config/elxsi/elxsi.c (elxsi_assemble_integer): New.\n\t* config/i370/i370.c (i370_hlasm_assemble_integer): New.\n\t* config/i370/i370.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_SHORT.\n\t(ASM_BYTE, ASM_SHORT, ASM_LONG): Delete.\n\t* config/i386/att.h, (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n\t* config/i386/linux.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Use\n\tASM_LONG instead of UNALIGNED_INT_ASM_OP.\n\t* config/i386/sco5.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Likewise.\n\t(ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n\t* config/i386/sysv4.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Use\n\tASM_LONG instead of UNALIGNED_INT_ASM_OP.\n\t* config/i860/fx2800.h (ASM_FILE_END): Avoid ASM_LONG.\n\t* config/i860/i860.c (i860_output_function_epilogue): Likewise.\n\t* config/i860/i860.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n\t(ASM_SHORT, ASM_LONG): Undefine.\n\t* config/i860/paragon.h (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n\t* config/i860/sysv3.h (ASM_OUTPUT_ASCII): Likewise.\n\t* config/i960/i960.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n\t* config/ia64/ia64.c (ia64_assemble_integer): New.\n\t* config/ia64/ia64.h (ASM_OUTPUT_DWARF_OFFSET): Use integer_asm_op.\n\t(ASM_OUTPUT_DWARF_PCREL): Likewise.\n\t* config/m68hc11/m68hc11.h (ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT,\n\tASM_OUTPUT_ADDR_DIFF_ELT, ASM_OUTPUT_ADDR_VEC_ELT): Avoid ASM_LONG.\n\t(ASM_SHORT, ASM_LONG): Remove.\n\t* config/m68k/m68k.h (INT_OP_GROUP): New macro.\n\t(INT_OP_STANDARD, INT_OP_DOT_WORD, INT_OP_NO_DOT, INT_OP_DC): New\n\tmacros, the allowed values for INT_OP_GROUP.\n\t* config/m68k/amix.h (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP\n\t* config/m68k/atari.h (ASM_OUTPUT_ASCII): Likewise\n\t* config/m68k/m68kelf.h (ASM_OUTPUT_ASCII): Likewise\n\t* config/m68k/auxas.h (BYTE_ASM_OP, WORD_ASM_OP, LONG_ASM_OP): Remove.\n\t(INT_OP_GROUP): Define to INT_OP_NO_DOT.\n\t* config/m68k/dpx2.h (ASM_LONG): Undefine.\n\t(INT_OP_GROUP): Define to INT_OP_DC.\n\t* config/m68k/dpx2g.h (ASM_LONG): Undefine.\n\t* config/m68k/hp320.h (INT_OP_GROUP): Define to INT_OP_NO_DOT.\n\t* config/m68k/lynx.h (ASM_LONG): Undefine.\n\t* config/m68k/dpx2g.h (ASM_LONG): Undefine.\n\t* config/m68k/m68kelf.h (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n\t* config/m68k/m68kv4.h (ASM_OUTPUT_ASCII): Likewise.\n\t(TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_*.\n\t* config/m68k/mot3300.h (INT_OP_GROUP): Define to INT_OP_STANDARD\n\tfor GAS and INT_OP_NO_DOT otherwise.\n\t(ASM_CHAR, ASM_BYTE, ASM_SHORT, ASM_LONG): Remove.\n\t(ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT,\n\tASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Avoid ASM_LONG.\n\t(ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n\t* config/m68k/sgs.h (BYTE_ASM_OP, WORD_ASM_OP, LONG_ASM_OP): Remove.\n\t(INT_OP_GROUP): Define to INT_OP_STANDARD.\n\t(ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT,\n\tASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Avoid LONG_ASM_OP.\n\t(ASM_OUTPUT_ASCII): Avoid BYTE_ASM_OP.\n\t* config/m68k/tower-as.h (ASM_LONG): Remove.\n\t(INT_OP_GROUP): Define to INT_OP_NO_DOT.\n\t* config/m88k/m88k.c (output_tdesc): Avoid ASM_LONG.\n\t* config/m88k/m88k.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n\t(ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT): Avoid ASM_LONG.\n\t* config/mips/iris5.h (TARGET_IRIX5): Define.\n\t* config/mips/mips.c (mips_assemble_integer): New.\n\t* config/mips/sni-svr4.h (ASM_LONG): Undefine.\n\t* config/mmix/mmix-protos.h (mmix_asm_output_double_int): Remove.\n\t* config/mmix/mmix.c (mmix_assemble_integer): New.\n\t(mmix_asm_output_double_int): Remove.\n\t(mmix_print_operand): Call mmix_output_octa directly.\n\t* config/mmix/mmix.h (ASM_LONG): Remove.\n\t* config/ns32k/ns32k.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n\t* config/pa/pa.c (pa_assemble_integer): New.\n\t(pa_override_options): Only use aligned DI ops on 64-bit targets.\n\tOnly use the unaligned ops if TARGET_GAS.\n\t* config/pdp11/pdp11.c (pdp11_assemble_integer): New.\n\t* config/pdp11/pdp11.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_SHORT.\n\t* config/pj/pj.h (ASM_LONG): Undefine.\n\t* config/rs6000/linux64.h (RELOCATABLE_NEEDS_FIXUP): Undefine.\n\t* config/rs6000/rs6000.c (rs6000_assemble_integer): New, mostly\n\textracted from ASM_OUTPUT_INT in sysv4.h.  Use in_text_section()\n\tand in_toc_section() rather than the in_section variable.\n\t(rs6000_override_options): Only use DI ops when TARGET_POWERPC64.\n\t* config/rs6000/sysv4.h (TOC_SECTION_FUNCTION): Add in_toc_section().\n\t(RELOCATABLE_NEEDS_FIXUP): Define.\n\t* config/rs6000/xcoff.h (DOUBLE_INT_ASM_OP): Change space to tab.\n\t* config/s390/linux.h (ASM_SHORT, ASM_LONG, ASM_QUAD): Remove.\n\t(ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Use integer_asm_op\n\tto get the word directive.\n\t(ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n\t* config/s390/s390.c (s390_assemble_integer): New.\n\t* config/s390/s390.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY): Use\n\tinteger_asm_op to get the word directive.\n\t* config/sparc/sol2.h (ASM_SHORT, ASM_LONG): Remove.\n\t* config/sparc/sparc-protos.h (output_double_int): Remove.\n\t* config/sparc/sparc.c (output_double_int): Move to...\n\t(sparc_assemble_integer): ...this new function.\n\t(sparc_override_options): Only use .uaxword if TARGET_ARCH64.\n\t* config/sparc/sparc.h (ASM_SHORT, ASM_LONG, ASM_LONGLONG): Remove.\n\t* config/sparc/sysv4.h (ASM_LONG): Remove.\n\t(ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT): Avoid\n\tASM_LONG.\n\t* config/vax/vax.h (TRAMPOLINE_TEMPLATE): Use assemble_aligned_integer.\n\t* config/we32k/we32k.h (TRAMPOLINE_TEMPLATE): Likewise.\n\n\t* config/1750a/1750a.c, config/a29k/a29k.c, config/alpha/alpha.c,\n\tconfig/arc/arc.c, config/arm/arm.c, config/avr/avr.c, config/c4x/c4x.c,\n\tconfig/clipper/clipper.c, config/convex/convex.c, config/cris/cris.c,\n\tconfig/d30v/d30v.c, config/dsp16xx/dsp16xx.c, config/elxsi/elxsi.c,\n\tconfig/fr30/fr30.c, config/h8300/h8300.c, config/i370/i370.c,\n\tconfig/i386/i386.c, config/i860/i860.c, config/i960/i960.c,\n\tconfig/ia64/ia64.c, config/m32r/m32r.c, config/m68hc11/m68hc11.c,\n\tconfig/m68k/m68k.c, config/m88k/m88k.c, config/mips/mips.c,\n\tconfig/mmix/mmix.c, config/mn10200/mn10200.c, config/mn10300/mn10300.c,\n\tconfig/ns32k/ns32k.c, config/pa/pa.c, config/pdp11/pdp11.c,\n\tconfig/sh/sh.c, config/sparc/sparc.c, config/stormy16/stormy16.c,\n\tconfig/v850/v850.c, config/vax/vax.c, config/we32k/we32k.c\n\t(TARGET_ASM_BYTE_OP, TARGET_ASM_ALIGNED_HI_OP,\n\tTARGET_ASM_ALIGNED_SI_OP, TARGET_ASM_ALIGNED_DI_OP,\n\tTARGET_ASM_UNALIGNED_HI_OP, TARGET_ASM_UNALIGNED_SI_OP,\n\tTARGET_ASM_UNALIGNED_DI_OP, TARGET_ASM_INTEGER): Redefine as\n\tappropriate.\n\n\t* config/defaults.h, config/darwin.h, config/elfos.h, config/svr3.h,\n\tconfig/1750a/1750a.h, config/a29k/a29k.h, config/alpha/alpha.h,\n\tconfig/arc/arc.h, config/arm/arm.h, config/avr/avr.h, config/c4x/c4x.h,\n\tconfig/clipper/clipper.h, config/convex/convex.h, config/cris/cris.h,\n\tconfig/d30v/d30v.h, config/dsp16xx/dsp16xx.h, config/elxsi/elxsi.h,\n\tconfig/fr30/fr30.h, config/h8300/h8300.h, config/i370/i370.h,\n\tconfig/i386/bsd.h, config/i386/djgpp.h, config/i386/i386.h,\n\tconfig/i386/sco5.h, config/i386/sol2.h, config/i386/sun386.h,\n\tconfig/i860/i860.h, config/i960/i960.h, config/ia64/ia64.h,\n\tconfig/m32r/m32r.h, config/m68hc11/m68hc11.h, config/m68k/auxas.h,\n\tconfig/m68k/dpx2.h, config/m68k/hp320.h, config/m68k/m68k.h,\n\tconfig/m68k/mot3300.h, config/m68k/sgs.h, config/m68k/tower-as.h,\n\tconfig/m88k/m88k.h, config/mcore/mcore-elf.h, config/mcore/mcore.h,\n\tconfig/mips/iris5.h, config/mips/iris6.h, config/mips/mips.h,\n\tconfig/mmix/mmix.h, config/mn10200/mn10200.h, config/mn10300/mn10300.h\n\tconfig/ns32k/encore.h, config/ns32k/ns32k.h, config/pa/pa-64.h,\n\tconfig/pa/pa.h, config/pdp11/pdp11.h, config/pj/pj.h,\n\tconfig/romp/romp.h, config/rs6000/linux64.h, config/rs6000/rs6000.h,\n\tconfig/rs6000/sysv4.h, config/rs6000/xcoff.h, config/s390/linux.h,\n\tconfig/sh/sh.h, config/sparc/linux64.h, config/sparc/sol2.h,\n\tconfig/sparc/sp64-elf.h, config/sparc/sparc.h, config/sparc/sysv4.h,\n\tconfig/stormy16/stormy16.h, config/v850/v850.h, config/vax/vax.h,\n\tconfig/we32k/we32k.h (ASM_OUTPUT_CHAR, ASM_OUTPUT_BYTE, ASM_BYTE_OP,\n\tASM_BYTE, ASM_OUTPUT_SHORT, ASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT,\n\tUNALIGNED_SHORT_ASM_OP, UNALIGNED_INT_ASM_OP,\n\tUNALIGNED_DOUBLE_INT_ASM_OP): Undefine, where defined.\n\nFrom-SVN: r48101", "tree": {"sha": "db00089740b52986d77e25864271a24f731e7688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db00089740b52986d77e25864271a24f731e7688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/comments", "author": null, "committer": null, "parents": [{"sha": "00a8c0b430ad9ed836ab88fba25ef2acf16d3a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00a8c0b430ad9ed836ab88fba25ef2acf16d3a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00a8c0b430ad9ed836ab88fba25ef2acf16d3a0d"}], "stats": {"total": 3961, "additions": 1501, "deletions": 2460}, "files": [{"sha": "211386bc34abbf759aa94107f2a4e2115f459139", "filename": "gcc/ChangeLog", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1,3 +1,210 @@\n+2001-12-17  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* target.h (asm_out.byte_op, asm_out.aligned_op, asm_out.unaligned_op,\n+\tasm_out.integer): New fields.\n+\t* target-def.h (TARGET_ASM_BYTE_OP, TARGET_ASM_ALIGNED_[HSDT]I_OP,\n+\tTARGET_ASM_UNALIGNED_[HSDT]I_OP, TARGET_ASM_INTEGER): New initialisers.\n+\t(TARGET_ASM_ALIGNED_INT_OP, TARGET_ASM_UNALIGNED_INT_OP): Collect\n+\tthe individual initialisers together.\n+\t(TARGET_ASM_OUT): Add the new initialisers.\n+\t* output.h (assemble_integer): Return bool.\n+\t(integer_asm_op): Declare.\n+\t(default_assemble_integer): Declare.\n+\t(assemble_aligned_integer): New interface to assemble_integer.\n+\t* varasm.c (integer_asm_op): New function to select pseudo-op.\n+\t(default_assemble_integer): Default implementation of asm_out.integer.\n+\t(assemble_integer): Use the new target hook.  Split objects into\n+\twords or bytes if the target hook fails.  Return bool.\n+\t* doc/tm.texi (ASM_OUTPUT_CHAR, ASM_OUTPUT_BYTE, ASM_OUTPUT_SHORT,\n+\tASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT, ASM_OUTPUT_QUADRUPLE_INT,\n+\tUNALIGNED_SHORT_ASM_OP,\tUNALIGNED_INT_ASM_OP,\n+\tUNALIGNED_DOUBLE_INT_ASM_OP): Undocument.\n+\tDocument new target hooks.\n+\n+\t* defaults.h (ASM_OUTPUT_ADDR_VEC_ELT): Use integer_asm_op.\n+\t* dwarf2asm.c (unaligned_integer_asm_op): Remove.\n+\t(dw2_assemble_integer): New.\n+\t(dw2_asm_output_data, dw2_asm_output_delta, dw2_asm_output_offset,\n+\tdw2_asm_output_pcrel, dw2_asm_output_addr, dw2_asm_output_addr_rtx,\n+\tdw2_asm_output_encoded_addr_rtx): Use it.\n+\t(dw2_asm_output_nstring): Use assemble_integer for the null terminator.\n+\t(dw2_asm_output_data_uleb128, dw2_asm_output_data_sleb128): Use\n+\tinteger_asm_op to get the byte pseudo-op.  Use assemble_integer\n+        if it returns NULL.\n+\t* dwarf2asm.h (dw2_assemble_integer): Declare.\n+\t* dwarfout.c: Include dwarf2asm.h.  Use dwarf2 functions for the\n+\tdefault\timplementation of most macros.\n+\t(output_unsigned_leb128): Use dw2_asm_output_data.\n+\t(output_signed_leb128, dwarfout_source_line): Likewise.\n+\t(output_reg_number): Use dw2_assemble_integer.\n+\t(generate_macinfo_entry): Separate the type and offset arguments.\n+\tUse assemble_integer to write the value.\n+\t(dwarfout_start_source_file): Update generate_macinfo_entry usage.\n+\t(dwarfout_end_source_file, dwarfout_define, dwarfout_undef): Likewise.\n+\t* final.c (output_addr_const): Don't put brackets round a subtracted\n+\tsymbol value or \".\".\n+\t* halfpic.c (half_pic_finish): Use assemble_aligned_integer.\n+\n+\t* config/1750a/1750a.c (assemble_integer_1750a): New,\n+\t* config/alpha/alpha.h (literal_section): Avoid ASM_OUTPUT_INT.\n+\t* config/arc/arc.c (arc_assemble_integer): New.\n+\t* config/arc/arc.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n+\t* config/arm/arm.c (arm_poke_function_name): Likewise.\n+\t(arm_assemble_integer): New, extracted from...\n+\t* config/arm/arm.h (OUTPUT_INT_ADDR_CONST): ...here, now removed.\n+\t(ARM_TRAMPOLINE_TEMPLATE, ARM_FUNCTION_PROFILER): Avoid ASM_OUTPUT_INT.\n+\t(ARM_FUNCTION_PROFILER): Likewise.\n+\t* config/avr/avr-protos.h (asm_output_byte): Remove.\n+\t(asm_output_char, asm_output_short): Remove.\n+\t* config/avr/avr.c (avr_assemble_integer): New.\n+\t(asm_output_byte, asm_output_char, asm_output_short): Remove.\n+\t* config/clipper/clipper.h (ASM_LONG): Remove.\n+\t* config/dsp16xx/dsp16xx-protos.h (asm_output_long): Remove.\n+\t* config/dsp16xx/dsp16xx.c (asm_output_long): Remove.\n+\t* config/elxsi/elxsi.c (elxsi_assemble_integer): New.\n+\t* config/i370/i370.c (i370_hlasm_assemble_integer): New.\n+\t* config/i370/i370.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_SHORT.\n+\t(ASM_BYTE, ASM_SHORT, ASM_LONG): Delete.\n+\t* config/i386/att.h, (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n+\t* config/i386/linux.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Use\n+\tASM_LONG instead of UNALIGNED_INT_ASM_OP.\n+\t* config/i386/sco5.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Likewise.\n+\t(ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n+\t* config/i386/sysv4.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Use\n+\tASM_LONG instead of UNALIGNED_INT_ASM_OP.\n+\t* config/i860/fx2800.h (ASM_FILE_END): Avoid ASM_LONG.\n+\t* config/i860/i860.c (i860_output_function_epilogue): Likewise.\n+\t* config/i860/i860.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n+\t(ASM_SHORT, ASM_LONG): Undefine.\n+\t* config/i860/paragon.h (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n+\t* config/i860/sysv3.h (ASM_OUTPUT_ASCII): Likewise.\n+\t* config/i960/i960.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n+\t* config/ia64/ia64.c (ia64_assemble_integer): New.\n+\t* config/ia64/ia64.h (ASM_OUTPUT_DWARF_OFFSET): Use integer_asm_op.\n+\t(ASM_OUTPUT_DWARF_PCREL): Likewise.\n+\t* config/m68hc11/m68hc11.h (ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT,\n+\tASM_OUTPUT_ADDR_DIFF_ELT, ASM_OUTPUT_ADDR_VEC_ELT): Avoid ASM_LONG.\n+\t(ASM_SHORT, ASM_LONG): Remove.\n+\t* config/m68k/m68k.h (INT_OP_GROUP): New macro.\n+\t(INT_OP_STANDARD, INT_OP_DOT_WORD, INT_OP_NO_DOT, INT_OP_DC): New\n+\tmacros, the allowed values for INT_OP_GROUP.\n+\t* config/m68k/amix.h (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP\n+\t* config/m68k/atari.h (ASM_OUTPUT_ASCII): Likewise\n+\t* config/m68k/m68kelf.h (ASM_OUTPUT_ASCII): Likewise\n+\t* config/m68k/auxas.h (BYTE_ASM_OP, WORD_ASM_OP, LONG_ASM_OP): Remove.\n+\t(INT_OP_GROUP): Define to INT_OP_NO_DOT.\n+\t* config/m68k/dpx2.h (ASM_LONG): Undefine.\n+\t(INT_OP_GROUP): Define to INT_OP_DC.\n+\t* config/m68k/dpx2g.h (ASM_LONG): Undefine.\n+\t* config/m68k/hp320.h (INT_OP_GROUP): Define to INT_OP_NO_DOT.\n+\t* config/m68k/lynx.h (ASM_LONG): Undefine.\n+\t* config/m68k/dpx2g.h (ASM_LONG): Undefine.\n+\t* config/m68k/m68kelf.h (ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n+\t* config/m68k/m68kv4.h (ASM_OUTPUT_ASCII): Likewise.\n+\t(TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_*.\n+\t* config/m68k/mot3300.h (INT_OP_GROUP): Define to INT_OP_STANDARD\n+\tfor GAS and INT_OP_NO_DOT otherwise.\n+\t(ASM_CHAR, ASM_BYTE, ASM_SHORT, ASM_LONG): Remove.\n+\t(ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT,\n+\tASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Avoid ASM_LONG.\n+\t(ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n+\t* config/m68k/sgs.h (BYTE_ASM_OP, WORD_ASM_OP, LONG_ASM_OP): Remove.\n+\t(INT_OP_GROUP): Define to INT_OP_STANDARD.\n+\t(ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT,\n+\tASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Avoid LONG_ASM_OP.\n+\t(ASM_OUTPUT_ASCII): Avoid BYTE_ASM_OP.\n+\t* config/m68k/tower-as.h (ASM_LONG): Remove.\n+\t(INT_OP_GROUP): Define to INT_OP_NO_DOT.\n+\t* config/m88k/m88k.c (output_tdesc): Avoid ASM_LONG.\n+\t* config/m88k/m88k.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n+\t(ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT): Avoid ASM_LONG.\n+\t* config/mips/iris5.h (TARGET_IRIX5): Define.\n+\t* config/mips/mips.c (mips_assemble_integer): New.\n+\t* config/mips/sni-svr4.h (ASM_LONG): Undefine.\n+\t* config/mmix/mmix-protos.h (mmix_asm_output_double_int): Remove.\n+\t* config/mmix/mmix.c (mmix_assemble_integer): New.\n+\t(mmix_asm_output_double_int): Remove.\n+\t(mmix_print_operand): Call mmix_output_octa directly.\n+\t* config/mmix/mmix.h (ASM_LONG): Remove.\n+\t* config/ns32k/ns32k.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_INT.\n+\t* config/pa/pa.c (pa_assemble_integer): New.\n+\t(pa_override_options): Only use aligned DI ops on 64-bit targets.\n+\tOnly use the unaligned ops if TARGET_GAS.\n+\t* config/pdp11/pdp11.c (pdp11_assemble_integer): New.\n+\t* config/pdp11/pdp11.h (TRAMPOLINE_TEMPLATE): Avoid ASM_OUTPUT_SHORT.\n+\t* config/pj/pj.h (ASM_LONG): Undefine.\n+\t* config/rs6000/linux64.h (RELOCATABLE_NEEDS_FIXUP): Undefine.\n+\t* config/rs6000/rs6000.c (rs6000_assemble_integer): New, mostly\n+\textracted from ASM_OUTPUT_INT in sysv4.h.  Use in_text_section()\n+\tand in_toc_section() rather than the in_section variable.\n+\t(rs6000_override_options): Only use DI ops when TARGET_POWERPC64.\n+\t* config/rs6000/sysv4.h (TOC_SECTION_FUNCTION): Add in_toc_section().\n+\t(RELOCATABLE_NEEDS_FIXUP): Define.\n+\t* config/rs6000/xcoff.h (DOUBLE_INT_ASM_OP): Change space to tab.\n+\t* config/s390/linux.h (ASM_SHORT, ASM_LONG, ASM_QUAD): Remove.\n+\t(ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Use integer_asm_op\n+\tto get the word directive.\n+\t(ASM_OUTPUT_ASCII): Avoid ASM_BYTE_OP.\n+\t* config/s390/s390.c (s390_assemble_integer): New.\n+\t* config/s390/s390.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY): Use\n+\tinteger_asm_op to get the word directive.\n+\t* config/sparc/sol2.h (ASM_SHORT, ASM_LONG): Remove.\n+\t* config/sparc/sparc-protos.h (output_double_int): Remove.\n+\t* config/sparc/sparc.c (output_double_int): Move to...\n+\t(sparc_assemble_integer): ...this new function.\n+\t(sparc_override_options): Only use .uaxword if TARGET_ARCH64.\n+\t* config/sparc/sparc.h (ASM_SHORT, ASM_LONG, ASM_LONGLONG): Remove.\n+\t* config/sparc/sysv4.h (ASM_LONG): Remove.\n+\t(ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT): Avoid\n+\tASM_LONG.\n+\t* config/vax/vax.h (TRAMPOLINE_TEMPLATE): Use assemble_aligned_integer.\n+\t* config/we32k/we32k.h (TRAMPOLINE_TEMPLATE): Likewise.\n+\n+\t* config/1750a/1750a.c, config/a29k/a29k.c, config/alpha/alpha.c,\n+\tconfig/arc/arc.c, config/arm/arm.c, config/avr/avr.c, config/c4x/c4x.c,\n+\tconfig/clipper/clipper.c, config/convex/convex.c, config/cris/cris.c,\n+\tconfig/d30v/d30v.c, config/dsp16xx/dsp16xx.c, config/elxsi/elxsi.c,\n+\tconfig/fr30/fr30.c, config/h8300/h8300.c, config/i370/i370.c,\n+\tconfig/i386/i386.c, config/i860/i860.c, config/i960/i960.c,\n+\tconfig/ia64/ia64.c, config/m32r/m32r.c, config/m68hc11/m68hc11.c,\n+\tconfig/m68k/m68k.c, config/m88k/m88k.c, config/mips/mips.c,\n+\tconfig/mmix/mmix.c, config/mn10200/mn10200.c, config/mn10300/mn10300.c,\n+\tconfig/ns32k/ns32k.c, config/pa/pa.c, config/pdp11/pdp11.c,\n+\tconfig/sh/sh.c, config/sparc/sparc.c, config/stormy16/stormy16.c,\n+\tconfig/v850/v850.c, config/vax/vax.c, config/we32k/we32k.c\n+\t(TARGET_ASM_BYTE_OP, TARGET_ASM_ALIGNED_HI_OP,\n+\tTARGET_ASM_ALIGNED_SI_OP, TARGET_ASM_ALIGNED_DI_OP,\n+\tTARGET_ASM_UNALIGNED_HI_OP, TARGET_ASM_UNALIGNED_SI_OP,\n+\tTARGET_ASM_UNALIGNED_DI_OP, TARGET_ASM_INTEGER): Redefine as\n+\tappropriate.\n+\t\n+\t* config/defaults.h, config/darwin.h, config/elfos.h, config/svr3.h,\n+\tconfig/1750a/1750a.h, config/a29k/a29k.h, config/alpha/alpha.h,\n+\tconfig/arc/arc.h, config/arm/arm.h, config/avr/avr.h, config/c4x/c4x.h,\n+\tconfig/clipper/clipper.h, config/convex/convex.h, config/cris/cris.h,\n+\tconfig/d30v/d30v.h, config/dsp16xx/dsp16xx.h, config/elxsi/elxsi.h,\n+\tconfig/fr30/fr30.h, config/h8300/h8300.h, config/i370/i370.h,\n+\tconfig/i386/bsd.h, config/i386/djgpp.h, config/i386/i386.h,\n+\tconfig/i386/sco5.h, config/i386/sol2.h, config/i386/sun386.h,\n+\tconfig/i860/i860.h, config/i960/i960.h, config/ia64/ia64.h,\n+\tconfig/m32r/m32r.h, config/m68hc11/m68hc11.h, config/m68k/auxas.h,\n+\tconfig/m68k/dpx2.h, config/m68k/hp320.h, config/m68k/m68k.h,\n+\tconfig/m68k/mot3300.h, config/m68k/sgs.h, config/m68k/tower-as.h,\n+\tconfig/m88k/m88k.h, config/mcore/mcore-elf.h, config/mcore/mcore.h,\n+\tconfig/mips/iris5.h, config/mips/iris6.h, config/mips/mips.h,\n+\tconfig/mmix/mmix.h, config/mn10200/mn10200.h, config/mn10300/mn10300.h\n+\tconfig/ns32k/encore.h, config/ns32k/ns32k.h, config/pa/pa-64.h,\n+\tconfig/pa/pa.h, config/pdp11/pdp11.h, config/pj/pj.h,\n+\tconfig/romp/romp.h, config/rs6000/linux64.h, config/rs6000/rs6000.h,\n+\tconfig/rs6000/sysv4.h, config/rs6000/xcoff.h, config/s390/linux.h,\n+\tconfig/sh/sh.h, config/sparc/linux64.h, config/sparc/sol2.h,\n+\tconfig/sparc/sp64-elf.h, config/sparc/sparc.h, config/sparc/sysv4.h,\n+\tconfig/stormy16/stormy16.h, config/v850/v850.h, config/vax/vax.h,\n+\tconfig/we32k/we32k.h (ASM_OUTPUT_CHAR, ASM_OUTPUT_BYTE, ASM_BYTE_OP,\n+\tASM_BYTE, ASM_OUTPUT_SHORT, ASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT,\n+\tUNALIGNED_SHORT_ASM_OP, UNALIGNED_INT_ASM_OP,\n+\tUNALIGNED_DOUBLE_INT_ASM_OP): Undefine, where defined.\n+\n 2001-12-17  Stan Shebs  <shebs@apple.com>\n \n \t* config/rs6000/darwin.h (SUBTARGET_OVERRIDE_OPTIONS): Define."}, {"sha": "54a2216b789631918f7f68f4c866db49ed6d3a73", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -47,10 +47,20 @@ const char *const sectname[4] =\n {\"Init\", \"Normal\", \"Konst\", \"Static\"};\n \n static int which_bit PARAMS ((int));\n+static bool assemble_integer_1750a PARAMS ((rtx, unsigned int, int));\n static void output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tdata\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\tdatal\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER assemble_integer_1750a\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -807,6 +817,25 @@ print_operand_address (file, addr)\n   addr_inc = 0;\n }\n \n+/* Target hook for assembling integer objects.  The 1750a version needs to\n+   keep track of how many bytes have been written.  */\n+\n+static bool\n+assemble_integer_1750a (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (default_assemble_integer (x, size, aligned_p))\n+    {\n+      if (label_pending)\n+\tlabel_pending = 0;\n+      datalbl[datalbl_ndx].size += size;\n+      return true;\n+    }\n+  return false;\n+}\n+\n \n /*\n  *  Return non zero if the LS 16 bits of the given value has just one bit set,"}, {"sha": "90903c9aa0e22bf0fed0858e10e35283f8bdf00e", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1118,46 +1118,6 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \tfprintf(FILE,\"\\n\");\t\t\t\t\t\t\\\n   } while (0)\n \n-/* This is how to output an assembler line defining a `char', `short', or\n-  `int' constant.\n-   1750 NOTE: The reason why this macro also outputs `short' and `int'\n-   constants is that for the 1750, BITS_PER_UNIT is 16 (as opposed to the\n-   usual 8.) This behavior is different from the usual, where\n-   ASM_OUTPUT_CHAR only outputs character constants. The name\n-   of this macro should perhaps be `ASM_OUTPUT_QUARTER_INT' or so.\n- */\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  do {\t  \\\n-\tif (label_pending) \t\t\t\t\t\t\\\n-\t   label_pending = 0;\t\t\t\t\t\t\\\n-\tdatalbl[datalbl_ndx].size++;\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tdata\\t\");\t\t\t\t\t\\\n-\toutput_addr_const(FILE, VALUE); \t\t\t\t\\\n-\tfprintf(FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* This is how to output an assembler line defining a `long int' constant.\n-   1750 NOTE: The reason why this macro outputs `long' instead of `short'\n-   constants is that for the 1750, BITS_PER_UNIT is 16 (as opposed to the\n-   usual 8.) The name of this macro should perhaps be `ASM_OUTPUT_HALF_INT'.\n- */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE) do {\t  \\\n-\tif (label_pending)\t\t\t\t\t\t\\\n-\t   label_pending = 0;\t\t\t\t\t\t\\\n-\tdatalbl[datalbl_ndx].size += 2;\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tdatal\\t%d\\n\",INTVAL(VALUE));\t\t\t\\\n-  } while (0)\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE) do {\t  \\\n-\tif (label_pending)\t\t\t\t\t\t\\\n-\t   label_pending = 0;\t\t\t\t\t\t\\\n-\tdatalbl[datalbl_ndx].size++;\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tdata\\t#%x\\n\", VALUE);\t\t\t\t\\\n-  } while (0)\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "3291bab5b245fc12233a48fa98d17fc8d8494bdd", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -97,6 +97,11 @@ rtx a29k_compare_op0, a29k_compare_op1;\n int a29k_compare_fp_p;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "775179dfb2faf41fd13ed2eb7d7524220dad7528", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1470,25 +1470,6 @@ extern int a29k_debug_reg_map[];\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\\\n   fprintf (FILE, \"\\t.float %.20e\\n\", (VALUE))\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n \n@@ -1505,11 +1486,6 @@ extern int a29k_debug_reg_map[];\n            reg_names[REGNO], reg_names[R_MSP], reg_names[R_MSP],\t\\\n \t   reg_names[R_MSP]);\n \n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\"}, {"sha": "2588f5f43710e16ff20a97e022bdc5cabe8ca315", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -205,6 +205,22 @@ static unsigned int unicosmk_section_type_flags PARAMS ((tree, const char *,\n # define TARGET_SECTION_TYPE_FLAGS unicosmk_section_type_flags\n #endif\n \n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n+\n+/* Default unaligned ops are provided for ELF systems.  To get unaligned\n+   data for non-ELF systems, we have to turn off auto alignment.  */\n+#ifndef OBJECT_FORMAT_ELF\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.align 0\\n\\t.word\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.align 0\\n\\t.long\\t\"\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.align 0\\n\\t.quad\\t\"\n+#endif\n+\n #undef TARGET_ASM_FUNCTION_END_PROLOGUE\n #define TARGET_ASM_FUNCTION_END_PROLOGUE alpha_output_function_end_prologue\n "}, {"sha": "db23a57b54fad039ef4bc16d400e702fb1011440", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1845,7 +1845,7 @@ literal_section ()\t\t\t\t\t\t\\\n       if (firsttime)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n \t  firsttime = 0;\t\t\t\t        \\\n-\t  ASM_OUTPUT_DOUBLE_INT (asm_out_file, const0_rtx);\t\\\n+\t  assemble_aligned_integer (8, const0_rtx);\t\t\\\n \t}\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n       in_section = readonly_data;\t\t\t\t\\\n@@ -1978,32 +1978,6 @@ do {\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.long 0x%lx\\n\", t & 0xffffffff);\t\t\\\n   } while (0)\n   \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \t\t\\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line defining a `long' constant.  */\n-\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)\t\\\n-( fprintf (FILE, \"\\t.quad \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.word %d\\n\",\t\t\\\n-    (int)(GET_CODE (VALUE) == CONST_INT\t\t\\\n-     ? INTVAL (VALUE) & 0xffff : (abort (), 0)))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)\t\t\\\n-  fprintf (FILE, \"\\t.byte %d\\n\",\t\t\\\n-    (int)(GET_CODE (VALUE) == CONST_INT\t\t\\\n-     ? INTVAL (VALUE) & 0xff : (abort (), 0)))\n-\n /* We use the default ASCII-output routine, except that we don't write more\n    than 50 characters since the assembler doesn't support very long lines.  */\n \n@@ -2048,11 +2022,6 @@ do {\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t      \\\n   while (0)\n \n-/* To get unaligned data, we have to turn off auto alignment.  */\n-#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.align 0\\n\\t.word\\t\"\n-#define UNALIGNED_INT_ASM_OP\t\t\"\\t.align 0\\n\\t.long\\t\"\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.align 0\\n\\t.quad\\t\"\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n \n@@ -2069,11 +2038,6 @@ do {\t\t\t\t\t\t\\\n \t  (REGNO) > 32 ? \"t\" : \"q\", (REGNO) > 32 ? \"f\" : \"\",\t\t\\\n \t  (REGNO) & 31);\n \n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (int) ((VALUE) & 0xff))\n-\n /* This is how to output an element of a case-vector that is absolute.\n    (Alpha does not use such vectors, but we must define this macro anyway.)  */\n "}, {"sha": "7e9b4d84b4b5b59d5b81decec6d456949ed159f0", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -624,12 +624,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* We support #pragma.  */\n #define HANDLE_SYSV_PRAGMA\n \n-/* Undo the auto-alignment stuff from alpha.h.  ELF has unaligned data\n-   pseudos natively.  */\n-#undef UNALIGNED_SHORT_ASM_OP\n-#undef UNALIGNED_INT_ASM_OP\n-#undef UNALIGNED_DOUBLE_INT_ASM_OP\n-\n /* Select a format to encode pointers in exception handling data.  CODE\n    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is\n    true if the symbol may be affected by dynamic relocations."}, {"sha": "62ed01097bf9eb6b79d34e5e48e10055ecc62da6", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -89,10 +89,18 @@ static void arc_init_reg_tables PARAMS ((void));\n static int get_arc_condition_code PARAMS ((rtx));\n const struct attribute_spec arc_attribute_table[];\n static tree arc_handle_interrupt_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static bool arc_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void arc_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void arc_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER arc_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE arc_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -1107,6 +1115,28 @@ arc_save_restore (file, base_reg, offset, gmask, op)\n     }\n }\n \f\n+/* Target hook to assemble an integer object.  The ARC version needs to\n+   emit a special directive for references to labels and function\n+   symbols.  */\n+\n+static bool\n+arc_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (size == UNITS_PER_WORD && aligned_p\n+      && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FLAG (x))\n+\t  || GET_CODE (x) == LABEL_REF))\n+    {\n+      fputs (\"\\t.word\\t%st(\", asm_out_file);\n+      output_addr_const (asm_out_file, x);\n+      fputs (\")\\n\", asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\f\n /* Set up the stack and frame pointer (if desired) for the function.  */\n \n static void"}, {"sha": "d7db3bd66dbd3000165878b5f3b925f951b55b82", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -863,10 +863,10 @@ arc_eligible_for_epilogue_delay (TRIAL, SLOTS_FILLED)\n */\n #define TRAMPOLINE_TEMPLATE(FILE) \\\n do { \\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x631f7c00)); \\\n-  ASM_OUTPUT_INT (FILE, const0_rtx); \\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x381f0000)); \\\n-  ASM_OUTPUT_INT (FILE, const0_rtx); \\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x631f7c00)); \\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx); \\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x381f0000)); \\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx); \\\n } while (0)\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -1238,36 +1238,6 @@ do {\t\t\t\t\t\t\t\\\n    no longer contain unusual constructs.  */\n #define ASM_APP_OFF \"\"\n \n-/* This is how to output an assembler line defining a `char' constant.  */\n-#define ASM_OUTPUT_CHAR(FILE, VALUE) \\\n-( fprintf (FILE, \"\\t.byte\\t\"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line defining a `short' constant.  */\n-#define ASM_OUTPUT_SHORT(FILE, VALUE) \\\n-( fprintf (FILE, \"\\t.hword\\t\"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line defining an `int' constant.\n-   We also handle symbol output here.  Code addresses must be right shifted\n-   by 2 because that's how the jump instruction wants them.  */\n-#define ASM_OUTPUT_INT(FILE, VALUE) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\t\\\n-  if ((GET_CODE (VALUE) == SYMBOL_REF && SYMBOL_REF_FLAG (VALUE))\t\\\n-      || GET_CODE (VALUE) == LABEL_REF)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%%st(\");\t\t\t\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n-      fprintf (FILE, \")\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* This is how to output an assembler line defining a `float' constant.  */\n #define ASM_OUTPUT_FLOAT(FILE, VALUE) \\\n {\t\t\t\t\t\t\t\\\n@@ -1290,11 +1260,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t   t[0], ASM_COMMENT_START, str, t[1]);\t\t\\\n }\n \n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_BYTE_OP\t\"\\t.byte\\t\"\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf (FILE, \"%s0x%x\\n\", ASM_BYTE_OP, (VALUE))\n-\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n #define ASM_OUTPUT_LABEL(FILE, NAME) \\"}, {"sha": "01826b8172713c950a9acb3327158f83dd48cd81", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -206,24 +206,6 @@ do {\t\t\t\t\t\t\t\\\n \t   l, ASM_COMMENT_START, dstr);\t\t\t\\\n } while (0)\n \n-#define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\\\n-  (fprintf ((STREAM), \"\\tDCD\\t\"),\t\t\\\n-   output_addr_const ((STREAM), (VALUE)),\t\\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_SHORT(STREAM,VALUE)\t\t\\\n-  (fprintf ((STREAM), \"\\tDCW\\t\"),\t\t\\\n-   output_addr_const ((STREAM), (VALUE)),\t\\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_CHAR(STREAM,VALUE)\t\t\\\n-  (fprintf ((STREAM), \"\\tDCB\\t\"),\t\t\\\n-   output_addr_const ((STREAM), (VALUE)),\t\\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_BYTE(STREAM,VALUE)\t\t\\\n-  fprintf ((STREAM), \"\\tDCB\\t%d\\n\", (VALUE))\n-\n #define ASM_OUTPUT_ASCII(STREAM,PTR,LEN)\t\t\\\n {\t\t\t\t\t\t\t\\\n   int i;\t\t\t\t\t\t\\"}, {"sha": "9832eda92607a946b53e87a57c03927acf6f206c", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -226,36 +226,6 @@ Boston, MA 02111-1307, USA.  */\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-#define ASM_OUTPUT_INT(STREAM, EXP)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.word\\t\");\t\t\\\n-      OUTPUT_INT_ADDR_CONST (STREAM, EXP);\t\\\n-      fputc ('\\n', STREAM);\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.short\\t\");\t\t\\\n-      output_addr_const (STREAM, EXP);\t\t\\\n-      fputc ('\\n', STREAM);\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.byte\\t\");\t\t\\\n-      output_addr_const (STREAM, EXP);\t\t\\\n-      fputc ('\\n', STREAM);\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \t\\\n-  fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE)\n-\n #undef  ASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)  \\\n   output_ascii_pseudo_op (STREAM, (const unsigned char *)(PTR), LEN)"}, {"sha": "7a5f03ae4ec8a275e8179be74311ba9587bba19f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -68,6 +68,10 @@ static int       const_ok_for_op \t\tPARAMS ((Hint, enum rtx_code));\n static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n static rtx\t emit_sfm\t\t\tPARAMS ((int, int));\n+#ifndef AOF_ASSEMBLER\n+static bool\t arm_assemble_integer\t\tPARAMS ((rtx, unsigned int,\n+\t\t\t\t\t\t\t int));\n+#endif\n static Ccstar    fp_const_from_val\t\tPARAMS ((REAL_VALUE_TYPE *));\n static arm_cc    get_arm_condition_code\t\tPARAMS ((rtx));\n static void      init_fpa_table\t\t\tPARAMS ((void));\n@@ -134,6 +138,20 @@ static int\t arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE arm_attribute_table\n \n+#ifdef AOF_ASSEMBLER\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tDCB\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\tDCW\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\tDCD\\t\"\n+#else\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER arm_assemble_integer\n+#endif\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE arm_output_function_prologue\n \n@@ -7320,7 +7338,7 @@ arm_poke_function_name (stream, name)\n   ASM_OUTPUT_ASCII (stream, name, length);\n   ASM_OUTPUT_ALIGN (stream, 2);\n   x = GEN_INT ((unsigned HOST_WIDE_INT) 0xff000000 + alignlength);\n-  ASM_OUTPUT_INT (stream, x);\n+  assemble_aligned_integer (UNITS_PER_WORD, x);\n }\n \n /* Place some comments into the assembler stream\n@@ -8509,6 +8527,40 @@ arm_print_operand (stream, x, code)\n     }\n }\n \f\n+#ifndef AOF_ASSEMBLER\n+/* Target hook for assembling integer objects.  The ARM version needs to\n+   handle word-sized values specially.  */\n+\n+static bool\n+arm_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (size == UNITS_PER_WORD && aligned_p)\n+    {\n+      fputs (\"\\t.word\\t\", asm_out_file);\n+      output_addr_const (asm_out_file, x);\n+\n+      /* Mark symbols as position independent.  We only do this in the\n+\t .text segment, not in the .data segment. */\n+      if (NEED_GOT_RELOC && flag_pic && making_const_table &&\n+\t  (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF))\n+\t{\n+\t  if (GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+\t    fputs (\"(GOTOFF)\", asm_out_file);\n+\t  else if (GET_CODE (x) == LABEL_REF)\n+\t    fputs (\"(GOTOFF)\", asm_out_file);\n+\t  else\n+\t    fputs (\"(GOT)\", asm_out_file);\n+\t}\n+      fputc ('\\n', asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+#endif\n+\f\n /* A finite state machine takes care of noticing whether or not instructions\n    can be conditionally executed, and thus decrease execution time and code\n    size by deleting branch instructions.  The fsm is controlled by"}, {"sha": "6060275d6bb5333f2524fa8b7de0a536a45c3ffe", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1579,7 +1579,7 @@ typedef struct\n   fputc ('\\n', STREAM);\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (temp, \"LP\", LABELNO);\t\\\n   sym = gen_rtx (SYMBOL_REF, Pmode, temp);\t\t\\\n-  ASM_OUTPUT_INT (STREAM, sym);\t\t\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, sym);\t\\\n }\n #endif\n \n@@ -1716,14 +1716,14 @@ typedef struct\n \t   .word\tstatic chain value\n \t   .word\tfunction's address\n    ??? FIXME: When the trampoline returns, r8 will be clobbered.  */\n-#define ARM_TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #0]\\n\",\t\t\\\n-\t       STATIC_CHAIN_REGNUM, PC_REGNUM);\t\t\\\n-  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #0]\\n\",\t\t\\\n-\t       PC_REGNUM, PC_REGNUM);\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n+#define ARM_TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #0]\\n\",\t\t\t\\\n+\t       STATIC_CHAIN_REGNUM, PC_REGNUM);\t\t\t\\\n+  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #0]\\n\",\t\t\t\\\n+\t       PC_REGNUM, PC_REGNUM);\t\t\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\\\n }\n \n /* On the Thumb we always switch into ARM mode to execute the trampoline.\n@@ -2781,24 +2781,6 @@ extern int making_const_table;\n   else\t\t\t\t\t\t\\\n     THUMB_PRINT_OPERAND_ADDRESS (STREAM, X)\n      \n-#define OUTPUT_INT_ADDR_CONST(STREAM, X) \t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    output_addr_const (STREAM, X);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* Mark symbols as position independent.  We only do this in the\t\\\n-      .text segment, not in the .data segment. */\t\t\t\\\n-    if (NEED_GOT_RELOC && flag_pic && making_const_table &&\t\t\\\n-    \t(GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF))\t\\\n-     {\t\t\t\t\t\t\t\t\t\\\n-        if (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X))\t\\\n-          fprintf (STREAM, \"(GOTOFF)\");\t\t\t\t\t\\\n-        else if (GET_CODE (X) == LABEL_REF)\t\t\t\t\\\n-          fprintf (STREAM, \"(GOTOFF)\");\t\t\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-          fprintf (STREAM, \"(GOT)\");\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\t\\\n-  }\n-\n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n #define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\t\\"}, {"sha": "e47b7e0ea6465eabed5fcdbbda08fe100d26e944", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -115,9 +115,6 @@ extern const char * output_reload_insisf PARAMS ((rtx insn, rtx *operands,\n \t\t\t\t\t\tint *len));\n extern int    default_rtx_costs      PARAMS ((rtx X, RTX_CODE code,\n \t\t\t\t\t     RTX_CODE outer_code));\n-extern void   asm_output_char        PARAMS ((FILE *file, rtx value));\n-extern void   asm_output_short       PARAMS ((FILE *file, rtx value));\n-extern void   asm_output_byte        PARAMS ((FILE *file, int value));\n extern enum reg_class secondary_input_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t\t\t   rtx));"}, {"sha": "7e20748220ce5c8c64063b993e55d805571cc421", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -61,6 +61,7 @@ void          debug_hard_reg_set   PARAMS ((HARD_REG_SET set));\n static tree   avr_handle_progmem_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree   avr_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n const struct attribute_spec avr_attribute_table[];\n+static bool   avr_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void   avr_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void   avr_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n@@ -174,6 +175,11 @@ static const struct mcu_type_s avr_mcu_types[] = {\n int avr_case_values_threshold = 30000;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER avr_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE avr_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -4458,49 +4464,25 @@ _reg_unused_after (insn, reg)\n   return 1;\n }\n \n-/* Output rtx VALUE as .byte to file FILE */\n-\n-void\n-asm_output_char (file, value)\n-     FILE *file;\n-     rtx value;\n-{\n-  fprintf (file, \"\\t.byte \");\n-  output_addr_const (file, value);\n-  fprintf (file, \"\\n\");\n-}\n-\n-\n-/* Output VALUE as .byte to file FILE */\n-\n-void\n-asm_output_byte (file, value)\n-     FILE *file;\n-     int value;\n-{\n-  fprintf (file, \"\\t.byte 0x%x\\n\", value & 0xff);\n-}\n-\n-\n-/* Output rtx VALUE as .word to file FILE */\n+/* Target hook for assembling integer objects.  The AVR version needs\n+   special handling for references to certain labels.  */\n \n-void\n-asm_output_short (file, value)\n-     FILE *file;\n-     rtx value;\n+static bool\n+avr_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n {\n-  if (SYMBOL_REF_FLAG (value) || GET_CODE (value) == LABEL_REF)\n-    {\n-      fprintf (file, \"\\t.word pm(\");\n-      output_addr_const (file, (value));\n-      fprintf (file, \")\\n\");\n-    }\n-  else\n+  if (size == POINTER_SIZE / BITS_PER_UNIT && aligned_p\n+      && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FLAG (x))\n+\t  || GET_CODE (x) == LABEL_REF))\n     {\n-      fprintf (file, \"\\t.word \");\n-      output_addr_const (file, (value));\n-      fprintf (file, \"\\n\");\n+      fputs (\"\\t.word\\tpm(\", asm_out_file);\n+      output_addr_const (asm_out_file, x);\n+      fputs (\")\\n\", asm_out_file);\n+      return true;\n     }\n+  return default_assemble_integer (x, size, aligned_p);\n }\n \n "}, {"sha": "fac7e46901aff6a9ec9621cda21014c4c78f474f", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -2025,39 +2025,6 @@ progmem_section (void)\t\t\t\t\t\t\t      \\\n    definitions.  */\n \n \n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\t\\\n- ( fprintf (FILE, \"\\t.long \"),\t\t\t\t\\\n-   output_addr_const (FILE, (VALUE)),\t\t\t\\\n-   fputs (\"\\n\", FILE))\n-\n- /* Likewise for `short' and `char' constants.   */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE) asm_output_short(FILE,VALUE)\n-#define ASM_OUTPUT_CHAR(FILE,VALUE) asm_output_char(FILE,VALUE)\n-\n-/* `ASM_OUTPUT_QUADRUPLE_INT (STREAM, EXP)'\n-   A C statement to output to the stdio stream STREAM an assembler\n-   instruction to assemble an integer of 16, 8, 4, 2 or 1 bytes,\n-   respectively, whose value is VALUE.  The argument EXP will be an\n-   RTL expression which represents a constant value.  Use\n-   `output_addr_const (STREAM, EXP)' to output this value as an\n-   assembler expression.\n-\n-   For sizes larger than `UNITS_PER_WORD', if the action of a macro\n-   would be identical to repeatedly calling the macro corresponding to\n-   a size of `UNITS_PER_WORD', once for each word, you need not define\n-   the macro.  */\n-\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE) asm_output_byte (FILE,VALUE)\n-/* A C statement to output to the stdio stream STREAM an assembler\n-   instruction to assemble a single byte containing the number VALUE.  */\n-\n-#define ASM_BYTE_OP \"\\t.byte \"\n-/* A C string constant giving the pseudo-op to use for a sequence of\n-   single-byte constants.  If this macro is not defined, the default\n-   is `\"\\t.byte\\t\"'.  */\n-\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)\t gas_output_ascii (FILE,P,SIZE)\n /* `ASM_OUTPUT_ASCII (STREAM, PTR, LEN)'\n    output_ascii (FILE, P, SIZE)"}, {"sha": "ee878dd709886e66511486dbeb1b9803e365293f", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -195,6 +195,13 @@ static void c4x_asm_named_section PARAMS ((const char *, unsigned int));\n static int c4x_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP NULL\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE c4x_attribute_table\n "}, {"sha": "824fa2ce7ffb758f622819aa0f0d2e2f6f5f63f4", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1888,19 +1888,6 @@ const_section ()\t\t\t\t\t\t\t\\\n                l[0], str, l[1]);\t\t\t\t\\\n   } while (0);\n \n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.word\\t\");\t\t\t\\\n-     output_addr_const (FILE, VALUE);\t\t\t\\\n-     if (GET_CODE (VALUE) != SYMBOL_REF)\t\t\\\n-       fprintf (FILE, \" ; 0%08xh\\n\", INTVAL (VALUE));\t\\\n-     else\t\t\t\t\t\t\\\n-       fputc ('\\n', FILE);\t\t\t\t\\\n-  } while (0);\n-\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.word\\t0%xh\\n\", (VALUE))\n-\n #define ASM_OUTPUT_ASCII(FILE, PTR, LEN) c4x_output_ascii (FILE, PTR, LEN)\n \n /* Output and Generation of Labels.  */"}, {"sha": "96c1caa7a6ea4ac3c036175fd5491fed1a8e7de7", "filename": "gcc/config/clipper/clipper.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -54,6 +54,9 @@ extern int frame_pointer_needed;\n static int frame_size;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE clipper_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "48671b02c3edc47c4c176ec42515e2564da2b636", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -979,30 +979,6 @@ do\t\t\t\t\t\t\t\t\t      \\\n #define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n   do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "cd625c1e827af120a2a287954cf76719e0a83632", "filename": "gcc/config/clipper/clix.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fclipper%2Fclix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fclipper%2Fclix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclix.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -70,7 +70,6 @@ do {\t\t\t\t\t\t\t\\\n   fprintf(FILE, \"\\t.align %d\\n\", 1 << (LOG))\n \n \n-#define ASM_LONG \".long\"\n #define BSS_SECTION_ASM_OP  \"\\t.bss\"\n #undef INIT_SECTION_ASM_OP\n #define INIT_SECTION_ASM_OP \"\\t.section .init,\\\"x\\\"\""}, {"sha": "bee0f173076d4de19cf86249fb8324e37234b57f", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -69,6 +69,13 @@ static void convex_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static int convex_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tds.b\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\tds.h\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\tds.w\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE convex_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "d8fa6836956a43e9834d600ffdcacb431cd522cf", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1267,48 +1267,6 @@ enum reg_class {\n #define ASM_OUTPUT_FLOAT(FILE,VALUE) \\\n   outfloat (FILE, VALUE, \"%.9e\", \"\\tds.s \", \"\\n\")\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tds.w \");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, simplify_for_convex (VALUE));\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-}\n-\n-/* Likewise for a `long long int' constant.  */\n-\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (VALUE) == CONST_DOUBLE)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tds.w %d,%d\\n\",\t\t\t\t\t\\\n-\t     const_double_high_int (VALUE), const_double_low_int (VALUE)); \\\n-  else if (GET_CODE (VALUE) == CONST_INT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int val = INTVAL (VALUE);\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tds.w %d,%d\\n\", val < 0 ? -1 : 0, val);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tds.h \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tds.b \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\tds.b %#x\\n\", (int)(VALUE))\n-\n /* This is how to output a string */\n \n #define ASM_OUTPUT_ASCII(FILE,STR,SIZE) do {\t\t\t\t\\"}, {"sha": "8d2afa82d0617f5ad53f3cc803168bcb23d99a0b", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -123,6 +123,25 @@ int cris_max_stackframe = 0;\n /* This is the parsed result of the \"-march=\" option, if given.  */\n int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n \n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.dword\\t\"\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n+\n+/* We need to define these, since the 2byte, 4byte, 8byte op:s are only\n+   available in ELF.  These \"normal\" pseudos do not have any alignment\n+   constraints or side-effects.  */\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP TARGET_ASM_ALIGNED_HI_OP\n+\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP TARGET_ASM_ALIGNED_SI_OP\n+\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP TARGET_ASM_ALIGNED_DI_OP\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE cris_target_asm_function_prologue\n "}, {"sha": "c7e2cba60537aeceb06780f228d959361a2fe3e4", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1537,56 +1537,8 @@ struct cum_args {int regs;};\n  ASM_OUTPUT_LONG_DOUBLE (FILE, VALUE)\n \n \n-/* This is a kludge for a.out+ELF support: For non-ELF prioritized\n-   [cd]tors, globalize the function so collect2 can collect it.  This is\n-   due to short-sightedness guided by defined (ASM_OUTPUT_SECTION_NAME)\n-   && defined (ASM_OUTPUT_CONSTRUCTOR).  */\n-\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.dword \");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.word \");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.byte \");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n- fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n #define IS_ASM_LOGICAL_LINE_SEPARATOR(C) (C) == '@'\n \n-/* FIXME: These are undocumented.  */\n-/* We need to define these, since the 2byte, 4byte, 8byte op:s are only\n-   available in ELF.  These \"normal\" pseudos do not have any alignment\n-   constraints or side-effects.  */\n-#undef UNALIGNED_SHORT_ASM_OP\n-#define UNALIGNED_SHORT_ASM_OP \"\\t.word\\t\"\n-\n-#undef UNALIGNED_INT_ASM_OP\n-#define UNALIGNED_INT_ASM_OP \"\\t.dword\\t\"\n-\n-#undef UNALIGNED_DOUBLE_INT_ASM_OP\n-#define UNALIGNED_DOUBLE_INT_ASM_OP \"\\t.quad\\t\"\n-\n /* Node: Uninitialized Data */\n \n /* Remember to round off odd values if we want data alignment,"}, {"sha": "f359d3d71c0bfd6d9641316f2aaf9f187cbfb24a", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -85,6 +85,11 @@ enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n enum reg_class reg_class_from_letter[256];\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE d30v_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "ebdefb598ed2215eba7f60668c002e576b0daf11", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -3778,53 +3778,6 @@ extern const char *d30v_branch_cost_string;\n /* #define ASM_OUTPUT_SHORT_FLOAT(STREAM, VALUE) */\n /* #define ASM_OUTPUT_BYTE_FLOAT(STREAM, VALUE) */\n \n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble an integer of 16, 8, 4, 2 or 1 bytes, respectively, whose value\n-   is VALUE.  The argument EXP will be an RTL expression which represents a\n-   constant value.  Use `output_addr_const (STREAM, EXP)' to output this value\n-   as an assembler expression.\n-\n-   For sizes larger than `UNITS_PER_WORD', if the action of a macro would be\n-   identical to repeatedly calling the macro corresponding to a size of\n-   `UNITS_PER_WORD', once for each word, you need not define the macro.  */\n-\n-/* #define ASM_OUTPUT_QUADRUPLE_INT(STREAM, EXP) */\n-/* #define ASM_OUTPUT_DOUBLE_INT(STREAM, EXP) */\n-\n-#define ASM_OUTPUT_INT(STREAM, EXP)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\t.word \", STREAM);\t\t\t\t\t\t\\\n-  output_addr_const (STREAM, EXP);\t\t\t\t\t\\\n-  putc ('\\n', STREAM);\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\t.hword \", STREAM);\t\t\t\t\t\t\\\n-  output_addr_const (STREAM, EXP);\t\t\t\t\t\\\n-  putc ('\\n', STREAM);\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\t.byte \", STREAM);\t\t\t\t\t\t\\\n-  output_addr_const (STREAM, EXP);\t\t\t\t\t\\\n-  putc ('\\n', STREAM);\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble a single byte containing the number VALUE.  */\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n-  fprintf (STREAM, \"%s%d\\n\", ASM_BYTE_OP, (int)(VALUE))\n-\n-/* A C string constant giving the pseudo-op to use for a sequence of\n-   single-byte constants.  If this macro is not defined, the default\n-   is `\"byte\"'.\n-\n-   Defined in svr4.h.  */\n-/* #define ASM_BYTE_OP */\n-\n /* A C statement to output to the stdio stream STREAM an assembler instruction\n    to assemble a string constant containing the LEN bytes at PTR.  PTR will be\n    a C expression of type `char *' and LEN a C expression of type `int'.\n@@ -4675,8 +4628,7 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n /* Define this macro to 0 if your target supports DWARF 2 frame unwind\n    information, but it does not yet work with exception handling.  Otherwise,\n    if your target supports this information (if it defines\n-   `INCOMING_RETURN_ADDR_RTX' and either `UNALIGNED_INT_ASM_OP' or\n-   `OBJECT_FORMAT_ELF'), GCC will provide a default definition of 1.\n+   `INCOMING_RETURN_ADDR_RTX'), GCC will provide a default definition of 1.\n \n    If this macro is defined to 1, the DWARF 2 unwinder will be the default\n    exception handling mechanism; otherwise, setjmp/longjmp will be used by"}, {"sha": "7988b61a393b61d53cf607a7f08008880b869ae6", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -262,13 +262,6 @@ do { text_section ();\t\t\t\t\t\t\t\\\n          fprintf (FILE, \"_%s\", NAME);\t\t\t\t\t\\\n   } while (0)\n \n-/* The standard fillin directives are unaligned.  */\n-\n-#define UNALIGNED_SHORT_ASM_OP          \"\\t.short\\t\"\n-#define UNALIGNED_INT_ASM_OP            \"\\t.long\\t\"\n-/* Don't try to use this before the assembler knows about it.  */\n-/* #define UNALIGNED_DOUBLE_INT_ASM_OP     \"\\t.quad\\t\"  */\n-\n #undef\tALIGN_ASM_OP\n #define ALIGN_ASM_OP\t\t\".align\"\n "}, {"sha": "a2f68afbc3ef9dd0aeb0378cdca18e8d0d5d2e07", "filename": "gcc/config/dsp16xx/dsp16xx-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -78,7 +78,6 @@ extern int initial_frame_pointer_offset PARAMS ((void));\n extern void asm_output_common PARAMS ((FILE *, const char *, int, int));\n extern void asm_output_local PARAMS ((FILE *, const char *, int, int));\n extern void asm_output_float PARAMS ((FILE *, double));\n-extern void asm_output_long PARAMS ((FILE *, long));\n extern void dsp16xx_file_start PARAMS ((void));\n extern void coff_dsp16xx_file_start PARAMS ((FILE *));\n extern void luxworks_dsp16xx_file_start PARAMS ((FILE *));"}, {"sha": "5cd1012e944b8e71f95b03547a365f40169167f8", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -151,6 +151,13 @@ static void dsp16xx_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void dsp16xx_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tint\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP NULL\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE dsp16xx_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -2281,20 +2288,6 @@ asm_output_float (file, fp_const)\n #endif\n }\n \n-void\n-asm_output_long (file, value)\n-     FILE *file;\n-     long value;\n-{\n-      fputs (\"\\tint \", file);\n-#ifdef WORDS_BIG_ENDIAN\n-      fprintf (file, \"0x%-4.4lx, 0x%-4.4lx\", (value >> 16) & 0xffff, (value & 0xffff));\n-#else\n-      fprintf (file, \"0x%-4.4lx, 0x%-4.4lx\", (value & 0xffff), (value >> 16) & 0xffff);\n-#endif\n-      fputs (\"\\n\", file);\n-}\n-\n int\n dsp16xx_address_cost (addr)\n      rtx addr;"}, {"sha": "af05183d0d47d83ea11495d29a414777b1987d02", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1648,21 +1648,6 @@ const_section ()                                                   \\\n    size HFmode.  */\n #define ASM_OUTPUT_SHORT_FLOAT(FILE,VALUE)  asm_output_float (FILE, VALUE)\n \n-/* This is how to output an assembler line defining an `char' constant.  */\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)              \\\n-( fprintf (FILE, \"\\tint \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line defining an `short' constant.  */\n-#define ASM_OUTPUT_SHORT(FILE,EXP)   asm_output_long(FILE,INTVAL(EXP))\n-\n-/* This is how to output an assembler line defining a 'int' constant.  */\n-#define ASM_OUTPUT_INT(FILE, EXP)    asm_output_long(FILE,INTVAL(EXP))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)    ASM_OUTPUT_CHAR(FILE,GEN_INT(VALUE))\n-\n /* This is how we output a 'c' character string. For the 16xx\n    assembler we have to do it one letter at a time */\n "}, {"sha": "d09bdbc8d9138c915d538bf2f717a01ad5b9e2fe", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -88,9 +88,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define IDENT_ASM_OP \"\\t.ident\\t\"\n \n-#undef  ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\"\\t.byte\\t\"\n-\n #undef  SET_ASM_OP\n #define SET_ASM_OP\t\"\\t.set\\t\"\n "}, {"sha": "c2b9c57e2d58e9cbafe5332f4233caf6bf5e8acd", "filename": "gcc/config/elxsi/elxsi.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Felxsi%2Felxsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Felxsi%2Felxsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -42,17 +42,51 @@ static const char *const cmp_tab[] = {\n     \"gt\", \"gt\", \"eq\", \"eq\", \"ge\", \"ge\", \"lt\", \"lt\", \"ne\", \"ne\",\n     \"le\", \"le\" };\n \n+static bool elxsi_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void elxsi_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void elxsi_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP NULL\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP NULL\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER elxsi_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE elxsi_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE elxsi_output_function_epilogue\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+/* Target hook for assembling integer objects.  The ELXSI assembler\n+   syntax uses a suffix to indicate the size of data, so we can't use\n+   the usual string hooks.  */\n+\n+static bool\n+elxsi_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (aligned_p)\n+    switch (size)\n+      {\n+      case 1:\n+      case 2:\n+      case 4:\n+\tfputs (\"\\t.data\\t\", asm_out_file);\n+\toutput_addr_const (asm_out_file, x);\n+\tfprintf (asm_out_file, \"{%d}\\n\", size * BITS_PER_UNIT);\n+\treturn true;\n+      }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\f\n /* Generate the assembly code for function entry.  FILE is a stdio\n    stream to output the code to.  SIZE is an int: how many units of\n    temporary storage to allocate."}, {"sha": "13e39d8b7f044f1e1df7fdcd60a359d590d61f09", "filename": "gcc/config/elxsi/elxsi.h", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -747,50 +747,6 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n   tem.f = (VALUE);\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.data %d{32}\\n\", tem.i); }\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( \\\n-\tfprintf (FILE, \"\\t.data\\t\"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"{32}\\n\"))\n-\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\t.data\\t\");\t\t\t\t\\\n-\tif (GET_CODE (VALUE) == CONST_DOUBLE)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"%d\", CONST_DOUBLE_HIGH (VALUE)); \\\n-\t\tfprintf (FILE, \"{32}, \");\t\t\t\\\n-\t\tfprintf (FILE, \"%d\", CONST_DOUBLE_LOW (VALUE)); \\\n-\t\tfprintf (FILE, \"{32}\\n\");\t\t\t\\\n-\t} else if (GET_CODE (VALUE) == CONST_INT)\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t\tint val = INTVAL (VALUE);\t\t\t\\\n-\t\tfprintf (FILE, \"%d\", val < 0 ? -1 : 0);\t\t\\\n-\t\tfprintf (FILE, \"{32}, \");\t\t\t\\\n-\t\tfprintf (FILE, \"%d\", val);\t\t\t\\\n-\t\tfprintf (FILE, \"{32}\\n\");\t\t\t\\\n-\t} else abort ();\t\t\t\t\t\\\n-}\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.data\\t\"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"{16}\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.data\\t\"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"{8}\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.data\\t%d{8}\\n\", (VALUE))\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "c386297a6465565612f91a4938cfe95055634772", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -141,6 +141,10 @@ static rtx fr30_pass_by_value PARAMS ((tree, tree));\n #endif\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f"}, {"sha": "b8f84f7d834436602f0a3a13aded9a7a616c86af", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1444,43 +1444,6 @@ do\t\t\t\t\t\t\t\t\t\t\\\n \t       t[0], ASM_COMMENT_START, str, t[1]);\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n-\n-/* This is how to output an assembler line defining a `char' constant.  */\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.byte\\t\");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to output an assembler line defining a `short' constant.  */\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.hword\\t\");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to output an assembler line defining an `int' constant.\n-   We also handle symbol output here.  */\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.word\\t\");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble a single byte containing the number VALUE.  */\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n-  fprintf (STREAM, \"%s0x%x\\n\", ASM_BYTE_OP, (VALUE))\n-\n /*}}}*/ \f\n /*{{{  Output and Generation of Labels.  */ \n "}, {"sha": "e16c54ca3f6bf246f7da38cd0b3db13b89aae3bd", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -106,6 +106,9 @@ const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE h8300_attribute_table\n \n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE h8300_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "0535d5f2c0d22be3c5454808234bdba8f7c44225", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1270,29 +1270,6 @@ readonly_data ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "81be7bd902601f3fcbb7995a8de3b7c68fd6a3ec", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -99,6 +99,9 @@ static FILE *assembler_source = 0;\n \n static label_node_t * mvs_get_label PARAMS ((int));\n static void i370_label_scan PARAMS ((void));\n+#ifdef TARGET_HLASM\n+static bool i370_hlasm_assemble_integer PARAMS ((rtx, unsigned int, int));\n+#endif\n static void i370_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void i370_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n #ifdef LONGEXTERNAL\n@@ -288,6 +291,17 @@ static const unsigned char ebcasc[256] =\n };\n \f\n /* Initialize the GCC target structure.  */\n+#ifdef TARGET_HLASM\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP NULL\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP NULL\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER i370_hlasm_assemble_integer\n+#endif\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE i370_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -1176,6 +1190,54 @@ unsigned_jump_follows_p (insn)\n     }\n }\n \n+#ifdef TARGET_HLASM\n+\n+/* Target hook for assembling integer objects.  This version handles all\n+   objects when TARGET_HLASM is defined.  */\n+\n+static bool\n+i370_hlasm_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  const char *int_format = NULL;\n+\n+  if (aligned_p)\n+    switch (size)\n+      {\n+      case 1:\n+\tint_format = \"\\tDC\\tX'%02X'\\n\";\n+\tbreak;\n+\n+      case 2:\n+\tint_format = \"\\tDC\\tX'%04X'\\n\";\n+\tbreak;\n+\n+      case 4:\n+\tif (GET_CODE (x) == CONST_INT)\n+\t  {\n+\t    fputs (\"\\tDC\\tF'\", asm_out_file);\n+\t    output_addr_const (asm_out_file, x);\n+\t    fputs (\"'\\n\", asm_out_file);\n+\t  }\n+\telse\n+\t  {\n+\t    fputs (\"\\tDC\\tA(\", asm_out_file);\n+\t    output_addr_const (asm_out_file, x);\n+\t    fputs (\")\\n\", asm_out_file);\n+\t  }\n+\treturn true;\n+      }\n+\n+  if (int_format && GET_CODE (x) == CONST_INT)\n+    {\n+      fprintf (asm_out_file, int_format, INTVAL (x));\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\n /* Generate the assembly code for function entry.  FILE is a stdio\n    stream to output the code to.  SIZE is an int: how many units of\n    temporary storage to allocate.\n@@ -1185,8 +1247,6 @@ unsigned_jump_follows_p (insn)\n    used in the function.  This function is responsible for knowing\n    which registers should not be saved even if used.  */\n \n-#ifdef TARGET_HLASM\n-\n static void\n i370_output_function_prologue (f, l)\n      FILE *f;"}, {"sha": "826382fbe6076935126a11b56347b3e6aa5715a7", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 10, "deletions": 68, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -629,16 +629,16 @@ enum reg_class\n \n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x05E0));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4)); \\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0xE00A));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x58F0)); \t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0xE00E));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x07FF));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x05E0));\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4)); \\\n+  assemble_aligned_integer (2, GEN_INT (0xE00A));\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x58F0)); \t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0xE00E));\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x07FF));\t\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -1191,39 +1191,6 @@ enum reg_class\n #define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDC\\tE'%.9G'\\n\", (VALUE))\n \n-/* This outputs an integer, if not a CONST_INT must be address constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE, EXP)\t\t\t\t\t\\\n-{ \t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (EXP) == CONST_INT)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tDC\\tF'\");\t\t\t\t\t\\\n-      output_addr_const (FILE, EXP);\t\t\t\t\t\\\n-      fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tDC\\tA(\");\t\t\t\t\t\\\n-      output_addr_const (FILE, EXP);\t\t\t\t\t\\\n-      fprintf (FILE, \")\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* This outputs a short integer.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE, EXP)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tX'%04X'\\n\", INTVAL(EXP) & 0xFFFF);\t\t\\\n-}\n-\n-/* This outputs a byte sized integer.  */\n-\n-#define ASM_OUTPUT_CHAR(FILE, EXP)\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tX'%02X'\\n\", INTVAL (EXP) )\n-\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tX'%02X'\\n\", VALUE)\n-\n /* This outputs a text string.  The string are chopped up to fit into\n    an 80 byte record.  Also, control and special characters, interpreted\n    by the IBM assembler, are output numerically.  */\n@@ -1898,9 +1865,6 @@ abort(); \\\n #undef ASM_OUTPUT_EXTERNAL\n \n #define ASM_DOUBLE \"\\t.double\"     \n-#define ASM_LONG \"\\t.long\"\n-#define ASM_SHORT \"\\t.short\"\n-#define ASM_BYTE \"\\t.byte\"\n \n /* Argument to the flt pt. macros is a REAL_VALUE_TYPE which \n    may or may not be a float/double, depending on whther we\n@@ -1920,28 +1884,6 @@ abort(); \\\n }\n \n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s \", ASM_LONG),              \\\n-  output_addr_const (FILE,(VALUE)),             \\\n-  putc('\\n',FILE))\n-\n-/* Likewise for `char' and `short' constants.  */\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s \", ASM_SHORT),             \\\n-  output_addr_const (FILE,(VALUE)),             \\\n-  putc('\\n',FILE))\n-\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s\", ASM_BYTE_OP),            \\\n-  output_addr_const (FILE, (VALUE)),            \\\n-  putc ('\\n', FILE))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf ((FILE), \"%s0x%x\\n\", ASM_BYTE_OP, (VALUE))\n- \n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n #define ASM_OUTPUT_LABEL(FILE,NAME)     \\"}, {"sha": "df47f891cfd7c88a7ad78938d711dc30e9ad0e20", "filename": "gcc/config/i386/att.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fatt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fatt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fatt.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -41,7 +41,7 @@ do\t\t\t\t\t\t\t\t\\\n { size_t i = 0, limit = (SIZE); \t\t\t\t\\\n   while (i < limit)\t\t\t\t\t\t\\\n     { if (i%10 == 0) { if (i!=0) fprintf ((FILE), \"\\n\");\t\\\n-\t\t       fprintf ((FILE), \"%s\", ASM_BYTE_OP); }\t\\\n+\t\t       fputs (\"\\t.byte\\t\", (FILE)); }\t\t\\\n       else fprintf ((FILE), \",\");\t\t\t\t\\\n \tfprintf ((FILE), \"0x%x\", ((PTR)[i++] & 0377)) ;}\t\\\n       fprintf ((FILE), \"\\n\");\t\t\t\t\t\\"}, {"sha": "c58db1b3e8e596698454d64adff06780a368a22a", "filename": "gcc/config/i386/bsd.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fbsd.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -40,7 +40,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Assembler pseudos to introduce constants of various size.  */\n \n-#define ASM_BYTE_OP \"\\t.byte\\t\"\n #define ASM_SHORT \"\\t.word\\t\"\n #define ASM_LONG \"\\t.long\\t\"\n #define ASM_QUAD \"\\t.quad\\t\"  /* Should not be used for 32bit compilation.  */"}, {"sha": "36b4639346f345f9052e40aae7f2261c353caccf", "filename": "gcc/config/i386/djgpp.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fdjgpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fdjgpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdjgpp.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -62,18 +62,6 @@ Boston, MA 02111-1307, USA.  */\n #undef TEXT_SECTION_ASM_OP\n #define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n \n-/* How to output an unaligned integer.  */\n-#undef UNALIGNED_INT_ASM_OP\n-#define UNALIGNED_INT_ASM_OP \"\\t.long\\t\"\n-\n-/* How to output an unaligned double length integer.  */\n-#undef UNALIGNED_DOUBLE_INT_ASM_OP\n-#define UNALIGNED_DOUBLE_INT_ASM_OP \"\\t.quad\\t\"\n-\n-/* How to output an unaligned half length intenger.  */\n-#undef UNALIGNED_SHORT_ASM_OP\n-#define UNALIGNED_SHORT_ASM_OP \"\\t.short\\t\"\n-\n /* Define standard DJGPP installation paths.                             */\n /* We override default /usr or /usr/local part with /dev/env/DJDIR which */\n /* points to actual DJGPP instalation directory.                         */"}, {"sha": "0c60bdafd8d991a66b585bbf951115d23cfd7a57", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -784,6 +784,22 @@ static enum x86_64_reg_class merge_classes PARAMS ((enum x86_64_reg_class,\n #undef TARGET_ASM_CLOSE_PAREN\n #define TARGET_ASM_CLOSE_PAREN \"\"\n \n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP ASM_SHORT\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP ASM_LONG\n+#ifdef ASM_QUAD\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP ASM_QUAD\n+#endif\n+\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP TARGET_ASM_ALIGNED_HI_OP\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP TARGET_ASM_ALIGNED_SI_OP\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP TARGET_ASM_ALIGNED_DI_OP\n+\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST ix86_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE"}, {"sha": "b38bdcaa6295591582db489c2515fa508b02c345", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -2912,42 +2912,6 @@ do { long l;\t\t\t\t\t\t\\\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fputs (ASM_LONG, FILE),\t\t\t\\\n-  output_addr_const (FILE,(VALUE)),\t\t\\\n-  putc('\\n',FILE))\n-\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s\\t\", ASM_QUAD),\t\t\\\n-  output_addr_const (FILE,(VALUE)),\t\t\\\n-  putc('\\n',FILE))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fputs (ASM_SHORT, FILE),\t\t\t\\\n-  output_addr_const (FILE,(VALUE)),\t\t\\\n-  putc('\\n',FILE))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fputs (ASM_BYTE_OP, FILE),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  putc ('\\n', FILE))\n-\n-/* Given that x86 natively supports unaligned data, it's reasonable to\n-   assume that all x86 assemblers don't auto-align data.  Thus the \n-   unaligned output macros required by dwarf2 frame unwind information\n-   degenerate to the macros used above.  */\n-#define UNALIGNED_SHORT_ASM_OP\t\tASM_SHORT\n-#define UNALIGNED_INT_ASM_OP\t\tASM_LONG\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  asm_fprintf ((FILE), \"%s0x%x\\n\", ASM_BYTE_OP, (int) (VALUE))\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "b7d7b3d079b1bf1ee405b51ad5112c473b243448", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -189,7 +189,7 @@ Boston, MA 02111-1307, USA.  */\n   do {\t\t\t\t\t\t\t\t\t\\\n     if ((SIZE) == 4 && ((ENCODING) & 0x70) == DW_EH_PE_datarel)\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-        fputs (UNALIGNED_INT_ASM_OP, FILE);\t\t\t\t\\\n+        fputs (ASM_LONG, FILE);\t\t\t\\\n         assemble_name (FILE, XSTR (ADDR, 0));\t\t\t\t\\\n \tfputs (((ENCODING) & DW_EH_PE_indirect ? \"@GOT\" : \"@GOTOFF\"), FILE); \\\n         goto DONE;\t\t\t\t\t\t\t\\"}, {"sha": "211ca366ab7a24641e57c7a69421d8d46b511b69", "filename": "gcc/config/i386/sco5.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsco5.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -35,9 +35,6 @@ Boston, MA 02111-1307, USA.  */\n #undef ASCII_DATA_ASM_OP\n #define ASCII_DATA_ASM_OP\t\t\"\\t.ascii\\t\"\n \n-#undef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\t\t\"\\t.byte\\t\"\n-\n #undef IDENT_ASM_OP\n #define IDENT_ASM_OP\t\t\t\"\\t.ident\\t\"\n \n@@ -57,7 +54,6 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_LONG\t\t\t\"\\t.long\\t\"\n \n #undef ASM_QUAD\n-#undef ASM_OUTPUT_DOUBLE_INT\n \n #undef TYPE_ASM_OP\n #define TYPE_ASM_OP\t\t\t\"\\t.type\\t\"\n@@ -349,7 +345,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n-\t\tfprintf ((FILE), \"%s\", ASM_BYTE_OP);\t\t\t\\\n+\t\tfputs (\"\\t.byte\\t\", (FILE));\t\t\t\t\\\n \t      else\t\t\t\t\t\t\t\\\n \t\tfputc (',', (FILE));\t\t\t\t\t\\\n \t      fprintf ((FILE), \"0x%02x\", *_ascii_bytes);\t\t\\\n@@ -846,7 +842,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if ((SIZE) == 4 && ((ENCODING) & 0x70) == DW_EH_PE_datarel)\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-        fputs (UNALIGNED_INT_ASM_OP, FILE);\t\t\t\t\\\n+        fputs (ASM_LONG, FILE);\t\t\t\t\t\t\\\n         assemble_name (FILE, XSTR (ADDR, 0));\t\t\t\t\\\n \tfputs (((ENCODING) & DW_EH_PE_indirect ? \"@GOT\" : \"@GOTOFF\"), FILE); \\\n         goto DONE;\t\t\t\t\t\t\t\\"}, {"sha": "ff1585e05d8ce367060373e03a914d6b6d06e68d", "filename": "gcc/config/i386/sol2.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsol2.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -156,7 +156,3 @@ Boston, MA 02111-1307, USA.  */\n \n #undef LOCAL_LABEL_PREFIX\n #define LOCAL_LABEL_PREFIX \".\"\n-\n-/* Override defaults.h and insist that Solaris/Intel doesn't have\n-   an eight byte data output directive.  */\n-#define UNALIGNED_DOUBLE_INT_ASM_OP NULL"}, {"sha": "d280d583cbeece2898c5c502e32d882c6581e2b4", "filename": "gcc/config/i386/sun386.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsun386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsun386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsun386.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Assembler pseudos to introduce constants of various size.  */\n \n-#define ASM_BYTE_OP \"\\t.byte\\t\"\n #define ASM_SHORT \"\\t.value\\t\"\n #define ASM_LONG \"\\t.long\\t\"\n #define ASM_QUAD \"\\t.quad\\t\"  /* Should not be used for 32bit compilation.  */\n@@ -46,7 +45,7 @@ do\t\t\t\t\t\t\t\t\\\n { size_t i = 0, limit = (SIZE); \t\t\t\t\\\n   while (i < limit)\t\t\t\t\t\t\\\n     { if (i%10 == 0) { if (i!=0) fprintf ((FILE), \"\\n\");\t\\\n-\t\t       fprintf ((FILE), \"%s\", ASM_BYTE_OP); }\t\\\n+\t\t       fputs (\"\\t.byte\\t\", (FILE)); }\t\t\\\n       else fprintf ((FILE), \",\");\t\t\t\t\\\n       fprintf ((FILE), \"0x%x\", ((PTR)[i++] & 0377)) ;}\t\t\\\n       fprintf ((FILE), \"\\n\");\t\t\t\t\t\\"}, {"sha": "0d44b1a23e4cd2e0fb68a4247c6b6588b53ab315", "filename": "gcc/config/i386/sysv4.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -170,7 +170,7 @@ do { long value[3];\t\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if ((SIZE) == 4 && ((ENCODING) & 0x70) == DW_EH_PE_datarel)\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-        fputs (UNALIGNED_INT_ASM_OP, FILE);\t\t\t\t\\\n+        fputs (ASM_LONG, FILE);\t\t\t\t\t\t\\\n         assemble_name (FILE, XSTR (ADDR, 0));\t\t\t\t\\\n \tfputs (((ENCODING) & DW_EH_PE_indirect ? \"@GOT\" : \"@GOTOFF\"), FILE); \\\n         goto DONE;\t\t\t\t\t\t\t\\"}, {"sha": "b12cb123742786988d740c8f05798e23a4bb02c9", "filename": "gcc/config/i860/fx2800.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Ffx2800.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Ffx2800.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Ffx2800.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -339,9 +339,12 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_FILE_END(FILE)\t\t\t\t\t\\\n do {\t\t\t\t \t\t\t\t\\\n      if (current_function_original_name != NULL) {\t\t\\\n+       const char *long_op = integer_asm_op (4, FALSE);\t\t\\\n        tdesc_section();\t\t\t\t\t\t\\\n-       fprintf ((FILE), \"%s __ETEXT\\n\", ASM_LONG);\t\t\\\n-       fprintf ((FILE), \"%s 0\\n\", ASM_LONG);\t\t\t\\\n+       fprintf ((FILE), \"%s __ETEXT\\n\", long_op);\t\t\\\n+       fprintf ((FILE), \"%s 0\\n\", long_op);\t\t\t\\\n+       fputs (\"\\t.long\\t__ETEXT\\n\", (FILE));\t\t\t\\\n+       fputs (\"\\t.long\\t0\\n\", (FILE));\t\t\t\t\\\n        text_section();\t\t\t\t\t\t\\\n        fputs(\"__ETEXT:\\n\", (FILE));\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\"}, {"sha": "dfc9f0d1ea38f33e7809a61b3a36e2af2ad86df5", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -2003,6 +2003,9 @@ i860_output_function_epilogue (asm_file, local_bytes)\n   register unsigned mask;\n   unsigned intflags=0;\n   register TDESC_flags *flags = (TDESC_flags *) &intflags;\n+#ifdef\tOUTPUT_TDESC\t/* Output an ABI-compliant TDESC entry */\n+  const char *long_op = integer_asm_op (4, TRUE);\n+#endif\n \n   flags->version = 4;\n   flags->reg_packing = 1;\n@@ -2092,23 +2095,23 @@ i860_output_function_epilogue (asm_file, local_bytes)\n   }\n   assemble_name(asm_file,current_function_original_name);\n   fputs(\".TDESC:\\n\", asm_file);\n-  fprintf(asm_file, \"%s 0x%0x\\n\", ASM_LONG, intflags);\n-  fprintf(asm_file, \"%s %d\\n\", ASM_LONG,\n+  fprintf(asm_file, \"%s 0x%0x\\n\", long_op, intflags);\n+  fprintf(asm_file, \"%s %d\\n\", long_op,\n \tint_restored ? must_preserve_bytes : 0);\n   if (flags->version > 1) {\n-    fprintf(asm_file, \"%s %d\\n\", ASM_LONG,\n+    fprintf(asm_file, \"%s %d\\n\", long_op,\n \t(restored_so_far == int_restored) ? 0 : must_preserve_bytes +\n \t  (4 * int_restored));\n     if (flags->version > 2) {\n-      fprintf(asm_file, \"%s %d\\n\", ASM_LONG, frame_upper_bytes);\n+      fprintf(asm_file, \"%s %d\\n\", long_op, frame_upper_bytes);\n       if (flags->version > 3)\n-\tfprintf(asm_file, \"%s %d\\n\", ASM_LONG, frame_lower_bytes);\n+\tfprintf(asm_file, \"%s %d\\n\", long_op, frame_lower_bytes);\n     }\n   }\n   tdesc_section();\n-  fprintf(asm_file, \"%s \", ASM_LONG);\n+  fprintf(asm_file, \"%s \", long_op);\n   assemble_name(asm_file, current_function_original_name);\n-  fprintf(asm_file, \"\\n%s \", ASM_LONG);\n+  fprintf(asm_file, \"\\n%s \", long_op);\n   assemble_name(asm_file, current_function_original_name);\n   fputs(\".TDESC\\n\", asm_file);\n   text_section();"}, {"sha": "aec2f2c0a759861573b4098507b45bbfa065f295", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -614,11 +614,11 @@ struct cumulative_args { int ints, floats; };\n      or #BOTTOM_OF_STATIC,r29,r29  */\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0xec1f0000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0xe7ff0000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0xec1d0000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x4000f800));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0xe7bd0000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xec1f0000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xe7ff0000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xec1d0000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x4000f800));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xe7bd0000));\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -975,9 +975,6 @@ struct cumulative_args { int ints, floats; };\n \n /* Assembler pseudos to introduce constants of various size.  */\n \n-#define ASM_BYTE_OP \"\\t.byte\\t\"\n-#define ASM_SHORT \"\\t.short\"\n-#define ASM_LONG \"\\t.long\"\n #define ASM_DOUBLE \"\\t.double\"\n \n /* Output at beginning of assembler file.  */\n@@ -1085,30 +1082,6 @@ do { ASM_OUTPUT_ALIGN ((FILE), 2);\t\t\t\t\t\\\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n   fprintf (FILE, \"\\t.float %.12e\\n\", (VALUE))\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This is how to output code to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "2a374fc5ff6b75fdc694dc8df88fd1f48b1f2182", "filename": "gcc/config/i860/paragon.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fparagon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fparagon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fparagon.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -133,7 +133,7 @@ Boston, MA 02111-1307, USA.  */\n \t          fprintf ((FILE), \"\\\"\\n\");\t\t\t\\\n \t          bytes_in_chunk = 0;\t\t\t\t\\\n \t        }\t\t\t\t\t\t\\\n-\t      fprintf ((FILE), \"%s%d\\n\", ASM_BYTE_OP, ch);\t\\\n+\t      assemble_aligned_integer (1, GEN_INT (ch));\t\\\n \t    }\t\t\t\t\t\t\t\\\n           else\t\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\\"}, {"sha": "cc26176c963383483ce807db35a2eaa8c3812eeb", "filename": "gcc/config/i860/sysv3.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fsysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi860%2Fsysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv3.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -113,7 +113,7 @@ extern const char *current_function_original_name;\n \t          fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n \t          bytes_in_chunk = 0;\t\t\t\t\t\\\n \t        }\t\t\t\t\t\t\t\\\n-\t      fprintf ((FILE), \"%s%d\\n\", ASM_BYTE_OP, ch);\t\t\\\n+\t      assemble_aligned_integer (1, GEN_INT (ch));\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n           else\t\t\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\"}, {"sha": "ffa28d58161f41368a7f881726bb5f0b1d0a8bac", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -93,6 +93,9 @@ static int ret_label = 0;\n  || current_function_varargs)\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE i960_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "12cf09c787ff57aba087ae191692dabe5beca600", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1401,30 +1401,6 @@ extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n \n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  i960_output_float(FILE, VALUE)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)\t\\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n #define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n   fprintf (FILE, \"\\tst\\t%s,(sp)\\n\\taddo\\t4,sp,sp\\n\", reg_names[REGNO])\n \n@@ -1558,11 +1534,11 @@ extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n \n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x8C203000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x8CE03000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x84212000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x8C203000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x00000000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x8CE03000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x00000000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x84212000));\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */"}, {"sha": "c46fe1262ca0547a3e36936ae188c3b66bf9ae36", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -139,6 +139,7 @@ static rtx ia64_expand_lock_test_and_set PARAMS ((enum machine_mode,\n \t\t\t\t\t\t  tree, rtx));\n static rtx ia64_expand_lock_release PARAMS ((enum machine_mode, tree, rtx));\n const struct attribute_spec ia64_attribute_table[];\n+static bool ia64_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void ia64_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ia64_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ia64_output_function_end_prologue PARAMS ((FILE *));\n@@ -165,6 +166,23 @@ static rtx ia64_cycle_display PARAMS ((int, rtx));\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN ia64_expand_builtin\n \n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tdata1\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\tdata2\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\tdata4\\t\"\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP \"\\tdata8\\t\"\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\tdata2.ua\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\tdata4.ua\\t\"\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP \"\\tdata8.ua\\t\"\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER ia64_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE ia64_output_function_prologue\n #undef TARGET_ASM_FUNCTION_END_PROLOGUE\n@@ -2589,6 +2607,28 @@ ia64_hard_regno_rename_ok (from, to)\n   return 1;\n }\n \n+/* Target hook for assembling integer objects.  Handle word-sized\n+   aligned objects and detect the cases when @fptr is needed.  */\n+\n+static bool\n+ia64_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (size == UNITS_PER_WORD && aligned_p\n+      && !(TARGET_NO_PIC || TARGET_AUTO_PIC)\n+      && GET_CODE (x) == SYMBOL_REF\n+      && SYMBOL_REF_FLAG (x))\n+    {\n+      fputs (\"\\tdata8\\t@fptr(\", asm_out_file);\n+      output_addr_const (asm_out_file, x);\n+      fputs (\")\\n\", asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\n /* Emit the function prologue.  */\n \n static void"}, {"sha": "24fdba1483d016ff75f920cb45381216ec7e98d1", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 3, "deletions": 70, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1944,54 +1944,6 @@ do {\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tdata4 0x%lx\\n\", t & 0xffffffff);\t\t\\\n } while (0)\n   \n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble an integer of 1, 2, 4, or 8 bytes, respectively, whose value\n-   is VALUE.  */\n-\n-/* This is how to output an assembler line defining a `char' constant.  */\n-\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"%s\", ASM_BYTE_OP);\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an assembler line defining a `short' constant.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tdata2\\t\");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an assembler line defining an `int' constant.\n-   We also handle symbol output here.  */\n-\n-/* ??? For ILP32, also need to handle function addresses here.  */\n-\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tdata4\\t\");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an assembler line defining a `long' constant.\n-   We also handle symbol output here.  */\n-\n-#define ASM_OUTPUT_DOUBLE_INT(FILE, VALUE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tdata8\\t\");\t\t\t\t\t\t\\\n-  if (!(TARGET_NO_PIC || TARGET_AUTO_PIC) && SYMBOL_REF_FLAG (VALUE))\t\\\n-    fprintf (FILE, \"@fptr(\");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  if (!(TARGET_NO_PIC || TARGET_AUTO_PIC) && SYMBOL_REF_FLAG (VALUE))\t\\\n-    fprintf (FILE, \")\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* This is how to output an assembler line defining a `char' constant\n    to an xdata segment.  */\n \n@@ -2044,12 +1996,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n \n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble a single byte containing the number VALUE.  */\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n-  fprintf (STREAM, \"%s0x%x\\n\", ASM_BYTE_OP, (int)(VALUE) & 0xff)\n-\n \f\n /* Output of Uninitialized Variables.  */\n \n@@ -2361,9 +2307,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n       reltag = \"@gprel(\";\t\t\t\t\t\t\\\n     if (reltag)\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tfputs (((SIZE) == 4 ? UNALIGNED_INT_ASM_OP\t\t\t\\\n-\t        : (SIZE) == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP\t\t\\\n-\t\t: (abort (), \"\")), FILE);\t\t\t\t\\\n+\tfputs (integer_asm_op (SIZE, FALSE), FILE);\t\t\t\\\n \tfputs (reltag, FILE);\t\t\t\t\t\t\\\n \tassemble_name (FILE, XSTR (ADDR, 0));\t\t\t\t\\\n \tfputc (')', FILE);\t\t\t\t\t\t\\\n@@ -2425,13 +2369,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define DWARF2_DEBUGGING_INFO\n \n-/* C string constants giving the pseudo-op to use for a sequence of\n-   2, 4, and 8 byte unaligned constants.  dwarf2out.c needs these.  */\n-\n-#define UNALIGNED_SHORT_ASM_OP\t\t\"\\tdata2.ua\\t\"\n-#define UNALIGNED_INT_ASM_OP\t\t\"\\tdata4.ua\\t\"\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\tdata8.ua\\t\"\n-\n #define DWARF2_ASM_LINE_DEBUG_INFO (TARGET_DWARF2_ASM)\n \n /* Use tags for debug info labels, so that they don't break instruction\n@@ -2447,9 +2384,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    proper relocations for them.  */\n #define ASM_OUTPUT_DWARF_OFFSET(FILE, SIZE, LABEL)\t\\\n   do {\t\t\t\t\t\t\t\\\n-    fputs (((SIZE) == 4 ? UNALIGNED_INT_ASM_OP\t\t\\\n-\t    : (SIZE) == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP\t\\\n-\t    : (abort (), \"\")), FILE);\t\t\t\\\n+    fputs (integer_asm_op (SIZE, FALSE), FILE);\t\t\\\n     fputs (\"@secrel(\", FILE);\t\t\t\t\\\n     assemble_name (FILE, LABEL);\t\t\t\\\n     fputc (')', FILE);\t\t\t\t\t\\\n@@ -2458,9 +2393,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Emit a PC-relative relocation.  */\n #define ASM_OUTPUT_DWARF_PCREL(FILE, SIZE, LABEL)\t\\\n   do {\t\t\t\t\t\t\t\\\n-    fputs (((SIZE) == 4 ? UNALIGNED_INT_ASM_OP\t\t\\\n-\t    : (SIZE) == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP\t\\\n-\t    : (abort (), \"\")), FILE);\t\t\t\\\n+    fputs (integer_asm_op (SIZE, FALSE), FILE);\t\t\\\n     fputs (\"@pcrel(\", FILE);\t\t\t\t\\\n     assemble_name (FILE, LABEL);\t\t\t\\\n     fputc (')', FILE);\t\t\t\t\t\\"}, {"sha": "1b5d4691efcde94151462fff074a58f3f7150a25", "filename": "gcc/config/ia64/sysv4.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fia64%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fia64%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsysv4.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -10,9 +10,6 @@\n /* Various pseudo-ops for which the Intel assembler uses non-standard\n    definitions.  */\n \n-#undef ASM_BYTE_OP\n-#define ASM_BYTE_OP \"\\tdata1\\t\"\n-\n #undef STRING_ASM_OP\n #define STRING_ASM_OP \"\\tstringz\\t\"\n "}, {"sha": "2b1dc75d33379f84238e72863688567865a20bc6", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -79,6 +79,11 @@ static int    m32r_issue_rate\t   PARAMS ((void));\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m32r_attribute_table\n \n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE m32r_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "4741849f7946645e1ca3db4d839a954270f8e4e1", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1719,37 +1719,6 @@ do {\t\t\t\t\t\t\t\\\n    no longer contain unusual constructs.  */\n #define ASM_APP_OFF \"\"\n \n-/* This is how to output an assembler line defining a `char' constant.  */\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.byte\\t\");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to output an assembler line defining a `short' constant.  */\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.hword\\t\");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to output an assembler line defining an `int' constant.\n-   We also handle symbol output here.  */\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.word\\t\");\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n /* This is how to output an assembler line defining a `float' constant.  */\n #define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n@@ -1776,10 +1745,6 @@ do {\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)\t\t\t\t\\\n-  fprintf (FILE, \"%s0x%x\\n\", ASM_BYTE_OP, (VALUE))\n-\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n /* On the M32R we need to ensure the next instruction starts on a 32 bit"}, {"sha": "b0e82dcedd49972bb0c904afccaf778cf6337cbc", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -213,6 +213,9 @@ static int nb_soft_regs;\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m68hc11_attribute_table\n \n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE m68hc11_output_function_epilogue\n "}, {"sha": "c2603c5967026391d1730568b31d01b34d69892b", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1579,38 +1579,18 @@ do {                                                                    \\\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n do { long l[2];\t\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n-     fprintf (FILE, \"\\t%s\\t0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1]);\t\\\n+     fprintf (FILE, \"\\t%s\\t0x%lx,0x%lx\\n\",\t\t\t\t\\\n+\t      integer_asm_op (4, TRUE), l[0], l[1]);\t\t\t\\\n    } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n #define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n do { long l;\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n-     fprintf ((FILE), \"\\t%s\\t0x%lx\\n\", ASM_LONG, l);\t\\\n+     assemble_aligned_integer (4, GEN_INT (l));\t\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining a `long' constant.  */\n-#define ASM_OUTPUT_INT(FILE,VALUE)\t\t        \\\n-( fprintf (FILE, \"\\t%s\\t\", ASM_LONG),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)\t\t\t\\\n-( fprintf (FILE, \"\\t%s\\t\", ASM_SHORT),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)\t\t\t\\\n-( fprintf (FILE, \"%s\", ASM_BYTE_OP),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\t\\\n-  putc ('\\n', FILE))\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)\t\t\t\\\n-  fprintf ((FILE), \"%s0x%x\\n\", ASM_BYTE_OP, (VALUE))\n-\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n \n@@ -1700,11 +1680,11 @@ do { long l;\t\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  asm_fprintf (FILE, \"\\t%s\\tL%d-L%d\\n\", ASM_SHORT, VALUE, REL)\n+  asm_fprintf (FILE, \"\\t%s\\tL%d-L%d\\n\", integer_asm_op (2, TRUE), VALUE, REL)\n \n /* This is how to output an element of a case-vector that is absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n-  asm_fprintf (FILE, \"\\t%s\\t.L%d\\n\", ASM_SHORT, VALUE)\n+  asm_fprintf (FILE, \"\\t%s\\t.L%d\\n\", integer_asm_op (2, TRUE), VALUE)\n \n /* This is how to output an assembler line that says to advance the\n    location counter to a multiple of 2**LOG bytes.  */\n@@ -1733,8 +1713,6 @@ do { long l;\t\t\t\t\t\t\\\n /* The prefix for immediate operands.  */\n #define IMMEDIATE_PREFIX \"#\"\n #define GLOBAL_ASM_OP   \"\\t.globl\\t\"\n-#define ASM_LONG        \".long\"\n-#define ASM_SHORT       \".word\"\n \n \f\n /* Miscellaneous Parameters.  */"}, {"sha": "998240eb3869a74fb3aec53731f8183c50b2714e", "filename": "gcc/config/m68k/amix.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Famix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Famix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Famix.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -101,7 +101,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   register size_t sp = 0, limit = (LEN);\t\t\t\\\n-  fprintf ((FILE), \"%s\", BYTE_ASM_OP);\t\t\t\t\\\n+  fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     int ch = (PTR)[sp];\t\t\t\t\t\t\\\n     if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n@@ -116,7 +116,7 @@ do {\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tif ((sp % 10) == 0)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", BYTE_ASM_OP);\t\t\\\n+\t    fprintf ((FILE), \"\\n%s\", integer_asm_op (1, TRUE));\t\\\n \t  }\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\"}, {"sha": "12b106a4be5ea7f6cbe987c2a21acfd0d226fc5e", "filename": "gcc/config/m68k/atari.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fatari.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fatari.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fatari.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -61,7 +61,7 @@ int switch_table_difference_label_flag;\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   register size_t sp = 0, limit = (LEN);\t\t\t\\\n-  fprintf ((FILE), \"%s\", BYTE_ASM_OP);\t\t\t\t\\\n+  fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     int ch = (PTR)[sp];\t\t\t\t\t\t\\\n     if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n@@ -76,7 +76,7 @@ int switch_table_difference_label_flag;\n       {\t\t\t\t\t\t\t\t\\\n \tif ((sp % 10) == 0)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", BYTE_ASM_OP);\t\t\\\n+\t    fprintf ((FILE), \"\\n%s\", integer_asm_op (1, TRUE));\t\\\n \t  }\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\"}, {"sha": "86d9853c3f00041a0141282970b949d1760c2405", "filename": "gcc/config/m68k/auxas.h", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fauxas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fauxas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fauxas.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -38,21 +38,15 @@ Boston, MA 02111-1307, USA.  */\n #define NO_DOLLAR_IN_LABEL\n #define NO_DOT_IN_LABEL\n \n+#undef INT_OP_GROUP\n+#define INT_OP_GROUP INT_OP_NO_DOT\n+\n #undef TEXT_SECTION_ASM_OP\n #define TEXT_SECTION_ASM_OP\t\"\\ttext\"\n \n #undef DATA_SECTION_ASM_OP\n #define DATA_SECTION_ASM_OP\t\"\\tdata\\t1\"\n \n-#undef BYTE_ASM_OP\n-#define\tBYTE_ASM_OP\t\t\"\\tbyte\\t\"\n-\n-#undef WORD_ASM_OP\n-#define WORD_ASM_OP\t\t\"\\tshort\\t\"\n-\n-#undef LONG_ASM_OP\n-#define LONG_ASM_OP\t\t\"\\tlong\\t\"\n-\n #undef SPACE_ASM_OP\n #define SPACE_ASM_OP\t\t\"\\tspace\\t\"\n \n@@ -76,12 +70,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define ADDITIONAL_REGISTER_NAMES { {\"%a6\", 14}, {\"%a7\", 15} }\n \n-#undef ASM_OUTPUT_INT\n-#define ASM_OUTPUT_INT(FILE,VALUE)                      \\\n-( fprintf ((FILE), \"%s\", LONG_ASM_OP),                  \\\n-  output_addr_const ((FILE), (VALUE)),                  \\\n-  fprintf ((FILE), \"\\n\"))\n-\n #undef ASM_OUTPUT_COMMON\n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n ( fputs (\"\\tcomm\\t\", (FILE)),\t\t\t\t\\"}, {"sha": "b23792930319e508e0a1e332db64b61faaf3ca6e", "filename": "gcc/config/m68k/dpx2.h", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -31,6 +31,9 @@ Boston, MA 02111-1307, USA.  */\n #undef SELECT_RTX_SECTION\n #include \"svr3.h\"\n \n+#undef INT_OP_GROUP\n+#define INT_OP_GROUP INT_OP_DC\n+\n /* We use collect2 instead of ctors_section constructors.  */\n #undef INIT_SECTION_ASM_OP\n #undef FINI_SECTION_ASM_OP\n@@ -119,13 +122,6 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_OUTPUT_SOURCE_FILENAME(FILE, NA)\t\\\n   do { fprintf ((FILE), \"\\t.file\\t'%s'\\n\", (NA)); } while (0)\n \n-/* Assembler pseudos to introduce constants of various size.  */\n-\n-#undef ASM_BYTE_OP\n-#define ASM_BYTE_OP \"\\tdc.b\\t\"\n-#undef ASM_LONG\n-#define ASM_LONG \"\\tdc.l\"\n-\n /* \n  * we don't seem to support any of:\n  * .globl\n@@ -310,31 +306,6 @@ do { long l;\t\t\t\t\t\t\\\n        fprintf (FILE, \"\\tdc.l $%lx\\n\", l);\t\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-#undef ASM_OUTPUT_INT \n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tdc.l \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-#undef ASM_OUTPUT_SHORT\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tdc.w \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#undef ASM_OUTPUT_CHAR\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tdc.b \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#undef ASM_OUTPUT_BYTE\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\tdc.b $%x\\n\", (int)(VALUE))\n-\n /* This is how to output an element of a case-vector that is absolute.\n    (The 68000 does not use such vectors,\n    but we must define this macro anyway.)  */"}, {"sha": "8fa6b42ac333d73547bddee33c8e82bbbc68033a", "filename": "gcc/config/m68k/dpx2g.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fdpx2g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fdpx2g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2g.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -15,7 +15,4 @@\n /* GAS does not understand .ident so don't output anything for #ident.  */\n #undef ASM_OUTPUT_IDENT\n \n-#undef ASM_LONG\n-#define ASM_LONG \"\\t.long\"\n-\n /* end of dpx2g.h */"}, {"sha": "11784c7ca9f3534555d7cdfc734084dd66c33f5e", "filename": "gcc/config/m68k/hp320.h", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -59,6 +59,9 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"m68k/m68k.h\"\n \n+#undef INT_OP_GROUP\n+#define INT_OP_GROUP INT_OP_NO_DOT\n+\n /* See m68k.h.  7 means 68020 with 68881.  */\n \n #ifndef TARGET_DEFAULT\n@@ -164,10 +167,6 @@ Boston, MA 02111-1307, USA.  */\n #undef READONLY_DATA_SECTION\n #undef ASM_OUTPUT_DOUBLE\n #undef ASM_OUTPUT_FLOAT\n-#undef ASM_OUTPUT_INT\n-#undef ASM_OUTPUT_SHORT\n-#undef ASM_OUTPUT_CHAR\n-#undef ASM_OUTPUT_BYTE\n #undef ASM_OUTPUT_ADDR_VEC_ELT\n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n #undef ASM_OUTPUT_ALIGN\n@@ -286,30 +285,6 @@ do { long l[3];\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\tlong 0x%lx,0x%lx,0x%lx\\n\", l[0], l[1], l[2]);\t\\\n    } while (0)\n   \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tlong \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tshort \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tbyte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\tbyte 0x%x\\n\", (int)(VALUE))\n-\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\tlong L%d\\n\", VALUE)\n "}, {"sha": "31415b97ad2d20ef9a5b560c665ceb0d25753c0f", "filename": "gcc/config/m68k/lynx.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Flynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Flynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flynx.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -29,8 +29,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define BSS_SECTION_ASM_OP \"\\t.bss\"\n \n-#define ASM_LONG \".long\"\n-\n #include <lynx.h>\n \n /* See m68k.h.  7 means 68020 with 68881.  */"}, {"sha": "228d98f1043cff420a57aa2059e9b675af1a3c5d", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -88,6 +88,35 @@ int m68k_align_funcs;\n int m68k_last_compare_had_fp_operands;\n \f\n /* Initialize the GCC target structure.  */\n+\n+#if INT_OP_GROUP == INT_OP_DOT_WORD\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+#endif\n+\n+#if INT_OP_GROUP == INT_OP_NO_DOT\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tbyte\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\tshort\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\tlong\\t\"\n+#endif\n+\n+#if INT_OP_GROUP == INT_OP_DC\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tdc.b\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\tdc.w\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\tdc.l\\t\"\n+#endif\n+\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP TARGET_ASM_ALIGNED_HI_OP\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP TARGET_ASM_ALIGNED_SI_OP\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE m68k_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "4637d812249aea8253d32ea5f76fbac6bb33d928", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -25,6 +25,16 @@ Boston, MA 02111-1307, USA.  */\n    many of the definitions that relate to assembler syntax.  */\n \n \n+/* Classify the groups of pseudo-ops used to assemble QI, HI and SI\n+   quantities.  */\n+#define INT_OP_STANDARD\t0\t/* .byte, .short, .long */\n+#define INT_OP_DOT_WORD\t1\t/* .byte, .word, .long */\n+#define INT_OP_NO_DOT   2\t/* byte, short, long */\n+#define INT_OP_DC\t3\t/* dc.b, dc.w, dc.l */\n+\n+/* Set the default */\n+#define INT_OP_GROUP INT_OP_DOT_WORD\n+\n /* Names to predefine in the preprocessor for this target machine.  */\n \n /* See sun3.h, sun2.h, isi.h for different CPP_PREDEFINES.  */\n@@ -1816,30 +1826,6 @@ do { long l;\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.long 0x%lx\\n\", l);\t\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (int)(VALUE))\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "88154fc7a7f8b85caa35e0aeac46ca9c7532b033", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -183,7 +183,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   register int sp = 0, ch;\t\t\t\t\t\\\n-  fprintf ((FILE), \"%s\", BYTE_ASM_OP);\t\t\t\t\\\n+  fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     ch = (PTR)[sp];\t\t\t\t\t\t\\\n     if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n@@ -198,7 +198,7 @@ do {\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tif ((sp % 10) == 0)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", BYTE_ASM_OP);\t\t\\\n+\t    fprintf ((FILE), \"\\n%s\", integer_asm_op (1, TRUE));\t\\\n \t  }\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\"}, {"sha": "d2bb108bd992fdb32387a4d6b43bfdcd9818d279", "filename": "gcc/config/m68k/m68kv4.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kv4.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -217,7 +217,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   register size_t sp = 0, limit = (LEN);\t\t\t\\\n-  fprintf ((FILE), \"%s\", BYTE_ASM_OP);\t\t\t\t\\\n+  fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     int ch = (PTR)[sp];\t\t\t\t\t\t\\\n     if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n@@ -232,7 +232,7 @@ do {\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tif ((sp % 10) == 0)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", BYTE_ASM_OP);\t\t\\\n+\t    fprintf ((FILE), \"\\n%s\", integer_asm_op (1, TRUE));\t\\\n \t  }\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n@@ -308,13 +308,13 @@ int switch_table_difference_label_flag;\n #undef TRAMPOLINE_TEMPLATE\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x227a));\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (8));\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x2f3a));\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (8));\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x4e75));\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x227a));\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (8));\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x2f3a));\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (8));\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x4e75));\t\t\t\\\n+  assemble_aligned_integer (4, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (4, const0_rtx);\t\t\t\t\\\n }\n \n /* Redefine since we are using a different trampoline */"}, {"sha": "6801f6b53eac72f3944afd87eacddd2e951b1b30", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 13, "deletions": 55, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -289,29 +289,12 @@ Boston, MA 02111-1307, USA.  */\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n   sprintf ((OUTPUT), \"%s_%%%d\", (NAME), (LABELNO)))\n \n+#undef INT_OP_GROUP\n #ifdef USE_GAS\n-#undef ASM_LONG\n-#define ASM_LONG\t\".long\"\n-#undef ASM_SHORT\n-#define ASM_SHORT\t\".short\"\n-#undef ASM_CHAR\n-#define ASM_CHAR\t\".byte\"\n-#undef ASM_BYTE\n-#define ASM_BYTE\t\".byte\"\n-#undef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\"\\t.byte\\t\"\n+#define INT_OP_GROUP INT_OP_STANDARD\n #else\n-#undef ASM_LONG\n-#define ASM_LONG\t\"long\"\n-#undef ASM_SHORT\n-#define ASM_SHORT\t\"short\"\n-#undef ASM_CHAR\n-#define ASM_CHAR\t\"byte\"\n-#undef ASM_BYTE\n-#define ASM_BYTE\t\"byte\"\n-#undef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\"\\tbyte\\t\"\n-#endif /* USE_GAS */\n+#define INT_OP_GROUP INT_OP_NO_DOT\n+#endif\n \n /* The sysV68 as doesn't know about double's and float's.  */\n /* This is how to output an assembler line defining a `double' constant.  */\n@@ -320,14 +303,16 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n do { long l[2];\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\\\n-     fprintf (FILE, \"\\t%s 0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1]); \\\n+     fprintf ((FILE), \"%s0x%lx,0x%lx\\n\",\t\t\\\n+\t      integer_asm_op (4, TRUE), l[0], l[1]);\t\\\n    } while (0)\n \n #undef ASM_OUTPUT_LONG_DOUBLE\n #define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\t\\\n do { long l[3];\t\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n-     fprintf (FILE, \"\\t%s 0x%lx,0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n+     fprintf (FILE, \"%s 0x%lx,0x%lx,0x%lx\\n\",\t\t\t\t\\\n+\t      integer_asm_op (4, TRUE), l[0], l[1], l[2]);\t\t\\\n    } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n@@ -336,37 +321,9 @@ do { long l[3];\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n do { long l;\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\\\n-     fprintf ((FILE), \"\\t%s 0x%lx\\n\", ASM_LONG, l);\t\\\n+     assemble_aligned_integer (4, GEN_INT (l));\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#undef ASM_OUTPUT_INT\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t%s \", ASM_LONG),\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#undef ASM_OUTPUT_SHORT\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t%s \", ASM_SHORT),\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#undef ASM_OUTPUT_CHAR\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t%s \", ASM_CHAR),\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#undef ASM_OUTPUT_BYTE\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t%s 0x%x\\n\", ASM_BYTE, (int)(VALUE))\n-\n /* This is how to output an assembler line\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n@@ -419,7 +376,7 @@ do { long l;\t\t\t\t\t\\\n #undef ASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n   do { register size_t sp = 0, lp = 0, limit = (LEN);\t\t\\\n-    fprintf ((FILE), \"%s\", ASM_BYTE_OP);\t\t\t\\\n+    fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n   loop:\t\t\t\t\t\t\t\t\\\n     if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\')\t\\\n       { lp += 3;\t\t\t\t\t\t\\\n@@ -490,13 +447,14 @@ do { long l;\t\t\t\t\t\\\n \n #undef ASM_OUTPUT_ADDR_VEC_ELT\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n-    asm_fprintf (FILE, \"\\t%s %LL%d\\n\", ASM_LONG, (VALUE))\n+    asm_fprintf (FILE, \"%s%LL%d\\n\", integer_asm_op (4, TRUE), (VALUE))\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n-    asm_fprintf (FILE, \"\\t%s %LL%d-%LL%d\\n\", ASM_SHORT, (VALUE), (REL))\n+    asm_fprintf (FILE, \"\\t%s %LL%d-%LL%d\\n\",\t\t\t\\\n+\t\t integer_asm_op (2, TRUE), (VALUE), (REL))\n \n #ifndef USE_GAS\n "}, {"sha": "7f44b2682093cde5e9c1080c6ddcc9daa3f27620", "filename": "gcc/config/m68k/sgs.h", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fsgs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Fsgs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsgs.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -30,21 +30,18 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"m68k/m68k.h\"\n \n+#undef INT_OP_GROUP\n+#define INT_OP_GROUP INT_OP_STANDARD\n+\n /* SGS specific assembler pseudo ops.  */\n \n-#define\tBYTE_ASM_OP\t\t\"\\t.byte \"\n-#define WORD_ASM_OP\t\t\"\\t.short \"\n-#define LONG_ASM_OP\t\t\"\\t.long \"\n #define SPACE_ASM_OP\t\t\"\\t.space \"\n #define ALIGN_ASM_OP\t\t\"\\t.align \"\n #undef GLOBAL_ASM_OP\n #define GLOBAL_ASM_OP\t\t\"\\t.global \"\n #define SWBEG_ASM_OP\t\t\"\\t.swbeg \"\n #define SET_ASM_OP\t\t\"\\t.set \"\n \n-#define UNALIGNED_SHORT_ASM_OP\t\"\\t.short \"\t/* Used in dwarfout.c */\n-#define UNALIGNED_INT_ASM_OP\t\"\\t.long \"\t\t/* Used in dwarfout.c */\n-\n #define ASM_PN_FORMAT\t\t\"%s_%d\"\t\t/* Format for private names */\n \n /* Here are four prefixes that are used by asm_fprintf to\n@@ -105,18 +102,12 @@ Boston, MA 02111-1307, USA.  */\n /* This is how to output an assembler line defining an `int' constant.  */\n /* The SGS assembler doesn't understand \".word\".  */\n \n-#undef ASM_OUTPUT_SHORT\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)\t\t\t\\\n-( fprintf ((FILE), \"%s\", WORD_ASM_OP),\t\t\t\\\n-  output_addr_const ((FILE), (VALUE)),\t\t\t\\\n-  fprintf ((FILE), \"\\n\"))\n-\n #undef ASM_OUTPUT_LONG_DOUBLE\n #define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\\\n do { long l[3];\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\\\n-     fprintf ((FILE), \"%s0x%lx,0x%lx,0x%lx\\n\", LONG_ASM_OP,\t\\\n-\t     l[0], l[1], l[2]);\t\t\t\t\t\\\n+     fprintf ((FILE), \"%s0x%lx,0x%lx,0x%lx\\n\",\t\t\t\\\n+\t      integer_asm_op (4, TRUE), l[0], l[1], l[2]);\t\\\n    } while (0)\n \n /* This is how to output an assembler line defining a `double' constant.  */\n@@ -125,8 +116,8 @@ do { long l[3];\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n do { long l[2];\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\\\n-     fprintf ((FILE), \"%s0x%lx,0x%lx\\n\", LONG_ASM_OP,\t\\\n-\t      l[0], l[1]);\t\t\t\t\\\n+     fprintf ((FILE), \"%s0x%lx,0x%lx\\n\",\t\t\\\n+\t      integer_asm_op (4, TRUE), l[0], l[1]);\t\\\n    } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n@@ -135,7 +126,7 @@ do { long l[2];\t\t\t\t\t\t\\\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n do { long l;\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n-     fprintf ((FILE), \"%s0x%lx\\n\", LONG_ASM_OP, l);\t\\\n+     assemble_aligned_integer (4, GEN_INT (l));\t\t\\\n    } while (0)\n \n /* This is how to output an assembler line that says to advance the\n@@ -160,7 +151,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   register size_t sp = 0, limit = (LEN);\t\t\t\\\n-  fprintf ((FILE), \"%s\", BYTE_ASM_OP);\t\t\t\t\\\n+  fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     int ch = (PTR)[sp];\t\t\t\t\t\t\\\n     if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n@@ -175,7 +166,7 @@ do {\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tif ((sp % 10) == 0)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", BYTE_ASM_OP);\t\t\\\n+\t    fprintf ((FILE), \"\\n%s\", integer_asm_op (1, TRUE));\t\\\n \t  }\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n@@ -423,7 +414,7 @@ extern int switch_table_difference_label_flag;\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n-  asm_fprintf (FILE, \"%s%LL%d-%LL%d\\n\", WORD_ASM_OP, VALUE, REL)\n+  asm_fprintf (FILE, \"%s%LL%d-%LL%d\\n\", integer_asm_op (2, TRUE), VALUE, REL)\n \n /* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to\n    keep switch tables in the text section.  */"}, {"sha": "f9009df0083b3b2f41bba29633ade36bb91f9525", "filename": "gcc/config/m68k/tower-as.h", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ftower-as.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -63,6 +63,9 @@ Boston, MA 02111-1307, USA.  */\n #define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n #define SGS_NO_LI\t\t/* Suppress jump table label usage */\n \n+#undef INT_OP_GROUP\n+#define INT_OP_GROUP INT_OP_NO_DOT\n+\n /* Turn on SDB debugging info.  */\n \n #define SDB_DEBUGGING_INFO\n@@ -276,34 +279,6 @@ do { long l;\t\t\t\t\t\\\n      fprintf ((FILE), \"\\tlong 0x%lx\\n\", l);\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#undef ASM_OUTPUT_INT\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tlong \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#undef ASM_OUTPUT_SHORT\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tshort \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#undef ASM_OUTPUT_CHAR\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tbyte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#undef ASM_OUTPUT_BYTE\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\tbyte 0x%x\\n\", (int)(VALUE))\n-\n #undef ASM_OUTPUT_ADDR_VEC_ELT\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n@@ -585,7 +560,6 @@ do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n    and CTOR_LIST_END to contribute to the .init section an instruction to\n    push a word containing 0 (or some equivalent of that).  */\n \n-#define ASM_LONG\t\"\\tlong\"\n #undef INIT_SECTION_ASM_OP\n #define INIT_SECTION_ASM_OP\t\"\\tsection\\t~init\"\n #undef FINI_SECTION_ASM_OP"}, {"sha": "e3ce288da618315e5fcf0f50792b4ac0b6f28e0f", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -76,6 +76,17 @@ static void m88k_svr3_asm_out_destructor PARAMS ((rtx, int));\n static int m88k_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP \"\\tbyte\\t\"\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\thalf\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\tword\\t\"\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\tuahalf\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\tuaword\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE m88k_output_function_prologue\n #undef TARGET_ASM_FUNCTION_END_PROLOGUE\n@@ -2364,7 +2375,8 @@ output_tdesc (file, offset)\n \n   tdesc_section ();\n \n-  fprintf (file, \"%s%d,%d\", ASM_LONG, /* 8:0,22:(20 or 16),2:2 */\n+  /* 8:0,22:(20 or 16),2:2 */\n+  fprintf (file, \"%s%d,%d\", integer_asm_op (4, TRUE),\n \t   (((xmask != 0) ? 20 : 16) << 2) | 2,\n \t   flag_pic ? 2 : 1);\n "}, {"sha": "47c49b822cdbb8c85c92194895ce9a8d0942c721", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1154,9 +1154,9 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n   /* Restore r10 and load the static chain register.  */\t\t\\\n   fprintf (FILE, \"\\tld.d\\t %s,%s,24\\n\", reg_names[10], reg_names[10]);\t\\\n   /* Storage: r10 save area, static chain, function address.  */\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.\n@@ -1687,9 +1687,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n #define BSS_ASM_OP\t\t\"\\tbss\\t\"\n #define FLOAT_ASM_OP\t\t\"\\tfloat\\t\"\n #define DOUBLE_ASM_OP\t\t\"\\tdouble\\t\"\n-#define ASM_LONG\t\t\"\\tword\\t\"\n-#define SHORT_ASM_OP\t\t\"\\thalf\\t\"\n-#define CHAR_ASM_OP\t\t\"\\tbyte\\t\"\n #define ASCII_DATA_ASM_OP\t\"\\tstring\\t\"\n \n /* These are particular to the global pool optimization.  */\n@@ -1715,8 +1712,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n /* These are specific to version 03.00 assembler syntax.  */\n #define INTERNAL_ASM_OP\t\t\"\\tlocal\\t\"\n #define VERSION_ASM_OP\t\t\"\\tversion\\t\"\n-#define UNALIGNED_SHORT_ASM_OP\t\"\\tuahalf\\t\"\n-#define UNALIGNED_INT_ASM_OP\t\"\\tuaword\\t\"\n #define PUSHSECTION_ASM_OP\t\"\\tsection\\t\"\n #define POPSECTION_ASM_OP\t\"\\tprevious\"\n \n@@ -2035,7 +2030,8 @@ do {\t\t\t\t\t\t\t\t\t \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     union { REAL_VALUE_TYPE d; long l[2]; } x;\t\t\t\t\\\n     x.d = (VALUE);\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s0x%.8lx, 0x%.8lx\\n\", ASM_LONG,\t\t\t\\\n+    fprintf (FILE, \"%s0x%.8lx, 0x%.8lx\\n\",\t\t\t\t\\\n+\t     integer_asm_op (4, TRUE),\t\t\t\t\t\\\n \t     (long) x.l[0], (long) x.l[1]);\t\t\t\t\\\n   } while (0)\n \n@@ -2044,32 +2040,10 @@ do {\t\t\t\t\t\t\t\t\t \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     int i;\t\t\t\t\t\t\t\t\\\n     FLOAT_TO_INT_INTERNAL (VALUE, i);\t\t\t\t\t\\\n-    fprintf (FILE, \"%s0x%.8x\\n\", ASM_LONG, i);\t\t\t\\\n+    assemble_aligned_integer (4, GEN_INT (i));\t\t\t\t\\\n   } while (0)\n \n-/* Likewise for `int', `short', and `char' constants.  */\n-#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\t\\\n-( fprintf (FILE, \"%s\", ASM_LONG),\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)\t\t\t\t\t\\\n-( fprintf (FILE, \"%s\", SHORT_ASM_OP),\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)\t\t\t\t\t\\\n-( fprintf (FILE, \"%s\", CHAR_ASM_OP),\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"%s0x%x\\n\", CHAR_ASM_OP, (int)(VALUE))\n-\n /* The single-byte pseudo-op is the default.  Override svr[34].h.  */\n-#undef\tASM_BYTE_OP\n-#define ASM_BYTE_OP \"\\tbyte\\t\"\n #undef\tASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii (FILE, ASCII_DATA_ASM_OP, 48, P, SIZE)"}, {"sha": "45cb3e86df1415cb33d3d57e8fe78c7e97406efd", "filename": "gcc/config/mcore/mcore-elf.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -40,11 +40,6 @@ Boston, MA 02111-1307, USA.  */\n #define DWARF_DEBUGGING_INFO 1\n #endif\n \n-/* MCore defines .long and .short to NOT force any alignment.\n-   This lets you misalign as much as you wish.  */\n-#define\tUNALIGNED_INT_ASM_OP\t\"\\t.long\\t\"\n-#define\tUNALIGNED_SHORT_ASM_OP\t\"\\t.short\\t\"\n-\n #define EXPORTS_SECTION_ASM_OP\t\"\\t.section .exports\"\n \n #define SUBTARGET_EXTRA_SECTIONS in_const, in_exports"}, {"sha": "2b47e24e82ddf827b3521238610dbd2970cc6ce5", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -144,6 +144,13 @@ static void\t  mcore_asm_named_section      PARAMS ((const char *,\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n #endif\n \n+#ifdef OBJECT_FORMAT_ELF\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.short\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.long\\t\"\n+#endif\n+\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE mcore_attribute_table\n "}, {"sha": "2709c578aabf63bbc794521afc6a11e8e0df8dc0", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1266,24 +1266,6 @@ extern long mcore_current_compilation_timestamp;\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n-#define ASM_OUTPUT_INT(STREAM, EXP)  \t\\\n-  (fprintf (STREAM, \"\\t.long\\t\"),      \t\\\n-   output_addr_const (STREAM, (EXP)),  \t\\\n-   fputc ('\\n', STREAM))\t\t\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n-  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n-   output_addr_const (STREAM, (EXP)),  \\\n-   fputc ('\\n', STREAM))\t\t\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP)  \t\\\n-  (fprintf (STREAM, \"\\t.byte\\t\"),      \t\\\n-   output_addr_const (STREAM, (EXP)),  \t\\\n-   fputc ('\\n', STREAM))\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \t\\\n-  fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE)  \t\\\n-\n /* This is how to output an assembler line\n    that says to advance the location counter by SIZE bytes.  */\n #undef  ASM_OUTPUT_SKIP"}, {"sha": "2c8fd83dd74c13e489d9b042abad5487d310fea8", "filename": "gcc/config/mips/iris5.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Firis5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Firis5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis5.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -19,6 +19,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#define TARGET_IRIX5 1\n+\n #ifndef TARGET_DEFAULT\n #define\tTARGET_DEFAULT\tMASK_ABICALLS\n #endif\n@@ -155,10 +157,6 @@ do {\t\t\t\t\t\t\\\n   fputs (\" .text\\n\", FILE);\t\t\t\\\n } while (0)\n \n-/* To get unaligned data, we have to turn off auto alignment.  */\n-#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.align 0\\n\\t.half\\t\"\n-#define UNALIGNED_INT_ASM_OP\t\t\"\\t.align 0\\n\\t.word\\t\"\n-\n /* Also do this for libcalls.  */\n #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\\\n   mips_output_external_libcall (FILE, XSTR (FUN, 0))"}, {"sha": "776434a8d59b430a41f4bd7567c14e4c97fcbe16", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -159,8 +159,6 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_OUTPUT_UNDEF_FUNCTION\n #undef ASM_OUTPUT_EXTERNAL_LIBCALL\n #undef ASM_DECLARE_FUNCTION_SIZE\n-#undef UNALIGNED_SHORT_ASM_OP\n-#undef UNALIGNED_INT_ASM_OP\n \n /* Stuff we need for Irix 6 that isn't in Irix 5.  */\n "}, {"sha": "9601efb946d9549e8997bc2733e8eefa331275a4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -118,6 +118,7 @@ static void abort_with_insn\t\t\tPARAMS ((rtx, const char *))\n   ATTRIBUTE_NORETURN;\n static int symbolic_expression_p                PARAMS ((rtx));\n static void mips_add_gc_roots                   PARAMS ((void));\n+static bool mips_assemble_integer\t  PARAMS ((rtx, unsigned int, int));\n static void mips_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void mips_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static enum processor_type mips_parse_cpu       PARAMS ((const char *));\n@@ -456,6 +457,20 @@ enum reg_class mips_char_to_class[256] =\n };\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER mips_assemble_integer\n+\n+#if TARGET_IRIX5 && !TARGET_IRIX6\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.align 0\\n\\t.half\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.align 0\\n\\t.word\\t\"\n+#endif\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE mips_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -5788,7 +5803,29 @@ print_operand_address (file, addr)\n \tbreak;\n     }\n }\n+\f\n+/* Target hook for assembling integer objects.  It appears that the Irix\n+   6 assembler can't handle 64-bit decimal integers, so avoid printing\n+   such an integer here.  */\n \n+static bool\n+mips_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if ((TARGET_64BIT || TARGET_GAS) && size == 8 && aligned_p)\n+    {\n+      fputs (\"\\t.dword\\t\", asm_out_file);\n+      if (HOST_BITS_PER_WIDE_INT < 64 || GET_CODE (x) != CONST_INT)\n+\toutput_addr_const (asm_out_file, x);\n+      else\n+\tprint_operand (asm_out_file, x, 'X');\n+      fputc ('\\n', asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n \f\n /* If optimizing for the global pointer, keep track of all of the externs, so\n    that at the end of the file, we can emit the appropriate .extern"}, {"sha": "c877fd15adc026362bb330ae7dfeb3cdc572e28a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -4396,69 +4396,6 @@ do {\t\t\t\t\t\t\t\\\n   mips_output_float (STREAM, VALUE)\n \n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t\");\t\t\t\t\t\\\n-  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Likewise for 64 bit, `char' and `short' constants.\n-\n-   FIXME: operand_subword can't handle some complex constant expressions\n-   that output_addr_const can (for example it does not call\n-   simplify_subtraction).  Since GAS can handle dword, even for mipsII,\n-   rely on that to avoid operand_subword for most of the cases where this\n-   matters.  Try gcc.c-torture/compile/930326-1.c with -mips2 -mlong64,\n-   or the same case with the type of 'i' changed to long long.\n-\n-*/\n-\n-#define ASM_OUTPUT_DOUBLE_INT(STREAM,VALUE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_64BIT || TARGET_GAS)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.dword\\t\");\t\t\t\t\t\\\n-      if (HOST_BITS_PER_WIDE_INT < 64 || GET_CODE (VALUE) != CONST_INT)\t\\\n-\t/* We can't use 'X' for negative numbers, because then we won't\t\\\n-\t   get the right value for the upper 32 bits.  */\t\t\\\n-        output_addr_const (STREAM, VALUE);\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t/* We must use 'X', because otherwise LONG_MIN will print as\t\\\n-\t   a number that the Irix 6 assembler won't accept.  */\t\t\\\n-        print_operand (STREAM, VALUE, 'X');\t\t\t\t\\\n-      fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      assemble_integer (operand_subword ((VALUE), 0, 0, DImode),\t\\\n-\t\t\tUNITS_PER_WORD, BITS_PER_WORD, 1);\t\t\\\n-      assemble_integer (operand_subword ((VALUE), 1, 0, DImode),\t\\\n-\t\t\tUNITS_PER_WORD, BITS_PER_WORD, 1);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_SHORT(STREAM,VALUE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.half\\t\");\t\t\t\t\t\\\n-  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_OUTPUT_CHAR(STREAM,VALUE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.byte\\t\");\t\t\t\t\t\\\n-  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-}\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(STREAM,VALUE)\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.byte\\t0x%x\\n\", (int)(VALUE))\n-\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\"}, {"sha": "e178355649005461c38ad545c754a036ac91a0c6", "filename": "gcc/config/mips/sni-svr4.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Fsni-svr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmips%2Fsni-svr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsni-svr4.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -68,7 +68,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define NM_FLAGS\t\"-p\"\n \n-#define ASM_LONG\t\".word\\t\"\n #define ASM_GLOBAL\t\".rdata\\n\\t\\t.globl\\t\"\n \n #include \"mips/mips.h\""}, {"sha": "0a3aca1ca803d549f1c41d15dac888e11e1e21f7", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -122,7 +122,6 @@ extern void mmix_canonicalize_comparison PARAMS ((RTX_CODE *, rtx *, rtx *));\n extern int mmix_rtx_cost_recalculated\n   PARAMS ((rtx, RTX_CODE, RTX_CODE, int *));\n extern int mmix_address_cost PARAMS ((rtx));\n-extern void mmix_asm_output_double_int PARAMS ((FILE *, rtx, int));\n extern void mmix_print_operand PARAMS ((FILE *, rtx, int));\n extern void mmix_print_operand_address PARAMS ((FILE *, rtx));\n extern int mmix_valid_comparison PARAMS ((RTX_CODE, enum machine_mode, rtx));"}, {"sha": "9ba6c2d2b409bd0b337bcd5f9662514ca9547083", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -87,6 +87,7 @@ static void mmix_output_shifted_value PARAMS ((FILE *, HOST_WIDEST_INT));\n static void mmix_output_condition PARAMS ((FILE *, rtx, int));\n static HOST_WIDEST_INT mmix_intval PARAMS ((rtx));\n static void mmix_output_octa PARAMS ((FILE *, HOST_WIDEST_INT, int));\n+static bool mmix_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void mmix_init_machine_status PARAMS ((struct function *));\n \n extern void mmix_target_asm_function_prologue\n@@ -100,6 +101,17 @@ extern void mmix_target_asm_function_epilogue\n \n /* Node: Function Entry */\n \n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP NULL\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP NULL\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP NULL\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER mmix_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE mmix_target_asm_function_prologue\n \n@@ -1911,31 +1923,45 @@ mmix_asm_output_float (stream, valuep)\n \t\t\t       + 1)));\n }\n \n-/* ASM_OUTPUT_DOUBLE_INT.  */\n+/* Target hook for assembling integer objects.  Use mmix_print_operand\n+   for WYDE and TETRA.  Use mmix_output_octa to output 8-byte\n+   CONST_DOUBLEs.  */\n \n-void\n-mmix_asm_output_double_int (stream, value, do_begin_end)\n-     FILE * stream;\n-     rtx value;\n-     int do_begin_end;\n+static bool\n+mmix_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n {\n-  if (do_begin_end)\n-    fprintf (stream, \"\\tOCTA \");\n-\n-  if (GET_CODE (value) == CONST_DOUBLE)\n-    {\n-      /* Get the bit representation of this number.  */\n-      HOST_WIDE_INT wval = mmix_intval (value);\n-      mmix_output_octa (stream, wval, 0);\n-    }\n-  else\n-    /* FIXME: We scrap the '@' symbol-modifier since it's not used\n-       anymore; we used to jump through lots of hoops, attempting to get\n-       mmixal-compatible symbols; defined before use (still failed).  */\n-    output_addr_const (stream, value);\n-\n-  if (do_begin_end)\n-    fprintf (stream, \"\\n\");\n+  if (aligned_p)\n+    switch (size)\n+      {\n+      case 1:\n+\tfputs (\"\\tBYTE\\t\", asm_out_file);\n+\tmmix_print_operand (asm_out_file, x, 'B');\n+\tfputc ('\\n', asm_out_file);\n+\treturn true;\n+\n+      case 2:\n+\tfputs (\"\\tWYDE\\t\", asm_out_file);\n+\tmmix_print_operand (asm_out_file, x, 'W');\n+\tfputc ('\\n', asm_out_file);\n+\treturn true;\n+\n+      case 4:\n+\tfputs (\"\\tTETRA\\t\", asm_out_file);\n+\tmmix_print_operand (asm_out_file, x, 'L');\n+\tfputc ('\\n', asm_out_file);\n+\treturn true;\n+\n+      case 8:\n+\tif (GET_CODE (x) == CONST_DOUBLE)\n+\t  mmix_output_octa (asm_out_file, mmix_intval (x), 0);\n+\telse\n+\t  assemble_integer_with_op (\"\\tOCTA\\t\", x);\n+\treturn true;\n+      }\n+  return default_assemble_integer (x, size, aligned_p);\n }\n \n /* ASM_OUTPUT_ASCII.  */\n@@ -2301,7 +2327,7 @@ mmix_print_operand (stream, x, code)\n \n     case CONST_DOUBLE:\n       /* Do somewhat as CONST_INT.  */\n-      mmix_asm_output_double_int (stream, modified_x, 0);\n+      mmix_output_octa (stream, mmix_intval (modified_x), 0);\n       return;\n \n     case CONST:"}, {"sha": "8cb14e29f8ac32be8220deb97e3db1cbad86674b", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -972,42 +972,6 @@ const_section ()\t\t\t\t\t\t\\\n #define ASM_OUTPUT_FLOAT(STREAM, VALUE) \\\n  mmix_asm_output_float (STREAM, &VALUE)\n \n-#define ASM_OUTPUT_DOUBLE_INT(STREAM, EXP) \\\n- mmix_asm_output_double_int (STREAM, EXP, 1)\n-\n-#define ASM_OUTPUT_INT(STREAM, EXP)\t\t\\\n- do {\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\tTETRA \");\t\t\t\\\n-  mmix_print_operand (STREAM, EXP, 'L');\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n- } while (0)\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP) \\\n- do {\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\tWYDE \");\t\t\t\\\n-  mmix_print_operand (STREAM, EXP, 'W');\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n- } while (0)\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP) \\\n- do {\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\tBYTE \");\t\t\t\\\n-  mmix_print_operand (STREAM, EXP, 'B');\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n- } while (0)\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n- fprintf (STREAM, \"\\tBYTE %d\\n\", (int) (VALUE) & 255)\n-\n-#define ASM_BYTE_OP \"\\tBYTE\\t\"\n-\n-/* We need these for DWARF2 EH data.  If we don't define them, the\n-   ordinary BYTE, WYDE, TETRA and OCTA will be used, and those are\n-   aligning.  */\n-#define UNALIGNED_SHORT_ASM_OP \"\\t.2byte\\t\"\n-#define UNALIGNED_INT_ASM_OP \"\\t.4byte\\t\"\n-#define UNALIGNED_DOUBLE_INT_ASM_OP \"\\t.8byte\\t\"\n-\n #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) \\\n  mmix_asm_output_ascii (STREAM, PTR, LEN)\n \n@@ -1150,12 +1114,6 @@ const_section ()\t\t\t\t\t\t\\\n  mmix_asm_output_addr_vec_elt (STREAM, VALUE)\n \n \n-/* FIXME: Add to docs; It is not mentioned at all that\n-   ASM_OUTPUT_ADDR_VEC_ELT is used if relative elements are\n-   used, and that the default expects an undocumented macro\n-   \"ASM_LONG\".  */\n-#define ASM_LONG \"OCTA\"\n-\n /* Node: Exception Region Output */\n /* (empty) */\n "}, {"sha": "bbe25b61aa25b53f9dfd5ec0ca2c89fab91af71c", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -67,6 +67,8 @@ static void count_tst_insns PARAMS ((int *));\n static int out_of_line_epilogue;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f"}, {"sha": "3aa38cf80f9dfd67dbfc4170ebeb5e73f5b33940", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -834,29 +834,6 @@ do { char dstr[30];\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This says how to output the assembler to define a global\n    uninitialized but not common symbol.\n    Try to use asm_output_bss to implement this macro.  */"}, {"sha": "54bf0409262edbbaad468765782df16712e85603", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -53,6 +53,8 @@ Boston, MA 02111-1307, USA.  */\n \t\t\t\t|| regs_ever_live[16] || regs_ever_live[17]))\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f"}, {"sha": "4adf82372c741141a21c4fec0918f34a43eaf3b0", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -918,29 +918,6 @@ do { char dstr[30];\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This says how to output the assembler to define a global\n    uninitialized but not common symbol.\n    Try to use asm_output_bss to implement this macro.  */"}, {"sha": "3a1515cdde5e7c22c9e0395005b42ceb191fd45a", "filename": "gcc/config/ns32k/encore.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fns32k%2Fencore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fns32k%2Fencore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fencore.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -40,7 +40,6 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_OUTPUT_ALIGN\n #undef ASM_OUTPUT_ASCII\n #undef ASM_OUTPUT_DOUBLE\n-#undef ASM_OUTPUT_INT\n #undef ASM_OUTPUT_INTERNAL_LABEL\n #undef ASM_OUTPUT_LOCAL\n #undef CPP_PREDEFINES\n@@ -98,11 +97,6 @@ output_file_directive ((FILE), main_input_filename)\n  *  uninitialized locals.\n  */\n \n-#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\\\n-( fprintf (FILE, \"\\t.double \"),\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n #define ASM_OUTPUT_LABELREF_AS_INT(STREAM, NAME)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\t.double\\t\");\t\t\t\t\t\\"}, {"sha": "3802675f981214895b4a8b812bc3478ebf1b4b48", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -74,6 +74,14 @@ static void ns32k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE ns32k_attribute_table\n \n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+\n+#ifdef ENCORE_ASM\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.double\\t\"\n+#endif\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE ns32k_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "8bd64f6a2efef8aa07ce7427cf3b2599179257eb", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -736,8 +736,8 @@ operands on the 32k are stored).  */\n   fprintf (FILE, \"\\tjump \" );\t\t\t\t\t\t\\\n   PUT_ABSOLUTE_PREFIX (FILE);\t\t\t\t\t\t\\\n   fprintf (FILE, \"__trampoline\\n\" );\t\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -1295,28 +1295,6 @@ while (0)\n \n /* This is how to output an assembler line defining an `int' constant.  */\n \n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This is how to output an assembler line defining an external/static\n    address which is not in tree format (for collect.c).  */\n "}, {"sha": "416e079511a1adf3ff0c9b45d4effd33ad92bd52", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -91,20 +91,6 @@ Boston, MA 02111-1307, USA.  */\n #undef STATIC_CHAIN_REGNUM\n #define STATIC_CHAIN_REGNUM 31\n \n-/* This is not needed for correct operation in 32bit mode, and since\n-   older versions of gas and the hpux assembler do not accept .dword\n-   we put this here instead of the more logical location, pa.h.  */\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE) \\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\t.dword \", FILE);\t\t\t\t\\\n-      if (function_label_operand (VALUE, VOIDmode))\t\t\\\n-\tfputs (\"P%\", FILE);\t\t\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\t\\\n-      fputs (\"\\n\", FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n /* Nonzero if we do not know how to pass TYPE solely in registers.  */\n #define MUST_PASS_IN_STACK(MODE,TYPE) \\\n   ((TYPE) != 0\t\t\t\t\t\t\t\\"}, {"sha": "6234a3356f44da9b04ecf21b286c30e81c3bd082", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -64,6 +64,7 @@ static void pa_add_gc_roots PARAMS ((void));\n static void mark_deferred_plabels PARAMS ((void *));\n static void compute_zdepwi_operands PARAMS ((unsigned HOST_WIDE_INT, unsigned *));\n static int compute_movstrsi_length PARAMS ((rtx));\n+static bool pa_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void remove_useless_addtr_insns PARAMS ((rtx, int));\n static rtx store_reg PARAMS ((int, int, int));\n static rtx load_reg PARAMS ((int, int, int));\n@@ -113,6 +114,22 @@ struct deferred_plabel\n int n_deferred_plabels = 0;\n \f\n /* Initialize the GCC target structure.  */\n+\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP \"\\t.dword\\t\"\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP TARGET_ASM_ALIGNED_HI_OP\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP TARGET_ASM_ALIGNED_SI_OP\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP TARGET_ASM_ALIGNED_DI_OP\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER pa_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE pa_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -209,6 +226,18 @@ override_options ()\n   if (flag_pic == 1 || TARGET_64BIT)\n     flag_pic = 2;\n \n+  /* We can't guarantee that .dword is available for 32-bit targets.  */\n+  if (UNITS_PER_WORD == 4)\n+    targetm.asm_out.aligned_op.di = NULL;\n+\n+  /* The unaligned ops are only available when using GAS.  */\n+  if (!TARGET_GAS)\n+    {\n+      targetm.asm_out.unaligned_op.hi = NULL;\n+      targetm.asm_out.unaligned_op.si = NULL;\n+      targetm.asm_out.unaligned_op.di = NULL;\n+    }\n+\n   /* Register global variables with the garbage collector.  */\n   pa_add_gc_roots ();\n }\n@@ -2513,6 +2542,27 @@ output_64bit_ior (operands)\n   return \"depdi -1,%2,%3,%0\";\n }\n \f\n+/* Target hook for assembling integer objects.  This code handles\n+   aligned SI and DI integers specially, since function references must\n+   be preceded by P%.  */\n+\n+static bool\n+pa_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (size == UNITS_PER_WORD && aligned_p\n+      && function_label_operand (x, VOIDmode))\n+    {\n+      fputs (size == 8? \"\\t.dword\\tP%\" : \"\\t.word\\tP%\", asm_out_file);\n+      output_addr_const (asm_out_file, x);\n+      fputc ('\\n', asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\f\n /* Output an ascii string.  */\n void\n output_ascii (file, p, size)"}, {"sha": "525a9420d2d65bae034e1d347641f1afe3b1d207", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1751,43 +1751,6 @@ while (0)\n        fprintf (FILE, \"\\t.word 0x%lx\\n\", l);\t\t\t\t\\\n      } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant. \n-\n-   This is made more complicated by the fact that functions must be\n-   prefixed by a P% as well as code label references for the exception\n-   table -- otherwise the linker chokes.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-{ fputs (\"\\t.word \", FILE);\t\t\t\\\n-  if (function_label_operand (VALUE, VOIDmode))\t\\\n-    fputs (\"P%\", FILE);\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\\\n-  fputs (\"\\n\", FILE);}\n-\n-/* Likewise for `short' and `char' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fputs (\"\\t.half \", FILE),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fputs (\"\\n\", FILE))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fputs (\"\\t.byte \", FILE),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fputs (\"\\n\", FILE))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (int)(VALUE))\n-\n-/* C string constants giving the pseudo-op to use for a sequence of\n-   2, 4, and 8 byte unaligned constants.  dwarf2out.c needs these.  */\n-\n-#define UNALIGNED_SHORT_ASM_OP\t\t(TARGET_GAS ? \"\\t.half \" : NULL)\n-#define UNALIGNED_INT_ASM_OP\t\t(TARGET_GAS ? \"\\t.word \" : NULL)\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t(TARGET_GAS ? \"\\t.dword \" : NULL)\n-\n #define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     /* We only handle DATA objects here, functions are globalized in\t\\"}, {"sha": "505456550bd72a0e0b718e6e593564f7b64aeaef", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -53,11 +53,21 @@ int current_first_parm_offset;\n /* rtx cc0_reg_rtx; - no longer needed? */\n \n static rtx find_addr_reg PARAMS ((rtx)); \n-static const char *singlemove_string PARAMS ((rtx *)); \n+static const char *singlemove_string PARAMS ((rtx *));\n+static bool pdp11_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void pdp11_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void pdp11_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_BYTE_OP\n+#define TARGET_ASM_BYTE_OP NULL\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP NULL\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP NULL\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER pdp11_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE pdp11_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -944,6 +954,34 @@ print_operand_address (file, addr)\n     }\n }\n \n+/* Target hook to assemble integer objects.  We need to use the\n+   pdp-specific version of output_addr_const.  */\n+\n+static bool\n+pdp11_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (aligned_p)\n+    switch (size)\n+      {\n+      case 1:\n+\tfprintf (asm_out_file, \"\\t.byte\\t\");\n+\toutput_addr_const_pdp11 (asm_out_file, x);\n+\tfprintf (asm_out_file, \" /* char */\\n\");\n+\treturn true;\n+\n+      case 2:\n+\tfprintf (asm_out_file, TARGET_UNIX_ASM ? \"\\t\" : \"\\t.word\\t\");\n+\toutput_addr_const_pdp11 (asm_out_file, x);\n+\tfprintf (asm_out_file, \" /* short */\\n\");\n+\treturn true;\n+      }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\n+\n /* register move costs, indexed by regs */\n \n static int move_costs[N_REG_CLASSES][N_REG_CLASSES] = "}, {"sha": "61327e748f583ad256b108b36bde263c709d06e8", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1099,25 +1099,6 @@ fprintf (FILE, \"$help$: . = .+8 ; space for tmp moves!\\n\")\t\\\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n   fprintf (FILE, \"\\tfloat %.12e\\n\", (VALUE))\n \n-/* Likewise for `short' and `char' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, TARGET_UNIX_ASM ? \"\\t\" : \"\\t.word \"),\t\\\n-  output_addr_const_pdp11 (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \" /*short*/\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const_pdp11 (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \" /* char */\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.\n-   This won't actually be used since we define ASM_OUTPUT_CHAR.\n-*/\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte %o\\n\", (VALUE))\n-\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii (FILE, P, SIZE)\n \n@@ -1228,10 +1209,10 @@ JMP\tFUNCTION\t0x0058  0x0000 <- FUNCTION\n   if (TARGET_SPLIT)\t\t\t\\\n     abort();\t\t\t\t\\\n \t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x9400+STATIC_CHAIN_REGNUM)); \\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT(0x0058));\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x9400+STATIC_CHAIN_REGNUM));\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT(0x0058));\t\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n }\n \n #define TRAMPOLINE_SIZE 8"}, {"sha": "11c6aad9d61d6d30ed46b99131e9959a26c1b530", "filename": "gcc/config/pj/pj.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpj%2Fpj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fpj%2Fpj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1049,7 +1049,6 @@ struct pj_args\n   fprintf (FILE,\"\\t! %s\\n\", TARGET_LITTLE_ENDIAN ? \".little\" : \".big\");      \\\n   fprintf (FILE,\"\\t.align 4\\n\");\n \n-#define ASM_LONG \".long\"\n #define ASM_APP_ON              \"\"\n #define ASM_APP_OFF             \"\"\n #define FILE_ASM_OP             \"\\t.file\\n\"\n@@ -1201,24 +1200,6 @@ do { char dstr[30];                                     \\\n      fprintf ((FILE), \"\\t.float %s\\n\", dstr);           \\\n    } while (0)\n \n-#define ASM_OUTPUT_INT(STREAM, EXP)             \\\n-  (fprintf ((STREAM), \"\\t.long\\t\"),             \\\n-   output_addr_const ((STREAM), (EXP)),         \\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP)   \\\n-  (fprintf ((STREAM), \"\\t.short\\t\"),    \\\n-   output_addr_const ((STREAM), (EXP)), \\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP)            \\\n-  (fprintf ((STREAM), \"\\t.byte\\t\"),             \\\n-   output_addr_const ((STREAM), (EXP)),         \\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE)          \\\n-  fprintf ((STREAM), \"\\t.byte\\t%d\\n\", (VALUE))  \n-\n /* This is how to output an assembler line\n    that says to advance the location counter by SIZE bytes.  */\n "}, {"sha": "f9b7e9d89895ba62e633fff518782c8705d7505c", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1404,30 +1404,6 @@ struct rt_cargs {int gregs, fregs; };\n        fprintf (FILE, \"\\t.long 0x%x\\n\", u_i_f.i);\\\n      } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This is how to output code to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "80a4c8abae46f39f8a98d938ad6fb78d021b4b9e", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -274,29 +274,8 @@ do {\t\t\t\t\t\t\\\n \t       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n \t\t   && ! TARGET_NO_FP_IN_TOC)))))\n \n-/* This is how to output an assembler line defining an `int'\n-   constant.  */\n-#undef  ASM_OUTPUT_INT\n-#define ASM_OUTPUT_INT(FILE, VALUE)            \\\n-  do                                           \\\n-    {                                          \\\n-      fputs (\"\\t.long \", (FILE));              \\\n-      output_addr_const ((FILE), (VALUE));     \\\n-      putc ('\\n', (FILE));                     \\\n-    }                                          \\\n-  while (0)\n-\n-/* This is how to output an assembler line defining a `double int'\n-   constant.  */\n-#undef  ASM_OUTPUT_DOUBLE_INT\n-#define ASM_OUTPUT_DOUBLE_INT(FILE, VALUE)     \\\n-  do                                           \\\n-    {                                          \\\n-      fputs (DOUBLE_INT_ASM_OP, (FILE));       \\\n-      output_addr_const ((FILE), (VALUE));     \\\n-      putc ('\\n', (FILE));                     \\\n-    }                                          \\\n-  while (0)\n-\n #undef  ASM_DEFAULT_SPEC\n #define\tASM_DEFAULT_SPEC \"-mppc64\"\n+\n+/* We don't need to generate entries in .fixup.  */\n+#undef RELOCATABLE_NEEDS_FIXUP"}, {"sha": "b2abd819cf7192d230919905d8034dfef769a2d1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -135,6 +135,7 @@ static void toc_hash_mark_table PARAMS ((void *));\n static int constant_pool_expr_1 PARAMS ((rtx, int *, int *));\n static void rs6000_free_machine_status PARAMS ((struct function *));\n static void rs6000_init_machine_status PARAMS ((struct function *));\n+static bool rs6000_assemble_integer PARAMS ((rtx, unsigned int, int));\n static int rs6000_ra_ever_killed PARAMS ((void));\n static tree rs6000_handle_longcall_attribute PARAMS ((tree *, tree, tree, int, bool *));\n const struct attribute_spec rs6000_attribute_table[];\n@@ -222,6 +223,35 @@ static const char alt_reg_names[][8] =\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE rs6000_attribute_table\n \n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP DOUBLE_INT_ASM_OP\n+\n+/* Default unaligned ops are only provided for ELF.  Find the ops needed\n+   for non-ELF systems.  */\n+#ifndef OBJECT_FORMAT_ELF\n+#ifdef OBJECT_FORMAT_COFF\n+/* For ECOFF.  rs6000_assemble_integer will handle unaligned DIs on\n+   64-bit targets.  */\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.vbyte\\t2,\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.vbyte\\t4,\"\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.vbyte\\t8,\"\n+#else\n+/* For Darwin.  */\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.short\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.long\\t\"\n+#endif\n+#endif\n+\n+/* This hook deals with fixups for relocatable code and DI-mode objects\n+   in 64-bit code.  */\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER rs6000_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE rs6000_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -532,6 +562,14 @@ rs6000_override_options (default_cpu)\n   if (TARGET_TOC) \n     ASM_GENERATE_INTERNAL_LABEL (toc_label_name, \"LCTOC\", 1);\n \n+  /* We can only guarantee the availability of DI pseudo-ops when\n+     assembling for 64-bit targets.  */\n+  if (!TARGET_POWERPC64)\n+    {\n+      targetm.asm_out.aligned_op.di = NULL;\n+      targetm.asm_out.unaligned_op.di = NULL;\n+    }\n+\n   /* Arrange to save and restore machine status around nested functions.  */\n   init_machine_status = rs6000_init_machine_status;\n   free_machine_status = rs6000_free_machine_status;\n@@ -6019,6 +6057,70 @@ print_operand_address (file, x)\n     abort ();\n }\n \f\n+/* Target hook for assembling integer objects.  The powerpc version has\n+   to handle fixup entries for relocatable code if RELOCATABLE_NEEDS_FIXUP\n+   is defined.  It also needs to handle DI-mode objects on 64-bit\n+   targets.  */\n+\n+static bool\n+rs6000_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+#ifdef RELOCATABLE_NEEDS_FIXUP\n+  /* Special handling for SI values.  */\n+  if (size == 4 && aligned_p)\n+    {\n+      extern int in_toc_section PARAMS ((void));\n+      static int recurse = 0;\n+      \n+      /* For -mrelocatable, we mark all addresses that need to be fixed up\n+\t in the .fixup section.  */\n+      if (TARGET_RELOCATABLE\n+\t  && !in_toc_section ()\n+\t  && !in_text_section ()\n+\t  && !recurse\n+\t  && GET_CODE (x) != CONST_INT\n+\t  && GET_CODE (x) != CONST_DOUBLE\n+\t  && CONSTANT_P (x))\n+\t{\n+\t  char buf[256];\n+\n+\t  recurse = 1;\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCP\", fixuplabelno);\n+\t  fixuplabelno++;\n+\t  ASM_OUTPUT_LABEL (asm_out_file, buf);\n+\t  fprintf (asm_out_file, \"\\t.long\\t(\");\n+\t  output_addr_const (asm_out_file, x);\n+\t  fprintf (asm_out_file, \")@fixup\\n\");\n+\t  fprintf (asm_out_file, \"\\t.section\\t\\\".fixup\\\",\\\"aw\\\"\\n\");\n+\t  ASM_OUTPUT_ALIGN (asm_out_file, 2);\n+\t  fprintf (asm_out_file, \"\\t.long\\t\");\n+\t  assemble_name (asm_out_file, buf);\n+\t  fprintf (asm_out_file, \"\\n\\t.previous\\n\");\n+\t  recurse = 0;\n+\t  return true;\n+\t}\n+      /* Remove initial .'s to turn a -mcall-aixdesc function\n+\t address into the address of the descriptor, not the function\n+\t itself.  */\n+      else if (GET_CODE (x) == SYMBOL_REF\n+\t       && XSTR (x, 0)[0] == '.'\n+\t       && DEFAULT_ABI == ABI_AIX)\n+\t{\n+\t  const char *name = XSTR (x, 0);\n+\t  while (*name == '.')\n+\t    name++;\n+\n+\t  fprintf (asm_out_file, \"\\t.long\\t%s\\n\", name);\n+\t  return true;\n+\t}\n+    }\n+#endif /* RELOCATABLE_NEEDS_FIXUP */\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\f\n enum rtx_code\n rs6000_reverse_condition (mode, code)\n      enum machine_mode mode;"}, {"sha": "8669324b126dd5e40012c085c37d0405246f2426", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -2727,50 +2727,6 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n     fprintf (FILE, \"\\t.long 0x%lx\\n\", t & 0xffffffff);\t\\\n   }\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_32BIT)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      assemble_integer (operand_subword ((VALUE), 0, 0, DImode),\t\\\n-                        UNITS_PER_WORD, BITS_PER_WORD, 1);\t\t\\\n-      assemble_integer (operand_subword ((VALUE), 1, 0, DImode),\t\\\n-                        UNITS_PER_WORD, BITS_PER_WORD, 1);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s\", DOUBLE_INT_ASM_OP);\t\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n-      putc ('\\n', FILE);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fputs (\"\\t.long \", FILE),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  putc ('\\n', FILE))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fputs (\"\\t.short \", FILE),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  putc ('\\n', FILE))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fputs (\"\\t.byte \", FILE),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  putc ('\\n', FILE))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (int)(VALUE))\n-\n-/* This is used by the definition of ASM_OUTPUT_ADDR_ELT in defaults.h.  */\n-#define ASM_LONG (TARGET_32BIT ? \".long\" : DOUBLE_INT_ASM_OP)\n-\n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\"}, {"sha": "e5abf8e9b139e5498c7d7af0dddf7a01c5660025", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -485,6 +485,12 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+extern int in_toc_section PARAMS ((void));\t\t\t\t\\\n+int in_toc_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  return in_section == in_toc;\t\t\t\t\t\t\\\n }\n \n #define\tSDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n@@ -788,59 +794,6 @@ extern int fixuplabelno;\n #define TARGET_ASM_CONSTRUCTOR  rs6000_elf_asm_out_constructor\n #define TARGET_ASM_DESTRUCTOR   rs6000_elf_asm_out_destructor\n \n-/* This is how to output an assembler line defining an `int' constant.\n-   For -mrelocatable, we mark all addresses that need to be fixed up\n-   in the .fixup section.  */\n-/* Override rs6000.h definition.  */\n-#undef\tASM_OUTPUT_INT\n-#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  static int recurse = 0;\t\t\t\t\t\t\\\n-  if (TARGET_RELOCATABLE\t\t\t\t\t\t\\\n-      && in_section != in_toc\t\t\t\t\t\t\\\n-      && in_section != in_text\t\t\t\t\t\t\\\n-      && !recurse\t\t\t\t\t\t\t\\\n-      && GET_CODE (VALUE) != CONST_INT\t\t\t\t\t\\\n-      && GET_CODE (VALUE) != CONST_DOUBLE\t\t\t\t\\\n-      && CONSTANT_P (VALUE))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      char buf[256];\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      recurse = 1;\t\t\t\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCP\", fixuplabelno);\t\t\\\n-      fixuplabelno++;\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL (FILE, buf);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long (\");\t\t\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n-      fprintf (FILE, \")@fixup\\n\");\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t\\\".fixup\\\",\\\"aw\\\"\\n\");\t\t\\\n-      ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long\\t\");\t\t\t\t\t\\\n-      assemble_name (FILE, buf);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\n\\t.previous\\n\");\t\t\t\t\\\n-      recurse = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  /* Remove initial .'s to turn a -mcall-aixdesc function\t\t\\\n-     address into the address of the descriptor, not the function\t\\\n-     itself.  */\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (VALUE) == SYMBOL_REF\t\t\t\t\\\n-\t   && XSTR (VALUE, 0)[0] == '.'\t\t\t\t\t\\\n-\t   && DEFAULT_ABI == ABI_AIX)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      const char *name = XSTR (VALUE, 0);\t\t\t\t\\\n-      while (*name == '.')\t\t\t\t\t\t\\\n-\tname++;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long %s\\n\", name);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long \");\t\t\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* This is the end of what might become sysv4.h.  */\n \n /* Use DWARF 2 debugging information by default.  */\n@@ -1497,3 +1450,6 @@ ncrtn.o%s\"\n #define TARGET_ASM_EXCEPTION_SECTION readonly_data_section\n \n #define DOUBLE_INT_ASM_OP \"\\t.quad\\t\"\n+\n+/* Generate entries in .fixup for relocatable addresses.  */\n+#define RELOCATABLE_NEEDS_FIXUP"}, {"sha": "095a5663ea845b679284c9985a9727df78cc21b1", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -472,17 +472,8 @@ toc_section ()\t\t\t\t\t\t\\\n /* This is how we tell the assembler that two symbols have the same value.  */\n #define SET_ASM_OP \"\\t.set \"\n \n-/* Used by definition of ASM_OUTPUT_DOUBLE_INT */\n-#define DOUBLE_INT_ASM_OP \"\\t.llong \"\n-\n-/* These are various definitions for DWARF output.  They could just\n-   use '.long' or '.word', but that aligns to a 4-byte boundary which\n-   is not what is required.  So we define a million macros...  */\n-\n-#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.vbyte\\t2,\"\n-#define UNALIGNED_INT_ASM_OP\t\t\"\\t.vbyte\\t4,\"\n-/* Only define if alignment greater than 4.  */\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t(TARGET_64BIT ? \"\\t.vbyte\\t8,\" : NULL)\n+/* Used by rs6000_assemble_integer, among others.  */\n+#define DOUBLE_INT_ASM_OP \"\\t.llong\\t\"\n \n /* Output before instructions.  */\n #define TEXT_SECTION_ASM_OP \"\\t.csect .text[PR]\""}, {"sha": "25bae58d475eb5e3b779993b62c4b4f9e5c04946", "filename": "gcc/config/s390/linux.h", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -76,9 +76,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Assembler pseudos to introduce constants of various size.  */\n \n-#define ASM_SHORT \"\\t.word\"\n-#define ASM_LONG \"\\t.long\"\n-#define ASM_QUAD \"\\t.quad\"\n #define ASM_DOUBLE \"\\t.double\"\n \n \n@@ -130,44 +127,6 @@ Boston, MA 02111-1307, USA.  */\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n \n-#define ASM_OUTPUT_DOUBLE_INT(FILE, VALUE)      \t\t\t\\\n-do { fprintf ((FILE), \"%s\\t\", ASM_QUAD);          \t\t\t\\\n-  /* Work around bug in some GNU as versions */\t\t\t\t\\\n-  if (GET_CODE (VALUE) == CONST_INT && INTVAL (VALUE) < INT_MIN)\t\\\n-    fprintf ((FILE), HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    output_addr_const ((FILE), (VALUE));            \t\t\t\\\n-  putc ('\\n', (FILE));                             \t\t\t\\\n- } while (0)\n-\n-\n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#undef ASM_OUTPUT_INT\n-#define ASM_OUTPUT_INT(FILE, VALUE)             \\\n-do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n-  output_addr_const (FILE, (VALUE));            \\\n-  putc ('\\n',FILE);                             \\\n- } while (0)\n-\n-/* Likewise for `char' and `short' constants. \n-   is this supposed to do align too?? */\n-\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)           \\\n-( fprintf (FILE, \"%s\\t\", ASM_SHORT),            \\\n-  output_addr_const (FILE, (VALUE)),            \\\n-  putc ('\\n',FILE))\n-\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)            \\\n-( fprintf (FILE, \"\\t%s\\t\", ASM_BYTE_OP),        \\\n-  output_addr_const (FILE, (VALUE)),            \\\n-  putc ('\\n', FILE))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf ((FILE), \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (int)(VALUE))\n-\n      /* internal macro to output long */\n #define _ASM_OUTPUT_LONG(FILE, VALUE)                                   \\\n       fprintf (FILE, \"\\t.long\\t0x%lX\\n\", VALUE);\n@@ -176,13 +135,13 @@ do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\\\n-  fprintf (FILE, \"%s\\t%s%d\\n\", TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n+  fprintf (FILE, \"%s%s%d\\n\", integer_asm_op (UNITS_PER_WORD, TRUE), \\\n \t   LPREFIX, VALUE)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n-  fprintf (FILE, \"%s\\t%s%d-%s%d\\n\", TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n+  fprintf (FILE, \"%s%s%d-%s%d\\n\", integer_asm_op (UNITS_PER_WORD, TRUE), \\\n \t   LPREFIX, VALUE, LPREFIX, REL)\n \n "}, {"sha": "83e02a8a845ba8ae2b872fed6224efbc9ff7e353", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -46,9 +46,17 @@ Boston, MA 02111-1307, USA.  */\n #include \"debug.h\"\n \n \n+static bool s390_assemble_integer PARAMS ((rtx, unsigned int, int));\n static int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int s390_adjust_priority PARAMS ((rtx, int));\n \n+#undef  TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+#undef  TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n+#undef  TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER s390_assemble_integer\n+\n #undef  TARGET_ASM_FUNCTION_PROLOGUE \n #define TARGET_ASM_FUNCTION_PROLOGUE s390_function_prologue\n \n@@ -1951,6 +1959,28 @@ print_operand (file, x, code)\n     }\n }\n \n+/* Target hook for assembling integer objects.  We need to define it\n+   here to work a round a bug in some versions of GAS, which couldn't\n+   handle values smaller than INT_MIN when printed in decimal.  */\n+\n+static bool\n+s390_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n+{\n+  if (size == 8 && aligned_p\n+      && GET_CODE (x) == CONST_INT && INTVAL (x) < INT_MIN)\n+    {\n+      fputs (\"\\t.quad\\t\", asm_out_file);\n+      fprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\n+      putc ('\\n', asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\n+\n #define DEBUG_SCHED 0\n \n /* Returns true if register REGNO is used  for forming "}, {"sha": "9b85fb4d0fb87846fabb544ff612f535680d3183", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1413,7 +1413,7 @@ extern int s390_nr_constants;\n \t      || GET_CODE (EXP) == SYMBOL_REF\t\t\t\t    \\\n \t      || GET_CODE (EXP) == LABEL_REF ))\t\t\t\t    \\\n         {\t\t\t\t\t\t\t\t    \\\n-          fprintf (FILE, \"%s\\t\",TARGET_64BIT ? ASM_QUAD : ASM_LONG);\t    \\\n+\t  fputs (integer_asm_op (UNITS_PER_WORD, TRUE), FILE);\t\t    \\\n           s390_output_symbolic_const (FILE, EXP);\t\t\t    \\\n           fputc ('\\n', (FILE));\t\t\t\t\t\t    \\\n \t}\t\t\t\t\t\t\t\t    \\"}, {"sha": "d08100d257eea5b6ec1b4c42f228b59aec3cb009", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -170,6 +170,12 @@ static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE sh_attribute_table\n \n+/* The next two are used for debug info when compiling with -gdwarf.  */\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.uaword\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.ualong\\t\"\n+\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE sh_output_function_epilogue\n "}, {"sha": "b2dd8f9bcc681a012e6329f6848ea6fca15ee1bb", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -2087,28 +2087,6 @@ do { char dstr[30];\t\t\t\t\t\\\n      fprintf ((FILE), \"\\t.float %s\\n\", dstr);\t\t\\\n    } while (0)\n \n-#define ASM_OUTPUT_INT(STREAM, EXP)\t\t\\\n-  (fprintf ((STREAM), \"\\t.long\\t\"),      \t\\\n-   output_addr_const ((STREAM), (EXP)),  \t\\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP)\t\\\n-  (fprintf ((STREAM), \"\\t.short\\t\"),\t\\\n-   output_addr_const ((STREAM), (EXP)),\t\\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP)\t\t\\\n-  (fprintf ((STREAM), \"\\t.byte\\t\"),      \t\\\n-   output_addr_const ((STREAM), (EXP)),  \t\\\n-   fputc ('\\n', (STREAM)))\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \t\\\n-  fprintf ((STREAM), \"\\t.byte\\t%d\\n\", (VALUE)) \t\\\n-\n-/* The next two are used for debug info when compiling with -gdwarf.  */\n-#define UNALIGNED_SHORT_ASM_OP\t\"\\t.uaword\\t\"\n-#define UNALIGNED_INT_ASM_OP\t\"\\t.ualong\\t\"\n-\n /* Loop alignment is now done in machine_dependent_reorg, so that\n    branch shortening can know about it.  */\n "}, {"sha": "613844654774b145a2ddce1bed9ad0adba2d20db", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -353,14 +353,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n   sprintf (LABEL, \"*.L%s%ld\", PREFIX, (long)(NUM))\n \n-/* Define the names of various pseudo-ops used by the Sparc/svr4 assembler.\n-   ??? If ints are 64 bits then UNALIGNED_INT_ASM_OP (defined elsewhere) is\n-   misnamed.  These should all refer to explicit sizes (half/word/xword?),\n-   anything other than short/int/long/etc.  */\n-\n-#undef  UNALIGNED_DOUBLE_INT_ASM_OP\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.uaxword\\t\"\n-\n /* DWARF bits.  */\n \n /* Follow Irix 6 and not the Dwarf2 draft in using 64-bit offsets. "}, {"sha": "82f7d32ab225ff2229ee38b9525b9fee4367de31", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -95,13 +95,6 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n   fprintf (FILE, \"\\t.skip %u\\n\", (SIZE))\n \n-/* Use .uahalf/.uaword so packed structure members don't generate\n-   assembler errors when using the native assembler.  */\n-#undef ASM_SHORT\n-#define ASM_SHORT \".uahalf\"\n-#undef ASM_LONG\n-#define ASM_LONG \".uaword\"\n-\n /* This is how to output a definition of an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.  */\n "}, {"sha": "3bd2a53f562fb3fe3edb47d021cefb1114b51db5", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -114,8 +114,3 @@ crtbegin.o%s \\\n \n #undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-\n-/* Define the names of various pseudo-ops used by the Sparc/svr4 assembler.  */\n-\n-#undef UNALIGNED_DOUBLE_INT_ASM_OP\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.uaxword\\t\""}, {"sha": "b0778eb85ef739ed0e556e482bfe98165e77c355", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -90,7 +90,6 @@ extern const char *output_return PARAMS ((rtx *));\n extern const char *output_sibcall PARAMS ((rtx, rtx));\n extern char *output_v9branch PARAMS ((rtx, int, int, int, int, int, rtx));\n extern void emit_v9_brxx_insn PARAMS ((enum rtx_code, rtx, rtx));\n-extern void output_double_int PARAMS ((FILE *, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern int mems_ok_for_ldd_peep PARAMS ((rtx, rtx));\n extern int arith_double_4096_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "d93f57c92c24fb0fce30fe77c28fd59c8c779427", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -151,6 +151,7 @@ static void sparc_add_gc_roots    PARAMS ((void));\n static void mark_ultrasparc_pipeline_state PARAMS ((void *));\n static int check_return_regs PARAMS ((rtx));\n static int epilogue_renumber PARAMS ((rtx *, int));\n+static bool sparc_assemble_integer PARAMS ((rtx, unsigned int, int));\n static int ultra_cmove_results_ready_p PARAMS ((rtx));\n static int ultra_fpmode_conflict_exists PARAMS ((enum machine_mode));\n static rtx *ultra_find_type PARAMS ((int, rtx *, int));\n@@ -202,6 +203,27 @@ struct sparc_cpu_select sparc_select[] =\n enum processor_type sparc_cpu;\n \f\n /* Initialize the GCC target structure.  */\n+\n+/* The sparc default is to use .half rather than .short for aligned\n+   HI objects.  Use .word instead of .long on non-ELF systems.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n+#ifndef OBJECT_FORMAT_ELF\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+#endif\n+\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.uahalf\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.uaword\\t\"\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.uaxword\\t\"\n+\n+/* The target hook has to handle DI-mode values.  */\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER sparc_assemble_integer\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE sparc_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -401,6 +423,10 @@ sparc_override_options ()\n   if (flag_pcc_struct_return == DEFAULT_PCC_STRUCT_RETURN)\n     flag_pcc_struct_return = (TARGET_ARCH64 ? 0 : 1);\n \n+  /* Only use .uaxword when compiling for a 64-bit target.  */\n+  if (!TARGET_ARCH64)\n+    targetm.asm_out.unaligned_op.di = NULL;\n+\n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n \n@@ -6008,65 +6034,33 @@ print_operand (file, x, code)\n   else { output_addr_const (file, x); }\n }\n \f\n-/* This function outputs assembler code for VALUE to FILE, where VALUE is\n-   a 64 bit (DImode) value.  */\n+/* Target hook for assembling integer objects.  The sparc version has\n+   special handling for aligned DI-mode objects.  */\n \n-/* ??? If there is a 64 bit counterpart to .word that the assembler\n-   understands, then using that would simply this code greatly.  */\n-/* ??? We only output .xword's for symbols and only then in environments\n-   where the assembler can handle them.  */\n-\n-void\n-output_double_int (file, value)\n-     FILE *file;\n-     rtx value;\n+static bool\n+sparc_assemble_integer (x, size, aligned_p)\n+     rtx x;\n+     unsigned int size;\n+     int aligned_p;\n {\n-  if (GET_CODE (value) == CONST_INT)\n-    {\n-      /* ??? This has endianness issues.  */\n-#if HOST_BITS_PER_WIDE_INT == 64\n-      HOST_WIDE_INT xword = INTVAL (value);\n-      HOST_WIDE_INT high, low;\n-\n-      high = (xword >> 32) & 0xffffffff;\n-      low  = xword & 0xffffffff;\n-      ASM_OUTPUT_INT (file, GEN_INT (high));\n-      ASM_OUTPUT_INT (file, GEN_INT (low));\n-#else\n-      if (INTVAL (value) < 0)\n-\tASM_OUTPUT_INT (file, constm1_rtx);\n-      else\n-\tASM_OUTPUT_INT (file, const0_rtx);\n-      ASM_OUTPUT_INT (file, value);\n-#endif\n-    }\n-  else if (GET_CODE (value) == CONST_DOUBLE)\n+  /* ??? We only output .xword's for symbols and only then in environments\n+     where the assembler can handle them.  */\n+  if (aligned_p && size == 8\n+      && (GET_CODE (x) != CONST_INT && GET_CODE (x) != CONST_DOUBLE))\n     {\n-      ASM_OUTPUT_INT (file, GEN_INT (CONST_DOUBLE_HIGH (value)));\n-      ASM_OUTPUT_INT (file, GEN_INT (CONST_DOUBLE_LOW (value)));\n-    }\n-  else if (GET_CODE (value) == SYMBOL_REF\n-\t   || GET_CODE (value) == CONST\n-\t   || GET_CODE (value) == PLUS\n-\t   || (TARGET_ARCH64 &&\n-\t       (GET_CODE (value) == LABEL_REF\n-\t\t|| GET_CODE (value) == CODE_LABEL\n-\t\t|| GET_CODE (value) == MINUS)))\n-    {\n-      if (! TARGET_V9)\n+      if (TARGET_V9)\n \t{\n-\t  ASM_OUTPUT_INT (file, const0_rtx);\n-\t  ASM_OUTPUT_INT (file, value);\n+\t  assemble_integer_with_op (\"\\t.xword\\t\", x);\n+\t  return true;\n \t}\n       else\n \t{\n-\t  fprintf (file, \"\\t%s\\t\", ASM_LONGLONG);\n-\t  output_addr_const (file, value);\n-\t  fprintf (file, \"\\n\");\n+\t  assemble_aligned_integer (4, const0_rtx);\n+\t  assemble_aligned_integer (4, x);\n+\t  return true;\n \t}\n     }\n-  else\n-    abort ();\n+  return default_assemble_integer (x, size, aligned_p);\n }\n \f\n /* Return the value of a code used in the .proc pseudo-op that says"}, {"sha": "358027537465065dd7f652a1c2c11e964991952d", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -2652,10 +2652,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* ??? Try to make the style consistent here (_OP?).  */\n \n-#define ASM_LONGLONG\t\".xword\"\n-#define ASM_LONG\t\".word\"\n-#define ASM_SHORT\t\".half\"\n-#define ASM_BYTE_OP\t\"\\t.byte\\t\"\n #define ASM_FLOAT\t\".single\"\n #define ASM_DOUBLE\t\".double\"\n #define ASM_LONGDOUBLE\t\".xxx\"\t\t/* ??? Not known (or used yet).  */\n@@ -2732,7 +2728,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n     char str[30];\t\t\t\t\t\t\\\n     REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", ASM_LONG, t,\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\",\t\t\t\\\n+\t     integer_asm_op (4, TRUE), t,\t\t\t\\\n \t     ASM_COMMENT_START, str);\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n \n@@ -2745,11 +2742,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     long t[2];\t\t\t\t\t\t\t\\\n     char str[30];\t\t\t\t\t\t\\\n+    const char *long_op = integer_asm_op (4, TRUE);\t\t\\\n     REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", ASM_LONG, t[0],\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", long_op, t[0],\t\\\n \t     ASM_COMMENT_START, str);\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[1]);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", long_op, t[1]);\t\t\\\n   }\n \n /* This is how to output an assembler line defining a `long double'\n@@ -2759,43 +2757,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     long t[4];\t\t\t\t\t\t\t\\\n     char str[30];\t\t\t\t\t\t\\\n+    const char *long_op = integer_asm_op (4, TRUE);\t\t\\\n     REAL_VALUE_TO_TARGET_LONG_DOUBLE ((VALUE), t);\t\t\\\n     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", ASM_LONG, t[0],\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx %s ~%s\\n\", long_op, t[0],\t\\\n \t     ASM_COMMENT_START, str);\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[1]);\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[2]);\t\t\\\n-    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", ASM_LONG, t[3]);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", long_op, t[1]);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", long_op, t[2]);\t\t\\\n+    fprintf (FILE, \"\\t%s\\t0x%lx\\n\", long_op, t[3]);\t\t\\\n   }\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t%s\\t\", ASM_LONG),\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line defining a DImode constant.  */\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n-  output_double_int (FILE, VALUE)\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t%s\\t\", ASM_SHORT),\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s\", ASM_BYTE_OP),\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"%s0x%x\\n\", ASM_BYTE_OP, (int)(VALUE))\n-\n /* This is how we hook in and defer the case-vector until the end of\n    the function.  */\n #define ASM_OUTPUT_ADDR_VEC(LAB,VEC) \\"}, {"sha": "7f4f7dbbc803edfffc56eee157670047072160e7", "filename": "gcc/config/sparc/sun4gas.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsun4gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsun4gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsun4gas.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -18,10 +18,5 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* gas supports unaligned data.  */\n-#define UNALIGNED_DOUBLE_INT_ASM_OP \"\\t.uaxword\\t\"\n-#define UNALIGNED_INT_ASM_OP\t\"\\t.uaword\\t\"\n-#define UNALIGNED_SHORT_ASM_OP\t\"\\t.uahalf\\t\"\n-\n /* defaults.h will define DWARF2_UNWIND_INFO for us.  */\n #undef DWARF2_UNWIND_INFO"}, {"sha": "a4c7f915c2e9985a372c77f2c5e65f8591eeaf7d", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -87,16 +87,9 @@ Boston, MA 02111-1307, USA.  */\n #define STRING_ASM_OP\t\t\"\\t.asciz\\t\"\n #define COMMON_ASM_OP\t\t\"\\t.common\\t\"\n #define SKIP_ASM_OP\t\t\"\\t.skip\\t\"\n-#define UNALIGNED_DOUBLE_INT_ASM_OP (TARGET_ARCH64 ? \"\\t.uaxword\\t\" : NULL)\n-#define UNALIGNED_INT_ASM_OP\t\"\\t.uaword\\t\"\n-#define UNALIGNED_SHORT_ASM_OP\t\"\\t.uahalf\\t\"\n #define PUSHSECTION_ASM_OP\t\"\\t.pushsection\\t\"\n #define POPSECTION_ASM_OP\t\"\\t.popsection\"\n \n-/* This is defined in sparc.h but is not used by svr4.h.  */\n-#undef ASM_LONG\n-#define ASM_LONG \".long\"\n-\n /* This is the format used to print the second operand of a .type pseudo-op\n    for the Sparc/svr4 assembler.  */\n "}, {"sha": "a8906c63828b936cd3a0705833041a518133b37e", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -2003,4 +2003,9 @@ xstormy16_handle_interrupt_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \f\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "4f71d53e66ee209a42c348c56da468f6c5dc7013", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -3571,57 +3571,6 @@ do { char dstr[30];                                     \\\n /* #define ASM_OUTPUT_SHORT_FLOAT(STREAM, VALUE) */\n /* #define ASM_OUTPUT_BYTE_FLOAT(STREAM, VALUE) */\n \n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble an integer of 16, 8, 4, 2 or 1 bytes, respectively, whose value\n-   is VALUE.  The argument EXP will be an RTL expression which represents a\n-   constant value.  Use `output_addr_const (STREAM, EXP)' to output this value\n-   as an assembler expression.\n-\n-   For sizes larger than `UNITS_PER_WORD', if the action of a macro would be\n-   identical to repeatedly calling the macro corresponding to a size of\n-   `UNITS_PER_WORD', once for each word, you need not define the macro.  */\n-/* #define ASM_OUTPUT_QUADRUPLE_INT(STREAM, EXP) */\n-/* #define ASM_OUTPUT_DOUBLE_INT(STREAM, EXP) */\n-\n-/* This is how to output an assembler line defining a `char' constant.  */\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.byte\\t\");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an assembler line defining a `short' constant.  */\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.hword\\t\");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an assembler line defining an `int' constant.\n-   We also handle symbol output here.  */\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble a single byte containing the number VALUE.\n-\n-   This declaration must be present.  */\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n-  fprintf (STREAM, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n-\n-/* A C string constant giving the pseudo-op to use for a sequence of\n-   single-byte constants.  If this macro is not defined, the default\n-   is `\"byte\"'.\n-\n-   Defined in svr4.h.  */\n-/* #define ASM_BYTE_OP */\n-\n /* A C statement to output to the stdio stream STREAM an assembler instruction\n    to assemble a string constant containing the LEN bytes at PTR.  PTR will be\n    a C expression of type `char *' and LEN a C expression of type `int'.\n@@ -4397,8 +4346,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Define this macro to 0 if your target supports DWARF 2 frame unwind\n    information, but it does not yet work with exception handling.  Otherwise,\n    if your target supports this information (if it defines\n-   `INCOMING_RETURN_ADDR_RTX' and either `UNALIGNED_INT_ASM_OP' or\n-   `OBJECT_FORMAT_ELF'), GCC will provide a default definition of 1.\n+   `INCOMING_RETURN_ADDR_RTX'), GCC will provide a default definition of 1.\n \n    If this macro is defined to 1, the DWARF 2 unwinder will be the default\n    exception handling mechanism; otherwise, setjmp/longjmp will be used by"}, {"sha": "4de6f52670c866bc0bfc7a7e56b7f3b1ce4ef9e6", "filename": "gcc/config/svr3.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsvr3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fsvr3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr3.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -154,12 +154,6 @@ Boston, MA 02111-1307, USA.\n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE BITS_PER_WORD\n \n-/* Assembler pseudos to introduce constants of various size.  These\n-   definitions should work for most svr3 systems.  */\n-\n-#undef ASM_BYTE_OP\n-#define ASM_BYTE_OP \"\\t.byte\\t\"\n-\n /* The prefix to add to user-visible assembler symbols.\n \n    For System V Release 3 the convention is to prepend a leading"}, {"sha": "3c9ac92e23bbfaa21bb5a0202436321202ea7902", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -87,6 +87,9 @@ static int v850_interrupt_cache_p = FALSE;\n static int v850_interrupt_p = FALSE;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE v850_attribute_table\n "}, {"sha": "cb3d1459f512857d27a777bb3aa94974124757a1", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1246,7 +1246,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef  USER_LABEL_PREFIX\n #define USER_LABEL_PREFIX \"_\"\n \n-/* When ASM_OUTPUT_SHORT is used to emit the offsets for a switch\n+/* When assemble_integer is used to emit the offsets for a switch\n    table it can encounter (TRUNCATE:HI (MINUS:SI (LABEL_REF:SI) (LABEL_REF:SI))).\n    output_addr_const will normally barf at this, but it is OK to omit\n    the truncate and just emit the difference of the two labels.  The\n@@ -1275,29 +1275,6 @@ do { char dstr[30];\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n    } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This says how to output the assembler to define a global\n    uninitialized but not common symbol.  */\n "}, {"sha": "ccaee768bb07a97d37b10ac01a274ce1039fa75d", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -45,6 +45,9 @@ static void vms_asm_out_destructor PARAMS ((rtx, int));\n #endif\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE vax_output_function_prologue\n "}, {"sha": "7d0608e46cfbf58d30f90d4732238c4b63790b47", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -504,14 +504,14 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n      movl $STATIC,r0   (store the functions static chain)\n      jmp  *$FUNCTION   (jump to function code at address FUNCTION)  */\n \n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x8fd0));\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n-  ASM_OUTPUT_BYTE  (FILE, 0x50 + STATIC_CHAIN_REGNUM);\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x9f17));\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x8fd0));\t\t\t\\\n+  assemble_aligned_integer (4, const0_rtx);\t\t\t\t\\\n+  assemble_aligned_integer (1, GEN_INT (0x50 + STATIC_CHAIN_REGNUM));\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x9f17));\t\t\t\\\n+  assemble_aligned_integer (4, const0_rtx);\t\t\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -1123,30 +1123,6 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n        REAL_VALUE_TO_DECIMAL (VALUE, \"%.20e\", dstr);\t\t\\\n        fprintf (FILE, \"\\t.float 0f%s\\n\", dstr); } while (0);\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n "}, {"sha": "5813b2a44bb5b2fde616f03dc789bdc210109c2f", "filename": "gcc/config/we32k/we32k.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -40,6 +40,11 @@ static void we32k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void we32k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE we32k_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "0cc12caf20efa4ca86309767e15d8844330e1e39", "filename": "gcc/config/we32k/we32k.h", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -439,15 +439,15 @@ enum reg_class { NO_REGS, GENERAL_REGS,\n      mov #STATIC,%r8\n      jmp #FUNCTION */\n \n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n-{\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x844f));\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n-  ASM_OUTPUT_CHAR  (FILE, GEN_INT (0x48));\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x247f));\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x844f));\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\\\n+  assemble_aligned_integer (1, GEN_INT (0x48));\t\t\\\n+  assemble_aligned_integer (2, GEN_INT (0x247f));\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\\\n+  assemble_aligned_integer (2, const0_rtx);\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -755,10 +755,6 @@ enum reg_class { NO_REGS, GENERAL_REGS,\n     ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\\\n   } while (0)\n \n-/* Assembler pseudo to introduce byte constants.  */\n-\n-#define ASM_BYTE_OP \"\\t.byte\\t\"\n-\n /* This is how to output an assembler line defining a `double' constant.  */\n \n /* This is how to output an assembler line defining a `float' constant.  */\n@@ -790,30 +786,6 @@ do { union { float f; long l;} tem;\t\t\t\t\\\n \n #endif /* not CROSS_COMPILE */\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.half \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n #define ASM_OUTPUT_ASCII(FILE,PTR,LEN)  \\\n do {\t\t\t\t\t\t\t\\\n   const unsigned char *s;\t\t\t\t\\"}, {"sha": "91962d4ea803e30fc87c4524925bdcefd806d781", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -62,7 +62,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #ifndef ASM_OUTPUT_ADDR_VEC_ELT\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-do { fprintf (FILE, \"\\t%s\\t\", ASM_LONG);\t\t\t\t\\\n+do { fputs (integer_asm_op (POINTER_SIZE / UNITS_PER_WORD, TRUE), FILE); \\\n      ASM_OUTPUT_INTERNAL_LABEL (FILE, \"L\", (VALUE));\t\t\t\\\n      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n    } while (0)\n@@ -400,23 +400,6 @@ do {\t\t\t\t\t\t\t\t\\\n #define TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER true\n #endif\n \n-/* GAS and SYSV4 assemblers accept these.  */\n-#if defined (OBJECT_FORMAT_ELF) || defined (OBJECT_FORMAT_ROSE)\n-#ifndef UNALIGNED_SHORT_ASM_OP\n-#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.2byte\\t\"\n-#endif\n-#ifndef UNALIGNED_INT_ASM_OP\n-#define UNALIGNED_INT_ASM_OP\t\t\"\\t.4byte\\t\"\n-#endif\n-#ifndef UNALIGNED_DOUBLE_INT_ASM_OP\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.8byte\\t\"\n-#endif\n-#endif /* OBJECT_FORMAT_ELF || OBJECT_FORMAT_ROSE */\n-\n-#ifndef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\t\t\"\\t.byte\\t\"\n-#endif\n-\n #ifndef DEFAULT_GDB_EXTENSIONS\n #define DEFAULT_GDB_EXTENSIONS 1\n #endif"}, {"sha": "da3b4d543dc12dad8a4911a550a5999c3718cf08", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -5810,8 +5810,39 @@ set via @code{__attribute__}.\n @node Data Output\n @subsection Output of Data\n \n-@c prevent bad page break with this line\n-This describes data output.\n+\n+@deftypevr {Target Hook} {const char *} TARGET_ASM_BYTE_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_HI_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_SI_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_DI_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_TI_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_HI_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_SI_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_DI_OP\n+@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_TI_OP\n+These hooks specify assembly directives for creating certain kinds\n+of integer object.  The @code{TARGET_ASM_BYTE_OP} directive creates a\n+byte-sized object, the @code{TARGET_ASM_ALIGNED_HI_OP} one creates an\n+aligned two-byte object, and so on.  Any of the hooks may be\n+@code{NULL}, indicating that no suitable directive is available.\n+\n+The compiler will print these strings at the start of a new line,\n+followed immediately by the object's initial value.  In most cases,\n+the string should contain a tab, a pseudo-op, and then another tab.\n+@end deftypevr\n+\n+@deftypefn {Target Hook} bool TARGET_ASM_INTEGER (rtx @var{x}, unsigned int @var{size}, int @var{aligned_p})\n+The @code{assemble_integer} function uses this hook to output an\n+integer object.  @var{x} is the object's value, @var{size} is its size\n+in bytes and @var{aligned_p} indicates whether it is aligned.  The\n+function should return @code{true} if it was able to output the\n+object.  If it returns false, @code{assemble_integer} will try to\n+split the object into smaller parts.\n+\n+The default implementation of this hook will use the\n+@code{TARGET_ASM_BYTE_OP} family of strings, returning @code{false}\n+when the relevant string is @code{NULL}.\n+@end deftypefn\n \n @table @code\n @findex ASM_OUTPUT_LONG_DOUBLE\n@@ -5831,29 +5862,6 @@ will be a C expression of type @code{REAL_VALUE_TYPE}.  Macros such as\n @code{REAL_VALUE_TO_TARGET_DOUBLE} are useful for writing these\n definitions.\n \n-@findex ASM_OUTPUT_QUADRUPLE_INT\n-@findex ASM_OUTPUT_DOUBLE_INT\n-@findex ASM_OUTPUT_INT\n-@findex ASM_OUTPUT_SHORT\n-@findex ASM_OUTPUT_CHAR\n-@findex output_addr_const\n-@item ASM_OUTPUT_QUADRUPLE_INT (@var{stream}, @var{exp})\n-@itemx ASM_OUTPUT_DOUBLE_INT (@var{stream}, @var{exp})\n-@itemx ASM_OUTPUT_INT (@var{stream}, @var{exp})\n-@itemx ASM_OUTPUT_SHORT (@var{stream}, @var{exp})\n-@itemx ASM_OUTPUT_CHAR (@var{stream}, @var{exp})\n-A C statement to output to the stdio stream @var{stream} an assembler\n-instruction to assemble an integer of 16, 8, 4, 2 or 1 bytes,\n-respectively, whose value is @var{value}.  The argument @var{exp} will\n-be an RTL expression which represents a constant value.  Use\n-@samp{output_addr_const (@var{stream}, @var{exp})} to output this value\n-as an assembler expression.\n-\n-For sizes larger than @code{UNITS_PER_WORD}, if the action of a macro\n-would be identical to repeatedly calling the macro corresponding to\n-a size of @code{UNITS_PER_WORD}, once for each word, you need not define\n-the macro.\n-\n @findex OUTPUT_ADDR_CONST_EXTRA\n @item OUTPUT_ADDR_CONST_EXTRA (@var{stream}, @var{x}, @var{fail})\n A C statement to recognize @var{rtx} patterns that\n@@ -5866,29 +5874,6 @@ If @code{OUTPUT_ADDR_CONST_EXTRA} fails to recognize a pattern, it must\n prints an error message itself, by calling, for example,\n @code{output_operand_lossage}, it may just complete normally.\n \n-@findex ASM_OUTPUT_BYTE\n-@item ASM_OUTPUT_BYTE (@var{stream}, @var{value})\n-A C statement to output to the stdio stream @var{stream} an assembler\n-instruction to assemble a single byte containing the number @var{value}.\n-\n-@findex ASM_BYTE_OP\n-@item ASM_BYTE_OP\n-A C string constant, including spacing, giving the pseudo-op to use for a\n-sequence of single-byte constants.  If this macro is not defined, the\n-default is @code{\"\\t.byte\\t\"}.\n-\n-@findex UNALIGNED_SHORT_ASM_OP\n-@findex UNALIGNED_INT_ASM_OP\n-@findex UNALIGNED_DOUBLE_INT_ASM_OP\n-@item UNALIGNED_SHORT_ASM_OP\n-@itemx UNALIGNED_INT_ASM_OP\n-@itemx UNALIGNED_DOUBLE_INT_ASM_OP\n-A C string constant, including spacing, giving the pseudo-op to use\n-to assemble 16-, 32-, and 64-bit integers respectively @emph{without}\n-adding implicit padding or alignment.  These macros are required if\n-DWARF 2 frame unwind is used.  On ELF systems, these will default\n-to @code{.2byte}, @code{.4byte}, and @code{.8byte}.\n-\n @findex ASM_OUTPUT_ASCII\n @item ASM_OUTPUT_ASCII (@var{stream}, @var{ptr}, @var{len})\n A C statement to output to the stdio stream @var{stream} an assembler"}, {"sha": "f2cc3c1e947a453a5bd213b31e0f56e12d3a4907", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 55, "deletions": 103, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"output.h\"\n+#include \"target.h\"\n #include \"dwarf2asm.h\"\n #include \"dwarf2.h\"\n #include \"splay-tree.h\"\n@@ -37,50 +38,29 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define ASM_COMMENT_START \";#\"\n #endif\n \n-/* We don't have unaligned support, let's hope the normal output works for\n-   .debug_frame.  But we know it won't work for .debug_info.  */\n-#if !defined(UNALIGNED_INT_ASM_OP) && defined(DWARF2_DEBUGGING_INFO)\n- #error DWARF2_DEBUGGING_INFO requires UNALIGNED_INT_ASM_OP.\n-#endif\n-\n \f\n-/* Despite the fact that assemble_integer handles unaligned data,\n-   continue emitting things by hand when possible, since that makes\n-   the assembler commentary come out prettier.  */\n-#ifdef UNALIGNED_INT_ASM_OP\n-static const char * unaligned_integer_asm_op  PARAMS ((int));\n-\n-static inline const char *\n-unaligned_integer_asm_op (size)\n+/* Output an unaligned integer with the given value and size.  Prefer not\n+   to print a newline, since the caller may want to add a comment.  */\n+\n+void\n+dw2_assemble_integer (size, x)\n      int size;\n+     rtx x;\n {\n-  const char *op = NULL;\n-  switch (size)\n+  const char *op = integer_asm_op (size, FALSE);\n+\n+  if (op)\n     {\n-    case 1:\n-      op = ASM_BYTE_OP;\n-      break;\n-    case 2:\n-      op = UNALIGNED_SHORT_ASM_OP;\n-      break;\n-    case 4:\n-      op = UNALIGNED_INT_ASM_OP;\n-      break;\n-    case 8:\n-#ifdef UNALIGNED_DOUBLE_INT_ASM_OP\n-      op = UNALIGNED_DOUBLE_INT_ASM_OP;\n-      break;\n-#endif\n-    default:\n-      abort ();\n+      fputs (op, asm_out_file);\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\n+      else\n+\toutput_addr_const (asm_out_file, x);\n     }\n-\n-  if (! op)\n-    abort ();\n-\n-  return op;\n+  else\n+    assemble_integer (x, size, BITS_PER_UNIT, 1);\n }\n-#endif /* UNALIGNED_INT_ASM_OP */\n+     \n \n /* Output an immediate constant in a given size.  */\n \n@@ -96,12 +76,7 @@ dw2_asm_output_data VPARAMS ((int size, unsigned HOST_WIDE_INT value,\n   if (size * 8 < HOST_BITS_PER_WIDE_INT)\n     value &= ~(~(unsigned HOST_WIDE_INT)0 << (size * 8));\n \n-#ifdef UNALIGNED_INT_ASM_OP\n-  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX, value);\n-#else\n-  assemble_integer (GEN_INT (value), size, BITS_PER_UNIT, 1);\n-#endif\n+  dw2_assemble_integer (size, GEN_INT (value));\n \n   if (flag_debug_asm && comment)\n     {\n@@ -129,16 +104,10 @@ dw2_asm_output_delta VPARAMS ((int size, const char *lab1, const char *lab2,\n   VA_FIXEDARG (ap, const char *, lab2);\n   VA_FIXEDARG (ap, const char *, comment);\n \n-#ifdef UNALIGNED_INT_ASM_OP\n-  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-  assemble_name (asm_out_file, lab1);\n-  fputc ('-', asm_out_file);\n-  assemble_name (asm_out_file, lab2);\n-#else\n-  assemble_integer (gen_rtx_MINUS (Pmode, gen_rtx_SYMBOL_REF (Pmode, lab1),\n-\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, lab2)),\n-\t\t    size, BITS_PER_UNIT, 1);\n-#endif\n+  dw2_assemble_integer (size,\n+\t\t\tgen_rtx_MINUS (Pmode,\n+\t\t\t\t       gen_rtx_SYMBOL_REF (Pmode, lab1),\n+\t\t\t\t       gen_rtx_SYMBOL_REF (Pmode, lab2)));\n \n   if (flag_debug_asm && comment)\n     {\n@@ -168,12 +137,7 @@ dw2_asm_output_offset VPARAMS ((int size, const char *label,\n #ifdef ASM_OUTPUT_DWARF_OFFSET\n   ASM_OUTPUT_DWARF_OFFSET (asm_out_file, size, label);\n #else\n-#ifdef UNALIGNED_INT_ASM_OP\n-  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-  assemble_name (asm_out_file, label);\n-#else\n-  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, label), size, BITS_PER_UNIT, 1);\n-#endif\n+  dw2_assemble_integer (size, gen_rtx_SYMBOL_REF (Pmode, label));\n #endif\n \n   if (flag_debug_asm && comment)\n@@ -202,14 +166,10 @@ dw2_asm_output_pcrel VPARAMS ((int size ATTRIBUTE_UNUSED,\n #ifdef ASM_OUTPUT_DWARF_PCREL\n   ASM_OUTPUT_DWARF_PCREL (asm_out_file, size, label);\n #else\n-#ifdef UNALIGNED_INT_ASM_OP\n-  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-  assemble_name (asm_out_file, label);\n-  fputc ('-', asm_out_file);\n-  fputc ('.', asm_out_file);\n-#else\n-  abort ();\n-#endif\n+  dw2_assemble_integer (size,\n+\t\t\tgen_rtx_MINUS (Pmode,\n+\t\t\t\t       gen_rtx_SYMBOL_REF (Pmode, label),\n+\t\t\t\t       pc_rtx));\n #endif\n \n   if (flag_debug_asm && comment)\n@@ -233,12 +193,7 @@ dw2_asm_output_addr VPARAMS ((int size, const char *label,\n   VA_FIXEDARG (ap, const char *, label);\n   VA_FIXEDARG (ap, const char *, comment);\n \n-#ifdef UNALIGNED_INT_ASM_OP\n-  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-  assemble_name (asm_out_file, label);\n-#else\n-  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, label), size, BITS_PER_UNIT, 1);\n-#endif\n+  dw2_assemble_integer (size, gen_rtx_SYMBOL_REF (Pmode, label));\n \n   if (flag_debug_asm && comment)\n     {\n@@ -261,12 +216,7 @@ dw2_asm_output_addr_rtx VPARAMS ((int size, rtx addr,\n   VA_FIXEDARG (ap, rtx, addr);\n   VA_FIXEDARG (ap, const char *, comment);\n \n-#ifdef UNALIGNED_INT_ASM_OP\n-  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-  output_addr_const (asm_out_file, addr);\n-#else\n-  assemble_integer (addr, size, BITS_PER_UNIT, 1);\n-#endif\n+  dw2_assemble_integer (size, addr);\n \n   if (flag_debug_asm && comment)\n     {\n@@ -319,7 +269,7 @@ dw2_asm_output_nstring VPARAMS ((const char *str, size_t orig_len,\n \tlen += 1;\n       ASM_OUTPUT_ASCII (asm_out_file, str, len);\n       if (orig_len != (size_t) -1)\n-\tfprintf (asm_out_file, \"%s0\\n\", ASM_BYTE_OP);\n+\tassemble_integer (const0_rtx, 1, BITS_PER_UNIT, 1);\n     }\n \n   VA_CLOSE (ap);\n@@ -571,8 +521,10 @@ dw2_asm_output_data_uleb128 VPARAMS ((unsigned HOST_WIDE_INT value,\n #else\n   {\n     unsigned HOST_WIDE_INT work = value;\n+    const char *byte_op = targetm.asm_out.byte_op;\n \n-    fputs (ASM_BYTE_OP, asm_out_file);\n+    if (byte_op)\n+      fputs (byte_op, asm_out_file);\n     do\n       {\n \tint byte = (work & 0x7f);\n@@ -581,9 +533,14 @@ dw2_asm_output_data_uleb128 VPARAMS ((unsigned HOST_WIDE_INT value,\n \t  /* More bytes to follow.  */\n \t  byte |= 0x80;\n \n-\tfprintf (asm_out_file, \"0x%x\", byte);\n-\tif (work != 0)\n-\t  fputc (',', asm_out_file);\n+\tif (byte_op)\n+\t  {\n+\t    fprintf (asm_out_file, \"0x%x\", byte);\n+\t    if (work != 0)\n+\t      fputc (',', asm_out_file);\n+\t  }\n+\telse\n+\t  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);\n       }\n     while (work != 0);\n \n@@ -627,8 +584,10 @@ dw2_asm_output_data_sleb128 VPARAMS ((HOST_WIDE_INT value,\n   {\n     HOST_WIDE_INT work = value;\n     int more, byte;\n+    const char *byte_op = targetm.asm_out.byte_op;\n \n-    fputs (ASM_BYTE_OP, asm_out_file);\n+    if (byte_op)\n+      fputs (byte_op, asm_out_file);\n     do\n       {\n \tbyte = (work & 0x7f);\n@@ -639,9 +598,14 @@ dw2_asm_output_data_sleb128 VPARAMS ((HOST_WIDE_INT value,\n \tif (more)\n \t  byte |= 0x80;\n \n-\tfprintf (asm_out_file, \"0x%x\", byte);\n-\tif (more)\n-\t  fputc (',', asm_out_file);\n+\tif (byte_op)\n+\t  {\n+\t    fprintf (asm_out_file, \"0x%x\", byte);\n+\t    if (more)\n+\t      fputc (',', asm_out_file);\n+\t  }\n+\telse\n+\t  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);\n       }\n     while (more);\n \n@@ -905,12 +869,7 @@ dw2_asm_output_encoded_addr_rtx VPARAMS ((int encoding,\n       switch (encoding & 0xF0)\n \t{\n \tcase DW_EH_PE_absptr:\n-#ifdef UNALIGNED_INT_ASM_OP\n-\t  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-\t  output_addr_const (asm_out_file, addr);\n-#else\n-\t  assemble_integer (addr, size, BITS_PER_UNIT, 1);\n-#endif\n+\t  dw2_assemble_integer (size, addr);\n \t  break;\n \n \tcase DW_EH_PE_pcrel:\n@@ -919,14 +878,7 @@ dw2_asm_output_encoded_addr_rtx VPARAMS ((int encoding,\n #ifdef ASM_OUTPUT_DWARF_PCREL\n \t  ASM_OUTPUT_DWARF_PCREL (asm_out_file, size, XSTR (addr, 0));\n #else\n-#ifdef UNALIGNED_INT_ASM_OP\n-\t  fputs (unaligned_integer_asm_op (size), asm_out_file);\n-\t  assemble_name (asm_out_file, XSTR (addr, 0));\n-\t  fputc ('-', asm_out_file);\n-\t  fputc ('.', asm_out_file);\n-#else\n-\t  abort ();\n-#endif\n+\t  dw2_assemble_integer (size, gen_rtx_MINUS (Pmode, addr, pc_rtx));\n #endif\n \t  break;\n "}, {"sha": "859883d45e3492f0193b839d265960311cb6bfb9", "filename": "gcc/dwarf2asm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -23,6 +23,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the way these routines are signaled that there is no associated\n    debug information.  So the attributes are commented out.  */\n \n+extern void dw2_assemble_integer\tPARAMS ((int, rtx));\n+\n extern void dw2_asm_output_data\t\tPARAMS ((int, unsigned HOST_WIDE_INT,\n \t\t\t\t\t\t const char *, ...))\n      /* ATTRIBUTE_PRINTF_3 */;"}, {"sha": "0ff75f585f7492cb47f8c3b70fe7074e0ccd037e", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 40, "deletions": 125, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -574,6 +574,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"insn-config.h\"\n #include \"reload.h\"\n #include \"output.h\"\n+#include \"dwarf2asm.h\"\n #include \"toplev.h\"\n #include \"tm_p.h\"\n #include \"debug.h\"\n@@ -928,7 +929,8 @@ static void shuffle_filename_entry\tPARAMS ((filename_entry *));\n static void generate_new_sfname_entry\tPARAMS ((void));\n static unsigned lookup_filename\t\tPARAMS ((const char *));\n static void generate_srcinfo_entry\tPARAMS ((unsigned, unsigned));\n-static void generate_macinfo_entry\tPARAMS ((const char *, const char *));\n+static void generate_macinfo_entry\tPARAMS ((unsigned int, rtx,\n+\t\t\t\t\t\t const char *));\n static int is_pseudo_reg\t\tPARAMS ((rtx));\n static tree type_main_variant\t\tPARAMS ((tree));\n static int is_tagged_type\t\tPARAMS ((tree));\n@@ -1207,147 +1209,77 @@ static void retry_incomplete_types\tPARAMS ((void));\n \n #ifndef ASM_OUTPUT_DWARF_DELTA2\n #define ASM_OUTPUT_DWARF_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_SHORT_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_delta (2, LABEL1, LABEL2, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_DELTA4\n #define ASM_OUTPUT_DWARF_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_delta (4, LABEL1, LABEL2, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_TAG\n #define ASM_OUTPUT_DWARF_TAG(FILE,TAG)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s0x%x\",\t\t\t\t\t\t\\\n-\t\t     UNALIGNED_SHORT_ASM_OP, (unsigned) TAG);\t\t\\\n-    if (flag_debug_asm)\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n-\t\t       ASM_COMMENT_START, dwarf_tag_name (TAG));\t\\\n-    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_data (2, TAG, \"%s\", dwarf_tag_name (TAG));\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_ATTRIBUTE\n #define ASM_OUTPUT_DWARF_ATTRIBUTE(FILE,ATTR)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s0x%x\",\t\t\t\t\t\t\\\n-\t\t     UNALIGNED_SHORT_ASM_OP, (unsigned) ATTR);\t\t\\\n-    if (flag_debug_asm)\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n-\t\t       ASM_COMMENT_START, dwarf_attr_name (ATTR));\t\\\n-    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_data (2, ATTR, \"%s\", dwarf_attr_name (ATTR))\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_STACK_OP\n #define ASM_OUTPUT_DWARF_STACK_OP(FILE,OP)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s0x%x\", ASM_BYTE_OP, (unsigned) OP);\t\t\\\n-    if (flag_debug_asm)\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n-\t\t       ASM_COMMENT_START, dwarf_stack_op_name (OP));\t\\\n-    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_data (1, OP, \"%s\", dwarf_stack_op_name (OP))\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_FUND_TYPE\n #define ASM_OUTPUT_DWARF_FUND_TYPE(FILE,FT)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s0x%x\",\t\t\t\t\t\t\\\n-\t\t     UNALIGNED_SHORT_ASM_OP, (unsigned) FT);\t\t\\\n-    if (flag_debug_asm)\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n-\t\t       ASM_COMMENT_START, dwarf_fund_type_name (FT));\t\\\n-    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_data (2, FT, \"%s\", dwarf_fund_type_name (FT))\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_FMT_BYTE\n #define ASM_OUTPUT_DWARF_FMT_BYTE(FILE,FMT)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s0x%x\", ASM_BYTE_OP, (unsigned) FMT);\t\t\\\n-    if (flag_debug_asm)\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n-\t\t       ASM_COMMENT_START, dwarf_fmt_byte_name (FMT));\t\\\n-    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_data (1, FMT, \"%s\", dwarf_fmt_byte_name (FMT));\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_TYPE_MODIFIER\n #define ASM_OUTPUT_DWARF_TYPE_MODIFIER(FILE,MOD)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s0x%x\", ASM_BYTE_OP, (unsigned) MOD);\t\t\\\n-    if (flag_debug_asm)\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n-\t\t       ASM_COMMENT_START, dwarf_typemod_name (MOD));\t\\\n-    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_data (1, MOD, \"%s\", dwarf_typemod_name (MOD));\n #endif\n \f\n #ifndef ASM_OUTPUT_DWARF_ADDR\n #define ASM_OUTPUT_DWARF_ADDR(FILE,LABEL)\t\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_addr (4, LABEL, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_ADDR_CONST\n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-    output_addr_const ((FILE), (RTX));\t\t\t\t\t\\\n-    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_addr_rtx (4, RTX, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_REF\n #define ASM_OUTPUT_DWARF_REF(FILE,LABEL)\t\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_addr (4, LABEL, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_DATA1\n #define ASM_OUTPUT_DWARF_DATA1(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%x\\n\", ASM_BYTE_OP, VALUE)\n+  dw2_asm_output_data (1, VALUE, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_DATA2\n #define ASM_OUTPUT_DWARF_DATA2(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%x\\n\", UNALIGNED_SHORT_ASM_OP, (unsigned) VALUE)\n+  dw2_asm_output_data (2, VALUE, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_DATA4\n #define ASM_OUTPUT_DWARF_DATA4(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%x\\n\", UNALIGNED_INT_ASM_OP, (unsigned) VALUE)\n+  dw2_asm_output_data (4, VALUE, NULL)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_DATA8\n #define ASM_OUTPUT_DWARF_DATA8(FILE,HIGH_VALUE,LOW_VALUE)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (WORDS_BIG_ENDIAN)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"%s0x%x\\n\", UNALIGNED_INT_ASM_OP, HIGH_VALUE); \\\n-\tfprintf ((FILE), \"%s0x%x\\n\", UNALIGNED_INT_ASM_OP, LOW_VALUE);\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"%s0x%x\\n\", UNALIGNED_INT_ASM_OP, LOW_VALUE);\t\\\n-\tfprintf ((FILE), \"%s0x%x\\n\", UNALIGNED_INT_ASM_OP, HIGH_VALUE); \\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+  dw2_asm_output_data (8, VALUE, NULL)\n #endif\n \n /* ASM_OUTPUT_DWARF_STRING is defined to output an ascii string, but to\n@@ -1757,11 +1689,8 @@ output_unsigned_leb128 (value)\n       value >>= 7;\n       if (value != 0)\t/* more bytes to follow */\n \tbyte |= 0x80;\n-      fprintf (asm_out_file, \"%s0x%x\", ASM_BYTE_OP, (unsigned) byte);\n-      if (flag_debug_asm && value == 0)\n-\tfprintf (asm_out_file, \"\\t%s ULEB128 number - value = %lu\",\n-\t\t ASM_COMMENT_START, orig_value);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, byte, \"\\t%s ULEB128 number - value = %lu\",\n+\t\t\t   orig_value);\n     }\n   while (value != 0);\n }\n@@ -1789,11 +1718,8 @@ output_signed_leb128 (value)\n \t  byte |= 0x80;\n \t  more = 1;\n \t}\n-      fprintf (asm_out_file, \"%s0x%x\", ASM_BYTE_OP, (unsigned) byte);\n-      if (flag_debug_asm && more == 0)\n-\tfprintf (asm_out_file, \"\\t%s SLEB128 number - value = %ld\",\n-\t\t ASM_COMMENT_START, orig_value);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, byte, \"\\t%s SLEB128 number - value = %ld\",\n+\t\t\t   orig_value);\n     }\n   while (more);\n }\n@@ -2168,8 +2094,7 @@ output_reg_number (rtl)\n \t\t\t regno);\n       regno = 0;\n     }\n-  fprintf (asm_out_file, \"%s0x%x\",\n-\t   UNALIGNED_INT_ASM_OP, DBX_REGISTER_NUMBER (regno));\n+  dw2_assemble_integer (4, GEN_INT (DBX_REGISTER_NUMBER (regno)));\n   if (flag_debug_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n@@ -6160,9 +6085,7 @@ dwarfout_source_line (line, filename)\n           filename = tail;\n       }\n \n-      fprintf (asm_out_file, \"%s%u\\t%s %s:%u\\n\",\n-\t       UNALIGNED_INT_ASM_OP, line, ASM_COMMENT_START,\n-\t       filename, line);\n+      dw2_asm_output_data (4, line, \"%s:%u\", filename, line);\n       ASM_OUTPUT_DWARF_DATA2 (asm_out_file, 0xffff);\n       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, label, TEXT_BEGIN_LABEL);\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n@@ -6176,16 +6099,18 @@ dwarfout_source_line (line, filename)\n /* Generate an entry in the .debug_macinfo section.  */\n \n static void\n-generate_macinfo_entry (type_and_offset, string)\n-     const char *type_and_offset;\n+generate_macinfo_entry (type, offset, string)\n+     unsigned int type;\n+     rtx offset;\n      const char *string;\n {\n   if (! use_gnu_debug_info_extensions)\n     return;\n \n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n-  fprintf (asm_out_file, \"%s%s\\n\", UNALIGNED_INT_ASM_OP, type_and_offset);\n+  assemble_integer (gen_rtx_PLUS (SImode, GEN_INT (type << 24), offset),\n+\t\t    4, BITS_PER_UNIT, 1);\n   ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, string);\n   ASM_OUTPUT_POP_SECTION (asm_out_file);\n }\n@@ -6206,15 +6131,16 @@ dwarfout_start_source_file (line, filename)\n      const char *filename;\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*3];\n+  const char *label1, *label2;\n \n   sprintf (label, SFNAMES_ENTRY_LABEL_FMT, lookup_filename (filename));\n-  sprintf (type_and_offset, \"0x%08x+%s-%s\",\n-\t   ((unsigned) MACINFO_start << 24),\n-\t   /* Hack: skip leading '*' .  */\n-\t   (*label == '*') + label,\n-\t   (*SFNAMES_BEGIN_LABEL == '*') + SFNAMES_BEGIN_LABEL);\n-  generate_macinfo_entry (type_and_offset, \"\");\n+  label1 = (*label == '*') + label;\n+  label2 = (*SFNAMES_BEGIN_LABEL == '*') + SFNAMES_BEGIN_LABEL;\n+  generate_macinfo_entry (MACINFO_start,\n+\t\t\t  gen_rtx_MINUS (Pmode,\n+\t\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, label1),\n+\t\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, label2)),\n+\t\t\t  \"\");\n }\n \n /* Wrapper for toplev.c callback to check debug info level.  */\n@@ -6230,11 +6156,7 @@ static void\n dwarfout_end_source_file (lineno)\n      unsigned lineno;\n {\n-  char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*2];\n-\n-  sprintf (type_and_offset, \"0x%08x+%u\",\n-\t   ((unsigned) MACINFO_resume << 24), lineno);\n-  generate_macinfo_entry (type_and_offset, \"\");\n+  generate_macinfo_entry (MACINFO_resume, GEN_INT (lineno), \"\");\n }\n \n /* Called from check_newline in c-parse.y.  The `buffer' parameter\n@@ -6248,16 +6170,13 @@ dwarfout_define (lineno, buffer)\n      const char *buffer;\n {\n   static int initialized = 0;\n-  char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*2];\n \n   if (!initialized)\n     {\n       dwarfout_start_source_file (0, primary_filename);\n       initialized = 1;\n     }\n-  sprintf (type_and_offset, \"0x%08x+%u\",\n-\t   ((unsigned) MACINFO_define << 24), lineno);\n-  generate_macinfo_entry (type_and_offset, buffer);\n+  generate_macinfo_entry (MACINFO_define, GEN_INT (lineno), buffer);\n }\n \n /* Called from check_newline in c-parse.y.  The `buffer' parameter\n@@ -6270,11 +6189,7 @@ dwarfout_undef (lineno, buffer)\n      unsigned lineno;\n      const char *buffer;\n {\n-  char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*2];\n-\n-  sprintf (type_and_offset, \"0x%08x+%u\",\n-\t   ((unsigned) MACINFO_undef << 24), lineno);\n-  generate_macinfo_entry (type_and_offset, buffer);\n+  generate_macinfo_entry (MACINFO_undef, GEN_INT (lineno), buffer);\n }\n \n /* Set up for Dwarf output at the start of compilation.\t */"}, {"sha": "e0100c18be67d35c1d5847cd498f4ff7c24e0a45", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -3465,16 +3465,16 @@ output_addr_const (file, x)\n \n       output_addr_const (file, XEXP (x, 0));\n       fprintf (file, \"-\");\n-      if ((GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t   && INTVAL (XEXP (x, 1)) < 0)\n-\t  || GET_CODE (XEXP (x, 1)) != CONST_INT)\n+      if ((GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) >= 0)\n+\t  || GET_CODE (XEXP (x, 1)) == PC\n+\t  || GET_CODE (XEXP (x, 1)) == SYMBOL_REF)\n+\toutput_addr_const (file, XEXP (x, 1));\n+      else\n \t{\n \t  fputs (targetm.asm_out.open_paren, file);\n \t  output_addr_const (file, XEXP (x, 1));\n \t  fputs (targetm.asm_out.close_paren, file);\n \t}\n-      else\n-\toutput_addr_const (file, XEXP (x, 1));\n       break;\n \n     case ZERO_EXTEND:"}, {"sha": "f491314f99f412b500bf45d83c725f4865689849", "filename": "gcc/halfpic.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fhalfpic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fhalfpic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -187,7 +187,8 @@ half_pic_finish (stream)\n       if (p->pointer_p)\n \t{\n \t  ASM_OUTPUT_LABEL (stream, p->ref_name);\n-\t  ASM_OUTPUT_INT (stream, gen_rtx_SYMBOL_REF (Pmode, p->real_name));\n+\t  assemble_aligned_integer (POINTER_SIZE / BITS_PER_UNIT,\n+\t\t\t\t    gen_rtx_SYMBOL_REF (Pmode, p->real_name));\n \t}\n     }\n }"}, {"sha": "1a2eefb36ebcf8e14d55c55d6b224f3856955299", "filename": "gcc/output.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -315,12 +315,34 @@ extern void assemble_eh_label\t\tPARAMS ((const char *));\n    Many macros in the tm file are defined to call this function.  */\n extern void assemble_name\t\tPARAMS ((FILE *, const char *));\n \n+/* Return the assembler directive for creating a given kind of integer\n+   object.  SIZE is the number of bytes in the object and ALIGNED_P\n+   indicates whether it is known to be aligned.  Return NULL if the\n+   assembly dialect has no such directive.\n+\n+   The returned string should be printed at the start of a new line and\n+   be followed immediately by the object's initial value.  */\n+extern const char *integer_asm_op\tPARAMS ((int, int));\n+\n #ifdef RTX_CODE\n+/* Use directive OP to assemble an integer object X.  Print OP at the\n+   start of the line, followed immediately by the value of X.  */\n+extern void assemble_integer_with_op\tPARAMS ((const char *, rtx));\n+\n+/* The default implementation of the asm_out.integer target hook.  */\n+extern bool default_assemble_integer\tPARAMS ((rtx, unsigned int, int));\n+\n /* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n    the alignment of the integer in bits.  Return 1 if we were able to output\n    the constant, otherwise 0.  If FORCE is non-zero, abort if we can't output\n    the constant.  */\n-extern int assemble_integer\t\tPARAMS ((rtx, unsigned, unsigned, int));\n+extern bool assemble_integer\t\tPARAMS ((rtx, unsigned, unsigned, int));\n+\n+/* An interface to assemble_integer for the common case in which a value is\n+   fully aligned and must be printed.  VALUE is the value of the integer\n+   object and SIZE is the number of bytes it contains.  */\n+#define assemble_aligned_integer(SIZE, VALUE) \\\n+  assemble_integer (VALUE, SIZE, (SIZE) * BITS_PER_UNIT, 1)\n \n #ifdef REAL_VALUE_TYPE\n /* Assemble the floating-point constant D into an object of size MODE.  */"}, {"sha": "feeb2c7aa33161afa94142d2c3d2f8b16361ed7f", "filename": "gcc/target-def.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -32,6 +32,28 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n /* Assembler output.  */\n #define TARGET_ASM_OPEN_PAREN \"(\"\n #define TARGET_ASM_CLOSE_PAREN \")\"\n+#define TARGET_ASM_BYTE_OP \"\\t.byte\\t\"\n+\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.short\\t\"\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.long\\t\"\n+#define TARGET_ASM_ALIGNED_DI_OP NULL\n+#define TARGET_ASM_ALIGNED_TI_OP NULL\n+\n+/* GAS and SYSV4 assemblers accept these.  */\n+#if defined (OBJECT_FORMAT_ELF) || defined (OBJECT_FORMAT_ROSE)\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.2byte\\t\"\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.4byte\\t\"\n+#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.8byte\\t\"\n+#define TARGET_ASM_UNALIGNED_TI_OP NULL\n+#else\n+#define TARGET_ASM_UNALIGNED_HI_OP NULL\n+#define TARGET_ASM_UNALIGNED_SI_OP NULL\n+#define TARGET_ASM_UNALIGNED_DI_OP NULL\n+#define TARGET_ASM_UNALIGNED_TI_OP NULL\n+#endif /* OBJECT_FORMAT_ELF || OBJECT_FORMAT_ROSE */\n+\n+#define TARGET_ASM_INTEGER default_assemble_integer\n+\n #define TARGET_ASM_FUNCTION_PROLOGUE default_function_pro_epilogue\n #define TARGET_ASM_FUNCTION_EPILOGUE default_function_pro_epilogue\n #define TARGET_ASM_FUNCTION_END_PROLOGUE no_asm_to_stream\n@@ -84,8 +106,24 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_ASM_EH_FRAME_SECTION default_eh_frame_section\n #endif\n \n+#define TARGET_ASM_ALIGNED_INT_OP\t\t\t\t\\\n+\t\t       {TARGET_ASM_ALIGNED_HI_OP,\t\t\\\n+\t\t\tTARGET_ASM_ALIGNED_SI_OP,\t\t\\\n+\t\t\tTARGET_ASM_ALIGNED_DI_OP,\t\t\\\n+\t\t\tTARGET_ASM_ALIGNED_TI_OP}\n+\n+#define TARGET_ASM_UNALIGNED_INT_OP\t\t\t\t\\\n+\t\t       {TARGET_ASM_UNALIGNED_HI_OP,\t\t\\\n+\t\t\tTARGET_ASM_UNALIGNED_SI_OP,\t\t\\\n+\t\t\tTARGET_ASM_UNALIGNED_DI_OP,\t\t\\\n+\t\t\tTARGET_ASM_UNALIGNED_TI_OP}\n+\n #define TARGET_ASM_OUT {TARGET_ASM_OPEN_PAREN,\t\t\t\\\n \t\t\tTARGET_ASM_CLOSE_PAREN,\t\t\t\\\n+\t\t\tTARGET_ASM_BYTE_OP,\t\t\t\\\n+\t\t\tTARGET_ASM_ALIGNED_INT_OP,\t\t\\\n+\t\t\tTARGET_ASM_UNALIGNED_INT_OP,\t\t\\\n+\t\t\tTARGET_ASM_INTEGER,\t\t\t\\\n \t\t\tTARGET_ASM_FUNCTION_PROLOGUE,\t\t\\\n \t\t\tTARGET_ASM_FUNCTION_END_PROLOGUE,\t\\\n \t\t\tTARGET_ASM_FUNCTION_BEGIN_EPILOGUE,\t\\"}, {"sha": "355a910502cc44a007ccab660009b7377bb54e3a", "filename": "gcc/target.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -52,6 +52,23 @@ struct gcc_target\n     /* Opening and closing parentheses for asm expression grouping.  */\n     const char *open_paren, *close_paren;\n \n+    /* Assembler instructions for creating various kinds of integer object.  */\n+    const char *byte_op;\n+    struct asm_int_op\n+    {\n+      const char *hi;\n+      const char *si;\n+      const char *di;\n+      const char *ti;\n+    } aligned_op, unaligned_op;\n+\n+    /* Try to output the assembler code for an integer object whose\n+       value is given by X.  SIZE is the size of the object in bytes and\n+       ALIGNED_P indicates whether it is aligned.  Return true if\n+       successful.  Only handles cases for which BYTE_OP, ALIGNED_OP\n+       and UNALIGNED_OP are NULL.  */\n+    bool (* integer) PARAMS ((rtx x, unsigned int size, int aligned_p));\n+\n     /* Output the assembler code for entry to a function.  */\n     void (* function_prologue) PARAMS ((FILE *, HOST_WIDE_INT));\n "}, {"sha": "87d81e38ba3371d6d46ea15f2e1b41a31572fd3c", "filename": "gcc/varasm.c", "status": "modified", "additions": 84, "deletions": 118, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301d03af8a3cbf51e79ff35c1aa71a6f353709c5/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=301d03af8a3cbf51e79ff35c1aa71a6f353709c5", "patch": "@@ -1922,154 +1922,120 @@ min_align (a, b)\n   return (a | b) & -(a | b);\n }\n \n-/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n-   the alignment of the integer in bits.  Return 1 if we were able to output\n-   the constant, otherwise 0.  If FORCE is non-zero, abort if we can't output\n-   the constant.  */\n+/* Return the assembler directive for creating a given kind of integer\n+   object.  SIZE is the number of bytes in the object and ALIGNED_P\n+   indicates whether it is known to be aligned.  Return NULL if the\n+   assembly dialect has no such directive.\n \n-int\n-assemble_integer (x, size, align, force)\n-     rtx x;\n-     unsigned int size;\n-     unsigned int align;\n-     int force;\n+   The returned string should be printed at the start of a new line and\n+   be followed immediately by the object's initial value.  */\n+\n+const char *\n+integer_asm_op (size, aligned_p)\n+     int size;\n+     int aligned_p;\n {\n-  /* First try to use the standard 1, 2, 4, 8, and 16 byte\n-     ASM_OUTPUT... macros.  */\n+  struct asm_int_op *ops;\n \n-  if (align >= MIN (size * BITS_PER_UNIT, BIGGEST_ALIGNMENT))\n-    switch (size)\n-      {\n-#ifdef ASM_OUTPUT_CHAR\n-      case 1:\n-\tASM_OUTPUT_CHAR (asm_out_file, x);\n-\treturn 1;\n-#endif\n-#ifdef ASM_OUTPUT_SHORT\n-      case 2:\n-\tASM_OUTPUT_SHORT (asm_out_file, x);\n-\treturn 1;\n-#endif\n-#ifdef ASM_OUTPUT_INT\n-      case 4:\n-\tASM_OUTPUT_INT (asm_out_file, x);\n-\treturn 1;\n-#endif\n-#ifdef ASM_OUTPUT_DOUBLE_INT\n-      case 8:\n-\tASM_OUTPUT_DOUBLE_INT (asm_out_file, x);\n-\treturn 1;\n-#endif\n-#ifdef ASM_OUTPUT_QUADRUPLE_INT\n-      case 16:\n-\tASM_OUTPUT_QUADRUPLE_INT (asm_out_file, x);\n-\treturn 1;\n-#endif\n-      }\n+  if (aligned_p)\n+    ops = &targetm.asm_out.aligned_op;\n   else\n+    ops = &targetm.asm_out.unaligned_op;\n+\n+  switch (size)\n     {\n-      const char *asm_op = NULL;\n+    case 1:\n+      return targetm.asm_out.byte_op;\n+    case 2:\n+      return ops->hi;\n+    case 4:\n+      return ops->si;\n+    case 8:\n+      return ops->di;\n+    case 16:\n+      return ops->ti;\n+    default:\n+      return NULL;\n+    }\n+}\n \n-      /* ??? This isn't quite as flexible as the ASM_OUTPUT_INT type hooks.\n-\t At present powerpc-eabi can't jump -mrelocatable hoops, so you can\n-\t get assembler errors from symbolic references in packed structs.  */\n-      switch (size)\n-\t{\n-#ifdef UNALIGNED_SHORT_ASM_OP\n-\tcase 2:\n-\t  asm_op = UNALIGNED_SHORT_ASM_OP;\n-\t  break;\n-#endif\n-#ifdef UNALIGNED_INT_ASM_OP\n-\tcase 4:\n-\t  asm_op = UNALIGNED_INT_ASM_OP;\n-\t  break;\n-#endif\n-#ifdef UNALIGNED_DOUBLE_INT_ASM_OP\n-\tcase 8:\n-\t  asm_op = UNALIGNED_DOUBLE_INT_ASM_OP;\n-\t  break;\n-#endif\n-\t}\n+/* Use directive OP to assemble an integer object X.  Print OP at the\n+   start of the line, followed immediately by the value of X.  */\n \n-      if (asm_op)\n-\t{\n-\t  fputs (asm_op, asm_out_file);\n-\t  output_addr_const (asm_out_file, x);\n-\t  fputc ('\\n', asm_out_file);\n-\t  return 1;\n-\t}\n-    }\n+void\n+assemble_integer_with_op (op, x)\n+     const char *op;\n+     rtx x;\n+{\n+  fputs (op, asm_out_file);\n+  output_addr_const (asm_out_file, x);\n+  fputc ('\\n', asm_out_file);\n+}\n \n-  /* If we couldn't do it that way, there are two other possibilities: First,\n-     if the machine can output an explicit byte and this is a 1 byte constant,\n-     we can use ASM_OUTPUT_BYTE.  */\n+/* The default implementation of the asm_out.integer target hook.  */\n \n-#ifdef ASM_OUTPUT_BYTE\n-  if (size == 1 && GET_CODE (x) == CONST_INT)\n-    {\n-      ASM_OUTPUT_BYTE (asm_out_file, INTVAL (x));\n-      return 1;\n-    }\n-#endif\n+bool\n+default_assemble_integer (x, size, aligned_p)\n+     rtx x ATTRIBUTE_UNUSED;\n+     unsigned int size ATTRIBUTE_UNUSED;\n+     int aligned_p ATTRIBUTE_UNUSED;\n+{\n+  const char *op = integer_asm_op (size, aligned_p);\n+  return op && (assemble_integer_with_op (op, x), true);\n+}\n \n-  /* If SIZE is larger than a single word, try to output the constant\n-     one word at a time.  */\n+/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n+   the alignment of the integer in bits.  Return 1 if we were able to output\n+   the constant, otherwise 0.  If FORCE is non-zero, abort if we can't output\n+   the constant.  */\n \n-  if (size > UNITS_PER_WORD)\n-    {\n-      enum machine_mode mode\n-\t= mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n-      unsigned align2 = min_align (align, BITS_PER_WORD);\n-      unsigned int i;\n+bool\n+assemble_integer (x, size, align, force)\n+     rtx x;\n+     unsigned int size;\n+     unsigned int align;\n+     int force;\n+{\n+  int aligned_p;\n \n-      for (i = 0; i < size / UNITS_PER_WORD; i++)\n-\t{\n-\t  rtx word = operand_subword (x, i, 0, mode);\n-\t  if (word == 0)\n-\t    break;\n-\t  if (! assemble_integer (word, UNITS_PER_WORD, align2, 0))\n-\t    break;\n-\t}\n+  aligned_p = (align >= MIN (size * BITS_PER_UNIT, BIGGEST_ALIGNMENT));\n \n-      if (i == size / UNITS_PER_WORD)\n-\treturn 1;\n-      /* If we output at least one word and then could not finish,\n-\t there is no valid way to continue.  */\n-      if (i > 0)\n-\tabort ();\n-    }\n+  /* See if the target hook can handle this kind of object.  */\n+  if ((*targetm.asm_out.integer) (x, size, aligned_p))\n+    return true;\n \n-  /* If unaligned, and this is a constant, emit it one byte at a time.  */\n-  if (align < size * BITS_PER_UNIT)\n+  /* If the object is a multi-byte one, try splitting it up.  Split\n+     it into words it if is multi-word, otherwise split it into bytes.  */\n+  if (size > 1)\n     {\n       enum machine_mode omode, imode;\n-      unsigned int i;\n+      unsigned int subalign;\n+      unsigned int subsize, i;\n \n-      omode = mode_for_size (BITS_PER_UNIT, MODE_INT, 0);\n+      subsize = size > UNITS_PER_WORD? UNITS_PER_WORD : 1;\n+      subalign = MIN (align, subsize * BITS_PER_UNIT);\n+      omode = mode_for_size (subsize * BITS_PER_UNIT, MODE_INT, 0);\n       imode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n \n-      for (i = 0; i < size; i++)\n+      for (i = 0; i < size; i += subsize)\n \t{\n-\t  rtx byte = simplify_subreg (omode, x, imode, i);\n-\t  if (byte == 0)\n-\t    break;\n-\t  if (! assemble_integer (byte, 1, BITS_PER_UNIT, 0))\n+\t  rtx partial = simplify_subreg (omode, x, imode, i);\n+\t  if (!partial || !assemble_integer (partial, subsize, subalign, 0))\n \t    break;\n \t}\n-\n       if (i == size)\n-\treturn 1;\n-      /* If we output at least one byte and then could not finish,\n-\t there is no valid way to continue.  */\n+\treturn true;\n+\n+      /* If we've printed some of it, but not all of it, there's no going\n+\t back now.  */\n       if (i > 0)\n \tabort ();\n     }\n \n   if (force)\n     abort ();\n \n-  return 0;\n+  return false;\n }\n \f\n /* Assemble the floating-point constant D into an object of size MODE.  */"}]}