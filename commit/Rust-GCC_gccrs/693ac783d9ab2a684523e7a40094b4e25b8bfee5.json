{"sha": "693ac783d9ab2a684523e7a40094b4e25b8bfee5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkzYWM3ODNkOWFiMmE2ODQ1MjNlN2E0MDA5NGI0ZTI1YjhiZmVlNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2012-09-29T17:58:34Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2012-09-29T17:58:34Z"}, "message": "re PR libstdc++/34106 ([parallel mode] Atomic operations compatibility layer needs cleanup)\n\n\tPR libstdc++/34106\n\t* include/parallel/compatibility.h: Remove non-GCC code.\n\nFrom-SVN: r191856", "tree": {"sha": "8028da891232539deac3fdd85c38381b620bc115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8028da891232539deac3fdd85c38381b620bc115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/693ac783d9ab2a684523e7a40094b4e25b8bfee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/693ac783d9ab2a684523e7a40094b4e25b8bfee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/693ac783d9ab2a684523e7a40094b4e25b8bfee5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/693ac783d9ab2a684523e7a40094b4e25b8bfee5/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a447b3d4d5fea7bbbab81658a696f642b2b8d93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a447b3d4d5fea7bbbab81658a696f642b2b8d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a447b3d4d5fea7bbbab81658a696f642b2b8d93"}], "stats": {"total": 188, "additions": 19, "deletions": 169}, "files": [{"sha": "889c724150186b13cb3de47fbb8553eab9f5bd0f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/693ac783d9ab2a684523e7a40094b4e25b8bfee5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/693ac783d9ab2a684523e7a40094b4e25b8bfee5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=693ac783d9ab2a684523e7a40094b4e25b8bfee5", "patch": "@@ -1,3 +1,8 @@\n+2012-09-27  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/34106\n+\t* include/parallel/compatibility.h: Remove non-GCC code.\n+\n 2012-09-28  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* fragment.am (CONFIG_CXXFLAGS): Remove EXTRA_CXX_FLAGS."}, {"sha": "03506d84de35c18f7291284eb3c85d3e48c461a7", "filename": "libstdc++-v3/include/parallel/compatibility.h", "status": "modified", "additions": 14, "deletions": 169, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/693ac783d9ab2a684523e7a40094b4e25b8bfee5/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/693ac783d9ab2a684523e7a40094b4e25b8bfee5/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h?ref=693ac783d9ab2a684523e7a40094b4e25b8bfee5", "patch": "@@ -24,7 +24,9 @@\n \n /** @file parallel/compatibility.h\n  *  @brief Compatibility layer, mostly concerned with atomic operations.\n- *  This file is a GNU parallel extension to the Standard C++ Library.\n+ *\n+ *  This file is a GNU parallel extension to the Standard C++ Library\n+ *  and contains implementation details for the library's internal use.\n  */\n \n // Written by Felix Putze.\n@@ -35,21 +37,10 @@\n #include <parallel/types.h>\n #include <parallel/base.h>\n \n-#if defined(__SUNPRO_CC) && defined(__sparc)\n-#include <sys/atomic.h>\n-#endif\n-\n #if !defined(_WIN32) || defined (__CYGWIN__)\n #include <sched.h>\n #endif\n \n-#if defined(_MSC_VER)\n-#include <Windows.h>\n-#include <intrin.h>\n-#undef max\n-#undef min\n-#endif\n-\n #ifdef __MINGW32__\n // Including <windows.h> will drag in all the windows32 names.  Since\n // that can cause user code portability problems, we just declare the\n@@ -60,30 +51,7 @@ __attribute((dllimport)) void __attribute__((stdcall)) Sleep (unsigned long);\n \n namespace __gnu_parallel\n {\n-#if defined(__ICC)\n-  template<typename _MustBeInt = int>\n-  int32_t __faa32(int32_t* __x, int32_t __inc)\n-  {\n-    asm volatile(\"lock xadd %0,%1\"\n-                 : \"=__r\" (__inc), \"=__m\" (*__x)\n-                 : \"0\" (__inc)\n-                 : \"memory\");\n-    return __inc;\n-  }\n-#if defined(__x86_64)\n-  template<typename _MustBeInt = int>\n-  int64_t __faa64(int64_t* __x, int64_t __inc)\n-  {\n-    asm volatile(\"lock xadd %0,%1\"\n-                 : \"=__r\" (__inc), \"=__m\" (*__x)\n-                 : \"0\" (__inc)\n-                 : \"memory\");\n-    return __inc;\n-  }\n-#endif\n-#endif\n-\n-  // atomic functions only work on integers\n+  // These atomic functions only work on integers\n \n   /** @brief Add a value to a variable, atomically.\n    *\n@@ -94,34 +62,7 @@ namespace __gnu_parallel\n   inline int32_t\n   __fetch_and_add_32(volatile int32_t* __ptr, int32_t __addend)\n   {\n-#if defined(__ICC)      //x86 version\n-    return _InterlockedExchangeAdd((void*)__ptr, __addend);\n-#elif defined(__ECC)    //IA-64 version\n-    return _InterlockedExchangeAdd((void*)__ptr, __addend);\n-#elif defined(__ICL) || defined(_MSC_VER)\n-    return _InterlockedExchangeAdd(reinterpret_cast<volatile long*>(__ptr),\n-                                   __addend);\n-#elif defined(__GNUC__)\n     return __atomic_fetch_add(__ptr, __addend, __ATOMIC_ACQ_REL);\n-#elif defined(__SUNPRO_CC) && defined(__sparc)\n-    volatile int32_t __before, __after;\n-    do\n-      {\n-        __before = *__ptr;\n-        __after = __before + __addend;\n-      } while (atomic_cas_32((volatile unsigned int*)__ptr, __before,\n-                             __after) != __before);\n-    return __before;\n-#else   //fallback, slow\n-#pragma message(\"slow __fetch_and_add_32\")\n-    int32_t __res;\n-#pragma omp critical\n-    {\n-      __res = *__ptr;\n-      *(__ptr) += __addend;\n-    }\n-    return __res;\n-#endif\n   }\n \n   /** @brief Add a value to a variable, atomically.\n@@ -133,34 +74,14 @@ namespace __gnu_parallel\n   inline int64_t\n   __fetch_and_add_64(volatile int64_t* __ptr, int64_t __addend)\n   {\n-#if defined(__ICC) && defined(__x86_64) //x86 version\n-    return __faa64<int>((int64_t*)__ptr, __addend);\n-#elif defined(__ECC)    //IA-64 version\n-    return _InterlockedExchangeAdd64((void*)__ptr, __addend);\n-#elif defined(__ICL) || defined(_MSC_VER)\n-#ifndef _WIN64\n-    _GLIBCXX_PARALLEL_ASSERT(false);    //not available in this case\n-    return 0;\n-#else\n-    return _InterlockedExchangeAdd64(__ptr, __addend);\n-#endif\n-#elif defined(__GNUC__) && defined(__x86_64)\n+#if defined(__x86_64)\n     return __atomic_fetch_add(__ptr, __addend, __ATOMIC_ACQ_REL);\n-#elif defined(__GNUC__) && defined(__i386) &&                   \\\n+#elif defined(__i386) &&                   \\\n   (defined(__i686) || defined(__pentium4) || defined(__athlon)  \\\n    || defined(__k8) || defined(__core2))\n     return __atomic_fetch_add(__ptr, __addend, __ATOMIC_ACQ_REL);\n-#elif defined(__SUNPRO_CC) && defined(__sparc)\n-    volatile int64_t __before, __after;\n-    do\n-      {\n-        __before = *__ptr;\n-        __after = __before + __addend;\n-      } while (atomic_cas_64((volatile unsigned long long*)__ptr, __before,\n-                             __after) != __before);\n-    return __before;\n #else   //fallback, slow\n-#if defined(__GNUC__) && defined(__i386)\n+#if defined(__i386)\n     // XXX doesn'__t work with -march=native\n     //#warning \"please compile with -march=i686 or better\"\n #endif\n@@ -195,39 +116,6 @@ namespace __gnu_parallel\n       _GLIBCXX_PARALLEL_ASSERT(false);\n   }\n \n-\n-#if defined(__ICC)\n-\n-  template<typename _MustBeInt = int>\n-  inline int32_t\n-  __cas32(volatile int32_t* __ptr, int32_t __old, int32_t __nw)\n-  {\n-    int32_t __before;\n-    __asm__ __volatile__(\"lock; cmpxchgl %1,%2\"\n-                         : \"=a\"(__before)\n-                         : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)),\n-                               \"0\"(__old)\n-                         : \"memory\");\n-    return __before;\n-  }\n-\n-#if defined(__x86_64)\n-  template<typename _MustBeInt = int>\n-  inline int64_t\n-  __cas64(volatile int64_t *__ptr, int64_t __old, int64_t __nw)\n-  {\n-    int64_t __before;\n-    __asm__ __volatile__(\"lock; cmpxchgq %1,%2\"\n-                         : \"=a\"(__before)\n-                         : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)),\n-                               \"0\"(__old)\n-                         : \"memory\");\n-    return __before;\n-  }\n-#endif\n-\n-#endif\n-\n   /** @brief Compare @c *__ptr and @c __comparand. If equal, let @c\n    * *__ptr=__replacement and return @c true, return @c false otherwise.\n    *\n@@ -240,37 +128,9 @@ namespace __gnu_parallel\n   __compare_and_swap_32(volatile int32_t* __ptr, int32_t __comparand,\n                         int32_t __replacement)\n   {\n-#if defined(__ICC)      //x86 version\n-    return _InterlockedCompareExchange((void*)__ptr, __replacement,\n-                                       __comparand) == __comparand;\n-#elif defined(__ECC)    //IA-64 version\n-    return _InterlockedCompareExchange((void*)__ptr, __replacement,\n-                                       __comparand) == __comparand;\n-#elif defined(__ICL) || defined(_MSC_VER)\n-    return _InterlockedCompareExchange(\n-               reinterpret_cast<volatile long*>(__ptr),\n-               __replacement, __comparand)\n-             == __comparand;\n-#elif defined(__GNUC__)\n     return __atomic_compare_exchange_n(__ptr, &__comparand, __replacement,\n \t\t\t\t       false, __ATOMIC_ACQ_REL,\n \t\t\t\t       __ATOMIC_RELAXED);\n-#elif defined(__SUNPRO_CC) && defined(__sparc)\n-    return atomic_cas_32((volatile unsigned int*)__ptr, __comparand,\n-                         __replacement) == __comparand;\n-#else\n-#pragma message(\"slow __compare_and_swap_32\")\n-    bool __res = false;\n-#pragma omp critical\n-    {\n-      if (*__ptr == __comparand)\n-        {\n-          *__ptr = __replacement;\n-          __res = true;\n-        }\n-    }\n-    return __res;\n-#endif\n   }\n \n   /** @brief Compare @c *__ptr and @c __comparand. If equal, let @c\n@@ -285,35 +145,18 @@ namespace __gnu_parallel\n   __compare_and_swap_64(volatile int64_t* __ptr, int64_t __comparand,\n                         int64_t __replacement)\n   {\n-#if defined(__ICC) && defined(__x86_64) //x86 version\n-    return __cas64<int>(__ptr, __comparand, __replacement) == __comparand;\n-#elif defined(__ECC)    //IA-64 version\n-    return _InterlockedCompareExchange64((void*)__ptr, __replacement,\n-                                         __comparand) == __comparand;\n-#elif defined(__ICL) || defined(_MSC_VER)\n-#ifndef _WIN64\n-    _GLIBCXX_PARALLEL_ASSERT(false);    //not available in this case\n-    return 0;\n-#else\n-    return _InterlockedCompareExchange64(__ptr, __replacement,\n-                                         __comparand) == __comparand;\n-#endif\n-\n-#elif defined(__GNUC__) && defined(__x86_64)\n+#if defined(__x86_64)\n     return __atomic_compare_exchange_n(__ptr, &__comparand, __replacement,\n \t\t\t\t       false, __ATOMIC_ACQ_REL,\n \t\t\t\t       __ATOMIC_RELAXED);\n-#elif defined(__GNUC__) && defined(__i386) &&                   \\\n+#elif defined(__i386) &&                   \\\n   (defined(__i686) || defined(__pentium4) || defined(__athlon)  \\\n    || defined(__k8) || defined(__core2))\n     return __atomic_compare_exchange_n(__ptr, &__comparand, __replacement,\n \t\t\t\t       false, __ATOMIC_ACQ_REL,\n \t\t\t\t       __ATOMIC_RELAXED);\n-#elif defined(__SUNPRO_CC) && defined(__sparc)\n-    return atomic_cas_64((volatile unsigned long long*)__ptr,\n-                         __comparand, __replacement) == __comparand;\n #else\n-#if defined(__GNUC__) && defined(__i386)\n+#if defined(__i386)\n     // XXX -march=native\n     //#warning \"please compile with -march=i686 or better\"\n #endif\n@@ -337,7 +180,8 @@ namespace __gnu_parallel\n    *  Implementation is heavily platform-dependent.\n    *  @param __ptr Pointer to signed integer.\n    *  @param __comparand Compare value.\n-   *  @param __replacement Replacement value. */\n+   *  @param __replacement Replacement value.\n+   */\n   template<typename _Tp>\n   inline bool\n   __compare_and_swap(volatile _Tp* __ptr, _Tp __comparand, _Tp __replacement)\n@@ -355,7 +199,8 @@ namespace __gnu_parallel\n   }\n \n   /** @brief Yield the control to another thread, without waiting for\n-      the end to the time slice. */\n+   *  the end of the time slice.\n+   */\n   inline void\n   __yield()\n   {"}]}