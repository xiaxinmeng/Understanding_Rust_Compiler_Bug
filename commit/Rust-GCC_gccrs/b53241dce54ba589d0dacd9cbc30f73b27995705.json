{"sha": "b53241dce54ba589d0dacd9cbc30f73b27995705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUzMjQxZGNlNTRiYTU4OWQwZGFjZDljYmMzMGY3M2IyNzk5NTcwNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-12-19T09:04:47Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-12-19T09:04:47Z"}, "message": "(build_encode_expr): Terminate the encode string with a null.\n\n(encode_aggregate): Distinguish pointer to record from a\nrecord.  Output fields for record.  Fix unions.\n\nFrom-SVN: r2896", "tree": {"sha": "4653a46d736b2ce04e8392b4c5f97144aa453a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4653a46d736b2ce04e8392b4c5f97144aa453a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b53241dce54ba589d0dacd9cbc30f73b27995705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53241dce54ba589d0dacd9cbc30f73b27995705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b53241dce54ba589d0dacd9cbc30f73b27995705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53241dce54ba589d0dacd9cbc30f73b27995705/comments", "author": null, "committer": null, "parents": [{"sha": "0e9934c8fcd9d05b2054a1d43745bd8350663ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9934c8fcd9d05b2054a1d43745bd8350663ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e9934c8fcd9d05b2054a1d43745bd8350663ecc"}], "stats": {"total": 70, "additions": 47, "deletions": 23}, "files": [{"sha": "edfc0b04a74d81d2ec32d11a48db14d25da4900c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53241dce54ba589d0dacd9cbc30f73b27995705/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53241dce54ba589d0dacd9cbc30f73b27995705/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=b53241dce54ba589d0dacd9cbc30f73b27995705", "patch": "@@ -2951,6 +2951,7 @@ build_encode_expr (type)\n     fatal (\"Objective-C text in C source file\");\n \n   encode_type (type, OBJC_ENCODE_INLINE_DEFS);\n+  obstack_1grow (&util_obstack, 0);    /* null terminate string */\n   string = obstack_finish (&util_obstack);\n \n   /* synthesize a string that represents the encoded struct/union */\n@@ -3749,63 +3750,86 @@ encode_aggregate (type, format)\n     {\n     case RECORD_TYPE:\n       {\n-\tif (*obstack_next_free (&util_obstack) == '^'\n-\t    || format !=  OBJC_ENCODE_INLINE_DEFS)\n+\tint have_pointer = 0;\n+\n+\tif (obstack_object_size (&util_obstack) > 0     \n+\t    && *(obstack_next_free (&util_obstack)-1) == '^')\n+\t  have_pointer = 1;\n+\n+\tobstack_1grow (&util_obstack, '{');\n+        if (TYPE_NAME (type))\n \t  {\n-\t    /* we have a reference - this is a NeXT extension--\n-\t       or we don't want the details.  */\n-            if (TYPE_NAME (type)\n-\t\t&& (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE))\n+\t    if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n \t      {\n-\t\tobstack_1grow (&util_obstack, '{');\n-\t\tobstack_grow (&util_obstack,\n+\t        obstack_grow (&util_obstack,\n \t\t\t      IDENTIFIER_POINTER (TYPE_NAME (type)),\n \t\t\t      strlen (IDENTIFIER_POINTER (TYPE_NAME (type))));\n-\t\tobstack_1grow (&util_obstack, '}');\n \t      }\n \t    else /* we have an untagged structure or a typedef */\n-\t      obstack_grow (&util_obstack, \"{?}\", 3);\n+\t      {\n+\t        obstack_1grow (&util_obstack, '?');\n+\t      }\n+\t  }\n+\t\n+\tif (have_pointer\n+\t    || format == OBJC_ENCODE_DONT_INLINE_DEFS)\n+\t  {\n+\t    /* we have a pointer\n+\t       or we don't want the details.  */\n+\t    obstack_1grow (&util_obstack, '}');\n \t  }\n \telse\n \t  {\n \t    tree fields = TYPE_FIELDS (type);\n-\t    obstack_1grow (&util_obstack, '{');\n+\t    obstack_1grow (&util_obstack, '=');\n \t    for ( ; fields; fields = TREE_CHAIN (fields))\n \t      encode_field_decl (fields, format);\n \t    obstack_1grow (&util_obstack, '}');\n \t  }\n \tbreak;\n       }\n+\n     case UNION_TYPE:\n       {\n-\tif (*obstack_next_free (&util_obstack) == '^'\n-\t    || format !=  OBJC_ENCODE_INLINE_DEFS)\n+\tint have_pointer = 0;\n+\n+\tif (obstack_object_size (&util_obstack) > 0     \n+\t    && *(obstack_next_free (&util_obstack)-1) == '^')\n+\t  have_pointer = 1;\n+\n+\tobstack_1grow (&util_obstack, '(');\n+        if (have_pointer && TYPE_NAME (type))\n \t  {\n-\t    /* we have a reference - this is a NeXT extension--\n-\t       or we don't want the details.  */\n-            if (TYPE_NAME (type)\n-\t\t&& (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE))\n+\t    if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n \t      {\n-\t\tobstack_1grow (&util_obstack, '<');\n-\t\tobstack_grow (&util_obstack,\n+\t        obstack_grow (&util_obstack,\n \t\t\t      IDENTIFIER_POINTER (TYPE_NAME (type)),\n \t\t\t      strlen (IDENTIFIER_POINTER (TYPE_NAME (type))));\n-\t\tobstack_1grow (&util_obstack, '>');\n \t      }\n \t    else /* we have an untagged structure or a typedef */\n-\t      obstack_grow (&util_obstack, \"<?>\", 3);\n+\t      {\n+\t        obstack_1grow (&util_obstack, '?');\n+\t      }\n+\t  }\n+\t\n+\tif (have_pointer\n+\t    || format == OBJC_ENCODE_DONT_INLINE_DEFS)\n+\t  {\n+\t    /* we have a pointer\n+\t       or we don't want the details.  */\n+\t    obstack_1grow (&util_obstack, ')');\n \t  }\n \telse\n \t  {\n \t    tree fields = TYPE_FIELDS (type);\n-\t    obstack_1grow (&util_obstack, '<');\n \t    for ( ; fields; fields = TREE_CHAIN (fields))\n \t      encode_field_decl (fields, format);\n-\t    obstack_1grow (&util_obstack, '>');\n+\t    obstack_1grow (&util_obstack, ')');\n \t  }\n \tbreak;\n       }\n \n+\n     case ENUMERAL_TYPE:\n       obstack_1grow (&util_obstack, 'i');\n       break;"}]}