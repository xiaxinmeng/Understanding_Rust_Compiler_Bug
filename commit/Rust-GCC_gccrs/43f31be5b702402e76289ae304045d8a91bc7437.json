{"sha": "43f31be5b702402e76289ae304045d8a91bc7437", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNmMzFiZTViNzAyNDAyZTc2Mjg5YWUzMDQwNDVkOGE5MWJjNzQzNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-11-04T20:09:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-11-04T20:09:25Z"}, "message": "invoke.texi: Document max-jump-thread-duplication-stmts PARAM.\n\n\n\t* doc/invoke.texi: Document max-jump-thread-duplication-stmts PARAM.\n\t* tree-ssa-dom.c: Include params.h.\n\t(thread_across_edge): If there are too many statements in the\n\ttarget block, then do not thread through it.\n\t* Makefile.in (tree-ssa-dom.o): Depend on $(PARAMS_H).\n\t* params.def (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS): New PARAM.\n\nFrom-SVN: r106503", "tree": {"sha": "ad9cd6b26ccb8f5631c14579e9c4b7fc9941c67e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad9cd6b26ccb8f5631c14579e9c4b7fc9941c67e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43f31be5b702402e76289ae304045d8a91bc7437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f31be5b702402e76289ae304045d8a91bc7437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43f31be5b702402e76289ae304045d8a91bc7437", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f31be5b702402e76289ae304045d8a91bc7437/comments", "author": null, "committer": null, "parents": [{"sha": "8b1062b24b37fcda9a94ad655e73e9352abcd3a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b1062b24b37fcda9a94ad655e73e9352abcd3a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b1062b24b37fcda9a94ad655e73e9352abcd3a0"}], "stats": {"total": 49, "additions": 48, "deletions": 1}, "files": [{"sha": "9bf6a7ca3e4c771371f1a0fd74b3da7196c0d17b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43f31be5b702402e76289ae304045d8a91bc7437", "patch": "@@ -1,3 +1,13 @@\n+2005-10-04  Jeff Law  <law@redhat.com>\n+\n+\tPR/21883\n+\t* doc/invoke.texi: Document max-jump-thread-duplication-stmts PARAM.\n+\t* tree-ssa-dom.c: Include params.h.\n+\t(thread_across_edge): If there are too many statements in the\n+\ttarget block, then do not thread through it.\n+\t* Makefile.in (tree-ssa-dom.o): Depend on $(PARAMS_H).\n+\t* params.def (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS): New PARAM.\n+\n 2005-11-03  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR 24627"}, {"sha": "8bba4e097b456da1b88c08ab2dae38b72578d02f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=43f31be5b702402e76289ae304045d8a91bc7437", "patch": "@@ -1791,7 +1791,7 @@ tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) langhooks.h \\\n-   tree-ssa-propagate.h $(CFGLOOP_H)\n+   tree-ssa-propagate.h $(CFGLOOP_H) $(PARAMS_H)\n tree-ssa-uncprop.o : tree-ssa-uncprop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "5662786911a8ffcf3f136eb055b4b6b32548ac09", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=43f31be5b702402e76289ae304045d8a91bc7437", "patch": "@@ -6085,6 +6085,9 @@ ratio is 3.\n The minimum size of buffers (i.e. arrays) that will receive stack smashing\n protection when @option{-fstack-protection} is used.\n \n+@item max-jump-thread-duplication-stmts\n+Maximum number of statements allowed in a block that needs to be\n+duplicated when threading jumps.\n @end table\n @end table\n "}, {"sha": "f0740a9d00f1e06f619b666fa958fa97ffa8e545", "filename": "gcc/params.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=43f31be5b702402e76289ae304045d8a91bc7437", "patch": "@@ -506,6 +506,24 @@ DEFPARAM (PARAM_SSP_BUFFER_SIZE,\n \t  \"The lower bound for a buffer to be considered for stack smashing protection\",\n \t  8, 1, 0)\n \n+/* When we thread through a block we have to make copies of the\n+   statements within the block.  Clearly for large blocks the code\n+   duplication is bad.\n+\n+   PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS specifies the maximum number\n+   of statements and PHI nodes allowed in a block which is going to\n+   be duplicated for thread jumping purposes.\n+\n+   Some simple analysis showed that more than 99% of the jump\n+   threading opportunities are for blocks with less than 15\n+   statements.  So we can get the benefits of jump threading\n+   without excessive code bloat for pathological cases with the\n+   throttle set at 15 statements.  */\n+DEFPARAM (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS,\n+\t  \"max-jump-thread-duplication-stmts\",\n+          \"Maximum number of statements allowed in a block that needs to be duplicated when threading jumps\",\n+\t  15, 0, 0)\n+   \n /*\n Local variables:\n mode:c"}, {"sha": "cb5eeb03a2f28cf6b8a80730a1a55bf7c6c41eec", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f31be5b702402e76289ae304045d8a91bc7437/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=43f31be5b702402e76289ae304045d8a91bc7437", "patch": "@@ -42,6 +42,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"langhooks.h\"\n+#include \"params.h\"\n \n /* This file implements optimizations on the dominator tree.  */\n \n@@ -608,6 +609,9 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n   block_stmt_iterator bsi;\n   tree stmt = NULL;\n   tree phi;\n+  int stmt_count = 0;\n+  int max_stmt_count;\n+\n \n   /* If E->dest does not end with a conditional, then there is\n      nothing to do.  */\n@@ -637,6 +641,11 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       tree dst = PHI_RESULT (phi);\n \n+      /* Do not include virtual PHIs in our statement count as\n+\t they never generate code.  */\n+      if (is_gimple_reg (dst))\n+\tstmt_count++;\n+\n       /* If the desired argument is not the same as this PHI's result \n \t and it is set by a PHI in E->dest, then we can not thread\n \t through E->dest.  */\n@@ -664,6 +673,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n      Failure to simplify into the form above merely means that the\n      statement provides no equivalences to help simplify later\n      statements.  This does not prevent threading through E->dest.  */\n+  max_stmt_count = PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS);\n   for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       tree cached_lhs = NULL;\n@@ -674,6 +684,12 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       if (IS_EMPTY_STMT (stmt) || TREE_CODE (stmt) == LABEL_EXPR)\n \tcontinue;\n \n+      /* If duplicating this block is going to cause too much code\n+\t expansion, then do not thread through this block.  */\n+      stmt_count++;\n+      if (stmt_count > max_stmt_count)\n+\treturn;\n+\n       /* Safely handle threading across loop backedges.  This is\n \t over conservative, but still allows us to capture the\n \t majority of the cases where we can thread across a loop"}]}