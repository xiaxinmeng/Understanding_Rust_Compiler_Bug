{"sha": "8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUwM2IyMWU4NGU0YjZhM2M4MDZiYjQ4YmI1ZWNlYWMxZjdlZDI3Mw==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2019-12-09T09:59:42Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2019-12-09T09:59:42Z"}, "message": "re PR tree-optimization/89007 ([SVE] Implement generic vector average expansion)\n\n2019-12-09  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\n\tPR tree-optimization/89007\n\t* tree-vect-patterns.c (vect_recog_average_pattern): If there is no\n\ttarget support available, generate code to distribute rshift over plus\n\tand add a carry.\n\ntestsuite/\n\t* gcc.target/aarch64/sve/pr89007-1.c: New test.\n\t* gcc.target/aarch64/sve/pr89007-2.c: Likewise.\n\nFrom-SVN: r279112", "tree": {"sha": "ea260ab621a5fe224c76b87e0f643c1e89502449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea260ab621a5fe224c76b87e0f643c1e89502449"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/comments", "author": null, "committer": null, "parents": [{"sha": "1d214c3f83521bcf0793f6460ace2bee89f670b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d214c3f83521bcf0793f6460ace2bee89f670b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d214c3f83521bcf0793f6460ace2bee89f670b8"}], "stats": {"total": 137, "additions": 132, "deletions": 5}, "files": [{"sha": "cee65513d00c75cb2276bb2e1a3030754ea3ee9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "patch": "@@ -1,3 +1,10 @@\n+2019-12-09  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\tPR tree-optimization/89007\n+\t* tree-vect-patterns.c (vect_recog_average_pattern): If there is no\n+\ttarget support available, generate code to distribute rshift over plus\n+\tand add a carry.\n+\n 2019-12-09  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/92737"}, {"sha": "0706b05b417e901007cb75a1fea3b8f8d25de202", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "patch": "@@ -1,3 +1,9 @@\n+2019-12-09  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\tPR tree-optimization/89007\n+\t* gcc.target/aarch64/sve/pr89007-1.c: New test.\n+\t* gcc.target/aarch64/sve/pr89007-2.c: Likewise.\n+\n 2019-12-09  Hongtao Liu  <hongtao@intel.com>\n \n \t* gcc.target/i386/pr92686.inc: New file."}, {"sha": "af4aff4ec6d9495fb6bbfa704b073caa11e6f85d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr89007-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-1.c?ref=8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O -ftree-vectorize -march=armv8.2-a+sve --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#define N 1024\n+unsigned char dst[N];\n+unsigned char in1[N];\n+unsigned char in2[N];\n+\n+/*\n+**  foo: \n+**\t...\n+**\tlsr\t(z[0-9]+\\.b), z[0-9]+\\.b, #1\n+**\tlsr\t(z[0-9]+\\.b), z[0-9]+\\.b, #1\n+**\tadd\t(z[0-9]+\\.b), (\\1, \\2|\\2, \\1)\n+**\torr\t(z[0-9]+)\\.d, z[0-9]+\\.d, z[0-9]+\\.d\n+**\tand\t(z[0-9]+\\.b), \\5\\.b, #0x1\n+**\tadd\tz0\\.b, (\\3, \\6|\\6, \\3)\n+**\t...\n+*/\n+void\n+foo ()\n+{\n+  for( int x = 0; x < N; x++ )\n+    dst[x] = (in1[x] + in2[x] + 1) >> 1;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tuunpklo\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tuunpkhi\\t} } } */"}, {"sha": "2ccdd0d353ebbbdeea44086b1954f8c893de1638", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr89007-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-2.c?ref=8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O -ftree-vectorize -march=armv8.2-a+sve --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#define N 1024\n+unsigned char dst[N];\n+unsigned char in1[N];\n+unsigned char in2[N];\n+\n+/*\n+**  foo: \n+**\t...\n+**\tlsr\t(z[0-9]+\\.b), z[0-9]+\\.b, #1\n+**\tlsr\t(z[0-9]+\\.b), z[0-9]+\\.b, #1\n+**\tadd\t(z[0-9]+\\.b), (\\1, \\2|\\2, \\1)\n+**\tand\t(z[0-9]+)\\.d, z[0-9]+\\.d, z[0-9]+\\.d\n+**\tand\t(z[0-9]+\\.b), \\5\\.b, #0x1\n+**\tadd\tz0\\.b, (\\3, \\6|\\6, \\3)\n+**\t...\n+*/\n+void\n+foo ()\n+{\n+  for( int x = 0; x < N; x++ )\n+    dst[x] = (in1[x] + in2[x]) >> 1;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tuunpklo\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tuunpkhi\\t} } } */"}, {"sha": "c9ad9e0eb9455901120c82917f08843eb21d9e73", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=8e03b21e84e4b6a3c806bb48bb5eceac1f7ed273", "patch": "@@ -1928,7 +1928,10 @@ vect_recog_mulhs_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n \t    TYPE avg = (TYPE) avg';\n \n   where NTYPE is no wider than half of TYPE.  Since only the bottom half\n-  of avg is used, all or part of the cast of avg' should become redundant.  */\n+  of avg is used, all or part of the cast of avg' should become redundant.\n+\n+  If there is no target support available, generate code to distribute rshift\n+  over plus and add a carry.  */\n \n static gimple *\n vect_recog_average_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n@@ -2032,9 +2035,20 @@ vect_recog_average_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n \n   /* Check for target support.  */\n   tree new_vectype = get_vectype_for_scalar_type (vinfo, new_type);\n-  if (!new_vectype\n-      || !direct_internal_fn_supported_p (ifn, new_vectype,\n-\t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n+  if (!new_vectype)\n+    return NULL;\n+\n+  bool fallback_p = false;\n+\n+  if (direct_internal_fn_supported_p (ifn, new_vectype, OPTIMIZE_FOR_SPEED))\n+    ;\n+  else if (TYPE_UNSIGNED (new_type)\n+\t   && optab_for_tree_code (RSHIFT_EXPR, new_vectype, optab_scalar)\n+\t   && optab_for_tree_code (PLUS_EXPR, new_vectype, optab_default)\n+\t   && optab_for_tree_code (BIT_IOR_EXPR, new_vectype, optab_default)\n+\t   && optab_for_tree_code (BIT_AND_EXPR, new_vectype, optab_default))\n+    fallback_p = true;\n+  else\n     return NULL;\n \n   /* The IR requires a valid vector type for the cast result, even though\n@@ -2043,11 +2057,53 @@ vect_recog_average_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n   if (!*type_out)\n     return NULL;\n \n-  /* Generate the IFN_AVG* call.  */\n   tree new_var = vect_recog_temp_ssa_var (new_type, NULL);\n   tree new_ops[2];\n   vect_convert_inputs (last_stmt_info, 2, new_ops, new_type,\n \t\t       unprom, new_vectype);\n+\n+  if (fallback_p)\n+    {\n+      /* As a fallback, generate code for following sequence:\n+\n+\t shifted_op0 = new_ops[0] >> 1;\n+\t shifted_op1 = new_ops[1] >> 1;\n+\t sum_of_shifted = shifted_op0 + shifted_op1;\n+\t unmasked_carry = new_ops[0] and/or new_ops[1];\n+\t carry = unmasked_carry & 1;\n+\t new_var = sum_of_shifted + carry;\n+      */\t \n+\n+      tree one_cst = build_one_cst (new_type);\n+      gassign *g;\n+\n+      tree shifted_op0 = vect_recog_temp_ssa_var (new_type, NULL);\n+      g = gimple_build_assign (shifted_op0, RSHIFT_EXPR, new_ops[0], one_cst);\n+      append_pattern_def_seq (last_stmt_info, g, new_vectype);\n+\n+      tree shifted_op1 = vect_recog_temp_ssa_var (new_type, NULL);\n+      g = gimple_build_assign (shifted_op1, RSHIFT_EXPR, new_ops[1], one_cst);\n+      append_pattern_def_seq (last_stmt_info, g, new_vectype);\n+\n+      tree sum_of_shifted = vect_recog_temp_ssa_var (new_type, NULL);\n+      g = gimple_build_assign (sum_of_shifted, PLUS_EXPR,\n+\t\t\t       shifted_op0, shifted_op1);\n+      append_pattern_def_seq (last_stmt_info, g, new_vectype);\n+      \n+      tree unmasked_carry = vect_recog_temp_ssa_var (new_type, NULL);\n+      tree_code c = (ifn == IFN_AVG_CEIL) ? BIT_IOR_EXPR : BIT_AND_EXPR;\n+      g = gimple_build_assign (unmasked_carry, c, new_ops[0], new_ops[1]);\n+      append_pattern_def_seq (last_stmt_info, g, new_vectype);\n+ \n+      tree carry = vect_recog_temp_ssa_var (new_type, NULL);\n+      g = gimple_build_assign (carry, BIT_AND_EXPR, unmasked_carry, one_cst);\n+      append_pattern_def_seq (last_stmt_info, g, new_vectype);\n+\n+      g = gimple_build_assign (new_var, PLUS_EXPR, sum_of_shifted, carry);\n+      return vect_convert_output (last_stmt_info, type, g, new_vectype);\n+    }\n+\n+  /* Generate the IFN_AVG* call.  */\n   gcall *average_stmt = gimple_build_call_internal (ifn, 2, new_ops[0],\n \t\t\t\t\t\t    new_ops[1]);\n   gimple_call_set_lhs (average_stmt, new_var);"}]}