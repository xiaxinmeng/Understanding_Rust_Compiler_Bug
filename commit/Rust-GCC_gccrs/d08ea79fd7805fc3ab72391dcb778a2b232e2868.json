{"sha": "d08ea79fd7805fc3ab72391dcb778a2b232e2868", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4ZWE3OWZkNzgwNWZjM2FiNzIzOTFkY2I3NzhhMmIyMzJlMjg2OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-30T10:40:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-30T10:40:07Z"}, "message": "(emit_reload_insns): Properly track what was reloaded into what register when...\n\n(emit_reload_insns): Properly track what was reloaded into what\nregister when what we reloaded was a hard register group.\n\nFrom-SVN: r3921", "tree": {"sha": "d057e59ec22ae676d315206dae261ff1d59a1e20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d057e59ec22ae676d315206dae261ff1d59a1e20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d08ea79fd7805fc3ab72391dcb778a2b232e2868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08ea79fd7805fc3ab72391dcb778a2b232e2868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d08ea79fd7805fc3ab72391dcb778a2b232e2868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08ea79fd7805fc3ab72391dcb778a2b232e2868/comments", "author": null, "committer": null, "parents": [{"sha": "9295e6afce10657a704512ddc34d5413f64cf06e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9295e6afce10657a704512ddc34d5413f64cf06e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9295e6afce10657a704512ddc34d5413f64cf06e"}], "stats": {"total": 40, "additions": 36, "deletions": 4}, "files": [{"sha": "b71cc9299a46c4877efe03ceab9198151d621873", "filename": "gcc/reload1.c", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08ea79fd7805fc3ab72391dcb778a2b232e2868/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08ea79fd7805fc3ab72391dcb778a2b232e2868/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d08ea79fd7805fc3ab72391dcb778a2b232e2868", "patch": "@@ -77,7 +77,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #endif\n \f\n /* During reload_as_needed, element N contains a REG rtx for the hard reg\n-   into which pseudo reg N has been reloaded (perhaps for a previous insn). */\n+   into which reg N has been reloaded (perhaps for a previous insn). */\n static rtx *reg_last_reload_reg;\n \n /* Elt N nonzero if reg_last_reload_reg[N] has been set in this insn\n@@ -3540,7 +3540,7 @@ order_regs_for_reload ()\n    and perhaps store insns after insns that modify the reloaded pseudo reg.\n \n    reg_last_reload_reg and reg_reloaded_contents keep track of\n-   which pseudo-registers are already available in reload registers.\n+   which registers are already available in reload registers.\n    We update these for the reloads that we perform,\n    as the insns are scanned.  */\n \n@@ -6134,14 +6134,32 @@ emit_reload_insns (insn)\n \t  if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG)\n \t    {\n \t      register int nregno = REGNO (reload_out[r]);\n+\t      int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n+\t\t\t : HARD_REGNO_NREGS (nregno,\n+\t\t\t\t\t     GET_MODE (reload_reg_rtx[r])));\n \n \t      spill_reg_store[i] = new_spill_reg_store[i];\n \t      reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n \n+\t      /* If NREGNO is a hard register, it may occupy more than\n+\t\t one register.  If it does, say what is in the \n+\t\t rest of the registers assuming that both registers\n+\t\t agree on how many words the object takes.  If not,\n+\t\t invalidate the subsequent registers.  */\n+\n+\t      if (nregno < FIRST_PSEUDO_REGISTER)\n+\t\tfor (k = 1; k < nnr; k++)\n+\t\t  reg_last_reload_reg[nregno + k]\n+\t\t    = (nr == nnr ? gen_rtx (REG, word_mode,\n+\t\t\t\t\t    REGNO (reload_reg_rtx[r]) + k)\n+\t\t       : 0);\n+\n+\t      /* Now do the inverse operation.  */\n \t      for (k = 0; k < nr; k++)\n \t\t{\n \t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n-\t\t    = nregno;\n+\t\t    = (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr ? nregno\n+\t\t       : nregno + k);\n \t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = insn;\n \t\t}\n \t    }\n@@ -6153,13 +6171,26 @@ emit_reload_insns (insn)\n \t\t       || GET_CODE (reload_in_reg[r]) == REG))\n \t    {\n \t      register int nregno;\n+\t      int nnr;\n+\n \t      if (GET_CODE (reload_in[r]) == REG)\n \t\tnregno = REGNO (reload_in[r]);\n \t      else\n \t\tnregno = REGNO (reload_in_reg[r]);\n \n+\t      nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n+\t\t     : HARD_REGNO_NREGS (nregno,\n+\t\t\t\t\t GET_MODE (reload_reg_rtx[r])));\n+\n \t      reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n \n+\t      if (nregno < FIRST_PSEUDO_REGISTER)\n+\t\tfor (k = 1; k < nnr; k++)\n+\t\t  reg_last_reload_reg[nregno + k]\n+\t\t    = (nr == nnr ? gen_rtx (REG, word_mode,\n+\t\t\t\t\t    REGNO (reload_reg_rtx[r]) + k)\n+\t\t       : 0);\n+\n \t      /* Unless we inherited this reload, show we haven't\n \t\t recently done a store.  */\n \t      if (! reload_inherited[r])\n@@ -6168,7 +6199,8 @@ emit_reload_insns (insn)\n \t      for (k = 0; k < nr; k++)\n \t\t{\n \t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n-\t\t    = nregno;\n+\t\t    = (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr ? nregno\n+\t\t       : nregno + k);\n \t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]]\n \t\t    = insn;\n \t\t}"}]}