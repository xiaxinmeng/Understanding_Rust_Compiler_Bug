{"sha": "39fb05d07106a838f2ea758b8ae10f9c94d2a515", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlmYjA1ZDA3MTA2YTgzOGYyZWE3NThiOGFlMTBmOWM5NGQyYTUxNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-13T16:22:06Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-13T16:22:06Z"}, "message": "cp-tree.h (lang_identifier): Remove class_value.\n\n\t* cp-tree.h (lang_identifier): Remove class_value.\n\t(IDENTIFIER_CLASS_VALUE): Remove.\n\t(pop_class_decls): Likewise.\n\t(init_search_processing): Likewise.\n\t* class.c (handle_using_decl): Use lookup_member, not\n\tIDENTIFIER_CLASS_VALUE.\n\t(restore_class_cache): New function, split out from ...\n\t(pushclass): ... here.  Do not call clear_identifier_class_values.\n\t(invalidate_class_lookup_cache): Do not clear\n\tIDENTIFIER_CLASS_VALUE.\n\t(popclass): Do not call pop_class_decls.\n\t(maybe_note_name_used_in_class): Do not save names looked up after\n\tthe class is complete.  Use lookup_member, not\n\tIDENTIFIER_CLASS_VALUE.\n\t* config-lang.in (gtfiles): Add $(srcdir)/cp/search.c.\n\t* decl.c (cxx_init_decl_processing): Do not call\n\tinit_search_processing.\n\t* method.c (do_build_copy_constructor): Remove unnecessary code.\n\t(do_build_assign_ref): Likewise.\n\t* name-lookup.c (pushdecl): Use lookup_member, not\n\tIDENTIFIER_CLASS_VALUE.\n\t(set_identifier_type_value_with_scope): Set TREE_TYPE on the\n\ttype_shadowed list.\n\t(poplevel_class): Do not restore IDENTIFIER_CLASS_VALUE.\n\t(push_class_binding): Do not set it.\n\t(clear_identifier_class_values): Remove.\n\t(push_class_level_binding): Do not set IDENTIFIER_CLASS_VALUE.\n\t(store_binding): Do not save it.\n\t(pop_from_top_level): Do not restore it.\n\t* name-lookup.h (cxx_saved_binding): Remove class_value.\n\t(clear_identifier_class_values): Remove.\n\t* ptree.c (cxx_print_identifier): Do not print\n\tIDENTIFIER_CLASS_VALUE.\n\t* search.c (search_obstack): Remove.\n\t(push_stack_level): Remove.\n\t(pop_stack_level): Remove.\n\t(search_level): Remove.\n\t(search_stack): Remove.\n\t(lookup_member): Don't check IDENTIFIER_CLASS_VALUE.\n\t(setup_class_bindings): Use IDENTIFIER_MARKED, not\n\tIDENTIFIER_CLASS_VALUE.\n\t(marked_identifiers): New variable.\n\t(push_class_decls): Clear IDENTIFIER_MARKED.\n\t(pop_class_decls): Don't call pop_search_level.\n\t(init_search_processing): Remove.\n\nFrom-SVN: r84629", "tree": {"sha": "4798d937d67deca799333982720732eda1d8cb1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4798d937d67deca799333982720732eda1d8cb1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39fb05d07106a838f2ea758b8ae10f9c94d2a515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39fb05d07106a838f2ea758b8ae10f9c94d2a515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39fb05d07106a838f2ea758b8ae10f9c94d2a515", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39fb05d07106a838f2ea758b8ae10f9c94d2a515/comments", "author": null, "committer": null, "parents": [{"sha": "6aa57acc95aa3225ff703c22e0359cff174031fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa57acc95aa3225ff703c22e0359cff174031fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa57acc95aa3225ff703c22e0359cff174031fa"}], "stats": {"total": 396, "additions": 141, "deletions": 255}, "files": [{"sha": "aaf5e25a85dfb1ed9d3d3808e1ca1bd6e8ee0485", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -1,3 +1,51 @@\n+2004-07-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (lang_identifier): Remove class_value.\n+\t(IDENTIFIER_CLASS_VALUE): Remove.\n+\t(pop_class_decls): Likewise.\n+\t(init_search_processing): Likewise.\n+\t* class.c (handle_using_decl): Use lookup_member, not\n+\tIDENTIFIER_CLASS_VALUE.\n+\t(restore_class_cache): New function, split out from ...\n+\t(pushclass): ... here.  Do not call clear_identifier_class_values.\n+\t(invalidate_class_lookup_cache): Do not clear\n+\tIDENTIFIER_CLASS_VALUE.\n+\t(popclass): Do not call pop_class_decls.\n+\t(maybe_note_name_used_in_class): Do not save names looked up after\n+\tthe class is complete.  Use lookup_member, not\n+\tIDENTIFIER_CLASS_VALUE.\n+\t* config-lang.in (gtfiles): Add $(srcdir)/cp/search.c.\n+\t* decl.c (cxx_init_decl_processing): Do not call\n+\tinit_search_processing.\n+\t* method.c (do_build_copy_constructor): Remove unnecessary code.\n+\t(do_build_assign_ref): Likewise.\n+\t* name-lookup.c (pushdecl): Use lookup_member, not\n+\tIDENTIFIER_CLASS_VALUE.\n+\t(set_identifier_type_value_with_scope): Set TREE_TYPE on the\n+\ttype_shadowed list.\n+\t(poplevel_class): Do not restore IDENTIFIER_CLASS_VALUE.\n+\t(push_class_binding): Do not set it.\n+\t(clear_identifier_class_values): Remove.\n+\t(push_class_level_binding): Do not set IDENTIFIER_CLASS_VALUE.\n+\t(store_binding): Do not save it.\n+\t(pop_from_top_level): Do not restore it.\n+\t* name-lookup.h (cxx_saved_binding): Remove class_value.\n+\t(clear_identifier_class_values): Remove.\n+\t* ptree.c (cxx_print_identifier): Do not print\n+\tIDENTIFIER_CLASS_VALUE.\n+\t* search.c (search_obstack): Remove.\n+\t(push_stack_level): Remove.\n+\t(pop_stack_level): Remove.\n+\t(search_level): Remove.\n+\t(search_stack): Remove.\n+\t(lookup_member): Don't check IDENTIFIER_CLASS_VALUE.\n+\t(setup_class_bindings): Use IDENTIFIER_MARKED, not\n+\tIDENTIFIER_CLASS_VALUE.\n+\t(marked_identifiers): New variable.\n+\t(push_class_decls): Clear IDENTIFIER_MARKED.\n+\t(pop_class_decls): Don't call pop_search_level.\n+\t(init_search_processing): Remove.\n+\n 2004-07-12  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (get_aggr_typedef): Remove."}, {"sha": "907503d51706895dd3a408835db364c02321d0e9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 44, "deletions": 59, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -1130,7 +1130,7 @@ handle_using_decl (tree using_decl, tree t)\n     /* Ignore base type this came from.  */\n     fdecl = BASELINK_FUNCTIONS (fdecl);\n \n-  old_value = IDENTIFIER_CLASS_VALUE (name);\n+  old_value = lookup_member (t, name, /*protect=*/0, /*want_type=*/false);\n   if (old_value)\n     {\n       if (is_overloaded_fn (old_value))\n@@ -5479,19 +5479,48 @@ init_class_processing (void)\n   ridpointers[(int) RID_PROTECTED] = access_protected_node;\n }\n \n+/* Restore the cached PREVIOUS_CLASS_LEVEL.  */\n+\n+static void\n+restore_class_cache (void)\n+{\n+  cp_class_binding *cb;\n+  tree type;\n+  size_t i;\n+\n+  /* We are re-entering the same class we just left, so we don't\n+     have to search the whole inheritance matrix to find all the\n+     decls to bind again.  Instead, we install the cached\n+     class_shadowed list and walk through it binding names.  */\n+  push_binding_level (previous_class_level);\n+  class_binding_level = previous_class_level;\n+  for (i = 0; \n+       (cb = VEC_iterate (cp_class_binding, \n+\t\t\t  previous_class_level->class_shadowed,\n+\t\t\t  i));\n+       ++i)\n+    {\n+      tree id;\n+\n+      id = cb->identifier;\n+      cb->base.previous = IDENTIFIER_BINDING (id);\n+      IDENTIFIER_BINDING (id) = &cb->base;\n+    }\n+  /* Restore IDENTIFIER_TYPE_VALUE.  */\n+  for (type = class_binding_level->type_shadowed; \n+       type; \n+       type = TREE_CHAIN (type))\n+    SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (type), TREE_TYPE (type));\n+}\n+\n /* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE as\n    appropriate for TYPE.\n \n    So that we may avoid calls to lookup_name, we cache the _TYPE\n    nodes of local TYPE_DECLs in the TREE_TYPE field of the name.\n \n    For multiple inheritance, we perform a two-pass depth-first search\n-   of the type lattice.  The first pass performs a pre-order search,\n-   marking types after the type has had its fields installed in\n-   the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely\n-   unmarks the marked types.  If a field or member function name\n-   appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of\n-   that name becomes `error_mark_node'.  */\n+   of the type lattice.  */\n \n void\n pushclass (tree type)\n@@ -5535,11 +5564,6 @@ pushclass (tree type)\n       invalidate_class_lookup_cache ();\n     }\n \n-  /* If we're about to enter a nested class, clear\n-     IDENTIFIER_CLASS_VALUE for the enclosing classes.  */\n-  if (current_class_depth > 1)\n-    clear_identifier_class_values ();\n-\n   if (!previous_class_level \n       || type != previous_class_level->this_entity\n       || current_class_depth > 1)\n@@ -5560,58 +5584,18 @@ pushclass (tree type)\n \t}\n     }\n   else\n-    {\n-      cp_class_binding *cb;\n-      size_t i;\n-\n-      /* We are re-entering the same class we just left, so we don't\n-\t have to search the whole inheritance matrix to find all the\n-\t decls to bind again.  Instead, we install the cached\n-\t class_shadowed list, and walk through it binding names and\n-\t setting up IDENTIFIER_TYPE_VALUEs.  */\n-      push_binding_level (previous_class_level);\n-      class_binding_level = previous_class_level;\n-      for (i = 0; \n-\t   (cb = VEC_iterate (cp_class_binding, \n-\t\t\t      previous_class_level->class_shadowed,\n-\t\t\t      i));\n-\t   ++i)\n-\t{\n-\t  tree id;\n-\t  tree type_decl;\n-\n-\t  id = cb->identifier;\n-\t  cb->base.previous = IDENTIFIER_BINDING (id);\n-\t  IDENTIFIER_BINDING (id) = &cb->base;\n-\t  type_decl = cb->base.value;\n-\t  if (!type_decl || TREE_CODE (type_decl) != TYPE_DECL)\n-\t    type_decl = cb->base.type;\n-\t  if (type_decl && TREE_CODE (type_decl) == TYPE_DECL)\n-\t    set_identifier_type_value (id, type_decl);\n-\t}\n-    }\n+    restore_class_cache ();\n   \n   cxx_remember_type_decls (CLASSTYPE_NESTED_UTDS (type));\n }\n \n-/* When we exit a toplevel class scope, we save the\n-   IDENTIFIER_CLASS_VALUEs so that we can restore them quickly if we\n-   reenter the class.  Here, we've entered some other class, so we\n-   must invalidate our cache.  */\n+/* When we exit a toplevel class scope, we save its binding level so\n+   that we can restore it quickly.  Here, we've entered some other\n+   class, so we must invalidate our cache.  */\n \n void\n invalidate_class_lookup_cache (void)\n {\n-  size_t i;\n-  cp_class_binding *cb;\n-  \n-  /* The IDENTIFIER_CLASS_VALUEs are no longer valid.  */\n-  for (i = 0;\n-       (cb = VEC_iterate (cp_class_binding, \n-\t\t\t  previous_class_level->class_shadowed, i));\n-       ++i)\n-    IDENTIFIER_CLASS_VALUE (cb->identifier) = NULL_TREE;\n-\n   previous_class_level = NULL;\n }\n  \n@@ -5622,7 +5606,6 @@ void\n popclass (void)\n {\n   poplevel_class ();\n-  pop_class_decls ();\n \n   current_class_depth--;\n   current_class_name = current_class_stack[current_class_depth].name;\n@@ -6448,12 +6431,14 @@ maybe_note_name_used_in_class (tree name, tree decl)\n   splay_tree names_used;\n \n   /* If we're not defining a class, there's nothing to do.  */\n-  if (innermost_scope_kind() != sk_class)\n+  if (!(innermost_scope_kind() == sk_class\n+\t&& TYPE_BEING_DEFINED (current_class_type)))\n     return;\n   \n   /* If there's already a binding for this NAME, then we don't have\n      anything to worry about.  */\n-  if (IDENTIFIER_CLASS_VALUE (name))\n+  if (lookup_member (current_class_type, name, \n+\t\t     /*protect=*/0, /*want_type=*/false))\n     return;\n \n   if (!current_class_stack[current_class_depth - 1].names_used)"}, {"sha": "48b88d7052d94edb6b1db09274868b34365e5fb2", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3 target-gperf\"\n \n-gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/search.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\""}, {"sha": "6e5dfdfa485c876400159dd6e4dfacaa0eadff6f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -170,7 +170,6 @@ struct lang_identifier GTY(())\n   struct c_common_identifier c_common;\n   cxx_binding *namespace_bindings;\n   cxx_binding *bindings;\n-  tree class_value;\n   tree class_template_info;\n   tree label_value;\n };\n@@ -340,14 +339,6 @@ typedef enum cp_id_kind\n #define IDENTIFIER_VALUE(NODE)\t\t\t\\\n   (IDENTIFIER_BINDING (NODE) ? IDENTIFIER_BINDING (NODE)->value : NULL)\n \n-/* If IDENTIFIER_CLASS_VALUE is set, then NODE is bound in the current\n-   class, and IDENTIFIER_CLASS_VALUE is the value binding.  This is\n-   just a pointer to the VALUE field of one of the bindings in the\n-   IDENTIFIER_BINDINGs list, so any time that this is non-NULL so is\n-   IDENTIFIER_BINDING.  */\n-#define IDENTIFIER_CLASS_VALUE(NODE) \\\n-  (LANG_IDENTIFIER_CAST (NODE)->class_value)\n-\n /* TREE_TYPE only indicates on local and class scope the current\n    type. For namespace scope, the presence of a type in any namespace\n    is indicated with global_type_node, and the real type behind must\n@@ -4013,9 +4004,7 @@ extern void get_pure_virtuals\t\t        (tree);\n extern void maybe_suppress_debug_info\t\t(tree);\n extern void note_debug_info_needed\t\t(tree);\n extern void push_class_decls\t\t\t(tree);\n-extern void pop_class_decls\t\t\t(void);\n extern void print_search_statistics\t\t(void);\n-extern void init_search_processing\t\t(void);\n extern void reinit_search_statistics\t\t(void);\n extern tree current_scope\t\t\t(void);\n extern int at_function_scope_p                  (void);"}, {"sha": "f5d4bd37a47ae55711e89650f01f1a3cbcbaf8b1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -3047,7 +3047,6 @@ cxx_init_decl_processing (void)\n \n   /* Perform other language dependent initializations.  */\n   init_class_processing ();\n-  init_search_processing ();\n   init_rtti_processing ();\n \n   if (flag_exceptions)"}, {"sha": "63fd1e7a10b7d50cea56ced69b6d3d53cdffac4a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -567,10 +567,6 @@ do_build_copy_constructor (tree fndecl)\n \t    {\n \t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n-\n-\t      /* True for duplicate members.  */\n-\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (field)) != field)\n-\t\tcontinue;\n \t    }\n \t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n \t\t   && ANON_AGGR_TYPE_P (t)\n@@ -673,10 +669,6 @@ do_build_assign_ref (tree fndecl)\n \t    {\n \t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n-\n-\t      /* True for duplicate members.  */\n-\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (field)) != field)\n-\t\tcontinue;\n \t    }\n \t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n \t\t   && ANON_AGGR_TYPE_P (t)"}, {"sha": "1511ff972892659e40f1df389d56a47354e9bd5e", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 22, "deletions": 87, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -997,9 +997,17 @@ pushdecl (tree x)\n \t      /* No shadow warnings for vars made for inlining.  */\n \t      && ! DECL_FROM_INLINE (x))\n \t    {\n-\t      if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE\n-\t\t       && current_class_ptr\n-\t\t       && !TREE_STATIC (name))\n+\t      tree member;\n+\n+\t      if (current_class_ptr)\n+\t\tmember = lookup_member (current_class_type,\n+\t\t\t\t\tname,\n+\t\t\t\t\t/*protect=*/0,\n+\t\t\t\t\t/*want_type=*/false);\n+\t      else\n+\t\tmember = NULL_TREE;\n+\t\t  \n+\t      if (member && !TREE_STATIC (member))\n \t\t{\n \t\t  /* Location of previous decl is not useful in this case.  */\n \t\t  warning (\"declaration of '%D' shadows a member of 'this'\",\n@@ -1777,6 +1785,7 @@ set_identifier_type_value_with_scope (tree id, tree decl, cxx_scope *b)\n       b->type_shadowed\n \t= tree_cons (id, old_type_value, b->type_shadowed);\n       type = decl ? TREE_TYPE (decl) : NULL_TREE;\n+      TREE_TYPE (b->type_shadowed) = type;\n     }\n   else\n     {\n@@ -2629,46 +2638,8 @@ poplevel_class (void)\n   timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (level != 0, 354);\n \n-  /* If we're leaving a toplevel class, don't bother to do the setting\n-     of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot\n-     shouldn't even be used when current_class_type isn't set, and second,\n-     if we don't touch it here, we're able to use the cache effect if the\n-     next time we're entering a class scope, it is the same class.  */\n-  if (current_class_depth != 1)\n-    {\n-      struct cp_binding_level* b;\n-      cp_class_binding* cb;\n-      size_t i;\n-\n-      /* Clear out our IDENTIFIER_CLASS_VALUEs.  */\n-      clear_identifier_class_values ();\n-\n-      /* Find the next enclosing class, and recreate\n-\t IDENTIFIER_CLASS_VALUEs appropriate for that class.  */\n-      b = level->level_chain;\n-      while (b && b->kind != sk_class)\n-\tb = b->level_chain;\n-\n-      if (b)\n-\tfor (i = 0;\n-\t     (cb = VEC_iterate (cp_class_binding, \n-\t\t\t\tb->class_shadowed, \n-\t\t\t\ti));\n-\t     ++i)\n-\t  {\n-\t    cxx_binding *binding;\n-            \n-\t    binding = IDENTIFIER_BINDING (cb->identifier);\n-\t    while (binding && binding->scope != b)\n-\t      binding = binding->previous;\n-\n-\t    if (binding)\n-\t      IDENTIFIER_CLASS_VALUE (cb->identifier) = binding->value;\n-\t  }\n-    }\n-  else\n-    /* Remember to save what IDENTIFIER's were bound in this scope so we\n-       can recover from cache misses.  */\n+  /* If we're leaving a toplevel class, cache its binding level.  */\n+  if (current_class_depth == 1)\n     previous_class_level = level;\n   for (shadowed = level->type_shadowed;\n        shadowed;\n@@ -2713,13 +2684,6 @@ push_class_binding (tree id, tree decl)\n     /* Create a new binding.  */\n     push_binding (id, decl, class_binding_level);\n \n-  /* Update the IDENTIFIER_CLASS_VALUE for this ID to be the\n-     class-level declaration.  Note that we do not use DECL here\n-     because of the possibility of the `struct stat' hack; if DECL is\n-     a class-name or enum-name we might prefer a field-name, or some\n-     such.  */\n-  IDENTIFIER_CLASS_VALUE (id) = IDENTIFIER_BINDING (id)->value;\n-\n   /* If this is a binding from a base class, mark it as such.  */\n   binding = IDENTIFIER_BINDING (id);\n   if (binding->value == decl && TREE_CODE (decl) != TREE_LIST)\n@@ -2746,24 +2710,6 @@ push_class_binding (tree id, tree decl)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result);\n }\n \n-/* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE\n-   for any names in enclosing classes.  */\n-\n-void\n-clear_identifier_class_values (void)\n-{\n-  size_t i;\n-  cp_class_binding *cb;\n-\n-  if (class_binding_level)\n-    for (i = 0;\n-\t (cb = VEC_iterate (cp_class_binding, \n-\t\t\t    class_binding_level->class_shadowed, \n-\t\t\t    i));\n-\t ++i)\n-      IDENTIFIER_CLASS_VALUE (cb->identifier) = NULL_TREE;\n-}\n-\n /* Make the declaration of X appear in CLASS scope.  */\n \n bool\n@@ -2821,9 +2767,9 @@ push_class_level_binding (tree name, tree x)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n   /* Check for invalid member names, if the class is being defined.\n-     This function is also used to restore IDENTIFIER_CLASS_VALUE,\n-     when reentering the class scope, and there is no point in\n-     checking again at that time.  */\n+     This function is also used to restore bindings when reentering\n+     the class scope, and there is no point in checking again at that\n+     time.  */\n   if (TYPE_BEING_DEFINED (current_class_type))\n     {\n       tree decl = x;\n@@ -2875,8 +2821,8 @@ push_class_level_binding (tree name, tree x)\n     }\n \n   /* If this declaration shadows a declaration from an enclosing\n-     class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n-     we leave this class.  Record the shadowed declaration here.  */\n+     class, then we will need to restore bindings when we leave this\n+     class.  Record the shadowed declaration here.  */\n   binding = IDENTIFIER_BINDING (name);\n   if (binding && binding->value)\n     {\n@@ -2922,7 +2868,6 @@ push_class_level_binding (tree name, tree x)\n \t     coming from a definition in the body of the class\n \t     itself.  */\n \t  INHERITED_VALUE_BINDING_P (binding) = 0;\n-\t  IDENTIFIER_CLASS_VALUE (name) = x;\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \t}\n     }\n@@ -3994,11 +3939,8 @@ qualified_lookup_using_namespace (tree name, tree scope,\n    If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n    Otherwise we prefer non-TYPE_DECLs.\n \n-   If NONCLASS is nonzero, we don't look for the NAME in class scope,\n-   using IDENTIFIER_CLASS_VALUE.  \n-\n-   If BLOCK_P is true, block scopes are examined; otherwise, they are\n-   skipped.  */\n+   If NONCLASS is nonzero, bindings in class scopes are ignored.  If\n+   BLOCK_P is false, bindings in block scopes are ignored.  */\n \n tree\n lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n@@ -4831,11 +4773,7 @@ store_binding (tree id, VEC(cxx_saved_binding) **old_bindings)\n {\n   cxx_saved_binding *saved;\n \n-  if (!id\n-      /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n-\t we have no IDENTIFIER_BINDING if we have left the class\n-\t scope, but cached the class-level declarations.  */\n-      || !(IDENTIFIER_BINDING (id) || IDENTIFIER_CLASS_VALUE (id)))\n+  if (!id || !IDENTIFIER_BINDING (id))\n     return;\n \n   if (IDENTIFIER_MARKED (id))\n@@ -4846,10 +4784,8 @@ store_binding (tree id, VEC(cxx_saved_binding) **old_bindings)\n   saved = VEC_safe_push (cxx_saved_binding, *old_bindings, NULL);\n   saved->identifier = id;\n   saved->binding = IDENTIFIER_BINDING (id);\n-  saved->class_value = IDENTIFIER_CLASS_VALUE (id);;\n   saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n   IDENTIFIER_BINDING (id) = NULL;\n-  IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n }\n \n static void\n@@ -4981,7 +4917,6 @@ pop_from_top_level (void)\n       tree id = saved->identifier;\n \n       IDENTIFIER_BINDING (id) = saved->binding;\n-      IDENTIFIER_CLASS_VALUE (id) = saved->class_value;\n       SET_IDENTIFIER_TYPE_VALUE (id, saved->real_type_value);\n     }\n "}, {"sha": "8d60f393ef30b210d195c4052850c3167a23333d", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -88,7 +88,6 @@ typedef struct cxx_saved_binding GTY(())\n   tree identifier;\n   /* The binding we're saving.  */\n   cxx_binding *binding;\n-  tree class_value;\n   tree real_type_value;\n } cxx_saved_binding;\n \n@@ -97,7 +96,6 @@ DEF_VEC_O(cxx_saved_binding);\n extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n extern void pop_binding (tree, tree);\n-extern void clear_identifier_class_values (void);\n extern tree constructor_name_full (tree);\n extern tree constructor_name (tree);\n extern bool constructor_name_p (tree, tree);"}, {"sha": "a74edc37dea44dfb3f85aceae78cdbe084d590b7", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -157,7 +157,6 @@ cxx_print_identifier (FILE *file, tree node, int indent)\n {\n   indent_to (file, indent);\n   cxx_print_binding (file, IDENTIFIER_NAMESPACE_BINDINGS (node), \"bindings\");\n-  print_node (file, \"class\", IDENTIFIER_CLASS_VALUE (node), indent + 4);\n   indent_to (file, indent);\n   cxx_print_binding (file, IDENTIFIER_BINDING (node), \"local bindings\");\n   print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);"}, {"sha": "460b24089042011d4517af1b683a5e5bde2475d6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 26, "deletions": 85, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fb05d07106a838f2ea758b8ae10f9c94d2a515/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=39fb05d07106a838f2ea758b8ae10f9c94d2a515", "patch": "@@ -36,39 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"stack.h\"\n \n-/* Obstack used for remembering decision points of breadth-first.  */\n-\n-static struct obstack search_obstack;\n-\n-/* Methods for pushing and popping objects to and from obstacks.  */\n-\n-struct stack_level *\n-push_stack_level (struct obstack *obstack, char *tp,/* Sony NewsOS 5.0 compiler doesn't like void * here.  */\n-\t\t  int size)\n-{\n-  struct stack_level *stack;\n-  obstack_grow (obstack, tp, size);\n-  stack = (struct stack_level *) ((char*)obstack_next_free (obstack) - size);\n-  obstack_finish (obstack);\n-  stack->obstack = obstack;\n-  stack->first = (tree *) obstack_base (obstack);\n-  stack->limit = obstack_room (obstack) / sizeof (tree *);\n-  return stack;\n-}\n-\n-struct stack_level *\n-pop_stack_level (struct stack_level *stack)\n-{\n-  struct stack_level *tem = stack;\n-  struct obstack *obstack = tem->obstack;\n-  stack = tem->prev;\n-  obstack_free (obstack, tem);\n-  return stack;\n-}\n-\n-#define search_level stack_level\n-static struct search_level *search_stack;\n-\n struct vbase_info \n {\n   /* The class dominating the hierarchy.  */\n@@ -90,9 +57,6 @@ static tree dfs_push_type_decls (tree, void *);\n static tree dfs_push_decls (tree, void *);\n static tree add_conversions (tree, void *);\n static int look_for_overrides_r (tree, tree);\n-static struct search_level *push_search_level (struct stack_level *,\n-\t\t\t\t\t       struct obstack *);\n-static struct search_level *pop_search_level (struct stack_level *);\n static tree bfs_walk (tree, tree (*) (tree, void *),\n \t\t      tree (*) (tree, int, void *), void *);\n static tree lookup_field_queue_p (tree, int, void *);\n@@ -108,26 +72,6 @@ static void setup_class_bindings (tree, int);\n static int template_self_reference_p (tree, tree);\n static tree dfs_get_pure_virtuals (tree, void *);\n \n-/* Allocate a level of searching.  */\n-\n-static struct search_level *\n-push_search_level (struct stack_level *stack, struct obstack *obstack)\n-{\n-  struct search_level tem;\n-\n-  tem.prev = stack;\n-  return push_stack_level (obstack, (char *)&tem, sizeof (tem));\n-}\n-\n-/* Discard a level of search allocation.  */\n-\n-static struct search_level *\n-pop_search_level (struct stack_level *obstack)\n-{\n-  struct search_level *stack = pop_stack_level (obstack);\n-\n-  return stack;\n-}\n \f\n /* Variables for gathering statistics.  */\n #ifdef GATHER_STATISTICS\n@@ -1263,17 +1207,6 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n       xbasetype = NULL_TREE;\n     }\n \n-  if (type == current_class_type && TYPE_BEING_DEFINED (type)\n-      && IDENTIFIER_CLASS_VALUE (name))\n-    {\n-      tree field = IDENTIFIER_CLASS_VALUE (name);\n-      if (! is_overloaded_fn (field)\n-\t  && ! (want_type && TREE_CODE (field) != TYPE_DECL))\n-\t/* We're in the scope of this class, and the value has already\n-\t   been looked up.  Just return the cached value.  */\n-\treturn field;\n-    }\n-\n   type = complete_type (type);\n   if (!basetype_path)\n     basetype_path = TYPE_BINFO (type);\n@@ -2099,6 +2032,11 @@ note_debug_info_needed (tree type)\n   dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp, 0);\n }\n \f\n+/* A vector of IDENTIFIER_NODEs that have been processed by\n+   setup_class_bindings.  */\n+\n+static GTY(()) VEC(tree) *marked_identifiers;\n+\n /* Subroutines of push_class_decls ().  */\n \n static void\n@@ -2109,9 +2047,12 @@ setup_class_bindings (tree name, int type_binding_p)\n \n   /* If we've already done the lookup for this declaration, we're\n      done.  */\n-  if (IDENTIFIER_CLASS_VALUE (name))\n+  if (IDENTIFIER_MARKED (name))\n     return;\n \n+  IDENTIFIER_MARKED (name) = 1;\n+  VEC_safe_push (tree, marked_identifiers, name);\n+\n   /* First, deal with the type binding.  */\n   if (type_binding_p)\n     {\n@@ -2161,8 +2102,13 @@ setup_class_bindings (tree name, int type_binding_p)\n \t    {\n \t      tree fns;\n \t      for (fns = value_binding; fns; fns = OVL_NEXT (fns))\n-\t\tif (IDENTIFIER_CLASS_VALUE (DECL_NAME (OVL_CURRENT (fns))))\n-\t\t  return;\n+\t\t{\n+\t\t  tree name = DECL_NAME (OVL_CURRENT (fns));\n+\t\t  if (IDENTIFIER_MARKED (name))\n+\t\t    return;\n+\t\t  IDENTIFIER_MARKED (name) = 1;\n+\t\t  VEC_safe_push (tree, marked_identifiers, name);\n+\t\t}\n \t    }\n \t  pushdecl_class_level (value_binding);\n \t}\n@@ -2245,7 +2191,8 @@ dfs_push_decls (tree binfo, void *data)\n void\n push_class_decls (tree type)\n {\n-  search_stack = push_search_level (search_stack, &search_obstack);\n+  tree id;\n+  size_t i;\n \n   if (!TYPE_BINFO (type))\n     /* This occurs when parsing an invalid declarator id where the\n@@ -2257,15 +2204,14 @@ push_class_decls (tree type)\n \n   /* Enter non-type declarations and unmark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_push_decls, marked_pushdecls_p, 0);\n-}\n \n-void\n-pop_class_decls (void)\n-{\n-  /* We haven't pushed a search level when dealing with cached classes,\n-     so we'd better not try to pop it.  */\n-  if (search_stack)\n-    search_stack = pop_search_level (search_stack);\n+  /* Clear the IDENTIFIER_MARKED bits.  */\n+  for (i = 0;\n+       (id = VEC_iterate (tree, marked_identifiers, i));\n+       ++i)\n+    IDENTIFIER_MARKED (id) = 0;\n+  if (marked_identifiers)\n+    VEC_truncate (tree, marked_identifiers, 0);\n }\n \n void\n@@ -2282,12 +2228,6 @@ print_search_statistics (void)\n #endif /* GATHER_STATISTICS */\n }\n \n-void\n-init_search_processing (void)\n-{\n-  gcc_obstack_init (&search_obstack);\n-}\n-\n void\n reinit_search_statistics (void)\n {\n@@ -2593,3 +2533,4 @@ original_binfo (tree binfo, tree here)\n   return result;\n }\n \n+#include \"gt-cp-search.h\""}]}