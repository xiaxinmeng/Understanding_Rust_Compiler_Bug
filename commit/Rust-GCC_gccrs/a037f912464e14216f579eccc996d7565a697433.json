{"sha": "a037f912464e14216f579eccc996d7565a697433", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAzN2Y5MTI0NjRlMTQyMTZmNTc5ZWNjYzk5NmQ3NTY1YTY5NzQzMw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2008-08-04T09:17:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-04T09:17:44Z"}, "message": "gprep.adb (Process_One_File): Call Prep.Preprocess with a Boolean variable...\n\n2008-08-04  Vincent Celier  <celier@adacore.com>\n\n\t* gprep.adb (Process_One_File): Call Prep.Preprocess with a Boolean\n\tvariable, but don't check the resulting value as it has no impact on\n\tthe processing.\n\t\n\t* opt.ads:\n\t(Generate_Processed_File): New Boolean flag, set to True in the compiler\n\twhen switch -gnateG is used.\n\t\n\t* prep.adb:\n\t(Preprocess): new Boolean out parameter Source_Modified. Set it to True\n\twhen the source is modified by the preprocessor and there is no\n\tpreprocessing errors.\n\t\n\t* prep.ads (Preprocess): new Boolean out parameter Source_Modified\n\t\n\t* sinput-l.adb:\n\t(Load_File): Output the result of preprocessing if the source text was\n\tmodified.\n\t\n\t* switch-c.adb (Scan_Front_End_Switches): Recognize switch -gnateG\n\t\n\t* switch-m.adb (Normalize_Compiler_Switches): Normalize switch -gnateG\n\t\n\t* ug_words: Add VMS equivalent for -gnateG\n\t\n\t* vms_data.ads:\n\tAdd VMS option /GENERATE_PROCESSED_SOURCE, equivalent to switch -gnateG\n\nFrom-SVN: r138590", "tree": {"sha": "3c10c3eda55b5d4bd88c5ae29f4d8dba412f8e42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c10c3eda55b5d4bd88c5ae29f4d8dba412f8e42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a037f912464e14216f579eccc996d7565a697433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a037f912464e14216f579eccc996d7565a697433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a037f912464e14216f579eccc996d7565a697433", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a037f912464e14216f579eccc996d7565a697433/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "762dffe7bfe92394589f61ab25f176eda510d710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/762dffe7bfe92394589f61ab25f176eda510d710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/762dffe7bfe92394589f61ab25f176eda510d710"}], "stats": {"total": 468, "additions": 302, "deletions": 166}, "files": [{"sha": "909e815cc27323a43e896ff4f1f2170ca9867a4f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -1,3 +1,33 @@\n+2008-08-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* gprep.adb (Process_One_File): Call Prep.Preprocess with a Boolean\n+\tvariable, but don't check the resulting value as it has no impact on\n+\tthe processing.\n+\t\n+\t* opt.ads:\n+\t(Generate_Processed_File): New Boolean flag, set to True in the compiler\n+\twhen switch -gnateG is used.\n+\t\n+\t* prep.adb:\n+\t(Preprocess): new Boolean out parameter Source_Modified. Set it to True\n+\twhen the source is modified by the preprocessor and there is no\n+\tpreprocessing errors.\n+\t\n+\t* prep.ads (Preprocess): new Boolean out parameter Source_Modified\n+\t\n+\t* sinput-l.adb:\n+\t(Load_File): Output the result of preprocessing if the source text was\n+\tmodified.\n+\t\n+\t* switch-c.adb (Scan_Front_End_Switches): Recognize switch -gnateG\n+\t\n+\t* switch-m.adb (Normalize_Compiler_Switches): Normalize switch -gnateG\n+\t\n+\t* ug_words: Add VMS equivalent for -gnateG\n+\t\n+\t* vms_data.ads:\n+\tAdd VMS option /GENERATE_PROCESSED_SOURCE, equivalent to switch -gnateG\n+\n 2008-08-04  Doug Rupp  <rupp@adacore.com>\n \n \t* gcc-interface/utils2.c:"}, {"sha": "44633b9c902c52dc260bd33dfc0b2e93aa7b1b00", "filename": "gcc/ada/gprep.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fgprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fgprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprep.adb?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -475,6 +475,9 @@ package body GPrep is\n       procedure Process_One_File is\n          Infile : Source_File_Index;\n \n+         Modified : Boolean;\n+         pragma Warnings (Off, Modified);\n+\n       begin\n          --  Create the output file (fails if this does not work)\n \n@@ -515,7 +518,7 @@ package body GPrep is\n \n          --  Preprocess the input file\n \n-         Prep.Preprocess;\n+         Prep.Preprocess (Modified);\n \n          --  In verbose mode, if there is no error, report it\n "}, {"sha": "68bf246919acf39ed1485565a7b6261ae12b4bf0", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -528,6 +528,11 @@ package Opt is\n    --  the name is of the form .xxx, then to name.xxx where name is the source\n    --  file name with extension stripped.\n \n+   Generate_Processed_File : Boolean := False;\n+   --  GNAT\n+   --  True when switch -gnateG is used. When True, create in a file\n+   --  <source>.prep, if the source is preprocessed.\n+\n    Generating_Code : Boolean := False;\n    --  GNAT\n    --  True if the frontend finished its work and has called the backend to"}, {"sha": "c1f4a5e780bc440eca5f1cf4e5a3d5068322e0c4", "filename": "gcc/ada/prep.adb", "status": "modified", "additions": 174, "deletions": 156, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprep.adb?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1043,10 +1043,12 @@ package body Prep is\n    -- Preprocess --\n    ----------------\n \n-   procedure Preprocess is\n+   procedure Preprocess (Source_Modified : out Boolean) is\n       Start_Of_Processing : Source_Ptr;\n       Cond                : Boolean;\n       Preprocessor_Line   : Boolean := False;\n+      No_Error_Found      : Boolean := True;\n+      Modified            : Boolean := False;\n \n       procedure Output (From, To : Source_Ptr);\n       --  Output the characters with indices From .. To in the buffer\n@@ -1118,75 +1120,21 @@ package body Prep is\n             --  Preprocessor line\n \n             if Token = Tok_Special and then Special_Character = '#' then\n-                  Preprocessor_Line := True;\n-                  Scan.all;\n-\n-                  case Token is\n-\n-                     --  #if\n-\n-                     when Tok_If =>\n-                        declare\n-                           If_Ptr : constant Source_Ptr := Token_Ptr;\n-\n-                        begin\n-                           Scan.all;\n-                           Cond := Expression (not Deleting);\n-\n-                           --  Check for an eventual \"then\"\n-\n-                           if Token = Tok_Then then\n-                              Scan.all;\n-                           end if;\n-\n-                           --  It is an error to have trailing characters after\n-                           --  the condition or \"then\".\n-\n-                           if Token /= Tok_End_Of_Line\n-                             and then Token /= Tok_EOF\n-                           then\n-                              Error_Msg\n-                                (\"extraneous text on preprocessor line\",\n-                                 Token_Ptr);\n-                              Go_To_End_Of_Line;\n-                           end if;\n-\n-                           declare\n-                              --  Set the initial state of this new \"#if\".\n-                              --  This must be done before incrementing the\n-                              --  Last of the table, otherwise function\n-                              --  Deleting does not report the correct value.\n-\n-                              New_State : constant Pp_State :=\n-                                (If_Ptr     => If_Ptr,\n-                                 Else_Ptr   => 0,\n-                                 Deleting   => Deleting or (not Cond),\n-                                 Match_Seen => Deleting or Cond);\n-\n-                           begin\n-                              Pp_States.Increment_Last;\n-                              Pp_States.Table (Pp_States.Last) := New_State;\n-                           end;\n-                        end;\n-\n-                     --  #elsif\n+               Modified := True;\n+               Preprocessor_Line := True;\n+               Scan.all;\n \n-                     when Tok_Elsif =>\n-                        Cond := False;\n+               case Token is\n \n-                        if Pp_States.Last = 0\n-                          or else Pp_States.Table (Pp_States.Last).Else_Ptr\n-                                                                        /= 0\n-                        then\n-                           Error_Msg (\"no IF for this ELSIF\", Token_Ptr);\n+                  --  #if\n \n-                        else\n-                           Cond :=\n-                             not Pp_States.Table (Pp_States.Last).Match_Seen;\n-                        end if;\n+                  when Tok_If =>\n+                     declare\n+                        If_Ptr : constant Source_Ptr := Token_Ptr;\n \n+                     begin\n                         Scan.all;\n-                        Cond := Expression (Cond);\n+                        Cond := Expression (not Deleting);\n \n                         --  Check for an eventual \"then\"\n \n@@ -1203,136 +1151,201 @@ package body Prep is\n                            Error_Msg\n                              (\"extraneous text on preprocessor line\",\n                               Token_Ptr);\n-\n+                           No_Error_Found := False;\n                            Go_To_End_Of_Line;\n                         end if;\n \n-                        --  Depending on the value of the condition, set the\n-                        --  new values of Deleting and Match_Seen.\n-                        if Pp_States.Last > 0 then\n-                           if Pp_States.Table (Pp_States.Last).Match_Seen then\n-                              Pp_States.Table (Pp_States.Last).Deleting :=\n-                                True;\n-                           else\n-                              if Cond then\n-                                 Pp_States.Table (Pp_States.Last).Match_Seen :=\n-                                   True;\n-                                 Pp_States.Table (Pp_States.Last).Deleting :=\n-                                   False;\n-                              end if;\n-                           end if;\n-                        end if;\n+                        declare\n+                           --  Set the initial state of this new \"#if\". This\n+                           --  must be done before incrementing the Last of\n+                           --  the table, otherwise function Deleting does\n+                           --  not report the correct value.\n \n-                     --  #else\n+                           New_State : constant Pp_State :=\n+                                         (If_Ptr     => If_Ptr,\n+                                          Else_Ptr   => 0,\n+                                          Deleting   => Deleting or (not Cond),\n+                                          Match_Seen => Deleting or Cond);\n \n-                     when Tok_Else =>\n-                        if Pp_States.Last = 0 then\n-                           Error_Msg (\"no IF for this ELSE\", Token_Ptr);\n+                        begin\n+                           Pp_States.Increment_Last;\n+                           Pp_States.Table (Pp_States.Last) := New_State;\n+                        end;\n+                     end;\n \n-                        elsif\n-                           Pp_States.Table (Pp_States.Last).Else_Ptr /= 0\n-                        then\n-                           Error_Msg (\"duplicate ELSE line\", Token_Ptr);\n-                        end if;\n+                  --  #elsif\n \n-                        --  Set the possibly new values of Deleting and\n-                        --  Match_Seen.\n+                  when Tok_Elsif =>\n+                     Cond := False;\n \n-                        if Pp_States.Last > 0 then\n-                           if Pp_States.Table (Pp_States.Last).Match_Seen then\n-                              Pp_States.Table (Pp_States.Last).Deleting :=\n-                                True;\n+                     if Pp_States.Last = 0\n+                       or else Pp_States.Table (Pp_States.Last).Else_Ptr /= 0\n+                     then\n+                        Error_Msg (\"no IF for this ELSIF\", Token_Ptr);\n+                        No_Error_Found := False;\n \n-                           else\n+                     else\n+                        Cond :=\n+                          not Pp_States.Table (Pp_States.Last).Match_Seen;\n+                     end if;\n+\n+                     Scan.all;\n+                     Cond := Expression (Cond);\n+\n+                     --  Check for an eventual \"then\"\n+\n+                     if Token = Tok_Then then\n+                        Scan.all;\n+                     end if;\n+\n+                     --  It is an error to have trailing characters after\n+                     --  the condition or \"then\".\n+\n+                     if Token /= Tok_End_Of_Line\n+                       and then Token /= Tok_EOF\n+                     then\n+                        Error_Msg\n+                          (\"extraneous text on preprocessor line\",\n+                           Token_Ptr);\n+                        No_Error_Found := False;\n+\n+                        Go_To_End_Of_Line;\n+                     end if;\n+\n+                     --  Depending on the value of the condition, set the\n+                     --  new values of Deleting and Match_Seen.\n+                     if Pp_States.Last > 0 then\n+                        if Pp_States.Table (Pp_States.Last).Match_Seen then\n+                           Pp_States.Table (Pp_States.Last).Deleting := True;\n+                        else\n+                           if Cond then\n                               Pp_States.Table (Pp_States.Last).Match_Seen :=\n                                 True;\n                               Pp_States.Table (Pp_States.Last).Deleting :=\n                                 False;\n                            end if;\n+                        end if;\n+                     end if;\n \n-                           --  Set the Else_Ptr to check for illegal #elsif\n-                           --  later.\n+                  --  #else\n \n-                           Pp_States.Table (Pp_States.Last).Else_Ptr :=\n-                             Token_Ptr;\n-                        end if;\n+                  when Tok_Else =>\n+                     if Pp_States.Last = 0 then\n+                        Error_Msg (\"no IF for this ELSE\", Token_Ptr);\n+                        No_Error_Found := False;\n \n-                        Scan.all;\n+                     elsif\n+                       Pp_States.Table (Pp_States.Last).Else_Ptr /= 0\n+                     then\n+                        Error_Msg (\"duplicate ELSE line\", Token_Ptr);\n+                        No_Error_Found := False;\n+                     end if;\n \n-                        --  It is an error to have characters after \"#else\"\n-                        if Token /= Tok_End_Of_Line\n-                          and then Token /= Tok_EOF\n-                        then\n-                           Error_Msg\n-                             (\"extraneous text on preprocessor line\",\n-                              Token_Ptr);\n-                           Go_To_End_Of_Line;\n-                        end if;\n+                     --  Set the possibly new values of Deleting and\n+                     --  Match_Seen.\n \n-                     --  #end if;\n+                     if Pp_States.Last > 0 then\n+                        if Pp_States.Table (Pp_States.Last).Match_Seen then\n+                           Pp_States.Table (Pp_States.Last).Deleting :=\n+                             True;\n \n-                     when Tok_End =>\n-                        if Pp_States.Last = 0 then\n-                           Error_Msg (\"no IF for this END\", Token_Ptr);\n+                        else\n+                           Pp_States.Table (Pp_States.Last).Match_Seen :=\n+                             True;\n+                           Pp_States.Table (Pp_States.Last).Deleting :=\n+                             False;\n                         end if;\n \n+                        --  Set the Else_Ptr to check for illegal #elsif\n+                        --  later.\n+\n+                        Pp_States.Table (Pp_States.Last).Else_Ptr :=\n+                          Token_Ptr;\n+                     end if;\n+\n+                     Scan.all;\n+\n+                     --  It is an error to have characters after \"#else\"\n+                     if Token /= Tok_End_Of_Line\n+                       and then Token /= Tok_EOF\n+                     then\n+                        Error_Msg\n+                          (\"extraneous text on preprocessor line\",\n+                           Token_Ptr);\n+                        No_Error_Found := False;\n+                        Go_To_End_Of_Line;\n+                     end if;\n+\n+                  --  #end if;\n+\n+                  when Tok_End =>\n+                     if Pp_States.Last = 0 then\n+                        Error_Msg (\"no IF for this END\", Token_Ptr);\n+                        No_Error_Found := False;\n+                     end if;\n+\n+                     Scan.all;\n+\n+                     if Token /= Tok_If then\n+                        Error_Msg (\"IF expected\", Token_Ptr);\n+                        No_Error_Found := False;\n+\n+                     else\n                         Scan.all;\n \n-                        if Token /= Tok_If then\n-                           Error_Msg (\"IF expected\", Token_Ptr);\n+                        if Token /= Tok_Semicolon then\n+                           Error_Msg (\"`;` Expected\", Token_Ptr);\n+                           No_Error_Found := False;\n \n                         else\n                            Scan.all;\n \n-                           if Token /= Tok_Semicolon then\n-                              Error_Msg (\"`;` Expected\", Token_Ptr);\n-\n-                           else\n-                              Scan.all;\n-\n-                              --  It is an error to have character after\n-                              --  \"#end if;\".\n-                              if Token /= Tok_End_Of_Line\n-                                and then Token /= Tok_EOF\n-                              then\n-                                 Error_Msg\n-                                   (\"extraneous text on preprocessor line\",\n-                                    Token_Ptr);\n-                              end if;\n+                           --  It is an error to have character after\n+                           --  \"#end if;\".\n+                           if Token /= Tok_End_Of_Line\n+                             and then Token /= Tok_EOF\n+                           then\n+                              Error_Msg\n+                                (\"extraneous text on preprocessor line\",\n+                                 Token_Ptr);\n+                              No_Error_Found := False;\n                            end if;\n                         end if;\n+                     end if;\n \n-                        --  In case of one of the errors above, skip the tokens\n-                        --  until the end of line is reached.\n+                     --  In case of one of the errors above, skip the tokens\n+                     --  until the end of line is reached.\n \n-                        Go_To_End_Of_Line;\n+                     Go_To_End_Of_Line;\n \n-                        --  Decrement the depth of the #if stack\n+                     --  Decrement the depth of the #if stack\n \n-                        if Pp_States.Last > 0 then\n-                           Pp_States.Decrement_Last;\n-                        end if;\n+                     if Pp_States.Last > 0 then\n+                        Pp_States.Decrement_Last;\n+                     end if;\n \n-                     --  Illegal preprocessor line\n+                  --  Illegal preprocessor line\n \n-                     when others =>\n-                        if Pp_States.Last = 0 then\n-                           Error_Msg (\"IF expected\", Token_Ptr);\n+                  when others =>\n+                     No_Error_Found := False;\n \n-                        elsif\n-                          Pp_States.Table (Pp_States.Last).Else_Ptr = 0\n-                        then\n-                           Error_Msg (\"IF, ELSIF, ELSE, or `END IF` expected\",\n-                                      Token_Ptr);\n+                     if Pp_States.Last = 0 then\n+                        Error_Msg (\"IF expected\", Token_Ptr);\n \n-                        else\n-                           Error_Msg (\"IF or `END IF` expected\", Token_Ptr);\n-                        end if;\n+                     elsif\n+                       Pp_States.Table (Pp_States.Last).Else_Ptr = 0\n+                     then\n+                        Error_Msg (\"IF, ELSIF, ELSE, or `END IF` expected\",\n+                                   Token_Ptr);\n+\n+                     else\n+                        Error_Msg (\"IF or `END IF` expected\", Token_Ptr);\n+                     end if;\n \n-                        --  Skip to the end of this illegal line\n+                     --  Skip to the end of this illegal line\n \n-                        Go_To_End_Of_Line;\n-                  end case;\n+                     Go_To_End_Of_Line;\n+               end case;\n \n             --  Not a preprocessor line\n \n@@ -1352,6 +1365,8 @@ package body Prep is\n                      if Token = Tok_Special\n                        and then Special_Character = '$'\n                      then\n+                        Modified := True;\n+\n                         declare\n                            Dollar_Ptr : constant Source_Ptr := Token_Ptr;\n                            Symbol     : Symbol_Id;\n@@ -1449,7 +1464,10 @@ package body Prep is\n \n       for Level in reverse 1 .. Pp_States.Last loop\n          Error_Msg (\"no `END IF` for this IF\", Pp_States.Table (Level).If_Ptr);\n+         No_Error_Found := False;\n       end loop;\n+\n+      Source_Modified := No_Error_Found and Modified;\n    end Preprocess;\n \n end Prep;"}, {"sha": "0f595e64dfbd6bf2f19ec5782bc43c8839051bbe", "filename": "gcc/ada/prep.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fprep.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fprep.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprep.ads?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2002-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -106,9 +106,10 @@ package Prep is\n    --  Parse the definition file. The definition file must have already been\n    --  loaded and the scanner initialized.\n \n-   procedure Preprocess;\n+   procedure Preprocess (Source_Modified : out Boolean);\n    --  Preprocess the input file. The input file must have already been loaded\n-   --  and the scanner initialized.\n+   --  and the scanner initialized. Source_Modified is set to True iff the\n+   --  preprocessor modified the source text.\n \n    procedure Check_Command_Line_Symbol_Definition\n      (Definition  : String;"}, {"sha": "8bb6778fbd77e2fc8cf6573ae172228017d72afe", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -28,6 +28,8 @@ with Atree;    use Atree;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n+with Fname;    use Fname;\n+with Hostparm;\n with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n@@ -39,6 +41,8 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with System;   use System;\n \n+with System.OS_Lib; use System.OS_Lib;\n+\n with Unchecked_Conversion;\n \n package body Sinput.L is\n@@ -319,7 +323,7 @@ package body Sinput.L is\n       --  source will be the last created, and we will be able to replace it\n       --  and modify Hi without stepping on another buffer.\n \n-      if T = Osint.Source then\n+      if T = Osint.Source and then not Is_Internal_File_Name (N) then\n          Prepare_To_Preprocess\n            (Source => N, Preprocessing_Needed => Preprocessing_Needed);\n       end if;\n@@ -475,6 +479,8 @@ package body Sinput.L is\n                --  Saved state of the Style_Check flag (which needs to be\n                --  temporarily set to False during preprocessing, see below).\n \n+               Modified : Boolean;\n+\n             begin\n                --  If this is the first time we preprocess a source, allocate\n                --  the preprocessing buffer.\n@@ -512,7 +518,7 @@ package body Sinput.L is\n                Save_Style_Check := Opt.Style_Check;\n                Opt.Style_Check := False;\n \n-               Preprocess;\n+               Preprocess (Modified);\n \n                --  Reset the scanner to its standard behavior, and restore the\n                --  Style_Checks flag.\n@@ -531,6 +537,54 @@ package body Sinput.L is\n                   return No_Source_File;\n \n                else\n+                  --  Output the result of the preprocessing, if requested and\n+                  --  the source has been modified by the preprocessing.\n+\n+                  if Generate_Processed_File and then Modified then\n+                     declare\n+                        FD     : File_Descriptor;\n+                        NB     : Integer;\n+                        Status : Boolean;\n+\n+                     begin\n+                        Get_Name_String (N);\n+\n+                        if Hostparm.OpenVMS then\n+                           Add_Str_To_Name_Buffer (\"_prep\");\n+                        else\n+                           Add_Str_To_Name_Buffer (\".prep\");\n+                        end if;\n+\n+                        Delete_File (Name_Buffer (1 .. Name_Len), Status);\n+\n+                        FD :=\n+                          Create_New_File (Name_Buffer (1 .. Name_Len), Text);\n+\n+                        Status := FD /= Invalid_FD;\n+\n+                        if Status then\n+                           NB :=\n+                             Write\n+                               (FD,\n+                                Prep_Buffer (1)'Address,\n+                                Integer (Prep_Buffer_Last));\n+                           Status := NB = Integer (Prep_Buffer_Last);\n+                        end if;\n+\n+                        if Status then\n+                           Close (FD, Status);\n+                        end if;\n+\n+                        if not Status then\n+                           Errout.Error_Msg\n+                             (\"could not write processed file \"\"\" &\n+                              Name_Buffer (1 .. Name_Len) & '\"',\n+                              Lo);\n+                           return No_Source_File;\n+                        end if;\n+                     end;\n+                  end if;\n+\n                   --  Set the new value of Hi\n \n                   Hi := Lo + Source_Ptr (Prep_Buffer_Last);"}, {"sha": "63a1a6d83aae67daa6e7784f4ef9940220c50d2f", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -371,6 +371,16 @@ package body Switch.C is\n                      Full_Path_Name_For_Brief_Errors := True;\n                      return;\n \n+                  --  -gnateG (save preprocessor output)\n+\n+                  when 'G' =>\n+                     if Ptr < Max then\n+                        Bad_Switch (Switch_Chars);\n+                     end if;\n+\n+                     Generate_Processed_File := True;\n+                     Ptr := Ptr + 1;\n+\n                   --  -gnateI (index of unit in multi-unit source)\n \n                   when 'I' =>"}, {"sha": "7be075d98962ab3d2327cfa60fbcbc0b400ca6b6", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -267,14 +267,16 @@ package body Switch.M is\n \n                   when 'e' =>\n \n-                     --  Only -gnateD and -gnatep= need storing in ALI file\n+                     --  Store -gnateD, -gnatep= and -gnateG in the ALI file.\n+                     --  The other -gnate switches do not need to be stored.\n \n                      Storing (First_Stored) := 'e';\n                      Ptr := Ptr + 1;\n \n                      if Ptr > Max\n                        or else (Switch_Chars (Ptr) /= 'D'\n-                                  and then Switch_Chars (Ptr) /= 'p')\n+                                 and then Switch_Chars (Ptr) /= 'G'\n+                                 and then Switch_Chars (Ptr) /= 'p')\n                      then\n                         Last := 0;\n                         return;\n@@ -292,7 +294,7 @@ package body Switch.M is\n \n                      --  Processing for -gnatep=\n \n-                     else\n+                     elsif Switch_Chars (Ptr) = 'p' then\n                         Ptr := Ptr + 1;\n \n                         if Ptr = Max then\n@@ -316,6 +318,9 @@ package body Switch.M is\n                              Switch_Chars (Ptr .. Max);\n                            Add_Switch_Component (To_Store);\n                         end;\n+\n+                     elsif Switch_Chars (Ptr) = 'G' then\n+                        Add_Switch_Component (\"-gnateG\");\n                      end if;\n \n                      return;"}, {"sha": "2cab6da2deaacc0852a1d52101ab194a06164401", "filename": "gcc/ada/ug_words", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fug_words", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fug_words", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fug_words?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -61,6 +61,7 @@ gcc -c          ^ GNAT COMPILE\n -gnatec         ^ /CONFIGURATION_PRAGMAS_FILE\n -gnateD         ^ /SYMBOL_PREPROCESSING\n -gnatef         ^ /FULL_PATH_IN_BRIEF_MESSAGES\n+-gnateG         ^ /GENERATE_PROCESSED_SOURCE\n -gnatem         ^ /MAPPING_FILE\n -gnatep         ^ /DATA_PREPROCESSING\n -gnatE          ^ /CHECKS=ELABORATION"}, {"sha": "63ba1df8d05c6c397f97bdaf1e416117ca3386a8", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a037f912464e14216f579eccc996d7565a697433/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=a037f912464e14216f579eccc996d7565a697433", "patch": "@@ -1526,6 +1526,14 @@ package VMS_Data is\n    --   /VERBOSE), then error lines start with the full path name of the\n    --   project file, rather than its simple file name.\n \n+   S_GCC_Generate : aliased constant S := \"/GENERATE_PROCESSED_SOURCE \"    &\n+                                             \"-gnateG\";\n+   --        /NOGENERATE_PROCESSED_SOURCE (D)\n+   --        /GENERATE_PROCESSED_SOURCE\n+   --\n+   --        Generate a file <source>_prep if the integrated preprocessing\n+   --        is modifying the source text.\n+\n    S_GCC_GNAT    : aliased constant S := \"/GNAT_INTERNAL \"                 &\n                                             \"-gnatg\";\n    --        /NOGNAT_INTERNAL (D)\n@@ -3311,6 +3319,7 @@ package VMS_Data is\n                      S_GCC_Follow  'Access,\n                      S_GCC_Force   'Access,\n                      S_GCC_Full    'Access,\n+                     S_GCC_Generate'Access,\n                      S_GCC_GNAT    'Access,\n                      S_GCC_Help    'Access,\n                      S_GCC_Ident   'Access,"}]}