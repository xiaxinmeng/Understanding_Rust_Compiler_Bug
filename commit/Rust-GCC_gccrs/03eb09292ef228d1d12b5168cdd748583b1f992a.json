{"sha": "03eb09292ef228d1d12b5168cdd748583b1f992a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNlYjA5MjkyZWYyMjhkMWQxMmI1MTY4Y2RkNzQ4NTgzYjFmOTkyYQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-08-28T08:26:13Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-12-01T10:43:25Z"}, "message": "Add if-chain to switch conversion pass.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/14799\n\tPR ipa/88702\n\t* Makefile.in: Add gimple-if-to-switch.o.\n\t* dbgcnt.def (DEBUG_COUNTER): Add new debug counter.\n\t* passes.def: Include new pass_if_to_switch pass.\n\t* timevar.def (TV_TREE_IF_TO_SWITCH): New timevar.\n\t* tree-pass.h (make_pass_if_to_switch): New.\n\t* tree-ssa-reassoc.c (struct operand_entry): Move to the header.\n\t(dump_range_entry): Move to header file.\n\t(debug_range_entry): Likewise.\n\t(no_side_effect_bb): Make it global.\n\t* tree-switch-conversion.h (simple_cluster::simple_cluster):\n\tAdd inline for couple of functions in order to prevent error\n\tabout multiple defined symbols.\n\t* gimple-if-to-switch.cc: New file.\n\t* tree-ssa-reassoc.h: New file.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/14799\n\tPR ipa/88702\n\t* gcc.dg/tree-ssa/pr96480.c: Disable if-to-switch conversion.\n\t* gcc.dg/tree-ssa/reassoc-32.c: Likewise.\n\t* g++.dg/tree-ssa/if-to-switch-1.C: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-1.c: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-2.c: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-3.c: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-4.c: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-5.c: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-6.c: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-7.c: New test.\n\t* gcc.dg/tree-ssa/if-to-switch-8.c: New test.", "tree": {"sha": "8e41919c16c723251463ac59666965cbd82e0f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e41919c16c723251463ac59666965cbd82e0f6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03eb09292ef228d1d12b5168cdd748583b1f992a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03eb09292ef228d1d12b5168cdd748583b1f992a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03eb09292ef228d1d12b5168cdd748583b1f992a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03eb09292ef228d1d12b5168cdd748583b1f992a/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58f71a34c68711c4432b45086bfcccb78be7ace5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f71a34c68711c4432b45086bfcccb78be7ace5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58f71a34c68711c4432b45086bfcccb78be7ace5"}], "stats": {"total": 898, "additions": 866, "deletions": 32}, "files": [{"sha": "16be66fefc6bce12e010dcc191dcfde11340f30d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -1364,6 +1364,7 @@ OBJS = \\\n \tgimple-array-bounds.o \\\n \tgimple-builder.o \\\n \tgimple-expr.o \\\n+\tgimple-if-to-switch.o \\\n \tgimple-iterator.o \\\n \tgimple-fold.o \\\n \tgimple-laddress.o \\"}, {"sha": "c0744b23f65f4559b7b29c23e977fc151e041994", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -170,6 +170,7 @@ DEBUG_COUNTER (if_after_combine)\n DEBUG_COUNTER (if_after_reload)\n DEBUG_COUNTER (if_conversion)\n DEBUG_COUNTER (if_conversion_tree)\n+DEBUG_COUNTER (if_to_switch)\n DEBUG_COUNTER (ipa_cp_bits)\n DEBUG_COUNTER (ipa_cp_values)\n DEBUG_COUNTER (ipa_cp_vr)"}, {"sha": "d132064fb9b823623dd78d4350d019010f37655a", "filename": "gcc/gimple-if-to-switch.cc", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Fgimple-if-to-switch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Fgimple-if-to-switch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-if-to-switch.cc?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,566 @@\n+/* If-elseif-else to switch conversion pass\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Algorithm of the pass runs in the following steps:\n+   a) We walk basic blocks in DOMINATOR order so that we first reach\n+      a first condition of a future switch.\n+   b) We follow false edges of a if-else-chain and we record chain\n+      of GIMPLE conditions.  These blocks are only used for comparison\n+      of a common SSA_NAME and we do not allow any side effect.\n+   c) We remove all basic blocks (except first) of such chain and\n+      GIMPLE switch replaces the condition in the first basic block.\n+   d) We move all GIMPLE statements in the removed blocks into the\n+      first one.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-dfa.h\"\n+#include \"tree-cfgcleanup.h\"\n+#include \"alias.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"diagnostic.h\"\n+#include \"cfghooks.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"cfganal.h\"\n+#include \"dbgcnt.h\"\n+#include \"target.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-switch-conversion.h\"\n+#include \"tree-ssa-reassoc.h\"\n+\n+using namespace tree_switch_conversion;\n+\n+struct condition_info\n+{\n+  typedef vec<std::pair<gphi *, tree>> mapping_vec;\n+\n+  condition_info (gcond *cond): m_cond (cond), m_bb (gimple_bb (cond)),\n+    m_forwarder_bb (NULL), m_ranges (), m_true_edge (NULL), m_false_edge (NULL),\n+    m_true_edge_phi_mapping (), m_false_edge_phi_mapping ()\n+  {\n+    m_ranges.create (0);\n+  }\n+\n+  /* Recond PHI mapping for an original edge E and save these into\n+     vector VEC.  */\n+  void record_phi_mapping (edge e, mapping_vec *vec);\n+\n+  gcond *m_cond;\n+  basic_block m_bb;\n+  basic_block m_forwarder_bb;\n+  vec<range_entry> m_ranges;\n+  edge m_true_edge;\n+  edge m_false_edge;\n+  mapping_vec m_true_edge_phi_mapping;\n+  mapping_vec m_false_edge_phi_mapping;\n+};\n+\n+/* Recond PHI mapping for an original edge E and save these into vector VEC.  */\n+\n+void\n+condition_info::record_phi_mapping (edge e, mapping_vec *vec)\n+{\n+  for (gphi_iterator gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+      if (!virtual_operand_p (gimple_phi_result (phi)))\n+\t{\n+\t  tree arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t  vec->safe_push (std::make_pair (phi, arg));\n+\t}\n+    }\n+}\n+\n+/* Master structure for one if to switch conversion candidate.  */\n+\n+struct if_chain\n+{\n+  /* Default constructor.  */\n+  if_chain (): m_entries ()\n+  {\n+    m_entries.create (2);\n+  }\n+\n+  /* Default destructor.  */\n+  ~if_chain ()\n+  {\n+    m_entries.release ();\n+  }\n+\n+  /* Verify that all case ranges do not overlap.  */\n+  bool check_non_overlapping_cases ();\n+\n+  /* Return true when the switch can be expanded with a jump table or\n+     a bit test (at least partially).  */\n+  bool is_beneficial ();\n+\n+  /* If chain entries.  */\n+  vec<condition_info *> m_entries;\n+};\n+\n+/* Compare two case ranges by minimum value.  */\n+\n+static int\n+range_cmp (const void *a, const void *b)\n+{\n+  const range_entry *re1 = *(const range_entry * const *) a;\n+  const range_entry *re2 = *(const range_entry * const *) b;\n+\n+  return tree_int_cst_compare (re1->low, re2->low);\n+}\n+\n+/* Verify that all case ranges do not overlap.  */\n+\n+bool\n+if_chain::check_non_overlapping_cases ()\n+{\n+  auto_vec<range_entry *> all_ranges;\n+  for (unsigned i = 0; i < m_entries.length (); i++)\n+    for (unsigned j = 0; j < m_entries[i]->m_ranges.length (); j++)\n+      all_ranges.safe_push (&m_entries[i]->m_ranges[j]);\n+\n+  all_ranges.qsort (range_cmp);\n+\n+  for (unsigned i = 0; i < all_ranges.length () - 1; i++)\n+    {\n+      range_entry *left = all_ranges[i];\n+      range_entry *right = all_ranges[i + 1];\n+      if (tree_int_cst_le (left->low, right->low)\n+\t  && tree_int_cst_le (right->low, left->high))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Compare clusters by minimum value.  */\n+\n+static int\n+cluster_cmp (const void *a, const void *b)\n+{\n+  simple_cluster *sc1 = *(simple_cluster * const *) a;\n+  simple_cluster *sc2 = *(simple_cluster * const *) b;\n+\n+  return tree_int_cst_compare (sc1->get_low (), sc2->get_high ());\n+}\n+\n+/* Dump constructed CLUSTERS with prefix MESSAGE.  */\n+\n+static void\n+dump_clusters (vec<cluster *> *clusters, const char *message)\n+{\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; %s: \", message);\n+      for (unsigned i = 0; i < clusters->length (); i++)\n+\t(*clusters)[i]->dump (dump_file, dump_flags & TDF_DETAILS);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Return true when the switch can be expanded with a jump table or\n+   a bit test (at least partially).  */\n+\n+bool\n+if_chain::is_beneficial ()\n+{\n+  profile_probability prob = profile_probability::uninitialized ();\n+\n+  auto_vec<cluster *> clusters;\n+  clusters.create (m_entries.length ());\n+\n+  for (unsigned i = 0; i < m_entries.length (); i++)\n+    {\n+      condition_info *info = m_entries[i];\n+      for (unsigned j = 0; j < info->m_ranges.length (); j++)\n+\t{\n+\t  range_entry *range = &info->m_ranges[j];\n+\t  basic_block bb = info->m_true_edge->dest;\n+\t  bool has_forwarder = !info->m_true_edge_phi_mapping.is_empty ();\n+\t  clusters.safe_push (new simple_cluster (range->low, range->high,\n+\t\t\t\t\t\t  NULL_TREE, bb, prob,\n+\t\t\t\t\t\t  has_forwarder));\n+\t}\n+    }\n+\n+  /* Sort clusters and merge them.  */\n+  auto_vec<cluster *> filtered_clusters;\n+  filtered_clusters.create (16);\n+  clusters.qsort (cluster_cmp);\n+  simple_cluster *left = static_cast<simple_cluster *> (clusters[0]);\n+  filtered_clusters.safe_push (left);\n+\n+  for (unsigned i = 1; i < clusters.length (); i++)\n+    {\n+      simple_cluster *right = static_cast<simple_cluster *> (clusters[i]);\n+      tree type = TREE_TYPE (left->get_low ());\n+      if (!left->m_has_forward_bb\n+\t  && !right->m_has_forward_bb\n+\t  && left->m_case_bb == right->m_case_bb)\n+\t{\n+\t  if (wi::eq_p (wi::to_wide (right->get_low ()) - wi::to_wide\n+\t\t\t(left->get_high ()), wi::one (TYPE_PRECISION (type))))\n+\t    {\n+\t      left->set_high (right->get_high ());\n+\t      continue;\n+\t    }\n+\t}\n+\n+      left = static_cast<simple_cluster *> (clusters[i]);\n+      filtered_clusters.safe_push (left);\n+    }\n+\n+  dump_clusters (&filtered_clusters, \"Canonical GIMPLE case clusters\");\n+\n+  vec<cluster *> output\n+    = jump_table_cluster::find_jump_tables (filtered_clusters);\n+  bool r = output.length () < filtered_clusters.length ();\n+  if (r)\n+    dump_clusters (&output, \"JT can be built\");\n+  output.release ();\n+  if (r)\n+    return true;\n+\n+  output = bit_test_cluster::find_bit_tests (filtered_clusters);\n+  r = output.length () < filtered_clusters.length ();\n+  if (r)\n+    dump_clusters (&output, \"BT can be built\");\n+  output.release ();\n+  return r;\n+}\n+\n+/* Build case label with MIN and MAX values of a given basic block DEST.  */\n+\n+static tree\n+build_case_label (tree index_type, tree min, tree max, basic_block dest)\n+{\n+  if (min != NULL_TREE && index_type != TREE_TYPE (min))\n+    min = fold_convert (index_type, min);\n+  if (max != NULL_TREE && index_type != TREE_TYPE (max))\n+    max = fold_convert (index_type, max);\n+\n+  tree label = gimple_block_label (dest);\n+  return build_case_label (min, min == max ? NULL_TREE : max, label);\n+}\n+\n+/* Compare two integer constants.  */\n+\n+static int\n+label_cmp (const void *a, const void *b)\n+{\n+  const_tree l1 = *(const const_tree *) a;\n+  const_tree l2 = *(const const_tree *) b;\n+\n+  return tree_int_cst_compare (CASE_LOW (l1), CASE_LOW (l2));\n+}\n+\n+/* Convert a given if CHAIN into a switch GIMPLE statement.  */\n+\n+static void\n+convert_if_conditions_to_switch (if_chain *chain)\n+{\n+  if (!dbg_cnt (if_to_switch))\n+    return;\n+\n+  auto_vec<tree> labels;\n+  unsigned entries = chain->m_entries.length ();\n+  condition_info *first_cond = chain->m_entries[0];\n+  condition_info *last_cond = chain->m_entries[entries - 1];\n+\n+  edge default_edge = last_cond->m_false_edge;\n+  basic_block default_bb = default_edge->dest;\n+\n+  gimple_stmt_iterator gsi = gsi_for_stmt (first_cond->m_cond);\n+  tree index_type = TREE_TYPE (first_cond->m_ranges[0].exp);\n+  for (unsigned i = 0; i < entries; i++)\n+    {\n+      condition_info *info = chain->m_entries[i];\n+      basic_block case_bb = info->m_true_edge->dest;\n+\n+      /* Create a forwarder block if needed.  */\n+      if (!info->m_true_edge_phi_mapping.is_empty ())\n+\t{\n+\t  info->m_forwarder_bb = split_edge (info->m_true_edge);\n+\t  case_bb = info->m_forwarder_bb;\n+\t}\n+\n+      for (unsigned j = 0; j < info->m_ranges.length (); j++)\n+\tlabels.safe_push (build_case_label (index_type,\n+\t\t\t\t\t    info->m_ranges[j].low,\n+\t\t\t\t\t    info->m_ranges[j].high,\n+\t\t\t\t\t    case_bb));\n+      default_bb = info->m_false_edge->dest;\n+\n+      if (i == 0)\n+\t{\n+\t  remove_edge (first_cond->m_true_edge);\n+\t  remove_edge (first_cond->m_false_edge);\n+\t}\n+      else\n+\tdelete_basic_block (info->m_bb);\n+\n+      make_edge (first_cond->m_bb, case_bb, 0);\n+    }\n+\n+  labels.qsort (label_cmp);\n+\n+  edge e = find_edge (first_cond->m_bb, default_bb);\n+  if (e == NULL)\n+    e = make_edge (first_cond->m_bb, default_bb, 0);\n+  gswitch *s\n+    = gimple_build_switch (first_cond->m_ranges[0].exp,\n+\t\t\t   build_case_label (index_type, NULL_TREE,\n+\t\t\t\t\t     NULL_TREE, default_bb),\n+\t\t\t   labels);\n+\n+  gsi_remove (&gsi, true);\n+  gsi_insert_before (&gsi, s, GSI_NEW_STMT);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Expanded into a new gimple STMT: \");\n+      print_gimple_stmt (dump_file, s, 0, TDF_SLIM);\n+      putc ('\\n', dump_file);\n+    }\n+\n+  /* Fill up missing PHI node arguments.  */\n+  for (unsigned i = 0; i < chain->m_entries.length (); ++i)\n+    {\n+      condition_info *info = chain->m_entries[i];\n+      for (unsigned j = 0; j < info->m_true_edge_phi_mapping.length (); ++j)\n+\t{\n+\t  std::pair<gphi *, tree> item = info->m_true_edge_phi_mapping[j];\n+\t  add_phi_arg (item.first, item.second,\n+\t\t       single_succ_edge (info->m_forwarder_bb),\n+\t\t       UNKNOWN_LOCATION);\n+\t}\n+    }\n+\n+  /* Fill up missing PHI nodes for the default BB.  */\n+  for (unsigned j = 0; j < last_cond->m_false_edge_phi_mapping.length (); ++j)\n+    {\n+      std::pair<gphi *, tree> item = last_cond->m_false_edge_phi_mapping[j];\n+      add_phi_arg (item.first, item.second, e, UNKNOWN_LOCATION);\n+    }\n+}\n+\n+/* Identify an index variable used in BB in a GIMPLE condition.\n+   Save information about the condition into CONDITIONS_IN_BBS.  */\n+\n+static void\n+find_conditions (basic_block bb,\n+\t\t hash_map<basic_block, condition_info> *conditions_in_bbs)\n+{\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n+  if (gsi_end_p (gsi))\n+    return;\n+\n+  gcond *cond = dyn_cast<gcond *> (gsi_stmt (gsi));\n+  if (cond == NULL)\n+    return;\n+\n+  if (!no_side_effect_bb (bb))\n+    return;\n+\n+  tree lhs = gimple_cond_lhs (cond);\n+  tree rhs = gimple_cond_rhs (cond);\n+  tree_code code = gimple_cond_code (cond);\n+\n+  condition_info info (cond);\n+\n+  gassign *def;\n+  if (code == NE_EXPR\n+      && TREE_CODE (lhs) == SSA_NAME\n+      && (def = dyn_cast<gassign *> (SSA_NAME_DEF_STMT (lhs))) != NULL\n+      && integer_zerop (rhs))\n+    {\n+      enum tree_code rhs_code = gimple_assign_rhs_code (def);\n+      if (rhs_code == BIT_IOR_EXPR)\n+\t{\n+\t  info.m_ranges.safe_grow (2, true);\n+\t  init_range_entry (&info.m_ranges[0], gimple_assign_rhs1 (def), NULL);\n+\t  init_range_entry (&info.m_ranges[1], gimple_assign_rhs2 (def), NULL);\n+\t}\n+    }\n+  else\n+    {\n+      info.m_ranges.safe_grow (1, true);\n+      init_range_entry (&info.m_ranges[0], NULL_TREE, cond);\n+    }\n+\n+  /* All identified ranges must have equal expression and IN_P flag.  */\n+  if (!info.m_ranges.is_empty ())\n+    {\n+      edge true_edge, false_edge;\n+      tree expr = info.m_ranges[0].exp;\n+      bool in_p = info.m_ranges[0].in_p;\n+\n+      extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+      info.m_true_edge = in_p ? true_edge : false_edge;\n+      info.m_false_edge = in_p ? false_edge : true_edge;\n+\n+      for (unsigned i = 0; i < info.m_ranges.length (); ++i)\n+\tif (info.m_ranges[i].exp == NULL_TREE\n+\t    || info.m_ranges[i].low == NULL_TREE\n+\t    || info.m_ranges[i].high == NULL_TREE)\n+\t  return;\n+\n+      for (unsigned i = 1; i < info.m_ranges.length (); ++i)\n+\tif (info.m_ranges[i].exp != expr\n+\t    || info.m_ranges[i].in_p != in_p)\n+\t  return;\n+\n+      info.record_phi_mapping (info.m_true_edge,\n+\t\t\t       &info.m_true_edge_phi_mapping);\n+      info.record_phi_mapping (info.m_false_edge,\n+\t\t\t       &info.m_false_edge_phi_mapping);\n+      conditions_in_bbs->put (bb, info);\n+    }\n+\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_if_to_switch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"iftoswitch\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_IF_TO_SWITCH, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_cleanup_cfg | TODO_update_ssa /* todo_flags_finish */\n+};\n+\n+class pass_if_to_switch : public gimple_opt_pass\n+{\n+public:\n+  pass_if_to_switch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_if_to_switch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+  {\n+    return (jump_table_cluster::is_enabled ()\n+\t    || bit_test_cluster::is_enabled ());\n+  }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_if_to_switch\n+\n+unsigned int\n+pass_if_to_switch::execute (function *fun)\n+{\n+  auto_vec<if_chain *> all_candidates;\n+  hash_map<basic_block, condition_info> conditions_in_bbs;\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fun)\n+    find_conditions (bb, &conditions_in_bbs);\n+\n+  if (conditions_in_bbs.is_empty ())\n+    return 0;\n+\n+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n+  unsigned n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n+\n+  auto_bitmap seen_bbs;\n+  for (int i = n - 1; i >= 0; --i)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n+      if (bitmap_bit_p (seen_bbs, bb->index))\n+\tcontinue;\n+\n+      bitmap_set_bit (seen_bbs, bb->index);\n+      condition_info *info = conditions_in_bbs.get (bb);\n+      if (info)\n+\t{\n+\t  if_chain *chain = new if_chain ();\n+\t  chain->m_entries.safe_push (info);\n+\t  /* Try to find a chain starting in this BB.  */\n+\t  while (true)\n+\t    {\n+\t      if (!single_pred_p (gimple_bb (info->m_cond)))\n+\t\tbreak;\n+\t      edge e = single_pred_edge (gimple_bb (info->m_cond));\n+\t      condition_info *info2 = conditions_in_bbs.get (e->src);\n+\t      if (!info2 || info->m_ranges[0].exp != info2->m_ranges[0].exp)\n+\t\tbreak;\n+\n+\t      chain->m_entries.safe_push (info2);\n+\t      bitmap_set_bit (seen_bbs, e->src->index);\n+\t      info = info2;\n+\t    }\n+\n+\t  chain->m_entries.reverse ();\n+\t  if (chain->m_entries.length () >= 3\n+\t      && chain->check_non_overlapping_cases ()\n+\t      && chain->is_beneficial ())\n+\t    {\n+\t      gcond *cond = chain->m_entries[0]->m_cond;\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, cond,\n+\t\t\t\t \"Condition chain with %d BBs \"\n+\t\t\t\t \"transformed into a switch statement.\\n\",\n+\t\t\t\t chain->m_entries.length ());\n+\t      all_candidates.safe_push (chain);\n+\t    }\n+\t}\n+    }\n+\n+  for (unsigned i = 0; i < all_candidates.length (); i++)\n+    {\n+      convert_if_conditions_to_switch (all_candidates[i]);\n+      delete all_candidates[i];\n+    }\n+\n+  free (rpo);\n+\n+  if (!all_candidates.is_empty ())\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      mark_virtual_operands_for_renaming (fun);\n+    }\n+\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_if_to_switch (gcc::context *ctxt)\n+{\n+  return new pass_if_to_switch (ctxt);\n+}"}, {"sha": "21b2e2af0f7034b90cc1314d177384029361a039", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -94,6 +94,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_phiopt, true /* early_p */);\n \t  NEXT_PASS (pass_modref);\n \t  NEXT_PASS (pass_tail_recursion);\n+\t  NEXT_PASS (pass_if_to_switch);\n \t  NEXT_PASS (pass_convert_switch);\n \t  NEXT_PASS (pass_cleanup_eh);\n \t  NEXT_PASS (pass_profile);"}, {"sha": "88505e8869f8bc0197e2969211cdd22ede16e584", "filename": "gcc/testsuite/g++.dg/tree-ssa/if-to-switch-1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fif-to-switch-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fif-to-switch-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fif-to-switch-1.C?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+void fancy_abort(const char *, int, const char *);\n+\n+enum machine_mode\n+{\n+  MODE_FLOAT,\n+  MODE_DECIMAL_FLOAT,\n+  MODE_COMPLEX_INT,\n+  MODE_COMPLEX_FLOAT,\n+  MODE_VECTOR_BOOL,\n+  MODE_VECTOR_FLOAT\n+} extern const mode_class;\n+\n+void tree_node() {\n+  if (mode_class)\n+    mode_class == MODE_FLOAT || mode_class == MODE_DECIMAL_FLOAT ||\n+        mode_class == MODE_COMPLEX_FLOAT || mode_class == MODE_VECTOR_FLOAT\n+        ? fancy_abort(\"aaa\", 2, __FUNCTION__),\n+        0 : 0;\n+  int g = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Condition chain with 3 BBs transformed into a switch statement.\" \"iftoswitch\" } } */"}, {"sha": "92df4e93bfa6f157b4800a68fd132f7a034a51ec", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-1.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int global;\n+int foo ();\n+\n+int main(int argc, char **argv)\n+{\n+  if (argc == 1)\n+    foo ();\n+  else if (argc == 2)\n+    {\n+      global += 1;\n+    }\n+  else if (argc == 3)\n+    {\n+      foo ();\n+      foo ();\n+    }\n+  else if (argc == 4)\n+    {\n+      foo ();\n+    }\n+  else if (argc == 5)\n+    {\n+      global = 2;\n+    }\n+  else\n+    global -= 123;\n+\n+  global -= 12;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Condition chain with 5 BBs transformed into a switch statement.\" \"iftoswitch\" } } */"}, {"sha": "36e62ae5be1856bc1be3381217b0d633741e164d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-2.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int IsHTMLWhitespaceNoRange(int aChar)\n+{\n+  return aChar == 0x0001 || aChar == 0x000A ||\n+         aChar == 0x000C || aChar == 0x000E ||\n+         aChar == 0x0020;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Condition chain with 3 BBs transformed into a switch statement.\" \"iftoswitch\" } } */"}, {"sha": "9a4ce16023847f6ed289031626d8332479868196", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-3.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int IsHTMLWhitespace(int aChar)\n+{\n+  return aChar == 0x0009 || aChar == 0x000A ||\n+         aChar == 0x000C || aChar == 0x000D ||\n+         aChar == 0x0020 || aChar == 0x0030;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Condition chain with 3 BBs transformed into a switch statement.\" \"iftoswitch\" } } */"}, {"sha": "6a0358834578dbf8793f06a05e595e87f4db7c00", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-4.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-4.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int global;\n+int foo ();\n+\n+int main(int argc, char **argv)\n+{\n+  if (argc == 1)\n+    foo ();\n+  else if (argc == 2)\n+    {\n+      global += 1;\n+    }\n+  else if (argc == 3)\n+    {\n+      foo ();\n+      foo ();\n+    }\n+  else if (argc == 4)\n+    {\n+      foo ();\n+    }\n+  /* This will be removed with EVRP.  */\n+  else if (argc == 1)\n+    {\n+      global = 2;\n+    }\n+  else\n+    global -= 123;\n+\n+  global -= 12;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Condition chain\" \"iftoswitch\" } } */"}, {"sha": "7734a58500bd7cddb96758793dd496ec27252082", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-5.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int crud (unsigned char c)\n+{\n+  return (((((((((((int) c == 46) || (int) c == 44)\n+\t\t || (int) c == 58) || (int) c == 59) || (int) c == 60)\n+\t      || (int) c == 62) || (int) c == 34) || (int) c == 92)\n+\t   || (int) c == 39) != 0);\n+}\n+\n+/* { dg-final { scan-tree-dump \"Condition chain with 5 BBs transformed into a switch statement.\" \"iftoswitch\" } } */"}, {"sha": "464b1fbd12476d614464e29207043fc775b22a4e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-6.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-6.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int global;\n+int foo ();\n+\n+int main(int argc, char **argv)\n+{\n+  if (argc >= 1 && argc <= 10)\n+    foo ();\n+  else if (argc == 12)\n+    {\n+      global += 1;\n+    }\n+  else if (argc == 13)\n+    {\n+      foo ();\n+      foo ();\n+    }\n+  else if (argc == 14)\n+    {\n+      foo ();\n+    }\n+  /* This will be removed with EVRP.  */\n+  else if (argc == 5)\n+    {\n+      global = 2;\n+    }\n+  /* This will be removed with EVRP.  */\n+  else if (argc >= 7 && argc <= 9)\n+    {\n+      global = 2;\n+    }\n+\n+  else\n+    global -= 123;\n+\n+  global -= 12;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Condition chain\" \"iftoswitch\" } } */"}, {"sha": "4a176f1a613fc50806879ed058fff73c9b5d3d5b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-7.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-7.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int global;\n+\n+int foo(int a)\n+{\n+  int x = 0;\n+  for (unsigned i = 0; i < a; i++)\n+  {\n+    if (a == 2)\n+    {\n+      global += 123;\n+      x = 1;\n+    }\n+    else if (a == 3)\n+      x = 2;\n+    else if (a == 10)\n+      x = 3;\n+  }\n+\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Condition chain \" \"iftoswitch\" } } */"}, {"sha": "f43ce7daf782f729fb39d96511803e8bbe291f48", "filename": "gcc/testsuite/gcc.dg/tree-ssa/if-to-switch-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fif-to-switch-8.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-iftoswitch-optimized\" } */\n+\n+int global;\n+int global1;\n+int global2;\n+int global3;\n+\n+int foo(int a, int b)\n+{\n+  int x = 0;\n+  for (unsigned i = 0; i < a; i++)\n+  {\n+    if (b == 1)\n+      global += 2;\n+    else if (a == 2)\n+      global = 123;\n+    else if (a == 3)\n+      global1 = 1234;\n+    else if (a == 10)\n+      global2 = 12345;\n+    else if (a == 1)\n+      global2 = 123456;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Condition chain\" \"iftoswitch\" } } */"}, {"sha": "cc04721c1df58a01567f5f90e06b3bf129878162", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr96480.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96480.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96480.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96480.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/96480 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fno-bit-tests\" } */\n /* { dg-final { scan-tree-dump \" = _\\[0-9]* <= 3;\" \"optimized\" } } */\n \n int v[4];"}, {"sha": "093e7a57a27a354518e77e68062d76ced58d564c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-32.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run { target { ! \"m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-*\"} } } */\n \n-/* { dg-options \"-O2 -fno-inline -fdump-tree-reassoc1-details --param logical-op-non-short-circuit=1\" } */\n+/* { dg-options \"-O2 -fno-inline -fdump-tree-reassoc1-details --param logical-op-non-short-circuit=1 -fno-bit-tests\" } */\n /* { dg-additional-options \"-mbranch-cost=2\" { target branch_cost } } */\n \n "}, {"sha": "1cf2300ecda5d7aa6b5b367dc33ac5b8cb0ace73", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -293,6 +293,7 @@ DEFTIMEVAR (TV_VAR_TRACKING          , \"variable tracking\")\n DEFTIMEVAR (TV_VAR_TRACKING_DATAFLOW , \"var-tracking dataflow\")\n DEFTIMEVAR (TV_VAR_TRACKING_EMIT     , \"var-tracking emit\")\n DEFTIMEVAR (TV_TREE_IFCOMBINE        , \"tree if-combine\")\n+DEFTIMEVAR (TV_TREE_IF_TO_SWITCH     , \"if to switch conversion\")\n DEFTIMEVAR (TV_TREE_UNINIT           , \"uninit var analysis\")\n DEFTIMEVAR (TV_PLUGIN_INIT           , \"plugin initialization\")\n DEFTIMEVAR (TV_PLUGIN_RUN            , \"plugin execution\")"}, {"sha": "450a379bac707d8e951f680f4156c7fbfbe99312", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -379,6 +379,7 @@ extern gimple_opt_pass *make_pass_empty_loop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_graphite (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_graphite_transforms (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_if_conversion (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_if_to_switch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_loop_distribution (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_vectorize (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_simduid_cleanup (gcc::context *ctxt);"}, {"sha": "e594230436dbca2b8c3ffe786857431e09d99460", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"gimplify.h\"\n #include \"case-cfn-macros.h\"\n+#include \"tree-ssa-reassoc.h\"\n \n /*  This is a simple global reassociation pass.  It is, in part, based\n     on the LLVM pass of the same name (They do some things more/less\n@@ -188,15 +189,6 @@ static struct\n   int pows_created;\n } reassociate_stats;\n \n-/* Operator, rank pair.  */\n-struct operand_entry\n-{\n-  unsigned int rank;\n-  unsigned int id;\n-  tree op;\n-  unsigned int count;\n-  gimple *stmt_to_insert;\n-};\n \n static object_allocator<operand_entry> operand_entry_pool\n   (\"operand entry pool\");\n@@ -226,7 +218,7 @@ static bool reassoc_stmt_dominates_stmt_p (gimple *, gimple *);\n /* Wrapper around gsi_remove, which adjusts gimple_uid of debug stmts\n    possibly added by gsi_remove.  */\n \n-bool\n+static bool\n reassoc_remove_stmt (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n@@ -2408,18 +2400,7 @@ optimize_ops_list (enum tree_code opcode,\n    For more information see comments above fold_test_range in fold-const.c,\n    this implementation is for GIMPLE.  */\n \n-struct range_entry\n-{\n-  tree exp;\n-  tree low;\n-  tree high;\n-  bool in_p;\n-  bool strict_overflow_p;\n-  unsigned int idx, next;\n-};\n \n-void dump_range_entry (FILE *file, struct range_entry *r);\n-void debug_range_entry (struct range_entry *r);\n \n /* Dump the range entry R to FILE, skipping its expression if SKIP_EXP.  */\n \n@@ -2449,7 +2430,7 @@ debug_range_entry (struct range_entry *r)\n    an SSA_NAME and STMT argument is ignored, otherwise STMT\n    argument should be a GIMPLE_COND.  */\n \n-static void\n+void\n init_range_entry (struct range_entry *r, tree exp, gimple *stmt)\n {\n   int in_p;\n@@ -4286,7 +4267,7 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n    range test optimization, all SSA_NAMEs set in the bb are consumed\n    in the bb and there are no PHIs.  */\n \n-static bool\n+bool\n no_side_effect_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;"}, {"sha": "dc7f59f1eca95215ecd790f021add754d2e5a60a", "filename": "gcc/tree-ssa-reassoc.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-ssa-reassoc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-ssa-reassoc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.h?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -0,0 +1,48 @@\n+/* Reassociation for trees.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SSA_REASSOC_H\n+#define GCC_SSA_REASSOC_H\n+\n+/* Operator, rank pair.  */\n+struct operand_entry\n+{\n+  unsigned int rank;\n+  unsigned int id;\n+  tree op;\n+  unsigned int count;\n+  gimple *stmt_to_insert;\n+};\n+\n+struct range_entry\n+{\n+  tree exp;\n+  tree low;\n+  tree high;\n+  bool in_p;\n+  bool strict_overflow_p;\n+  unsigned int idx, next;\n+};\n+\n+void dump_range_entry (FILE *file, struct range_entry *r);\n+void debug_range_entry (struct range_entry *r);\n+void init_range_entry (struct range_entry *r, tree exp, gimple *stmt);\n+bool no_side_effect_bb (basic_block bb);\n+\n+#endif  /* GCC_SSA_REASSOC_H  */"}, {"sha": "62cfde168c86d3d76aba150509391c6ee5abb6e2", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03eb09292ef228d1d12b5168cdd748583b1f992a/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=03eb09292ef228d1d12b5168cdd748583b1f992a", "patch": "@@ -48,8 +48,8 @@ class cluster\n {\n public:\n   /* Constructor.  */\n-  cluster (tree case_label_expr, basic_block case_bb, profile_probability prob,\n-\t   profile_probability subtree_prob);\n+  inline cluster (tree case_label_expr, basic_block case_bb,\n+\t\t  profile_probability prob, profile_probability subtree_prob);\n \n   /* Destructor.  */\n   virtual ~cluster ()\n@@ -121,8 +121,9 @@ class simple_cluster: public cluster\n {\n public:\n   /* Constructor.  */\n-  simple_cluster (tree low, tree high, tree case_label_expr,\n-\t\t  basic_block case_bb, profile_probability prob);\n+  inline simple_cluster (tree low, tree high, tree case_label_expr,\n+\t\t\t basic_block case_bb, profile_probability prob,\n+\t\t\t bool has_forward_bb = false);\n \n   /* Destructor.  */\n   ~simple_cluster ()\n@@ -146,6 +147,11 @@ class simple_cluster: public cluster\n     return m_high;\n   }\n \n+  void set_high (tree high)\n+  {\n+    m_high = high;\n+  }\n+\n   void\n   debug ()\n   {\n@@ -182,12 +188,16 @@ class simple_cluster: public cluster\n \n   /* True if case is a range.  */\n   bool m_range_p;\n+\n+  /* True if the case will use a forwarder BB.  */\n+  bool m_has_forward_bb;\n };\n \n simple_cluster::simple_cluster (tree low, tree high, tree case_label_expr,\n-\t\t\t\tbasic_block case_bb, profile_probability prob):\n+\t\t\t\tbasic_block case_bb, profile_probability prob,\n+\t\t\t\tbool has_forward_bb):\n   cluster (case_label_expr, case_bb, prob, prob),\n-  m_low (low), m_high (high)\n+  m_low (low), m_high (high), m_has_forward_bb (has_forward_bb)\n {\n   m_range_p = m_high != NULL;\n   if (m_high == NULL)\n@@ -271,7 +281,7 @@ class jump_table_cluster: public group_cluster\n   static inline unsigned int case_values_threshold (void);\n \n   /* Return whether jump table expansion is allowed.  */\n-  static bool is_enabled (void);\n+  static inline bool is_enabled (void);\n };\n \n /* A GIMPLE switch statement can be expanded to a short sequence of bit-wise"}]}