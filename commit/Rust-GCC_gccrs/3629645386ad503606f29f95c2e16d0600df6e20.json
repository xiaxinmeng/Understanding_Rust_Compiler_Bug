{"sha": "3629645386ad503606f29f95c2e16d0600df6e20", "node_id": "C_kwDOANBUbNoAKDM2Mjk2NDUzODZhZDUwMzYwNmYyOWY5NWMyZTE2ZDA2MDBkZjZlMjA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-15T23:02:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-15T23:02:03Z"}, "message": "Merge #832 #833\n\n832: Refactor TyTy::ResolveCompile pass to be in its own file r=philberty a=philberty\n\nThis name likely needs to be refactored, this class is used to take TyTy types\r\nand compile them down to GCC tree's but take into account that we may have\r\nalready compiled this type before so to preserve the canonical types we\r\n\"resolve\" the type if possible and then compile.\r\n\n\n833: Refactor CallExpr and MethodCallExpr into rust-compile-expr.cc r=philberty a=philberty\n\nOur compile times are very bad for the front-end code and this is part\r\nof the drive to pull more implementation code out of headers and into\r\ncode files such that we can have smaller headers and many code files\r\nto reduce recompilation of the same code.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "804921378462fc777925e2362e204172c48d7536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/804921378462fc777925e2362e204172c48d7536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3629645386ad503606f29f95c2e16d0600df6e20", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhunPrCRBK7hj4Ov3rIwAAUOIIAE5/ZUJGslTUId+rymCql46s\nPejmQsUHdALWxg/oER5lxb2I+R44PPKFWaz1SJA63Ldqgnvj+t+N2Q2U886GcN7z\n87XFOHyM3bl8OeESuTGRScTXS6o+Mvay/qPx8Tij1/uQ9T0lcGTn2vUElStEiQ6L\nB4RM05UDokWJ9GhUyWwJwDsE7SlujbDZtGCDMwNHNSkCkwoHkvqGUIKbY4HbRwuh\nnneyhNfBhm9xefuofq5Ij1p4Ape3l4fFD6EpR5cnI/gWSKlPyNr6l5i4Xng1bn6L\n6mzFStfAEZbT98sG2hqXGWncOzUQ0TtvaL3AbHDydLkaIXzlLTGRA7sT7a+U0/A=\n=OVB8\n-----END PGP SIGNATURE-----\n", "payload": "tree 804921378462fc777925e2362e204172c48d7536\nparent de9bb867970b755eca6ff612daae801f120ee928\nparent 40aae6224b1bab4825b11a1d16ea73ba52a04d6b\nparent 91a5d085cb5cf8320dbf5bb2a04933b54b5b4494\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639609323 +0000\ncommitter GitHub <noreply@github.com> 1639609323 +0000\n\nMerge #832 #833\n\n832: Refactor TyTy::ResolveCompile pass to be in its own file r=philberty a=philberty\n\nThis name likely needs to be refactored, this class is used to take TyTy types\r\nand compile them down to GCC tree's but take into account that we may have\r\nalready compiled this type before so to preserve the canonical types we\r\n\"resolve\" the type if possible and then compile.\r\n\n\n833: Refactor CallExpr and MethodCallExpr into rust-compile-expr.cc r=philberty a=philberty\n\nOur compile times are very bad for the front-end code and this is part\r\nof the drive to pull more implementation code out of headers and into\r\ncode files such that we can have smaller headers and many code files\r\nto reduce recompilation of the same code.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3629645386ad503606f29f95c2e16d0600df6e20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3629645386ad503606f29f95c2e16d0600df6e20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3629645386ad503606f29f95c2e16d0600df6e20/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de9bb867970b755eca6ff612daae801f120ee928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de9bb867970b755eca6ff612daae801f120ee928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de9bb867970b755eca6ff612daae801f120ee928"}, {"sha": "40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40aae6224b1bab4825b11a1d16ea73ba52a04d6b"}, {"sha": "91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494"}], "stats": {"total": 1322, "additions": 714, "deletions": 608}, "files": [{"sha": "3a5e7cc2724eb1c0472ec42dbe7e6bef832bcc98", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=3629645386ad503606f29f95c2e16d0600df6e20", "patch": "@@ -93,6 +93,7 @@ GRS_OBJS = \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-base62.o \\\n     rust/rust-compile-expr.o \\\n+    rust/rust-compile-type.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "ed6bba4dc3c4e68b10139aca3351db49ce139ecb", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=3629645386ad503606f29f95c2e16d0600df6e20", "patch": "@@ -18,6 +18,7 @@\n #define RUST_COMPILE_BASE\n \n #include \"rust-compile-context.h\"\n+#include \"rust-compile-type.h\"\n #include \"rust-hir-visitor.h\"\n #include \"rust-hir-full.h\"\n "}, {"sha": "6347e766f97b45f93f3c4aa15d6b0af2d5bf9457", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 0, "deletions": 344, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=3629645386ad503606f29f95c2e16d0600df6e20", "patch": "@@ -334,350 +334,6 @@ class Context\n   std::vector<tree> func_decls;\n };\n \n-class TyTyResolveCompile : public TyTy::TyConstVisitor\n-{\n-public:\n-  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n-\t\t       bool trait_object_mode = false)\n-  {\n-    TyTyResolveCompile compiler (ctx, trait_object_mode);\n-    ty->accept_vis (compiler);\n-    return compiler.translated;\n-  }\n-\n-  void visit (const TyTy::ErrorType &) override { gcc_unreachable (); }\n-  void visit (const TyTy::InferType &) override { gcc_unreachable (); }\n-\n-  void visit (const TyTy::ProjectionType &type) override\n-  {\n-    type.get ()->accept_vis (*this);\n-  }\n-\n-  void visit (const TyTy::PlaceholderType &type) override\n-  {\n-    type.resolve ()->accept_vis (*this);\n-  }\n-\n-  void visit (const TyTy::ParamType &param) override\n-  {\n-    recursion_count++;\n-    rust_assert (recursion_count < kDefaultRecusionLimit);\n-\n-    param.resolve ()->accept_vis (*this);\n-  }\n-\n-  void visit (const TyTy::FnType &type) override\n-  {\n-    Backend::typed_identifier receiver;\n-    std::vector<Backend::typed_identifier> parameters;\n-    std::vector<Backend::typed_identifier> results;\n-\n-    if (!type.get_return_type ()->is_unit ())\n-      {\n-\tauto hir_type = type.get_return_type ();\n-\tauto ret\n-\t  = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n-\tresults.push_back (Backend::typed_identifier (\n-\t  \"_\", ret,\n-\t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n-      }\n-\n-    for (auto &param_pair : type.get_params ())\n-      {\n-\tauto param_tyty = param_pair.second;\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n-\n-\tauto compiled_param = Backend::typed_identifier (\n-\t  param_pair.first->as_string (), compiled_param_type,\n-\t  ctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n-\n-\tparameters.push_back (compiled_param);\n-      }\n-\n-    if (!type.is_varadic ())\n-      translated = ctx->get_backend ()->function_type (\n-\treceiver, parameters, results, NULL,\n-\tctx->get_mappings ()->lookup_location (type.get_ref ()));\n-    else\n-      translated = ctx->get_backend ()->function_type_varadic (\n-\treceiver, parameters, results, NULL,\n-\tctx->get_mappings ()->lookup_location (type.get_ref ()));\n-  }\n-\n-  void visit (const TyTy::FnPtr &type) override\n-  {\n-    tree result_type\n-      = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n-\n-    std::vector<tree> parameters;\n-    type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n-      tree pty = TyTyResolveCompile::compile (ctx, p);\n-      parameters.push_back (pty);\n-      return true;\n-    });\n-\n-    translated = ctx->get_backend ()->function_ptr_type (\n-      result_type, parameters,\n-      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n-  }\n-\n-  void visit (const TyTy::ADTType &type) override\n-  {\n-    if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n-      return;\n-\n-    // we dont support enums yet\n-    rust_assert (!type.is_enum ());\n-    rust_assert (type.number_of_variants () == 1);\n-\n-    TyTy::VariantDef &variant = *type.get_variants ().at (0);\n-    std::vector<Backend::typed_identifier> fields;\n-    for (size_t i = 0; i < variant.num_fields (); i++)\n-      {\n-\tconst TyTy::StructFieldType *field = variant.get_field_at_index (i);\n-\ttree compiled_field_ty\n-\t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n-\n-\tBackend::typed_identifier f (field->get_name (), compiled_field_ty,\n-\t\t\t\t     ctx->get_mappings ()->lookup_location (\n-\t\t\t\t       type.get_ty_ref ()));\n-\tfields.push_back (std::move (f));\n-      }\n-\n-    tree type_record;\n-    if (type.is_union ())\n-      type_record = ctx->get_backend ()->union_type (fields);\n-    else\n-      type_record = ctx->get_backend ()->struct_type (fields);\n-    tree named_struct\n-      = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ty_ref ()));\n-\n-    ctx->push_type (named_struct);\n-    translated = named_struct;\n-\n-    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n-  }\n-\n-  void visit (const TyTy::TupleType &type) override\n-  {\n-    if (type.num_fields () == 0)\n-      {\n-\ttranslated = ctx->get_backend ()->unit_type ();\n-\treturn;\n-      }\n-\n-    bool ok\n-      = ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type);\n-    if (ok)\n-      return;\n-\n-    // create implicit struct\n-    std::vector<Backend::typed_identifier> fields;\n-    for (size_t i = 0; i < type.num_fields (); i++)\n-      {\n-\tTyTy::BaseType *field = type.get_field (i);\n-\ttree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n-\n-\t// rustc uses the convention __N, where N is an integer, to\n-\t// name the fields of a tuple.  We follow this as well,\n-\t// because this is used by GDB.  One further reason to prefer\n-\t// this, rather than simply emitting the integer, is that this\n-\t// approach makes it simpler to use a C-only debugger, or\n-\t// GDB's C mode, when debugging Rust.\n-\tBackend::typed_identifier f (\"__\" + std::to_string (i),\n-\t\t\t\t     compiled_field_ty,\n-\t\t\t\t     ctx->get_mappings ()->lookup_location (\n-\t\t\t\t       type.get_ty_ref ()));\n-\tfields.push_back (std::move (f));\n-      }\n-\n-    tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n-    tree named_struct\n-      = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n-\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ty_ref ()));\n-\n-    ctx->push_type (named_struct);\n-    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n-    translated = named_struct;\n-  }\n-\n-  void visit (const TyTy::ArrayType &type) override\n-  {\n-    tree element_type\n-      = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n-    translated\n-      = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n-  }\n-\n-  void visit (const TyTy::BoolType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::IntType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::UintType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::FloatType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::USizeType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::ISizeType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::CharType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::ReferenceType &type) override\n-  {\n-    tree base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n-    if (type.is_mutable ())\n-      {\n-\ttranslated = ctx->get_backend ()->reference_type (base_compiled_type);\n-      }\n-    else\n-      {\n-\tauto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n-\ttranslated = ctx->get_backend ()->reference_type (base);\n-      }\n-  }\n-\n-  void visit (const TyTy::PointerType &type) override\n-  {\n-    tree base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n-    if (type.is_mutable ())\n-      {\n-\ttranslated = ctx->get_backend ()->pointer_type (base_compiled_type);\n-      }\n-    else\n-      {\n-\tauto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n-\ttranslated = ctx->get_backend ()->pointer_type (base);\n-      }\n-  }\n-\n-  void visit (const TyTy::StrType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::NeverType &) override\n-  {\n-    translated = ctx->get_backend ()->unit_type ();\n-  }\n-\n-  void visit (const TyTy::DynamicObjectType &type) override\n-  {\n-    if (trait_object_mode)\n-      {\n-\ttranslated = ctx->get_backend ()->integer_type (\n-\t  true, ctx->get_backend ()->get_pointer_size ());\n-\treturn;\n-      }\n-\n-    if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n-      return;\n-\n-    // create implicit struct\n-    auto items = type.get_object_items ();\n-    std::vector<Backend::typed_identifier> fields;\n-\n-    tree uint = ctx->get_backend ()->integer_type (\n-      true, ctx->get_backend ()->get_pointer_size ());\n-    tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n-\n-    Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n-\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t   type.get_ty_ref ()));\n-    fields.push_back (std::move (f));\n-\n-    for (size_t i = 0; i < items.size (); i++)\n-      {\n-\t// mrustc seems to make a vtable consisting of uintptr's\n-\ttree uint = ctx->get_backend ()->integer_type (\n-\t  true, ctx->get_backend ()->get_pointer_size ());\n-\ttree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n-\n-\tBackend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n-\t\t\t\t     ctx->get_mappings ()->lookup_location (\n-\t\t\t\t       type.get_ty_ref ()));\n-\tfields.push_back (std::move (f));\n-      }\n-\n-    tree type_record = ctx->get_backend ()->struct_type (fields);\n-    tree named_struct\n-      = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ty_ref ()));\n-\n-    ctx->push_type (named_struct);\n-    translated = named_struct;\n-\n-    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n-  }\n-\n-  void visit (const TyTy::ClosureType &) override { gcc_unreachable (); }\n-\n-private:\n-  TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n-    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr),\n-      recursion_count (0)\n-  {}\n-\n-  Context *ctx;\n-  bool trait_object_mode;\n-  tree translated;\n-  size_t recursion_count;\n-\n-  static const size_t kDefaultRecusionLimit = 5;\n-};\n-\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "7c8aa29e24c6283f80fb427a5824cd32470861ba", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=3629645386ad503606f29f95c2e16d0600df6e20", "patch": "@@ -154,6 +154,268 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n \t\t\t\t\t\tknown_valid, expr.get_locus ());\n }\n \n+void\n+CompileExpr::visit (HIR::CallExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_fnexpr ()->get_mappings ().get_hirid (), &tyty))\n+    {\n+      rust_error_at (expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  // must be a tuple constructor\n+  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  if (!is_fn)\n+    {\n+      rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+      auto variant = adt->get_variants ().at (0);\n+\n+      // this assumes all fields are in order from type resolution and if a\n+      // base struct was specified those fields are filed via accesors\n+      std::vector<tree> vals;\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+\t{\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  auto respective_field = variant->get_field_at_index (i);\n+\t  auto expected = respective_field->get_field_type ();\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  vals.push_back (rvalue);\n+\t}\n+\n+      translated\n+\t= ctx->get_backend ()->constructor_expression (compiled_adt_type, vals,\n+\t\t\t\t\t\t       -1, expr.get_locus ());\n+    }\n+  else\n+    {\n+      auto get_parameter_tyty_at_index\n+\t= [] (const TyTy::BaseType *base, size_t index,\n+\t      TyTy::BaseType **result) -> bool {\n+\tbool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t     || base->get_kind () == TyTy::TypeKind::FNPTR;\n+\trust_assert (is_fn);\n+\n+\tif (base->get_kind () == TyTy::TypeKind::FNPTR)\n+\t  {\n+\t    const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n+\t    *result = fn->param_at (index);\n+\n+\t    return true;\n+\t  }\n+\n+\tconst TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n+\tauto param = fn->param_at (index);\n+\t*result = param.second;\n+\n+\treturn true;\n+      };\n+\n+      bool is_varadic = false;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  is_varadic = fn->is_varadic ();\n+\t}\n+\n+      size_t required_num_args;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n+      else\n+\t{\n+\t  const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n+\n+      std::vector<tree> args;\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+\t{\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  if (is_varadic && i >= required_num_args)\n+\t    {\n+\t      args.push_back (rvalue);\n+\t      continue;\n+\t    }\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  bool ok;\n+\t  TyTy::BaseType *expected = nullptr;\n+\t  ok = get_parameter_tyty_at_index (tyty, i, &expected);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  args.push_back (rvalue);\n+\t}\n+\n+      // must be a call to a function\n+      auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+      auto fncontext = ctx->peek_fn ();\n+      translated\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n+\t\t\t\t\t\targs, nullptr,\n+\t\t\t\t\t\texpr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  // method receiver\n+  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n+      return;\n+    }\n+\n+  // reverse lookup\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // lookup the expected function type\n+  TyTy::BaseType *lookup_fntype = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_method_name ().get_mappings ().get_hirid (), &lookup_fntype);\n+  rust_assert (ok);\n+  rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      for (auto &arg : expr.get_arguments ())\n+\targuments.push_back (arg.get ());\n+\n+      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n+\t\t\t\t\t      arguments, expr.get_locus ());\n+      return;\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathExprSegment method_name = expr.get_method_name ();\n+  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n+  tree fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self = ctx->get_backend ()->address_expression (\n+\t    self, expr.get_receiver ()->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  tree expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self = ctx->get_backend ()->indirect_expression (\n+\t    expected_type, self, true, /* known_valid*/\n+\t    expr.get_receiver ()->get_locus ());\n+\t  break;\n+\t}\n+    }\n+\n+  std::vector<tree> args;\n+  args.push_back (self); // adjusted self\n+\n+  // normal args\n+  for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+    {\n+      auto &argument = expr.get_arguments ().at (i);\n+      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+      // assignments are coercion sites so lets convert the rvalue if\n+      // necessary, offset from the already adjusted implicit self\n+      bool ok;\n+      TyTy::BaseType *expected = fntype->param_at (i + 1).second;\n+\n+      TyTy::BaseType *actual = nullptr;\n+      ok = ctx->get_tyctx ()->lookup_type (\n+\targument->get_mappings ().get_hirid (), &actual);\n+      rust_assert (ok);\n+\n+      // coerce it if required\n+      rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+      // add it to the list\n+      args.push_back (rvalue);\n+    }\n+\n+  auto fncontext = ctx->peek_fn ();\n+  translated\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t    nullptr, expr.get_locus ());\n+}\n+\n tree\n CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\tTyTy::BaseType *receiver,"}, {"sha": "76ab4db289146000d32a5b3d93a78d3156695ccf", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=3629645386ad503606f29f95c2e16d0600df6e20", "patch": "@@ -0,0 +1,371 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-type.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ErrorType &)\n+{\n+  gcc_unreachable ();\n+}\n+void\n+TyTyResolveCompile::visit (const TyTy::InferType &)\n+{\n+  gcc_unreachable ();\n+}\n+void\n+TyTyResolveCompile::visit (const TyTy::ClosureType &)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ProjectionType &type)\n+{\n+  type.get ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::PlaceholderType &type)\n+{\n+  type.resolve ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ParamType &param)\n+{\n+  recursion_count++;\n+  rust_assert (recursion_count < kDefaultRecusionLimit);\n+\n+  param.resolve ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FnType &type)\n+{\n+  Backend::typed_identifier receiver;\n+  std::vector<Backend::typed_identifier> parameters;\n+  std::vector<Backend::typed_identifier> results;\n+\n+  if (!type.get_return_type ()->is_unit ())\n+    {\n+      auto hir_type = type.get_return_type ();\n+      auto ret = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n+      results.push_back (Backend::typed_identifier (\n+\t\"_\", ret,\n+\tctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n+    }\n+\n+  for (auto &param_pair : type.get_params ())\n+    {\n+      auto param_tyty = param_pair.second;\n+      auto compiled_param_type\n+\t= TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n+\n+      auto compiled_param = Backend::typed_identifier (\n+\tparam_pair.first->as_string (), compiled_param_type,\n+\tctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n+\n+      parameters.push_back (compiled_param);\n+    }\n+\n+  if (!type.is_varadic ())\n+    translated = ctx->get_backend ()->function_type (\n+      receiver, parameters, results, NULL,\n+      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+  else\n+    translated = ctx->get_backend ()->function_type_varadic (\n+      receiver, parameters, results, NULL,\n+      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FnPtr &type)\n+{\n+  tree result_type = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n+\n+  std::vector<tree> parameters;\n+  type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n+    tree pty = TyTyResolveCompile::compile (ctx, p);\n+    parameters.push_back (pty);\n+    return true;\n+  });\n+\n+  translated = ctx->get_backend ()->function_ptr_type (\n+    result_type, parameters,\n+    ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ADTType &type)\n+{\n+  if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n+    return;\n+\n+  // we dont support enums yet\n+  rust_assert (!type.is_enum ());\n+  rust_assert (type.number_of_variants () == 1);\n+\n+  TyTy::VariantDef &variant = *type.get_variants ().at (0);\n+  std::vector<Backend::typed_identifier> fields;\n+  for (size_t i = 0; i < variant.num_fields (); i++)\n+    {\n+      const TyTy::StructFieldType *field = variant.get_field_at_index (i);\n+      tree compiled_field_ty\n+\t= TyTyResolveCompile::compile (ctx, field->get_field_type ());\n+\n+      Backend::typed_identifier f (field->get_name (), compiled_field_ty,\n+\t\t\t\t   ctx->get_mappings ()->lookup_location (\n+\t\t\t\t     type.get_ty_ref ()));\n+      fields.push_back (std::move (f));\n+    }\n+\n+  tree type_record;\n+  if (type.is_union ())\n+    type_record = ctx->get_backend ()->union_type (fields);\n+  else\n+    type_record = ctx->get_backend ()->struct_type (fields);\n+  tree named_struct\n+    = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\n+  ctx->push_type (named_struct);\n+  translated = named_struct;\n+\n+  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::TupleType &type)\n+{\n+  if (type.num_fields () == 0)\n+    {\n+      translated = ctx->get_backend ()->unit_type ();\n+      return;\n+    }\n+\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type);\n+  if (ok)\n+    return;\n+\n+  // create implicit struct\n+  std::vector<Backend::typed_identifier> fields;\n+  for (size_t i = 0; i < type.num_fields (); i++)\n+    {\n+      TyTy::BaseType *field = type.get_field (i);\n+      tree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n+\n+      // rustc uses the convention __N, where N is an integer, to\n+      // name the fields of a tuple.  We follow this as well,\n+      // because this is used by GDB.  One further reason to prefer\n+      // this, rather than simply emitting the integer, is that this\n+      // approach makes it simpler to use a C-only debugger, or\n+      // GDB's C mode, when debugging Rust.\n+      Backend::typed_identifier f (\"__\" + std::to_string (i), compiled_field_ty,\n+\t\t\t\t   ctx->get_mappings ()->lookup_location (\n+\t\t\t\t     type.get_ty_ref ()));\n+      fields.push_back (std::move (f));\n+    }\n+\n+  tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n+  tree named_struct\n+    = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\n+  ctx->push_type (named_struct);\n+  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+  translated = named_struct;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n+{\n+  tree element_type\n+    = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+  translated\n+    = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::BoolType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::IntType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::UintType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FloatType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::USizeType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ISizeType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::CharType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ReferenceType &type)\n+{\n+  tree base_compiled_type\n+    = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n+  if (type.is_mutable ())\n+    {\n+      translated = ctx->get_backend ()->reference_type (base_compiled_type);\n+    }\n+  else\n+    {\n+      auto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n+      translated = ctx->get_backend ()->reference_type (base);\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::PointerType &type)\n+{\n+  tree base_compiled_type\n+    = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n+  if (type.is_mutable ())\n+    {\n+      translated = ctx->get_backend ()->pointer_type (base_compiled_type);\n+    }\n+  else\n+    {\n+      auto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n+      translated = ctx->get_backend ()->pointer_type (base);\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::StrType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::NeverType &)\n+{\n+  translated = ctx->get_backend ()->unit_type ();\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n+{\n+  if (trait_object_mode)\n+    {\n+      translated = ctx->get_backend ()->integer_type (\n+\ttrue, ctx->get_backend ()->get_pointer_size ());\n+      return;\n+    }\n+\n+  if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n+    return;\n+\n+  // create implicit struct\n+  auto items = type.get_object_items ();\n+  std::vector<Backend::typed_identifier> fields;\n+\n+  tree uint = ctx->get_backend ()->integer_type (\n+    true, ctx->get_backend ()->get_pointer_size ());\n+  tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+  Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t type.get_ty_ref ()));\n+  fields.push_back (std::move (f));\n+\n+  for (size_t i = 0; i < items.size (); i++)\n+    {\n+      // mrustc seems to make a vtable consisting of uintptr's\n+      tree uint = ctx->get_backend ()->integer_type (\n+\ttrue, ctx->get_backend ()->get_pointer_size ());\n+      tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+      Backend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n+\t\t\t\t   ctx->get_mappings ()->lookup_location (\n+\t\t\t\t     type.get_ty_ref ()));\n+      fields.push_back (std::move (f));\n+    }\n+\n+  tree type_record = ctx->get_backend ()->struct_type (fields);\n+  tree named_struct\n+    = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\n+  ctx->push_type (named_struct);\n+  translated = named_struct;\n+\n+  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "f62581fbfad4fda2d60ccd5c14740658aaa775be", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=3629645386ad503606f29f95c2e16d0600df6e20", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_TYPE\n+#define RUST_COMPILE_TYPE\n+\n+#include \"rust-compile-context.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class TyTyResolveCompile : public TyTy::TyConstVisitor\n+{\n+public:\n+  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n+\t\t       bool trait_object_mode = false)\n+  {\n+    TyTyResolveCompile compiler (ctx, trait_object_mode);\n+    ty->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  void visit (const TyTy::InferType &) override;\n+  void visit (const TyTy::ADTType &) override;\n+  void visit (const TyTy::TupleType &) override;\n+  void visit (const TyTy::FnType &) override;\n+  void visit (const TyTy::FnPtr &) override;\n+  void visit (const TyTy::ArrayType &) override;\n+  void visit (const TyTy::BoolType &) override;\n+  void visit (const TyTy::IntType &) override;\n+  void visit (const TyTy::UintType &) override;\n+  void visit (const TyTy::FloatType &) override;\n+  void visit (const TyTy::USizeType &) override;\n+  void visit (const TyTy::ISizeType &) override;\n+  void visit (const TyTy::ErrorType &) override;\n+  void visit (const TyTy::CharType &) override;\n+  void visit (const TyTy::ReferenceType &) override;\n+  void visit (const TyTy::PointerType &) override;\n+  void visit (const TyTy::ParamType &) override;\n+  void visit (const TyTy::StrType &) override;\n+  void visit (const TyTy::NeverType &) override;\n+  void visit (const TyTy::PlaceholderType &) override;\n+  void visit (const TyTy::ProjectionType &) override;\n+  void visit (const TyTy::DynamicObjectType &) override;\n+  void visit (const TyTy::ClosureType &) override;\n+\n+private:\n+  TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n+    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr),\n+      recursion_count (0)\n+  {}\n+\n+  Context *ctx;\n+  bool trait_object_mode;\n+  tree translated;\n+  size_t recursion_count;\n+\n+  static const size_t kDefaultRecusionLimit = 5;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_TYPE"}, {"sha": "ac3be3bd1809e193cf9bb30cdcfce4259418837d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3629645386ad503606f29f95c2e16d0600df6e20/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=3629645386ad503606f29f95c2e16d0600df6e20", "patch": "@@ -52,270 +52,6 @@ CompileCrate::go ()\n     CompileItem::compile (item.get (), ctx, true);\n }\n \n-// rust-compile-expr.h\n-\n-void\n-CompileExpr::visit (HIR::CallExpr &expr)\n-{\n-  TyTy::BaseType *tyty = nullptr;\n-  if (!ctx->get_tyctx ()->lookup_type (\n-\texpr.get_fnexpr ()->get_mappings ().get_hirid (), &tyty))\n-    {\n-      rust_error_at (expr.get_locus (), \"unknown type\");\n-      return;\n-    }\n-\n-  // must be a tuple constructor\n-  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  if (!is_fn)\n-    {\n-      rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n-      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n-      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n-\n-      rust_assert (!adt->is_enum ());\n-      rust_assert (adt->number_of_variants () == 1);\n-      auto variant = adt->get_variants ().at (0);\n-\n-      // this assumes all fields are in order from type resolution and if a\n-      // base struct was specified those fields are filed via accesors\n-      std::vector<tree> vals;\n-      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n-\t{\n-\t  auto &argument = expr.get_arguments ().at (i);\n-\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n-\n-\t  // assignments are coercion sites so lets convert the rvalue if\n-\t  // necessary\n-\t  auto respective_field = variant->get_field_at_index (i);\n-\t  auto expected = respective_field->get_field_type ();\n-\n-\t  TyTy::BaseType *actual = nullptr;\n-\t  bool ok = ctx->get_tyctx ()->lookup_type (\n-\t    argument->get_mappings ().get_hirid (), &actual);\n-\t  rust_assert (ok);\n-\n-\t  // coerce it if required\n-\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n-\n-\t  // add it to the list\n-\t  vals.push_back (rvalue);\n-\t}\n-\n-      translated\n-\t= ctx->get_backend ()->constructor_expression (compiled_adt_type, vals,\n-\t\t\t\t\t\t       -1, expr.get_locus ());\n-    }\n-  else\n-    {\n-      auto get_parameter_tyty_at_index\n-\t= [] (const TyTy::BaseType *base, size_t index,\n-\t      TyTy::BaseType **result) -> bool {\n-\tbool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n-\t\t     || base->get_kind () == TyTy::TypeKind::FNPTR;\n-\trust_assert (is_fn);\n-\n-\tif (base->get_kind () == TyTy::TypeKind::FNPTR)\n-\t  {\n-\t    const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n-\t    *result = fn->param_at (index);\n-\n-\t    return true;\n-\t  }\n-\n-\tconst TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n-\tauto param = fn->param_at (index);\n-\t*result = param.second;\n-\n-\treturn true;\n-      };\n-\n-      bool is_varadic = false;\n-      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-\t{\n-\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n-\t  is_varadic = fn->is_varadic ();\n-\t}\n-\n-      size_t required_num_args;\n-      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-\t{\n-\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n-\t  required_num_args = fn->num_params ();\n-\t}\n-      else\n-\t{\n-\t  const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n-\t  required_num_args = fn->num_params ();\n-\t}\n-\n-      std::vector<tree> args;\n-      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n-\t{\n-\t  auto &argument = expr.get_arguments ().at (i);\n-\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n-\n-\t  if (is_varadic && i >= required_num_args)\n-\t    {\n-\t      args.push_back (rvalue);\n-\t      continue;\n-\t    }\n-\n-\t  // assignments are coercion sites so lets convert the rvalue if\n-\t  // necessary\n-\t  bool ok;\n-\t  TyTy::BaseType *expected = nullptr;\n-\t  ok = get_parameter_tyty_at_index (tyty, i, &expected);\n-\t  rust_assert (ok);\n-\n-\t  TyTy::BaseType *actual = nullptr;\n-\t  ok = ctx->get_tyctx ()->lookup_type (\n-\t    argument->get_mappings ().get_hirid (), &actual);\n-\t  rust_assert (ok);\n-\n-\t  // coerce it if required\n-\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n-\n-\t  // add it to the list\n-\t  args.push_back (rvalue);\n-\t}\n-\n-      // must be a call to a function\n-      auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n-      auto fncontext = ctx->peek_fn ();\n-      translated\n-\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n-\t\t\t\t\t\targs, nullptr,\n-\t\t\t\t\t\texpr.get_locus ());\n-    }\n-}\n-\n-void\n-CompileExpr::visit (HIR::MethodCallExpr &expr)\n-{\n-  // method receiver\n-  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n-\n-  // lookup the resolved name\n-  NodeId resolved_node_id = UNKNOWN_NODEID;\n-  if (!ctx->get_resolver ()->lookup_resolved_name (\n-\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n-    {\n-      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n-      return;\n-    }\n-\n-  // reverse lookup\n-  HirId ref;\n-  if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n-      return;\n-    }\n-\n-  // lookup the expected function type\n-  TyTy::BaseType *lookup_fntype = nullptr;\n-  bool ok = ctx->get_tyctx ()->lookup_type (\n-    expr.get_method_name ().get_mappings ().get_hirid (), &lookup_fntype);\n-  rust_assert (ok);\n-  rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n-\n-  TyTy::BaseType *receiver = nullptr;\n-  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t   &receiver);\n-  rust_assert (ok);\n-\n-  bool is_dyn_dispatch\n-    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n-  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n-  if (is_generic_receiver)\n-    {\n-      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n-      receiver = p->resolve ();\n-    }\n-\n-  if (is_dyn_dispatch)\n-    {\n-      const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n-\n-      std::vector<HIR::Expr *> arguments;\n-      for (auto &arg : expr.get_arguments ())\n-\targuments.push_back (arg.get ());\n-\n-      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n-\t\t\t\t\t      arguments, expr.get_locus ());\n-      return;\n-    }\n-\n-  // lookup compiled functions since it may have already been compiled\n-  HIR::PathExprSegment method_name = expr.get_method_name ();\n-  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n-  tree fn_expr\n-    = resolve_method_address (fntype, ref, receiver, segment_name,\n-\t\t\t      expr.get_mappings (), expr.get_locus ());\n-\n-  // lookup the autoderef mappings\n-  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n-  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n-    expr.get_mappings ().get_hirid (), &adjustments);\n-  rust_assert (ok);\n-\n-  for (auto &adjustment : *adjustments)\n-    {\n-      switch (adjustment.get_type ())\n-\t{\n-\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n-\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  self = ctx->get_backend ()->address_expression (\n-\t    self, expr.get_receiver ()->get_locus ());\n-\t  break;\n-\n-\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  tree expected_type\n-\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\t  self = ctx->get_backend ()->indirect_expression (\n-\t    expected_type, self, true, /* known_valid*/\n-\t    expr.get_receiver ()->get_locus ());\n-\t  break;\n-\t}\n-    }\n-\n-  std::vector<tree> args;\n-  args.push_back (self); // adjusted self\n-\n-  // normal args\n-  for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n-    {\n-      auto &argument = expr.get_arguments ().at (i);\n-      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n-\n-      // assignments are coercion sites so lets convert the rvalue if\n-      // necessary, offset from the already adjusted implicit self\n-      bool ok;\n-      TyTy::BaseType *expected = fntype->param_at (i + 1).second;\n-\n-      TyTy::BaseType *actual = nullptr;\n-      ok = ctx->get_tyctx ()->lookup_type (\n-\targument->get_mappings ().get_hirid (), &actual);\n-      rust_assert (ok);\n-\n-      // coerce it if required\n-      rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n-\n-      // add it to the list\n-      args.push_back (rvalue);\n-    }\n-\n-  auto fncontext = ctx->peek_fn ();\n-  translated\n-    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n-\t\t\t\t\t    nullptr, expr.get_locus ());\n-}\n-\n // rust-compile-block.h\n \n void"}]}