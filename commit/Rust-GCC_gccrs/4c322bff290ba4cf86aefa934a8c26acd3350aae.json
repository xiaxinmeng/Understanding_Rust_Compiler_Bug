{"sha": "4c322bff290ba4cf86aefa934a8c26acd3350aae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMzMjJiZmYyOTBiYTRjZjg2YWVmYTkzNGE4YzI2YWNkMzM1MGFhZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-08-30T18:16:00Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-08-30T18:16:00Z"}, "message": "JarURLConnection.java (getCertificates): New method from Classpath.\n\n\t* java/net/JarURLConnection.java (getCertificates): New method\n\tfrom Classpath.\n\t* java/net/URLClassLoader.java (URLClassLoader): Extends\n\tSecureClassLoader.\n\t(definePackage): New method from Classpath.\n\t(getPermissions): Likewise.\n\t(newInstance): Likewise.\n\t(findClass): Construct CodeSource for new class (from Classpath).\n\t* java/net/SocketImpl.java (shutdownInput, shutdownOutput): New\n\tmethods.\n\t* java/net/URL.java (getUserInfo): New method.\n\t(set(String,String,int,String,String,String,String,String)): New\n\tmethod.\n\t* java/net/PlainSocketImpl.java (_Jv_SO_KEEPALIVE_): Define.\n\t(shutdownInput, shutdownOutput): Declare.\n\t* java/net/PlainDatagramSocketImpl.java (_Jv_SO_KEEPALIVE_):\n\tDefine.\n\t* java/net/natPlainSocketImpl.cc (setOption): Handle keepalive.\n\t(getOption): Likewise.\n\t(shutdownInput): New method.\n\t(shutdownOutput): Likewise.\n\t* java/net/natPlainDatagramSocketImpl.cc (setOption): Handle\n\tkeepalive.\n\t(getOption): Likewise.\n\t* java/net/SocketOptions.java (SO_KEEPALIVE): New constant.\n\t* java/net/Socket.java (setKeepAlive): New method.\n\t(getKeepAlive): Likewise.\n\t(shutdownInput, shutdownOutput): New methods.\n\nFrom-SVN: r56685", "tree": {"sha": "6b8d006ff1e5363ff7071fe6e79480680b240d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b8d006ff1e5363ff7071fe6e79480680b240d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c322bff290ba4cf86aefa934a8c26acd3350aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c322bff290ba4cf86aefa934a8c26acd3350aae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c322bff290ba4cf86aefa934a8c26acd3350aae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c322bff290ba4cf86aefa934a8c26acd3350aae/comments", "author": null, "committer": null, "parents": [{"sha": "55f49e3d50d0a2d4158ecb93fbb8d079f396b1d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55f49e3d50d0a2d4158ecb93fbb8d079f396b1d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55f49e3d50d0a2d4158ecb93fbb8d079f396b1d2"}], "stats": {"total": 407, "additions": 392, "deletions": 15}, "files": [{"sha": "33c9bb40fc09f4a521fb522e9d8be76dded04b37", "filename": "libjava/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -1,3 +1,34 @@\n+2002-08-29  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/net/JarURLConnection.java (getCertificates): New method\n+\tfrom Classpath.\n+\t* java/net/URLClassLoader.java (URLClassLoader): Extends\n+\tSecureClassLoader.\n+\t(definePackage): New method from Classpath.\n+\t(getPermissions): Likewise.\n+\t(newInstance): Likewise.\n+\t(findClass): Construct CodeSource for new class (from Classpath).\n+\t* java/net/SocketImpl.java (shutdownInput, shutdownOutput): New\n+\tmethods.\n+\t* java/net/URL.java (getUserInfo): New method.\n+\t(set(String,String,int,String,String,String,String,String)): New\n+\tmethod.\n+\t* java/net/PlainSocketImpl.java (_Jv_SO_KEEPALIVE_): Define.\n+\t(shutdownInput, shutdownOutput): Declare.\n+\t* java/net/PlainDatagramSocketImpl.java (_Jv_SO_KEEPALIVE_):\n+\tDefine.\n+\t* java/net/natPlainSocketImpl.cc (setOption): Handle keepalive.\n+\t(getOption): Likewise.\n+\t(shutdownInput): New method.\n+\t(shutdownOutput): Likewise.\n+\t* java/net/natPlainDatagramSocketImpl.cc (setOption): Handle\n+\tkeepalive.\n+\t(getOption): Likewise.\n+\t* java/net/SocketOptions.java (SO_KEEPALIVE): New constant.\n+\t* java/net/Socket.java (setKeepAlive): New method.\n+\t(getKeepAlive): Likewise.\n+\t(shutdownInput, shutdownOutput): New methods.\n+\n 2002-08-29  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/DatagramPacket.java: updated to JDK 1.4 API"}, {"sha": "5ee438dd5152ffad0d2d799dc302126749caa97d", "filename": "libjava/java/net/JarURLConnection.java", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FJarURLConnection.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -15,6 +15,7 @@\n import java.util.Map;\n import java.util.Vector;\n import java.util.Hashtable;\n+import java.security.cert.Certificate;\n \n /**\n  * @author Kresten Krab Thorup <krab@gnu.org>\n@@ -316,4 +317,16 @@ private void getHeaders() throws IOException\n     hdrHash.put(key.toLowerCase(), Long.toString(len));\n   }\n \n+  /**\n+   * Returns an array of Certificate objects for the jar file entry specified\n+   * by this URL or null if there are none\n+   *\n+   * @return A Certificate array\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public Certificate[] getCertificates() throws IOException\n+  {\n+    return getJarEntry().getCertificates();\n+  }\n }"}, {"sha": "5f8a559557c3f806a4c4e6d2f2fe2d54dae1a8ff", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -1,6 +1,6 @@\n // PlainDatagramSocketImpl.java - Implementation of DatagramSocketImpl.\n \n-/* Copyright (C) 1999  Free Software Foundation\n+/* Copyright (C) 1999, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -33,7 +33,8 @@ class PlainDatagramSocketImpl extends DatagramSocketImpl\n                    _Jv_SO_LINGER_ = SocketOptions.SO_LINGER,\n                    _Jv_SO_TIMEOUT_ = SocketOptions.SO_TIMEOUT,\n                    _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,\n-                   _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF;\n+                   _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF,\n+                   _Jv_SO_KEEPALIVE_ = SocketOptions.SO_KEEPALIVE;\n \n   int fnum = -1;\n "}, {"sha": "2146f5e9a7db65aa1c5987f137678b44d36ff442", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -32,7 +32,8 @@ class PlainSocketImpl extends SocketImpl\n                    _Jv_SO_LINGER_ = SocketOptions.SO_LINGER,\n                    _Jv_SO_TIMEOUT_ = SocketOptions.SO_TIMEOUT,\n                    _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,\n-                   _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF;\n+                   _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF,\n+                   _Jv_SO_KEEPALIVE_ = SocketOptions.SO_KEEPALIVE;\n \n   /**\n    * The OS file handle representing the socket.\n@@ -53,6 +54,10 @@ class PlainSocketImpl extends SocketImpl\n \n   public native Object getOption(int optID) throws SocketException;\n \n+  public native void shutdownInput () throws IOException;\n+\n+  public native void shutdownOutput () throws IOException;\n+\n   protected native void create (boolean stream)  throws IOException;\n \n   protected void connect (String host, int port) throws IOException"}, {"sha": "217e6956b5b781e99eb12263059872cd7ee88353", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -617,6 +617,47 @@ public int getReceiveBufferSize () throws SocketException\n       throw new SocketException(\"Internal Error: Unexpected type\");\n   }\n \n+  /**\n+   * This method sets the value for the socket level socket option\n+   * SO_KEEPALIVE.\n+   *\n+   * @param on True if SO_KEEPALIVE should be enabled\n+   *\n+   * @exception SocketException If an error occurs or Socket is not connected\n+   *\n+   * @since Java 1.3\n+   */\n+  public void setKeepAlive (boolean on) throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    impl.setOption(SocketOptions.SO_RCVBUF, new Boolean(on));\n+  }\n+\n+  /**\n+   * This method returns the value of the socket level socket option\n+   * SO_KEEPALIVE.\n+   *\n+   * @return The setting\n+   *\n+   * @exception SocketException If an error occurs or Socket is not connected\n+   *\n+   * @since Java 1.3\n+   */\n+  public boolean getKeepAlive () throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    Object buf = impl.getOption(SocketOptions.SO_RCVBUF);\n+\n+    if (buf instanceof Boolean)\n+      return(((Boolean)buf).booleanValue());\n+    else\n+      throw new SocketException(\"Internal Error: Unexpected type\");\n+  }\n+\n   /**\n    * Closes the socket.\n    *\n@@ -667,4 +708,26 @@ public static synchronized void setSocketImplFactory (SocketImplFactory fac)\n \n     factory = fac;\n   }\n+\n+  /**\n+   * Closes the input side of the socket stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public void shutdownInput() throws IOException \n+  {\n+    if (impl != null)\n+      impl.shutdownInput();\n+  }\n+\n+  /**\n+   * Closes the output side of the socket stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public void shutdownOutput() throws IOException\n+  {\n+    if (impl != null)\n+      impl.shutdownOutput();\n+  }\n }"}, {"sha": "7dcf87de629b921958772387e1e1a4ee479a3127", "filename": "libjava/java/net/SocketImpl.java", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImpl.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -264,4 +264,20 @@ public abstract void setOption(int option_id, Object val)\n    * @XXX This redeclaration from SocketOptions is a workaround to a gcj bug.\n    */\n   public abstract Object getOption(int option_id) throws SocketException;\n+\n+  /**\n+   * Shut down the input side of this socket.  Subsequent reads will\n+   * return end-of-file.\n+   *\n+   * @exception IOException if an error occurs\n+   */\n+  public abstract void shutdownInput () throws IOException;\n+\n+  /**\n+   * Shut down the output side of this socket.  Subsequent writes will\n+   * fail with an IOException.\n+   *\n+   * @exception IOException if an error occurs\n+   */\n+  public abstract void shutdownOutput () throws IOException;\n }"}, {"sha": "bf57450d0375dee24ec465bb79da26c50682c87f", "filename": "libjava/java/net/SocketOptions.java", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FSocketOptions.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FSocketOptions.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketOptions.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -1,5 +1,5 @@\n /* SocketOptions.java -- Implements options for sockets (duh!)\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -61,6 +61,11 @@\n  * Static Variables\n  */\n \n+/**\n+ * Option id for the SO_KEEPALIVE value\n+ */\n+static final int SO_KEEPALIVE = 0x8;\n+\n /**\n   * Option id for the SO_LINGER value\n   */"}, {"sha": "73edeca415d5140b1406d106019c768429e6142f", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -175,7 +175,8 @@ else if (context != null)\n       this.handler = setURLStreamHandler(protocol);\n \n     if (this.handler == null)\n-      throw new MalformedURLException(\"Protocol handler not found: \" + protocol);\n+      throw new MalformedURLException(\"Protocol handler not found: \"\n+\t\t\t\t      + protocol);\n \n     // JDK 1.2 doc for parseURL specifically states that any '#' ref\n     // is to be excluded by passing the 'limit' as the indexOf the '#'\n@@ -245,6 +246,12 @@ public String getRef()\n     return ref;\n   }\n \n+  public String getUserInfo ()\n+  {\n+    int at = host.indexOf('@');\n+    return at < 0 ? null : host.substring(0, at);\n+  }\n+\n   public int hashCode()\n   {\n     // JCL book says this is computed using (only) the hashcodes of the \n@@ -299,6 +306,30 @@ protected void set(String protocol, String host, int port, String file,\n     hashCode = hashCode();\t\t\t// Used for serialization.\n   }\n \n+  /** @since 1.3 */\n+  protected void set(String protocol, String host, int port,\n+\t\t     String authority, String userInfo,\n+\t\t     String path, String query, String ref)\n+  {\n+    // TBD: Theoretically, a poorly written StreamHandler could pass an\n+    // invalid protocol.  It will cause the handler to be set to null\n+    // thus overriding a valid handler.  Callers of this method should\n+    // be aware of this.\n+    this.handler = setURLStreamHandler(protocol);\n+    this.protocol = protocol;\n+    if (userInfo == null)\n+      this.host = host;\n+    else\n+      this.host = userInfo + \"@\" + host;\n+    this.port = port;\n+    if (query == null)\n+      this.file = path;\n+    else\n+      this.file = path + \"?\" + query;\n+    this.ref = ref;\n+    hashCode = hashCode();\t\t\t// Used for serialization.\n+  }\n+\n   public static synchronized void\n \tsetURLStreamHandlerFactory(URLStreamHandlerFactory fac)\n   {"}, {"sha": "3afb8f1861ccc981c25edff66f557c6957fffad7", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 170, "deletions": 7, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -12,11 +12,15 @@\n import java.util.jar.*;\n import java.util.Enumeration;\n import java.util.Vector;\n+import java.security.CodeSource;\n+import java.security.SecureClassLoader;\n+import java.security.PermissionCollection;\n+import java.security.cert.Certificate;\n \n /**\n  * @since 1.2\n  */\n-public class URLClassLoader extends ClassLoader \n+public class URLClassLoader extends SecureClassLoader\n {\n   // The URLStreamHandlerFactory\n   URLStreamHandlerFactory factory = null;\n@@ -228,12 +232,12 @@ protected Class findClass (String name)\n \n     try \n       {\n-\tURL u = getResource (name.replace ('.', '/') + \".class\");\n+\tURL url = getResource (name.replace ('.', '/') + \".class\");\n \n-\tif (u == null)\n+\tif (url == null)\n \t  throw new ClassNotFoundException (name);\n \n-\tURLConnection connection = u.openConnection ();\n+\tURLConnection connection = url.openConnection ();\n \tInputStream is = connection.getInputStream ();\n \n \tint len = connection.getContentLength ();\n@@ -250,12 +254,171 @@ protected Class findClass (String name)\n \t    off += c;\n \t  }\n \n-\treturn defineClass (name, data, 0, len);\n+\t// Now construct the CodeSource (if loaded from a jar file)\n+\tCodeSource source = null;\n+\tif (url.getProtocol().equals(\"jar\"))\n+\t  {\n+\t    Certificate[] certificates =\n+\t      ((JarURLConnection) connection).getCertificates();\n+\t    String u = url.toExternalForm ();\n+\t    u = u.substring (4); //skip \"jar:\"\n+\t    int i = u.indexOf ('!');\n+\t    if (i >= 0)\n+\t      u = u.substring (0, i);\n+\t    url = new URL(\"jar\", \"\", u);\n+\n+\t    source = new CodeSource(url, certificates);\n+\t  }\n+\telse if (url.getProtocol().equals(\"file\"))\n+\t  {\n+\t    try\n+\t      {\n+\t\tString u = url.toExternalForm();\n+\t\t// Skip \"file:\" and then get canonical directory name.\n+\t\tFile f = new File(u.substring(5));\n+\t\tf = f.getCanonicalFile();\n+\t\turl = new URL(\"file\", \"\", f.getParent());\n+\t\tsource = new CodeSource (url, null);\n+\t      }\n+\t    catch (IOException ignore)\n+\t      {\n+\t      }\n+\t  }\n+\n+\treturn defineClass (name, data, 0, len, source);\n       } \n     catch (java.io.IOException x)\n       {\n \tthrow new ClassNotFoundException(name);\n       }\n   }\n-}\n \n+  /** \n+   * Defines a Package based on the given name and the supplied manifest\n+   * information. The manifest indicates the tile, version and\n+   * vendor information of the specification and implementation and wheter the\n+   * package is sealed. If the Manifest indicates that the package is sealed\n+   * then the Package will be sealed with respect to the supplied URL.\n+   *\n+   * @exception IllegalArgumentException If this package name already exists\n+   * in this class loader\n+   * @param name The name of the package\n+   * @param manifest The manifest describing the specification,\n+   * implementation and sealing details of the package\n+   * @param url the code source url to seal the package\n+   * @return the defined Package\n+   */\n+  protected Package definePackage(String name, Manifest manifest, URL url) \n+    throws IllegalArgumentException\n+  {\n+    Attributes attr = manifest.getMainAttributes();\n+    String specTitle =\n+      attr.getValue(Attributes.Name.SPECIFICATION_TITLE); \n+    String specVersion =\n+      attr.getValue(Attributes.Name.SPECIFICATION_VERSION); \n+    String specVendor =\n+      attr.getValue(Attributes.Name.SPECIFICATION_VENDOR); \n+    String implTitle =\n+      attr.getValue(Attributes.Name.IMPLEMENTATION_TITLE); \n+    String implVersion =\n+      attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION); \n+    String implVendor =\n+      attr.getValue(Attributes.Name.IMPLEMENTATION_VENDOR);\n+\n+    // Look if the Manifest indicates that this package is sealed\n+    // XXX - most likely not completely correct!\n+    // Shouldn't we also check the sealed attribute of the complete jar?\n+    // http://java.sun.com/products/jdk/1.3/docs/guide/extensions/spec.html#bundled\n+    // But how do we get that jar manifest here?\n+    String sealed = attr.getValue(Attributes.Name.SEALED);\n+    if (\"false\".equals(sealed))\n+      {\n+\t// Make sure that the URL is null so the package is not\n+\t// sealed.\n+\turl = null;\n+      }\n+\n+    return definePackage(name, specTitle, specVersion, specVendor,\n+\t\t\t implTitle, implVersion, implVendor, url);\n+  }\n+\n+  /**\n+   * Returns the permissions needed to access a particular code source.\n+   * These permissions includes those returned by\n+   * <CODE>SecureClassLoader.getPermissions</CODE> and the actual permissions\n+   * to access the objects referenced by the URL of the code source.\n+   * The extra permissions added depend on the protocol and file portion of\n+   * the URL in the code source. If the URL has the \"file\" protocol ends with\n+   * a / character then it must be a directory and a file Permission to read\n+   * everthing in that directory and all subdirectories is added. If the URL\n+   * had the \"file\" protocol and doesn't end with a / character then it must\n+   * be a normal file and a file permission to read that file is added. If the\n+   * URL has any other protocol then a socket permission to connect and accept\n+   * connections from the host portion of the URL is added.\n+   * @param source The codesource that needs the permissions to be accessed\n+   * @return the collection of permissions needed to access the code resource\n+   * @see SecureClassLoader.getPermissions()\n+   */\n+  protected PermissionCollection getPermissions(CodeSource source)\n+  {\n+    // XXX - This implementation does exactly as the Javadoc describes.\n+    // But maybe we should/could use URLConnection.getPermissions()?\n+\n+    // First get the permissions that would normally be granted\n+    PermissionCollection permissions = super.getPermissions(source);\n+        \n+    // Now add the any extra permissions depending on the URL location\n+    URL url = source.getLocation();\n+    String protocol = url.getProtocol();\n+    if (protocol.equals(\"file\"))\n+      {\n+\tString file = url.getFile();\n+\t// If the file end in / it must be an directory\n+\tif (file.endsWith(\"/\"))\n+\t  {\n+\t    // Grant permission to read everything in that directory and\n+\t    // all subdirectories\n+\t    permissions.add(new FilePermission(file + \"-\", \"read\"));\n+\t  }\n+\telse\n+\t  {\n+\t    // It is a 'normal' file\n+\t    // Grant permission to access that file\n+\t    permissions.add(new FilePermission(file, \"read\"));\n+\t  }\n+      }\n+    else\n+      {\n+\t// Grant permission to connect to and accept connections from host\n+\t  String host = url.getHost();\n+\t  permissions.add(new SocketPermission(host, \"connect,accept\"));\n+      }\n+\n+    return permissions;\n+  }\n+\n+  /**\n+   * Creates a new instance of a URLClassLoader that gets classes from the\n+   * supplied URLs. This class loader will have as parent the standard\n+   * system class loader.\n+   * @param urls the initial URLs used to resolve classes and resources\n+   */\n+  public static URLClassLoader newInstance(URL urls[]) throws\n+    SecurityException\n+  {\n+    return new URLClassLoader(urls);\n+  }\n+\n+  /**\n+   * Creates a new instance of a URLClassLoader that gets classes from the\n+   * supplied URLs and with the supplied loader as parent class loader.\n+   * @param urls the initial URLs used to resolve classes and resources\n+   * @param parent the parent class loader\n+   */\n+  public static URLClassLoader newInstance(URL urls[],\n+\t\t\t\t\t   ClassLoader parent)\n+    throws SecurityException\n+  {\n+    return new URLClassLoader(urls, parent);\n+  }\n+}"}, {"sha": "bb306e202bdfe572ba82ad94a07b205d45655ec7", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -524,6 +524,10 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_LINGER not valid for UDP\"));\n         return;\n+      case _Jv_SO_KEEPALIVE_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n+        return;\n       case _Jv_SO_SNDBUF_ :\n       case _Jv_SO_RCVBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n@@ -613,11 +617,14 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"TCP_NODELAY not valid for UDP\"));\n         break;\n-\n       case _Jv_SO_LINGER_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_LINGER not valid for UDP\"));\n         break;    \n+      case _Jv_SO_KEEPALIVE_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n+        break;\n       case _Jv_SO_RCVBUF_ :\n       case _Jv_SO_SNDBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)"}, {"sha": "f82aa6bb47cee3009dc939833b2feb98072bd057", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c322bff290ba4cf86aefa934a8c26acd3350aae/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=4c322bff290ba4cf86aefa934a8c26acd3350aae", "patch": "@@ -222,6 +222,20 @@ java::net::PlainSocketImpl::close(void)\n     JvNewStringLatin1 (\"SocketImpl.close: unimplemented\"));\n }\n \n+void\n+java::net::PlainSocketImpl::shutdownInput (void)\n+{\n+  throw new SocketException (\n+    JvNewStringLatin1 (\"SocketImpl.shutdownInput: unimplemented\"));\n+}\n+\n+void\n+java::net::PlainSocketImpl::shutdownOutput (void)\n+{\n+  throw new SocketException (\n+    JvNewStringLatin1 (\"SocketImpl.shutdownOutput: unimplemented\"));\n+}\n+\n #else /* DISABLE_JAVA_NET */\n \n union SockAddr\n@@ -722,12 +736,18 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n #ifdef TCP_NODELAY\n         if (::setsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n \t    val_len) != 0)\n-\t  goto error;    \n+\t  goto error;\n #else\n         throw new java::lang::InternalError (\n           JvNewStringUTF (\"TCP_NODELAY not supported\"));\n #endif /* TCP_NODELAY */\n         return;\n+\n+      case _Jv_SO_KEEPALIVE_ :\n+        if (::setsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n+\t    val_len) != 0)\n+\t  goto error;\n+\n       case _Jv_SO_LINGER_ :\n #ifdef SO_LINGER\n         struct linger l_val;\n@@ -816,6 +836,14 @@ java::net::PlainSocketImpl::getOption (jint optID)\n           JvNewStringUTF (\"SO_LINGER not supported\"));\n #endif\n         break;    \n+\n+      case _Jv_SO_KEEPALIVE_ :\n+        if (::getsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n+\t    &val_len) != 0)\n+          goto error;\n+        else\n+\t  return new java::lang::Boolean (val != 0);\n+\n       case _Jv_SO_RCVBUF_ :\n       case _Jv_SO_SNDBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n@@ -876,4 +904,18 @@ java::net::PlainSocketImpl::getOption (jint optID)\n   throw new java::net::SocketException (JvNewStringUTF (strerr));\n }\n \n+void\n+java::net::PlainSocketImpl::shutdownInput (void)\n+{\n+  if (::shutdown (fnum, 0))\n+    throw new SocketException (JvNewStringUTF (strerror (errno)));\n+}\n+\n+void\n+java::net::PlainSocketImpl::shutdownOutput (void)\n+{\n+  if (::shutdown (fnum, 1))\n+    throw new SocketException (JvNewStringUTF (strerror (errno)));\n+}\n+\n #endif /* DISABLE_JAVA_NET */"}]}