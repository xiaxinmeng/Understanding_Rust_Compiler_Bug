{"sha": "2929029c50e34fdc22da8b8b029daa880dd70359", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkyOTAyOWM1MGUzNGZkYzIyZGE4YjhiMDI5ZGFhODgwZGQ3MDM1OQ==", "commit": {"author": {"name": "Wei Guozhi", "email": "carrot@google.com", "date": "2009-10-27T09:06:36Z"}, "committer": {"name": "Wei Guozhi", "email": "carrot@gcc.gnu.org", "date": "2009-10-27T09:06:36Z"}, "message": "target.h (have_conditional_execution): Add a new target hook function.\n\n\t* target.h (have_conditional_execution): Add a new target hook function.\n\t* target-def.h (TARGET_HAVE_CONDITIONAL_EXECUTION): Likewise.\n\t* targhooks.h (default_have_conditional_execution): Likewise.\n\t* targhooks.c (default_have_conditional_execution): Likewise.\n\t* doc/tm.texi (TARGET_HAVE_CONDITIONAL_EXECUTION): Document it.\n\t* config/arm/arm.c (TARGET_HAVE_CONDITIONAL_EXECUTION): Define it.\n\t(arm_have_conditional_execution): New function.\n\t* ifcvt.c (noce_process_if_block, find_if_header,\n\tcond_exec_find_if_block, dead_or_predicable): Change the usage of macro\n\tHAVE_conditional_execution to a target hook call.\n\t* recog.c (peephole2_optimize): Likewise.\n\t* sched-rgn.c (add_branch_dependences): Likewise.\n\t* final.c (asm_insn_count, final_scan_insn): Likewise.\n\t* bb-reorder.c (HAVE_conditional_execution): Remove it.\n\nFrom-SVN: r153584", "tree": {"sha": "5ae128336a4b205cba9a2852606f3947295a32f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ae128336a4b205cba9a2852606f3947295a32f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2929029c50e34fdc22da8b8b029daa880dd70359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2929029c50e34fdc22da8b8b029daa880dd70359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2929029c50e34fdc22da8b8b029daa880dd70359", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2929029c50e34fdc22da8b8b029daa880dd70359/comments", "author": {"login": "weiguozhi", "id": 57237827, "node_id": "MDQ6VXNlcjU3MjM3ODI3", "avatar_url": "https://avatars.githubusercontent.com/u/57237827?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weiguozhi", "html_url": "https://github.com/weiguozhi", "followers_url": "https://api.github.com/users/weiguozhi/followers", "following_url": "https://api.github.com/users/weiguozhi/following{/other_user}", "gists_url": "https://api.github.com/users/weiguozhi/gists{/gist_id}", "starred_url": "https://api.github.com/users/weiguozhi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weiguozhi/subscriptions", "organizations_url": "https://api.github.com/users/weiguozhi/orgs", "repos_url": "https://api.github.com/users/weiguozhi/repos", "events_url": "https://api.github.com/users/weiguozhi/events{/privacy}", "received_events_url": "https://api.github.com/users/weiguozhi/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c67ec2204d7db5ad689b2b4728c8816bbbe6c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c67ec2204d7db5ad689b2b4728c8816bbbe6c3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c67ec2204d7db5ad689b2b4728c8816bbbe6c3e"}], "stats": {"total": 151, "additions": 97, "deletions": 54}, "files": [{"sha": "14d1ed1a59ffe7917c10ccd1cdd3a87b1e2edd8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -1,3 +1,21 @@\n+2009-10-27  Wei Guozhi  <carrot@google.com>\n+\n+\tPR target/41705\n+\t* target.h (have_conditional_execution): Add a new target hook function.\n+\t* target-def.h (TARGET_HAVE_CONDITIONAL_EXECUTION): Likewise.\n+\t* targhooks.h (default_have_conditional_execution): Likewise.\n+\t* targhooks.c (default_have_conditional_execution): Likewise.\n+\t* doc/tm.texi (TARGET_HAVE_CONDITIONAL_EXECUTION): Document it.\n+\t* config/arm/arm.c (TARGET_HAVE_CONDITIONAL_EXECUTION): Define it.\n+\t(arm_have_conditional_execution): New function.\n+\t* ifcvt.c (noce_process_if_block, find_if_header,\n+\tcond_exec_find_if_block, dead_or_predicable): Change the usage of macro\n+\tHAVE_conditional_execution to a target hook call.\n+\t* recog.c (peephole2_optimize): Likewise.\n+\t* sched-rgn.c (add_branch_dependences): Likewise.\n+\t* final.c (asm_insn_count, final_scan_insn): Likewise.\n+\t* bb-reorder.c (HAVE_conditional_execution): Remove it.\n+\n 2009-10-26  Ben Elliston  <bje@au.ibm.com>\n \t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n \t    Ulrich Weigand  <uweigand@de.ibm.com>"}, {"sha": "47828bf28c1ae87b1726610bf31d255a5c18bf3f", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -86,10 +86,6 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n \n-#ifndef HAVE_conditional_execution\n-#define HAVE_conditional_execution 0\n-#endif\n-\n /* The number of rounds.  In most cases there will only be 4 rounds, but\n    when partitioning hot and cold basic blocks into separate sections of\n    the .o file there will be an extra round.*/\n@@ -2297,5 +2293,3 @@ struct rtl_opt_pass pass_partition_blocks =\n   TODO_dump_func | TODO_verify_rtl_sharing/* todo_flags_finish */\n  }\n };\n-\n-"}, {"sha": "35bd3946c57abddd6fc6255b6868df11086c5e11", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -138,6 +138,7 @@ static rtx arm_libcall_value (enum machine_mode, const_rtx);\n static void arm_internal_label (FILE *, const char *, unsigned long);\n static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t tree);\n+static bool arm_have_conditional_execution (void);\n static bool arm_rtx_costs_1 (rtx, enum rtx_code, int*, bool);\n static bool arm_size_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);\n static bool arm_slowmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n@@ -445,6 +446,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_HAVE_TLS true\n #endif\n \n+#undef TARGET_HAVE_CONDITIONAL_EXECUTION\n+#define TARGET_HAVE_CONDITIONAL_EXECUTION arm_have_conditional_execution\n+\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM arm_cannot_force_const_mem\n \n@@ -21183,4 +21187,12 @@ arm_frame_pointer_required (void)\n           || (TARGET_ARM && TARGET_APCS_FRAME && ! leaf_function_p ()));\n }\n \n+/* Only thumb1 can't support conditional execution, so return true if\n+   the target is not thumb1.  */\n+static bool\n+arm_have_conditional_execution (void)\n+{\n+  return !TARGET_THUMB1;\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "0f33d3d1a8d9d012dacbde98f9c18c7590f24c90", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -10842,6 +10842,12 @@ to have to make special provisions in @code{INITIAL_ELIMINATION_OFFSET}\n to reserve space for caller-saved target registers.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_HAVE_CONDITIONAL_EXECUTION (void)\n+This target hook returns true if the target supports conditional execution.\n+This target hook is required only when the target has several different\n+modes and they have different conditional execution capability, such as ARM.\n+@end deftypefn\n+\n @defmac POWI_MAX_MULTS\n If defined, this macro is interpreted as a signed integer C expression\n that specifies the maximum number of floating point multiplications"}, {"sha": "ef450d2fe3edf1c024866196a9fee2eca26edacb", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -204,10 +204,8 @@ rtx final_sequence;\n static int dialect_number;\n #endif\n \n-#ifdef HAVE_conditional_execution\n /* Nonnull if the insn currently being emitted was a COND_EXEC pattern.  */\n rtx current_insn_predicate;\n-#endif\n \n #ifdef HAVE_ATTR_length\n static int asm_insn_count (rtx);\n@@ -2102,10 +2100,9 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tconst char *templ;\n \tbool is_stmt;\n \n-#ifdef HAVE_conditional_execution\n \t/* Reset this early so it is correct for ASM statements.  */\n \tcurrent_insn_predicate = NULL_RTX;\n-#endif\n+\n \t/* An INSN, JUMP_INSN or CALL_INSN.\n \t   First check for special kinds that recog doesn't recognize.  */\n \n@@ -2590,10 +2587,9 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tFINAL_PRESCAN_INSN (insn, recog_data.operand, recog_data.n_operands);\n #endif\n \n-#ifdef HAVE_conditional_execution\n-\tif (GET_CODE (PATTERN (insn)) == COND_EXEC)\n+\tif (targetm.have_conditional_execution ()\n+\t    && GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t  current_insn_predicate = COND_EXEC_TEST (PATTERN (insn));\n-#endif\n \n #ifdef HAVE_cc0\n \tcc_prev_status = cc_status;"}, {"sha": "4417e6e6b8783dfa14559090383761fde32bbf24", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -47,9 +47,6 @@\n #include \"vecprim.h\"\n #include \"dbgcnt.h\"\n \n-#ifndef HAVE_conditional_execution\n-#define HAVE_conditional_execution 0\n-#endif\n #ifndef HAVE_conditional_move\n #define HAVE_conditional_move 0\n #endif\n@@ -2426,7 +2423,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n   if (HAVE_conditional_move\n       && noce_try_cmove (if_info))\n     goto success;\n-  if (! HAVE_conditional_execution)\n+  if (! targetm.have_conditional_execution ())\n     {\n       if (noce_try_store_flag_constants (if_info))\n \tgoto success;\n@@ -3070,7 +3067,7 @@ find_if_header (basic_block test_bb, int pass)\n       && noce_find_if_block (test_bb, then_edge, else_edge, pass))\n     goto success;\n \n-  if (HAVE_conditional_execution && reload_completed\n+  if (targetm.have_conditional_execution () && reload_completed\n       && cond_exec_find_if_block (&ce_info))\n     goto success;\n \n@@ -3080,7 +3077,7 @@ find_if_header (basic_block test_bb, int pass)\n     goto success;\n \n   if (dom_info_state (CDI_POST_DOMINATORS) >= DOM_NO_FAST_QUERY\n-      && (! HAVE_conditional_execution || reload_completed))\n+      && (! targetm.have_conditional_execution () || reload_completed))\n     {\n       if (find_if_case_1 (test_bb, then_edge, else_edge))\n \tgoto success;\n@@ -3187,7 +3184,7 @@ cond_exec_find_if_block (struct ce_if_block * ce_info)\n \n   /* We only ever should get here after reload,\n      and only if we have conditional execution.  */\n-  gcc_assert (HAVE_conditional_execution && reload_completed);\n+  gcc_assert (targetm.have_conditional_execution () && reload_completed);\n \n   /* Discover if any fall through predecessors of the current test basic block\n      were && tests (which jump to the else block) or || tests (which jump to\n@@ -3865,7 +3862,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   /* Disable handling dead code by conditional execution if the machine needs\n      to do anything funny with the tests, etc.  */\n #ifndef IFCVT_MODIFY_TESTS\n-  if (HAVE_conditional_execution)\n+  if (targetm.have_conditional_execution ())\n     {\n       /* In the conditional execution case, we have things easy.  We know\n \t the condition is reversible.  We don't have to check life info"}, {"sha": "4ad3be9dfaf16a4414a5b667c0835b1f36af6fe7", "filename": "gcc/recog.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -3279,40 +3279,44 @@ peephole2_optimize (void)\n \t\t      do_cleanup_cfg |= purge_dead_edges (bb);\n \t\t    }\n \n-#ifdef HAVE_conditional_execution\n-\t\t  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n-\t\t    peep2_insn_data[i].insn = NULL_RTX;\n-\t\t  peep2_insn_data[peep2_current].insn = PEEP2_EOB;\n-\t\t  peep2_current_count = 0;\n-#else\n-\t\t  /* Back up lifetime information past the end of the\n-\t\t     newly created sequence.  */\n-\t\t  if (++i >= MAX_INSNS_PER_PEEP2 + 1)\n-\t\t    i = 0;\n-\t\t  bitmap_copy (live, peep2_insn_data[i].live_before);\n-\n-\t\t  /* Update life information for the new sequence.  */\n-\t\t  x = attempt;\n-\t\t  do\n+\t\t  if (targetm.have_conditional_execution ())\n \t\t    {\n-\t\t      if (INSN_P (x))\n+\t\t      for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n+\t\t\tpeep2_insn_data[i].insn = NULL_RTX;\n+\t\t      peep2_insn_data[peep2_current].insn = PEEP2_EOB;\n+\t\t      peep2_current_count = 0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Back up lifetime information past the end of the\n+\t\t\t newly created sequence.  */\n+\t\t      if (++i >= MAX_INSNS_PER_PEEP2 + 1)\n+\t\t\ti = 0;\n+\t\t      bitmap_copy (live, peep2_insn_data[i].live_before);\n+\n+\t\t      /* Update life information for the new sequence.  */\n+\t\t      x = attempt;\n+\t\t      do\n \t\t\t{\n-\t\t\t  if (--i < 0)\n-\t\t\t    i = MAX_INSNS_PER_PEEP2;\n-\t\t\t  if (peep2_current_count < MAX_INSNS_PER_PEEP2\n-\t\t\t      && peep2_insn_data[i].insn == NULL_RTX)\n-\t\t\t    peep2_current_count++;\n-\t\t\t  peep2_insn_data[i].insn = x;\n-\t\t\t  df_insn_rescan (x);\n-\t\t\t  df_simulate_one_insn_backwards (bb, x, live);\n-\t\t\t  bitmap_copy (peep2_insn_data[i].live_before, live);\n+\t\t\t  if (INSN_P (x))\n+\t\t\t    {\n+\t\t\t      if (--i < 0)\n+\t\t\t\ti = MAX_INSNS_PER_PEEP2;\n+\t\t\t      if (peep2_current_count < MAX_INSNS_PER_PEEP2\n+\t\t\t\t  && peep2_insn_data[i].insn == NULL_RTX)\n+\t\t\t\tpeep2_current_count++;\n+\t\t\t      peep2_insn_data[i].insn = x;\n+\t\t\t      df_insn_rescan (x);\n+\t\t\t      df_simulate_one_insn_backwards (bb, x, live);\n+\t\t\t      bitmap_copy (peep2_insn_data[i].live_before,\n+\t\t\t\t\t   live);\n+\t\t\t    }\n+\t\t\t  x = PREV_INSN (x);\n \t\t\t}\n-\t\t      x = PREV_INSN (x);\n-\t\t    }\n-\t\t  while (x != prev);\n+\t\t      while (x != prev);\n \n-\t\t  peep2_current = i;\n-#endif\n+\t\t      peep2_current = i;\n+\t\t    }\n \n \t\t  /* If we generated a jump instruction, it won't have\n \t\t     JUMP_LABEL set.  Recompute after we're done.  */"}, {"sha": "0acdc4a2a47b5f1abc6d8072d48d57689f76933a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -2508,7 +2508,9 @@ add_branch_dependences (rtx head, rtx tail)\n \t  add_dependence (last, insn, REG_DEP_ANTI);\n       }\n \n-#ifdef HAVE_conditional_execution\n+  if (!targetm.have_conditional_execution ())\n+    return;\n+\n   /* Finally, if the block ends in a jump, and we are doing intra-block\n      scheduling, make sure that the branch depends on any COND_EXEC insns\n      inside the block to avoid moving the COND_EXECs past the branch insn.\n@@ -2557,7 +2559,6 @@ add_branch_dependences (rtx head, rtx tail)\n       if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == COND_EXEC)\n \tadd_dependence (tail, insn, REG_DEP_ANTI);\n     }\n-#endif\n }\n \n /* Data structures for the computation of data dependences in a regions.  We\n@@ -3588,4 +3589,3 @@ struct rtl_opt_pass pass_sched2 =\n   TODO_ggc_collect                      /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "c5a73216780b32b867e69c8fce03e798210513f5", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -534,6 +534,7 @@\n #define TARGET_BRANCH_TARGET_REGISTER_CLASS \\\n   default_branch_target_register_class\n #define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED hook_bool_bool_false\n+#define TARGET_HAVE_CONDITIONAL_EXECUTION default_have_conditional_execution\n #define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false\n #define TARGET_CANNOT_COPY_INSN_P NULL\n #define TARGET_COMMUTATIVE_P hook_bool_const_rtx_commutative_p\n@@ -934,6 +935,7 @@\n   TARGET_CANNOT_MODIFY_JUMPS_P,\t\t\t\\\n   TARGET_BRANCH_TARGET_REGISTER_CLASS,\t\t\\\n   TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED,\t\\\n+  TARGET_HAVE_CONDITIONAL_EXECUTION,\t\t\\\n   TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n   TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n   TARGET_COMMUTATIVE_P,\t\t\t\t\\"}, {"sha": "31a54f321df2ad6f4b05c73b047f7cc86bd60ea2", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -621,6 +621,9 @@ struct gcc_target\n      already been generated.  */\n   bool (* branch_target_register_callee_saved) (bool after_pe_gen);\n \n+  /* Return true if the target supports conditional execution.  */\n+  bool (* have_conditional_execution) (void);\n+\n   /* True if the constant X cannot be placed in the constant pool.  */\n   bool (* cannot_force_const_mem) (rtx);\n "}, {"sha": "dfc470c869ec707014d49236cd1065778821a495", "filename": "gcc/targhooks.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -998,4 +998,14 @@ unsigned int default_case_values_threshold (void)\n   return (HAVE_casesi ? 4 : 5);\n }\n \n+bool\n+default_have_conditional_execution (void)\n+{\n+#ifdef HAVE_conditional_execution\n+  return HAVE_conditional_execution;\n+#else\n+  return false;\n+#endif\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "365496b9825d360dcaa1489f64caff37ab1bc58d", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2929029c50e34fdc22da8b8b029daa880dd70359/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=2929029c50e34fdc22da8b8b029daa880dd70359", "patch": "@@ -131,3 +131,4 @@ extern rtx default_addr_space_legitimize_address (rtx, rtx, enum machine_mode,\n extern bool default_addr_space_subset_p (addr_space_t, addr_space_t);\n extern rtx default_addr_space_convert (rtx, tree, tree);\n extern unsigned int default_case_values_threshold (void);\n+extern bool default_have_conditional_execution (void);"}]}