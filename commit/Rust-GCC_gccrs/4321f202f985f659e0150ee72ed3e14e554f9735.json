{"sha": "4321f202f985f659e0150ee72ed3e14e554f9735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyMWYyMDJmOTg1ZjY1OWUwMTUwZWU3MmVkM2UxNGU1NTRmOTczNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-07T03:11:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-07T03:11:47Z"}, "message": "syscall: add Hurd support\n    \n    Loosely based on a patch by Svante Signell.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/161518\n\nFrom-SVN: r268603", "tree": {"sha": "fee209b557ac0c36614bc7f9a12f2d4559517db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fee209b557ac0c36614bc7f9a12f2d4559517db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4321f202f985f659e0150ee72ed3e14e554f9735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4321f202f985f659e0150ee72ed3e14e554f9735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4321f202f985f659e0150ee72ed3e14e554f9735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4321f202f985f659e0150ee72ed3e14e554f9735/comments", "author": null, "committer": null, "parents": [{"sha": "9fa4b2aa45d3ceec8f13cc6b1415a84d13254018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa4b2aa45d3ceec8f13cc6b1415a84d13254018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fa4b2aa45d3ceec8f13cc6b1415a84d13254018"}], "stats": {"total": 323, "additions": 189, "deletions": 134}, "files": [{"sha": "53780e1bc2139cdc480d0b54260757650fcc991e", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -1,4 +1,4 @@\n-77f0f28af556f50c561ff5c2cca17ad6f985068e\n+db618eeabdcf1ba56861d21d5639ca4514cd6934\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "5b19e6f202d8475c99e0633b41844550c02bb26d", "filename": "libgo/go/syscall/errstr_glibc.go", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Ferrstr_glibc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Ferrstr_glibc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr_glibc.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -1,4 +1,4 @@\n-// errstr_linux.go -- GNU/Linux specific error strings.\n+// errstr_glibc.go -- GNU/Linux and GNU/Hurd specific error strings.\n \n // Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n@@ -7,6 +7,8 @@\n // We use this rather than errstr.go because on GNU/Linux sterror_r\n // returns a pointer to the error message, and may not use buf at all.\n \n+// +build hurd linux\n+\n package syscall\n \n import \"unsafe\"", "previous_filename": "libgo/go/syscall/errstr_linux.go"}, {"sha": "bad2ce44302feefd0a3d45cbaf02eff9a47409b6", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n+// +build aix darwin dragonfly freebsd hurd linux netbsd openbsd solaris\n \n // Fork, exec, wait, etc.\n \n@@ -319,7 +319,7 @@ func Exec(argv0 string, argv []string, envv []string) (err error) {\n \truntime_BeforeExec()\n \n \tvar err1 error\n-\tif runtime.GOOS == \"solaris\" || runtime.GOOS == \"aix\" {\n+\tif runtime.GOOS == \"solaris\" || runtime.GOOS == \"aix\" || runtime.GOOS == \"hurd\" {\n \t\t// RawSyscall should never be used on Solaris or AIX.\n \t\terr1 = execveLibc(\n \t\t\tuintptr(unsafe.Pointer(argv0p)),"}, {"sha": "a90fc9b3f8bdd5278ee8248d585cdb865e642fa2", "filename": "libgo/go/syscall/libcall_glibc.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_glibc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_glibc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_glibc.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build hurd linux\n+\n+// glibc library calls.\n+\n+package syscall\n+\n+import (\n+\t\"internal/race\"\n+\t\"unsafe\"\n+)\n+\n+//sys\tOpenat(dirfd int, path string, flags int, mode uint32) (fd int, err error)\n+//__go_openat(dirfd _C_int, path *byte, flags _C_int, mode Mode_t) _C_int\n+\n+//sys\tfutimesat(dirfd int, path *byte, times *[2]Timeval) (err error)\n+//futimesat(dirfd _C_int, path *byte, times *[2]Timeval) _C_int\n+func Futimesat(dirfd int, path string, tv []Timeval) (err error) {\n+\tif len(tv) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\treturn futimesat(dirfd, StringBytePtr(path), (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n+}\n+\n+func Futimes(fd int, tv []Timeval) (err error) {\n+\t// Believe it or not, this is the best we can do on GNU/Linux\n+\t// (and is what glibc does).\n+\treturn Utimes(\"/proc/self/fd/\"+itoa(fd), tv)\n+}\n+\n+//sys\tptrace(request int, pid int, addr uintptr, data uintptr) (err error)\n+//ptrace(request _C_int, pid Pid_t, addr *byte, data *byte) _C_long\n+\n+//sys\taccept4(fd int, sa *RawSockaddrAny, len *Socklen_t, flags int) (nfd int, err error)\n+//accept4(fd _C_int, sa *RawSockaddrAny, len *Socklen_t, flags _C_int) _C_int\n+\n+func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error) {\n+\tvar rsa RawSockaddrAny\n+\tvar len Socklen_t = SizeofSockaddrAny\n+\tnfd, err = accept4(fd, &rsa, &len, flags)\n+\tif err != nil {\n+\t\treturn -1, nil, err\n+\t}\n+\tsa, err = anyToSockaddr(&rsa)\n+\tif err != nil {\n+\t\tClose(nfd)\n+\t\treturn -1, nil, err\n+\t}\n+\treturn nfd, sa, nil\n+}\n+\n+//sysnb\tDup3(oldfd int, newfd int, flags int) (err error)\n+//dup3(oldfd _C_int, newfd _C_int, flags _C_int) _C_int\n+\n+//sys\tFaccessat(dirfd int, path string, mode uint32, flags int) (err error)\n+//faccessat(dirfd _C_int, pathname *byte, mode _C_int, flags _C_int) _C_int\n+\n+//sys\tFallocate(fd int, mode uint32, off int64, len int64) (err error)\n+//fallocate(fd _C_int, mode _C_int, offset Offset_t, len Offset_t) _C_int\n+\n+//sys\tFchmodat(dirfd int, path string, mode uint32, flags int) (err error)\n+//fchmodat(dirfd _C_int, pathname *byte, mode Mode_t, flags _C_int) _C_int\n+\n+//sys\tFchownat(dirfd int, path string, uid int, gid int, flags int) (err error)\n+//fchownat(dirfd _C_int, path *byte, owner Uid_t, group Gid_t, flags _C_int) _C_int\n+\n+//sys\tFlock(fd int, how int) (err error)\n+//flock(fd _C_int, how _C_int) _C_int\n+\n+func Getdents(fd int, buf []byte) (n int, err error) {\n+\tvar p *byte\n+\tif len(buf) > 0 {\n+\t\tp = &buf[0]\n+\t} else {\n+\t\tp = (*byte)(unsafe.Pointer(&_zero))\n+\t}\n+\ts := SYS_GETDENTS64\n+\tif s == 0 {\n+\t\ts = SYS_GETDENTS\n+\t}\n+\tr1, _, errno := Syscall(uintptr(s), uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(len(buf)))\n+\tn = int(r1)\n+\tif n < 0 {\n+\t\terr = errno\n+\t}\n+\treturn\n+}\n+\n+func ReadDirent(fd int, buf []byte) (n int, err error) {\n+\treturn Getdents(fd, buf)\n+}\n+\n+//sys\tMkdirat(dirfd int, path string, mode uint32) (err error)\n+//mkdirat(dirfd _C_int, path *byte, mode Mode_t) _C_int\n+\n+//sys\tMknodat(dirfd int, path string, mode uint32, dev int) (err error)\n+//mknodat(dirfd _C_int, path *byte, mode Mode_t, dev _dev_t) _C_int\n+\n+//sysnb\tpipe2(p *[2]_C_int, flags int) (err error)\n+//pipe2(p *[2]_C_int, flags _C_int) _C_int\n+func Pipe2(p []int, flags int) (err error) {\n+\tif len(p) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\tvar pp [2]_C_int\n+\terr = pipe2(&pp, flags)\n+\tp[0] = int(pp[0])\n+\tp[1] = int(pp[1])\n+\treturn\n+}\n+\n+//sys\tsendfile(outfd int, infd int, offset *Offset_t, count int) (written int, err error)\n+//sendfile64(outfd _C_int, infd _C_int, offset *Offset_t, count Size_t) Ssize_t\n+func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {\n+\tif race.Enabled {\n+\t\trace.ReleaseMerge(unsafe.Pointer(&ioSync))\n+\t}\n+\tvar soff Offset_t\n+\tvar psoff *Offset_t\n+\tif offset != nil {\n+\t\tsoff = Offset_t(*offset)\n+\t\tpsoff = &soff\n+\t}\n+\twritten, err = sendfile(outfd, infd, psoff, count)\n+\tif offset != nil {\n+\t\t*offset = int64(soff)\n+\t}\n+\treturn\n+}\n+\n+//sys\tSyncFileRange(fd int, off int64, n int64, flags int) (err error)\n+//sync_file_range(fd _C_int, off Offset_t, n Offset_t, flags _C_uint) _C_int"}, {"sha": "f0e038ca616c6dbceff85f601380a673e65e32d4", "filename": "libgo/go/syscall/libcall_hurd.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_hurd.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// GNU/Hurd library calls.\n+\n+package syscall\n+\n+// Dummy function\n+func raw_ptrace(request int, pid int, addr *byte, data *byte) Errno {\n+\treturn ENOSYS\n+}\n+\n+//sys   Fstatfs(fd int, buf *Statfs_t) (err error)\n+//fstatfs(fd _C_int, buf *Statfs_t) _C_int\n+\n+// For exec_unix.go.\n+const SYS_EXECVE = 0"}, {"sha": "783429ca60ad0766693a8dfeab0400e8d267d52a", "filename": "libgo/go/syscall/libcall_hurd_386.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_hurd_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_hurd_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_hurd_386.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// GNU/Hurd library calls 386 specific derived from libcall_linux_386.go.\n+// Remove Iopl, iopl.\n+\n+package syscall\n+\n+//sys\tIoperm(from int, num int, on int) (err error)\n+//ioperm(from _C_long, num _C_long, on _C_int) _C_int"}, {"sha": "88286c07b6e10ded29412f7b1e5df945609aee20", "filename": "libgo/go/syscall/libcall_linux.go", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -7,31 +7,9 @@\n package syscall\n \n import (\n-\t\"internal/race\"\n \t\"unsafe\"\n )\n \n-//sys\tOpenat(dirfd int, path string, flags int, mode uint32) (fd int, err error)\n-//__go_openat(dirfd _C_int, path *byte, flags _C_int, mode Mode_t) _C_int\n-\n-//sys\tfutimesat(dirfd int, path *byte, times *[2]Timeval) (err error)\n-//futimesat(dirfd _C_int, path *byte, times *[2]Timeval) _C_int\n-func Futimesat(dirfd int, path string, tv []Timeval) (err error) {\n-\tif len(tv) != 2 {\n-\t\treturn EINVAL\n-\t}\n-\treturn futimesat(dirfd, StringBytePtr(path), (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n-}\n-\n-func Futimes(fd int, tv []Timeval) (err error) {\n-\t// Believe it or not, this is the best we can do on GNU/Linux\n-\t// (and is what glibc does).\n-\treturn Utimes(\"/proc/self/fd/\"+itoa(fd), tv)\n-}\n-\n-//sys\tptrace(request int, pid int, addr uintptr, data uintptr) (err error)\n-//ptrace(request _C_int, pid Pid_t, addr *byte, data *byte) _C_long\n-\n //sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (err Errno)\n //ptrace(request _C_int, pid Pid_t, addr *byte, data *byte) _C_long\n \n@@ -169,48 +147,12 @@ func Reboot(cmd int) (err error) {\n \treturn reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, \"\")\n }\n \n-//sys\taccept4(fd int, sa *RawSockaddrAny, len *Socklen_t, flags int) (nfd int, err error)\n-//accept4(fd _C_int, sa *RawSockaddrAny, len *Socklen_t, flags _C_int) _C_int\n-\n-func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error) {\n-\tvar rsa RawSockaddrAny\n-\tvar len Socklen_t = SizeofSockaddrAny\n-\tnfd, err = accept4(fd, &rsa, &len, flags)\n-\tif err != nil {\n-\t\treturn -1, nil, err\n-\t}\n-\tsa, err = anyToSockaddr(&rsa)\n-\tif err != nil {\n-\t\tClose(nfd)\n-\t\treturn -1, nil, err\n-\t}\n-\treturn nfd, sa, nil\n-}\n-\n //sys\tAcct(path string) (err error)\n //acct(path *byte) _C_int\n \n //sys\tAdjtimex(buf *Timex) (state int, err error)\n //adjtimex(buf *Timex) _C_int\n \n-//sysnb\tDup3(oldfd int, newfd int, flags int) (err error)\n-//dup3(oldfd _C_int, newfd _C_int, flags _C_int) _C_int\n-\n-//sys\tFaccessat(dirfd int, path string, mode uint32, flags int) (err error)\n-//faccessat(dirfd _C_int, pathname *byte, mode _C_int, flags _C_int) _C_int\n-\n-//sys\tFallocate(fd int, mode uint32, off int64, len int64) (err error)\n-//fallocate(fd _C_int, mode _C_int, offset Offset_t, len Offset_t) _C_int\n-\n-//sys\tFchmodat(dirfd int, path string, mode uint32, flags int) (err error)\n-//fchmodat(dirfd _C_int, pathname *byte, mode Mode_t, flags _C_int) _C_int\n-\n-//sys\tFchownat(dirfd int, path string, uid int, gid int, flags int) (err error)\n-//fchownat(dirfd _C_int, path *byte, owner Uid_t, group Gid_t, flags _C_int) _C_int\n-\n-//sys\tFlock(fd int, how int) (err error)\n-//flock(fd _C_int, how _C_int) _C_int\n-\n //sys\tFstatfs(fd int, buf *Statfs_t) (err error)\n //fstatfs64(fd _C_int, buf *Statfs_t) _C_int\n \n@@ -219,29 +161,6 @@ func Gettid() (tid int) {\n \treturn int(r1)\n }\n \n-func Getdents(fd int, buf []byte) (n int, err error) {\n-\tvar p *byte\n-\tif len(buf) > 0 {\n-\t\tp = &buf[0]\n-\t} else {\n-\t\tp = (*byte)(unsafe.Pointer(&_zero))\n-\t}\n-\ts := SYS_GETDENTS64\n-\tif s == 0 {\n-\t\ts = SYS_GETDENTS\n-\t}\n-\tr1, _, errno := Syscall(uintptr(s), uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(len(buf)))\n-\tn = int(r1)\n-\tif n < 0 {\n-\t\terr = errno\n-\t}\n-\treturn\n-}\n-\n-func ReadDirent(fd int, buf []byte) (n int, err error) {\n-\treturn Getdents(fd, buf)\n-}\n-\n //sys\tGetxattr(path string, attr string, dest []byte) (sz int, err error)\n //getxattr(path *byte, attr *byte, buf *byte, count Size_t) Ssize_t\n \n@@ -263,25 +182,6 @@ func ReadDirent(fd int, buf []byte) (n int, err error) {\n //sys\tListxattr(path string, dest []byte) (sz int, err error)\n //listxattr(path *byte, list *byte, size Size_t) Ssize_t\n \n-//sys\tMkdirat(dirfd int, path string, mode uint32) (err error)\n-//mkdirat(dirfd _C_int, path *byte, mode Mode_t) _C_int\n-\n-//sys\tMknodat(dirfd int, path string, mode uint32, dev int) (err error)\n-//mknodat(dirfd _C_int, path *byte, mode Mode_t, dev _dev_t) _C_int\n-\n-//sysnb\tpipe2(p *[2]_C_int, flags int) (err error)\n-//pipe2(p *[2]_C_int, flags _C_int) _C_int\n-func Pipe2(p []int, flags int) (err error) {\n-\tif len(p) != 2 {\n-\t\treturn EINVAL\n-\t}\n-\tvar pp [2]_C_int\n-\terr = pipe2(&pp, flags)\n-\tp[0] = int(pp[0])\n-\tp[1] = int(pp[1])\n-\treturn\n-}\n-\n //sys\tPivotRoot(newroot string, putold string) (err error)\n //pivot_root(newroot *byte, putold *byte) _C_int\n \n@@ -291,25 +191,6 @@ func Pipe2(p []int, flags int) (err error) {\n //sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //renameat(olddirfd _C_int, oldpath *byte, newdirfd _C_int, newpath *byte) _C_int\n \n-//sys\tsendfile(outfd int, infd int, offset *Offset_t, count int) (written int, err error)\n-//sendfile64(outfd _C_int, infd _C_int, offset *Offset_t, count Size_t) Ssize_t\n-func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {\n-\tif race.Enabled {\n-\t\trace.ReleaseMerge(unsafe.Pointer(&ioSync))\n-\t}\n-\tvar soff Offset_t\n-\tvar psoff *Offset_t\n-\tif offset != nil {\n-\t\tsoff = Offset_t(*offset)\n-\t\tpsoff = &soff\n-\t}\n-\twritten, err = sendfile(outfd, infd, psoff, count)\n-\tif offset != nil {\n-\t\t*offset = int64(soff)\n-\t}\n-\treturn\n-}\n-\n //sys\tSetfsgid(gid int) (err error)\n //setfsgid(gid Gid_t) _C_int\n \n@@ -353,9 +234,6 @@ func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n i\n //sys\tStatfs(path string, buf *Statfs_t) (err error)\n //statfs64(path *byte, buf *Statfs_t) _C_int\n \n-//sys\tSyncFileRange(fd int, off int64, n int64, flags int) (err error)\n-//sync_file_range(fd _C_int, off Offset_t, n Offset_t, flags _C_uint) _C_int\n-\n //sysnb\tSysinfo(info *Sysinfo_t) (err error)\n //sysinfo(info *Sysinfo_t) _C_int\n "}, {"sha": "d2fa0d9d433b7241e998456e73cf085128abd38f", "filename": "libgo/go/syscall/libcall_posix.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -9,8 +9,6 @@\n // Note that sometimes we use a lowercase //sys name and\n // wrap it in our own nicer implementation.\n \n-// +build !hurd\n-\n package syscall\n \n import \"unsafe\"\n@@ -267,9 +265,6 @@ func Gettimeofday(tv *Timeval) (err error) {\n //sys\tMknod(path string, mode uint32, dev int) (err error)\n //mknod(path *byte, mode Mode_t, dev _dev_t) _C_int\n \n-//sys\tMount(source string, target string, fstype string, flags uintptr, data string) (err error)\n-//mount(source *byte, target *byte, fstype *byte, flags _C_long, data *byte) _C_int\n-\n //sys\tNanosleep(time *Timespec, leftover *Timespec) (err error)\n //nanosleep(time *Timespec, leftover *Timespec) _C_int\n \n@@ -355,9 +350,6 @@ func Settimeofday(tv *Timeval) (err error) {\n //sys\tmunmap(addr uintptr, length uintptr) (err error)\n //munmap(addr *byte, length Size_t) _C_int\n \n-//sys Madvise(b []byte, advice int) (err error)\n-//madvise(addr *byte, len Size_t, advice _C_int) _C_int\n-\n //sys\tMprotect(b []byte, prot int) (err error)\n //mprotect(addr *byte, len Size_t, prot _C_int) _C_int\n "}, {"sha": "afdca3f2f490b035e38b4c1c2b227a55e56ce0d7", "filename": "libgo/go/syscall/libcall_posix_nonhurd.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_posix_nonhurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Flibcall_posix_nonhurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_nonhurd.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !hurd\n+\n+package syscall\n+\n+// Removed the mount call for GNU/Hurd, it exists but use translators.\n+// Functionality is not the same as descibed in Linux <sys/mount.h>.\n+// Removed the madvise call for GNU/Hurd, not yet implemented.\n+\n+//sys\tMount(source string, target string, fstype string, flags uintptr, data string) (err error)\n+//mount(source *byte, target *byte, fstype *byte, flags _C_long, data *byte) _C_int\n+\n+//sys Madvise(b []byte, advice int) (err error)\n+//madvise(addr *byte, len Size_t, advice _C_int) _C_int"}, {"sha": "b40f297facb210644c6ea8eb1b4dce84bb9f6f37", "filename": "libgo/go/syscall/syscall_glibc.go", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Fsyscall_glibc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4321f202f985f659e0150ee72ed3e14e554f9735/libgo%2Fgo%2Fsyscall%2Fsyscall_glibc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_glibc.go?ref=4321f202f985f659e0150ee72ed3e14e554f9735", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build hurd linux\n+\n package syscall\n \n import \"unsafe\"", "previous_filename": "libgo/go/syscall/syscall_linux.go"}]}