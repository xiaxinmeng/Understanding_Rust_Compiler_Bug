{"sha": "bdcee4712ec20209d14aeb2d0487de41be1ad424", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjZWU0NzEyZWMyMDIwOWQxNGFlYjJkMDQ4N2RlNDFiZTFhZDQyNA==", "commit": {"author": {"name": "Chen Liqin", "email": "liqin@sunnorth.com.cn", "date": "2006-10-10T07:50:29Z"}, "committer": {"name": "Chen Liqin", "email": "liqin@gcc.gnu.org", "date": "2006-10-10T07:50:29Z"}, "message": "* Add new port for score.\n\nFrom-SVN: r117597", "tree": {"sha": "8be96e3f546284421229d84be5c1ea9963e5725c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8be96e3f546284421229d84be5c1ea9963e5725c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdcee4712ec20209d14aeb2d0487de41be1ad424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcee4712ec20209d14aeb2d0487de41be1ad424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdcee4712ec20209d14aeb2d0487de41be1ad424", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcee4712ec20209d14aeb2d0487de41be1ad424/comments", "author": null, "committer": null, "parents": [{"sha": "07d83dadc40ee22afce7b969f025684d2ad3d6de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07d83dadc40ee22afce7b969f025684d2ad3d6de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07d83dadc40ee22afce7b969f025684d2ad3d6de"}], "stats": {"total": 5271, "additions": 5270, "deletions": 1}, "files": [{"sha": "f59e369ff93519dde59e34f61ce548c3b2fbdf0a", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -1,3 +1,7 @@\n+2006-10-10  Chen Liqin  <liqin@sunnorth.com.cn>\n+\n+\t* MAINTAINERS: Add self as score port maintainer.\n+\n 2006-10-04  Brooks Moses  <bmoses@stanford.edu>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "b6de3e775ae1a38af79991369640b4a738aaee68", "filename": "gcc/config.gcc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -309,6 +309,9 @@ powerpc*-*-*)\n rs6000*-*-*)\n \tneed_64bit_hwint=yes\n \t;;\n+score*-*-*)\n+\tcpu_type=score\n+\t;;\n sparc64*-*-*)\n \tcpu_type=sparc\n \tneed_64bit_hwint=yes\n@@ -1932,6 +1935,11 @@ s390x-ibm-tpf*)\n         thread_file='tpf'\n \textra_options=\"${extra_options} s390/tpf.opt\"\n \t;;\n+score-*-elf)\n+        tm_file=\"dbxelf.h elfos.h score/elf.h score/score.h\"\n+        tmake_file=score/t-score-elf\n+        extra_objs=\"score-mdaux.o\"\n+        ;;\n sh-*-elf* | sh[12346l]*-*-elf* | sh*-*-kaos* | \\\n sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n   sh-*-linux* | sh[346lbe]*-*-linux* | \\"}, {"sha": "65ffb159919731daee8b86d334156be498c9f70a", "filename": "gcc/config/score/crti.asm", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrti.asm?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,85 @@\n+# crti.asm for Sunplus S+CORE\n+#\n+#   Copyright (C) 2005 Free Software Foundation, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+#\n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to the Free\n+# Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+#\n+#   As a special exception, if you link this library with files\n+#   compiled with GCC to produce an executable, this does not cause\n+#   the resulting executable to be covered by the GNU General Public License.\n+#   This exception does not however invalidate any other reasons why\n+#   the executable file might be covered by the GNU General Public License.\n+#\n+\n+# This file makes a stack frame for the contents of the .init and\n+# .fini sections.\n+\n+.section .init,\"ax\", @progbits\n+        .weak   _start\n+        .ent    _start\n+        .frame  r0, 0, r3, 0\n+        .mask   0x00000000, 0\n+_start:\n+        la      r28, _gp\n+        la      r8, __bss_start\n+        la      r9, __bss_end__\n+        sub!    r9, r8\n+        srli!   r9, 2\n+        addi    r9, -1\n+        mtsr    r9, sr0\n+        li      r9, 0\n+1:\n+        sw      r9, [r8]+, 4\n+        bcnz    1b\n+        la      r0, _stack\n+        jl      _init\n+        la      r4, _end\n+        jl      _init_argv\n+        jl      exit\n+        .end    _start\n+\n+        .weak   _init_argv\n+        .ent\n+        .frame  r0, 0, r3, 0\n+        .mask   0x00000000, 0\n+_init_argv:\n+        ldiu!   r4, 0\n+        ldiu!   r5, 0\n+        j       main\n+        .end    _init_argv\n+\n+        .globl  _init\n+        .type   _init, %function\n+_init:\n+        addi    r0, -32\n+        sw      r3, [r0, 20]\n+\n+        .section .fini, \"ax\", @progbits\n+        .globl  _fini\n+        .type   _fini, %function\n+_fini:\n+        addi    r0, -32\n+        sw      r3, [r0, 20]\n+\n+"}, {"sha": "97039fa24dfcdb31340fce76df7371e0bc543861", "filename": "gcc/config/score/crtn.asm", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrtn.asm?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,47 @@\n+# crtn.asm for Sunplus S+CORE\n+\n+#   Copyright (C) 2005 Free Software Foundation, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+#\n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to the Free\n+# Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+#\n+#    As a special exception, if you link this library with files\n+#    compiled with GCC to produce an executable, this does not cause\n+#    the resulting executable to be covered by the GNU General Public License.\n+#    This exception does not however invalidate any other reasons why\n+#    the executable file might be covered by the GNU General Public License.\n+#\n+\n+# This file makes sure that the .init and .fini sections do in\n+# fact return.\n+\n+.section .init, \"ax\", @progbits\n+        lw      r3, [r0, 20]\n+        addi    r0, 32\n+        br      r3\n+\n+.section .fini, \"ax\", @progbits\n+        lw      r3, [r0, 20]\n+        addi    r0, 32\n+        br      r3\n+"}, {"sha": "8c8b5dc80ebf51a0ea12811c41b80a5fe1cf42bb", "filename": "gcc/config/score/elf.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Felf.h?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,101 @@\n+/* elf.h for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#define OBJECT_FORMAT_ELF\n+\n+/* Biggest alignment supported by the object file format of this machine.  */\n+#undef  MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT        (32768 * 8)\n+\n+/* Switch into a generic section.  */\n+#undef  TARGET_ASM_NAMED_SECTION\n+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  */\n+#define TYPE_OPERAND_FMT        \"@%s\"\n+\n+#undef TYPE_ASM_OP\n+#define TYPE_ASM_OP        \"\\t.type\\t\"\n+\n+#undef SIZE_ASM_OP\n+#define SIZE_ASM_OP        \"\\t.size\\t\"\n+\n+/* A c expression whose value is a string containing the\n+   assembler operation to identify the following data as\n+   uninitialized global data.  */\n+#ifndef BSS_SECTION_ASM_OP\n+#define BSS_SECTION_ASM_OP        \"\\t.section\\t.bss\"\n+#endif\n+\n+#ifndef ASM_OUTPUT_ALIGNED_BSS\n+#define ASM_OUTPUT_ALIGNED_BSS asm_output_aligned_bss\n+#endif\n+\n+#define ASM_OUTPUT_DEF(FILE, LABEL1, LABEL2)                       \\\n+  do {                                                             \\\n+    fputc ('\\t', FILE);                                            \\\n+    assemble_name (FILE, LABEL1);                                  \\\n+    fputs (\" = \", FILE);                                           \\\n+    assemble_name (FILE, LABEL2);                                  \\\n+    fputc ('\\n', FILE);                                            \\\n+ } while (0)\n+\n+\n+/* This is how we tell the assembler that a symbol is weak.  */\n+#undef  ASM_WEAKEN_LABEL\n+#define ASM_WEAKEN_LABEL(FILE, NAME) ASM_OUTPUT_WEAK_ALIAS (FILE, NAME, 0)\n+\n+#define ASM_OUTPUT_WEAK_ALIAS(FILE, NAME, VALUE)      \\\n+  do {                                                \\\n+    fputs (\"\\t.weak\\t\", FILE);                        \\\n+    assemble_name (FILE, NAME);                       \\\n+    if (VALUE)                                        \\\n+      {                                               \\\n+        fputc (' ', FILE);                            \\\n+        assemble_name (FILE, VALUE);                  \\\n+      }                                               \\\n+    fputc ('\\n', FILE);                               \\\n+ } while (0)\n+\n+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n+\n+/* On elf, we *do* have support for the .init and .fini sections, and we\n+   can put stuff in there to be executed before and after `main'.  We let\n+   crtstuff.c and other files know this by defining the following symbols.\n+   The definitions say how to change sections to the .init and .fini\n+   sections.  This is the same for all known elf assemblers.  */\n+#undef  INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP     \"\\t.section\\t.init\"\n+#undef  FINI_SECTION_ASM_OP\n+#define FINI_SECTION_ASM_OP     \"\\t.section\\t.fini\"\n+\n+/* Don't set the target flags, this is done by the linker script */\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"\"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC          \"crti%O%s crtbegin%O%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC            \"crtend%O%s crtn%O%s\"\n+\n+/* We support #pragma.  */\n+#define HANDLE_SYSV_PRAGMA      1"}, {"sha": "ca7889d4185d1b675d06df9449f291d6fbb2753f", "filename": "gcc/config/score/mac.md", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fmac.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fmac.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmac.md?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,181 @@\n+;;  Machine description for Sunplus S+CORE\n+;;  Copyright (C) 2005\n+;;  Free Software Foundation, Inc.\n+;;  Contributed by Sunnorth.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+(define_insn \"smaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (smax:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"TARGET_MAC\"\n+  \"max     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"sminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (smin:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"TARGET_MAC\"\n+  \"min     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"abssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (abs:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_MAC\"\n+  \"abs     %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"clzsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (clz:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_MAC\"\n+  \"clz     %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"sffs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")] SFFS))]\n+  \"TARGET_MAC\"\n+  \"bitrev  %0, %1, r0\\;clz     %0, %0\\;addi    %0, 0x1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_expand \"ffssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+        (ffs:SI (match_operand:SI 1 \"register_operand\")))]\n+  \"TARGET_MAC\"\n+{\n+  emit_insn (gen_sffs (operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (CC_NZmode, CC_REGNUM),\n+                          gen_rtx_COMPARE (CC_NZmode, operands[0],\n+                                           GEN_INT (33))));\n+  emit_insn (gen_movsicc_internal (operands[0],\n+             gen_rtx_fmt_ee (EQ, VOIDmode, operands[0], GEN_INT (33)),\n+             GEN_INT (0),\n+             operands[0]));\n+  DONE;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"loreg_operand\" \"\")\n+        (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_operand:SI 2 \"hireg_operand\" \"\")\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"TARGET_MAC\"\n+  [(parallel\n+       [(set (match_dup 0) (match_dup 1))\n+        (set (match_dup 2) (match_dup 3))])])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"hireg_operand\" \"\")\n+        (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_operand:SI 2 \"loreg_operand\" \"\")\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"TARGET_MAC\"\n+  [(parallel\n+       [(set (match_dup 2) (match_dup 3))\n+        (set (match_dup 0) (match_dup 1))])])\n+\n+(define_insn \"movtohilo\"\n+  [(parallel\n+       [(set (match_operand:SI 0 \"loreg_operand\" \"=l\")\n+             (match_operand:SI 1 \"register_operand\" \"d\"))\n+        (set (match_operand:SI 2 \"hireg_operand\" \"=h\")\n+             (match_operand:SI 3 \"register_operand\" \"d\"))])]\n+  \"TARGET_MAC\"\n+  \"mtcehl  %3, %1\"\n+  [(set_attr \"type\" \"fce\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"mulsi3addsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,d\")\n+        (plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n+                          (match_operand:SI 3 \"register_operand\" \"d,d,d\"))\n+                 (match_operand:SI 1 \"register_operand\" \"0,d,l\")))\n+   (clobber (reg:SI HI_REGNUM))]\n+  \"TARGET_MAC\"\n+  \"@\n+   mad     %2, %3\n+   mtcel%S1 %1\\;mad     %2, %3\n+   mad      %2, %3\\;mfcel%S0 %0\"\n+  [(set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"mulsi3subsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,d\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,d,l\")\n+                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n+                           (match_operand:SI 3 \"register_operand\" \"d,d,d\"))))\n+   (clobber (reg:SI HI_REGNUM))]\n+  \"TARGET_MAC\"\n+  \"@\n+   msb     %2, %3\n+   mtcel%S1 %1\\;msb     %2, %3\n+   msb     %2, %3\\;mfcel%S0 %0\"\n+  [(set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"mulsidi3adddi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+        (plus:DI (mult:DI\n+                  (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n+                  (sign_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))\n+                 (match_operand:DI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_MAC\"\n+  \"mad     %2, %3\"\n+  [(set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"umulsidi3adddi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+        (plus:DI (mult:DI\n+                  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n+                  (zero_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))\n+                 (match_operand:DI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_MAC\"\n+  \"madu    %2, %3\"\n+  [(set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"mulsidi3subdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+        (minus:DI\n+         (match_operand:DI 1 \"register_operand\" \"0\")\n+         (mult:DI\n+          (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n+          (sign_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))))]\n+  \"TARGET_MAC\"\n+  \"msb     %2, %3\"\n+  [(set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"umulsidi3subdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+        (minus:DI\n+         (match_operand:DI 1 \"register_operand\" \"0\")\n+         (mult:DI (zero_extend:DI\n+                   (match_operand:SI 2 \"register_operand\" \"%d\"))\n+                  (zero_extend:DI\n+                   (match_operand:SI 3 \"register_operand\" \"d\")))))]\n+  \"TARGET_MAC\"\n+  \"msbu    %2, %3\"\n+  [(set_attr \"mode\" \"DI\")])"}, {"sha": "d19c53538a6ddbb029d401804cd9fb1601dcd3c2", "filename": "gcc/config/score/misc.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fmisc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fmisc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmisc.md?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,108 @@\n+;;  Machine description for Sunplus S+CORE\n+;;  Copyright (C) 2005\n+;;  Free Software Foundation, Inc.\n+;;  Contributed by Sunnorth.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+(define_insn \"pushsi\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n+        (match_operand:SI 1 \"register_operand\" \"d\"))]\n+  \"\"\n+  \"push!   %1, [r0]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"popsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (match_operand:SI 1 \"pop_operand\" \">\"))]\n+  \"\"\n+  \"pop!    %0, [r0]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n+        (match_operand:SI 1 \"loreg_operand\" \"\"))\n+   (set (match_operand:SI 2 \"g32reg_operand\" \"\")\n+        (match_operand:SI 3 \"hireg_operand\" \"\"))]\n+  \"\"\n+  [(parallel\n+       [(set (match_dup 0) (match_dup 1))\n+        (set (match_dup 2) (match_dup 3))])])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n+        (match_operand:SI 1 \"hireg_operand\" \"\"))\n+   (set (match_operand:SI 2 \"g32reg_operand\" \"\")\n+        (match_operand:SI 3 \"loreg_operand\" \"\"))]\n+  \"\"\n+  [(parallel\n+       [(set (match_dup 2) (match_dup 3))\n+        (set (match_dup 0) (match_dup 1))])])\n+\n+(define_insn \"movhilo\"\n+  [(parallel\n+       [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+             (match_operand:SI 1 \"loreg_operand\" \"\"))\n+        (set (match_operand:SI 2 \"register_operand\" \"=d\")\n+             (match_operand:SI 3 \"hireg_operand\" \"\"))])]\n+  \"\"\n+  \"mfcehl  %2, %0\"\n+  [(set_attr \"type\" \"fce\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_expand \"movsicc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (if_then_else:SI (match_operator 1 \"comparison_operator\"\n+                          [(reg:CC CC_REGNUM) (const_int 0)])\n+                         (match_operand:SI 2 \"register_operand\" \"\")\n+                         (match_operand:SI 3 \"register_operand\" \"\")))]\n+  \"\"\n+{\n+  mdx_movsicc (operands);\n+})\n+\n+(define_insn \"movsicc_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (if_then_else:SI (match_operator 1 \"comparison_operator\"\n+                          [(reg:CC CC_REGNUM) (const_int 0)])\n+                         (match_operand:SI 2 \"register_operand\" \"d\")\n+                         (match_operand:SI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"mv%C1   %0, %2\"\n+  [(set_attr \"type\" \"cndmv\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"zero_extract_bittst\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (unspec:SI\n+                        [(match_operand:SI 0 \"register_operand\" \"*e,d\")\n+                         (match_operand:SI 1 \"const_bi_operand\" \"\")]\n+                        BITTST)\n+                       (const_int 0)))]\n+  \"\"\n+  \"@\n+   bittst!  %0, %c1\n+   bittst.c %0, %c1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+"}, {"sha": "37a2406b20a4fbd0d0f2c6f07c190958cf820fd8", "filename": "gcc/config/score/mul-div.S", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fmul-div.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fmul-div.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmul-div.S?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,224 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Sunnorth\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#define ra r3\n+#define a0 r4\n+#define a1 r5\n+#define a2 r6\n+#define a3 r7\n+#define v0 r23\n+\n+#define t0 r8\n+#define t1 r9\n+#define t2 r10\n+#define t3 r11\n+\n+#define t4 r22\n+\n+#if defined(__scorebe__)\n+#define LIBGCC1_BIG_ENDIAN\n+#define out_H        v0\n+#define out_L        v1\n+#define in0_H        a0\n+#define in0_L        a1\n+#define in1_H        a2\n+#define in1_L        a3\n+#elif defined(__scorele__)\n+#define out_H        v1\n+#define out_L        v0\n+#define in0_H        a1\n+#define in0_L        a0\n+#define in1_H        a3\n+#define in1_L        a2\n+#else\n+#err  \"must specify S+core endian!\"\n+#endif\n+\n+#if !defined(L_mulsi3) && !defined(L_divsi3)\n+               .text\n+               .global _flush_cache\n+_flush_cache:\n+                srli    r9, r5, 4\n+                mv      r8, r4\n+                mtsr    r9, sr0\n+1:\n+                cache   0xe, [r8, 0]                  # write back invalid dcache\n+                addi    r8, 16\n+                bcnz    1b\n+                mfcr    r8, cr4\n+                bittst! r8, 0x3                       # if LDM is enable, write back LDM\n+                beq!    6f\n+                ldi     r10, 0\n+                cache   0xc, [r10, 0]\n+6:\n+                bittst! r8, 0x2                       # if LIM is enable, refill it\n+                beq!    7f\n+                cache   0x4, [r10, 0]\n+7:\n+                #nop!\n+                #nop!\n+                #nop!\n+                #nop!\n+                #nop!\n+                mv      r8, r4\n+                mtsr    r9, sr0\n+2:\n+                cache   0x2, [r8, 0]                  # invalid unlock icache\n+                #nop!\n+                #nop!\n+                #nop!\n+                #nop!\n+                #nop!\n+                addi    r8, 16\n+                bcnz    2b\n+                br      r3\n+#endif\n+\n+/* FUNCTION\n+   (U) INT32 v0 = __mulsi3 ((U) INT32 a0, (U) INT32 a1);\n+   REGISTERS:\n+        use             t0\n+        modify          a0\n+                        a1        -> become 0\n+   NOTE:\n+         this seems to give better performance to just rotate and add.  */\n+\n+#ifdef L_mulsi3\n+                .text\n+                .global __umulsi3\n+                .global __mulsi3\n+                /* signed multiplication (32x32)  */\n+                .ent    __mulsi3\n+__umulsi3:\n+__mulsi3:\n+                li      t1, 0\n+__mulsi3_loop:\n+                andri.c t0, a1, 1                 /* t0 = multiplier[0]     */\n+                srli    a1, a1, 1                 /* a1 /= 2                */\n+                beq     __mulsi3_loop2            /* skip if (t0 == 0)      */\n+                add     t1, t1, a0                /* add multiplicand       */\n+__mulsi3_loop2:\n+                slli    a0, a0, 1                 /* multiplicand mul 2     */\n+                cmpi.c  a1, 0\n+                bne     __mulsi3_loop\n+                mv      r4, t1\n+                br      ra\n+                .end    __mulsi3\n+#endif /* L_mulsi3 */\n+\n+\n+/* FUNCTION\n+   UINT32 (v0) = __udivsi3 (UINT32 (a0), UINT32 (a1));\n+   INT32 (v0) = __divsi3 (INT32 (a0),  INT32 (a1));\n+   UINT32 (v0) = __umodsi3 (UINT32 (a0), UINT32 (a1));\n+   INT32 (v0) = __modsi3 (INT32 (a0),  INT32 (a1));\n+   DESCRIPTION\n+        performs 32-bit division/modulo.\n+   REGISTERS\n+        used        t0        bit-index\n+                    t1\n+        modify      a0         becomes remainer  */\n+#ifdef L_divsi3\n+                .text\n+                .global __udivsi3\n+                .global __umodsi3\n+                .global __divsi3\n+                .global __modsi3\n+\n+                /* unsigned division  */\n+                .ent    __udivsi3\n+__udivsi3:\n+                li      t4, 0\n+                cmpi.c  a1, 0\n+                beq     __uds_exit\n+                li      t0, 1\n+                blt     __uds_ok\n+__uds_normalize:\n+                cmp.c   a0, a1\n+                bcc     __uds_ok\n+                slli    a1, a1, 1\n+                slli    t0, t0, 1\n+                cmpi.c  a1, 0\n+                bge     __uds_normalize\n+__uds_ok:\n+__uds_loop2:\n+                cmp.c   a0, a1\n+                bcc     __uds_loop3\n+                sub     a0, a0, a1\n+                or      t4, t4, t0\n+__uds_loop3:\n+                srli    t0, t0, 1\n+                srli    a1, a1, 1\n+                cmpi.c  t0, 0\n+                bne     __uds_loop2\n+__uds_exit:\n+                mv      a1, a0\n+                mv      r4, t4\n+                br      ra\n+                .end    __udivsi3\n+\n+                /* unsigned modulus  */\n+                .ent    __umodsi3\n+__umodsi3:\n+                mv      t3, ra\n+                jl      __udivsi3\n+                mv      r4, a1\n+                br      t3\n+                .end    __umodsi3\n+\n+                /* abs and div  */\n+                .ent    __orgsi3\n+__orgsi3:\n+                cmpi.c  a0, 0\n+                bge     __orgsi3_a0p\n+                neg     a0, a0\n+__orgsi3_a0p:\n+                cmpi.c  a1, 0\n+                bge     __udivsi3\n+                neg     a1, a1\n+                b       __udivsi3                /* goto udivsi3  */\n+                .end    __orgsi3\n+\n+                /* signed division  */\n+                .ent    __divsi3\n+__divsi3:\n+                mv      t3, ra\n+                xor     t2, a0, a1\n+                jl      __orgsi3\n+__divsi3_adjust:\n+                cmpi.c  t2, 0\n+                bge     __divsi3_exit\n+                neg     r4, r4\n+__divsi3_exit:\n+                br      t3\n+                .end    __divsi3\n+\n+                /* signed modulus  */\n+                .ent    __modsi3\n+__modsi3:\n+                mv      t3, ra\n+                mv      t2, a0\n+                jl      __orgsi3\n+                mv      r4, a1\n+                b       __divsi3_adjust\n+                .end    __modsi3\n+\n+#endif /* L_divsi3 */\n+"}, {"sha": "f1633ec4b2eb5c714c5990c1a0ad8f3880cee82d", "filename": "gcc/config/score/predicates.md", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fpredicates.md?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,63 @@\n+;; Predicate definitions for Sunplus S+CORE.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+(define_predicate \"arith_operand\"\n+  (ior (match_code \"const_int\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_call_insn_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum score_symbol_type symbol_type;\n+\n+  return (mda_symbolic_constant_p (op, &symbol_type)\n+          && (symbol_type == SYMBOL_GENERAL));\n+})\n+\n+(define_predicate \"call_insn_operand\"\n+  (ior (match_operand 0 \"const_call_insn_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_bi_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'J')\")))\n+\n+(define_predicate \"pindex_off_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'P')\")))\n+\n+(define_predicate \"hireg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == HI_REGNUM\")))\n+\n+(define_predicate \"loreg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == LO_REGNUM\")))\n+\n+(define_predicate \"g32reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"GP_REG_P (REGNO (op))\")))\n+\n+(define_predicate \"branch_n_operator\"\n+  (match_code \"lt,ge\"))\n+\n+(define_predicate \"branch_nz_operator\"\n+  (match_code \"eq,ne,lt,ge\"))\n+"}, {"sha": "72730d89b837b099eee458ed31d5ae2c422a6e30", "filename": "gcc/config/score/score-conv.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-conv.h?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,82 @@\n+/* score-conv.h for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#ifndef SCORE_CONV_0601\n+#define SCORE_CONV_0601\n+\n+extern int target_flags;\n+\n+#define GP_REG_FIRST                    0U\n+#define GP_REG_LAST                     31U\n+#define GP_REG_NUM                      (GP_REG_LAST - GP_REG_FIRST + 1U)\n+#define GP_DBX_FIRST                    0U\n+\n+#define CE_REG_FIRST                    48U\n+#define CE_REG_LAST                     49U\n+#define CE_REG_NUM                      (CE_REG_LAST - CE_REG_FIRST + 1U)\n+\n+#define ARG_REG_FIRST                   4U\n+#define ARG_REG_LAST                    7U\n+#define ARG_REG_NUM                     (ARG_REG_LAST - ARG_REG_FIRST + 1U)\n+\n+#define REG_CONTAIN(REGNO, FIRST, NUM) \\\n+  ((unsigned int)((int) (REGNO) - (FIRST)) < (NUM))\n+\n+#define GP_REG_P(REGNO)        REG_CONTAIN (REGNO, GP_REG_FIRST, GP_REG_NUM)\n+\n+#define G16_REG_P(REGNO)       REG_CONTAIN (REGNO, GP_REG_FIRST, 16)\n+\n+#define CE_REG_P(REGNO)        REG_CONTAIN (REGNO, CE_REG_FIRST, CE_REG_NUM)\n+\n+#define UIMM_IN_RANGE(V, W)  ((V) >= 0 && (V) < ((HOST_WIDE_INT)1 << (W)))\n+\n+#define SIMM_IN_RANGE(V, W)                            \\\n+  ((V) >= (-1 * ((HOST_WIDE_INT) 1 << ((W) - 1)))      \\\n+   && (V) < (1 * ((HOST_WIDE_INT) 1 << ((W) - 1))))\n+\n+#define IMM_IN_RANGE(V, W, S) \\\n+  ((S) ? SIMM_IN_RANGE (V, W) : UIMM_IN_RANGE (V, W))\n+\n+#define SCORE_STACK_ALIGN(LOC)          (((LOC) + 3) & ~3)\n+\n+#define SCORE_MAX_FIRST_STACK_STEP      (0x3ff0)\n+\n+#define SCORE_SDATA_MAX                 score_sdata_max ()\n+\n+#define DEFAULT_SDATA_MAX               8\n+\n+#define CONST_HIGH_PART(VALUE) \\\n+  (((VALUE) + 0x8000) & ~(unsigned HOST_WIDE_INT) 0xffff)\n+\n+#define CONST_LOW_PART(VALUE)           ((VALUE) - CONST_HIGH_PART (VALUE))\n+\n+#define PROLOGUE_TEMP_REGNUM            (GP_REG_FIRST + 8)\n+\n+#define EPILOGUE_TEMP_REGNUM            (GP_REG_FIRST + 8)\n+\n+enum score_symbol_type\n+{\n+  SYMBOL_GENERAL,\n+  SYMBOL_SMALL_DATA     /* The symbol refers to something in a small data section.  */\n+};\n+\n+int score_sdata_max (void);\n+\n+#endif"}, {"sha": "6f72fb6a46523f4204baffd205dd9cee67cfb938", "filename": "gcc/config/score/score-mdaux.c", "status": "added", "additions": 738, "deletions": 0, "changes": 738, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,738 @@\n+/* score-mdaux.c for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Sunnorth\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include <signal.h>\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"flags.h\"\n+#include \"reload.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"gstab.h\"\n+#include \"hashtab.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"integrate.h\"\n+#include \"langhooks.h\"\n+#include \"cfglayout.h\"\n+#include \"score-mdaux.h\"\n+\n+#define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n+#define INS_BUF_SZ                100\n+\n+/* Define the information needed to generate branch insns.  This is\n+   stored from the compare operation.  */\n+rtx cmp_op0, cmp_op1;\n+\n+static char ins[INS_BUF_SZ + 8];\n+\n+/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n+   to the same object as SYMBOL.  */\n+static int\n+score_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n+{\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return 0;\n+\n+  if (CONSTANT_POOL_ADDRESS_P (symbol)\n+      && offset >= 0\n+      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n+    return 1;\n+\n+  if (SYMBOL_REF_DECL (symbol) != 0\n+      && offset >= 0\n+      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Split X into a base and a constant offset, storing them in *BASE\n+   and *OFFSET respectively.  */\n+static void\n+score_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n+{\n+  *offset = 0;\n+\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *offset += INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+    }\n+\n+  *base = x;\n+}\n+\n+/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n+static enum\n+score_symbol_type score_classify_symbol (rtx x)\n+{\n+  if (GET_CODE (x) == LABEL_REF)\n+    return SYMBOL_GENERAL;\n+\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    gcc_unreachable ();\n+\n+  if (CONSTANT_POOL_ADDRESS_P(x))\n+    {\n+      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE_SDATA_MAX)\n+        return SYMBOL_SMALL_DATA;\n+      return SYMBOL_GENERAL;\n+    }\n+  if (SYMBOL_REF_SMALL_P (x))\n+    return SYMBOL_SMALL_DATA;\n+  return SYMBOL_GENERAL;\n+}\n+\n+/* Return true if the current function must save REGNO.  */\n+static int\n+score_save_reg_p (unsigned int regno)\n+{\n+  /* Check call-saved registers.  */\n+  if (regs_ever_live[regno] && !call_used_regs[regno])\n+    return 1;\n+\n+  /* We need to save the old frame pointer before setting up a new one.  */\n+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return 1;\n+\n+  /* We need to save the incoming return address if it is ever clobbered\n+     within the function.  */\n+  if (regno == RA_REGNUM && regs_ever_live[regno])\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return one word of double-word value OP, taking into account the fixed\n+   endianness of certain registers.  HIGH_P is true to select the high part,\n+   false to select the low part.  */\n+static rtx\n+subw (rtx op, int high_p)\n+{\n+  unsigned int byte;\n+  enum machine_mode mode = GET_MODE (op);\n+\n+  if (mode == VOIDmode)\n+    mode = DImode;\n+\n+  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n+\n+  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n+    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n+\n+  if (GET_CODE (op) == MEM)\n+    return adjust_address (op, SImode, byte);\n+\n+  return simplify_gen_subreg (SImode, op, mode, byte);\n+}\n+\n+struct score_frame_info *\n+mda_cached_frame (void)\n+{\n+  static struct score_frame_info _frame_info;\n+  return &_frame_info;\n+}\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n+struct score_frame_info *\n+mda_compute_frame_size (HOST_WIDE_INT size)\n+{\n+  unsigned int regno;\n+  struct score_frame_info *f = mda_cached_frame ();\n+\n+  memset (f, 0, sizeof (struct score_frame_info));\n+  f->gp_reg_size = 0;\n+  f->mask = 0;\n+  f->var_size = SCORE_STACK_ALIGN (size);\n+  f->args_size = current_function_outgoing_args_size;\n+  f->cprestore_size = SCORE_STACK_ALIGN (STARTING_FRAME_OFFSET) - f->args_size;\n+  if (f->var_size == 0 && current_function_is_leaf)\n+    f->args_size = f->cprestore_size = 0;\n+\n+  if (f->args_size == 0 && current_function_calls_alloca)\n+    f->args_size = UNITS_PER_WORD;\n+\n+  f->total_size = f->var_size + f->args_size;\n+  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    {\n+      if (score_save_reg_p (regno))\n+        {\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  if (current_function_calls_eh_return)\n+    {\n+      unsigned int i;\n+      for (i = 0; ; ++i)\n+        {\n+          regno = EH_RETURN_DATA_REGNO (i);\n+          if (regno == INVALID_REGNUM)\n+            break;\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  f->total_size += SCORE_STACK_ALIGN (f->gp_reg_size);\n+  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n+\n+  if (f->mask)\n+    {\n+      HOST_WIDE_INT offset;\n+      offset = (f->args_size + f->cprestore_size + f->var_size\n+                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n+      f->gp_sp_offset = offset;\n+    }\n+  else\n+    {\n+      f->gp_sp_offset = 0;\n+    }\n+\n+  if ((f->total_size == f->gp_reg_size) && flag_pic)\n+    f->total_size += 8;\n+\n+  return f;\n+}\n+\n+/* Generate the prologue instructions for entry into a S+core function.  */\n+void\n+mdx_prologue (void)\n+{\n+#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n+\n+  struct score_frame_info *f = mda_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (flag_pic)\n+    emit_insn (gen_cpload ());\n+\n+  for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n+    {\n+      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n+        {\n+          rtx mem = gen_rtx_MEM (SImode,\n+                                 gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n+          rtx reg = gen_rtx_REG (SImode, regno);\n+          if (!current_function_calls_eh_return)\n+            MEM_READONLY_P (mem) = 1;\n+          EMIT_PL (emit_insn (gen_pushsi (mem, reg)));\n+        }\n+    }\n+\n+  if (size > 0)\n+    {\n+      rtx insn;\n+\n+      if (CONST_OK_FOR_LETTER_P (-size, 'L'))\n+        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                                           stack_pointer_rtx,\n+                                           GEN_INT (-size))));\n+      else\n+        {\n+          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, PROLOGUE_TEMP_REGNUM),\n+                                   GEN_INT (size)));\n+          EMIT_PL (emit_insn\n+                   (gen_sub3_insn (stack_pointer_rtx,\n+                                   stack_pointer_rtx,\n+                                   gen_rtx_REG (Pmode,\n+                                                PROLOGUE_TEMP_REGNUM))));\n+        }\n+      insn = get_last_insn ();\n+      REG_NOTES (insn) =\n+        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+                                      plus_constant (stack_pointer_rtx,\n+                                                     -size)),\n+                                      REG_NOTES (insn));\n+    }\n+\n+  if (frame_pointer_needed)\n+    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n+\n+  if (flag_pic)\n+    emit_insn (gen_cprestore (GEN_INT (size + 4)));\n+\n+#undef EMIT_PL\n+}\n+\n+/* Generate the epilogue instructions in a S+core function.  */\n+void\n+mdx_epilogue (int sibcall_p)\n+{\n+  struct score_frame_info *f = mda_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+  rtx base;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (!frame_pointer_needed)\n+    base = stack_pointer_rtx;\n+  else\n+    base = hard_frame_pointer_rtx;\n+\n+  if (size)\n+    {\n+      if (CONST_OK_FOR_LETTER_P (size, 'L'))\n+        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n+      else\n+        {\n+          emit_move_insn (gen_rtx_REG (Pmode, EPILOGUE_TEMP_REGNUM),\n+                          GEN_INT (size));\n+          emit_insn (gen_add3_insn (base, base,\n+                                    gen_rtx_REG (Pmode,\n+                                                 EPILOGUE_TEMP_REGNUM)));\n+        }\n+    }\n+\n+  if (base != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, base);\n+\n+  if (current_function_calls_eh_return)\n+    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                              stack_pointer_rtx,\n+                              EH_RETURN_STACKADJ_RTX));\n+\n+  for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n+    {\n+      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n+        {\n+          rtx mem = gen_rtx_MEM (SImode,\n+                                 gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n+          rtx reg = gen_rtx_REG (SImode, regno);\n+\n+          if (!current_function_calls_eh_return)\n+            MEM_READONLY_P (mem) = 1;\n+\n+          emit_insn (gen_popsi (reg, mem));\n+        }\n+    }\n+\n+  if (!sibcall_p)\n+    emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, RA_REGNUM)));\n+}\n+\n+/* Return true if X is a valid base register for the given mode.\n+   Allow only hard registers if STRICT.  */\n+int\n+mda_valid_base_register_p (rtx x, int strict)\n+{\n+  if (!strict && GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  return (GET_CODE (x) == REG\n+          && score_regno_mode_ok_for_base_p (REGNO (x), strict));\n+}\n+\n+/* Return true if X is a valid address for machine mode MODE.  If it is,\n+   fill in INFO appropriately.  STRICT is true if we should only accept\n+   hard base registers.  */\n+int\n+mda_classify_address (struct score_address_info *info,\n+                      enum machine_mode mode, rtx x, int strict)\n+{\n+  info->code = GET_CODE (x);\n+\n+  switch (info->code)\n+    {\n+    case REG:\n+    case SUBREG:\n+      info->type = ADD_REG;\n+      info->reg = x;\n+      info->offset = const0_rtx;\n+      return mda_valid_base_register_p (info->reg, strict);\n+    case PLUS:\n+      info->type = ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = XEXP (x, 1);\n+      return (mda_valid_base_register_p (info->reg, strict)\n+              && GET_CODE (info->offset) == CONST_INT\n+              && CONST_OK_FOR_LETTER_P (INTVAL (info->offset), 'O'));\n+    case PRE_DEC:\n+    case POST_DEC:\n+    case PRE_INC:\n+    case POST_INC:\n+      if (TARGET_NOPINDEX || GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n+        return false;\n+      info->type = ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n+      return mda_valid_base_register_p (info->reg, strict);\n+    case CONST_INT:\n+      info->type = ADD_CONST_INT;\n+      return CONST_OK_FOR_LETTER_P (INTVAL (x), 'O');\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      info->type = ADD_SYMBOLIC;\n+      return (mda_symbolic_constant_p (x, &info->symbol_type)\n+              && (info->symbol_type == SYMBOL_GENERAL\n+                  || info->symbol_type == SYMBOL_SMALL_DATA));\n+    default:\n+      return 0;\n+    }\n+}\n+\n+void\n+mda_gen_cmp (enum machine_mode mode)\n+{\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n+                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+}\n+\n+/* Return true if X is a symbolic constant that can be calculated in\n+   the same way as a bare symbol.  If it is, store the type of the\n+   symbol in *SYMBOL_TYPE.  */\n+int\n+mda_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  score_split_const (x, &x, &offset);\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    *symbol_type = score_classify_symbol (x);\n+  else\n+    return 0;\n+\n+  if (offset == 0)\n+    return 1;\n+\n+  /* if offset > 15bit, must reload  */\n+  if (!CONST_OK_FOR_LETTER_P (offset, 'O'))\n+    return 0;\n+\n+  switch (*symbol_type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 1;\n+    case SYMBOL_SMALL_DATA:\n+      return score_offset_within_object_p (x, offset);\n+    }\n+  gcc_unreachable ();\n+}\n+\n+void\n+mdx_movsicc (rtx *ops)\n+{\n+  enum machine_mode mode = CCmode;\n+\n+  if (GET_CODE (ops[1]) == EQ || GET_CODE (ops[1]) == NE)\n+    mode = CC_NZmode;\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n+                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+}\n+\n+/* Call and sibcall pattern all need call this function.  */\n+void\n+mdx_call (rtx *ops, bool sib)\n+{\n+  rtx addr = XEXP (ops[0], 0);\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_internal (addr, ops[1]));\n+  else\n+    emit_call_insn (gen_call_internal (addr, ops[1]));\n+}\n+\n+/* Call value and sibcall value pattern all need call this function.  */\n+void\n+mdx_call_value (rtx *ops, bool sib)\n+{\n+  rtx result = ops[0];\n+  rtx addr = XEXP (ops[1], 0);\n+  rtx arg = ops[2];\n+\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_value_internal (result, addr, arg));\n+  else\n+    emit_call_insn (gen_call_value_internal (result, addr, arg));\n+}\n+\n+/* Machine Split  */\n+void\n+mds_movdi (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx dst0 = subw (dst, 0);\n+  rtx dst1 = subw (dst, 1);\n+  rtx src0 = subw (src, 0);\n+  rtx src1 = subw (src, 1);\n+\n+  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n+    {\n+      emit_move_insn (dst1, src1);\n+      emit_move_insn (dst0, src0);\n+    }\n+  else\n+    {\n+      emit_move_insn (dst0, src0);\n+      emit_move_insn (dst1, src1);\n+    }\n+}\n+\n+void\n+mds_zero_extract_andi (rtx *ops)\n+{\n+  if (INTVAL (ops[1]) == 1 && const_bi_operand (ops[2], SImode))\n+    emit_insn (gen_zero_extract_bittst (ops[0], ops[2]));\n+  else\n+    {\n+      unsigned HOST_WIDE_INT mask;\n+      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n+      mask = mask << INTVAL (ops[2]);\n+      emit_insn (gen_andsi3_cmp (ops[0], gen_int_mode (mask, SImode)));\n+    }\n+}\n+\n+/* Check addr could be present as PRE/POST mode.  */\n+static bool\n+mda_pindex_mem (rtx addr)\n+{\n+  if (GET_CODE (addr) == MEM)\n+    {\n+      switch (GET_CODE (XEXP (addr, 0)))\n+        {\n+        case PRE_DEC:\n+        case POST_DEC:\n+        case PRE_INC:\n+        case POST_INC:\n+          return true;\n+        default:\n+          break;\n+        }\n+    }\n+  return false;\n+}\n+\n+/* Output asm code for ld/sw insn.  */\n+static int\n+pr_addr_post (rtx *ops, int idata, int iaddr, char *ip, enum mda_mem_unit unit)\n+{\n+  struct score_address_info ai;\n+\n+  gcc_assert (GET_CODE (ops[idata]) == REG);\n+  gcc_assert (mda_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n+\n+  if (!mda_pindex_mem (ops[iaddr])\n+      && ai.type == ADD_REG\n+      && GET_CODE (ai.offset) == CONST_INT\n+      && G16_REG_P (REGNO (ops[idata]))\n+      && G16_REG_P (REGNO (ai.reg)))\n+    {\n+      if (INTVAL (ai.offset) == 0)\n+        {\n+          ops[iaddr] = ai.reg;\n+          return snprintf (ip, INS_BUF_SZ,\n+                           \"!        %%%d, [%%%d]\", idata, iaddr);\n+        }\n+      if (REGNO (ai.reg) == HARD_FRAME_POINTER_REGNUM)\n+        {\n+          HOST_WIDE_INT offset = INTVAL (ai.offset);\n+          if (MDA_ALIGN_UNIT (offset, unit)\n+              && CONST_OK_FOR_LETTER_P (offset >> unit, 'J'))\n+            {\n+              ops[iaddr] = ai.offset;\n+              return snprintf (ip, INS_BUF_SZ,\n+                               \"p!        %%%d, %%c%d\", idata, iaddr);\n+            }\n+        }\n+    }\n+  return snprintf (ip, INS_BUF_SZ, \"        %%%d, %%a%d\", idata, iaddr);\n+}\n+\n+/* Output asm insn for load.  */\n+const char *\n+mdp_linsn (rtx *ops, enum mda_mem_unit unit, bool sign)\n+{\n+  const char *pre_ins[] =\n+    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n+  char *ip;\n+\n+  strcpy (ins, pre_ins[(sign ? 4 : 0) + unit]);\n+  ip = ins + strlen (ins);\n+\n+  if ((!sign && unit != MDA_HWORD)\n+      || (sign && unit != MDA_BYTE))\n+    pr_addr_post (ops, 0, 1, ip, unit);\n+  else\n+    snprintf (ip, INS_BUF_SZ, \"        %%0, %%a1\");\n+\n+  return ins;\n+}\n+\n+/* Output asm insn for store.  */\n+const char *\n+mdp_sinsn (rtx *ops, enum mda_mem_unit unit)\n+{\n+  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n+  char *ip;\n+\n+  strcpy (ins, pre_ins[unit]);\n+  ip = ins + strlen (ins);\n+  pr_addr_post (ops, 1, 0, ip, unit);\n+  return ins;\n+}\n+\n+/* Output asm insn for load immediate.  */\n+const char *\n+mdp_limm (rtx *ops)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+\n+  if (G16_REG_P (REGNO (ops[0]))\n+      && CONST_OK_FOR_LETTER_P (INTVAL (ops[1]), 'I'))\n+    return \"ldiu!   %0, %c1\";\n+  else if (CONST_OK_FOR_LETTER_P (INTVAL (ops[1]), 'L'))\n+    return \"ldi     %0, %c1\";\n+  else if (EXTRA_CONSTRAINT (ops[1], 'Q'))\n+    return \"ldis    %0, %U1\";\n+  else\n+    return \"li      %0, %D1\";\n+}\n+\n+/* Output asm insn for move.  */\n+const char *\n+mdp_move (rtx *ops)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  if (G16_REG_P (REGNO (ops[0])))\n+    {\n+      if (G16_REG_P (REGNO (ops[1])))\n+        return \"mv!     %0, %1\";\n+      else\n+        return \"mlfh!   %0, %1\";\n+    }\n+  else if (G16_REG_P (REGNO (ops[1])))\n+    return \"mhfl!   %0, %1\";\n+  else\n+    return \"mv      %0, %1\";\n+}\n+\n+/* Score support add/sub with exponent immediate insn,\n+   use to judge imm condition.  */\n+static unsigned int\n+num_bits1 (unsigned HOST_WIDE_INT v)\n+{\n+  int i, n = 0;\n+\n+  for (i = 0; i < BITS_PER_WORD; i++)\n+    n += BITSET_P (v, i) ? 1 : 0;\n+  return n;\n+}\n+\n+/* Generate add insn, insn will affect condition flag. Optimize used.  */\n+const char *\n+mdp_add_imm_ucc (rtx *ops)\n+{\n+  HOST_WIDE_INT v = INTVAL (ops[2]);\n+\n+  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n+  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n+\n+  if (G16_REG_P (REGNO (ops[0])))\n+    {\n+      if (v > 0 && num_bits1 (v) == 1 && IMM_IN_RANGE (ffs (v) - 1, 4, 0))\n+        {\n+          ops[2] = GEN_INT (ffs (v) - 1);\n+          return \"addei!  %0, %c2\";\n+        }\n+\n+      if (v < 0 && num_bits1 (-v) == 1 && IMM_IN_RANGE (ffs (-v) - 1, 4, 0))\n+        {\n+          ops[2] = GEN_INT (ffs (-v) - 1);\n+          return \"subei!  %0, %c2\";\n+        }\n+    }\n+    return \"addi.c  %0, %c2\";\n+}\n+\n+/* Output arith insn, insn will update condition flag.  */\n+const char *\n+mdp_select (rtx *ops, const char *inst_pre, bool commu, const char *let)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  if (G16_REG_P (REGNO (ops[0]))\n+      && (GET_CODE (ops[2]) == REG ? G16_REG_P (REGNO (ops[2])) : 1)\n+      && REGNO (ops[0]) == REGNO (ops[1]))\n+    {\n+      snprintf (ins, INS_BUF_SZ, \"%s!        %%0, %%%s2\", inst_pre, let);\n+      return ins;\n+    }\n+\n+  if (commu && G16_REG_P (REGNO (ops[0]))\n+      && G16_REG_P (REGNO (ops[1]))\n+      && REGNO (ops[0]) == REGNO (ops[2]))\n+    {\n+      gcc_assert (GET_CODE (ops[2]) == REG);\n+      snprintf (ins, INS_BUF_SZ, \"%s!        %%0, %%%s1\", inst_pre, let);\n+      return ins;\n+    }\n+\n+  snprintf (ins, INS_BUF_SZ, \"%s.c        %%0, %%1, %%%s2\", inst_pre, let);\n+  return ins;\n+}\n+"}, {"sha": "965174996b0ad05f4c41a07ee0d10503cde33533", "filename": "gcc/config/score/score-mdaux.h", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,113 @@\n+/* score-mdaux.h for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Sunnorth\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#ifndef SCORE_MDAUX_0621\n+#define SCORE_MDAUX_0621\n+\n+/* Machine Auxiliary Functions.  */\n+enum score_address_type\n+{\n+  ADD_REG,\n+  ADD_CONST_INT,\n+  ADD_SYMBOLIC\n+};\n+#ifdef RTX_CODE\n+struct score_address_info\n+{\n+  enum score_address_type type;\n+  rtx reg;\n+  rtx offset;\n+  enum rtx_code code;\n+  enum score_symbol_type symbol_type;\n+};\n+#endif\n+\n+struct score_frame_info\n+{\n+  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n+  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n+  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n+  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n+  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n+  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n+  unsigned int  mask;             /* mask of saved gp registers  */\n+  int num_gp;                     /* number of gp registers saved  */\n+};\n+\n+typedef void (*score_save_restore_fn) (rtx, rtx);\n+\n+int mda_valid_base_register_p (rtx x, int strict);\n+\n+#ifdef RTX_CODE\n+int mda_classify_address (struct score_address_info *info,\n+                          enum machine_mode mode, rtx x, int strict);\n+\n+struct score_frame_info *mda_compute_frame_size (HOST_WIDE_INT size);\n+\n+struct score_frame_info *mda_cached_frame (void);\n+\n+void mda_gen_cmp (enum machine_mode mode);\n+#endif\n+\n+int mda_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type);\n+\n+bool mda_pindex_mem (rtx addr);\n+\n+int mda_bp (void);\n+\n+/* Machine Expand.  */\n+void mdx_prologue (void);\n+\n+void mdx_epilogue (int sibcall_p);\n+\n+void mdx_movsicc (rtx *ops);\n+\n+void mdx_call (rtx *ops, bool sibcall);\n+\n+void mdx_call_value (rtx *ops, bool sibcall);\n+\n+/* Machine Split.  */\n+void mds_movdi (rtx *ops);\n+\n+void mds_addsi (rtx *ops);\n+\n+void mds_zero_extract_andi (rtx *ops);\n+\n+/* Machine Print.  */\n+enum mda_mem_unit {MDA_BYTE = 0, MDA_HWORD = 1, MDA_WORD = 2};\n+\n+#define MDA_ALIGN_UNIT(V, UNIT)   !(V & ((1 << UNIT) - 1))\n+\n+const char * mdp_linsn (rtx *ops, enum mda_mem_unit unit, bool sign);\n+\n+const char * mdp_sinsn (rtx *ops, enum mda_mem_unit unit);\n+\n+const char * mdp_add_imm_ucc (rtx *ops);\n+\n+const char * mdp_select (rtx *ops, const char *inst_pre,\n+                        bool comu, const char *let);\n+\n+const char * mdp_limm (rtx *ops);\n+\n+const char * mdp_move (rtx *ops);\n+\n+#endif\n+"}, {"sha": "2f076f5b8e6568ca4a758d4c7e6d7f7a3d0ea364", "filename": "gcc/config/score/score-modes.def", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-modes.def?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,26 @@\n+/* score-modes.def for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+/* CC_NZmode should be used if the N (sign) and Z (zero) flag is set correctly.\n+   CC_Nmode should be used if only the N flag is set correctly.  */\n+\n+CC_MODE (CC_NZ);\n+CC_MODE (CC_N);\n+"}, {"sha": "bbe444e91d1bf2610fb62342e3825e1d0f20e2b3", "filename": "gcc/config/score/score-protos.h", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,92 @@\n+/* score-protos.h for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#ifndef __SCORE_PROTOS_H__\n+#define __SCORE_PROTOS_H__\n+\n+extern enum reg_class score_char_to_class[];\n+\n+void score_override_options (void);\n+\n+void score_init_expanders (void);\n+\n+int score_hard_regno_mode_ok (unsigned int, enum machine_mode);\n+\n+int score_reg_class (int regno);\n+\n+enum reg_class score_preferred_reload_class (rtx x, enum reg_class class);\n+\n+enum reg_class score_secondary_reload_class (enum reg_class class,\n+                                             enum machine_mode mode, rtx x);\n+\n+int score_const_ok_for_letter_p (int value, char c);\n+\n+int score_extra_constraint (rtx op, char c);\n+\n+rtx score_return_addr (int count, rtx frame);\n+\n+HOST_WIDE_INT score_initial_elimination_offset (int from, int to);\n+\n+rtx score_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                        tree type, int named);\n+\n+int score_arg_partial_nregs (const CUMULATIVE_ARGS *cum,\n+                             enum machine_mode mode, tree type, int named);\n+\n+void score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n+                                 tree fntype, rtx libname);\n+\n+void score_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                                 tree type, int named);\n+\n+rtx score_function_value (tree valtype, tree func, enum machine_mode mode);\n+\n+rtx score_va_arg (tree va_list, tree type);\n+\n+void score_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN);\n+\n+int score_address_p (enum machine_mode mode, rtx x, int strict);\n+\n+int score_legitimize_address (rtx *xloc);\n+\n+int score_regno_mode_ok_for_base_p (int regno, int strict);\n+\n+int score_register_move_cost (enum machine_mode mode, enum reg_class to,\n+                              enum reg_class from);\n+\n+void score_declare_object (FILE *stream, const char *name,\n+                           const char *directive, const char *fmt, ...);\n+\n+void score_declare_object_name (FILE *stream, const char *name, tree decl);\n+\n+int score_output_external (FILE *file, tree decl, const char *name);\n+\n+void score_print_operand (FILE *file, rtx op, int letter);\n+\n+void score_print_operand_address (FILE *file, rtx addr);\n+\n+#ifdef RTX_CODE\n+enum machine_mode score_select_cc_mode (enum rtx_code op, rtx x, rtx y);\n+#endif\n+\n+#include \"score-mdaux.h\"\n+\n+#endif /* __SCORE_PROTOS_H__  */\n+"}, {"sha": "2eeaf2f0d998059080d00bc1ee746d475c7f7849", "filename": "gcc/config/score/score-version.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore-version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-version.h?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,21 @@\n+/* score-version.h for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#define SCORE_GCC_VERSION \"1.1\""}, {"sha": "458de7922e239f10b99b1d6655fdd8aefcbf4af4", "filename": "gcc/config/score/score.c", "status": "added", "additions": 1071, "deletions": 0, "changes": 1071, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,1071 @@\n+/* Output routines for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Sunnorth.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include <signal.h>\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"flags.h\"\n+#include \"reload.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"gstab.h\"\n+#include \"hashtab.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"integrate.h\"\n+#include \"langhooks.h\"\n+#include \"cfglayout.h\"\n+#include \"score-mdaux.h\"\n+\n+#define GR_REG_CLASS_P(C)        ((C) == G16_REGS || (C) == G32_REGS)\n+#define SP_REG_CLASS_P(C) \\\n+  ((C) == CN_REG || (C) == LC_REG || (C) == SC_REG || (C) == SP_REGS)\n+#define CP_REG_CLASS_P(C) \\\n+  ((C) == CP1_REGS || (C) == CP2_REGS || (C) == CP3_REGS || (C) == CPA_REGS)\n+#define CE_REG_CLASS_P(C) \\\n+  ((C) == HI_REG || (C) == LO_REG || (C) == CE_REGS)\n+\n+static int score_arg_partial_bytes (const CUMULATIVE_ARGS *cum,\n+                                    enum machine_mode mode,\n+                                    tree type, int named);\n+\n+#undef  TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START                   th_asm_file_start\n+\n+#undef  TARGET_ASM_FILE_END\n+#define TARGET_ASM_FILE_END                     th_asm_file_end\n+\n+#undef  TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE            th_function_prologue\n+\n+#undef  TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE            th_function_epilogue\n+\n+#undef  TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE                 th_issue_rate\n+\n+#undef TARGET_ASM_SELECT_RTX_SECTION\n+#define TARGET_ASM_SELECT_RTX_SECTION           th_select_rtx_section\n+\n+#undef  TARGET_IN_SMALL_DATA_P\n+#define TARGET_IN_SMALL_DATA_P                  th_in_small_data_p\n+\n+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL          th_function_ok_for_sibcall\n+\n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING           th_strict_argument_naming\n+\n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK              th_output_mi_thunk\n+\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK       hook_bool_tree_hwi_hwi_tree_true\n+\n+#undef TARGET_PROMOTE_FUNCTION_ARGS\n+#define TARGET_PROMOTE_FUNCTION_ARGS            hook_bool_tree_true\n+\n+#undef TARGET_PROMOTE_FUNCTION_RETURN\n+#define TARGET_PROMOTE_FUNCTION_RETURN          hook_bool_tree_true\n+\n+#undef TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES               hook_bool_tree_true\n+\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK               must_pass_in_stack_var_size\n+\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES                score_arg_partial_bytes\n+\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE                score_pass_by_reference\n+\n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY                 score_return_in_memory\n+\n+/* Implement TARGET_RETURN_IN_MEMORY.  In S+core,\n+   small structures are returned in a register.\n+   Objects with varying size must still be returned in memory.  */\n+static bool\n+score_return_in_memory (tree type, tree fndecl ATTRIBUTE_UNUSED)\n+{\n+  return ((TYPE_MODE (type) == BLKmode)\n+          || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n+          || (int_size_in_bytes (type) == -1));\n+}\n+\n+/* Return nonzero when an argument must be passed by reference.  */\n+static bool\n+score_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+                         enum machine_mode mode, tree type,\n+                         bool named ATTRIBUTE_UNUSED)\n+{\n+  /* If we have a variable-sized parameter, we have no choice.  */\n+  return targetm.calls.must_pass_in_stack (mode, type);\n+}\n+\n+/* Return a legitimate address for REG + OFFSET.  */\n+static rtx\n+score_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)\n+{\n+  if (!CONST_OK_FOR_LETTER_P (offset, 'O'))\n+    {\n+      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n+                                 gen_int_mode (offset & 0xffffc000,\n+                                               GET_MODE (reg)),\n+                                 reg, NULL, 0, OPTAB_WIDEN);\n+      offset &= 0x3fff;\n+    }\n+\n+  return plus_constant (reg, offset);\n+}\n+\n+/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n+   in order to avoid duplicating too much logic from elsewhere.  */\n+static void\n+th_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+                    HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+                    tree function)\n+{\n+  rtx this, temp1, temp2, insn, fnaddr;\n+\n+  /* Pretend to be a post-reload pass while generating rtl.  */\n+  no_new_pseudos = 1;\n+  reload_completed = 1;\n+  reset_block_changes ();\n+\n+  /* We need two temporary registers in some cases.  */\n+  temp1 = gen_rtx_REG (Pmode, 8);\n+  temp2 = gen_rtx_REG (Pmode, 9);\n+\n+  /* Find out which register contains the \"this\" pointer.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    this = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n+  else\n+    this = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n+\n+  /* Add DELTA to THIS.  */\n+  if (delta != 0)\n+    {\n+      rtx offset = GEN_INT (delta);\n+      if (!CONST_OK_FOR_LETTER_P (delta, 'L'))\n+        {\n+          emit_move_insn (temp1, offset);\n+          offset = temp1;\n+        }\n+      emit_insn (gen_add3_insn (this, this, offset));\n+    }\n+\n+  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  if (vcall_offset != 0)\n+    {\n+      rtx addr;\n+\n+      /* Set TEMP1 to *THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n+\n+      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      addr = score_add_offset (temp2, temp1, vcall_offset);\n+\n+      /* Load the offset and add it to THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n+      emit_insn (gen_add3_insn (this, this, temp1));\n+    }\n+\n+  /* Jump to the target function.  */\n+  fnaddr = XEXP (DECL_RTL (function), 0);\n+  insn = emit_call_insn (gen_sibcall_internal (fnaddr, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  /* Run just enough of rest_of_compilation.  This sequence was\n+     \"borrowed\" from alpha.c.  */\n+  insn = get_insns ();\n+  insn_locators_initialize ();\n+  split_all_insns_noflow ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+\n+  /* Clean up the vars set above.  Note that final_end_function resets\n+     the global pointer for us.  */\n+  reload_completed = 0;\n+  no_new_pseudos = 0;\n+}\n+\n+/* Implement TARGET_STRICT_ARGUMENT_NAMING.  */\n+static bool\n+th_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+/* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n+static bool\n+th_function_ok_for_sibcall (ATTRIBUTE_UNUSED tree decl,\n+                            ATTRIBUTE_UNUSED tree exp)\n+{\n+  return true;\n+}\n+\n+struct score_arg_info\n+{\n+  /* The argument's size, in bytes.  */\n+  unsigned int num_bytes;\n+\n+  /* The number of words passed in registers, rounded up.  */\n+  unsigned int reg_words;\n+\n+  /* The offset of the first register from GP_ARG_FIRST or FP_ARG_FIRST,\n+     or ARG_REG_NUM if the argument is passed entirely on the stack.  */\n+  unsigned int reg_offset;\n+\n+  /* The number of words that must be passed on the stack, rounded up.  */\n+  unsigned int stack_words;\n+\n+  /* The offset from the start of the stack overflow area of the argument's\n+     first stack word.  Only meaningful when STACK_WORDS is nonzero.  */\n+  unsigned int stack_offset;\n+};\n+\n+/* Fill INFO with information about a single argument.  CUM is the\n+   cumulative state for earlier arguments.  MODE is the mode of this\n+   argument and TYPE is its type (if known).  NAMED is true if this\n+   is a named (fixed) argument rather than a variable one.  */\n+static void\n+classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+              tree type, int named, struct score_arg_info *info)\n+{\n+  int even_reg_p;\n+  unsigned int num_words, max_regs;\n+\n+  even_reg_p = 0;\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n+  else\n+    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n+      even_reg_p = 1;\n+\n+  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n+    info->reg_offset = ARG_REG_NUM;\n+  else\n+    {\n+      info->reg_offset = cum->num_gprs;\n+      if (even_reg_p)\n+        info->reg_offset += info->reg_offset & 1;\n+    }\n+\n+  if (mode == BLKmode)\n+    info->num_bytes = int_size_in_bytes (type);\n+  else\n+    info->num_bytes = GET_MODE_SIZE (mode);\n+\n+  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  max_regs = ARG_REG_NUM - info->reg_offset;\n+\n+  /* Partition the argument between registers and stack.  */\n+  info->reg_words = MIN (num_words, max_regs);\n+  info->stack_words = num_words - info->reg_words;\n+\n+  /* The alignment applied to registers is also applied to stack arguments.  */\n+  if (info->stack_words)\n+    {\n+      info->stack_offset = cum->stack_words;\n+      if (even_reg_p)\n+        info->stack_offset += info->stack_offset & 1;\n+    }\n+}\n+\n+/* Set up the stack and frame (if desired) for the function.  */\n+static void\n+th_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  const char *fnname;\n+  struct score_frame_info *f = mda_cached_frame ();\n+  HOST_WIDE_INT tsize = f->total_size;\n+\n+  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fputs (\"\\t.ent\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n+  assemble_name (file, fnname);\n+  fputs (\":\\n\", file);\n+\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fprintf (file,\n+               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n+               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n+               \", args= \" HOST_WIDE_INT_PRINT_DEC\n+               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+               (reg_names[(frame_pointer_needed)\n+                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n+               tsize,\n+               reg_names[RA_REGNUM],\n+               current_function_is_leaf ? 1 : 0,\n+               f->var_size,\n+               f->num_gp,\n+               f->args_size,\n+               f->cprestore_size);\n+\n+      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+              f->mask,\n+              (f->gp_sp_offset - f->total_size));\n+    }\n+}\n+\n+/* Do any necessary cleanup after a function to restore stack, frame,\n+   and regs.  */\n+static void\n+th_function_epilogue (FILE *file,\n+                      HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  if (!flag_inhibit_size_directive)\n+    {\n+      const char *fnname;\n+      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+      fputs (\"\\t.end\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n+}\n+\n+/* Implement TARGET_SCHED_ISSUE_RATE.  */\n+static int\n+th_issue_rate (void)\n+{\n+  return 1;\n+}\n+\n+/* Returns true if X contains a SYMBOL_REF.  */\n+static bool\n+symbolic_expression_p (rtx x)\n+{\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return true;\n+\n+  if (GET_CODE (x) == CONST)\n+    return symbolic_expression_p (XEXP (x, 0));\n+\n+  if (UNARY_P (x))\n+    return symbolic_expression_p (XEXP (x, 0));\n+\n+  if (ARITHMETIC_P (x))\n+    return (symbolic_expression_p (XEXP (x, 0))\n+            || symbolic_expression_p (XEXP (x, 1)));\n+\n+  return false;\n+}\n+\n+/* Choose the section to use for the constant rtx expression X that has\n+   mode MODE.  */\n+static section *\n+th_select_rtx_section (enum machine_mode mode, rtx x,\n+                       unsigned HOST_WIDE_INT align)\n+{\n+  if (GET_MODE_SIZE (mode) <= SCORE_SDATA_MAX)\n+    return get_named_section (0, \".sdata\", 0);\n+  else if (flag_pic && symbolic_expression_p (x))\n+    return get_named_section (0, \".data.rel.ro\", 3);\n+  else\n+    return mergeable_constant_section (mode, align, 0);\n+}\n+\n+/* Implement TARGET_IN_SMALL_DATA_P.  */\n+static bool\n+th_in_small_data_p (tree decl)\n+{\n+  HOST_WIDE_INT size;\n+\n+  if (TREE_CODE (decl) == STRING_CST\n+      || TREE_CODE (decl) == FUNCTION_DECL)\n+    return false;\n+\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n+    {\n+      const char *name;\n+      name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n+      if (strcmp (name, \".sdata\") != 0\n+          && strcmp (name, \".sbss\") != 0)\n+        return true;\n+      if (!DECL_EXTERNAL (decl))\n+        return false;\n+    }\n+  size = int_size_in_bytes (TREE_TYPE (decl));\n+  return (size > 0 && size <= SCORE_SDATA_MAX);\n+}\n+\n+/* Implement TARGET_ASM_FILE_START.  */\n+static void\n+th_asm_file_start (void)\n+{\n+  default_file_start ();\n+  fprintf (asm_out_file, ASM_COMMENT_START\n+           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n+\n+  if (flag_pic)\n+    fprintf (asm_out_file, \"\\t.set pic\\n\");\n+}\n+\n+/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n+   .externs for any small-data variables that turned out to be external.  */\n+struct extern_list *extern_head = 0;\n+\n+static void\n+th_asm_file_end (void)\n+{\n+  tree name_tree;\n+  struct extern_list *p;\n+  if (extern_head)\n+    {\n+      fputs (\"\\n\", asm_out_file);\n+      for (p = extern_head; p != 0; p = p->next)\n+        {\n+          name_tree = get_identifier (p->name);\n+          if (!TREE_ASM_WRITTEN (name_tree)\n+              && TREE_SYMBOL_REFERENCED (name_tree))\n+            {\n+              TREE_ASM_WRITTEN (name_tree) = 1;\n+              fputs (\"\\t.extern\\t\", asm_out_file);\n+              assemble_name (asm_out_file, p->name);\n+              fprintf (asm_out_file, \", %d\\n\", p->size);\n+            }\n+        }\n+    }\n+}\n+\n+static unsigned int sdata_max;\n+\n+int\n+score_sdata_max (void)\n+{\n+  return sdata_max;\n+}\n+\n+/* default 0 = NO_REGS  */\n+enum reg_class score_char_to_class[256];\n+\n+/* Implement OVERRIDE_OPTIONS macro.  */\n+void\n+score_override_options (void)\n+{\n+  if (!flag_pic)\n+    sdata_max = g_switch_set ? g_switch_value : DEFAULT_SDATA_MAX;\n+  else\n+    {\n+      sdata_max = 0;\n+      if (g_switch_set)\n+        warning (0, \"-fPIC and -G are incompatible\");\n+    }\n+\n+  score_char_to_class['d'] = G32_REGS;\n+  score_char_to_class['e'] = G16_REGS;\n+  score_char_to_class['t'] = T32_REGS;\n+\n+  score_char_to_class['h'] = HI_REG;\n+  score_char_to_class['l'] = LO_REG;\n+  score_char_to_class['x'] = CE_REGS;\n+\n+  score_char_to_class['q'] = CN_REG;\n+  score_char_to_class['y'] = LC_REG;\n+  score_char_to_class['z'] = SC_REG;\n+  score_char_to_class['a'] = SP_REGS;\n+\n+  score_char_to_class['c'] = CR_REGS;\n+\n+  score_char_to_class['b'] = CP1_REGS;\n+  score_char_to_class['f'] = CP2_REGS;\n+  score_char_to_class['i'] = CP3_REGS;\n+  score_char_to_class['j'] = CPA_REGS;\n+}\n+\n+/* Implement REGNO_REG_CLASS macro.  */\n+int\n+score_reg_class (int regno)\n+{\n+  int c;\n+  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n+\n+  if (regno == FRAME_POINTER_REGNUM\n+      || regno == ARG_POINTER_REGNUM)\n+    return ALL_REGS;\n+\n+  for (c = 0 ; c < N_REG_CLASSES ; c++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n+      return c;\n+\n+  return NO_REGS;\n+}\n+\n+/* Implement PREFERRED_RELOAD_CLASS macro.  */\n+enum reg_class\n+score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+{\n+  if (reg_class_subset_p (G32_REGS, class))\n+    class = G32_REGS;\n+  if (reg_class_subset_p (G16_REGS, class))\n+    class = G16_REGS;\n+  return class;\n+}\n+\n+/* Implement SECONDARY_INPUT_RELOAD_CLASS\n+   and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n+enum reg_class\n+score_secondary_reload_class (enum reg_class class,\n+                              enum machine_mode mode ATTRIBUTE_UNUSED,\n+                              rtx x)\n+{\n+  int regno = -1;\n+  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n+    regno = true_regnum (x);\n+\n+  if (!GR_REG_CLASS_P (class))\n+    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n+  return NO_REGS;\n+}\n+\n+/* Implement CONST_OK_FOR_LETTER_P macro.  */\n+/* imm constraints\n+   I        IMM8        (i15-2-form)\n+   J        IMM5        (i15_1-form)\n+   K        IMM16       (i-form)\n+   L        IMM16s      (i-form)\n+   M        IMM14       (ri-form)\n+   N        IMM14s      (ri-form)\n+   O        IMM15s      (ri-form)\n+   P        IMM12s      (rix-form) / IMM10s(cop-form) << 2  */\n+int\n+score_const_ok_for_letter_p (int value, char c)\n+{\n+  switch (c)\n+    {\n+    case 'I': return IMM_IN_RANGE (value, 8, 0);\n+    case 'J': return IMM_IN_RANGE (value, 5, 0);\n+    case 'K': return IMM_IN_RANGE (value, 16, 0);\n+    case 'L': return IMM_IN_RANGE (value, 16, 1);\n+    case 'M': return IMM_IN_RANGE (value, 14, 0);\n+    case 'N': return IMM_IN_RANGE (value, 14, 1);\n+    case 'O': return IMM_IN_RANGE (value, 15, 1);\n+    case 'P': return IMM_IN_RANGE (value, 12, 1);\n+    default : return 0;\n+    }\n+}\n+\n+/* Implement EXTRA_CONSTRAINT macro.  */\n+/* Q        const_hi    imm\n+   Z        symbol_ref  */\n+int\n+score_extra_constraint (rtx op, char c)\n+{\n+  switch (c)\n+    {\n+    case 'Q':\n+      return (GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff) == 0);\n+    case 'Z':\n+      return GET_CODE (op) == SYMBOL_REF;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return truth value on whether or not a given hard register\n+   can support a given mode.  */\n+int\n+score_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+{\n+  int size = GET_MODE_SIZE (mode);\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+\n+  if (class == MODE_CC)\n+    return regno == CC_REGNUM;\n+  else if (regno == FRAME_POINTER_REGNUM\n+           || regno == ARG_POINTER_REGNUM)\n+    return class == MODE_INT;\n+  else if (GP_REG_P (regno))\n+    /* ((regno <= (GP_REG_LAST- HARD_REGNO_NREGS (dummy, mode)) + 1)  */\n+    return !(regno & 1) || (size <= UNITS_PER_WORD);\n+  else if (CE_REG_P (regno))\n+    return (class == MODE_INT\n+            && ((size <= UNITS_PER_WORD)\n+                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n+  else\n+    return (class == MODE_INT) && (size <= UNITS_PER_WORD);\n+}\n+\n+/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n+   pointer or argument pointer.  TO is either the stack pointer or\n+   hard frame pointer.  */\n+HOST_WIDE_INT\n+score_initial_elimination_offset (int from,\n+                                  int to ATTRIBUTE_UNUSED)\n+{\n+  struct score_frame_info *f = mda_compute_frame_size (get_frame_size ());\n+  switch (from)\n+    {\n+    case ARG_POINTER_REGNUM:\n+      return f->total_size;\n+    case FRAME_POINTER_REGNUM:\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Argument support functions.  */\n+\n+/* Initialize CUMULATIVE_ARGS for a function.  */\n+void\n+score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n+                            tree fntype ATTRIBUTE_UNUSED,\n+                            rtx libname ATTRIBUTE_UNUSED)\n+{\n+  memset (cum, 0, sizeof (CUMULATIVE_ARGS));\n+}\n+\n+/* Implement FUNCTION_ARG_ADVANCE macro.  */\n+void\n+score_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                            tree type, int named)\n+{\n+  struct score_arg_info info;\n+  classify_arg (cum, mode, type, named, &info);\n+  cum->num_gprs = info.reg_offset + info.reg_words;\n+  if (info.stack_words > 0)\n+    cum->stack_words = info.stack_offset + info.stack_words;\n+  cum->arg_number++;\n+}\n+\n+/* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n+static int\n+score_arg_partial_bytes (const CUMULATIVE_ARGS *cum,\n+                         enum machine_mode mode, tree type, int named)\n+{\n+  struct score_arg_info info;\n+  classify_arg (cum, mode, type, named, &info);\n+  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n+}\n+\n+/* Implement FUNCTION_ARG macro.  */\n+rtx\n+score_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                    tree type, int named)\n+{\n+  struct score_arg_info info;\n+\n+  if (mode == VOIDmode || !named)\n+    return 0;\n+\n+  classify_arg (cum, mode, type, named, &info);\n+\n+  if (info.reg_offset == ARG_REG_NUM)\n+    return 0;\n+\n+  if (!info.stack_words)\n+    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n+  else\n+    {\n+      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n+      unsigned int i, part_offset = 0;\n+      for (i = 0; i < info.reg_words; i++)\n+        {\n+          rtx reg;\n+          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n+          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n+                                                   GEN_INT (part_offset));\n+          part_offset += UNITS_PER_WORD;\n+        }\n+      return ret;\n+    }\n+}\n+\n+/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n+   VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n+   VALTYPE is null and MODE is the mode of the return value.  */\n+rtx\n+score_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n+                      enum machine_mode mode)\n+{\n+  if (valtype)\n+    {\n+      int unsignedp;\n+      mode = TYPE_MODE (valtype);\n+      unsignedp = TYPE_UNSIGNED (valtype);\n+      mode = promote_mode (valtype, mode, &unsignedp, 1);\n+    }\n+  return gen_rtx_REG (mode, RT_REGNUM);\n+}\n+\n+/* Implement INITIALIZE_TRAMPOLINE macro.  */\n+void\n+score_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN)\n+{\n+#define FFCACHE          \"_flush_cache\"\n+#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n+\n+  unsigned int tramp[TRAMPOLINE_INSNS] = {\n+    0x8103bc56,                         /* mv      r8, r3          */\n+    0x9000bc05,                         /* bl      0x0x8           */\n+    0xc1238000 | (CODE_SIZE - 8),       /* lw      r9, &func       */\n+    0xc0038000\n+    | (STATIC_CHAIN_REGNUM << 21)\n+    | (CODE_SIZE - 4),                  /* lw  static chain reg, &chain */\n+    0x8068bc56,                         /* mv      r3, r8          */\n+    0x8009bc08,                         /* br      r9              */\n+    0x0,\n+    0x0,\n+    };\n+  rtx pfunc, pchain;\n+  int i;\n+\n+  for (i = 0; i < TRAMPOLINE_INSNS; i++)\n+    emit_move_insn (gen_rtx_MEM (ptr_mode, plus_constant (ADDR, i << 2)),\n+                    GEN_INT (tramp[i]));\n+\n+  pfunc = plus_constant (ADDR, CODE_SIZE);\n+  pchain = plus_constant (ADDR, CODE_SIZE + GET_MODE_SIZE (ptr_mode));\n+\n+  emit_move_insn (gen_rtx_MEM (ptr_mode, pfunc), FUNC);\n+  emit_move_insn (gen_rtx_MEM (ptr_mode, pchain), CHAIN);\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, FFCACHE),\n+                     0, VOIDmode, 2,\n+                     ADDR, Pmode,\n+                     GEN_INT (TRAMPOLINE_SIZE), SImode);\n+#undef FFCACHE\n+#undef CODE_SIZE\n+}\n+\n+/* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n+int\n+score_regno_mode_ok_for_base_p (int regno, int strict)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (!strict)\n+        return 1;\n+      regno = reg_renumber[regno];\n+    }\n+  if (regno == ARG_POINTER_REGNUM\n+      || regno == FRAME_POINTER_REGNUM)\n+    return 1;\n+  return GP_REG_P (regno);\n+}\n+\n+/* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n+int\n+score_address_p (enum machine_mode mode, rtx x, int strict)\n+{\n+  struct score_address_info addr;\n+\n+  return mda_classify_address (&addr, mode, x, strict);\n+}\n+\n+/* Copy VALUE to a register and return that register.  If new psuedos\n+   are allowed, copy it into a new register, otherwise use DEST.  */\n+static rtx\n+score_force_temporary (rtx dest, rtx value)\n+{\n+  if (!no_new_pseudos)\n+    return force_reg (Pmode, value);\n+  else\n+    {\n+      emit_move_insn (copy_rtx (dest), value);\n+      return dest;\n+    }\n+}\n+\n+/* Return a LO_SUM expression for ADDR.  TEMP is as for score_force_temporary\n+   and is used to load the high part into a register.  */\n+static rtx\n+score_split_symbol (rtx temp, rtx addr)\n+{\n+  rtx high = score_force_temporary (temp,\n+                                    gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n+  return gen_rtx_LO_SUM (Pmode, high, addr);\n+}\n+\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n+   be legitimized in a way that the generic machinery might not expect,\n+   put the new address in *XLOC and return true.  */\n+int\n+score_legitimize_address (rtx *xloc)\n+{\n+  enum score_symbol_type symbol_type;\n+\n+  if (mda_symbolic_constant_p (*xloc, &symbol_type)\n+      && symbol_type == SYMBOL_GENERAL)\n+    {\n+      *xloc = score_split_symbol (0, *xloc);\n+      return 1;\n+    }\n+\n+  if (GET_CODE (*xloc) == PLUS\n+      && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n+    {\n+      rtx reg = XEXP (*xloc, 0);\n+      if (!mda_valid_base_register_p (reg, 0))\n+        reg = copy_to_mode_reg (Pmode, reg);\n+      *xloc = score_add_offset (NULL, reg, INTVAL (XEXP (*xloc, 1)));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return a number assessing the cost of moving a register in class\n+   FROM to class TO. */\n+int\n+score_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+                          enum reg_class from, enum reg_class to)\n+{\n+  if (GR_REG_CLASS_P (from))\n+    {\n+      if (GR_REG_CLASS_P (to))\n+        return 2;\n+      else if (SP_REG_CLASS_P (to))\n+        return 4;\n+      else if (CP_REG_CLASS_P (to))\n+        return 5;\n+      else if (CE_REG_CLASS_P (to))\n+        return 6;\n+    }\n+  if (GR_REG_CLASS_P (to))\n+    {\n+      if (GR_REG_CLASS_P (from))\n+        return 2;\n+      else if (SP_REG_CLASS_P (from))\n+        return 4;\n+      else if (CP_REG_CLASS_P (from))\n+        return 5;\n+      else if (CE_REG_CLASS_P (from))\n+        return 6;\n+    }\n+  return 12;\n+}\n+\n+/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n+int\n+score_output_external (FILE *file ATTRIBUTE_UNUSED,\n+                       tree decl, const char *name)\n+{\n+  register struct extern_list *p;\n+\n+  if (th_in_small_data_p (decl))\n+    {\n+      p = (struct extern_list *) ggc_alloc (sizeof (struct extern_list));\n+      p->next = extern_head;\n+      p->name = name;\n+      p->size = int_size_in_bytes (TREE_TYPE (decl));\n+      extern_head = p;\n+    }\n+  return 0;\n+}\n+\n+/* Output format asm string.  */\n+void\n+score_declare_object (FILE *stream, const char *name,\n+                      const char *directive, const char *fmt, ...)\n+{\n+  va_list ap;\n+  fputs (directive, stream);\n+  assemble_name (stream, name);\n+  va_start (ap, fmt);\n+  vfprintf (stream, fmt, ap);\n+  va_end (ap);\n+}\n+\n+/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n+   back to a previous frame.  */\n+rtx\n+score_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n+{\n+  if (count != 0)\n+    return const0_rtx;\n+  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n+}\n+\n+/* Implement PRINT_OPERAND macro.  */\n+/* Score-specific operand codes:\n+   '['        print .set nor1 directive\n+   ']'        print .set r1        directive\n+\n+   'U'        print hi part of a CONST_INT rtx\n+   'D'        print first part of const double\n+   'S'        selectively print '!' if operand is 15bit instrucion accessable\n+   'V'        print \"v!\" if operand is 15bit instruction accessable, or\n+   \"lfh!\"\n+\n+   'L'        low  part of DImode reg operand\n+   'H'        high part of DImode reg operand\n+\n+   'C'  print part of opcode for a branch condition.  */\n+void\n+score_print_operand (FILE *file, rtx op, int c)\n+{\n+  enum rtx_code code = -1;\n+  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n+    code = GET_CODE (op);\n+\n+  if (c == '[')\n+    {\n+      fprintf (file, \".set r1\\n\");\n+    }\n+  else if (c == ']')\n+    {\n+      fprintf (file, \"\\n\\t.set nor1\");\n+    }\n+  else if (c == 'U')\n+    {\n+      gcc_assert (code == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+               (unsigned HOST_WIDE_INT) INTVAL (op) >> 16);\n+    }\n+  else if (c == 'D')\n+    {\n+      if (GET_CODE (op) == CONST_DOUBLE)\n+        fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+                 TARGET_LITTLE_ENDIAN\n+                 ? CONST_DOUBLE_LOW (op) : CONST_DOUBLE_HIGH (op));\n+      else\n+        output_addr_const (file, op);\n+    }\n+  else if (c == 'S')\n+    {\n+      gcc_assert (code == REG);\n+      if (G16_REG_P (REGNO (op)))\n+        fprintf (file, \"!\");\n+    }\n+  else if (c == 'V')\n+    {\n+      gcc_assert (code == REG);\n+      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n+    }\n+  else if (code == REG)\n+    {\n+      int regnum = REGNO (op);\n+      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n+          || (c == 'L' && WORDS_BIG_ENDIAN))\n+        regnum ++;\n+      fprintf (file, \"%s\", reg_names[regnum]);\n+    }\n+  else if (c == 'C')\n+    {\n+      switch (code)\n+        {\n+        case EQ: fputs (\"eq\", file); break;\n+        case NE: fputs (\"ne\", file); break;\n+        case GT: fputs (\"gt\", file); break;\n+        case GE: fputs (\"ge\", file); break;\n+        case LT: fputs (\"lt\", file); break;\n+        case LE: fputs (\"le\", file); break;\n+        case GTU: fputs (\"gtu\", file); break;\n+        case GEU: fputs (\"cs\", file); break;\n+        case LTU: fputs (\"cc\", file); break;\n+        case LEU: fputs (\"leu\", file); break;\n+        default:\n+          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n+        }\n+    }\n+  else\n+    {\n+      switch (code)\n+        {\n+        case MEM:\n+          score_print_operand_address (file, op);\n+          break;\n+        default:\n+          output_addr_const (file, op);\n+        }\n+    }\n+}\n+\n+/* Implement PRINT_OPERAND_ADDRESS macro.  */\n+void\n+score_print_operand_address (FILE *file, rtx x)\n+{\n+  struct score_address_info addr;\n+  enum rtx_code code = GET_CODE (x);\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (code == MEM)\n+    x = XEXP (x, 0);\n+\n+  if (mda_classify_address (&addr, mode, x, true))\n+    {\n+      switch (addr.type)\n+        {\n+        case ADD_REG:\n+          {\n+            switch (addr.code)\n+              {\n+              case PRE_DEC:\n+                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_DEC:\n+                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case PRE_INC:\n+                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_INC:\n+                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              default:\n+                fprintf (file, \"[%s,%ld]\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              }\n+          }\n+          return;\n+        case ADD_CONST_INT:\n+        case ADD_SYMBOLIC:\n+          output_addr_const (file, x);\n+          return;\n+        }\n+    }\n+  print_rtl (stderr, x);\n+  gcc_unreachable ();\n+}\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "01fe9b57df8e26141b00ee2dac73af68a5e88b7e", "filename": "gcc/config/score/score.h", "status": "added", "additions": 909, "deletions": 0, "changes": 909, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,909 @@\n+/* score.h for Sunplus S+CORE processor\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Sunnorth.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#include \"score-conv.h\"\n+#include \"score-version.h\"\n+\n+/* Define the information needed to generate branch insns.  This is\n+   stored from the compare operation.  */\n+extern GTY(()) rtx cmp_op0;\n+extern GTY(()) rtx cmp_op1;\n+\n+/* Controlling the Compilation Driver.  */\n+#define SWITCH_TAKES_ARG(CHAR) \\\n+  (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n+\n+/* CC1_SPEC is the set of arguments to pass to the compiler proper.  */\n+#undef CC1_SPEC\n+#define CC1_SPEC                 \"%{!mel:-meb}\"\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+  \"%{!mel:-EB} %{mel:-EL} %{mSCORE5U:-SCORE5U} %{mSCORE7:-SCORE7} %{G*}\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC                 \"%{!mel:-EB} %{mel:-EL} %{G*}\"\n+\n+/* Run-time Target Specification.  */\n+#define TARGET_CPU_CPP_BUILTINS()               \\\n+  do {                                          \\\n+    builtin_define (\"SUNPLUS\");                 \\\n+    builtin_define (\"__SCORE__\");               \\\n+    builtin_define (\"__score__\");               \\\n+    if (TARGET_LITTLE_ENDIAN)                   \\\n+      builtin_define (\"__scorele__\");           \\\n+    else                                        \\\n+      builtin_define (\"__scorebe__\");           \\\n+    if (TARGET_SCORE5U)                         \\\n+      builtin_define (\"__score5u__\");           \\\n+  } while (0)\n+\n+\n+#define TARGET_DEFAULT         MASK_SCORE7\n+\n+#define TARGET_VERSION \\\n+  fprintf (stderr, \"Sunplus S+CORE %s\", SCORE_GCC_VERSION);\n+\n+#define OVERRIDE_OPTIONS       score_override_options ()\n+\n+/* Show we can debug even without a frame pointer.  */\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+/* Target machine storage layout.  */\n+#define BITS_BIG_ENDIAN        0\n+#define BYTES_BIG_ENDIAN       (TARGET_LITTLE_ENDIAN == 0)\n+#define WORDS_BIG_ENDIAN       (TARGET_LITTLE_ENDIAN == 0)\n+\n+/* Define this to set the endianness to use in libgcc2.c, which can\n+   not depend on target_flags.  */\n+#if defined(__scorele__)\n+#define LIBGCC2_WORDS_BIG_ENDIAN       0\n+#else\n+#define LIBGCC2_WORDS_BIG_ENDIAN       1\n+#endif\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD                 4\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)     \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT         \\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n+    (MODE) = SImode;\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY                  BITS_PER_WORD\n+#define STACK_BOUNDARY                 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY              BITS_PER_WORD\n+\n+/* There is no point aligning anything to a rounder boundary than this.  */\n+#define BIGGEST_ALIGNMENT              LONG_DOUBLE_TYPE_SIZE\n+\n+/* If defined, a C expression to compute the alignment for a static\n+   variable.  TYPE is the data type, and ALIGN is the alignment that\n+   the object would ordinarily have.  The value of this macro is used\n+   instead of that alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   One use of this macro is to increase alignment of medium-size\n+   data to make it all fit in fewer cache lines.  Another is to\n+   cause character arrays to be word-aligned so that `strcpy' calls\n+   that copy constants to character arrays can be done inline.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)                                     \\\n+  ((((ALIGN) < BITS_PER_WORD)                                           \\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE                                  \\\n+        || TREE_CODE (TYPE) == UNION_TYPE                               \\\n+        || TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY           32\n+\n+/* All accesses must be aligned.  */\n+#define STRICT_ALIGNMENT               1\n+\n+/* Score requires that structure alignment is affected by bitfields.  */\n+#define PCC_BITFIELD_TYPE_MATTERS      1\n+\n+/* long double is not a fixed mode, but the idea is that, if we\n+   support long double, we also want a 128-bit integer type.  */\n+#define MAX_FIXED_MODE_SIZE            LONG_DOUBLE_TYPE_SIZE\n+\n+#define TARGET_FLOAT_FORMAT            IEEE_FLOAT_FORMAT\n+\n+/* Layout of Data Type.  */\n+/* Set the sizes of the core types.  */\n+#define INT_TYPE_SIZE                   32\n+#define SHORT_TYPE_SIZE                 16\n+#define LONG_TYPE_SIZE                  32\n+#define LONG_LONG_TYPE_SIZE             64\n+#define CHAR_TYPE_SIZE                  8\n+#define FLOAT_TYPE_SIZE                 32\n+#define DOUBLE_TYPE_SIZE                64\n+#define LONG_DOUBLE_TYPE_SIZE           64\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#undef DEFAULT_SIGNED_CHAR\n+#define DEFAULT_SIGNED_CHAR             1\n+\n+/* Default definitions for size_t and ptrdiff_t.  */\n+#define SIZE_TYPE                       \"unsigned int\"\n+\n+/* Register Usage\n+\n+   S+core have:\n+   - 32 integer registers\n+   - 16 control registers (cond)\n+   - 16 special registers (ceh/cel/cnt/lcr/scr/arg/fp)\n+   - 32 coprocessors 1 registers\n+   - 32 coprocessors 2 registers\n+   - 32 coprocessors 3 registers.  */\n+#define FIRST_PSEUDO_REGISTER           160\n+\n+/* By default, fix the kernel registers (r30 and r31), the global\n+   pointer (r28) and the stack pointer (r0).  This can change\n+   depending on the command-line options.\n+\n+   Regarding coprocessor registers: without evidence to the contrary,\n+   it's best to assume that each coprocessor register has a unique\n+   use.  This can be overridden, in, e.g., override_options() or\n+   CONDITIONAL_REGISTER_USAGE should the assumption be inappropriate\n+   for a particular target.  */\n+\n+/* Control Registers, use mfcr/mtcr insn\n+    32        cr0         PSR\n+    33        cr1         Condition\n+    34        cr2         ECR\n+    35        cr3         EXCPVec\n+    36        cr4         CCR\n+    37        cr5         EPC\n+    38        cr6         EMA\n+    39        cr7         TLBLock\n+    40        cr8         TLBPT\n+    41        cr8         PEADDR\n+    42        cr10        TLBRPT\n+    43        cr11        PEVN\n+    44        cr12        PECTX\n+    45        cr13\n+    46        cr14\n+    47        cr15\n+\n+    Custom Engine Register, use mfce/mtce\n+    48        CEH        CEH\n+    49        CEL        CEL\n+\n+    Special-Purpose Register, use mfsr/mtsr\n+    50        sr0        CNT\n+    51        sr1        LCR\n+    52        sr2        SCR\n+\n+    53        ARG_POINTER_REGNUM\n+    54        FRAME_POINTER_REGNUM\n+    but Control register have 32 registers, cr16-cr31.  */\n+#define FIXED_REGISTERS                                  \\\n+{                                                        \\\n+  /* General Purpose Registers */                        \\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,        \\\n+  /* Control Regisers */                                 \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* CEH/ CEL/ CNT/ LCR/ SCR / ARG_POINTER_REGNUM/ FRAME_POINTER_REGNUM */\\\n+  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* CP 1 Registers  */                                  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* CP 2 Registers  */                                  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* CP 3 Registers*/                                    \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+}\n+\n+#define CALL_USED_REGISTERS                              \\\n+{                                                        \\\n+  /* General purpose register */                         \\\n+  1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,        \\\n+  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* Control Regisers */                                 \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* CP 1 Registers  */                                  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* CP 2 Registers  */                                  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  /* CP 3 Registers  */                                  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n+}\n+\n+#define REG_ALLOC_ORDER                                                   \\\n+{   0,  1,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,        \\\n+   18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,  2,  3,        \\\n+   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,        \\\n+   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,        \\\n+   64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,        \\\n+   80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,        \\\n+   96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,        \\\n+  112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,        \\\n+  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,        \\\n+  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159        }\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Return true if REGNO is suitable for holding a quantity of type MODE.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) score_hard_regno_mode_ok (REGNO, MODE)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)                             \\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT                          \\\n+    || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)              \\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT                       \\\n+       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\n+/* Register Classes.  */\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.  */\n+enum reg_class\n+{\n+  NO_REGS,\n+  G16_REGS,    /* r0 ~ r15 */\n+  G32_REGS,    /* r0 ~ r31 */\n+  T32_REGS,    /* r8 ~ r11 | r22 ~ r27 */\n+\n+  HI_REG,      /* hi                 */\n+  LO_REG,      /* lo                 */\n+  CE_REGS,     /* hi + lo            */\n+\n+  CN_REG,      /* cnt                */\n+  LC_REG,      /* lcb                */\n+  SC_REG,      /* scb                */\n+  SP_REGS,     /* cnt + lcb + scb    */\n+\n+  CR_REGS,     /* cr0 - cr15         */\n+\n+  CP1_REGS,    /* cp1                */\n+  CP2_REGS,    /* cp2                */\n+  CP3_REGS,    /* cp3                */\n+  CPA_REGS,    /* cp1 + cp2 + cp3    */\n+\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES                  ((int) LIM_REG_CLASSES)\n+\n+#define GENERAL_REGS                   G32_REGS\n+\n+/* Give names of register classes as strings for dump file.  */\n+#define REG_CLASS_NAMES           \\\n+{                                 \\\n+  \"NO_REGS\",                      \\\n+  \"G16_REGS\",                     \\\n+  \"G32_REGS\",                     \\\n+  \"T32_REGS\",                     \\\n+                                  \\\n+  \"HI_REG\",                       \\\n+  \"LO_REG\",                       \\\n+  \"CE_REGS\",                      \\\n+                                  \\\n+  \"CN_REG\",                       \\\n+  \"LC_REG\",                       \\\n+  \"SC_REG\",                       \\\n+  \"SP_REGS\",                      \\\n+                                  \\\n+  \"CR_REGS\",                      \\\n+                                  \\\n+  \"CP1_REGS\",                     \\\n+  \"CP2_REGS\",                     \\\n+  \"CP3_REGS\",                     \\\n+  \"CPA_REGS\",                     \\\n+                                  \\\n+  \"ALL_REGS\",                     \\\n+}\n+\n+/* Define which registers fit in which classes.  */\n+#define REG_CLASS_CONTENTS                                        \\\n+{                                                                 \\\n+  /* NO_REGS/G16/G32/T32  */                                      \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x0000ffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x0fc00f00, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  /* HI/LO/CE  */                                                 \\\n+  { 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x00000000, 0x00020000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x00000000, 0x00030000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  /* CN/LC/SC/SP/CR  */                                           \\\n+  { 0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x00000000, 0x00080000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x00000000, 0x00100000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x00000000, 0x001c0000, 0x00000000, 0x00000000, 0x00000000},  \\\n+  { 0x00000000, 0x0000ffff, 0x00000000, 0x00000000, 0x00000000},  \\\n+  /* CP1/CP2/CP3/CPA  */                                          \\\n+  { 0x00000000, 0x00000000, 0xffffffff, 0x00000000, 0x00000000},  \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0x00000000},  \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff},  \\\n+  { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff},  \\\n+  /* ALL_REGS        */                                           \\\n+  { 0xffffffff, 0x001fffff, 0xffffffff, 0xffffffff, 0xffffffff},  \\\n+}\n+\n+/* A C expression whose value is a register class containing hard\n+   register REGNO.  In general there is more that one such class;\n+   choose a class which is \"minimal\", meaning that no smaller class\n+   also contains the register.  */\n+#define REGNO_REG_CLASS(REGNO)         score_reg_class (REGNO)\n+\n+/* A macro whose definition is the name of the class to which a\n+   valid base register must belong.  A base register is one used in\n+   an address which is the register value plus a displacement.  */\n+#define BASE_REG_CLASS                 G16_REGS\n+\n+/* The class value for index registers.  */\n+#define INDEX_REG_CLASS                NO_REGS\n+\n+#define REG_CLASS_FROM_LETTER(C)       score_char_to_class[(unsigned char) (C)]\n+\n+/* Addressing modes, and classification of registers for them.  */\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) \\\n+  score_regno_mode_ok_for_base_p (REGNO, 1)\n+\n+#define REGNO_OK_FOR_INDEX_P(NUM)       0\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n+  score_preferred_reload_class (X, CLASS)\n+\n+/* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)        \\\n+  score_secondary_reload_class (CLASS, MODE, X)\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)       \\\n+  score_secondary_reload_class (CLASS, MODE, X)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)    \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)    \\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)        \\\n+   ? reg_classes_intersect_p (HI_REG, (CLASS)) : 0)\n+\n+/* The letters I, J, K, L, M, N, O, and P in a register constraint\n+   string can be used to stand for particular ranges of immediate\n+   operands.  This macro defines what the ranges are.  C is the\n+   letter, and VALUE is a constant value.  Return 1 if VALUE is\n+   in the range specified by C.  */\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) score_const_ok_for_letter_p (VALUE, C)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)        \\\n+  ((C) == 'G' && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\n+\n+/* Letters in the range `Q' through `U' may be defined in a\n+   machine-dependent fashion to stand for arbitrary operand types.\n+   The machine description macro `EXTRA_CONSTRAINT' is passed the\n+   operand as its first argument and the constraint letter as its\n+   second operand.  */\n+#define EXTRA_CONSTRAINT(VALUE, C)      score_extra_constraint (VALUE, C)\n+\n+/* Basic Stack Layout.  */\n+/* Stack layout; function entry, exit and calling.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+#define STACK_PUSH_CODE                 PRE_DEC\n+#define STACK_POP_CODE                  POST_INC\n+\n+/* The offset of the first local variable from the beginning of the frame.\n+   See compute_frame_size for details about the frame layout.  */\n+#define STARTING_FRAME_OFFSET           current_function_outgoing_args_size\n+\n+/* The argument pointer always points to the first argument.  */\n+#define FIRST_PARM_OFFSET(FUNDECL)      0\n+\n+/* A C expression whose value is RTL representing the value of the return\n+   address for the frame COUNT steps up from the current frame.  */\n+#define RETURN_ADDR_RTX(count, frame)   score_return_addr (count, frame)\n+\n+/* Pick up the return address upon entry to a procedure.  */\n+#define INCOMING_RETURN_ADDR_RTX        gen_rtx_REG (VOIDmode, RA_REGNUM)\n+\n+/* Exception handling Support.  */\n+/* Use r0 to r3 to pass exception handling information.  */\n+#define EH_RETURN_DATA_REGNO(N) \\\n+  ((N) < 4 ? (N) + ARG_REG_FIRST : INVALID_REGNUM)\n+\n+/* The register that holds the return address in exception handlers.  */\n+#define EH_RETURN_STACKADJ_RTX          gen_rtx_REG (Pmode, EH_REGNUM)\n+\n+/* Registers That Address the Stack Frame.  */\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM            SP_REGNUM\n+\n+/* These two registers don't really exist: they get eliminated to either\n+   the stack or hard frame pointer.  */\n+#define FRAME_POINTER_REGNUM            53\n+\n+/*  we use r2 as the frame pointer.  */\n+#define HARD_FRAME_POINTER_REGNUM       FP_REGNUM\n+\n+#define ARG_POINTER_REGNUM              54\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM             23\n+\n+/* Elimination Frame Pointer and Arg Pointer  */\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED          current_function_calls_alloca\n+\n+#define ELIMINABLE_REGS                                \\\n+  {{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},        \\\n+   { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},   \\\n+   { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},      \\\n+   { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+/* We can always eliminate to the hard frame pointer.  We can eliminate\n+   to the stack pointer unless a frame pointer is needed.  */\n+#define CAN_ELIMINATE(FROM, TO)        \\\n+  (((TO) == HARD_FRAME_POINTER_REGNUM) \\\n+   || ((TO) == STACK_POINTER_REGNUM    \\\n+       && !frame_pointer_needed))\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  (OFFSET) = score_initial_elimination_offset ((FROM), (TO))\n+\n+/* Passing Function Arguments on the Stack.  */\n+/* Allocate stack space for arguments at the beginning of each function.  */\n+#define ACCUMULATE_OUTGOING_ARGS        1\n+\n+/* reserve stack space for all argument registers.  */\n+#define REG_PARM_STACK_SPACE(FNDECL)    UNITS_PER_WORD\n+\n+/* Define this if it is the responsibility of the caller to\n+   allocate the area reserved for arguments passed in registers.\n+   If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect\n+   of this macro is to determine whether the space is included in\n+   `current_function_outgoing_args_size'.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n+\n+/* Passing Arguments in Registers  */\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  score_function_arg (&CUM, MODE, TYPE, NAMED)\n+\n+/* A C type for declaring a variable that is used as the first argument of\n+   `FUNCTION_ARG' and other related values.  For some target machines, the\n+   type `int' suffices and can hold the number of bytes of argument so far.  */\n+typedef struct score_args\n+{\n+  unsigned int arg_number;             /* how many arguments have been seen  */\n+  unsigned int num_gprs;               /* number of gprs in use  */\n+  unsigned int stack_words;            /* number of words in stack  */\n+} score_args_t;\n+\n+#define CUMULATIVE_ARGS                score_args_t\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, n_named_args) \\\n+  score_init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+  score_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   We have no FP argument registers when soft-float.  When FP registers\n+   are 32 bits, we can't directly reference the odd numbered ones.  */\n+#define FUNCTION_ARG_REGNO_P(REGNO) \\\n+  REG_CONTAIN (REGNO, ARG_REG_FIRST, ARG_REG_NUM)\n+\n+/* How Scalar Function Values Are Returned.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  score_function_value ((VALTYPE), (FUNC), VOIDmode)\n+\n+#define LIBCALL_VALUE(MODE)  score_function_value (NULL_TREE, NULL, (MODE))\n+\n+/* 1 if N is a possible register number for a function value.  */\n+#define FUNCTION_VALUE_REGNO_P(REGNO)   ((REGNO) == (ARG_REG_FIRST))\n+\n+#define PIC_FUNCTION_ADDR_REGNUM        (GP_REG_FIRST + 25)\n+\n+/* How Large Values Are Returned.  */\n+#define STRUCT_VALUE                    0\n+\n+/* Function Entry and Exit  */\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+#define EXIT_IGNORE_STACK               1\n+\n+/* Generating Code for Profiling  */\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO)                           \\\n+{                                                                  \\\n+  fprintf (FILE, \" .set r1  \\n\");                                  \\\n+  fprintf (FILE, \" mv   r%d,r%d \\n\", AT_REGNUM, RA_REGNUM);        \\\n+  fprintf (FILE, \" subi r%d, %d \\n\", STACK_POINTER_REGNUM, 8);     \\\n+  fprintf (FILE, \" jl   _mcount \\n\");                              \\\n+  fprintf (FILE, \" .set nor1 \\n\");                                 \\\n+}\n+\n+/* Trampolines for Nested Functions.  */\n+#define TRAMPOLINE_INSNS                8\n+\n+/* A C expression for the size in bytes of the trampoline, as an integer.  */\n+#define TRAMPOLINE_SIZE \\\n+  (TRAMPOLINE_INSNS * GET_MODE_SIZE (SImode) + GET_MODE_SIZE (ptr_mode) * 2)\n+\n+/* A C statement to initialize the variable parts of a trampoline.\n+   ADDR is an RTX for the address of the trampoline; FNADDR is an\n+   RTX for the address of the nested function; STATIC_CHAIN is an\n+   RTX for the static chain value that should be passed to the\n+   function when it is called.  */\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN) \\\n+  score_initialize_trampoline (ADDR, FUNC, CHAIN)\n+\n+#define HAVE_PRE_INCREMENT              1\n+#define HAVE_PRE_DECREMENT              1\n+#define HAVE_POST_INCREMENT             1\n+#define HAVE_POST_DECREMENT             1\n+#define HAVE_PRE_MODIFY_DISP            0\n+#define HAVE_POST_MODIFY_DISP           0\n+#define HAVE_PRE_MODIFY_REG             0\n+#define HAVE_POST_MODIFY_REG            0\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X)           CONSTANT_P (X)\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS            1\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)   \\\n+  if (score_address_p (MODE, X, 1))                \\\n+    goto LABEL;\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)   \\\n+  if (score_address_p (MODE, X, 0))                \\\n+    goto LABEL;\n+#endif\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects them all.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Some source files that are used after register allocation\n+   need to be strict.  */\n+#ifndef REG_OK_STRICT\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  score_regno_mode_ok_for_base_p (REGNO (X), 0)\n+#else\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  score_regno_mode_ok_for_base_p (REGNO (X), 1)\n+#endif\n+\n+#define REG_OK_FOR_INDEX_P(X) 0\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)   \\\n+  do {                                           \\\n+    if (score_legitimize_address (&(X)))         \\\n+      goto WIN;                                  \\\n+  } while (0)\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)       {}\n+\n+#define LEGITIMATE_CONSTANT_P(X)        1\n+\n+/* Describing Relative Costs of Operations  */\n+/* Compute extra cost of moving data between one register class and another.  */\n+#define REGISTER_MOVE_COST(MODE, FROM, TO) \\\n+  score_register_move_cost (MODE, FROM, TO)\n+\n+/* Moves to and from memory are quite expensive */\n+#define MEMORY_MOVE_COST(MODE, CLASS, TO_P) \\\n+  (4 + memory_move_secondary_cost ((MODE), (CLASS), (TO_P)))\n+\n+/* Try to generate sequences that don't involve branches.  */\n+#define BRANCH_COST                     2\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS                1\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.  */\n+#define NO_FUNCTION_CSE                 1\n+\n+/* Dividing the Output into Sections (Texts, Data, ...).  */\n+/* Define the strings to put out for each section in the object file.  */\n+#define TEXT_SECTION_ASM_OP             \"\\t.text\"\n+#define DATA_SECTION_ASM_OP             \"\\t.data\"\n+#define SDATA_SECTION_ASM_OP            \"\\t.sdata\"\n+\n+#undef  READONLY_DATA_SECTION_ASM_OP\n+#define READONLY_DATA_SECTION_ASM_OP    \"\\t.rdata\"\n+\n+/* The Overall Framework of an Assembler File  */\n+/* How to start an assembler comment.\n+   The leading space is important.  */\n+#define ASM_COMMENT_START               \"#\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+#define ASM_APP_ON                     \"#APP\\n\\t.set volatile\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+#define ASM_APP_OFF                     \"#NO_APP\\n\\t.set optimize\\n\"\n+\n+/* Output of Uninitialized Variables.  */\n+/* This says how to define a global common symbol.  */\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGN)     \\\n+  score_declare_object (STREAM, NAME, \"\\n\\t.comm\\t\",                        \\\n+                        \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",             \\\n+                        SIZE, ALIGN / BITS_PER_UNIT);\n+\n+/* This says how to define a local common symbol (i.e., not visible to\n+   linker).  */\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)            \\\n+  score_declare_object (STREAM, NAME, \"\\n\\t.lcomm\\t\",                  \\\n+                        \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",        \\\n+                        SIZE, ALIGN / BITS_PER_UNIT);\n+\n+/* Globalizing directive for a label.  */\n+#define GLOBAL_ASM_OP                   \"\\t.globl\\t\"\n+\n+/* Output and Generation of Labels  */\n+/* This is how to declare a function name.  The actual work of\n+   emitting the label is moved to function_prologue, so that we can\n+   get the line number correctly emitted before the .ent directive,\n+   and after any .file directives.  Define as empty so that the function\n+   is not declared before the .ent directive elsewhere.  */\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\n+\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \\\n+  score_declare_object (STREAM, NAME, \"\", \":\\n\", 0)\n+\n+/* This says how to output an external.  It would be possible not to\n+   output anything and let undefined symbol become external. However\n+   the assembler uses length information on externals to allocate in\n+   data/sdata bss/sbss, thereby saving exec time.  */\n+#define ASM_OUTPUT_EXTERNAL(STREAM, DECL, NAME) \\\n+  score_output_external (STREAM, DECL, NAME)\n+\n+/* This handles the magic '..CURRENT_FUNCTION' symbol, which means\n+   'the start of the function that this code is output in'.  */\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+  fprintf ((STREAM), \"%s\", (NAME))\n+\n+/* Local compiler-generated symbols must have a prefix that the assembler\n+   understands.  */\n+#define LOCAL_LABEL_PREFIX              \".\"\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM) \\\n+  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))\n+\n+/* Output of Assembler Instructions.  */\n+#define REGISTER_NAMES                                                   \\\n+{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",                        \\\n+  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",                  \\\n+  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",                \\\n+  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",                \\\n+                                                                         \\\n+  \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\",                \\\n+  \"cr8\", \"cr9\", \"cr10\", \"cr11\", \"cr12\", \"cr13\", \"cr14\", \"cr15\",          \\\n+                                                                         \\\n+  \"ceh\", \"cel\", \"sr0\", \"sr1\", \"sr2\", \"_arg\", \"_frame\", \"\",               \\\n+  \"cr24\", \"cr25\", \"cr26\", \"cr27\", \"cr28\", \"cr29\", \"cr30\", \"cr31\",        \\\n+                                                                         \\\n+  \"c1r0\", \"c1r1\", \"c1r2\", \"c1r3\", \"c1r4\", \"c1r5\", \"c1r6\", \"c1r7\",        \\\n+  \"c1r8\", \"c1r9\", \"c1r10\", \"c1r11\", \"c1r12\", \"c1r13\", \"c1r14\", \"c1r15\",  \\\n+  \"c1r16\", \"c1r17\", \"c1r18\", \"c1r19\", \"c1r20\", \"c1r21\", \"c1r22\", \"c1r23\",\\\n+  \"c1r24\", \"c1r25\", \"c1r26\", \"c1r27\", \"c1r28\", \"c1r29\", \"c1r30\", \"c1r31\",\\\n+                                                                         \\\n+  \"c2r0\", \"c2r1\", \"c2r2\", \"c2r3\", \"c2r4\", \"c2r5\", \"c2r6\", \"c2r7\",        \\\n+  \"c2r8\", \"c2r9\", \"c2r10\", \"c2r11\", \"c2r12\", \"c2r13\", \"c2r14\", \"c2r15\",  \\\n+  \"c2r16\", \"c2r17\", \"c2r18\", \"c2r19\", \"c2r20\", \"c2r21\", \"c2r22\", \"c2r23\",\\\n+  \"c2r24\", \"c2r25\", \"c2r26\", \"c2r27\", \"c2r28\", \"c2r29\", \"c2r30\", \"c2r31\",\\\n+                                                                         \\\n+  \"c3r0\", \"c3r1\", \"c3r2\", \"c3r3\", \"c3r4\", \"c3r5\", \"c3r6\", \"c3r7\",        \\\n+  \"c3r8\", \"c3r9\", \"c3r10\", \"c3r11\", \"c3r12\", \"c3r13\", \"c3r14\", \"c3r15\",  \\\n+  \"c3r16\", \"c3r17\", \"c3r18\", \"c3r19\", \"c3r20\", \"c3r21\", \"c3r22\", \"c3r23\",\\\n+  \"c3r24\", \"c3r25\", \"c3r26\", \"c3r27\", \"c3r28\", \"c3r29\", \"c3r30\", \"c3r31\",\\\n+}\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.  */\n+#define PRINT_OPERAND(STREAM, X, CODE)  score_print_operand (STREAM, X, CODE)\n+\n+/* A C expression which evaluates to true if CODE is a valid\n+   punctuation character for use in the `PRINT_OPERAND' macro.  */\n+#define PRINT_OPERAND_PUNCT_VALID_P(C)  ((C) == '[' || (C) == ']')\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+#define PRINT_OPERAND_ADDRESS(STREAM, X) \\\n+  score_print_operand_address (STREAM, X)\n+\n+/* By default on the S+core, external symbols do not have an underscore\n+   prepended.  */\n+#define USER_LABEL_PREFIX        \"\"\n+\n+/* This is how to output an insn to push a register on the stack.  */\n+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)       \\\n+  do {                                           \\\n+    fprintf (STREAM, \"\\tpush! %s,[%s]\\n\",        \\\n+             reg_names[REGNO],                   \\\n+             reg_names[STACK_POINTER_REGNUM]);   \\\n+  } while (0)\n+\n+/* This is how to output an insn to pop a register from the stack.  */\n+#define ASM_OUTPUT_REG_POP(STREAM, REGNO)        \\\n+  do {                                           \\\n+    fprintf (STREAM, \"\\tpop! %s,[%s]\\n\",         \\\n+             reg_names[REGNO],                   \\\n+             reg_names[STACK_POINTER_REGNUM]);   \\\n+  } while (0)\n+\n+/* Output of Dispatch Tables.  */\n+/* This is how to output an element of a case-vector.  We can make the\n+   entries PC-relative in GP-relative when .gp(d)word is supported.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)              \\\n+  do {                                                                  \\\n+    if (flag_pic)                                                       \\\n+      fprintf (STREAM, \"\\t.gpword %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE); \\\n+    else                                                                \\\n+      fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);   \\\n+  } while (0)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n+  fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE)\n+\n+/* Assembler Commands for Exception Regions  */\n+/* Since the S+core is encoded in the least-significant bit\n+   of the address, mask it off return addresses for purposes of\n+   finding exception handling regions.  */\n+#define MASK_RETURN_ADDR               constm1_rtx\n+\n+/* Assembler Commands for Alignment  */\n+/* This is how to output an assembler line to advance the location\n+   counter by SIZE bytes.  */\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(STREAM, SIZE) \\\n+  fprintf (STREAM, \"\\t.space\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (SIZE))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(STREAM, LOG) \\\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\", (LOG))\n+\n+/* Macros Affecting All Debugging Formats.  */\n+#ifndef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE         DWARF2_DEBUG\n+#endif\n+\n+/* Specific Options for DBX Output.  */\n+#define DBX_DEBUGGING_INFO              1\n+\n+/* By default, turn on GDB extensions.  */\n+#define DEFAULT_GDB_EXTENSIONS          1\n+\n+#define DBX_CONTIN_LENGTH               0\n+\n+/* File Names in DBX Format.  */\n+#define DWARF2_DEBUGGING_INFO           1\n+\n+/* The DWARF 2 CFA column which tracks the return address.  */\n+#define DWARF_FRAME_RETURN_COLUMN       3\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE                SImode\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/*  All references are zero extended.  */\n+#define LOAD_EXTEND_OP(MODE)            ZERO_EXTEND\n+\n+/* Define if loading short immediate values into registers sign extends.  */\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX                        4\n+\n+/* Define this to be nonzero if shift instructions ignore all but the low-order\n+   few bits.  */\n+#define SHIFT_COUNT_TRUNCATED           1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode                           SImode\n+\n+/* Give call MEMs SImode since it is the \"most permissive\" mode\n+   for 32-bit targets.  */\n+#define FUNCTION_MODE                   Pmode\n+\n+struct extern_list GTY ((chain_next (\"%h.next\")))\n+{\n+  struct extern_list *next;             /* next external  */\n+  const char *name;                     /* name of the external  */\n+  int size;                             /* size in bytes  */\n+};\n+\n+extern GTY (()) struct extern_list      *extern_head ;"}, {"sha": "bc3d99f712695b46c54f69f59ed9164dd44c98b1", "filename": "gcc/config/score/score.md", "status": "added", "additions": 1253, "deletions": 0, "changes": 1253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.md?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,1253 @@\n+;;  Machine description for Sunplus S+CORE\n+;;  Copyright (C) 2005\n+;;  Free Software Foundation, Inc.\n+;;  Contributed by Sunnorth.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+; branch        conditional branch\n+; jump          unconditional jump\n+; call          unconditional call\n+; load          load instruction(s)\n+; store         store instruction(s)\n+; cmp           integer compare\n+; arith         integer arithmetic instruction\n+; move          data movement within same register set\n+; const         load constant\n+; nop           no operation\n+; mul           integer multiply\n+; div           integer divide\n+; cndmv         conditional moves\n+; fce           transfer from hi/lo registers\n+; tce           transfer to   hi/lo registers\n+; fsr           transfer from special registers\n+; tsr           transfer to   special registers\n+; pseudo        pseudo instruction\n+\n+(define_constants\n+  [(CC_REGNUM       33)\n+   (T_REGNUM        34)\n+   (RA_REGNUM       3)\n+   (SP_REGNUM       0)\n+   (AT_REGNUM       1)\n+   (FP_REGNUM       2)\n+   (RT_REGNUM       4)\n+   (GP_REGNUM       28)\n+   (EH_REGNUM       29)\n+   (HI_REGNUM       48)\n+   (LO_REGNUM       49)\n+   (CN_REGNUM       50)\n+   (LC_REGNUM       51)\n+   (SC_REGNUM       52)])\n+\n+(define_constants\n+   [(BITTST         0)\n+    (LOAD_ADD       1)\n+    (STORE_ADD      2)\n+\n+    (SCB            3)\n+    (SCW            4)\n+    (SCE            5)\n+    (SCLC           6)\n+\n+    (LCB            7)\n+    (LCW            8)\n+    (LCE            9)\n+\n+    (SFFS           10)])\n+\n+(define_attr \"type\"\n+  \"unknown,branch,jump,call,load,store,cmp,arith,move,const,nop,mul,div,cndmv,fce,tce,fsr,tsr,fcr,tcr,pseudo\"\n+  (const_string \"unknown\"))\n+\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI\"\n+  (const_string \"unknown\"))\n+\n+(define_attr \"up_c\" \"yes,no\"\n+  (const_string \"no\"))\n+\n+(include \"score7.md\")\n+(include \"predicates.md\")\n+(include \"misc.md\")\n+(include \"mac.md\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a\")\n+        (match_operand:QI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d\"))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return mdp_limm (operands);\n+    case 1: return mdp_move (operands);\n+    case 2: return mdp_linsn (operands, MDA_BYTE, false);\n+    case 3: return mdp_sinsn (operands, MDA_BYTE);\n+    case 4: return TARGET_MAC ? \\\"mf%1%S0 %0\\\" : \\\"mf%1    %0\\\";\n+    case 5: return TARGET_MAC ? \\\"mt%0%S1 %1\\\" : \\\"mt%0    %1\\\";\n+    case 6: return \\\"mfsr    %0, %1\\\";\n+    case 7: return \\\"mtsr    %1, %0\\\";\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a\")\n+        (match_operand:HI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d\"))]\n+  \"\"\n+{\n+  switch(which_alternative)\n+    {\n+    case 0: return mdp_limm (operands);\n+    case 1: return mdp_move (operands);\n+    case 2: return mdp_linsn (operands, MDA_HWORD, false);\n+    case 3: return mdp_sinsn (operands, MDA_HWORD);\n+    case 4: return TARGET_MAC ? \\\"mf%1%S0 %0\\\" : \\\"mf%1    %0\\\";\n+    case 5: return TARGET_MAC ? \\\"mt%0%S1 %1\\\" : \\\"mt%0    %1\\\";\n+    case 6: return \\\"mfsr    %0, %1\\\";\n+    case 7: return \\\"mtsr    %1, %0\\\";\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a,d,c\")\n+        (match_operand:SI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d,c,d\"))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (GET_CODE (operands[1]) != CONST_INT)\n+        return \\\"la      %0, %1\\\";\n+      else\n+        return mdp_limm (operands);\n+    case 1: return mdp_move (operands);\n+    case 2: return mdp_linsn (operands, MDA_WORD, false);\n+    case 3: return mdp_sinsn (operands, MDA_WORD);\n+    case 4: return TARGET_MAC ? \\\"mf%1%S0 %0\\\" : \\\"mf%1    %0\\\";\n+    case 5: return TARGET_MAC ? \\\"mt%0%S1 %1\\\" : \\\"mt%0    %1\\\";\n+    case 6: return \\\"mfsr    %0, %1\\\";\n+    case 7: return \\\"mtsr    %1, %0\\\";\n+    case 8: return \\\"mfcr    %0, %1\\\";\n+    case 9: return \\\"mtcr    %1, %0\\\";\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr,fcr,tcr\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x\")\n+        (match_operand:DI 1 \"general_operand\" \"i,d,m,d,*x,d\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  mds_movdi (operands);\n+  DONE;\n+})\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0,d,%d\")\n+                 (match_operand:SI 2 \"arith_operand\" \"L,N,d\")))]\n+  \"\"\n+  \"@\n+   addi    %0, %c2\n+   addri   %0, %1, %c2\n+   add     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*addsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (plus:SI (match_operand:SI 0 \"register_operand\" \"d,d,d\")\n+                                (match_operand:SI 1 \"arith_operand\" \"N,L,d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"@\n+   %[       addri.c r1, %0, %c1       %]\n+   %[       m%V0    r1, %0\\;addi.c  r1, %2        %]\n+   %[       add.c   r1, %0, %1        %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"addsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (plus:SI (match_operand:SI 1 \"register_operand\" \"0,d,d\")\n+                                (match_operand:SI 2 \"arith_operand\" \"L,N,d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+        (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return mdp_add_imm_ucc (operands);\n+    case 1: return \\\"addri.c %0, %1, %c2\\\";\n+    case 2: return mdp_select (operands, \"add\", true, \"\");\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=*e,d\")\n+        (plus:DI (match_operand:DI 1 \"register_operand\" \"*0,d\")\n+                 (match_operand:DI 2 \"register_operand\" \"*e,d\")))\n+  (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   add!    %L0, %L2\\;addc!   %H0, %H2\n+   add.c   %L0, %L1, %L2\\;addc    %H0, %H1, %H2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                  (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"sub     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*subsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (minus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+                                 (match_operand:SI 1 \"register_operand\" \"d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"%[        sub.c   r1, %0, %1        %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n+        (minus:SI (match_operand:SI 1 \"g32reg_operand\" \"\")\n+                  (match_operand:SI 2 \"g32reg_operand\" \"\")))\n+   (set (reg:CC CC_REGNUM)\n+        (compare:CC (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  [(parallel\n+       [(set (reg:CC CC_REGNUM)\n+             (compare:CC (match_dup 1) (match_dup 2)))\n+        (set (match_dup 0)\n+             (minus:SI (match_dup 1) (match_dup 2)))])])\n+\n+(define_insn \"subsi3_ucc_pcmp\"\n+  [(parallel\n+       [(set (reg:CC CC_REGNUM)\n+             (compare:CC (match_operand:SI 1 \"register_operand\" \"d\")\n+                         (match_operand:SI 2 \"register_operand\" \"d\")))\n+        (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+             (minus:SI (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+{\n+  return mdp_select (operands, \"sub\", false, \"\");\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"subsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                 (match_operand:SI 2 \"register_operand\" \"d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (minus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  return mdp_select (operands, \"sub\", false, \"\");\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=*e,d\")\n+        (minus:DI (match_operand:DI 1 \"register_operand\" \"*0,d\")\n+                  (match_operand:DI 2 \"register_operand\" \"*e,d\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   sub!    %L0, %L2\\;subc    %H0, %H1, %H2\n+   sub.c   %L0, %L1, %L2\\;subc    %H0, %H1, %H2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+        (and:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                (match_operand:SI 2 \"arith_operand\" \"K,Q,M,d\")))]\n+  \"\"\n+  \"@\n+   andi    %0, %c2\n+   andis   %0, %U2\n+   andri   %0, %1, %c2\n+   and     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"andsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (and:SI (match_operand:SI 0 \"register_operand\" \"d,d,d,d\")\n+                               (match_operand:SI 1 \"arith_operand\" \"M,K,Q,d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"@\n+   %[        andri.c r1, %0, %c1      %]\n+   %[        m%V0    r1, %0\\;andi.c  r1, %c1        %]\n+   %[        m%V0    r1, %0\\;andis.c r1, %U1        %]\n+   %[        and.c   r1, %0, %1       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"andsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (and:SI\n+                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"K,Q,M,d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+        (and:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:  return \\\"andi.c  %0, %c2\\\";\n+    case 1:  return \\\"andis.c %0, %U2\\\";\n+    case 2:  return \\\"andri.c %0, %1, %c2\\\";\n+    case 3:  return mdp_select (operands, \"and\", true, \"\");\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*zero_extract_andi\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (zero_extract:SI\n+                        (match_operand:SI 0 \"register_operand\" \"d\")\n+                        (match_operand:SI 1 \"const_bi_operand\" \"\")\n+                        (match_operand:SI 2 \"const_bi_operand\" \"\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(const_int 1)]\n+{\n+  mds_zero_extract_andi (operands);\n+  DONE;\n+})\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+        (ior:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                (match_operand:SI 2 \"arith_operand\" \"K,Q,M,d\")))]\n+  \"\"\n+  \"@\n+   ori     %0, %c2\n+   oris    %0, %U2\n+   orri    %0, %1, %c2\n+   or      %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"iorsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (ior:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                               (match_operand:SI 2 \"register_operand\" \"d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (ior:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  return mdp_select (operands, \"or\", true, \"\");\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"iorsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (ior:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+                               (match_operand:SI 1 \"register_operand\" \"d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"%[        or.c    r1, %0, %1       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"xor     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"xorsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (xor:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                               (match_operand:SI 2 \"register_operand\" \"d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (xor:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  return mdp_select (operands, \"xor\", true, \"\");\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"xorsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (xor:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+                               (match_operand:SI 1 \"register_operand\" \"d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"%[        xor.c   r1, %0, %1       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"d,m\")))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"extsb   %0, %1\\\";\n+    case 1: return mdp_linsn (operands, MDA_BYTE, true);\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"extendqisi2_cmp\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (ashiftrt:SI\n+                       (ashift:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+                                  (const_int 24))\n+                       (const_int 24))\n+                      (const_int 0)))]\n+  \"\"\n+  \"%[        extsb.c r1, %0       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"extendqisi2_ucc\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (ashiftrt:SI\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                  (const_int 24))\n+                       (const_int 24))\n+                      (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (sign_extend:SI (match_operand:QI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extsb.c %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"\"=d,d\")\n+        (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"d,m\")))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"extzb   %0, %1\\\";\n+    case 1: return mdp_linsn (operands, MDA_BYTE, false);\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith, load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,m\")))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"extsh   %0, %1\\\";\n+    case 1: return mdp_linsn (operands, MDA_HWORD, true);\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith, load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"extendhisi2_cmp\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (ashiftrt:SI\n+                       (ashift:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+                                  (const_int 16))\n+                       (const_int 16))\n+                      (const_int 0)))]\n+  \"\"\n+  \"%[        extsh.c r1, %0       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"extendhisi2_ucc\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (ashiftrt:SI\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                  (const_int 16))\n+                       (const_int 16))\n+                      (const_int 0)))\n+  (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+       (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extsh.c %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,m\")))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"extzh   %0, %1\\\";\n+    case 1: return mdp_linsn (operands, MDA_HWORD, false);\n+    default: gcc_unreachable ();\n+    }\n+  }\n+  [(set_attr \"type\" \"arith, load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+        (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                 (match_operand:SI 2 \"register_operand\" \"d\")))\n+  (clobber (reg:SI HI_REGNUM))]\n+  \"!TARGET_SCORE5U\"\n+  \"mul     %1, %2\"\n+  [(set_attr \"type\" \"mul\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+        (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+                 (sign_extend:DI\n+                  (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"!TARGET_SCORE5U\"\n+  \"mul     %1, %2\"\n+  [(set_attr \"type\" \"mul\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+                 (zero_extend:DI\n+                  (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"!TARGET_SCORE5U\"\n+  \"mulu    %1, %2\"\n+  [(set_attr \"type\" \"mul\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"divmodsi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+        (div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=h\")\n+        (mod:SI (match_dup 1) (match_dup 2)))]\n+  \"!TARGET_SCORE5U\"\n+  \"div     %1, %2\"\n+  [(set_attr \"type\" \"div\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"udivmodsi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+        (udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                 (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=h\")\n+        (umod:SI (match_dup 1) (match_dup 2)))]\n+  \"!TARGET_SCORE5U\"\n+  \"divu    %1, %2\"\n+  [(set_attr \"type\" \"div\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (ashift:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                   (match_operand:SI 2 \"arith_operand\" \"J,d\")))]\n+  \"\"\n+  \"@\n+   slli    %0, %1, %c2\n+   sll     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashlsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (ashift:SI\n+                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (ashift:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return mdp_select (operands, \"slli\", false, \"c\");\n+    case 1: return mdp_select (operands, \"sll\", false, \"\");\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashlsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (ashift:SI\n+                        (match_operand:SI 0 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"@\n+   %[        slli.c  r1, %0, %c1      %]\n+   %[        sll.c   r1, %0, %1       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                     (match_operand:SI 2 \"arith_operand\" \"J,d\")))]\n+  \"\"\n+  \"@\n+   srai    %0, %1, %c2\n+   sra     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashrsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (ashiftrt:SI\n+                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (ashiftrt:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"srai.c  %0, %1, %c2\\\";\n+    case 1: return mdp_select (operands, \"sra\", false, \"\");\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashrsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (ashiftrt:SI\n+                        (match_operand:SI 0 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"@\n+   %[        srai.c  r1, %0, %c1      %]\n+   %[        sra.c   r1, %0, %1       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashrsi3_ucc_n\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (ashiftrt:SI\n+                       (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                       (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n+                      (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (ashiftrt:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"srai.c  %0, %1, %c2\\\";\n+    case 1: return mdp_select (operands, \"sra\", false, \"\");\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashrsi3_cmp_n\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (ashiftrt:SI\n+                       (match_operand:SI 0 \"register_operand\" \"d,d\")\n+                       (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n+                      (const_int 0)))]\n+  \"\"\n+  \"@\n+   %[        srai.c  r1, %0, %c1      %]\n+   %[        sra.c   r1, %0, %1       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                     (match_operand:SI 2 \"arith_operand\" \"J,d\")))]\n+  \"\"\n+  \"@\n+   srli    %0, %1, %c2\n+   srl     %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"lshrsi3_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (lshiftrt:SI\n+                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (lshiftrt:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return mdp_select (operands, \"srli\", false, \"c\");\n+    case 1: return mdp_select (operands, \"srl\", false, \"\");\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"lshrsi3_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (lshiftrt:SI\n+                        (match_operand:SI 0 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"@\n+   %[        srli.c  r1, %0, %c1      %]\n+   %[        srl.c   r1, %0, %1       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (neg:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"neg     %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"negsi2_ucc\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (neg:SI (match_operand:SI 1 \"register_operand\" \"*e,d\"))\n+                    (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=*e,d\")\n+        (neg:SI (match_dup 1)))]\n+  \"\"\n+  \"@\n+   neg!    %0, %1\n+   neg.c   %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (not:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"not     %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"one_cmplsi2_ucc\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (not:SI (match_operand:SI 1 \"register_operand\" \"*e,d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=*e,d\")\n+        (not:SI (match_dup 1)))]\n+  \"\"\n+  \"@\n+   not!    %0, %1\n+   not.c   %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"one_cmplsi2_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (not:SI (match_operand:SI 0 \"register_operand\" \"*e,d\"))\n+                       (const_int 0)))]\n+  \"\"\n+  \"@\n+   %[        not!    r1, %0       %]\n+   %[        not.c   r1, %0       %]\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (rotate:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                   (match_operand:SI 2 \"arith_operand\" \"J,d\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   roli.c  %0, %1, %c2\n+   rol.c   %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (rotatert:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                     (match_operand:SI 2 \"arith_operand\" \"J,d\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   rori.c  %0, %1, %c2\n+   ror.c   %0, %1, %2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_expand \"cmpsi\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"arith_operand\" \"\")]\n+  \"\"\n+{\n+  cmp_op0 = operands[0];\n+  cmp_op1 = operands[1];\n+  DONE;\n+})\n+\n+(define_insn \"cmpsi_nz\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (match_operand:SI 0 \"register_operand\" \"d,*e,d\")\n+                       (match_operand:SI 1 \"arith_operand\" \"L,*e,d\")))]\n+  \"\"\n+  \"@\n+   cmpi.c  %0, %c1\n+   cmp!    %0, %1\n+   cmp.c   %0, %1\"\n+   [(set_attr \"type\" \"cmp\")\n+    (set_attr \"up_c\" \"yes\")\n+    (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"cmpsi_n\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (match_operand:SI 0 \"register_operand\" \"d,*e,d\")\n+                      (match_operand:SI 1 \"arith_operand\" \"L,*e,d\")))]\n+  \"\"\n+  \"@\n+   cmpi.c  %0, %c1\n+   cmp!    %0, %1\n+   cmp.c   %0, %1\"\n+   [(set_attr \"type\" \"cmp\")\n+    (set_attr \"up_c\" \"yes\")\n+    (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"cmpsi_cc\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_operand:SI 0 \"register_operand\" \"d,*e,d\")\n+                    (match_operand:SI 1 \"arith_operand\" \"L,*e,d\")))]\n+  \"\"\n+  \"@\n+   cmpi.c  %0, %c1\n+   cmp!    %0, %1\n+   cmp.c   %0, %1\"\n+  [(set_attr \"type\" \"cmp\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+        (if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+        (if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+        (if_then_else (gt (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+        (if_then_else (le (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+        (if_then_else (ge (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+        (if_then_else (lt (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+        (if_then_else (gtu (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+        (if_then_else (leu (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+        (if_then_else (geu (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+        (if_then_else (ltu (reg:CC CC_REGNUM) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  mda_gen_cmp (CCmode);\n+})\n+\n+(define_insn \"branch_n\"\n+  [(set (pc)\n+        (if_then_else\n+         (match_operator 0 \"branch_n_operator\"\n+                         [(reg:CC_N CC_REGNUM)\n+                          (const_int 0)])\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))]\n+  \"\"\n+  \"b%C0    %1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"branch_nz\"\n+  [(set (pc)\n+        (if_then_else\n+         (match_operator 0 \"branch_nz_operator\"\n+                         [(reg:CC_NZ CC_REGNUM)\n+                          (const_int 0)])\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))]\n+  \"\"\n+  \"b%C0    %1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"branch_cc\"\n+  [(set (pc)\n+        (if_then_else\n+         (match_operator 0 \"comparison_operator\"\n+                         [(reg:CC CC_REGNUM)\n+                          (const_int 0)])\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))]\n+  \"\"\n+  \"b%C0    %1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+        (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+{\n+  if (!flag_pic)\n+    return \\\"j      %0\\\";\n+  else\n+    return \\\"b      %0\\\";\n+}\n+  [(set_attr \"type\" \"jump\")])\n+\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+                    (match_operand 1 \"\" \"\"))\n+              (use (match_operand 2 \"\" \"\"))])]\n+  \"\"\n+{\n+  mdx_call (operands, true);\n+  DONE;\n+})\n+\n+(define_insn \"sibcall_internal\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"t,Z\"))\n+         (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI RT_REGNUM))]\n+  \"SIBLING_CALL_P (insn) && !flag_pic\"\n+  \"@\n+   br%S0   %0\n+   j       %0\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+              (call (match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")))\n+              (use (match_operand 3 \"\" \"\"))])]\n+  \"\"\n+{\n+  mdx_call_value (operands, true);\n+  DONE;\n+})\n+\n+(define_insn \"sibcall_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n+        (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"t,Z\"))\n+              (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI RT_REGNUM))]\n+  \"SIBLING_CALL_P(insn) && !flag_pic\"\n+  \"@\n+   br%S1   %1\n+   j       %1\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\"))\n+              (use (match_operand 2 \"\" \"\"))])]\n+  \"\"\n+{\n+  mdx_call (operands, false);\n+  DONE;\n+})\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"d,Z\"))\n+         (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI RA_REGNUM))]\n+  \"\"\n+{\n+  if (!flag_pic)\n+    switch (which_alternative)\n+      {\n+      case 0: return \\\"brl%S0  %0\\\";\n+      case 1: return \\\"jl      %0\\\";\n+      default: gcc_unreachable ();\n+      }\n+  else\n+    return \\\"la      r29, %0\\;brl     r29\\\";\n+}\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+              (call (match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")))\n+              (use (match_operand 3 \"\" \"\"))])]\n+  \"\"\n+{\n+  mdx_call_value (operands, false);\n+  DONE;\n+})\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n+        (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"d,Z\"))\n+              (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI RA_REGNUM))]\n+  \"\"\n+{\n+  if (!flag_pic)\n+    switch (which_alternative)\n+      {\n+      case 0: return \\\"brl%S1  %1\\\";\n+      case 1: return \\\"jl      %1\\\";\n+      default: gcc_unreachable ();\n+      }\n+  else\n+    return \\\"la      r29, %1\\;brl     r29\\\";\n+}\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"d\"))]\n+  \"\"\n+{\n+  rtx dest;\n+  dest = operands[0];\n+  if (GET_CODE (dest) != REG\n+      || GET_MODE (dest) != Pmode)\n+    operands[0] = copy_to_mode_reg (Pmode, dest);\n+\n+  emit_jump_insn (gen_indirect_jump_internal1 (operands[0]));\n+  DONE;\n+})\n+\n+(define_insn \"indirect_jump_internal1\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))]\n+  \"\"\n+  \"br%S0   %0\"\n+  [(set_attr \"type\" \"jump\")])\n+\n+(define_expand \"tablejump\"\n+  [(set (pc)\n+        (match_operand 0 \"register_operand\" \"d\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+{\n+  if (GET_MODE (operands[0]) != ptr_mode)\n+    gcc_unreachable ();\n+  emit_jump_insn (gen_tablejump_internal1 (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"tablejump_internal1\"\n+  [(set (pc)\n+        (match_operand:SI 0 \"register_operand\" \"d\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"*\n+   if (flag_pic)\n+     return \\\"mv!     r29, %0\\;.cpadd  r29\\;br%S0   r29\\\";\n+   else\n+     return \\\"br%S0   %0\\\";\n+  \"\n+  [(set_attr \"type\" \"jump\")])\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+{\n+  mdx_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+{\n+  mdx_epilogue (false);\n+  DONE;\n+})\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+{\n+  mdx_epilogue (true);\n+  DONE;\n+})\n+\n+(define_insn \"return_internal\"\n+  [(return)\n+   (use (match_operand 0 \"pmode_register_operand\" \"d\"))]\n+  \"\"\n+  \"br%S0   %0\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"#nop!\"\n+)\n+\n+(define_insn \"cpload\"\n+  [(unspec:SI [(const_int 1)] 1)]\n+  \"flag_pic\"\n+  \".cpload r29\"\n+)\n+\n+(define_insn \"cprestore\"\n+  [(unspec:SI [(match_operand:SI 0 \"\" \"\")] 2)]\n+  \"flag_pic\"\n+  \".cprestore %0\"\n+)"}, {"sha": "2b9f03e480cbac54bf7215746bc33b3a9b399aa9", "filename": "gcc/config/score/score.opt", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.opt?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,53 @@\n+; Options for the Sunnorth port of the compiler.\n+\n+; Copyright (C) 2005 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 2, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+; 02110-1301, USA.\n+\n+meb\n+Target RejectNegative Report InverseMask(LITTLE_ENDIAN)\n+Generate big-endian code\n+\n+mel\n+Target RejectNegative Report Mask(LITTLE_ENDIAN)\n+Generate little-endian code\n+\n+mnpi\n+Target RejectNegative Report Mask(NOPINDEX)\n+Do not use pre/post index\n+\n+mnuls\n+Target RejectNegative Report Mask(NOUNALIGNED)\n+Do not use unaligned load/store\n+\n+mmac\n+Target RejectNegative Report Mask(MAC)\n+Enable mac instruction\n+\n+mSCORE5\n+Target RejectNegative Report Mask(SCORE5)\n+Support SCORE 5 ISA\n+\n+mSCORE5U\n+Target RejectNegative Report Mask(SCORE5U)\n+Support SCORE 5U ISA\n+\n+mSCORE7\n+Target RejectNegative Report Mask(SCORE7)\n+Support SCORE 7 ISA\n+"}, {"sha": "f04054ea5fa69fb43f471dddbf1538b1a7d7733b", "filename": "gcc/config/score/score7.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore7.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Fscore7.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.md?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,46 @@\n+;;  Machine description for Sunplus S+CORE\n+;;  Sunplus S+CORE 7 Pipeline Description\n+;;  Copyright (C) 2005\n+;;  Free Software Foundation, Inc.\n+;;  Contributed by Sunnorth.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+(define_automaton \"score\")\n+\n+(define_cpu_unit \"core\" \"score\")\n+\n+(define_insn_reservation \"memory\" 3\n+                         (eq_attr \"type\" \"load\")\n+                         \"core\")\n+\n+(define_insn_reservation \"mul\" 3\n+                         (eq_attr \"type\" \"mul,div\")\n+                         \"core\")\n+\n+(define_insn_reservation \"fce\" 1\n+                         (eq_attr \"type\" \"fce\")\n+                         \"core\")\n+\n+(define_insn_reservation \"tsr\" 1\n+                         (eq_attr \"type\" \"tsr,fsr\")\n+                         \"core\")\n+\n+(define_insn_reservation \"up_c\" 1\n+                         (eq_attr \"up_c\" \"yes\")\n+                         \"core\")"}, {"sha": "66424dddebdba2d7fe9a32bb3bbfdd78809b207d", "filename": "gcc/config/score/t-score-elf", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Ft-score-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfig%2Fscore%2Ft-score-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Ft-score-elf?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -0,0 +1,44 @@\n+# Additional Backend Files\n+score-mdaux.o: $(srcdir)/config/score/score-mdaux.c $(CONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h $(TM_H) $(RTL_H) output.h flags.h $(TREE_H) \\\n+  expr.h toplev.h $(TM_P_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t$(srcdir)/config/score/score-mdaux.c\n+\n+# Assemble startup files.\n+$(T)crti.o: $(srcdir)/config/score/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/score/crti.asm\n+\n+$(T)crtn.o: $(srcdir)/config/score/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/score/crtn.asm\n+\n+LIB1ASMSRC = score/mul-div.S\n+\n+LIB1ASMFUNCS = _mulsi3 _divsi3 _flush_cache\n+\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+# If any special flags are necessary when building libgcc2 put them here.\n+TARGET_LIBGCC2_CFLAGS = -g\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# We must build libgcc2.a with -G 0, in case the user wants to link\n+# without the $gp register.\n+TARGET_LIBGCC2_CFLAGS = -G 0\n+\n+MULTILIB_OPTIONS = mel mSCORE7\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+"}, {"sha": "37788e92cb4012c3841c1ff7186124f81040097c", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcee4712ec20209d14aeb2d0487de41be1ad424/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=bdcee4712ec20209d14aeb2d0487de41be1ad424", "patch": "@@ -15619,7 +15619,7 @@ esac\n case \"$target\" in\n   i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* \\\n   | x86_64*-*-* | hppa*-*-* | arm*-*-* | strongarm*-*-* | xscale*-*-* \\\n-  | xstormy16*-*-* | cris-*-* | xtensa-*-* | bfin-*-*)\n+  | xstormy16*-*-* | cris-*-* | xtensa-*-* | bfin-*-* | score*-*-*)\n     insn=\"nop\"\n     ;;\n   ia64*-*-* | s390*-*-*)"}]}