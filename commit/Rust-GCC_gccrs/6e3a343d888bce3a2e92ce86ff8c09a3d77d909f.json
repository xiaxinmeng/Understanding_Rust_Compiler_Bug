{"sha": "6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUzYTM0M2Q4ODhiY2UzYTJlOTJjZTg2ZmY4YzA5YTNkNzdkOTA5Zg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2007-01-11T10:10:54Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2007-01-11T10:10:54Z"}, "message": "predicates.md (mcore_general_movesrc_operand): Accept CONSTs.\n\n* config/mcore/predicates.md (mcore_general_movesrc_operand): Accept CONSTs.\n  (mcore_general_movdst_operand): Do not accept CONST_INTs.\n  (mcore_arith_K_S_operand): Run the test for the S constraint not the test for the M constraint.\n  (mcore_addsub_operand): Do not accept integer values that are larger than 32 bits.\n* config/mcore/mcore.md: Remove unused constraints from split.\n  (andsi3): Use HOST_WIDE_INT instead of int to hold an INTVAL.\n  (addsi3): Likewise.\n  (allocate_stack): Likewise.\n* config/mcore/mcore.c (mcore_print_operand): Restrict output of P operands to 32 bits.\n  (mcore_const_costs): Use HOST_WIDE_INT instead of int to hold an INTVAL.\n  (mcore_and_cost, mcore_modify_comparison, const_ok_for_mcore,\n   mcore_const_ok_for_inline, mcore_const_trick_uses_not,\n   try_constant_tricks, mcore_num_ones, mcore_num_zeros,\n   mcore_output_bclri, mcore_output_andn, output_inline_const,\n   mcore_output_move, mcore_output_movedouble): Likewise.\n  (mcore_output_cmov): Use CONST_OK_FOR_M and CONST_OK_FOR_N.\n  (output_inline_const): Likewise.\n  (output_inline_const): Fix format strings used in sprintf statements.\n* config/mcore/mcore-protos.h: Update prototypes for changed functions in mcore.c.\n* config/mcore/mcore.h (CONST_OK_FOR_I): Cast values to HOST_WIDE_INT and not int.\n  (CONST_OK_FOR_J, CONST_OK_FOR_K, CONST_OK_FOR_L, CONST_OK_FOR_M,\n   CONST_OK_FOR_N): Likewise.\n  (LEGITIMATE_CONSTANT_P): Also check CONSTANT_P.\n  (GO_IF_LEGITIMATE_INDEX): Use HOST_WIDE_INT instead of int to hold an INTVAL.\n\nFrom-SVN: r120669", "tree": {"sha": "953008ca699afb9450947e2b6af2bfd99e64408a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/953008ca699afb9450947e2b6af2bfd99e64408a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d499824ede45b788cd35a4d9cd6c560fce7f11d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d499824ede45b788cd35a4d9cd6c560fce7f11d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d499824ede45b788cd35a4d9cd6c560fce7f11d"}], "stats": {"total": 440, "additions": 244, "deletions": 196}, "files": [{"sha": "48491d6a790627a9aa413c44db5923922d5666d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "patch": "@@ -1,3 +1,39 @@\n+2007-01-11  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mcore/predicates.md (mcore_general_movesrc_operand):\n+\tAccept CONSTs.\n+\t(mcore_general_movdst_operand): Do not accept CONST_INTs.\n+\t(mcore_arith_K_S_operand): Run the test for the S constraint not\n+\tthe test for the M constraint.\n+\t(mcore_addsub_operand): Do not accept integer values that are\n+\tlarger than 32 bits.\n+\t* config/mcore/mcore.md: Remove unused constraints from split.\n+\t(andsi3): Use HOST_WIDE_INT instead of int to hold an INTVAL.\n+\t(addsi3): Likewise.\n+\t(allocate_stack): Likewise.\n+\t* config/mcore/mcore.c (mcore_print_operand): Restrict output of P\n+\toperands to 32 bits.\n+\t(mcore_const_costs): Use HOST_WIDE_INT instead of int to hold an\n+\tINTVAL.\n+\t(mcore_and_cost, mcore_modify_comparison, const_ok_for_mcore,\n+\tmcore_const_ok_for_inline, mcore_const_trick_uses_not,\n+\ttry_constant_tricks, mcore_num_ones, mcore_num_zeros,\n+\tmcore_output_bclri, mcore_output_andn, output_inline_const,\n+\tmcore_output_move, mcore_output_movedouble): Likewise.\n+\t(mcore_output_cmov): Use CONST_OK_FOR_M and CONST_OK_FOR_N.\n+\t(output_inline_const): Likewise.\n+\t(output_inline_const): Fix format strings used in sprintf\n+\tstatements.\n+\t* config/mcore/mcore-protos.h: Update prototypes for changed\n+\tfunctions in mcore.c.\n+\t* config/mcore/mcore.h (CONST_OK_FOR_I): Cast values to\n+\tHOST_WIDE_INT and not int.\n+\t(CONST_OK_FOR_J, CONST_OK_FOR_K, CONST_OK_FOR_L, CONST_OK_FOR_M,\n+\tCONST_OK_FOR_N): Likewise.\n+\t(LEGITIMATE_CONSTANT_P): Also check CONSTANT_P.\n+\t(GO_IF_LEGITIMATE_INDEX): Use HOST_WIDE_INT instead of int to hold\n+\tan INTVAL.\n+\n 2007-01-10  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-vrp.c (remove_range_assertions): Release defs."}, {"sha": "b2c5abb1acb8eb1c1d1530aa763fff76003dc45f", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for exported functions defined in mcore.c\n-   Copyright (C) 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n    Contributed by Nick Clifton (nickc@redhat.com)\n \n    This file is part of GCC.\n@@ -22,13 +22,13 @@\n extern const char * mcore_output_jump_label_table\t(void);\n extern void         mcore_expand_prolog          \t(void);\n extern void         mcore_expand_epilog          \t(void);\n-extern int          mcore_const_ok_for_inline    \t(long);\n-extern int          mcore_num_ones               \t(int);\n-extern int          mcore_num_zeros              \t(int);\n+extern int          mcore_const_ok_for_inline    \t(HOST_WIDE_INT);\n+extern int          mcore_num_ones               \t(HOST_WIDE_INT);\n+extern int          mcore_num_zeros              \t(HOST_WIDE_INT);\n extern int          mcore_initial_elimination_offset\t(int, int);\n extern int          mcore_byte_offset            \t(unsigned int);\n extern int          mcore_halfword_offset        \t(unsigned int);\n-extern int          mcore_const_trick_uses_not   \t(long);\n+extern int          mcore_const_trick_uses_not   \t(HOST_WIDE_INT);\n extern void         mcore_override_options       \t(void);\n extern int          mcore_dllexport_name_p       \t(const char *);\n extern int          mcore_dllimport_name_p       \t(const char *);\n@@ -71,7 +71,7 @@ extern int          mcore_arith_S_operand         \t(rtx);\n #ifdef HAVE_MACHINE_MODES\n extern const char * mcore_output_move          \t\t(rtx, rtx *, enum machine_mode);\n extern const char * mcore_output_movedouble    \t\t(rtx *, enum machine_mode);\n-extern int          const_ok_for_mcore                  (int);\n+extern int          const_ok_for_mcore                  (HOST_WIDE_INT);\n #ifdef TREE_CODE\n extern rtx          mcore_function_arg           \t(CUMULATIVE_ARGS, enum machine_mode, tree, int);\n #endif /* TREE_CODE */"}, {"sha": "44035b229679ba4f6564e795efb312387258372b", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 149, "deletions": 148, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for Motorola MCore processor\n-   Copyright (C) 1993, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1993, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -118,7 +118,7 @@ cond_type;\n \n static void       output_stack_adjust           (int, int);\n static int        calc_live_regs                (int *);\n-static int        try_constant_tricks           (long, int *, int *);\n+static int        try_constant_tricks           (long, HOST_WIDE_INT *, HOST_WIDE_INT *);\n static const char *     output_inline_const     (enum machine_mode, rtx *);\n static void       layout_mcore_frame            (struct mcore_frame *);\n static void       mcore_setup_incoming_varargs\t(CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n@@ -345,7 +345,7 @@ mcore_print_operand (FILE * stream, rtx x, int code)\n \tfprintf (asm_out_file, \"%d\", exact_log2 (INTVAL (x) + 1));\n       break;\n     case 'P':\n-      fprintf (asm_out_file, \"%d\", exact_log2 (INTVAL (x)));\n+      fprintf (asm_out_file, \"%d\", exact_log2 (INTVAL (x) & 0xffffffff));\n       break;\n     case 'Q':\n       fprintf (asm_out_file, \"%d\", exact_log2 (~INTVAL (x)));\n@@ -404,7 +404,7 @@ mcore_print_operand (FILE * stream, rtx x, int code)\n static int\n mcore_const_costs (rtx exp, enum rtx_code code)\n {\n-  int val = INTVAL (exp);\n+  HOST_WIDE_INT val = INTVAL (exp);\n \n   /* Easy constants.  */\n   if (   CONST_OK_FOR_I (val)\t\n@@ -432,7 +432,7 @@ mcore_const_costs (rtx exp, enum rtx_code code)\n static int\n mcore_and_cost (rtx x)\n {\n-  int val;\n+  HOST_WIDE_INT val;\n \n   if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n     return 2;\n@@ -458,7 +458,7 @@ mcore_and_cost (rtx x)\n static int\n mcore_ior_cost (rtx x)\n {\n-  int val;\n+  HOST_WIDE_INT val;\n \n   if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n     return 2;\n@@ -529,7 +529,7 @@ mcore_modify_comparison (enum rtx_code code)\n   \n   if (GET_CODE (op1) == CONST_INT)\n     {\n-      int val = INTVAL (op1);\n+      HOST_WIDE_INT val = INTVAL (op1);\n       \n       switch (code)\n \t{\n@@ -686,17 +686,17 @@ mcore_output_call (rtx operands[], int index)\n /* Can we load a constant with a single instruction ?  */\n \n int\n-const_ok_for_mcore (int value)\n+const_ok_for_mcore (HOST_WIDE_INT value)\n {\n   if (value >= 0 && value <= 127)\n     return 1;\n   \n   /* Try exact power of two.  */\n-  if ((value & (value - 1)) == 0)\n+  if (CONST_OK_FOR_M (value))\n     return 1;\n   \n   /* Try exact power of two - 1.  */\n-  if ((value & (value + 1)) == 0)\n+  if (CONST_OK_FOR_N (value) && value != -1)\n     return 1;\n   \n   return 0;\n@@ -705,19 +705,19 @@ const_ok_for_mcore (int value)\n /* Can we load a constant inline with up to 2 instructions ?  */\n \n int\n-mcore_const_ok_for_inline (long value)\n+mcore_const_ok_for_inline (HOST_WIDE_INT value)\n {\n-  int x, y;\n+  HOST_WIDE_INT x, y;\n    \n   return try_constant_tricks (value, & x, & y) > 0;\n }\n \n /* Are we loading the constant using a not ?  */\n \n int\n-mcore_const_trick_uses_not (long value)\n+mcore_const_trick_uses_not (HOST_WIDE_INT value)\n {\n-  int x, y;\n+  HOST_WIDE_INT x, y;\n \n   return try_constant_tricks (value, & x, & y) == 2; \n }       \n@@ -739,121 +739,120 @@ mcore_const_trick_uses_not (long value)\n    11: single insn followed by ixw.  */\n \n static int\n-try_constant_tricks (long value, int * x, int * y)\n+try_constant_tricks (HOST_WIDE_INT value, HOST_WIDE_INT * x, HOST_WIDE_INT * y)\n {\n-  int i;\n-  unsigned bit, shf, rot;\n+  HOST_WIDE_INT i;\n+  unsigned HOST_WIDE_INT bit, shf, rot;\n \n   if (const_ok_for_mcore (value))\n     return 1;\t/* Do the usual thing.  */\n   \n-  if (TARGET_HARDLIT) \n+  if (! TARGET_HARDLIT) \n+    return 0;\n+\n+  if (const_ok_for_mcore (~value))\n+    {\n+      *x = ~value;\n+      return 2;\n+    }\n+\n+  for (i = 1; i <= 32; i++)\n     {\n-      if (const_ok_for_mcore (~value))\n+      if (const_ok_for_mcore (value - i))\n \t{\n-\t  *x = ~value;\n-\t  return 2;\n+\t  *x = value - i;\n+\t  *y = i;\n+\n+\t  return 3;\n \t}\n-      \n-      for (i = 1; i <= 32; i++)\n+\n+      if (const_ok_for_mcore (value + i))\n \t{\n-\t  if (const_ok_for_mcore (value - i))\n-\t    {\n-\t      *x = value - i;\n-\t      *y = i;\n-\t      \n-\t      return 3;\n-\t    }\n-\t  \n-\t  if (const_ok_for_mcore (value + i))\n-\t    {\n-\t      *x = value + i;\n-\t      *y = i;\n-\t      \n-\t      return 4;\n-\t    }\n+\t  *x = value + i;\n+\t  *y = i;\n+\n+\t  return 4;\n \t}\n-      \n-      bit = 0x80000000L;\n-      \n-      for (i = 0; i <= 31; i++)\n+    }\n+\n+  bit = 0x80000000ULL;\n+\n+  for (i = 0; i <= 31; i++)\n+    {\n+      if (const_ok_for_mcore (i - value))\n \t{\n-\t  if (const_ok_for_mcore (i - value))\n-\t    {\n-\t      *x = i - value;\n-\t      *y = i;\n-\t      \n-\t      return 5;\n-\t    }\n-\t  \n-\t  if (const_ok_for_mcore (value & ~bit))\n-\t    {\n-\t      *y = bit;\n-\t      *x = value & ~bit;\n-\t      \n-\t      return 6;\n-\t    }\n-\t  \n-\t  if (const_ok_for_mcore (value | bit))\n-\t    {\n-\t      *y = ~bit;\n-\t      *x = value | bit;\n-\t      \n-\t      return 7;\n-\t    }\n-\t  \n-\t  bit >>= 1;\n+\t  *x = i - value;\n+\t  *y = i;\n+\n+\t  return 5;\n \t}\n-      \n-      shf = value;\n-      rot = value;\n-      \n-      for (i = 1; i < 31; i++)\n+\n+      if (const_ok_for_mcore (value & ~bit))\n \t{\n-\t  int c;\n-\t  \n-\t  /* MCore has rotate left.  */\n-\t  c = rot << 31;\n-\t  rot >>= 1;\n-\t  rot &= 0x7FFFFFFF;\n-\t  rot |= c;   /* Simulate rotate.  */\n-\t  \n-\t  if (const_ok_for_mcore (rot))\n-\t    {\n-\t      *y = i;\n-\t      *x = rot;\n-\t      \n-\t      return 8;\n-\t    }\n-\t  \n-\t  if (shf & 1)\n-\t    shf = 0;\t/* Can't use logical shift, low order bit is one.  */\n-\t  \n-\t  shf >>= 1;\n-\t  \n-\t  if (shf != 0 && const_ok_for_mcore (shf))\n-\t    {\n-\t      *y = i;\n-\t      *x = shf;\n-\t      \n-\t      return 9;\n-\t    }\n+\t  *y = bit;\n+\t  *x = value & ~bit;\n+\t  return 6;\n \t}\n-      \n-      if ((value % 3) == 0 && const_ok_for_mcore (value / 3))\n+\n+      if (const_ok_for_mcore (value | bit))\n \t{\n-\t  *x = value / 3;\n-\t  \n-\t  return 10;\n+\t  *y = ~bit;\n+\t  *x = value | bit;\n+\n+\t  return 7;\n \t}\n-      \n-      if ((value % 5) == 0 && const_ok_for_mcore (value / 5))\n+\n+      bit >>= 1;\n+    }\n+\n+  shf = value;\n+  rot = value;\n+\n+  for (i = 1; i < 31; i++)\n+    {\n+      int c;\n+\n+      /* MCore has rotate left.  */\n+      c = rot << 31;\n+      rot >>= 1;\n+      rot &= 0x7FFFFFFF;\n+      rot |= c;   /* Simulate rotate.  */\n+\n+      if (const_ok_for_mcore (rot))\n \t{\n-\t  *x = value / 5;\n-\t  \n-\t  return 11;\n+\t  *y = i;\n+\t  *x = rot;\n+\n+\t  return 8;\n+\t}\n+\n+      if (shf & 1)\n+\tshf = 0;\t/* Can't use logical shift, low order bit is one.  */\n+\n+      shf >>= 1;\n+\n+      if (shf != 0 && const_ok_for_mcore (shf))\n+\t{\n+\t  *y = i;\n+\t  *x = shf;\n+\n+\t  return 9;\n \t}\n     }\n+\n+  if ((value % 3) == 0 && const_ok_for_mcore (value / 3))\n+    {\n+      *x = value / 3;\n+\n+      return 10;\n+    }\n+\n+  if ((value % 5) == 0 && const_ok_for_mcore (value / 5))\n+    {\n+      *x = value / 5;\n+\n+      return 11;\n+    }\n   \n   return 0;\n }\n@@ -910,7 +909,7 @@ mcore_is_dead (rtx first, rtx reg)\n /* Count the number of ones in mask.  */\n \n int\n-mcore_num_ones (int mask)\n+mcore_num_ones (HOST_WIDE_INT mask)\n {\n   /* A trick to count set bits recently posted on comp.compilers.  */\n   mask =  (mask >> 1  & 0x55555555) + (mask & 0x55555555);\n@@ -924,7 +923,7 @@ mcore_num_ones (int mask)\n /* Count the number of zeros in mask.  */\n \n int\n-mcore_num_zeros (int mask)\n+mcore_num_zeros (HOST_WIDE_INT mask)\n {\n   return 32 - mcore_num_ones (mask);\n }\n@@ -1015,8 +1014,8 @@ mcore_output_bclri (rtx dst, int mask)\n const char *\n mcore_output_cmov (rtx operands[], int cmp_t, const char * test)\n {\n-  int load_value;\n-  int adjust_value;\n+  HOST_WIDE_INT load_value;\n+  HOST_WIDE_INT adjust_value;\n   rtx out_operands[4];\n \n   out_operands[0] = operands[0];\n@@ -1049,9 +1048,9 @@ mcore_output_cmov (rtx operands[], int cmp_t, const char * test)\n      instruction sequence has a different length attribute).  */\n   if (load_value >= 0 && load_value <= 127)\n     output_asm_insn (\"movi\\t%0,%1\", out_operands);\n-  else if ((load_value & (load_value - 1)) == 0)\n+  else if (CONST_OK_FOR_M (load_value))\n     output_asm_insn (\"bgeni\\t%0,%P1\", out_operands);\n-  else if ((load_value & (load_value + 1)) == 0)\n+  else if (CONST_OK_FOR_N (load_value))\n     output_asm_insn (\"bmaski\\t%0,%N1\", out_operands);\n    \n   /* Output the constant adjustment.  */\n@@ -1079,7 +1078,7 @@ mcore_output_cmov (rtx operands[], int cmp_t, const char * test)\n const char *\n mcore_output_andn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n {\n-  int x, y;\n+  HOST_WIDE_INT x, y;\n   rtx out_operands[3];\n   const char * load_op;\n   char buf[256];\n@@ -1089,22 +1088,25 @@ mcore_output_andn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n   gcc_assert (trick_no == 2);\n \n   out_operands[0] = operands[0];\n-  out_operands[1] = GEN_INT(x);\n+  out_operands[1] = GEN_INT (x);\n   out_operands[2] = operands[2];\n \n   if (x >= 0 && x <= 127)\n     load_op = \"movi\\t%0,%1\";\n   \n   /* Try exact power of two.  */\n-  else if ((x & (x - 1)) == 0)\n+  else if (CONST_OK_FOR_M (x))\n     load_op = \"bgeni\\t%0,%P1\";\n   \n   /* Try exact power of two - 1.  */\n-  else if ((x & (x + 1)) == 0)\n+  else if (CONST_OK_FOR_N (x))\n     load_op = \"bmaski\\t%0,%N1\";\n   \n-  else \n-    load_op = \"BADMOVI\\t%0,%1\";\n+  else\n+    {\n+      load_op = \"BADMOVI-andn\\t%0, %1\";\n+      gcc_unreachable ();\n+    }\n \n   sprintf (buf, \"%s\\n\\tandn\\t%%2,%%0\", load_op);\n   output_asm_insn (buf, out_operands);\n@@ -1117,13 +1119,13 @@ mcore_output_andn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n static const char *\n output_inline_const (enum machine_mode mode, rtx operands[])\n {\n-  int x = 0, y = 0;\n+  HOST_WIDE_INT x = 0, y = 0;\n   int trick_no;\n   rtx out_operands[3];\n   char buf[256];\n   char load_op[256];\n   const char *dst_fmt;\n-  int value;\n+  HOST_WIDE_INT value;\n \n   value = INTVAL (operands[1]);\n \n@@ -1153,51 +1155,54 @@ output_inline_const (enum machine_mode mode, rtx operands[])\n     sprintf (load_op, \"movi\\t%s,%%1\", dst_fmt);\n   \n   /* Try exact power of two.  */\n-  else if ((x & (x - 1)) == 0)\n+  else if (CONST_OK_FOR_M (x))\n     sprintf (load_op, \"bgeni\\t%s,%%P1\", dst_fmt);\n   \n   /* Try exact power of two - 1.  */\n-  else if ((x & (x + 1)) == 0)\n+  else if (CONST_OK_FOR_N (x))\n     sprintf (load_op, \"bmaski\\t%s,%%N1\", dst_fmt);\n   \n-  else \n-    sprintf (load_op, \"BADMOVI\\t%s,%%1\", dst_fmt);\n+  else\n+    {\n+      sprintf (load_op, \"BADMOVI-inline_const %s, %%1\", dst_fmt);\n+      gcc_unreachable ();\n+    }      \n \n   switch (trick_no)\n     {\n     case 1:\n       strcpy (buf, load_op);\n       break;\n     case 2:   /* not */\n-      sprintf (buf, \"%s\\n\\tnot\\t%s\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\tnot\\t%s\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n     case 3:   /* add */\n-      sprintf (buf, \"%s\\n\\taddi\\t%s,%%2\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\taddi\\t%s,%%2\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n     case 4:   /* sub */\n-      sprintf (buf, \"%s\\n\\tsubi\\t%s,%%2\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\tsubi\\t%s,%%2\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n     case 5:   /* rsub */\n       /* Never happens unless -mrsubi, see try_constant_tricks().  */\n-      sprintf (buf, \"%s\\n\\trsubi\\t%s,%%2\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\trsubi\\t%s,%%2\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n-    case 6:   /* bset */\n-      sprintf (buf, \"%s\\n\\tbseti\\t%s,%%P2\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+    case 6:   /* bseti */\n+      sprintf (buf, \"%s\\n\\tbseti\\t%s,%%P2\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n     case 7:   /* bclr */\n-      sprintf (buf, \"%s\\n\\tbclri\\t%s,%%Q2\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\tbclri\\t%s,%%Q2\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n     case 8:   /* rotl */\n-      sprintf (buf, \"%s\\n\\trotli\\t%s,%%2\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\trotli\\t%s,%%2\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n     case 9:   /* lsl */\n-      sprintf (buf, \"%s\\n\\tlsli\\t%s,%%2\\t// %d 0x%x\", load_op, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\tlsli\\t%s,%%2\\t// %ld 0x%lx\", load_op, dst_fmt, value, value);\n       break;\n     case 10:  /* ixh */\n-      sprintf (buf, \"%s\\n\\tixh\\t%s,%s\\t// %d 0x%x\", load_op, dst_fmt, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\tixh\\t%s,%s\\t// %ld 0x%lx\", load_op, dst_fmt, dst_fmt, value, value);\n       break;\n     case 11:  /* ixw */\n-      sprintf (buf, \"%s\\n\\tixw\\t%s,%s\\t// %d 0x%x\", load_op, dst_fmt, dst_fmt, value, value);\n+      sprintf (buf, \"%s\\n\\tixw\\t%s,%s\\t// %ld 0x%lx\", load_op, dst_fmt, dst_fmt, value, value);\n       break;\n     default:\n       return \"\";\n@@ -1245,7 +1250,7 @@ mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \t}\n       else if (GET_CODE (src) == CONST_INT)\n \t{\n-\t  int x, y;\n+\t  HOST_WIDE_INT x, y;\n \t  \n \t  if (CONST_OK_FOR_I (INTVAL (src)))       /* r-I */\n             return \"movi\\t%0,%1\";\n@@ -1342,8 +1347,6 @@ mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED\n \t\toutput_asm_insn (\"movi\t%0,%1\", operands);\n \t      else if (CONST_OK_FOR_M (INTVAL (src)))\n \t\toutput_asm_insn (\"bgeni\t%0,%P1\", operands);\n-\t      else if (INTVAL (src) == -1)\n-\t\toutput_asm_insn (\"bmaski\t%0,32\", operands);\n \t      else if (CONST_OK_FOR_N (INTVAL (src)))\n \t\toutput_asm_insn (\"bmaski\t%0,%N1\", operands);\n \t      else\n@@ -1360,13 +1363,11 @@ mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED\n \t\toutput_asm_insn (\"movi\t%R0,%1\", operands);\n \t      else if (CONST_OK_FOR_M (INTVAL (src)))\n \t\toutput_asm_insn (\"bgeni\t%R0,%P1\", operands);\n-\t      else if (INTVAL (src) == -1)\n-\t\toutput_asm_insn (\"bmaski\t%R0,32\", operands);\n \t      else if (CONST_OK_FOR_N (INTVAL (src)))\n \t\toutput_asm_insn (\"bmaski\t%R0,%N1\", operands);\n \t      else\n \t\tgcc_unreachable ();\n-\t      \n+\n \t      if (INTVAL (src) < 0)\n \t\treturn \"bmaski\t%0,32\";\n \t      else\n@@ -1410,7 +1411,7 @@ mcore_expand_insv (rtx operands[])\n     {\n       /* Do directly with bseti or bclri.  */\n       /* RBE: 2/97 consider only low bit of constant.  */\n-      if ((INTVAL(operands[3])&1) == 0)\n+      if ((INTVAL (operands[3]) & 1) == 0)\n \t{\n \t  mask = ~(1 << posn);\n \t  emit_insn (gen_rtx_SET (SImode, operands[0],\n@@ -1445,8 +1446,8 @@ mcore_expand_insv (rtx operands[])\n      immediates.  */\n \n   /* If setting the entire field, do it directly.  */\n-  if (GET_CODE (operands[3]) == CONST_INT && \n-      INTVAL (operands[3]) == ((1 << width) - 1))\n+  if (GET_CODE (operands[3]) == CONST_INT\n+      && INTVAL (operands[3]) == ((1 << width) - 1))\n     {\n       mreg = force_reg (SImode, GEN_INT (INTVAL (operands[3]) << posn));\n       emit_insn (gen_rtx_SET (SImode, operands[0],"}, {"sha": "cbc2f33e66ffffabb4bc8b4cb63724d7a935d69d", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    for Motorola M*CORE Processor.\n-   Copyright (C) 1993, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1993, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -452,17 +452,17 @@ extern const enum reg_class reg_class_from_letter[];\n         U: constant 0\n         xxxS: 1 cleared bit out of 32 (complement of power of 2). for bclri\n         xxxT: 2 cleared bits out of 32. for pairs of bclris.  */\n-#define CONST_OK_FOR_I(VALUE) (((int)(VALUE)) >= 0 && ((int)(VALUE)) <= 0x7f)\n-#define CONST_OK_FOR_J(VALUE) (((int)(VALUE)) >  0 && ((int)(VALUE)) <= 32)\n-#define CONST_OK_FOR_L(VALUE) (((int)(VALUE)) <  0 && ((int)(VALUE)) >= -32)\n-#define CONST_OK_FOR_K(VALUE) (((int)(VALUE)) >= 0 && ((int)(VALUE)) <= 31)\n-#define CONST_OK_FOR_M(VALUE) (exact_log2 (VALUE) >= 0)\n-#define CONST_OK_FOR_N(VALUE) (((int)(VALUE)) == -1 || exact_log2 ((VALUE) + 1) >= 0)\n+#define CONST_OK_FOR_I(VALUE) (((HOST_WIDE_INT)(VALUE)) >= 0 && ((HOST_WIDE_INT)(VALUE)) <= 0x7f)\n+#define CONST_OK_FOR_J(VALUE) (((HOST_WIDE_INT)(VALUE)) >  0 && ((HOST_WIDE_INT)(VALUE)) <= 32)\n+#define CONST_OK_FOR_L(VALUE) (((HOST_WIDE_INT)(VALUE)) <  0 && ((HOST_WIDE_INT)(VALUE)) >= -32)\n+#define CONST_OK_FOR_K(VALUE) (((HOST_WIDE_INT)(VALUE)) >= 0 && ((HOST_WIDE_INT)(VALUE)) <= 31)\n+#define CONST_OK_FOR_M(VALUE) (exact_log2 (VALUE) >= 0 && exact_log2 (VALUE) <= 30)\n+#define CONST_OK_FOR_N(VALUE) (((HOST_WIDE_INT)(VALUE)) == -1 || (exact_log2 ((VALUE) + 1) >= 0 && exact_log2 ((VALUE) + 1) <= 30))\n #define CONST_OK_FOR_O(VALUE) (CONST_OK_FOR_I(VALUE) || \\\n                                CONST_OK_FOR_M(VALUE) || \\\n                                CONST_OK_FOR_N(VALUE) || \\\n-                               CONST_OK_FOR_M((int)(VALUE) - 1) || \\\n-                               CONST_OK_FOR_N((int)(VALUE) + 1))\n+                               CONST_OK_FOR_M((HOST_WIDE_INT)(VALUE) - 1) || \\\n+                               CONST_OK_FOR_N((HOST_WIDE_INT)(VALUE) + 1))\n \n #define CONST_OK_FOR_P(VALUE) (mcore_const_ok_for_inline (VALUE)) \n \n@@ -698,7 +698,8 @@ extern const enum reg_class reg_class_from_letter[];\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n \n    On the MCore, allow anything but a double.  */\n-#define LEGITIMATE_CONSTANT_P(X) (GET_CODE(X) != CONST_DOUBLE)\n+#define LEGITIMATE_CONSTANT_P(X) (GET_CODE(X) != CONST_DOUBLE \\\n+\t\t\t\t  && CONSTANT_P (X))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -755,15 +756,15 @@ extern const enum reg_class reg_class_from_letter[];\n       if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n         {\t\t\t\t\t\t\t\t\\\n \t  if (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\t\\\n-\t      && (((unsigned)INTVAL (OP)) % 4) == 0\t\t\t\\\n-\t      &&  ((unsigned)INTVAL (OP)) <= 64 - GET_MODE_SIZE (MODE))\t\\\n+\t      && (((unsigned HOST_WIDE_INT) INTVAL (OP)) % 4) == 0\t\\\n+\t      &&  ((unsigned HOST_WIDE_INT) INTVAL (OP)) <= 64 - GET_MODE_SIZE (MODE))\t\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n \t  if (GET_MODE_SIZE (MODE) == 2 \t\t\t\t\\\n-\t      && (((unsigned)INTVAL (OP)) % 2) == 0\t\t\t\\\n-\t      &&  ((unsigned)INTVAL (OP)) <= 30)\t\t\t\\\n+\t      && (((unsigned HOST_WIDE_INT) INTVAL (OP)) % 2) == 0\t\\\n+\t      &&  ((unsigned HOST_WIDE_INT) INTVAL (OP)) <= 30)\t\t\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n \t  if (GET_MODE_SIZE (MODE) == 1 \t\t\t\t\\\n-\t      && ((unsigned)INTVAL (OP)) <= 15)\t\t\t\t\\\n+\t      && ((unsigned HOST_WIDE_INT) INTVAL (OP)) <= 15)\t\t\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -853,7 +854,7 @@ extern const enum reg_class reg_class_from_letter[];\n #define DATA_SECTION_ASM_OP  \"\\t.data\"\n \n /* Switch into a generic section.  */\n-#undef TARGET_ASM_NAMED_SECTION\n+#undef  TARGET_ASM_NAMED_SECTION\n #define TARGET_ASM_NAMED_SECTION  mcore_asm_named_section\n \n /* This is how to output an insn to push a register on the stack."}, {"sha": "c4af69ed0d35efd1539f6fcb76a226f422d735b7", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "patch": "@@ -1,5 +1,5 @@\n ;;  Machine description the Motorola MCore\n-;;  Copyright (C) 1993, 1999, 2000, 2004, 2005\n+;;  Copyright (C) 1993, 1999, 2000, 2004, 2005, 2007\n ;;  Free Software Foundation, Inc.\n ;;  Contributed by Motorola.\n \n@@ -192,11 +192,11 @@\n (define_split \n   [(parallel[\n       (set (reg:CC 17)\n-           (ne:CC (ne:SI (leu:CC (match_operand:SI 0 \"mcore_arith_reg_operand\" \"r\")\n-                                 (match_operand:SI 1 \"mcore_arith_reg_operand\" \"r\"))\n+           (ne:CC (ne:SI (leu:CC (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n+                                 (match_operand:SI 1 \"mcore_arith_reg_operand\" \"\"))\n                          (const_int 0))\n                   (const_int 0)))\n-      (clobber (match_operand:CC 2 \"mcore_arith_reg_operand\" \"=r\"))])]\n+      (clobber (match_operand:CC 2 \"mcore_arith_reg_operand\" \"\"))])]\n   \"\"\n   [(set (reg:CC 17) (ne:SI (match_dup 0) (const_int 0)))\n    (set (reg:CC 17) (leu:CC (match_dup 0) (match_dup 1)))])\n@@ -355,7 +355,8 @@\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0\n       && ! mcore_arith_S_operand (operands[2]))\n     {\n-      int not_value = ~ INTVAL (operands[2]);\n+      HOST_WIDE_INT not_value = ~ INTVAL (operands[2]);\n+\n       if (   CONST_OK_FOR_I (not_value)\n           || CONST_OK_FOR_M (not_value)\n \t  || CONST_OK_FOR_N (not_value))\n@@ -730,9 +731,11 @@\n   /* Convert adds to subtracts if this makes loading the constant cheaper.\n      But only if we are allowed to generate new pseudos.  */\n   if (! (reload_in_progress || reload_completed)\n-      && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < -32)\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < -32)\n     {\n-      int neg_value = - INTVAL (operands[2]);\n+      HOST_WIDE_INT neg_value = - INTVAL (operands[2]);\n+\n       if (   CONST_OK_FOR_I (neg_value)\n \t  || CONST_OK_FOR_M (neg_value)\n \t  || CONST_OK_FOR_N (neg_value))\n@@ -764,7 +767,7 @@\n ;;        || (INTVAL (operands[2]) < -32 && INTVAL(operands[2]) >= -64))\"\n ;;   \"*\n ;; {\n-;;    int n = INTVAL(operands[2]);\n+;;    HOST_WIDE_INT n = INTVAL(operands[2]);\n ;;    if (n > 0)\n ;;      {\n ;;        operands[2] = GEN_INT(n - 32);\n@@ -822,7 +825,7 @@\n ;;        || (INTVAL (operands[2]) < -32 && INTVAL(operands[2]) >= -64))\"\n ;;   \"*\n ;; {\n-;;    int n = INTVAL(operands[2]);\n+;;    HOST_WIDE_INT n = INTVAL(operands[2]);\n ;;    if ( n > 0)\n ;;      {\n ;;        operands[2] = GEN_INT( n - 32);\n@@ -2976,8 +2979,9 @@\n         (match_operand:SI 1 \"const_int_operand\" \"\"))\n    (set (match_operand:SI 2 \"mcore_arith_reg_operand\" \"\")\n         (ior:SI (match_dup 2) (match_dup 0)))]\n-  \"TARGET_HARDLIT && mcore_num_ones (INTVAL (operands[1])) == 2 &&\n-       mcore_is_dead (insn, operands[0])\"\n+  \"TARGET_HARDLIT\n+   && mcore_num_ones (INTVAL (operands[1])) == 2\n+   && mcore_is_dead (insn, operands[0])\"\n   \"* return mcore_output_bseti (operands[2], INTVAL (operands[1]));\")\n \n (define_peephole\n@@ -3276,7 +3280,7 @@\n   if (GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) < 8 * STACK_UNITS_MAXSTEP)\n     {\n-      int left = INTVAL(operands[1]);\n+      HOST_WIDE_INT left = INTVAL(operands[1]);\n \n       /* If it's a long way, get close enough for a last shot.  */\n       if (left >= STACK_UNITS_MAXSTEP)\n@@ -3295,7 +3299,7 @@\n \t  while (left > STACK_UNITS_MAXSTEP);\n \t}\n       /* Perform the final adjustment.  */\n-      emit_insn (gen_addsi3 (stack_pointer_rtx,stack_pointer_rtx,GEN_INT(-left)));\n+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (-left)));\n ;;      emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n       DONE;\n     }\n@@ -3309,7 +3313,7 @@\n \n #if 1\n       emit_insn (gen_movsi (tmp, operands[1]));\n-      emit_insn (gen_movsi (step, GEN_INT(STACK_UNITS_MAXSTEP)));\n+      emit_insn (gen_movsi (step, GEN_INT (STACK_UNITS_MAXSTEP)));\n \n       if (GET_CODE (operands[1]) != CONST_INT)\n \t{"}, {"sha": "60c4d6dc1ee298eb843f1ff884102fa74e28e8d4", "filename": "gcc/config/mcore/predicates.md", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3a343d888bce3a2e92ce86ff8c09a3d77d909f/gcc%2Fconfig%2Fmcore%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fpredicates.md?ref=6e3a343d888bce3a2e92ce86ff8c09a3d77d909f", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for Motorola MCore.\n-;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -38,7 +38,7 @@\n ;; Nonzero if OP can be source of a simple move operation.\n \n (define_predicate \"mcore_general_movsrc_operand\"\n-  (match_code \"mem,const_int,reg,subreg,symbol_ref,label_ref\")\n+  (match_code \"mem,const_int,reg,subreg,symbol_ref,label_ref,const\")\n {\n   /* Any (MEM LABEL_REF) is OK.  That is a pc-relative load.  */\n   if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n@@ -50,7 +50,7 @@\n ;; Nonzero if OP can be destination of a simple move operation.\n \n (define_predicate \"mcore_general_movdst_operand\"\n-  (match_code \"mem,const_int,reg,subreg\")\n+  (match_code \"mem,reg,subreg\")\n {\n   if (GET_CODE (op) == REG && REGNO (op) == CC_REG)\n     return 0;\n@@ -141,7 +141,7 @@\n \n   if (GET_CODE (op) == CONST_INT)\n     {\n-      if (CONST_OK_FOR_K (INTVAL (op)) || CONST_OK_FOR_M (~INTVAL (op)))\n+      if (CONST_OK_FOR_K (INTVAL (op)) || (mcore_num_zeros (INTVAL (op)) <= 2))\n \treturn 1;\n     }\n \n@@ -212,18 +212,24 @@\n \n   if (GET_CODE (op) == CONST_INT)\n     {\n-      return 1;\n-\n-      /* The following is removed because it precludes large constants from being\n+      /* The following has been removed because it precludes large constants from being\n \t returned as valid source operands for and add/sub insn.  While large\n \t constants may not directly be used in an add/sub, they may if first loaded\n \t into a register.  Thus, this predicate should indicate that they are valid,\n \t and the constraint in mcore.md should control whether an additional load to\n-\t register is needed. (see mcore.md, addsi). -- DAC 4/2/1998  */\n-      /*\n-\tif (CONST_OK_FOR_J(INTVAL(op)) || CONST_OK_FOR_L(INTVAL(op)))\n-          return 1;\n-      */\n+\t register is needed. (see mcore.md, addsi). -- DAC 4/2/1998\n+      \n+      if (CONST_OK_FOR_J (INTVAL (op)) || CONST_OK_FOR_L (INTVAL (op)))\n+        return 1;\n+\n+\t However we do still need to check to make sure that the constant is not too\n+\t big, especially if we are running on a 64-bit OS...  Nickc 8/1/07.  */\n+\n+      if (trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n+\treturn 0;\n+\n+      return 1;\n+\n     }\n \n   return 0;"}]}