{"sha": "a448ff403b72f8e9d914a63d89ebca8246dad0ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ0OGZmNDAzYjcyZjhlOWQ5MTRhNjNkODllYmNhODI0NmRhZDBlZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-30T17:58:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-30T17:58:19Z"}, "message": "invoke.texi (-fpeel-loops,-O3): Update documentation.\n\n\n\t* doc/invoke.texi (-fpeel-loops,-O3): Update documentation.\n\t* opts.c (default_options): Enable peel loops at -O3.\n\t* tree-ssa-loop-ivcanon.c (peeled_loops): New static var.\n\t(try_peel_loop): Do not re-peel already peeled loops;\n\tuse likely upper bounds; fix profile updating.\n\t(pass_complete_unroll::execute): Initialize peeled_loops.\n\n\t* gcc.dg/tree-ssa/peel1.c: New testcase.\n\t* gcc.dg/tree-ssa/pr61743-1.c: Disable loop peeling.\n\t* gcc.dg/tree-ssa/pr61743-2.c: Disable loop peeling.\n\nFrom-SVN: r236892", "tree": {"sha": "1618933ba1605bd935706f18f0ece6f212807cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1618933ba1605bd935706f18f0ece6f212807cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a448ff403b72f8e9d914a63d89ebca8246dad0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a448ff403b72f8e9d914a63d89ebca8246dad0ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a448ff403b72f8e9d914a63d89ebca8246dad0ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a448ff403b72f8e9d914a63d89ebca8246dad0ef/comments", "author": null, "committer": null, "parents": [{"sha": "83e0b73912068e0f42204df117e5f7a2a2e349e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e0b73912068e0f42204df117e5f7a2a2e349e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e0b73912068e0f42204df117e5f7a2a2e349e1"}], "stats": {"total": 85, "additions": 66, "deletions": 19}, "files": [{"sha": "e4816b34b14662f9fc6535978940ce3006b37112", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -1,3 +1,12 @@\n+2016-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* doc/invoke.texi (-fpeel-loops,-O3): Update documentation.\n+\t* opts.c (default_options): Enable peel loops at -O3.\n+\t* tree-ssa-loop-ivcanon.c (peeled_loops): New static var.\n+\t(try_peel_loop): Do not re-peel already peeled loops;\n+\tuse likely upper bounds; fix profile updating.\n+\t(pass_complete_unroll::execute): Initialize peeled_loops.\n+\n 2016-05-30  Martin Liska  <mliska@suse.cz>\n \n \t* tree-ssa-loop-ivopts.c (get_computation_cost_at): Scale"}, {"sha": "aaafff2dbd807a9e36004cfd3610ad78ff4b166e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -6338,7 +6338,8 @@ by @option{-O2} and also turns on the @option{-finline-functions},\n @option{-fgcse-after-reload}, @option{-ftree-loop-vectorize},\n @option{-ftree-loop-distribute-patterns}, @option{-fsplit-paths}\n @option{-ftree-slp-vectorize}, @option{-fvect-cost-model},\n-@option{-ftree-partial-pre} and @option{-fipa-cp-clone} options.\n+@option{-ftree-partial-pre}, @option{-fpeel-loops}\n+and @option{-fipa-cp-clone} options.\n \n @item -O0\n @opindex O0\n@@ -8661,10 +8662,11 @@ the loop is entered.  This usually makes programs run more slowly.\n @item -fpeel-loops\n @opindex fpeel-loops\n Peels loops for which there is enough information that they do not\n-roll much (from profile feedback).  It also turns on complete loop peeling\n-(i.e.@: complete removal of loops with small constant number of iterations).\n+roll much (from profile feedback or static analysis).  It also turns on\n+complete loop peeling (i.e.@: complete removal of loops with small constant\n+number of iterations).\n \n-Enabled with @option{-fprofile-use}.\n+Enabled with @option{-O3} and/or @option{-fprofile-use}.\n \n @item -fmove-loop-invariants\n @opindex fmove-loop-invariants"}, {"sha": "e80331f4bf52c119994fb32646e924d65440049f", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -535,6 +535,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_3_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_DYNAMIC },\n     { OPT_LEVELS_3_PLUS, OPT_fipa_cp_clone, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_partial_pre, NULL, 1 },\n+    { OPT_LEVELS_3_PLUS, OPT_fpeel_loops, NULL, 1 },\n \n     /* -Ofast adds optimizations to -O3.  */\n     { OPT_LEVELS_FAST, OPT_ffast_math, NULL, 1 },"}, {"sha": "67cab5797a500c051d4b2478f90c9b54bac3493f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -1,3 +1,9 @@\n+2016-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/peel1.c: New testcase.\n+\t* gcc.dg/tree-ssa/pr61743-1.c: Disable loop peeling.\n+\t* gcc.dg/tree-ssa/pr61743-2.c: Disable loop peeling.\n+\n 2016-05-30  Tom de Vries  <tom@codesourcery.com>\n \n \t* gcc.dg/graphite/pr69067.c (main): Remove superfluous argument in call"}, {"sha": "40a1f3a213229a31701bacacf02d1373dd4bf78a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/peel1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpeel1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpeel1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpeel1.c?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-cunroll-details\" } */\n+struct foo {int b; int a[3];} foo;\n+void add(struct foo *a,int l)\n+{\n+  int i;\n+  for (i=0;i<l;i++)\n+    a->a[i]++;\n+}\n+/* { dg-final { scan-tree-dump \"Loop 1 likely iterates at most 3 times.\" \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump \"Peeled loop 1, 4 times.\" \"cunroll\"} } */"}, {"sha": "8041c6a323e72ae6c18c866eeb575bd315a87303", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr61743-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-1.c?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\r\n-/* { dg-options \"-O3 -funroll-loops -fno-tree-vectorize -fdump-tree-cunroll-details\" } */\r\n+/* { dg-options \"-O3 -funroll-loops -fno-tree-vectorize -fdump-tree-cunroll-details -fno-peel-loops\" } */\r\n \r\n #define N 8\r\n #define M 14\r"}, {"sha": "5bf38c5c743faeea40a528c0ec411b28c4981cd8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr61743-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-2.c?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\r\n-/* { dg-options \"-O3 -funroll-loops -fno-tree-vectorize -fdump-tree-cunroll-details\" } */\r\n+/* { dg-options \"-O3 -funroll-loops -fno-tree-vectorize -fdump-tree-cunroll-details -fno-peel-loops\" } */\r\n \r\n #define N 8\r\n #define M 14\r"}, {"sha": "319a4106930ab0b31bd340f38d29085175ae7fd8", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a448ff403b72f8e9d914a63d89ebca8246dad0ef/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=a448ff403b72f8e9d914a63d89ebca8246dad0ef", "patch": "@@ -594,6 +594,8 @@ remove_redundant_iv_tests (struct loop *loop)\n /* Stores loops that will be unlooped after we process whole loop tree. */\n static vec<loop_p> loops_to_unloop;\n static vec<int> loops_to_unloop_nunroll;\n+/* Stores loops that has been peeled.  */\n+static bitmap peeled_loops;\n \n /* Cancel all fully unrolled loops by putting __builtin_unreachable\n    on the latch edge.  \n@@ -962,14 +964,17 @@ try_peel_loop (struct loop *loop,\n   vec<edge> to_remove = vNULL;\n   edge e;\n \n-  /* If the iteration bound is known and large, then we can safely eliminate\n-     the check in peeled copies.  */\n-  if (TREE_CODE (niter) != INTEGER_CST)\n-    exit = NULL;\n-\n-  if (!flag_peel_loops || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0)\n+  if (!flag_peel_loops || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0\n+      || !peeled_loops)\n     return false;\n \n+  if (bitmap_bit_p (peeled_loops, loop->num))\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: loop is already peeled\\n\");\n+      return false;\n+    }\n+\n   /* Peel only innermost loops.\n      While the code is perfectly capable of peeling non-innermost loops,\n      the heuristics would probably need some improvements. */\n@@ -989,6 +994,8 @@ try_peel_loop (struct loop *loop,\n \n   /* Check if there is an estimate on the number of iterations.  */\n   npeel = estimated_loop_iterations_int (loop);\n+  if (npeel < 0)\n+    npeel = likely_max_loop_iterations_int (loop);\n   if (npeel < 0)\n     {\n       if (dump_file)\n@@ -1036,8 +1043,7 @@ try_peel_loop (struct loop *loop,\n       && wi::leu_p (npeel, wi::to_widest (niter)))\n     {\n       bitmap_ones (wont_exit);\n-      if (wi::eq_p (wi::to_widest (niter), npeel))\n-        bitmap_clear_bit (wont_exit, 0);\n+      bitmap_clear_bit (wont_exit, 0);\n     }\n   else\n     {\n@@ -1074,14 +1080,14 @@ try_peel_loop (struct loop *loop,\n     }\n   if (loop->any_upper_bound)\n     {\n-      if (wi::ltu_p (npeel, loop->nb_iterations_estimate))\n+      if (wi::ltu_p (npeel, loop->nb_iterations_upper_bound))\n         loop->nb_iterations_upper_bound -= npeel;\n       else\n         loop->nb_iterations_upper_bound = 0;\n     }\n   if (loop->any_likely_upper_bound)\n     {\n-      if (wi::ltu_p (npeel, loop->nb_iterations_estimate))\n+      if (wi::ltu_p (npeel, loop->nb_iterations_likely_upper_bound))\n \tloop->nb_iterations_likely_upper_bound -= npeel;\n       else\n \t{\n@@ -1107,6 +1113,7 @@ try_peel_loop (struct loop *loop,\n   else if (loop->header->frequency)\n     scale = RDIV (entry_freq * REG_BR_PROB_BASE, loop->header->frequency);\n   scale_loop_profile (loop, scale, 0);\n+  bitmap_set_bit (peeled_loops, loop->num);\n   return true;\n }\n /* Adds a canonical induction variable to LOOP if suitable.\n@@ -1519,9 +1526,20 @@ pass_complete_unroll::execute (function *fun)\n   if (number_of_loops (fun) <= 1)\n     return 0;\n \n-  return tree_unroll_loops_completely (flag_unroll_loops\n-\t\t\t\t       || flag_peel_loops\n-\t\t\t\t       || optimize >= 3, true);\n+  /* If we ever decide to run loop peeling more than once, we will need to\n+     track loops already peeled in loop structures themselves to avoid\n+     re-peeling the same loop multiple times.  */\n+  if (flag_peel_loops)\n+    peeled_loops = BITMAP_ALLOC (NULL);\n+  int val = tree_unroll_loops_completely (flag_unroll_loops\n+\t\t\t\t\t  || flag_peel_loops\n+\t\t\t\t\t  || optimize >= 3, true);\n+  if (peeled_loops)\n+    {\n+      BITMAP_FREE (peeled_loops);\n+      peeled_loops = NULL;\n+    }\n+  return val;\n }\n \n } // anon namespace"}]}