{"sha": "eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkYTU1Yjk2ZTY0YTFhMWU0YTM0MDRiNDc2YjNkM2Q4N2NjNTk2Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-10-27T22:55:59Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-10-27T22:55:59Z"}, "message": "bb-reorder.c (find_traces_1_round): Fix off-by-one index.\n\n\t* bb-reorder.c (find_traces_1_round): Fix off-by-one index.\n\tMove comment around.  Do not reset best_edge for a copiable\n\tdestination if the copy would cause a partition change.\n\t(better_edge_p): Remove redundant check.\n\nFrom-SVN: r254188", "tree": {"sha": "1dda6ae9f1e1af4129bd2bc3bd46cb3ccbc13713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dda6ae9f1e1af4129bd2bc3bd46cb3ccbc13713"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/comments", "author": null, "committer": null, "parents": [{"sha": "a3123cd86744bf7de1ee3a160f58824fd741a859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3123cd86744bf7de1ee3a160f58824fd741a859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3123cd86744bf7de1ee3a160f58824fd741a859"}], "stats": {"total": 133, "additions": 114, "deletions": 19}, "files": [{"sha": "b1b14be82780cc0384424d231a3707377144bf43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "patch": "@@ -1,3 +1,10 @@\n+2017-10-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* bb-reorder.c (find_traces_1_round): Fix off-by-one index.\n+\tMove comment around.  Do not reset best_edge for a copiable\n+\tdestination if the copy would cause a partition change.\n+\t(better_edge_p): Remove redundant check.\n+\n 2017-10-27  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386-protos.h (ix86_fp_compare_mode): Remove prototype."}, {"sha": "cd9595200eb6c1864489067a3ad866625e4f1cb1", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "patch": "@@ -529,7 +529,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t  if (dump_file)\n \t    fprintf (dump_file, \"Basic block %d was visited in trace %d\\n\",\n-\t\t     bb->index, *n_traces - 1);\n+\t\t     bb->index, *n_traces);\n \n \t  ends_in_call = block_ends_with_call_p (bb);\n \n@@ -545,6 +545,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  && bb_visited_trace (e->dest) != *n_traces)\n \t\tcontinue;\n \n+\t      /* If partitioning hot/cold basic blocks, don't consider edges\n+\t\t that cross section boundaries.  */\n \t      if (BB_PARTITION (e->dest) != BB_PARTITION (bb))\n \t\tcontinue;\n \n@@ -574,9 +576,6 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t      || e->count () < count_th) && (!for_size)))\n \t\tcontinue;\n \n-\t      /* If partitioning hot/cold basic blocks, don't consider edges\n-\t\t that cross section boundaries.  */\n-\n \t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq,\n \t\t\t\t best_edge))\n \t\t{\n@@ -586,12 +585,28 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t}\n \t    }\n \n-\t  /* If the best destination has multiple predecessors, and can be\n-\t     duplicated cheaper than a jump, don't allow it to be added\n-\t     to a trace.  We'll duplicate it when connecting traces.  */\n-\t  if (best_edge && EDGE_COUNT (best_edge->dest->preds) >= 2\n+\t  /* If the best destination has multiple predecessors and can be\n+\t     duplicated cheaper than a jump, don't allow it to be added to\n+\t     a trace; we'll duplicate it when connecting the traces later.\n+\t     However, we need to check that this duplication wouldn't leave\n+\t     the best destination with only crossing predecessors, because\n+\t     this would change its effective partition from hot to cold.  */\n+\t  if (best_edge\n+\t      && EDGE_COUNT (best_edge->dest->preds) >= 2\n \t      && copy_bb_p (best_edge->dest, 0))\n-\t    best_edge = NULL;\n+\t    {\n+\t      bool only_crossing_preds = true;\n+\t      edge e;\n+\t      edge_iterator ei;\n+\t      FOR_EACH_EDGE (e, ei, best_edge->dest->preds)\n+\t\tif (e != best_edge && !(e->flags & EDGE_CROSSING))\n+\t\t  {\n+\t\t    only_crossing_preds = false;\n+\t\t    break;\n+\t\t  }\n+\t      if (!only_crossing_preds)\n+\t\tbest_edge = NULL;\n+\t    }\n \n \t  /* If the best destination has multiple successors or predecessors,\n \t     don't allow it to be added when optimizing for size.  This makes\n@@ -988,16 +1003,6 @@ better_edge_p (const_basic_block bb, const_edge e, profile_probability prob,\n   else\n     is_better_edge = false;\n \n-  /* If we are doing hot/cold partitioning, make sure that we always favor\n-     non-crossing edges over crossing edges.  */\n-\n-  if (!is_better_edge\n-      && flag_reorder_blocks_and_partition\n-      && cur_best_edge\n-      && (cur_best_edge->flags & EDGE_CROSSING)\n-      && !(e->flags & EDGE_CROSSING))\n-    is_better_edge = true;\n-\n   return is_better_edge;\n }\n "}, {"sha": "58da3bbde1d556f43ac95ae1173475ebeaf5e20c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "patch": "@@ -1,3 +1,7 @@\n+2017-10-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt68.ad[sb]: New test.\n+\n 2017-10-27  Daniel Santos  <daniel.santos@pobox.com>\n \n \t* gcc.target/i386/pr82196-1.c (dg-options): Add -mno-avx."}, {"sha": "caf6b713996bc65f9784ed5d7faf482c379a196e", "filename": "gcc/testsuite/gnat.dg/opt68.adb", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Ftestsuite%2Fgnat.dg%2Fopt68.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Ftestsuite%2Fgnat.dg%2Fopt68.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt68.adb?ref=eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "patch": "@@ -0,0 +1,53 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O3\" }\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package body Opt68 is\n+\n+  procedure Free\n+    is new Ada.Unchecked_Deallocation (Queue_Element, A_Queue_Element);\n+\n+  procedure Copy (dest : in out Queue; src : Queue) is\n+    d, s, pd, ps, t : A_Queue_Element;\n+  begin\n+    if src.sz /= 0 then\n+      d := dest.front;\n+      s := src.front;\n+      while d /= null and s /= null loop\n+        d.value := s.value;\n+        pd := d;\n+        ps := s;\n+        d  := d.next;\n+        s  := s.next;\n+      end loop;\n+      if src.sz = dest.sz then\n+        return;\n+      elsif s = null then\n+        while d /= null loop\n+          t := d.next;\n+          Free (d);\n+          d := t;\n+        end loop;\n+        dest.back      := pd;\n+        dest.back.next := null;\n+      else\n+        if pd = null then\n+          dest.front       := new Queue_Element;\n+          dest.front.value := s.value;\n+          s                := s.next;\n+          pd               := dest.front;\n+        end if;\n+        while s /= null loop\n+          pd.next       := new Queue_Element;\n+          pd.next.value := s.value;\n+          pd            := pd.next;\n+          s             := s.next;\n+        end loop;\n+        dest.back := pd;\n+      end if;\n+      dest.sz := src.sz;\n+    end if;\n+  end;\n+\n+end Opt68;"}, {"sha": "25e28a50d7b599a7cf97c7fe39c6cd35a647e2ec", "filename": "gcc/testsuite/gnat.dg/opt68.ads", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Ftestsuite%2Fgnat.dg%2Fopt68.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eada55b96e64a1a1e4a3404b476b3d3d87cc5962/gcc%2Ftestsuite%2Fgnat.dg%2Fopt68.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt68.ads?ref=eada55b96e64a1a1e4a3404b476b3d3d87cc5962", "patch": "@@ -0,0 +1,26 @@\n+with Ada.Finalization;\n+\n+package Opt68 is\n+\n+  type Cont is new Ada.Finalization.Controlled with null record;\n+\n+  type Element is record\n+    C : Cont;\n+  end record;\n+\n+  type Queue_Element;\n+  type A_Queue_Element is access Queue_Element;\n+  type Queue_Element is record\n+    Value : Element;\n+    Next  : A_Queue_Element;\n+  end record;\n+\n+  type Queue is limited record\n+    Sz    : Natural;\n+    Front : A_Queue_Element;\n+    Back  : A_Queue_Element;\n+  end record;\n+\n+  procedure Copy (dest : in out Queue; src : Queue);\n+\n+end Opt68;"}]}