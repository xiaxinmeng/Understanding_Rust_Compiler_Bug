{"sha": "603a4ad49978d2a967a1996ac626531200553715", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAzYTRhZDQ5OTc4ZDJhOTY3YTE5OTZhYzYyNjUzMTIwMDU1MzcxNQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-09-14T09:01:21Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-09-14T09:01:21Z"}, "message": "Consider doloop IV in IVOPTs\n\n   For the targets supporting low-overhead loops, IVOPTs has to take care of\n   the loops which will probably be transformed in RTL doloop optimization,\n   to try to make selected IV candidate set optimal.  The process of doloop\n   support includes:\n\n   1) Analyze the current loop will be transformed to doloop or not, find and\n      mark its compare type IV use as doloop use (iv_group field doloop_p), and\n      set flag doloop_use_p of ivopts_data to notify subsequent processings on\n      doloop.  See analyze_and_mark_doloop_use and its callees for the details.\n      The target hook predict_doloop_p can be used for target specific checks.\n\n   2) Add one doloop dedicated IV cand {(may_be_zero ? 1 : (niter + 1)), +, -1},\n      set flag doloop_p of iv_cand, step cost is set as zero and no extra cost\n      like biv.  For cost determination between doloop IV cand and IV use, the\n      target hooks doloop_cost_for_generic and doloop_cost_for_address are\n      provided to add on extra costs for generic type and address type IV use.\n      Zero cost is assigned to the pair between doloop IV cand and doloop IV\n      use, and bound zero is set for IV elimination.\n\n   3) With the cost setting in step 2), the current cost model based IV\n      selection algorithm will process as usual, pick up doloop dedicated IV if\n      profitable.\n\ngcc/ChangeLog\n\n2019-09-14  Kewen Lin  <linkw@gcc.gnu.org>\n\n    PR middle-end/80791\n    * config/rs6000/rs6000.c (TARGET_HAVE_COUNT_REG_DECR_P): New macro.\n    (TARGET_DOLOOP_COST_FOR_GENERIC): Likewise.\n    (TARGET_DOLOOP_COST_FOR_ADDRESS): Likewise.\n    * target.def (have_count_reg_decr_p): New hook.\n    (doloop_cost_for_generic): Likewise.\n    (doloop_cost_for_address): Likewise.\n    * doc/tm.texi.in (TARGET_HAVE_COUNT_REG_DECR_P): Likewise.\n    (TARGET_DOLOOP_COST_FOR_GENERIC): Likewise.\n    (TARGET_DOLOOP_COST_FOR_ADDRESS): Likewise.\n    * doc/tm.texi: Regenerate.\n    * tree-ssa-loop-ivopts.c (comp_cost::operator+=): Consider infinite cost\n    addend.\n    (record_group): Init doloop_p.\n    (add_candidate_1): Add optional argument doloop, change the handlings\n    accordingly.\n    (add_candidate): Likewise.\n    (generic_predict_doloop_p): Update attribute.\n    (force_expr_to_var_cost): Add costing for expressions COND_EXPR/LT_EXPR/\n    LE_EXPR/GT_EXPR/GE_EXPR/EQ_EXPR/NE_EXPR/UNORDERED_EXPR/ORDERED_EXPR/\n    UNLT_EXPR/UNLE_EXPR/UNGT_EXPR/UNGE_EXPR/UNEQ_EXPR/LTGT_EXPR/MAX_EXPR/\n    MIN_EXPR.\n    (get_computation_cost): Update for doloop IV cand extra cost.    \n    (determine_group_iv_cost_cond): Update for doloop IV cand.\n    (determine_iv_cost): Likewise.\n    (ivopts_estimate_reg_pressure): Likewise.\n    (may_eliminate_iv): Update handlings for doloop IV cand.\n    (add_iv_candidate_for_doloop): New function.\n    (find_iv_candidates): Call function add_iv_candidate_for_doloop.\n    (iv_ca_set_no_cp): Update for doloop IV cand.\n    (iv_ca_set_cp): Likewise.\n    (iv_ca_dump): Dump register cost.\n    (find_doloop_use): New function.\n    (analyze_and_mark_doloop_use): Likewise.\n    (tree_ssa_iv_optimize_loop): Call function analyze_and_mark_doloop_use.\n\ngcc/testsuite/ChangeLog\n\n2019-09-14  Kewen Lin  <linkw@gcc.gnu.org>\n\n    PR middle-end/80791\n    * gcc.dg/tree-ssa/ivopts-3.c: Adjust for doloop change.\n    * gcc.dg/tree-ssa/ivopts-lt.c: Likewise.\n    * gcc.dg/tree-ssa/pr32044.c: Likewise.\n\nFrom-SVN: r275713", "tree": {"sha": "4cee5f4426954435348cd0b29cd6f982a463318a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cee5f4426954435348cd0b29cd6f982a463318a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/603a4ad49978d2a967a1996ac626531200553715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/603a4ad49978d2a967a1996ac626531200553715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/603a4ad49978d2a967a1996ac626531200553715", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/603a4ad49978d2a967a1996ac626531200553715/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3898644854c846c3d28d6b2300bf40283d88c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3898644854c846c3d28d6b2300bf40283d88c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3898644854c846c3d28d6b2300bf40283d88c94"}], "stats": {"total": 426, "additions": 400, "deletions": 26}, "files": [{"sha": "41cf9267c95dd265352d1ea909942a5455a6d754", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -1,3 +1,41 @@\n+2019-09-14  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR middle-end/80791\n+\t* config/rs6000/rs6000.c (TARGET_HAVE_COUNT_REG_DECR_P): New macro.\n+\t(TARGET_DOLOOP_COST_FOR_GENERIC): Likewise.\n+\t(TARGET_DOLOOP_COST_FOR_ADDRESS): Likewise.\n+\t* target.def (have_count_reg_decr_p): New hook.\n+\t(doloop_cost_for_generic): Likewise.\n+\t(doloop_cost_for_address): Likewise.\n+\t* doc/tm.texi.in (TARGET_HAVE_COUNT_REG_DECR_P): Likewise.\n+\t(TARGET_DOLOOP_COST_FOR_GENERIC): Likewise.\n+\t(TARGET_DOLOOP_COST_FOR_ADDRESS): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* tree-ssa-loop-ivopts.c (comp_cost::operator+=): Consider infinite cost\n+\taddend.\n+\t(record_group): Init doloop_p.\n+\t(add_candidate_1): Add optional argument doloop, change the handlings\n+\taccordingly.\n+\t(add_candidate): Likewise.\n+\t(generic_predict_doloop_p): Update attribute.\n+\t(force_expr_to_var_cost): Add costing for expressions COND_EXPR/LT_EXPR/\n+\tLE_EXPR/GT_EXPR/GE_EXPR/EQ_EXPR/NE_EXPR/UNORDERED_EXPR/ORDERED_EXPR/\n+\tUNLT_EXPR/UNLE_EXPR/UNGT_EXPR/UNGE_EXPR/UNEQ_EXPR/LTGT_EXPR/MAX_EXPR/\n+\tMIN_EXPR.\n+\t(get_computation_cost): Update for doloop IV cand extra cost.\n+\t(determine_group_iv_cost_cond): Update for doloop IV cand.\n+\t(determine_iv_cost): Likewise.\n+\t(ivopts_estimate_reg_pressure): Likewise.\n+\t(may_eliminate_iv): Update handlings for doloop IV cand.\n+\t(add_iv_candidate_for_doloop): New function.\n+\t(find_iv_candidates): Call function add_iv_candidate_for_doloop.\n+\t(iv_ca_set_no_cp): Update for doloop IV cand.\n+\t(iv_ca_set_cp): Likewise.\n+\t(iv_ca_dump): Dump register cost.\n+\t(find_doloop_use): New function.\n+\t(analyze_and_mark_doloop_use): Likewise.\n+\t(tree_ssa_iv_optimize_loop): Call function analyze_and_mark_doloop_use.\n+\n 2019-09-13  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR middle-end/91708"}, {"sha": "c2834bdcfe6e8cd9183a21ef519c501eb493582d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -1651,6 +1651,16 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_PREDICT_DOLOOP_P\n #define TARGET_PREDICT_DOLOOP_P rs6000_predict_doloop_p\n \n+#undef TARGET_HAVE_COUNT_REG_DECR_P\n+#define TARGET_HAVE_COUNT_REG_DECR_P true\n+\n+/* 1000000000 is infinite cost in IVOPTs.  */\n+#undef TARGET_DOLOOP_COST_FOR_GENERIC\n+#define TARGET_DOLOOP_COST_FOR_GENERIC 1000000000\n+\n+#undef TARGET_DOLOOP_COST_FOR_ADDRESS\n+#define TARGET_DOLOOP_COST_FOR_ADDRESS 1000000000\n+\n #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV rs6000_atomic_assign_expand_fenv\n "}, {"sha": "0250cf58e72b4df8fec19cfb4399ed0e2594342b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -11615,6 +11615,36 @@ loops, and will help ivopts to make some decisions.\n The default version of this hook returns false.\n @end deftypefn\n \n+@deftypevr {Target Hook} bool TARGET_HAVE_COUNT_REG_DECR_P\n+Return true if the target supports hardware count register for decrement\n+and branch.\n+The default value is false.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} int64_t TARGET_DOLOOP_COST_FOR_GENERIC\n+One IV candidate dedicated for doloop is introduced in IVOPTs, we can\n+calculate the computation cost of adopting it to any generic IV use by\n+function get_computation_cost as before.  But for targets which have\n+hardware count register support for decrement and branch, it may have to\n+move IV value from hardware count register to general purpose register\n+while doloop IV candidate is used for generic IV uses.  It probably takes\n+expensive penalty.  This hook allows target owners to define the cost for\n+this especially for generic IV uses.\n+The default value is zero.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} int64_t TARGET_DOLOOP_COST_FOR_ADDRESS\n+One IV candidate dedicated for doloop is introduced in IVOPTs, we can\n+calculate the computation cost of adopting it to any address IV use by\n+function get_computation_cost as before.  But for targets which have\n+hardware count register support for decrement and branch, it may have to\n+move IV value from hardware count register to general purpose register\n+while doloop IV candidate is used for address IV uses.  It probably takes\n+expensive penalty.  This hook allows target owners to define the cost for\n+this escpecially for address IV uses.\n+The default value is zero.\n+@end deftypevr\n+\n @deftypefn {Target Hook} bool TARGET_CAN_USE_DOLOOP_P (const widest_int @var{&iterations}, const widest_int @var{&iterations_max}, unsigned int @var{loop_depth}, bool @var{entered_at_top})\n Return true if it is possible to use low-overhead loops (@code{doloop_end}\n and @code{doloop_begin}) for a particular loop.  @var{iterations} gives the"}, {"sha": "0b77dd8eb46dc53fc585d7b3eac9805c6ed79951", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -7950,6 +7950,12 @@ to by @var{ce_info}.\n \n @hook TARGET_PREDICT_DOLOOP_P\n \n+@hook TARGET_HAVE_COUNT_REG_DECR_P\n+\n+@hook TARGET_DOLOOP_COST_FOR_GENERIC\n+\n+@hook TARGET_DOLOOP_COST_FOR_ADDRESS\n+\n @hook TARGET_CAN_USE_DOLOOP_P\n \n @hook TARGET_INVALID_WITHIN_DOLOOP"}, {"sha": "01609136848fc157a47a93a0267c03524fe9383e", "filename": "gcc/target.def", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -4225,6 +4225,39 @@ The default version of this hook returns false.\",\n  bool, (class loop *loop),\n  default_predict_doloop_p)\n \n+DEFHOOKPOD\n+(have_count_reg_decr_p,\n+ \"Return true if the target supports hardware count register for decrement\\n\\\n+and branch.\\n\\\n+The default value is false.\",\n+ bool, false)\n+\n+DEFHOOKPOD\n+(doloop_cost_for_generic,\n+ \"One IV candidate dedicated for doloop is introduced in IVOPTs, we can\\n\\\n+calculate the computation cost of adopting it to any generic IV use by\\n\\\n+function get_computation_cost as before.  But for targets which have\\n\\\n+hardware count register support for decrement and branch, it may have to\\n\\\n+move IV value from hardware count register to general purpose register\\n\\\n+while doloop IV candidate is used for generic IV uses.  It probably takes\\n\\\n+expensive penalty.  This hook allows target owners to define the cost for\\n\\\n+this especially for generic IV uses.\\n\\\n+The default value is zero.\",\n+ int64_t, 0)\n+\n+DEFHOOKPOD\n+(doloop_cost_for_address,\n+ \"One IV candidate dedicated for doloop is introduced in IVOPTs, we can\\n\\\n+calculate the computation cost of adopting it to any address IV use by\\n\\\n+function get_computation_cost as before.  But for targets which have\\n\\\n+hardware count register support for decrement and branch, it may have to\\n\\\n+move IV value from hardware count register to general purpose register\\n\\\n+while doloop IV candidate is used for address IV uses.  It probably takes\\n\\\n+expensive penalty.  This hook allows target owners to define the cost for\\n\\\n+this escpecially for address IV uses.\\n\\\n+The default value is zero.\",\n+ int64_t, 0)\n+\n DEFHOOK\n (can_use_doloop_p,\n  \"Return true if it is possible to use low-overhead loops (@code{doloop_end}\\n\\"}, {"sha": "c950a0d1f583ba7abec1c2aa73ccae6f79a5a295", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -1,3 +1,10 @@\n+2019-09-14  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR middle-end/80791\n+\t* gcc.dg/tree-ssa/ivopts-3.c: Adjust for doloop change.\n+\t* gcc.dg/tree-ssa/ivopts-lt.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr32044.c: Likewise.\n+\n 2019-09-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/91566"}, {"sha": "ce4b1d05664dee1cddc1a9d423acb11a48eb8543", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopts-3.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-3.c?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -10,4 +10,6 @@ int main (void)\n     f2 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"!= 0\" 5 \"ivopts\" } }  */\n+/* { dg-final { scan-tree-dump-times \"!= 0\" 5 \"ivopts\" { target { ! powerpc*-*-* } } } } */\n+/* More debug information emitted for doloop on powerpc.  */\n+/* { dg-final { scan-tree-dump-times \"!= 0\" 6 \"ivopts\" { target { powerpc*-*-* } } } } */"}, {"sha": "71d7f672c44d9f4cef31bd003743e02b8f9c57de", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopts-lt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-lt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-lt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-lt.c?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -17,6 +17,7 @@ f1 (char *p, uintptr_t i, uintptr_t n)\n   while (i < n);\n }\n \n-/* { dg-final { scan-tree-dump-times \"PHI\" 1 \"ivopts\" } } */\n-/* { dg-final { scan-tree-dump-times \"PHI <p_\" 1 \"ivopts\"} } */\n-/* { dg-final { scan-tree-dump-times \"p_\\[0-9\\]* <\" 1 \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-times \"PHI\" 1 \"ivopts\" { target { ! powerpc*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"PHI\" 2 \"ivopts\" { target { powerpc*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"PHI <p_\" 1 \"ivopts\" { target { ! powerpc*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"p_\\[0-9\\]* <\" 1 \"ivopts\" { target { ! powerpc*-*-* } } } } */"}, {"sha": "06c27b03fad1d704b0fff269d7353ad77803bf32", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr32044.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -1,6 +1,10 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n+/* For powerpc, disable doloop IV cand generation in IVOPTs to avoid unexpected\n+   division operation for its base setup.  */\n+/* { dg-additional-options \"-fno-branch-count-reg\" { target { powerpc*-*-* } } } */\n+\n int foo (int n)\n {\n   while (n >= 45)"}, {"sha": "4ab6d6f91f56bc6afefa6da52172dff53cd2b18e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 265, "deletions": 22, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603a4ad49978d2a967a1996ac626531200553715/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=603a4ad49978d2a967a1996ac626531200553715", "patch": "@@ -64,7 +64,30 @@ along with GCC; see the file COPYING3.  If not see\n    All of this is done loop by loop.  Doing it globally is theoretically\n    possible, it might give a better performance and it might enable us\n    to decide costs more precisely, but getting all the interactions right\n-   would be complicated.  */\n+   would be complicated.\n+\n+   For the targets supporting low-overhead loops, IVOPTs has to take care of\n+   the loops which will probably be transformed in RTL doloop optimization,\n+   to try to make selected IV candidate set optimal.  The process of doloop\n+   support includes:\n+\n+   1) Analyze the current loop will be transformed to doloop or not, find and\n+      mark its compare type IV use as doloop use (iv_group field doloop_p), and\n+      set flag doloop_use_p of ivopts_data to notify subsequent processings on\n+      doloop.  See analyze_and_mark_doloop_use and its callees for the details.\n+      The target hook predict_doloop_p can be used for target specific checks.\n+\n+   2) Add one doloop dedicated IV cand {(may_be_zero ? 1 : (niter + 1)), +, -1},\n+      set flag doloop_p of iv_cand, step cost is set as zero and no extra cost\n+      like biv.  For cost determination between doloop IV cand and IV use, the\n+      target hooks doloop_cost_for_generic and doloop_cost_for_address are\n+      provided to add on extra costs for generic type and address type IV use.\n+      Zero cost is assigned to the pair between doloop IV cand and doloop IV\n+      use, and bound zero is set for IV elimination.\n+\n+   3) With the cost setting in step 2), the current cost model based IV\n+      selection algorithm will process as usual, pick up doloop dedicated IV if\n+      profitable.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -276,6 +299,9 @@ comp_cost::operator+= (comp_cost cost)\n comp_cost\n comp_cost::operator+= (HOST_WIDE_INT c)\n {\n+  if (c >= INFTY)\n+    this->cost = INFTY;\n+\n   if (infinite_cost_p ())\n     return *this;\n \n@@ -401,6 +427,8 @@ struct iv_group\n   class cost_pair *cost_map;\n   /* The selected candidate for the group.  */\n   struct iv_cand *selected;\n+  /* To indicate this is a doloop use group.  */\n+  bool doloop_p;\n   /* Uses in the group.  */\n   vec<struct iv_use *> vuses;\n };\n@@ -441,6 +469,7 @@ struct iv_cand\n \t\t\t   be hoisted out of loop.  */\n   struct iv *orig_iv;\t/* The original iv if this cand is added from biv with\n \t\t\t   smaller type.  */\n+  bool doloop_p;\t/* Whether this is a doloop candidate.  */\n };\n \n /* Hashtable entry for common candidate derived from iv uses.  */\n@@ -618,6 +647,9 @@ struct ivopts_data\n \n   /* Whether the loop body can only be exited via single exit.  */\n   bool loop_single_exit_p;\n+\n+  /* Whether the loop has doloop comparison use.  */\n+  bool doloop_use_p;\n };\n \n /* An assignment of iv candidates to uses.  */\n@@ -1542,6 +1574,7 @@ record_group (struct ivopts_data *data, enum use_type type)\n   group->type = type;\n   group->related_cands = BITMAP_ALLOC (NULL);\n   group->vuses.create (1);\n+  group->doloop_p = false;\n \n   data->vgroups.safe_push (group);\n   return group;\n@@ -3033,10 +3066,10 @@ get_loop_invariant_expr (struct ivopts_data *data, tree inv_expr)\n    replacement of the final value of the iv by a direct computation.  */\n \n static struct iv_cand *\n-add_candidate_1 (struct ivopts_data *data,\n-\t\t tree base, tree step, bool important, enum iv_position pos,\n-\t\t struct iv_use *use, gimple *incremented_at,\n-\t\t struct iv *orig_iv = NULL)\n+add_candidate_1 (struct ivopts_data *data, tree base, tree step, bool important,\n+\t\t enum iv_position pos, struct iv_use *use,\n+\t\t gimple *incremented_at, struct iv *orig_iv = NULL,\n+\t\t bool doloop = false)\n {\n   unsigned i;\n   struct iv_cand *cand = NULL;\n@@ -3095,11 +3128,15 @@ add_candidate_1 (struct ivopts_data *data,\n       cand->pos = pos;\n       if (pos != IP_ORIGINAL)\n \t{\n-\t  cand->var_before = create_tmp_var_raw (TREE_TYPE (base), \"ivtmp\");\n+\t  if (doloop)\n+\t    cand->var_before = create_tmp_var_raw (TREE_TYPE (base), \"doloop\");\n+\t  else\n+\t    cand->var_before = create_tmp_var_raw (TREE_TYPE (base), \"ivtmp\");\n \t  cand->var_after = cand->var_before;\n \t}\n       cand->important = important;\n       cand->incremented_at = incremented_at;\n+      cand->doloop_p = doloop;\n       data->vcands.safe_push (cand);\n \n       if (!poly_int_tree_p (step))\n@@ -3132,6 +3169,7 @@ add_candidate_1 (struct ivopts_data *data,\n     }\n \n   cand->important |= important;\n+  cand->doloop_p |= doloop;\n \n   /* Relate candidate to the group for which it is added.  */\n   if (use)\n@@ -3225,14 +3263,16 @@ add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,\n    the end of loop.  */\n \n static void\n-add_candidate (struct ivopts_data *data,\n-\t       tree base, tree step, bool important, struct iv_use *use,\n-\t       struct iv *orig_iv = NULL)\n+add_candidate (struct ivopts_data *data, tree base, tree step, bool important,\n+\t       struct iv_use *use, struct iv *orig_iv = NULL,\n+\t       bool doloop = false)\n {\n   if (ip_normal_pos (data->current_loop))\n-    add_candidate_1 (data, base, step, important,\n-\t\t     IP_NORMAL, use, NULL, orig_iv);\n-  if (ip_end_pos (data->current_loop)\n+    add_candidate_1 (data, base, step, important, IP_NORMAL, use, NULL, orig_iv,\n+\t\t     doloop);\n+  /* Exclude doloop candidate here since it requires decrement then comparison\n+     and jump, the IP_END position doesn't match.  */\n+  if (!doloop && ip_end_pos (data->current_loop)\n       && allow_ip_end_pos_p (data->current_loop))\n     add_candidate_1 (data, base, step, important, IP_END, use, NULL, orig_iv);\n }\n@@ -3760,7 +3800,7 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n    Some RTL specific checks seems unable to be checked in gimple, if any new\n    checks or easy checks _are_ missing here, please add them.  */\n \n-static bool ATTRIBUTE_UNUSED\n+static bool\n generic_predict_doloop_p (struct ivopts_data *data)\n {\n   class loop *loop = data->current_loop;\n@@ -4213,6 +4253,36 @@ force_expr_to_var_cost (tree expr, bool speed)\n       STRIP_NOPS (op0);\n       op1 = NULL_TREE;\n       break;\n+    /* See add_iv_candidate_for_doloop, for doloop may_be_zero case, we\n+       introduce COND_EXPR for IV base, need to support better cost estimation\n+       for this COND_EXPR and tcc_comparison.  */\n+    case COND_EXPR:\n+      op0 = TREE_OPERAND (expr, 1);\n+      STRIP_NOPS (op0);\n+      op1 = TREE_OPERAND (expr, 2);\n+      STRIP_NOPS (op1);\n+      break;\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      op0 = TREE_OPERAND (expr, 0);\n+      STRIP_NOPS (op0);\n+      op1 = TREE_OPERAND (expr, 1);\n+      STRIP_NOPS (op1);\n+      break;\n \n     default:\n       /* Just an arbitrary value, FIXME.  */\n@@ -4294,6 +4364,35 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case RSHIFT_EXPR:\n       cost = comp_cost (add_cost (speed, mode), 0);\n       break;\n+    case COND_EXPR:\n+      op0 = TREE_OPERAND (expr, 0);\n+      STRIP_NOPS (op0);\n+      if (op0 == NULL_TREE || TREE_CODE (op0) == SSA_NAME\n+\t  || CONSTANT_CLASS_P (op0))\n+\tcost = no_cost;\n+      else\n+\tcost = force_expr_to_var_cost (op0, speed);\n+      break;\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      /* Simply use add cost for now, FIXME if there is some more accurate cost\n+\t evaluation way.  */\n+      cost = comp_cost (add_cost (speed, mode), 0);\n+      break;\n \n     default:\n       gcc_unreachable ();\n@@ -4670,7 +4769,10 @@ get_computation_cost (struct ivopts_data *data, struct iv_use *use,\n     {\n       cost = get_address_cost (data, use, cand, &aff_inv, &aff_var, ratio,\n \t\t\t       inv_vars, inv_expr, can_autoinc, speed);\n-      return get_scaled_computation_cost_at (data, at, cost);\n+      cost = get_scaled_computation_cost_at (data, at, cost);\n+      /* For doloop IV cand, add on the extra cost.  */\n+      cost += cand->doloop_p ? targetm.doloop_cost_for_address : 0;\n+      return cost;\n     }\n \n   bool simple_inv = (aff_combination_const_p (&aff_inv)\n@@ -4720,7 +4822,13 @@ get_computation_cost (struct ivopts_data *data, struct iv_use *use,\n   if (comp_inv && !integer_zerop (comp_inv))\n     cost += add_cost (speed, TYPE_MODE (utype));\n \n-  return get_scaled_computation_cost_at (data, at, cost);\n+  cost = get_scaled_computation_cost_at (data, at, cost);\n+\n+  /* For doloop IV cand, add on the extra cost.  */\n+  if (cand->doloop_p && use->type == USE_NONLINEAR_EXPR)\n+    cost += targetm.doloop_cost_for_generic;\n+\n+  return cost;\n }\n \n /* Determines cost of computing the use in GROUP with CAND in a generic\n@@ -5178,6 +5286,15 @@ may_eliminate_iv (struct ivopts_data *data,\n \t}\n     }\n \n+  /* For doloop IV cand, the bound would be zero.  It's safe whether\n+     may_be_zero set or not.  */\n+  if (cand->doloop_p)\n+    {\n+      *bound = build_int_cst (TREE_TYPE (cand->iv->base), 0);\n+      *comp = iv_elimination_compare (data, use);\n+      return true;\n+    }\n+\n   cand_value_at (loop, cand, use->stmt, desc->niter, &bnd);\n \n   *bound = fold_convert (TREE_TYPE (cand->iv->base),\n@@ -5300,6 +5417,9 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n       inv_vars = inv_vars_elim;\n       inv_vars_elim = NULL;\n       inv_expr = inv_expr_elim;\n+      /* For doloop candidate/use pair, adjust to zero cost.  */\n+      if (group->doloop_p && cand->doloop_p && elim_cost.cost > no_cost.cost)\n+\tcost = no_cost;\n     }\n   else\n     {\n@@ -5426,6 +5546,42 @@ relate_compare_use_with_all_cands (struct ivopts_data *data)\n     }\n }\n \n+/* Add one doloop dedicated IV candidate:\n+     - Base is (may_be_zero ? 1 : (niter + 1)).\n+     - Step is -1.  */\n+\n+static void\n+add_iv_candidate_for_doloop (struct ivopts_data *data)\n+{\n+  tree_niter_desc *niter_desc = niter_for_single_dom_exit (data);\n+  gcc_assert (niter_desc && niter_desc->assumptions);\n+\n+  tree niter = niter_desc->niter;\n+  tree ntype = TREE_TYPE (niter);\n+  gcc_assert (TREE_CODE (ntype) == INTEGER_TYPE);\n+\n+  tree may_be_zero = niter_desc->may_be_zero;\n+  if (may_be_zero && integer_zerop (may_be_zero))\n+    may_be_zero = NULL_TREE;\n+  if (may_be_zero)\n+    {\n+      if (COMPARISON_CLASS_P (may_be_zero))\n+\t{\n+\t  niter = fold_build3 (COND_EXPR, ntype, may_be_zero,\n+\t\t\t       build_int_cst (ntype, 0),\n+\t\t\t       rewrite_to_non_trapping_overflow (niter));\n+\t}\n+      /* Don't try to obtain the iteration count expression when may_be_zero is\n+\t integer_nonzerop (actually iteration count is one) or else.  */\n+      else\n+\treturn;\n+    }\n+\n+  tree base = fold_build2 (PLUS_EXPR, ntype, unshare_expr (niter),\n+\t\t\t   build_int_cst (ntype, 1));\n+  add_candidate (data, base, build_int_cst (ntype, -1), true, NULL, NULL, true);\n+}\n+\n /* Finds the candidates for the induction variables.  */\n \n static void\n@@ -5434,6 +5590,10 @@ find_iv_candidates (struct ivopts_data *data)\n   /* Add commonly used ivs.  */\n   add_standard_iv_candidates (data);\n \n+  /* Add doloop dedicated ivs.  */\n+  if (data->doloop_use_p)\n+    add_iv_candidate_for_doloop (data);\n+\n   /* Add old induction variables.  */\n   add_iv_candidate_for_bivs (data);\n \n@@ -5614,16 +5774,21 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n      or a const set.  */\n   if (cost_base.cost == 0)\n     cost_base.cost = COSTS_N_INSNS (1);\n-  cost_step = add_cost (data->speed, TYPE_MODE (TREE_TYPE (base)));\n-\n+  /* Doloop decrement should be considered as zero cost.  */\n+  if (cand->doloop_p)\n+    cost_step = 0;\n+  else\n+    cost_step = add_cost (data->speed, TYPE_MODE (TREE_TYPE (base)));\n   cost = cost_step + adjust_setup_cost (data, cost_base.cost);\n \n   /* Prefer the original ivs unless we may gain something by replacing it.\n      The reason is to make debugging simpler; so this is not relevant for\n      artificial ivs created by other optimization passes.  */\n-  if (cand->pos != IP_ORIGINAL\n-      || !SSA_NAME_VAR (cand->var_before)\n-      || DECL_ARTIFICIAL (SSA_NAME_VAR (cand->var_before)))\n+  if ((cand->pos != IP_ORIGINAL\n+       || !SSA_NAME_VAR (cand->var_before)\n+       || DECL_ARTIFICIAL (SSA_NAME_VAR (cand->var_before)))\n+      /* Prefer doloop as well.  */\n+      && !cand->doloop_p)\n     cost++;\n \n   /* Prefer not to insert statements into latch unless there are some\n@@ -5868,7 +6033,8 @@ iv_ca_set_no_cp (struct ivopts_data *data, class iv_ca *ivs,\n   if (ivs->n_cand_uses[cid] == 0)\n     {\n       bitmap_clear_bit (ivs->cands, cid);\n-      ivs->n_cands--;\n+      if (!cp->cand->doloop_p || !targetm.have_count_reg_decr_p)\n+\tivs->n_cands--;\n       ivs->cand_cost -= cp->cand->cost;\n       iv_ca_set_remove_invs (ivs, cp->cand->inv_vars, ivs->n_inv_var_uses);\n       iv_ca_set_remove_invs (ivs, cp->cand->inv_exprs, ivs->n_inv_expr_uses);\n@@ -5925,7 +6091,8 @@ iv_ca_set_cp (struct ivopts_data *data, class iv_ca *ivs,\n       if (ivs->n_cand_uses[cid] == 1)\n \t{\n \t  bitmap_set_bit (ivs->cands, cid);\n-\t  ivs->n_cands++;\n+\t  if (!cp->cand->doloop_p || !targetm.have_count_reg_decr_p)\n+\t    ivs->n_cands++;\n \t  ivs->cand_cost += cp->cand->cost;\n \t  iv_ca_set_add_invs (ivs, cp->cand->inv_vars, ivs->n_inv_var_uses);\n \t  iv_ca_set_add_invs (ivs, cp->cand->inv_exprs, ivs->n_inv_expr_uses);\n@@ -6170,6 +6337,8 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, class iv_ca *ivs)\n \n   fprintf (file, \"  cost: %\" PRId64 \" (complexity %d)\\n\", cost.cost,\n \t   cost.complexity);\n+  fprintf (file, \"  reg_cost: %d\\n\",\n+\t   ivopts_estimate_reg_pressure (data, ivs->n_invs, ivs->n_cands));\n   fprintf (file, \"  cand_cost: %\" PRId64 \"\\n  cand_group_cost: \"\n \t   \"%\" PRId64 \" (complexity %d)\\n\", ivs->cand_cost,\n \t   ivs->cand_use_cost.cost, ivs->cand_use_cost.complexity);\n@@ -7608,6 +7777,77 @@ determine_scaling_factor (struct ivopts_data *data, basic_block *body)\n     }\n }\n \n+/* Find doloop comparison use and set its doloop_p on if found.  */\n+\n+static bool\n+find_doloop_use (struct ivopts_data *data)\n+{\n+  struct loop *loop = data->current_loop;\n+\n+  for (unsigned i = 0; i < data->vgroups.length (); i++)\n+    {\n+      struct iv_group *group = data->vgroups[i];\n+      if (group->type == USE_COMPARE)\n+\t{\n+\t  gcc_assert (group->vuses.length () == 1);\n+\t  struct iv_use *use = group->vuses[0];\n+\t  gimple *stmt = use->stmt;\n+\t  if (gimple_code (stmt) == GIMPLE_COND)\n+\t    {\n+\t      basic_block bb = gimple_bb (stmt);\n+\t      edge true_edge, false_edge;\n+\t      extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\t      /* This comparison is used for loop latch.  Require latch is empty\n+\t\t for now.  */\n+\t      if ((loop->latch == true_edge->dest\n+\t\t   || loop->latch == false_edge->dest)\n+\t\t  && empty_block_p (loop->latch))\n+\t\t{\n+\t\t  group->doloop_p = true;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Doloop cmp iv use: \");\n+\t\t      print_gimple_stmt (dump_file, stmt, TDF_DETAILS);\n+\t\t    }\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* For the targets which support doloop, to predict whether later RTL doloop\n+   transformation will perform on this loop, further detect the doloop use and\n+   mark the flag doloop_use_p if predicted.  */\n+\n+void\n+analyze_and_mark_doloop_use (struct ivopts_data *data)\n+{\n+  data->doloop_use_p = false;\n+\n+  if (!flag_branch_on_count_reg)\n+    return;\n+\n+  if (!generic_predict_doloop_p (data))\n+    return;\n+\n+  if (find_doloop_use (data))\n+    {\n+      data->doloop_use_p = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  struct loop *loop = data->current_loop;\n+\t  fprintf (dump_file,\n+\t\t   \"Predict loop %d can perform\"\n+\t\t   \" doloop optimization later.\\n\",\n+\t\t   loop->num);\n+\t  flow_loop_dump (loop, dump_file, NULL, 1);\n+\t}\n+    }\n+}\n+\n /* Optimizes the LOOP.  Returns true if anything changed.  */\n \n static bool\n@@ -7662,6 +7902,9 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, class loop *loop,\n   /* Determine cost scaling factor for basic blocks in loop.  */\n   determine_scaling_factor (data, body);\n \n+  /* Analyze doloop possibility and mark the doloop use if predicted.  */\n+  analyze_and_mark_doloop_use (data);\n+\n   /* Finds candidates for the induction variables (item 2).  */\n   find_iv_candidates (data);\n "}]}