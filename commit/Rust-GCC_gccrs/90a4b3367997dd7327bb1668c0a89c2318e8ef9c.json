{"sha": "90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBhNGIzMzY3OTk3ZGQ3MzI3YmIxNjY4YzBhODljMjMxOGU4ZWY5Yw==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2015-05-26T09:35:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T09:35:07Z"}, "message": "inline.adb (Has_Initialized_Type): Adapt to new names.\n\n2015-05-26  Yannick Moy  <moy@adacore.com>\n\n\t* inline.adb (Has_Initialized_Type): Adapt to new names.\n\t* sem_aux.adb, sem_aux.ads (Get_Low_Bound, Number_Components,\n\tSubprogram_Body, Subprogram_Body_Entity, Subprogram_Spec,\n\tSubprogram_Specification): New query functions used in GNATprove.\n\t* sem_disp.adb, sem_disp.ads (Is_Overriding_Subprogram): New\n\tquery functions used in GNATprove.\n\t* sem_util.adb, sem_util.adso (Enclosing_Lib_Unit_Node,\n\tGet_Cursor_Type, Get_Return_Object, Get_User_Defined_Eq,\n\tIs_Double_Precision_Floating_Point_Type,\n\tIs_Single_Precision_Floating_Point_Type): New query functions\n\tused in GNATprove.\n\nFrom-SVN: r223674", "tree": {"sha": "8066afafdb2ec4a6940ea9c2e31bc092ced59858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8066afafdb2ec4a6940ea9c2e31bc092ced59858"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35fd12d80463c7e5fcc05c2128311f2f0c5b37cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fd12d80463c7e5fcc05c2128311f2f0c5b37cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35fd12d80463c7e5fcc05c2128311f2f0c5b37cc"}], "stats": {"total": 368, "additions": 328, "deletions": 40}, "files": [{"sha": "960a118b110cf7570151b822ac03f568ab4be617", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -1,3 +1,17 @@\n+2015-05-26  Yannick Moy  <moy@adacore.com>\n+\n+\t* inline.adb (Has_Initialized_Type): Adapt to new names.\n+\t* sem_aux.adb, sem_aux.ads (Get_Low_Bound, Number_Components,\n+\tSubprogram_Body, Subprogram_Body_Entity, Subprogram_Spec,\n+\tSubprogram_Specification): New query functions used in GNATprove.\n+\t* sem_disp.adb, sem_disp.ads (Is_Overriding_Subprogram): New\n+\tquery functions used in GNATprove.\n+\t* sem_util.adb, sem_util.adso (Enclosing_Lib_Unit_Node,\n+\tGet_Cursor_Type, Get_Return_Object, Get_User_Defined_Eq,\n+\tIs_Double_Precision_Floating_Point_Type,\n+\tIs_Single_Precision_Floating_Point_Type): New query functions\n+\tused in GNATprove.\n+\n 2015-05-26  Bob Duff  <duff@adacore.com>\n \n \t* s-rpc.ads (Partition_ID): Increase maximum Partition_ID to"}, {"sha": "b36ec52908e66dea73e80bb48fca841670cb0289", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -3639,7 +3639,7 @@ package body Inline is\n    --------------------------\n \n    function Has_Initialized_Type (E : Entity_Id) return Boolean is\n-      E_Body : constant Node_Id := Get_Subprogram_Body (E);\n+      E_Body : constant Node_Id := Subprogram_Body (E);\n       Decl   : Node_Id;\n \n    begin"}, {"sha": "63f74d9d63c235f629c49e5851aa10b84699ce2d", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -472,6 +472,19 @@ package body Sem_Aux is\n       end case;\n    end Get_Binary_Nkind;\n \n+   -------------------\n+   -- Get_Low_Bound --\n+   -------------------\n+\n+   function Get_Low_Bound (E : Entity_Id) return Node_Id is\n+   begin\n+      if Ekind (E) = E_String_Literal_Subtype then\n+         return String_Literal_Low_Bound (E);\n+      else\n+         return Low_Bound (Scalar_Range (E));\n+      end if;\n+   end Get_Low_Bound;\n+\n    ------------------\n    -- Get_Rep_Item --\n    ------------------\n@@ -1361,6 +1374,35 @@ package body Sem_Aux is\n       return Empty;\n    end Next_Tag_Component;\n \n+   -----------------------\n+   -- Number_Components --\n+   -----------------------\n+\n+   function Number_Components (Typ : Entity_Id) return Pos is\n+      N    : Int;\n+      Comp : Entity_Id;\n+\n+   begin\n+      N := 0;\n+\n+      --  We do not call Einfo.First_Component_Or_Discriminant, as this\n+      --  function does not skip completely hidden discriminants, which we\n+      --  want to skip here.\n+\n+      if Has_Discriminants (Typ) then\n+         Comp := First_Discriminant (Typ);\n+      else\n+         Comp := First_Component (Typ);\n+      end if;\n+\n+      while Present (Comp) loop\n+         N := N + 1;\n+         Comp := Next_Component_Or_Discriminant (Comp);\n+      end loop;\n+\n+      return N;\n+   end Number_Components;\n+\n    --------------------------\n    -- Number_Discriminants --\n    --------------------------\n@@ -1419,6 +1461,97 @@ package body Sem_Aux is\n       return N;\n    end Package_Specification;\n \n+   ---------------------\n+   -- Subprogram_Body --\n+   ---------------------\n+\n+   function Subprogram_Body (E : Entity_Id) return Node_Id is\n+      Body_E : constant Entity_Id := Subprogram_Body_Entity (E);\n+\n+   begin\n+      if No (Body_E) then\n+         return Empty;\n+      else\n+         return Parent (Subprogram_Specification (Body_E));\n+      end if;\n+   end Subprogram_Body;\n+\n+   ----------------------------\n+   -- Subprogram_Body_Entity --\n+   ----------------------------\n+\n+   function Subprogram_Body_Entity (E : Entity_Id) return Entity_Id is\n+      N : Node_Id;\n+\n+   begin\n+      --  Retrieve the declaration for E\n+\n+      N := Parent (Subprogram_Specification (E));\n+\n+      --  If this declaration is not a subprogram body, then it must be a\n+      --  subprogram declaration, from which we can retrieve the entity for\n+      --  the corresponding subprogram body if any.\n+\n+      if Nkind (N) = N_Subprogram_Body then\n+         return E;\n+      else\n+         return Corresponding_Body (N);\n+      end if;\n+   end Subprogram_Body_Entity;\n+\n+   ---------------------\n+   -- Subprogram_Spec --\n+   ---------------------\n+\n+   function Subprogram_Spec (E : Entity_Id) return Node_Id is\n+      N : Node_Id;\n+\n+   begin\n+      --  Retrieve the declaration for E\n+\n+      N := Parent (Subprogram_Specification (E));\n+\n+      --  This declaration is either subprogram declaration or a subprogram\n+      --  body, in which case return Empty.\n+\n+      if Nkind (N) = N_Subprogram_Declaration then\n+         return N;\n+      else\n+         return Empty;\n+      end if;\n+   end Subprogram_Spec;\n+\n+   ------------------------------\n+   -- Subprogram_Specification --\n+   ------------------------------\n+\n+   function Subprogram_Specification (E : Entity_Id) return Node_Id is\n+      N : Node_Id;\n+\n+   begin\n+      N := Parent (E);\n+\n+      if Nkind (N) = N_Defining_Program_Unit_Name then\n+         N := Parent (N);\n+      end if;\n+\n+      --  If the Parent pointer of E is not a subprogram specification node\n+      --  (going through an intermediate N_Defining_Program_Unit_Name node\n+      --  for subprogram units), then E is an inherited operation. Its parent\n+      --  points to the type derivation that produces the inheritance: that's\n+      --  the node that generates the subprogram specification. Its alias\n+      --  is the parent subprogram, and that one points to a subprogram\n+      --  declaration, or to another type declaration if this is a hierarchy\n+      --  of derivations.\n+\n+      if Nkind (N) not in N_Subprogram_Specification then\n+         pragma Assert (Present (Alias (E)));\n+         N := Subprogram_Specification (Alias (E));\n+      end if;\n+\n+      return N;\n+   end Subprogram_Specification;\n+\n    ---------------\n    -- Tree_Read --\n    ---------------"}, {"sha": "e3117f253f40fd21515c611f7de783c0d7cfe8b9", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -158,6 +158,9 @@ package Sem_Aux is\n    --  referencing this entity. It is an error to call this function if Ekind\n    --  (Op) /= E_Operator.\n \n+   function Get_Low_Bound (E : Entity_Id) return Node_Id;\n+   --  For an index subtype or string literal subtype, return its low bound\n+\n    function Get_Unary_Nkind (Op : Entity_Id) return Node_Kind;\n    --  Op must be an entity with an Ekind of E_Operator. This function returns\n    --  the Nkind value that would be used to construct a unary operator node\n@@ -369,6 +372,10 @@ package Sem_Aux is\n    --  The result returned is the next _Tag field in this record, or Empty\n    --  if this is the last such field.\n \n+   function Number_Components (Typ : Entity_Id) return Pos;\n+   --  Typ is a record type, yields number of components (including\n+   --  discriminants) in type.\n+\n    function Number_Discriminants (Typ : Entity_Id) return Pos;\n    --  Typ is a type with discriminants, yields number of discriminants in type\n \n@@ -381,6 +388,30 @@ package Sem_Aux is\n    --  derived type, and the subtype is not an unconstrained array subtype\n    --  (RM 3.3(23.10/3)).\n \n+   function Package_Specification (Pack_Id : Entity_Id) return Node_Id;\n+   --  Given an entity for a package or generic package, return corresponding\n+   --  package specification. Simplifies handling of child units, and better\n+   --  than the old idiom: Specification (Unit_Declaration_Node (Pack_Id)).\n+\n+   function Subprogram_Body (E : Entity_Id) return Node_Id;\n+   --  Given an entity for a subprogram (spec or body), return the\n+   --  corresponding subprogram body if any, or else Empty.\n+\n+   function Subprogram_Body_Entity (E : Entity_Id) return Entity_Id;\n+   --  Given an entity for a subprogram (spec or body), return the entity\n+   --  corresponding to the subprogram body, which may be the same as E or\n+   --  Empty if no body is available.\n+\n+   function Subprogram_Spec (E : Entity_Id) return Node_Id;\n+   --  Given an entity for a subprogram spec, return the corresponding\n+   --  subprogram spec if any, or else Empty.\n+\n+   function Subprogram_Specification (E : Entity_Id) return Node_Id;\n+   --  Given an entity for a subprogram, return the corresponding subprogram\n+   --  specification. If the entity is an inherited subprogram without\n+   --  specification itself, return the specification of the inherited\n+   --  subprogram.\n+\n    function Ultimate_Alias (Prim : Entity_Id) return Entity_Id;\n    pragma Inline (Ultimate_Alias);\n    --  Return the last entity in the chain of aliased entities of Prim. If Prim\n@@ -393,9 +424,4 @@ package Sem_Aux is\n    --  it returns the subprogram, task or protected body node for it. The unit\n    --  may be a child unit with any number of ancestors.\n \n-   function Package_Specification (Pack_Id : Entity_Id) return Node_Id;\n-   --  Given an entity for a package or generic package, return corresponding\n-   --  package specification. Simplifies handling of child units, and better\n-   --  than the old idiom: Specification (Unit_Declaration_Node (Pack_Id)).\n-\n end Sem_Aux;"}, {"sha": "52eda74da9b72e09e572f2c3688fe3f7646bad39", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -2239,6 +2239,16 @@ package body Sem_Disp is\n       end if;\n    end Is_Inherited_Public_Operation;\n \n+   ------------------------------\n+   -- Is_Overriding_Subprogram --\n+   ------------------------------\n+\n+   function Is_Overriding_Subprogram (E : Entity_Id) return Boolean is\n+      Inherited : constant Subprogram_List := Inherited_Subprograms (E);\n+   begin\n+      return Inherited'Length > 0;\n+   end Is_Overriding_Subprogram;\n+\n    --------------------------\n    -- Is_Tag_Indeterminate --\n    --------------------------"}, {"sha": "d2aa620ddb78fc32af39f4e64477942eebe5d7b3", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -129,6 +129,9 @@ package Sem_Disp is\n    function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean;\n    --  Returns True if E is a null procedure that is an interface primitive\n \n+   function Is_Overriding_Subprogram (E : Entity_Id) return Boolean;\n+   --  Returns True if E is an overriding subprogram\n+\n    function Is_Tag_Indeterminate (N : Node_Id) return Boolean;\n    --  Returns true if the expression N is tag-indeterminate. An expression\n    --  is tag-indeterminate if it is a call that dispatches on result, and all"}, {"sha": "99bf2bab0304cfb265b54e8f72cf17b0aa385bea", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 92, "deletions": 23, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -5674,6 +5674,25 @@ package body Sem_Util is\n       end if;\n    end Enclosing_Comp_Unit_Node;\n \n+   -----------------------------\n+   -- Enclosing_Lib_Unit_Node --\n+   -----------------------------\n+\n+   function Enclosing_Lib_Unit_Node (N : Node_Id) return Node_Id is\n+      Encl_Unit : Node_Id;\n+\n+   begin\n+      Encl_Unit := Enclosing_Comp_Unit_Node (N);\n+\n+      while Present (Encl_Unit)\n+        and then Nkind (Unit (Encl_Unit)) = N_Subunit\n+      loop\n+         Encl_Unit := Library_Unit (Encl_Unit);\n+      end loop;\n+\n+      return Encl_Unit;\n+   end Enclosing_Lib_Unit_Node;\n+\n    --------------------------\n    -- Enclosing_CPP_Parent --\n    --------------------------\n@@ -7417,6 +7436,11 @@ package body Sem_Util is\n       return Cursor;\n    end Get_Cursor_Type;\n \n+   function Get_Cursor_Type (Typ : Entity_Id) return Entity_Id is\n+   begin\n+      return Etype (Get_Iterable_Type_Primitive (Typ, Name_First));\n+   end Get_Cursor_Type;\n+\n    -------------------------------\n    -- Get_Default_External_Name --\n    -------------------------------\n@@ -7771,34 +7795,24 @@ package body Sem_Util is\n       return R;\n    end Get_Renamed_Entity;\n \n-   -------------------------\n-   -- Get_Subprogram_Body --\n-   -------------------------\n+   -----------------------\n+   -- Get_Return_Object --\n+   -----------------------\n \n-   function Get_Subprogram_Body (E : Entity_Id) return Node_Id is\n+   function Get_Return_Object (N : Node_Id) return Entity_Id is\n       Decl : Node_Id;\n \n    begin\n-      Decl := Unit_Declaration_Node (E);\n-\n-      if Nkind (Decl) = N_Subprogram_Body then\n-         return Decl;\n-\n-      --  The below comment is bad, because it is possible for\n-      --  Nkind (Decl) to be an N_Subprogram_Body_Stub ???\n-\n-      else           --  Nkind (Decl) = N_Subprogram_Declaration\n-\n-         if Present (Corresponding_Body (Decl)) then\n-            return Unit_Declaration_Node (Corresponding_Body (Decl));\n-\n-         --  Imported subprogram case\n+      Decl := First (Return_Object_Declarations (N));\n+      while Present (Decl) loop\n+         exit when Nkind (Decl) = N_Object_Declaration\n+           and then Is_Return_Object (Defining_Identifier (Decl));\n+         Next (Decl);\n+      end loop;\n \n-         else\n-            return Empty;\n-         end if;\n-      end if;\n-   end Get_Subprogram_Body;\n+      pragma Assert (Present (Decl));\n+      return Defining_Identifier (Decl);\n+   end Get_Return_Object;\n \n    ---------------------------\n    -- Get_Subprogram_Entity --\n@@ -7878,6 +7892,33 @@ package body Sem_Util is\n       return Task_Body_Procedure (Underlying_Type (Root_Type (E)));\n    end Get_Task_Body_Procedure;\n \n+   -------------------------\n+   -- Get_User_Defined_Eq --\n+   -------------------------\n+\n+   function Get_User_Defined_Eq (E : Entity_Id) return Entity_Id is\n+      Prim : Elmt_Id;\n+      Op   : Entity_Id;\n+\n+   begin\n+      Prim := First_Elmt (Collect_Primitive_Operations (E));\n+      while Present (Prim) loop\n+         Op := Node (Prim);\n+\n+         if Chars (Op) = Name_Op_Eq\n+           and then Etype (Op) = Standard_Boolean\n+           and then Etype (First_Formal (Op)) = E\n+           and then Etype (Next_Formal (First_Formal (Op))) = E\n+         then\n+            return Op;\n+         end if;\n+\n+         Next_Elmt (Prim);\n+      end loop;\n+\n+      return Empty;\n+   end Get_User_Defined_Eq;\n+\n    -----------------------\n    -- Has_Access_Values --\n    -----------------------\n@@ -11242,6 +11283,20 @@ package body Sem_Util is\n       end if;\n    end Is_Descendent_Of;\n \n+   ---------------------------------------------\n+   -- Is_Double_Precision_Floating_Point_Type --\n+   ---------------------------------------------\n+\n+   function Is_Double_Precision_Floating_Point_Type\n+     (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Floating_Point_Type (E)\n+        and then Machine_Radix_Value (E) = Uint_2\n+        and then Machine_Mantissa_Value (E) = UI_From_Int (53)\n+        and then Machine_Emax_Value (E) = Uint_2 ** Uint_10\n+        and then Machine_Emin_Value (E) = Uint_3 - (Uint_2 ** Uint_10);\n+   end Is_Double_Precision_Floating_Point_Type;\n+\n    -----------------------------\n    -- Is_Effectively_Volatile --\n    -----------------------------\n@@ -12703,6 +12758,20 @@ package body Sem_Util is\n       end if;\n    end Is_Selector_Name;\n \n+   ---------------------------------------------\n+   -- Is_Single_Precision_Floating_Point_Type --\n+   ---------------------------------------------\n+\n+   function Is_Single_Precision_Floating_Point_Type\n+     (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Floating_Point_Type (E)\n+        and then Machine_Radix_Value (E) = Uint_2\n+        and then Machine_Mantissa_Value (E) = Uint_24\n+        and then Machine_Emax_Value (E) = Uint_2 ** Uint_7\n+        and then Machine_Emin_Value (E) = Uint_3 - (Uint_2 ** Uint_7);\n+   end Is_Single_Precision_Floating_Point_Type;\n+\n    -------------------------------------\n    -- Is_SPARK_05_Initialization_Expr --\n    -------------------------------------"}, {"sha": "8394b105586c4a0ae5aab0cad54c6d7fe906ef2c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a4b3367997dd7327bb1668c0a89c2318e8ef9c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=90a4b3367997dd7327bb1668c0a89c2318e8ef9c", "patch": "@@ -529,9 +529,16 @@ package Sem_Util is\n    --  related expression evaluates to True.\n \n    function Enclosing_Comp_Unit_Node (N : Node_Id) return Node_Id;\n-   --  Returns the enclosing N_Compilation_Unit Node that is the root of a\n+   --  Returns the enclosing N_Compilation_Unit node that is the root of a\n    --  subtree containing N.\n \n+   function Enclosing_Lib_Unit_Node (N : Node_Id) return Node_Id;\n+   --  Returns the N_Compilation_Unit node of the library unit that is directly\n+   --  or indirectly (through a subunit) at the root of a subtree containing\n+   --  N. This may be either the same as Enclosing_Comp_Unit_Node, or if\n+   --  Enclosing_Comp_Unit_Node returns a subunit, then the corresponding\n+   --  library unit.\n+\n    function Enclosing_CPP_Parent (Typ : Entity_Id) return Entity_Id;\n    --  Returns the closest ancestor of Typ that is a CPP type.\n \n@@ -814,10 +821,15 @@ package Sem_Util is\n    function Get_Cursor_Type\n      (Aspect : Node_Id;\n       Typ    : Entity_Id) return Entity_Id;\n-   --  Find Cursor type in scope of formal container Typ, by locating primitive\n-   --  operation First. For use in resolving the other primitive operations\n-   --  of an Iterable type and expanding loops and quantified expressions\n-   --  over formal containers.\n+   --  Find Cursor type in scope of type Typ with Iterable aspect, by locating\n+   --  primitive operation First. For use in resolving the other primitive\n+   --  operations of an Iterable type and expanding loops and quantified\n+   --  expressions over formal containers.\n+\n+   function Get_Cursor_Type (Typ : Entity_Id) return Entity_Id;\n+   --  Find Cursor type in scope of type Typ with Iterable aspect, by locating\n+   --  primitive operation First. For use after resolving the primitive\n+   --  operations of an Iterable type.\n \n    function Get_Default_External_Name (E : Node_Or_Entity_Id) return Node_Id;\n    --  This is used to construct the string literal node representing a\n@@ -906,22 +918,25 @@ package Sem_Util is\n    --  not a renamed entity, returns its argument. It is an error to call this\n    --  with any other kind of entity.\n \n+   function Get_Return_Object (N : Node_Id) return Entity_Id;\n+   --  Given an extended return statement, return the corresponding return\n+   --  object, identified as the one for which Is_Return_Object = True.\n+\n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n    --  Nod is either a procedure call statement, or a function call, or an\n    --  accept statement node. This procedure finds the Entity_Id of the related\n    --  subprogram or entry and returns it, or if no subprogram can be found,\n    --  returns Empty.\n \n-   function Get_Subprogram_Body (E : Entity_Id) return Node_Id;\n-   --  Given the entity for a subprogram (E_Function or E_Procedure), return\n-   --  the corresponding N_Subprogram_Body node. If the corresponding body\n-   --  is missing (as for an imported subprogram), return Empty.\n-\n    function Get_Task_Body_Procedure (E : Entity_Id) return Node_Id;\n    pragma Inline (Get_Task_Body_Procedure);\n    --  Given an entity for a task type or subtype, retrieves the\n    --  Task_Body_Procedure field from the corresponding task type declaration.\n \n+   function Get_User_Defined_Eq (E : Entity_Id) return Entity_Id;\n+   --  For a type entity, return the entity of the primitive equality function\n+   --  for the type if it exists, otherwise return Empty.\n+\n    function Has_Access_Values (T : Entity_Id) return Boolean;\n    --  Returns true if type or subtype T is an access type, or has a component\n    --  (at any recursive level) that is an access type. This is a conservative\n@@ -1248,6 +1263,15 @@ package Sem_Util is\n    --  This is the RM definition, a type is a descendent of another type if it\n    --  is the same type or is derived from a descendent of the other type.\n \n+   function Is_Double_Precision_Floating_Point_Type\n+     (E : Entity_Id) return Boolean;\n+   --  Return whether E is a double precision floating point type,\n+   --  characterized by:\n+   --  . machine_radix = 2\n+   --  . machine_mantissa = 53\n+   --  . machine_emax = 2**10\n+   --  . machine_emin = 3 - machine_emax\n+\n    function Is_Effectively_Volatile (Id : Entity_Id) return Boolean;\n    --  The SPARK property \"effectively volatile\" applies to both types and\n    --  objects. To qualify as such, an entity must be either volatile or be\n@@ -1410,6 +1434,15 @@ package Sem_Util is\n    --  represent use of the N_Identifier node for a true identifier, when\n    --  normally such nodes represent a direct name.\n \n+   function Is_Single_Precision_Floating_Point_Type\n+     (E : Entity_Id) return Boolean;\n+   --  Return whether E is a single precision floating point type,\n+   --  characterized by:\n+   --  . machine_radix = 2\n+   --  . machine_mantissa = 24\n+   --  . machine_emax = 2**7\n+   --  . machine_emin = 3 - machine_emax\n+\n    function Is_SPARK_05_Initialization_Expr (N : Node_Id) return Boolean;\n    --  Determines if the tree referenced by N represents an initialization\n    --  expression in SPARK 2005, suitable for initializing an object in an"}]}