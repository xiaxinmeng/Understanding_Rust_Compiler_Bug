{"sha": "5c352a47a6d4a1a1877ff5fc9e43d42848c05e31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMzNTJhNDdhNmQ0YTFhMTg3N2ZmNWZjOWU0M2Q0Mjg0OGMwNWUzMQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-04-30T07:22:11Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-04-30T07:22:11Z"}, "message": "re PR libstdc++/5280 (Problems with named locales and iostreams (gnulocale))\n\n\n2002-04-29  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/5280\n\t* include/bits/fstream.tcc (basic_filebuf::_M_underflow_common):\n\tCheck for eof.\n\t* include/bits/streambuf_iterator.h: Match stream_iterator.h.\n\t(istreambuf_iterator::operator++): Invalidate on eof.\n\t(istreambuf_iterator::operator++(int)): Same.\n\t(istreambuf_iterator::operator*): Same.\n\nFrom-SVN: r52933", "tree": {"sha": "12723318288adeb644b70043ed0aa7df5590001f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12723318288adeb644b70043ed0aa7df5590001f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31/comments", "author": null, "committer": null, "parents": [{"sha": "775450350b352ffccc4769689077ed1694dc27ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/775450350b352ffccc4769689077ed1694dc27ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/775450350b352ffccc4769689077ed1694dc27ba"}], "stats": {"total": 185, "additions": 97, "deletions": 88}, "files": [{"sha": "76ab32d1134de3afd3026f3b3f1d4ec1e0b9e3c5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5c352a47a6d4a1a1877ff5fc9e43d42848c05e31", "patch": "@@ -1,3 +1,13 @@\n+2002-04-29  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/5280\n+\t* include/bits/fstream.tcc (basic_filebuf::_M_underflow_common):\n+\tCheck for eof.\n+\t* include/bits/streambuf_iterator.h: Match stream_iterator.h.\n+\t(istreambuf_iterator::operator++): Invalidate on eof.\n+\t(istreambuf_iterator::operator++(int)): Same.\n+\t(istreambuf_iterator::operator*): Same.\n+\t\n 2002-04-29  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* testsuite/lib/libstdc++-v3-dg.exp (libstdc++-v3-init): Set all"}, {"sha": "910209a1bf1093077155c421629e69d9d11ddb58", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=5c352a47a6d4a1a1877ff5fc9e43d42848c05e31", "patch": "@@ -227,11 +227,15 @@ namespace std\n \t  // Check for unbuffered stream.\n \t  if (_M_buf_size == 1)\n \t    {\n-\t      __ret = _M_file.sys_getc();\n-\t      *_M_in_cur = traits_type::to_char_type(__ret);\n-\t      _M_set_determinate(1);\n-\t      if (__testout)\n-\t\t_M_out_cur = _M_in_cur;\n+\t      int_type __c = _M_file.sys_getc();\n+\t      if (__c != __ret)\n+\t\t{\n+\t\t  __ret = __c;\n+\t\t  *_M_in_cur = traits_type::to_char_type(__c);\n+\t\t  _M_set_determinate(1);\n+\t\t  if (__testout)\n+\t\t    _M_out_cur = _M_in_cur;\n+\t\t}\n \t      return __ret;\n \t    }\n "}, {"sha": "f7317b2e48139eac06232718cbe4690dc3870511", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 78, "deletions": 83, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c352a47a6d4a1a1877ff5fc9e43d42848c05e31/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=5c352a47a6d4a1a1877ff5fc9e43d42848c05e31", "patch": "@@ -1,6 +1,7 @@\n // Streambuf iterators\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -41,60 +42,6 @@\n \n namespace std\n {\n-  template<typename _CharT, typename _Traits>\n-    class ostreambuf_iterator\n-    : public iterator<output_iterator_tag, void, void, void, void>\n-    {\n-    public:\n-      // Types:\n-      typedef _CharT                           char_type;\n-      typedef _Traits                          traits_type;\n-      typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n-      typedef basic_ostream<_CharT, _Traits>   ostream_type;\n-\n-    private:\n-      streambuf_type* \t_M_sbuf;\n-      bool \t\t_M_failed;\n-\n-    public:\n-      inline \n-      ostreambuf_iterator(ostream_type& __s) throw ()\n-      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n-      \n-      ostreambuf_iterator(streambuf_type* __s) throw ()\n-      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n-\n-      ostreambuf_iterator& \n-      operator=(_CharT __c);\n-\n-      ostreambuf_iterator& \n-      operator*() throw()\n-      { return *this; }\n-\n-      ostreambuf_iterator& \n-      operator++(int) throw()\n-      { return *this; }\n-\n-      ostreambuf_iterator& \n-      operator++() throw()\n-      { return *this; }\n-\n-      bool \n-      failed() const throw()\n-      { return _M_failed; }\n-    };\n-\n-  template<typename _CharT, typename _Traits>\n-    inline ostreambuf_iterator<_CharT, _Traits>&\n-    ostreambuf_iterator<_CharT, _Traits>::operator=(_CharT __c)\n-    {\n-      if (!_M_failed && \n-          _Traits::eq_int_type(_M_sbuf->sputc(__c),_Traits::eof()))\n-      _M_failed = true;\n-      return *this;\n-    }\n-\n-\n   // 24.5.3 Template class istreambuf_iterator\n   template<typename _CharT, typename _Traits>\n     class istreambuf_iterator\n@@ -117,12 +64,12 @@ namespace std\n       // the \"end of stream\" iterator value.\n       // NB: This implementation assumes the \"end of stream\" value\n       // is EOF, or -1.\n-      streambuf_type* \t\t_M_sbuf;  \n+      mutable streambuf_type* \t_M_sbuf;  \n       int_type \t\t\t_M_c;\n \n     public:\n       istreambuf_iterator() throw() \n-      : _M_sbuf(NULL), _M_c(-2) { }\n+      : _M_sbuf(0), _M_c(-2) { }\n       \n       istreambuf_iterator(istream_type& __s) throw()\n       : _M_sbuf(__s.rdbuf()), _M_c(-2) { }\n@@ -137,53 +84,48 @@ namespace std\n       operator*() const\n       { \n \t// The result of operator*() on an end of stream is undefined.\n-\tchar_type __ret;\n-\tif (_M_sbuf && _M_c != static_cast<int_type>(-2))\n-\t  __ret = _M_c;\n-\telse if (_M_sbuf)\n-\t  __ret = traits_type::to_char_type(_M_sbuf->sgetc()); \n-\telse\n-\t  __ret = static_cast<char_type>(traits_type::eof());\n-\treturn __ret;\n+\tint_type __ret = traits_type::eof();\n+\tif (_M_sbuf)\n+\t  { \n+\t    if (_M_c != static_cast<int_type>(-2))\n+\t      __ret = _M_c;\n+\t    else \n+\t      if ((__ret = _M_sbuf->sgetc()) == traits_type::eof())\n+\t\t_M_sbuf = 0;\n+\t  }\n+\treturn traits_type::to_char_type(__ret);\n       }\n \t\n       istreambuf_iterator& \n       operator++()\n       { \n-\tif (_M_sbuf)\n-\t  _M_sbuf->sbumpc();\n-\t_M_c = -2;\n+\tif (_M_sbuf && _M_sbuf->sbumpc() == traits_type::eof())\n+\t  _M_sbuf = 0;\n+\telse\n+\t  _M_c = -2;\n \treturn *this; \n       }\n \n       istreambuf_iterator\n       operator++(int)\n       {\n \tistreambuf_iterator __old = *this;\n-\tif (_M_sbuf)\n-\t  __old._M_c = _M_sbuf->sbumpc();\n-\t_M_c = -2;\n+\tif (_M_sbuf && (__old._M_c = _M_sbuf->sbumpc()) == traits_type::eof())\n+\t  _M_sbuf = 0;\n+\telse\n+\t  _M_c = -2;\n \treturn __old; \n       }\n \n-      bool \n-      equal(const istreambuf_iterator& __b)\n-      { \n-\tint_type __eof = traits_type::eof();\n-\tbool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;\n-\tbool __beof = !__b._M_sbuf || __b._M_sbuf->sgetc() == __eof;\n-\treturn (__thiseof && __beof || (!__thiseof && !__beof));\n-      }\n-\n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n       // 110 istreambuf_iterator::equal not const\n       // NB: there is also number 111 (NAD, Future) pending on this function.\n       bool \n       equal(const istreambuf_iterator& __b) const\n       {\n-\tint_type __eof = traits_type::eof();\n-\tbool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;\n-\tbool __beof = !__b._M_sbuf || __b._M_sbuf->sgetc() == __eof;\n+\tconst int_type __eof = traits_type::eof();\n+\tbool __thiseof = traits_type::eq_int_type(this->operator*(), __eof);\n+\tbool __beof = traits_type::eq_int_type(__b.operator*(), __eof);\n \treturn (__thiseof && __beof || (!__thiseof && !__beof));\n       }\n #endif\n@@ -200,5 +142,58 @@ namespace std\n     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,\n \t       const istreambuf_iterator<_CharT, _Traits>& __b)\n     { return !__a.equal(__b); }\n+\n+  template<typename _CharT, typename _Traits>\n+    class ostreambuf_iterator\n+    : public iterator<output_iterator_tag, void, void, void, void>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT                           char_type;\n+      typedef _Traits                          traits_type;\n+      typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n+      typedef basic_ostream<_CharT, _Traits>   ostream_type;\n+\n+    private:\n+      streambuf_type* \t_M_sbuf;\n+      bool \t\t_M_failed;\n+\n+    public:\n+      inline \n+      ostreambuf_iterator(ostream_type& __s) throw ()\n+      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n+      \n+      ostreambuf_iterator(streambuf_type* __s) throw ()\n+      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n+\n+      ostreambuf_iterator& \n+      operator=(_CharT __c);\n+\n+      ostreambuf_iterator& \n+      operator*() throw()\n+      { return *this; }\n+\n+      ostreambuf_iterator& \n+      operator++(int) throw()\n+      { return *this; }\n+\n+      ostreambuf_iterator& \n+      operator++() throw()\n+      { return *this; }\n+\n+      bool \n+      failed() const throw()\n+      { return _M_failed; }\n+    };\n+\n+  template<typename _CharT, typename _Traits>\n+    inline ostreambuf_iterator<_CharT, _Traits>&\n+    ostreambuf_iterator<_CharT, _Traits>::operator=(_CharT __c)\n+    {\n+      if (!_M_failed && \n+          _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))\n+\t_M_failed = true;\n+      return *this;\n+    }\n } // namespace std\n #endif"}]}