{"sha": "683e55facfd5c1d348796119424d7b3f9e889ffe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzZTU1ZmFjZmQ1YzFkMzQ4Nzk2MTE5NDI0ZDdiM2Y5ZTg4OWZmZQ==", "commit": {"author": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2020-09-27T05:27:32Z"}, "committer": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2020-09-27T05:27:32Z"}, "message": "IFN: Implement IFN_VEC_SET for ARRAY_REF with VIEW_CONVERT_EXPR\n\nThis patch enables transformation from ARRAY_REF(VIEW_CONVERT_EXPR) to\nVEC_SET internal function in gimple-isel pass if target supports\nvec_set with variable index by checking can_vec_set_var_idx_p.\n\ngcc/ChangeLog:\n\n2020-09-27  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\t* gimple-isel.cc (gimple_expand_vec_set_expr): New function.\n\t(gimple_expand_vec_cond_exprs): Rename to ...\n\t(gimple_expand_vec_exprs): ... this and call\n\tgimple_expand_vec_set_expr.\n\t* internal-fn.c (vec_set_direct): New define.\n\t(expand_vec_set_optab_fn): New function.\n\t(direct_vec_set_optab_supported_p): New define.\n\t* internal-fn.def (VEC_SET): New DEF_INTERNAL_OPTAB_FN.\n\t* optabs.c (can_vec_set_var_idx_p): New function.\n\t* optabs.h (can_vec_set_var_idx_p): New declaration.", "tree": {"sha": "182e5ca06d98352268ad98a44f900859843331ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/182e5ca06d98352268ad98a44f900859843331ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/683e55facfd5c1d348796119424d7b3f9e889ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683e55facfd5c1d348796119424d7b3f9e889ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683e55facfd5c1d348796119424d7b3f9e889ffe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683e55facfd5c1d348796119424d7b3f9e889ffe/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91dd4a3864110704c921ab8467f568ff42c38e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91dd4a3864110704c921ab8467f568ff42c38e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91dd4a3864110704c921ab8467f568ff42c38e5c"}], "stats": {"total": 143, "additions": 141, "deletions": 2}, "files": [{"sha": "b64e31fc6feff9e91a93c3eecbe3cdb7709972a6", "filename": "gcc/gimple-isel.cc", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Fgimple-isel.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Fgimple-isel.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-isel.cc?ref=683e55facfd5c1d348796119424d7b3f9e889ffe", "patch": "@@ -35,6 +35,74 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"bitmap.h\"\n #include \"tree-ssa-dce.h\"\n+#include \"memmodel.h\"\n+#include \"optabs.h\"\n+\n+/* Expand all ARRAY_REF(VIEW_CONVERT_EXPR) gimple assignments into calls to\n+   internal function based on vector type of selected expansion.\n+   i.e.:\n+     VIEW_CONVERT_EXPR<int[4]>(u)[_1] =  = i_4(D);\n+   =>\n+     _7 = u;\n+     _8 = .VEC_SET (_7, i_4(D), _1);\n+     u = _8;  */\n+\n+static gimple *\n+gimple_expand_vec_set_expr (gimple_stmt_iterator *gsi)\n+{\n+  enum tree_code code;\n+  gcall *new_stmt = NULL;\n+  gassign *ass_stmt = NULL;\n+\n+  /* Only consider code == GIMPLE_ASSIGN.  */\n+  gassign *stmt = dyn_cast<gassign *> (gsi_stmt (*gsi));\n+  if (!stmt)\n+    return NULL;\n+\n+  tree lhs = gimple_assign_lhs (stmt);\n+  code = TREE_CODE (lhs);\n+  if (code != ARRAY_REF)\n+    return NULL;\n+\n+  tree val = gimple_assign_rhs1 (stmt);\n+  tree op0 = TREE_OPERAND (lhs, 0);\n+  if (TREE_CODE (op0) == VIEW_CONVERT_EXPR && DECL_P (TREE_OPERAND (op0, 0))\n+      && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+      && TYPE_MODE (TREE_TYPE (lhs))\n+\t   == TYPE_MODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 0)))))\n+    {\n+      tree pos = TREE_OPERAND (lhs, 1);\n+      tree view_op0 = TREE_OPERAND (op0, 0);\n+      machine_mode outermode = TYPE_MODE (TREE_TYPE (view_op0));\n+      if (auto_var_in_fn_p (view_op0, cfun->decl)\n+\t  && !TREE_ADDRESSABLE (view_op0) && can_vec_set_var_idx_p (outermode))\n+\t{\n+\t  location_t loc = gimple_location (stmt);\n+\t  tree var_src = make_ssa_name (TREE_TYPE (view_op0));\n+\t  tree var_dst = make_ssa_name (TREE_TYPE (view_op0));\n+\n+\t  ass_stmt = gimple_build_assign (var_src, view_op0);\n+\t  gimple_set_vuse (ass_stmt, gimple_vuse (stmt));\n+\t  gimple_set_location (ass_stmt, loc);\n+\t  gsi_insert_before (gsi, ass_stmt, GSI_SAME_STMT);\n+\n+\t  new_stmt\n+\t    = gimple_build_call_internal (IFN_VEC_SET, 3, var_src, val, pos);\n+\t  gimple_call_set_lhs (new_stmt, var_dst);\n+\t  gimple_set_location (new_stmt, loc);\n+\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+\n+\t  ass_stmt = gimple_build_assign (view_op0, var_dst);\n+\t  gimple_set_location (ass_stmt, loc);\n+\t  gsi_insert_before (gsi, ass_stmt, GSI_SAME_STMT);\n+\n+\t  gimple_move_vops (ass_stmt, stmt);\n+\t  gsi_remove (gsi, true);\n+\t}\n+    }\n+\n+  return ass_stmt;\n+}\n \n /* Expand all VEC_COND_EXPR gimple assignments into calls to internal\n    function based on type of selected expansion.  */\n@@ -165,7 +233,7 @@ gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,\n    VEC_COND_EXPR assignments.  */\n \n static unsigned int\n-gimple_expand_vec_cond_exprs (void)\n+gimple_expand_vec_exprs (void)\n {\n   gimple_stmt_iterator gsi;\n   basic_block bb;\n@@ -178,12 +246,15 @@ gimple_expand_vec_cond_exprs (void)\n \t{\n \t  gimple *g = gimple_expand_vec_cond_expr (&gsi,\n \t\t\t\t\t\t   &vec_cond_ssa_name_uses);\n+\n \t  if (g != NULL)\n \t    {\n \t      tree lhs = gimple_assign_lhs (gsi_stmt (gsi));\n \t      gimple_set_lhs (g, lhs);\n \t      gsi_replace (&gsi, g, false);\n \t    }\n+\n+\t  gimple_expand_vec_set_expr (&gsi);\n \t}\n     }\n \n@@ -226,7 +297,7 @@ class pass_gimple_isel : public gimple_opt_pass\n \n   virtual unsigned int execute (function *)\n     {\n-      return gimple_expand_vec_cond_exprs ();\n+      return gimple_expand_vec_exprs ();\n     }\n \n }; // class pass_gimple_isel"}, {"sha": "8ea3195d31ce6b6f25430445f2679fe071773af2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=683e55facfd5c1d348796119424d7b3f9e889ffe", "patch": "@@ -115,6 +115,7 @@ init_internal_fns ()\n #define vec_condeq_direct { 0, 0, false }\n #define scatter_store_direct { 3, 1, false }\n #define len_store_direct { 3, 3, false }\n+#define vec_set_direct { 3, 3, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n #define ternary_direct { 0, 0, true }\n@@ -2658,6 +2659,45 @@ expand_vect_cond_mask_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n \n #define expand_vec_cond_mask_optab_fn expand_vect_cond_mask_optab_fn\n \n+/* Expand VEC_SET internal functions.  */\n+\n+static void\n+expand_vec_set_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree op0 = gimple_call_arg (stmt, 0);\n+  tree op1 = gimple_call_arg (stmt, 1);\n+  tree op2 = gimple_call_arg (stmt, 2);\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx src = expand_normal (op0);\n+\n+  machine_mode outermode = TYPE_MODE (TREE_TYPE (op0));\n+  scalar_mode innermode = GET_MODE_INNER (outermode);\n+\n+  rtx value = expand_normal (op1);\n+  rtx pos = expand_normal (op2);\n+\n+  class expand_operand ops[3];\n+  enum insn_code icode = optab_handler (optab, outermode);\n+\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      rtx temp = gen_reg_rtx (outermode);\n+      emit_move_insn (temp, src);\n+\n+      create_fixed_operand (&ops[0], temp);\n+      create_input_operand (&ops[1], value, innermode);\n+      create_convert_operand_from (&ops[2], pos, TYPE_MODE (TREE_TYPE (op2)),\n+\t\t\t\t   true);\n+      if (maybe_expand_insn (icode, 3, ops))\n+\t{\n+\t  emit_move_insn (target, temp);\n+\t  return;\n+\t}\n+    }\n+  gcc_unreachable ();\n+}\n+\n static void\n expand_ABNORMAL_DISPATCHER (internal_fn, gcall *)\n {\n@@ -3253,6 +3293,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_fold_left_optab_supported_p direct_optab_supported_p\n #define direct_mask_fold_left_optab_supported_p direct_optab_supported_p\n #define direct_check_ptrs_optab_supported_p direct_optab_supported_p\n+#define direct_vec_set_optab_supported_p direct_optab_supported_p\n \n /* Return the optab used by internal function FN.  */\n "}, {"sha": "e6cfe1b615988e9b5f89a383a60c539a7d5741b1", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=683e55facfd5c1d348796119424d7b3f9e889ffe", "patch": "@@ -145,6 +145,8 @@ DEF_INTERNAL_OPTAB_FN (VCONDU, 0, vcondu, vec_condu)\n DEF_INTERNAL_OPTAB_FN (VCONDEQ, 0, vcondeq, vec_condeq)\n DEF_INTERNAL_OPTAB_FN (VCOND_MASK, 0, vcond_mask, vec_cond_mask)\n \n+DEF_INTERNAL_OPTAB_FN (VEC_SET, 0, vec_set, vec_set)\n+\n DEF_INTERNAL_OPTAB_FN (LEN_STORE, 0, len_store, len_store)\n \n DEF_INTERNAL_OPTAB_FN (WHILE_ULT, ECF_CONST | ECF_NOTHROW, while_ult, while)"}, {"sha": "8e844028d929e6565c7d441c89fceaf5b953c846", "filename": "gcc/optabs.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=683e55facfd5c1d348796119424d7b3f9e889ffe", "patch": "@@ -3841,6 +3841,27 @@ can_vcond_compare_p (enum rtx_code code, machine_mode value_mode,\n \t && insn_operand_matches (icode, 3, test);\n }\n \n+/* Return whether the backend can emit vector set instructions for inserting\n+   element into vector at variable index position.  */\n+\n+bool\n+can_vec_set_var_idx_p (machine_mode vec_mode)\n+{\n+  if (!VECTOR_MODE_P (vec_mode))\n+    return false;\n+\n+  machine_mode inner_mode = GET_MODE_INNER (vec_mode);\n+  rtx reg1 = alloca_raw_REG (vec_mode, LAST_VIRTUAL_REGISTER + 1);\n+  rtx reg2 = alloca_raw_REG (inner_mode, LAST_VIRTUAL_REGISTER + 2);\n+  rtx reg3 = alloca_raw_REG (VOIDmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+  enum insn_code icode = optab_handler (vec_set_optab, vec_mode);\n+\n+  return icode != CODE_FOR_nothing && insn_operand_matches (icode, 0, reg1)\n+\t && insn_operand_matches (icode, 1, reg2)\n+\t && insn_operand_matches (icode, 2, reg3);\n+}\n+\n /* This function is called when we are going to emit a compare instruction that\n    compares the values found in X and Y, using the rtl operator COMPARISON.\n "}, {"sha": "0b14700ab3d89a29c8313a1859f365a4d4dd55b4", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e55facfd5c1d348796119424d7b3f9e889ffe/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=683e55facfd5c1d348796119424d7b3f9e889ffe", "patch": "@@ -249,6 +249,10 @@ extern int can_compare_p (enum rtx_code, machine_mode,\n    VALUE_MODE.  */\n extern bool can_vcond_compare_p (enum rtx_code, machine_mode, machine_mode);\n \n+/* Return whether the backend can emit vector set instructions for inserting\n+   element into vector at variable index position.  */\n+extern bool can_vec_set_var_idx_p (machine_mode);\n+\n extern rtx prepare_operand (enum insn_code, rtx, int, machine_mode,\n \t\t\t    machine_mode, int);\n /* Emit a pair of rtl insns to compare two rtx's and to jump"}]}