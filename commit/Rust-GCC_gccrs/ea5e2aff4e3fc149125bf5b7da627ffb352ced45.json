{"sha": "ea5e2aff4e3fc149125bf5b7da627ffb352ced45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE1ZTJhZmY0ZTNmYzE0OTEyNWJmNWI3ZGE2MjdmZmIzNTJjZWQ0NQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-07-04T14:02:19Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:18Z"}, "message": "Added MSP430 target hook (or at least provisional one)", "tree": {"sha": "45343d2b42b0163b1efd5bd63cb5d5b2c0b9c685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45343d2b42b0163b1efd5bd63cb5d5b2c0b9c685"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea5e2aff4e3fc149125bf5b7da627ffb352ced45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5e2aff4e3fc149125bf5b7da627ffb352ced45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea5e2aff4e3fc149125bf5b7da627ffb352ced45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5e2aff4e3fc149125bf5b7da627ffb352ced45/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "888c584e06447dd1b3bb8cc39aff3cf9dbfcf47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/888c584e06447dd1b3bb8cc39aff3cf9dbfcf47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/888c584e06447dd1b3bb8cc39aff3cf9dbfcf47b"}], "stats": {"total": 575, "additions": 290, "deletions": 285}, "files": [{"sha": "5d481ff2ca6a27c7711478b71b1f2e31935452c5", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 290, "deletions": 285, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea5e2aff4e3fc149125bf5b7da627ffb352ced45/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea5e2aff4e3fc149125bf5b7da627ffb352ced45/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=ea5e2aff4e3fc149125bf5b7da627ffb352ced45", "patch": "@@ -17,7 +17,6 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n-\f\n \n /* Run-time Target Specification */\n \n@@ -26,93 +25,133 @@\n extern bool msp430x;\n #endif\n \n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define (\"NO_TRAMPOLINES\");\t\\\n-      builtin_define (\"__MSP430__\"); \t\t\\\n-      builtin_define (msp430_mcu_name ());\t\\\n-      if (msp430x)\t\t\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  builtin_define (\"__MSP430X__\");\t\\\n-\t  builtin_assert (\"cpu=MSP430X\");\t\\\n-\t  if (TARGET_LARGE)\t\t\t\\\n-\t    builtin_define (\"__MSP430X_LARGE__\");\t\\\n-\t}\t\t\t\t\t\\\n-      else\t\t\t\t\t\\\n-\tbuiltin_assert (\"cpu=MSP430\"); \t\t\\\n-    }\t\t\t\t\t\t\\\n+#define TARGET_CPU_CPP_BUILTINS()                                              \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      builtin_define (\"NO_TRAMPOLINES\");                                       \\\n+      builtin_define (\"__MSP430__\");                                           \\\n+      builtin_define (msp430_mcu_name ());                                     \\\n+      if (msp430x)                                                             \\\n+\t{                                                                      \\\n+\t  builtin_define (\"__MSP430X__\");                                      \\\n+\t  builtin_assert (\"cpu=MSP430X\");                                      \\\n+\t  if (TARGET_LARGE)                                                    \\\n+\t    builtin_define (\"__MSP430X_LARGE__\");                              \\\n+\t}                                                                      \\\n+      else                                                                     \\\n+\tbuiltin_assert (\"cpu=MSP430\");                                         \\\n+    }                                                                          \\\n   while (0)\n \n /* For the \"c\" language where exceptions are implicitly disabled, use\n    crt*_no_eh.o unless -fexceptions is passed.  For other languages, only use\n    crt*_no_eh.o if -fno-exceptions is explicitly passed.  */\n-#undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC \"%{pg:gcrt0.o%s}\" \\\n-  \"%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} \" \\\n-  \"%{!minrt:%{,c:%{!fexceptions:crtbegin_no_eh.o%s; :crtbegin.o%s}; \" \\\n-    \":%{fno-exceptions:crtbegin_no_eh.o%s; :crtbegin.o%s}}}\"\n+\n+#define TARGET_RUST_CPU_INFO()                                                 \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      rust_add_target_info (\"target_arch\", \"msp430\");                          \\\n+      /*TODO: ensure below variables work*/                                    \\\n+      if (msp430_hwmult_type == MSP430_HWMULT_SMALL)                           \\\n+\trust_add_target_info (\"target_feature\", \"hwmult16\");                   \\\n+      else if (msp430_hwmult_type == MSP430_HWMULT_LARGE)                      \\\n+\trust_add_target_info (\"target_feature\", \"hwmult32\");                   \\\n+      else if (msp430_hwmult_type == MSP430_HWMULT_F5SERIES)                   \\\n+\trust_add_target_info (\"target_feature\", \"hwmultf5\");                   \\\n+      if (msp430x)                                                             \\\n+\trust_add_target_info (\"target_feature\", \"ext\");                        \\\n+      /*TODO: add other options that aren't in llvm?*/                         \\\n+    }                                                                          \\\n+  while (0)\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC                                                         \\\n+  \"%{pg:gcrt0.o%s}\"                                                            \\\n+  \"%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} \"                          \\\n+  \"%{!minrt:%{,c:%{!fexceptions:crtbegin_no_eh.o%s; :crtbegin.o%s}; \"          \\\n+  \":%{fno-exceptions:crtbegin_no_eh.o%s; :crtbegin.o%s}}}\"\n \n /* -lgcc is included because crtend.o needs __mspabi_func_epilog_1.  */\n-#undef  ENDFILE_SPEC\n-#define ENDFILE_SPEC \\\n-  \"%{!minrt:%{,c:%{!fexceptions:crtend_no_eh.o%s; :crtend.o%s}; \" \\\n-    \":%{fno-exceptions:crtend_no_eh.o%s; :crtend.o%s}}} \" \\\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC                                                           \\\n+  \"%{!minrt:%{,c:%{!fexceptions:crtend_no_eh.o%s; :crtend.o%s}; \"              \\\n+  \":%{fno-exceptions:crtend_no_eh.o%s; :crtend.o%s}}} \"                        \\\n   \"%{minrt:%:if-exists(crtn-minrt.o%s)}%{!minrt:%:if-exists(crtn.o%s)} -lgcc\"\n \n-#define ASM_SPEC \"-mP \" /* Enable polymorphic instructions.  */ \\\n-  \"%{mcpu=*:-mcpu=%*} \" /* Pass the CPU type on to the assembler.  */ \\\n-  \"%{mrelax=-mQ} \" /* Pass the relax option on to the assembler.  */ \\\n-  /* Tell the assembler if we are building for the LARGE pointer model.  */ \\\n-  \"%{mlarge:-ml} \" \\\n-  \"%{msilicon-errata=*:-msilicon-errata=%*} \" \\\n-  \"%{msilicon-errata-warn=*:-msilicon-errata-warn=%*} \" \\\n-  /* Create DWARF line number sections for -ffunction-sections.  */ \\\n-  \"%{ffunction-sections:-gdwarf-sections} \" \\\n+#define ASM_SPEC                                                                  \\\n+  \"-mP \"\t\t/* Enable polymorphic instructions.  */                   \\\n+  \"%{mcpu=*:-mcpu=%*} \" /* Pass the CPU type on to the assembler.  */             \\\n+  \"%{mrelax=-mQ} \" /* Pass the relax option on to the assembler.  */ /* Tell      \\\n+\t\t\t\t\t\t\t\t\tthe       \\\n+\t\t\t\t\t\t\t\t\tassembler \\\n+\t\t\t\t\t\t\t\t\tif we     \\\n+\t\t\t\t\t\t\t\t\tare       \\\n+\t\t\t\t\t\t\t\t\tbuilding  \\\n+\t\t\t\t\t\t\t\t\tfor       \\\n+\t\t\t\t\t\t\t\t\tthe       \\\n+\t\t\t\t\t\t\t\t\tLARGE     \\\n+\t\t\t\t\t\t\t\t\tpointer   \\\n+\t\t\t\t\t\t\t\t\tmodel.    \\\n+\t\t\t\t\t\t\t\t      */          \\\n+  \"%{mlarge:-ml} \"                                                                \\\n+  \"%{msilicon-errata=*:-msilicon-errata=%*} \"                                     \\\n+  \"%{msilicon-errata-warn=*:-msilicon-errata-warn=%*} \" /* Create DWARF line      \\\n+\t\t\t\t\t\t\t   number sections for    \\\n+\t\t\t\t\t\t\t   -ffunction-sections.   \\\n+\t\t\t\t\t\t\t */                       \\\n+  \"%{ffunction-sections:-gdwarf-sections} \"                                       \\\n   \"%{mdata-region=*:-mdata-region=%*} \"\n \n /* Enable linker section garbage collection by default, unless we\n    are creating a relocatable binary (gc does not work) or debugging\n    is enabled  (the GDB testsuite relies upon unused entities not being\n    deleted).  */\n-#define LINK_SPEC \"%{mrelax:--relax} %{mlarge:%{!r:%{!g:--gc-sections}}} \" \\\n-  \"%{mcode-region=*:--code-region=%:\" \\\n-    \"msp430_propagate_region_opt(%* %{muse-lower-region-prefix})} \" \\\n-  \"%{mdata-region=*:--data-region=%:\" \\\n-    \"msp430_propagate_region_opt(%* %{muse-lower-region-prefix})} \" \\\n-  \"%:msp430_get_linker_devices_include_path() \" \\\n+#define LINK_SPEC                                                              \\\n+  \"%{mrelax:--relax} %{mlarge:%{!r:%{!g:--gc-sections}}} \"                     \\\n+  \"%{mcode-region=*:--code-region=%:\"                                          \\\n+  \"msp430_propagate_region_opt(%* %{muse-lower-region-prefix})} \"              \\\n+  \"%{mdata-region=*:--data-region=%:\"                                          \\\n+  \"msp430_propagate_region_opt(%* %{muse-lower-region-prefix})} \"              \\\n+  \"%:msp430_get_linker_devices_include_path() \"                                \\\n   \"%{mtiny-printf:--wrap puts --wrap printf} \"\n \n-#define DRIVER_SELF_SPECS \\\n-  \" %{!mlarge:%{mcode-region=*:%{mdata-region=*:%e-mcode-region and \"\t\\\n-    \"-mdata-region require the large memory model (-mlarge)}}}\" \\\n-  \" %{!mlarge:%{mcode-region=*:\"\t\\\n-    \"%e-mcode-region requires the large memory model (-mlarge)}}\"\t\\\n-  \" %{!mlarge:%{mdata-region=*:\"\t\\\n-    \"%e-mdata-region requires the large memory model (-mlarge)}}\"\t\\\n-  \" %{mno-warn-devices-csv:%:msp430_set_driver_var(msp430_warn_devices_csv 0)}\"\\\n-  \" %{mdevices-csv-loc=*:%:msp430_set_driver_var(msp430_devices_csv_loc %*)}\"\\\n-  \" %{I*:%:msp430_check_path_for_devices(%{I*:%*})}\"       \\\n-  \" %{L*:%:msp430_check_path_for_devices(%{L*:%*})}\"       \\\n+#define DRIVER_SELF_SPECS                                                      \\\n+  \" %{!mlarge:%{mcode-region=*:%{mdata-region=*:%e-mcode-region and \"          \\\n+  \"-mdata-region require the large memory model (-mlarge)}}}\"                  \\\n+  \" %{!mlarge:%{mcode-region=*:\"                                               \\\n+  \"%e-mcode-region requires the large memory model (-mlarge)}}\"                \\\n+  \" %{!mlarge:%{mdata-region=*:\"                                               \\\n+  \"%e-mdata-region requires the large memory model (-mlarge)}}\"                \\\n+  \" %{mno-warn-devices-csv:%:msp430_set_driver_var(msp430_warn_devices_csv \"   \\\n+  \"0)}\"                                                                        \\\n+  \" %{mdevices-csv-loc=*:%:msp430_set_driver_var(msp430_devices_csv_loc %*)}\"  \\\n+  \" %{I*:%:msp430_check_path_for_devices(%{I*:%*})}\"                           \\\n+  \" %{L*:%:msp430_check_path_for_devices(%{L*:%*})}\"                           \\\n   \" %{!mcpu=*:%{mmcu=*:%:msp430_select_cpu(%{mmcu=*:%*})}}\"\n \n-extern const char * msp430_select_hwmult_lib (int, const char **);\n-extern const char * msp430_select_cpu (int, const char **);\n-extern const char * msp430_set_driver_var (int, const char **);\n-extern const char * msp430_check_path_for_devices (int, const char **);\n-extern const char *msp430_propagate_region_opt (int, const char **);\n-extern const char *msp430_get_linker_devices_include_path (int, const char **);\n+extern const char *\n+msp430_select_hwmult_lib (int, const char **);\n+extern const char *\n+msp430_select_cpu (int, const char **);\n+extern const char *\n+msp430_set_driver_var (int, const char **);\n+extern const char *\n+msp430_check_path_for_devices (int, const char **);\n+extern const char *\n+msp430_propagate_region_opt (int, const char **);\n+extern const char *\n+msp430_get_linker_devices_include_path (int, const char **);\n \n /* There must be a trailing comma after the last item, see gcc.c\n    \"static_spec_functions\".  */\n-# define EXTRA_SPEC_FUNCTIONS\t\t\t\t\\\n-  { \"msp430_hwmult_lib\", msp430_select_hwmult_lib },\t\\\n-  { \"msp430_select_cpu\", msp430_select_cpu },\t\t\\\n-  { \"msp430_set_driver_var\", msp430_set_driver_var },\t\t\\\n-  { \"msp430_check_path_for_devices\", msp430_check_path_for_devices }, \\\n-  { \"msp430_propagate_region_opt\", msp430_propagate_region_opt }, \\\n-  { \"msp430_get_linker_devices_include_path\", \\\n-    msp430_get_linker_devices_include_path },\n+#define EXTRA_SPEC_FUNCTIONS                                                   \\\n+  {\"msp430_hwmult_lib\", msp430_select_hwmult_lib},                             \\\n+    {\"msp430_select_cpu\", msp430_select_cpu},                                  \\\n+    {\"msp430_set_driver_var\", msp430_set_driver_var},                          \\\n+    {\"msp430_check_path_for_devices\", msp430_check_path_for_devices},          \\\n+    {\"msp430_propagate_region_opt\", msp430_propagate_region_opt},              \\\n+    {\"msp430_get_linker_devices_include_path\",                                 \\\n+     msp430_get_linker_devices_include_path},\n \n /* Specify the libraries to include on the linker command line.\n \n@@ -129,8 +168,9 @@ extern const char *msp430_get_linker_devices_include_path (int, const char **);\n    values of FOO that a table is used to look up the name and map\n    it to a hardware multiply library.  This table (in device-msp430.c)\n    must be kept in sync with the same table in msp430.c.  */\n-#undef  LIB_SPEC\n-#define LIB_SPEC \"\t\t\t\t\t\\\n+#undef LIB_SPEC\n+#define LIB_SPEC                                                               \\\n+  \"\t\t\t\t\t\\\n --start-group\t\t\t\t\t\t\\\n %{mhwmult=auto:%{mmcu=*:%:msp430_hwmult_lib(mcu %{mmcu=*:%*});\\\n   :%:msp430_hwmult_lib(default)};\t\t\t\\\n@@ -146,17 +186,16 @@ extern const char *msp430_get_linker_devices_include_path (int, const char **);\n %{!T*:%{!msim:%{mmcu=*:--script=%*.ld}}}\t\t\\\n %{!T*:%{msim:%{mlarge:%Tmsp430xl-sim.ld}%{!mlarge:%Tmsp430-sim.ld}}} \\\n \"\n-\f\n-/* Storage Layout */\n \n-#define BITS_BIG_ENDIAN \t\t0\n-#define BYTES_BIG_ENDIAN \t\t0\n-#define WORDS_BIG_ENDIAN \t\t0\n+/* Storage Layout */\n \n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n \n #ifdef IN_LIBGCC2\n /* This is to get correct SI and DI modes in libgcc2.c (32 and 64 bits).  */\n-#define\tUNITS_PER_WORD\t\t\t4\n+#define UNITS_PER_WORD 4\n /* We have a problem with libgcc2.  It only defines two versions of\n    each function, one for \"int\" and one for \"long long\".  Ie it assumes\n    that \"sizeof (int) == sizeof (long)\".  For the MSP430 this is not true\n@@ -166,52 +205,52 @@ extern const char *msp430_get_linker_devices_include_path (int, const char **);\n    provide our own set of HI functions, which is why this\n    definition is surrounded by #ifndef..#endif.  */\n #ifndef LIBGCC2_UNITS_PER_WORD\n-#define LIBGCC2_UNITS_PER_WORD \t\t4\n+#define LIBGCC2_UNITS_PER_WORD 4\n #endif\n #else\n /* Actual width of a word, in units (bytes).  */\n-#define\tUNITS_PER_WORD \t\t\t2\n+#define UNITS_PER_WORD 2\n #endif\n \n-#define SHORT_TYPE_SIZE\t\t\t16\n-#define INT_TYPE_SIZE\t\t\t16\n-#define LONG_TYPE_SIZE\t\t\t32\n-#define LONG_LONG_TYPE_SIZE\t\t64\n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n \n-#define FLOAT_TYPE_SIZE \t\t32\n-#define DOUBLE_TYPE_SIZE \t\t64\n-#define LONG_DOUBLE_TYPE_SIZE\t\t64 /*DOUBLE_TYPE_SIZE*/\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64 /*DOUBLE_TYPE_SIZE*/\n \n-#define DEFAULT_SIGNED_CHAR\t\t0\n+#define DEFAULT_SIGNED_CHAR 0\n \n-#define STRICT_ALIGNMENT \t\t1\n-#define FUNCTION_BOUNDARY \t\t16\n-#define BIGGEST_ALIGNMENT \t\t16\n-#define STACK_BOUNDARY \t\t\t16\n-#define PARM_BOUNDARY \t\t\t8\n-#define PCC_BITFIELD_TYPE_MATTERS\t1\n+#define STRICT_ALIGNMENT 1\n+#define FUNCTION_BOUNDARY 16\n+#define BIGGEST_ALIGNMENT 16\n+#define STACK_BOUNDARY 16\n+#define PARM_BOUNDARY 8\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n \n-#define STACK_GROWS_DOWNWARD\t\t1\n-#define FRAME_GROWS_DOWNWARD\t\t1\n-#define FIRST_PARM_OFFSET(FNDECL) \t0\n+#define STACK_GROWS_DOWNWARD 1\n+#define FRAME_GROWS_DOWNWARD 1\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n \n-#define MAX_REGS_PER_ADDRESS \t\t1\n+#define MAX_REGS_PER_ADDRESS 1\n \n-#define Pmode \t\t\t\t(TARGET_LARGE ? PSImode : HImode)\n-#define POINTER_SIZE\t\t\t(TARGET_LARGE ? 20 : 16)\n+#define Pmode (TARGET_LARGE ? PSImode : HImode)\n+#define POINTER_SIZE (TARGET_LARGE ? 20 : 16)\n /* This is just for .eh_frame, to match bfd.  */\n-#define PTR_SIZE\t\t\t(TARGET_LARGE ? 4 : 2)\n-#define\tPOINTERS_EXTEND_UNSIGNED\t1\n+#define PTR_SIZE (TARGET_LARGE ? 4 : 2)\n+#define POINTERS_EXTEND_UNSIGNED 1\n \n /* TARGET_VTABLE_ENTRY_ALIGN defaults to POINTER_SIZE, which is 20 for\n    TARGET_LARGE.  Pointer alignment is always 16 for MSP430, so set explicitly\n    here.  */\n #define TARGET_VTABLE_ENTRY_ALIGN 16\n \n-#define ADDR_SPACE_NEAR\t1\n-#define ADDR_SPACE_FAR\t2\n+#define ADDR_SPACE_NEAR 1\n+#define ADDR_SPACE_FAR 2\n \n-#define REGISTER_TARGET_PRAGMAS() msp430_register_pragmas()\n+#define REGISTER_TARGET_PRAGMAS() msp430_register_pragmas ()\n \n #if 1 /* XXX */\n /* Define this macro if it is advisable to hold scalars in registers\n@@ -220,28 +259,25 @@ extern const char *msp430_get_linker_devices_include_path (int, const char **);\n    type, but kept valid in the wider mode.  The signedness of the\n    extension may differ from that of the type.  */\n \n-#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-      && GET_MODE_SIZE (MODE) < 2)      \t\\\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)                                    \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT && GET_MODE_SIZE (MODE) < 2)           \\\n     (MODE) = HImode;\n #endif\n-\f\n+\n /* Layout of Source Language Data Types */\n \n-#undef  SIZE_TYPE\n-#define SIZE_TYPE\t\t\t(TARGET_LARGE \\\n-\t\t\t\t\t ? \"__int20__ unsigned\" \\\n-\t\t\t\t\t : \"unsigned int\")\n-#undef  PTRDIFF_TYPE\n-#define PTRDIFF_TYPE\t\t\t(TARGET_LARGE ? \"__int20__\" : \"int\")\n-#undef  WCHAR_TYPE\n-#define WCHAR_TYPE\t\t\t\"long int\"\n-#undef  WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE\t\t\tBITS_PER_WORD\n-#define FUNCTION_MODE \t\t\tHImode\n-#define CASE_VECTOR_MODE\t\tPmode\n-#define HAS_LONG_COND_BRANCH\t\t0\n-#define HAS_LONG_UNCOND_BRANCH\t\t0\n+#undef SIZE_TYPE\n+#define SIZE_TYPE (TARGET_LARGE ? \"__int20__ unsigned\" : \"unsigned int\")\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_LARGE ? \"__int20__\" : \"int\")\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+#define FUNCTION_MODE HImode\n+#define CASE_VECTOR_MODE Pmode\n+#define HAS_LONG_COND_BRANCH 0\n+#define HAS_LONG_UNCOND_BRANCH 0\n \n /* The cost of a branch sequence is roughly 3 \"cheap\" instructions.  */\n #define BRANCH_COST(speed_p, predictable_p) 3\n@@ -251,57 +287,43 @@ extern const char *msp430_get_linker_devices_include_path (int, const char **);\n    codesize and performance.  */\n #define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n \n-#define LOAD_EXTEND_OP(M)\t\tZERO_EXTEND\n-#define WORD_REGISTER_OPERATIONS\t1\n+#define LOAD_EXTEND_OP(M) ZERO_EXTEND\n+#define WORD_REGISTER_OPERATIONS 1\n \n-#define MOVE_MAX \t\t\t8\n+#define MOVE_MAX 8\n \n-#define INCOMING_RETURN_ADDR_RTX \\\n-  msp430_incoming_return_addr_rtx ()\n+#define INCOMING_RETURN_ADDR_RTX msp430_incoming_return_addr_rtx ()\n \n-#define RETURN_ADDR_RTX(COUNT, FA)\t\t\\\n-  msp430_return_addr_rtx (COUNT)\n+#define RETURN_ADDR_RTX(COUNT, FA) msp430_return_addr_rtx (COUNT)\n \n-#define SLOW_BYTE_ACCESS\t\t0\n+#define SLOW_BYTE_ACCESS 0\n \n /* Calling a constant function address costs the same number of clock\n    cycles as calling an address stored in a register. However, in terms of\n    instruction length, calling a constant address is more expensive.  */\n #define NO_FUNCTION_CSE (optimize >= 2 && !optimize_size)\n-\f\n \n /* Register Usage */\n \n /* gas doesn't recognize PC (R0), SP (R1), and SR (R2) as register\n    names.  */\n-#define REGISTER_NAMES\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\",\t\t\\\n-    \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\t\\\n-  \"argptr\"\t\t\t\t\t\t\t\\\n-}\n+#define REGISTER_NAMES                                                         \\\n+  {                                                                            \\\n+    \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\", \"R10\", \"R11\",  \\\n+      \"R12\", \"R13\", \"R14\", \"R15\", \"argptr\"                                     \\\n+  }\n \n /* Allow lowercase \"r\" to be used in register names instead of upper\n    case \"R\".  */\n-#define ADDITIONAL_REGISTER_NAMES\t\\\n-{\t\t\t\t\t\\\n-    { \"r0\",  0 },\t\t\t\\\n-    { \"r1\",  1 },\t\t\t\\\n-    { \"r2\",  2 },\t\t\t\\\n-    { \"r3\",  3 },\t\t\t\\\n-    { \"r4\",  4 },\t\t\t\\\n-    { \"r5\",  5 },\t\t\t\\\n-    { \"r6\",  6 },\t\t\t\\\n-    { \"r7\",  7 },\t\t\t\\\n-    { \"r8\",  8 },\t\t\t\\\n-    { \"r9\",  9 },\t\t\t\\\n-    { \"r10\", 10 },\t\t\t\\\n-    { \"r11\", 11 },\t\t\t\\\n-    { \"r12\", 12 },\t\t\t\\\n-    { \"r13\", 13 },\t\t\t\\\n-    { \"r14\", 14 },\t\t\t\\\n-    { \"r15\", 15 }\t\t\t\\\n-}\n+#define ADDITIONAL_REGISTER_NAMES                                              \\\n+  {                                                                            \\\n+    {\"r0\", 0}, {\"r1\", 1}, {\"r2\", 2}, {\"r3\", 3}, {\"r4\", 4}, {\"r5\", 5},          \\\n+      {\"r6\", 6}, {\"r7\", 7}, {\"r8\", 8}, {\"r9\", 9}, {\"r10\", 10}, {\"r11\", 11},    \\\n+      {\"r12\", 12}, {\"r13\", 13}, {\"r14\", 14},                                   \\\n+    {                                                                          \\\n+      \"r15\", 15                                                                \\\n+    }                                                                          \\\n+  }\n \n enum reg_class\n {\n@@ -313,90 +335,79 @@ enum reg_class\n   LIM_REG_CLASSES\n };\n \n-#define REG_CLASS_NAMES \\\n-{\t\t\t\\\n-  \"NO_REGS\",\t\t\\\n-  \"R12_REGS\",\t\t\\\n-  \"R13_REGS\",\t\t\\\n-  \"GEN_REGS\",\t\t\\\n-  \"ALL_REGS\"\t\t\\\n-}\n-\n-#define REG_CLASS_CONTENTS \\\n-{\t\t\t   \\\n-  0x00000000,\t\t   \\\n-  0x00001000,\t\t   \\\n-  0x00002000,\t\t   \\\n-  0x0000fff3,\t\t   \\\n-  0x0001ffff\t\t   \\\n-}\n+#define REG_CLASS_NAMES                                                        \\\n+  {                                                                            \\\n+    \"NO_REGS\", \"R12_REGS\", \"R13_REGS\", \"GEN_REGS\", \"ALL_REGS\"                  \\\n+  }\n+\n+#define REG_CLASS_CONTENTS                                                     \\\n+  {                                                                            \\\n+    0x00000000, 0x00001000, 0x00002000, 0x0000fff3, 0x0001ffff                 \\\n+  }\n \n /* GENERAL_REGS just means that the \"g\" and \"r\" constraints can use these\n    registers.\n    Even though R0 (PC) and R1 (SP) are not \"general\" in that they can be used\n    for any purpose by the register allocator, they are general in that they can\n    be used by any instruction in any addressing mode.  */\n-#define GENERAL_REGS\t\t\tGEN_REGS\n-#define BASE_REG_CLASS  \t\tGEN_REGS\n-#define INDEX_REG_CLASS\t\t\tGEN_REGS\n-#define N_REG_CLASSES\t\t\t(int) LIM_REG_CLASSES\n-\n-#define PC_REGNUM\t\t\t0\n-#define STACK_POINTER_REGNUM\t\t1\n-#define CC_REGNUM \t\t\t2\n-#define FRAME_POINTER_REGNUM \t\t4 /* not usually used, call preserved */\n-#define ARG_POINTER_REGNUM \t\t16\n-#define STATIC_CHAIN_REGNUM \t\t5 /* FIXME */\n-\n-#define FIRST_PSEUDO_REGISTER \t\t17\n-\n-#define REGNO_REG_CLASS(REGNO)\t\t(REGNO != 2 \\\n-\t\t\t\t\t && REGNO != 3 \\\n-\t\t\t\t\t && REGNO < 17 \\\n-\t\t\t\t\t ? GEN_REGS : NO_REGS)\n-\n-#define TRAMPOLINE_SIZE\t\t\t4 /* FIXME */\n-#define TRAMPOLINE_ALIGNMENT\t\t16 /* FIXME */\n-\n-#define ELIMINABLE_REGS\t\t\t\t\t\\\n-{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM },\t\\\n- { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM },\t\\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\\\n+#define GENERAL_REGS GEN_REGS\n+#define BASE_REG_CLASS GEN_REGS\n+#define INDEX_REG_CLASS GEN_REGS\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define PC_REGNUM 0\n+#define STACK_POINTER_REGNUM 1\n+#define CC_REGNUM 2\n+#define FRAME_POINTER_REGNUM 4 /* not usually used, call preserved */\n+#define ARG_POINTER_REGNUM 16\n+#define STATIC_CHAIN_REGNUM 5 /* FIXME */\n+\n+#define FIRST_PSEUDO_REGISTER 17\n+\n+#define REGNO_REG_CLASS(REGNO)                                                 \\\n+  (REGNO != 2 && REGNO != 3 && REGNO < 17 ? GEN_REGS : NO_REGS)\n+\n+#define TRAMPOLINE_SIZE 4\t/* FIXME */\n+#define TRAMPOLINE_ALIGNMENT 16 /* FIXME */\n+\n+#define ELIMINABLE_REGS                                                        \\\n+  {                                                                            \\\n+    {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},                                \\\n+      {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},                              \\\n+    {                                                                          \\\n+      FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM                               \\\n+    }                                                                          \\\n+  }\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)                           \\\n   (OFFSET) = msp430_initial_elimination_offset ((FROM), (TO))\n \n-\n-#define FUNCTION_ARG_REGNO_P(N)\t  \t((N) >= 8 && (N) < ARG_POINTER_REGNUM)\n-#define DEFAULT_PCC_STRUCT_RETURN\t0\n+#define FUNCTION_ARG_REGNO_P(N) ((N) >= 8 && (N) < ARG_POINTER_REGNUM)\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n \n /* 1 == register can't be used by gcc, in general\n    0 == register can be used by gcc, in general */\n-#define FIXED_REGISTERS\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  1,0,1,1, 0,0,0,0,\t\t\t\t\t\\\n-  0,0,0,0, 0,0,0,0,\t\t\t\t\t\\\n-  1,\t\t\t\t\t\t\t\\\n-}\n+#define FIXED_REGISTERS                                                        \\\n+  {                                                                            \\\n+    1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,                         \\\n+  }\n \n /* 1 == value changes across function calls\n    0 == value is the same after a call      */\n /* R4 through R10 are callee-saved */\n-#define CALL_USED_REGISTERS\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  1,0,1,1, 0,0,0,0,\t\t\t\t\t\\\n-  0,0,0,1, 1,1,1,1,\t\t\t\t\t\\\n-  1,\t\t\t\t\t\t\\\n-}\n-\n-#define REG_ALLOC_ORDER\t\t\t\t\t\\\n-  { 12, 13, 14, 15, 10, 9, 8, 7, 6, 5, 4, 11, 0, 1, 2, 3, 16 }\n+#define CALL_USED_REGISTERS                                                    \\\n+  {                                                                            \\\n+    1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,                         \\\n+  }\n+\n+#define REG_ALLOC_ORDER                                                        \\\n+  {                                                                            \\\n+    12, 13, 14, 15, 10, 9, 8, 7, 6, 5, 4, 11, 0, 1, 2, 3, 16                   \\\n+  }\n /*  { 11, 15, 14, 13, 12, 10, 9, 8, 7, 6, 5, 4, 0, 1, 2, 3, 16 }*/\n \n-#define REGNO_OK_FOR_BASE_P(regno)\t1\n-#define REGNO_OK_FOR_INDEX_P(regno)\t1\n-\n-\f\n+#define REGNO_OK_FOR_BASE_P(regno) 1\n+#define REGNO_OK_FOR_INDEX_P(regno) 1\n \n typedef struct\n {\n@@ -411,93 +422,86 @@ typedef struct\n   char special_p;\n } CUMULATIVE_ARGS;\n \n-#define INIT_CUMULATIVE_ARGS(CA, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+#define INIT_CUMULATIVE_ARGS(CA, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS)      \\\n   msp430_init_cumulative_args (&CA, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS)\n \n-\f\n /* FIXME */\n-#define NO_PROFILE_COUNTERS     1\n+#define NO_PROFILE_COUNTERS 1\n #define PROFILE_BEFORE_PROLOGUE 1\n \n-#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n-    fprintf (FILE, \"\\tcall\\t__mcount\\n\");\n-\f\n+#define FUNCTION_PROFILER(FILE, LABELNO) fprintf (FILE, \"\\tcall\\t__mcount\\n\");\n+\n /* Exception Handling */\n \n /* R12,R13,R14 - EH data\n    R15 - stack adjustment */\n \n-#define EH_RETURN_DATA_REGNO(N) \\\n-  (((N) < 3) ? ((N) + 12) : INVALID_REGNUM)\n+#define EH_RETURN_DATA_REGNO(N) (((N) < 3) ? ((N) + 12) : INVALID_REGNUM)\n \n-#define EH_RETURN_HANDLER_RTX \\\n-  gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, SP_REGNO), \\\n-\t\t\t\t   gen_rtx_REG (Pmode, 15)))\n+#define EH_RETURN_HANDLER_RTX                                                  \\\n+  gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, SP_REGNO),      \\\n+\t\t\t\t    gen_rtx_REG (Pmode, 15)))\n \n #define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, 15)\n \n-#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) DW_EH_PE_udata4\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) DW_EH_PE_udata4\n \n-\f\n /* Stack Layout and Calling Conventions */\n \n-\f\n /* Addressing Modes */\n \n-\f\n-\n #define TEXT_SECTION_ASM_OP \".text\"\n #define DATA_SECTION_ASM_OP \".data\"\n-#define BSS_SECTION_ASM_OP   \"\\t.section .bss\"\n+#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n \n-#define ASM_COMMENT_START\t\" ;\"\n-#define ASM_APP_ON\t\t\"\"\n-#define ASM_APP_OFF \t\t\"\"\n-#define LOCAL_LABEL_PREFIX\t\".L\"\n-#undef  USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX\t\"\"\n+#define ASM_COMMENT_START \" ;\"\n+#define ASM_APP_ON \"\"\n+#define ASM_APP_OFF \"\"\n+#define LOCAL_LABEL_PREFIX \".L\"\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n \n-#define GLOBAL_ASM_OP \t\t\"\\t.global\\t\"\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n \n #define ASM_OUTPUT_LABELREF(FILE, SYM) msp430_output_labelref ((FILE), (SYM))\n \n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)                                   \\\n   fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n    Note: The local label referenced by the \"3b\" below is emitted by\n    the tablejump insn.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)                       \\\n   fprintf (FILE, \"\\t.long .L%d - 1b\\n\", VALUE)\n \n-\n-#define ASM_OUTPUT_ALIGN(STREAM, LOG)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if ((LOG) == 0)\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.balign %d\\n\", 1 << (LOG));\t\\\n-    }\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_ALIGN(STREAM, LOG)                                          \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      if ((LOG) == 0)                                                          \\\n+\tbreak;                                                                 \\\n+      fprintf (STREAM, \"\\t.balign %d\\n\", 1 << (LOG));                          \\\n+    }                                                                          \\\n   while (0)\n \n-#define JUMP_TABLES_IN_TEXT_SECTION\t1\n-\f\n-#undef\tDWARF2_ADDR_SIZE\n-#define\tDWARF2_ADDR_SIZE\t\t\t4\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n \n-#define INCOMING_FRAME_SP_OFFSET\t\t(TARGET_LARGE ? 4 : 2)\n+#undef DWARF2_ADDR_SIZE\n+#define DWARF2_ADDR_SIZE 4\n \n-#undef  PREFERRED_DEBUGGING_TYPE\n+#define INCOMING_FRAME_SP_OFFSET (TARGET_LARGE ? 4 : 2)\n+\n+#undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n-#define DWARF2_ASM_LINE_DEBUG_INFO\t\t1\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n \n /* Prevent reload (and others) from choosing HImode stack slots\n    when spilling hard registers when they may contain PSImode values.  */\n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO,NREGS,MODE) \\\n-  ((TARGET_LARGE && ((NREGS) <= 2)) ? PSImode \\\n-   : choose_hard_reg_mode ((REGNO), (NREGS), NULL))\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)                        \\\n+  ((TARGET_LARGE && ((NREGS) <= 2))                                            \\\n+     ? PSImode                                                                 \\\n+     : choose_hard_reg_mode ((REGNO), (NREGS), NULL))\n \n #define ACCUMULATE_OUTGOING_ARGS 1\n \n@@ -507,44 +511,45 @@ typedef struct\n    want to prevent any instructions using a \"store post increment\" from being\n    generated.  These will have to later be reloaded since msp430 does not\n    support post inc for the destination operand.  */\n-#define USE_STORE_POST_INCREMENT(MODE)  0\n+#define USE_STORE_POST_INCREMENT(MODE) 0\n \n /* Many other targets set USE_LOAD_POST_INCREMENT to 0.  For msp430-elf\n    the benefit of disabling it is not clear.  When looking at code size, on\n    average, there is a slight advantage to leaving it enabled.  */\n \n-#undef  ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)                            \\\n   msp430_start_function ((FILE), (NAME), (DECL))\n \n-#define TARGET_HAS_NO_HW_DIVIDE (! TARGET_HWMULT)\n+#define TARGET_HAS_NO_HW_DIVIDE (!TARGET_HWMULT)\n \n-void msp430_register_pre_includes (const char *sysroot ATTRIBUTE_UNUSED,\n-\t\t\t\t   const char *iprefix ATTRIBUTE_UNUSED,\n-\t\t\t\t   int stdinc ATTRIBUTE_UNUSED);\n+void\n+msp430_register_pre_includes (const char *sysroot ATTRIBUTE_UNUSED,\n+\t\t\t      const char *iprefix ATTRIBUTE_UNUSED,\n+\t\t\t      int stdinc ATTRIBUTE_UNUSED);\n #undef TARGET_EXTRA_PRE_INCLUDES\n #define TARGET_EXTRA_PRE_INCLUDES msp430_register_pre_includes\n \n-#undef  USE_SELECT_SECTION_FOR_FUNCTIONS\n+#undef USE_SELECT_SECTION_FOR_FUNCTIONS\n #define USE_SELECT_SECTION_FOR_FUNCTIONS 1\n \n #undef ASM_OUTPUT_ALIGNED_DECL_COMMON\n-#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)          \\\n   msp430_output_aligned_decl_common ((FILE), (DECL), (NAME), (SIZE), (ALIGN), 0)\n \n-#undef  ASM_OUTPUT_ALIGNED_DECL_LOCAL\n-#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+#undef ASM_OUTPUT_ALIGNED_DECL_LOCAL\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)           \\\n   msp430_output_aligned_decl_common ((FILE), (DECL), (NAME), (SIZE), (ALIGN), 1)\n \n-\n #define SYMBOL_FLAG_LOW_MEM (SYMBOL_FLAG_MACH_DEP << 0)\n \n-#define ADJUST_INSN_LENGTH(insn, length) \\\n-  do\t\\\n-    {\t\\\n-      if (recog_memoized (insn) >= 0)\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  length += get_attr_extra_length (insn);\t\\\n-\t  length *= get_attr_length_multiplier (insn);\t\\\n-\t}\t\t\t\t\t\t\\\n-    } while (0)\n+#define ADJUST_INSN_LENGTH(insn, length)                                       \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      if (recog_memoized (insn) >= 0)                                          \\\n+\t{                                                                      \\\n+\t  length += get_attr_extra_length (insn);                              \\\n+\t  length *= get_attr_length_multiplier (insn);                         \\\n+\t}                                                                      \\\n+    }                                                                          \\\n+  while (0)"}]}