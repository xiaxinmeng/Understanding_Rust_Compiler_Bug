{"sha": "ec6840c19d9641c54bcfd0b71cfd15569ddc8475", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2ODQwYzE5ZDk2NDFjNTRiY2ZkMGI3MWNmZDE1NTY5ZGRjODQ3NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-07T14:37:12Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-07T14:37:12Z"}, "message": "(add_long_const): New function.\n\n(output_{pro,epi}log): Use it.\nIf register save area is more than 32768 from SP, compute its address into\na register.\n\nFrom-SVN: r5099", "tree": {"sha": "9f40caca1f3a044e67f01d870efa586daad2339b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f40caca1f3a044e67f01d870efa586daad2339b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec6840c19d9641c54bcfd0b71cfd15569ddc8475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6840c19d9641c54bcfd0b71cfd15569ddc8475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6840c19d9641c54bcfd0b71cfd15569ddc8475", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6840c19d9641c54bcfd0b71cfd15569ddc8475/comments", "author": null, "committer": null, "parents": [{"sha": "bc1c7e9300698df733202b646759ba4fe58ad295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc1c7e9300698df733202b646759ba4fe58ad295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc1c7e9300698df733202b646759ba4fe58ad295"}], "stats": {"total": 211, "additions": 116, "deletions": 95}, "files": [{"sha": "302de2fd7ba5684da1e99da831e7b42f92313173", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 116, "deletions": 95, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6840c19d9641c54bcfd0b71cfd15569ddc8475/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6840c19d9641c54bcfd0b71cfd15569ddc8475/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ec6840c19d9641c54bcfd0b71cfd15569ddc8475", "patch": "@@ -1120,6 +1120,56 @@ alpha_write_verstamp (file)\n   fprintf (file, \"\\n\");\n #endif\n }\n+\f\n+/* Write code to add constant C to register number IN_REG (possibly 31)\n+   and put the result into OUT_REG.  Write the code to FILE.  */\n+\n+static void\n+add_long_const (file, c, in_reg, out_reg)\n+     HOST_WIDE_INT c;\n+     int in_reg, out_reg;\n+     FILE *file;\n+{\n+  HOST_WIDE_INT low = (c & 0xffff) - 2 * (c & 0x8000);\n+  HOST_WIDE_INT tmp1 = c - low;\n+  HOST_WIDE_INT high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+  HOST_WIDE_INT extra = 0;\n+\n+  /* We don't have code to write out constants larger than 32 bits.  */\n+#if HOST_BITS_PER_LONG_INT == 64\n+  if ((unsigned HOST_WIDE_INT) c >> 32 != 0)\n+    abort ();\n+#endif\n+\n+  /* If HIGH will be interpreted as negative, we must adjust it to do two\n+     ldha insns.  Note that we will never be building a negative constant\n+     here.  */\n+\n+  if (high & 0x8000)\n+    {\n+      extra = 0x4000;\n+      tmp1 -= 0x40000000;\n+      high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+    }\n+\n+  if (low != 0)\n+    {\n+      if (low >= 0 && low < 255)\n+\tfprintf (file, \"\\taddq $%d,%d,$%d\\n\", in_reg, low, out_reg);\n+      else\n+\tfprintf (file, \"\\tlda $%d,%d($%d)\\n\", out_reg, low, in_reg);\n+      in_reg = out_reg;\n+    }\n+\n+  if (extra)\n+    {\n+      fprintf (file, \"\\tldah $%d,%d($%d)\\n\", out_reg, extra, in_reg);\n+      in_reg = out_reg;\n+    }\n+\n+  if (high)\n+    fprintf (file, \"\\tldah $%d,%d($%d)\\n\", out_reg, high, in_reg);\n+}\n \n /* Write function prologue.  */\n \n@@ -1131,9 +1181,11 @@ output_prolog (file, size)\n   HOST_WIDE_INT frame_size = ((size + current_function_outgoing_args_size\n \t\t\t       + current_function_pretend_args_size\n \t\t\t       + alpha_sa_size () + 15) & ~15);\n-  int reg_offset = size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT reg_offset = size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT start_reg_offset = reg_offset;\n+  HOST_WIDE_INT actual_start_reg_offset = start_reg_offset;\n   rtx insn;\n-  int start_reg_offset = reg_offset;\n+  int reg_offset_base_reg = 30;\n   unsigned reg_mask = 0;\n   int i;\n \n@@ -1195,48 +1247,12 @@ output_prolog (file, size)\n       /* Here we generate code to set R4 to SP + 4096 and set R5 to the\n \t number of 8192 byte blocks to probe.  We then probe each block\n \t in the loop and then set SP to the proper location.  If the\n-\t amount remaining is > 4096, we have to do one more probe.\n-\n-\t This is complicated by the code we would generate if\n-\t the number of blocks > 32767.  */\n+\t amount remaining is > 4096, we have to do one more probe.  */\n \n       HOST_WIDE_INT blocks = (frame_size + 4096) / 8192;\n       HOST_WIDE_INT leftover = frame_size + 4096 - blocks * 8192;\n-      HOST_WIDE_INT low = (blocks & 0xffff) - 2 * (blocks & 0x8000);\n-      HOST_WIDE_INT tmp1 = blocks - low;\n-      HOST_WIDE_INT high\n-\t= ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-      HOST_WIDE_INT extra = 0;\n-      int in_reg = 31;\n-\n-      /* If HIGH will be interpreted as negative, we must adjust it to\n-\t do two ldha insns.  Note that we will never be building a negative\n-\t constant here.  */\n-\n-      if (high & 0x8000)\n-\t{\n-\t  extra = 0x4000;\n-\t  tmp1 -= 0x40000000;\n-\t  high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-\t}\n-\n-      if (low != 0)\n-\t{\n-\t  if (low < 255)\n-\t    fprintf (file, \"\\tbis $31,%d,$5\\n\", low);\n-\t  else\n-\t    fprintf (file, \"\\tlda $5,%d($31)\\n\", low);\n-\t  in_reg = 5;\n-\t}\n \n-      if (extra)\n-\t{\n-\t  fprintf (file, \"\\tldah $5,%d($%d)\\n\", extra, in_reg);\n-\t  in_reg = 5;\n-\t}\n-\n-      if (high)\n-\tfprintf (file, \"\\tldah $5,%d($%d)\\n\", high, in_reg);\n+      add_long_const (file, blocks, 31, 5);\n \n       fprintf (file, \"\\tlda $4,4096($30)\\n\");\n       fprintf (file, \"%s..sc:\\n\", alpha_function_name);\n@@ -1255,12 +1271,22 @@ output_prolog (file, size)\n \t   frame_pointer_needed ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM,\n \t   frame_size, current_function_pretend_args_size);\n     \n+  /* If reg_offset is \"close enough\" to 2**15 that one of the offsets would\n+     overflow a store instruction, compute the base of the register save\n+     area into $28.  */\n+  if (reg_offset >= 32768 - alpha_sa_size () && alpha_sa_size () != 0)\n+    {\n+      add_long_const (file, reg_offset, 30, 28);\n+      reg_offset_base_reg = 28;\n+      reg_offset = start_reg_offset = 0;\n+    }\n+\n   /* Save register 26 if it is used or if any other register needs to\n      be saved.  */\n   if (regs_ever_live[26] || alpha_sa_size () != 0)\n     {\n       reg_mask |= 1 << 26;\n-      fprintf (file, \"\\tstq $26,%d($30)\\n\", reg_offset);\n+      fprintf (file, \"\\tstq $26,%d($%d)\\n\", reg_offset, reg_offset_base_reg);\n       reg_offset += 8;\n     }\n \n@@ -1269,14 +1295,15 @@ output_prolog (file, size)\n     if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i] && i != 26)\n       {\n \treg_mask |= 1 << i;\n-\tfprintf (file, \"\\tstq $%d,%d($30)\\n\", i, reg_offset);\n+\tfprintf (file, \"\\tstq $%d,%d($%d)\\n\",\n+\t\t i, reg_offset, reg_offset_base_reg);\n \treg_offset += 8;\n       }\n \n   /* Print the register mask and do floating-point saves.  */\n   if (reg_mask)\n     fprintf (file, \"\\t.mask 0x%x,%d\\n\", reg_mask,\n-\t     start_reg_offset - frame_size);\n+\t     actual_start_reg_offset - frame_size);\n \n   start_reg_offset = reg_offset;\n   reg_mask = 0;\n@@ -1286,13 +1313,14 @@ output_prolog (file, size)\n \t&& regs_ever_live[i + 32])\n       {\n \treg_mask |= 1 << i;\n-\tfprintf (file, \"\\tstt $f%d,%d($30)\\n\", i, reg_offset);\n+\tfprintf (file, \"\\tstt $f%d,%d($%d)\\n\",\n+\t\t i, reg_offset, reg_offset_base_reg);\n \treg_offset += 8;\n       }\n \n   /* Print the floating-point mask, if we've saved any fp register.  */\n   if (reg_mask)\n-    fprintf (file, \"\\t.fmask 0x%x,%d\\n\", reg_mask, start_reg_offset);\n+    fprintf (file, \"\\t.fmask 0x%x,%d\\n\", reg_mask, actual_start_reg_offset);\n \n   /* If we need a frame pointer, set it from the stack pointer.  Note that\n      this must always be the last instruction in the prologue.  */\n@@ -1314,7 +1342,9 @@ output_epilog (file, size)\n   HOST_WIDE_INT frame_size = ((size + current_function_outgoing_args_size\n \t\t\t       + current_function_pretend_args_size\n \t\t\t       + alpha_sa_size () + 15) & ~15);\n-  int reg_offset = size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT reg_offset = size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT frame_size_from_reg_save = frame_size - reg_offset;\n+  int reg_offset_base_reg = 30;\n   int i;\n \n   /* If the last insn was a BARRIER, we don't have to write anything except\n@@ -1329,11 +1359,21 @@ output_epilog (file, size)\n       if (frame_pointer_needed)\n \tfprintf (file, \"\\tbis $15,$15,$30\\n\");\n \n+      /* If the register save area is out of range, put its address into\n+\t $28.  */\n+      if (reg_offset >= 32768 - alpha_sa_size () && alpha_sa_size () != 0)\n+\t{\n+\t  add_long_const (file, reg_offset, 30, 28);\n+\t  reg_offset_base_reg = 28;\n+\t  reg_offset = 0;\n+\t}\n+\n       /* Restore all the registers, starting with the return address\n \t register.  */\n       if (regs_ever_live[26] || alpha_sa_size () != 0)\n \t{\n-\t  fprintf (file, \"\\tldq $26,%d($30)\\n\", reg_offset);\n+\t  fprintf (file, \"\\tldq $26,%d($%d)\\n\",\n+\t\t   reg_offset, reg_offset_base_reg);\n \t  reg_offset += 8;\n \t}\n \n@@ -1348,73 +1388,54 @@ output_epilog (file, size)\n \t    if (i == FRAME_POINTER_REGNUM && frame_pointer_needed)\n \t      fp_offset = reg_offset;\n \t    else\n-\t      fprintf (file, \"\\tldq $%d,%d($30)\\n\", i, reg_offset);\n+\t      fprintf (file, \"\\tldq $%d,%d($%d)\\n\",\n+\t\t       i, reg_offset, reg_offset_base_reg);\n \t    reg_offset += 8;\n \t  }\n \n       for (i = 0; i < 32; i++)\n \tif (! fixed_regs[i + 32] && ! call_used_regs[i + 32]\n \t    && regs_ever_live[i + 32])\n \t  {\n-\t    fprintf (file, \"\\tldt $f%d,%d($30)\\n\", i, reg_offset);\n+\t    fprintf (file, \"\\tldt $f%d,%d($%d)\\n\",\n+\t\t     i, reg_offset, reg_offset_base_reg);\n \t    reg_offset += 8;\n \t  }\n \n       /* If the stack size is large, compute the size of the stack into\n \t a register because the old FP restore, stack pointer adjust,\n-\t and return are required to be consecutive instructions.  */\n-      if (frame_size > 32767)\n-\t{\n-\t  HOST_WIDE_INT low\n-\t    = (frame_size & 0xffff) - 2 * (frame_size & 0x8000);\n-\t  HOST_WIDE_INT tmp1 = frame_size - low;\n-\t  HOST_WIDE_INT high\n-\t    = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-\t  HOST_WIDE_INT extra = 0;\n-\t  int in_reg = 31;\n-\n-\t  /* We haven't written code to handle frames > 4GB.  */\n-#if HOST_BITS_PER_LONG_INT == 64\n-\t  if ((unsigned HOST_WIDE_INT) frame_size >> 32 != 0)\n-\t    abort ();\n-#endif\n-\n-\t  /* If HIGH will be interpreted as negative, we must adjust it to\n-\t     do two ldha insns.  Note that we will never be building a negative\n-\t     constant here.  */\n-\n-\t  if (high & 0x8000)\n-\t    {\n-\t      extra = 0x4000;\n-\t      tmp1 -= 0x40000000;\n-\t      high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-\t    }\n-\n-\t  if (low != 0)\n-\t    {\n-\t      fprintf (file, \"\\tlda $28,%d($%d)\\n\", low, in_reg);\n-\t      in_reg = 28;\n-\t    }\n-\n-\t  if (extra)\n-\t    {\n-\t      fprintf (file, \"\\tldah $28,%d($%d)\\n\", extra, in_reg);\n-\t      in_reg = 28;\n-\t    }\n-\n-\t  fprintf (file, \"\\tldah $28,%d($%d)\\n\", high, in_reg);\n-\t}\n+\t and return are required to be consecutive instructions.  \n+\t However, if the new stack pointer can be computed by adding the\n+\t a constant to the start of the register save area, we can do\n+\t it that way.  */\n+      if (frame_size > 32767\n+\t  && ! (reg_offset_base_reg != 30\n+\t\t&& frame_size_from_reg_save < 32768))\n+\tadd_long_const (file, frame_size, 31, 1);\n \n       /* If we needed a frame pointer and we have to restore it, do it\n-\t now.  */\n-\n+\t now.  This must be done in one instruction immediately\n+\t before the SP update.  */\n       if (frame_pointer_needed && regs_ever_live[FRAME_POINTER_REGNUM])\n-\tfprintf (file, \"\\tldq $15,%d($30)\\n\", fp_offset);\n+\tfprintf (file, \"\\tldq $15,%d($%d)\\n\", fp_offset, reg_offset_base_reg);\n \n       /* Now update the stack pointer, if needed.  This must be done in\n \t one, stylized, instruction.  */\n       if (frame_size > 32768)\n-\tfprintf (file, \"\\taddq $28,$30,$30\\n\");\n+\t{\n+\t  if (reg_offset_base_reg != 30\n+\t      && frame_size_from_reg_save < 32768)\n+\t    {\n+\t      if (frame_size_from_reg_save < 255)\n+\t\tfprintf (file, \"\\taddq $%d,%d,$30\\n\",\n+\t\t\t reg_offset_base_reg, frame_size_from_reg_save);\n+\t      else\n+\t\tfprintf (file, \"\\tlda %30,%d($%d)\\n\",\n+\t\t\t frame_size_from_reg_save, reg_offset_base_reg);\n+\t    }\n+\t  else\n+\t    fprintf (file, \"\\taddq $1,$30,$30\\n\");\n+\t}\n       else if (frame_size != 0)\n \tfprintf (file, \"\\tlda $30,%d($30)\\n\", frame_size);\n "}]}