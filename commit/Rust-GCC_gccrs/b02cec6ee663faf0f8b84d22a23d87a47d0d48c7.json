{"sha": "b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAyY2VjNmVlNjYzZmFmMGY4Yjg0ZDIyYTIzZDg3YTQ3ZDBkNDhjNw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2009-05-01T14:09:20Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2009-05-01T14:09:20Z"}, "message": "c-objc-common.c (c_tree_printer): Print identifiers with pp_identifier, not pp_string.\n\n\t* c-objc-common.c (c_tree_printer): Print identifiers with\n\tpp_identifier, not pp_string.  Mark \"({anonymous})\" for\n\ttranslation.\n\t* c-pretty-print.c (pp_c_ws_string): New.\n\t(pp_c_cv_qualifier, pp_c_type_specifier,\n\tpp_c_specifier_qualifier_list, pp_c_parameter_type_list,\n\tpp_c_storage_class_specifier, pp_c_function_specifier,\n\tpp_c_attributes, pp_c_bool_constant, pp_c_constant,\n\tpp_c_primary_expression, pp_c_postfix_expression,\n\tpp_c_unary_expression, pp_c_shift_expression,\n\tpp_c_relational_expression, pp_c_equality_expression,\n\tpp_c_logical_and_expression, pp_c_logical_or_expression): Mostly\n\tuse pp_string and pp_c_ws_string in place of pp_identifier and\n\tpp_c_identifier for non-identifiers.  Mark English strings for\n\ttranslation.\n\t* c-pretty-print.h (pp_c_ws_string): Declare.\n\ncp:\n\t* cxx-pretty-print.c (is_destructor_name, pp_cxx_unqualified_id,\n\tpp_cxx_template_keyword_if_needed, pp_cxx_postfix_expression,\n\tpp_cxx_new_expression, pp_cxx_delete_expression,\n\tpp_cxx_unary_expression, pp_cxx_assignment_operator,\n\tpp_cxx_assignment_expression, pp_cxx_expression,\n\tpp_cxx_function_specifier, pp_cxx_decl_specifier_seq,\n\tpp_cxx_simple_type_specifier, pp_cxx_type_specifier_seq,\n\tpp_cxx_exception_specification, pp_cxx_direct_declarator,\n\tpp_cxx_ctor_initializer, pp_cxx_type_id, pp_cxx_statement,\n\tpp_cxx_namespace_alias_definition, pp_cxx_template_parameter,\n\tpp_cxx_canonical_template_parameter, pp_cxx_template_declaration,\n\tpp_cxx_declaration, pp_cxx_typeid_expression,\n\tpp_cxx_va_arg_expression, pp_cxx_offsetof_expression,\n\tpp_cxx_trait_expression): Mostly use pp_string and\n\tpp_cxx_ws_string in place of pp_identifier and pp_cxx_identifier\n\tfor non-identifiers.  Mark English strings for translation.\n\t* cxx-pretty-print.h (pp_cxx_ws_string): Define.\n\t* error.c (dump_template_parameter, dump_template_bindings,\n\tdump_type, dump_aggr_type, dump_type_prefix, dump_simple_decl,\n\tdump_decl, dump_template_decl, dump_function_decl,\n\tdump_parameters, dump_exception_spec, dump_template_parms,\n\tdump_expr, dump_binary_op, dump_unary_op, op_to_string,\n\tassop_to_string, args_to_string, cp_print_error_function,\n\tprint_instantiation_full_context,\n\tprint_instantiation_partial_context): Mostly use pp_string and\n\tpp_cxx_ws_string in place of pp_identifier and pp_cxx_identifier\n\tfor non-identifiers.  Mark English strings for translation.\n\t(dump_global_iord): Mark strings for translation; use longer\n\tstrings instead of substituting single words.\n\t(function_category): Return a format string marked for\n\ttranslation, not a single word or phrase to substitute in a longer\n\tphrase.\n\nFrom-SVN: r147033", "tree": {"sha": "c73f9284b0b73f23edef3b10866ccd576c4ddca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c73f9284b0b73f23edef3b10866ccd576c4ddca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b0249cbff2a0a1edd3a9437df014738a616141d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0249cbff2a0a1edd3a9437df014738a616141d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0249cbff2a0a1edd3a9437df014738a616141d"}], "stats": {"total": 484, "additions": 279, "deletions": 205}, "files": [{"sha": "75ebba55d480bb1ab1d24608a08db47800097e36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -1,3 +1,22 @@\n+2009-05-01  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-objc-common.c (c_tree_printer): Print identifiers with\n+\tpp_identifier, not pp_string.  Mark \"({anonymous})\" for\n+\ttranslation.\n+\t* c-pretty-print.c (pp_c_ws_string): New.\n+\t(pp_c_cv_qualifier, pp_c_type_specifier,\n+\tpp_c_specifier_qualifier_list, pp_c_parameter_type_list,\n+\tpp_c_storage_class_specifier, pp_c_function_specifier,\n+\tpp_c_attributes, pp_c_bool_constant, pp_c_constant,\n+\tpp_c_primary_expression, pp_c_postfix_expression,\n+\tpp_c_unary_expression, pp_c_shift_expression,\n+\tpp_c_relational_expression, pp_c_equality_expression,\n+\tpp_c_logical_and_expression, pp_c_logical_or_expression): Mostly\n+\tuse pp_string and pp_c_ws_string in place of pp_identifier and\n+\tpp_c_identifier for non-identifiers.  Mark English strings for\n+\ttranslation.\n+\t* c-pretty-print.h (pp_c_ws_string): Declare.\n+\n 2009-04-30  Paul Pluzhnikov  <ppluzhnikov@google.com>\n \t    Roland McGrath <roland@redhat.com>\n "}, {"sha": "d6729ac5d0fc254b1d8943720af045c9342968cc", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -1,5 +1,6 @@\n /* Some code common to C and ObjC front ends.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007,\n+   2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -26,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-config.h\"\n #include \"integrate.h\"\n #include \"c-tree.h\"\n+#include \"intl.h\"\n #include \"c-pretty-print.h\"\n #include \"function.h\"\n #include \"flags.h\"\n@@ -98,7 +100,6 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n {\n   tree t = va_arg (*text->args_ptr, tree);\n   tree name;\n-  const char *n = \"({anonymous})\";\n   c_pretty_printer *cpp = (c_pretty_printer *) pp;\n   pp->padding = pp_none;\n \n@@ -124,7 +125,10 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n \n     case 'F':\n       if (DECL_NAME (t))\n-\tn = lang_hooks.decl_printable_name (t, 2);\n+\t{\n+\t  pp_identifier (cpp, lang_hooks.decl_printable_name (t, 2));\n+\t  return true;\n+\t}\n       break;\n \n     case 'T':\n@@ -134,7 +138,7 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n       if (name && TREE_CODE (name) == TYPE_DECL)\n \t{\n \t  if (DECL_NAME (name))\n-\t    pp_string (cpp, lang_hooks.decl_printable_name (name, 2));\n+\t    pp_identifier (cpp, lang_hooks.decl_printable_name (name, 2));\n \t  else\n \t    pp_type_id (cpp, t);\n \t  return true;\n@@ -148,19 +152,16 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n \n     case 'E':\n       if (TREE_CODE (t) == IDENTIFIER_NODE)\n-\tn = IDENTIFIER_POINTER (t);\n+\tpp_identifier (cpp, IDENTIFIER_POINTER (t));\n       else\n-\t{\n-\t  pp_expression (cpp, t);\n-\t  return true;\n-\t}\n-      break;\n+\tpp_expression (cpp, t);\n+      return true;\n \n     default:\n       return false;\n     }\n \n-  pp_string (cpp, n);\n+  pp_string (cpp, _(\"({anonymous})\"));\n   return true;\n }\n "}, {"sha": "efd15ac9b262186c5357c3393697a490ea6a9af4", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 61, "deletions": 47, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"real.h\"\n #include \"fixed-value.h\"\n+#include \"intl.h\"\n #include \"c-pretty-print.h\"\n #include \"c-tree.h\"\n #include \"tree-iterator.h\"\n@@ -177,7 +178,7 @@ pp_c_cv_qualifier (c_pretty_printer *pp, const char *cv)\n      logic in the C++ pretty-printer.  */\n   if (p != NULL && (*p == '*' || *p == '&'))\n     pp_c_whitespace (pp);\n-  pp_c_identifier (pp, cv);\n+  pp_c_ws_string (pp, cv);\n }\n \n /* Pretty-print T using the type-cast notation '( type-name )'.  */\n@@ -306,7 +307,7 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n   switch (code)\n     {\n     case ERROR_MARK:\n-      pp_c_identifier (pp, \"<type-error>\");\n+      pp_c_ws_string (pp, _(\"<type-error>\"));\n       break;\n \n     case IDENTIFIER_NODE:\n@@ -345,14 +346,14 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n \t\t{\n \t\tcase INTEGER_TYPE:\n \t\t  pp_string (pp, (TYPE_UNSIGNED (t)\n-\t\t\t\t  ? \"<unnamed-unsigned:\"\n-\t\t\t\t  : \"<unnamed-signed:\"));\n+\t\t\t\t  ? _(\"<unnamed-unsigned:\")\n+\t\t\t\t  : _(\"<unnamed-signed:\")));\n \t\t  break;\n \t\tcase REAL_TYPE:\n-\t\t  pp_string (pp, \"<unnamed-float:\");\n+\t\t  pp_string (pp, _(\"<unnamed-float:\"));\n \t\t  break;\n \t\tcase FIXED_POINT_TYPE:\n-\t\t  pp_string (pp, \"<unnamed-fixed:\");\n+\t\t  pp_string (pp, _(\"<unnamed-fixed:\"));\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -367,25 +368,25 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n       if (DECL_NAME (t))\n \tpp_id_expression (pp, t);\n       else\n-\tpp_c_identifier (pp, \"<typedef-error>\");\n+\tpp_c_ws_string (pp, _(\"<typedef-error>\"));\n       break;\n \n     case UNION_TYPE:\n     case RECORD_TYPE:\n     case ENUMERAL_TYPE:\n       if (code == UNION_TYPE)\n-\tpp_c_identifier (pp, \"union\");\n+\tpp_c_ws_string (pp, \"union\");\n       else if (code == RECORD_TYPE)\n-\tpp_c_identifier (pp, \"struct\");\n+\tpp_c_ws_string (pp, \"struct\");\n       else if (code == ENUMERAL_TYPE)\n-\tpp_c_identifier (pp, \"enum\");\n+\tpp_c_ws_string (pp, \"enum\");\n       else\n-\tpp_c_identifier (pp, \"<tag-error>\");\n+\tpp_c_ws_string (pp, _(\"<tag-error>\"));\n \n       if (TYPE_NAME (t))\n \tpp_id_expression (pp, TYPE_NAME (t));\n       else\n-\tpp_c_identifier (pp, \"<anonymous>\");\n+\tpp_c_ws_string (pp, _(\"<anonymous>\"));\n       break;\n \n     default:\n@@ -441,9 +442,9 @@ pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n     case COMPLEX_TYPE:\n       pp_c_specifier_qualifier_list (pp, TREE_TYPE (t));\n       if (code == COMPLEX_TYPE)\n-\tpp_c_identifier (pp, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n+\tpp_c_ws_string (pp, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n       else if (code == VECTOR_TYPE)\n-\tpp_c_identifier (pp, \"__vector__\");\n+\tpp_c_ws_string (pp, \"__vector__\");\n       break;\n \n     default:\n@@ -471,7 +472,7 @@ pp_c_parameter_type_list (c_pretty_printer *pp, tree t)\n   tree parms = want_parm_decl ? DECL_ARGUMENTS (t) :  TYPE_ARG_TYPES (t);\n   pp_c_left_paren (pp);\n   if (parms == void_list_node)\n-    pp_c_identifier (pp, \"void\");\n+    pp_c_ws_string (pp, \"void\");\n   else\n     {\n       bool first = true;\n@@ -587,13 +588,13 @@ void\n pp_c_storage_class_specifier (c_pretty_printer *pp, tree t)\n {\n   if (TREE_CODE (t) == TYPE_DECL)\n-    pp_c_identifier (pp, \"typedef\");\n+    pp_c_ws_string (pp, \"typedef\");\n   else if (DECL_P (t))\n     {\n       if (DECL_REGISTER (t))\n-\tpp_c_identifier (pp, \"register\");\n+\tpp_c_ws_string (pp, \"register\");\n       else if (TREE_STATIC (t) && TREE_CODE (t) == VAR_DECL)\n-\tpp_c_identifier (pp, \"static\");\n+\tpp_c_ws_string (pp, \"static\");\n     }\n }\n \n@@ -604,7 +605,7 @@ void\n pp_c_function_specifier (c_pretty_printer *pp, tree t)\n {\n   if (TREE_CODE (t) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (t))\n-    pp_c_identifier (pp, \"inline\");\n+    pp_c_ws_string (pp, \"inline\");\n }\n \n /* declaration-specifiers:\n@@ -733,7 +734,7 @@ pp_c_attributes (c_pretty_printer *pp, tree attributes)\n   if (attributes == NULL_TREE)\n     return;\n \n-  pp_c_identifier (pp, \"__attribute__\");\n+  pp_c_ws_string (pp, \"__attribute__\");\n   pp_c_left_paren (pp);\n   pp_c_left_paren (pp);\n   for (; attributes != NULL_TREE; attributes = TREE_CHAIN (attributes))\n@@ -869,18 +870,18 @@ pp_c_bool_constant (c_pretty_printer *pp, tree b)\n   if (b == boolean_false_node)\n     {\n       if (c_dialect_cxx ())\n-\tpp_c_identifier (pp, \"false\");\n+\tpp_c_ws_string (pp, \"false\");\n       else if (flag_isoc99)\n-\tpp_c_identifier (pp, \"_False\");\n+\tpp_c_ws_string (pp, \"_False\");\n       else\n \tpp_unsupported_tree (pp, b);\n     }\n   else if (b == boolean_true_node)\n     {\n       if (c_dialect_cxx ())\n-\tpp_c_identifier (pp, \"true\");\n+\tpp_c_ws_string (pp, \"true\");\n       else if (flag_isoc99)\n-\tpp_c_identifier (pp, \"_True\");\n+\tpp_c_ws_string (pp, \"_True\");\n       else\n \tpp_unsupported_tree (pp, b);\n     }\n@@ -1069,7 +1070,20 @@ pp_c_constant (c_pretty_printer *pp, tree e)\n     }\n }\n \n-/* Pretty-print an IDENTIFIER_NODE, preceded by whitespace is necessary.  */\n+/* Pretty-print a string such as an identifier, without changing its\n+   encoding, preceded by whitespace is necessary.  */\n+\n+void\n+pp_c_ws_string (c_pretty_printer *pp, const char *str)\n+{\n+  pp_c_maybe_whitespace (pp);\n+  pp_string (pp, str);\n+  pp_base (pp)->padding = pp_before;\n+}\n+\n+/* Pretty-print an IDENTIFIER_NODE, which may contain UTF-8 sequences\n+   that need converting to the locale encoding, preceded by whitespace\n+   is necessary.  */\n \n void\n pp_c_identifier (c_pretty_printer *pp, const char *id)\n@@ -1105,11 +1119,11 @@ pp_c_primary_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case ERROR_MARK:\n-      pp_c_identifier (pp, \"<erroneous-expression>\");\n+      pp_c_ws_string (pp, _(\"<erroneous-expression>\"));\n       break;\n \n     case RESULT_DECL:\n-      pp_c_identifier (pp, \"<return-value>\");\n+      pp_c_ws_string (pp, _(\"<return-value>\"));\n       break;\n \n     case INTEGER_CST:\n@@ -1120,7 +1134,7 @@ pp_c_primary_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case TARGET_EXPR:\n-      pp_c_identifier (pp, \"__builtin_memcpy\");\n+      pp_c_ws_string (pp, \"__builtin_memcpy\");\n       pp_c_left_paren (pp);\n       pp_ampersand (pp);\n       pp_primary_expression (pp, TREE_OPERAND (e, 0));\n@@ -1338,7 +1352,7 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       pp_postfix_expression (pp, TREE_OPERAND (e, 0));\n-      pp_identifier (pp, code == POSTINCREMENT_EXPR ? \"++\" : \"--\");\n+      pp_string (pp, code == POSTINCREMENT_EXPR ? \"++\" : \"--\");\n       break;\n \n     case ARRAY_REF:\n@@ -1365,49 +1379,49 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n       }\n \n     case UNORDERED_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"isunordered\"\n \t\t\t   : \"__builtin_isunordered\");\n       goto two_args_fun;\n \n     case ORDERED_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"!isunordered\"\n \t\t\t   : \"!__builtin_isunordered\");\n       goto two_args_fun;\n \n     case UNLT_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"!isgreaterequal\"\n \t\t\t   : \"!__builtin_isgreaterequal\");\n       goto two_args_fun;\n \n     case UNLE_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"!isgreater\"\n \t\t\t   : \"!__builtin_isgreater\");\n       goto two_args_fun;\n \n     case UNGT_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"!islessequal\"\n \t\t\t   : \"!__builtin_islessequal\");\n       goto two_args_fun;\n \n     case UNGE_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"!isless\"\n \t\t\t   : \"!__builtin_isless\");\n       goto two_args_fun;\n \n     case UNEQ_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"!islessgreater\"\n \t\t\t   : \"!__builtin_islessgreater\");\n       goto two_args_fun;\n \n     case LTGT_EXPR:\n-      pp_c_identifier (pp, flag_isoc99\n+      pp_c_ws_string (pp, flag_isoc99\n \t\t\t   ? \"islessgreater\"\n \t\t\t   : \"__builtin_islessgreater\");\n       goto two_args_fun;\n@@ -1421,7 +1435,7 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case ABS_EXPR:\n-      pp_c_identifier (pp, \"__builtin_abs\");\n+      pp_c_ws_string (pp, \"__builtin_abs\");\n       pp_c_left_paren (pp);\n       pp_expression (pp, TREE_OPERAND (e, 0));\n       pp_c_right_paren (pp);\n@@ -1491,7 +1505,7 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case VA_ARG_EXPR:\n-      pp_c_identifier (pp, \"__builtin_va_arg\");\n+      pp_c_ws_string (pp, \"__builtin_va_arg\");\n       pp_c_left_paren (pp);\n       pp_assignment_expression (pp, TREE_OPERAND (e, 0));\n       pp_separate_with (pp, ',');\n@@ -1580,7 +1594,7 @@ pp_c_unary_expression (c_pretty_printer *pp, tree e)\n     {\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n-      pp_identifier (pp, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n+      pp_string (pp, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n       pp_c_unary_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n@@ -1606,7 +1620,7 @@ pp_c_unary_expression (c_pretty_printer *pp, tree e)\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_c_identifier (pp, code == REALPART_EXPR ? \"__real__\" : \"__imag__\");\n+      pp_c_ws_string (pp, code == REALPART_EXPR ? \"__real__\" : \"__imag__\");\n       pp_c_whitespace (pp);\n       pp_unary_expression (pp, TREE_OPERAND (e, 0));\n       break;\n@@ -1717,7 +1731,7 @@ pp_c_shift_expression (c_pretty_printer *pp, tree e)\n     case RSHIFT_EXPR:\n       pp_c_shift_expression (pp, TREE_OPERAND (e, 0));\n       pp_c_whitespace (pp);\n-      pp_identifier (pp, code == LSHIFT_EXPR ? \"<<\" : \">>\");\n+      pp_string (pp, code == LSHIFT_EXPR ? \"<<\" : \">>\");\n       pp_c_whitespace (pp);\n       pp_c_additive_expression (pp, TREE_OPERAND (e, 1));\n       break;\n@@ -1751,9 +1765,9 @@ pp_c_relational_expression (c_pretty_printer *pp, tree e)\n       else if (code == GT_EXPR)\n \tpp_greater (pp);\n       else if (code == LE_EXPR)\n-\tpp_identifier (pp, \"<=\");\n+\tpp_string (pp, \"<=\");\n       else if (code == GE_EXPR)\n-\tpp_identifier (pp, \">=\");\n+\tpp_string (pp, \">=\");\n       pp_c_whitespace (pp);\n       pp_c_shift_expression (pp, TREE_OPERAND (e, 1));\n       break;\n@@ -1779,7 +1793,7 @@ pp_c_equality_expression (c_pretty_printer *pp, tree e)\n     case NE_EXPR:\n       pp_c_equality_expression (pp, TREE_OPERAND (e, 0));\n       pp_c_whitespace (pp);\n-      pp_identifier (pp, code == EQ_EXPR ? \"==\" : \"!=\");\n+      pp_string (pp, code == EQ_EXPR ? \"==\" : \"!=\");\n       pp_c_whitespace (pp);\n       pp_c_relational_expression (pp, TREE_OPERAND (e, 1));\n       break;\n@@ -1863,7 +1877,7 @@ pp_c_logical_and_expression (c_pretty_printer *pp, tree e)\n     {\n       pp_c_logical_and_expression (pp, TREE_OPERAND (e, 0));\n       pp_c_whitespace (pp);\n-      pp_identifier (pp, \"&&\");\n+      pp_string (pp, \"&&\");\n       pp_c_whitespace (pp);\n       pp_c_inclusive_or_expression (pp, TREE_OPERAND (e, 1));\n     }\n@@ -1883,7 +1897,7 @@ pp_c_logical_or_expression (c_pretty_printer *pp, tree e)\n     {\n       pp_c_logical_or_expression (pp, TREE_OPERAND (e, 0));\n       pp_c_whitespace (pp);\n-      pp_identifier (pp, \"||\");\n+      pp_string (pp, \"||\");\n       pp_c_whitespace (pp);\n       pp_c_logical_and_expression (pp, TREE_OPERAND (e, 1));\n     }"}, {"sha": "8f12bb0523766896a7861d3ea34c7f2149073d98", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -1,5 +1,5 @@\n /* Various declarations for the C and C++ pretty-printers.\n-   Copyright (C) 2002, 2003, 2004, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -203,6 +203,7 @@ void pp_c_primary_expression (c_pretty_printer *, tree);\n void pp_c_init_declarator (c_pretty_printer *, tree);\n void pp_c_constant (c_pretty_printer *, tree);\n void pp_c_id_expression (c_pretty_printer *, tree);\n+void pp_c_ws_string (c_pretty_printer *, const char *);\n void pp_c_identifier (c_pretty_printer *, const char *);\n void pp_c_string_literal (c_pretty_printer *, tree);\n "}, {"sha": "785dbb1b6b2ae811aaac20a749f3bf5932396e1e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -1,3 +1,38 @@\n+2009-05-01  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* cxx-pretty-print.c (is_destructor_name, pp_cxx_unqualified_id,\n+\tpp_cxx_template_keyword_if_needed, pp_cxx_postfix_expression,\n+\tpp_cxx_new_expression, pp_cxx_delete_expression,\n+\tpp_cxx_unary_expression, pp_cxx_assignment_operator,\n+\tpp_cxx_assignment_expression, pp_cxx_expression,\n+\tpp_cxx_function_specifier, pp_cxx_decl_specifier_seq,\n+\tpp_cxx_simple_type_specifier, pp_cxx_type_specifier_seq,\n+\tpp_cxx_exception_specification, pp_cxx_direct_declarator,\n+\tpp_cxx_ctor_initializer, pp_cxx_type_id, pp_cxx_statement,\n+\tpp_cxx_namespace_alias_definition, pp_cxx_template_parameter,\n+\tpp_cxx_canonical_template_parameter, pp_cxx_template_declaration,\n+\tpp_cxx_declaration, pp_cxx_typeid_expression,\n+\tpp_cxx_va_arg_expression, pp_cxx_offsetof_expression,\n+\tpp_cxx_trait_expression): Mostly use pp_string and\n+\tpp_cxx_ws_string in place of pp_identifier and pp_cxx_identifier\n+\tfor non-identifiers.  Mark English strings for translation.\n+\t* cxx-pretty-print.h (pp_cxx_ws_string): Define.\n+\t* error.c (dump_template_parameter, dump_template_bindings,\n+\tdump_type, dump_aggr_type, dump_type_prefix, dump_simple_decl,\n+\tdump_decl, dump_template_decl, dump_function_decl,\n+\tdump_parameters, dump_exception_spec, dump_template_parms,\n+\tdump_expr, dump_binary_op, dump_unary_op, op_to_string,\n+\tassop_to_string, args_to_string, cp_print_error_function,\n+\tprint_instantiation_full_context,\n+\tprint_instantiation_partial_context): Mostly use pp_string and\n+\tpp_cxx_ws_string in place of pp_identifier and pp_cxx_identifier\n+\tfor non-identifiers.  Mark English strings for translation.\n+\t(dump_global_iord): Mark strings for translation; use longer\n+\tstrings instead of substituting single words.\n+\t(function_category): Return a format string marked for\n+\ttranslation, not a single word or phrase to substitute in a longer\n+\tphrase.\n+\n 2009-04-28  Ben Elliston  <bje@au.ibm.com>\n \n \tPR c++/35652"}, {"sha": "2edffd3754812b657432a8d4d6fc7e7fa9f9d37a", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 70, "deletions": 68, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -1,5 +1,6 @@\n /* Implementation of subroutines for the GNU C++ pretty-printer.\n-   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2007, 2008,\n+   2009 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -23,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"real.h\"\n+#include \"intl.h\"\n #include \"cxx-pretty-print.h\"\n #include \"cp-tree.h\"\n #include \"toplev.h\"\n@@ -116,7 +118,7 @@ is_destructor_name (tree name)\n static inline void\n pp_cxx_conversion_function_id (cxx_pretty_printer *pp, tree t)\n {\n-  pp_cxx_identifier (pp, \"operator\");\n+  pp_cxx_ws_string (pp, \"operator\");\n   pp_cxx_type_specifier_seq (pp, TREE_TYPE (t));\n }\n \n@@ -145,7 +147,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n   switch (code)\n     {\n     case RESULT_DECL:\n-      pp_cxx_identifier (pp, \"<return-value>\");\n+      pp_cxx_ws_string (pp, _(\"<return-value>\"));\n       break;\n \n     case OVERLOAD:\n@@ -164,7 +166,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n \n     case IDENTIFIER_NODE:\n       if (t == NULL)\n-\tpp_cxx_identifier (pp, \"<unnamed>\");\n+\tpp_cxx_ws_string (pp, _(\"<unnamed>\"));\n       else if (IDENTIFIER_TYPENAME_P (t))\n \tpp_cxx_conversion_function_id (pp, t);\n       else\n@@ -237,7 +239,7 @@ pp_cxx_template_keyword_if_needed (cxx_pretty_printer *pp, tree scope, tree t)\n {\n   if (TREE_CODE (t) == TEMPLATE_ID_EXPR\n       && TYPE_P (scope) && dependent_type_p (scope))\n-    pp_cxx_identifier (pp, \"template\");\n+    pp_cxx_ws_string (pp, \"template\");\n }\n \n /* nested-name-specifier:\n@@ -566,13 +568,13 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n     case REINTERPRET_CAST_EXPR:\n     case CONST_CAST_EXPR:\n       if (code == DYNAMIC_CAST_EXPR)\n-\tpp_cxx_identifier (pp, \"dynamic_cast\");\n+\tpp_cxx_ws_string (pp, \"dynamic_cast\");\n       else if (code == STATIC_CAST_EXPR)\n-\tpp_cxx_identifier (pp, \"static_cast\");\n+\tpp_cxx_ws_string (pp, \"static_cast\");\n       else if (code == REINTERPRET_CAST_EXPR)\n-\tpp_cxx_identifier (pp, \"reinterpret_cast\");\n+\tpp_cxx_ws_string (pp, \"reinterpret_cast\");\n       else\n-\tpp_cxx_identifier (pp, \"const_cast\");\n+\tpp_cxx_ws_string (pp, \"const_cast\");\n       pp_cxx_begin_template_argument_list (pp);\n       pp_cxx_type_id (pp, TREE_TYPE (t));\n       pp_cxx_end_template_argument_list (pp);\n@@ -644,7 +646,7 @@ pp_cxx_new_expression (cxx_pretty_printer *pp, tree t)\n     case VEC_NEW_EXPR:\n       if (NEW_EXPR_USE_GLOBAL (t))\n \tpp_cxx_colon_colon (pp);\n-      pp_cxx_identifier (pp, \"new\");\n+      pp_cxx_ws_string (pp, \"new\");\n       if (TREE_OPERAND (t, 0))\n \t{\n \t  pp_cxx_call_argument_list (pp, TREE_OPERAND (t, 0));\n@@ -689,7 +691,7 @@ pp_cxx_delete_expression (cxx_pretty_printer *pp, tree t)\n     case VEC_DELETE_EXPR:\n       if (DELETE_EXPR_USE_GLOBAL (t))\n \tpp_cxx_colon_colon (pp);\n-      pp_cxx_identifier (pp, \"delete\");\n+      pp_cxx_ws_string (pp, \"delete\");\n       pp_space (pp);\n       if (code == VEC_DELETE_EXPR\n \t  || DELETE_EXPR_USE_VEC (t))\n@@ -743,8 +745,8 @@ pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n \t{\n-\t  pp_cxx_identifier (pp, \"sizeof\");\n-\t  pp_cxx_identifier (pp, \"...\");\n+\t  pp_cxx_ws_string (pp, \"sizeof\");\n+\t  pp_cxx_ws_string (pp, \"...\");\n \t  pp_cxx_whitespace (pp);\n \t  pp_cxx_left_paren (pp);\n \t  if (TYPE_P (TREE_OPERAND (t, 0)))\n@@ -757,7 +759,7 @@ pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n       /* Fall through  */\n \n     case ALIGNOF_EXPR:\n-      pp_cxx_identifier (pp, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n+      pp_cxx_ws_string (pp, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n       pp_cxx_whitespace (pp);\n       if (TYPE_P (TREE_OPERAND (t, 0)))\n \t{\n@@ -924,7 +926,7 @@ pp_cxx_assignment_operator (cxx_pretty_printer *pp, tree t)\n       break;\n     }\n \n-  pp_cxx_identifier (pp, op);\n+  pp_cxx_ws_string (pp, op);\n }\n \n \n@@ -954,7 +956,7 @@ pp_cxx_assignment_expression (cxx_pretty_printer *pp, tree e)\n       break;\n \n     case THROW_EXPR:\n-      pp_cxx_identifier (pp, \"throw\");\n+      pp_cxx_ws_string (pp, \"throw\");\n       if (TREE_OPERAND (e, 0))\n \tpp_cxx_assignment_expression (pp, TREE_OPERAND (e, 0));\n       break;\n@@ -1076,7 +1078,7 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n \n     case EXPR_PACK_EXPANSION:\n       pp_cxx_expression (pp, PACK_EXPANSION_PATTERN (t));\n-      pp_cxx_identifier (pp, \"...\");\n+      pp_cxx_ws_string (pp, \"...\");\n       break;\n \n     case NONTYPE_ARGUMENT_PACK:\n@@ -1113,9 +1115,9 @@ pp_cxx_function_specifier (cxx_pretty_printer *pp, tree t)\n     {\n     case FUNCTION_DECL:\n       if (DECL_VIRTUAL_P (t))\n-\tpp_cxx_identifier (pp, \"virtual\");\n+\tpp_cxx_ws_string (pp, \"virtual\");\n       else if (DECL_CONSTRUCTOR_P (t) && DECL_NONCONVERTING_P (t))\n-\tpp_cxx_identifier (pp, \"explicit\");\n+\tpp_cxx_ws_string (pp, \"explicit\");\n       else\n \tpp_c_function_specifier (pp_c_base (pp), t);\n \n@@ -1148,7 +1150,7 @@ pp_cxx_decl_specifier_seq (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case TYPE_DECL:\n-      pp_cxx_identifier (pp, \"typedef\");\n+      pp_cxx_ws_string (pp, \"typedef\");\n       pp_cxx_decl_specifier_seq (pp, TREE_TYPE (t));\n       break;\n \n@@ -1209,7 +1211,7 @@ pp_cxx_simple_type_specifier (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case TYPENAME_TYPE:\n-      pp_cxx_identifier (pp, \"typename\");\n+      pp_cxx_ws_string (pp, \"typename\");\n       pp_cxx_nested_name_specifier (pp, TYPE_CONTEXT (t));\n       pp_cxx_unqualified_id (pp, TYPE_NAME (t));\n       break;\n@@ -1251,7 +1253,7 @@ pp_cxx_type_specifier_seq (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case DECLTYPE_TYPE:\n-      pp_cxx_identifier (pp, \"decltype\");\n+      pp_cxx_ws_string (pp, \"decltype\");\n       pp_cxx_left_paren (pp);\n       pp_cxx_expression (pp, DECLTYPE_TYPE_EXPR (t));\n       pp_cxx_right_paren (pp);\n@@ -1393,7 +1395,7 @@ pp_cxx_exception_specification (cxx_pretty_printer *pp, tree t)\n \n   if (!TYPE_NOTHROW_P (t) && ex_spec == NULL)\n     return;\n-  pp_cxx_identifier (pp, \"throw\");\n+  pp_cxx_ws_string (pp, \"throw\");\n   pp_cxx_left_paren (pp);\n   for (; ex_spec && TREE_VALUE (ex_spec); ex_spec = TREE_CHAIN (ex_spec))\n     {\n@@ -1447,7 +1449,7 @@ pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n \t      || template_parameter_pack_p (t))\n \t    /* A function parameter pack or non-type template\n \t       parameter pack.  */\n-\t    pp_cxx_identifier (pp, \"...\");\n+\t    pp_cxx_ws_string (pp, \"...\");\n \t\t      \n \t  pp_cxx_id_expression (pp, DECL_NAME (t));\n \t}\n@@ -1523,7 +1525,7 @@ pp_cxx_ctor_initializer (cxx_pretty_printer *pp, tree t)\n \tpp_cxx_primary_expression (pp, purpose);\n       pp_cxx_call_argument_list (pp, TREE_VALUE (t));\n       if (is_pack)\n-\tpp_cxx_identifier (pp, \"...\");\n+\tpp_cxx_ws_string (pp, \"...\");\n       if (TREE_CHAIN (t))\n \tpp_cxx_separate_with (pp, ',');\n     }\n@@ -1647,7 +1649,7 @@ pp_cxx_type_id (cxx_pretty_printer *pp, tree t)\n \n     case TYPE_PACK_EXPANSION:\n       pp_cxx_type_id (pp, PACK_EXPANSION_PATTERN (t));\n-      pp_cxx_identifier (pp, \"...\");\n+      pp_cxx_ws_string (pp, \"...\");\n       break;\n \n     default:\n@@ -1730,15 +1732,15 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case USING_STMT:\n-      pp_cxx_identifier (pp, \"using\");\n-      pp_cxx_identifier (pp, \"namespace\");\n+      pp_cxx_ws_string (pp, \"using\");\n+      pp_cxx_ws_string (pp, \"namespace\");\n       if (DECL_CONTEXT (t))\n \tpp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n       pp_cxx_qualified_id (pp, USING_STMT_NAMESPACE (t));\n       break;\n \n     case USING_DECL:\n-      pp_cxx_identifier (pp, \"using\");\n+      pp_cxx_ws_string (pp, \"using\");\n       pp_cxx_nested_name_specifier (pp, USING_DECL_SCOPE (t));\n       pp_cxx_unqualified_id (pp, DECL_NAME (t));\n       break;\n@@ -1750,7 +1752,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \t    try compound-statement handler-seq  */\n     case TRY_BLOCK:\n       pp_maybe_newline_and_indent (pp, 0);\n-      pp_cxx_identifier (pp, \"try\");\n+      pp_cxx_ws_string (pp, \"try\");\n       pp_newline_and_indent (pp, 3);\n       pp_cxx_statement (pp, TRY_STMTS (t));\n       pp_newline_and_indent (pp, -3);\n@@ -1772,7 +1774,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \t    type-specifier-seq abstract-declarator\n \t    ...   */\n     case HANDLER:\n-      pp_cxx_identifier (pp, \"catch\");\n+      pp_cxx_ws_string (pp, \"catch\");\n       pp_cxx_left_paren (pp);\n       pp_cxx_exception_declaration (pp, HANDLER_PARMS (t));\n       pp_cxx_right_paren (pp);\n@@ -1787,7 +1789,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \t    if ( expression ) statement\n \t    if ( expression ) statement else statement  */\n     case IF_STMT:\n-      pp_cxx_identifier (pp, \"if\");\n+      pp_cxx_ws_string (pp, \"if\");\n       pp_cxx_whitespace (pp);\n       pp_cxx_left_paren (pp);\n       pp_cxx_expression (pp, IF_COND (t));\n@@ -1798,7 +1800,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       if (ELSE_CLAUSE (t))\n \t{\n \t  tree else_clause = ELSE_CLAUSE (t);\n-\t  pp_cxx_identifier (pp, \"else\");\n+\t  pp_cxx_ws_string (pp, \"else\");\n \t  if (TREE_CODE (else_clause) == IF_STMT)\n \t    pp_cxx_whitespace (pp);\n \t  else\n@@ -1810,7 +1812,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case SWITCH_STMT:\n-      pp_cxx_identifier (pp, \"switch\");\n+      pp_cxx_ws_string (pp, \"switch\");\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n       pp_cxx_expression (pp, SWITCH_STMT_COND (t));\n@@ -1827,7 +1829,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \t    for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n \t    for ( declaration expression(opt) ; expression(opt) ) statement  */\n     case WHILE_STMT:\n-      pp_cxx_identifier (pp, \"while\");\n+      pp_cxx_ws_string (pp, \"while\");\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n       pp_cxx_expression (pp, WHILE_COND (t));\n@@ -1839,11 +1841,11 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case DO_STMT:\n-      pp_cxx_identifier (pp, \"do\");\n+      pp_cxx_ws_string (pp, \"do\");\n       pp_newline_and_indent (pp, 3);\n       pp_cxx_statement (pp, DO_BODY (t));\n       pp_newline_and_indent (pp, -3);\n-      pp_cxx_identifier (pp, \"while\");\n+      pp_cxx_ws_string (pp, \"while\");\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n       pp_cxx_expression (pp, DO_COND (t));\n@@ -1853,7 +1855,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case FOR_STMT:\n-      pp_cxx_identifier (pp, \"for\");\n+      pp_cxx_ws_string (pp, \"for\");\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n       if (FOR_INIT_STMT (t))\n@@ -1882,7 +1884,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \t    return expression(opt) ;  */\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n-      pp_identifier (pp, TREE_CODE (t) == BREAK_STMT ? \"break\" : \"continue\");\n+      pp_string (pp, TREE_CODE (t) == BREAK_STMT ? \"break\" : \"continue\");\n       pp_cxx_semicolon (pp);\n       pp_needs_newline (pp) = true;\n       break;\n@@ -1896,11 +1898,11 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case CLEANUP_STMT:\n-      pp_cxx_identifier (pp, \"try\");\n+      pp_cxx_ws_string (pp, \"try\");\n       pp_newline_and_indent (pp, 2);\n       pp_cxx_statement (pp, CLEANUP_BODY (t));\n       pp_newline_and_indent (pp, -2);\n-      pp_cxx_identifier (pp, CLEANUP_EH_ONLY (t) ? \"catch\" : \"finally\");\n+      pp_cxx_ws_string (pp, CLEANUP_EH_ONLY (t) ? \"catch\" : \"finally\");\n       pp_newline_and_indent (pp, 2);\n       pp_cxx_statement (pp, CLEANUP_EXPR (t));\n       pp_newline_and_indent (pp, -2);\n@@ -1924,7 +1926,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n static void\n pp_cxx_original_namespace_definition (cxx_pretty_printer *pp, tree t)\n {\n-  pp_cxx_identifier (pp, \"namespace\");\n+  pp_cxx_ws_string (pp, \"namespace\");\n   if (DECL_CONTEXT (t))\n     pp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n   if (DECL_NAME (t))\n@@ -1948,7 +1950,7 @@ pp_cxx_original_namespace_definition (cxx_pretty_printer *pp, tree t)\n static void\n pp_cxx_namespace_alias_definition (cxx_pretty_printer *pp, tree t)\n {\n-  pp_cxx_identifier (pp, \"namespace\");\n+  pp_cxx_ws_string (pp, \"namespace\");\n   if (DECL_CONTEXT (t))\n     pp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n   pp_cxx_unqualified_id (pp, t);\n@@ -2011,9 +2013,9 @@ pp_cxx_template_parameter (cxx_pretty_printer *pp, tree t)\n   switch (TREE_CODE (parameter))\n     {\n     case TYPE_DECL:\n-      pp_cxx_identifier (pp, \"class\");\n+      pp_cxx_ws_string (pp, \"class\");\n       if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))\n-\tpp_cxx_identifier (pp, \"...\");\n+\tpp_cxx_ws_string (pp, \"...\");\n       if (DECL_NAME (parameter))\n \tpp_cxx_tree_identifier (pp, DECL_NAME (parameter));\n       /* FIXME: Check if we should print also default argument.  */\n@@ -2046,7 +2048,7 @@ pp_cxx_canonical_template_parameter (cxx_pretty_printer *pp, tree parm)\n     parm = TEMPLATE_TYPE_PARM_INDEX (parm);\n \n   pp_cxx_begin_template_argument_list (pp);\n-  pp_cxx_identifier (pp, \"template-parameter-\");\n+  pp_cxx_ws_string (pp, _(\"template-parameter-\"));\n   pp_wide_integer (pp, TEMPLATE_PARM_LEVEL (parm));\n   pp_minus (pp);\n   pp_wide_integer (pp, TEMPLATE_PARM_IDX (parm) + 1);\n@@ -2067,7 +2069,7 @@ pp_cxx_template_declaration (cxx_pretty_printer *pp, tree t)\n   pp_maybe_newline_and_indent (pp, 0);\n   for (level = DECL_TEMPLATE_PARMS (tmpl); level; level = TREE_CHAIN (level))\n     {\n-      pp_cxx_identifier (pp, \"template\");\n+      pp_cxx_ws_string (pp, \"template\");\n       pp_cxx_begin_template_argument_list (pp);\n       pp_cxx_template_parameter_list (pp, TREE_VALUE (level));\n       pp_cxx_end_template_argument_list (pp);\n@@ -2114,7 +2116,7 @@ pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n {\n   if (TREE_CODE (t) == STATIC_ASSERT)\n     {\n-      pp_cxx_identifier (pp, \"static_assert\");\n+      pp_cxx_ws_string (pp, \"static_assert\");\n       pp_cxx_left_paren (pp);\n       pp_cxx_expression (pp, STATIC_ASSERT_CONDITION (t));\n       pp_cxx_separate_with (pp, ',');\n@@ -2172,7 +2174,7 @@ static void\n pp_cxx_typeid_expression (cxx_pretty_printer *pp, tree t)\n {\n   t = TREE_OPERAND (t, 0);\n-  pp_cxx_identifier (pp, \"typeid\");\n+  pp_cxx_ws_string (pp, \"typeid\");\n   pp_cxx_left_paren (pp);\n   if (TYPE_P (t))\n     pp_cxx_type_id (pp, t);\n@@ -2184,7 +2186,7 @@ pp_cxx_typeid_expression (cxx_pretty_printer *pp, tree t)\n void\n pp_cxx_va_arg_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_cxx_identifier (pp, \"va_arg\");\n+  pp_cxx_ws_string (pp, \"va_arg\");\n   pp_cxx_left_paren (pp);\n   pp_cxx_assignment_expression (pp, TREE_OPERAND (t, 0));\n   pp_cxx_separate_with (pp, ',');\n@@ -2228,7 +2230,7 @@ pp_cxx_offsetof_expression_1 (cxx_pretty_printer *pp, tree t)\n void\n pp_cxx_offsetof_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_cxx_identifier (pp, \"offsetof\");\n+  pp_cxx_ws_string (pp, \"offsetof\");\n   pp_cxx_left_paren (pp);\n   if (!pp_cxx_offsetof_expression_1 (pp, TREE_OPERAND (t, 0)))\n     pp_cxx_expression (pp, TREE_OPERAND (t, 0));\n@@ -2243,55 +2245,55 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n   switch (kind)\n     {\n     case CPTK_HAS_NOTHROW_ASSIGN:\n-      pp_cxx_identifier (pp, \"__has_nothrow_assign\");\n+      pp_cxx_ws_string (pp, \"__has_nothrow_assign\");\n       break;\n     case CPTK_HAS_TRIVIAL_ASSIGN:\n-      pp_cxx_identifier (pp, \"__has_trivial_assign\");\n+      pp_cxx_ws_string (pp, \"__has_trivial_assign\");\n       break;\n     case CPTK_HAS_NOTHROW_CONSTRUCTOR:\n-      pp_cxx_identifier (pp, \"__has_nothrow_constructor\");\n+      pp_cxx_ws_string (pp, \"__has_nothrow_constructor\");\n       break;\n     case CPTK_HAS_TRIVIAL_CONSTRUCTOR:\n-      pp_cxx_identifier (pp, \"__has_trivial_constructor\");\n+      pp_cxx_ws_string (pp, \"__has_trivial_constructor\");\n       break;\n     case CPTK_HAS_NOTHROW_COPY:\n-      pp_cxx_identifier (pp, \"__has_nothrow_copy\");\n+      pp_cxx_ws_string (pp, \"__has_nothrow_copy\");\n       break;\n     case CPTK_HAS_TRIVIAL_COPY:\n-      pp_cxx_identifier (pp, \"__has_trivial_copy\");\n+      pp_cxx_ws_string (pp, \"__has_trivial_copy\");\n       break;\n     case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n-      pp_cxx_identifier (pp, \"__has_trivial_destructor\");\n+      pp_cxx_ws_string (pp, \"__has_trivial_destructor\");\n       break;\n     case CPTK_HAS_VIRTUAL_DESTRUCTOR:\n-      pp_cxx_identifier (pp, \"__has_virtual_destructor\");\n+      pp_cxx_ws_string (pp, \"__has_virtual_destructor\");\n       break;\n     case CPTK_IS_ABSTRACT:\n-      pp_cxx_identifier (pp, \"__is_abstract\");\n+      pp_cxx_ws_string (pp, \"__is_abstract\");\n       break;\n     case CPTK_IS_BASE_OF:\n-      pp_cxx_identifier (pp, \"__is_base_of\");\n+      pp_cxx_ws_string (pp, \"__is_base_of\");\n       break;\n     case CPTK_IS_CLASS:\n-      pp_cxx_identifier (pp, \"__is_class\");\n+      pp_cxx_ws_string (pp, \"__is_class\");\n       break;\n     case CPTK_IS_CONVERTIBLE_TO:\n-      pp_cxx_identifier (pp, \"__is_convertible_to\");\n+      pp_cxx_ws_string (pp, \"__is_convertible_to\");\n       break;\n     case CPTK_IS_EMPTY:\n-      pp_cxx_identifier (pp, \"__is_empty\");\n+      pp_cxx_ws_string (pp, \"__is_empty\");\n       break;\n     case CPTK_IS_ENUM:\n-      pp_cxx_identifier (pp, \"__is_enum\");\n+      pp_cxx_ws_string (pp, \"__is_enum\");\n       break;\n     case CPTK_IS_POD:\n-      pp_cxx_identifier (pp, \"__is_pod\");\n+      pp_cxx_ws_string (pp, \"__is_pod\");\n       break;\n     case CPTK_IS_POLYMORPHIC:\n-      pp_cxx_identifier (pp, \"__is_polymorphic\");\n+      pp_cxx_ws_string (pp, \"__is_polymorphic\");\n       break;\n     case CPTK_IS_UNION:\n-      pp_cxx_identifier (pp, \"__is_union\");\n+      pp_cxx_ws_string (pp, \"__is_union\");\n       break;\n \n     default:"}, {"sha": "a88d4c5ccdb945196f0edccf2ee0a6a3994fc35f", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -1,5 +1,5 @@\n /* Interface for the GNU C++ pretty-printer.\n-   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -57,6 +57,7 @@ typedef struct\n #define pp_cxx_semicolon(PP)\t\tpp_c_semicolon (pp_c_base (PP))\n #define pp_cxx_complement(PP)\t\tpp_c_complement (pp_c_base (PP))\n \n+#define pp_cxx_ws_string(PP, I)\t\tpp_c_ws_string (pp_c_base (PP), I)\n #define pp_cxx_identifier(PP, I)\tpp_c_identifier (pp_c_base (PP), I)\n #define pp_cxx_tree_identifier(PP, T) \\\n   pp_c_tree_identifier (pp_c_base (PP), T)"}, {"sha": "13b32ad1850b433cfe4e0b43303586cd777603d5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 78, "deletions": 77, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02cec6ee663faf0f8b84d22a23d87a47d0d48c7/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b02cec6ee663faf0f8b84d22a23d87a47d0d48c7", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"langhooks-def.h\"\n+#include \"intl.h\"\n #include \"cxx-pretty-print.h\"\n #include \"pointer-set.h\"\n \n@@ -231,9 +232,9 @@ dump_template_parameter (tree parm, int flags)\n     {\n       if (flags & TFF_DECL_SPECIFIERS)\n \t{\n-\t  pp_cxx_identifier (cxx_pp, \"class\");\n+\t  pp_cxx_ws_string (cxx_pp, \"class\");\n           if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (p)))\n-            pp_cxx_identifier (cxx_pp, \"...\");\n+            pp_cxx_ws_string (cxx_pp, \"...\");\n \t  if (DECL_NAME (p))\n \t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n \t}\n@@ -297,7 +298,7 @@ dump_template_bindings (tree parms, tree args, VEC(tree,gc)* typenames)\n \t  if (arg)\n \t    dump_template_argument (arg, TFF_PLAIN_IDENTIFIER);\n \t  else\n-\t    pp_identifier (cxx_pp, \"<missing>\");\n+\t    pp_string (cxx_pp, _(\"<missing>\"));\n \n \t  ++arg_idx;\n \t  need_comma = 1;\n@@ -338,9 +339,9 @@ dump_type (tree t, int flags)\n     {\n     case UNKNOWN_TYPE:\n       if (t == init_list_type_node)\n-\tpp_identifier (cxx_pp, \"<brace-enclosed initializer list>\");\n+\tpp_string (cxx_pp, _(\"<brace-enclosed initializer list>\"));\n       else\n-\tpp_identifier (cxx_pp, \"<unresolved overloaded function type>\");\n+\tpp_string (cxx_pp, _(\"<unresolved overloaded function type>\"));\n       break;\n \n     case TREE_LIST:\n@@ -436,7 +437,7 @@ dump_type (tree t, int flags)\n \t  break;\n \t}\n       pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-      pp_cxx_identifier (cxx_pp,\n+      pp_cxx_ws_string (cxx_pp,\n \t\t\t TYPENAME_IS_ENUM_P (t) ? \"enum\"\n \t\t\t : TYPENAME_IS_CLASS_P (t) ? \"class\"\n \t\t\t : \"typename\");\n@@ -446,12 +447,12 @@ dump_type (tree t, int flags)\n     case UNBOUND_CLASS_TEMPLATE:\n       dump_type (TYPE_CONTEXT (t), flags);\n       pp_cxx_colon_colon (cxx_pp);\n-      pp_cxx_identifier (cxx_pp, \"template\");\n+      pp_cxx_ws_string (cxx_pp, \"template\");\n       dump_type (DECL_NAME (TYPE_NAME (t)), flags);\n       break;\n \n     case TYPEOF_TYPE:\n-      pp_cxx_identifier (cxx_pp, \"__typeof__\");\n+      pp_cxx_ws_string (cxx_pp, \"__typeof__\");\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_paren (cxx_pp);\n       dump_expr (TYPEOF_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n@@ -460,15 +461,15 @@ dump_type (tree t, int flags)\n \n     case TYPE_PACK_EXPANSION:\n       dump_type (PACK_EXPANSION_PATTERN (t), flags);\n-      pp_cxx_identifier (cxx_pp, \"...\");\n+      pp_cxx_ws_string (cxx_pp, \"...\");\n       break;\n \n     case TYPE_ARGUMENT_PACK:\n       dump_template_argument (t, flags);\n       break;\n \n     case DECLTYPE_TYPE:\n-      pp_cxx_identifier (cxx_pp, \"decltype\");\n+      pp_cxx_ws_string (cxx_pp, \"decltype\");\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_paren (cxx_pp);\n       dump_expr (DECLTYPE_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n@@ -480,7 +481,7 @@ dump_type (tree t, int flags)\n       /* Fall through to error.  */\n \n     case ERROR_MARK:\n-      pp_identifier (cxx_pp, \"<type error>\");\n+      pp_string (cxx_pp, _(\"<type error>\"));\n       break;\n     }\n }\n@@ -535,7 +536,7 @@ dump_aggr_type (tree t, int flags)\n   pp_cxx_cv_qualifier_seq (cxx_pp, t);\n \n   if (flags & TFF_CLASS_KEY_OR_ENUM)\n-    pp_cxx_identifier (cxx_pp, variety);\n+    pp_cxx_ws_string (cxx_pp, variety);\n \n   name = TYPE_NAME (t);\n \n@@ -577,9 +578,9 @@ dump_aggr_type (tree t, int flags)\n   if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n       if (flags & TFF_CLASS_KEY_OR_ENUM)\n-\tpp_identifier (cxx_pp, \"<anonymous>\");\n+\tpp_string (cxx_pp, _(\"<anonymous>\"));\n       else\n-\tpp_printf (pp_base (cxx_pp), \"<anonymous %s>\", variety);\n+\tpp_printf (pp_base (cxx_pp), _(\"<anonymous %s>\"), variety);\n     }\n   else\n     pp_cxx_tree_identifier (cxx_pp, name);\n@@ -701,7 +702,7 @@ dump_type_prefix (tree t, int flags)\n       pp_unsupported_tree (cxx_pp, t);\n       /* fall through.  */\n     case ERROR_MARK:\n-      pp_identifier (cxx_pp, \"<typeprefixerror>\");\n+      pp_string (cxx_pp, _(\"<typeprefixerror>\"));\n       break;\n     }\n }\n@@ -811,13 +812,13 @@ dump_global_iord (tree t)\n   const char *p = NULL;\n \n   if (DECL_GLOBAL_CTOR_P (t))\n-    p = \"initializers\";\n+    p = _(\"(static initializers for %s)\");\n   else if (DECL_GLOBAL_DTOR_P (t))\n-    p = \"destructors\";\n+    p = _(\"(static destructors for %s)\");\n   else\n     gcc_unreachable ();\n \n-  pp_printf (pp_base (cxx_pp), \"(static %s for %s)\", p, input_filename);\n+  pp_printf (pp_base (cxx_pp), p, input_filename);\n }\n \n static void\n@@ -836,11 +837,11 @@ dump_simple_decl (tree t, tree type, int flags)\n   if ((flags & TFF_DECL_SPECIFIERS)\n       && DECL_TEMPLATE_PARM_P (t) \n       && TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (t)))\n-    pp_identifier (cxx_pp, \"...\");\n+    pp_string (cxx_pp, \"...\");\n   if (DECL_NAME (t))\n     dump_decl (DECL_NAME (t), flags);\n   else\n-    pp_identifier (cxx_pp, \"<anonymous>\");\n+    pp_string (cxx_pp, _(\"<anonymous>\"));\n   if (flags & TFF_DECL_SPECIFIERS)\n     dump_type_suffix (type, flags);\n }\n@@ -863,18 +864,18 @@ dump_decl (tree t, int flags)\n \t      && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n \t    {\n \t      /* Say `class T' not just `T'.  */\n-\t      pp_cxx_identifier (cxx_pp, \"class\");\n+\t      pp_cxx_ws_string (cxx_pp, \"class\");\n \n \t      /* Emit the `...' for a parameter pack.  */\n \t      if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))\n-\t\tpp_cxx_identifier (cxx_pp, \"...\");\n+\t\tpp_cxx_ws_string (cxx_pp, \"...\");\n \t    }\n \n \t  dump_type (TREE_TYPE (t), flags);\n \t  break;\n \t}\n       if (flags & TFF_DECL_SPECIFIERS)\n-\tpp_cxx_identifier (cxx_pp, \"typedef\");\n+\tpp_cxx_ws_string (cxx_pp, \"typedef\");\n       dump_simple_decl (t, DECL_ORIGINAL_TYPE (t)\n \t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n \t\t\tflags);\n@@ -883,7 +884,7 @@ dump_decl (tree t, int flags)\n     case VAR_DECL:\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n-\t  pp_string (cxx_pp, \"vtable for \");\n+\t  pp_string (cxx_pp, _(\"vtable for \"));\n \t  gcc_assert (TYPE_P (DECL_CONTEXT (t)));\n \t  dump_type (DECL_CONTEXT (t), flags);\n \t  break;\n@@ -895,7 +896,7 @@ dump_decl (tree t, int flags)\n       break;\n \n     case RESULT_DECL:\n-      pp_string (cxx_pp, \"<return value> \");\n+      pp_string (cxx_pp, _(\"<return value> \"));\n       dump_simple_decl (t, TREE_TYPE (t), flags);\n       break;\n \n@@ -908,7 +909,7 @@ dump_decl (tree t, int flags)\n \t    dump_scope (CP_DECL_CONTEXT (t), flags);\n \t  flags &= ~TFF_UNQUALIFIED_NAME;\n \t  if (DECL_NAME (t) == NULL_TREE)\n-\t    pp_identifier (cxx_pp, \"<unnamed>\");\n+\t    pp_string (cxx_pp, _(\"<unnamed>\"));\n \t  else\n \t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n \t}\n@@ -948,7 +949,7 @@ dump_decl (tree t, int flags)\n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t))\n \t{\n-\t  pp_cxx_identifier (cxx_pp, \"operator\");\n+\t  pp_cxx_ws_string (cxx_pp, \"operator\");\n \t  /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n \t  dump_type (TREE_TYPE (t), flags);\n \t  break;\n@@ -982,7 +983,7 @@ dump_decl (tree t, int flags)\n \n     case FUNCTION_DECL:\n       if (! DECL_LANG_SPECIFIC (t))\n-\tpp_identifier (cxx_pp, \"<built-in>\");\n+\tpp_string (cxx_pp, _(\"<built-in>\"));\n       else if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n \tdump_global_iord (t);\n       else\n@@ -1021,11 +1022,11 @@ dump_decl (tree t, int flags)\n       else if (DECL_INITIAL (t))\n \tdump_expr (DECL_INITIAL (t), flags | TFF_EXPR_IN_PARENS);\n       else\n-\tpp_identifier (cxx_pp, \"<enumerator>\");\n+\tpp_string (cxx_pp, _(\"<enumerator>\"));\n       break;\n \n     case USING_DECL:\n-      pp_cxx_identifier (cxx_pp, \"using\");\n+      pp_cxx_ws_string (cxx_pp, \"using\");\n       dump_type (USING_DECL_SCOPE (t), flags);\n       pp_cxx_colon_colon (cxx_pp);\n       dump_decl (DECL_NAME (t), flags);\n@@ -1061,7 +1062,7 @@ dump_decl (tree t, int flags)\n       /* Fall through to error.  */\n \n     case ERROR_MARK:\n-      pp_identifier (cxx_pp, \"<declaration error>\");\n+      pp_string (cxx_pp, _(\"<declaration error>\"));\n       break;\n     }\n }\n@@ -1085,7 +1086,7 @@ dump_template_decl (tree t, int flags)\n \t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n \t  int len = TREE_VEC_LENGTH (inner_parms);\n \n-\t  pp_cxx_identifier (cxx_pp, \"template\");\n+\t  pp_cxx_ws_string (cxx_pp, \"template\");\n \t  pp_cxx_begin_template_argument_list (cxx_pp);\n \n \t  /* If we've shown the template prefix, we'd better show the\n@@ -1106,11 +1107,11 @@ dump_template_decl (tree t, int flags)\n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n \t{\n \t  /* Say `template<arg> class TT' not just `template<arg> TT'.  */\n-\t  pp_cxx_identifier (cxx_pp, \"class\");\n+\t  pp_cxx_ws_string (cxx_pp, \"class\");\n \n \t  /* If this is a parameter pack, print the ellipsis.  */\n \t  if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))\n-\t    pp_cxx_identifier (cxx_pp, \"...\");\n+\t    pp_cxx_ws_string (cxx_pp, \"...\");\n \t}\n     }\n \n@@ -1241,9 +1242,9 @@ dump_function_decl (tree t, int flags)\n   if (!(flags & TFF_DECL_SPECIFIERS))\n     /* OK */;\n   else if (DECL_STATIC_FUNCTION_P (t))\n-    pp_cxx_identifier (cxx_pp, \"static\");\n+    pp_cxx_ws_string (cxx_pp, \"static\");\n   else if (DECL_VIRTUAL_P (t))\n-    pp_cxx_identifier (cxx_pp, \"virtual\");\n+    pp_cxx_ws_string (cxx_pp, \"virtual\");\n \n   /* Print the return type?  */\n   if (show_return)\n@@ -1291,7 +1292,7 @@ dump_function_decl (tree t, int flags)\n     {\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_bracket (cxx_pp);\n-      pp_cxx_identifier (cxx_pp, \"with\");\n+      pp_cxx_ws_string (cxx_pp, _(\"with\"));\n       pp_cxx_whitespace (cxx_pp);\n       dump_template_bindings (template_parms, template_args, typenames);\n       pp_cxx_right_bracket (cxx_pp);\n@@ -1316,7 +1317,7 @@ dump_parameters (tree parmtypes, int flags)\n       first = 0;\n       if (!parmtypes)\n \t{\n-\t  pp_cxx_identifier (cxx_pp, \"...\");\n+\t  pp_cxx_ws_string (cxx_pp, \"...\");\n \t  break;\n \t}\n \n@@ -1341,7 +1342,7 @@ dump_exception_spec (tree t, int flags)\n {\n   if (t)\n     {\n-      pp_cxx_identifier (cxx_pp, \"throw\");\n+      pp_cxx_ws_string (cxx_pp, \"throw\");\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_paren (cxx_pp);\n       if (TREE_VALUE (t) != NULL_TREE)\n@@ -1397,7 +1398,7 @@ dump_function_name (tree t, int flags)\n \t declarations, both will have the same name, yet\n \t the types will be different, hence the TREE_TYPE field\n \t of the first name will be clobbered by the second.  */\n-      pp_cxx_identifier (cxx_pp, \"operator\");\n+      pp_cxx_ws_string (cxx_pp, \"operator\");\n       dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n   else if (IDENTIFIER_OPNAME_P (name))\n@@ -1456,7 +1457,7 @@ dump_template_parms (tree info, int primary, int flags)\n             pp_separate_with_comma (cxx_pp);\n           \n           if (!arg)\n-            pp_identifier (cxx_pp, \"<template parameter error>\");\n+            pp_string (cxx_pp, _(\"<template parameter error>\"));\n           else\n             dump_template_argument (arg, flags);\n         }\n@@ -1476,7 +1477,7 @@ dump_template_parms (tree info, int primary, int flags)\n \n           if (TREE_VEC_ELT (parms, ix) == error_mark_node)\n             {\n-              pp_identifier (cxx_pp, \"<template parameter error>\");\n+              pp_string (cxx_pp, _(\"<template parameter error>\"));\n               continue;\n             }\n \n@@ -1602,7 +1603,7 @@ dump_expr (tree t, int flags)\n \n   if (STATEMENT_CLASS_P (t))\n     {\n-      pp_cxx_identifier (cxx_pp, \"<statement>\");\n+      pp_cxx_ws_string (cxx_pp, _(\"<statement>\"));\n       return;\n     }\n \n@@ -1631,7 +1632,7 @@ dump_expr (tree t, int flags)\n     case THROW_EXPR:\n       /* While waiting for caret diagnostics, avoid printing\n \t __cxa_allocate_exception, __cxa_throw, and the like.  */\n-      pp_cxx_identifier (cxx_pp, \"<throw-expression>\");\n+      pp_cxx_ws_string (cxx_pp, _(\"<throw-expression>\"));\n       break;\n \n     case PTRMEM_CST:\n@@ -1662,7 +1663,7 @@ dump_expr (tree t, int flags)\n     case SAVE_EXPR:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n-\t  pp_cxx_identifier (cxx_pp, \"new\");\n+\t  pp_cxx_ws_string (cxx_pp, \"new\");\n \t  pp_cxx_whitespace (cxx_pp);\n \t  dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n \t}\n@@ -1856,7 +1857,7 @@ dump_expr (tree t, int flags)\n     case POSTINCREMENT_EXPR:\n       pp_cxx_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_identifier (cxx_pp, operator_name_info[(int)TREE_CODE (t)].name);\n+      pp_cxx_ws_string (cxx_pp, operator_name_info[(int)TREE_CODE (t)].name);\n       pp_cxx_right_paren (cxx_pp);\n       break;\n \n@@ -2027,16 +2028,16 @@ dump_expr (tree t, int flags)\n       break;\n \n     case STATIC_CAST_EXPR:\n-      pp_cxx_identifier (cxx_pp, \"static_cast\");\n+      pp_cxx_ws_string (cxx_pp, \"static_cast\");\n       goto cast;\n     case REINTERPRET_CAST_EXPR:\n-      pp_cxx_identifier (cxx_pp, \"reinterpret_cast\");\n+      pp_cxx_ws_string (cxx_pp, \"reinterpret_cast\");\n       goto cast;\n     case CONST_CAST_EXPR:\n-      pp_cxx_identifier (cxx_pp, \"const_cast\");\n+      pp_cxx_ws_string (cxx_pp, \"const_cast\");\n       goto cast;\n     case DYNAMIC_CAST_EXPR:\n-      pp_cxx_identifier (cxx_pp, \"dynamic_cast\");\n+      pp_cxx_ws_string (cxx_pp, \"dynamic_cast\");\n     cast:\n       pp_cxx_begin_template_argument_list (cxx_pp);\n       dump_type (TREE_TYPE (t), flags);\n@@ -2054,11 +2055,11 @@ dump_expr (tree t, int flags)\n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n-\tpp_cxx_identifier (cxx_pp, \"sizeof\");\n+\tpp_cxx_ws_string (cxx_pp, \"sizeof\");\n       else\n \t{\n \t  gcc_assert (TREE_CODE (t) == ALIGNOF_EXPR);\n-\t  pp_cxx_identifier (cxx_pp, \"__alignof__\");\n+\t  pp_cxx_ws_string (cxx_pp, \"__alignof__\");\n \t}\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_paren (cxx_pp);\n@@ -2071,13 +2072,13 @@ dump_expr (tree t, int flags)\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_cxx_identifier (cxx_pp, operator_name_info[TREE_CODE (t)].name);\n+      pp_cxx_ws_string (cxx_pp, operator_name_info[TREE_CODE (t)].name);\n       pp_cxx_whitespace (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags);\n       break;\n \n     case DEFAULT_ARG:\n-      pp_identifier (cxx_pp, \"<unparsed>\");\n+      pp_string (cxx_pp, _(\"<unparsed>\"));\n       break;\n \n     case TRY_CATCH_EXPR:\n@@ -2223,7 +2224,7 @@ dump_expr (tree t, int flags)\n       pp_unsupported_tree (cxx_pp, t);\n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n-      pp_identifier (cxx_pp, \"<expression error>\");\n+      pp_string (cxx_pp, _(\"<expression error>\"));\n       break;\n     }\n }\n@@ -2235,9 +2236,9 @@ dump_binary_op (const char *opstring, tree t, int flags)\n   dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n   pp_cxx_whitespace (cxx_pp);\n   if (opstring)\n-    pp_cxx_identifier (cxx_pp, opstring);\n+    pp_cxx_ws_string (cxx_pp, opstring);\n   else\n-    pp_identifier (cxx_pp, \"<unknown operator>\");\n+    pp_string (cxx_pp, _(\"<unknown operator>\"));\n   pp_cxx_whitespace (cxx_pp);\n   dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n   pp_cxx_right_paren (cxx_pp);\n@@ -2248,7 +2249,7 @@ dump_unary_op (const char *opstring, tree t, int flags)\n {\n   if (flags & TFF_EXPR_IN_PARENS)\n     pp_cxx_left_paren (cxx_pp);\n-  pp_cxx_identifier (cxx_pp, opstring);\n+  pp_cxx_ws_string (cxx_pp, opstring);\n   dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n   if (flags & TFF_EXPR_IN_PARENS)\n     pp_cxx_right_paren (cxx_pp);\n@@ -2419,7 +2420,7 @@ static const char *\n op_to_string (enum tree_code p)\n {\n   tree id = operator_name_info[(int) p].identifier;\n-  return id ? IDENTIFIER_POINTER (id) : \"<unknown>\";\n+  return id ? IDENTIFIER_POINTER (id) : _(\"<unknown>\");\n }\n \n static const char *\n@@ -2439,7 +2440,7 @@ static const char *\n assop_to_string (enum tree_code p)\n {\n   tree id = assignment_operator_name_info[(int) p].identifier;\n-  return id ? IDENTIFIER_POINTER (id) : \"{unknown}\";\n+  return id ? IDENTIFIER_POINTER (id) : _(\"{unknown}\");\n }\n \n static const char *\n@@ -2459,7 +2460,7 @@ args_to_string (tree p, int verbose)\n   for (; p; p = TREE_CHAIN (p))\n     {\n       if (TREE_VALUE (p) == null_node)\n-\tpp_cxx_identifier (cxx_pp, \"NULL\");\n+\tpp_cxx_ws_string (cxx_pp, \"NULL\");\n       else\n \tdump_type (error_type (TREE_VALUE (p)), flags);\n       if (TREE_CHAIN (p))\n@@ -2521,7 +2522,7 @@ cp_print_error_function (diagnostic_context *context,\n       pp_base_set_prefix (context->printer, new_prefix);\n \n       if (current_function_decl == NULL)\n-\tpp_base_string (context->printer, \"At global scope:\");\n+\tpp_base_string (context->printer, _(\"At global scope:\"));\n       else\n \t{\n \t  tree fndecl, ao;\n@@ -2539,8 +2540,7 @@ cp_print_error_function (diagnostic_context *context,\n \t  else\n \t    fndecl = current_function_decl;\n \n-\t  pp_printf (context->printer, \"In %s %qs\",\n-\t\t     function_category (fndecl),\n+\t  pp_printf (context->printer, function_category (fndecl),\n \t\t     cxx_printable_name (fndecl, 2));\n \n \t  while (abstract_origin)\n@@ -2591,18 +2591,18 @@ cp_print_error_function (diagnostic_context *context,\n \t\t    {\n \t\t      if (flag_show_column && s.column != 0)\n \t\t\tpp_printf (context->printer,\n-\t\t\t\t   \"    inlined from %qs at %s:%d:%d\",\n+\t\t\t\t   _(\"    inlined from %qs at %s:%d:%d\"),\n \t\t\t\t   cxx_printable_name (fndecl, 2),\n \t\t\t\t   s.file, s.line, s.column);\n \t\t      else\n \t\t\tpp_printf (context->printer,\n-\t\t\t\t   \"    inlined from %qs at %s:%d\",\n+\t\t\t\t   _(\"    inlined from %qs at %s:%d\"),\n \t\t\t\t   cxx_printable_name (fndecl, 2),\n \t\t\t\t   s.file, s.line);\n \n \t\t    }\n \t\t  else\n-\t\t    pp_printf (context->printer, \"    inlined from %qs\",\n+\t\t    pp_printf (context->printer, _(\"    inlined from %qs\"),\n \t\t\t       cxx_printable_name (fndecl, 2));\n \t\t}\n \t    }\n@@ -2616,25 +2616,26 @@ cp_print_error_function (diagnostic_context *context,\n     }\n }\n \n-/* Returns a description of FUNCTION using standard terminology.  */\n+/* Returns a description of FUNCTION using standard terminology.  The\n+   result is a format string of the form \"In CATEGORY %qs\".  */\n static const char *\n function_category (tree fn)\n {\n   if (DECL_FUNCTION_MEMBER_P (fn))\n     {\n       if (DECL_STATIC_FUNCTION_P (fn))\n-\treturn \"static member function\";\n+\treturn _(\"In static member function %qs\");\n       else if (DECL_COPY_CONSTRUCTOR_P (fn))\n-\treturn \"copy constructor\";\n+\treturn _(\"In copy constructor %qs\");\n       else if (DECL_CONSTRUCTOR_P (fn))\n-\treturn \"constructor\";\n+\treturn _(\"In constructor %qs\");\n       else if (DECL_DESTRUCTOR_P (fn))\n-\treturn \"destructor\";\n+\treturn _(\"In destructor %qs\");\n       else\n-\treturn \"member function\";\n+\treturn _(\"In member function %qs\");\n     }\n   else\n-    return \"function\";\n+    return _(\"In function %qs\");\n }\n \n /* Report the full context of a current template instantiation,\n@@ -2659,7 +2660,7 @@ print_instantiation_full_context (diagnostic_context *context)\n \t    /* Avoid redundancy with the \"In function\" line.  */;\n \t  else\n \t    pp_verbatim (context->printer,\n-\t\t\t \"%s: In instantiation of %qs:\\n\",\n+\t\t\t _(\"%s: In instantiation of %qs:\\n\"),\n \t\t\t LOCATION_FILE (location),\n \t\t\t decl_as_string (p->decl,\n \t\t\t\t\t TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n@@ -2683,13 +2684,13 @@ print_instantiation_partial_context (diagnostic_context *context,\n       xloc = expand_location (loc);\n       if (t == NULL)\n \tbreak;\n-      pp_verbatim (context->printer, \"%s:%d:   instantiated from %qs\\n\",\n+      pp_verbatim (context->printer, _(\"%s:%d:   instantiated from %qs\\n\"),\n \t\t   xloc.file, xloc.line,\n \t\t   decl_as_string (t->decl,\n \t\t\t\t   TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n       loc = t->locus;\n     }\n-  pp_verbatim (context->printer, \"%s:%d:   instantiated from here\",\n+  pp_verbatim (context->printer, _(\"%s:%d:   instantiated from here\"),\n \t       xloc.file, xloc.line);\n   pp_base_newline (context->printer);\n }"}]}