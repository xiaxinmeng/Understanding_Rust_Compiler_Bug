{"sha": "aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVkY2RiNjU1ZGQ1ZDY0NDRjYWNhM2UxYWEyYTQ3ODZjMDljZWI4Yw==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-12-04T01:10:08Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-12-04T01:10:08Z"}, "message": "decl.c (complete_start_java_method): Now generate TRY_FINALLY_EXPR instead of CLEANUP_POINT_EXPR and WITH_CLEANUP_EXPR.\n\n\n\t* decl.c (complete_start_java_method):  Now generate TRY_FINALLY_EXPR\n\tinstead of CLEANUP_POINT_EXPR and WITH_CLEANUP_EXPR.\n\t* jcf-write.c (generate_bytecode_insns):  Remove support for\n\tCLEANUP_POINT_EXPR and WITH_CLEANUP_EXPR as they are no longer used.\n\t* check-init.c (check_init):  Likewise.\n\nFrom-SVN: r47587", "tree": {"sha": "74c53a26a18861bde10a625d7b3eca0f8d353671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74c53a26a18861bde10a625d7b3eca0f8d353671"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3acc0e76327f930d3a7094d94bf65963aab68b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3acc0e76327f930d3a7094d94bf65963aab68b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3acc0e76327f930d3a7094d94bf65963aab68b20"}], "stats": {"total": 117, "additions": 14, "deletions": 103}, "files": [{"sha": "ca9284ccdd93114269cfd1fd63af1a36c92f3c39", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "patch": "@@ -1,3 +1,11 @@\n+2001-12-03  Per Bothner  <per@bothner.com>\n+\n+\t* decl.c (complete_start_java_method):  Now generate TRY_FINALLY_EXPR\n+\tinstead of CLEANUP_POINT_EXPR and WITH_CLEANUP_EXPR.\n+\t* jcf-write.c (generate_bytecode_insns):  Remove support for\n+\tCLEANUP_POINT_EXPR and WITH_CLEANUP_EXPR as they are no longer used.\n+\t* check-init.c (check_init):  Likewise.\n+\n 2001-12-03  Per Bothner  <per@bothner.com>\n \n \t* verify.c (subroutine_nesting):  New function."}, {"sha": "7aea18218457f3b9e2a01d65104b074955c6d0c4", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "patch": "@@ -529,29 +529,6 @@ check_init (exp, before)\n \tbreak;\n       }\n \n-    case CLEANUP_POINT_EXPR:\n-      {\n-\tstruct alternatives alt;\n-\tBEGIN_ALTERNATIVES (before, alt);\n-\tCLEAR_ALL (alt.combined);\n-\tcheck_init (TREE_OPERAND (exp, 0), before); \n-\tUNION (alt.combined, alt.combined, before);\n-\tEND_ALTERNATIVES (before, alt);\n-      }\n-      return;\n-    case WITH_CLEANUP_EXPR:\n-      {\n-\tstruct alternatives *alt = alternatives;\t\n-#ifdef ENABLE_JC1_CHECKING\n-\tif (TREE_CODE (alt->block) != CLEANUP_POINT_EXPR)\n-\t  abort ();\n-#endif\n-\tcheck_init (TREE_OPERAND (exp, 0), before);\n-\tUNION (alt->combined, alt->combined, before);\n-\tcheck_init (TREE_OPERAND (exp, 1), alt->combined);\n-\treturn;\n-      }\n-\n     case TRY_EXPR:\n       {\n \ttree try_clause = TREE_OPERAND (exp, 0);"}, {"sha": "1cbd6030024958aad9cb9d319fb5c7cba00fee75", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "patch": "@@ -1714,12 +1714,9 @@ complete_start_java_method (fndecl)\n \t{\n \t  tree function_body = DECL_FUNCTION_BODY (fndecl);\n \t  tree body = BLOCK_EXPR_BODY (function_body);\n-\t  lock = build (WITH_CLEANUP_EXPR, void_type_node,\n-\t\t\tenter, exit, NULL_TREE);\n-\t  TREE_SIDE_EFFECTS (lock) = 1;\n-\t  lock = build (COMPOUND_EXPR, TREE_TYPE (body), lock, body);\n-\t  TREE_SIDE_EFFECTS (lock) = 1;\n-\t  lock = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (body), lock);\n+\t  lock = build (COMPOUND_EXPR, void_type_node,\n+\t\t\tenter,\n+\t\t\tbuild (TRY_FINALLY_EXPR, void_type_node, body, exit));\n \t  TREE_SIDE_EFFECTS (lock) = 1;\n \t  BLOCK_EXPR_BODY (function_body) = lock;\n \t}"}, {"sha": "43622f8b71558f5a4d9d4445c765ee8283c11328", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 3, "deletions": 74, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=aedcdb655dd5d6444caca3e1aa2a4786c09ceb8c", "patch": "@@ -112,7 +112,7 @@ struct jcf_block\n {\n   /* For blocks that that are defined, the next block (in pc order).\n      For blocks that are not-yet-defined the end label of a LABELED_BLOCK_EXPR\n-     or a cleanup expression (from a WITH_CLEANUP_EXPR),\n+     or a cleanup expression (from a TRY_FINALLY_EXPR),\n      this is the next (outer) such end label, in a stack headed by\n      labeled_blocks in jcf_partial. */\n   struct jcf_block *next;\n@@ -1348,7 +1348,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n     abort ();\n }\n \n-/* Call pending cleanups i.e. those for surrounding CLEANUP_POINT_EXPRs\n+/* Call pending cleanups i.e. those for surrounding TRY_FINAL_EXPRs.\n    but only as far out as LIMIT (since we are about to jump to the\n    emit label that is LIMIT). */\n \n@@ -2279,78 +2279,6 @@ generate_bytecode_insns (exp, target, state)\n       }\n       break;\n \n-    case CLEANUP_POINT_EXPR:\n-      {\n-\tstruct jcf_block *save_labeled_blocks = state->labeled_blocks;\n-\tint can_complete = CAN_COMPLETE_NORMALLY (TREE_OPERAND (exp, 0));\n-\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), IGNORE_TARGET, state);\n-\tif (target != IGNORE_TARGET)\n-\t  abort ();\n-\twhile (state->labeled_blocks != save_labeled_blocks)\n-\t  {\n-\t    struct jcf_block *finished_label = NULL;\n-\t    tree return_link;\n-\t    tree exception_type = build_pointer_type (throwable_type_node);\n-\t    tree exception_decl = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t\t\t      exception_type);\n-\t    struct jcf_block *end_label = get_jcf_label_here (state);\n-\t    struct jcf_block *label = state->labeled_blocks;\n-\t    struct jcf_handler *handler;\n-\t    tree cleanup = label->u.labeled_block;\n-\t    state->labeled_blocks = label->next;\n-\t    state->num_finalizers--;\n-\t    if (can_complete)\n-\t      {\n-\t\tfinished_label = gen_jcf_label (state);\n-\t\temit_jsr (label, state);\n-\t\temit_goto (finished_label, state);\n-\t\tif (! CAN_COMPLETE_NORMALLY (cleanup))\n-\t\t  can_complete = 0;\n-\t      }\n-\t    handler = alloc_handler (label->v.start_label, end_label, state);\n-\t    handler->type = NULL_TREE;\n-\t    localvar_alloc (exception_decl, state);\n-\t    NOTE_PUSH (1);\n-            emit_store (exception_decl, state);\n-\t    emit_jsr (label, state);\n-\t    emit_load (exception_decl, state);\n-\t    RESERVE (1);\n-\t    OP1 (OPCODE_athrow);\n-\t    NOTE_POP (1);\n-\n-\t    /* The finally block. */\n-\t    return_link = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t\t      return_address_type_node);\n-\t    define_jcf_label (label, state);\n-\t    NOTE_PUSH (1);\n-\t    localvar_alloc (return_link, state);\n-\t    emit_store (return_link, state);\n-\t    generate_bytecode_insns (cleanup, IGNORE_TARGET, state);\n-\t    maybe_wide (OPCODE_ret, DECL_LOCAL_INDEX (return_link), state);\n-\t    localvar_free (return_link, state);\n-\t    localvar_free (exception_decl, state);\n-\t    if (finished_label != NULL)\n-\t      define_jcf_label (finished_label, state);\n-\t  }\n-      }\n-      break;\n-\n-    case WITH_CLEANUP_EXPR:\n-      {\n-\tstruct jcf_block *label;\n-\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), IGNORE_TARGET, state);\n-\tlabel = gen_jcf_label (state);\n-\tlabel->pc = PENDING_CLEANUP_PC;\n-\tlabel->next = state->labeled_blocks;\n-\tstate->labeled_blocks = label;\n-\tstate->num_finalizers++;\n-\tlabel->u.labeled_block = TREE_OPERAND (exp, 1);\n-\tlabel->v.start_label = get_jcf_label_here (state);\n-\tif (target != IGNORE_TARGET)\n-\t  abort ();\n-      }\n-      break;\n-\n     case TRY_EXPR:\n       {\n \ttree try_clause = TREE_OPERAND (exp, 0);\n@@ -2383,6 +2311,7 @@ generate_bytecode_insns (exp, target, state)\n \tdefine_jcf_label (finished_label, state);\n       }\n       break;\n+\n     case TRY_FINALLY_EXPR:\n       {\n \tstruct jcf_block *finished_label,"}]}