{"sha": "05cc23e8152a05136cfc32dfa1c9606171cb24f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVjYzIzZTgxNTJhMDUxMzZjZmMzMmRmYTFjOTYwNjE3MWNiMjRmNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-02-25T19:34:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-02-25T19:34:06Z"}, "message": "ifcvt.c (struct noce_if_info): Add test_bb.\n\n        * ifcvt.c (struct noce_if_info): Add test_bb.\n        (noce_get_alt_condition): New.\n        (noce_try_minmax, noce_try_abs): New.\n        (noce_operand_ok): New.\n        (noce_process_if_block): Use them.\n        * rtlanal.c (may_trap_p): NEG and ABS can never trap.\n\nFrom-SVN: r40060", "tree": {"sha": "a22f2c2daa5bc0393efc4ea2dec8b6e6c7f035d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a22f2c2daa5bc0393efc4ea2dec8b6e6c7f035d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05cc23e8152a05136cfc32dfa1c9606171cb24f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05cc23e8152a05136cfc32dfa1c9606171cb24f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05cc23e8152a05136cfc32dfa1c9606171cb24f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05cc23e8152a05136cfc32dfa1c9606171cb24f6/comments", "author": null, "committer": null, "parents": [{"sha": "052d4b6cd7c5b318c7990194b83855bd64611736", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/052d4b6cd7c5b318c7990194b83855bd64611736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/052d4b6cd7c5b318c7990194b83855bd64611736"}], "stats": {"total": 367, "additions": 352, "deletions": 15}, "files": [{"sha": "3648e8aa9da28e23c25ca056f956a1e585d17237", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05cc23e8152a05136cfc32dfa1c9606171cb24f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05cc23e8152a05136cfc32dfa1c9606171cb24f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05cc23e8152a05136cfc32dfa1c9606171cb24f6", "patch": "@@ -1,3 +1,12 @@\n+2001-02-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* ifcvt.c (struct noce_if_info): Add test_bb.\n+\t(noce_get_alt_condition): New.\n+\t(noce_try_minmax, noce_try_abs): New.\n+\t(noce_operand_ok): New.\n+\t(noce_process_if_block): Use them.\n+\t* rtlanal.c (may_trap_p): NEG and ABS can never trap.\n+\n Sun Feb 25 14:26:17 2001  Christopher Faylor <cgf@cygnus.com>\n \n \t* config/i386/cygwin.h (CPP_SPEC): Add missing space before w32api\n@@ -19,18 +28,18 @@ Sun Feb 25 08:34:23 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-02-25  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cppinit.c (builtin_array): Update.\n-        (init_builtins): Flag builtins to warn if redefined or\n-        undefined.  Define __GXX_WEAK as a normal macro.\n-        * cpplib.c (do_undef): Warn if flagged NODE_WARN.\n-        * cpplib.h (NODE_WARN): New flag.\n-        * cppmacro.c (builtin_macro): Remove handling of __GXX_WEAK__.\n-        Handle __STDC__ as a builtin only on Solaris.\n-        (warn_of_redefinition): Renamed from check_macro_definition.\n-        Reverse sense of test.  Always warn if NODE_WARN.\n-        (_cpp_create_definition): Use warn_of_redefinition.  Flag\n-        any macro beginning with \"__STDC_\" to require a mandatory\n-        warning if redefined or undefined.\n+\t* cppinit.c (builtin_array): Update.\n+\t(init_builtins): Flag builtins to warn if redefined or\n+\tundefined.  Define __GXX_WEAK as a normal macro.\n+\t* cpplib.c (do_undef): Warn if flagged NODE_WARN.\n+\t* cpplib.h (NODE_WARN): New flag.\n+\t* cppmacro.c (builtin_macro): Remove handling of __GXX_WEAK__.\n+\tHandle __STDC__ as a builtin only on Solaris.\n+\t(warn_of_redefinition): Renamed from check_macro_definition.\n+\tReverse sense of test.  Always warn if NODE_WARN.\n+\t(_cpp_create_definition): Use warn_of_redefinition.  Flag\n+\tany macro beginning with \"__STDC_\" to require a mandatory\n+\twarning if redefined or undefined.\n \n 2001-02-24  Zack Weinberg  <zackw@stanford.edu>\n "}, {"sha": "c5778e1eb3521c68294dee942791bc1b0dd539b1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 326, "deletions": 3, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05cc23e8152a05136cfc32dfa1c9606171cb24f6/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05cc23e8152a05136cfc32dfa1c9606171cb24f6/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=05cc23e8152a05136cfc32dfa1c9606171cb24f6", "patch": "@@ -30,6 +30,7 @@\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"expr.h\"\n+#include \"real.h\"\n #include \"output.h\"\n #include \"tm_p.h\"\n \n@@ -79,6 +80,7 @@ static int cond_exec_process_if_block\tPARAMS ((basic_block, basic_block,\n \t\t\t\t\t\t basic_block, basic_block));\n \n static rtx noce_get_condition\t\tPARAMS ((rtx, rtx *));\n+static int noce_operand_ok\t\tPARAMS ((rtx));\n static int noce_process_if_block\tPARAMS ((basic_block, basic_block,\n \t\t\t\t\t\t basic_block, basic_block));\n \n@@ -451,6 +453,7 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \n struct noce_if_info\n {\n+  basic_block test_bb;\n   rtx insn_a, insn_b;\n   rtx x, a, b;\n   rtx jump, cond, cond_earliest;\n@@ -467,6 +470,10 @@ static rtx noce_emit_cmove\t\tPARAMS ((struct noce_if_info *,\n \t\t\t\t\t\t rtx, rtx, rtx));\n static int noce_try_cmove\t\tPARAMS ((struct noce_if_info *));\n static int noce_try_cmove_arith\t\tPARAMS ((struct noce_if_info *));\n+static rtx noce_get_alt_condition\tPARAMS ((struct noce_if_info *,\n+\t\t\t\t\t\t rtx, rtx *));\n+static int noce_try_minmax\t\tPARAMS ((struct noce_if_info *));\n+static int noce_try_abs\t\t\tPARAMS ((struct noce_if_info *));\n \n /* Helper function for noce_try_store_flag*.  */\n \n@@ -1066,6 +1073,274 @@ noce_try_cmove_arith (if_info)\n   return FALSE;\n }\n \n+/* For most cases, the simplified condition we found is the best\n+   choice, but this is not the case for the min/max/abs transforms.\n+   For these we wish to know that it is A or B in the condition.  */\n+\n+static rtx\n+noce_get_alt_condition (if_info, target, earliest)\n+     struct noce_if_info *if_info;\n+     rtx target;\n+     rtx *earliest;\n+{\n+  rtx cond, set, insn;\n+  int reverse;\n+\n+  /* If target is already mentioned in the known condition, return it.  */\n+  if (reg_mentioned_p (target, if_info->cond))\n+    {\n+      *earliest = if_info->cond_earliest;\n+      return if_info->cond;\n+    }\n+\n+  set = pc_set (if_info->jump);\n+  cond = XEXP (SET_SRC (set), 0);\n+  reverse\n+    = GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n+      && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (if_info->jump);\n+\n+  cond = canonicalize_condition (if_info->jump, cond, reverse,\n+\t\t\t\t earliest, target);\n+  if (! cond || ! reg_mentioned_p (target, cond))\n+    return NULL;\n+\n+  /* We almost certainly searched back to a different place.\n+     Need to re-verify correct lifetimes.  */\n+\n+  /* X may not be mentioned in the range (cond_earliest, jump].  */\n+  for (insn = if_info->jump; insn != *earliest; insn = PREV_INSN (insn))\n+    if (INSN_P (insn) && reg_mentioned_p (if_info->x, insn))\n+      return NULL;\n+\n+  /* A and B may not be modified in the range [cond_earliest, jump).  */\n+  for (insn = *earliest; insn != if_info->jump; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn)\n+\t&& (modified_in_p (if_info->a, insn)\n+\t    || modified_in_p (if_info->b, insn)))\n+      return NULL;\n+\n+  return cond;\n+}\n+\n+/* Convert \"if (a < b) x = a; else x = b;\" to \"x = min(a, b);\", etc.  */\n+\n+static int\n+noce_try_minmax (if_info)\n+     struct noce_if_info *if_info;\n+{ \n+  rtx cond, earliest, target, seq;\n+  enum rtx_code code;\n+  int unsignedp;\n+  optab op;\n+\n+  /* ??? Can't guarantee that expand_binop won't create pseudos.  */\n+  if (no_new_pseudos)\n+    return FALSE;\n+\n+  /* ??? Reject FP modes since we don't know how 0 vs -0 or NaNs\n+     will be resolved with an SMIN/SMAX.  It wouldn't be too hard\n+     to get the target to tell us...  */\n+  if (FLOAT_MODE_P (GET_MODE (if_info->x))\n+      && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n+      && ! flag_fast_math)\n+    return FALSE;\n+\n+  cond = noce_get_alt_condition (if_info, if_info->a, &earliest);\n+  if (!cond)\n+    return FALSE;\n+\n+  /* Verify the condition is of the form we expect, and canonicalize\n+     the comparison code.  */\n+  code = GET_CODE (cond);\n+  if (rtx_equal_p (XEXP (cond, 0), if_info->a))\n+    {\n+      if (! rtx_equal_p (XEXP (cond, 1), if_info->b))\n+\treturn FALSE;\n+    }\n+  else if (rtx_equal_p (XEXP (cond, 1), if_info->a))\n+    {\n+      if (! rtx_equal_p (XEXP (cond, 0), if_info->b))\n+\treturn FALSE;\n+      code = swap_condition (code);\n+    }\n+  else\n+    return FALSE;\n+\n+  /* Determine what sort of operation this is.  Note that the code is for\n+     a taken branch, so the code->operation mapping appears backwards.  */\n+  switch (code)\n+    {\n+    case LT:\n+    case LE:\n+    case UNLT:\n+    case UNLE:\n+      op = smax_optab;\n+      unsignedp = 0;\n+      break;\n+    case GT:\n+    case GE:\n+    case UNGT:\n+    case UNGE:\n+      op = smin_optab;\n+      unsignedp = 0;\n+      break;\n+    case LTU:\n+    case LEU:\n+      op = umax_optab;\n+      unsignedp = 1;\n+      break;\n+    case GTU:\n+    case GEU:\n+      op = umin_optab;\n+      unsignedp = 1;\n+      break;\n+    default:\n+      return FALSE;\n+    }\n+\n+  start_sequence ();\n+\n+  target = expand_binop (GET_MODE (if_info->x), op, if_info->a, if_info->b,\n+\t\t\t if_info->x, unsignedp, OPTAB_WIDEN);\n+  if (! target)\n+    {\n+      end_sequence ();\n+      return FALSE;\n+    }\n+  if (target != if_info->x)\n+    emit_move_insn (if_info->x, target);\n+\n+  seq = get_insns ();\n+  end_sequence ();  \n+\n+  if (seq_contains_jump (seq))\n+    return FALSE;\n+\n+  emit_insns_before (seq, earliest);\n+  if_info->cond = cond;\n+  if_info->cond_earliest = earliest;\n+\n+  return TRUE;\n+}\n+\n+/* Convert \"if (a < 0) x = -a; else x = a;\" to \"x = abs(a);\", etc.  */\n+\n+static int\n+noce_try_abs (if_info)\n+     struct noce_if_info *if_info;\n+{ \n+  rtx cond, earliest, target, seq, a, b, c;\n+  int negate;\n+\n+  /* ??? Can't guarantee that expand_binop won't create pseudos.  */\n+  if (no_new_pseudos)\n+    return FALSE;\n+\n+  /* Recognize A and B as constituting an ABS or NABS.  */\n+  a = if_info->a;\n+  b = if_info->b;\n+  if (GET_CODE (a) == NEG && rtx_equal_p (XEXP (a, 0), b))\n+    negate = 0;\n+  else if (GET_CODE (b) == NEG && rtx_equal_p (XEXP (b, 0), a))\n+    {\n+      c = a; a = b; b = c;\n+      negate = 1;\n+    }\n+  else\n+    return FALSE;\n+   \n+  cond = noce_get_alt_condition (if_info, b, &earliest);\n+  if (!cond)\n+    return FALSE;\n+\n+  /* Verify the condition is of the form we expect.  */\n+  if (rtx_equal_p (XEXP (cond, 0), b))\n+    c = XEXP (cond, 1);\n+  else if (rtx_equal_p (XEXP (cond, 1), b))\n+    c = XEXP (cond, 0);\n+  else\n+    return FALSE;\n+\n+  /* Verify that C is zero.  Search backward through the block for\n+     a REG_EQUAL note if necessary.  */\n+  if (REG_P (c))\n+    {\n+      rtx insn, note = NULL;\n+      for (insn = earliest;\n+\t   insn != if_info->test_bb->head;\n+\t   insn = PREV_INSN (insn))\n+\tif (INSN_P (insn) \n+\t    && ((note = find_reg_note (insn, REG_EQUAL, c))\n+\t\t|| (note = find_reg_note (insn, REG_EQUIV, c))))\n+\t  break;\n+      if (! note)\n+\treturn FALSE;\n+      c = XEXP (note, 0);\n+    }\n+  if (GET_CODE (c) == MEM\n+      && GET_CODE (XEXP (c, 0)) == SYMBOL_REF\n+      && CONSTANT_POOL_ADDRESS_P (XEXP (c, 0)))\n+    c = get_pool_constant (XEXP (c, 0));\n+\n+  /* Work around funny ideas get_condition has wrt canonicalization.\n+     Note that these rtx constants are known to be CONST_INT, and \n+     therefore imply integer comparisons.  */\n+  if (c == constm1_rtx && GET_CODE (cond) == GT)\n+    ;\n+  else if (c == const1_rtx && GET_CODE (cond) == LT)\n+    ;\n+  else if (c != CONST0_RTX (GET_MODE (b)))\n+    return FALSE;\n+\n+  /* Determine what sort of operation this is.  */\n+  switch (GET_CODE (cond))\n+    {\n+    case LT:\n+    case LE:\n+    case UNLT:\n+    case UNLE:\n+      negate = !negate;\n+      break;\n+    case GT:\n+    case GE:\n+    case UNGT:\n+    case UNGE:\n+      break;\n+    default:\n+      return FALSE;\n+    }\n+\n+  start_sequence ();\n+\n+  target = expand_unop (GET_MODE (if_info->x), abs_optab, b, if_info->x, 0);\n+\n+  /* ??? It's a quandry whether cmove would be better here, especially\n+     for integers.  Perhaps combine will clean things up.  */\n+  if (target && negate)\n+    target = expand_unop (GET_MODE (target), neg_optab, target, if_info->x, 0);\n+\n+  if (! target)\n+    {\n+      end_sequence ();\n+      return FALSE;\n+    }\n+\n+  if (target != if_info->x)\n+    emit_move_insn (if_info->x, target);\n+\n+  seq = get_insns ();\n+  end_sequence ();  \n+\n+  if (seq_contains_jump (seq))\n+    return FALSE;\n+\n+  emit_insns_before (seq, earliest);\n+  if_info->cond = cond;\n+  if_info->cond_earliest = earliest;\n+\n+  return TRUE;\n+}\n+\n /* Look for the condition for the jump first.  We'd prefer to avoid\n    get_condition if we can -- it tries to look back for the contents\n    of an original compare.  On targets that use normal integers for\n@@ -1107,6 +1382,51 @@ noce_get_condition (jump, earliest)\n   return cond;\n }\n \n+/* Return true if OP is ok for if-then-else processing.  */\n+\n+static int\n+noce_operand_ok (op)\n+     rtx op;\n+{\n+  /* We special-case memories, so handle any of them with\n+     no address side effects.  */\n+  if (GET_CODE (op) == MEM)\n+    return ! side_effects_p (XEXP (op, 0));\n+\n+  if (side_effects_p (op))\n+    return FALSE;\n+\n+  /* ??? Unfortuantely may_trap_p can't look at flag_fast_math, due to\n+     being linked into the genfoo programs.  This is probably a mistake.\n+     With finite operands, most fp operations don't trap.  */\n+  if (flag_fast_math && FLOAT_MODE_P (GET_MODE (op)))\n+    switch (GET_CODE (op))\n+      {\n+      case DIV:\n+      case MOD:\n+      case UDIV:\n+      case UMOD:\n+\t/* ??? This is kinda lame -- almost every target will have forced\n+\t   the constant into a register first.  But given the expense of\n+\t   division, this is probably for the best.  */\n+\treturn (CONSTANT_P (XEXP (op, 1))\n+\t\t&& XEXP (op, 1) != CONST0_RTX (GET_MODE (op))\n+\t\t&& ! may_trap_p (XEXP (op, 0)));\n+\n+      default:\n+\tswitch (GET_RTX_CLASS (GET_CODE (op)))\n+\t  {\n+\t  case 'c':\n+\t  case '1':\n+\t  case '2':\n+\t    return ! may_trap_p (XEXP (op, 0)) && ! may_trap_p (XEXP (op, 1));\n+\t  }\n+\tbreak;\n+      }\n+\n+  return ! may_trap_p (op);\n+}\n+\n /* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it\n    without using conditional execution.  Return TRUE if we were\n    successful at converting the the block.  */\n@@ -1214,12 +1534,11 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n     }\n \n   /* Don't operate on sources that may trap or are volatile.  */\n-  if (side_effects_p (a) || side_effects_p (b)\n-      || (GET_CODE (a) != MEM && may_trap_p (a))\n-      || (GET_CODE (b) != MEM && may_trap_p (b)))\n+  if (! noce_operand_ok (a) || ! noce_operand_ok (b))\n     return FALSE;\n \n   /* Set up the info block for our subroutines.  */\n+  if_info.test_bb = test_bb;\n   if_info.cond = cond;\n   if_info.jump = jump;\n   if_info.insn_a = insn_a;\n@@ -1258,6 +1577,10 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \n   if (noce_try_store_flag (&if_info))\n     goto success;\n+  if (noce_try_minmax (&if_info))\n+    goto success;\n+  if (noce_try_abs (&if_info))\n+    goto success;\n   if (HAVE_conditional_move\n       && noce_try_cmove (&if_info))\n     goto success;"}, {"sha": "237382f9072c0fb693650a884e960945a7bbaa3b", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05cc23e8152a05136cfc32dfa1c9606171cb24f6/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05cc23e8152a05136cfc32dfa1c9606171cb24f6/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=05cc23e8152a05136cfc32dfa1c9606171cb24f6", "patch": "@@ -2020,6 +2020,11 @@ may_trap_p (x)\n \treturn 1;\n       break;\n \n+    case NEG:\n+    case ABS:\n+      /* These operations don't trap even with floating point.  */\n+      break;\n+\n     default:\n       /* Any floating arithmetic may trap.  */\n       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)"}]}