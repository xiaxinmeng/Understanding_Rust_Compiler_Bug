{"sha": "25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVhZTUwMjczYWQyODAxZWNjMjYyYmE3NWZhOGJhYzBjNGUwMDAxYg==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-11-12T15:53:25Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:53:25Z"}, "message": "Instrument built-in memory access function calls\n\nThis patch instruments many memory access patterns through builtins.\n\nBasically, for a call like:\n\n     __builtin_memset (from, 0, n_bytes);\n\nthe patch would only instrument the accesses at the beginning and at\nthe end of the memory region [from, from + n_bytes].  This is the\nstrategy used by the llvm implementation of asan.\n\nThis instrumentation is done for all the memory access builtin\nfunctions that expose a well specified memory region -- one that\nexplicitly states the number of bytes accessed in the region.\n\nA special treatment is used for __builtin_strlen.  The patch\ninstruments the access to the first byte of its argument, as well as\nthe access to the byte (of the argument) at the offset returned by\nstrlen.\n\nFor the __sync_* and __atomic* calls the patch instruments the access\nto the bytes pointed to by the argument.\n\nWhile doing this, I have added a new parameter to build_check_stmt to\ndecide whether to insert the instrumentation code before or after the\nstatement iterator.  This allows us to do away with the\ngsi_{next,prev} dance we were doing in the callers of this function.\n\nTested by running cc1 -fasan on variations of simple programs like:\n\n    int\n    foo ()\n    {\n      char foo[10] = {0};\n\n      foo[0] = 't';\n      foo[1] = 'e';\n      foo[2] = 's';\n      foo[3] = 't';\n      int l = __builtin_strlen (foo);\n      int n = sizeof (foo);\n      __builtin_memset (&foo[4], 0, n - 4);\n      __sync_fetch_and_add (&foo[11], 1);\n\n      return l;\n    }\n\nand by starring at the gimple output which for this function is:\n\n    ;; Function foo (foo, funcdef_no=0, decl_uid=1714, cgraph_uid=0)\n\n    foo ()\n    {\n      int n;\n      int l;\n      char foo[10];\n      int D.1725;\n      char * D.1724;\n      int D.1723;\n      long unsigned int D.1722;\n      int D.1721;\n      long unsigned int D.1720;\n      long unsigned int _1;\n      int _4;\n      long unsigned int _5;\n      int _6;\n      char * _7;\n      int _8;\n      char * _9;\n      unsigned long _10;\n      unsigned long _11;\n      unsigned long _12;\n      signed char * _13;\n      signed char _14;\n      _Bool _15;\n      unsigned long _16;\n      signed char _17;\n      _Bool _18;\n      _Bool _19;\n      char * _20;\n      unsigned long _21;\n      unsigned long _22;\n      unsigned long _23;\n      signed char * _24;\n      signed char _25;\n      _Bool _26;\n      unsigned long _27;\n      signed char _28;\n      _Bool _29;\n      _Bool _30;\n      char * _31;\n      unsigned long _32;\n      unsigned long _33;\n      unsigned long _34;\n      signed char * _35;\n      signed char _36;\n      _Bool _37;\n      unsigned long _38;\n      signed char _39;\n      _Bool _40;\n      _Bool _41;\n      char * _42;\n      unsigned long _43;\n      unsigned long _44;\n      unsigned long _45;\n      signed char * _46;\n      signed char _47;\n      _Bool _48;\n      unsigned long _49;\n      signed char _50;\n      _Bool _51;\n      _Bool _52;\n      char * _53;\n      unsigned long _54;\n      unsigned long _55;\n      unsigned long _56;\n      signed char * _57;\n      signed char _58;\n      _Bool _59;\n      unsigned long _60;\n      signed char _61;\n      _Bool _62;\n      _Bool _63;\n      char[10] * _64;\n      unsigned long _65;\n      unsigned long _66;\n      unsigned long _67;\n      signed char * _68;\n      signed char _69;\n      _Bool _70;\n      unsigned long _71;\n      signed char _72;\n      _Bool _73;\n      _Bool _74;\n      unsigned long _75;\n      unsigned long _76;\n      unsigned long _77;\n      signed char * _78;\n      signed char _79;\n      _Bool _80;\n      unsigned long _81;\n      signed char _82;\n      _Bool _83;\n      _Bool _84;\n      long unsigned int _85;\n      long unsigned int _86;\n      char * _87;\n      char * _88;\n      unsigned long _89;\n      unsigned long _90;\n      unsigned long _91;\n      signed char * _92;\n      signed char _93;\n      _Bool _94;\n      unsigned long _95;\n      signed char _96;\n      _Bool _97;\n      _Bool _98;\n      char * _99;\n      unsigned long _100;\n      unsigned long _101;\n      unsigned long _102;\n      signed char * _103;\n      signed char _104;\n      _Bool _105;\n      unsigned long _106;\n      signed char _107;\n      _Bool _108;\n      _Bool _109;\n\n      <bb 2>:\n      foo = {};\n      _9 = &foo[0];\n      _10 = (unsigned long) _9;\n      _11 = _10 >> 3;\n      _12 = _11 + 17592186044416;\n      _13 = (signed char *) _12;\n      _14 = *_13;\n      _15 = _14 != 0;\n      _16 = _10 & 7;\n      _17 = (signed char) _16;\n      _18 = _17 >= _14;\n      _19 = _15 & _18;\n      if (_19 != 0)\n\tgoto <bb 5>;\n      else\n\tgoto <bb 4>;\n\n      <bb 5>:\n      __asan_report_store1 (_10);\n\n      <bb 4>:\n      foo[0] = 116;\n      _20 = &foo[1];\n      _21 = (unsigned long) _20;\n      _22 = _21 >> 3;\n      _23 = _22 + 17592186044416;\n      _24 = (signed char *) _23;\n      _25 = *_24;\n      _26 = _25 != 0;\n      _27 = _21 & 7;\n      _28 = (signed char) _27;\n      _29 = _28 >= _25;\n      _30 = _26 & _29;\n      if (_30 != 0)\n\tgoto <bb 7>;\n      else\n\tgoto <bb 6>;\n\n      <bb 7>:\n      __asan_report_store1 (_21);\n\n      <bb 6>:\n      foo[1] = 101;\n      _31 = &foo[2];\n      _32 = (unsigned long) _31;\n      _33 = _32 >> 3;\n      _34 = _33 + 17592186044416;\n      _35 = (signed char *) _34;\n      _36 = *_35;\n      _37 = _36 != 0;\n      _38 = _32 & 7;\n      _39 = (signed char) _38;\n      _40 = _39 >= _36;\n      _41 = _37 & _40;\n      if (_41 != 0)\n\tgoto <bb 9>;\n      else\n\tgoto <bb 8>;\n\n      <bb 9>:\n      __asan_report_store1 (_32);\n\n      <bb 8>:\n      foo[2] = 115;\n      _42 = &foo[3];\n      _43 = (unsigned long) _42;\n      _44 = _43 >> 3;\n      _45 = _44 + 17592186044416;\n      _46 = (signed char *) _45;\n      _47 = *_46;\n      _48 = _47 != 0;\n      _49 = _43 & 7;\n      _50 = (signed char) _49;\n      _51 = _50 >= _47;\n      _52 = _48 & _51;\n      if (_52 != 0)\n\tgoto <bb 11>;\n      else\n\tgoto <bb 10>;\n\n      <bb 11>:\n      __asan_report_store1 (_43);\n\n      <bb 10>:\n      foo[3] = 116;\n      _53 = (char *) &foo;\n      _54 = (unsigned long) _53;\n      _55 = _54 >> 3;\n      _56 = _55 + 17592186044416;\n      _57 = (signed char *) _56;\n      _58 = *_57;\n      _59 = _58 != 0;\n      _60 = _54 & 7;\n      _61 = (signed char) _60;\n      _62 = _61 >= _58;\n      _63 = _59 & _62;\n      if (_63 != 0)\n\tgoto <bb 13>;\n      else\n\tgoto <bb 12>;\n\n      <bb 13>:\n      __asan_report_load1 (_54);\n\n      <bb 12>:\n      _1 = __builtin_strlen (&foo);\n      _64 = _53 + _1;\n      _65 = (unsigned long) _64;\n      _66 = _65 >> 3;\n      _67 = _66 + 17592186044416;\n      _68 = (signed char *) _67;\n      _69 = *_68;\n      _70 = _69 != 0;\n      _71 = _65 & 7;\n      _72 = (signed char) _71;\n      _73 = _72 >= _69;\n      _74 = _70 & _73;\n      if (_74 != 0)\n\tgoto <bb 15>;\n      else\n\tgoto <bb 14>;\n\n      <bb 15>:\n      __asan_report_load1 (_65);\n\n      <bb 14>:\n      l_2 = (int) _1;\n      n_3 = 10;\n      _4 = n_3 + -4;\n      _5 = (long unsigned int) _4;\n      _6 = l_2 + 1;\n      _7 = &foo[_6];\n      if (_5 != 0)\n\tgoto <bb 17>;\n      else\n\tgoto <bb 16>;\n\n      <bb 17>:\n      _75 = (unsigned long) _7;\n      _76 = _75 >> 3;\n      _77 = _76 + 17592186044416;\n      _78 = (signed char *) _77;\n      _79 = *_78;\n      _80 = _79 != 0;\n      _81 = _75 & 7;\n      _82 = (signed char) _81;\n      _83 = _82 >= _79;\n      _84 = _80 & _83;\n      _85 = _5;\n      _86 = _85 - 1;\n      _87 = _7;\n      _88 = _87 + _86;\n      _89 = (unsigned long) _88;\n      _90 = _89 >> 3;\n      _91 = _90 + 17592186044416;\n      _92 = (signed char *) _91;\n      _93 = *_92;\n      _94 = _93 != 0;\n      _95 = _89 & 7;\n      _96 = (signed char) _95;\n      _97 = _96 >= _93;\n      _98 = _94 & _97;\n      if (_98 != 0)\n\tgoto <bb 21>;\n      else\n\tgoto <bb 20>;\n\n      <bb 21>:\n      __asan_report_store1 (_89);\n\n      <bb 20>:\n      if (_84 != 0)\n\tgoto <bb 19>;\n      else\n\tgoto <bb 18>;\n\n      <bb 19>:\n      __asan_report_store1 (_75);\n\n      <bb 18>:\n\n      <bb 16>:\n      __builtin_memset (_7, 0, _5);\n      _99 = &foo[11];\n      _100 = (unsigned long) _99;\n      _101 = _100 >> 3;\n      _102 = _101 + 17592186044416;\n      _103 = (signed char *) _102;\n      _104 = *_103;\n      _105 = _104 != 0;\n      _106 = _100 & 7;\n      _107 = (signed char) _106;\n      _108 = _107 >= _104;\n      _109 = _105 & _108;\n      if (_109 != 0)\n\tgoto <bb 23>;\n      else\n\tgoto <bb 22>;\n\n      <bb 23>:\n      __asan_report_store1 (_100);\n\n      <bb 22>:\n      __sync_fetch_and_add_1 (&foo[11], 1);\n      _8 = l_2;\n      foo ={v} {CLOBBER};\n\n    <L1>:\n      return _8;\n\n    }\n\n    ;; Function _GLOBAL__sub_I_00099_0_foo (_GLOBAL__sub_I_00099_0_foo, funcdef_no=1, decl_uid=1752, cgraph_uid=4)\n\n    _GLOBAL__sub_I_00099_0_foo ()\n    {\n      <bb 2>:\n      __asan_init ();\n      return;\n\n    }\n\ngcc/\n\t* gimple.h (is_gimple_builtin_call): Declare ...\n\t* gimple.c (is_gimple_builtin_call): ... New public function.\n\t* asan.c (insert_if_then_before_iter, instrument_mem_region_access,\n\tinstrument_strlen_call, maybe_instrument_builtin_call,\n\tinstrument_call): New static functions.\n\t(create_cond_insert_point): Renamed\n\tcreate_cond_insert_point_before_iter into this.  Add a new\n\tparameter to decide whether to insert the condition before or\n\tafter the statement iterator.\n\t(build_check_stmt): Adjust for the new create_cond_insert_point.\n\tAdd a new parameter to decide whether to add the instrumentation\n\tcode before or after the statement iterator.\n\t(instrument_assignment): Factorize from ...\n\t(transform_statements): ... here.  Use maybe_instrument_call to\n\tinstrument builtin function calls as well.\n\t(instrument_derefs): Adjust for the new parameter of\n\tbuild_check_stmt.  Fix detection of bit-field access.\n\nFrom-SVN: r193440", "tree": {"sha": "054f7f2a4b41b511aa587f661cefa6dcea2c0934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/054f7f2a4b41b511aa587f661cefa6dcea2c0934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/comments", "author": null, "committer": null, "parents": [{"sha": "01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01452015d7d9b18b1dfa4c7343cc6f84f8038b7e"}], "stats": {"total": 680, "additions": 650, "deletions": 30}, "files": [{"sha": "e79dee9d6e0088c4a31e98e004344fedc73a675f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "patch": "@@ -1,3 +1,29 @@\n+2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* gimple.h (is_gimple_builtin_call): Declare ...\n+\t* gimple.c (is_gimple_builtin_call): ... new public function.\n+\t* asan.c (insert_if_then_before_iter, instrument_mem_region_access,\n+\tinstrument_strlen_call, maybe_instrument_builtin_call,\n+\tinstrument_call): New static functions.\n+\t(create_cond_insert_point): Renamed\n+\tcreate_cond_insert_point_before_iter into this.  Add a new\n+\tparameter to decide whether to insert the condition before or\n+\tafter the statement iterator.\n+\t(build_check_stmt): Adjust for the new create_cond_insert_point.\n+\tAdd a new parameter to decide whether to add the instrumentation\n+\tcode before or after the statement iterator.\n+\t(instrument_assignment): Factorize from ...\n+\t(transform_statements): ... here.  Use maybe_instrument_call to\n+\tinstrument builtin function calls as well.\n+\t(instrument_derefs): Adjust for the new parameter of\n+\tbuild_check_stmt.  Fix detection of bit-field access.\n+\n+2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* asan.c (create_cond_insert_point_before_iter): Factorize out of ...\n+\t(build_check_stmt): ... here.\n+\n+\n 2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n \n \t* asan.c (create_cond_insert_point_before_iter): Factorize out of ..."}, {"sha": "f8fa5f8985aa96c6ba05b064b190eae1c9e6437a", "filename": "gcc/asan.c", "status": "modified", "additions": 605, "deletions": 30, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "patch": "@@ -521,9 +521,9 @@ asan_init_func (void)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n /* Split the current basic block and create a condition statement\n-   insertion point right before the statement pointed to by ITER.\n-   Return an iterator to the point at which the caller might safely\n-   insert the condition statement.\n+   insertion point right before or after the statement pointed to by\n+   ITER.  Return an iterator to the point at which the caller might\n+   safely insert the condition statement.\n \n    THEN_BLOCK must be set to the address of an uninitialized instance\n    of basic_block.  The function will then set *THEN_BLOCK to the\n@@ -537,18 +537,21 @@ asan_init_func (void)\n    statements starting from *ITER, and *THEN_BLOCK is a new empty\n    block.\n \n-   *ITER is adjusted to still point to the same statement it was\n-   *pointing to initially.  */\n+   *ITER is adjusted to point to always point to the first statement\n+    of the basic block * FALLTHROUGH_BLOCK.  That statement is the\n+    same as what ITER was pointing to prior to calling this function,\n+    if BEFORE_P is true; otherwise, it is its following statement.  */\n \n static gimple_stmt_iterator\n-create_cond_insert_point_before_iter (gimple_stmt_iterator *iter,\n-\t\t\t\t      bool then_more_likely_p,\n-\t\t\t\t      basic_block *then_block,\n-\t\t\t\t      basic_block *fallthrough_block)\n+create_cond_insert_point (gimple_stmt_iterator *iter,\n+\t\t\t  bool before_p,\n+\t\t\t  bool then_more_likely_p,\n+\t\t\t  basic_block *then_block,\n+\t\t\t  basic_block *fallthrough_block)\n {\n   gimple_stmt_iterator gsi = *iter;\n \n-  if (!gsi_end_p (gsi))\n+  if (!gsi_end_p (gsi) && before_p)\n     gsi_prev (&gsi);\n \n   basic_block cur_bb = gsi_bb (*iter);\n@@ -589,18 +592,58 @@ create_cond_insert_point_before_iter (gimple_stmt_iterator *iter,\n   return gsi_last_bb (cond_bb);\n }\n \n+/* Insert an if condition followed by a 'then block' right before the\n+   statement pointed to by ITER.  The fallthrough block -- which is the\n+   else block of the condition as well as the destination of the\n+   outcoming edge of the 'then block' -- starts with the statement\n+   pointed to by ITER.\n+\n+   COND is the condition of the if.  \n+\n+   If THEN_MORE_LIKELY_P is true, the probability of the edge to the\n+   'then block' is higher than the probability of the edge to the\n+   fallthrough block.\n+\n+   Upon completion of the function, *THEN_BB is set to the newly\n+   inserted 'then block' and similarly, *FALLTHROUGH_BB is set to the\n+   fallthrough block.\n+\n+   *ITER is adjusted to still point to the same statement it was\n+   pointing to initially.  */\n+\n+static void\n+insert_if_then_before_iter (gimple cond,\n+\t\t\t    gimple_stmt_iterator *iter,\n+\t\t\t    bool then_more_likely_p,\n+\t\t\t    basic_block *then_bb,\n+\t\t\t    basic_block *fallthrough_bb)\n+{\n+  gimple_stmt_iterator cond_insert_point =\n+    create_cond_insert_point (iter,\n+\t\t\t      /*before_p=*/true,\n+\t\t\t      then_more_likely_p,\n+\t\t\t      then_bb,\n+\t\t\t      fallthrough_bb);\n+  gsi_insert_after (&cond_insert_point, cond, GSI_NEW_STMT);\n+}\n+\n /* Instrument the memory access instruction BASE.  Insert new\n-   statements before ITER.\n+   statements before or after ITER.\n \n    Note that the memory access represented by BASE can be either an\n    SSA_NAME, or a non-SSA expression.  LOCATION is the source code\n    location.  IS_STORE is TRUE for a store, FALSE for a load.\n-   SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n+   BEFORE_P is TRUE for inserting the instrumentation code before\n+   ITER, FALSE for inserting it after ITER.  SIZE_IN_BYTES is one of\n+   1, 2, 4, 8, 16.\n+\n+   If BEFORE_P is TRUE, *ITER is arranged to still point to the\n+   statement it was pointing to prior to calling this function,\n+   otherwise, it points to the statement logically following it.  */\n \n static void\n-build_check_stmt (tree base, gimple_stmt_iterator *iter,\n-                  location_t location, bool is_store,\n-\t\t  int size_in_bytes)\n+build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n+\t\t  bool before_p, bool is_store, int size_in_bytes)\n {\n   gimple_stmt_iterator gsi;\n   basic_block then_bb, else_bb;\n@@ -614,10 +657,10 @@ build_check_stmt (tree base, gimple_stmt_iterator *iter,\n \n   /* Get an iterator on the point where we can add the condition\n      statement for the instrumentation.  */\n-  gsi = create_cond_insert_point_before_iter (iter,\n-\t\t\t\t\t      /*then_more_likely_p=*/false,\n-\t\t\t\t\t      &then_bb,\n-\t\t\t\t\t      &else_bb);\n+  gsi = create_cond_insert_point (iter, before_p,\n+\t\t\t\t  /*then_more_likely_p=*/false,\n+\t\t\t\t  &then_bb,\n+\t\t\t\t  &else_bb);\n \n   base = unshare_expr (base);\n \n@@ -749,7 +792,7 @@ build_check_stmt (tree base, gimple_stmt_iterator *iter,\n \n /* If T represents a memory access, add instrumentation code before ITER.\n    LOCATION is source code location.\n-   IS_STORE is either 1 (for a store) or 0 (for a load).  */\n+   IS_STORE is either TRUE (for a store) or FALSE (for a load).  */\n \n static void\n instrument_derefs (gimple_stmt_iterator *iter, tree t,\n@@ -784,11 +827,538 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n   int volatilep = 0, unsignedp = 0;\n   get_inner_reference (t, &bitsize, &bitpos, &offset,\n \t\t       &mode, &unsignedp, &volatilep, false);\n-  if (bitpos != 0 || bitsize != size_in_bytes * BITS_PER_UNIT)\n+  if (bitpos % (size_in_bytes * BITS_PER_UNIT)\n+      || bitsize != size_in_bytes * BITS_PER_UNIT)\n     return;\n \n   base = build_fold_addr_expr (t);\n-  build_check_stmt (base, iter, location, is_store, size_in_bytes);\n+  build_check_stmt (location, base, iter, /*before_p=*/true,\n+\t\t    is_store, size_in_bytes);\n+}\n+\n+/* Instrument an access to a contiguous memory region that starts at\n+   the address pointed to by BASE, over a length of LEN (expressed in\n+   the sizeof (*BASE) bytes).  ITER points to the instruction before\n+   which the instrumentation instructions must be inserted.  LOCATION\n+   is the source location that the instrumentation instructions must\n+   have.  If IS_STORE is true, then the memory access is a store;\n+   otherwise, it's a load.  */\n+\n+static void\n+instrument_mem_region_access (tree base, tree len,\n+\t\t\t      gimple_stmt_iterator *iter,\n+\t\t\t      location_t location, bool is_store)\n+{\n+  if (integer_zerop (len))\n+    return;\n+\n+  gimple_stmt_iterator gsi = *iter;\n+\n+  basic_block fallthrough_bb = NULL, then_bb = NULL;\n+  if (!is_gimple_constant (len))\n+    {\n+      /* So, the length of the memory area to asan-protect is\n+\t non-constant.  Let's guard the generated instrumentation code\n+\t like:\n+\n+\t if (len != 0)\n+\t   {\n+\t     //asan instrumentation code goes here.\n+           }\n+\t   // falltrough instructions, starting with *ITER.  */\n+\n+      gimple g = gimple_build_cond (NE_EXPR,\n+\t\t\t\t    len,\n+\t\t\t\t    build_int_cst (TREE_TYPE (len), 0),\n+\t\t\t\t    NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, location);\n+      insert_if_then_before_iter (g, iter, /*then_more_likely_p=*/true,\n+\t\t\t\t  &then_bb, &fallthrough_bb);\n+      /* Note that fallthrough_bb starts with the statement that was\n+\t pointed to by ITER.  */\n+\n+      /* The 'then block' of the 'if (len != 0) condition is where\n+\t we'll generate the asan instrumentation code now.  */\n+      gsi = gsi_start_bb (then_bb);\n+    }\n+\n+  /* Instrument the beginning of the memory region to be accessed,\n+     and arrange for the rest of the intrumentation code to be\n+     inserted in the then block *after* the current gsi.  */\n+  build_check_stmt (location, base, &gsi, /*before_p=*/true, is_store, 1);\n+\n+  if (then_bb)\n+    /* We are in the case where the length of the region is not\n+       constant; so instrumentation code is being generated in the\n+       'then block' of the 'if (len != 0) condition.  Let's arrange\n+       for the subsequent instrumentation statements to go in the\n+       'then block'.  */\n+    gsi = gsi_last_bb (then_bb);\n+  else\n+    *iter = gsi;\n+\n+  /* We want to instrument the access at the end of the memory region,\n+     which is at (base + len - 1).  */\n+\n+  /* offset = len - 1;  */\n+  len = unshare_expr (len);\n+  gimple offset =\n+    gimple_build_assign_with_ops (TREE_CODE (len),\n+\t\t\t\t  make_ssa_name (TREE_TYPE (len), NULL),\n+\t\t\t\t  len, NULL);\n+  gimple_set_location (offset, location);\n+  gsi_insert_before (&gsi, offset, GSI_NEW_STMT);\n+\n+  offset =\n+    gimple_build_assign_with_ops (MINUS_EXPR,\n+\t\t\t\t  make_ssa_name (size_type_node, NULL),\n+\t\t\t\t  gimple_assign_lhs (offset),\n+\t\t\t\t  build_int_cst (size_type_node, 1));\n+  gimple_set_location (offset, location);\n+  gsi_insert_after (&gsi, offset, GSI_NEW_STMT);\n+\n+  /* _1 = base;  */\n+  base = unshare_expr (base);\n+  gimple region_end =\n+    gimple_build_assign_with_ops (TREE_CODE (base),\n+\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n+\t\t\t\t  base, NULL);\n+  gimple_set_location (region_end, location);\n+  gsi_insert_after (&gsi, region_end, GSI_NEW_STMT);\n+\n+  /* _2 = _1 + offset;  */\n+  region_end =\n+    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n+\t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n+\t\t\t\t  gimple_assign_lhs (region_end), \n+\t\t\t\t  gimple_assign_lhs (offset));\n+  gimple_set_location (region_end, location);\n+  gsi_insert_after (&gsi, region_end, GSI_NEW_STMT);\n+\n+  /* instrument access at _2;  */\n+  build_check_stmt (location, gimple_assign_lhs (region_end),\n+\t\t    &gsi, /*before_p=*/false, is_store, 1);\n+}\n+\n+/* Instrument the call (to the builtin strlen function) pointed to by\n+   ITER.\n+\n+   This function instruments the access to the first byte of the\n+   argument, right before the call.  After the call it instruments the\n+   access to the last byte of the argument; it uses the result of the\n+   call to deduce the offset of that last byte.\n+\n+   Upon completion, iff the call has actullay been instrumented, this\n+   function returns TRUE and *ITER points to the statement logically\n+   following the built-in strlen function call *ITER was initially\n+   pointing to.  Otherwise, the function returns FALSE and *ITER\n+   remains unchanged.  */\n+\n+static bool\n+instrument_strlen_call (gimple_stmt_iterator *iter)\n+{\n+  gimple call = gsi_stmt (*iter);\n+  gcc_assert (is_gimple_call (call));\n+\n+  tree callee = gimple_call_fndecl (call);\n+  gcc_assert (is_builtin_fn (callee)\n+\t      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (callee) == BUILT_IN_STRLEN);\n+\n+  tree len = gimple_call_lhs (call);\n+  if (len == NULL)\n+    /* Some passes might clear the return value of the strlen call;\n+       bail out in that case.  Return FALSE as we are not advancing\n+       *ITER.  */\n+    return false;\n+  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (len)));\n+\n+  location_t loc = gimple_location (call);\n+  tree str_arg = gimple_call_arg (call, 0);\n+\n+  /* Instrument the access to the first byte of str_arg.  i.e:\n+\n+     _1 = str_arg; instrument (_1); */\n+  gimple str_arg_ssa =\n+    gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t  make_ssa_name (build_pointer_type\n+\t\t\t\t\t\t (char_type_node), NULL),\n+\t\t\t\t  str_arg, NULL);\n+  gimple_set_location (str_arg_ssa, loc);\n+  gimple_stmt_iterator gsi = *iter;\n+  gsi_insert_before (&gsi, str_arg_ssa, GSI_NEW_STMT);\n+  build_check_stmt (loc, gimple_assign_lhs (str_arg_ssa), &gsi,\n+\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n+\n+  /* If we initially had an instruction like:\n+\n+\t int n = strlen (str)\n+\n+     we now want to instrument the access to str[n], after the\n+     instruction above.*/\n+\n+  /* So let's build the access to str[n] that is, access through the\n+     pointer_plus expr: (_1 + len).  */\n+  gimple stmt =\n+    gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n+\t\t\t\t  make_ssa_name (TREE_TYPE (str_arg),\n+\t\t\t\t\t\t NULL),\n+\t\t\t\t  gimple_assign_lhs (str_arg_ssa),\n+\t\t\t\t  len);\n+  gimple_set_location (stmt, loc);\n+  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+\n+  build_check_stmt (loc, gimple_assign_lhs (stmt), &gsi,\n+\t\t    /*before_p=*/false, /*is_store=*/false, 1);\n+\n+  /* Ensure that iter points to the statement logically following the\n+     one it was initially pointing to.  */\n+  *iter = gsi;\n+  /* As *ITER has been advanced to point to the next statement, let's\n+     return true to inform transform_statements that it shouldn't\n+     advance *ITER anymore; otherwises it will skip that next\n+     statement, which wouldn't be instrumented.  */\n+  return true;\n+}\n+\n+/* Instrument the call to a built-in memory access function that is\n+   pointed to by the iterator ITER.\n+\n+   Upon completion, return TRUE iff *ITER has been advanced to the\n+   statement following the one it was originally pointing to.  */\n+\n+static bool\n+instrument_builtin_call (gimple_stmt_iterator *iter)\n+{\n+  gimple call = gsi_stmt (*iter);\n+\n+  gcc_assert (is_gimple_builtin_call (call));\n+\n+  tree callee = gimple_call_fndecl (call);\n+  location_t loc = gimple_location (call);\n+  tree source0 = NULL_TREE, source1 = NULL_TREE,\n+    dest = NULL_TREE, len = NULL_TREE;\n+  bool is_store = true;\n+\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+      /* (s, s, n) style memops.  */\n+    case BUILT_IN_BCMP:\n+    case BUILT_IN_MEMCMP:\n+      len = gimple_call_arg (call, 2);\n+      source0 = gimple_call_arg (call, 0);\n+      source1 = gimple_call_arg (call, 1);\n+      break;\n+\n+      /* (src, dest, n) style memops.  */\n+    case BUILT_IN_BCOPY:\n+      len = gimple_call_arg (call, 2);\n+      source0 = gimple_call_arg (call, 0);\n+      dest = gimple_call_arg (call, 2);\n+      break;\n+\n+      /* (dest, src, n) style memops.  */\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMPCPY_CHK:\n+      dest = gimple_call_arg (call, 0);\n+      source0 = gimple_call_arg (call, 1);\n+      len = gimple_call_arg (call, 2);\n+      break;\n+\n+      /* (dest, n) style memops.  */\n+    case BUILT_IN_BZERO:\n+      dest = gimple_call_arg (call, 0);\n+      len = gimple_call_arg (call, 1);\n+      break;\n+\n+      /* (dest, x, n) style memops*/\n+    case BUILT_IN_MEMSET:\n+    case BUILT_IN_MEMSET_CHK:\n+      dest = gimple_call_arg (call, 0);\n+      len = gimple_call_arg (call, 2);\n+      break;\n+\n+    case BUILT_IN_STRLEN:\n+      return instrument_strlen_call (iter);\n+\n+    /* And now the __atomic* and __sync builtins.\n+       These are handled differently from the classical memory memory\n+       access builtins above.  */\n+\n+    case BUILT_IN_ATOMIC_LOAD:\n+    case BUILT_IN_ATOMIC_LOAD_1:\n+    case BUILT_IN_ATOMIC_LOAD_2:\n+    case BUILT_IN_ATOMIC_LOAD_4:\n+    case BUILT_IN_ATOMIC_LOAD_8:\n+    case BUILT_IN_ATOMIC_LOAD_16:\n+      is_store = false;\n+      /* fall through.  */\n+\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_1:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_2:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_4:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_8:\n+    case BUILT_IN_SYNC_FETCH_AND_ADD_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_1:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_2:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_4:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_8:\n+    case BUILT_IN_SYNC_FETCH_AND_SUB_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_OR_1:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_2:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_4:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_8:\n+    case BUILT_IN_SYNC_FETCH_AND_OR_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_AND_1:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_2:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_4:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_8:\n+    case BUILT_IN_SYNC_FETCH_AND_AND_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_1:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_2:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_4:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_8:\n+    case BUILT_IN_SYNC_FETCH_AND_XOR_16:\n+\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_1:\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_2:\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_4:\n+    case BUILT_IN_SYNC_FETCH_AND_NAND_8:\n+\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_1:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_2:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_4:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_8:\n+    case BUILT_IN_SYNC_ADD_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_1:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_2:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_4:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_8:\n+    case BUILT_IN_SYNC_SUB_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_OR_AND_FETCH_1:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_2:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_4:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_8:\n+    case BUILT_IN_SYNC_OR_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_AND_AND_FETCH_1:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_2:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_4:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_8:\n+    case BUILT_IN_SYNC_AND_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_1:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_2:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_4:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_8:\n+    case BUILT_IN_SYNC_XOR_AND_FETCH_16:\n+\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_1:\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_2:\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_4:\n+    case BUILT_IN_SYNC_NAND_AND_FETCH_8:\n+\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_1:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_2:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8:\n+    case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_16:\n+\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_1:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_2:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_4:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_8:\n+    case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_16:\n+\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_1:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_2:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_4:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_8:\n+    case BUILT_IN_SYNC_LOCK_TEST_AND_SET_16:\n+\n+    case BUILT_IN_SYNC_LOCK_RELEASE_1:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_2:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_4:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_8:\n+    case BUILT_IN_SYNC_LOCK_RELEASE_16:\n+\n+    case BUILT_IN_ATOMIC_TEST_AND_SET:\n+    case BUILT_IN_ATOMIC_CLEAR:\n+    case BUILT_IN_ATOMIC_EXCHANGE:\n+    case BUILT_IN_ATOMIC_EXCHANGE_1:\n+    case BUILT_IN_ATOMIC_EXCHANGE_2:\n+    case BUILT_IN_ATOMIC_EXCHANGE_4:\n+    case BUILT_IN_ATOMIC_EXCHANGE_8:\n+    case BUILT_IN_ATOMIC_EXCHANGE_16:\n+\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_2:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n+\n+    case BUILT_IN_ATOMIC_STORE:\n+    case BUILT_IN_ATOMIC_STORE_1:\n+    case BUILT_IN_ATOMIC_STORE_2:\n+    case BUILT_IN_ATOMIC_STORE_4:\n+    case BUILT_IN_ATOMIC_STORE_8:\n+    case BUILT_IN_ATOMIC_STORE_16:\n+\n+    case BUILT_IN_ATOMIC_ADD_FETCH_1:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_2:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_4:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_8:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_SUB_FETCH_1:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_2:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_4:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_8:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_AND_FETCH_1:\n+    case BUILT_IN_ATOMIC_AND_FETCH_2:\n+    case BUILT_IN_ATOMIC_AND_FETCH_4:\n+    case BUILT_IN_ATOMIC_AND_FETCH_8:\n+    case BUILT_IN_ATOMIC_AND_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_NAND_FETCH_1:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_2:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_4:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_8:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_XOR_FETCH_1:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_2:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_4:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_8:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_OR_FETCH_1:\n+    case BUILT_IN_ATOMIC_OR_FETCH_2:\n+    case BUILT_IN_ATOMIC_OR_FETCH_4:\n+    case BUILT_IN_ATOMIC_OR_FETCH_8:\n+    case BUILT_IN_ATOMIC_OR_FETCH_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_ADD_1:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_2:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_4:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_8:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_SUB_1:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_2:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_4:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_8:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_AND_1:\n+    case BUILT_IN_ATOMIC_FETCH_AND_2:\n+    case BUILT_IN_ATOMIC_FETCH_AND_4:\n+    case BUILT_IN_ATOMIC_FETCH_AND_8:\n+    case BUILT_IN_ATOMIC_FETCH_AND_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_NAND_1:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_2:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_4:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_8:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_XOR_1:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_2:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_4:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_8:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_16:\n+\n+    case BUILT_IN_ATOMIC_FETCH_OR_1:\n+    case BUILT_IN_ATOMIC_FETCH_OR_2:\n+    case BUILT_IN_ATOMIC_FETCH_OR_4:\n+    case BUILT_IN_ATOMIC_FETCH_OR_8:\n+    case BUILT_IN_ATOMIC_FETCH_OR_16:\n+      {\n+\tdest = gimple_call_arg (call, 0);\n+\t/* So DEST represents the address of a memory location.\n+\t   instrument_derefs wants the memory location, so lets\n+\t   dereference the address DEST before handing it to\n+\t   instrument_derefs.  */\n+\tif (TREE_CODE (dest) == ADDR_EXPR)\n+\t  dest = TREE_OPERAND (dest, 0);\n+\telse if (TREE_CODE (dest) == SSA_NAME)\n+\t  dest = build2 (MEM_REF, TREE_TYPE (TREE_TYPE (dest)),\n+\t\t\t dest, build_int_cst (TREE_TYPE (dest), 0));\n+\telse\n+\t  gcc_unreachable ();\n+\n+\tinstrument_derefs (iter, dest, loc, is_store);\n+\treturn false;\n+      }\n+\n+    default:\n+      /* The other builtins memory access are not instrumented in this\n+\t function because they either don't have any length parameter,\n+\t or their length parameter is just a limit.  */\n+      break;\n+    }\n+\n+  if (len != NULL_TREE)\n+    {\n+      if (source0 != NULL_TREE)\n+\tinstrument_mem_region_access (source0, len, iter,\n+\t\t\t\t      loc, /*is_store=*/false);\n+      if (source1 != NULL_TREE)\n+\tinstrument_mem_region_access (source1, len, iter,\n+\t\t\t\t      loc, /*is_store=*/false);\n+      else if (dest != NULL_TREE)\n+\tinstrument_mem_region_access (dest, len, iter,\n+\t\t\t\t      loc, /*is_store=*/true);\n+\n+      *iter = gsi_for_stmt (call);\n+      return false;\n+    }\n+  return false;\n+}\n+\n+/*  Instrument the assignment statement ITER if it is subject to\n+    instrumentation.  */\n+\n+static void\n+instrument_assignment (gimple_stmt_iterator *iter)\n+{\n+  gimple s = gsi_stmt (*iter);\n+\n+  gcc_assert (gimple_assign_single_p (s));\n+\n+  instrument_derefs (iter, gimple_assign_lhs (s),\n+\t\t     gimple_location (s), true);\n+  instrument_derefs (iter, gimple_assign_rhs1 (s),\n+\t\t     gimple_location (s), false);\n+}\n+\n+/* Instrument the function call pointed to by the iterator ITER, if it\n+   is subject to instrumentation.  At the moment, the only function\n+   calls that are instrumented are some built-in functions that access\n+   memory.  Look at instrument_builtin_call to learn more.\n+\n+   Upon completion return TRUE iff *ITER was advanced to the statement\n+   following the one it was originally pointing to.  */\n+\n+static bool\n+maybe_instrument_call (gimple_stmt_iterator *iter)\n+{\n+  if (is_gimple_builtin_call (gsi_stmt (*iter)))\n+    return instrument_builtin_call (iter);\n+  return false;\n }\n \n /* asan: this looks too complex. Can this be done simpler? */\n@@ -807,15 +1377,20 @@ transform_statements (void)\n   FOR_EACH_BB (bb)\n     {\n       if (bb->index >= saved_last_basic_block) continue;\n-      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+      for (i = gsi_start_bb (bb); !gsi_end_p (i);)\n         {\n-          gimple s = gsi_stmt (i);\n-          if (!gimple_assign_single_p (s))\n-\t    continue;\n-          instrument_derefs (&i, gimple_assign_lhs (s),\n-                             gimple_location (s), true);\n-          instrument_derefs (&i, gimple_assign_rhs1 (s),\n-                             gimple_location (s), false);\n+\t  gimple s = gsi_stmt (i);\n+\n+\t  if (gimple_assign_single_p (s))\n+\t    instrument_assignment (&i);\n+\t  else if (is_gimple_call (s))\n+\t    {\n+\t      if (maybe_instrument_call (&i))\n+\t\t/* Avoid gsi_next (&i), because maybe_instrument_call\n+\t\t   advanced the I iterator already.  */\n+\t\tcontinue;\n+\t    }\n+\t  gsi_next (&i);\n         }\n     }\n }"}, {"sha": "481a4d9e477fcfe0c16ca52468485082790fdbdc", "filename": "gcc/gimple.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "patch": "@@ -4121,6 +4121,22 @@ gimple_decl_printable_name (tree decl, int verbosity)\n   return IDENTIFIER_POINTER (DECL_NAME (decl));\n }\n \n+/* Return TRUE iff stmt is a call to a built-in function.  */\n+\n+bool\n+is_gimple_builtin_call (gimple stmt)\n+{\n+  tree callee;\n+\n+  if (is_gimple_call (stmt)\n+      && (callee = gimple_call_fndecl (stmt))\n+      && is_builtin_fn (callee)\n+      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return true when STMT is builtins call to CODE.  */\n \n bool"}, {"sha": "e73fe0d890515a1691862e1d1c67472940fecab8", "filename": "gcc/gimple.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ae50273ad2801ecc262ba75fa8bac0c4e0001b/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "patch": "@@ -875,6 +875,9 @@ extern bool is_gimple_condexpr (tree);\n /* Returns true iff T is a valid call address expression.  */\n extern bool is_gimple_call_addr (tree);\n \n+/* Return TRUE iff stmt is a call to a built-in function.  */\n+extern bool is_gimple_builtin_call (gimple stmt);\n+\n extern void recalculate_side_effects (tree);\n extern bool gimple_compare_field_offset (tree, tree);\n extern tree gimple_register_canonical_type (tree);"}]}