{"sha": "a5db0683cb7693e65b162883a755fe2a5f4ed3d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVkYjA2ODNjYjc2OTNlNjViMTYyODgzYTc1NWZlMmE1ZjRlZDNkOA==", "commit": {"author": {"name": "Jeff Sturm", "email": "jsturm@one-point.com", "date": "2002-11-04T02:45:31Z"}, "committer": {"name": "Jeff Sturm", "email": "jsturm@gcc.gnu.org", "date": "2002-11-04T02:45:31Z"}, "message": "resolve.cc (METHOD_NOT_THERE, [...]): Remove.\n\n\t* resolve.cc (METHOD_NOT_THERE, METHOD_INACCESSIBLE): Remove.\n\t(_Jv_ResolvePoolEntry): Use _Jv_Method.index, not\n\t_Jv_DetermineVTableIndex, to determine vtable offset.\n\t(_Jv_DetermineVTableIndex): Remove.\n\t(_Jv_PrepareClass): Don't layout vtable.  Use _Jv_MakeVTable instead.\n\n\t* java/lang/Class.h (friend int _Jv_DetermineVTableIndex): Remove.\n\nFrom-SVN: r58780", "tree": {"sha": "3bd82f6539b830acabdf79e52f169766b83e6679", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bd82f6539b830acabdf79e52f169766b83e6679"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5db0683cb7693e65b162883a755fe2a5f4ed3d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5db0683cb7693e65b162883a755fe2a5f4ed3d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5db0683cb7693e65b162883a755fe2a5f4ed3d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5db0683cb7693e65b162883a755fe2a5f4ed3d8/comments", "author": null, "committer": null, "parents": [{"sha": "548502d3b1a9d50061b1ee76ec6e94071d77029f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548502d3b1a9d50061b1ee76ec6e94071d77029f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/548502d3b1a9d50061b1ee76ec6e94071d77029f"}], "stats": {"total": 242, "additions": 15, "deletions": 227}, "files": [{"sha": "8695a4acb2203a8c72f192be31270ee8690594de", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5db0683cb7693e65b162883a755fe2a5f4ed3d8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5db0683cb7693e65b162883a755fe2a5f4ed3d8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a5db0683cb7693e65b162883a755fe2a5f4ed3d8", "patch": "@@ -1,3 +1,13 @@\n+2002-11-03  Jeff Sturm  <jsturm@one-point.com>\n+\n+\t* resolve.cc (METHOD_NOT_THERE, METHOD_INACCESSIBLE): Remove.\n+\t(_Jv_ResolvePoolEntry): Use _Jv_Method.index, not\n+\t_Jv_DetermineVTableIndex, to determine vtable offset.\n+\t(_Jv_DetermineVTableIndex): Remove.\n+\t(_Jv_PrepareClass): Don't layout vtable.  Use _Jv_MakeVTable instead.\n+\n+\t* java/lang/Class.h (friend int _Jv_DetermineVTableIndex): Remove.\n+\n 2002-11-03  Tom Tromey  <tromey@redhat.com>\n \n \t* java/nio/channels/AlreadyConnectedException.java: Extend"}, {"sha": "bd2903d47cf67f853c9855dc6c46820a84d82c31", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5db0683cb7693e65b162883a755fe2a5f4ed3d8/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5db0683cb7693e65b162883a755fe2a5f4ed3d8/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=a5db0683cb7693e65b162883a755fe2a5f4ed3d8", "patch": "@@ -331,8 +331,6 @@ class java::lang::Class : public java::lang::Object\n #ifdef INTERPRETER\n   friend jboolean _Jv_IsInterpretedClass (jclass);\n   friend void _Jv_InitField (jobject, jclass, _Jv_Field*);\n-  friend int _Jv_DetermineVTableIndex (jclass, _Jv_Utf8Const *, \n-\t\t\t\t       _Jv_Utf8Const*);\n   friend void _Jv_InitField (jobject, jclass, int);\n   friend _Jv_word _Jv_ResolvePoolEntry (jclass, int);\n   friend _Jv_Method *_Jv_SearchMethodInClass (jclass cls, jclass klass, "}, {"sha": "e9fe4ad5af2bfee2b4340a843e21a2f817211016", "filename": "libjava/resolve.cc", "status": "modified", "additions": 5, "deletions": 225, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5db0683cb7693e65b162883a755fe2a5f4ed3d8/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5db0683cb7693e65b162883a755fe2a5f4ed3d8/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=a5db0683cb7693e65b162883a755fe2a5f4ed3d8", "patch": "@@ -55,10 +55,6 @@ static void throw_class_format_error (jstring msg)\n static void throw_class_format_error (char *msg)\n \t__attribute__ ((__noreturn__));\n \n-// Exceptional return values for _Jv_DetermineVTableIndex\n-#define METHOD_NOT_THERE (-2)\n-#define METHOD_INACCESSIBLE (-1)\n-\n static int get_alignment_from_class (jclass);\n \n static _Jv_ResolvedMethod* \n@@ -237,7 +233,6 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n       _Jv_Utf8Const *method_name = pool->data[name_index].utf8;\n       _Jv_Utf8Const *method_signature = pool->data[type_index].utf8;\n \n-      int vtable_index = -1;\n       _Jv_Method *the_method = 0;\n       jclass found_class = 0;\n \n@@ -314,15 +309,9 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t  throw new java::lang::NoSuchMethodError (sb->toString());\n \t}\n       \n-      if (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n-\tvtable_index = -1;\n-      else\n-\tvtable_index = _Jv_DetermineVTableIndex (found_class, method_name,\n-\t\t\t\t\t\t method_signature);\n-\n-      if (vtable_index == METHOD_NOT_THERE)\n-\tthrow_incompatible_class_change_error\n-\t  (JvNewStringLatin1 (\"method not found\"));\n+      int vtable_index = -1;\n+      if (pool->tags[index] != JV_CONSTANT_InterfaceMethodref)\n+\tvtable_index = (jshort)the_method->index;\n \n       pool->data[index].rmethod = \n \t_Jv_BuildResolvedMethod(the_method,\n@@ -374,116 +363,6 @@ _Jv_SearchMethodInClass (jclass cls, jclass klass,\n   return 0;\n }\n \n-/** FIXME: this is a terribly inefficient algorithm!  It would improve\n-    things if compiled classes to know vtable offset, and _Jv_Method had\n-    a field for this.\n-\n-    Returns METHOD_NOT_THERE if this class does not declare the given method.\n-    Returns METHOD_INACCESSIBLE if the given method does not appear in the\n-\t\tvtable, i.e., it is static, private, final or a constructor.\n-    Otherwise, returns the vtable index.  */\n-int \n-_Jv_DetermineVTableIndex (jclass klass,\n-\t\t\t  _Jv_Utf8Const *name,\n-\t\t\t  _Jv_Utf8Const *signature)\n-{\n-  using namespace java::lang::reflect;\n-\n-  jclass super_class = klass->getSuperclass ();\n-\n-  if (super_class != NULL)\n-    {\n-      int prev = _Jv_DetermineVTableIndex (super_class,\n-\t\t\t\t\t   name,\n-\t\t\t\t\t   signature);\n-      if (prev != METHOD_NOT_THERE)\n-\treturn prev;\n-    }\n-\n-  /* at this point, we know that the super-class does not declare\n-   * the method.  Otherwise, the above call would have found it, and\n-   * determined the result of this function (-1 or some positive\n-   * number).\n-   */\n-\n-  _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n-\n-  /* now, if we do not declare this method, return zero */\n-  if (meth == NULL)\n-    return METHOD_NOT_THERE;\n-\n-  /* so now, we know not only that the super class does not declare the\n-   * method, but we do!  So, this is a first declaration of the method. */\n-\n-  /* now, the checks for things that are declared in this class, but do\n-   * not go into the vtable.  There are three cases.  \n-   * 1) the method is static, private or final\n-   * 2) the class itself is final, or\n-   * 3) it is the method <init>\n-   */\n-\n-  if ((meth->accflags & (Modifier::STATIC\n-\t\t\t | Modifier::PRIVATE\n-\t\t\t | Modifier::FINAL)) != 0\n-      || (klass->accflags & Modifier::FINAL) != 0\n-      || _Jv_equalUtf8Consts (name, init_name))\n-    return METHOD_INACCESSIBLE;\n-\n-  /* reaching this point, we know for sure, that the method in question\n-   * will be in the vtable.  The question is where. */\n-\n-  /* the base offset, is where we will start assigning vtable\n-   * indexes for this class.  It is 0 for base classes\n-   * and for non-base classes it is the\n-   * number of entries in the super class' vtable. */\n-\n-  int base_offset;\n-  if (super_class == 0)\n-    base_offset = 0;\n-  else\n-    base_offset = super_class->vtable_method_count;\n-\n-  /* we will consider methods 0..this_method_index-1.  And for each one,\n-   * determine if it is new (i.e., if it appears in the super class),\n-   * and if it should go in the vtable.  If so, increment base_offset */\n-\n-  int this_method_index = meth - (&klass->methods[0]);\n-\n-  for (int i = 0; i < this_method_index; i++)\n-    {\n-      _Jv_Method *m = &klass->methods[i];\n-\n-      /* fist some checks for things that surely do not go in the\n-       * vtable */\n-\n-      if ((m->accflags & (Modifier::STATIC | Modifier::PRIVATE)) != 0)\n-\tcontinue;\n-      if (_Jv_equalUtf8Consts (m->name, init_name))\n-\tcontinue;\n-      \n-      /* Then, we need to know if this method appears in the\n-         superclass. (This is where this function gets expensive) */\n-      _Jv_Method *sm = _Jv_LookupDeclaredMethod (super_class,\n-\t\t\t\t\t\t m->name,\n-\t\t\t\t\t\t m->signature);\n-      \n-      /* if it was somehow declared in the superclass, skip this */\n-      if (sm != NULL)\n-\tcontinue;\n-\n-      /* but if it is final, and not declared in the super class,\n-       * then we also skip it */\n-      if ((m->accflags & Modifier::FINAL) != 0)\n-\tcontinue;\n-\n-      /* finally, we can assign the index of this method */\n-      /* m->vtable_index = base_offset */\n-      base_offset += 1;\n-    }\n-\n-  return base_offset;\n-}\n-\n /* this is installed in place of abstract methods */\n static void\n _Jv_abstractMethodError ()\n@@ -651,107 +530,8 @@ _Jv_PrepareClass(jclass klass)\n       return;\n     }\n \n-  /* Now onto the actual job: vtable layout.  First, count how many new\n-     methods we have */\n-  int new_method_count = 0;\n-\n-  jclass super_class = clz->getSuperclass ();\n-\n-  for (int i = 0; i < clz->method_count; i++)\n-    {\n-      _Jv_Method *this_meth = &clz->methods[i];\n-\n-      if ((this_meth->accflags & (Modifier::STATIC | Modifier::PRIVATE)) != 0\n-\t  || _Jv_equalUtf8Consts (this_meth->name, init_name))\n-\t{\n-\t  /* skip this, it doesn't go in the vtable */\n-\t  continue;\n-\t}\n-\t  \n-      _Jv_Method *orig_meth = _Jv_LookupDeclaredMethod (super_class,\n-\t\t\t\t\t\t\tthis_meth->name,\n-\t\t\t\t\t\t\tthis_meth->signature);\n-\n-      if (orig_meth == 0)\n-\t{\n-\t  // new methods that are final, also don't go in the vtable\n-\t  if ((this_meth->accflags & Modifier::FINAL) != 0)\n-\t    continue;\n-\n-\t  new_method_count += 1;\n-\t  continue;\n-\t}\n-\n-      if ((orig_meth->accflags & (Modifier::STATIC\n-\t\t\t\t  | Modifier::PRIVATE\n-\t\t\t\t  | Modifier::FINAL)) != 0\n-\t  || ((orig_meth->accflags & Modifier::ABSTRACT) == 0\n-\t      && (this_meth->accflags & Modifier::ABSTRACT) != 0\n-\t      && (klass->accflags & Modifier::ABSTRACT) == 0))\n-\t{\n-\t  clz->state = JV_STATE_ERROR;\n-\t  clz->notifyAll ();\n-\t  throw new java::lang::IncompatibleClassChangeError (clz->getName ());\n-\t}\n-\n-      /* FIXME: At this point, if (loader != super_class->loader), we\n-       * need to \"impose class loader constraints\" for the types\n-       * involved in the signature of this method */\n-    }\n-  \n-  /* determine size */\n-  int vtable_count = (super_class->vtable_method_count) + new_method_count;\n-  clz->vtable_method_count = vtable_count;\n-\n-  /* allocate vtable structure */\n-  _Jv_VTable *vtable = _Jv_VTable::new_vtable (vtable_count);\n-  vtable->clas = clz;\n-  vtable->gc_descr = _Jv_BuildGCDescr(clz);\n-\n-  {\n-    jclass effective_superclass = super_class;\n-\n-    /* If super_class is abstract or an interface it has no vtable.\n-       We need to find a real one... */\n-    while (effective_superclass && effective_superclass->vtable == NULL)\n-      effective_superclass = effective_superclass->superclass;\n-\n-    /* If we ended up without a superclass, use Object.  */\n-    if (! effective_superclass)\n-      effective_superclass = &java::lang::Object::class$;\n-\n-    /* copy super class' vtable entries. */\n-    if (effective_superclass && effective_superclass->vtable)\n-      for (int i = 0; i < effective_superclass->vtable_method_count; ++i)\n-\tvtable->set_method (i, effective_superclass->vtable->get_method (i));\n-  }\n-\n-  /* now, install our own vtable entries, reprise... */\n-  for (int i = 0; i < clz->method_count; i++)\n-    {\n-      _Jv_Method *this_meth = &clz->methods[i];\n-\n-      int index = _Jv_DetermineVTableIndex (clz, \n-\t\t\t\t\t    this_meth->name,\n-\t\t\t\t\t    this_meth->signature);\n-\n-      if (index == METHOD_NOT_THERE)\n-\tthrow_internal_error (\"method now found in own class\");\n-\n-      if (index != METHOD_INACCESSIBLE)\n-\t{\n-\t  if (index > clz->vtable_method_count)\n-\t    throw_internal_error (\"vtable problem...\");\n-\n-\t  if (clz->interpreted_methods[i] == 0)\n-\t    vtable->set_method(index, (void*)&_Jv_abstractMethodError);\n-\t  else\n-\t    vtable->set_method(index, this_meth->ncode);\n-\t}\n-    }\n-\n-  /* finally, assign the vtable! */\n-  clz->vtable = vtable;\n+  clz->vtable_method_count = -1;\n+  _Jv_MakeVTable (clz);\n \n   /* wooha! we're done. */\n   clz->state = JV_STATE_PREPARED;"}]}