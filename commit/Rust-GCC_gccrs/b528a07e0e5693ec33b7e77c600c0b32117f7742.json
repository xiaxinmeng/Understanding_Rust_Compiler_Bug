{"sha": "b528a07e0e5693ec33b7e77c600c0b32117f7742", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyOGEwN2UwZTU2OTNlYzMzYjdlNzdjNjAwYzBiMzIxMTdmNzc0Mg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-12T11:46:21Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-12T11:46:21Z"}, "message": "cppexp.c: Don't worry about pfile->skipping.\n\n        * cppexp.c: Don't worry about pfile->skipping.\n        * cpplib.c (struct if_stack): Make was_skipping unsigned char.\n        (cpp_handle_directive): Save pfile->skipping in struct cpp_buffer\n        for handled directives.\n        (skip_rest_of_line): Use _cpp_lex_token after popping contexts\n        and releasing lookaheads.\n        (do_ifdef, do_ifndef, do_if): Use buffer->was_skipping.\n        (do_else, do_elif, push_conditional): Update logic.\n        (do_endif): Set buffer->was_skipping rather than pfile->skipping.\n        (unwind_if_stack): Inline into cpp_pop_buffer.\n        (cpp_push_buffer): Clear ifs->was_skipping for cpp_handle_directive.\n        * cpplex.c (_cpp_lex_token): Clear skipping on EOF.  Handle\n        multiple-include optimisation.\n        * cpplib.h (struct cpp_buffer): New member was_skipping.\n        * cppmacro.c (_cpp_get_token): Loop whilst pfile->skipping.  This\n        works because skipping == 0 in directives.\n        (_cpp_release_lookahead): Renamed from release_lookahead.\n        (cpp_get_token): No need to check skipping as _cpp_get_token does\n        this for us.  No need to handle MI optimisation.\n\nFrom-SVN: r37404", "tree": {"sha": "f74638e6668fd7907064468bc11254a90aefe287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f74638e6668fd7907064468bc11254a90aefe287"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b528a07e0e5693ec33b7e77c600c0b32117f7742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b528a07e0e5693ec33b7e77c600c0b32117f7742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b528a07e0e5693ec33b7e77c600c0b32117f7742", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b528a07e0e5693ec33b7e77c600c0b32117f7742/comments", "author": null, "committer": null, "parents": [{"sha": "46bdc296a8c34fb42a934e21878817970541560e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46bdc296a8c34fb42a934e21878817970541560e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46bdc296a8c34fb42a934e21878817970541560e"}], "stats": {"total": 240, "additions": 118, "deletions": 122}, "files": [{"sha": "b255253a79dc5134317c430b3301fdec951485ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b528a07e0e5693ec33b7e77c600c0b32117f7742", "patch": "@@ -1,3 +1,25 @@\n+2000-11-12  Neil Booth  <neilb@earthling.net>\n+\n+        * cppexp.c: Don't worry about pfile->skipping.\n+        * cpplib.c (struct if_stack): Make was_skipping unsigned char.\n+        (cpp_handle_directive): Save pfile->skipping in struct cpp_buffer\n+        for handled directives.\n+        (skip_rest_of_line): Use _cpp_lex_token after popping contexts\n+        and releasing lookaheads.\n+        (do_ifdef, do_ifndef, do_if): Use buffer->was_skipping.\n+        (do_else, do_elif, push_conditional): Update logic.\n+        (do_endif): Set buffer->was_skipping rather than pfile->skipping.\n+        (unwind_if_stack): Inline into cpp_pop_buffer.\n+        (cpp_push_buffer): Clear ifs->was_skipping for cpp_handle_directive.\n+        * cpplex.c (_cpp_lex_token): Clear skipping on EOF.  Handle\n+        multiple-include optimisation.\n+        * cpplib.h (struct cpp_buffer): New member was_skipping.\n+        * cppmacro.c (_cpp_get_token): Loop whilst pfile->skipping.  This\n+        works because skipping == 0 in directives.\n+        (_cpp_release_lookahead): Renamed from release_lookahead.\n+        (cpp_get_token): No need to check skipping as _cpp_get_token does\n+        this for us.  No need to handle MI optimisation.\n+\n Sat Nov 11 21:14:02 2000  Mark P Mitchell  <mark@codesourcery.com>\n \n \t* fixinc/inclhack.def (sunos_matherr_decl): Bypass matherr"}, {"sha": "82f8aab580f3bbb4f897813fcb24c79ec56c4c2a", "filename": "gcc/cppexp.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=b528a07e0e5693ec33b7e77c600c0b32117f7742", "patch": "@@ -752,10 +752,6 @@ _cpp_parse_expr (pfile)\n   int skip_evaluation = 0;\n   int result;\n \n-  /* Save parser state and set it to something sane.  */\n-  int save_skipping = pfile->skipping;\n-  pfile->skipping = 0;\n-\n   /* Set up detection of #if ! defined().  */\n   pfile->mi_lexed = 0;\n   pfile->mi_if_not_defined = MI_IND_NONE;\n@@ -1039,7 +1035,6 @@ _cpp_parse_expr (pfile)\n   /* Free dynamic stack if we allocated one.  */\n   if (stack != init_stack)\n     free (stack);\n-  pfile->skipping = save_skipping;\n   return result;\n }\n "}, {"sha": "ebccda6080c635499622c83a1b69905329e40f95", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=b528a07e0e5693ec33b7e77c600c0b32117f7742", "patch": "@@ -160,6 +160,7 @@ extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n extern void _cpp_get_token \t\tPARAMS ((cpp_reader *, cpp_token *));\n extern void _cpp_free_lookaheads\tPARAMS ((cpp_reader *));\n+extern void _cpp_release_lookahead\tPARAMS ((cpp_reader *));\n extern void _cpp_push_token\t\tPARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t\t\t const cpp_lexer_pos *));\n "}, {"sha": "75d094d21c0f95ac505c711d95dcb621b4f95283", "filename": "gcc/cpplex.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=b528a07e0e5693ec33b7e77c600c0b32117f7742", "patch": "@@ -874,6 +874,7 @@ _cpp_lex_token (pfile, result)\n       if (pfile->lexer_pos.col != 0 && !buffer->from_stage3)\n \tcpp_pedwarn (pfile, \"no newline at end of file\");\n       pfile->state.next_bol = 1;\n+      pfile->skipping = 0;\t/* In case missing #endif.  */\n       result->type = CPP_EOF;\n       break;\n \n@@ -1270,6 +1271,12 @@ _cpp_lex_token (pfile, result)\n       result->val.c = c;\n       break;\n     }\n+\n+  /* Non-comment tokens invalidate any controlling macros.  */\n+  if (result->type != CPP_COMMENT\n+      && result->type != CPP_EOF\n+      && !pfile->state.in_directive)\n+    pfile->mi_state = MI_FAILED;\n }\n \n /* An upper bound on the number of bytes needed to spell a token,"}, {"sha": "159c3db85f5761b7f2601ed2c28ae476422d854b", "filename": "gcc/cpplib.c", "status": "modified", "additions": 76, "deletions": 86, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=b528a07e0e5693ec33b7e77c600c0b32117f7742", "patch": "@@ -44,7 +44,7 @@ struct if_stack\n   struct if_stack *next;\n   cpp_lexer_pos pos;\t\t/* line and column where condition started */\n   const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */\n-  int was_skipping;\t\t/* value of pfile->skipping before this if */\n+  unsigned char was_skipping;\t/* Value of pfile->skipping before this if.  */\n   int type;\t\t\t/* type of last directive seen in this group */\n };\n \n@@ -92,9 +92,7 @@ static int  read_line_number\tPARAMS ((cpp_reader *, int *));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type));\n-static cpp_hashnode *\n-\tlex_macro_node\t\tPARAMS ((cpp_reader *));\n-static void unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n+static cpp_hashnode *lex_macro_node\tPARAMS ((cpp_reader *));\n static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n@@ -185,17 +183,18 @@ skip_rest_of_line (pfile)\n {\n   cpp_token token;\n \n+  /* Discard all lookaheads.  */\n+  while (pfile->la_read)\n+    _cpp_release_lookahead (pfile);\n+\n   /* Discard all stacked contexts.  */\n   while (pfile->context != &pfile->base_context)\n     _cpp_pop_context (pfile);\n \n-  /* Sweep up all tokens remaining on the line.  We need to read\n-     tokens from lookahead, but cannot just drop the lookahead buffers\n-     because they may be saving tokens prior to this directive for an\n-     external client.  So we use _cpp_get_token, with macros disabled.  */\n+  /* Sweep up all tokens remaining on the line.  */\n   pfile->state.prevent_expansion++;\n   while (!pfile->state.next_bol)\n-    _cpp_get_token (pfile, &token);\n+    _cpp_lex_token (pfile, &token);\n   pfile->state.prevent_expansion--;\n }\n \n@@ -222,6 +221,7 @@ _cpp_handle_directive (pfile, indented)\n      cpp_reader *pfile;\n      int indented;\n {\n+  cpp_buffer *buffer = pfile->buffer;\n   const directive *dir = 0;\n   cpp_token dname;\n   int not_asm = 1;\n@@ -250,11 +250,11 @@ _cpp_handle_directive (pfile, indented)\n \t skipped conditional groups.  Complain about this form if\n \t we're being pedantic, but not if this is regurgitated input\n \t (preprocessed or fed back in by the C++ frontend).  */\n-      if (!pfile->skipping  && !CPP_OPTION (pfile, lang_asm))\n+      if (! pfile->skipping  && !CPP_OPTION (pfile, lang_asm))\n \t{\n \t  dir = &dtable[T_LINE];\n \t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n-\t  if (CPP_PEDANTIC (pfile) && CPP_BUFFER (pfile)->inc\n+\t  if (CPP_PEDANTIC (pfile) && buffer->inc\n \t      && ! CPP_OPTION (pfile, preprocessed))\n \t    cpp_pedwarn (pfile, \"# followed by integer\");\n \t}\n@@ -290,7 +290,7 @@ _cpp_handle_directive (pfile, indented)\n \n \t  /* If we are skipping a failed conditional group, all\n \t     non-conditional directives are ignored.  */\n-\t  if (!pfile->skipping || (dir->flags & COND))\n+\t  if (! pfile->skipping || (dir->flags & COND))\n \t    {\n \t      /* Issue -pedantic warnings for extensions.   */\n \t      if (CPP_PEDANTIC (pfile) && dir->origin == EXTENSION)\n@@ -301,7 +301,10 @@ _cpp_handle_directive (pfile, indented)\n \t      if (! (dir->flags & IF_COND))\n \t\tpfile->mi_state = MI_FAILED;\n \n+\t      buffer->was_skipping = pfile->skipping;\n+\t      pfile->skipping = 0;\n \t      (*dir->handler) (pfile);\n+\t      pfile->skipping = buffer->was_skipping;\n \t    }\n \t}\n     }\n@@ -311,7 +314,7 @@ _cpp_handle_directive (pfile, indented)\n       if (indented && CPP_WTRADITIONAL (pfile))\n \tcpp_warning (pfile, \"traditional C ignores #\\\\n with the # indented\");\n     }\n-  else\n+  else if (!pfile->skipping)\n     {\n       /* An unknown directive.  Don't complain about it in assembly\n \t source: we don't know where the comments are, and # may\n@@ -323,7 +326,7 @@ _cpp_handle_directive (pfile, indented)\n \t  not_asm = 0;\n \t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n \t}\n-      else if (!pfile->skipping)\n+      else\n \tcpp_error (pfile, \"invalid preprocessing directive #%s\",\n \t\t   cpp_token_as_text (pfile, &dname));\n     }\n@@ -1164,7 +1167,7 @@ do_ifdef (pfile)\n {\n   int skip = 1;\n \n-  if (! pfile->skipping)\n+  if (! pfile->buffer->was_skipping)\n     {\n       const cpp_hashnode *node = lex_macro_node (pfile);\n \n@@ -1182,7 +1185,7 @@ do_ifndef (pfile)\n   int skip = 1;\n   const cpp_hashnode *node = 0;\n \n-  if (! pfile->skipping)\n+  if (! pfile->buffer->was_skipping)\n     {\n       node = lex_macro_node (pfile);\n       if (node)\n@@ -1204,7 +1207,7 @@ do_if (pfile)\n   int skip = 1;\n   const cpp_hashnode *cmacro = 0;\n \n-  if (!pfile->skipping)\n+  if (! pfile->buffer->was_skipping)\n     {\n       /* Controlling macro of #if ! defined ()  */\n       pfile->mi_ind_cmacro = 0;\n@@ -1215,15 +1218,16 @@ do_if (pfile)\n   push_conditional (pfile, skip, T_IF, cmacro);\n }\n \n-/* #else flips pfile->skipping and continues without changing\n+/* Flip skipping state if appropriate and continue without changing\n    if_stack; this is so that the error message for missing #endif's\n    etc. will point to the original #if.  */\n \n static void\n do_else (pfile)\n      cpp_reader *pfile;\n {\n-  struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n+  cpp_buffer *buffer = pfile->buffer;\n+  struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n     cpp_error (pfile, \"#else without #if\");\n@@ -1235,18 +1239,15 @@ do_else (pfile)\n \t  cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n \t\t\t       \"the conditional began here\");\n \t}\n+      ifs->type = T_ELSE;\n+\n+      /* Buffer->was_skipping is 1 if all conditionals in this chain\n+\t have been false, 2 if a conditional has been true.  */\n+      if (! ifs->was_skipping && buffer->was_skipping != 2)\n+\tbuffer->was_skipping = ! buffer->was_skipping;\n \n       /* Invalidate any controlling macro.  */\n       ifs->mi_cmacro = 0;\n-\n-      ifs->type = T_ELSE;\n-      if (! ifs->was_skipping)\n-\t{\n-\t  /* If pfile->skipping is 2, one of the blocks in an #if\n-\t     #elif ... chain succeeded, so we skip the else block.  */\n-\t  if (pfile->skipping < 2)\n-\t    pfile->skipping = ! pfile->skipping;\n-\t}\n     }\n \n   check_eol (pfile);\n@@ -1259,35 +1260,35 @@ static void\n do_elif (pfile)\n      cpp_reader *pfile;\n {\n-  struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n+  cpp_buffer *buffer = pfile->buffer;\n+  struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n+    cpp_error (pfile, \"#elif without #if\");\n+  else\n     {\n-      cpp_error (pfile, \"#elif without #if\");\n-      return;\n-    }\n-\n-  if (ifs->type == T_ELSE)\n-    {\n-      cpp_error (pfile, \"#elif after #else\");\n-      cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n-\t\t\t   \"the conditional began here\");\n-    }\n-\n-  /* Invalidate any controlling macro.  */\n-  ifs->mi_cmacro = 0;\n+      if (ifs->type == T_ELSE)\n+\t{\n+\t  cpp_error (pfile, \"#elif after #else\");\n+\t  cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t\t\t       \"the conditional began here\");\n+\t}\n+      ifs->type = T_ELIF;\n \n-  ifs->type = T_ELIF;\n-  if (ifs->was_skipping)\n-    return;  /* Don't evaluate a nested #if */\n+      /* Don't evaluate #elif if our higher level is skipping.  */\n+      if (! ifs->was_skipping)\n+\t{\n+\t  /* Buffer->was_skipping is 1 if all conditionals in this\n+\t     chain have been false, 2 if a conditional has been true.  */\n+\t  if (buffer->was_skipping == 1)\n+\t    buffer->was_skipping = ! _cpp_parse_expr (pfile);\n+\t  else\n+\t    buffer->was_skipping = 2;\n \n-  if (pfile->skipping != 1)\n-    {\n-      pfile->skipping = 2;  /* one block succeeded, so don't do any others */\n-      return;\n+\t  /* Invalidate any controlling macro.  */\n+\t  ifs->mi_cmacro = 0;\n+\t}\n     }\n-\n-  pfile->skipping = ! _cpp_parse_expr (pfile);\n }\n \n /* #endif pops the if stack and resets pfile->skipping.  */\n@@ -1296,7 +1297,8 @@ static void\n do_endif (pfile)\n      cpp_reader *pfile;\n {\n-  struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n+  cpp_buffer *buffer = pfile->buffer;\n+  struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n     cpp_error (pfile, \"#endif without #if\");\n@@ -1309,8 +1311,8 @@ do_endif (pfile)\n \t  pfile->mi_cmacro = ifs->mi_cmacro;\n \t}\n \n-      CPP_BUFFER (pfile)->if_stack = ifs->next;\n-      pfile->skipping = ifs->was_skipping;\n+      buffer->if_stack = ifs->next;\n+      buffer->was_skipping = ifs->was_skipping;\n       obstack_free (pfile->buffer_ob, ifs);\n     }\n \n@@ -1329,39 +1331,20 @@ push_conditional (pfile, skip, type, cmacro)\n      const cpp_hashnode *cmacro;\n {\n   struct if_stack *ifs;\n+  cpp_buffer *buffer = pfile->buffer;\n \n   ifs = xobnew (pfile->buffer_ob, struct if_stack);\n   ifs->pos = pfile->directive_pos;\n-  ifs->next = CPP_BUFFER (pfile)->if_stack;\n-  ifs->was_skipping = pfile->skipping;\n+  ifs->next = buffer->if_stack;\n+  ifs->was_skipping = buffer->was_skipping;\n   ifs->type = type;\n   if (pfile->mi_state == MI_OUTSIDE && pfile->mi_cmacro == 0)\n     ifs->mi_cmacro = cmacro;\n   else\n     ifs->mi_cmacro = 0;\n \n-  if (!pfile->skipping)\n-    pfile->skipping = skip;\n-\n-  CPP_BUFFER (pfile)->if_stack = ifs;\n-}\n-\n-/* Called when we reach the end of a file.  Walk back up the\n-   conditional stack till we reach its level at entry to this file,\n-   issuing error messages.  Then force skipping off.  */\n-static void\n-unwind_if_stack (pfile, pbuf)\n-     cpp_reader *pfile;\n-     cpp_buffer *pbuf;\n-{\n-  struct if_stack *ifs;\n-\n-  /* No need to free stack - they'll all go away with the buffer.  */\n-  for (ifs = pbuf->if_stack; ifs; ifs = ifs->next)\n-    cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n-\t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n-\n-  pfile->skipping = 0;\n+  buffer->was_skipping = skip;\n+  buffer->if_stack = ifs;\n }\n \n /* Read the tokens of the answer into the macro pool.  Only commit the\n@@ -1723,6 +1706,7 @@ cpp_push_buffer (pfile, buffer, length)\n   new->rlimit = buffer + length;\n   new->prev = buf;\n   new->pfile = pfile;\n+  new->was_skipping = 0;\n   /* Preprocessed files don't do trigraph and escaped newline processing.  */\n   new->from_stage3 = CPP_OPTION (pfile, preprocessed);\n   /* No read ahead or extra char initially.  */\n@@ -1738,22 +1722,28 @@ cpp_buffer *\n cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n+  cpp_buffer *buffer = pfile->buffer;\n+  struct if_stack *ifs = buffer->if_stack;\n   int wfb;\n-  cpp_buffer *buf = CPP_BUFFER (pfile);\n \n-  unwind_if_stack (pfile, buf);\n-  wfb = (buf->inc != 0);\n+  /* Walk back up the conditional stack till we reach its level at\n+     entry to this file, issuing error messages.  */\n+  for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n+    cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n+\n+  wfb = (buffer->inc != 0);\n   if (wfb)\n-    _cpp_pop_file_buffer (pfile, buf);\n+    _cpp_pop_file_buffer (pfile, buffer);\n \n-  CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n-  obstack_free (pfile->buffer_ob, buf);\n+  pfile->buffer = buffer->prev;\n+  obstack_free (pfile->buffer_ob, buffer);\n   pfile->buffer_stack_depth--;\n \n-  if (CPP_BUFFER (pfile) && wfb && pfile->cb.leave_file)\n+  if (pfile->buffer && wfb && pfile->cb.leave_file)\n     (*pfile->cb.leave_file) (pfile);\n   \n-  return CPP_BUFFER (pfile);\n+  return pfile->buffer;\n }\n \n #define obstack_chunk_alloc xmalloc"}, {"sha": "8b6560dc5004d7635b5b5a574446203ebcd7883d", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=b528a07e0e5693ec33b7e77c600c0b32117f7742", "patch": "@@ -290,6 +290,9 @@ struct cpp_buffer\n      for preprocessed input, command line directives, and _Pragma\n      buffers.  */\n   unsigned char from_stage3;\n+\n+  /* Temporary storage for pfile->skipping whilst in a directive.  */\n+  unsigned char was_skipping;\n };\n \n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for"}, {"sha": "7ea7085019faccb9ede1689a54b8d176caca7b58", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528a07e0e5693ec33b7e77c600c0b32117f7742/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=b528a07e0e5693ec33b7e77c600c0b32117f7742", "patch": "@@ -86,7 +86,6 @@ static void replace_args PARAMS ((cpp_reader *, cpp_macro *, macro_arg *,\n \n static void save_lookahead_token PARAMS ((cpp_reader *, const cpp_token *));\n static void take_lookahead_token PARAMS ((cpp_reader *, cpp_token *));\n-static void release_lookahead PARAMS ((cpp_reader *));\n static cpp_lookahead *alloc_lookahead PARAMS ((cpp_reader *));\n static void free_lookahead PARAMS ((cpp_lookahead *));\n \n@@ -897,7 +896,7 @@ _cpp_get_token (pfile, token)\n      cpp_token *token;\n {\n  next_token:\n-  for (;;)\n+  do\n     {\n       cpp_context *context = pfile->context;\n \n@@ -913,22 +912,15 @@ _cpp_get_token (pfile, token)\n \t  if (context->macro)\n \t    {\n \t      _cpp_pop_context (pfile);\n-\t      continue;\n+\t      goto next_token;\n \t    }\n \t  /* End of argument pre-expansion.  */\n \t  token->type = CPP_EOF;\n \t  token->flags = 0;\n+\t  return;\n \t}\n-      break;\n     }\n-\n-  /* Only perform macro expansion (and therefore pasting) when not\n-     skipping, or when skipping but in a directive.  The only\n-     directive where this could be true is #elif.  A possible later\n-     optimisation: get do_elif to clear skipping so we don't need the\n-     directive test here.  */\n-  if (pfile->skipping && !pfile->state.in_directive)\n-    return;\n+  while (pfile->skipping);\n \n   for (;;)\n     {\n@@ -985,21 +977,7 @@ cpp_get_token (pfile, token)\n      cpp_reader *pfile;\n      cpp_token *token;\n {\n-  for (;;)\n-    {\n-      _cpp_get_token (pfile, token);\n-\n-      if (token->type == CPP_EOF)\n-\tbreak;\n-      else if (pfile->skipping)\n-\tcontinue;\n-\n-      /* Non-comment tokens invalidate any controlling macros.  */\n-      if (token->type != CPP_COMMENT)\n-\tpfile->mi_state = MI_FAILED;\n-\n-      break;\n-    }\n+  _cpp_get_token (pfile, token);\n \n   if (pfile->la_write)\n     save_lookahead_token (pfile, token);\n@@ -1057,12 +1035,12 @@ take_lookahead_token (pfile, token)\n   pfile->lexer_pos = twp->pos;\n \n   if (++la->cur == la->count)\n-    release_lookahead (pfile);\n+    _cpp_release_lookahead (pfile);\n }\n \n /* Moves the lookahead at the front of the read list to the free store.  */\n-static void\n-release_lookahead (pfile)\n+void\n+_cpp_release_lookahead (pfile)\n      cpp_reader *pfile;\n {\n   cpp_lookahead *la = pfile->la_read;\n@@ -1151,7 +1129,7 @@ cpp_stop_lookahead (pfile, drop)\n   pfile->la_read = la;\n \n   if (drop || la->count == 0)\n-    release_lookahead (pfile);\n+    _cpp_release_lookahead (pfile);\n   else\n     pfile->lexer_pos = la->pos;\n }"}]}