{"sha": "4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJhMTI2ZTQ2OGRiNWE0YTZmYTA3ZDFiOTQ4M2JjOGYwNTYyODMzYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-08-01T04:46:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-08-01T04:46:23Z"}, "message": "call.c (build_field_call): Do not look up the field by name.\n\n\t* call.c (build_field_call): Do not look up the field by name.\n\t(build_method_call): Simplify.\n\t(struct z_candidate): Add access_path and conversion_path.  Remove\n\tbasetype_path.\n\t(convert_class_to_reference): Adjust use of\n\tadd_function_candidate.\n\t(add_candidate): Add conversion_path argument.\n\t(add_function_candidate): Use it.\n\t(add_conv_dndidate): Likewise.\n\t(build_builtin_candidate): Likewise.\n\t(add_template_candidate_real): Add conversion_path argument.\n\t(add_template_conv_candidate): Likewise.\n\t(add_template_candidate): Likewise.\n\t(build_user_type_conversion_1): Use it.\n\t(build_new_function_call): Remove name lookup code.  Adjust use of\n\tadd_template_candidate and add_function_candidate.\n\t(build_new_op): Likewise.\n\t(convert_like_real): Use build_special_member_call.\n\t(build_over_call): Use cand->conversion_path.\n\t(build_special_member_call): New method.\n\t(build_new_method_call): Remove name lookup code.\n\t* cp-tree.def (OFFSET_REF): Update documentation.\n\t(TEMPLATE_ID_EXPR): Likewise.\n\t* cp-tree.h (BASELINK_ACCESS_BINFO): New macro.\n\t(BASELINK_OPTYPE): Likewise.\n\t(build_new_method_call): Adjust prototype.\n\t(build_special_member_call): New method.\n\t(build_baselink): New method.\n\t(build_offset_ref_call_from_tree): Likewise.\n\t(build_call_from_tree): Likewise.\n\t(finish_qualified_call_expr): Remove.\n\t(finish_call_expr): Adjust prototype.\n\t(build_x_function_call): Remove.\n\t* cvt.c (ocp_convert): Use build_special_member_call.\n\t* decl2.c (reparse_absdcl_as_expr): Use finish_call_expr.\n\t(build_expr_from_tree): Adjust handling for TEMPLATE_ID_EXPR and\n\tCALL_EXPR.\n\t(build_offset_ref_call_from_tree): New function.\n\t(build_call_from_tree): Likewise.\n\t* init.c (expand_cleanup): Use build_special_member_call.\n\t(expand_default_init): Likewise.\n\t(build_member_call): Use finish_call_expr.\n\t(build_new_1): Use build_special_member_call.\n\t(push_base_cleanups): Likewise.\n\t* method.c (do_build_assign_ref): Likewise.\n\t* parse.y (template_id): Do not pass a COMPONENT_REF to\n\tlookup_template_function.\n\t(primary): Use parse_finish_call_epxr, not finish_call_expr.\n\t(parse_finish_call_expr): New function.\n\t* pt.c (lookup_template_function): Add assertions.\n\t* search.c (lookup_base): Allow T to be a binfo.\n\t(build_baselink): New function.\n\t(lookup_member): Use it.\n\t* semantics.c (finish_call_expr): Do not do name lookup.\n\t(finish_object_call_expr): Remove #if 0'd code.\n\t(finish_qualified_call_expr): Remove.\n\t* typeck.c (build_x_function_call): Remove.\n\t(build_static_case): Use build_special_member_call.\n\t* typeck2.c (build_functional_cast): Likewise.\n\n\t* g++.dg/inherit/operator1.C: New test.\n\t* g++.dg/lookup/disamb1.C: Fix typo in comment.\n\t* g++.dg/other/error1.C: Change expected error message.\n\t* g++.dg/template/conv4.C: Likewise.\n\nFrom-SVN: r55920", "tree": {"sha": "5e0393052914787f60f9dbf9c085031bf97bb5c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e0393052914787f60f9dbf9c085031bf97bb5c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/comments", "author": null, "committer": null, "parents": [{"sha": "692f56114c8f0e4e859583ac7a6b5e1c7540003a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692f56114c8f0e4e859583ac7a6b5e1c7540003a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692f56114c8f0e4e859583ac7a6b5e1c7540003a"}], "stats": {"total": 1734, "additions": 1032, "deletions": 702}, "files": [{"sha": "bb5db823651c2caa959ad6f75a34cd6ee2594a70", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -1,3 +1,65 @@\n+2002-07-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_field_call): Do not look up the field by name.\n+\t(build_method_call): Simplify.\n+\t(struct z_candidate): Add access_path and conversion_path.  Remove\n+\tbasetype_path.\n+\t(convert_class_to_reference): Adjust use of\n+\tadd_function_candidate.\n+\t(add_candidate): Add conversion_path argument.\n+\t(add_function_candidate): Use it.\n+\t(add_conv_dndidate): Likewise.\n+\t(build_builtin_candidate): Likewise.\n+\t(add_template_candidate_real): Add conversion_path argument.\n+\t(add_template_conv_candidate): Likewise.\n+\t(add_template_candidate): Likewise.\n+\t(build_user_type_conversion_1): Use it.\n+\t(build_new_function_call): Remove name lookup code.  Adjust use of\n+\tadd_template_candidate and add_function_candidate.\n+\t(build_new_op): Likewise.\n+\t(convert_like_real): Use build_special_member_call.\n+\t(build_over_call): Use cand->conversion_path.\n+\t(build_special_member_call): New method.\n+\t(build_new_method_call): Remove name lookup code.\n+\t* cp-tree.def (OFFSET_REF): Update documentation.\n+\t(TEMPLATE_ID_EXPR): Likewise.\n+\t* cp-tree.h (BASELINK_ACCESS_BINFO): New macro.\n+\t(BASELINK_OPTYPE): Likewise.\n+\t(build_new_method_call): Adjust prototype.\n+\t(build_special_member_call): New method.\n+\t(build_baselink): New method.\n+\t(build_offset_ref_call_from_tree): Likewise.\n+\t(build_call_from_tree): Likewise.\n+\t(finish_qualified_call_expr): Remove.\n+\t(finish_call_expr): Adjust prototype.\n+\t(build_x_function_call): Remove.\n+\t* cvt.c (ocp_convert): Use build_special_member_call.\n+\t* decl2.c (reparse_absdcl_as_expr): Use finish_call_expr.\n+\t(build_expr_from_tree): Adjust handling for TEMPLATE_ID_EXPR and\n+\tCALL_EXPR.\n+\t(build_offset_ref_call_from_tree): New function.\n+\t(build_call_from_tree): Likewise.\n+\t* init.c (expand_cleanup): Use build_special_member_call.\n+\t(expand_default_init): Likewise.\n+\t(build_member_call): Use finish_call_expr.\n+\t(build_new_1): Use build_special_member_call.\n+\t(push_base_cleanups): Likewise.\n+\t* method.c (do_build_assign_ref): Likewise.\n+\t* parse.y (template_id): Do not pass a COMPONENT_REF to\n+\tlookup_template_function.\n+\t(primary): Use parse_finish_call_epxr, not finish_call_expr.\n+\t(parse_finish_call_expr): New function.\n+\t* pt.c (lookup_template_function): Add assertions.\n+\t* search.c (lookup_base): Allow T to be a binfo.\n+\t(build_baselink): New function.\n+\t(lookup_member): Use it.\n+\t* semantics.c (finish_call_expr): Do not do name lookup.\n+\t(finish_object_call_expr): Remove #if 0'd code.\n+\t(finish_qualified_call_expr): Remove.\n+\t* typeck.c (build_x_function_call): Remove.\n+\t(build_static_case): Use build_special_member_call.\n+\t* typeck2.c (build_functional_cast): Likewise.\n+\t\n 2002-07-30  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* lang-specs.h: Remove __GXX_ABI_VERSION, moved to gcc.c."}, {"sha": "403d8b53ee3265bd9ee69149714a0218cd45477e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 387, "deletions": 240, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -38,9 +38,7 @@ Boston, MA 02111-1307, USA.  */\n \n extern int inhibit_warnings;\n \n-static tree build_new_method_call PARAMS ((tree, tree, tree, tree, int));\n-\n-static tree build_field_call PARAMS ((tree, tree, tree, tree));\n+static tree build_field_call PARAMS ((tree, tree, tree));\n static struct z_candidate * tourney PARAMS ((struct z_candidate *));\n static int equal_functions PARAMS ((tree, tree));\n static int joust PARAMS ((struct z_candidate *, struct z_candidate *, int));\n@@ -64,13 +62,13 @@ static struct z_candidate * splice_viable PARAMS ((struct z_candidate *));\n static int any_viable PARAMS ((struct z_candidate *));\n static int any_strictly_viable PARAMS ((struct z_candidate *));\n static struct z_candidate * add_template_candidate\n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, int,\n-\t       unification_kind_t));\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, \n+\t\t tree, tree, int, unification_kind_t));\n static struct z_candidate * add_template_candidate_real\n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, int,\n-\t       tree, unification_kind_t));\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, \n+\t\t tree, tree, int, tree, unification_kind_t));\n static struct z_candidate * add_template_conv_candidate \n-        PARAMS ((struct z_candidate *, tree, tree, tree, tree));\n+        PARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, tree));\n static struct z_candidate * add_builtin_candidates\n \tPARAMS ((struct z_candidate *, enum tree_code, enum tree_code,\n \t       tree, tree *, int));\n@@ -82,9 +80,9 @@ static struct z_candidate * build_builtin_candidate\n \tPARAMS ((struct z_candidate *, tree, tree, tree, tree *, tree *,\n \t       int));\n static struct z_candidate * add_conv_candidate \n-\tPARAMS ((struct z_candidate *, tree, tree, tree));\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree));\n static struct z_candidate * add_function_candidate \n-\tPARAMS ((struct z_candidate *, tree, tree, tree, int));\n+\t(struct z_candidate *, tree, tree, tree, tree, tree, int);\n static tree implicit_conversion PARAMS ((tree, tree, tree, int));\n static tree standard_conversion PARAMS ((tree, tree, tree));\n static tree reference_binding PARAMS ((tree, tree, tree, int));\n@@ -93,8 +91,8 @@ static tree build_conv PARAMS ((enum tree_code, tree, tree));\n static int is_subseq PARAMS ((tree, tree));\n static tree maybe_handle_ref_bind PARAMS ((tree*));\n static void maybe_handle_implicit_object PARAMS ((tree*));\n-static struct z_candidate * add_candidate PARAMS ((struct z_candidate *,\n-\t\t\t\t\t\t   tree, tree, int));\n+static struct z_candidate *add_candidate \n+        (struct z_candidate *, tree, tree, tree, tree, int);\n static tree source_type PARAMS ((tree));\n static void add_warning PARAMS ((struct z_candidate *, struct z_candidate *));\n static int reference_related_p PARAMS ((tree, tree));\n@@ -129,30 +127,19 @@ build_vfield_ref (datum, type)\n    operator ()(), or is a pointer-to-function or pointer-to-method.  */\n \n static tree\n-build_field_call (basetype_path, instance_ptr, name, parms)\n-     tree basetype_path, instance_ptr, name, parms;\n+build_field_call (tree instance_ptr, tree decl, tree parms)\n {\n-  tree field, instance;\n-\n-  if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n-    return NULL_TREE;\n+  tree instance;\n \n-  /* Speed up the common case.  */\n-  if (instance_ptr == current_class_ptr\n-      && IDENTIFIER_CLASS_VALUE (name) == NULL_TREE)\n-    return NULL_TREE;\n-\n-  field = lookup_field (basetype_path, name, 1, 0);\n+  if (decl == error_mark_node || decl == NULL_TREE)\n+    return decl;\n \n-  if (field == error_mark_node || field == NULL_TREE)\n-    return field;\n-\n-  if (TREE_CODE (field) == FIELD_DECL || TREE_CODE (field) == VAR_DECL)\n+  if (TREE_CODE (decl) == FIELD_DECL || TREE_CODE (decl) == VAR_DECL)\n     {\n       /* If it's a field, try overloading operator (),\n \t or calling if the field is a pointer-to-function.  */\n       instance = build_indirect_ref (instance_ptr, NULL);\n-      instance = build_component_ref_1 (instance, field, 0);\n+      instance = build_component_ref_1 (instance, decl, 0);\n \n       if (instance == error_mark_node)\n \treturn error_mark_node;\n@@ -476,7 +463,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n      tree instance, name, parms, basetype_path;\n      int flags;\n {\n-  tree basetype, instance_ptr;\n+  tree fn;\n+  tree object_type;\n+  tree template_args = NULL_TREE;\n+  bool has_template_args = false;\n \n #ifdef GATHER_STATISTICS\n   n_build_method_call++;\n@@ -485,7 +475,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   if (instance == error_mark_node\n       || name == error_mark_node\n       || parms == error_mark_node\n-      || (instance != NULL_TREE && TREE_TYPE (instance) == error_mark_node))\n+      || (instance && TREE_TYPE (instance) == error_mark_node))\n     return error_mark_node;\n \n   if (processing_template_decl)\n@@ -508,39 +498,98 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, NULL_TREE);\n     }\n \n+  if (TREE_CODE (instance) == OFFSET_REF)\n+    instance = resolve_offset_ref (instance);\n+  if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n+    instance = convert_from_reference (instance);\n+  object_type = TREE_TYPE (instance);\n+\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n+      tree instance_ptr;\n+\n       if (parms)\n \terror (\"destructors take no parameters\");\n-      basetype = TREE_TYPE (instance);\n-      if (TREE_CODE (basetype) == REFERENCE_TYPE)\n-\tbasetype = TREE_TYPE (basetype);\n \n-      if (! check_dtor_name (basetype, name))\n+      if (! check_dtor_name (object_type, name))\n \terror\n \t  (\"destructor name `~%T' does not match type `%T' of expression\",\n-\t   TREE_OPERAND (name, 0), basetype);\n+\t   TREE_OPERAND (name, 0), object_type);\n \n-      if (! TYPE_HAS_DESTRUCTOR (complete_type (basetype)))\n+      if (! TYPE_HAS_DESTRUCTOR (complete_type (object_type)))\n \treturn cp_convert (void_type_node, instance);\n       instance = default_conversion (instance);\n       instance_ptr = build_unary_op (ADDR_EXPR, instance, 0);\n-      return build_delete (build_pointer_type (basetype),\n+      return build_delete (build_pointer_type (object_type),\n \t\t\t   instance_ptr, sfk_complete_destructor,\n \t\t\t   LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n     }\n \n-  return build_new_method_call (instance, name, parms, basetype_path, flags);\n+  if (!CLASS_TYPE_P (object_type))\n+    {\n+      if ((flags & LOOKUP_COMPLAIN) \n+\t  && TREE_TYPE (instance) != error_mark_node)\n+\terror (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n+\t       name, instance, object_type);\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+    {\n+      template_args = TREE_OPERAND (name, 1);\n+      has_template_args = true;\n+      name = TREE_OPERAND (name, 0);\n+    }\n+  if (TREE_CODE (name) == OVERLOAD)\n+    name = DECL_NAME (get_first_fn (name));\n+  else if (DECL_P (name))\n+    name = DECL_NAME (name);\n+  if (has_template_args)\n+    fn = lookup_fnfields (object_type, name, /*protect=*/0);\n+  else\n+    fn = lookup_member (object_type, name, /*protect=*/0, \n+\t\t\t/*want_type=*/0);\n+  \n+  /* If the name could not be found, issue an error.  */\n+  if (!fn)\n+    {\n+      unqualified_name_lookup_error (name);\n+      return error_mark_node;\n+    }\n+\n+  if (BASELINK_P (fn) && has_template_args)\n+    BASELINK_FUNCTIONS (fn)\n+      = build_nt (TEMPLATE_ID_EXPR,\n+\t\t  BASELINK_FUNCTIONS (fn),\n+\t\t  template_args);\n+  if (BASELINK_P (fn) && basetype_path)\n+    BASELINK_ACCESS_BINFO (fn) = basetype_path;\n+\n+  return build_new_method_call (instance, fn, parms, \n+\t\t\t\t/*conversion_path=*/NULL_TREE, flags);\n }\n \n /* New overloading code.  */\n \n struct z_candidate GTY(()) {\n+  /* The FUNCTION_DECL that will be called if this candidate is\n+     selected by overload resolution.  */\n   tree fn;\n   tree convs;\n   tree second_conv;\n   int viable;\n-  tree basetype_path;\n+  /* If FN is a member function, the binfo indicating the path used to\n+     qualify the name of FN at the call site.  This path is used to\n+     determine whether or not FN is accessible if it is selected by\n+     overload resolution.  The DECL_CONTEXT of FN will always be a\n+     (possibly improper) base of this binfo.  */\n+  tree access_path;\n+  /* If FN is a non-static member function, the binfo indicating the\n+     subobject to which the `this' pointer should be converted if FN\n+     is selected by overload resolution.  The type pointed to the by\n+     the `this' pointer must correspond to the most derived class\n+     indicated by the CONVERSION_PATH.  */\n+  tree conversion_path;\n   tree template;\n   tree warnings;\n   struct z_candidate *next;\n@@ -981,6 +1030,8 @@ convert_class_to_reference (t, s, expr)\n \t\t\t\t\t  NULL_TREE,\n \t\t\t\t\t  arglist,\n \t\t\t\t\t  build_reference_type (t),\n+\t\t\t\t\t  TYPE_BINFO (s),\n+\t\t\t\t\t  TREE_PURPOSE (conversions),\n \t\t\t\t\t  LOOKUP_NORMAL,\n \t\t\t\t\t  DEDUCE_CONV);\n \t      \n@@ -1001,10 +1052,9 @@ convert_class_to_reference (t, s, expr)\n \t\t   && reference_compatible_p (t, TREE_TYPE (t2)))\n \t    candidates \n \t      = add_function_candidate (candidates, f, s, arglist, \n+\t\t\t\t\tTYPE_BINFO (s), \t\n+\t\t\t\t\tTREE_PURPOSE (conversions),\n \t\t\t\t\tLOOKUP_NORMAL);\n-\n-\t  if (candidates != old_candidates)\n-\t    candidates->basetype_path = TYPE_BINFO (s);\n \t}\n     }\n \n@@ -1282,16 +1332,17 @@ implicit_conversion (to, from, expr, flags)\n    functions.  */\n \n static struct z_candidate *\n-add_candidate (candidates, fn, convs, viable)\n-     struct z_candidate *candidates;\n-     tree fn, convs;\n-     int viable;\n+add_candidate (struct z_candidate *candidates, \n+\t       tree fn, tree convs, tree access_path, tree\n+\t       conversion_path, int viable)\n {\n   struct z_candidate *cand\n     = (struct z_candidate *) ggc_alloc_cleared (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n   cand->convs = convs;\n+  cand->access_path = access_path;\n+  cand->conversion_path = conversion_path;\n   cand->viable = viable;\n   cand->next = candidates;\n \n@@ -1306,10 +1357,10 @@ add_candidate (candidates, fn, convs, viable)\n    comes from for purposes of overload resolution.  */\n \n static struct z_candidate *\n-add_function_candidate (candidates, fn, ctype, arglist, flags)\n-     struct z_candidate *candidates;\n-     tree fn, ctype, arglist;\n-     int flags;\n+add_function_candidate (struct z_candidate *candidates, \n+\t\t\ttree fn, tree ctype, tree arglist, \n+\t\t\ttree access_path, tree conversion_path,\n+\t\t\tint flags)\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   int i, len;\n@@ -1421,7 +1472,8 @@ add_function_candidate (candidates, fn, ctype, arglist, flags)\n     }\n \n  out:\n-  return add_candidate (candidates, fn, convs, viable);\n+  return add_candidate (candidates, fn, convs, access_path,\n+\t\t\tconversion_path, viable);\n }\n \n /* Create an overload candidate for the conversion function FN which will\n@@ -1436,9 +1488,12 @@ add_function_candidate (candidates, fn, ctype, arglist, flags)\n    instead of the function.  */\n \n static struct z_candidate *\n-add_conv_candidate (candidates, fn, obj, arglist)\n+add_conv_candidate (candidates, fn, obj, arglist, access_path,\n+\t\t    conversion_path)\n      struct z_candidate *candidates;\n      tree fn, obj, arglist;\n+     tree access_path;\n+     tree conversion_path;\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   int i, len, viable, flags;\n@@ -1498,7 +1553,8 @@ add_conv_candidate (candidates, fn, obj, arglist)\n   if (!sufficient_parms_p (parmnode))\n     viable = 0;\n \n-  return add_candidate (candidates, totype, convs, viable);\n+  return add_candidate (candidates, totype, convs, access_path,\n+\t\t\tconversion_path, viable);\n }\n \n static struct z_candidate *\n@@ -1547,7 +1603,10 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n \tviable = 0;\n     }      \n \n-  return add_candidate (candidates, fnname, convs, viable);\n+  return add_candidate (candidates, fnname, convs, \n+\t\t\t/*access_path=*/NULL_TREE,\n+\t\t\t/*conversion_path=*/NULL_TREE,\n+\t\t\tviable);\n }\n \n static int\n@@ -2185,10 +2244,12 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \n static struct z_candidate*\n add_template_candidate_real (candidates, tmpl, ctype, explicit_targs,\n-\t\t\t     arglist, return_type, flags,\n-\t\t\t     obj, strict)\n+\t\t\t     arglist, return_type, access_path,\n+\t\t\t     conversion_path, flags, obj, strict)\n      struct z_candidate *candidates;\n      tree tmpl, ctype, explicit_targs, arglist, return_type;\n+     tree access_path;\n+     tree conversion_path;\n      int flags;\n      tree obj;\n      unification_kind_t strict;\n@@ -2253,10 +2314,12 @@ add_template_candidate_real (candidates, tmpl, ctype, explicit_targs,\n \n   if (obj != NULL_TREE)\n     /* Aha, this is a conversion function.  */\n-    cand = add_conv_candidate (candidates, fn, obj, arglist);\n+    cand = add_conv_candidate (candidates, fn, obj, access_path,\n+\t\t\t       conversion_path, arglist);\n   else\n     cand = add_function_candidate (candidates, fn, ctype,\n-\t\t\t\t   arglist, flags);\n+\t\t\t\t   arglist, access_path, \n+\t\t\t\t   conversion_path, flags);\n   if (DECL_TI_TEMPLATE (fn) != tmpl)\n     /* This situation can occur if a member template of a template\n        class is specialized.  Then, instantiate_template might return\n@@ -2285,27 +2348,35 @@ add_template_candidate_real (candidates, tmpl, ctype, explicit_targs,\n \n static struct z_candidate *\n add_template_candidate (candidates, tmpl, ctype, explicit_targs, \n-\t\t\targlist, return_type, flags, strict)\n+\t\t\targlist, return_type, access_path, \n+\t\t\tconversion_path, flags, strict)\n      struct z_candidate *candidates;\n      tree tmpl, ctype, explicit_targs, arglist, return_type;\n+     tree access_path;\n+     tree conversion_path;\n      int flags;\n      unification_kind_t strict;\n {\n   return \n     add_template_candidate_real (candidates, tmpl, ctype,\n-\t\t\t\t explicit_targs, arglist, return_type, flags,\n-\t\t\t\t NULL_TREE, strict);\n+\t\t\t\t explicit_targs, arglist, return_type, \n+\t\t\t\t access_path, conversion_path,\n+\t\t\t\t flags, NULL_TREE, strict);\n }\n \n \n static struct z_candidate *\n-add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type)\n+add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type,\n+\t\t\t     access_path, conversion_path)\n      struct z_candidate *candidates;\n      tree tmpl, obj, arglist, return_type;\n+     tree access_path;\n+     tree conversion_path;\n {\n   return \n     add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,\n-\t\t\t\t arglist, return_type, 0, obj, DEDUCE_CONV);\n+\t\t\t\t arglist, return_type, access_path,\n+\t\t\t\t conversion_path, 0, obj, DEDUCE_CONV);\n }\n \n \n@@ -2446,26 +2517,29 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t  templates = tree_cons (NULL_TREE, ctor, templates);\n \t  candidates = \n \t    add_template_candidate (candidates, ctor, totype,\n-\t\t\t\t    NULL_TREE, args, NULL_TREE, flags,\n+\t\t\t\t    NULL_TREE, args, NULL_TREE, \n+\t\t\t\t    TYPE_BINFO (totype),\n+\t\t\t\t    TYPE_BINFO (totype),\n+\t\t\t\t    flags,\n \t\t\t\t    DEDUCE_CALL);\n-\t} \n+\t}\n       else \n \tcandidates = add_function_candidate (candidates, ctor, totype,\n-\t\t\t\t\t     args, flags); \n+\t\t\t\t\t     args, TYPE_BINFO (totype), \n+\t\t\t\t\t     TYPE_BINFO (totype),\n+\t\t\t\t\t     flags); \n \n       if (candidates) \n-\t{\n-\t  candidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n-\t  candidates->basetype_path = TYPE_BINFO (totype);\n-\t} \n+\tcandidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n     }\n \n   if (convs)\n     args = build_tree_list (NULL_TREE, build_this (expr));\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n-      tree fns = TREE_VALUE (convs);\n+      tree fns;\n+      tree conversion_path = TREE_PURPOSE (convs);\n       int convflags = LOOKUP_NO_CONVERSION;\n \n       /* If we are called to convert to a reference type, we are trying to\n@@ -2475,7 +2549,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n       \n-      for (; fns; fns = OVL_NEXT (fns))\n+      for (fns = TREE_VALUE (convs); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  struct z_candidate *old_candidates = candidates;\n@@ -2492,12 +2566,17 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t      templates = tree_cons (NULL_TREE, fn, templates);\n \t      candidates = \n \t\tadd_template_candidate (candidates, fn, fromtype, NULL_TREE,\n-\t\t\t\t\targs, totype, flags,\n+\t\t\t\t\targs, totype, TYPE_BINFO (fromtype), \n+\t\t\t\t\tconversion_path,\n+\t\t\t\t\tflags,\n \t\t\t\t\tDEDUCE_CONV);\n \t    } \n \t  else \n \t    candidates = add_function_candidate (candidates, fn, fromtype,\n-\t\t\t\t\t\t args, flags); \n+\t\t\t\t\t\t args,\n+\t\t\t\t\t\t TYPE_BINFO (fromtype),\n+\t\t\t\t\t\t conversion_path,\n+\t\t\t\t\t\t flags); \n \n \t  if (candidates != old_candidates)\n \t    {\n@@ -2506,7 +2585,6 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t\t 0, convflags);\n \n \t      candidates->second_conv = ics;\n-\t      candidates->basetype_path = TYPE_BINFO (fromtype);\n \t      \n \t      if (ics == NULL_TREE)\n \t\tcandidates->viable = 0;\n@@ -2517,19 +2595,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     }\n \n   if (! any_viable (candidates))\n-    {\n-#if 0\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  if (candidates && ! candidates->next)\n-\t    /* say why this one won't work or try to be loose */;\n-\t  else\n-\t    error (\"no viable candidates\");\n-\t}\n-#endif\n-\n-      return 0;\n-    }\n+    return 0;\n \n   candidates = splice_viable (candidates);\n   cand = tourney (candidates);\n@@ -2609,6 +2675,9 @@ resolve_args (args)\n     }\n   return args;\n }\n+\n+/* Return an expression for a call to FN (a namespace-scope function)\n+   with the ARGS.  */\n       \n tree\n build_new_function_call (fn, args)\n@@ -2618,14 +2687,24 @@ build_new_function_call (fn, args)\n   tree explicit_targs = NULL_TREE;\n   int template_only = 0;\n \n+  /* Check FN and ARGS.  */\n+  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL \n+\t\t      || TREE_CODE (fn) == TEMPLATE_DECL\n+\t\t      || TREE_CODE (fn) == OVERLOAD\n+\t\t      || TREE_CODE (fn) == TEMPLATE_ID_EXPR,\n+\t\t      20020712);\n+  my_friendly_assert (!args || TREE_CODE (args) == TREE_LIST,\n+\t\t      20020712);\n+\n   if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n     {\n       explicit_targs = TREE_OPERAND (fn, 1);\n       fn = TREE_OPERAND (fn, 0);\n       template_only = 1;\n     }\n \n-  if (really_overloaded_fn (fn))\n+  if (really_overloaded_fn (fn) \n+      || TREE_CODE (fn) == TEMPLATE_DECL)\n     {\n       tree t1;\n       tree templates = NULL_TREE;\n@@ -2635,28 +2714,31 @@ build_new_function_call (fn, args)\n       if (args == error_mark_node)\n \treturn error_mark_node;\n \n-      for (t1 = fn; t1; t1 = OVL_CHAIN (t1))\n+      for (t1 = fn; t1; t1 = OVL_NEXT (t1))\n \t{\n-\t  tree t = OVL_FUNCTION (t1);\n+\t  tree t = OVL_CURRENT (t1);\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n \t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n-\t\t(candidates, t, NULL_TREE, explicit_targs, args, NULL_TREE,\n+\t\t(candidates, t, NULL_TREE, explicit_targs, args, \n+\t\t NULL_TREE,\n+\t\t /*access_path=*/NULL_TREE, /*conversion_path=*/NULL_TREE,\n \t\t LOOKUP_NORMAL, DEDUCE_CALL);  \n \t    }\n \t  else if (! template_only)\n \t    candidates = add_function_candidate\n-\t      (candidates, t, NULL_TREE, args, LOOKUP_NORMAL);\n+\t      (candidates, t, NULL_TREE, args, /*access_path=*/NULL_TREE, \n+\t       /*conversion_path=*/NULL_TREE, LOOKUP_NORMAL);\n \t}\n \n       if (! any_viable (candidates))\n \t{\n \t  if (candidates && ! candidates->next)\n \t    return build_function_call (candidates->fn, args);\n \t  error (\"no matching function for call to `%D(%A)'\",\n-\t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n+\t\t    DECL_NAME (OVL_CURRENT (fn)), args);\n \t  if (candidates)\n \t    print_z_candidates (candidates);\n \t  return error_mark_node;\n@@ -2719,14 +2801,14 @@ build_object_call (obj, args)\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, base, NULL_TREE,\n \t\t\t\t\t  mem_args, NULL_TREE, \n+\t\t\t\t\t  TYPE_BINFO (type),\n+\t\t\t\t\t  TYPE_BINFO (type),\n \t\t\t\t\t  LOOKUP_NORMAL, DEDUCE_CALL);\n \t    }\n \t  else\n \t    candidates = add_function_candidate\n-\t      (candidates, fn, base, mem_args, LOOKUP_NORMAL);\n-\n-\t  if (candidates)\n-\t    candidates->basetype_path = TYPE_BINFO (type);\n+\t      (candidates, fn, base, mem_args, TYPE_BINFO (type),\n+\t       TYPE_BINFO (type), LOOKUP_NORMAL);\n \t}\n     }\n \n@@ -2749,14 +2831,15 @@ build_object_call (obj, args)\n \t    tree fn = OVL_CURRENT (fns);\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL) \n \t      {\n-\t\tcandidates = add_template_conv_candidate (candidates,\n-\t\t\t\t\t\t\t  fn,\n-\t\t\t\t\t\t\t  obj,\n-\t\t\t\t\t\t\t  args,\n-\t\t\t\t\t\t\t  totype);\n+\t\tcandidates = (add_template_conv_candidate \n+\t\t\t      (candidates, fn, obj, args, totype,\n+\t\t\t       /*access_path=*/NULL_TREE,\n+\t\t\t       /*conversion_path=*/NULL_TREE));\n \t      }\n \t    else\n-\t      candidates = add_conv_candidate (candidates, fn, obj, args);\n+\t      candidates = add_conv_candidate (candidates, fn, obj, args,\n+\t\t\t\t\t       /*conversion_path=*/NULL_TREE,\n+\t\t\t\t\t       /*access_path=*/NULL_TREE);\n \t  }\n     }\n \n@@ -2890,9 +2973,7 @@ conditional_conversion (e1, e2)\n }\n \n /* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three\n-   arguments to the conditional expression.  By the time this function\n-   is called, any suitable candidate functions are included in\n-   CANDIDATES.  */\n+   arguments to the conditional expression.  */\n \n tree\n build_conditional_expr (arg1, arg2, arg3)\n@@ -3331,11 +3412,16 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  candidates \n \t    = add_template_candidate (candidates, fn, NULL_TREE, NULL_TREE,\n \t\t\t\t      arglist, TREE_TYPE (fnname),\n+\t\t\t\t      /*access_path=*/NULL_TREE,\n+\t\t\t\t      /*conversion_path=*/NULL_TREE,\n \t\t\t\t      flags, DEDUCE_CALL); \n \t}\n       else\n \tcandidates = add_function_candidate (candidates, fn, NULL_TREE,\n-\t\t\t\t\t     arglist, flags);\n+\t\t\t\t\t     arglist,\n+\t\t\t\t\t     /*access_path=*/NULL_TREE,\n+\t\t\t\t\t     /*conversion_path=*/NULL_TREE,\n+\t\t\t\t\t     flags);\n     }\n \n   if (IS_AGGR_TYPE (TREE_TYPE (arg1)))\n@@ -3349,12 +3435,14 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \n   if (fns)\n     {\n-      tree basetype = BINFO_TYPE (TREE_PURPOSE (fns));\n+      tree conversion_path = BASELINK_BINFO (fns);\n+\n       mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n-      for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n+      for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  tree this_arglist;\n+\t  tree access_path = TYPE_BINFO (TREE_TYPE (arg1));\n \n \t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n \t    this_arglist = mem_arglist;\n@@ -3366,16 +3454,17 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t      /* A member template. */\n \t      templates = tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n-\t\t= add_template_candidate (candidates, fn, basetype, NULL_TREE,\n+\t\t= add_template_candidate (candidates, fn, \n+\t\t\t\t\t  BINFO_TYPE (conversion_path),\n+\t\t\t\t\t  NULL_TREE,\n \t\t\t\t\t  this_arglist,  TREE_TYPE (fnname),\n+\t\t\t\t\t  access_path, conversion_path,\n \t\t\t\t\t  flags, DEDUCE_CALL); \n \t    }\n \t  else\n \t    candidates = add_function_candidate\n-\t      (candidates, fn, basetype, this_arglist, flags);\n-\n-\t  if (candidates)\n-\t    candidates->basetype_path = TYPE_BINFO (TREE_TYPE (arg1));\n+\t      (candidates, fn, BINFO_TYPE (conversion_path), this_arglist, \n+\t       access_path, conversion_path, flags);\n \t}\n     }\n \n@@ -3863,7 +3952,7 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t    && (inner >= 0 || !lvalue_p (expr)))\n \t  {\n \t    savew = warningcount, savee = errorcount;\n-\t    expr = build_new_method_call\n+\t    expr = build_special_member_call\n \t      (NULL_TREE, complete_ctor_identifier,\n \t       build_tree_list (NULL_TREE, expr), TYPE_BINFO (totype),\n \t       /* Core issue 84, now a DR, says that we don't allow UDCs\n@@ -3945,10 +4034,10 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t type is the same class as, or a derived class of, the class of the\n \t destination [is treated as direct-initialization].  [dcl.init] */\n       savew = warningcount, savee = errorcount;\n-      expr = build_new_method_call (NULL_TREE, complete_ctor_identifier,\n-\t\t\t\t    build_tree_list (NULL_TREE, expr),\n-\t\t\t\t    TYPE_BINFO (totype),\n-\t\t\t\t    LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING);\n+      expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n+\t\t\t\t\tTYPE_BINFO (totype),\n+\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_ONLYCONVERTING);\n       if (fn)\n \t{\n \t  if (warningcount > savew)\n@@ -4207,7 +4296,7 @@ build_over_call (cand, args, flags)\n       joust (cand, WRAPPER_ZC (TREE_VALUE (val)), 1);\n \n   if (DECL_FUNCTION_MEMBER_P (fn))\n-    enforce_access (cand->basetype_path, fn);\n+    enforce_access (cand->access_path, fn);\n \n   if (args && TREE_CODE (args) != TREE_LIST)\n     args = build_tree_list (NULL_TREE, args);\n@@ -4236,7 +4325,8 @@ build_over_call (cand, args, flags)\n     {\n       tree parmtype = TREE_VALUE (parm);\n       tree argtype = TREE_TYPE (TREE_VALUE (arg));\n-      tree t;\n+      tree converted_arg;\n+\n       if (ICS_BAD_FLAG (TREE_VEC_ELT (convs, i)))\n \tpedwarn (\"passing `%T' as `this' argument of `%#D' discards qualifiers\",\n \t\t    TREE_TYPE (argtype), fn);\n@@ -4248,10 +4338,13 @@ build_over_call (cand, args, flags)\n          So we can assume that anything passed as 'this' is non-null, and\n \t optimize accordingly.  */\n       my_friendly_assert (TREE_CODE (parmtype) == POINTER_TYPE, 19990811);\n-      t = lookup_base (TREE_TYPE (TREE_TYPE (TREE_VALUE (arg))),\n-\t\t       TREE_TYPE (parmtype), ba_ignore, NULL);\n-      t = build_base_path (PLUS_EXPR, TREE_VALUE (arg), t, 1);\n-      converted_args = tree_cons (NULL_TREE, t, converted_args);\n+      /* Convert to the base in which the function was declared.  */\n+      my_friendly_assert (cand->conversion_path != NULL_TREE, 20020730);\n+      converted_arg = build_base_path (PLUS_EXPR,\n+\t\t\t\t       TREE_VALUE (arg),\n+\t\t\t\t       cand->conversion_path,\n+\t\t\t\t       1);\n+      converted_args = tree_cons (NULL_TREE, converted_arg, converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n       ++i;\n@@ -4534,143 +4627,191 @@ in_charge_arg_for_name (name)\n   return NULL_TREE;\n }\n \n-static tree\n-build_new_method_call (instance, name, args, basetype_path, flags)\n-     tree instance, name, args, basetype_path;\n-     int flags;\n+/* Build a call to a constructor, destructor, or an assignment\n+   operator for INSTANCE, an expression with class type.  NAME\n+   indicates the special member function to call; ARGS are the\n+   arguments.  BINFO indicates the base of INSTANCE that is to be\n+   passed as the `this' parameter to the member function called.\n+\n+   FLAGS are the LOOKUP_* flags to use when processing the call.\n+\n+   If NAME indicates a complete object constructor, INSTANCE may be\n+   NULL_TREE.  In this case, the caller will call build_cplus_new to\n+   store the newly constructed object into a VAR_DECL.  */\n+\n+tree\n+build_special_member_call (tree instance, tree name, tree args, \n+\t\t\t   tree binfo, int flags)\n+{\n+  tree fns;\n+  /* The type of the subobject to be constructed or destroyed.  */\n+  tree class_type;\n+\n+  my_friendly_assert (name == complete_ctor_identifier\n+\t\t      || name == base_ctor_identifier\n+\t\t      || name == complete_dtor_identifier\n+\t\t      || name == base_dtor_identifier\n+\t\t      || name == deleting_dtor_identifier\n+\t\t      || name == ansi_assopname (NOP_EXPR),\n+\t\t      20020712);\n+  my_friendly_assert (binfo != NULL_TREE, 20020712);\n+\n+  class_type = BINFO_TYPE (binfo);\n+\n+  /* Handle the special case where INSTANCE is NULL_TREE.  */\n+  if (name == complete_ctor_identifier && !instance)\n+    {\n+      instance = build_int_2 (0, 0);\n+      TREE_TYPE (instance) = build_pointer_type (class_type);\n+      instance = build1 (INDIRECT_REF, class_type, instance);\n+    }\n+  else if (name == complete_dtor_identifier \n+\t   || name == base_dtor_identifier\n+\t   || name == deleting_dtor_identifier)\n+    my_friendly_assert (args == NULL_TREE, 20020712);\n+\n+  my_friendly_assert (instance != NULL_TREE, 20020712);\n+\n+  /* Resolve the name.  */\n+  if (!complete_type_or_else (BINFO_TYPE (binfo), NULL_TREE))\n+    return error_mark_node;\n+\n+  fns = lookup_fnfields (binfo, name, 1);\n+    \n+  /* When making a call to a constructor or destructor for a subobject\n+     that uses virtual base classes, pass down a pointer to a VTT for\n+     the subobject.  */\n+  if ((name == base_ctor_identifier\n+       || name == base_dtor_identifier)\n+      && TYPE_USES_VIRTUAL_BASECLASSES (class_type))\n+    {\n+      tree vtt;\n+      tree sub_vtt;\n+\n+      /* If the current function is a complete object constructor\n+\t or destructor, then we fetch the VTT directly.\n+\t Otherwise, we look it up using the VTT we were given.  */\n+      vtt = IDENTIFIER_GLOBAL_VALUE (get_vtt_name (current_class_type));\n+      vtt = decay_conversion (vtt);\n+      vtt = build (COND_EXPR, TREE_TYPE (vtt),\n+\t\t   build (EQ_EXPR, boolean_type_node,\n+\t\t\t  current_in_charge_parm, integer_zero_node),\n+\t\t   current_vtt_parm,\n+\t\t   vtt);\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\tbinfo = binfo_for_vbase (class_type, current_class_type);\n+      my_friendly_assert (BINFO_SUBVTT_INDEX (binfo), 20010110);\n+      sub_vtt = build (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n+\t\t       BINFO_SUBVTT_INDEX (binfo));\n+\n+      args = tree_cons (NULL_TREE, sub_vtt, args);\n+    }\n+\n+  return build_new_method_call (instance, fns, args, binfo, flags);\n+}\n+\n+/* Build a call to \"INSTANCE.FN (ARGS)\".  */\n+\n+tree\n+build_new_method_call (tree instance, tree fns, tree args, \n+\t\t       tree conversion_path, int flags)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree explicit_targs = NULL_TREE;\n-  tree basetype, mem_args = NULL_TREE, fns, instance_ptr;\n-  tree pretty_name;\n+  tree basetype = NULL_TREE;\n+  tree access_binfo;\n+  tree optype;\n+  tree mem_args = NULL_TREE, instance_ptr;\n+  tree name, pretty_name;\n   tree user_args;\n   tree templates = NULL_TREE;\n   tree call;\n   int template_only = 0;\n \n-  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-    {\n-      explicit_targs = TREE_OPERAND (name, 1);\n-      name = TREE_OPERAND (name, 0);\n-      if (DECL_P (name))\n-\tname = DECL_NAME (name);\n-      else\n-\t{\n-\t  if (TREE_CODE (name) == COMPONENT_REF)\n-\t    name = TREE_OPERAND (name, 1);\n-\t  if (TREE_CODE (name) == OVERLOAD)\n-\t    name = DECL_NAME (OVL_CURRENT (name));\n-\t}\n+  my_friendly_assert (instance != NULL_TREE, 20020729);\n \n-      template_only = 1;\n-    }\n+  if (instance == error_mark_node || fns == error_mark_node \n+      || args == error_mark_node)\n+    return error_mark_node;\n \n+  /* Process the argument list.  */\n   user_args = args;\n   args = resolve_args (args);\n-\n   if (args == error_mark_node)\n     return error_mark_node;\n \n-  if (instance == NULL_TREE)\n-    basetype = BINFO_TYPE (basetype_path);\n-  else\n+  if (TREE_CODE (instance) == OFFSET_REF)\n+    instance = resolve_offset_ref (instance);\n+  if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n+    instance = convert_from_reference (instance);\n+  basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));\n+  instance_ptr = build_this (instance);\n+\n+  if (!BASELINK_P (fns))\n     {\n-      if (TREE_CODE (instance) == OFFSET_REF)\n-\tinstance = resolve_offset_ref (instance);\n-      if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n-\tinstance = convert_from_reference (instance);\n-      basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));\n+      call = build_field_call (instance_ptr, fns, args);\n+      if (call)\n+\treturn call;\n+      error (\"call to non-function `%D'\", fns);\n+      return error_mark_node;\n+    }\n \n-      /* XXX this should be handled before we get here.  */\n-      if (! IS_AGGR_TYPE (basetype))\n-\t{\n-\t  if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n-\t    error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n-\t\t      name, instance, basetype);\n+  if (!conversion_path)\n+    conversion_path = BASELINK_BINFO (fns);\n+  access_binfo = BASELINK_ACCESS_BINFO (fns);\n+  optype = BASELINK_OPTYPE (fns);\n+  fns = BASELINK_FUNCTIONS (fns);\n \n-\t  return error_mark_node;\n-\t}\n+  if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n+    {\n+      explicit_targs = TREE_OPERAND (fns, 1);\n+      fns = TREE_OPERAND (fns, 0);\n+      template_only = 1;\n     }\n \n-  if (basetype_path == NULL_TREE)\n-    basetype_path = TYPE_BINFO (basetype);\n+  my_friendly_assert (TREE_CODE (fns) == FUNCTION_DECL\n+\t\t      || TREE_CODE (fns) == TEMPLATE_DECL\n+\t\t      || TREE_CODE (fns) == OVERLOAD,\n+\t\t      20020712);\n \n-  if (instance)\n+  /* XXX this should be handled before we get here.  */\n+  if (! IS_AGGR_TYPE (basetype))\n     {\n-      instance_ptr = build_this (instance);\n+      if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n+\terror (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n+\t       fns, instance, basetype);\n \n-      if (! template_only)\n-\t{\n-\t  /* XXX this should be handled before we get here.  */\n-\t  fns = build_field_call (basetype_path, instance_ptr, name, args);\n-\t  if (fns)\n-\t    return fns;\n-\t}\n-    }\n-  else\n-    {\n-      instance_ptr = build_int_2 (0, 0);\n-      TREE_TYPE (instance_ptr) = build_pointer_type (basetype);\n+      return error_mark_node;\n     }\n \n-  /* Callers should explicitly indicate whether they want to construct\n-     the complete object or just the part without virtual bases.  */\n-  my_friendly_assert (name != ctor_identifier, 20000408);\n-  /* Similarly for destructors.  */\n-  my_friendly_assert (name != dtor_identifier, 20000408);\n+  name = DECL_NAME (get_first_fn (fns));\n \n   if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     {\n-      int constructor_p;\n-\n-      constructor_p = (name == complete_ctor_identifier\n-\t\t       || name == base_ctor_identifier);\n-      pretty_name = (constructor_p \n-\t\t     ? constructor_name (basetype) : dtor_identifier);\n-\n-      /* If we're a call to a constructor or destructor for a\n-\t subobject that uses virtual base classes, then we need to\n-\t pass down a pointer to a VTT for the subobject.  */\n-      if ((name == base_ctor_identifier\n-\t   || name == base_dtor_identifier)\n-\t  && TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t{\n-\t  tree vtt;\n-\t  tree sub_vtt;\n-\t  tree basebinfo = basetype_path;\n-\n-\t  /* If the current function is a complete object constructor\n-\t     or destructor, then we fetch the VTT directly.\n-\t     Otherwise, we look it up using the VTT we were given.  */\n-\t  vtt = IDENTIFIER_GLOBAL_VALUE (get_vtt_name (current_class_type));\n-\t  vtt = decay_conversion (vtt);\n-\t  vtt = build (COND_EXPR, TREE_TYPE (vtt),\n-\t\t       build (EQ_EXPR, boolean_type_node,\n-\t\t\t      current_in_charge_parm, integer_zero_node),\n-\t\t       current_vtt_parm,\n-\t\t       vtt);\n-\t  if (TREE_VIA_VIRTUAL (basebinfo))\n-\t    basebinfo = binfo_for_vbase (basetype, current_class_type);\n-\t  my_friendly_assert (BINFO_SUBVTT_INDEX (basebinfo), 20010110);\n-\t  sub_vtt = build (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n-\t\t\t   BINFO_SUBVTT_INDEX (basebinfo));\n-\n-\t  args = tree_cons (NULL_TREE, sub_vtt, args);\n-\t}\n+      /* Callers should explicitly indicate whether they want to construct\n+\t the complete object or just the part without virtual bases.  */\n+      my_friendly_assert (name != ctor_identifier, 20000408);\n+      /* Similarly for destructors.  */\n+      my_friendly_assert (name != dtor_identifier, 20000408);\n+      \n+      if (name == complete_ctor_identifier\n+\t  || name == base_ctor_identifier)\n+\tpretty_name = constructor_name (basetype);\n+      else\n+\tpretty_name = dtor_identifier;\n     }\n   else\n     pretty_name = name;\n \n-  fns = lookup_fnfields (basetype_path, name, 1);\n-\n-  if (fns == error_mark_node)\n-    return error_mark_node;\n   if (fns)\n     {\n-      tree base = BINFO_TYPE (TREE_PURPOSE (fns));\n-      tree fn = TREE_VALUE (fns);\n+      tree fn;\n+      tree class_type = (conversion_path \n+\t\t\t ? BINFO_TYPE (conversion_path)\n+\t\t\t : NULL_TREE);\n+\n       mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n-      for (; fn; fn = OVL_NEXT (fn))\n+      for (fn = fns; fn; fn = OVL_NEXT (fn))\n \t{\n \t  tree t = OVL_CURRENT (fn);\n \t  tree this_arglist;\n@@ -4690,16 +4831,22 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t      /* A member template. */\n \t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = \n-\t\tadd_template_candidate (candidates, t, base, explicit_targs,\n-\t\t\t\t\tthis_arglist,\n-\t\t\t\t\tTREE_TYPE (name), flags, DEDUCE_CALL); \n+\t\tadd_template_candidate (candidates, t, \n+\t\t\t\t\tclass_type,\n+\t\t\t\t\texplicit_targs,\n+\t\t\t\t\tthis_arglist, optype,\n+\t\t\t\t\taccess_binfo, \n+\t\t\t\t\tconversion_path,\n+\t\t\t\t\tflags,\n+\t\t\t\t\tDEDUCE_CALL);\n \t    }\n \t  else if (! template_only)\n-\t    candidates = add_function_candidate (candidates, t, base,\n-\t\t\t\t\t\t this_arglist, flags);\n-\n-\t  if (candidates)\n-\t    candidates->basetype_path = basetype_path;\n+\t    candidates = add_function_candidate (candidates, t, \n+\t\t\t\t\t\t class_type,\n+\t\t\t\t\t\t this_arglist,\n+\t\t\t\t\t\t access_binfo,\n+\t\t\t\t\t\t conversion_path,\n+\t\t\t\t\t\t flags);\n \t}\n     }\n \n@@ -4754,9 +4901,9 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n   else\n     {\n       call = build_over_call (cand, args, flags);\n-      /* Do evaluate the object parameter in a call to a static member\n-\t function.  */\n-      if (TREE_SIDE_EFFECTS (instance))\n+      /* In an expression of the form `a->f()' where `f' turns out to\n+\t be a static member function, `a' is none-the-less evaluated.  */\n+      if (instance && TREE_SIDE_EFFECTS (instance))\n \tcall = build (COMPOUND_EXPR, TREE_TYPE (call), instance, call);\n     }\n "}, {"sha": "a70ad50141247a411c81acbf371407c61424e83e", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -23,11 +23,25 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n  \n-/* Reference to the contents of an offset\n-   (a value whose type is an OFFSET_TYPE).\n-   Operand 0 is the object within which the offset is taken.\n-   Operand 1 is the offset.  The language independent OFFSET_REF\n-   just won't work for us.  */\n+/* An OFFSET_REF is used in two situations:\n+\n+   1. An expression of the form `A::m' where `A' is a class and `m' is\n+      a non-static data member.  In this case, operand 0 will be a\n+      TYPE (corresponding to `A') and operand 1 will be a FIELD_DECL\n+      (corresponding to `m'.\n+\n+      The expression is a pointer-to-member if its address is taken,\n+      but simply denotes a member of the object if its address isnot\n+      taken.  In the latter case, resolve_offset_ref is used to\n+      convert it to a representation of the member referred to by the\n+      OFFSET_REF.\n+\n+   2. An expression of the form `x.*p'.  In this case, operand 0 will\n+      be an expression corresponding to `x' and operand 1 will be an\n+      expression with pointer-to-member type.\n+\n+   OFFSET_REFs are only used during the parsing phase; once semantic\n+   analysis has taken place they are eliminated.  */\n DEFTREECODE (OFFSET_REF, \"offset_ref\", 'r', 2)\n \n /* A pointer-to-member constant.  For a pointer-to-member constant\n@@ -186,7 +200,8 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'x', 2)\n    The second is the TREE_LIST or TREE_VEC of explicitly specified\n    arguments.  The template will be a FUNCTION_DECL, TEMPLATE_DECL, or\n    an OVERLOAD.  If the template-id refers to a member template, the\n-   template may be an IDENTIFIER_NODE.  */\n+   template may be an IDENTIFIER_NODE.  In an uninstantiated template,\n+   the template may be a LOOKUP_EXPR.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n /* An association between name and entity. Parameters are the scope"}, {"sha": "9f220186ca052a3ae6a2a5bb5796d3a01f100f51", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -385,10 +385,25 @@ struct tree_overload GTY(())\n   (TREE_CODE (NODE) == TREE_LIST && TREE_LANG_FLAG_1 (NODE))\n #define SET_BASELINK_P(NODE) \\\n   (TREE_LANG_FLAG_1 (NODE) = 1)\n+/* The BINFO indicated the base from which the BASELINK_FUNCTIONS came.  */\n+#define BASELINK_BINFO(NODE) \\\n+  (TREE_PURPOSE (NODE))\n /* The functions referred to by the BASELINK; either a FUNCTION_DECL\n    or an OVERLOAD.  */\n #define BASELINK_FUNCTIONS(NODE) \\\n   (TREE_VALUE (NODE))\n+/* The BINFO in which the search for the functions indicated by this baselink \n+   began.  This base is used to determine the accessibility of functions \n+   selected by overload resolution.  */\n+#define BASELINK_ACCESS_BINFO(NODE) \\\n+  (TREE_TYPE (NODE))\n+/* For a type-conversion operator, the BASELINK_OPTYPE indicates the type\n+   to which the conversion should occur.  This value is important if\n+   the BASELINK_FUNCTIONS include a template conversion operator --\n+   the BASELINK_OPTYPE can be used to determine what type the user\n+   requested.  */\n+#define BASELINK_OPTYPE(NODE) \\\n+  (TREE_CHAIN (NODE))\n \n #define WRAPPER_ZC(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->z_c)\n \n@@ -3676,6 +3691,8 @@ extern int sufficient_parms_p                   PARAMS ((tree));\n extern tree type_decays_to\t\t\tPARAMS ((tree));\n extern tree build_user_type_conversion\t\tPARAMS ((tree, tree, int));\n extern tree build_new_function_call\t\tPARAMS ((tree, tree));\n+extern tree build_new_method_call               (tree, tree, tree, tree, int);\n+extern tree build_special_member_call           (tree, tree, tree, tree, int);\n extern tree build_new_op\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n extern tree build_op_delete_call\t\tPARAMS ((enum tree_code, tree, tree, int, tree));\n extern int can_convert\t\t\t\tPARAMS ((tree, tree));\n@@ -3950,6 +3967,8 @@ extern void finish_file\t\t\t\tPARAMS ((void));\n extern tree reparse_absdcl_as_expr\t\tPARAMS ((tree, tree));\n extern tree reparse_absdcl_as_casts\t\tPARAMS ((tree, tree));\n extern tree build_expr_from_tree\t\tPARAMS ((tree));\n+extern tree build_offset_ref_call_from_tree     (tree, tree);\n+extern tree build_call_from_tree                (tree, tree, bool);\n extern tree reparse_decl_as_expr\t\tPARAMS ((tree, tree));\n extern tree finish_decl_parsing\t\t\tPARAMS ((tree));\n extern void set_decl_namespace                  PARAMS ((tree, tree, int));\n@@ -4229,6 +4248,7 @@ extern tree unmarked_vtable_pathp               PARAMS ((tree, void *));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));\n extern tree binfo_for_vbase                     PARAMS ((tree, tree));\n extern tree binfo_via_virtual                   PARAMS ((tree, tree));\n+extern tree build_baselink                      (tree, tree, tree, tree);\n \n /* in semantics.c */\n extern void init_cp_semantics                   PARAMS ((void));\n@@ -4281,13 +4301,12 @@ extern void finish_subobject                    PARAMS ((tree));\n extern tree finish_parenthesized_expr           PARAMS ((tree));\n extern tree begin_stmt_expr                     PARAMS ((void));\n extern tree finish_stmt_expr                    PARAMS ((tree));\n-extern tree finish_call_expr                    PARAMS ((tree, tree, int));\n+extern tree finish_call_expr                    (tree, tree, bool);\n extern tree finish_increment_expr               PARAMS ((tree, enum tree_code));\n extern tree finish_this_expr                    PARAMS ((void));\n extern tree finish_object_call_expr             PARAMS ((tree, tree, tree));\n extern tree finish_qualified_object_call_expr   PARAMS ((tree, tree, tree));\n extern tree finish_pseudo_destructor_call_expr  PARAMS ((tree, tree, tree));\n-extern tree finish_qualified_call_expr          PARAMS ((tree, tree));\n extern tree finish_unary_op_expr                PARAMS ((enum tree_code, tree));\n extern tree finish_id_expr                      PARAMS ((tree));\n extern tree finish_fname                        (tree);\n@@ -4454,7 +4473,6 @@ extern tree build_x_component_ref\t\tPARAMS ((tree, tree, tree));\n extern tree build_x_indirect_ref\t\tPARAMS ((tree, const char *));\n extern tree build_indirect_ref\t\t\tPARAMS ((tree, const char *));\n extern tree build_array_ref\t\t\tPARAMS ((tree, tree));\n-extern tree build_x_function_call\t\tPARAMS ((tree, tree, tree));\n extern tree get_member_function_from_ptrfunc\tPARAMS ((tree *, tree));\n extern tree build_function_call_real\t\tPARAMS ((tree, tree, int, int));\n extern tree build_function_call_maybe\t\tPARAMS ((tree, tree));"}, {"sha": "ee01a31a5668c4efe7b347382e30bbeb24fa6d46", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -771,10 +771,10 @@ ocp_convert (type, expr, convtype, flags)\n \t   the target with the temp (see [dcl.init]).  */\n \tctor = build_user_type_conversion (type, ctor, flags);\n       else\n-\tctor = build_method_call (NULL_TREE, \n-\t\t\t\t  complete_ctor_identifier,\n-\t\t\t\t  build_tree_list (NULL_TREE, ctor),\n-\t\t\t\t  TYPE_BINFO (type), flags);\n+\tctor = build_special_member_call (NULL_TREE, \n+\t\t\t\t\t  complete_ctor_identifier,\n+\t\t\t\t\t  build_tree_list (NULL_TREE, ctor),\n+\t\t\t\t\t  TYPE_BINFO (type), flags);\n       if (ctor)\n \treturn build_cplus_new (type, ctor);\n     }"}, {"sha": "8317198454476d98929bea536e6321fe64a88064", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 136, "deletions": 14, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -3587,14 +3587,7 @@ reparse_absdcl_as_expr (type, decl)\n   /* recurse */\n   decl = reparse_absdcl_as_expr (type, TREE_OPERAND (decl, 0));\n \n-  decl = build_x_function_call (decl, NULL_TREE, current_class_ref);\n-\n-  if (TREE_CODE (decl) == CALL_EXPR\n-      && (! TREE_TYPE (decl)\n-          || TREE_CODE (TREE_TYPE (decl)) != VOID_TYPE))\n-    decl = require_complete_type (decl);\n-\n-  return decl;\n+  return finish_call_expr (decl, NULL_TREE, /*disallow_virtual=*/false);\n }\n \n /* This is something of the form `int ((int)(int)(int)1)' that has turned\n@@ -3647,7 +3640,8 @@ reparse_absdcl_as_casts (decl, expr)\n   return expr;\n }\n \n-/* Given plain tree nodes for an expression, build up the full semantics.  */\n+/* T is the parse tree for an expression.  Return the expression after\n+   performing semantic analysis.  */\n \n tree\n build_expr_from_tree (t)\n@@ -3671,9 +3665,29 @@ build_expr_from_tree (t)\n \treturn do_identifier (TREE_OPERAND (t, 0), 0, NULL_TREE);\n \n     case TEMPLATE_ID_EXPR:\n-      return (lookup_template_function\n-\t      (build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t       build_expr_from_tree (TREE_OPERAND (t, 1))));\n+      {\n+\ttree template;\n+\ttree args;\n+\ttree object;\n+\n+\ttemplate = build_expr_from_tree (TREE_OPERAND (t, 0));\n+\targs = build_expr_from_tree (TREE_OPERAND (t, 1));\n+\t\n+\tif (TREE_CODE (template) == COMPONENT_REF)\n+\t  {\n+\t    object = TREE_OPERAND (template, 0);\n+\t    template = TREE_OPERAND (template, 1);\n+\t  }\n+\telse\n+\t  object = NULL_TREE;\n+\n+\ttemplate = lookup_template_function (template, args);\n+\tif (object)\n+\t  return build (COMPONENT_REF, TREE_TYPE (template), \n+\t\t\tobject, template);\n+\telse\n+\t  return template;\n+      }\n \n     case INDIRECT_REF:\n       return build_x_indirect_ref\n@@ -3881,9 +3895,18 @@ build_expr_from_tree (t)\n               name = do_identifier (id, 0, args);\n             }\n           else if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n-\t      || ! really_overloaded_fn (name))\n+\t\t   || ! really_overloaded_fn (name))\n \t    name = build_expr_from_tree (name);\n-\t  return build_x_function_call (name, args, current_class_ref);\n+\n+\t  if (TREE_CODE (name) == OFFSET_REF)\n+\t    return build_offset_ref_call_from_tree (name, args);\n+\t  if (TREE_CODE (name) == COMPONENT_REF)\n+\t    return finish_object_call_expr (TREE_OPERAND (name, 1),\n+\t\t\t\t\t    TREE_OPERAND (name, 0),\n+\t\t\t\t\t    args);\n+\t  name = convert_from_reference (name);\n+\t  return build_call_from_tree (name, args, \n+\t\t\t\t       /*disallow_virtual=*/false);\n \t}\n \n     case COND_EXPR:\n@@ -3988,6 +4011,105 @@ build_expr_from_tree (t)\n     }\n }\n \n+/* FN is an OFFSET_REF indicating the function to call in parse-tree\n+   form; it has not yet been semantically analyzed.  ARGS are the\n+   arguments to the function.  They have already been semantically\n+   analzyed.  */\n+\n+tree\n+build_offset_ref_call_from_tree (tree fn, tree args)\n+{\n+  tree object_addr;\n+\n+  my_friendly_assert (TREE_CODE (fn) == OFFSET_REF, 20020725);\n+\n+  /* A qualified name corresponding to a non-static member\n+     function or a pointer-to-member is represented as an \n+     OFFSET_REF.  \n+\n+     For both of these function calls, FN will be an OFFSET_REF.\n+\n+\tstruct A { void f(); };\n+\tvoid A::f() { (A::f) (); } \n+\n+\tstruct B { void g(); };\n+\tvoid (B::*p)();\n+\tvoid B::g() { (this->*p)(); }  */\n+\n+  /* This code is not really correct (for example, it does not\n+     handle the case that `A::f' is overloaded), but it is\n+     historically how we have handled this situation.  */\n+  object_addr = build_unary_op (ADDR_EXPR, TREE_OPERAND (fn, 0), 0);\n+  if (TREE_CODE (TREE_OPERAND (fn, 1)) == FIELD_DECL)\n+    fn = resolve_offset_ref (fn);\n+  else\n+    {\n+      fn = TREE_OPERAND (fn, 1);\n+      fn = get_member_function_from_ptrfunc (&object_addr, fn);\n+    }\n+  args = tree_cons (NULL_TREE, object_addr, args);\n+  return build_function_call (fn, args);\n+}\n+\n+/* FN indicates the function to call.  Name resolution has been\n+   performed on FN.  ARGS are the arguments to the function.  They\n+   have already been semantically analyzed.  DISALLOW_VIRTUAL is true\n+   if the function call should be determined at compile time, even if\n+   FN is virtual.  */\n+\n+tree\n+build_call_from_tree (tree fn, tree args, bool disallow_virtual)\n+{\n+  tree template_args;\n+  tree template_id;\n+  tree f;\n+  \n+  /* Check to see that name lookup has already been performed.  */\n+  my_friendly_assert (TREE_CODE (fn) != OFFSET_REF, 20020725);\n+  my_friendly_assert (TREE_CODE (fn) != SCOPE_REF, 20020725);\n+\n+  /* In the future all of this should be eliminated.  Instead,\n+     name-lookup for a member function should simply return a\n+     baselink, instead of a FUNCTION_DECL, TEMPLATE_DECL, or\n+     TEMPLATE_ID_EXPR.  */\n+\n+  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+    {\n+      template_id = fn;\n+      template_args = TREE_OPERAND (fn, 1);\n+      fn = TREE_OPERAND (fn, 0);\n+    }\n+  else\n+    template_id = NULL_TREE;\n+\n+  f = (TREE_CODE (fn) == OVERLOAD) ? get_first_fn (fn) : fn;\n+  /* Make sure we have a baselink (rather than simply a\n+     FUNCTION_DECL) for a member function.  */\n+  if (current_class_type\n+      && ((TREE_CODE (f) == FUNCTION_DECL\n+\t   && DECL_FUNCTION_MEMBER_P (f))\n+\t  || (DECL_FUNCTION_TEMPLATE_P (f) \n+\t      && DECL_FUNCTION_MEMBER_P (f))))\n+    {\n+      f = lookup_member (current_class_type, DECL_NAME (f), \n+\t\t\t /*protect=*/1, /*want_type=*/0);\n+      if (f)\n+\tfn = f;\n+    }\n+\n+  if (template_id)\n+    {\n+      if (BASELINK_P (fn))\n+\t  BASELINK_FUNCTIONS (fn) = build_nt (TEMPLATE_ID_EXPR, \n+\t\t\t\t\t      BASELINK_FUNCTIONS (fn),\n+\t\t\t\t\t      template_args);\n+      else\n+\tfn = template_id;\n+    }\n+\n+  return finish_call_expr (fn, args, disallow_virtual);\n+}\n+\n /* This is something of the form `int (*a)++' that has turned out to be an\n    expr.  It was only converted into parse nodes, so we need to go through\n    and build up the semantics.  Most of the work is done by"}, {"sha": "421a00ac2897426a9b7bbbb4c55f33104cd437ae", "filename": "gcc/cp/init.c", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -852,8 +852,11 @@ expand_cleanup_for_base (binfo, flag)\n     return;\n \n   /* Call the destructor.  */\n-  expr = (build_scoped_method_call\n-\t  (current_class_ref, binfo, base_dtor_identifier, NULL_TREE));\n+  expr = build_special_member_call (current_class_ref, \n+\t\t\t\t    base_dtor_identifier,\n+\t\t\t\t    NULL_TREE,\n+\t\t\t\t    binfo,\n+\t\t\t\t    LOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n   if (flag)\n     expr = fold (build (COND_EXPR, void_type_node,\n \t\t\tc_common_truthvalue_conversion (flag),\n@@ -1282,7 +1285,7 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n   else\n     ctor_name = base_ctor_identifier;\n \n-  rval = build_method_call (exp, ctor_name, parms, binfo, flags);\n+  rval = build_special_member_call (exp, ctor_name, parms, binfo, flags);\n   if (TREE_SIDE_EFFECTS (rval))\n     {\n       if (building_stmt_tree ())\n@@ -1451,15 +1454,16 @@ build_member_call (type, name, parmlist)\n \t  TREE_OPERAND (name, 0) = method_name;\n \t}\n       my_friendly_assert (is_overloaded_fn (method_name), 980519);\n-      return build_x_function_call (name, parmlist, current_class_ref);\n+      return finish_call_expr (name, parmlist, /*disallow_virtual=*/true);\n     }\n \n   if (DECL_P (name))\n     name = DECL_NAME (name);\n \n   if (TREE_CODE (type) == NAMESPACE_DECL)\n-    return build_x_function_call (lookup_namespace_name (type, name),\n-\t\t\t\t  parmlist, current_class_ref);\n+    return finish_call_expr (lookup_namespace_name (type, name),\n+\t\t\t     parmlist,\n+\t\t\t     /*disallow_virtual=*/true);\n \n   if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n     {\n@@ -1486,10 +1490,9 @@ build_member_call (type, name, parmlist)\n     {\n       tree ns = lookup_name (type, 0);\n       if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n-\t{\n-\t  return build_x_function_call (build_offset_ref (type, name),\n-\t\t\t\t\tparmlist, current_class_ref);\n-\t}\n+\treturn finish_call_expr (lookup_namespace_name (ns, name),\n+\t\t\t\t parmlist,\n+\t\t\t\t /*disallow_virtual=*/true);\n     }\n \n   if (type == NULL_TREE || ! is_aggr_type (type, 1))\n@@ -2326,7 +2329,8 @@ build_new_1 (exp)\n \t\t       args));\n       else\n \talloc_call = build_method_call (build_dummy_object (true_type),\n-\t\t\t\t\tfnname, args, NULL_TREE,\n+\t\t\t\t\tfnname, args, \n+\t\t\t\t\tTYPE_BINFO (true_type),\n \t\t\t\t\tLOOKUP_NORMAL);\n     }\n \n@@ -2415,10 +2419,10 @@ build_new_1 (exp)\n       if (has_array)\n \tinit_expr = build_vec_init (init_expr, init, 0);\n       else if (TYPE_NEEDS_CONSTRUCTING (type))\n-\tinit_expr = build_method_call (init_expr, \n-\t\t\t\t       complete_ctor_identifier,\n-\t\t\t\t       init, TYPE_BINFO (true_type),\n-\t\t\t\t       LOOKUP_NORMAL);\n+\tinit_expr = build_special_member_call (init_expr, \n+\t\t\t\t\t       complete_ctor_identifier,\n+\t\t\t\t\t       init, TYPE_BINFO (true_type),\n+\t\t\t\t\t       LOOKUP_NORMAL);\n       else\n \t{\n \t  /* We are processing something like `new int (10)', which\n@@ -3090,7 +3094,8 @@ build_dtor_call (exp, dtor_kind, flags)\n     default:\n       abort ();\n     }\n-  return build_method_call (exp, name, NULL_TREE, NULL_TREE, flags);\n+  return build_method_call (exp, name, NULL_TREE, \n+\t\t\t    TYPE_BINFO (TREE_TYPE (exp)), flags);\n }\n \n /* Generate a call to a destructor. TYPE is the type to cast ADDR to.\n@@ -3282,9 +3287,12 @@ push_base_cleanups ()\n \n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (base_type))\n \t    {\n-\t      expr = build_scoped_method_call (current_class_ref, vbase,\n-\t\t\t\t\t       base_dtor_identifier,\n-\t\t\t\t\t       NULL_TREE);\n+\t      expr = build_special_member_call (current_class_ref, \n+\t\t\t\t\t\tbase_dtor_identifier,\n+\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\tvbase,\n+\t\t\t\t\t\t(LOOKUP_NORMAL \n+\t\t\t\t\t\t | LOOKUP_NONVIRTUAL));\n \t      expr = build (COND_EXPR, void_type_node, cond,\n \t\t\t    expr, void_zero_node);\n \t      finish_decl_cleanup (NULL_TREE, expr);\n@@ -3303,10 +3311,10 @@ push_base_cleanups ()\n \t  || TREE_VIA_VIRTUAL (base_binfo))\n \tcontinue;\n \n-      expr = build_scoped_method_call (current_class_ref, base_binfo,\n-\t\t\t\t       base_dtor_identifier,\n-\t\t\t\t       NULL_TREE);\n-\n+      expr = build_special_member_call (current_class_ref, \n+\t\t\t\t\tbase_dtor_identifier,\n+\t\t\t\t\tNULL_TREE, base_binfo, \n+\t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n       finish_decl_cleanup (NULL_TREE, expr);\n     }\n "}, {"sha": "81bcc951ce35252f8d05b1d01785e57b513e1764", "filename": "gcc/cp/method.c", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -623,28 +623,34 @@ do_build_assign_ref (fndecl)\n     }\n   else\n     {\n-      tree fields = TYPE_FIELDS (current_class_type);\n-      int n_bases = CLASSTYPE_N_BASECLASSES (current_class_type);\n-      tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n+      tree fields;\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n \n-      for (i = 0; i < n_bases; ++i)\n+      /* Assign to each of thedirect base classes.  */\n+      for (i = 0; i < CLASSTYPE_N_BASECLASSES (current_class_type); ++i)\n \t{\n-\t  /* We must deal with the binfo's directly as a direct base\n-\t     might be inaccessible due to ambiguity.  */\n-\t  tree binfo = TREE_VEC_ELT (binfos, i);\n-\t  tree src = build_base_path (PLUS_EXPR, parm, binfo, 1);\n-\t  tree dst = build_base_path (PLUS_EXPR, current_class_ref, binfo, 1);\n-\n-\t  tree expr = build_method_call (dst,\n-\t\t\t\t\t ansi_assopname (NOP_EXPR),\n-\t\t\t\t\t build_tree_list (NULL_TREE, src),\n-\t\t\t\t\t binfo,\n-\t\t\t\t\t LOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n-\t  finish_expr_stmt (expr);\n+\t  tree binfo;\n+\t  tree converted_parm;\n+\n+\t  binfo = BINFO_BASETYPE (TYPE_BINFO (current_class_type), i);\n+\t  /* We must convert PARM directly to the base class\n+\t     explicitly since the base class may be ambiguous.  */\n+\t  converted_parm = build_base_path (PLUS_EXPR, parm, binfo, 1);\n+\t  /* Call the base class assignment operator.  */\n+\t  finish_expr_stmt \n+\t    (build_special_member_call (current_class_ref, \n+\t\t\t\t\tansi_assopname (NOP_EXPR),\n+\t\t\t\t\tbuild_tree_list (NULL_TREE, \n+\t\t\t\t\t\t\t converted_parm),\n+\t\t\t\t\tbinfo,\n+\t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL));\n \t}\n-      for (; fields; fields = TREE_CHAIN (fields))\n+\n+      /* Assign to each of the non-static data members.  */\n+      for (fields = TYPE_FIELDS (current_class_type); \n+\t   fields; \n+\t   fields = TREE_CHAIN (fields))\n \t{\n \t  tree comp, init, t;\n \t  tree field = fields;"}, {"sha": "0fa97743734d5faf1298e08c0680f2c577906429", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 161, "deletions": 8, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -131,6 +131,7 @@ static tree parse_xref_tag (tree, tree, int);\n static tree parse_handle_class_head (tree, tree, tree, int, int *);\n static void parse_decl_instantiation (tree, tree, tree);\n static int parse_begin_function_definition (tree, tree);\n+static tree parse_finish_call_expr (tree, tree, int);\n \n /* Cons up an empty parameter list.  */\n static inline tree\n@@ -1534,9 +1535,19 @@ do_id:\n \n template_id:\n           PFUNCNAME '<' do_id template_arg_list_opt template_close_bracket\n-                { $$ = lookup_template_function ($3, $4); }\n+                { \n+\t\t  tree template_name = $3;\n+\t\t  if (TREE_CODE (template_name) == COMPONENT_REF)\n+\t\t    template_name = TREE_OPERAND (template_name, 1);\n+\t\t  $$ = lookup_template_function (template_name, $4); \n+\t\t}\n         | operator_name '<' do_id template_arg_list_opt template_close_bracket\n-                { $$ = lookup_template_function ($3, $4); }\n+                { \n+\t\t  tree template_name = $3;\n+\t\t  if (TREE_CODE (template_name) == COMPONENT_REF)\n+\t\t    template_name = TREE_OPERAND (template_name, 1);\n+\t\t  $$ = lookup_template_function (template_name, $4); \n+\t\t}\n \t;\n \n object_template_id:\n@@ -1637,13 +1648,13 @@ primary:\n            We could store lastiddecl in $1 to avoid another lookup,\n            but that would result in many additional reduce/reduce conflicts. */\n         | notype_unqualified_id '(' nonnull_exprlist ')'\n-               { $$ = finish_call_expr ($1, $3, 1); }\n+               { $$ = parse_finish_call_expr ($1, $3, 1); }\n         | notype_unqualified_id LEFT_RIGHT\n-               { $$ = finish_call_expr ($1, NULL_TREE, 1); }\n+               { $$ = parse_finish_call_expr ($1, NULL_TREE, 1); }\n \t| primary '(' nonnull_exprlist ')'\n-               { $$ = finish_call_expr ($1, $3, 0); }\n+               { $$ = parse_finish_call_expr ($1, $3, 0); }\n \t| primary LEFT_RIGHT\n-               { $$ = finish_call_expr ($1, NULL_TREE, 0); }\n+               { $$ = parse_finish_call_expr ($1, NULL_TREE, 0); }\n \t| VA_ARG '(' expr_no_commas ',' type_id ')'\n \t\t{ $$ = build_x_va_arg ($3, groktypename ($5.t));\n \t\t  check_for_new_type (\"__builtin_va_arg\", $5); }\n@@ -1705,9 +1716,9 @@ primary:\n \t| overqualified_id  %prec HYPERUNARY\n \t\t{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }\n \t| overqualified_id '(' nonnull_exprlist ')'\n-                { $$ = finish_qualified_call_expr ($1, $3); }\n+                { $$ = parse_finish_call_expr ($1, $3, 0); }\n \t| overqualified_id LEFT_RIGHT\n-\t\t{ $$ = finish_qualified_call_expr ($1, NULL_TREE); }\n+\t\t{ $$ = parse_finish_call_expr ($1, NULL_TREE, 0); }\n         | object object_template_id %prec UNARY\n                 {\n \t\t  $$ = build_x_component_ref ($$, $2, NULL_TREE);\n@@ -4099,4 +4110,146 @@ parse_begin_function_definition (tree specs_attrs, tree declarator)\n   return begin_function_definition (specs, attrs, declarator);\n }\n \n+/* Like finish_call_expr, but the name for FN has not yet been\n+   resolved.  */\n+\n+static tree\n+parse_finish_call_expr (tree fn, tree args, int koenig)\n+{\n+  bool disallow_virtual;\n+  tree template_args;\n+  tree template_id;\n+  tree f;\n+\n+  if (TREE_CODE (fn) == OFFSET_REF)\n+    return build_offset_ref_call_from_tree (fn, args);\n+\n+  if (TREE_CODE (fn) == SCOPE_REF)\n+    {\n+      tree scope;\n+      tree name;\n+\n+      scope = TREE_OPERAND (fn, 0);\n+      name = TREE_OPERAND (fn, 1);\n+\n+      if (scope == error_mark_node || name == error_mark_node)\n+\treturn error_mark_node;\n+      if (!processing_template_decl)\n+\t{\n+\t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n+\t    fn = lookup_namespace_name (scope, name);\n+\t  else\n+\t    {\n+\t      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+\t\t{\n+\t\t  template_id = name;\n+\t\t  template_args = TREE_OPERAND (name, 1);\n+\t\t  name = TREE_OPERAND (name, 0);\n+\t\t}\n+\t      else \n+\t\ttemplate_id = NULL_TREE;\n+\n+\t      if (TREE_CODE (name) == OVERLOAD)\n+\t\tname = DECL_NAME (get_first_fn (name));\n+\t      fn = lookup_member (scope, name, /*protect=*/1, \n+\t\t\t\t  /*prefer_type=*/0);\n+\t      if (BASELINK_P (fn) && template_id)\n+\t\tBASELINK_FUNCTIONS (fn) = build_nt (TEMPLATE_ID_EXPR,\n+\t\t\t\t\t\t    BASELINK_FUNCTIONS (fn),\n+\t\t\t\t\t\t    template_args);\n+\t      if (BASELINK_P (fn) \n+\t\t  && current_class_type \n+\t\t  && DERIVED_FROM_P (scope, current_class_type))\n+\t\t{\n+\t\t  scope = lookup_base (current_class_type, scope,\n+\t\t\t\t       ba_ignore | ba_quiet, NULL);\n+\t\t  if (scope)\n+\t\t    {\n+\t\t      BASELINK_ACCESS_BINFO (fn) = scope;\n+\t\t      BASELINK_BINFO (fn) \n+\t\t\t= lookup_base (scope,\n+\t\t\t\t       BINFO_TYPE (BASELINK_BINFO (fn)),\n+\t\t\t\t       ba_ignore | ba_quiet,\n+\t\t\t\t       NULL);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      disallow_virtual = true;\n+    }\n+  else\n+    disallow_virtual = false;\n+\n+  if (koenig && TREE_CODE (fn) == IDENTIFIER_NODE)\n+    {\n+      /* Do the Koenig lookup.  */\n+      fn = do_identifier (fn, 2, args);\n+      /* If name lookup didn't find any matching declarations, we've\n+\t got an unbound identifier.  */\n+      if (TREE_CODE (fn) == IDENTIFIER_NODE)\n+\t{\n+\t  /* For some reason, do_identifier does not resolve\n+\t     conversion operator names if the only matches would be\n+\t     template conversion operators.  So, we do it here.  */\n+\t  if (IDENTIFIER_TYPENAME_P (fn) && current_class_type)\n+\t    {\n+\t      f = lookup_member (current_class_type, fn,\n+\t\t\t\t /*protect=*/1, /*want_type=*/0);\n+\t      if (f)\n+\t\treturn finish_call_expr (f, args,\n+\t\t\t\t\t /*disallow_virtual=*/false);\n+\t    }\n+\t  /* If the name still could not be resolved, then the program\n+\t     is ill-formed.  */\n+\t  if (TREE_CODE (fn) == IDENTIFIER_NODE)\n+\t    {\n+\t      unqualified_name_lookup_error (fn);\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      else if (TREE_CODE (fn) == FUNCTION_DECL\n+\t       || DECL_FUNCTION_TEMPLATE_P (fn)\n+\t       || TREE_CODE (fn) == OVERLOAD)\n+\t{\n+\t  tree scope = DECL_CONTEXT (get_first_fn (fn));\n+\t  if (scope && TYPE_P (scope))\n+\t    {\n+\t      tree access_scope;\n+\n+\t      if (DERIVED_FROM_P (scope, current_class_type)\n+\t\t  && current_class_ref)\n+\t\treturn finish_object_call_expr (fn,\n+\t\t\t\t\t\tcurrent_class_ref,\n+\t\t\t\t\t\targs);\n+\n+\t      access_scope = current_class_type;\n+\t      while (!DERIVED_FROM_P (scope, access_scope))\n+\t\t{\n+\t\t  access_scope = TYPE_CONTEXT (access_scope);\n+\t\t  while (DECL_P (access_scope))\n+\t\t    access_scope = DECL_CONTEXT (access_scope);\n+\t\t}\n+\t      \n+\t      fn = build_baselink (NULL_TREE,\n+\t\t\t\t   TYPE_BINFO (access_scope),\n+\t\t\t\t   fn,\n+\t\t\t\t   /*optype=*/NULL_TREE);\n+\t    }\n+\t}\n+    }\n+\n+  if (TREE_CODE (fn) == COMPONENT_REF)\n+    /* If the parser sees `(x->y)(bar)' we get here because the\n+       parentheses confuse the parser.  Treat this like \n+       `x->y(bar)'.  */\n+    return finish_object_call_expr (TREE_OPERAND (fn, 1),\n+\t\t\t\t    TREE_OPERAND (fn, 0),\n+\t\t\t\t    args);\n+\n+  if (processing_template_decl)\n+    return build_nt (CALL_EXPR, fn, args, NULL_TREE);\n+\n+  return build_call_from_tree (fn, args, disallow_virtual);\n+}\n+\n #include \"gt-cp-parse.h\""}, {"sha": "d279ed0a72db2fcfeceaf6dfe62b31da0caea69b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -3814,30 +3814,36 @@ add_pending_template (d)\n }\n \n \n-/* Return a TEMPLATE_ID_EXPR corresponding to the indicated FNS (which\n-   may be either a _DECL or an overloaded function or an\n-   IDENTIFIER_NODE), and ARGLIST.  */\n+/* Return a TEMPLATE_ID_EXPR corresponding to the indicated FNS and\n+   ARGLIST.  Valid choices for FNS are given in the cp-tree.def\n+   documentation for TEMPLATE_ID_EXPR.  */\n \n tree\n lookup_template_function (fns, arglist)\n      tree fns, arglist;\n {\n   tree type;\n \n+  if (fns == error_mark_node || arglist == error_mark_node)\n+    return error_mark_node;\n+\n   if (fns == NULL_TREE)\n     {\n       error (\"non-template used as template\");\n       return error_mark_node;\n     }\n \n+  my_friendly_assert (TREE_CODE (fns) == TEMPLATE_DECL\n+\t\t      || TREE_CODE (fns) == OVERLOAD\n+\t\t      || TREE_CODE (fns) == IDENTIFIER_NODE\n+\t\t      || TREE_CODE (fns) == LOOKUP_EXPR,\n+\t\t      20020730);\n+\n   type = TREE_TYPE (fns);\n   if (TREE_CODE (fns) == OVERLOAD || !type)\n     type = unknown_type_node;\n-\n-  if (processing_template_decl)\n-    return build_min (TEMPLATE_ID_EXPR, type, fns, arglist);  \n-  else\n-    return build (TEMPLATE_ID_EXPR, type, fns, arglist);\n+  \n+  return build (TEMPLATE_ID_EXPR, type, fns, arglist);\n }\n \n /* Within the scope of a template class S<T>, the name S gets bound\n@@ -8012,8 +8018,7 @@ type_unification_real (tparms, targs, xparms, xargs, subr,\n   my_friendly_assert (TREE_CODE (tparms) == TREE_VEC, 289);\n   my_friendly_assert (xparms == NULL_TREE \n \t\t      || TREE_CODE (xparms) == TREE_LIST, 290);\n-  /* ARGS could be NULL (via a call from parse.y to\n-     build_x_function_call).  */\n+  /* ARGS could be NULL.  */\n   if (xargs)\n     my_friendly_assert (TREE_CODE (xargs) == TREE_LIST, 291);\n   my_friendly_assert (ntparms > 0, 292);"}, {"sha": "48c4f8fbe46f6ec05dd7a690743a73453f2df306", "filename": "gcc/cp/search.c", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -310,6 +310,7 @@ lookup_base (t, base, access, kind_ptr)\n      base_kind *kind_ptr;\n {\n   tree binfo = NULL;\t\t/* The binfo we've found so far. */\n+  tree t_binfo = NULL;\n   base_kind bk;\n   \n   if (t == error_mark_node || base == error_mark_node)\n@@ -318,13 +319,21 @@ lookup_base (t, base, access, kind_ptr)\n \t*kind_ptr = bk_not_base;\n       return error_mark_node;\n     }\n-  my_friendly_assert (TYPE_P (t) && TYPE_P (base), 20011127);\n+  my_friendly_assert (TYPE_P (base), 20011127);\n   \n+  if (!TYPE_P (t))\n+    {\n+      t_binfo = t;\n+      t = BINFO_TYPE (t);\n+    }\n+  else \n+    t_binfo = TYPE_BINFO (t);\n+\n   /* Ensure that the types are instantiated.  */\n   t = complete_type (TYPE_MAIN_VARIANT (t));\n   base = complete_type (TYPE_MAIN_VARIANT (base));\n   \n-  bk = lookup_base_r (TYPE_BINFO (t), base, access & ~ba_quiet,\n+  bk = lookup_base_r (t_binfo, base, access & ~ba_quiet,\n \t\t      0, 0, 0, &binfo);\n \n   switch (bk)\n@@ -1361,6 +1370,32 @@ lookup_field_r (binfo, data)\n   return NULL_TREE;\n }\n \n+/* Return a \"baselink\" which BASELINK_BINFO, BASELINK_ACCESS_BINFO,\n+   BASELINK_FUNCTIONS, and BASELINK_OPTYPE set to BINFO, ACCESS_BINFO,\n+   FUNCTIONS, and OPTYPE respectively.  */\n+\n+tree\n+build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n+{\n+  tree baselink;\n+\n+  my_friendly_assert (TREE_CODE (functions) == FUNCTION_DECL\n+\t\t      || TREE_CODE (functions) == TEMPLATE_DECL\n+\t\t      || TREE_CODE (functions) == TEMPLATE_ID_EXPR\n+\t\t      || TREE_CODE (functions) == OVERLOAD,\n+\t\t      20020730);\n+  my_friendly_assert (!optype || TYPE_P (optype), 20020730);\n+\n+  baselink = build_tree_list (NULL_TREE, NULL_TREE);\n+  SET_BASELINK_P (baselink);\n+  BASELINK_BINFO (baselink) = binfo;\n+  BASELINK_ACCESS_BINFO (baselink) = access_binfo;\n+  BASELINK_FUNCTIONS (baselink) = functions;\n+  BASELINK_OPTYPE (baselink) = optype;\n+\n+  return baselink;\n+}\n+\n /* Look for a member named NAME in an inheritance lattice dominated by\n    XBASETYPE.  If PROTECT is 0 or two, we do not check access.  If it is\n    1, we enforce accessibility.  If PROTECT is zero, then, for an\n@@ -1470,19 +1505,9 @@ lookup_member (xbasetype, name, protect, want_type)\n \t\t\t\t\t\tTREE_TYPE (rval)));\n \n   if (rval && is_overloaded_fn (rval)) \n-    {\n-      /* Note that the binfo we put in the baselink is the binfo where\n-\t we found the functions, which we need for overload\n-\t resolution, but which should not be passed to enforce_access;\n-\t rather, enforce_access wants a binfo which refers to the\n-\t scope in which we started looking for the function.  This\n-\t will generally be the binfo passed into this function as\n-\t xbasetype.  */\n-\n-      rval = tree_cons (rval_binfo, rval, NULL_TREE);\n-      SET_BASELINK_P (rval);\n-    }\n-\n+    rval = build_baselink (rval_binfo, basetype_path, rval,\n+\t\t\t   (IDENTIFIER_TYPENAME_P (name)\n+\t\t\t   ? TREE_TYPE (name): NULL_TREE));\n   return rval;\n }\n "}, {"sha": "7098aae6c3e2de33c0e0770a7411e02bba286863", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 74, "deletions": 45, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -1242,32 +1242,86 @@ finish_stmt_expr (rtl_expr)\n   return result;\n }\n \n-/* Finish a call to FN with ARGS.  Returns a representation of the\n-   call.  */\n+/* Generate an expression for `FN (ARGS)'.\n+\n+   If DISALLOW_VIRTUAL is true, the call to FN will be not generated\n+   as a virtual call, even if FN is virtual.  (This flag is set when\n+   encountering an expression where the function name is explicitly\n+   qualified.  For example a call to `X::f' never generates a virtual\n+   call.)\n+\n+   Returns code for the call.  */\n \n tree \n-finish_call_expr (fn, args, koenig)\n-     tree fn;\n-     tree args;\n-     int koenig;\n+finish_call_expr (tree fn, tree args, bool disallow_virtual)\n {\n-  tree result;\n+  if (fn == error_mark_node || args == error_mark_node)\n+    return error_mark_node;\n+\n+  if (processing_template_decl)\n+    return build_nt (CALL_EXPR, fn, args, NULL_TREE);\n \n-  if (koenig)\n+  /* ARGS should be a list of arguments.  */\n+  my_friendly_assert (!args || TREE_CODE (args) == TREE_LIST,\n+\t\t      20020712);\n+\n+  if (BASELINK_P (fn))\n     {\n-      if (TREE_CODE (fn) == BIT_NOT_EXPR)\n-\tfn = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND (fn, 0));\n-      else if (TREE_CODE (fn) != TEMPLATE_ID_EXPR)\n-\tfn = do_identifier (fn, 2, args);\n-    }\n-  result = build_x_function_call (fn, args, current_class_ref);\n+      tree object;\n+\n+      /* A call to a member function.  From [over.call.func]:\n+\n+\t   If the keyword this is in scope and refers to the class of\n+\t   that member function, or a derived class thereof, then the\n+\t   function call is transformed into a qualified function call\n+\t   using (*this) as the postfix-expression to the left of the\n+\t   . operator.... [Otherwise] a contrived object of type T\n+\t   becomes the implied object argument.  \n+\n+        This paragraph is unclear about this situation:\n+\n+\t  struct A { void f(); };\n+\t  struct B : public A {};\n+\t  struct C : public A { void g() { B::f(); }};\n+\n+\tIn particular, for `B::f', this paragraph does not make clear\n+\twhether \"the class of that member function\" refers to `A' or \n+\tto `B'.  We believe it refers to `B'.  */\n+      if (current_class_type \n+\t  && DERIVED_FROM_P (BINFO_TYPE (BASELINK_ACCESS_BINFO (fn)),\n+\t\t\t     current_class_type)\n+\t  && current_class_ref)\n+\tobject = current_class_ref;\n+      else\n+\t{\n+\t  tree representative_fn;\n \n-  if (TREE_CODE (result) == CALL_EXPR\n-      && (! TREE_TYPE (result)\n-          || TREE_CODE (TREE_TYPE (result)) != VOID_TYPE))\n-    result = require_complete_type (result);\n+\t  representative_fn = BASELINK_FUNCTIONS (fn);\n+\t  if (TREE_CODE (representative_fn) == TEMPLATE_ID_EXPR)\n+\t    representative_fn = TREE_OPERAND (representative_fn, 0);\n+\t  representative_fn = get_first_fn (representative_fn);\n+\t  object = build_dummy_object (DECL_CONTEXT (representative_fn));\n+\t}\n \n-  return result;\n+      return build_new_method_call (object, fn, args, NULL_TREE,\n+\t\t\t\t    (disallow_virtual \n+\t\t\t\t     ? LOOKUP_NONVIRTUAL : 0));\n+    }\n+  else if (is_overloaded_fn (fn))\n+    /* A call to a namespace-scope function.  */\n+    return build_new_function_call (fn, args);\n+  else if (CLASS_TYPE_P (TREE_TYPE (fn)))\n+    {\n+      /* If the \"function\" is really an object of class type, it might\n+\t have an overloaded `operator ()'.  */\n+      tree result;\n+      result = build_opfncall (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE);\n+      if (result)\n+\treturn result;\n+    }\n+\n+  /* A call where the function is unknown.  */\n+  return build_function_call (fn, args);\n }\n \n /* Finish a call to a postfix increment or decrement or EXPR.  (Which\n@@ -1327,14 +1381,6 @@ finish_object_call_expr (fn, object, args)\n      tree object;\n      tree args;\n {\n-#if 0\n-  /* This is a future direction of this code, but because\n-     build_x_function_call cannot always undo what is done in\n-     build_component_ref entirely yet, we cannot do this.  */\n-\n-  tree real_fn = build_component_ref (object, fn, NULL_TREE, 1);\n-  return finish_call_expr (real_fn, args);\n-#else\n   if (DECL_DECLARES_TYPE_P (fn))\n     {\n       if (processing_template_decl)\n@@ -1353,9 +1399,8 @@ finish_object_call_expr (fn, object, args)\n \t  return error_mark_node;\n \t}\n     }\n-\n+  \n   return build_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n-#endif\n }\n \n /* Finish a qualified member function call using OBJECT and ARGS as\n@@ -1396,22 +1441,6 @@ finish_pseudo_destructor_call_expr (object, scope, destructor)\n   return cp_convert (void_type_node, object);\n }\n \n-/* Finish a call to a globally qualified member function FN using\n-   ARGS.  Returns an expression for the call.  */\n-\n-tree \n-finish_qualified_call_expr (fn, args)\n-     tree fn;\n-     tree args;\n-{\n-  if (processing_template_decl)\n-    return build_min_nt (CALL_EXPR, fn, args, NULL_TREE);\n-  else\n-    return build_member_call (TREE_OPERAND (fn, 0),\n-\t\t\t      TREE_OPERAND (fn, 1),\n-\t\t\t      args);\n-}\n-\n /* Finish an expression of the form CODE EXPR.  */\n \n tree"}, {"sha": "def5e687509b0b5904b1658b19678052cdcbd6e4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 307, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -2455,309 +2455,6 @@ build_array_ref (array, idx)\n   }\n }\n \f\n-/* Build a function call to function FUNCTION with parameters PARAMS.\n-   PARAMS is a list--a chain of TREE_LIST nodes--in which the\n-   TREE_VALUE of each node is a parameter-expression.  The PARAMS do\n-   not include any object pointer that may be required.  FUNCTION's\n-   data type may be a function type or a pointer-to-function.\n-\n-   For C++: If FUNCTION's data type is a TREE_LIST, then the tree list\n-   is the list of possible methods that FUNCTION could conceivably\n-   be.  If the list of methods comes from a class, then it will be\n-   a list of lists (where each element is associated with the class\n-   that produced it), otherwise it will be a simple list (for\n-   functions overloaded in global scope).\n-\n-   In the first case, TREE_VALUE (function) is the head of one of those\n-   lists, and TREE_PURPOSE is the name of the function.\n-\n-   In the second case, TREE_PURPOSE (function) is the function's\n-   name directly.\n-\n-   DECL is the class instance variable, usually CURRENT_CLASS_REF.\n-\n-   When calling a TEMPLATE_DECL, we don't require a complete return\n-   type.  */\n-\n-tree\n-build_x_function_call (function, params, decl)\n-     tree function, params, decl;\n-{\n-  tree type;\n-  tree template_id = NULL_TREE;\n-  int is_method;\n-\n-  if (function == error_mark_node)\n-    return error_mark_node;\n-\n-  if (processing_template_decl)\n-    return build_min_nt (CALL_EXPR, function, params, NULL_TREE);\n-\n-  /* Save explicit template arguments if found */\n-  if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n-    {\n-      template_id = function;\n-      function = TREE_OPERAND (function, 0);\n-    }\n-\n-  type = TREE_TYPE (function);\n-\n-  if (TREE_CODE (type) == OFFSET_TYPE\n-      && TREE_TYPE (type) == unknown_type_node\n-      && TREE_CODE (function) == TREE_LIST\n-      && TREE_CHAIN (function) == NULL_TREE)\n-    {\n-      /* Undo (Foo:bar)()...  */\n-      type = TYPE_OFFSET_BASETYPE (type);\n-      function = TREE_VALUE (function);\n-      my_friendly_assert (TREE_CODE (function) == TREE_LIST, 999);\n-      my_friendly_assert (TREE_CHAIN (function) == NULL_TREE, 999);\n-      function = TREE_VALUE (function);\n-      if (TREE_CODE (function) == OVERLOAD)\n-\tfunction = OVL_FUNCTION (function);\n-      my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 999);\n-      function = DECL_NAME (function);\n-      return build_method_call (decl, function, params,\n-\t\t\t\tTYPE_BINFO (type), LOOKUP_NORMAL);\n-    }\n-    \n-  if (TREE_CODE (function) == OFFSET_REF\n-      && TREE_CODE (type) != METHOD_TYPE)\n-    function = resolve_offset_ref (function);\n-\n-  if ((TREE_CODE (function) == FUNCTION_DECL\n-       && DECL_STATIC_FUNCTION_P (function))\n-      || (DECL_FUNCTION_TEMPLATE_P (function)\n-\t  && DECL_STATIC_FUNCTION_P (DECL_TEMPLATE_RESULT (function))))\n-      return build_member_call (DECL_CONTEXT (function), \n-\t\t\t\ttemplate_id \n-\t\t\t\t? template_id : DECL_NAME (function), \n-\t\t\t\tparams);\n-\n-  is_method = ((TREE_CODE (function) == TREE_LIST\n-\t\t&& current_class_type != NULL_TREE\n-\t\t&& (IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (function))\n-\t\t    == function))\n-\t       || (TREE_CODE (function) == OVERLOAD\n-\t\t   && DECL_FUNCTION_MEMBER_P (OVL_CURRENT (function)))\n-\t       || TREE_CODE (function) == IDENTIFIER_NODE\n-\t       || TREE_CODE (type) == METHOD_TYPE\n-\t       || TYPE_PTRMEMFUNC_P (type));\n-\n-  /* A friend template.  Make it look like a toplevel declaration.  */\n-  if (! is_method && TREE_CODE (function) == TEMPLATE_DECL)\n-    function = ovl_cons (function, NULL_TREE);\n-\n-  /* Handle methods, friends, and overloaded functions, respectively.  */\n-  if (is_method)\n-    {\n-      tree basetype = NULL_TREE;\n-\n-      if (TREE_CODE (function) == OVERLOAD)\n-\tfunction = OVL_CURRENT (function);\n-\n-      if (TREE_CODE (function) == FUNCTION_DECL\n-\t  || DECL_FUNCTION_TEMPLATE_P (function))\n-\t{\n-\t  basetype = DECL_CONTEXT (function);\n-\n-\t  if (DECL_NAME (function))\n-\t    function = DECL_NAME (function);\n-\t  else\n-\t    function = TYPE_IDENTIFIER (DECL_CONTEXT (function));\n-\t}\n-      else if (TREE_CODE (function) == TREE_LIST)\n-\t{\n-\t  my_friendly_assert (TREE_CODE (TREE_VALUE (function))\n-\t\t\t      == FUNCTION_DECL, 312);\n-\t  basetype = DECL_CONTEXT (TREE_VALUE (function));\n-\t  function = TREE_PURPOSE (function);\n-\t}\n-      else if (TREE_CODE (function) != IDENTIFIER_NODE)\n-\t{\n-\t  if (TREE_CODE (function) == OFFSET_REF)\n-\t    {\n-\t      if (TREE_OPERAND (function, 0))\n-\t\tdecl = TREE_OPERAND (function, 0);\n-\t    }\n-\t  /* Call via a pointer to member function.  */\n-\t  if (decl == NULL_TREE)\n-\t    {\n-\t      error (\"pointer to member function called, but not in class scope\");\n-\t      return error_mark_node;\n-\t    }\n-\t  /* What other type of POINTER_TYPE could this be? */\n-\t  if (TREE_CODE (TREE_TYPE (function)) != POINTER_TYPE\n-\t      && ! TYPE_PTRMEMFUNC_P (TREE_TYPE (function))\n-\t      && TREE_CODE (function) != OFFSET_REF)\n-\t    function = build (OFFSET_REF, TREE_TYPE (type), NULL_TREE,\n-\t\t\t      function);\n-\t  goto do_x_function;\n-\t}\n-\n-      /* this is an abbreviated method call.\n-         must go through here in case it is a virtual function.\n-\t @@ Perhaps this could be optimized.  */\n-\n-      if (basetype && (! current_class_type\n-\t\t       || ! DERIVED_FROM_P (basetype, current_class_type)))\n-\treturn build_member_call (basetype, function, params);\n-\n-      if (decl == NULL_TREE)\n-\t{\n-\t  if (current_class_type == NULL_TREE)\n-\t    {\n-\t      error (\"object missing in call to method `%D'\", function);\n-\t      return error_mark_node;\n-\t    }\n-\t  /* Yow: call from a static member function.  */\n-\t  decl = build_dummy_object (current_class_type);\n-\t}\n-\n-      /* Put back explicit template arguments, if any.  */\n-      if (template_id)\n-        function = template_id;\n-      return build_method_call (decl, function, params,\n-\t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n-    }\n-  else if (TREE_CODE (function) == COMPONENT_REF\n-\t   && type == unknown_type_node)\n-    {\n-      /* Undo what we did in build_component_ref.  */\n-      decl = TREE_OPERAND (function, 0);\n-      function = TREE_OPERAND (function, 1);\n-\n-      if (TREE_CODE (function) == OVERLOAD\n- \t  && TREE_TYPE (function) != unknown_type_node)\n- \t/* It was a conversion operator. We can't use DECL_NAME, as\n- \t   that might refer to a templated function.  */\n-\tfunction = mangle_conv_op_name_for_type (TREE_TYPE (function));\n-      else if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n-\t{\n-\t  my_friendly_assert (!template_id, 20011228);\n-\n-\t  template_id = function;\n-\t}\n-      else\n-\t{\n-\t  function = DECL_NAME (OVL_CURRENT (function));\n-\n-\t  if (template_id)\n-\t    {\n-\t      TREE_OPERAND (template_id, 0) = function;\n-\t      function = template_id;\n-\t    }\n-\t}\n-\n-      return build_method_call (decl, function, params,\n-\t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n-    }\n-  else if (really_overloaded_fn (function))\n-    {\n-      if (OVL_FUNCTION (function) == NULL_TREE)\n-\t{\n-\t  error (\"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?\",\n-\t\t    TREE_PURPOSE (function));\n-\t  return error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  /* Put back explicit template arguments, if any.  */\n-\t  if (template_id)\n-\t    function = template_id;\n-\t  return build_new_function_call (function, params);\n-\t}\n-    }\n-  else\n-    /* Remove a potential OVERLOAD around it */\n-    function = OVL_CURRENT (function);\n-\n- do_x_function:\n-  if (TREE_CODE (function) == OFFSET_REF)\n-    {\n-      /* If the component is a data element (or a virtual function), we play\n-\t games here to make things work.  */\n-      tree decl_addr;\n-\n-      if (TREE_OPERAND (function, 0))\n-\tdecl = TREE_OPERAND (function, 0);\n-      else\n-\tdecl = current_class_ref;\n-\n-      decl_addr = build_unary_op (ADDR_EXPR, decl, 0);\n-\n-      /* Sigh.  OFFSET_REFs are being used for too many things.\n-\t They're being used both for -> and ->*, and we want to resolve\n-\t the -> cases here, but leave the ->*.  We could use\n-\t resolve_offset_ref for those, too, but it would call\n-         get_member_function_from_ptrfunc and decl_addr wouldn't get\n-         updated properly.  Nasty.  */\n-      if (TREE_CODE (TREE_OPERAND (function, 1)) == FIELD_DECL)\n-\tfunction = resolve_offset_ref (function);\n-      else\n-\tfunction = TREE_OPERAND (function, 1);\n-\n-      function = get_member_function_from_ptrfunc (&decl_addr, function);\n-      params = tree_cons (NULL_TREE, decl_addr, params);\n-      return build_function_call (function, params);\n-    }\n-\n-  type = TREE_TYPE (function);\n-  if (type != error_mark_node)\n-    {\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\ttype = TREE_TYPE (type);\n-\n-      if (IS_AGGR_TYPE (type))\n-\treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL, function, params, NULL_TREE);\n-    }\n-\n-  if (is_method)\n-    {\n-      tree fntype = TREE_TYPE (function);\n-      tree ctypeptr = NULL_TREE;\n-\n-      /* Explicitly named method?  */\n-      if (TREE_CODE (function) == FUNCTION_DECL)\n-\tctypeptr = build_pointer_type (DECL_CLASS_CONTEXT (function));\n-      /* Expression with ptr-to-method type?  It could either be a plain\n-\t usage, or it might be a case where the ptr-to-method is being\n-\t passed in as an argument.  */\n-      else if (TYPE_PTRMEMFUNC_P (fntype))\n-\t{\n-\t  tree rec = TYPE_METHOD_BASETYPE (TREE_TYPE\n-\t\t\t\t\t   (TYPE_PTRMEMFUNC_FN_TYPE (fntype)));\n-\t  ctypeptr = build_pointer_type (rec);\n-\t}\n-      /* Unexpected node type?  */\n-      else\n-\tabort ();\n-      if (decl == NULL_TREE)\n-\t{\n-\t  if (current_function_decl\n-\t      && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\t    error (\"invalid call to member function needing `this' in static member function scope\");\n-\t  else\n-\t    error (\"pointer to member function called, but not in class scope\");\n-\t  return error_mark_node;\n-\t}\n-      if (TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE\n-\t  && ! TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))\n-\t{\n-\t  tree binfo = lookup_base (TREE_TYPE (decl), TREE_TYPE (ctypeptr),\n-\t\t\t\t    ba_check, NULL);\n-\t  \n-\t  decl = build_unary_op (ADDR_EXPR, decl, 0);\n-\t  decl = build_base_path (PLUS_EXPR, decl, binfo, 1);\n-\t}\n-      else\n-\tdecl = build_c_cast (ctypeptr, decl);\n-      params = tree_cons (NULL_TREE, decl, params);\n-    }\n-\n-  return build_function_call (function, params);\n-}\n-\n /* Resolve a pointer to member function.  INSTANCE is the object\n    instance to use, if the member points to a virtual member.\n \n@@ -4928,7 +4625,7 @@ build_static_cast (type, expr)\n \t\t\t\t   LOOKUP_COMPLAIN, NULL_TREE)));\n \n   if (IS_AGGR_TYPE (type))\n-    return build_cplus_new (type, (build_method_call\n+    return build_cplus_new (type, (build_special_member_call\n \t\t\t\t   (NULL_TREE, complete_ctor_identifier, \n \t\t\t\t    build_tree_list (NULL_TREE, expr),\n \t\t\t\t    TYPE_BINFO (type), LOOKUP_NORMAL)));\n@@ -5431,9 +5128,10 @@ build_modify_expr (lhs, modifycode, rhs)\n \t/* Do the default thing */;\n       else\n \t{\n-\t  result = build_method_call (lhs, complete_ctor_identifier,\n-\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n-\t\t\t\t      TYPE_BINFO (lhstype), LOOKUP_NORMAL);\n+\t  result = build_special_member_call (lhs, complete_ctor_identifier,\n+\t\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n+\t\t\t\t\t      TYPE_BINFO (lhstype), \n+\t\t\t\t\t      LOOKUP_NORMAL);\n \t  if (result == NULL_TREE)\n \t    return error_mark_node;\n \t  return result;"}, {"sha": "fac68e917d6ef28568183fd829aa84dcd8e8598a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -1309,8 +1309,8 @@ build_functional_cast (exp, parms)\n       return get_target_expr (exp);\n     }\n \n-  exp = build_method_call (NULL_TREE, complete_ctor_identifier, parms,\n-\t\t\t   TYPE_BINFO (type), LOOKUP_NORMAL);\n+  exp = build_special_member_call (NULL_TREE, complete_ctor_identifier, parms,\n+\t\t\t\t   TYPE_BINFO (type), LOOKUP_NORMAL);\n \n   if (exp == error_mark_node)\n     return error_mark_node;"}, {"sha": "864248be1c51bf6a17f687a544f3ac1af6a0bc59", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -1,4 +1,11 @@\n-2002-07-26  Neil Booth  <neil@daikokuya.co.uk>\n+2002-07-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/inherit/operator1.C: New test.\n+\t* g++.dg/lookup/disamb1.C: Fix typo in comment.\n+\t* g++.dg/other/error1.C: Change expected error message.\n+\t* g++.dg/template/conv4.C: Likewise.\n+\t\n+2002-07-26  Neil Booth  <neil@daikokuya.cop.uk>\n \n \t* gcc.dg/cpp/trad/Wunused.c, gcc.dg/cpp/Wunused.c: Add test\n \tfor documented behaviour."}, {"sha": "1e44d939e2e3860515a3f3ef8f3ece77dc3826cb", "filename": "gcc/testsuite/README.QMTEST", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2FREADME.QMTEST", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2FREADME.QMTEST", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FREADME.QMTEST?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -113,11 +113,12 @@ Here are some more advanced usage instructions:\n 1. To run a particular set of tests (rather than all of the tests),\n    use the make variable \"QMTEST_GPP_TESTS\".  For example, \n \n-     make QMTEST_GPP_TESTS=\"gpp.dg\" qmtest-g++\n+     make QMTEST_GPP_TESTS=\"g++.dg\" qmtest-g++\n \n    will run only the tests in the g++.dg subdirectory, and:\n \n-     make QMTEST_GPP_TESTS=\"gpp.dg.special.conpr1 gpp.old-deja.other.access2\"\n+     make QMTEST_GPP_TESTS=\"g++.dg/special/conpr1.C \\\n+                            g++.old-deja/g++.other/access2.C\"\n           qmtest-g++\n \n    will run only the two tests indicated."}, {"sha": "6ef669c219e6ac71cee1082d5ac65fcff0ccfd50", "filename": "gcc/testsuite/g++.dg/inherit/operator1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Foperator1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Foperator1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Foperator1.C?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -0,0 +1,34 @@\n+// Test that conversions to base classes happen when calling\n+// operators.\n+\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+struct B1;\n+struct B2;\n+\n+B2* p;\n+B1* p2;\n+\n+struct B1 {\n+  virtual void f () {}\n+};\n+\n+struct B2 {\n+  int i;\n+  bool operator!() { if (this != p) abort (); return true; }\n+  operator void*() { if (this != p) abort (); return this; }\n+};\n+\n+struct B3 : public B1, public B2 {\n+};\n+\n+int main () {\n+  B3 b;\n+  p = (B2*) &b;\n+  p2 = (B1*) &b;\n+  bool b1 = b;\n+  bool b2 = !b;\n+}\n+"}, {"sha": "638eb2fcdca9d0e5a7ce50d4f13b244f2e876fa5", "filename": "gcc/testsuite/g++.dg/lookup/disamb1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdisamb1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdisamb1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdisamb1.C?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -1,5 +1,5 @@\n // PR c++/525\n-// Bug: With -pedantic, we weren't converting this to D1* for the call.\n+// Bug: With -pedantic, we weren't converting this to B1* for the call.\n \n struct A\n {"}, {"sha": "a55fcc60cf6ed64664066f236d55ad27ceee8e2e", "filename": "gcc/testsuite/g++.dg/other/error1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror1.C?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -1,6 +1,6 @@\n // { dg-do compile }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 18 Dec 2001 <nathan@nathan@codesourcery.com>\n \n // PR 90, stupid error message `(this + 160)'\n@@ -10,6 +10,6 @@ class foo {\n   int fudge[40];\n   int bar [40];\n   inline int access(int i) {\n-    return bar(i);  // { dg-error \"`this->foo::bar' cannot\" \"\" }\n+    return bar(i);  // { dg-error \"call to non-function `foo::bar'\" \"\" }\n   }\n };"}, {"sha": "01f158aeff3a8811dc125822dd74145a1d9a51fb", "filename": "gcc/testsuite/g++.dg/template/conv4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba126e468db5a4a6fa07d1b9483bc8f0562833b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv4.C?ref=4ba126e468db5a4a6fa07d1b9483bc8f0562833b", "patch": "@@ -1,6 +1,6 @@\n // { dg-do compile }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 29 Dec 2001 <nathan@codesourcery.com>\n \n // PR 4361. Template conversion operators were not overloaded.\n@@ -21,7 +21,7 @@ struct D\n {\n   int Foo ()\n   {\n-    return operator int (); // { dg-error \"no matching function\" \"\" }\n+    return operator int (); // { dg-error \"not defined\" \"\" }\n   }\n };\n "}]}