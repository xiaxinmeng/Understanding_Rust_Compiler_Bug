{"sha": "4262e6231adab0ff8a3da565bf620037ce9b1343", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI2MmU2MjMxYWRhYjBmZjhhM2RhNTY1YmY2MjAwMzdjZTliMTM0Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-11T16:58:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-11T16:58:57Z"}, "message": "basic-block.h (EDGE_CRITICAL): Remove; renumber other flags.\n\n\t* basic-block.h (EDGE_CRITICAL): Remove; renumber other flags.\n\t(EDGE_CRITICAL_P): New predicate.\n\t* cfg.c (force_nonfallthru_and_redirect, split_edge): Kill EDGE_CRITICAL\n\thandling.\n\t(insert_insn_on_edge): Use EDGE_CRITICAL_P.\n\t(dump_edge_info): Remove \"crit\".\n\t* cfganal.c (mark_critical_edges): Kill.\n\t* cfgbuild.c (find_basic_blocks): Remove mark_critical_edges call.\n\t* cfgcleanup.c (cleanup_cfg): Likewise.\n\t* profile.c (instrument_edges): Use EDGE_CRITICAL_P.\n\t(find_spanning_tree): Likewise.\n\t* reg-stack.c (convert_regs_1): Likewise.\n\t* ssa.c (mark_regs_equivalent_over_bad_edges): Likewise.\n\n\t* basic-block.h (create_basic_block_structure): New.\n\t(create_basic_block): Update prototype.\n\t(force_nonfallthru): New.\n\t* bb-reorder.c (fixup_reorder_chain): Fixup use force_nonfallthru.\n\t* cfg.c (create_basic_block_structure): Rename from create_basic_block;\n\thandle updating of block_for_insn, creating of empty BBs and BBs at\n\tthe end of INSN chain.\n\t(create_basic_block): New function.\n\t(split_block): Use create_basic_block.\n\t(force_nonfallthru_and_redirect): Break out from ...; cleanup\n\t(redirect_edge_and_branch_force): ... here.\n\t(force_nonfallthru): New.\n\t(split_edge): Rewrite to use force_nonfallthru and create_block.\n\t* cfgbuild.c (find_basic_blocks_1): Use create_basic_block_structure.\n\t(find_basic_blocks): Free basic_block_for_insn.\n\t* cfgcleanup.c (merge_blocks): Use force_nonfallthru.\n\n\t* cfg.c: Fix formating.\n\t* cfgcleanup.c: Fix formating.\n\t(merge_blocks, tail_recursion_label_p): Return bool.\n\t(merge_blocks_move_predecessor_nojumps,\n\t merge_blocks_move_successor_nojumps): Return void.\n\nFrom-SVN: r45549", "tree": {"sha": "e55ae3fa06b243cd5fe8bf5b133011184ac58d17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e55ae3fa06b243cd5fe8bf5b133011184ac58d17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4262e6231adab0ff8a3da565bf620037ce9b1343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4262e6231adab0ff8a3da565bf620037ce9b1343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4262e6231adab0ff8a3da565bf620037ce9b1343", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4262e6231adab0ff8a3da565bf620037ce9b1343/comments", "author": null, "committer": null, "parents": [{"sha": "201556f0e005802b8ebb206a193a6feb55a555af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201556f0e005802b8ebb206a193a6feb55a555af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/201556f0e005802b8ebb206a193a6feb55a555af"}], "stats": {"total": 723, "additions": 292, "deletions": 431}, "files": [{"sha": "74f3fe36b594c2c840368a63dd53e20b7450b895", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -1,3 +1,42 @@\n+Tue Sep 11 18:57:47 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (EDGE_CRITICAL): Remove; renumber other flags.\n+\t(EDGE_CRITICAL_P): New predicate.\n+\t* cfg.c (force_nonfallthru_and_redirect, split_edge): Kill EDGE_CRITICAL\n+\thandling.\n+\t(insert_insn_on_edge): Use EDGE_CRITICAL_P.\n+\t(dump_edge_info): Remove \"crit\".\n+\t* cfganal.c (mark_critical_edges): Kill.\n+\t* cfgbuild.c (find_basic_blocks): Remove mark_critical_edges call.\n+\t* cfgcleanup.c (cleanup_cfg): Likewise.\n+\t* profile.c (instrument_edges): Use EDGE_CRITICAL_P.\n+\t(find_spanning_tree): Likewise.\n+\t* reg-stack.c (convert_regs_1): Likewise.\n+\t* ssa.c (mark_regs_equivalent_over_bad_edges): Likewise.\n+\n+\t* basic-block.h (create_basic_block_structure): New.\n+\t(create_basic_block): Update prototype.\n+\t(force_nonfallthru): New.\n+\t* bb-reorder.c (fixup_reorder_chain): Fixup use force_nonfallthru.\n+\t* cfg.c (create_basic_block_structure): Rename from create_basic_block;\n+\thandle updating of block_for_insn, creating of empty BBs and BBs at\n+\tthe end of INSN chain.\n+\t(create_basic_block): New function.\n+\t(split_block): Use create_basic_block.\n+\t(force_nonfallthru_and_redirect): Break out from ...; cleanup\n+\t(redirect_edge_and_branch_force): ... here.\n+\t(force_nonfallthru): New.\n+\t(split_edge): Rewrite to use force_nonfallthru and create_block.\n+\t* cfgbuild.c (find_basic_blocks_1): Use create_basic_block_structure.\n+\t(find_basic_blocks): Free basic_block_for_insn.\n+\t* cfgcleanup.c (merge_blocks): Use force_nonfallthru.\n+\n+\t* cfg.c: Fix formating.\n+\t* cfgcleanup.c: Fix formating.\n+\t(merge_blocks, tail_recursion_label_p): Return bool.\n+\t(merge_blocks_move_predecessor_nojumps,\n+\t merge_blocks_move_successor_nojumps): Return void.\n+\n 2001-09-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* configure.in: Check whether assembler supports section merging."}, {"sha": "95ee0dd61969ee6596aad989787d7eb252a0748e", "filename": "gcc/basic-block.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -140,12 +140,11 @@ typedef struct edge_def {\n } *edge;\n \n #define EDGE_FALLTHRU\t\t1\n-#define EDGE_CRITICAL\t\t2\n-#define EDGE_ABNORMAL\t\t4\n-#define EDGE_ABNORMAL_CALL\t8\n-#define EDGE_EH\t\t\t16\n-#define EDGE_FAKE\t\t32\n-#define EDGE_DFS_BACK\t\t64\n+#define EDGE_ABNORMAL\t\t2\n+#define EDGE_ABNORMAL_CALL\t4\n+#define EDGE_EH\t\t\t8\n+#define EDGE_FAKE\t\t16\n+#define EDGE_DFS_BACK\t\t32\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n@@ -315,7 +314,8 @@ extern void remove_edge\t\t\tPARAMS ((edge));\n extern void redirect_edge_succ\t\tPARAMS ((edge, basic_block));\n extern edge redirect_edge_succ_nodup\tPARAMS ((edge, basic_block));\n extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n-extern void create_basic_block\t\tPARAMS ((int, rtx, rtx, rtx));\n+extern basic_block create_basic_block_structure PARAMS ((int, rtx, rtx, rtx));\n+extern basic_block create_basic_block\tPARAMS ((int, rtx, rtx));\n extern int flow_delete_block\t\tPARAMS ((basic_block));\n extern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\n extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n@@ -536,6 +536,10 @@ struct edge_list\n \t\t\t\t\t  + REG_BR_PROB_BASE / 2) \\\n \t\t\t\t\t / REG_BR_PROB_BASE)\n \n+/* Return nonzero if edge is critical.  */\n+#define EDGE_CRITICAL_P(e)\t\t((e)->src->succ->succ_next \\\n+\t\t\t\t\t && (e)->dest->pred->pred_next)\n+\n struct edge_list * create_edge_list\tPARAMS ((void));\n void free_edge_list\t\t\tPARAMS ((struct edge_list *));\n void print_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));\n@@ -629,6 +633,7 @@ extern void allocate_bb_life_data\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n extern void delete_noop_moves\t\tPARAMS ((rtx));\n extern basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n+extern basic_block force_nonfallthru\tPARAMS ((edge));\n extern bool redirect_edge_and_branch\tPARAMS ((edge, basic_block));\n extern rtx block_label\t\t\tPARAMS ((basic_block));\n extern bool forwarder_block_p\t\tPARAMS ((basic_block));"}, {"sha": "f51294b6d44f657387715ab386a85f49eeb78b57", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -610,7 +610,7 @@ fixup_reorder_chain ()\n   for (bb = BASIC_BLOCK (0); bb ; bb = RBI (bb)->next)\n     {\n       edge e_fall, e_taken, e;\n-      rtx jump_insn, barrier_insn, bb_end_insn;\n+      rtx bb_end_insn;\n       basic_block nb;\n \n       if (bb->succ == NULL)\n@@ -698,54 +698,24 @@ fixup_reorder_chain ()\n \t  /* An fallthru to exit block.  */\n \t  if (!RBI (bb)->next && e_fall->dest == EXIT_BLOCK_PTR)\n \t    continue;\n-\n-\t  /* We need a new jump insn.  If the block has only one outgoing\n-\t     edge, then we can stuff the new jump insn in directly.  */\n-\t  if (bb->succ->succ_next == NULL)\n-\t    {\n-\t      e_fall->flags &= ~EDGE_FALLTHRU;\n-\n-\t      jump_insn = emit_jump_to_block_after (e_fall->dest, bb_end_insn);\n-\t      bb->end = jump_insn;\n-\t      barrier_insn = emit_barrier_after (jump_insn);\n-\t      RBI (bb)->eff_end = barrier_insn;\n-\t      continue;\n-\t    }\n \t}\n \n-      /* We got here if we need to add a new jump insn in a new block\n-\t across the edge e_fall.  */\n-\n-      jump_insn = emit_jump_to_block_after (e_fall->dest, bb_end_insn);\n-      barrier_insn = emit_barrier_after (jump_insn);\n+      /* We got here if we need to add a new jump insn.  */\n \n-      VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n-      create_basic_block (n_basic_blocks - 1, jump_insn, jump_insn, NULL);\n+      nb = force_nonfallthru (e_fall);\n \n-      nb = BASIC_BLOCK (n_basic_blocks - 1);\n-      nb->local_set = 0;\n-      nb->count = e_fall->count;\n-      nb->frequency = EDGE_FREQUENCY (e_fall);\n-\n-      nb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      nb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      COPY_REG_SET (nb->global_live_at_start, bb->global_live_at_start);\n-      COPY_REG_SET (nb->global_live_at_end, bb->global_live_at_start);\n-\n-      nb->aux = xmalloc (sizeof (struct reorder_block_def));\n-      RBI (nb)->eff_head = nb->head;\n-      RBI (nb)->eff_end = barrier_insn;\n-      RBI (nb)->scope = RBI (bb)->scope;\n-      RBI (nb)->visited = 1;\n-      RBI (nb)->next = RBI (bb)->next;\n-      RBI (bb)->next = nb;\n-\n-      /* Link to new block.  */\n-      make_single_succ_edge (nb, e_fall->dest, 0);\n-      redirect_edge_succ (e_fall, nb);\n-\n-      /* Don't process this new block.  */\n-      bb = nb;\n+      if (nb)\n+\t{\n+\t  nb->aux = xmalloc (sizeof (struct reorder_block_def));\n+\t  RBI (nb)->eff_head = nb->head;\n+\t  RBI (nb)->eff_end = NEXT_INSN (nb->end);\n+\t  RBI (nb)->scope = RBI (bb)->scope;\n+\t  RBI (nb)->visited = 1;\n+\t  RBI (nb)->next = RBI (bb)->next;\n+\t  RBI (bb)->next = nb;\n+\t  /* Don't process this new block.  */\n+\t  bb = nb;\n+\t}\n     }\n \n   /* Put basic_block_info in the new order.  */"}, {"sha": "5ceff715063f9005f410e67b7a531e437d29b052", "filename": "gcc/cfg.c", "status": "modified", "additions": 173, "deletions": 258, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -40,7 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t - High level edge redirection (with updating and optimizing instruction\n \t   chain)\n \t     block_label, redirect_edge_and_branch,\n-\t     redirect_edge_and_branch_force, tidy_fallthru_edge\n+\t     redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n       - Edge splitting and commiting to edges\n \t  split_edge, insert_insn_on_edge, commit_edge_insertions\n       - Dumpipng and debugging\n@@ -147,6 +147,7 @@ static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n static void expunge_block\t\tPARAMS ((basic_block));\n static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n+static basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n \f\n /* Called once at intialization time.  */\n \n@@ -320,11 +321,16 @@ flow_delete_insn_chain (start, finish)\n }\n \f\n /* Create a new basic block consisting of the instructions between\n-   HEAD and END inclusive.  Reuses the note and basic block struct\n-   in BB_NOTE, if any.  */\n+   HEAD and END inclusive.  This function is designed to allow fast\n+   BB construction - reuses the note and basic block struct\n+   in BB_NOTE, if any and do not grow BASIC_BLOCK chain and should\n+   be used directly only by CFG construction code.\n+   END can be NULL in to create new empty basic block before HEAD.\n+   Both END and HEAD can be NULL to create basic block at the end of\n+   INSN chain.  */\n \n-void\n-create_basic_block (index, head, end, bb_note)\n+basic_block\n+create_basic_block_structure (index, head, end, bb_note)\n      int index;\n      rtx head, end, bb_note;\n {\n@@ -360,12 +366,23 @@ create_basic_block (index, head, end, bb_note)\n       bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n       memset (bb, 0, sizeof (*bb));\n \n-      if (GET_CODE (head) == CODE_LABEL)\n-\tbb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, head);\n+      if (!head && !end)\n+\t{\n+\t  head = end = bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK,\n+\t\t\t\t\t\t  get_last_insn ());\n+\t}\n+      else if (GET_CODE (head) == CODE_LABEL && end)\n+\t{\n+\t  bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, head);\n+\t  if (head == end)\n+\t    end = bb_note;\n+\t}\n       else\n \t{\n \t  bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK, head);\n \t  head = bb_note;\n+\t  if (!end)\n+\t    end = head;\n \t}\n       NOTE_BASIC_BLOCK (bb_note) = bb;\n     }\n@@ -378,10 +395,46 @@ create_basic_block (index, head, end, bb_note)\n   bb->end = end;\n   bb->index = index;\n   BASIC_BLOCK (index) = bb;\n+  if (basic_block_for_insn)\n+    update_bb_for_insn (bb);\n \n   /* Tag the block so that we know it has been used when considering\n      other basic block notes.  */\n   bb->aux = bb;\n+\n+  return bb;\n+}\n+\n+/* Create new basic block consisting of instructions in between HEAD and\n+   END and place it to the BB chain at possition INDEX.\n+   END can be NULL in to create new empty basic block before HEAD.\n+   Both END and HEAD can be NULL to create basic block at the end of\n+   INSN chain.  */\n+\n+basic_block\n+create_basic_block (index, head, end)\n+     int index;\n+     rtx head, end;\n+{\n+  basic_block bb;\n+  int i;\n+\n+  /* Place the new block just after the block being split.  */\n+  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+\n+  /* Some parts of the compiler expect blocks to be number in\n+     sequential order so insert the new block immediately after the\n+     block being split..  */\n+  for (i = n_basic_blocks - 1; i > index; --i)\n+    {\n+      basic_block tmp = BASIC_BLOCK (i - 1);\n+      BASIC_BLOCK (i) = tmp;\n+      tmp->index = i;\n+    }\n+\n+  bb = create_basic_block_structure (index, head, end, NULL);\n+  bb->aux = NULL;\n+  return bb;\n }\n \n /* Remove block B from the basic block array and compact behind it.  */\n@@ -570,6 +623,7 @@ set_block_for_new_insns (insn, bb)\n \f\n /* Create an edge connecting SRC and DST with FLAGS optionally using\n    edge cache CACHE.  Return the new edge, NULL if already exist. */\n+\n edge\n cached_make_edge (edge_cache, src, dst, flags)\n      sbitmap *edge_cache;\n@@ -777,75 +831,26 @@ split_block (bb, insn)\n   basic_block new_bb;\n   edge new_edge;\n   edge e;\n-  rtx bb_note;\n-  int i, j;\n \n   /* There is no point splitting the block after its end.  */\n   if (bb->end == insn)\n     return 0;\n \n-  /* Create the new structures.  */\n-  new_bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*new_bb));\n-\n-  memset (new_bb, 0, sizeof (*new_bb));\n-\n-  new_bb->head = NEXT_INSN (insn);\n-  new_bb->end = bb->end;\n-  bb->end = insn;\n-\n-  new_bb->succ = bb->succ;\n-  bb->succ = NULL;\n-  new_bb->pred = NULL;\n+  /* Create the new basic block.  */\n+  new_bb = create_basic_block (bb->index + 1, NEXT_INSN (insn), bb->end);\n   new_bb->count = bb->count;\n   new_bb->frequency = bb->frequency;\n   new_bb->loop_depth = bb->loop_depth;\n+  bb->end = insn;\n \n-  /* Redirect the src of the successor edges of bb to point to new_bb.  */\n+  /* Redirect the outgoing edges.  */\n+  new_bb->succ = bb->succ;\n+  bb->succ = NULL;\n   for (e = new_bb->succ; e; e = e->succ_next)\n     e->src = new_bb;\n \n   new_edge = make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);\n \n-  /* Place the new block just after the block being split.  */\n-  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n-\n-  /* Some parts of the compiler expect blocks to be number in\n-     sequential order so insert the new block immediately after the\n-     block being split..  */\n-  j = bb->index;\n-  for (i = n_basic_blocks - 1; i > j + 1; --i)\n-    {\n-      basic_block tmp = BASIC_BLOCK (i - 1);\n-      BASIC_BLOCK (i) = tmp;\n-      tmp->index = i;\n-    }\n-\n-  BASIC_BLOCK (i) = new_bb;\n-  new_bb->index = i;\n-\n-  if (GET_CODE (new_bb->head) == CODE_LABEL)\n-    {\n-      /* Create the basic block note.  */\n-      bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK,\n-\t\t\t\t new_bb->head);\n-      NOTE_BASIC_BLOCK (bb_note) = new_bb;\n-\n-      /* If the only thing in this new block was the label, make sure\n-\t the block note gets included.  */\n-      if (new_bb->head == new_bb->end)\n-\tnew_bb->end = bb_note;\n-    }\n-  else\n-    {\n-      /* Create the basic block note.  */\n-      bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK,\n-\t\t\t\t  new_bb->head);\n-      NOTE_BASIC_BLOCK (bb_note) = new_bb;\n-      new_bb->head = bb_note;\n-    }\n-\n-  update_bb_for_insn (new_bb);\n-\n   if (bb->global_live_at_start)\n     {\n       new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n@@ -1110,7 +1115,7 @@ last_loop_beg_note (insn)\n {\n   rtx last = insn;\n   insn = NEXT_INSN (insn);\n-  while (GET_CODE (insn) == NOTE\n+  while (insn && GET_CODE (insn) == NOTE\n \t && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n     {\n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n@@ -1222,117 +1227,99 @@ redirect_edge_and_branch (e, target)\n   return true;\n }\n \n-/* Redirect edge even at the expense of creating new jump insn or\n-   basic block.  Return new basic block if created, NULL otherwise.\n-   Abort if converison is impossible.  */\n+/* Like force_nonfallthru bellow, but additionally performs redirection\n+   Used by redirect_edge_and_branch_force.  */\n \n-basic_block\n-redirect_edge_and_branch_force (e, target)\n+static basic_block\n+force_nonfallthru_and_redirect (e, target)\n      edge e;\n      basic_block target;\n {\n-  basic_block new_bb;\n+  basic_block jump_block, new_bb = NULL;\n+  rtx note;\n   edge new_edge;\n   rtx label;\n-  rtx bb_note;\n-  int i, j;\n \n-  if (redirect_edge_and_branch (e, target))\n-    return NULL;\n-  if (e->dest == target)\n-    return NULL;\n   if (e->flags & EDGE_ABNORMAL)\n     abort ();\n   if (!(e->flags & EDGE_FALLTHRU))\n     abort ();\n-\n-  e->flags &= ~EDGE_FALLTHRU;\n-  label = block_label (target);\n-  /* Case of the fallthru block.  */\n-  if (!e->src->succ->succ_next)\n+  if (e->src->succ->succ_next)\n     {\n-      e->src->end = emit_jump_insn_after (gen_jump (label),\n-\t\t\t\t\t  last_loop_beg_note (e->src->end));\n-      JUMP_LABEL (e->src->end) = label;\n-      LABEL_NUSES (label)++;\n-      if (basic_block_for_insn)\n-\tset_block_for_new_insns (e->src->end, e->src);\n-      emit_barrier_after (e->src->end);\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n-\t\t \"Emitting jump insn %i to redirect edge %i->%i to %i\\n\",\n-\t\t INSN_UID (e->src->end), e->src->index, e->dest->index,\n-\t\t target->index);\n-      redirect_edge_succ (e, target);\n-      return NULL;\n-    }\n-  /* Redirecting fallthru edge of the conditional needs extra work.  */\n-\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n-\t     \"Emitting jump insn %i in new BB to redirect edge %i->%i to %i\\n\",\n-\t     INSN_UID (e->src->end), e->src->index, e->dest->index,\n-\t     target->index);\n-\n-  /* Create the new structures.  */\n-  new_bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*new_bb));\n+      /* Create the new structures.  */\n+      note = last_loop_beg_note (e->src->end);\n+      jump_block = create_basic_block (e->src->index + 1, NEXT_INSN (note), NULL);\n+      jump_block->count = e->count;\n+      jump_block->frequency = EDGE_FREQUENCY (e);\n+      jump_block->loop_depth = target->loop_depth;\n+\n+      if (target->global_live_at_start)\n+\t{\n+\t  jump_block->global_live_at_start =\n+\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  jump_block->global_live_at_end =\n+\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  COPY_REG_SET (jump_block->global_live_at_start,\n+\t\t\ttarget->global_live_at_start);\n+\t  COPY_REG_SET (jump_block->global_live_at_end,\n+\t\t\ttarget->global_live_at_start);\n+\t}\n \n-  memset (new_bb, 0, sizeof (*new_bb));\n+      /* Wire edge in.  */\n+      new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n+      new_edge->probability = e->probability;\n+      new_edge->count = e->count;\n \n-  new_bb->end = new_bb->head = last_loop_beg_note (e->src->end);\n-  new_bb->succ = NULL;\n-  new_bb->pred = NULL;\n-  new_bb->count = e->count;\n-  new_bb->frequency = EDGE_FREQUENCY (e);\n-  new_bb->loop_depth = e->dest->loop_depth;\n+      /* Redirect old edge.  */\n+      redirect_edge_pred (e, jump_block);\n+      e->probability = REG_BR_PROB_BASE;\n \n-  if (target->global_live_at_start)\n-    {\n-      new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      COPY_REG_SET (new_bb->global_live_at_start,\n-\t\t    target->global_live_at_start);\n-      COPY_REG_SET (new_bb->global_live_at_end, new_bb->global_live_at_start);\n+      new_bb = jump_block;\n     }\n+  else\n+    jump_block = e->src;\n+  e->flags &= ~EDGE_FALLTHRU;\n+  label = block_label (target);\n+  jump_block->end = emit_jump_insn_after (gen_jump (label), jump_block->end);\n+  JUMP_LABEL (jump_block->end) = label;\n+  LABEL_NUSES (label)++;\n+  if (basic_block_for_insn)\n+    set_block_for_new_insns (jump_block->end, jump_block);\n+  emit_barrier_after (jump_block->end);\n+  redirect_edge_succ_nodup (e, target);\n \n-  /* Wire edge in.  */\n-  new_edge = make_edge (e->src, new_bb, EDGE_FALLTHRU);\n-  new_edge->probability = e->probability;\n-  new_edge->count = e->count;\n-\n-  /* Redirect old edge.  */\n-  redirect_edge_succ (e, target);\n-  redirect_edge_pred (e, new_bb);\n-  e->probability = REG_BR_PROB_BASE;\n+  return new_bb;\n+}\n \n-  /* Place the new block just after the block being split.  */\n-  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+/* Edge E is assumed to be fallthru edge.  Emit needed jump instruction\n+   (and possibly create new basic block) to make edge non-fallthru.\n+   Return newly created BB or NULL if none.  */\n+basic_block\n+force_nonfallthru (e)\n+     edge e;\n+{\n+  return force_nonfallthru_and_redirect (e, e->dest);\n+}\n \n-  /* Some parts of the compiler expect blocks to be number in\n-     sequential order so insert the new block immediately after the\n-     block being split..  */\n-  j = new_edge->src->index;\n-  for (i = n_basic_blocks - 1; i > j + 1; --i)\n-    {\n-      basic_block tmp = BASIC_BLOCK (i - 1);\n-      BASIC_BLOCK (i) = tmp;\n-      tmp->index = i;\n-    }\n+/* Redirect edge even at the expense of creating new jump insn or\n+   basic block.  Return new basic block if created, NULL otherwise.\n+   Abort if converison is impossible.  */\n \n-  BASIC_BLOCK (i) = new_bb;\n-  new_bb->index = i;\n+basic_block\n+redirect_edge_and_branch_force (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  basic_block new_bb;\n \n-  /* Create the basic block note.  */\n-  bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, new_bb->head);\n-  NOTE_BASIC_BLOCK (bb_note) = new_bb;\n-  new_bb->head = bb_note;\n+  if (redirect_edge_and_branch (e, target))\n+    return NULL;\n+  if (e->dest == target)\n+    return NULL;\n \n-  new_bb->end = emit_jump_insn_after (gen_jump (label), new_bb->head);\n-  JUMP_LABEL (new_bb->end) = label;\n-  LABEL_NUSES (label)++;\n-  if (basic_block_for_insn)\n-    set_block_for_new_insns (new_bb->end, new_bb);\n-  emit_barrier_after (new_bb->end);\n+  /* In case the edge redirection failed, try to force it to be non-fallthru\n+     and redirect newly created simplejump.  */\n+  new_bb = force_nonfallthru_and_redirect (e, target);\n   return new_bb;\n }\n \n@@ -1479,111 +1466,27 @@ basic_block\n split_edge (edge_in)\n      edge edge_in;\n {\n-  basic_block old_pred, bb, old_succ;\n+  basic_block bb;\n   edge edge_out;\n-  rtx bb_note;\n-  int i, j;\n+  rtx before;\n \n   /* Abnormal edges cannot be split.  */\n   if ((edge_in->flags & EDGE_ABNORMAL) != 0)\n     abort ();\n \n-  old_pred = edge_in->src;\n-  old_succ = edge_in->dest;\n-\n-  /* Create the new structures.  */\n-  bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n-\n-  memset (bb, 0, sizeof (*bb));\n-\n-  /* ??? This info is likely going to be out of date very soon.  */\n-  if (old_succ->global_live_at_start)\n-    {\n-      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      COPY_REG_SET (bb->global_live_at_start, old_succ->global_live_at_start);\n-      COPY_REG_SET (bb->global_live_at_end, old_succ->global_live_at_start);\n-    }\n-\n-  /* Wire them up.  */\n-  bb->succ = NULL;\n-  bb->count = edge_in->count;\n-  bb->frequency = EDGE_FREQUENCY (edge_in);\n-\n-  edge_in->flags &= ~EDGE_CRITICAL;\n-\n-  edge_out = make_single_succ_edge (bb, old_succ, EDGE_FALLTHRU);\n-\n-  /* Tricky case -- if there existed a fallthru into the successor\n-     (and we're not it) we must add a new unconditional jump around\n-     the new block we're actually interested in.\n-\n-     Further, if that edge is critical, this means a second new basic\n-     block must be created to hold it.  In order to simplify correct\n-     insn placement, do this before we touch the existing basic block\n-     ordering for the block we were really wanting.  */\n+  /* We are going to place the new block in front of edge destination.\n+     Avoid existence of fallthru predecesors.  */\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n       edge e;\n-      for (e = edge_out->pred_next; e; e = e->pred_next)\n+      for (e = edge_in->dest->pred; e; e = e->pred_next)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n \n       if (e)\n-\t{\n-\t  basic_block jump_block;\n-\t  rtx pos;\n-\n-\t  if ((e->flags & EDGE_CRITICAL) == 0\n-\t      && e->src != ENTRY_BLOCK_PTR)\n-\t    {\n-\t      /* Non critical -- we can simply add a jump to the end\n-\t\t of the existing predecessor.  */\n-\t      jump_block = e->src;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We need a new block to hold the jump.  The simplest\n-\t         way to do the bulk of the work here is to recursively\n-\t         call ourselves.  */\n-\t      jump_block = split_edge (e);\n-\t      e = jump_block->succ;\n-\t    }\n-\n-\t  /* Now add the jump insn ...  */\n-\t  pos = emit_jump_insn_after (gen_jump (old_succ->head),\n-\t\t\t\t      last_loop_beg_note (jump_block->end));\n-\t  jump_block->end = pos;\n-\t  if (basic_block_for_insn)\n-\t    set_block_for_new_insns (pos, jump_block);\n-\t  emit_barrier_after (pos);\n-\n-\t  /* ... let jump know that label is in use, ...  */\n-\t  JUMP_LABEL (pos) = old_succ->head;\n-\t  ++LABEL_NUSES (old_succ->head);\n-\n-\t  /* ... and clear fallthru on the outgoing edge.  */\n-\t  e->flags &= ~EDGE_FALLTHRU;\n-\n-\t  /* Continue splitting the interesting edge.  */\n-\t}\n+\tforce_nonfallthru (e);\n     }\n \n-  /* Place the new block just in front of the successor.  */\n-  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n-  if (old_succ == EXIT_BLOCK_PTR)\n-    j = n_basic_blocks - 1;\n-  else\n-    j = old_succ->index;\n-  for (i = n_basic_blocks - 1; i > j; --i)\n-    {\n-      basic_block tmp = BASIC_BLOCK (i - 1);\n-      BASIC_BLOCK (i) = tmp;\n-      tmp->index = i;\n-    }\n-  BASIC_BLOCK (i) = bb;\n-  bb->index = i;\n-\n   /* Create the basic block note.\n \n      Where we place the note can have a noticable impact on the generated\n@@ -1601,19 +1504,33 @@ split_edge (edge_in)\n       we want to ensure the instructions we insert are outside of any\n       loop notes that physically sit between block 0 and block 1.  Otherwise\n       we confuse the loop optimizer into thinking the loop is a phony.  */\n-  if (old_succ != EXIT_BLOCK_PTR\n-      && PREV_INSN (old_succ->head)\n-      && GET_CODE (PREV_INSN (old_succ->head)) == NOTE\n-      && NOTE_LINE_NUMBER (PREV_INSN (old_succ->head)) == NOTE_INSN_LOOP_BEG\n-      && !back_edge_of_syntactic_loop_p (old_succ, old_pred))\n-    bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK,\n-\t\t\t\tPREV_INSN (old_succ->head));\n-  else if (old_succ != EXIT_BLOCK_PTR)\n-    bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK, old_succ->head);\n+\n+  if (edge_in->dest != EXIT_BLOCK_PTR\n+      && PREV_INSN (edge_in->dest->head)\n+      && GET_CODE (PREV_INSN (edge_in->dest->head)) == NOTE\n+      && NOTE_LINE_NUMBER (PREV_INSN (edge_in->dest->head)) == NOTE_INSN_LOOP_BEG\n+      && !back_edge_of_syntactic_loop_p (edge_in->dest, edge_in->src))\n+    before = PREV_INSN (edge_in->dest->head);\n+  else if (edge_in->dest != EXIT_BLOCK_PTR)\n+    before = edge_in->dest->head;\n   else\n-    bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, get_last_insn ());\n-  NOTE_BASIC_BLOCK (bb_note) = bb;\n-  bb->head = bb->end = bb_note;\n+    before = NULL_RTX;\n+\n+  bb = create_basic_block (edge_in->dest == EXIT_BLOCK_PTR ? n_basic_blocks\n+\t\t\t   : edge_in->dest->index, before, NULL);\n+  bb->count = edge_in->count;\n+  bb->frequency = EDGE_FREQUENCY (edge_in);\n+\n+  /* ??? This info is likely going to be out of date very soon.  */\n+  if (edge_in->dest->global_live_at_start)\n+    {\n+      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      COPY_REG_SET (bb->global_live_at_start, edge_in->dest->global_live_at_start);\n+      COPY_REG_SET (bb->global_live_at_end, edge_in->dest->global_live_at_start);\n+    }\n+\n+  edge_out = make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n \n   /* For non-fallthry edges, we must adjust the predecessor's\n      jump instruction to target our new block.  */\n@@ -1639,8 +1556,7 @@ insert_insn_on_edge (pattern, e)\n {\n   /* We cannot insert instructions on an abnormal critical edge.\n      It will be easier to find the culprit if we die now.  */\n-  if ((e->flags & (EDGE_ABNORMAL|EDGE_CRITICAL))\n-      == (EDGE_ABNORMAL|EDGE_CRITICAL))\n+  if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n     abort ();\n \n   if (e->insns == NULL_RTX)\n@@ -1917,7 +1833,7 @@ dump_edge_info (file, e, do_succ)\n   if (e->flags)\n     {\n       static const char * const bitnames[] = {\n-\t\"fallthru\", \"crit\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"\n+\t\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"\n       };\n       int comma = 0;\n       int i, flags = e->flags;\n@@ -2390,7 +2306,6 @@ verify_flow_info ()\n   free (edge_checksum);\n }\n \f\n-\f\n /* Assume that the preceeding pass has possibly eliminated jump instructions\n    or converted the unconditional jumps.  Eliminate the edges from CFG.\n    Return true if any edges are eliminated.  */"}, {"sha": "5ad1a10a9bb67701a894faecec849ae99e36b0d9", "filename": "gcc/cfganal.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -89,50 +89,6 @@ can_fallthru (src, target)\n   return next_active_insn (insn) == insn2;\n }\n \f\n-/* Identify critical edges and set the bits appropriately.  */\n-\n-void\n-mark_critical_edges ()\n-{\n-  int i, n = n_basic_blocks;\n-  basic_block bb;\n-\n-  /* We begin with the entry block.  This is not terribly important now,\n-     but could be if a front end (Fortran) implemented alternate entry\n-     points.  */\n-  bb = ENTRY_BLOCK_PTR;\n-  i = -1;\n-\n-  while (1)\n-    {\n-      edge e;\n-\n-      /* (1) Critical edges must have a source with multiple successors.  */\n-      if (bb->succ && bb->succ->succ_next)\n-\t{\n-\t  for (e = bb->succ; e; e = e->succ_next)\n-\t    {\n-\t      /* (2) Critical edges must have a destination with multiple\n-\t\t predecessors.  Note that we know there is at least one\n-\t\t predecessor -- the edge we followed to get here.  */\n-\t      if (e->dest->pred->pred_next)\n-\t\te->flags |= EDGE_CRITICAL;\n-\t      else\n-\t\te->flags &= ~EDGE_CRITICAL;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  for (e = bb->succ; e; e = e->succ_next)\n-\t    e->flags &= ~EDGE_CRITICAL;\n-\t}\n-\n-      if (++i >= n)\n-\tbreak;\n-      bb = BASIC_BLOCK (i);\n-    }\n-}\n-\n /* Mark the back edges in DFS traversal.\n    Return non-zero if a loop (natural or otherwise) is present.\n    Inspired by Depth_First_Search_PP described in:"}, {"sha": "a6ac3a08f64063b0ac5e9d5104067b468156cd95", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -452,7 +452,7 @@ find_basic_blocks_1 (f)\n \t     to a barrier or some such, no need to do it again.  */\n \t  if (head != NULL_RTX)\n \t    {\n-\t      create_basic_block (i++, head, end, bb_note);\n+\t      create_basic_block_structure (i++, head, end, bb_note);\n \t      bb_note = NULL_RTX;\n \t    }\n \n@@ -523,7 +523,7 @@ find_basic_blocks_1 (f)\n \t\tend = insn;\n \n \t      new_bb_exclusive:\n-\t\tcreate_basic_block (i++, head, end, bb_note);\n+\t\tcreate_basic_block_structure (i++, head, end, bb_note);\n \t\thead = end = NULL_RTX;\n \t\tbb_note = NULL_RTX;\n \t\tbreak;\n@@ -579,7 +579,7 @@ find_basic_blocks_1 (f)\n     }\n \n   if (head != NULL_RTX)\n-    create_basic_block (i++, head, end, bb_note);\n+    create_basic_block_structure (i++, head, end, bb_note);\n   else if (bb_note)\n     flow_delete_insn (bb_note);\n \n@@ -604,6 +604,10 @@ find_basic_blocks (f, nregs, file)\n   int max_uid;\n   timevar_push (TV_CFG);\n \n+  if (basic_block_for_insn)\n+    VARRAY_FREE (basic_block_for_insn);\n+  basic_block_for_insn = 0;\n+\n   /* Flush out existing data.  */\n   if (basic_block_info != NULL)\n     {\n@@ -655,8 +659,6 @@ find_basic_blocks (f, nregs, file)\n      here and cleanup_cfg, e.g. thread_prologue_and_epilogue_insns.  */\n   tidy_fallthru_edges ();\n \n-  mark_critical_edges ();\n-\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif"}, {"sha": "2dbf8efbf1f3bb176e55b016cf9db84203bcbb0d", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 40, "deletions": 66, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -52,12 +52,12 @@ static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n \t\t\t\t\t\t rtx *, rtx *));\n \n static bool delete_unreachable_blocks\tPARAMS ((void));\n-static int tail_recursion_label_p\tPARAMS ((rtx));\n-static int merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n+static bool tail_recursion_label_p\tPARAMS ((rtx));\n+static void merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\t  basic_block));\n-static int merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n+static void merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\tbasic_block));\n-static int merge_blocks\t\t\tPARAMS ((edge,basic_block,basic_block,\n+static bool merge_blocks\t\tPARAMS ((edge,basic_block,basic_block,\n \t\t\t\t\t\t int));\n static bool try_optimize_cfg\t\tPARAMS ((int));\n static bool try_simplify_condjump\tPARAMS ((basic_block));\n@@ -248,24 +248,26 @@ try_forward_edges (mode, b)\n   return changed;\n }\n \f\n-static int\n+/* Return true if LABEL is used for tail recursion.  */\n+\n+static bool\n tail_recursion_label_p (label)\n      rtx label;\n {\n   rtx x;\n \n   for (x = tail_recursion_label_list; x; x = XEXP (x, 1))\n     if (label == XEXP (x, 0))\n-      return 1;\n+      return true;\n \n-  return 0;\n+  return false;\n }\n \n /* Blocks A and B are to be merged into a single block.  A has no incoming\n    fallthru edge, so it can be moved before B without adding or modifying\n    any jumps (aside from the jump from A to B).  */\n \n-static int\n+static void\n merge_blocks_move_predecessor_nojumps (a, b)\n      basic_block a, b;\n {\n@@ -307,15 +309,13 @@ merge_blocks_move_predecessor_nojumps (a, b)\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n   merge_blocks_nomove (a, b);\n-\n-  return 1;\n }\n \n /* Blocks A and B are to be merged into a single block.  B has no outgoing\n    fallthru edge, so it can be moved after A without adding or modifying\n    any jumps (aside from the jump from A to B).  */\n \n-static int\n+static void\n merge_blocks_move_successor_nojumps (a, b)\n      basic_block a, b;\n {\n@@ -359,14 +359,12 @@ merge_blocks_move_successor_nojumps (a, b)\n       fprintf (rtl_dump_file, \"Moved block %d after %d and merged.\\n\",\n \t       b->index, a->index);\n     }\n-\n-  return 1;\n }\n \n /* Attempt to merge basic blocks that are potentially non-adjacent.\n    Return true iff the attempt succeeded.  */\n \n-static int\n+static bool\n merge_blocks (e, b, c, mode)\n      edge e;\n      basic_block b, c;\n@@ -376,9 +374,10 @@ merge_blocks (e, b, c, mode)\n      edge recorded from the call_placeholder back to this label, as\n      that would make optimize_sibling_and_tail_recursive_calls more\n      complex for no gain.  */\n-  if (GET_CODE (c->head) == CODE_LABEL\n+  if ((mode & CLEANUP_PRE_SIBCALL)\n+      && GET_CODE (c->head) == CODE_LABEL\n       && tail_recursion_label_p (c->head))\n-    return 0;\n+    return false;\n \n   /* If B has a fallthru edge to C, no need to move anything.  */\n   if (e->flags & EDGE_FALLTHRU)\n@@ -391,22 +390,22 @@ merge_blocks (e, b, c, mode)\n \t\t   b->index, c->index);\n \t}\n \n-      return 1;\n+      return true;\n     }\n   /* Otherwise we will need to move code around.  Do that only if expensive\n      transformations are allowed.  */\n   else if (mode & CLEANUP_EXPENSIVE)\n     {\n-      edge tmp_edge, c_fallthru_edge;\n-      int c_has_outgoing_fallthru;\n-      int b_has_incoming_fallthru;\n+      edge tmp_edge, b_fallthru_edge;\n+      bool c_has_outgoing_fallthru;\n+      bool b_has_incoming_fallthru;\n \n       /* Avoid overactive code motion, as the forwarder blocks should be\n          eliminated by edge redirection instead.  One exception might have\n \t been if B is a forwarder block and C has no fallthru edge, but\n \t that should be cleaned up by bb-reorder instead.  */\n       if (forwarder_block_p (b) || forwarder_block_p (c))\n-\treturn 0;\n+\treturn false;\n \n       /* We must make sure to not munge nesting of lexical blocks,\n \t and loop notes.  This is done by squeezing out all the notes\n@@ -416,59 +415,37 @@ merge_blocks (e, b, c, mode)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n       c_has_outgoing_fallthru = (tmp_edge != NULL);\n-      c_fallthru_edge = tmp_edge;\n \n       for (tmp_edge = b->pred; tmp_edge; tmp_edge = tmp_edge->pred_next)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n       b_has_incoming_fallthru = (tmp_edge != NULL);\n+      b_fallthru_edge = tmp_edge;\n+\n+      /* Otherwise, we're going to try to move C after B.  If C does\n+\t not have an outgoing fallthru, then it can be moved\n+\t immediately after B without introducing or modifying jumps.  */\n+      if (! c_has_outgoing_fallthru)\n+\t{\n+\t  merge_blocks_move_successor_nojumps (b, c);\n+\t  return true;\n+\t}\n \n       /* If B does not have an incoming fallthru, then it can be moved\n \t immediately before C without introducing or modifying jumps.\n \t C cannot be the first block, so we do not have to worry about\n \t accessing a non-existent block.  */\n-      if (! b_has_incoming_fallthru)\n-\treturn merge_blocks_move_predecessor_nojumps (b, c);\n \n-      /* Otherwise, we're going to try to move C after B.  If C does\n-\t not have an outgoing fallthru, then it can be moved\n-\t immediately after B without introducing or modifying jumps.  */\n-      if (! c_has_outgoing_fallthru)\n-\treturn merge_blocks_move_successor_nojumps (b, c);\n-\n-      /* Otherwise, we'll need to insert an extra jump, and possibly\n-\t a new block to contain it.  We can't redirect to EXIT_BLOCK_PTR,\n-\t as we don't have explicit return instructions before epilogues\n-\t are generated, so give up on that case.  */\n-\n-      if (c_fallthru_edge->dest != EXIT_BLOCK_PTR\n-\t  && merge_blocks_move_successor_nojumps (b, c))\n-        {\n-\t  basic_block target = c_fallthru_edge->dest;\n-\t  rtx barrier;\n-\t  basic_block new;\n-\n-\t  /* This is a dirty hack to avoid code duplication.\n-\n-\t     Set edge to point to wrong basic block, so\n-\t     redirect_edge_and_branch_force will do the trick\n-\t     and rewire edge back to the original location.  */\n-\t  redirect_edge_succ (c_fallthru_edge, ENTRY_BLOCK_PTR);\n-\t  new = redirect_edge_and_branch_force (c_fallthru_edge, target);\n-\n-\t  /* We've just created barrier, but another barrier is\n-\t     already present in the stream.  Avoid the duplicate.  */\n-\t  barrier = next_nonnote_insn (new ? new->end : b->end);\n-\t  if (GET_CODE (barrier) != BARRIER)\n-\t    abort ();\n-\t  flow_delete_insn (barrier);\n-\n-\t  return 1;\n-        }\n-\n-      return 0;\n+      if (b_has_incoming_fallthru)\n+\t{\n+\t  if (b_fallthru_edge->src == ENTRY_BLOCK_PTR)\n+\t    return false;\n+\t  force_nonfallthru (b_fallthru_edge);\n+\t}\n+      merge_blocks_move_predecessor_nojumps (b, c);\n+      return true;\n     }\n-  return 0;\n+  return false;\n }\n \f\n /* Look through the insns at the end of BB1 and BB2 and find the longest\n@@ -1191,6 +1168,7 @@ try_optimize_cfg (mode)\n }\n \f\n /* Delete all unreachable basic blocks.   */\n+\n static bool\n delete_unreachable_blocks ()\n {\n@@ -1215,7 +1193,6 @@ delete_unreachable_blocks ()\n     tidy_fallthru_edges ();\n   return changed;\n }\n-\n \f\n /* Tidy the CFG by deleting unreachable code and whatnot.  */\n \n@@ -1231,9 +1208,6 @@ cleanup_cfg (mode)\n   if (try_optimize_cfg (mode))\n     delete_unreachable_blocks (), changed = true;\n \n-  if (changed)\n-    mark_critical_edges ();\n-\n   /* Kill the data we won't maintain.  */\n   free_EXPR_LIST_list (&label_value_list);\n   free_EXPR_LIST_list (&tail_recursion_label_list);"}, {"sha": "644a9b45599dfc1c7ca401977762724c7fb2c0c2", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -152,7 +152,7 @@ instrument_edges (el)\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Edge %d to %d instrumented%s\\n\",\n \t\t\t e->src->index, e->dest->index,\n-\t\t\t e->flags & EDGE_CRITICAL ? \" (and split)\" : \"\");\n+\t\t\t EDGE_CRITICAL_P (e) ? \" (and split)\" : \"\");\n \t      need_func_profiler = 1;\n \t      insert_insn_on_edge (\n \t\t\t gen_edge_profiler (total_num_edges_instrumented\n@@ -884,7 +884,7 @@ find_spanning_tree (el)\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n-      if ((e->flags & EDGE_CRITICAL)\n+      if ((EDGE_CRITICAL_P (e))\n \t  && !EDGE_INFO (e)->ignore\n \t  && (find_group (e->src) != find_group (e->dest)))\n \t{"}, {"sha": "2c542c6f62c4d8d30103e879f751723bad076ffa", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -2660,9 +2660,10 @@ convert_regs_1 (file, block)\n \tbeste = e;\n       else if (beste->count > e->count)\n \t;\n-      else if ((e->flags & EDGE_CRITICAL) != (beste->flags & EDGE_CRITICAL))\n+      else if ((EDGE_CRITICAL_P (e) != 0)\n+\t       != (EDGE_CRITICAL_P (beste) != 0))\n \t{\n-\t  if (e->flags & EDGE_CRITICAL)\n+\t  if (EDGE_CRITICAL_P (e))\n \t    beste = e;\n \t}\n       else if (e->src->index < beste->src->index)"}, {"sha": "f2ede4d8fda33473c394bed306c3081fb8069dbe", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4262e6231adab0ff8a3da565bf620037ce9b1343/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=4262e6231adab0ff8a3da565bf620037ce9b1343", "patch": "@@ -1498,8 +1498,7 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n \n       /* Scan incoming abnormal critical edges.  */\n       for (e = b->pred; e; e = e->pred_next)\n-\tif ((e->flags & (EDGE_ABNORMAL | EDGE_CRITICAL)) \n-\t\t== (EDGE_ABNORMAL | EDGE_CRITICAL))\n+\tif ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n \t  {\n \t    rtx *alt = phi_alternative (set, e->src->index);\n \t    int alt_regno;"}]}