{"sha": "973dfbb4a63ba7c580e4de0c99b4970ef159631c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczZGZiYjRhNjNiYTdjNTgwZTRkZTBjOTliNDk3MGVmMTU5NjMxYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-05-06T15:03:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-05-06T15:03:40Z"}, "message": "re PR tree-optimization/78496 (Missed opportunities for jump threading)\n\n\tPR tree-optimization/78496\n\t* tree-vrp.c (simplify_assert_expr_using_ranges): New function.\n\t(simplify_stmt_using_ranges): Call it.\n\t(vrp_dom_walker::before_dom_children): Extract equivalences\n\tfrom an ASSERT_EXPR with an equality comparison against a\n\tconstant.\n\n\tPR tree-optimization/78496\n\t* gcc.dg/tree-ssa/ssa-thread-16.c: New test.\n\t* gcc.dg/tree-ssa/ssa-thread-17.c: New test.\n\nFrom-SVN: r247721", "tree": {"sha": "4c8e6a9ca78122f5f070154b3bc851d9e0c3ed1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c8e6a9ca78122f5f070154b3bc851d9e0c3ed1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/973dfbb4a63ba7c580e4de0c99b4970ef159631c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973dfbb4a63ba7c580e4de0c99b4970ef159631c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973dfbb4a63ba7c580e4de0c99b4970ef159631c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973dfbb4a63ba7c580e4de0c99b4970ef159631c/comments", "author": null, "committer": null, "parents": [{"sha": "8ffa3150d30b90a11aba7d7bba3c6462b6461101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffa3150d30b90a11aba7d7bba3c6462b6461101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ffa3150d30b90a11aba7d7bba3c6462b6461101"}], "stats": {"total": 144, "additions": 141, "deletions": 3}, "files": [{"sha": "0f78f2a2ed1e6132bc6184474d3a27624b7413be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=973dfbb4a63ba7c580e4de0c99b4970ef159631c", "patch": "@@ -1,3 +1,12 @@\n+2017-05-06  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/78496\n+\t* tree-vrp.c (simplify_assert_expr_using_ranges): New function.\n+\t(simplify_stmt_using_ranges): Call it.\n+\t(vrp_dom_walker::before_dom_children): Extract equivalences\n+\tfrom an ASSERT_EXPR with an equality comparison against a\n+\tconstant.\n+\n 2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* lra-constraints.c (lra_copy_reg_equiv): New function."}, {"sha": "42782a6d17c6f10352a58e221b034d5e33331b5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=973dfbb4a63ba7c580e4de0c99b4970ef159631c", "patch": "@@ -1,3 +1,9 @@\n+2017-05-06  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/78496\n+\t* gcc.dg/tree-ssa/ssa-thread-16.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-thread-17.c: New test.\n+\n 2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.target/aarch64/spill_1.c: New test."}, {"sha": "78c349ca14d99ee9648c988aa376727c74fa15c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-16.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-16.c?ref=973dfbb4a63ba7c580e4de0c99b4970ef159631c", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n+\n+/* We should thread the if (exp == 2) conditional on the\n+   the path from inside the if (x) THEN arm.  It is the only\n+   jump threading opportunity in this code.  */\n+   \n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"vrp1\" } } */\n+\n+\n+extern void abort (void) __attribute__ ((__nothrow__, __leaf__))\n+  __attribute__ ((__noreturn__));\n+\n+int x;\n+\n+\n+int code;\n+void\n+do_jump (int exp)\n+{\n+  switch (code)\n+    {\n+    case 4:\n+      if ((exp) == 1)\n+\tgoto normal;\n+      if (x)\n+\t{\n+\t  if (exp != 0)\n+\t    abort ();\n+\t}\n+      if ((exp) == 2)\n+\tgoto normal;\n+    case 3:\n+\tabort ();\n+    }\n+  normal:\n+      ;\n+}"}, {"sha": "692658fbb4b4445d0022bd2c82a9d332c8b4f4c9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-17.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-17.c?ref=973dfbb4a63ba7c580e4de0c99b4970ef159631c", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n+\n+/* We should simplify one ASSERT_EXPR from a relational\n+   into an equality test.  */\n+/* { dg-final { scan-tree-dump-times \"Folded into:\\[^\\r\\n\\]*ASSERT_EXPR\\*\\[^\\r\\n\\]* == 1\" 1 \"vrp1\" } } */\n+\n+/* And simplification of the ASSERT_EXPR leads to a jump threading opportunity.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"vrp1\" } } */\n+\n+extern void abort (void) __attribute__ ((__nothrow__, __leaf__))\n+  __attribute__ ((__noreturn__));\n+\n+union gimple_statement_d;\n+typedef union gimple_statement_d *gimple;\n+\n+\n+\n+union gimple_statement_d\n+{\n+  unsigned num_ops;\n+};\n+\n+void\n+gimple_assign_set_rhs_with_ops_1 (int code, gimple stmt, unsigned new_rhs_ops)\n+{\n+\n+  stmt->num_ops = new_rhs_ops + 1;\n+  if (stmt->num_ops <= 1)\n+    abort ();\n+  if (new_rhs_ops > 1)\n+    if (stmt->num_ops <= 2)\n+      abort ();\n+  if (new_rhs_ops > 2)\n+      abort ();\n+}"}, {"sha": "461a48f5c9c734bd674319cb220a3256ead57f99", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973dfbb4a63ba7c580e4de0c99b4970ef159631c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=973dfbb4a63ba7c580e4de0c99b4970ef159631c", "patch": "@@ -9600,6 +9600,43 @@ range_fits_type_p (value_range *vr, unsigned dest_precision, signop dest_sgn)\n   return true;\n }\n \n+/* Simplify STMT, an ASSERT_EXPR, using ranges.  This is helpful because jump\n+   threading looks at the ASSERT_EXPRs.  Collapsing the condition of\n+   an ASSERT_EXPR from a relational to an equality test is where most\n+   of the benefit occurrs, so that's the only thing we currently do.  */\n+\n+static bool\n+simplify_assert_expr_using_ranges (gimple *stmt)\n+{\n+  return false;\n+  tree cond = TREE_OPERAND (gimple_assign_rhs1 (stmt), 1);\n+  tree_code code = TREE_CODE (cond);\n+  tree op0 = TREE_OPERAND (cond, 0);\n+\n+  /* The condition of the ASSERT_EXPR must be a simple relational\n+     between an SSA_NAME (with a range) and a constant.  */\n+  if (TREE_CODE (op0) != SSA_NAME\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+    return false;\n+\n+  tree op1 = TREE_OPERAND (cond, 1);\n+  if (TREE_CODE (op1) != INTEGER_CST)\n+    return false;\n+\n+  value_range *vr = get_value_range (op0);\n+  if (!vr || vr->type != VR_RANGE)\n+    return false;\n+\n+  tree res = test_for_singularity (code, op0, op1, vr);\n+  if (res)\n+    {\n+      TREE_SET_CODE (cond, EQ_EXPR);\n+      TREE_OPERAND (cond, 1) = res;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Simplify a conditional using a relational operator to an equality\n    test if the range information indicates only one value can satisfy\n    the original conditional.  */\n@@ -10334,6 +10371,9 @@ simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n \tcase MAX_EXPR:\n \t  return simplify_min_or_max_using_ranges (gsi, stmt);\n \n+\tcase ASSERT_EXPR:\n+\t  return simplify_assert_expr_using_ranges (stmt);\n+\n \tdefault:\n \t  break;\n \t}\n@@ -10598,16 +10638,25 @@ vrp_dom_walker::before_dom_children (basic_block bb)\n \t{\n \t  tree rhs1 = gimple_assign_rhs1 (stmt);\n \t  tree cond = TREE_OPERAND (rhs1, 1);\n+\t  tree lhs = gimple_assign_lhs (stmt);\n+\t  m_const_and_copies->record_const_or_copy (lhs, TREE_OPERAND (rhs1, 0));\n+\n+\t  if (TREE_CODE (cond) == EQ_EXPR)\n+\t    {\n+\t      tree cond_op0 = TREE_OPERAND (cond, 0);\n+\t      tree cond_op1 = TREE_OPERAND (cond, 1);\n+\t      if (TREE_CODE (cond_op0) == SSA_NAME)\n+\t\tm_const_and_copies->record_const_or_copy (cond_op0, cond_op1);\n+\t      continue;\n+\t    }\n+\n \t  tree inverted = invert_truthvalue (cond);\n \t  vec<cond_equivalence> p;\n \t  p.create (3);\n \t  record_conditions (&p, cond, inverted);\n \t  for (unsigned int i = 0; i < p.length (); i++)\n \t    m_avail_exprs_stack->record_cond (&p[i]);\n \n-\t  tree lhs = gimple_assign_lhs (stmt);\n-\t  m_const_and_copies->record_const_or_copy (lhs,\n-\t\t\t\t\t\t    TREE_OPERAND (rhs1, 0));\n \t  p.release ();\n \t  continue;\n \t}"}]}