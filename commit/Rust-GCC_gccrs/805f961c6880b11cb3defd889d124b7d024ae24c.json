{"sha": "805f961c6880b11cb3defd889d124b7d024ae24c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA1Zjk2MWM2ODgwYjExY2IzZGVmZDg4OWQxMjRiN2QwMjRhZTI0Yw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-29T04:56:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-29T04:56:04Z"}, "message": "(self_promoting_args_p): No longer static.\n\n(initializer_constant_valid_p): Allow CONVERT_EXPR if its operand is ok.\n(build_c_cast): For cast to union, make a CONSTRUCTOR.\n\nFrom-SVN: r1334", "tree": {"sha": "d5d5ac7703991ec1bd32b6acfb65a95e72471a64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5d5ac7703991ec1bd32b6acfb65a95e72471a64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/805f961c6880b11cb3defd889d124b7d024ae24c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805f961c6880b11cb3defd889d124b7d024ae24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/805f961c6880b11cb3defd889d124b7d024ae24c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805f961c6880b11cb3defd889d124b7d024ae24c/comments", "author": null, "committer": null, "parents": [{"sha": "664b4b1e0467168064ebb0d2fbcd75d3a3e87155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/664b4b1e0467168064ebb0d2fbcd75d3a3e87155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/664b4b1e0467168064ebb0d2fbcd75d3a3e87155"}], "stats": {"total": 69, "additions": 41, "deletions": 28}, "files": [{"sha": "805d907cd164121835c5b937903c540edc2a2bb1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805f961c6880b11cb3defd889d124b7d024ae24c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805f961c6880b11cb3defd889d124b7d024ae24c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=805f961c6880b11cb3defd889d124b7d024ae24c", "patch": "@@ -38,7 +38,7 @@ static tree convert_for_assignment ();\n static void warn_for_assignment ();\n static int function_types_compatible_p ();\n static int type_lists_compatible_p ();\n-static int self_promoting_args_p ();\n+int self_promoting_args_p ();\n static int self_promoting_type_p ();\n static int comp_target_types ();\n static tree pointer_int_sum ();\n@@ -588,7 +588,7 @@ type_lists_compatible_p (args1, args2)\n /* Return 1 if PARMS specifies a fixed number of parameters\n    and none of their types is affected by default promotions.  */\n \n-static int\n+int\n self_promoting_args_p (parms)\n      tree parms;\n {\n@@ -3663,11 +3663,23 @@ build_c_cast (type, expr)\n \n       if (field)\n \t{\n-\t  tree nvalue = build1 (CONVERT_EXPR, type, value);\n-\t  TREE_CONSTANT (nvalue) = TREE_CONSTANT (value);\n+\t  char *name;\n+\t  tree nvalue;\n+\n \t  if (pedantic)\n \t    pedwarn (\"ANSI C forbids casts to union type\");\n-\t  return nvalue;\n+\t  if (TYPE_NAME (type) != 0)\n+\t    {\n+\t      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n+\t\tname = IDENTIFIER_POINTER (TYPE_NAME (type));\n+\t      else\n+\t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+\t    }\n+\t  else\n+\t    name = \"\";\n+\t  return digest_init (type, build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t\t\t      build_tree_list (field, value)),\n+\t\t\t      0, 0, 0, name);\n \t}\n       error (\"cast to union type from type not present in union\");\n       return error_mark_node;\n@@ -4137,6 +4149,9 @@ initializer_constant_valid_p (value)\n \t  && tree_int_cst_equal (TYPE_SIZE (TREE_TYPE (value)),\n \t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_OPERAND (value, 0)))))\n \treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+      /* Allow conversions to union types if the value inside is okay.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n       return 0;\n \n     case PLUS_EXPR:\n@@ -4654,26 +4669,19 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t  return error_mark_node;\n \t}\n \n-      SAVE_SPELLING_DEPTH\n-\t({\n-\t  if (ofwhat)\n-\t    push_string (ofwhat);\n-\t  push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n-\n-\t  if (raw_constructor)\n-\t    result = process_init_constructor (type, inside_init, 0,\n-\t\t\t\t\t       require_constant,\n-\t\t\t\t\t       constructor_constant, 0);\n-\t  else if (tail != 0)\n-\t    {\n-\t      *tail = old_tail_contents;\n-\t      result = process_init_constructor (type, 0, tail,\n-\t\t\t\t\t\t require_constant,\n-\t\t\t\t\t\t constructor_constant, 0);\n-\t    }\n-\t  else\n-\t    result = 0;\n-\t});\n+      if (raw_constructor)\n+\tresult = process_init_constructor (type, inside_init, 0,\n+\t\t\t\t\t   require_constant,\n+\t\t\t\t\t   constructor_constant, ofwhat);\n+      else if (tail != 0)\n+\t{\n+\t  *tail = old_tail_contents;\n+\t  result = process_init_constructor (type, 0, tail,\n+\t\t\t\t\t     require_constant,\n+\t\t\t\t\t     constructor_constant, ofwhat);\n+\t}\n+      else\n+\tresult = 0;\n \n       if (result)\n \treturn result;\n@@ -4986,7 +4994,8 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t\t  if (temp)\n \t\t    field = temp, i = j, win = 1;\n \t\t  else\n-\t\t    error_with_decl (temp, \"no field `%s' in structure being initialized\");\n+\t\t    error (\"no field `%s' in structure being initialized\",\n+\t\t\t   IDENTIFIER_POINTER (TREE_PURPOSE (tail))); \n \t\t}\n \t      if (!win)\n \t\tTREE_VALUE (tail) = error_mark_node;\n@@ -5064,7 +5073,10 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t{\n \t  int win = 0;\n \n-\t  if (TREE_CODE (TREE_PURPOSE (tail)) != IDENTIFIER_NODE)\n+\t  if (TREE_CODE (TREE_PURPOSE (tail)) == FIELD_DECL)\n+\t    /* Handle the case of a call by build_c_cast.  */\n+\t    field = TREE_PURPOSE (tail), win = 1;\n+\t  else if (TREE_CODE (TREE_PURPOSE (tail)) != IDENTIFIER_NODE)\n \t    error (\"index value instead of field name in union initializer\");\n \t  else\n \t    {\n@@ -5077,7 +5089,8 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t      if (temp)\n \t\tfield = temp, win = 1;\n \t      else\n-\t\terror_with_decl (temp, \"no field `%s' in union being initialized\");\n+\t\terror (\"no field `%s' in union being initialized\",\n+\t\t       IDENTIFIER_POINTER (TREE_PURPOSE (tail)));\n \t    }\n \t  if (!win)\n \t    TREE_VALUE (tail) = error_mark_node;"}]}