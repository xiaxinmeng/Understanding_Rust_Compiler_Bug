{"sha": "0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "node_id": "C_kwDOANBUbNoAKDBhMGMyYzNmMDYyMjdkNDZiNWU5NTQyZGZkZDRlMGZkMmQ2N2Q4OTQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-18T17:49:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-18T18:02:19Z"}, "message": "c++: Fix up constexpr evaluation of new with zero sized types [PR104568]\n\nThe new expression constant expression evaluation right now tries to\ndeduce how many elts the array it uses for the heap or heap [] vars\nshould have (or how many elts should its trailing array have if it has\ncookie at the start).  As new is lowered at that point to\n(some_type *) ::operator new (size)\nor so, it computes it by subtracting cookie size if any from size, then\ndivides the result by sizeof (some_type).\nThis works fine for most types, except when sizeof (some_type) is 0,\nthen we divide by zero; size is then equal to cookie_size (or if there\nis no cookie, to 0).\nThe following patch special cases those cases so that we don't divide\nby zero and also recover the original outer_nelts from the expression\nby forcing the size not to be folded in that case but be explicit\n0 * outer_nelts or cookie_size + 0 * outer_nelts.\n\nNote, we have further issues, we accept-invalid various cases, for both\nzero sized elt_type and even non-zero sized elts, we aren't able to\ndiagnose out of bounds POINTER_PLUS_EXPR like:\nconstexpr bool\nfoo ()\n{\n  auto p = new int[2];\n  auto q1 = &p[0];\n  auto q2 = &p[1];\n  auto q3 = &p[2];\n  auto q4 = &p[3];\n  delete[] p;\n  return true;\n}\nconstexpr bool a = foo ();\nThat doesn't look like a regression so I think we should resolve that for\nGCC 13, but there are 2 problems.  Figure out why\ncxx_fold_pointer_plus_expression doesn't deal with the &heap []\netc. cases, and for the zero sized arrays, I think we really need to preserve\nwhether user wrote an array ref or pointer addition, because in the\n&p[3] case if sizeof(p[0]) == 0 we know that if it has 2 elements it is\nout of bounds, while if we see p p+ 0 the information if it was\np + 2 or p + 3 in the source is lost.\nclang++ seems to handle it fine even in the zero sized cases or with\nnew expressions.\n\n2022-03-18  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/104568\n\t* init.cc (build_new_constexpr_heap_type): Remove FULL_SIZE\n\targument and its handling, instead add ITYPE2 argument.  Only\n\tsupport COOKIE_SIZE != NULL.\n\t(build_new_1): If size is 0, change it to 0 * outer_nelts if\n\touter_nelts is non-NULL.  Pass type rather than elt_type to\n\tmaybe_wrap_new_for_constexpr.\n\t* constexpr.cc (build_new_constexpr_heap_type): New function.\n\t(cxx_eval_constant_expression) <case CONVERT_EXPR>:\n\tIf elt_size is zero sized type, try to recover outer_nelts from\n\tthe size argument to operator new/new[] and pass that as\n\targ_size to build_new_constexpr_heap_type.  Pass ctx,\n\tnon_constant_p and overflow_p to that call too.\n\n\t* g++.dg/cpp2a/constexpr-new22.C: New test.", "tree": {"sha": "1823583497af8c3323a7f8983e4353aab86a35e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1823583497af8c3323a7f8983e4353aab86a35e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9131a329a92074decb91a69e70480a431918e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9131a329a92074decb91a69e70480a431918e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9131a329a92074decb91a69e70480a431918e4a"}], "stats": {"total": 175, "additions": 149, "deletions": 26}, "files": [{"sha": "a3136ce819dd9b6beebd7e04e4fda132cb765c9f", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 93, "deletions": 2, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "patch": "@@ -6422,6 +6422,84 @@ maybe_warn_about_constant_value (location_t loc, tree decl)\n     }\n }\n \n+/* For element type ELT_TYPE, return the appropriate type of the heap object\n+   containing such element(s).  COOKIE_SIZE is NULL or the size of cookie\n+   in bytes.  If COOKIE_SIZE is NULL, return array type\n+   ELT_TYPE[FULL_SIZE / sizeof(ELT_TYPE)], otherwise return\n+   struct { size_t[COOKIE_SIZE/sizeof(size_t)]; ELT_TYPE[N]; }\n+   where N is is computed such that the size of the struct fits into FULL_SIZE.\n+   If ARG_SIZE is non-NULL, it is the first argument to the new operator.\n+   It should be passed if ELT_TYPE is zero sized type in which case FULL_SIZE\n+   will be also 0 and so it is not possible to determine the actual array\n+   size.  CTX, NON_CONSTANT_P and OVERFLOW_P are used during constant\n+   expression evaluation of subexpressions of ARG_SIZE.  */\n+\n+static tree\n+build_new_constexpr_heap_type (const constexpr_ctx *ctx, tree elt_type,\n+\t\t\t       tree cookie_size, tree full_size, tree arg_size,\n+\t\t\t       bool *non_constant_p, bool *overflow_p)\n+{\n+  gcc_assert (cookie_size == NULL_TREE || tree_fits_uhwi_p (cookie_size));\n+  gcc_assert (tree_fits_uhwi_p (full_size));\n+  unsigned HOST_WIDE_INT csz = cookie_size ? tree_to_uhwi (cookie_size) : 0;\n+  if (arg_size)\n+    {\n+      STRIP_NOPS (arg_size);\n+      if (cookie_size)\n+\t{\n+\t  if (TREE_CODE (arg_size) != PLUS_EXPR)\n+\t    arg_size = NULL_TREE;\n+\t  else if (TREE_CODE (TREE_OPERAND (arg_size, 0)) == INTEGER_CST\n+\t\t   && tree_int_cst_equal (cookie_size,\n+\t\t\t\t\t  TREE_OPERAND (arg_size, 0)))\n+\t    {\n+\t      arg_size = TREE_OPERAND (arg_size, 1);\n+\t      STRIP_NOPS (arg_size);\n+\t    }\n+\t  else if (TREE_CODE (TREE_OPERAND (arg_size, 1)) == INTEGER_CST\n+\t\t   && tree_int_cst_equal (cookie_size,\n+\t\t\t\t\t  TREE_OPERAND (arg_size, 1)))\n+\t    {\n+\t      arg_size = TREE_OPERAND (arg_size, 0);\n+\t      STRIP_NOPS (arg_size);\n+\t    }\n+\t  else\n+\t    arg_size = NULL_TREE;\n+\t}\n+      if (arg_size && TREE_CODE (arg_size) == MULT_EXPR)\n+\t{\n+\t  tree op0 = TREE_OPERAND (arg_size, 0);\n+\t  tree op1 = TREE_OPERAND (arg_size, 1);\n+\t  if (integer_zerop (op0))\n+\t    arg_size\n+\t      = cxx_eval_constant_expression (ctx, op1, false, non_constant_p,\n+\t\t\t\t\t      overflow_p);\n+\t  else if (integer_zerop (op1))\n+\t    arg_size\n+\t      = cxx_eval_constant_expression (ctx, op0, false, non_constant_p,\n+\t\t\t\t\t      overflow_p);\n+\t  else\n+\t    arg_size = NULL_TREE;\n+\t}\n+      else\n+\targ_size = NULL_TREE;\n+    }\n+\n+  unsigned HOST_WIDE_INT fsz = tree_to_uhwi (arg_size ? arg_size : full_size);\n+  if (!arg_size)\n+    {\n+      unsigned HOST_WIDE_INT esz = int_size_in_bytes (elt_type);\n+      gcc_assert (fsz >= csz);\n+      fsz -= csz;\n+      if (esz)\n+\tfsz /= esz;\n+    }\n+  tree itype2 = build_index_type (size_int (fsz - 1));\n+  if (!cookie_size)\n+    return build_cplus_array_type (elt_type, itype2);\n+  return build_new_constexpr_heap_type (elt_type, cookie_size, itype2);\n+}\n+\n /* Attempt to reduce the expression T to a constant value.\n    On failure, issue diagnostic and return error_mark_node.  */\n /* FIXME unify with c_fully_fold */\n@@ -7253,6 +7331,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    tree var_size = TYPE_SIZE_UNIT (TREE_TYPE (var));\n \t    tree elt_type = TREE_TYPE (type);\n \t    tree cookie_size = NULL_TREE;\n+\t    tree arg_size = NULL_TREE;\n \t    if (TREE_CODE (elt_type) == RECORD_TYPE\n \t\t&& TYPE_NAME (elt_type) == heap_identifier)\n \t      {\n@@ -7264,9 +7343,21 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    DECL_NAME (var)\n \t      = (DECL_NAME (var) == heap_uninit_identifier\n \t\t ? heap_identifier : heap_vec_identifier);\n+\t    /* For zero sized elt_type, try to recover how many outer_nelts\n+\t       it should have.  */\n+\t    if ((cookie_size ? tree_int_cst_equal (var_size, cookie_size)\n+\t\t\t     : integer_zerop (var_size))\n+\t\t&& !int_size_in_bytes (elt_type)\n+\t\t&& TREE_CODE (oldop) == CALL_EXPR\n+\t\t&& call_expr_nargs (oldop) >= 1)\n+\t      if (tree fun = get_function_named_in_call (oldop))\n+\t\tif (cxx_replaceable_global_alloc_fn (fun)\n+\t\t    && IDENTIFIER_NEW_OP_P (DECL_NAME (fun)))\n+\t\t  arg_size = CALL_EXPR_ARG (oldop, 0);\n \t    TREE_TYPE (var)\n-\t      = build_new_constexpr_heap_type (elt_type, cookie_size,\n-\t\t\t\t\t       var_size);\n+\t      = build_new_constexpr_heap_type (ctx, elt_type, cookie_size,\n+\t\t\t\t\t       var_size, arg_size,\n+\t\t\t\t\t       non_constant_p, overflow_p);\n \t    TREE_TYPE (TREE_OPERAND (op, 0))\n \t      = build_pointer_type (TREE_TYPE (var));\n \t  }"}, {"sha": "7575597c8fd1075fc90c8c62e0b8e965ab535a4f", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "patch": "@@ -2931,33 +2931,17 @@ std_placement_new_fn_p (tree alloc_fn)\n }\n \n /* For element type ELT_TYPE, return the appropriate type of the heap object\n-   containing such element(s).  COOKIE_SIZE is NULL or the size of cookie\n-   in bytes.  FULL_SIZE is NULL if it is unknown how big the heap allocation\n-   will be, otherwise size of the heap object.  If COOKIE_SIZE is NULL,\n-   return array type ELT_TYPE[FULL_SIZE / sizeof(ELT_TYPE)], otherwise return\n+   containing such element(s).  COOKIE_SIZE is the size of cookie in bytes.\n+   Return\n    struct { size_t[COOKIE_SIZE/sizeof(size_t)]; ELT_TYPE[N]; }\n-   where N is nothing (flexible array member) if FULL_SIZE is NULL, otherwise\n-   it is computed such that the size of the struct fits into FULL_SIZE.  */\n+   where N is nothing (flexible array member) if ITYPE2 is NULL, otherwise\n+   the array has ITYPE2 as its TYPE_DOMAIN.  */\n \n tree\n-build_new_constexpr_heap_type (tree elt_type, tree cookie_size, tree full_size)\n+build_new_constexpr_heap_type (tree elt_type, tree cookie_size, tree itype2)\n {\n-  gcc_assert (cookie_size == NULL_TREE || tree_fits_uhwi_p (cookie_size));\n-  gcc_assert (full_size == NULL_TREE || tree_fits_uhwi_p (full_size));\n-  unsigned HOST_WIDE_INT csz = cookie_size ? tree_to_uhwi (cookie_size) : 0;\n-  tree itype2 = NULL_TREE;\n-  if (full_size)\n-    {\n-      unsigned HOST_WIDE_INT fsz = tree_to_uhwi (full_size);\n-      gcc_assert (fsz >= csz);\n-      fsz -= csz;\n-      fsz /= int_size_in_bytes (elt_type);\n-      itype2 = build_index_type (size_int (fsz - 1));\n-      if (!cookie_size)\n-\treturn build_cplus_array_type (elt_type, itype2);\n-    }\n-  else\n-    gcc_assert (cookie_size);\n+  gcc_assert (tree_fits_uhwi_p (cookie_size));\n+  unsigned HOST_WIDE_INT csz = tree_to_uhwi (cookie_size);\n   csz /= int_size_in_bytes (sizetype);\n   tree itype1 = build_index_type (size_int (csz - 1));\n   tree atype1 = build_cplus_array_type (sizetype, itype1);\n@@ -3408,6 +3392,12 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t    outer_nelts_check = NULL_TREE;\n \t}\n \n+      /* If size is zero e.g. due to type having zero size, try to\n+\t preserve outer_nelts for constant expression evaluation\n+\t purposes.  */\n+      if (integer_zerop (size) && outer_nelts)\n+\tsize = build2 (MULT_EXPR, TREE_TYPE (size), size, outer_nelts);\n+\n       alloc_call = build_operator_new_call (fnname, placement,\n \t\t\t\t\t    &size, &cookie_size,\n \t\t\t\t\t    align_arg, outer_nelts_check,\n@@ -3484,7 +3474,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n     }\n \n   if (cookie_size)\n-    alloc_call = maybe_wrap_new_for_constexpr (alloc_call, elt_type,\n+    alloc_call = maybe_wrap_new_for_constexpr (alloc_call, type,\n \t\t\t\t\t       cookie_size);\n \n   /* In the simple case, we can stop now.  */"}, {"sha": "9af9c9f93aebb573c79f9f9ae21e58c213ec87a5", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new22.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new22.C?ref=0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "patch": "@@ -0,0 +1,42 @@\n+// PR c++/104568\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"\" }\n+\n+struct S { int s; constexpr S () : s (0) {} constexpr ~S () {} };\n+typedef int T[0];\n+typedef int U[0];\n+\n+constexpr bool\n+foo ()\n+{\n+  auto p = new T[2];\n+  auto q1 = &p[0];\n+  auto q2 = &p[1];\n+  auto q3 = &p[2];\n+  delete[] p;\n+  return true;\n+}\n+\n+constexpr bool\n+bar ()\n+{\n+  auto p = new U[2];\n+  auto q1 = &p[0];\n+  auto q2 = &p[1];\n+  auto q3 = &p[2];\n+  delete[] p;\n+  return true;\n+}\n+\n+constexpr bool\n+baz ()\n+{\n+  auto p = new T[0];\n+  auto q1 = &p[0];\n+  delete[] p;\n+  return true;\n+}\n+\n+constexpr bool a = foo ();\n+constexpr bool b = bar ();\n+constexpr bool c = baz ();"}]}