{"sha": "a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxZGM5ZDE1MjliOGE4MDcxZTM2YjIyYjZlODQ5MmZjMmNlN2Q1YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-24T10:55:27Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-24T12:11:32Z"}, "message": "Emit .file 0 directive earlier in DWARF 5\n\nWhen the assembler supports it, the compiler automatically passes --gdwarf-5\nto it, which has an interesting side effect: any assembly instruction prior\nto the first .file directive defines a new line associated with .file 0 in\nthe .debug_line section and of course the numbering of these implicit lines\nhas nothing to do with that of the source code.  This can be problematic in\nAda when we do not generate .file/.loc directives for compiled-generated\nfunctions to avoid too jumpy a debugging experience.\n\ngcc/\n\t* dwarf2out.c (dwarf2out_assembly_start): Emit .file 0 marker here..\n\t(dwarf2out_finish): ...instead of here.", "tree": {"sha": "829f01cd963c51ac561180550349df52c3d3f7fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/829f01cd963c51ac561180550349df52c3d3f7fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a/comments", "author": null, "committer": null, "parents": [{"sha": "aca1213627d1d5e5a70ce956cf227be9ae9b4022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca1213627d1d5e5a70ce956cf227be9ae9b4022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca1213627d1d5e5a70ce956cf227be9ae9b4022"}], "stats": {"total": 45, "additions": 24, "deletions": 21}, "files": [{"sha": "9a91981acb078556b677b9cdb230fffa206ec395", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a21dc9d1529b8a8071e36b22b6e8492fc2ce7d5a", "patch": "@@ -29363,6 +29363,30 @@ dwarf2out_assembly_start (void)\n       && dwarf2out_do_cfi_asm ()\n       && !dwarf2out_do_eh_frame ())\n     fprintf (asm_out_file, \"\\t.cfi_sections\\t.debug_frame\\n\");\n+\n+#if defined(HAVE_AS_GDWARF_5_DEBUG_FLAG) && defined(HAVE_AS_WORKING_DWARF_N_FLAG)\n+  if (output_asm_line_debug_info () && dwarf_version >= 5)\n+    {\n+      /* When gas outputs DWARF5 .debug_line[_str] then we have to\n+\t tell it the comp_dir and main file name for the zero entry\n+\t line table.  */\n+      const char *comp_dir, *filename0;\n+\n+      comp_dir = comp_dir_string ();\n+      if (comp_dir == NULL)\n+\tcomp_dir = \"\";\n+\n+      filename0 = get_AT_string (comp_unit_die (), DW_AT_name);\n+      if (filename0 == NULL)\n+\tfilename0 = \"\";\n+\n+      fprintf (asm_out_file, \"\\t.file 0 \");\n+      output_quoted_string (asm_out_file, remap_debug_filename (comp_dir));\n+      fputc (' ', asm_out_file);\n+      output_quoted_string (asm_out_file, remap_debug_filename (filename0));\n+      fputc ('\\n', asm_out_file);\n+    }\n+#endif\n }\n \n /* A helper function for dwarf2out_finish called through\n@@ -32315,27 +32339,6 @@ dwarf2out_finish (const char *filename)\n   ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);\n   if (! output_asm_line_debug_info ())\n     output_line_info (false);\n-  else if (asm_outputs_debug_line_str ())\n-    {\n-      /* When gas outputs DWARF5 .debug_line[_str] then we have to\n-\t tell it the comp_dir and main file name for the zero entry\n-\t line table.  */\n-      const char *comp_dir, *filename0;\n-\n-      comp_dir = comp_dir_string ();\n-      if (comp_dir == NULL)\n-\tcomp_dir = \"\";\n-\n-      filename0 = get_AT_string (comp_unit_die (), DW_AT_name);\n-      if (filename0 == NULL)\n-\tfilename0 = \"\";\n-\n-      fprintf (asm_out_file, \"\\t.file 0 \");\n-      output_quoted_string (asm_out_file, remap_debug_filename (comp_dir));\n-      fputc (' ', asm_out_file);\n-      output_quoted_string (asm_out_file, remap_debug_filename (filename0));\n-      fputc ('\\n', asm_out_file);\n-    }\n \n   if (dwarf_split_debug_info && info_section_emitted)\n     {"}]}