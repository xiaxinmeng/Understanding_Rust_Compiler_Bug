{"sha": "4aae8a9a4b76096ecedba3b01161ba4e86d154be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFhZThhOWE0Yjc2MDk2ZWNlZGJhM2IwMTE2MWJhNGU4NmQxNTRiZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-26T19:59:27Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-26T19:59:27Z"}, "message": "i386-modes.def: Fix comment typos.\n\n\t* config/i386/i386-modes.def: Fix comment typos.\n\t* config/i386/i386.c: Likewise.\n\t* config/i386/i386.md: Likewise.\n\nFrom-SVN: r61855", "tree": {"sha": "b728b2882120a386bce9982fa12334575eb042c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b728b2882120a386bce9982fa12334575eb042c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4aae8a9a4b76096ecedba3b01161ba4e86d154be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aae8a9a4b76096ecedba3b01161ba4e86d154be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aae8a9a4b76096ecedba3b01161ba4e86d154be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aae8a9a4b76096ecedba3b01161ba4e86d154be/comments", "author": null, "committer": null, "parents": [{"sha": "7aa6688e8e3fec6ae3b5308f04bf3e5c7db462db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aa6688e8e3fec6ae3b5308f04bf3e5c7db462db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aa6688e8e3fec6ae3b5308f04bf3e5c7db462db"}], "stats": {"total": 16, "additions": 11, "deletions": 5}, "files": [{"sha": "77b21d895f177200f8c06587c48e89c2b16b104b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4aae8a9a4b76096ecedba3b01161ba4e86d154be", "patch": "@@ -1,3 +1,9 @@\n+2003-01-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/i386/i386-modes.def: Fix comment typos.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/i386/i386.md: Likewise.\n+\n 2003-01-26  Steven Bosscher  <s.bosscher@student.tudelft.nl>\n \n \t* config/avr/avr.h, config/cris/aout.h, config/elfos.h,"}, {"sha": "fd0f03d390a24219c0106054d7f56ee4e0e715f7", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=4aae8a9a4b76096ecedba3b01161ba4e86d154be", "patch": "@@ -27,11 +27,11 @@ Boston, MA 02111-1307, USA.  */\n    Overflow flag to be unset.  Sign bit test is used instead and\n    thus can be used to form \"a&b>0\" type of tests.\n \n-   Add CCGC to indicate comparisons agains zero that allows\n+   Add CCGC to indicate comparisons against zero that allows\n    unspecified garbage in the Carry flag.  This mode is used\n    by inc/dec instructions.\n \n-   Add CCGOC to indicate comparisons agains zero that allows\n+   Add CCGOC to indicate comparisons against zero that allows\n    unspecified garbage in the Carry and Overflow flag. This\n    mode is used to simulate comparisons of (a-b) and (a+b)\n    against zero using sub/cmp/add operations."}, {"sha": "d963667d005adb4b3416cb38921b11fbf184eee6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4aae8a9a4b76096ecedba3b01161ba4e86d154be", "patch": "@@ -8465,7 +8465,7 @@ ix86_cc_mode (code, op0, op1)\n \treturn CCGCmode;\n       /* Codes doable only with sign flag when comparing\n          against zero, but we miss jump instruction for it\n-         so we need to use relational tests agains overflow\n+         so we need to use relational tests against overflow\n          that thus needs to be zero.  */\n     case GT:\t\t\t/* ZF=0 & SF=OF */\n     case LE:\t\t\t/* ZF=1 | SF<>OF */\n@@ -10765,7 +10765,7 @@ ix86_expand_movstr (dst, src, count_exp, align_exp)\n          handle small counts using the loops.  Many CPUs (such as Athlon)\n          have large REP prefix setup costs.\n \n-         This is quite costy.  Maybe we can revisit this decision later or\n+         This is quite costly.  Maybe we can revisit this decision later or\n          add some customizability to this code.  */\n \n       if (count == 0 && align < desired_alignment)"}, {"sha": "b17579fbf8a9e9080e5897eb8b54395d8df95904", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aae8a9a4b76096ecedba3b01161ba4e86d154be/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4aae8a9a4b76096ecedba3b01161ba4e86d154be", "patch": "@@ -5867,7 +5867,7 @@\n \t(const_string \"alu\")))\n    (set_attr \"mode\" \"SI\")])\n \n-; For comparisons agains 1, -1 and 128, we may generate better code\n+; For comparisons against 1, -1 and 128, we may generate better code\n ; by converting cmp to add, inc or dec as done by peephole2.  This pattern\n ; is matched then.  We can't accept general immediate, because for\n ; case of overflows,  the result is messed up."}]}