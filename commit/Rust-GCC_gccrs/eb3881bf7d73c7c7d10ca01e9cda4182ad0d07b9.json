{"sha": "eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIzODgxYmY3ZDczYzdjN2QxMGNhMDFlOWNkYTQxODJhZDBkMDdiOQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-06-03T20:00:16Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-06-03T20:00:16Z"}, "message": "sh.c (fixup_addr_diff_vecs): Emit braf reference label.\n\n\t* sh.c (fixup_addr_diff_vecs): Emit braf reference label.\n\t(braf_label_ref_operand): Delete.\n\t* sh.h (PREDICATE_CODES): Remove braf_label_ref_operand.\n\t* sh.md (casesi_jump_2): Operand1 is now the inside of a\n\tlabel_ref, and has no predicate.\n\tThe patten has a predicate to guard against invalid substitutions.\n\t(dummy_jump): Delete.\n\t(casesi): Update use of casesi_jump_2.\n\nFrom-SVN: r27329", "tree": {"sha": "f7c07bdf5f360c560962565eb708fce8c60d76f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7c07bdf5f360c560962565eb708fce8c60d76f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/comments", "author": null, "committer": null, "parents": [{"sha": "b89c5a7b53874bf0fa55f53a8ebbf16cc23ed345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89c5a7b53874bf0fa55f53a8ebbf16cc23ed345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89c5a7b53874bf0fa55f53a8ebbf16cc23ed345"}], "stats": {"total": 71, "additions": 23, "deletions": 48}, "files": [{"sha": "310c918e5c3a439873313e3689a6144c810f3d7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "patch": "@@ -1,3 +1,14 @@\n+Fri Jun  4 03:20:40 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* sh.c (fixup_addr_diff_vecs): Emit braf reference label.\n+\t(braf_label_ref_operand): Delete.\n+\t* sh.h (PREDICATE_CODES): Remove braf_label_ref_operand.\n+\t* sh.md (casesi_jump_2): Operand1 is now the inside of a\n+\tlabel_ref, and has no predicate.\n+\tThe patten has a predicate to guard against invalid substitutions.\n+\t(dummy_jump): Delete.\n+\t(casesi): Update use of casesi_jump_2.\n+\n Thu Jun 3 07:48 1999  Bruce Korb <ddsinc09@ix.netcom.com>\n \n \t*fixinc/inclhack.def(Io_Def_Quotes): corrected sed expression"}, {"sha": "feca33e1b227c93b722a393fe20a4f0fa683f0e8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "patch": "@@ -2641,7 +2641,7 @@ fixup_addr_diff_vecs (first)\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n-      rtx vec_lab, pat, prev, prevpat, x;\n+      rtx vec_lab, pat, prev, prevpat, x, braf_label;\n \n       if (GET_CODE (insn) != JUMP_INSN\n \t  || GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n@@ -2664,10 +2664,15 @@ fixup_addr_diff_vecs (first)\n \t  if (GET_CODE (x) == LABEL_REF && XEXP (x, 0) == vec_lab)\n \t    break;\n \t}\n+\n+      /* Emit the reference label of the braf where it belongs, right after\n+\t the casesi_jump_2 (i.e. braf).  */\n+      braf_label = XEXP (XEXP (SET_SRC (XVECEXP (prevpat, 0, 0)), 1), 0);\n+      emit_label_after (braf_label, prev);\n+\n       /* Fix up the ADDR_DIF_VEC to be relative\n \t to the reference address of the braf.  */\n-      XEXP (XEXP (pat, 0), 0)\n-\t= XEXP (XEXP (SET_SRC (XVECEXP (prevpat, 0, 0)), 1), 0);\n+      XEXP (XEXP (pat, 0), 0) = braf_label;\n     }\n }\n \n@@ -4303,29 +4308,6 @@ fp_one_operand (op)\n   return REAL_VALUES_EQUAL (r, dconst1);\n }\n \n-int\n-braf_label_ref_operand(op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  rtx prev;\n-\n-  if (GET_CODE (op) != LABEL_REF)\n-    return 0;\n-  prev = prev_real_insn (XEXP (op, 0));\n-  if (GET_CODE (prev) != JUMP_INSN)\n-    return 0;\n-  prev = PATTERN (prev);\n-  if (GET_CODE (prev) != PARALLEL || XVECLEN (prev, 0) != 2)\n-    return 0;\n-  prev = XVECEXP (prev, 0, 0);\n-  if (GET_CODE (prev) != SET)\n-    return 0;\n-  prev = SET_SRC (prev);\n-  if (GET_CODE (prev) != PLUS || XEXP (prev, 1) != op)\n-    return 0;\n-}\n-\n int\n tertiary_reload_operand (op, mode)\n      rtx op;"}, {"sha": "644668f903949737573d76e79e0b68767d9c89d7", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "patch": "@@ -2129,7 +2129,6 @@ extern struct rtx_def *get_fpscr_rtx ();\n   {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"binary_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n-  {\"braf_label_ref_operand\", {LABEL_REF}},\t\t\t\t\\\n   {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n   {\"fp_arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"fp_extended_operand\", {SUBREG, REG, FLOAT_EXTEND}},\t\t\t\\"}, {"sha": "e4648bb325fa62faee0a2b3194721a99b255da2f", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=eb3881bf7d73c7c7d10ca01e9cda4182ad0d07b9", "patch": "@@ -3203,19 +3203,13 @@\n ;; For all later processors.\n (define_insn \"casesi_jump_2\"\n   [(set (pc) (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t      (match_operand 1 \"braf_label_ref_operand\" \"\")))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))\n    (use (label_ref (match_operand 2 \"\" \"\")))]\n-  \"\"\n+  \"! INSN_UID (operands[1]) || prev_real_insn (operands[1]) == insn\"\n   \"braf\t%0%#\"\n   [(set_attr \"needs_delay_slot\" \"yes\")\n    (set_attr \"type\" \"jump_ind\")])\n \n-(define_insn \"dummy_jump\"\n-  [(set (pc) (const_int 0))]\n-  \"\"\n-  \"\"\n-  [(set_attr \"length\" \"0\")])\n-\n ;; Call subroutine returning any type.\n ;; ??? This probably doesn't work.\n \n@@ -3302,20 +3296,9 @@\n \t\t\t   reg));\n   emit_insn (gen_casesi_worker_0 (reg2, reg, operands[3]));\n   if (TARGET_SH2)\n-    {\n-      rtx lab = gen_label_rtx ();\n-      emit_jump_insn (gen_casesi_jump_2 (reg2,\n-\t\t\t\t\t gen_rtx (LABEL_REF, VOIDmode, lab),\n-\t\t\t\t\t operands[3]));\n-      emit_label (lab);\n-      /* Put a fake jump after the label, lest some optimization might\n-\t delete the barrier and LAB.  */\n-      emit_jump_insn (gen_dummy_jump ());\n-    }\n+    emit_jump_insn (gen_casesi_jump_2 (reg2, gen_label_rtx (), operands[3]));\n   else\n-    {\n-      emit_jump_insn (gen_casesi_jump_1 (reg2, operands[3]));\n-    }\n+    emit_jump_insn (gen_casesi_jump_1 (reg2, operands[3]));\n   /* For SH2 and newer, the ADDR_DIFF_VEC is not actually relative to\n      operands[3], but to lab.  We will fix this up in\n      machine_dependent_reorg.  */"}]}