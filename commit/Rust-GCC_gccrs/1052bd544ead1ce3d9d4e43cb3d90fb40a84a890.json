{"sha": "1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1MmJkNTQ0ZWFkMWNlM2Q5ZDRlNDNjYjNkOTBmYjQwYTg0YTg5MA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-12-22T14:23:40Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-12-22T14:23:40Z"}, "message": "df.c (df_bitmaps_free): Only work for bbs for that structures are allocated.\n\n\t* df.c (df_bitmaps_free): Only work for bbs for that structures are\n\tallocated.\n\t(df_bb_modify): Realloc tables to the new index.\n\t(df_find_use): New function.\n\t(df_find_def, df_reg_used): Handle subregs.\n\t* df.h (df_find_use): Declare.\n\n\t* loop-invariant.c: Include hashtab.h.\n\t(struct invariant): Remove processed field, add eqto and reg fields.\n\t(struct invariant_expr_entry): New.\n\t(invariant_for_use, hash_invariant_expr_1, invariant_expr_equal_p,\n\thash_invariant_expr, eq_invariant_expr, find_or_insert_inv,\n\tfind_identical_invariants, merge_identical_invariants): New functions.\n\t(create_new_invariant): Return the new invariant.  Initialize new\n\tfields.\n\t(find_invariants): Call merge_identical_invariants.\n\t(get_inv_cost, best_gain_for_invariant, set_move_mark,\n\tmove_invariant_reg): Handle equivalent invariants.\n\t* Makefile.in (loop-invariant.o): Add HASHTAB_H dependency.\n\n\nCo-Authored-By: Steven Bosscher <stevenb@suse.de>\n\nFrom-SVN: r108949", "tree": {"sha": "85322ca05abf7b49ec62b5f1ab6e6fd391a10f29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85322ca05abf7b49ec62b5f1ab6e6fd391a10f29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/comments", "author": null, "committer": null, "parents": [{"sha": "ab84748af1b9eb158f6a2cb0d2f8be97f196a5f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab84748af1b9eb158f6a2cb0d2f8be97f196a5f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab84748af1b9eb158f6a2cb0d2f8be97f196a5f2"}], "stats": {"total": 516, "additions": 437, "deletions": 79}, "files": [{"sha": "b264973f82c5a957cb33b09c88e5ee65ac4d6233", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "patch": "@@ -1,3 +1,26 @@\n+2005-12-22  Zdenek Dvorak <dvorakz@suse.cz>\n+\t    Steven Bosscher <stevenb@suse.de>\n+\n+\t* df.c (df_bitmaps_free): Only work for bbs for that structures are\n+\tallocated.\n+\t(df_bb_modify): Realloc tables to the new index.\n+\t(df_find_use): New function.\n+\t(df_find_def, df_reg_used): Handle subregs.\n+\t* df.h (df_find_use): Declare.\n+\n+\t* loop-invariant.c: Include hashtab.h.\n+\t(struct invariant): Remove processed field, add eqto and reg fields.\n+\t(struct invariant_expr_entry): New.\n+\t(invariant_for_use, hash_invariant_expr_1, invariant_expr_equal_p,\n+\thash_invariant_expr, eq_invariant_expr, find_or_insert_inv,\n+\tfind_identical_invariants, merge_identical_invariants): New functions.\n+\t(create_new_invariant): Return the new invariant.  Initialize new\n+\tfields.\n+\t(find_invariants): Call merge_identical_invariants.\n+\t(get_inv_cost, best_gain_for_invariant, set_move_mark,\n+\tmove_invariant_reg): Handle equivalent invariants.\n+\t* Makefile.in (loop-invariant.o): Add HASHTAB_H dependency.\n+\n 2005-12-22  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/23333"}, {"sha": "a94bf4497caa3965b54331c29f19c80947c3dc9f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "patch": "@@ -2372,7 +2372,8 @@ loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    output.h intl.h\n loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h \\\n-   $(TM_H) $(TM_P_H) function.h $(FLAGS_H) $(DF_H) $(OBSTACK_H) output.h\n+   $(TM_H) $(TM_P_H) function.h $(FLAGS_H) $(DF_H) $(OBSTACK_H) output.h \\\n+   $(HASHTAB_H)\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) output.h \\\n    coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H)"}, {"sha": "fafd06dad4574dfef672ab38d0ac30b04239a1ba", "filename": "gcc/df.c", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "patch": "@@ -451,14 +451,11 @@ df_bitmaps_alloc (struct df *df, bitmap blocks, int flags)\n static void\n df_bitmaps_free (struct df *df, int flags)\n {\n-  basic_block bb;\n+  unsigned i;\n \n-  FOR_EACH_BB (bb)\n+  for (i = 0; i < df->n_bbs; i++)\n     {\n-      struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-\n-      if (!bb_info)\n-\tcontinue;\n+      struct bb_info *bb_info = &df->bbs[i];\n \n       if ((flags & DF_RD) && bb_info->rd_in)\n \t{\n@@ -2636,7 +2633,7 @@ static void\n df_bb_modify (struct df *df, basic_block bb)\n {\n   if ((unsigned) bb->index >= df->n_bbs)\n-    df_bb_table_realloc (df, df->n_bbs);\n+    df_bb_table_realloc (df, bb->index);\n \n   bitmap_set_bit (df->bbs_modified, bb->index);\n }\n@@ -3032,25 +3029,42 @@ df_find_def (struct df *df, rtx insn, rtx reg)\n {\n   struct df_link *defs;\n \n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  gcc_assert (REG_P (reg));\n+\n   for (defs = DF_INSN_DEFS (df, insn); defs; defs = defs->next)\n-    if (rtx_equal_p (DF_REF_REG (defs->ref), reg))\n+    if (rtx_equal_p (DF_REF_REAL_REG (defs->ref), reg))\n       return defs->ref;\n \n   return NULL;\n }\n \n-/* Return 1 if REG is referenced in INSN, zero otherwise.  */ \n+/* Finds the reference corresponding to the use of REG in INSN.\n+   DF is the dataflow object.  */\n \n-int\n-df_reg_used (struct df *df, rtx insn, rtx reg)\n+struct ref *\n+df_find_use (struct df *df, rtx insn, rtx reg)\n {\n   struct df_link *uses;\n \n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  gcc_assert (REG_P (reg));\n+\n   for (uses = DF_INSN_USES (df, insn); uses; uses = uses->next)\n-    if (rtx_equal_p (DF_REF_REG (uses->ref), reg))\n-      return 1; \n+    if (rtx_equal_p (DF_REF_REAL_REG (uses->ref), reg))\n+      return uses->ref;\n \n-  return 0;\n+  return NULL;\n+}\n+\n+/* Return 1 if REG is referenced in INSN, zero otherwise.  */ \n+\n+int\n+df_reg_used (struct df *df, rtx insn, rtx reg)\n+{\n+  return df_find_use (df, insn, reg) != NULL;\n }\n \n static int"}, {"sha": "e2ad9774dfb7581fca6d36e441caa2ec5e021d45", "filename": "gcc/df.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "patch": "@@ -290,6 +290,8 @@ extern struct ref *df_bb_regno_last_def_find (struct df *, basic_block, unsigned\n \n extern struct ref *df_find_def (struct df *, rtx, rtx);\n \n+extern struct ref *df_find_use (struct df *, rtx, rtx);\n+\n extern int df_reg_used (struct df *, rtx, rtx);\n \n /* Functions for debugging from GDB.  */"}, {"sha": "8c3f2d23512d90bb2d04eb0f58f7bbacc3472c59", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 382, "deletions": 64, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1052bd544ead1ce3d9d4e43cb3d90fb40a84a890/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=1052bd544ead1ce3d9d4e43cb3d90fb40a84a890", "patch": "@@ -46,10 +46,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n #include \"expr.h\"\n+#include \"recog.h\"\n #include \"output.h\"\n #include \"function.h\"\n #include \"flags.h\"\n #include \"df.h\"\n+#include \"hashtab.h\"\n \n /* The data stored for the loop.  */\n \n@@ -88,8 +90,12 @@ struct invariant\n   /* The number of the invariant.  */\n   unsigned invno;\n \n-  /* Whether we already processed the invariant.  */\n-  bool processed;\n+  /* The number of the invariant with the same value.  */\n+  unsigned eqto;\n+\n+  /* If we moved the invariant out of the loop, the register that contains its\n+     value.  */\n+  rtx reg;\n \n   /* The definition of the invariant.  */\n   struct def *def;\n@@ -114,6 +120,23 @@ struct invariant\n   unsigned stamp;\n };\n \n+/* Entry for hash table of invariant expressions.  */\n+\n+struct invariant_expr_entry\n+{\n+  /* The invariant.  */\n+  struct invariant *inv;\n+\n+  /* Its value.  */\n+  rtx expr;\n+\n+  /* Its mode.  */\n+  enum machine_mode mode;\n+\n+  /* Its hash.  */\n+  hashval_t hash;\n+};\n+\n /* The actual stamp for marking already visited invariants during determining\n    costs of movements.  */\n \n@@ -199,6 +222,269 @@ check_maybe_invariant (rtx x)\n   return true;\n }\n \n+/* Returns the invariant definition for USE, or NULL if USE is not\n+   invariant.  */\n+\n+static struct invariant *\n+invariant_for_use (struct ref *use)\n+{\n+  struct df_link *defs;\n+  struct ref *def;\n+  basic_block bb = BLOCK_FOR_INSN (use->insn), def_bb;\n+\n+  defs = DF_REF_CHAIN (use);\n+  if (!defs || defs->next)\n+    return NULL;\n+  def = defs->ref;\n+  if (!DF_REF_DATA (def))\n+    return NULL;\n+\n+  def_bb = DF_REF_BB (def);\n+  if (!dominated_by_p (CDI_DOMINATORS, bb, def_bb))\n+    return NULL;\n+  return DF_REF_DATA (def);\n+}\n+\n+/* Computes hash value for invariant expression X in INSN.  */\n+\n+static hashval_t\n+hash_invariant_expr_1 (rtx insn, rtx x)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+  const char *fmt;\n+  hashval_t val = code;\n+  int do_not_record_p;\n+  struct ref *use;\n+  struct invariant *inv;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CONST:\n+    case LABEL_REF:\n+      return hash_rtx (x, GET_MODE (x), &do_not_record_p, NULL, false);\n+\n+    case REG:\n+      use = df_find_use (df, insn, x);\n+      if (!use)\n+\treturn hash_rtx (x, GET_MODE (x), &do_not_record_p, NULL, false);\n+      inv = invariant_for_use (use);\n+      if (!inv)\n+\treturn hash_rtx (x, GET_MODE (x), &do_not_record_p, NULL, false);\n+\n+      gcc_assert (inv->eqto != ~0u);\n+      return inv->eqto;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tval ^= hash_invariant_expr_1 (insn, XEXP (x, i));\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    val ^= hash_invariant_expr_1 (insn, XVECEXP (x, i, j));\n+\t}\n+    }\n+\n+  return val;\n+}\n+\n+/* Returns true if the invariant expressions E1 and E2 used in insns INSN1\n+   and INSN2 have always the same value.  */\n+\n+static bool\n+invariant_expr_equal_p (rtx insn1, rtx e1, rtx insn2, rtx e2)\n+{\n+  enum rtx_code code = GET_CODE (e1);\n+  int i, j;\n+  const char *fmt;\n+  struct ref *use1, *use2;\n+  struct invariant *inv1 = NULL, *inv2 = NULL;\n+  rtx sub1, sub2;\n+\n+  /* If mode of only one of the operands is VOIDmode, it is not equivalent to\n+     the other one.  If both are VOIDmode, we rely on the caller of this\n+     function to verify that their modes are the same.  */\n+  if (code != GET_CODE (e2) || GET_MODE (e1) != GET_MODE (e2))\n+    return false;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CONST:\n+    case LABEL_REF:\n+      return rtx_equal_p (e1, e2);\n+\n+    case REG:\n+      use1 = df_find_use (df, insn1, e1);\n+      use2 = df_find_use (df, insn2, e2);\n+      if (use1)\n+\tinv1 = invariant_for_use (use1);\n+      if (use2)\n+\tinv2 = invariant_for_use (use2);\n+\n+      if (!inv1 && !inv2)\n+\treturn rtx_equal_p (e1, e2);\n+\n+      if (!inv1 || !inv2)\n+\treturn false;\n+\n+      gcc_assert (inv1->eqto != ~0u);\n+      gcc_assert (inv2->eqto != ~0u);\n+      return inv1->eqto == inv2->eqto;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  sub1 = XEXP (e1, i);\n+\t  sub2 = XEXP (e2, i);\n+\n+\t  if (!invariant_expr_equal_p (insn1, sub1, insn2, sub2))\n+\t    return false;\n+\t}\n+\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  if (XVECLEN (e1, i) != XVECLEN (e2, i))\n+\t    return false;\n+\n+\t  for (j = 0; j < XVECLEN (e1, i); j++)\n+\t    {\n+\t      sub1 = XVECEXP (e1, i, j);\n+\t      sub2 = XVECEXP (e2, i, j);\n+\n+\t      if (!invariant_expr_equal_p (insn1, sub1, insn2, sub2))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Returns hash value for invariant expression entry E.  */\n+\n+static hashval_t\n+hash_invariant_expr (const void *e)\n+{\n+  const struct invariant_expr_entry *entry = e;\n+\n+  return entry->hash;\n+}\n+\n+/* Compares invariant expression entries E1 and E2.  */\n+\n+static int\n+eq_invariant_expr (const void *e1, const void *e2)\n+{\n+  const struct invariant_expr_entry *entry1 = e1;\n+  const struct invariant_expr_entry *entry2 = e2;\n+\n+  if (entry1->mode != entry2->mode)\n+    return 0;\n+\n+  return invariant_expr_equal_p (entry1->inv->insn, entry1->expr,\n+\t\t\t\t entry2->inv->insn, entry2->expr);\n+}\n+\n+/* Checks whether invariant with value EXPR in machine mode MODE is\n+   recorded in EQ.  If this is the case, return the invariant.  Otherwise\n+   insert INV to the table for this expression and return INV.  */\n+\n+static struct invariant *\n+find_or_insert_inv (htab_t eq, rtx expr, enum machine_mode mode,\n+\t\t    struct invariant *inv)\n+{\n+  hashval_t hash = hash_invariant_expr_1 (inv->insn, expr);\n+  struct invariant_expr_entry *entry;\n+  struct invariant_expr_entry pentry;\n+  PTR *slot;\n+\n+  pentry.expr = expr;\n+  pentry.inv = inv;\n+  pentry.mode = mode;\n+  slot = htab_find_slot_with_hash (eq, &pentry, hash, INSERT);\n+  entry = *slot;\n+\n+  if (entry)\n+    return entry->inv;\n+\n+  entry = xmalloc (sizeof (struct invariant_expr_entry));\n+  entry->inv = inv;\n+  entry->expr = expr;\n+  entry->mode = mode;\n+  entry->hash = hash;\n+  *slot = entry;\n+\n+  return inv;\n+}\n+\n+/* Finds invariants identical to INV and records the equivalence.  EQ is the\n+   hash table of the invariants.  */\n+\n+static void\n+find_identical_invariants (htab_t eq, struct invariant *inv)\n+{\n+  unsigned depno;\n+  bitmap_iterator bi;\n+  struct invariant *dep;\n+  rtx expr, set;\n+  enum machine_mode mode;\n+\n+  if (inv->eqto != ~0u)\n+    return;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno, bi)\n+    {\n+      dep = VEC_index (invariant_p, invariants, depno);\n+      find_identical_invariants (eq, dep);\n+    }\n+\n+  set = single_set (inv->insn);\n+  expr = SET_SRC (set);\n+  mode = GET_MODE (expr);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (SET_DEST (set));\n+  inv->eqto = find_or_insert_inv (eq, expr, mode, inv)->invno;\n+\n+  if (dump_file && inv->eqto != inv->invno)\n+    fprintf (dump_file,\n+\t     \"Invariant %d is equivalent to invariant %d.\\n \",\n+\t     inv->invno, inv->eqto);\n+}\n+\n+/* Find invariants with the same value and record the equivalences.  */\n+\n+static void\n+merge_identical_invariants (void)\n+{\n+  unsigned i;\n+  struct invariant *inv;\n+  htab_t eq = htab_create (VEC_length (invariant_p, invariants),\n+\t\t\t   hash_invariant_expr, eq_invariant_expr, free);\n+\n+  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n+    find_identical_invariants (eq, inv);\n+\n+  htab_delete (eq);\n+}\n+\n /* Determines the basic blocks inside LOOP that are always executed and\n    stores their bitmap to ALWAYS_REACHED.  MAY_EXIT is a bitmap of\n    basic blocks that may either exit the loop, or contain the call that\n@@ -320,9 +606,10 @@ find_defs (struct loop *loop, basic_block *body)\n \n /* Creates a new invariant for definition DEF in INSN, depending on invariants\n    in DEPENDS_ON.  ALWAYS_EXECUTED is true if the insn is always executed,\n-   unless the program ends due to a function call.  */\n+   unless the program ends due to a function call.  The newly created invariant\n+   is returned.  */\n \n-static void\n+static struct invariant *\n create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n \t\t      bool always_executed)\n {\n@@ -341,11 +628,12 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n     inv->cost = rtx_cost (SET_SRC (set), SET);\n \n   inv->move = false;\n-  inv->processed = false;\n+  inv->reg = NULL_RTX;\n   inv->stamp = 0;\n   inv->insn = insn;\n \n   inv->invno = VEC_length (invariant_p, invariants);\n+  inv->eqto = ~0u;\n   if (def)\n     def->invno = inv->invno;\n   VEC_safe_push (invariant_p, heap, invariants, inv);\n@@ -357,6 +645,8 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n \t       INSN_UID (insn), inv->invno, inv->cost);\n       dump_bitmap (dump_file, inv->depends_on);\n     }\n+\n+  return inv;\n }\n \n /* Record USE at DEF.  */\n@@ -387,7 +677,8 @@ check_dependencies (rtx insn, bitmap depends_on)\n   struct ref *use, *def;\n   basic_block bb = BLOCK_FOR_INSN (insn), def_bb;\n   struct def *def_data;\n-  \n+  struct invariant *inv;\n+\n   for (uses = DF_INSN_USES (df, insn); uses; uses = uses->next)\n     {\n       use = uses->ref;\n@@ -400,11 +691,17 @@ check_dependencies (rtx insn, bitmap depends_on)\n \treturn false;\n \n       def = defs->ref;\n-      def_data = DF_REF_DATA (def);\n-      if (!def_data)\n+      inv = DF_REF_DATA (def);\n+      if (!inv)\n \treturn false;\n \n+      def_data = inv->def;\n+      gcc_assert (def_data != NULL);\n+\n       def_bb = DF_REF_BB (def);\n+      /* Note that in case bb == def_bb, we know that the definition dominates\n+\t insn, because def has DF_REF_DATA defined and we process the insns\n+\t in the basic block bb sequentially.  */\n       if (!dominated_by_p (CDI_DOMINATORS, bb, def_bb))\n \treturn false;\n \n@@ -426,13 +723,14 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n   bitmap depends_on;\n   rtx set, dest;\n   bool simple = true;\n+  struct invariant *inv;\n \n   /* Until we get rid of LIBCALLS.  */\n   if (find_reg_note (insn, REG_RETVAL, NULL_RTX)\n       || find_reg_note (insn, REG_LIBCALL, NULL_RTX)\n       || find_reg_note (insn, REG_NO_CONFLICT, NULL_RTX))\n     return;\n- \n+\n   set = single_set (insn);\n   if (!set)\n     return;\n@@ -465,42 +763,34 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n     }\n \n   if (simple)\n-    {\n-      ref = df_find_def (df, insn, dest);\n-      def = xcalloc (1, sizeof (struct def));\n-      DF_REF_DATA (ref) = def;\n-    }\n+    def = xcalloc (1, sizeof (struct def));\n   else\n     def = NULL;\n \n-  create_new_invariant (def, insn, depends_on, always_executed);\n+  inv = create_new_invariant (def, insn, depends_on, always_executed);\n+\n+  if (simple)\n+    {\n+      ref = df_find_def (df, insn, dest);\n+      DF_REF_DATA (ref) = inv;\n+    }\n }\n \n /* Record registers used in INSN that have a unique invariant definition.  */\n \n static void\n record_uses (rtx insn)\n {\n-  struct df_link *uses, *defs;\n-  struct ref *use, *def;\n-  basic_block bb = BLOCK_FOR_INSN (insn), def_bb;\n-  \n+  struct df_link *uses;\n+  struct ref *use;\n+  struct invariant *inv;\n+\n   for (uses = DF_INSN_USES (df, insn); uses; uses = uses->next)\n     {\n       use = uses->ref;\n-\n-      defs = DF_REF_CHAIN (use);\n-      if (!defs || defs->next)\n-\tcontinue;\n-      def = defs->ref;\n-      if (!DF_REF_DATA (def))\n-\tcontinue;\n-\n-      def_bb = DF_REF_BB (def);\n-      if (!dominated_by_p (CDI_DOMINATORS, bb, def_bb))\n-\tcontinue;\n-\n-      record_use (DF_REF_DATA (def), DF_REF_LOC (use), DF_REF_INSN (use));\n+      inv = invariant_for_use (use);\n+      if (inv)\n+\trecord_use (inv->def, DF_REF_LOC (use), DF_REF_INSN (use));\n     }\n }\n \n@@ -573,6 +863,7 @@ find_invariants (struct loop *loop)\n \n   find_defs (loop, body);\n   find_invariants_body (loop, body, always_reached, always_executed);\n+  merge_identical_invariants ();\n \n   BITMAP_FREE (always_reached);\n   BITMAP_FREE (always_executed);\n@@ -607,6 +898,9 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   struct invariant *dep;\n   bitmap_iterator bi;\n \n+  /* Find the representative of the class of the equivalent invariants.  */\n+  inv = VEC_index (invariant_p, invariants, inv->eqto);\n+\n   *comp_cost = 0;\n   *regs_needed = 0;\n   if (inv->move\n@@ -683,6 +977,10 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n       if (inv->move)\n \tcontinue;\n \n+      /* Only consider the \"representatives\" of equivalent invariants.  */\n+      if (inv->eqto != inv->invno)\n+\tcontinue;\n+\n       again = gain_for_invariant (inv, &aregs_needed,\n \t\t\t\t  new_regs, regs_used, n_inv_uses);\n       if (again > gain)\n@@ -704,6 +1002,9 @@ set_move_mark (unsigned invno)\n   struct invariant *inv = VEC_index (invariant_p, invariants, invno);\n   bitmap_iterator bi;\n \n+  /* Find the representative of the class of the equivalent invariants.  */\n+  inv = VEC_index (invariant_p, invariants, inv->eqto);\n+\n   if (inv->move)\n     return;\n   inv->move = true;\n@@ -766,50 +1067,68 @@ static void\n move_invariant_reg (struct loop *loop, unsigned invno)\n {\n   struct invariant *inv = VEC_index (invariant_p, invariants, invno);\n+  struct invariant *repr = VEC_index (invariant_p, invariants, inv->eqto);\n   unsigned i;\n   basic_block preheader = loop_preheader_edge (loop)->src;\n   rtx reg, set;\n   struct use *use;\n   bitmap_iterator bi;\n \n-  if (inv->processed)\n+  if (inv->reg\n+      || !repr->move)\n     return;\n-  inv->processed = true;\n \n-  if (inv->depends_on)\n+  /* If this is a representative of the class of equivalent invariants,\n+     really move the invariant.  Otherwise just replace its use with\n+     the register used for the representative.  */\n+  if (inv == repr)\n     {\n-      EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, i, bi)\n+      if (inv->depends_on)\n \t{\n-\t  move_invariant_reg (loop, i);\n+\t  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, i, bi)\n+\t    {\n+\t      move_invariant_reg (loop, i);\n+\t    }\n \t}\n-    }\n \n-  /* Move the set out of the loop.  If the set is always executed (we could\n-     omit this condition if we know that the register is unused outside of the\n-     loop, but it does not seem worth finding out) and it has no uses that\n-     would not be dominated by it, we may just move it (TODO).  Otherwise we\n-     need to create a temporary register.  */\n-  set = single_set (inv->insn);\n-  reg = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n-  df_pattern_emit_after (df, gen_move_insn (SET_DEST (set), reg),\n-\t\t\t BLOCK_FOR_INSN (inv->insn), inv->insn);\n-\n-  /* If the SET_DEST of the invariant insn is a reg, we can just move\n-     the insn out of the loop.  Otherwise, we have to use gen_move_insn\n-     to let emit_move_insn produce a valid instruction stream.  */\n-  if (REG_P (SET_DEST (set)))\n-    {\n-      SET_DEST (set) = reg;\n-      reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n-      df_insn_modify (df, preheader, inv->insn);\n+      /* Move the set out of the loop.  If the set is always executed (we could\n+\t omit this condition if we know that the register is unused outside of the\n+\t loop, but it does not seem worth finding out) and it has no uses that\n+\t would not be dominated by it, we may just move it (TODO).  Otherwise we\n+\t need to create a temporary register.  */\n+      set = single_set (inv->insn);\n+      reg = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n+      df_pattern_emit_after (df, gen_move_insn (SET_DEST (set), reg),\n+\t\t\t     BLOCK_FOR_INSN (inv->insn), inv->insn);\n+\n+      /* If the SET_DEST of the invariant insn is a reg, we can just move\n+\t the insn out of the loop.  Otherwise, we have to use gen_move_insn\n+\t to let emit_move_insn produce a valid instruction stream.  */\n+      if (REG_P (SET_DEST (set)))\n+\t{\n+\t  SET_DEST (set) = reg;\n+\t  reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n+\t  df_insn_modify (df, preheader, inv->insn);\n+\t}\n+      else\n+\t{\n+\t  df_pattern_emit_after (df, gen_move_insn (reg, SET_SRC (set)),\n+\t\t\t\t preheader, BB_END (preheader));\n+\t  df_insn_delete (df, BLOCK_FOR_INSN (inv->insn), inv->insn);\n+\t}\n     }\n   else\n     {\n-      df_pattern_emit_after (df, gen_move_insn (reg, SET_SRC (set)),\n-\t\t\t     preheader, BB_END (preheader));\n+      move_invariant_reg (loop, repr->invno);\n+      reg = repr->reg;\n+      set = single_set (inv->insn);\n+      df_pattern_emit_after (df, gen_move_insn (SET_DEST (set), reg),\n+\t\t\t     BLOCK_FOR_INSN (inv->insn), inv->insn);\n       df_insn_delete (df, BLOCK_FOR_INSN (inv->insn), inv->insn);\n     }\n \n+  inv->reg = reg;\n+\n   /* Replace the uses we know to be dominated.  It saves work for copy\n      propagation, and also it is necessary so that dependent invariants\n      are computed right.  */\n@@ -833,10 +1152,7 @@ move_invariants (struct loop *loop)\n   unsigned i;\n \n   for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n-    {\n-      if (inv->move)\n-\tmove_invariant_reg (loop, i);\n-    }\n+    move_invariant_reg (loop, i);\n }\n \n /* Initializes invariant motion data.  */\n@@ -863,9 +1179,11 @@ free_inv_motion_data (void)\n       if (!df->defs[i])\n \tcontinue;\n \n-      def = DF_REF_DATA (df->defs[i]);\n-      if (!def)\n+      inv = DF_REF_DATA (df->defs[i]);\n+      if (!inv)\n \tcontinue;\n+      def = inv->def;\n+      gcc_assert (def != NULL);\n \n       free_use_list (def->uses);\n       free (def);"}]}