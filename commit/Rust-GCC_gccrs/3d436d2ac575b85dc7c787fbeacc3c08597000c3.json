{"sha": "3d436d2ac575b85dc7c787fbeacc3c08597000c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q0MzZkMmFjNTc1Yjg1ZGM3Yzc4N2ZiZWFjYzNjMDg1OTcwMDBjMw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-01-24T20:27:02Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-01-24T20:27:02Z"}, "message": "cfgloopanal.c: New file.\n\n\t* cfgloopanal.c: New file.\n\t* cfgloopmanip.c: New file.\n\t* Makefile.in (cfgloopanal.o, cfgloopmanip.o): New.\n\t(toplev.o, loop.o, doloop.o, unroll.o, cfgloop.o, predict.o,\n\tcfglayout.o): Add dependency on cfgloop.h.\n\t(cfgloop.o): Add flags.h dependency.\n\t* basic-block.h (BB_IRREDUCIBLE_LOOP, BB_SUPERBLOCK): New flags.\n\t(VLS_EXPECT_PREHEADERS, VLS_EXPECT_SIMPLE_LATCHES): Removed.\n\t(struct loop, struct loops, flow_loops_find, flow_loops_update,\n\tflow_loops_free, flow_loops_dump, flow_loop_dump,\n\tflow_loop_scan, flow_loop_tree_node_add, flow_loop_tree_node_remove,\n\tLOOP_TREE,,LOOP_PRE_HEADER, LOOP_ENTRY_EDGES, LOOP_EXIT_EDGES,\n\tLOOP_ALL, flow_loop_outside_edge_p, flow_loop_nested_p,\n\tflow_bb_inside_loop_p, get_loop_body, loop_preheader_edge,\n\tloop_latch_edge, add_bb_to_loop, remove_bb_from_loops,\n\tfind_common_loop, verify_loop_structure): Declarations moved to ...\n\t* cfgloop.h: New file.\n\t* bb-reorder.c (reorder_basic_blocks): Modified.\n\t* cfglayout.c: Include cfgloop.h.\n\t(cleanup_unconditional_jumps, cfg_layout_redirect_edge,\n\tcfg_layout_duplicate_bb, cfg_layout_initialize): Update loop structure.\n\t(break_superblocks): New static function.\n\t(cfg_layout_finalize): Use it.\n\t(cfg_layout_split_block): New function.\n\t* cfglayout.h (struct reorder_block_def): Add copy and duplicated\n\tfields.\n\t(cfg_layout_initialize, cfg_layout_redirect_edge): Declaration\n\tchanged.\n\t(cfg_layout_split_block): Declare.\n\t* cfgloop.c: Include cfgloop.h and flags.h.\n\t(flow_loop_dump, flow_loops_free, flow_loop_exit_edges_find,\n\tget_loop_body): Avoid signed versus unsigned comparison warnings.\n\t(make_forwarder_block, flow_loops_find, loop_preheader_edge,\n\tloop_latch_edge): Modified.\n\t(verify_loop_structure): Modified to use flags stored in loop structure;\n\tcheck irreducible loops.\n\t(cancel_loop, cancel_loop_tree): New functions.\n\t(estimate_probability): Use loop analysis code for predictions.\n\t(estimate_loops_at_level):  Avoid signed versus unsigned comparison\n\twarnings.\n\t* doloop.c: Include cfgloop.h.\n\t* loop.c: Include cfgloop.h.\n\t* predict.c: Include cfgloop.h.\n\t* toplev.c: Include cfgloop.h.\n\t* unroll.c: Include cfgloop.h.\n\t* tracer.c (tracer): Modified.\n\nFrom-SVN: r61730", "tree": {"sha": "dcedb00430c0c7c8dca147fb1c6499d017c95537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcedb00430c0c7c8dca147fb1c6499d017c95537"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d436d2ac575b85dc7c787fbeacc3c08597000c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d436d2ac575b85dc7c787fbeacc3c08597000c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d436d2ac575b85dc7c787fbeacc3c08597000c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d436d2ac575b85dc7c787fbeacc3c08597000c3/comments", "author": null, "committer": null, "parents": [{"sha": "55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d0e5e0223bae2b64faf4b858b59eb486efbe4b"}], "stats": {"total": 2153, "additions": 1916, "deletions": 237}, "files": [{"sha": "03765553c94eaf8264de84c59fb45e3462425565", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -1,3 +1,52 @@\n+2003-01-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloopanal.c: New file.\n+\t* cfgloopmanip.c: New file.\n+\t* Makefile.in (cfgloopanal.o, cfgloopmanip.o): New.\n+\t(toplev.o, loop.o, doloop.o, unroll.o, cfgloop.o, predict.o,\n+\tcfglayout.o): Add dependency on cfgloop.h.\n+\t(cfgloop.o): Add flags.h dependency.\n+\t* basic-block.h (BB_IRREDUCIBLE_LOOP, BB_SUPERBLOCK): New flags.\n+\t(VLS_EXPECT_PREHEADERS, VLS_EXPECT_SIMPLE_LATCHES): Removed.\n+\t(struct loop, struct loops, flow_loops_find, flow_loops_update,\n+\tflow_loops_free, flow_loops_dump, flow_loop_dump,\n+\tflow_loop_scan, flow_loop_tree_node_add, flow_loop_tree_node_remove,\n+\tLOOP_TREE,,LOOP_PRE_HEADER, LOOP_ENTRY_EDGES, LOOP_EXIT_EDGES,\n+\tLOOP_ALL, flow_loop_outside_edge_p, flow_loop_nested_p,\n+\tflow_bb_inside_loop_p, get_loop_body, loop_preheader_edge,\n+\tloop_latch_edge, add_bb_to_loop, remove_bb_from_loops,\n+\tfind_common_loop, verify_loop_structure): Declarations moved to ...\n+\t* cfgloop.h: New file.\n+\t* bb-reorder.c (reorder_basic_blocks): Modified.\n+\t* cfglayout.c: Include cfgloop.h.\n+\t(cleanup_unconditional_jumps, cfg_layout_redirect_edge,\n+\tcfg_layout_duplicate_bb, cfg_layout_initialize): Update loop structure.\n+\t(break_superblocks): New static function.\n+\t(cfg_layout_finalize): Use it.\n+\t(cfg_layout_split_block): New function.\n+\t* cfglayout.h (struct reorder_block_def): Add copy and duplicated\n+\tfields.\n+\t(cfg_layout_initialize, cfg_layout_redirect_edge): Declaration\n+\tchanged.\n+\t(cfg_layout_split_block): Declare.\n+\t* cfgloop.c: Include cfgloop.h and flags.h.\n+\t(flow_loop_dump, flow_loops_free, flow_loop_exit_edges_find,\n+\tget_loop_body): Avoid signed versus unsigned comparison warnings.\n+\t(make_forwarder_block, flow_loops_find, loop_preheader_edge,\n+\tloop_latch_edge): Modified.\n+\t(verify_loop_structure): Modified to use flags stored in loop structure;\n+\tcheck irreducible loops.\n+\t(cancel_loop, cancel_loop_tree): New functions.\n+\t(estimate_probability): Use loop analysis code for predictions.\n+\t(estimate_loops_at_level):  Avoid signed versus unsigned comparison\n+\twarnings.\n+\t* doloop.c: Include cfgloop.h.\n+\t* loop.c: Include cfgloop.h.\n+\t* predict.c: Include cfgloop.h.\n+\t* toplev.c: Include cfgloop.h.\n+\t* unroll.c: Include cfgloop.h.\n+\t* tracer.c (tracer): Modified.\n+\n 2003-01-24  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (get_shift_alg): Fix a typo."}, {"sha": "37a14ac35040b962f94af767bd97f0ca8487f2f9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -770,6 +770,7 @@ C_OBJS = c-parse.o c-lang.o c-pretty-print.o $(C_AND_OBJC_OBJS)\n \n OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n+ cfgloopanal.o cfgloopmanip.o \t\t\t\t\t\t   \\\n  cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o\t   \\\n  debug.o df.o diagnostic.o doloop.o dominance.o\t\t                   \\\n  dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o\t   \\\n@@ -1428,7 +1429,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n    graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) $(lang_options_files) \\\n    ssa.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n-   langhooks.h insn-flags.h options.h cfglayout.h real.h\n+   langhooks.h insn-flags.h options.h cfglayout.h real.h cfgloop.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n \t  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)\n@@ -1560,13 +1561,15 @@ profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TRE\n    $(TARGET_H) langhooks.h profile.h libfuncs.h gt-profile.h $(HASHTAB_H)\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n-   real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h \\\n+   real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h cfgloop.h \\\n    toplev.h varray.h except.h cselib.h $(OPTABS_H) $(TM_P_H)\n doloop.o : doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n-   $(LOOP_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) toplev.h\n+   $(LOOP_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) toplev.h \\\n+   cfgloop.h\n unroll.o : unroll.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-config.h \\\n    function.h $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \\\n-   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H) $(PARAMS_H)\n+   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H) $(PARAMS_H) \\\n+   cfgloop.h\n alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h\n flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n@@ -1585,8 +1588,12 @@ cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) fla\n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TIMEVAR_H) $(BASIC_BLOCK_H) hard-reg-set.h output.h flags.h $(RECOG_H) toplev.h \\\n    $(GGC_H) insn-config.h cselib.h $(TARGET_H) $(TM_P_H)\n-cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h\n+cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h flags.h\n+cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h $(EXPR_H)\n+cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h output.h\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h\n@@ -1669,7 +1676,7 @@ reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) real.h \\\n-   $(PARAMS_H) $(TARGET_H)\n+   $(PARAMS_H) $(TARGET_H) cfgloop.h\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) flags.h $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h $(TARGET_H)\n@@ -1678,7 +1685,7 @@ tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n    $(PARAMS_H) profile.h\n cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h function.h \\\n-   cfglayout.h\n+   cfglayout.h cfgloop.h\n timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TIMEVAR_H) flags.h \\\n    intl.h toplev.h\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "0fd77bf17515bdb115936847823d318e6fef2606", "filename": "gcc/basic-block.h", "status": "modified", "additions": 8, "deletions": 201, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -153,6 +153,9 @@ typedef struct edge_def {\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n+/* Declared in cfgloop.h.  */\n+struct loop;\n+struct loops;\n \n /* A basic block is a sequence of instructions with only entry and\n    only one exit.  If any one of the instructions are executed, they\n@@ -240,6 +243,8 @@ typedef struct basic_block_def {\n #define BB_NEW\t\t\t2\n #define BB_REACHABLE\t\t4\n #define BB_VISITED\t\t8\n+#define BB_IRREDUCIBLE_LOOP\t16\n+#define BB_SUPERBLOCK\t\t32\n \n /* Number of basic blocks in the current function.  */\n \n@@ -360,6 +365,9 @@ extern void tidy_fallthru_edges\t\tPARAMS ((void));\n extern void flow_reverse_top_sort_order_compute\tPARAMS ((int *));\n extern int flow_depth_first_order_compute\tPARAMS ((int *, int *));\n extern void flow_preorder_transversal_compute\tPARAMS ((int *));\n+extern int dfs_enumerate_from\t\tPARAMS ((basic_block, int,\n+\t\t\t\t\t\tbool (*)(basic_block, void *),\n+\t\t\t\t\t\tbasic_block *, int, void *));\n extern void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n extern void clear_edges\t\t\tPARAMS ((void));\n extern void mark_critical_edges\t\tPARAMS ((void));\n@@ -369,165 +377,6 @@ extern rtx first_insn_after_basic_block_note\tPARAMS ((basic_block));\n \n typedef struct dominance_info *dominance_info;\n \n-/* Structure to hold information for each natural loop.  */\n-struct loop\n-{\n-  /* Index into loops array.  */\n-  int num;\n-\n-  /* Basic block of loop header.  */\n-  basic_block header;\n-\n-  /* Basic block of loop latch.  */\n-  basic_block latch;\n-\n-  /* Basic block of loop pre-header or NULL if it does not exist.  */\n-  basic_block pre_header;\n-\n-  /* Array of edges along the pre-header extended basic block trace.\n-     The source of the first edge is the root node of pre-header\n-     extended basic block, if it exists.  */\n-  edge *pre_header_edges;\n-\n-  /* Number of edges along the pre_header extended basic block trace.  */\n-  int num_pre_header_edges;\n-\n-  /* The first block in the loop.  This is not necessarily the same as\n-     the loop header.  */\n-  basic_block first;\n-\n-  /* The last block in the loop.  This is not necessarily the same as\n-     the loop latch.  */\n-  basic_block last;\n-\n-  /* Bitmap of blocks contained within the loop.  */\n-  sbitmap nodes;\n-\n-  /* Number of blocks contained within the loop.  */\n-  int num_nodes;\n-\n-  /* Array of edges that enter the loop.  */\n-  edge *entry_edges;\n-\n-  /* Number of edges that enter the loop.  */\n-  int num_entries;\n-\n-  /* Array of edges that exit the loop.  */\n-  edge *exit_edges;\n-\n-  /* Number of edges that exit the loop.  */\n-  int num_exits;\n-\n-  /* Bitmap of blocks that dominate all exits of the loop.  */\n-  sbitmap exits_doms;\n-\n-  /* The loop nesting depth.  */\n-  int depth;\n-\n-  /* Superloops of the loop.  */\n-  struct loop **pred;\n-\n-  /* The height of the loop (enclosed loop levels) within the loop\n-     hierarchy tree.  */\n-  int level;\n-\n-  /* The outer (parent) loop or NULL if outermost loop.  */\n-  struct loop *outer;\n-\n-  /* The first inner (child) loop or NULL if innermost loop.  */\n-  struct loop *inner;\n-\n-  /* Link to the next (sibling) loop.  */\n-  struct loop *next;\n-\n-  /* Nonzero if the loop is invalid (e.g., contains setjmp.).  */\n-  int invalid;\n-\n-  /* Auxiliary info specific to a pass.  */\n-  void *aux;\n-\n-  /* The following are currently used by loop.c but they are likely to\n-     disappear as loop.c is converted to use the CFG.  */\n-\n-  /* Nonzero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n-  rtx vtop;\n-\n-  /* Nonzero if the loop has a NOTE_INSN_LOOP_CONT.\n-     A continue statement will generate a branch to NEXT_INSN (cont).  */\n-  rtx cont;\n-\n-  /* The NOTE_INSN_LOOP_BEG.  */\n-  rtx start;\n-\n-  /* The NOTE_INSN_LOOP_END.  */\n-  rtx end;\n-\n-  /* For a rotated loop that is entered near the bottom,\n-     this is the label at the top.  Otherwise it is zero.  */\n-  rtx top;\n-\n-  /* Place in the loop where control enters.  */\n-  rtx scan_start;\n-\n-  /* The position where to sink insns out of the loop.  */\n-  rtx sink;\n-\n-  /* List of all LABEL_REFs which refer to code labels outside the\n-     loop.  Used by routines that need to know all loop exits, such as\n-     final_biv_value and final_giv_value.\n-\n-     This does not include loop exits due to return instructions.\n-     This is because all bivs and givs are pseudos, and hence must be\n-     dead after a return, so the presence of a return does not affect\n-     any of the optimizations that use this info.  It is simpler to\n-     just not include return instructions on this list.  */\n-  rtx exit_labels;\n-\n-  /* The number of LABEL_REFs on exit_labels for this loop and all\n-     loops nested inside it.  */\n-  int exit_count;\n-};\n-\n-\n-/* Structure to hold CFG information about natural loops within a function.  */\n-struct loops\n-{\n-  /* Number of natural loops in the function.  */\n-  int num;\n-\n-  /* Maxium nested loop level in the function.  */\n-  int levels;\n-\n-  /* Array of natural loop descriptors (scanning this array in reverse order\n-     will find the inner loops before their enclosing outer loops).  */\n-  struct loop *array;\n-\n-  /* The above array is unused in new loop infrastructure and is kept only for\n-     purposes of the old loop optimizer.  Instead we store just pointers to\n-     loops here.  */\n-  struct loop **parray;\n-\n-  /* Pointer to root of loop heirachy tree.  */\n-  struct loop *tree_root;\n-\n-  /* Information derived from the CFG.  */\n-  struct cfg\n-  {\n-    /* The bitmap vector of dominators or NULL if not computed.  */\n-    dominance_info dom;\n-\n-    /* The ordering of the basic blocks in a depth first search.  */\n-    int *dfs_order;\n-\n-    /* The reverse completion ordering of the basic blocks found in a\n-       depth first search.  */\n-    int *rc_order;\n-  } cfg;\n-\n-  /* Headers shared by multiple loops that should be merged.  */\n-  sbitmap shared_headers;\n-};\n-\n /* Structure to group all of the information to process IF-THEN and\n    IF-THEN-ELSE blocks for the conditional execution support.  This\n    needs to be in a public file in case the IFCVT macros call\n@@ -555,19 +404,6 @@ typedef struct ce_if_block\n \n } ce_if_block_t;\n \n-extern int flow_loops_find PARAMS ((struct loops *, int flags));\n-extern int flow_loops_update PARAMS ((struct loops *, int flags));\n-extern void flow_loops_free PARAMS ((struct loops *));\n-extern void flow_loops_dump PARAMS ((const struct loops *, FILE *,\n-\t\t\t\t     void (*)(const struct loop *,\n-\t\t\t\t\t      FILE *, int), int));\n-extern void flow_loop_dump PARAMS ((const struct loop *, FILE *,\n-\t\t\t\t    void (*)(const struct loop *,\n-\t\t\t\t\t     FILE *, int), int));\n-extern int flow_loop_scan PARAMS ((struct loops *, struct loop *, int));\n-extern void flow_loop_tree_node_add PARAMS ((struct loop *, struct loop *));\n-extern void flow_loop_tree_node_remove PARAMS ((struct loop *));\n-\n /* This structure maintains an edge list vector.  */\n struct edge_list\n {\n@@ -658,15 +494,6 @@ enum update_life_extent\n #define CLEANUP_THREADING\t64\t/* Do jump threading.  */\n #define CLEANUP_NO_INSN_DEL\t128\t/* Do not try to delete trivially dead\n \t\t\t\t\t   insns.  */\n-/* Flags for loop discovery.  */\n-\n-#define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */\n-#define LOOP_PRE_HEADER\t\t2\t/* Analyse loop pre-header.  */\n-#define LOOP_ENTRY_EDGES\t4\t/* Find entry edges.  */\n-#define LOOP_EXIT_EDGES\t\t8\t/* Find exit edges.  */\n-#define LOOP_EDGES\t\t(LOOP_ENTRY_EDGES | LOOP_EXIT_EDGES)\n-#define LOOP_ALL\t       15\t/* All of the above  */\n-\n extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n extern int update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n \t\t\t\t\t int));\n@@ -752,26 +579,6 @@ extern void free_aux_for_edges\t\tPARAMS ((void));\n    debugger, and it is declared extern so we don't get warnings about\n    it being unused.  */\n extern void verify_flow_info\t\tPARAMS ((void));\n-extern bool flow_loop_outside_edge_p\tPARAMS ((const struct loop *, edge));\n-extern bool flow_loop_nested_p PARAMS ((const struct loop *,\n-\t\t\t\t\tconst struct loop *));\n-extern bool flow_bb_inside_loop_p       PARAMS ((const struct loop *,\n-\t\t\t\t\t\t const basic_block));\n-extern basic_block *get_loop_body       PARAMS ((const struct loop *));\n-extern int dfs_enumerate_from           PARAMS ((basic_block, int,\n-\t\t\t\t         bool (*)(basic_block, void *),\n-\t\t\t\t\t basic_block *, int, void *));\n-\n-extern edge loop_preheader_edge PARAMS ((struct loop *));\n-extern edge loop_latch_edge PARAMS ((struct loop *));\n-\n-extern void add_bb_to_loop PARAMS ((basic_block, struct loop *));\n-extern void remove_bb_from_loops PARAMS ((basic_block));\n-extern struct loop * find_common_loop PARAMS ((struct loop *, struct loop *));\n-\n-extern void verify_loop_structure PARAMS ((struct loops *, int));\n-#define VLS_EXPECT_PREHEADERS 1\n-#define VLS_EXPECT_SIMPLE_LATCHES 2\n \n typedef struct conflict_graph_def *conflict_graph;\n "}, {"sha": "4b80d9b3306f4c306678c9223befbaba5a39242a", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -268,7 +268,7 @@ reorder_basic_blocks ()\n   if ((* targetm.cannot_modify_jumps_p) ())\n     return;\n \n-  cfg_layout_initialize ();\n+  cfg_layout_initialize (NULL);\n \n   make_reorder_chain ();\n "}, {"sha": "7ac9cb6a9d8a86757708d1203c2ae55637b2e7f1", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 82, "deletions": 7, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"function.h\"\n #include \"obstack.h\"\n #include \"cfglayout.h\"\n+#include \"cfgloop.h\"\n \n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.  */\n@@ -48,10 +49,11 @@ static void set_block_levels\t\tPARAMS ((tree, int));\n static void change_scope\t\tPARAMS ((rtx, tree, tree));\n \n void verify_insn_chain\t\t\tPARAMS ((void));\n-static void cleanup_unconditional_jumps\tPARAMS ((void));\n+static void cleanup_unconditional_jumps\tPARAMS ((struct loops *));\n static void fixup_fallthru_exit_predecessor PARAMS ((void));\n static rtx unlink_insn_chain PARAMS ((rtx, rtx));\n static rtx duplicate_insn_chain PARAMS ((rtx, rtx));\n+static void break_superblocks PARAMS ((void));\n \f\n static rtx\n unlink_insn_chain (first, last)\n@@ -612,10 +614,12 @@ verify_insn_chain ()\n /* Remove any unconditional jumps and forwarder block creating fallthru\n    edges instead.  During BB reordering, fallthru edges are not required\n    to target next basic block in the linear CFG layout, so the unconditional\n-   jumps are not needed.  */\n+   jumps are not needed.  If LOOPS is not null, also update loop structure &\n+   dominators.  */\n \n static void\n-cleanup_unconditional_jumps ()\n+cleanup_unconditional_jumps (loops)\n+     struct loops *loops;\n {\n   basic_block bb;\n \n@@ -637,6 +641,25 @@ cleanup_unconditional_jumps ()\n \t\tfprintf (rtl_dump_file, \"Removing forwarder BB %i\\n\",\n \t\t\t bb->index);\n \n+\t      if (loops)\n+\t\t{\n+\t\t  /* bb cannot be loop header, as it only has one entry\n+\t\t     edge.  It could be a loop latch.  */\n+\t\t  if (bb->loop_father->header == bb)\n+\t\t    abort ();\n+\n+\t\t  if (bb->loop_father->latch == bb)\n+\t\t    bb->loop_father->latch = bb->pred->src;\n+\n+\t\t  if (get_immediate_dominator\n+\t\t      (loops->cfg.dom, bb->succ->dest) == bb)\n+\t\t    set_immediate_dominator\n+\t\t      (loops->cfg.dom, bb->succ->dest, bb->pred->src);\n+\n+\t\t  remove_bb_from_loops (bb);\n+\t\t  delete_from_dominance_info (loops->cfg.dom, bb);\n+\t\t}\n+\n \t      redirect_edge_succ_nodup (bb->pred, bb->succ->dest);\n \t      flow_delete_block (bb);\n \t      bb = prev;\n@@ -822,13 +845,14 @@ duplicate_insn_chain (from, to)\n }\n \n /* Redirect Edge to DEST.  */\n-void\n+bool\n cfg_layout_redirect_edge (e, dest)\n      edge e;\n      basic_block dest;\n {\n   basic_block src = e->src;\n   basic_block old_next_bb = src->next_bb;\n+  bool ret;\n \n   /* Redirect_edge_and_branch may decide to turn branch into fallthru edge\n      in the case the basic block appears to be in sequence.  Avoid this\n@@ -849,9 +873,11 @@ cfg_layout_redirect_edge (e, dest)\n \t    delete_insn (src->end);\n \t}\n       redirect_edge_succ_nodup (e, dest);\n+\n+      ret = true;\n     }\n   else\n-    redirect_edge_and_branch (e, dest);\n+    ret = redirect_edge_and_branch (e, dest);\n \n   /* We don't want simplejumps in the insn stream during cfglayout.  */\n   if (simplejump_p (src->end))\n@@ -861,6 +887,22 @@ cfg_layout_redirect_edge (e, dest)\n       src->succ->flags |= EDGE_FALLTHRU;\n     }\n   src->next_bb = old_next_bb;\n+\n+  return ret;\n+}\n+\n+/* Same as split_block but update cfg_layout structures.  */\n+edge\n+cfg_layout_split_block (bb, insn)\n+     basic_block bb;\n+     rtx insn;\n+{\n+  edge fallthru = split_block (bb, insn);\n+\n+  alloc_aux_for_block (fallthru->dest, sizeof (struct reorder_block_def));\n+  RBI (fallthru->dest)->footer = RBI (fallthru->src)->footer;\n+  RBI (fallthru->src)->footer = NULL;\n+  return fallthru;\n }\n \n /* Create a duplicate of the basic block BB and redirect edge E into it.  */\n@@ -949,24 +991,55 @@ cfg_layout_duplicate_bb (bb, e)\n     bb->frequency = 0;\n \n   RBI (new_bb)->original = bb;\n+  RBI (bb)->copy = new_bb;\n   return new_bb;\n }\n \f\n /* Main entry point to this module - initialize the datastructures for\n    CFG layout changes.  It keeps LOOPS up-to-date if not null.  */\n \n void\n-cfg_layout_initialize ()\n+cfg_layout_initialize (loops)\n+     struct loops *loops;\n {\n   /* Our algorithm depends on fact that there are now dead jumptables\n      around the code.  */\n   alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n \n-  cleanup_unconditional_jumps ();\n+  cleanup_unconditional_jumps (loops);\n \n   record_effective_endpoints ();\n }\n \n+/* Splits superblocks.  */\n+static void\n+break_superblocks ()\n+{\n+  sbitmap superblocks;\n+  int i, need;\n+\n+  superblocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (superblocks);\n+\n+  need = 0;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (BASIC_BLOCK(i)->flags & BB_SUPERBLOCK)\n+      {\n+\tBASIC_BLOCK(i)->flags &= ~BB_SUPERBLOCK;\n+\tSET_BIT (superblocks, i);\n+\tneed = 1;\n+      }\n+\n+  if (need)\n+    {\n+      rebuild_jump_labels (get_insns ());\n+      find_many_sub_basic_blocks (superblocks);\n+    }\n+\n+  free (superblocks);\n+}\n+\n /* Finalize the changes: reorder insn list according to the sequence, enter\n    compensation code, rebuild scope forest.  */\n \n@@ -982,6 +1055,8 @@ cfg_layout_finalize ()\n \n   free_aux_for_blocks ();\n \n+  break_superblocks ();\n+\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif"}, {"sha": "aec5e7ebba319c2e362045a76f5caef7abfffe29", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -25,17 +25,21 @@ typedef struct reorder_block_def\n   rtx footer;\n   basic_block next;\n   basic_block original;\n+  /* Used by loop copying.  */\n+  basic_block copy;\n+  int duplicated;\n \n   /* These fields are used by bb-reorder pass.  */\n   int visited;\n } *reorder_block_def;\n \n #define RBI(BB)\t((reorder_block_def) (BB)->aux)\n \n-extern void cfg_layout_initialize\tPARAMS ((void));\n+extern void cfg_layout_initialize\tPARAMS ((struct loops *));\n extern void cfg_layout_finalize\t\tPARAMS ((void));\n extern bool cfg_layout_can_duplicate_bb_p PARAMS ((basic_block));\n extern basic_block cfg_layout_duplicate_bb PARAMS ((basic_block, edge));\n extern void scope_to_insns_initialize\tPARAMS ((void));\n extern void scope_to_insns_finalize\tPARAMS ((void));\n-extern void cfg_layout_redirect_edge\tPARAMS ((edge, basic_block));\n+extern bool cfg_layout_redirect_edge\tPARAMS ((edge, basic_block));\n+extern edge cfg_layout_split_block\tPARAMS ((basic_block, rtx));"}, {"sha": "9f8c305110735e7a29f2d771239e67a94a13ed1b", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 93, "deletions": 13, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -26,6 +26,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"toplev.h\"\n+#include \"cfgloop.h\"\n+#include \"flags.h\"\n \n /* Ratio of frequencies of edges so that one of more latch edges is\n    considered to belong to inner loop with same header.  */\n@@ -114,7 +116,7 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n      int verbose;\n {\n   basic_block *bbs;\n-  int i;\n+  unsigned i;\n \n   if (! loop || ! loop->header)\n     return;\n@@ -206,7 +208,7 @@ flow_loops_free (loops)\n {\n   if (loops->parray)\n     {\n-      int i;\n+      unsigned i;\n \n       if (! loops->num)\n \tabort ();\n@@ -275,7 +277,7 @@ flow_loop_exit_edges_find (loop)\n {\n   edge e;\n   basic_block node, *bbs;\n-  int num_exits, i;\n+  unsigned num_exits, i;\n \n   loop->exit_edges = NULL;\n   loop->num_exits = 0;\n@@ -609,6 +611,10 @@ make_forwarder_block (bb, redirect_latch, redirect_nonlatch, except,\n \n   insn = PREV_INSN (first_insn_after_basic_block_note (bb));\n \n+  /* For empty block split_block will return NULL.  */\n+  if (bb->end == insn)\n+    emit_note_after (NOTE_INSN_DELETED, insn);\n+\n   fallthru = split_block (bb, insn);\n   dummy = fallthru->src;\n   bb = fallthru->dest;\n@@ -926,9 +932,11 @@ flow_loops_find (loops, flags)\n       loops->cfg.dom = NULL;\n       free_dominance_info (dom);\n     }\n+\n+  loops->state = 0;\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n-  verify_loop_structure (loops, 0);\n+  verify_loop_structure (loops);\n #endif\n \n   return loops->num;\n@@ -992,7 +1000,7 @@ get_loop_body (loop)\n      const struct loop *loop;\n {\n   basic_block *tovisit, bb;\n-  int tv = 0;\n+  unsigned tv = 0;\n \n   if (!loop->num_nodes)\n     abort ();\n@@ -1003,7 +1011,7 @@ get_loop_body (loop)\n   if (loop->latch == EXIT_BLOCK_PTR)\n     {\n       /* There may be blocks unreachable from EXIT_BLOCK.  */\n-      if (loop->num_nodes != n_basic_blocks + 2)\n+      if (loop->num_nodes != (unsigned) n_basic_blocks + 2)\n \tabort ();\n       FOR_EACH_BB (bb)\n \ttovisit[tv++] = bb;\n@@ -1073,18 +1081,57 @@ find_common_loop (loop_s, loop_d)\n   return loop_s;\n }\n \n+/* Cancels the LOOP; it must be innermost one.  */\n+void\n+cancel_loop (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  basic_block *bbs;\n+  unsigned i;\n+\n+  if (loop->inner)\n+    abort ();\n+\n+  /* Move blocks up one level (they should be removed as soon as possible).  */\n+  bbs = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    bbs[i]->loop_father = loop->outer;\n+\n+  /* Remove the loop from structure.  */\n+  flow_loop_tree_node_remove (loop);\n+\n+  /* Remove loop from loops array.  */\n+  loops->parray[loop->num] = NULL;\n+\n+  /* Free loop data.  */\n+  flow_loop_free (loop);\n+}\n+\n+/* Cancels LOOP and all its subloops.  */\n+void\n+cancel_loop_tree (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  while (loop->inner)\n+    cancel_loop_tree (loops, loop->inner);\n+  cancel_loop (loops, loop);\n+}\n+\n /* Checks that LOOPS are allright:\n      -- sizes of loops are allright\n      -- results of get_loop_body really belong to the loop\n      -- loop header have just single entry edge and single latch edge\n      -- loop latches have only single successor that is header of their loop\n+     -- irreducible loops are correctly marked\n   */\n void\n-verify_loop_structure (loops, flags)\n+verify_loop_structure (loops)\n      struct loops *loops;\n-     int flags;\n {\n-  int *sizes, i, j;\n+  unsigned *sizes, i, j;\n+  sbitmap irreds;\n   basic_block *bbs, bb;\n   struct loop *loop;\n   int err = 0;\n@@ -1137,14 +1184,14 @@ verify_loop_structure (loops, flags)\n       if (!loop)\n \tcontinue;\n \n-      if ((flags & VLS_EXPECT_PREHEADERS)\n+      if ((loops->state & LOOPS_HAVE_PREHEADERS)\n \t  && (!loop->header->pred->pred_next\n \t      || loop->header->pred->pred_next->pred_next))\n \t{\n \t  error (\"Loop %d's header does not have exactly 2 entries.\", i);\n \t  err = 1;\n \t}\n-      if (flags & VLS_EXPECT_SIMPLE_LATCHES)\n+      if (loops->state & LOOPS_HAVE_SIMPLE_LATCHES)\n \t{\n \t  if (!loop->latch->succ\n \t      || loop->latch->succ->succ_next)\n@@ -1170,14 +1217,47 @@ verify_loop_structure (loops, flags)\n \t}\n     }\n \n+  /* Check irreducible loops.  */\n+  if (loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n+    {\n+      /* Record old info.  */\n+      irreds = sbitmap_alloc (last_basic_block);\n+      FOR_EACH_BB (bb)\n+\tif (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t  SET_BIT (irreds, bb->index);\n+\telse\n+\t  RESET_BIT (irreds, bb->index);\n+\n+      /* Recount it.  */\n+      mark_irreducible_loops (loops);\n+\n+      /* Compare.  */\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  if ((bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t      && !TEST_BIT (irreds, bb->index))\n+\t    {\n+\t      error (\"Basic block %d should be marked irreducible.\", bb->index);\n+\t      err = 1;\n+\t    }\n+\t  else if (!(bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t      && TEST_BIT (irreds, bb->index))\n+\t    {\n+\t      error (\"Basic block %d should not be marked irreducible.\", bb->index);\n+\t      err = 1;\n+\t    }\n+\t}\n+      free (irreds);\n+    }\n+\n   if (err)\n     abort ();\n }\n \n /* Returns latch edge of LOOP.  */\n edge\n loop_latch_edge (loop)\n-     struct loop *loop;\n+     const struct loop *loop;\n {\n   edge e;\n \n@@ -1190,7 +1270,7 @@ loop_latch_edge (loop)\n /* Returns preheader edge of LOOP.  */\n edge\n loop_preheader_edge (loop)\n-     struct loop *loop;\n+     const struct loop *loop;\n {\n   edge e;\n "}, {"sha": "84c9d0545dfa38f3f045f789257c353d245e6d99", "filename": "gcc/cfgloop.h", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -0,0 +1,314 @@\n+/* Natural loop functions\n+   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Structure to hold decision about unrolling/peeling.  */\n+enum lpt_dec\n+{\n+  LPT_NONE,\n+  LPT_PEEL_COMPLETELY,\n+  LPT_PEEL_SIMPLE,\n+  LPT_UNROLL_CONSTANT,\n+  LPT_UNROLL_RUNTIME,\n+  LPT_UNROLL_STUPID\n+};\n+\n+struct lpt_decision\n+{\n+  enum lpt_dec decision;\n+  unsigned times;\n+};\n+\n+/* Description of loop for simple loop unrolling.  */\n+struct loop_desc\n+{\n+  int postincr;\t\t/* 1 if increment/decrement is done after loop exit condition.  */\n+  rtx stride;\t\t/* Value added to VAR in each iteration.  */\n+  rtx var;\t\t/* Loop control variable.  */\n+  rtx var_alts;\t\t/* List of definitions of its initial value.  */\n+  rtx lim;\t\t/* Expression var is compared with.  */\n+  rtx lim_alts;\t\t/* List of definitions of its initial value.  */\n+  bool const_iter;      /* True if it iterates constant number of times.  */\n+  unsigned HOST_WIDE_INT niter;\n+\t\t\t/* Number of iterations if it is constant.  */\n+  bool may_be_zero;     /* If we cannot determine that the first iteration will pass.  */\n+  enum rtx_code cond;\t/* Exit condition.  */\n+  int neg;\t\t/* Set to 1 if loop ends when condition is satisfied.  */\n+  edge out_edge;\t/* The exit edge.  */\n+  edge in_edge;\t\t/* And the other one.  */\n+  int n_branches;\t/* Number of branches inside the loop.  */\n+};\n+\n+/* Structure to hold information for each natural loop.  */\n+struct loop\n+{\n+  /* Index into loops array.  */\n+  int num;\n+\n+  /* Basic block of loop header.  */\n+  basic_block header;\n+\n+  /* Basic block of loop latch.  */\n+  basic_block latch;\n+\n+  /* Basic block of loop preheader or NULL if it does not exist.  */\n+  basic_block pre_header;\n+\n+  /* For loop unrolling/peeling decision.  */\n+  struct lpt_decision lpt_decision;\n+\n+  /* Simple loop description.  */\n+  int simple;\n+  struct loop_desc desc;\n+  int has_desc;\n+\n+  /* Number of loop insns.  */\n+  unsigned ninsns;\n+\n+  /* Average number of executed insns per iteration.  */\n+  unsigned av_ninsns;\n+\n+  /* Array of edges along the preheader extended basic block trace.\n+     The source of the first edge is the root node of preheader\n+     extended basic block, if it exists.  */\n+  edge *pre_header_edges;\n+\n+  /* Number of edges along the pre_header extended basic block trace.  */\n+  int num_pre_header_edges;\n+\n+  /* The first block in the loop.  This is not necessarily the same as\n+     the loop header.  */\n+  basic_block first;\n+\n+  /* The last block in the loop.  This is not necessarily the same as\n+     the loop latch.  */\n+  basic_block last;\n+\n+  /* Bitmap of blocks contained within the loop.  */\n+  sbitmap nodes;\n+\n+  /* Number of blocks contained within the loop.  */\n+  unsigned num_nodes;\n+\n+  /* Array of edges that enter the loop.  */\n+  edge *entry_edges;\n+\n+  /* Number of edges that enter the loop.  */\n+  int num_entries;\n+\n+  /* Array of edges that exit the loop.  */\n+  edge *exit_edges;\n+\n+  /* Number of edges that exit the loop.  */\n+  int num_exits;\n+\n+  /* Bitmap of blocks that dominate all exits of the loop.  */\n+  sbitmap exits_doms;\n+\n+  /* The loop nesting depth.  */\n+  int depth;\n+\n+  /* Superloops of the loop.  */\n+  struct loop **pred;\n+\n+  /* The height of the loop (enclosed loop levels) within the loop\n+     hierarchy tree.  */\n+  int level;\n+\n+  /* The outer (parent) loop or NULL if outermost loop.  */\n+  struct loop *outer;\n+\n+  /* The first inner (child) loop or NULL if innermost loop.  */\n+  struct loop *inner;\n+\n+  /* Link to the next (sibling) loop.  */\n+  struct loop *next;\n+\n+  /* Loop that is copy of this loop.  */\n+  struct loop *copy;\n+\n+  /* Non-zero if the loop is invalid (e.g., contains setjmp.).  */\n+  int invalid;\n+\n+  /* Auxiliary info specific to a pass.  */\n+  void *aux;\n+\n+  /* The following are currently used by loop.c but they are likely to\n+     disappear as loop.c is converted to use the CFG.  */\n+\n+  /* Non-zero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n+  rtx vtop;\n+\n+  /* Non-zero if the loop has a NOTE_INSN_LOOP_CONT.\n+     A continue statement will generate a branch to NEXT_INSN (cont).  */\n+  rtx cont;\n+\n+  /* The dominator of cont.  */\n+  rtx cont_dominator;\n+\n+  /* The NOTE_INSN_LOOP_BEG.  */\n+  rtx start;\n+\n+  /* The NOTE_INSN_LOOP_END.  */\n+  rtx end;\n+\n+  /* For a rotated loop that is entered near the bottom,\n+     this is the label at the top.  Otherwise it is zero.  */\n+  rtx top;\n+\n+  /* Place in the loop where control enters.  */\n+  rtx scan_start;\n+\n+  /* The position where to sink insns out of the loop.  */\n+  rtx sink;\n+\n+  /* List of all LABEL_REFs which refer to code labels outside the\n+     loop.  Used by routines that need to know all loop exits, such as\n+     final_biv_value and final_giv_value.\n+\n+     This does not include loop exits due to return instructions.\n+     This is because all bivs and givs are pseudos, and hence must be\n+     dead after a return, so the presence of a return does not affect\n+     any of the optimizations that use this info.  It is simpler to\n+     just not include return instructions on this list.  */\n+  rtx exit_labels;\n+\n+  /* The number of LABEL_REFs on exit_labels for this loop and all\n+     loops nested inside it.  */\n+  int exit_count;\n+};\n+\n+/* Flags for state of loop structure.  */\n+enum\n+{\n+  LOOPS_HAVE_PREHEADERS = 1,\n+  LOOPS_HAVE_SIMPLE_LATCHES = 2,\n+  LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS = 4\n+};\n+\n+/* Structure to hold CFG information about natural loops within a function.  */\n+struct loops\n+{\n+  /* Number of natural loops in the function.  */\n+  unsigned num;\n+\n+  /* Maximum nested loop level in the function.  */\n+  unsigned levels;\n+\n+  /* Array of natural loop descriptors (scanning this array in reverse order\n+     will find the inner loops before their enclosing outer loops).  */\n+  struct loop *array;\n+\n+  /* The above array is unused in new loop infrastructure and is kept only for\n+     purposes of the old loop optimizer.  Instead we store just pointers to\n+     loops here.  */\n+  struct loop **parray;\n+\n+  /* Pointer to root of loop hierarchy tree.  */\n+  struct loop *tree_root;\n+\n+  /* Information derived from the CFG.  */\n+  struct cfg\n+  {\n+    /* The bitmap vector of dominators or NULL if not computed.  */\n+    dominance_info dom;\n+\n+    /* The ordering of the basic blocks in a depth first search.  */\n+    int *dfs_order;\n+\n+    /* The reverse completion ordering of the basic blocks found in a\n+       depth first search.  */\n+    int *rc_order;\n+  } cfg;\n+\n+  /* Headers shared by multiple loops that should be merged.  */\n+  sbitmap shared_headers;\n+\n+  /* State of loops.  */\n+  int state;\n+};\n+\n+/* Flags for loop discovery.  */\n+\n+#define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */\n+#define LOOP_PRE_HEADER\t\t2\t/* Analyze loop preheader.  */\n+#define LOOP_ENTRY_EDGES\t4\t/* Find entry edges.  */\n+#define LOOP_EXIT_EDGES\t\t8\t/* Find exit edges.  */\n+#define LOOP_EDGES\t\t(LOOP_ENTRY_EDGES | LOOP_EXIT_EDGES)\n+#define LOOP_ALL\t       15\t/* All of the above  */\n+\n+/* Loop recognition.  */\n+extern int flow_loops_find\t\tPARAMS ((struct loops *, int flags));\n+extern int flow_loops_update\t\tPARAMS ((struct loops *, int flags));\n+extern void flow_loops_free\t\tPARAMS ((struct loops *));\n+extern void flow_loops_dump\t\tPARAMS ((const struct loops *, FILE *,\n+\t\t\t\t\t\tvoid (*)(const struct loop *,\n+\t\t\t\t\t\tFILE *, int), int));\n+extern void flow_loop_dump\t\tPARAMS ((const struct loop *, FILE *,\n+\t\t\t\t\t\tvoid (*)(const struct loop *,\n+\t\t\t\t\t\tFILE *, int), int));\n+extern int flow_loop_scan\t\tPARAMS ((struct loops *,\n+\t\t\t\t\t\tstruct loop *, int));\n+void mark_irreducible_loops\t\tPARAMS ((struct loops *));\n+\n+/* Loop datastructure manipulation/querying.  */\n+extern void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n+extern void flow_loop_tree_node_remove\tPARAMS ((struct loop *));\n+extern bool flow_loop_outside_edge_p\tPARAMS ((const struct loop *, edge));\n+extern bool flow_loop_nested_p\t\tPARAMS ((const struct loop *,\n+\t\t\t\t\t\tconst struct loop *));\n+extern bool flow_bb_inside_loop_p\tPARAMS ((const struct loop *,\n+\t\t\t\t\t\tbasic_block));\n+extern struct loop * find_common_loop\tPARAMS ((struct loop *, struct loop *));\n+extern int num_loop_insns\t\tPARAMS ((struct loop *));\n+extern int average_num_loop_insns\tPARAMS ((struct loop *));\n+\n+/* Loops & cfg manipulation.  */\n+extern basic_block *get_loop_body\tPARAMS ((const struct loop *));\n+\n+extern edge loop_preheader_edge\t\tPARAMS ((const struct loop *));\n+extern edge loop_latch_edge\t\tPARAMS ((const struct loop *));\n+\n+extern void add_bb_to_loop\t\tPARAMS ((basic_block, struct loop *));\n+extern void remove_bb_from_loops\tPARAMS ((basic_block));\n+\n+extern void cancel_loop\t\t\tPARAMS ((struct loops *, struct loop *));\n+extern void cancel_loop_tree\t\tPARAMS ((struct loops *, struct loop *));\n+\n+extern basic_block loop_split_edge_with PARAMS ((edge, rtx, struct loops *));\n+\n+enum\n+{\n+  CP_SIMPLE_PREHEADERS = 1,\n+  CP_INSIDE_CFGLAYOUT = 2\n+};\n+\n+extern void create_preheaders\t\tPARAMS ((struct loops *, int));\n+extern void force_single_succ_latches\tPARAMS ((struct loops *));\n+\n+extern void verify_loop_structure\tPARAMS ((struct loops *));\n+\n+/* Loop analysis.  */\n+extern bool simple_loop_p\t\tPARAMS ((struct loops *, struct loop *,\n+\t\t\t\t\t\tstruct loop_desc *));\n+extern rtx count_loop_iterations\tPARAMS ((struct loop_desc *, rtx, rtx));\n+extern bool just_once_each_iteration_p\tPARAMS ((struct loops *,struct loop *,\n+\t\t\t\t\t\t basic_block));\n+extern unsigned expected_loop_iterations PARAMS ((const struct loop *));"}, {"sha": "1c2a57d182c6e3c9c95c0c5baa17bd176c7ce33c", "filename": "gcc/cfgloopanal.c", "status": "added", "additions": 1097, "deletions": 0, "changes": 1097, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -0,0 +1,1097 @@\n+/* Natural loop analysis code for GNU compiler.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"expr.h\"\n+#include \"output.h\"\n+\n+struct unmark_altered_insn_data;\n+static void unmark_altered\t PARAMS ((rtx, rtx, regset));\n+static void blocks_invariant_registers PARAMS ((basic_block *, int, regset));\n+static void unmark_altered_insn\t PARAMS ((rtx, rtx, struct unmark_altered_insn_data *));\n+static void blocks_single_set_registers PARAMS ((basic_block *, int, rtx *));\n+static int invariant_rtx_wrto_regs_p_helper PARAMS ((rtx *, regset));\n+static bool invariant_rtx_wrto_regs_p PARAMS ((rtx, regset));\n+static rtx test_for_iteration PARAMS ((struct loop_desc *desc,\n+\t\t\t\t       unsigned HOST_WIDE_INT));\n+static bool constant_iterations PARAMS ((struct loop_desc *,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t bool *));\n+static bool simple_loop_exit_p PARAMS ((struct loops *, struct loop *,\n+\t\t\t\t\tedge, regset, rtx *,\n+\t\t\t\t\tstruct loop_desc *));\n+static rtx variable_initial_value PARAMS ((rtx, regset, rtx, rtx *));\n+static rtx variable_initial_values PARAMS ((edge, rtx));\n+static bool simple_condition_p PARAMS ((struct loop *, rtx,\n+\t\t\t\t\tregset, struct loop_desc *));\n+static basic_block simple_increment PARAMS ((struct loops *, struct loop *,\n+\t\t\t\t\t     rtx *, struct loop_desc *));\n+\n+/* Checks whether BB is executed exactly once in each LOOP iteration.  */\n+bool\n+just_once_each_iteration_p (loops, loop, bb)\n+     struct loops *loops;\n+     struct loop *loop;\n+     basic_block bb;\n+{\n+  /* It must be executed at least once each iteration.  */\n+  if (!dominated_by_p (loops->cfg.dom, loop->latch, bb))\n+    return false;\n+\n+  /* And just once.  */\n+  if (bb->loop_father != loop)\n+    return false;\n+\n+  /* But this was not enough.  We might have some irreducible loop here.  */\n+  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Unmarks modified registers; helper to blocks_invariant_registers.  */\n+static void\n+unmark_altered (what, by, regs)\n+     rtx what;\n+     rtx by ATTRIBUTE_UNUSED;\n+     regset regs;\n+{\n+  if (GET_CODE (what) == SUBREG)\n+    what = SUBREG_REG (what);\n+  if (!REG_P (what))\n+    return;\n+  CLEAR_REGNO_REG_SET (regs, REGNO (what));\n+}\n+\n+/* Marks registers that are invariant inside blocks BBS.  */\n+static void\n+blocks_invariant_registers (bbs, nbbs, regs)\n+     basic_block *bbs;\n+     int nbbs;\n+     regset regs;\n+{\n+  rtx insn;\n+  int i;\n+\n+  for (i = 0; i < max_reg_num (); i++)\n+    SET_REGNO_REG_SET (regs, i);\n+  for (i = 0; i < nbbs; i++)\n+    for (insn = bbs[i]->head;\n+\t insn != NEXT_INSN (bbs[i]->end);\n+\t insn = NEXT_INSN (insn))\n+      if (INSN_P (insn))\n+\tnote_stores (PATTERN (insn),\n+\t\t     (void (*) PARAMS ((rtx, rtx, void *))) unmark_altered,\n+\t\t     regs);\n+}\n+\n+/* Unmarks modified registers; helper to blocks_single_set_registers.  */\n+struct unmark_altered_insn_data\n+{\n+  rtx *regs;\n+  rtx insn;\n+};\n+\n+static void\n+unmark_altered_insn (what, by, data)\n+     rtx what;\n+     rtx by ATTRIBUTE_UNUSED;\n+     struct unmark_altered_insn_data *data;\n+{\n+  int rn;\n+\n+  if (GET_CODE (what) == SUBREG)\n+    what = SUBREG_REG (what);\n+  if (!REG_P (what))\n+    return;\n+  rn = REGNO (what);\n+  if (data->regs[rn] == data->insn)\n+    return;\n+  data->regs[rn] = NULL;\n+}\n+\n+/* Marks registers that have just single simple set in BBS; the relevant\n+   insn is returned in REGS.  */\n+static void\n+blocks_single_set_registers (bbs, nbbs, regs)\n+     basic_block *bbs;\n+     int nbbs;\n+     rtx *regs;\n+{\n+  rtx insn;\n+  int i;\n+  struct unmark_altered_insn_data data;\n+\n+  for (i = 0; i < max_reg_num (); i++)\n+    regs[i] = NULL;\n+\n+  for (i = 0; i < nbbs; i++)\n+    for (insn = bbs[i]->head;\n+\t insn != NEXT_INSN (bbs[i]->end);\n+\t insn = NEXT_INSN (insn))\n+      {\n+\trtx set = single_set (insn);\n+\tif (!set)\n+\t  continue;\n+\tif (!REG_P (SET_DEST (set)))\n+\t  continue;\n+\tregs[REGNO (SET_DEST (set))] = insn;\n+      }\n+\n+  data.regs = regs;\n+  for (i = 0; i < nbbs; i++)\n+    for (insn = bbs[i]->head;\n+\t insn != NEXT_INSN (bbs[i]->end);\n+\t insn = NEXT_INSN (insn))\n+      {\n+        if (!INSN_P (insn))\n+\t  continue;\n+\tdata.insn = insn;\n+\tnote_stores (PATTERN (insn),\n+\t    (void (*) PARAMS ((rtx, rtx, void *))) unmark_altered_insn,\n+\t    &data);\n+      }\n+}\n+\n+/* Helper for invariant_rtx_wrto_regs_p.  */\n+static int\n+invariant_rtx_wrto_regs_p_helper (expr, invariant_regs)\n+     rtx *expr;\n+     regset invariant_regs;\n+{\n+  switch (GET_CODE (*expr))\n+    {\n+    case CC0:\n+    case PC:\n+    case UNSPEC_VOLATILE:\n+      return 1;\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case ASM_OPERANDS:\n+      return MEM_VOLATILE_P (*expr);\n+\n+    case MEM:\n+      /* If the memory is not constant, assume it is modified.  If it is\n+\t constant, we still have to check the address.  */\n+      return !RTX_UNCHANGING_P (*expr);\n+\n+    case REG:\n+      return !REGNO_REG_SET_P (invariant_regs, REGNO (*expr));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Checks that EXPR is invariant provided that INVARIANT_REGS are invariant. */\n+static bool\n+invariant_rtx_wrto_regs_p (expr, invariant_regs)\n+     rtx expr;\n+     regset invariant_regs;\n+{\n+  return !for_each_rtx (&expr, (rtx_function) invariant_rtx_wrto_regs_p_helper,\n+\t\t\tinvariant_regs);\n+}\n+\n+/* Checks whether CONDITION is a simple comparison in that one of operands\n+   is register and the other one is invariant in the LOOP. Fills var, lim\n+   and cond fields in DESC.  */\n+static bool\n+simple_condition_p (loop, condition, invariant_regs, desc)\n+     struct loop *loop ATTRIBUTE_UNUSED;\n+     rtx condition;\n+     regset invariant_regs;\n+     struct loop_desc *desc;\n+{\n+  rtx op0, op1;\n+\n+  /* Check condition.  */\n+  switch (GET_CODE (condition))\n+    {\n+      case EQ:\n+      case NE:\n+      case LE:\n+      case LT:\n+      case GE:\n+      case GT:\n+      case GEU:\n+      case GTU:\n+      case LEU:\n+      case LTU:\n+\tbreak;\n+      default:\n+\treturn false;\n+    }\n+\n+  /* Of integers or pointers.  */\n+  if (GET_MODE_CLASS (GET_MODE (XEXP (condition, 0))) != MODE_INT\n+      && GET_MODE_CLASS (GET_MODE (XEXP (condition, 0))) != MODE_PARTIAL_INT)\n+    return false;\n+\n+  /* One of operands must be a simple register.  */\n+  op0 = XEXP (condition, 0);\n+  op1 = XEXP (condition, 1);\n+  \n+  /* One of operands must be invariant.  */\n+  if (invariant_rtx_wrto_regs_p (op0, invariant_regs))\n+    {\n+      /* And the other one must be a register.  */\n+      if (!REG_P (op1))\n+\treturn false;\n+      desc->var = op1;\n+      desc->lim = op0;\n+\n+      desc->cond = swap_condition (GET_CODE (condition));\n+      if (desc->cond == UNKNOWN)\n+\treturn false;\n+      return true;\n+    }\n+\n+  /* Check the other operand. */\n+  if (!invariant_rtx_wrto_regs_p (op1, invariant_regs))\n+    return false;\n+  if (!REG_P (op0))\n+    return false;\n+\n+  desc->var = op0;\n+  desc->lim = op1;\n+\n+  desc->cond = GET_CODE (condition);\n+\n+  return true;\n+}\n+\n+/* Checks whether DESC->var is incremented/decremented exactly once each\n+   iteration.  Fills in DESC->stride and returns block in that DESC->var is\n+   modified.  */\n+static basic_block\n+simple_increment (loops, loop, simple_increment_regs, desc)\n+     struct loops *loops;\n+     struct loop *loop;\n+     rtx *simple_increment_regs;\n+     struct loop_desc *desc;\n+{\n+  rtx mod_insn, set, set_src, set_add;\n+  basic_block mod_bb;\n+\n+  /* Find insn that modifies var.  */\n+  mod_insn = simple_increment_regs[REGNO (desc->var)];\n+  if (!mod_insn)\n+    return NULL;\n+  mod_bb = BLOCK_FOR_INSN (mod_insn);\n+\n+  /* Check that it is executed exactly once each iteration.  */\n+  if (!just_once_each_iteration_p (loops, loop, mod_bb))\n+    return NULL;\n+\n+  /* mod_insn must be a simple increment/decrement.  */\n+  set = single_set (mod_insn);\n+  if (!set)\n+    abort ();\n+  if (!rtx_equal_p (SET_DEST (set), desc->var))\n+    abort ();\n+\n+  set_src = find_reg_equal_equiv_note (mod_insn);\n+  if (!set_src)\n+    set_src = SET_SRC (set);\n+  if (GET_CODE (set_src) != PLUS)\n+    return NULL;\n+  if (!rtx_equal_p (XEXP (set_src, 0), desc->var))\n+    return NULL;\n+\n+  /* Set desc->stride.  */\n+  set_add = XEXP (set_src, 1);\n+  if (CONSTANT_P (set_add))\n+    desc->stride = set_add;\n+  else\n+    return NULL;\n+\n+  return mod_bb;\n+}\n+\n+/* Tries to find initial value of VAR in INSN.  This value must be invariant\n+   wrto INVARIANT_REGS.  If SET_INSN is not NULL, insn in that var is set is\n+   placed here.  */\n+static rtx\n+variable_initial_value (insn, invariant_regs, var, set_insn)\n+     rtx insn;\n+     regset invariant_regs;\n+     rtx var;\n+     rtx *set_insn;\n+{\n+  basic_block bb;\n+  rtx set;\n+\n+  /* Go back through cfg.  */\n+  bb = BLOCK_FOR_INSN (insn);\n+  while (1)\n+    {\n+      for (; insn != bb->head; insn = PREV_INSN (insn))\n+\t{\n+\t  if (modified_between_p (var, PREV_INSN (insn), NEXT_INSN (insn)))\n+\t    break;\n+\t  if (INSN_P (insn))\n+\t    note_stores (PATTERN (insn),\n+\t\t(void (*) PARAMS ((rtx, rtx, void *))) unmark_altered,\n+\t\tinvariant_regs);\n+\t}\n+\n+      if (insn != bb->head)\n+\t{\n+\t  /* We found place where var is set.  */\n+\t  rtx set_dest;\n+\t  rtx val;\n+\t  rtx note;\n+          \n+\t  set = single_set (insn);\n+\t  if (!set)\n+\t    return NULL;\n+\t  set_dest = SET_DEST (set);\n+\t  if (!rtx_equal_p (set_dest, var))\n+\t    return NULL;\n+\n+\t  note = find_reg_equal_equiv_note (insn);\n+\t  if (note && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n+\t    val = XEXP (note, 0);\n+\t  else\n+\t    val = SET_SRC (set);\n+\t  if (!invariant_rtx_wrto_regs_p (val, invariant_regs))\n+\t    return NULL;\n+\n+\t  if (set_insn)\n+\t    *set_insn = insn;\n+\t  return val;\n+\t}\n+\n+\n+      if (bb->pred->pred_next || bb->pred->src == ENTRY_BLOCK_PTR)\n+\treturn NULL;\n+\n+      bb = bb->pred->src;\n+      insn = bb->end;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Returns list of definitions of initial value of VAR at Edge.  */\n+static rtx\n+variable_initial_values (e, var)\n+     edge e;\n+     rtx var;\n+{\n+  rtx set_insn, list;\n+  regset invariant_regs;\n+  regset_head invariant_regs_head;\n+  int i;\n+\n+  invariant_regs = INITIALIZE_REG_SET (invariant_regs_head);\n+  for (i = 0; i < max_reg_num (); i++)\n+    SET_REGNO_REG_SET (invariant_regs, i);\n+\n+  list = alloc_EXPR_LIST (0, copy_rtx (var), NULL);\n+\n+  if (e->src == ENTRY_BLOCK_PTR)\n+    return list;\n+\n+  set_insn = e->src->end;\n+  while (REG_P (var)\n+\t && (var = variable_initial_value (set_insn, invariant_regs, var, &set_insn)))\n+    list = alloc_EXPR_LIST (0, copy_rtx (var), list);\n+\n+  FREE_REG_SET (invariant_regs);\n+  return list;\n+}\n+\n+/* Counts constant number of iterations of the loop described by DESC;\n+   returns false if impossible.  */\n+static bool\n+constant_iterations (desc, niter, may_be_zero)\n+     struct loop_desc *desc;\n+     unsigned HOST_WIDE_INT *niter;\n+     bool *may_be_zero;\n+{\n+  rtx test, expr;\n+  rtx ainit, alim;\n+\n+  test = test_for_iteration (desc, 0);\n+  if (test == const0_rtx)\n+    {\n+      *niter = 0;\n+      *may_be_zero = false;\n+      return true;\n+    }\n+\n+  *may_be_zero = (test != const_true_rtx);\n+\n+  /* It would make a little sense to check every with every when we\n+     know that all but the first alternative are simply registers.  */\n+  for (ainit = desc->var_alts; ainit; ainit = XEXP (ainit, 1))\n+    {\n+      alim = XEXP (desc->lim_alts, 0);\n+      if (!(expr = count_loop_iterations (desc, XEXP (ainit, 0), alim)))\n+\tabort ();\n+      if (GET_CODE (expr) == CONST_INT)\n+\t{\n+\t  *niter = INTVAL (expr);\n+\t  return true;\n+\t}\n+    }\n+  for (alim = XEXP (desc->lim_alts, 1); alim; alim = XEXP (alim, 1))\n+    {\n+      ainit = XEXP (desc->var_alts, 0);\n+      if (!(expr = count_loop_iterations (desc, ainit, XEXP (alim, 0))))\n+\tabort ();\n+      if (GET_CODE (expr) == CONST_INT)\n+\t{\n+\t  *niter = INTVAL (expr);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Return RTX expression representing number of iterations of loop as bounded\n+   by test described by DESC (in the case loop really has multiple exit\n+   edges, fewer iterations may happen in the practice).  \n+\n+   Return NULL if it is unknown.  Additionally the value may be invalid for\n+   paradoxical loop (lets define paradoxical loops as loops whose test is\n+   failing at -1th iteration, for instance \"for (i=5;i<1;i++);\").\n+   \n+   These cases needs to be either cared by copying the loop test in the front\n+   of loop or keeping the test in first iteration of loop.\n+   \n+   When INIT/LIM are set, they are used instead of var/lim of DESC. */\n+rtx\n+count_loop_iterations (desc, init, lim)\n+     struct loop_desc *desc;\n+     rtx init;\n+     rtx lim;\n+{\n+  enum rtx_code cond = desc->cond;\n+  rtx stride = desc->stride;\n+  rtx mod, exp;\n+\n+  /* Give up on floating point modes and friends.  It can be possible to do\n+     the job for constant loop bounds, but it is probably not worthwhile.  */\n+  if (!INTEGRAL_MODE_P (GET_MODE (desc->var)))\n+    return NULL;\n+\n+  init = copy_rtx (init ? init : desc->var);\n+  lim = copy_rtx (lim ? lim : desc->lim);\n+\n+  /* Ensure that we always handle the condition to stay inside loop.  */\n+  if (desc->neg)\n+    cond = reverse_condition (cond);\n+\n+  /* Compute absolute value of the difference of initial and final value.  */\n+  if (INTVAL (stride) > 0)\n+    {\n+      /* Bypass nonsensical tests.  */\n+      if (cond == EQ || cond == GE || cond == GT || cond == GEU\n+\t  || cond == GTU)\n+\treturn NULL;\n+      exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n+\t\t\t\t lim, init);\n+    }\n+  else\n+    {\n+      /* Bypass nonsensical tests.  */\n+      if (cond == EQ || cond == LE || cond == LT || cond == LEU\n+\t  || cond == LTU)\n+\treturn NULL;\n+      exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n+\t\t\t\t init, lim);\n+      stride = simplify_gen_unary (NEG, GET_MODE (desc->var),\n+\t\t\t\t   stride, GET_MODE (desc->var));\n+    }\n+\n+  /* Normalize difference so the value is always first examined\n+     and later incremented.  */\n+\n+  if (!desc->postincr)\n+    exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n+\t\t\t       exp, stride);\n+\n+  /* Determine delta caused by exit condition.  */\n+  switch (cond)\n+    {\n+    case NE:\n+      /* For NE tests, make sure that the iteration variable won't miss\n+\t the final value.  If EXP mod STRIDE is not zero, then the\n+\t iteration variable will overflow before the loop exits, and we\n+\t can not calculate the number of iterations easily.  */\n+      if (stride != const1_rtx\n+\t  && (simplify_gen_binary (UMOD, GET_MODE (desc->var), exp, stride)\n+              != const0_rtx))\n+\treturn NULL;\n+      break;\n+    case LT:\n+    case GT:\n+    case LTU:\n+    case GTU:\n+      break;\n+    case LE:\n+    case GE:\n+    case LEU:\n+    case GEU:\n+      exp = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n+\t\t\t\t exp, const1_rtx);\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  if (stride != const1_rtx)\n+    {\n+      /* Number of iterations is now (EXP + STRIDE - 1 / STRIDE),\n+\t but we need to take care for overflows.   */\n+\n+      mod = simplify_gen_binary (UMOD, GET_MODE (desc->var), exp, stride);\n+\n+      /* This is dirty trick.  When we can't compute number of iterations\n+\t to be constant, we simply ignore the possible overflow, as\n+\t runtime unroller always use power of 2 amounts and does not\n+\t care about possible lost bits.  */\n+\n+      if (GET_CODE (mod) != CONST_INT)\n+\t{\n+\t  rtx stridem1 = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n+\t\t\t\t\t      stride, constm1_rtx);\n+\t  exp = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n+\t\t\t\t     exp, stridem1);\n+\t  exp = simplify_gen_binary (UDIV, GET_MODE (desc->var), exp, stride);\n+\t}\n+      else\n+\t{\n+\t  exp = simplify_gen_binary (UDIV, GET_MODE (desc->var), exp, stride);\n+\t  if (mod != const0_rtx)\n+\t    exp = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n+\t\t\t\t       exp, const1_rtx);\n+\t}\n+    }\n+\n+  if (rtl_dump_file)\n+    {\n+      fprintf (rtl_dump_file, \";  Number of iterations: \");\n+      print_simple_rtl (rtl_dump_file, exp);\n+      fprintf (rtl_dump_file, \"\\n\");\n+    }\n+\n+  return exp;\n+}\n+\n+/* Return simplified RTX expression representing the value of test\n+   described of DESC at given iteration of loop.  */\n+\n+static rtx\n+test_for_iteration (desc, iter)\n+     struct loop_desc *desc;\n+     unsigned HOST_WIDE_INT iter;\n+{\n+  enum rtx_code cond = desc->cond;\n+  rtx exp = XEXP (desc->var_alts, 0);\n+  rtx addval;\n+\n+  /* Give up on floating point modes and friends.  It can be possible to do\n+     the job for constant loop bounds, but it is probably not worthwhile.  */\n+  if (!INTEGRAL_MODE_P (GET_MODE (desc->var)))\n+    return NULL;\n+\n+  /* Ensure that we always handle the condition to stay inside loop.  */\n+  if (desc->neg)\n+    cond = reverse_condition (cond);\n+\n+  /* Compute the value of induction variable.  */\n+  addval = simplify_gen_binary (MULT, GET_MODE (desc->var),\n+\t\t\t\tdesc->stride,\n+\t\t\t\tgen_int_mode (desc->postincr\n+\t\t\t\t\t      ? iter : iter + 1,\n+\t\t\t\t\t      GET_MODE (desc->var)));\n+  exp = simplify_gen_binary (PLUS, GET_MODE (desc->var), exp, addval);\n+  /* Test at given condition.  */\n+  exp = simplify_gen_relational (cond, SImode,\n+\t\t\t\t GET_MODE (desc->var), exp, desc->lim);\n+\n+  if (rtl_dump_file)\n+    {\n+      fprintf (rtl_dump_file, \";  Conditional to continue loop at \");\n+      fprintf (rtl_dump_file, HOST_WIDE_INT_PRINT_UNSIGNED, iter);\n+      fprintf (rtl_dump_file, \"th iteration: \");\n+      print_simple_rtl (rtl_dump_file, exp);\n+      fprintf (rtl_dump_file, \"\\n\");\n+    }\n+  return exp;\n+}\n+\n+\n+/* Tests whether exit at EXIT_EDGE from LOOP is simple.  Returns simple loop\n+   description joined to it in in DESC.  INVARIANT_REGS and SINGLE_SET_REGS\n+   are results of blocks_{invariant,single_set}_regs over BODY.  */\n+static bool\n+simple_loop_exit_p (loops, loop, exit_edge, invariant_regs, single_set_regs, desc)\n+     struct loops *loops;\n+     struct loop *loop;\n+     edge exit_edge;\n+     struct loop_desc *desc;\n+     regset invariant_regs;\n+     rtx *single_set_regs;\n+{\n+  basic_block mod_bb, exit_bb;\n+  int fallthru_out;\n+  rtx condition;\n+  edge ei, e;\n+\n+  exit_bb = exit_edge->src;\n+\n+  fallthru_out = (exit_edge->flags & EDGE_FALLTHRU);\n+\n+  if (!exit_bb)\n+    return false;\n+\n+  /* It must be tested (at least) once during any iteration.  */\n+  if (!dominated_by_p (loops->cfg.dom, loop->latch, exit_bb))\n+    return false;\n+\n+  /* It must end in a simple conditional jump.  */\n+  if (!any_condjump_p (exit_bb->end))\n+    return false;\n+\n+  ei = exit_bb->succ;\n+  if (ei == exit_edge)\n+    ei = ei->succ_next;\n+\n+  desc->out_edge = exit_edge;\n+  desc->in_edge = ei;\n+\n+  /* Condition must be a simple comparison in that one of operands\n+     is register and the other one is invariant.  */\n+  if (!(condition = get_condition (exit_bb->end, NULL)))\n+    return false;\n+\n+  if (!simple_condition_p (loop, condition, invariant_regs, desc))\n+    return false;\n+\n+  /*  Var must be simply incremented or decremented in exactly one insn that\n+     is executed just once every iteration.  */\n+  if (!(mod_bb = simple_increment (loops, loop, single_set_regs, desc)))\n+    return false;\n+\n+  /* OK, it is simple loop.  Now just fill in remaining info.  */\n+  desc->postincr = !dominated_by_p (loops->cfg.dom, exit_bb, mod_bb);\n+  desc->neg = !fallthru_out;\n+\n+  /* Find initial value of var and alternative values for lim.  */\n+  e = loop_preheader_edge (loop);\n+  desc->var_alts = variable_initial_values (e, desc->var);\n+  desc->lim_alts = variable_initial_values (e, desc->lim);\n+\n+  /* Number of iterations. */\n+  if (!count_loop_iterations (desc, NULL, NULL))\n+    return false;\n+  desc->const_iter =\n+    constant_iterations (desc, &desc->niter, &desc->may_be_zero);\n+  return true;\n+}\n+\n+/* Tests whether LOOP is simple for loop.  Returns simple loop description\n+   in DESC.  */\n+bool\n+simple_loop_p (loops, loop, desc)\n+     struct loops *loops;\n+     struct loop *loop;\n+     struct loop_desc *desc;\n+{\n+  unsigned i;\n+  basic_block *body;\n+  edge e;\n+  struct loop_desc act;\n+  bool any = false;\n+  regset invariant_regs;\n+  regset_head invariant_regs_head;\n+  rtx *single_set_regs;\n+  int n_branches;\n+  \n+  body = get_loop_body (loop);\n+\n+  invariant_regs = INITIALIZE_REG_SET (invariant_regs_head);\n+  single_set_regs = xmalloc (max_reg_num () * sizeof (rtx));\n+\n+  blocks_invariant_registers (body, loop->num_nodes, invariant_regs);\n+  blocks_single_set_registers (body, loop->num_nodes, single_set_regs);\n+\n+  n_branches = 0;\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      for (e = body[i]->succ; e; e = e->succ_next)\n+\tif (!flow_bb_inside_loop_p (loop, e->dest)\n+\t    && simple_loop_exit_p (loops, loop, e,\n+\t\t   invariant_regs, single_set_regs, &act))\n+\t  {\n+\t    /* Prefer constant iterations; the less the better.  */\n+\t    if (!any)\n+\t      any = true;\n+\t    else if (!act.const_iter\n+\t\t     || (desc->const_iter && act.niter >= desc->niter))\n+\t      continue;\n+\t    *desc = act;\n+\t  }\n+\n+      if (body[i]->succ && body[i]->succ->succ_next)\n+\tn_branches++;\n+    }\n+  desc->n_branches = n_branches;\n+\n+  if (rtl_dump_file && any)\n+    {\n+      fprintf (rtl_dump_file, \"; Simple loop %i\\n\", loop->num);\n+      if (desc->postincr)\n+\tfprintf (rtl_dump_file,\n+\t\t \";  does postincrement after loop exit condition\\n\");\n+\n+      fprintf (rtl_dump_file, \";  Induction variable:\");\n+      print_simple_rtl (rtl_dump_file, desc->var);\n+      fputc ('\\n', rtl_dump_file);\n+\n+      fprintf (rtl_dump_file, \";  Initial values:\");\n+      print_simple_rtl (rtl_dump_file, desc->var_alts);\n+      fputc ('\\n', rtl_dump_file);\n+\n+      fprintf (rtl_dump_file, \";  Stride:\");\n+      print_simple_rtl (rtl_dump_file, desc->stride);\n+      fputc ('\\n', rtl_dump_file);\n+\n+      fprintf (rtl_dump_file, \";  Compared with:\");\n+      print_simple_rtl (rtl_dump_file, desc->lim);\n+      fputc ('\\n', rtl_dump_file);\n+\n+      fprintf (rtl_dump_file, \";  Alternative values:\");\n+      print_simple_rtl (rtl_dump_file, desc->lim_alts);\n+      fputc ('\\n', rtl_dump_file);\n+\n+      fprintf (rtl_dump_file, \";  Exit condition:\");\n+      if (desc->neg)\n+\tfprintf (rtl_dump_file, \"(negated)\");\n+      fprintf (rtl_dump_file, \"%s\\n\", GET_RTX_NAME (desc->cond));\n+\n+      fprintf (rtl_dump_file, \";  Number of branches:\");\n+      fprintf (rtl_dump_file, \"%d\\n\", desc->n_branches);\n+\n+      fputc ('\\n', rtl_dump_file);\n+    }\n+\n+  free (body);\n+  FREE_REG_SET (invariant_regs);\n+  free (single_set_regs);\n+  return any;\n+}\n+\n+/* Marks blocks that are part of non-recognized loops; i.e. we throw away\n+   all latch edges and mark blocks inside any remaining cycle.  Everything\n+   is a bit complicated due to fact we do not want to do this for parts of\n+   cycles that only \"pass\" through some loop -- i.e. for each cycle, we want\n+   to mark blocks that belong directly to innermost loop containing the whole\n+   cycle.  */\n+void\n+mark_irreducible_loops (loops)\n+     struct loops *loops;\n+{\n+  int *dfs_in, *closed, *mr, *mri, *n_edges, *stack;\n+  unsigned i;\n+  edge **edges, e;\n+  basic_block act;\n+  int stack_top, tick, depth;\n+  struct loop *cloop;\n+\n+  /* The first last_basic_block + 1 entries are for real blocks (including\n+     entry); then we have loops->num - 1 fake blocks for loops to that we\n+     assign edges leading from loops (fake loop 0 is not interesting).  */\n+  dfs_in = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  closed = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  mr = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  mri = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  n_edges = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  edges = xmalloc ((last_basic_block + loops->num) * sizeof (edge *));\n+  stack = xmalloc ((n_basic_blocks + loops->num) * sizeof (int));\n+\n+  /* Create the edge lists.  */\n+  for (i = 0; i < last_basic_block + loops->num; i++)\n+    n_edges[i] = 0;\n+  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    for (e = act->succ; e; e = e->succ_next)\n+      {\n+        /* Ignore edges to exit.  */\n+        if (e->dest == EXIT_BLOCK_PTR)\n+\t  continue;\n+\t/* And latch edges.  */\n+\tif (e->dest->loop_father->header == e->dest\n+\t    && e->dest->loop_father->latch == act)\n+\t  continue;\n+\t/* Edges inside a single loop should be left where they are.  Edges\n+\t   to subloop headers should lead to representative of the subloop,\n+\t   but from the same place.  */\n+\tif (act->loop_father == e->dest->loop_father\n+\t    || act->loop_father == e->dest->loop_father->outer)\n+\t  {\n+\t    n_edges[act->index + 1]++;\n+\t    continue;\n+\t  }\n+\t/* Edges exiting loops remain.  They should lead from representative\n+\t   of the son of nearest common ancestor of the loops in that\n+\t   act lays.  */\n+\tdepth = find_common_loop (act->loop_father, e->dest->loop_father)->depth + 1;\n+\tif (depth == act->loop_father->depth)\n+\t  cloop = act->loop_father;\n+\telse\n+\t  cloop = act->loop_father->pred[depth];\n+\tn_edges[cloop->num + last_basic_block]++;\n+      }\n+\n+  for (i = 0; i < last_basic_block + loops->num; i++)\n+    {\n+      edges[i] = xmalloc (n_edges[i] * sizeof (edge));\n+      n_edges[i] = 0;\n+    }\n+\n+  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    for (e = act->succ; e; e = e->succ_next)\n+      {\n+        if (e->dest == EXIT_BLOCK_PTR)\n+\t  continue;\n+\tif (e->dest->loop_father->header == e->dest\n+\t    && e->dest->loop_father->latch == act)\n+\t  continue;\n+\tif (act->loop_father == e->dest->loop_father\n+\t    || act->loop_father == e->dest->loop_father->outer)\n+\t  {\n+\t    edges[act->index + 1][n_edges[act->index + 1]++] = e;\n+\t    continue;\n+\t  }\n+\tdepth = find_common_loop (act->loop_father, e->dest->loop_father)->depth + 1;\n+\tif (depth == act->loop_father->depth)\n+\t  cloop = act->loop_father;\n+\telse\n+\t  cloop = act->loop_father->pred[depth];\n+\ti = cloop->num + last_basic_block;\n+\tedges[i][n_edges[i]++] = e;\n+      }\n+\n+  /* Compute dfs numbering, starting from loop headers, and mark found\n+     loops.*/\n+  tick = 0;\n+  for (i = 0; i < last_basic_block + loops->num; i++)\n+    {\n+      dfs_in[i] = -1;\n+      closed[i] = 0;\n+      mr[i] = last_basic_block + loops->num;\n+      mri[i] = -1;\n+    }\n+\n+  stack_top = 0;\n+  for (i = 0; i < loops->num; i++)\n+    if (loops->parray[i])\n+      stack[stack_top++] = loops->parray[i]->header->index + 1;\n+\n+  while (stack_top)\n+    {\n+      int idx, sidx;\n+\n+      idx = stack[stack_top - 1];\n+      if (dfs_in[idx] < 0)\n+\tdfs_in[idx] = tick++;\n+\n+      while (n_edges[idx])\n+\t{\n+\t  e = edges[idx][--n_edges[idx]];\n+\t  sidx = e->dest->loop_father->header == e->dest\n+\t           ? e->dest->loop_father->num + last_basic_block\n+\t           : e->dest->index + 1;\n+          if (closed[sidx])\n+\t    {\n+\t      if (mr[sidx] < mr[idx] && !closed[mri[sidx]])\n+\t\t{\n+\t\t  mr[idx] = mr[sidx];\n+\t\t  mri[idx] = mri[sidx];\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  if (dfs_in[sidx] < 0)\n+\t    {\n+\t      stack[stack_top++] = sidx;\n+\t      goto next;\n+\t    }\n+\t  if (dfs_in[sidx] < mr[idx])\n+\t    {\n+\t      mr[idx] = dfs_in[sidx];\n+\t      mri[idx] = sidx;\n+\t    }\n+\t}\n+\n+      /* Return back.  */\n+      closed[idx] = 1;\n+      stack_top--;\n+      if (stack_top && dfs_in[stack[stack_top - 1]] >= 0)\n+        {\n+\t  /* Propagate information back.  */\n+\t  sidx = stack[stack_top - 1];\n+\t  if (mr[sidx] > mr[idx])\n+\t    {\n+\t      mr[sidx] = mr[idx];\n+\t      mri[sidx] = mri[idx];\n+\t    }\n+\t}\n+      /* Mark the block if relevant.  */\n+      if (idx && idx <= last_basic_block && mr[idx] <= dfs_in[idx])\n+        BASIC_BLOCK (idx - 1)->flags |= BB_IRREDUCIBLE_LOOP;\n+next:;\n+    }\n+\n+  free (stack);\n+  free (dfs_in);\n+  free (closed);\n+  free (mr);\n+  free (mri);\n+  for (i = 0; i < last_basic_block + loops->num; i++)\n+    free (edges[i]);\n+  free (edges);\n+  free (n_edges);\n+  loops->state |= LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n+}\n+\n+/* Counts number of insns inside LOOP.  */\n+int\n+num_loop_insns (loop)\n+     struct loop *loop;\n+{\n+  basic_block *bbs, bb;\n+  unsigned i, ninsns = 0;\n+  rtx insn;\n+\n+  bbs = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = bbs[i];\n+      ninsns++;\n+      for (insn = bb->head; insn != bb->end; insn = NEXT_INSN (insn))\n+\tninsns++;\n+    }\n+  free(bbs);\n+  \n+  return ninsns;\n+}\n+\n+/* Counts number of insns executed on average per iteration LOOP.  */\n+int\n+average_num_loop_insns (loop)\n+     struct loop *loop;\n+{\n+  basic_block *bbs, bb;\n+  unsigned i, binsns, ninsns, ratio;\n+  rtx insn;\n+\n+  ninsns = 0;\n+  bbs = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = bbs[i];\n+\n+      binsns = 1;\n+      for (insn = bb->head; insn != bb->end; insn = NEXT_INSN (insn))\n+\tbinsns++;\n+\n+      ratio = loop->header->frequency == 0\n+\t      ? BB_FREQ_MAX\n+\t      : (bb->frequency * BB_FREQ_MAX) / loop->header->frequency;\n+      ninsns += binsns * ratio;\n+    }\n+  free(bbs);\n+ \n+  ninsns /= BB_FREQ_MAX;\n+  if (!ninsns)\n+    ninsns = 1; /* To avoid division by zero.  */\n+\n+  return ninsns;\n+}\n+\n+/* Returns expected number of LOOP iterations.\n+   Compute upper bound on number of iterations in case they do not fit integer\n+   to help loop peeling heuristics.  Use exact counts if at all possible.  */\n+unsigned\n+expected_loop_iterations (loop)\n+     const struct loop *loop;\n+{\n+  edge e;\n+\n+  if (loop->header->count)\n+    {\n+      gcov_type count_in, count_latch, expected;\n+\n+      count_in = 0;\n+      count_latch = 0;\n+\n+      for (e = loop->header->pred; e; e = e->pred_next)\n+\tif (e->src == loop->latch)\n+\t  count_latch = e->count;\n+\telse\n+\t  count_in += e->count;\n+\n+      if (count_in == 0)\n+\treturn 0;\n+\n+      expected = (count_latch + count_in - 1) / count_in;\n+\n+      /* Avoid overflows.  */\n+      return (expected > REG_BR_PROB_BASE ? REG_BR_PROB_BASE : expected);\n+    }\n+  else\n+    {\n+      int freq_in, freq_latch;\n+\n+      freq_in = 0;\n+      freq_latch = 0;\n+\n+      for (e = loop->header->pred; e; e = e->pred_next)\n+\tif (e->src == loop->latch)\n+\t  freq_latch = EDGE_FREQUENCY (e);\n+\telse\n+\t  freq_in += EDGE_FREQUENCY (e);\n+\n+      if (freq_in == 0)\n+\treturn 0;\n+\n+      return (freq_latch + freq_in - 1) / freq_in;\n+    }\n+}"}, {"sha": "0bbf4b02e4598199862ca7db25333413923505d8", "filename": "gcc/cfgloopmanip.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -0,0 +1,226 @@\n+/* Loop manipulation code for GNU compiler.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"cfglayout.h\"\n+#include \"output.h\"\n+\n+static basic_block create_preheader\tPARAMS ((struct loop *, dominance_info,\n+\t\t\t\t\t\tint));\n+\n+/* Creates a pre-header for a LOOP.  Returns newly created block.  Unless\n+   CP_SIMPLE_PREHEADERS is set in FLAGS, we only force LOOP to have single\n+   entry; otherwise we also force preheader block to have only one successor.\n+   */\n+static basic_block\n+create_preheader (loop, dom, flags)\n+     struct loop *loop;\n+     dominance_info dom;\n+     int flags;\n+{\n+  edge e, fallthru;\n+  basic_block dummy;\n+  basic_block jump, src;\n+  struct loop *cloop, *ploop;\n+  int nentry = 0;\n+  rtx insn;\n+\n+  cloop = loop->outer;\n+\n+  for (e = loop->header->pred; e; e = e->pred_next)\n+    {\n+      if (e->src == loop->latch)\n+\tcontinue;\n+      nentry++;\n+    }\n+  if (!nentry)\n+    abort ();\n+  if (nentry == 1)\n+    {\n+      for (e = loop->header->pred; e->src == loop->latch; e = e->pred_next);\n+      if (!(flags & CP_SIMPLE_PREHEADERS)\n+\t  || !e->src->succ->succ_next)\n+\treturn NULL;\n+    }\n+\n+  insn = first_insn_after_basic_block_note (loop->header);\n+  if (insn)\n+    insn = PREV_INSN (insn);\n+  else\n+    insn = get_last_insn ();\n+  if (insn == loop->header->end)\n+    {\n+      /* Split_block would not split block after its end.  */\n+      emit_note_after (NOTE_INSN_DELETED, insn);\n+    }\n+  if (flags & CP_INSIDE_CFGLAYOUT)\n+    fallthru = cfg_layout_split_block (loop->header, insn);\n+  else\n+    fallthru = split_block (loop->header, insn);\n+  dummy = fallthru->src;\n+  loop->header = fallthru->dest;\n+\n+  /* The header could be a latch of some superloop(s); due to design of\n+     split_block, it would now move to fallthru->dest.  */\n+  for (ploop = loop; ploop; ploop = ploop->outer)\n+    if (ploop->latch == dummy)\n+      ploop->latch = fallthru->dest;\n+\n+  add_to_dominance_info (dom, fallthru->dest);\n+  \n+  /* Redirect edges. */\n+  for (e = dummy->pred; e; e = e->pred_next)\n+    {\n+      src = e->src;\n+      if (src == loop->latch)\n+\tbreak;\n+    }\n+  if (!e)\n+    abort ();\n+\n+  dummy->frequency -= EDGE_FREQUENCY (e);\n+  dummy->count -= e->count;\n+  fallthru->count -= e->count;\n+  if (flags & CP_INSIDE_CFGLAYOUT)\n+    cfg_layout_redirect_edge (e, loop->header);\n+  else\n+    {\n+      jump = redirect_edge_and_branch_force (e, loop->header);\n+      if (jump)\n+\t{\n+\t  add_to_dominance_info (dom, jump);\n+\t  set_immediate_dominator (dom, jump, src);\n+\t  add_bb_to_loop (jump, loop);\n+\t  loop->latch = jump;\n+\t}\n+    }\n+\n+  /* Update structures.  */\n+  redirect_immediate_dominators (dom, dummy, loop->header);\n+  set_immediate_dominator (dom, loop->header, dummy);\n+  loop->header->loop_father = loop;\n+  add_bb_to_loop (dummy, cloop);\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Created preheader block for loop %i\\n\",\n+\t     loop->num);\n+\n+  return dummy;\n+}\n+\n+/* Create preheaders for each loop; for meaning of flags see\n+   create_preheader.  */\n+void\n+create_preheaders (loops, flags)\n+     struct loops *loops;\n+     int flags;\n+{\n+  unsigned i;\n+  for (i = 1; i < loops->num; i++)\n+    create_preheader (loops->parray[i], loops->cfg.dom, flags);\n+  loops->state |= LOOPS_HAVE_PREHEADERS;\n+}\n+\n+/* Forces all loop latches to have only single successor.  */\n+void\n+force_single_succ_latches (loops)\n+     struct loops *loops;\n+{\n+  unsigned i;\n+  struct loop *loop;\n+  edge e;\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (!loop->latch->succ->succ_next)\n+\tcontinue;\n+ \n+      for (e = loop->header->pred; e->src != loop->latch; e = e->pred_next);\n+\tloop_split_edge_with (e, NULL_RTX, loops);\n+    }\n+  loops->state |= LOOPS_HAVE_SIMPLE_LATCHES;\n+}\n+\n+/* A quite stupid function to put INSNS on E. They are supposed to form\n+   just one basic block. Jumps out are not handled, so cfg do not have to\n+   be ok after this function.  */\n+basic_block\n+loop_split_edge_with (e, insns, loops)\n+     edge e;\n+     rtx insns;\n+     struct loops *loops;\n+{\n+  basic_block src, dest, new_bb;\n+  struct loop *loop_c;\n+  edge new_e;\n+  \n+  src = e->src;\n+  dest = e->dest;\n+\n+  loop_c = find_common_loop (src->loop_father, dest->loop_father);\n+\n+  /* Create basic block for it.  */\n+\n+  new_bb = create_basic_block (NULL_RTX, NULL_RTX, EXIT_BLOCK_PTR->prev_bb);\n+  add_to_dominance_info (loops->cfg.dom, new_bb);\n+  add_bb_to_loop (new_bb, loop_c);\n+  new_bb->flags = insns ? BB_SUPERBLOCK : 0;\n+  if (src->flags & BB_IRREDUCIBLE_LOOP)\n+    {\n+      /* We expect simple preheaders here.  */\n+      if ((dest->flags & BB_IRREDUCIBLE_LOOP)\n+          || dest->loop_father->header == dest)\n+        new_bb->flags |= BB_IRREDUCIBLE_LOOP;\n+    }\n+\n+  new_e = make_edge (new_bb, dest, EDGE_FALLTHRU);\n+  new_e->probability = REG_BR_PROB_BASE;\n+  new_e->count = e->count;\n+\n+  new_bb->count = e->count;\n+  new_bb->frequency = EDGE_FREQUENCY (e);\n+  cfg_layout_redirect_edge (e, new_bb);\n+\n+  alloc_aux_for_block (new_bb, sizeof (struct reorder_block_def));\n+  if (insns)\n+    {\n+      start_sequence ();\n+      emit_insn (insns);\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_insn_after (insns, new_bb->end);\n+    }\n+\n+  set_immediate_dominator (loops->cfg.dom, new_bb, src);\n+  set_immediate_dominator (loops->cfg.dom, dest,\n+    recount_dominator (loops->cfg.dom, dest));\n+\n+  if (dest->loop_father->latch == src)\n+    dest->loop_father->latch = new_bb;\n+  \n+  return new_bb;\n+}"}, {"sha": "2916d950ec1f004ea0b9048294dc11365b07be85", "filename": "gcc/doloop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"toplev.h\"\n #include \"tm_p.h\"\n+#include \"cfgloop.h\"\n \n \n /* This module is used to modify loops with a determinable number of"}, {"sha": "c7165e54ed70bc205ef8d6b9e18b4be6ebb0bb87", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -56,6 +56,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"predict.h\"\n #include \"insn-flags.h\"\n #include \"optabs.h\"\n+#include \"cfgloop.h\"\n \n /* Not really meaningful values, but at least something.  */\n #ifndef SIMULTANEOUS_PREFETCHES\n@@ -495,7 +496,7 @@ loop_optimize (f, dumpfile, flags)\n \n   /* Allocate and initialize auxiliary loop information.  */\n   loops_info = xcalloc (loops->num, sizeof (struct loop_info));\n-  for (i = 0; i < loops->num; i++)\n+  for (i = 0; i < (int) loops->num; i++)\n     loops->array[i].aux = loops_info + i;\n \n   /* Now find all register lifetimes.  This must be done after"}, {"sha": "09bc562e6c1bfbf7e826686293a84a769796d5bd", "filename": "gcc/predict.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -52,6 +52,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"target.h\"\n #include \"loop.h\"\n+#include \"cfgloop.h\"\n \n /* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n \t\t   1/REG_BR_PROB_BASE, 0.5, BB_FREQ_MAX.  */\n@@ -425,7 +426,7 @@ estimate_probability (loops_info)\n {\n   dominance_info dominators, post_dominators;\n   basic_block bb;\n-  int i;\n+  unsigned i;\n \n   connect_infinite_loops_to_exit ();\n   dominators = calculate_dominance_info (CDI_DOMINATORS);\n@@ -436,13 +437,28 @@ estimate_probability (loops_info)\n   for (i = 1; i < loops_info->num; i++)\n     {\n       basic_block bb, *bbs;\n-      int j;\n+      unsigned j;\n       int exits;\n       struct loop *loop = loops_info->parray[i];\n+      struct loop_desc desc;\n+      unsigned HOST_WIDE_INT niter;\n \n       flow_loop_scan (loops_info, loop, LOOP_EXIT_EDGES);\n       exits = loop->num_exits;\n \n+      if (simple_loop_p (loops_info, loop, &desc)\n+\t  && desc.const_iter)\n+\t{\n+\t  niter = desc.niter + 1;\n+\t  if (niter == 0)        /* We might overflow here.  */\n+\t    niter = desc.niter;\n+\n+\t  predict_edge (desc.in_edge, PRED_LOOP_ITERATIONS,\n+\t\t\tREG_BR_PROB_BASE\n+\t\t\t- (REG_BR_PROB_BASE + niter /2)\n+\t\t\t/ niter);\n+\t}\n+\n       bbs = get_loop_body (loop);\n       for (j = 0; j < loop->num_nodes; j++)\n \t{\n@@ -1060,7 +1076,7 @@ estimate_loops_at_level (first_loop)\n     {\n       edge e;\n       basic_block *bbs;\n-      int i;\n+      unsigned i;\n \n       estimate_loops_at_level (loop->inner);\n       "}, {"sha": "1ab3f82007bab291afaf12f14d7625324c888f27", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -73,6 +73,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n+#include \"cfgloop.h\"\n \n #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\""}, {"sha": "5c19b55aafd829cca6f3736eb7f326a8105f77b1", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -366,7 +366,7 @@ tracer ()\n {\n   if (n_basic_blocks <= 1)\n     return;\n-  cfg_layout_initialize ();\n+  cfg_layout_initialize (NULL);\n   mark_dfs_back_edges ();\n   if (rtl_dump_file)\n     dump_flow_info (rtl_dump_file);"}, {"sha": "849b1b582637cf584d8115fcdfc937fe2cbb992d", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d436d2ac575b85dc7c787fbeacc3c08597000c3/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=3d436d2ac575b85dc7c787fbeacc3c08597000c3", "patch": "@@ -150,6 +150,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"predict.h\"\n #include \"params.h\"\n+#include \"cfgloop.h\"\n \n /* The prime factors looked for when trying to unroll a loop by some\n    number which is modulo the total number of iterations.  Just checking"}]}