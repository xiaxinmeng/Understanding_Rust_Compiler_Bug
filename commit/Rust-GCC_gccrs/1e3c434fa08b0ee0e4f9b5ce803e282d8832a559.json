{"sha": "1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUzYzQzNGZhMDhiMGVlMGU0ZjliNWNlODAzZTI4MmQ4ODMyYTU1OQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2018-11-14T11:41:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-11-14T11:41:36Z"}, "message": "[Ada] System'To_Address not always static\n\nSystem'To_Address is supposed to be static when its parameter is static.\nThis patch fixes a bug in which it is considered nonstatic when used as\nthe initial value of a variable with the Thread_Local_Storage aspect, so\nthe compiler incorrectly gives an error when initializing such a\nvariable with System'To_Address (0).\n\n2018-11-14  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* sem_attr.adb (To_Address): Simplify setting of\n\tIs_Static_Expression. Remove second (unconditional) call to\n\tSet_Is_Static_Expression -- surely it's not static if the\n\toperand is not.  Initialize Static on declaration.  Do not try\n\tto fold 'To_Address, even though it's static.\n\t* exp_attr.adb (To_Address): Preserve Is_Static_Expression.\n\t* sinfo.ads, sem_eval.ads, sem_eval.adb (Is_Static_Expression,\n\tIs_OK_Static_Expression, Raises_Constraint_Error): Simplify\n\tdocumentation.  There was too much repetition and redundancy.\n\nFrom-SVN: r266124", "tree": {"sha": "53c1e8aff76e28c94f53a22b6ebaf2c960a5812c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53c1e8aff76e28c94f53a22b6ebaf2c960a5812c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43018f5892ff43551abad3f339bcb55cf74c89cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43018f5892ff43551abad3f339bcb55cf74c89cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43018f5892ff43551abad3f339bcb55cf74c89cf"}], "stats": {"total": 194, "additions": 90, "deletions": 104}, "files": [{"sha": "52ea778131afd06320c44d695efd1db8e7898137", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "patch": "@@ -1,3 +1,15 @@\n+2018-11-14  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_attr.adb (To_Address): Simplify setting of\n+\tIs_Static_Expression. Remove second (unconditional) call to\n+\tSet_Is_Static_Expression -- surely it's not static if the\n+\toperand is not.  Initialize Static on declaration.  Do not try\n+\tto fold 'To_Address, even though it's static.\n+\t* exp_attr.adb (To_Address): Preserve Is_Static_Expression.\n+\t* sinfo.ads, sem_eval.ads, sem_eval.adb (Is_Static_Expression,\n+\tIs_OK_Static_Expression, Raises_Constraint_Error): Simplify\n+\tdocumentation.  There was too much repetition and redundancy.\n+\n 2018-11-14  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Analyze_Object_Declaration): Use the"}, {"sha": "2c2442a3bc85d1f0a6021b3d7cd217219e1ce0a5", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "patch": "@@ -6605,15 +6605,20 @@ package body Exp_Attr is\n       ----------------\n \n       --  Transforms System'To_Address (X) and System.Address'Ref (X) into\n-      --  unchecked conversion from (integral) type of X to type address.\n+      --  unchecked conversion from (integral) type of X to type address. If\n+      --  the To_Address is a static expression, the transformed expression\n+      --  also needs to be static, because we do some legality checks (e.g.\n+      --  for Thread_Local_Storage) after this transformation.\n \n-      when Attribute_Ref\n-         | Attribute_To_Address\n-      =>\n+      when Attribute_Ref | Attribute_To_Address => To_Address : declare\n+         Is_Static : constant Boolean := Is_Static_Expression (N);\n+      begin\n          Rewrite (N,\n            Unchecked_Convert_To (RTE (RE_Address),\n              Relocate_Node (First (Exprs))));\n+         Set_Is_Static_Expression (N, Is_Static);\n          Analyze_And_Resolve (N, RTE (RE_Address));\n+      end To_Address;\n \n       ------------\n       -- To_Any --"}, {"sha": "30cdc95eb65fefdec2c89ad5feb5bbf5845676bc", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "patch": "@@ -6144,7 +6144,6 @@ package body Sem_Attr is\n \n       when Attribute_To_Address => To_Address : declare\n          Val : Uint;\n-\n       begin\n          Check_E1;\n          Analyze (P);\n@@ -6153,10 +6152,7 @@ package body Sem_Attr is\n          Generate_Reference (RTE (RE_Address), P);\n          Analyze_And_Resolve (E1, Any_Integer);\n          Set_Etype (N, RTE (RE_Address));\n-\n-         if Is_Static_Expression (E1) then\n-            Set_Is_Static_Expression (N, True);\n-         end if;\n+         Set_Is_Static_Expression (N, Is_Static_Expression (E1));\n \n          --  OK static expression case, check range and set appropriate type\n \n@@ -6188,8 +6184,6 @@ package body Sem_Attr is\n                Set_Etype (E1, Standard_Unsigned_64);\n             end if;\n          end if;\n-\n-         Set_Is_Static_Expression (N, True);\n       end To_Address;\n \n       ------------\n@@ -7202,7 +7196,7 @@ package body Sem_Attr is\n       P_Root_Type : Entity_Id;\n       --  The root type of the prefix type\n \n-      Static : Boolean;\n+      Static : Boolean := False;\n       --  True if the result is Static. This is set by the general processing\n       --  to true if the prefix is static, and all expressions are static. It\n       --  can be reset as processing continues for particular attributes. This\n@@ -7563,10 +7557,16 @@ package body Sem_Attr is\n    --  Start of processing for Eval_Attribute\n \n    begin\n+      --  The To_Address attribute can be static, but it cannot be evaluated at\n+      --  compile time, so just return.\n+\n+      if Id = Attribute_To_Address then\n+         return;\n+      end if;\n+\n       --  Initialize result as non-static, will be reset if appropriate\n \n       Set_Is_Static_Expression (N, False);\n-      Static := False;\n \n       --  Acquire first two expressions (at the moment, no attributes take more\n       --  than two expressions in any case).\n@@ -8283,8 +8283,8 @@ package body Sem_Attr is\n          --  static attribute in GNAT.\n \n          Analyze_And_Resolve (N, Standard_Boolean);\n-            Static := True;\n-            Set_Is_Static_Expression (N, True);\n+         Static := True;\n+         Set_Is_Static_Expression (N, True);\n       end Atomic_Always_Lock_Free;\n \n       ---------\n@@ -8346,7 +8346,6 @@ package body Sem_Attr is\n          --  attribute reference, and this reference is not static.\n \n          Set_Is_Static_Expression (N, False);\n-         null;\n \n       ---------------\n       -- Copy_Sign --\n@@ -8737,8 +8736,8 @@ package body Sem_Attr is\n          --  static attribute in GNAT.\n \n          Analyze_And_Resolve (N, Standard_Boolean);\n-            Static := True;\n-            Set_Is_Static_Expression (N, True);\n+         Static := True;\n+         Set_Is_Static_Expression (N, True);\n       end Lock_Free;\n \n       ----------"}, {"sha": "ec98a3af8d2bd462841453b438f8d1e088ac03d1", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "patch": "@@ -66,33 +66,25 @@ package body Sem_Eval is\n    --  a subexpression is resolved and is therefore accomplished in a bottom\n    --  up fashion. The flags are synthesized using the following approach.\n \n-   --    Is_Static_Expression is determined by following the detailed rules\n-   --    in RM 4.9(4-14). This involves testing the Is_Static_Expression\n-   --    flag of the operands in many cases.\n-\n-   --    Raises_Constraint_Error is set if any of the operands have the flag\n-   --    set or if an attempt to compute the value of the current expression\n-   --    results in detection of a runtime constraint error.\n-\n-   --  As described in the spec, the requirement is that Is_Static_Expression\n-   --  be accurately set, and in addition for nodes for which this flag is set,\n-   --  Raises_Constraint_Error must also be set. Furthermore a node which has\n-   --  Is_Static_Expression set, and Raises_Constraint_Error clear, then the\n-   --  requirement is that the expression value must be precomputed, and the\n-   --  node is either a literal, or the name of a constant entity whose value\n-   --  is a static expression.\n+   --    Is_Static_Expression is determined by following the rules in\n+   --    RM-4.9. This involves testing the Is_Static_Expression flag of\n+   --    the operands in many cases.\n+\n+   --    Raises_Constraint_Error is usually set if any of the operands have\n+   --    the flag set or if an attempt to compute the value of the current\n+   --    expression results in Constraint_Error.\n \n    --  The general approach is as follows. First compute Is_Static_Expression.\n    --  If the node is not static, then the flag is left off in the node and\n    --  we are all done. Otherwise for a static node, we test if any of the\n-   --  operands will raise constraint error, and if so, propagate the flag\n+   --  operands will raise Constraint_Error, and if so, propagate the flag\n    --  Raises_Constraint_Error to the result node and we are done (since the\n    --  error was already posted at a lower level).\n \n    --  For the case of a static node whose operands do not raise constraint\n    --  error, we attempt to evaluate the node. If this evaluation succeeds,\n    --  then the node is replaced by the result of this computation. If the\n-   --  evaluation raises constraint error, then we rewrite the node with\n+   --  evaluation raises Constraint_Error, then we rewrite the node with\n    --  Apply_Compile_Time_Constraint_Error to raise the exception and also\n    --  to post appropriate error messages.\n \n@@ -108,7 +100,7 @@ package body Sem_Eval is\n    --  discrete types (the most common case), and is populated by calls to\n    --  Compile_Time_Known_Value and Expr_Value, but only used by Expr_Value\n    --  since it is possible for the status to change (in particular it is\n-   --  possible for a node to get replaced by a constraint error node).\n+   --  possible for a node to get replaced by a Constraint_Error node).\n \n    CV_Bits : constant := 5;\n    --  Number of low order bits of Node_Id value used to reference entries\n@@ -295,8 +287,8 @@ package body Sem_Eval is\n    --    If either operand is Any_Type then propagate it to result to prevent\n    --    cascaded errors.\n    --\n-   --    If some operand raises constraint error, then replace the node N\n-   --    with the raise constraint error node. This replacement inherits the\n+   --    If some operand raises Constraint_Error, then replace the node N\n+   --    with the raise Constraint_Error node. This replacement inherits the\n    --    Is_Static_Expression flag from the operands.\n \n    procedure Test_Expression_Is_Foldable\n@@ -1129,7 +1121,7 @@ package body Sem_Eval is\n          return Unknown;\n       end if;\n \n-      --  If either operand could raise constraint error, then we cannot\n+      --  If either operand could raise Constraint_Error, then we cannot\n       --  know the result at compile time (since CE may be raised).\n \n       if not (Cannot_Raise_Constraint_Error (L)\n@@ -1696,7 +1688,7 @@ package body Sem_Eval is\n       CV_Ent : CV_Entry renames CV_Cache (Nat (Op) mod CV_Cache_Size);\n \n    begin\n-      --  Never known at compile time if bad type or raises constraint error\n+      --  Never known at compile time if bad type or raises Constraint_Error\n       --  or empty (latter case occurs only as a result of a previous error).\n \n       if No (Op) then\n@@ -2201,7 +2193,7 @@ package body Sem_Eval is\n       end if;\n \n       --  First loop, make sure all the alternatives are static expressions\n-      --  none of which raise Constraint_Error. We make the constraint error\n+      --  none of which raise Constraint_Error. We make the Constraint_Error\n       --  check because part of the legality condition for a correct static\n       --  case expression is that the cases are covered, like any other case\n       --  expression. And we can't do that if any of the conditions raise an\n@@ -2237,7 +2229,7 @@ package body Sem_Eval is\n \n       Set_Is_Static_Expression (N);\n \n-      --  Now to deal with propagating a possible constraint error\n+      --  Now to deal with propagating a possible Constraint_Error\n \n       --  If the selecting expression raises CE, propagate and we are done\n \n@@ -2408,7 +2400,7 @@ package body Sem_Eval is\n \n    begin\n       --  Enumeration literals are always considered to be constants\n-      --  and cannot raise constraint error (RM 4.9(22)).\n+      --  and cannot raise Constraint_Error (RM 4.9(22)).\n \n       if Ekind (Def_Id) = E_Enumeration_Literal then\n          Set_Is_Static_Expression (N);\n@@ -2506,7 +2498,7 @@ package body Sem_Eval is\n          return;\n       end if;\n \n-      --  If condition raises constraint error then we have already signaled\n+      --  If condition raises Constraint_Error then we have already signaled\n       --  an error, and we just propagate to the result and do not fold.\n \n       if Raises_Constraint_Error (Condition) then\n@@ -2531,8 +2523,8 @@ package body Sem_Eval is\n       end if;\n \n       --  Note that it does not matter if the non-result operand raises a\n-      --  Constraint_Error, but if the result raises constraint error then we\n-      --  replace the node with a raise constraint error. This will properly\n+      --  Constraint_Error, but if the result raises Constraint_Error then we\n+      --  replace the node with a raise Constraint_Error. This will properly\n       --  propagate Raises_Constraint_Error since this flag is set in Result.\n \n       if Raises_Constraint_Error (Result) then\n@@ -2884,7 +2876,7 @@ package body Sem_Eval is\n \n       Set_Is_Static_Expression (N);\n \n-      --  If left operand raises constraint error, propagate and we are done\n+      --  If left operand raises Constraint_Error, propagate and we are done\n \n       if Raises_Constraint_Error (Expr) then\n          Set_Raises_Constraint_Error (N, True);\n@@ -3117,7 +3109,7 @@ package body Sem_Eval is\n       if not Fold then\n          return;\n \n-      --  Don't try fold if target type has constraint error bounds\n+      --  Don't try fold if target type has Constraint_Error bounds\n \n       elsif not Is_OK_Static_Subtype (Target_Type) then\n          Set_Raises_Constraint_Error (N);\n@@ -3645,7 +3637,7 @@ package body Sem_Eval is\n       --  Now look at the operands, we can't quite use the normal call to\n       --  Test_Expression_Is_Foldable here because short circuit operations\n       --  are a special case, they can still be foldable, even if the right\n-      --  operand raises constraint error.\n+      --  operand raises Constraint_Error.\n \n       --  If either operand is Any_Type, just propagate to result and do not\n       --  try to fold, this prevents cascaded errors.\n@@ -3654,8 +3646,8 @@ package body Sem_Eval is\n          Set_Etype (N, Any_Type);\n          return;\n \n-      --  If left operand raises constraint error, then replace node N with\n-      --  the raise constraint error node, and we are obviously not foldable.\n+      --  If left operand raises Constraint_Error, then replace node N with\n+      --  the raise Constraint_Error node, and we are obviously not foldable.\n       --  Is_Static_Expression is set from the two operands in the normal way,\n       --  and we check the right operand if it is in a non-static context.\n \n@@ -3678,12 +3670,12 @@ package body Sem_Eval is\n \n       --  Here the result is static, note that, unlike the normal processing\n       --  in Test_Expression_Is_Foldable, we did *not* check above to see if\n-      --  the right operand raises constraint error, that's because it is not\n+      --  the right operand raises Constraint_Error, that's because it is not\n       --  significant if the left operand is decisive.\n \n       Set_Is_Static_Expression (N);\n \n-      --  It does not matter if the right operand raises constraint error if\n+      --  It does not matter if the right operand raises Constraint_Error if\n       --  it will not be evaluated. So deal specially with the cases where\n       --  the right operand is not evaluated. Note that we will fold these\n       --  cases even if the right operand is non-static, which is fine, but\n@@ -3700,7 +3692,7 @@ package body Sem_Eval is\n       end if;\n \n       --  If first operand not decisive, then it does matter if the right\n-      --  operand raises constraint error, since it will be evaluated, so\n+      --  operand raises Constraint_Error, since it will be evaluated, so\n       --  we simply replace the node with the right operand. Note that this\n       --  properly propagates Is_Static_Expression and Raises_Constraint_Error\n       --  (both are set to True in Right).\n@@ -3951,7 +3943,7 @@ package body Sem_Eval is\n       if not Fold then\n          return;\n \n-      --  Don't try fold if target type has constraint error bounds\n+      --  Don't try fold if target type has Constraint_Error bounds\n \n       elsif not Is_OK_Static_Subtype (Target_Type) then\n          Set_Raises_Constraint_Error (N);\n@@ -4915,7 +4907,7 @@ package body Sem_Eval is\n    --------------------------\n \n    --  Determines if Typ is a static subtype as defined in (RM 4.9(26)) where\n-   --  neither bound raises constraint error when evaluated.\n+   --  neither bound raises Constraint_Error when evaluated.\n \n    function Is_OK_Static_Subtype (Typ : Entity_Id) return Boolean is\n       Base_T   : constant Entity_Id := Base_Type (Typ);\n@@ -6044,7 +6036,7 @@ package body Sem_Eval is\n                      then\n                         return False;\n \n-                        --  If either expression raised a constraint error,\n+                        --  If either expression raised a Constraint_Error,\n                         --  consider the expressions as matching, since this\n                         --  helps to prevent cascading errors.\n \n@@ -6255,8 +6247,8 @@ package body Sem_Eval is\n          Set_Etype (N, Any_Type);\n          return;\n \n-      --  If operand raises constraint error, then replace node N with the\n-      --  raise constraint error node, and we are obviously not foldable.\n+      --  If operand raises Constraint_Error, then replace node N with the\n+      --  raise Constraint_Error node, and we are obviously not foldable.\n       --  Note that this replacement inherits the Is_Static_Expression flag\n       --  from the operand.\n \n@@ -6283,7 +6275,7 @@ package body Sem_Eval is\n          return;\n \n       --  Here we have the case of an operand whose type is OK, which is\n-      --  static, and which does not raise constraint error, we can fold.\n+      --  static, and which does not raise Constraint_Error, we can fold.\n \n       else\n          Set_Is_Static_Expression (N);\n@@ -6323,7 +6315,7 @@ package body Sem_Eval is\n          Set_Etype (N, Any_Type);\n          return;\n \n-      --  If left operand raises constraint error, then replace node N with the\n+      --  If left operand raises Constraint_Error, then replace node N with the\n       --  Raise_Constraint_Error node, and we are obviously not foldable.\n       --  Is_Static_Expression is set from the two operands in the normal way,\n       --  and we check the right operand if it is in a non-static context.\n@@ -6376,7 +6368,7 @@ package body Sem_Eval is\n          return;\n \n       --  Else result is static and foldable. Both operands are static, and\n-      --  neither raises constraint error, so we can definitely fold.\n+      --  neither raises Constraint_Error, so we can definitely fold.\n \n       else\n          Set_Is_Static_Expression (N);\n@@ -6413,7 +6405,7 @@ package body Sem_Eval is\n       if Error_Posted (N) then\n          return Unknown;\n \n-      --  Expression that raises constraint error is an odd case. We certainly\n+      --  Expression that raises Constraint_Error is an odd case. We certainly\n       --  do not want to consider it to be in range. It might make sense to\n       --  consider it always out of range, but this causes incorrect error\n       --  messages about static expressions out of range. So we just return\n@@ -6601,7 +6593,7 @@ package body Sem_Eval is\n             return;\n          end if;\n \n-         --  Test for constraint error raised\n+         --  Test for Constraint_Error raised\n \n          if Raises_Constraint_Error (Expr) then\n "}, {"sha": "3c71a57fb9fb2b82169c9c088e73135cc585e639", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "patch": "@@ -51,13 +51,7 @@ package Sem_Eval is\n \n    --    Is_Static_Expression\n \n-   --      This flag is set on any expression that is static according to the\n-   --      rules in (RM 4.9(3-32)). This flag should be tested during testing\n-   --      of legality of parts of a larger static expression. For all other\n-   --      contexts that require static expressions, use the separate predicate\n-   --      Is_OK_Static_Expression, since an expression that meets the RM 4.9\n-   --      requirements, but raises a constraint error when evaluated in a non-\n-   --      static context does not meet the legality requirements.\n+   --      True for static expressions, as defined in RM-4.9.\n \n    --    Raises_Constraint_Error\n \n@@ -68,31 +62,28 @@ package Sem_Eval is\n    --      (i.e. the flag is accurate for static expressions, and conservative\n    --      for non-static expressions.\n \n-   --  If a static expression does not raise constraint error, then it will\n-   --  have the flag Raises_Constraint_Error flag False, and the expression\n-   --  must be computed at compile time, which means that it has the form of\n-   --  either a literal, or a constant that is itself (recursively) either a\n-   --  literal or a constant.\n+   --  See also Is_OK_Static_Expression, which is True for static\n+   --  expressions that do not raise Constraint_Error. This is used in most\n+   --  legality checks, because static expressions that raise Constraint_Error\n+   --  are usually illegal.\n \n-   --  The above rules must be followed exactly in order for legality checks to\n-   --  be accurate. For subexpressions that are not static according to the RM\n-   --  definition, they are sometimes folded anyway, but of course in this case\n-   --  Is_Static_Expression is not set.\n+   --  See also Compile_Time_Known_Value, which is True for an expression whose\n+   --  value is known at compile time. In this case, the expression is folded\n+   --  to a literal or to a constant that is itself (recursively) either a\n+   --  literal or a constant\n+\n+   --  Is_[OK_]Static_Expression are used for legality checks, whereas\n+   --  Compile_Time_Known_Value is used for optimization purposes.\n \n    --  When we are analyzing and evaluating static expressions, we propagate\n-   --  both flags accurately. Usually if a subexpression raises a constraint\n-   --  error, then so will its parent expression, and Raise_Constraint_Error\n-   --  will be propagated to this parent. The exception is conditional cases\n-   --  like (True or else 1/0 = 0) which results in an expresion that has the\n+   --  both flags. Usually if a subexpression raises a Constraint_Error, then\n+   --  so will its parent expression, and Raise_Constraint_Error will be\n+   --  propagated to this parent. The exception is conditional cases like\n+   --  (True or else 1/0 = 0), which results in an expression that has the\n    --  Is_Static_Expression flag True, and Raises_Constraint_Error False. Even\n    --  though 1/0 would raise an exception, the right operand is never actually\n    --  executed, so the expression as a whole does not raise CE.\n \n-   --  For constructs in the language where static expressions are part of the\n-   --  required semantics, we need an expression that meets the 4.9 rules and\n-   --  does not raise CE. So nearly everywhere, callers should call function\n-   --  Is_OK_Static_Expression rather than Is_Static_Expression.\n-\n    --  Finally, the case of static predicates. These are applied only to entire\n    --  expressions, not to subexpressions, so we do not have the case of having\n    --  to propagate this information. We handle this case simply by resetting"}, {"sha": "efba51b3cfc2572e159cb76d99c3bdd52e654ed8", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c434fa08b0ee0e4f9b5ce803e282d8832a559/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=1e3c434fa08b0ee0e4f9b5ce803e282d8832a559", "patch": "@@ -1966,12 +1966,7 @@ package Sinfo is\n \n    --  Is_Static_Expression (Flag6-Sem)\n    --    Indicates that an expression is a static expression according to the\n-   --    rules in (RM 4.9). Note that it is possible for this flag to be set\n-   --    when Raises_Constraint_Error is also set. In practice almost all cases\n-   --    where a static expression is required do not allow an expression which\n-   --    raises Constraint_Error, so almost always, callers should call the\n-   --    Is_Ok_Static_Expression routine instead of testing this flag. See\n-   --    spec of package Sem_Eval for full details on the use of this flag.\n+   --    rules in RM-4.9. See Sem_Eval for details.\n \n    --  Is_Subprogram_Descriptor (Flag16-Sem)\n    --    Present in N_Object_Declaration, and set only for the object\n@@ -2297,15 +2292,7 @@ package Sinfo is\n \n    --  Raises_Constraint_Error (Flag7-Sem)\n    --    Set on an expression whose evaluation will definitely fail constraint\n-   --    error check. In the case of static expressions, this flag must be set\n-   --    accurately (and if it is set, the expression is typically illegal\n-   --    unless it appears as a non-elaborated branch of a short-circuit form).\n-   --    For a non-static expression, this flag may be set whenever an\n-   --    expression (e.g. an aggregate) is known to raise constraint error. If\n-   --    set, the expression definitely will raise CE if elaborated at runtime.\n-   --    If not set, the expression may or may not raise CE. In other words, on\n-   --    static expressions, the flag is set accurately, on non-static\n-   --    expressions it is set conservatively.\n+   --    error check. See Sem_Eval for details.\n \n    --  Redundant_Use (Flag13-Sem)\n    --    Present in nodes that can appear as an operand in a use clause or use"}]}