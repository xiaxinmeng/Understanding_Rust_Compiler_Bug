{"sha": "00a17e31a624e135eb6807c6ef5cf150018593ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBhMTdlMzFhNjI0ZTEzNWViNjgwN2M2ZWY1Y2YxNTAwMTg1OTNlZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-13T00:22:59Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-13T00:22:59Z"}, "message": "call.c: Fix comment formatting.\n\n\t* call.c: Fix comment formatting.\n\t* class.c: Likewise.\n\t* cp-lang.c: Likewise.\n\t* cp-tree.h: Likewise.\n\t* cvt.c: Likewise.\n\nFrom-SVN: r57083", "tree": {"sha": "fc3eb95e9abe520b88a499541198f53a22ea8a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc3eb95e9abe520b88a499541198f53a22ea8a0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00a17e31a624e135eb6807c6ef5cf150018593ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00a17e31a624e135eb6807c6ef5cf150018593ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00a17e31a624e135eb6807c6ef5cf150018593ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00a17e31a624e135eb6807c6ef5cf150018593ef/comments", "author": null, "committer": null, "parents": [{"sha": "714e9334c4d48635ed65ae7cad428b6ee2afe739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714e9334c4d48635ed65ae7cad428b6ee2afe739", "html_url": "https://github.com/Rust-GCC/gccrs/commit/714e9334c4d48635ed65ae7cad428b6ee2afe739"}], "stats": {"total": 142, "additions": 75, "deletions": 67}, "files": [{"sha": "9fc71cc7ef3d9696d1656b8e9172ce0bfbbdc7dd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=00a17e31a624e135eb6807c6ef5cf150018593ef", "patch": "@@ -1,3 +1,11 @@\n+2002-09-12  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* call.c: Fix comment formatting.\n+\t* class.c: Likewise.\n+\t* cp-lang.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\n 2002-09-11  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Make-lang.in: Build cp/cxxfilt.o from $(srcdir)/cp/cxxfilt.c,"}, {"sha": "0715f2f1333cae5107b0c3abe4766f9fe9346aba", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=00a17e31a624e135eb6807c6ef5cf150018593ef", "patch": "@@ -648,7 +648,7 @@ null_ptr_cst_p (t)\n \n \n /* Returns non-zero if PARMLIST consists of only default parms and/or\n-   ellipsis. */\n+   ellipsis.  */\n \n int\n sufficient_parms_p (parmlist)\n@@ -2764,7 +2764,7 @@ build_new_function_call (fn, args)\n       return build_over_call (cand, args, LOOKUP_NORMAL);\n     }\n \n-  /* This is not really overloaded. */\n+  /* This is not really overloaded.  */\n   fn = OVL_CURRENT (fn);\n \n   return build_function_call (fn, args);\n@@ -3053,7 +3053,7 @@ build_conditional_expr (arg1, arg2, arg3)\n \t   type of the other and is an rvalue.\n \n \t --Both the second and the third operands have type void; the\n-\t   result is of type void and is an rvalue.   */\n+\t   result is of type void and is an rvalue.  */\n       if ((TREE_CODE (arg2) == THROW_EXPR)\n \t  ^ (TREE_CODE (arg3) == THROW_EXPR))\n \tresult_type = ((TREE_CODE (arg2) == THROW_EXPR) \n@@ -3275,7 +3275,7 @@ build_conditional_expr (arg1, arg2, arg3)\n        qualification conversions (_conv.qual_) are performed to bring\n        them to a common type, whose cv-qualification shall match the\n        cv-qualification of either the second or the third operand.\n-       The result is of the common type.   */\n+       The result is of the common type.  */\n   else if ((null_ptr_cst_p (arg2) \n \t    && (TYPE_PTR_P (arg3_type) || TYPE_PTRMEM_P (arg3_type)\n \t\t|| TYPE_PTRMEMFUNC_P (arg3_type)))\n@@ -3360,7 +3360,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     case VEC_NEW_EXPR:\n     case VEC_DELETE_EXPR:\n     case DELETE_EXPR:\n-      /* Use build_op_new_call and build_op_delete_call instead. */\n+      /* Use build_op_new_call and build_op_delete_call instead.  */\n       abort ();\n \n     case CALL_EXPR:\n@@ -3458,7 +3458,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n-\t      /* A member template. */\n+\t      /* A member template.  */\n \t      templates = tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, \n@@ -3752,10 +3752,10 @@ build_op_delete_call (code, addr, size, flags, placement)\n       tree alloc_fn;\n       tree call_expr;\n \n-      /* Find the allocation function that is being called. */\n+      /* Find the allocation function that is being called.  */\n       call_expr = placement;\n       /* Sometimes we have a COMPOUND_EXPR, rather than a simple\n-\t CALL_EXPR. */\n+\t CALL_EXPR.  */\n       while (TREE_CODE (call_expr) == COMPOUND_EXPR)\n \tcall_expr = TREE_OPERAND (call_expr, 1);\n       /* Extract the function.  */\n@@ -3876,7 +3876,7 @@ enforce_access (basetype_path, decl)\n    FN and ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n    indicates the `this' argument of a method.  INNER is non-zero when\n    being called to continue a conversion chain. It is negative when a\n-   reference binding will be applied, positive otherwise. */\n+   reference binding will be applied, positive otherwise.  */\n \n static tree\n convert_like_real (convs, expr, fn, argnum, inner)\n@@ -4553,11 +4553,11 @@ build_java_interface_fn_ref (fn, instance)\n     }\n \n   /* Look up the pointer to the runtime java.lang.Class object for `instance'. \n-     This is the first entry in the vtable. */\n+     This is the first entry in the vtable.  */\n   klass_ref = build_vtbl_ref (build_indirect_ref (instance, 0), \n \t\t\t      integer_zero_node);\n \n-  /* Get the java.lang.Class pointer for the interface being called. */\n+  /* Get the java.lang.Class pointer for the interface being called.  */\n   iface = DECL_CONTEXT (fn);\n   iface_ref = lookup_field (iface, get_identifier (\"class$\"), 0, 0);\n   if (!iface_ref || TREE_CODE (iface_ref) != VAR_DECL\n@@ -4569,7 +4569,7 @@ build_java_interface_fn_ref (fn, instance)\n     }\n   iface_ref = build1 (ADDR_EXPR, build_pointer_type (iface), iface_ref);\n   \n-  /* Determine the itable index of FN. */\n+  /* Determine the itable index of FN.  */\n   i = 1;\n   for (method = TYPE_METHODS (iface); method; method = TREE_CHAIN (method))\n     {\n@@ -4814,7 +4814,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n-\t      /* A member template. */\n+\t      /* A member template.  */\n \t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = \n \t\tadd_template_candidate (candidates, t, "}, {"sha": "48dadea487c4fdd736a5bbdd8e30a28d283613d7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=00a17e31a624e135eb6807c6ef5cf150018593ef", "patch": "@@ -828,7 +828,7 @@ add_method (type, method, error_p)\n \t\t\t\t       && DECL_TEMPLATE_CONV_FN_P (m));\n \t      \n \t      /* If we need to move things up, see if there's\n-\t\t space. */\n+\t\t space.  */\n \t      if (!have_template_convs_p)\n \t\t{\n \t\t  slot = len - 1;\n@@ -1181,7 +1181,7 @@ handle_using_decl (using_decl, t)\n     }\n \n   if (BASELINK_P (fdecl))\n-    /* Ignore base type this came from. */\n+    /* Ignore base type this came from.  */\n     fdecl = BASELINK_FUNCTIONS (fdecl);\n \n   old_value = IDENTIFIER_CLASS_VALUE (name);\n@@ -1314,7 +1314,7 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n \t}\n \n       if (TREE_VIA_VIRTUAL (base_binfo))\n-\t/* A virtual base does not effect nearly emptiness. */\n+\t/* A virtual base does not effect nearly emptiness.  */\n \t;\n       else if (CLASSTYPE_NEARLY_EMPTY_P (basetype))\n \t{\n@@ -1323,7 +1323,7 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n \t       derived class is not nearly empty either.  */\n \t    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n \t  else\n-\t    /* Remember we've seen one. */\n+\t    /* Remember we've seen one.  */\n \t    seen_non_virtual_nearly_empty_base_p = 1;\n \t}\n       else if (!is_empty_class (basetype))\n@@ -1470,7 +1470,7 @@ mark_primary_virtual_base (base_binfo, type)\n \n /* If BINFO is an unmarked virtual binfo for a class with a primary virtual\n    base, then BINFO has no primary base in this graph.  Called from\n-   mark_primary_bases.  DATA is the most derived type. */\n+   mark_primary_bases.  DATA is the most derived type.  */\n \n static tree dfs_unshared_virtual_bases (binfo, data)\n      tree binfo;\n@@ -1503,11 +1503,11 @@ static tree dfs_unshared_virtual_bases (binfo, data)\n   if (binfo != TYPE_BINFO (t))\n     /* The vtable fields will have been copied when duplicating the\n        base binfos. That information is bogus, make sure we don't try\n-       and use it. */\n+       and use it.  */\n     BINFO_VTABLE (binfo) = NULL_TREE;\n \n   /* If this is a virtual primary base, make sure its offset matches\n-     that which it is primary for. */\n+     that which it is primary for.  */\n   if (BINFO_PRIMARY_P (binfo) && TREE_VIA_VIRTUAL (binfo) &&\n       binfo_for_vbase (BINFO_TYPE (binfo), t) == binfo)\n     {\n@@ -1536,7 +1536,7 @@ mark_primary_bases (type)\n       tree base_binfo;\n       \n       if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n-        /* Not a dynamic base. */\n+        /* Not a dynamic base.  */\n         continue;\n \n       base_binfo = get_primary_binfo (binfo);\n@@ -2253,7 +2253,7 @@ dfs_find_final_overrider (binfo, data)\n \t  /* Assume the path is non-virtual.  See if there are any\n \t     virtual bases from (but not including) the overrider up\n \t     to and including the base where the function is\n-\t     defined. */\n+\t     defined.  */\n \t  for (base = TREE_CHAIN (path); base; base = TREE_CHAIN (base))\n \t    if (TREE_VIA_VIRTUAL (TREE_VALUE (base)))\n \t      {\n@@ -2756,11 +2756,11 @@ warn_hidden (t)\n \t\t\t\t  base_fndecls);\n \t}\n \n-      /* If there are no functions to hide, continue. */\n+      /* If there are no functions to hide, continue.  */\n       if (!base_fndecls)\n \tcontinue;\n \n-      /* Remove any overridden functions. */\n+      /* Remove any overridden functions.  */\n       for (fns = TREE_VEC_ELT (method_vec, i); fns; fns = OVL_NEXT (fns))\n \t{\n \t  fndecl = OVL_CURRENT (fns);\n@@ -3708,7 +3708,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets, t)\n    past the end of the class, and should be correctly aligned for a\n    class of the type indicated by BINFO; OFFSETS gives the offsets of\n    the empty bases allocated so far. T is the most derived\n-   type.  Return non-zero iff we added it at the end. */\n+   type.  Return non-zero iff we added it at the end.  */\n \n static bool\n layout_empty_base (binfo, eoc, offsets, t)\n@@ -3757,7 +3757,7 @@ layout_empty_base (binfo, eoc, offsets, t)\n    *BASE_ALIGN is a running maximum of the alignments of any base\n    class.  OFFSETS gives the location of empty base subobjects.  T is\n    the most derived type.  Return non-zero if the new object cannot be\n-   nearly-empty. */\n+   nearly-empty.  */\n \n static bool\n build_base_field (rli, binfo, empty_p, offsets, t)\n@@ -4080,7 +4080,7 @@ clone_function_decl (fn, update_method_vec_p)\n    declared. An out-of-class definition can specify additional default\n    arguments. As it is the clones that are involved in overload\n    resolution, we must propagate the information from the DECL to its\n-   clones. */\n+   clones.  */\n \n void\n adjust_clone_args (decl)\n@@ -4097,7 +4097,7 @@ adjust_clone_args (decl)\n \n       clone_parms = orig_clone_parms;\n       \n-      /* Skip the 'this' parameter. */\n+      /* Skip the 'this' parameter.  */\n       orig_clone_parms = TREE_CHAIN (orig_clone_parms);\n       orig_decl_parms = TREE_CHAIN (orig_decl_parms);\n \n@@ -4120,7 +4120,7 @@ adjust_clone_args (decl)\n \t  if (TREE_PURPOSE (decl_parms) && !TREE_PURPOSE (clone_parms))\n \t    {\n \t      /* A default parameter has been added. Adjust the\n-\t\t clone's parameters. */\n+\t\t clone's parameters.  */\n \t      tree exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (clone));\n \t      tree basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (clone));\n \t      tree type;\n@@ -4274,7 +4274,7 @@ check_bases_and_members (t, empty_p)\n      it turns out not to be nearly empty.  */\n   CLASSTYPE_NEARLY_EMPTY_P (t) = 1;\n \n-  /* Check all the base-classes. */\n+  /* Check all the base-classes.  */\n   check_bases (t, &cant_have_default_ctor, &cant_have_const_ctor,\n \t       &no_const_asn_ref);\n \n@@ -4779,7 +4779,7 @@ splay_tree_compare_integer_csts (k1, k2)\n \n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n    BINFO_OFFSETs for all of the base-classes.  Position the vtable\n-   pointer.  Accumulate declared virtual functions on VIRTUALS_P. */\n+   pointer.  Accumulate declared virtual functions on VIRTUALS_P.  */\n \n static void\n layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n@@ -5031,7 +5031,7 @@ finish_struct_1 (t)\n {\n   tree x;\n   int vfuns;\n-  /* A TREE_LIST.  The TREE_VALUE of each node is a FUNCTION_DECL. */\n+  /* A TREE_LIST.  The TREE_VALUE of each node is a FUNCTION_DECL.  */\n   tree virtuals = NULL_TREE;\n   int n_fields = 0;\n   tree vfield;\n@@ -5073,7 +5073,7 @@ finish_struct_1 (t)\n       my_friendly_assert (same_type_p (DECL_FIELD_CONTEXT (vfield),\n \t\t\t\t       BINFO_TYPE (primary)),\n \t\t\t  20010726);\n-      /* The vtable better be at the start. */\n+      /* The vtable better be at the start.  */\n       my_friendly_assert (integer_zerop (DECL_FIELD_OFFSET (vfield)),\n \t\t\t  20010726);\n       my_friendly_assert (integer_zerop (BINFO_OFFSET (primary)),\n@@ -5372,7 +5372,7 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n           if (nonnull)\n             *nonnull = 1;\n         \n-          /* if we're in a ctor or dtor, we know our type. */\n+          /* if we're in a ctor or dtor, we know our type.  */\n           if (DECL_LANG_SPECIFIC (current_function_decl)\n               && (DECL_CONSTRUCTOR_P (current_function_decl)\n                   || DECL_DESTRUCTOR_P (current_function_decl)))\n@@ -5714,7 +5714,7 @@ push_lang_context (name)\n       /* DECL_IGNORED_P is initially set for these types, to avoid clutter.\n \t (See record_builtin_java_type in decl.c.)  However, that causes\n \t incorrect debug entries if these types are actually used.\n-\t So we re-enable debug output after extern \"Java\". */\n+\t So we re-enable debug output after extern \"Java\".  */\n       DECL_IGNORED_P (TYPE_NAME (java_byte_type_node)) = 0;\n       DECL_IGNORED_P (TYPE_NAME (java_short_type_node)) = 0;\n       DECL_IGNORED_P (TYPE_NAME (java_int_type_node)) = 0;\n@@ -6138,7 +6138,7 @@ instantiate_type (lhstype, rhs, flags)\n \t\t\t\t\t\t/*explicit_targs=*/NULL_TREE);\n \n     case TREE_LIST:\n-      /* Now we should have a baselink. */\n+      /* Now we should have a baselink.  */\n       my_friendly_assert (BASELINK_P (rhs), 990412);\n \n       return instantiate_type (lhstype, BASELINK_FUNCTIONS (rhs), flags);\n@@ -6480,7 +6480,7 @@ get_vtbl_decl_for_binfo (binfo)\n \n /* Called from get_primary_binfo via dfs_walk.  DATA is a TREE_LIST\n    who's TREE_PURPOSE is the TYPE of the required primary base and\n-   who's TREE_VALUE is a list of candidate binfos that we fill in. */\n+   who's TREE_VALUE is a list of candidate binfos that we fill in.  */\n \n static tree\n dfs_get_primary_binfo (binfo, data)\n@@ -6587,7 +6587,7 @@ get_primary_binfo (binfo)\n   return result;\n }\n \n-/* If INDENTED_P is zero, indent to INDENT. Return non-zero. */\n+/* If INDENTED_P is zero, indent to INDENT. Return non-zero.  */\n \n static int\n maybe_indent_hierarchy (stream, indent, indented_p)\n@@ -6954,7 +6954,7 @@ get_original_base (base_binfo, binfo)\n /* When building a secondary VTT, BINFO_VTABLE is set to a TREE_LIST with\n    PURPOSE the RTTI_BINFO, VALUE the real vtable pointer for this binfo,\n    and CHAIN the vtable pointer for this binfo after construction is\n-   complete.  VALUE can also be another BINFO, in which case we recurse. */\n+   complete.  VALUE can also be another BINFO, in which case we recurse.  */\n \n static tree\n binfo_ctor_vtable (binfo)\n@@ -7145,7 +7145,7 @@ dfs_build_secondary_vptr_vtt_inits (binfo, data)\n     {\n       /* It's a primary virtual base, and this is not the construction\n          vtable. Find the base this is primary of in the inheritance graph,\n-         and use that base's vtable now. */\n+         and use that base's vtable now.  */\n       while (BINFO_PRIMARY_BASE_OF (binfo))\n         binfo = BINFO_PRIMARY_BASE_OF (binfo);\n     }\n@@ -7284,7 +7284,7 @@ accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n \t\t\t\t   BINFO_TYPE (orig_binfo)),\n \t\t      20000517);\n \n-  /* If it doesn't have a vptr, we don't do anything. */\n+  /* If it doesn't have a vptr, we don't do anything.  */\n   if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n     return;\n   "}, {"sha": "51239a5d1e0e651c53f85e82ddf43bf46de49ae0", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=00a17e31a624e135eb6807c6ef5cf150018593ef", "patch": "@@ -157,7 +157,7 @@ static tree cp_expr_size PARAMS ((tree));\n /* Each front end provides its own hooks, for toplev.c.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n-/* Tree code classes. */\n+/* Tree code classes.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n "}, {"sha": "8dd6b9c6af49f7534f6634125af039e22c2cfa0c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=00a17e31a624e135eb6807c6ef5cf150018593ef", "patch": "@@ -153,7 +153,7 @@ struct diagnostic_context;\n      the virtual function this one overrides, and whose TREE_CHAIN is\n      the old DECL_VINDEX.  */\n \n-/* Language-specific tree checkers. */\n+/* Language-specific tree checkers.  */\n \n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n@@ -340,18 +340,18 @@ struct tree_binding GTY(())\n   tree value;\n };\n \n-/* The overloaded FUNCTION_DECL. */\n+/* The overloaded FUNCTION_DECL.  */\n #define OVL_FUNCTION(NODE) \\\n   (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n #define OVL_CHAIN(NODE)      TREE_CHAIN (NODE)\n-/* Polymorphic access to FUNCTION and CHAIN. */\n+/* Polymorphic access to FUNCTION and CHAIN.  */\n #define OVL_CURRENT(NODE)     \\\n   ((TREE_CODE (NODE) == OVERLOAD) ? OVL_FUNCTION (NODE) : (NODE))\n #define OVL_NEXT(NODE)        \\\n   ((TREE_CODE (NODE) == OVERLOAD) ? TREE_CHAIN (NODE) : NULL_TREE)\n /* If set, this was imported in a using declaration.\n    This is not to confuse with being used somewhere, which\n-   is not important for this node. */\n+   is not important for this node.  */\n #define OVL_USED(NODE)        TREE_USED (NODE)\n \n struct tree_overload GTY(())\n@@ -435,7 +435,7 @@ struct tree_srcloc GTY(())\n /* TREE_TYPE only indicates on local and class scope the current\n    type. For namespace scope, the presence of a type in any namespace\n    is indicated with global_type_node, and the real type behind must\n-   be found through lookup. */\n+   be found through lookup.  */\n #define IDENTIFIER_TYPE_VALUE(NODE) identifier_type_value (NODE)\n #define REAL_IDENTIFIER_TYPE_VALUE(NODE) TREE_TYPE (NODE)\n #define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = (TYPE))\n@@ -708,7 +708,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n /* The node for `__null'.  */\n #define null_node                       cp_global_trees[CPTI_NULL]\n \n-/* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*). */\n+/* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*).  */\n #define jclass_node                     cp_global_trees[CPTI_JCLASS]\n \n /* The declaration for `std::terminate'.  */\n@@ -770,7 +770,7 @@ struct saved_scope GTY(())\n \n #define current_namespace scope_chain->old_namespace\n \n-/* The stack for namespaces of current declarations. */\n+/* The stack for namespaces of current declarations.  */\n \n #define decl_namespace_list scope_chain->decl_ns_list\n \n@@ -996,7 +996,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* In a *_TYPE, nonzero means a built-in type.  */\n #define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6 (NODE)\n \n-/* True if this a \"Java\" type, defined in 'extern \"Java\"'. */\n+/* True if this a \"Java\" type, defined in 'extern \"Java\"'.  */\n #define TYPE_FOR_JAVA(NODE) TYPE_LANG_FLAG_3 (NODE)\n \n /* Nonzero if this type is const-qualified.  */\n@@ -1401,7 +1401,7 @@ struct lang_type GTY(())\n   (CLASSTYPE_ALIGN (NODE) / BITS_PER_UNIT)\n \n /* True if this a Java interface type, declared with \n-   '__attribute__ ((java_interface))'. */\n+   '__attribute__ ((java_interface))'.  */\n #define TYPE_JAVA_INTERFACE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->java_interface)\n \n /* A cons list of virtual functions which cannot be inherited by\n@@ -1614,11 +1614,11 @@ struct lang_type GTY(())\n    non-NULL).  */\n #define VF_BASETYPE_VALUE(NODE) TREE_VALUE (NODE)\n \n-/* Accessor macros for the BINFO_VIRTUALS list. */\n+/* Accessor macros for the BINFO_VIRTUALS list.  */\n \n /* The number of bytes by which to adjust the `this' pointer when\n    calling this virtual function.  Subtract this value from the this\n-   pointer. Always non-NULL, might be constant zero though. */\n+   pointer. Always non-NULL, might be constant zero though.  */\n #define BV_DELTA(NODE) (TREE_PURPOSE (NODE))\n \n /* If non-NULL, the vtable index at which to find the vcall offset\n@@ -2043,7 +2043,7 @@ struct lang_decl GTY(())\n   (TREE_LANG_FLAG_0 (NODE))\n \n /* The _TYPE context in which this _DECL appears.  This field holds the\n-   class where a virtual function instance is actually defined. */\n+   class where a virtual function instance is actually defined.  */\n #define DECL_CLASS_CONTEXT(NODE) \\\n   (DECL_CLASS_SCOPE_P (NODE) ? DECL_CONTEXT (NODE) : NULL_TREE)\n \n@@ -2062,7 +2062,7 @@ struct lang_decl GTY(())\n #define SET_DECL_FRIEND_CONTEXT(NODE, CONTEXT) \\\n   (DECL_LANG_SPECIFIC (NODE)->u.f.context = (CONTEXT))\n \n-/* NULL_TREE in DECL_CONTEXT represents the global namespace. */\n+/* NULL_TREE in DECL_CONTEXT represents the global namespace.  */\n #define CP_DECL_CONTEXT(NODE) \\\n   (DECL_CONTEXT (NODE) ? DECL_CONTEXT (NODE) : global_namespace)\n #define FROB_CONTEXT(NODE)   ((NODE) == global_namespace ? NULL_TREE : (NODE))\n@@ -2092,11 +2092,11 @@ struct lang_decl GTY(())\n \n /* For a NAMESPACE_DECL: the list of using namespace directives\n    The PURPOSE is the used namespace, the value is the namespace\n-   that is the common ancestor. */\n+   that is the common ancestor.  */\n #define DECL_NAMESPACE_USING(NODE) DECL_VINDEX (NAMESPACE_DECL_CHECK (NODE))\n \n /* In a NAMESPACE_DECL, the DECL_INITIAL is used to record all users\n-   of a namespace, to record the transitive closure of using namespace. */\n+   of a namespace, to record the transitive closure of using namespace.  */\n #define DECL_NAMESPACE_USERS(NODE) DECL_INITIAL (NAMESPACE_DECL_CHECK (NODE))\n \n /* In a NAMESPACE_DECL, points to the original namespace if this is\n@@ -2137,7 +2137,7 @@ struct lang_decl GTY(())\n   (DECL_LANG_SPECIFIC (NODE)->u.f.u.pending_inline_info)\n \n /* For a TYPE_DECL: if this function has many fields, we'll sort them\n-   and put them into a TREE_VEC. */\n+   and put them into a TREE_VEC.  */\n #define DECL_SORTED_FIELDS(NODE) \\\n   (DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))->u.f.u.sorted_fields)\n \n@@ -3053,19 +3053,19 @@ typedef enum tsubst_flags_t {\n \t\t\t\t(make_typename_type use) */\n } tsubst_flags_t;\n \n-/* The kind of checking we can do looking in a class hierarchy. */\n+/* The kind of checking we can do looking in a class hierarchy.  */\n typedef enum base_access {\n   ba_any = 0,      /* Do not check access, allow an ambiguous base,\n \t\t      prefer a non-virtual base */\n   ba_ignore = 1,   /* Do not check access */\n   ba_check = 2,    /* Check access */\n   ba_not_special = 3, /* Do not consider special privilege\n-\t\t         current_class_type might give. */\n+\t\t         current_class_type might give.  */\n   ba_quiet = 4,    /* Do not issue error messages (bit mask).  */\n } base_access;\n \n /* The kind of base we can find, looking in a class hierarchy.\n-   Values <0 indicate we failed. */\n+   Values <0 indicate we failed.  */\n typedef enum base_kind {\n   bk_inaccessible = -3,   /* The base is inaccessible */\n   bk_ambig = -2,          /* The base is ambiguous */\n@@ -3074,7 +3074,7 @@ typedef enum base_kind {\n   bk_proper_base = 1,     /* It is a proper base */\n   bk_via_virtual = 2      /* It is a proper base, but via a virtual\n \t\t\t     path. This might not be the canonical\n-\t\t\t     binfo. */\n+\t\t\t     binfo.  */\n } base_kind;\n \n /* Set by add_implicitly_declared_members() to keep those members from"}, {"sha": "1585b7c7d3cd271d05d47aad1792577c48fe3f2f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00a17e31a624e135eb6807c6ef5cf150018593ef/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=00a17e31a624e135eb6807c6ef5cf150018593ef", "patch": "@@ -149,12 +149,12 @@ cp_convert_to_pointer (type, expr, force)\n \t  enum tree_code code = PLUS_EXPR;\n \t  tree binfo;\n \n-\t  /* Try derived to base conversion. */\n+\t  /* Try derived to base conversion.  */\n \t  binfo = lookup_base (TREE_TYPE (intype), TREE_TYPE (type),\n \t\t\t       ba_check, NULL);\n \t  if (!binfo)\n \t    {\n-\t      /* Try base to derived conversion. */\n+\t      /* Try base to derived conversion.  */\n \t      binfo = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n \t\t\t\t   ba_check, NULL);\n \t      code = MINUS_EXPR;\n@@ -164,7 +164,7 @@ cp_convert_to_pointer (type, expr, force)\n \t  if (binfo)\n \t    {\n \t      expr = build_base_path (code, expr, binfo, 0);\n-\t      /* Add any qualifier conversions. */\n+\t      /* Add any qualifier conversions.  */\n \t      if (!same_type_p (TREE_TYPE (TREE_TYPE (expr)),\n \t\t\t\tTREE_TYPE (type)))\n \t\t{\n@@ -322,7 +322,7 @@ convert_to_pointer_force (type, expr)\n \t  if (binfo)\n \t    {\n \t      expr = build_base_path (code, expr, binfo, 0);\n-\t      /* Add any qualifier conversions. */\n+\t      /* Add any qualifier conversions.  */\n \t      if (!same_type_p (TREE_TYPE (TREE_TYPE (expr)),\n \t\t\t\tTREE_TYPE (type)))\n \t\t{\n@@ -857,7 +857,7 @@ convert_to_void (expr, implicit)\n     \n     case NON_LVALUE_EXPR:\n     case NOP_EXPR:\n-      /* These have already decayed to rvalue. */\n+      /* These have already decayed to rvalue.  */\n       break;\n     \n     case CALL_EXPR:   /* we have a special meaning for volatile void fn() */"}]}