{"sha": "eaa826f822541a6059d1f633b4299a81079c160b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFhODI2ZjgyMjU0MWE2MDU5ZDFmNjMzYjQyOTlhODEwNzljMTYwYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-07-23T09:34:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T09:34:26Z"}, "message": "checks.adb (Apply_Arithmetic_Overflow_Check): Add comments cross-referencing the new related code in...\n\n2009-07-23  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Arithmetic_Overflow_Check): Add comments\n\tcross-referencing the new related code in\n\tExp_Ch4.Expand_N_Type_Conversion.\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Avoid unnecessary overflows\n\n\t* exp_disp.adb, exp_disp.ads, sinfo.ads: Minor reformatting.\n\tAdd comment.\n\nFrom-SVN: r149983", "tree": {"sha": "cc91e16e1239e5e819de3651e828aab9e9648cd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc91e16e1239e5e819de3651e828aab9e9648cd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaa826f822541a6059d1f633b4299a81079c160b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa826f822541a6059d1f633b4299a81079c160b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa826f822541a6059d1f633b4299a81079c160b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa826f822541a6059d1f633b4299a81079c160b/comments", "author": null, "committer": null, "parents": [{"sha": "a50790d1cad989184d0b77e20c60bf38de3c08a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50790d1cad989184d0b77e20c60bf38de3c08a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a50790d1cad989184d0b77e20c60bf38de3c08a4"}], "stats": {"total": 178, "additions": 140, "deletions": 38}, "files": [{"sha": "05a6cc89c8d0870d5838874d8516647bbbac3e6b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=eaa826f822541a6059d1f633b4299a81079c160b", "patch": "@@ -1,3 +1,13 @@\n+2009-07-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Apply_Arithmetic_Overflow_Check): Add comments\n+\tcross-referencing the new related code in\n+\tExp_Ch4.Expand_N_Type_Conversion.\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Avoid unnecessary overflows\n+\n+\t* exp_disp.adb, exp_disp.ads, sinfo.ads: Minor reformatting.\n+\tAdd comment.\n+\n 2009-07-23  Javier Miranda  <miranda@adacore.com>\n \n \t* sinfo.ads (Is_Scil_Node, Scil_Nkind, Scil_Related_Node,"}, {"sha": "e39e3e079a64bcba6d708943e50a3793f100018f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=eaa826f822541a6059d1f633b4299a81079c160b", "patch": "@@ -760,6 +760,13 @@ package body Checks is\n       --  off, since this is precisely about giving the \"right\" result and\n       --  avoiding the need for an overflow check.\n \n+      --  Note: this circuit is partially redundant with respect to the similar\n+      --  processing in Exp_Ch4.Expand_N_Type_Conversion, but the latter deals\n+      --  with cases that do not come through here. We still need the following\n+      --  processing even with the Exp_Ch4 code in place, since we want to be\n+      --  sure not to generate the arithmetic overflow check in these cases\n+      --  (Exp_Ch4 would have a hard time removing them once generated).\n+\n       if Is_Signed_Integer_Type (Typ)\n         and then Nkind (Parent (N)) = N_Type_Conversion\n       then"}, {"sha": "c55cfa54050ade559396938c7723e68d4fc5e382", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=eaa826f822541a6059d1f633b4299a81079c160b", "patch": "@@ -7621,6 +7621,7 @@ package body Exp_Ch4 is\n          Cons : List_Id;\n \n       begin\n+\n          --  Nothing else to do if no change of representation\n \n          if Same_Representation (Operand_Type, Target_Type) then\n@@ -7860,8 +7861,7 @@ package body Exp_Ch4 is\n          --  Otherwise rewrite the conversion as described above\n \n          Conv := Relocate_Node (N);\n-         Rewrite\n-           (Subtype_Mark (Conv), New_Occurrence_Of (Btyp, Loc));\n+         Rewrite (Subtype_Mark (Conv), New_Occurrence_Of (Btyp, Loc));\n          Set_Etype (Conv, Btyp);\n \n          --  Enable overflow except for case of integer to float conversions,\n@@ -7937,6 +7937,94 @@ package body Exp_Ch4 is\n \n       --  Here if we may need to expand conversion\n \n+      --  If the operand of the type conversion is an arithmetic operation on\n+      --  signed integers, and the based type of the signed integer type in\n+      --  question is smaller than Standard.Integer, we promote both of the\n+      --  operands to type Integer.\n+\n+      --  For example, if we have\n+\n+      --     target-type (opnd1 + opnd2)\n+\n+      --  and opnd1 and opnd2 are of type short integer, then we rewrite\n+      --  this as:\n+\n+      --     target-type (integer(opnd1) + integer(opnd2))\n+\n+      --  We do this because we are always allowed to compute in a larger type\n+      --  if we do the right thing with the result, and in this case we are\n+      --  going to do a conversion which will do an appropriate check to make\n+      --  sure that things are in range of the target type in any case. This\n+      --  avoids some unnecessary intermediate overflows.\n+\n+      --  We also do a similar transformation in the case where the target\n+      --  type is a 64-bit signed integer, in this case we do the inner\n+      --  computation in Long_Long_Integer. We also use Long_Long_Integer\n+      --  as the inner type in the fixed-point or floating-point target case.\n+\n+      --  Note: this circuit is partially redundant with respect to the circuit\n+      --  in Checks.Apply_Arithmetic_Overflow_Check, but we catch more cases in\n+      --  the processing here. Also we still need the Checks circuit, since we\n+      --  have to be sure not to generate junk overflow checks in the first\n+      --  place, since it would be trick to remove them here!\n+\n+      declare\n+         Inner_Type        : Entity_Id          := Empty;\n+         Root_Target_Type  : constant Entity_Id := Root_Type (Target_Type);\n+         Root_Operand_Type : constant Entity_Id := Root_Type (Operand_Type);\n+\n+      begin\n+         if (Root_Target_Type = Base_Type (Standard_Long_Long_Integer)\n+              or else Is_Real_Type (Root_Target_Type))\n+           and then Is_Signed_Integer_Type (Operand_Type)\n+         then\n+            Inner_Type := Standard_Long_Long_Integer;\n+\n+         elsif Root_Operand_Type = Base_Type (Standard_Short_Integer)\n+                 or else\n+               Root_Operand_Type = Base_Type (Standard_Short_Short_Integer)\n+         then\n+            Inner_Type := Standard_Integer;\n+         end if;\n+\n+         --  Do rewrite if enabled\n+\n+         if Present (Inner_Type) then\n+\n+            --  Test for binary operation. Note that this includes junk like\n+            --  XOR and concatenation, but none of those will yield a signed\n+            --  integer result, so we won't get here except in the interesting\n+            --  cases of simple arithmetic operators like addition.\n+\n+            if Nkind (Operand) in N_Binary_Op then\n+               Rewrite (Left_Opnd (Operand),\n+                 Make_Type_Conversion (Loc,\n+                   Subtype_Mark => New_Reference_To (Inner_Type, Loc),\n+                   Expression   => Relocate_Node (Left_Opnd (Operand))));\n+\n+               Rewrite (Right_Opnd (Operand),\n+                 Make_Type_Conversion (Loc,\n+                   Subtype_Mark => New_Reference_To (Inner_Type, Loc),\n+                   Expression   => Relocate_Node (Right_Opnd (Operand))));\n+\n+               Set_Analyzed (Operand, False);\n+               Analyze_And_Resolve (Operand, Inner_Type);\n+\n+               --  Similar processing for unary operation. The only interesting\n+               --  case is negation, nothing else can produce an overflow.\n+\n+            elsif Nkind (Operand) = N_Op_Minus then\n+               Rewrite (Right_Opnd (Operand),\n+                 Make_Type_Conversion (Loc,\n+                   Subtype_Mark => New_Reference_To (Inner_Type, Loc),\n+                   Expression   => Relocate_Node (Right_Opnd (Operand))));\n+\n+               Set_Analyzed (Operand, False);\n+               Analyze_And_Resolve (Operand, Inner_Type);\n+            end if;\n+         end if;\n+      end;\n+\n       --  Do validity check if validity checking operands\n \n       if Validity_Checks_On\n@@ -9596,9 +9684,7 @@ package body Exp_Ch4 is\n       --  Skip this processing if the component size is different from system\n       --  storage unit (since at least for NOT this would cause problems).\n \n-      if Is_Array_Type (Etype (Lhs))\n-        and then Component_Size (Etype (Lhs)) /= System_Storage_Unit\n-      then\n+      if Component_Size (Etype (Lhs)) /= System_Storage_Unit then\n          return False;\n \n       --  Cannot do in place stuff on VM_Target since cannot pass addresses\n@@ -9608,9 +9694,7 @@ package body Exp_Ch4 is\n \n       --  Cannot do in place stuff if non-standard Boolean representation\n \n-      elsif (Is_Array_Type (Etype (Lhs)) or else Is_String_Type (Etype (Lhs)))\n-        and then Has_Non_Standard_Rep (Component_Type (Etype (Lhs)))\n-      then\n+      elsif Has_Non_Standard_Rep (Component_Type (Etype (Lhs))) then\n          return False;\n \n       elsif not Is_Unaliased (Lhs) then"}, {"sha": "191b88f16398695c1d445ed8677f353db8d8c420", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=eaa826f822541a6059d1f633b4299a81079c160b", "patch": "@@ -643,7 +643,7 @@ package body Exp_Disp is\n          Typ := Non_Limited_View (Typ);\n       end if;\n \n-      --  Generate the SCIL node of this dispatching call\n+      --  Generate the SCIL node for this dispatching call\n \n       if Generate_SCIL then\n          Insert_Action (Call_Node,"}, {"sha": "fa16aaf0ffbb300947461f0819efa027419fd14d", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=eaa826f822541a6059d1f633b4299a81079c160b", "patch": "@@ -39,26 +39,24 @@ package Exp_Disp is\n    --  N_Null_Statement nodes that have extra attributes. The information\n    --  available through these extra attributes relies on the kind of SCIL\n    --  node. The SCIL node kind is stored in the Scil_Nkind attribute of\n-   --  the N_Null_Statement node. The kind of SCIL nodes generated by the\n-   --  frontend are the following:\n-\n-   --    IP_Tag_Init: Scil node of tag component initialization.\n-\n-   --    Dispatching_Call: Scil node of dispatching call. Used by the\n-   --      CodePeer backend to locate nodes associated with dispatching\n-   --      calls.\n-\n-   --    Dispatching_Table_Object_Init: Scil node of object declaration\n-   --      containing a dispatch table.\n-\n-   --    Dispatching_Table_Tag_Init: Scil node of tag initialization.\n+   --  the N_Null_Statement node, and indicates the type of the SCIL node.\n \n    type Scil_Node_Kind is\n      (Unused,\n+      --  What is this for ???\n+\n       IP_Tag_Init,\n+      --  SCIL node for tag component initialization\n+\n       Dispatching_Call,\n+      --  SCIL node for dispatching call. Used by the CodePeer backend to\n+      --  locate nodes associated with dispatching calls.\n+\n       Dispatch_Table_Object_Init,\n+      --  SCIL node for object declaration containing a dispatch table\n+\n       Dispatch_Table_Tag_Init);\n+      --  SCIL node for tag initialization\n \n    -------------------------------------\n    -- Predefined primitive operations --"}, {"sha": "e1ab8f0026c8a7695fb18334faed33fb0d2d668a", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa826f822541a6059d1f633b4299a81079c160b/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=eaa826f822541a6059d1f633b4299a81079c160b", "patch": "@@ -1253,10 +1253,10 @@ package Sinfo is\n \n    --  Is_Scil_Node (Flag4-Sem)\n    --    Present in N_Null_Statement nodes. Set to indicate that it is a SCIL\n-   --    node. Scil nodes are special nodes that help the CodePeer backend\n+   --    node. SCIL nodes are special nodes that help the CodePeer backend\n    --    locating nodes that require special processing. In order to minimize\n    --    the impact on the compiler and ASIS, and also to maximize flexibility\n-   --    when adding SCIl nodes to the tree, instead of adding new kind of\n+   --    when adding SCIL nodes to the tree, instead of adding new kind of\n    --    nodes, SCIL nodes are added to the tree as N_Null_Statement nodes on\n    --    which this attribute is set.\n \n@@ -1599,11 +1599,11 @@ package Sinfo is\n    --    and multiplication operations.\n \n    --  Scil_Nkind (Uint3-Sem)\n-   --    Present in N_Null_Statement nodes that are Scil nodes. Used to\n-   --    indicate the kind of SCIL node (see scil node kinds in exp_disp.ads).\n+   --    Present in N_Null_Statement nodes that are SCIL nodes. Indicates the\n+   --    kind of SCIL node (see Scil_Node_Kind in Exp_Disp spec).\n \n    --  Scil_Related_Node (Node1-Sem)\n-   --    Present in N_Null_Statement nodes that are Scil nodes. Used to\n+   --    Present in N_Null_Statement nodes that are SCIL nodes. Used to\n    --    reference a tree node that requires special processing in the\n    --    CodePeer backend.\n \n@@ -3866,7 +3866,11 @@ package Sinfo is\n \n       --  Note that in SCIL nodes (N_Null_Statement nodes with Is_Scil_Node\n       --  set to True), Entity references the tagged type associated with\n-      --  the SCIL node.\n+      --  the SCIL node. However, this is not really an Entity field in the\n+      --  normal sense, so N_Null_Statement is not included in N_Has_Entity.\n+\n+      --  It would be much better to call this SCIL_Entity, and avoid this\n+      --  very confusing non-standard use of Entity. ???\n \n       ----------------\n       -- 5.1  Label --\n@@ -7430,9 +7434,9 @@ package Sinfo is\n      N_Attribute_Reference;\n    --  Nodes that have Entity fields\n    --  Warning: DOES NOT INCLUDE N_Freeze_Entity!\n-\n+   --\n    --  Warning: DOES NOT INCLUDE N_Null_Assignment because it not always\n-   --  available. The Entity attribute is only available in Scil nodes\n+   --  available. The Entity attribute is only available in SCIL nodes\n    --  (that is, N_Null_Assignment nodes that have Is_Scil_Node set to true).\n    --  Processing such nodes never requires testing if the node is in\n    --  N_Has_Entity node kind.\n@@ -7452,14 +7456,13 @@ package Sinfo is\n    subtype N_Later_Decl_Item is Node_Kind range\n      N_Task_Type_Declaration ..\n      N_Generic_Subprogram_Declaration;\n-   --  Note: this is Ada 83 relevant only (see Ada 83 RM 3.9 (2)) and\n-   --  includes only those items which can appear as later declarative\n-   --  items. This also includes N_Implicit_Label_Declaration which is\n-   --  not specifically in the grammar but may appear as a valid later\n-   --  declarative items. It does NOT include N_Pragma which can also\n-   --  appear among later declarative items. It does however include\n-   --  N_Protected_Body, which is a bit peculiar, but harmless since\n-   --  this cannot appear in Ada 83 mode anyway.\n+   --  Note: this is Ada 83 relevant only (see Ada 83 RM 3.9 (2)) and includes\n+   --  only those items which can appear as later declarative items. This also\n+   --  includes N_Implicit_Label_Declaration which is not specifically in the\n+   --  grammar but may appear as a valid later declarative items. It does NOT\n+   --  include N_Pragma which can also appear among later declarative items.\n+   --  It does however include N_Protected_Body, which is a bit peculiar, but\n+   --  harmless since this cannot appear in Ada 83 mode anyway.\n \n    subtype N_Membership_Test is Node_Kind range\n       N_In .."}]}