{"sha": "c27ba9120aa6d7a4477315f359088ea7e4267bd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3YmE5MTIwYWE2ZDdhNDQ3NzMxNWYzNTkwODhlYTdlNDI2N2JkMw==", "commit": {"author": {"name": "Dmitri Makarov", "email": "dim@windriver.com", "date": "2000-02-29T01:42:52Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-02-29T01:42:52Z"}, "message": "Apply Dimitri Makarov's patch to import attribute short_call and #pragma\nlong_calls, no_long_calls.\n\nFrom-SVN: r32248", "tree": {"sha": "7e5e83e1bbfeec9523a4194b16ed3c7e0c4a5df4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e5e83e1bbfeec9523a4194b16ed3c7e0c4a5df4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c27ba9120aa6d7a4477315f359088ea7e4267bd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c27ba9120aa6d7a4477315f359088ea7e4267bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c27ba9120aa6d7a4477315f359088ea7e4267bd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c27ba9120aa6d7a4477315f359088ea7e4267bd3/comments", "author": null, "committer": null, "parents": [{"sha": "8aacf0160022afb99df7b9042b2f44493512ed54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aacf0160022afb99df7b9042b2f44493512ed54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aacf0160022afb99df7b9042b2f44493512ed54"}], "stats": {"total": 513, "additions": 405, "deletions": 108}, "files": [{"sha": "b5dd91be01b6b533290db0aeeedce114da1bfb60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -1,3 +1,72 @@\n+2000-02-28  Dmitri Makarov  <dim@windriver.com>\n+\n+\t* extend.texi: Document ARM's support for long/short calls.\n+\n+\t* invoke.texi: Document ARM's -mlong-calls command line switch.\n+\t\n+\t* config/arm/arm-protos.h (arm_is_longcall_p): Add prototype.\n+\t(arm_encode_call_attribute): Add prototype.\n+\t(arm_set_default_type_attribute): Add prototype.\n+\t(arm_strip_name_encoding): Add prototype.\n+\n+\t* config/arm/arm.c (arm_init_cumulative_args): replace\n+\tinitialisation og 'long_calls' field with initialisation of\n+\t'call_cookie' field.\n+\t(enum arm_pragma_enum): New enum.\n+\t(arm_pragma_long_calls): New static variable.\n+\t(arm_process_pragma): Also process \"#pragma long_calls_off\".\n+\t(arm_valid_type_attribute_p): Accept short_call attribute.\n+\t(arm_comp_type_attributes): Check long/short call attributes.\n+\t(arm_encode_call_attribute):  New function:  Encode long_call\n+\tor short_call attribute in function name.\n+\t(arm_set_default_type_attributes): New function: Assign\n+\tdefault attributes to newly defined type.\n+\t(current_file_function_operand): New function: Return true if\n+\tthe symbol is a function which has already been compiled.\n+\t(arm_is_longcall_p): New function: Return true if the\n+\tindicated function should be called via a long call.\n+\t(arm_get_strip_length): New function.  Returns number of\n+\tprefix characters to be stripped from a function's name.\n+\t(arm_strip_name_encoding): New function.  Strip prefix characters\n+\tfrom a function's name.\n+\n+\t* config/arm/arm.h (CUMULATIVE_ARGS): Replace 'long_call' field\n+\twith 'call_cookie'.\n+\t(SHORT_CALL_FAG_CHAR): Define.\n+\t(LONG_CALL_FAG_CHAR): Define.\n+\t(ENCODED_SHORT_CALL_ATTR_P): Define.\n+\t(ENCODED_LONG_CALL_ATTR_P): Define.\n+\t(ARM_NAME_ENCODING_LENGTHS): Define.\n+\t(STRIP_NAME_ENCODING): Define.\n+\t(ASM_OUTPUT_LABELREF): Define, and use to strip name encoding.\n+\t(ARM_ENCODE_CALL_TYPE): Define.\n+\t(ENCODE_SECTION): Invoke ARM_ENCODE_CALL_TYPE.\n+\t(ARM_DECLARE_FUNCTION_SIZE): Define.\n+\t(SET_DEFAULT_TYPE_ATTRIBUTES): Define.\n+\n+\t* config/arm/arm.md (call): Call arm_is_longcall_p to decide\n+        if a long call is needed.\n+\t(call_value): Ditto.\n+\t(call_symbol): Ditto.\n+\n+\t* config/arm/elf.h (ASM_DECLARE_FUNCTION_SIZE): Add invocation of\n+\tARM_DECLARE_FUNCTION_SIZE.\n+\n+\t* config/arm/pe.h (ARM_PE_FLAG_CHAR): Define.\n+\t(SUBTARGET_NAME_ENCODING_LENGTHS): Define.\n+\t(ARM_STRIP_NAME_ENCODING): Undefine.\n+\t(STRIP_NAME_ENCODING): Undefine.\n+\t(ASM_OUTPUT_LABELREF): Use arm_strip_name_encoding.\n+\t(ASM_DECLARE_FUNCTION_NAME): Ditto.\n+\t(ASM_OUTPUT_COMMON): Ditto.\n+\t(ASM_DECLARE_OBJECT_NAME): Ditto.\n+\n+\t* config/arm/pe.c (arm_dllexport_name_p): Check for\n+\tARM_PE_FLAG_CHAR.\n+\t(arm_dllimport_name_p): Ditto.\n+\t(arm_mark_dllexport): Use ARM_PE_FLAG_CHAR.\n+\t(arm_mark_dllimport): Ditto.\n+\t\n Mon Feb 28 22:11:12 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.h (DWARF_LINE_MIN_INSTR_LENGTH): Define."}, {"sha": "d19aa71d8b6f2528dc9439aa33d55bed65e7061e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -34,6 +34,7 @@ extern void   output_ascii_pseudo_op\t\tPARAMS ((FILE *, unsigned char *, int));\n extern void   output_func_epilogue\t\tPARAMS ((int));\n extern void   output_func_prologue\t\tPARAMS ((FILE *, int));\n extern int    use_return_insn\t\t\tPARAMS ((int));\n+extern const char * arm_strip_name_encoding\tPARAMS ((const char *));\n #if defined AOF_ASSEMBLER \n extern void   aof_add_import\t\t\tPARAMS ((char *));\n extern char * aof_data_section\t\t\tPARAMS ((void));\n@@ -62,6 +63,9 @@ extern void   arm_pe_encode_section_info \tPARAMS ((tree));\n extern tree   arm_pe_merge_machine_decl_attributes PARAMS ((tree, tree));\n extern void   arm_pe_unique_section \t\tPARAMS ((tree, int));\n extern int    arm_pe_valid_machine_decl_attribute PARAMS ((tree, tree, tree, tree));\n+extern void   arm_set_default_type_attributes\tPARAMS ((tree));\n+extern void   arm_encode_call_attribute\t\tPARAMS ((tree, char));\n+extern int    arm_pe_return_in_memory\t\tPARAMS ((tree));\n #endif\n \n #ifdef RTX_CODE"}, {"sha": "ffa26bb0cc8dff21afc048bf9dcbb0fe38b6430b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 190, "deletions": 72, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -40,19 +40,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"ggc.h\"\n-#include \"arm-protos.h\"\n-\n-/* The maximum number of insns skipped which will be conditionalised if\n-   possible.  */\n-static int max_insns_skipped = 5;\n-\n-extern FILE * asm_out_file;\n-/* Some function declarations.  */\n+#include \"tm_p.h\"\n \n #ifndef Mmode\n #define Mmode enum machine_mode\n #endif\n \n+/* Some function declarations.  */\n static HOST_WIDE_INT int_log2 \t\tPARAMS ((HOST_WIDE_INT));\n static char * output_multi_immediate \tPARAMS ((rtx *, char *, char *, int, HOST_WIDE_INT));\n static int arm_gen_constant \t\tPARAMS ((enum rtx_code, Mmode, HOST_WIDE_INT, rtx, rtx, int, int));\n@@ -76,6 +70,12 @@ static enum arm_cond_code get_arm_condition_code PARAMS ((rtx));\n static int const_ok_for_op \t\tPARAMS ((HOST_WIDE_INT, enum rtx_code));\n static void arm_add_gc_roots \t\tPARAMS ((void));\n \n+/* The maximum number of insns skipped which will be conditionalised if\n+   possible.  */\n+static int max_insns_skipped = 5;\n+\n+extern FILE * asm_out_file;\n+\n /* True if we are currently building a constant table. */\n int making_const_table;\n \n@@ -1487,9 +1487,8 @@ arm_init_cumulative_args (pcum, fntype, libname, indirect)\n      int indirect ATTRIBUTE_UNUSED;\n {\n   /* On the ARM, the offset starts at 0.  */\n-  pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype)))\n-\t\t ? 1 : 0);\n-\n+  pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype))) ? 1 : 0);\n+  \n   pcum->call_cookie = CALL_NORMAL;\n \n   if (TARGET_LONG_CALLS)\n@@ -1534,73 +1533,37 @@ arm_function_arg (pcum, mode, type, named)\n   \n   return gen_rtx_REG (mode, pcum->nregs);\n }\n-\n \f\n-/* Return 1 if the operand is a SYMBOL_REF for a function\n-   known to be defined in the current compilation unit.  */\n-static int\n-current_file_function_operand (sym_ref)\n-  rtx sym_ref;\n+/* Encode the current state of the #pragma [no_]long_calls.  */\n+typedef enum\n {\n-  /* XXX FIXME - we need some way to determine if SYMREF has already been\n-     compiled.  We wanted to used SYMBOL_REF_FLAG but this is already in use\n-     by the constant pool generation code.  */\n-  return\n-    GET_CODE (sym_ref) == SYMBOL_REF\n-    && sym_ref == XEXP (DECL_RTL (current_function_decl), 0)\n-    && ! DECL_WEAK (current_function_decl);\n-}\n-\n-/* Return non-zero if a 32 bit \"long call\" should be generated for this\n-   call.\n+  OFF,\t\t/* No #pramgma [no_]long_calls is in effect.  */\n+  LONG,\t\t/* #pragma long_calls is in effect.  */\n+  SHORT\t\t/* #pragma no_long_calls is in effect.  */\n+} arm_pragma_enum;\n \n-   We generate a long call if the function is not declared\n-   __attribute__ ((short_call),\n+static arm_pragma_enum arm_pragma_long_calls = OFF;\n \n-   AND:\n-   \n-     (1)  the function is declared __attribute__ ((long_call))\n-\n-   OR\n-\n-     (2) -mlong-calls is enabled and we don't know whether the target\n-         function is declared in this file.\n-\t \n-   This function will typically be called by C fragments in the machine\n-   description file.  CALL_REF is the matched rtl operand.  CALL_COOKIE\n-   describes the value of the long_call and short_call attributes for\n-   the called functiion.  CALL_SYMBOL is used to distinguish between\n-   two different callers of the function.  It is set to 1 in the \"call_symbol\"\n-   and \"call_symbol_value\" patterns in arm.md and to 0 in the \"call\" and\n-   \"call_value\" patterns.  This is because of the difference of SYM_REFs passed\n-   from \"call_symbol\" and \"call\"  patterns.  */\n+/* Handle pragmas for compatibility with Intel's compilers.\n+   FIXME: This is incomplete, since it does not handle all\n+   the pragmas that the Intel compilers understand.  */\n int\n-arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n-  rtx sym_ref;\n-  int call_cookie;\n-  int call_symbol;\n-{\n-  if (! call_symbol)\n-    {\n-      if (GET_CODE (sym_ref) != MEM)\n-\treturn 0;\n-\n-      sym_ref = XEXP (sym_ref, 0);\n-    }\n-\n-  if (GET_CODE (sym_ref) != SYMBOL_REF)\n-    return 0;\n-\n-  if (call_cookie & CALL_SHORT)\n-    return 0;\n-\n-  if (TARGET_LONG_CALLS && flag_function_sections)\n-    return 1;\n-  \n-  if (current_file_function_operand (sym_ref, VOIDmode))\n+arm_process_pragma (p_getc, p_ungetc, pname)\n+     int (*  p_getc)   PARAMS ((void)) ATTRIBUTE_UNUSED;\n+     void (* p_ungetc) PARAMS ((int))  ATTRIBUTE_UNUSED;\n+     char *  pname;\n+{\n+  /* Should be pragma 'far' or equivalent for callx/balx here.  */\n+  if (strcmp (pname, \"long_calls\") == 0)\n+    arm_pragma_long_calls = LONG;\n+  else if (strcmp (pname, \"no_long_calls\") == 0)\n+    arm_pragma_long_calls = SHORT;\n+  else if (strcmp (pname, \"long_calls_off\") == 0)\n+    arm_pragma_long_calls = OFF;\n+  else\n     return 0;\n   \n-  return (call_cookie & CALL_LONG) || TARGET_LONG_CALLS;\n+  return 1;\n }\n \f\n /* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n@@ -1624,7 +1587,7 @@ arm_valid_type_attribute_p (type, attributes, identifier, args)\n      call.  */\n   if (is_attribute_p (\"long_call\", identifier))\n     return (args == NULL_TREE);\n-\n+  \n   /* Whereas these functions are always known to reside within the 26 bit\n      addressing range.  */\n   if (is_attribute_p (\"short_call\", identifier))\n@@ -1668,6 +1631,136 @@ arm_comp_type_attributes (type1, type2)\n   return 1;\n }\n \n+/*  Encode long_call or short_call attribute by prefixing\n+    symbol name in DECL with a special character FLAG.  */\n+void\n+arm_encode_call_attribute (decl, flag)\n+  tree decl;\n+  char flag;\n+{\n+  char * str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+  int    len = strlen (str);\n+  char * newstr;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    return;\n+\n+  /* Do not allow weak functions to be treated as short call.  */\n+  if (DECL_WEAK (decl) && flag == SHORT_CALL_FLAG_CHAR)\n+    return;\n+  \n+  if (ggc_p)\n+    newstr = ggc_alloc_string (NULL, len + 2);\n+  else\n+    newstr = permalloc (len + 2);\n+\n+  sprintf (newstr, \"%c%s\", flag, str);\n+\n+  XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n+}\n+\n+/*  Assigns default attributes to newly defined type.  This is used to\n+    set short_call/long_call attributes for function types of\n+    functions defined inside corresponding #pragma scopes.  */\n+void\n+arm_set_default_type_attributes (type)\n+  tree type;\n+{\n+  /* Add __attribute__ ((long_call)) to all functions, when\n+     inside #pragma long_calls or __attribute__ ((short_call)),\n+     when inside #pragma no_long_calls.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      tree type_attr_list, attr_name;\n+      type_attr_list = TYPE_ATTRIBUTES (type);\n+\n+      if (arm_pragma_long_calls == LONG)\n+ \tattr_name = get_identifier (\"long_call\");\n+      else if (arm_pragma_long_calls == SHORT)\n+ \tattr_name = get_identifier (\"short_call\");\n+      else\n+ \treturn;\n+\n+      type_attr_list = tree_cons (attr_name, NULL_TREE, type_attr_list);\n+      TYPE_ATTRIBUTES (type) = type_attr_list;\n+    }\n+}\n+\f\n+/* Return 1 if the operand is a SYMBOL_REF for a function known to be\n+   defined within the current compilation unit.  If this caanot be\n+   determined, then 0 is returned.  */\n+static int\n+current_file_function_operand (sym_ref)\n+  rtx sym_ref;\n+{\n+  /* This is a bit of a fib.  A function will have a short call flag\n+     applied to its name if it has the short call attribute, or it has\n+     already been defined within the current compilation unit.  */\n+  if (ENCODED_SHORT_CALL_ATTR_P (XSTR (sym_ref, 0)))\n+    return 1;\n+\n+  /* The current funciton is always defined within the current compilation\n+     unit.  if it s a weak defintion however, then this may not be the real\n+     defintion of the function, and so we have to say no.  */\n+  if (sym_ref == XEXP (DECL_RTL (current_function_decl), 0)\n+      && ! DECL_WEAK (current_function_decl))\n+    return 1;\n+\n+  /* We cannot make the determination - default to returning 0.  */\n+  return 0;\n+}\n+\n+/* Return non-zero if a 32 bit \"long_call\" should be generated for\n+   this call.  We generate a long_call if the function:\n+\n+        a.  has an __attribute__((long call))\n+     or b.  is within the scope of a #pragma long_calls\n+     or c.  the -mlong-calls command line switch has been specified\n+\n+   However we do not generate a long call if the function:\n+   \n+        d.  has an __attribute__ ((short_call))\n+     or e.  is inside the scope of a #pragma no_long_calls\n+     or f.  has an __attribute__ ((section))\n+     or g.  is defined within the current compilation unit.\n+   \n+   This function will be called by C fragments contained in the machine\n+   description file.  CALL_REF and CALL_COOKIE correspond to the matched\n+   rtl operands.  CALL_SYMBOL is used to distinguish between\n+   two different callers of the function.  It is set to 1 in the\n+   \"call_symbol\" and \"call_symbol_value\" patterns and to 0 in the \"call\"\n+   and \"call_value\" patterns.  This is because of the difference in the\n+   SYM_REFs passed by these patterns.  */\n+int\n+arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n+  rtx sym_ref;\n+  int call_cookie;\n+  int call_symbol;\n+{\n+  if (! call_symbol)\n+    {\n+      if (GET_CODE (sym_ref) != MEM)\n+\treturn 0;\n+\n+      sym_ref = XEXP (sym_ref, 0);\n+    }\n+\n+  if (GET_CODE (sym_ref) != SYMBOL_REF)\n+    return 0;\n+\n+  if (call_cookie & CALL_SHORT)\n+    return 0;\n+\n+  if (TARGET_LONG_CALLS && flag_function_sections)\n+    return 1;\n+  \n+  if (current_file_function_operand (sym_ref, VOIDmode))\n+    return 0;\n+  \n+  return (call_cookie & CALL_LONG)\n+    || ENCODED_LONG_CALL_ATTR_P (XSTR (sym_ref, 0))\n+    || TARGET_LONG_CALLS;\n+}\n \f\n int\n legitimate_pic_operand_p (x)\n@@ -6988,6 +7081,31 @@ arm_final_prescan_insn (insn)\n     }\n }\n \n+/* Return the length of a function name prefix\n+    that starts with the character 'c'.  */\n+static int\n+arm_get_strip_length (char c)\n+{\n+  switch (c)\n+    {\n+    ARM_NAME_ENCODING_LENGTHS\n+      default: return 0; \n+    }\n+}\n+\n+/* Return a pointer to a function's name with any\n+   and all prefix encodings stripped from it.  */\n+const char *\n+arm_strip_name_encoding (const char * name)\n+{\n+  int skip;\n+  \n+  while ((skip = arm_get_strip_length (* name)))\n+    name += skip;\n+\n+  return name;\n+}\n+\n #ifdef AOF_ASSEMBLER\n /* Special functions only needed when producing AOF syntax assembler. */\n "}, {"sha": "c20d82bb615bd5b8239e54c012d25a52f9c8d8a5", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -397,7 +397,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n      \"Do not load the PIC register in function prologues\" },\t\\\n   {\"no-single-pic-base\",       -ARM_FLAG_SINGLE_PIC_BASE, \"\" },\t\\\n   {\"long-calls\",\t\tARM_FLAG_LONG_CALLS,\t\t\\\n-     \"Generate all call instructions as indirect calls\"},\t\\\n+     \"Generate call insns as indirect calls, if necessary\"},\t\\\n   {\"no-long-calls\",\t       -ARM_FLAG_LONG_CALLS, \"\"},\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n   {\"\",\t\t\t\tTARGET_DEFAULT, \"\" }\t\t\\\n@@ -1037,7 +1037,7 @@ enum reg_class\n \t  else\t\t\t\t\t\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\t\\\n \t  \t\t\t\t\t\t\t\t\t\\\n-\t  high = ((((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000);\t\\\n+\t  high = ((((val - low) & 0xffffffffUL) ^ 0x80000000UL) - 0x80000000UL);\\\n \t  /* Check for overflow or zero */\t\t\t\t\t\\\n \t  if (low == 0 || high == 0 || (high + low != val))\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\t\\\n@@ -1452,6 +1452,55 @@ CUMULATIVE_ARGS;\n    \n    When generating pic allow anything.  */\n #define LEGITIMATE_CONSTANT_P(X)\t(flag_pic || ! label_mentioned_p (X))\n+\f\n+/* Special characters prefixed to function names\n+   in order to encode attribute like information.\n+   Note, '@' and '*' have already been taken.  */\n+#define SHORT_CALL_FLAG_CHAR\t'^'\n+#define LONG_CALL_FLAG_CHAR\t'#'\n+\n+#define ENCODED_SHORT_CALL_ATTR_P(SYMBOL_NAME)\t\\\n+  (*(SYMBOL_NAME) == SHORT_CALL_FLAG_CHAR)\n+\n+#define ENCODED_LONG_CALL_ATTR_P(SYMBOL_NAME)\t\\\n+  (*(SYMBOL_NAME) == LONG_CALL_FLAG_CHAR)\n+\n+#ifndef SUBTARGET_NAME_ENCODING_LENGTHS\n+#define SUBTARGET_NAME_ENCODING_LENGTHS\n+#endif\n+\n+/* This is a C fragement for the inside of a switch statement.\n+   Each case label should return the number of characters to\n+   be stripped from the start of a function's name, if that\n+   name starts with the indicated character.  */\n+#define ARM_NAME_ENCODING_LENGTHS\t\t\\\n+  case SHORT_CALL_FLAG_CHAR: return 1;\t\t\\\n+  case LONG_CALL_FLAG_CHAR:  return 1;\t\t\\\n+  case '*':  return 1;\t\t\t\t\\\n+  SUBTARGET_NAME_ENCODING_LENGTHS\t\t\n+\n+/* This has to be handled by a function because more than part of the\n+   ARM backend uses funciton name prefixes to encode attributes.  */\n+#define STRIP_NAME_ENCODING(VAR, SYMBOL_NAME)\t\\\n+  (VAR) = arm_strip_name_encoding (SYMBOL_NAME)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\\\n+  fprintf (FILE, \"%s%s\", USER_LABEL_PREFIX, arm_strip_name_encoding (NAME))\n+\n+/* If we are referencing a function that is weak then encode a long call\n+   flag in the function name, otherwise if the function is static or\n+   or known to be defined in this file then encode a short call flag.\n+   This macro is used inside the ENCODE_SECTION macro.  */\n+#define ARM_ENCODE_CALL_TYPE(decl)\t\t\t\t\t\\\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (DECL_WEAK (decl))\t\t\t\t\t\t\\\n+        arm_encode_call_attribute (decl, LONG_CALL_FLAG_CHAR);\t\t\\\n+      else if (! TREE_PUBLIC (decl))        \t\t\t\t\\\n+        arm_encode_call_attribute (decl, SHORT_CALL_FLAG_CHAR);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \n /* Symbols in the text segment can be accessed without indirecting via the\n    constant pool; it may take an extra binary operation, but this is still\n@@ -1470,9 +1519,18 @@ CUMULATIVE_ARGS;\n                  ? TREE_CST_RTL (decl) : DECL_RTL (decl));\t\t\\\n       SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  ARM_ENCODE_CALL_TYPE (decl)\t\t\t\t\t\t\\\n+}\n+#else\n+#define ENCODE_SECTION_INFO(decl)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ARM_ENCODE_CALL_TYPE (decl)\t\t\t\t\t\t\\\n }\n #endif\n \n+#define ARM_DECLARE_FUNCTION_SIZE(STREAM, NAME, DECL)\t\\\n+  arm_encode_call_attribute (DECL, SHORT_CALL_FLAG_CHAR)\n+\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them.\n@@ -1892,8 +1950,8 @@ extern const char * arm_pic_register_string;\n \t(   ! symbol_mentioned_p (X)\t\t\t\t\t\\\n \t && ! label_mentioned_p (X)\t\t\t\t\t\\\n \t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n-\t     || (   ! symbol_mentioned_p (get_pool_constant (X)))  \t\\\n-\t         && ! label_mentioned_p (get_pool_constant (X))))\n+\t     || (   ! symbol_mentioned_p (get_pool_constant (X))  \t\\\n+\t         && ! label_mentioned_p (get_pool_constant (X)))))\n      \n /* We need to know when we are making a constant pool; this determines\n    whether data needs to be in the GOT or can be referenced via a GOT\n@@ -1912,6 +1970,14 @@ extern int making_const_table;\n    generated).  */\n #define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n   (arm_comp_type_attributes (TYPE1, TYPE2))\n+\n+/* If defined, a C statement that assigns default attributes to newly\n+   defined TYPE.  */\n+#define SET_DEFAULT_TYPE_ATTRIBUTES(TYPE) \\\n+  arm_set_default_type_attributes (TYPE)\n+\n+/* Handle pragmas for compatibility with Intel's compilers.  */\n+#define HANDLE_PRAGMA(GET, UNGET, NAME) arm_process_pragma (GET, UNGET, NAME)\n \f\n /* Condition code information. */\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,"}, {"sha": "ed1a3da80b787afaee53ba37ae3aa0fe1f572f62", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -4514,18 +4514,24 @@\n   \"\"\n   \"\n   {\n-    rtx callee = XEXP (operands[0], 0);\n+    rtx callee;\n     \n-    /* Decide if we need to generate an indirect call by loading the 32 bit\n-       address of the callee into a register and then jumping to the contents\n-       of that register.  operands[2] contains the long_call / short_call\n-       attribute.  The third parameter to arm_is_longcall_p tells it that it\n-       is being passed a (MEM) and not a SYMREF().  */\n-     \n     /* In an untyped call, we can get NULL for operand 2.  */\n     if (operands[2] == NULL_RTX)\n       operands[2] = const0_rtx;\n       \n+    /* This is to decide if we should generate indirect calls by loading the\n+       32 bit address of the callee into a register before performing the\n+       branch and link.  operand[2] encodes the long_call/short_call\n+       attribute of the function being called.  This attribute is set whenever\n+       __attribute__((long_call/short_call)) or #pragma long_call/no_long_call\n+       is used, and the short_call attribute can also be set if function is\n+       declared as static or if it has already been defined in the current\n+       compilation unit.  See arm.c and arm.h for info about this.  The third\n+       parameter to arm_is_longcall_p is used to tell it which pattern\n+       invoked it.  */\n+    callee  = XEXP (operands[0], 0);\n+    \n     if (GET_CODE (callee) != REG\n        && arm_is_longcall_p (operands[0], INTVAL (operands[2]), 0))\n       XEXP (operands[0], 0) = force_reg (Pmode, callee);\n@@ -4575,7 +4581,7 @@\n     /* See the comment in define_expand \\\"call\\\".  */\n     if (GET_CODE (callee) != REG\n \t&& arm_is_longcall_p (operands[1], INTVAL (operands[3]), 0))\n-       XEXP (operands[1], 0) = force_reg (Pmode, callee);\n+      XEXP (operands[1], 0) = force_reg (Pmode, callee);\n   }\"\n )\n \n@@ -4613,8 +4619,8 @@\n \t (match_operand:SI 1 \"general_operand\" \"g\"))\n    (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:SI 14))]\n-  \"! arm_is_longcall_p (operands[0], INTVAL (operands[2]), 1)\n-   && GET_CODE (operands[0]) == SYMBOL_REF\"\n+  \"(GET_CODE (operands[0]) == SYMBOL_REF)\n+   && ! arm_is_longcall_p (operands[0], INTVAL (operands[2]), 1)\"\n   \"*\n   {\n     return NEED_PLT_RELOC ? \\\"bl%?\\\\t%a0(PLT)\\\" : \\\"bl%?\\\\t%a0\\\";\n@@ -4627,8 +4633,8 @@\n \t(match_operand:SI 2 \"general_operand\" \"g\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI 14))]\n-  \"! arm_is_longcall_p (operands[1], INTVAL (operands[3]), 1)\n-   && GET_CODE (operands[1]) == SYMBOL_REF\"\n+  \"(GET_CODE (operands[1]) == SYMBOL_REF)\n+   && ! arm_is_longcall_p (operands[1], INTVAL (operands[3]), 1)\"\n   \"*\n   {\n     return NEED_PLT_RELOC ? \\\"bl%?\\\\t%a1(PLT)\\\" : \\\"bl%?\\\\t%a1\\\";"}, {"sha": "b95c7fbecc0f0260cd96f7e63c8e1fb2436f3d2a", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -127,6 +127,7 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n+      ARM_DECLARE_FUNCTION_SIZE (FILE, FNAME, DECL);\t\t\\\n       if (!flag_inhibit_size_directive)\t\t\t\t\\\n         {\t\t\t\t\t\t\t\\\n           char label[256];\t\t\t\t\t\\"}, {"sha": "90158ff6f275b494acc74e13b4483702c7d3755c", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -19,9 +19,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include <stdio.h>\n-#include <string.h>\n #include \"config.h\"\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"flags.h\"\n@@ -240,7 +239,7 @@ int\n arm_dllexport_name_p (symbol)\n      char * symbol;\n {\n-  return symbol[0] == '@' && symbol[1] == 'e' && symbol[2] == '.';\n+  return symbol[0] == ARM_PE_FLAG_CHAR && symbol[1] == 'e' && symbol[2] == '.';\n }\n \n /* Return non-zero if SYMBOL is marked as being dllimport'd.  */\n@@ -249,7 +248,7 @@ int\n arm_dllimport_name_p (symbol)\n      char * symbol;\n {\n-  return symbol[0] == '@' && symbol[1] == 'i' && symbol[2] == '.';\n+  return symbol[0] == ARM_PE_FLAG_CHAR && symbol[1] == 'i' && symbol[2] == '.';\n }\n \n /* Mark a DECL as being dllexport'd.\n@@ -278,7 +277,7 @@ arm_mark_dllexport (decl)\n     return; /* already done */\n \n   newname = alloca (strlen (oldname) + 4);\n-  sprintf (newname, \"@e.%s\", oldname);\n+  sprintf (newname, \"%ce.%s\", ARM_PE_FLAG_CHAR, oldname);\n \n   /* We pass newname through get_identifier to ensure it has a unique\n      address.  RTL processing can sometimes peek inside the symbol ref\n@@ -349,7 +348,7 @@ arm_mark_dllimport (decl)\n     }\n \n   newname = alloca (strlen (oldname) + 11);\n-  sprintf (newname, \"@i.__imp_%s\", oldname);\n+  sprintf (newname, \"%ci.__imp_%s\", ARM_PE_FLAG_CHAR, oldname);\n \n   /* We pass newname through get_identifier to ensure it has a unique\n      address.  RTL processing can sometimes peek inside the symbol ref"}, {"sha": "dfa5d4d08b4257fe541d1790108809587c8f496c", "filename": "gcc/config/arm/pe.h", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Fpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fconfig%2Farm%2Fpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.h?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -19,6 +19,12 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#define ARM_PE_FLAG_CHAR '@'\n+\n+/* Ensure that @x. will be stripped from the function name.  */\n+#define SUBTARGET_NAME_ENCODING_LENGTHS  \\\n+  case ARM_PE_FLAG_CHAR: return 3;\n+\n #include \"arm/coff.h\"\n \n #undef  USER_LABEL_PREFIX\n@@ -123,16 +129,6 @@ Boston, MA 02111-1307, USA.  */\n #define REDO_SECTION_INFO_P(DECL) 1\n #endif\n \n-/* Utility used only in this file.  */\n-#define ARM_STRIP_NAME_ENCODING(SYM_NAME) \\\n-((SYM_NAME) + ((SYM_NAME)[0] == '@' ? 3 : 0))\n-\n-/* Strip any text from SYM_NAME added by ENCODE_SECTION_INFO and store\n-   the result in VAR.  */\n-#undef  STRIP_NAME_ENCODING\n-#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n-(VAR) = ARM_STRIP_NAME_ENCODING (SYM_NAME)\n-\n /* Define this macro if in some cases global symbols from one translation\n    unit may not be bound to undefined symbols in another translation unit\n    without user intervention.  For instance, under Microsoft Windows\n@@ -184,7 +180,7 @@ Boston, MA 02111-1307, USA.  */\n /* Output a reference to a label.  */\n #undef  ASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n-  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, ARM_STRIP_NAME_ENCODING (NAME))\n+  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, arm_strip_name_encoding (NAME))\n \n /* Output a function definition label.  */\n #undef  ASM_DECLARE_FUNCTION_NAME\n@@ -195,7 +191,7 @@ Boston, MA 02111-1307, USA.  */\n \t{\t\t\t\t\t\t\\\n \t  drectve_section ();\t\t\t\t\\\n \t  fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\\\n-\t\t   ARM_STRIP_NAME_ENCODING (NAME));\t\\\n+\t\t   arm_strip_name_encoding (NAME));\t\\\n \t  function_section (DECL);\t\t\t\\\n \t}\t\t\t\t\t\t\\\n       if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n@@ -213,7 +209,7 @@ Boston, MA 02111-1307, USA.  */\n \t{\t\t\t\t\t\t\\\n \t  drectve_section ();\t\t\t\t\\\n \t  fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\\\n-\t\t   ARM_STRIP_NAME_ENCODING (NAME));\t\\\n+\t\t   arm_strip_name_encoding (NAME));\t\\\n \t}\t\t\t\t\t\t\\\n       if (! arm_dllimport_name_p (NAME))\t\t\\\n \t{\t\t\t\t\t\t\\\n@@ -235,7 +231,7 @@ Boston, MA 02111-1307, USA.  */\n \t  enum in_section save_section = in_section;\t\\\n \t  drectve_section ();\t\t\t\t\\\n \t  fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\\\n-\t\t   ARM_STRIP_NAME_ENCODING (NAME));\t\\\n+\t\t   arm_strip_name_encoding (NAME));\t\\\n \t  switch_to_section (save_section, (DECL));\t\\\n \t}\t\t\t\t\t\t\\\n       ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\\"}, {"sha": "fa13154d7feb1e8834dbdfec76f87ac531ef07c1", "filename": "gcc/extend.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -1613,6 +1613,17 @@ compiler to always call the function via a pointer, so that functions\n which reside further than 64 megabytes (67,108,864 bytes) from the\n current location can be called.\n \n+@item long_call/short_call\n+@cindex indirect calls on ARM\n+This attribute allows to specify how to call a particular function on\n+ARM.  Both attributes override the @code{-mlong-calls} (@pxref{ARM Options})\n+command line switch and @code{#pragma long_calls} settings.  The\n+@code{long_call} attribute causes the compiler to always call the\n+function by first loading its address into a register and then using the\n+contents of that register.   The @code{short_call} attribute always places\n+the offset to the function from the call site into the @samp{BL}\n+instruction directly.\n+\n @item dllimport\n @cindex functions which are imported from a dll on PowerPC Windows NT\n On the PowerPC running Windows NT, the @code{dllimport} attribute causes"}, {"sha": "3be7f72f6e960fab3a7a7537526313a98ffc52da", "filename": "gcc/invoke.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27ba9120aa6d7a4477315f359088ea7e4267bd3/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=c27ba9120aa6d7a4477315f359088ea7e4267bd3", "patch": "@@ -269,6 +269,7 @@ in the following sections.\n -mstructure-size-boundary=\n -mbsd -mxopen -mno-symrename\n -mabort-on-noreturn\n+-mlong-calls -mno-long-calls\n -mnop-fun-dllimport -mno-nop-fun-dllimport\n -msingle-pic-base -mno-single-pic-base\n -mpic-register=\n@@ -4608,6 +4609,32 @@ value as future versions of the toolchain may default to this value.\n Generate a call to the function abort at the end of a noreturn function.\n It will be executed if the function tries to return.\n \n+@item -mlong-calls\n+@itemx -mno-long-calls\n+Tells the compiler to perform function calls by first loading the\n+address of the function into a register and then performing a subroutine\n+call on this register.  This switch is needed if the target function\n+will lie outside of the 64 megabyte addressing range of the offset based\n+version of subroutine call instruction. \n+\n+Even if this switch is enabled, not all function calls will be turned\n+into long calls.  The heuristic is that static functions, functions\n+which have the @samp{short-call} attribute, functions that are inside\n+the scope of a @samp{#pragma no_long_calls} directive and functions whose\n+definitions have already been compiled within the current compilation\n+unit, will not be turned into long calls.  The exception to this rule is\n+that weak function defintions, functions with the @samp{long-call}\n+attribute or the @samp{section} attribute, and functions that are within\n+the scope of a @samp{#pragma long_calls} directive, will always be\n+turned into long calls.\n+\n+This feature is not enabled by default.  Specifying\n+@samp{--no-long-calls} will restore the default behaviour, as will\n+placing the function calls within the scope of a @samp{#pragma\n+long_calls_off} directive.  Note these switches have no effect on how\n+the compiler generates code to handle function calls via function\n+pointers.  \n+\n @item -mnop-fun-dllimport\n @kindex -mnop-fun-dllimport\n Disable the support for the @emph{dllimport} attribute."}]}