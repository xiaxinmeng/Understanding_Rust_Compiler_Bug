{"sha": "5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5N2JkNTA2MmQyN2QxMjk5Y2E2M2MzZTI1MmRjN2I3NWJjMWUxZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-09-10T10:55:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-09-10T10:55:20Z"}, "message": "alias.c (clear_reg_alias_info): Use K&R format definition.\n\n\t* alias.c (clear_reg_alias_info): Use K&R format definition.\n\tAvoid unsigned warning.\n\t* builtins.c: Use \"unsigned int\", not \"unsigned\".\n\t(target_char_cast): Use host_integerp and tree_low_cst.\n\t(expand_builtin_args_info, expand_builtin_frame_address): Likewise.\n\t(c_strlen): Likewise; OFFSET now HOST_WIDE_INT.\n\t(c_getstr): Likewise.\n\t(std_expand_builtin_va_arg): Use int_size_in_bytes.\n\t(builtin_memcpy_read_str): Avoid unsigned warning.\n\t(expand_builtin_memcpy): Alignments are unsigned.\n\t(expand_builtin_strncpy, expand_builtin_memset): Likewise.\n\t(expand_builtin_expect_jump): Use integer_zerop and integer_onep.\n\t* predict.c (expensive_function_p): LIMIT now unsigned.\n\t* resource.c (mark_target_live_regs): Make some vars unsigned.\n\t* sdbout.c: Use \"unsigned int\", not \"unsigned\".\n\t(MAKE_LINE_SAFE): Add cast to avoid unsigned warning.\n\t(sdbout_source_line): Likewise.\n\t(sdbout_record_type_name): Remove \"const\" for NAME declaration.\n\t* config/alpha/alpha.c (alpha_expand_block_move): Whitespace fixes.\n\nFrom-SVN: r45503", "tree": {"sha": "71dad6a024a9276781b0e5afd4cd53f3d06901cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71dad6a024a9276781b0e5afd4cd53f3d06901cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/comments", "author": null, "committer": null, "parents": [{"sha": "2e547b13f124ca29dd676bd57ece27888eee5cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e547b13f124ca29dd676bd57ece27888eee5cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e547b13f124ca29dd676bd57ece27888eee5cf1"}], "stats": {"total": 192, "additions": 112, "deletions": 80}, "files": [{"sha": "b2f641ace7f526a2b6f4d8c0cfe89675d8e3f0fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "patch": "@@ -1,3 +1,25 @@\n+Mon Sep 10 06:47:35 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (clear_reg_alias_info): Use K&R format definition.\n+\tAvoid unsigned warning.\n+\t* builtins.c: Use \"unsigned int\", not \"unsigned\".\n+\t(target_char_cast): Use host_integerp and tree_low_cst.\n+\t(expand_builtin_args_info, expand_builtin_frame_address): Likewise.\n+\t(c_strlen): Likewise; OFFSET now HOST_WIDE_INT.\n+\t(c_getstr): Likewise.\n+\t(std_expand_builtin_va_arg): Use int_size_in_bytes.\n+\t(builtin_memcpy_read_str): Avoid unsigned warning.\n+\t(expand_builtin_memcpy): Alignments are unsigned.\n+\t(expand_builtin_strncpy, expand_builtin_memset): Likewise.\n+\t(expand_builtin_expect_jump): Use integer_zerop and integer_onep.\n+\t* predict.c (expensive_function_p): LIMIT now unsigned.\n+\t* resource.c (mark_target_live_regs): Make some vars unsigned.\n+\t* sdbout.c: Use \"unsigned int\", not \"unsigned\".\n+\t(MAKE_LINE_SAFE): Add cast to avoid unsigned warning.\n+\t(sdbout_source_line): Likewise.\n+\t(sdbout_record_type_name): Remove \"const\" for NAME declaration.\n+\t* config/alpha/alpha.c (alpha_expand_block_move): Whitespace fixes.\n+\n 2001-09-10  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* calls.c (store_one_arg): Expand comment."}, {"sha": "5da7740ad6c9b70c18353b27650c848729dff907", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "patch": "@@ -966,12 +966,11 @@ record_base_value (regno, val, invariant)\n    changes the offset.  */\n \n void\n-clear_reg_alias_info (rtx reg)\n+clear_reg_alias_info (reg)\n+     rtx reg;\n {\n-  int regno = REGNO (reg);\n-\n-  if (regno < reg_known_value_size)\n-    reg_known_value[regno] = reg;\n+  if (REGNO (reg) < reg_known_value_size)\n+    reg_known_value[REGNO (reg)] = reg;\n }\n \n /* Returns a canonical version of X, from the point of view alias"}, {"sha": "9adbf96153c276e86a761674f7ef5bfac262ef11", "filename": "gcc/builtins.c", "status": "modified", "additions": 66, "deletions": 57, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "patch": "@@ -74,7 +74,7 @@ tree built_in_decls[(int) END_BUILTINS];\n \n tree (*lang_type_promotes_to) PARAMS ((tree));\n \n-static int get_pointer_alignment\tPARAMS ((tree, unsigned));\n+static int get_pointer_alignment\tPARAMS ((tree, unsigned int));\n static tree c_strlen\t\t\tPARAMS ((tree));\n static const char *c_getstr\t\tPARAMS ((tree));\n static rtx c_readstr\t\t\tPARAMS ((const char *,\n@@ -150,17 +150,17 @@ static int validate_arglist\t\tPARAMS ((tree, ...));\n /* Return the alignment in bits of EXP, a pointer valued expression.\n    But don't return more than MAX_ALIGN no matter what.\n    The alignment returned is, by default, the alignment of the thing that\n-   EXP points to (if it is not a POINTER_TYPE, 0 is returned).\n+   EXP points to.  If it is not a POINTER_TYPE, 0 is returned.\n \n    Otherwise, look at the expression to see if we can do better, i.e., if the\n    expression is actually pointing at an object whose alignment is tighter.  */\n \n static int\n get_pointer_alignment (exp, max_align)\n      tree exp;\n-     unsigned max_align;\n+     unsigned int max_align;\n {\n-  unsigned align, inner;\n+  unsigned int align, inner;\n \n   if (TREE_CODE (TREE_TYPE (exp)) != POINTER_TYPE)\n     return 0;\n@@ -231,7 +231,8 @@ c_strlen (src)\n      tree src;\n {\n   tree offset_node;\n-  int offset, max;\n+  HOST_WIDE_INT offset;\n+  int max;\n   const char *ptr;\n \n   src = string_constant (src, &offset_node);\n@@ -263,16 +264,11 @@ c_strlen (src)\n     }\n \n   /* We have a known offset into the string.  Start searching there for\n-     a null character.  */\n-  if (offset_node == 0)\n+     a null character if we can represent it as a single HOST_WIDE_INT.  */\n+  if (offset_node == 0 || ! host_integerp (offset_node, 0))\n     offset = 0;\n   else\n-    {\n-      /* Did we get a long long offset?  If so, punt.  */\n-      if (TREE_INT_CST_HIGH (offset_node) != 0)\n-\treturn 0;\n-      offset = TREE_INT_CST_LOW (offset_node);\n-    }\n+    offset = tree_low_cst (offset_node, 0);\n \n   /* If the offset is known to be out of bounds, warn, and call strlen at\n      runtime.  */\n@@ -299,7 +295,8 @@ c_getstr (src)\n      tree src;\n {\n   tree offset_node;\n-  int offset, max;\n+  HOST_WIDE_INT offset;\n+  int max;\n   const char *ptr;\n \n   src = string_constant (src, &offset_node);\n@@ -309,19 +306,12 @@ c_getstr (src)\n   max = TREE_STRING_LENGTH (src) - 1;\n   ptr = TREE_STRING_POINTER (src);\n \n-  if (!offset_node)\n-    offset = 0;\n-  else if (TREE_CODE (offset_node) != INTEGER_CST)\n+  if (offset_node == 0 || !host_integerp (offset_node, 0))\n+    return ptr;\n+\n+  offset = tree_low_cst (offset_node, 0);\n+  if (offset < 0 || offset > max)\n     return 0;\n-  else\n-    {\n-      /* Did we get a long long offset?  If so, punt.  */\n-      if (TREE_INT_CST_HIGH (offset_node) != 0)\n-\treturn 0;\n-      offset = TREE_INT_CST_LOW (offset_node);\n-      if (offset < 0 || offset > max)\n-\treturn 0;\n-    }\n \n   return ptr + offset;\n }\n@@ -373,11 +363,11 @@ target_char_cast (cst, p)\n {\n   unsigned HOST_WIDE_INT val, hostval;\n \n-  if (TREE_CODE (cst) != INTEGER_CST\n+  if (!host_integerp (cst, 1)\n       || CHAR_TYPE_SIZE > HOST_BITS_PER_WIDE_INT)\n     return 1;\n \n-  val = TREE_INT_CST_LOW (cst);\n+  val = tree_low_cst (cst, 1);\n   if (CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT)\n     val &= (((unsigned HOST_WIDE_INT) 1) << CHAR_TYPE_SIZE) - 1;\n \n@@ -1014,6 +1004,7 @@ expand_builtin_apply_args_1 ()\n    possibly be used in performing a function call.  The code is\n    moved to the start of the function so the incoming values are\n    saved.  */\n+\n static rtx\n expand_builtin_apply_args ()\n {\n@@ -1265,6 +1256,7 @@ expand_builtin_return (result)\n }\n \n /* Used by expand_builtin_classify_type and fold_builtin_classify_type.  */\n+\n static enum type_class\n type_to_class (type)\n      tree type;\n@@ -1297,6 +1289,7 @@ type_to_class (type)\n   \n /* Expand a call to __builtin_classify_type with arguments found in\n    ARGLIST.  */\n+\n static rtx\n expand_builtin_classify_type (arglist)\n      tree arglist;\n@@ -1307,6 +1300,7 @@ expand_builtin_classify_type (arglist)\n }\n \n /* Expand expression EXP, which is a call to __builtin_constant_p.  */\n+\n static rtx\n expand_builtin_constant_p (exp)\n      tree exp;\n@@ -1333,6 +1327,7 @@ expand_builtin_constant_p (exp)\n    function in-line.  EXP is the expression that is a call to the builtin\n    function; if convenient, the result should be placed in TARGET.\n    SUBTARGET may be used as the target for computing one of EXP's operands.  */\n+\n static rtx\n expand_builtin_mathfn (exp, target, subtarget)\n      tree exp;\n@@ -1789,13 +1784,16 @@ builtin_memcpy_read_str (data, offset, mode)\n {\n   const char *str = (const char *) data;\n \n-  if (offset + GET_MODE_SIZE (mode) > strlen (str) + 1)\n+  if (offset < 0\n+      || ((unsigned HOST_WIDE_INT) offset + GET_MODE_SIZE (mode)\n+\t  > strlen (str) + 1))\n     abort ();  /* Attempt to read past the end of constant string.  */\n \n   return c_readstr (str + offset, mode);\n }\n \n /* Expand a call to the memcpy builtin, with arguments in ARGLIST.  */\n+\n static rtx\n expand_builtin_memcpy (arglist)\n      tree arglist;\n@@ -1810,8 +1808,9 @@ expand_builtin_memcpy (arglist)\n       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n       const char *src_str;\n \n-      int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-      int dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+      unsigned int dest_align\n+\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, src_mem, dest_addr, len_rtx;\n \n       /* If either SRC or DEST is not a pointer type, don't do\n@@ -1953,18 +1952,19 @@ expand_builtin_strncpy (arglist, target, mode)\n       if (tree_int_cst_lt (slen, len))\n \t{\n \t  tree dest = TREE_VALUE (arglist);\n-\t  int dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\t  unsigned int dest_align\n+\t    = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n \t  const char *p = c_getstr (TREE_VALUE (TREE_CHAIN (arglist)));\n \t  rtx dest_mem;\n \n-\t  if (!p || !dest_align || TREE_INT_CST_HIGH (len)\n-\t      || !can_store_by_pieces (TREE_INT_CST_LOW (len),\n+\t  if (!p || dest_align == 0 || !host_integerp (len, 1)\n+\t      || !can_store_by_pieces (tree_low_cst (len, 1),\n \t\t\t\t       builtin_strncpy_read_str,\n \t\t\t\t       (PTR) p, dest_align))\n \t    return 0;\n \n \t  dest_mem = get_memory_rtx (dest);\n-\t  store_by_pieces (dest_mem, TREE_INT_CST_LOW (len),\n+\t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_strncpy_read_str,\n \t\t\t   (PTR) p, dest_align);\n \t  return force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -2012,7 +2012,8 @@ expand_builtin_memset (exp)\n       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n       char c;\n \n-      int dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      unsigned int dest_align\n+\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, dest_addr, len_rtx;\n \n       /* If DEST is not a pointer type, don't do this \n@@ -2028,16 +2029,16 @@ expand_builtin_memset (exp)\n \n       if (c)\n \t{\n-\t  if (TREE_CODE (len) != INTEGER_CST || TREE_INT_CST_HIGH (len))\n+\t  if (!host_integerp (len, 1))\n \t    return 0;\n \t  if (current_function_check_memory_usage\n-\t      || !can_store_by_pieces (TREE_INT_CST_LOW (len),\n+\t      || !can_store_by_pieces (tree_low_cst (len, 1),\n \t\t\t\t       builtin_memset_read_str,\n \t\t\t\t       (PTR) &c, dest_align))\n \t    return 0;\n \n \t  dest_mem = get_memory_rtx (dest);\n-\t  store_by_pieces (dest_mem, TREE_INT_CST_LOW (len),\n+\t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_memset_read_str,\n \t\t\t   (PTR) &c, dest_align);\n \t  return force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -2067,6 +2068,7 @@ expand_builtin_memset (exp)\n \n /* Expand expression EXP, which is a call to the bzero builtin.  Return 0\n    if we failed the caller should emit a normal call.  */\n+\n static rtx\n expand_builtin_bzero (exp)\n      tree exp;\n@@ -2098,10 +2100,12 @@ expand_builtin_bzero (exp)\n }\n \n #ifdef HAVE_cmpstrsi\n+\n /* Expand expression EXP, which is a call to the memcmp or the strcmp builtin.\n    ARGLIST is the argument list for this call.  Return 0 if we failed and the\n    caller should emit a normal call, otherwise try to get the result in\n    TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_memcmp (exp, arglist, target)\n      tree exp;\n@@ -2286,6 +2290,7 @@ expand_builtin_strcmp (exp, target, mode)\n /* Expand expression EXP, which is a call to the strncmp builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_strncmp (exp, target, mode)\n      tree exp;\n@@ -2393,6 +2398,7 @@ expand_builtin_strncmp (exp, target, mode)\n /* Expand expression EXP, which is a call to the strcat builtin.\n    Return 0 if we failed the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_strcat (arglist, target, mode)\n      tree arglist;\n@@ -2422,6 +2428,7 @@ expand_builtin_strcat (arglist, target, mode)\n /* Expand expression EXP, which is a call to the strncat builtin.\n    Return 0 if we failed the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_strncat (arglist, target, mode)\n      tree arglist;\n@@ -2478,6 +2485,7 @@ expand_builtin_strncat (arglist, target, mode)\n /* Expand expression EXP, which is a call to the strspn builtin.\n    Return 0 if we failed the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_strspn (arglist, target, mode)\n      tree arglist;\n@@ -2518,6 +2526,7 @@ expand_builtin_strspn (arglist, target, mode)\n /* Expand expression EXP, which is a call to the strcspn builtin.\n    Return 0 if we failed the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_strcspn (arglist, target, mode)\n      tree arglist;\n@@ -2641,14 +2650,13 @@ expand_builtin_args_info (exp)\n \n   if (arglist != 0)\n     {\n-      tree arg = TREE_VALUE (arglist);\n-      if (TREE_CODE (arg) != INTEGER_CST)\n+      if (!host_integerp (TREE_VALUE (arglist), 0))\n \terror (\"argument of `__builtin_args_info' must be constant\");\n       else\n \t{\n-\t  int wordnum = TREE_INT_CST_LOW (arg);\n+\t  HOST_WIDE_INT wordnum = tree_low_cst (TREE_VALUE (arglist), 0);\n \n-\t  if (wordnum < 0 || wordnum >= nwords || TREE_INT_CST_HIGH (arg))\n+\t  if (wordnum < 0 || wordnum >= nwords)\n \t    error (\"argument of `__builtin_args_info' out of range\");\n \t  else\n \t    return GEN_INT (word_ptr[wordnum]);\n@@ -2675,6 +2683,7 @@ expand_builtin_args_info (exp)\n }\n \n /* Expand ARGLIST, from a call to __builtin_next_arg.  */\n+\n static rtx\n expand_builtin_next_arg (arglist)\n      tree arglist;\n@@ -2769,6 +2778,7 @@ stabilize_va_list (valist, needs_lvalue)\n \n /* The \"standard\" implementation of va_start: just assign `nextarg' to\n    the variable.  */\n+\n void\n std_expand_builtin_va_start (stdarg_p, valist, nextarg)\n      int stdarg_p;\n@@ -2798,6 +2808,7 @@ std_expand_builtin_va_start (stdarg_p, valist, nextarg)\n \n /* Expand ARGLIST, which from a call to __builtin_stdarg_va_start or\n    __builtin_varargs_va_start, depending on STDARG_P.  */\n+\n static rtx\n expand_builtin_va_start (stdarg_p, arglist)\n      int stdarg_p;\n@@ -2847,10 +2858,8 @@ std_expand_builtin_va_arg (valist, type)\n     {\n       /* Small args are padded downward.  */\n \n-      HOST_WIDE_INT adj;\n-      adj = TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_UNIT;\n-      if (rounded_size > align)\n-\tadj = rounded_size;\n+      HOST_WIDE_INT adj\n+\t= rounded_size > align ? rounded_size : int_size_in_bytes (type);\n \n       addr_tree = build (PLUS_EXPR, TREE_TYPE (addr_tree), addr_tree,\n \t\t\t build_int_2 (rounded_size - adj, 0));\n@@ -3022,6 +3031,7 @@ expand_builtin_va_copy (arglist)\n \n /* Expand a call to one of the builtin functions __builtin_frame_address or\n    __builtin_return_address.  */\n+\n static rtx\n expand_builtin_frame_address (exp)\n      tree exp;\n@@ -3035,8 +3045,7 @@ expand_builtin_frame_address (exp)\n   if (arglist == 0)\n     /* Warning about missing arg was already issued.  */\n     return const0_rtx;\n-  else if (TREE_CODE (TREE_VALUE (arglist)) != INTEGER_CST\n-\t   || tree_int_cst_sgn (TREE_VALUE (arglist)) < 0)\n+  else if (! host_integerp (TREE_VALUE (arglist), 1))\n     {\n       if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n \terror (\"invalid arg to `__builtin_frame_address'\");\n@@ -3046,9 +3055,10 @@ expand_builtin_frame_address (exp)\n     }\n   else\n     {\n-      rtx tem = expand_builtin_return_addr (DECL_FUNCTION_CODE (fndecl),\n-\t\t\t\t\t    TREE_INT_CST_LOW (TREE_VALUE (arglist)),\n-\t\t\t\t\t    hard_frame_pointer_rtx);\n+      rtx tem\n+\t= expand_builtin_return_addr (DECL_FUNCTION_CODE (fndecl),\n+\t\t\t\t      tree_low_cst (TREE_VALUE (arglist), 1),\n+\t\t\t\t      hard_frame_pointer_rtx);\n \n       /* Some ports cannot access arbitrary stack frames.  */\n       if (tem == NULL)\n@@ -3264,9 +3274,7 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n   /* Only handle __builtin_expect (test, 0) and\n      __builtin_expect (test, 1).  */\n   if (TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE\n-      && TREE_CODE (arg1) == INTEGER_CST\n-      && (TREE_INT_CST_LOW (arg1) == 0 || TREE_INT_CST_LOW (arg1) == 1)\n-      && TREE_INT_CST_HIGH (arg1) == 0)\n+      && (integer_zerop (arg1) || integer_onep (arg1)))\n     {\n       int j;\n       int num_jumps = 0;\n@@ -3341,7 +3349,7 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n \n \t      /* If the test is expected to fail, reverse the\n \t\t probabilities.  */\n-\t      if (TREE_INT_CST_LOW (arg1) == 0)\n+\t      if (integer_zerop (arg1))\n \t\ttaken = 1 - taken;\n \n \t      /* If we are jumping to the false label, reverse the\n@@ -3366,7 +3374,6 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n \n   return ret;\n }\n-\n \f\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -3791,6 +3798,7 @@ fold_builtin_constant_p (arglist)\n }\n \n /* Fold a call to __builtin_classify_type.  */\n+\n static tree\n fold_builtin_classify_type (arglist)\n      tree arglist;\n@@ -3856,6 +3864,7 @@ build_function_call_expr (fn, arglist)\n    represented as a tree chain of parameters against a specified list\n    of tree_codes.  If the last specifier is a 0, that represents an\n    ellipses, otherwise the last specifier must be a VOID_TYPE.  */\n+\n static int\n validate_arglist VPARAMS ((tree arglist, ...))\n {"}, {"sha": "aba367294d7a7bd1a40581e1f8b901ed3b030eff", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "patch": "@@ -3599,7 +3599,7 @@ alpha_expand_block_move (operands)\n \t  if (mode == TImode)\n \t    {\n \t      data_regs[nregs] = gen_lowpart (DImode, tmp);\n-\t      data_regs[nregs+1] = gen_highpart (DImode, tmp);\n+\t      data_regs[nregs + 1] = gen_highpart (DImode, tmp);\n \t      nregs += 2;\n \t    }\n \t  else\n@@ -3620,7 +3620,7 @@ alpha_expand_block_move (operands)\n       words = bytes / 8;\n \n       for (i = 0; i < words; ++i)\n-\tdata_regs[nregs + i] = gen_reg_rtx(DImode);\n+\tdata_regs[nregs + i] = gen_reg_rtx (DImode);\n \n       for (i = 0; i < words; ++i)\n \temit_move_insn (data_regs[nregs + i],\n@@ -3636,7 +3636,7 @@ alpha_expand_block_move (operands)\n       words = bytes / 4;\n \n       for (i = 0; i < words; ++i)\n-\tdata_regs[nregs + i] = gen_reg_rtx(SImode);\n+\tdata_regs[nregs + i] = gen_reg_rtx (SImode);\n \n       for (i = 0; i < words; ++i)\n \temit_move_insn (data_regs[nregs + i],\n@@ -3652,7 +3652,7 @@ alpha_expand_block_move (operands)\n       words = bytes / 8;\n \n       for (i = 0; i < words+1; ++i)\n-\tdata_regs[nregs + i] = gen_reg_rtx(DImode);\n+\tdata_regs[nregs + i] = gen_reg_rtx (DImode);\n \n       alpha_expand_unaligned_load_words (data_regs + nregs, orig_src,\n \t\t\t\t\t words, ofs);"}, {"sha": "df69e943a5070f55a5492b84c2f3f64e28402f6e", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "patch": "@@ -793,7 +793,7 @@ expensive_function_p (threshold)\n {\n   unsigned int sum = 0;\n   int i;\n-  int limit;\n+  unsigned int limit;\n \n   /* We can not compute accurately for large thresholds due to scaled\n      frequencies.  */"}, {"sha": "10b0d34c3a7efe255c0df486299cdd381872fc47", "filename": "gcc/resource.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "patch": "@@ -891,7 +891,7 @@ mark_target_live_regs (insns, target, res)\n      struct resources *res;\n {\n   int b = -1;\n-  int i;\n+  unsigned int i;\n   struct target_info *tinfo = NULL;\n   rtx insn;\n   rtx jump_insn = 0;\n@@ -949,7 +949,8 @@ mark_target_live_regs (insns, target, res)\n \t  tinfo = (struct target_info *) xmalloc (sizeof (struct target_info));\n \t  tinfo->uid = INSN_UID (target);\n \t  tinfo->block = b;\n-\t  tinfo->next = target_hash_table[INSN_UID (target) % TARGET_HASH_PRIME];\n+\t  tinfo->next\n+\t    = target_hash_table[INSN_UID (target) % TARGET_HASH_PRIME];\n \t  target_hash_table[INSN_UID (target) % TARGET_HASH_PRIME] = tinfo;\n \t}\n     }\n@@ -1061,8 +1062,8 @@ mark_target_live_regs (insns, target, res)\n \t\t    && GET_CODE (XEXP (link, 0)) == REG\n \t\t    && REGNO (XEXP (link, 0)) < FIRST_PSEUDO_REGISTER)\n \t\t  {\n-\t\t    int first_regno = REGNO (XEXP (link, 0));\n-\t\t    int last_regno\n+\t\t    unsigned int first_regno = REGNO (XEXP (link, 0));\n+\t\t    unsigned int last_regno\n \t\t      = (first_regno\n \t\t\t + HARD_REGNO_NREGS (first_regno,\n \t\t\t\t\t     GET_MODE (XEXP (link, 0))));\n@@ -1080,8 +1081,8 @@ mark_target_live_regs (insns, target, res)\n \t\t    && GET_CODE (XEXP (link, 0)) == REG\n \t\t    && REGNO (XEXP (link, 0)) < FIRST_PSEUDO_REGISTER)\n \t\t  {\n-\t\t    int first_regno = REGNO (XEXP (link, 0));\n-\t\t    int last_regno\n+\t\t    unsigned int first_regno = REGNO (XEXP (link, 0));\n+\t\t    unsigned int last_regno\n \t\t      = (first_regno\n \t\t\t + HARD_REGNO_NREGS (first_regno,\n \t\t\t\t\t     GET_MODE (XEXP (link, 0))));"}, {"sha": "556423ef914d639d483cf6a7dcb23dbd3f82605d", "filename": "gcc/sdbout.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197bd5062d27d1299ca63c3e252dc7b75bc1e1f/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=5197bd5062d27d1299ca63c3e252dc7b75bc1e1f", "patch": "@@ -94,10 +94,10 @@ extern tree current_function_decl;\n \n static void sdbout_init\t\t\tPARAMS ((const char *));\n static void sdbout_finish\t\tPARAMS ((const char *));\n-static void sdbout_start_source_file\tPARAMS ((unsigned, const char *));\n-static void sdbout_end_source_file\tPARAMS ((unsigned));\n-static void sdbout_begin_block\t\tPARAMS ((unsigned, unsigned));\n-static void sdbout_end_block\t\tPARAMS ((unsigned, unsigned));\n+static void sdbout_start_source_file\tPARAMS ((unsigned int, const char *));\n+static void sdbout_end_source_file\tPARAMS ((unsigned int));\n+static void sdbout_begin_block\t\tPARAMS ((unsigned int, unsigned int));\n+static void sdbout_end_block\t\tPARAMS ((unsigned int, unsigned int));\n static void sdbout_source_line\t\tPARAMS ((unsigned int, const char *));\n static void sdbout_end_epilogue\t\tPARAMS ((void));\n static void sdbout_global_decl\t\tPARAMS ((tree));\n@@ -263,7 +263,8 @@ do { fprintf (asm_out_file, \"\\t.tag\\t\");\t\\\n \n /* Ensure we don't output a negative line number.  */\n #define MAKE_LINE_SAFE(line)  \\\n-  if (line <= sdb_begin_function_line) line = sdb_begin_function_line + 1\n+  if ((int) line <= sdb_begin_function_line) \\\n+    line = sdb_begin_function_line + 1\n \n /* Perform linker optimization of merging header file definitions together\n    for targets with MIPS_DEBUGGING_INFO defined.  This won't work without a\n@@ -439,7 +440,7 @@ static void\n sdbout_record_type_name (type)\n      tree type;\n {\n-  const char *name = 0;\n+  char *name = 0;\n   int no_name;\n \n   if (KNOWN_TYPE_TAG (type))\n@@ -1606,7 +1607,7 @@ sdbout_source_line (line, filename)\n      const char *filename ATTRIBUTE_UNUSED;\n {\n   /* COFF relative line numbers must be positive.  */\n-  if (line > sdb_begin_function_line)\n+  if ((int) line > sdb_begin_function_line)\n     {\n #ifdef ASM_OUTPUT_SOURCE_LINE\n       ASM_OUTPUT_SOURCE_LINE (asm_out_file, line);"}]}