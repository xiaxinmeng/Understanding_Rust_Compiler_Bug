{"sha": "d2c49530bb30888afa711911c98fc8d9bf6ee380", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJjNDk1MzBiYjMwODg4YWZhNzExOTExYzk4ZmM4ZDliZjZlZTM4MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-06-04T16:42:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-06-04T16:42:23Z"}, "message": "i386.c (min_insn_size, [...]): New functions\n\n\t* i386.c (min_insn_size, k8_avoid_jump_misspredicts): New functions\n\t(ix86_reorg): Use it.\n\t* i386.md (align): New insn pattern.\n\nFrom-SVN: r67446", "tree": {"sha": "aa9aeacad2cb7bb2bf196867a31b18e218904bfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa9aeacad2cb7bb2bf196867a31b18e218904bfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2c49530bb30888afa711911c98fc8d9bf6ee380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c49530bb30888afa711911c98fc8d9bf6ee380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2c49530bb30888afa711911c98fc8d9bf6ee380", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c49530bb30888afa711911c98fc8d9bf6ee380/comments", "author": null, "committer": null, "parents": [{"sha": "05a0e2af5828c599ac6174f2191996cf8138b6b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a0e2af5828c599ac6174f2191996cf8138b6b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05a0e2af5828c599ac6174f2191996cf8138b6b0"}], "stats": {"total": 134, "additions": 134, "deletions": 0}, "files": [{"sha": "96a0ab80a70aea15392522e3df43004bffd1fcc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c49530bb30888afa711911c98fc8d9bf6ee380/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c49530bb30888afa711911c98fc8d9bf6ee380/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2c49530bb30888afa711911c98fc8d9bf6ee380", "patch": "@@ -1,3 +1,9 @@\n+Wed Jun  4 18:39:33 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (min_insn_size, k8_avoid_jump_misspredicts): New functions\n+\t(ix86_reorg): Use it.\n+\t* i386.md (align): New insn pattern.\n+\n 2003-06-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* toplev.c (rest_of_type_compilation): Fix typo."}, {"sha": "c96ac8c68c7d14964b91e9136426d1df3b3c0d63", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c49530bb30888afa711911c98fc8d9bf6ee380/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c49530bb30888afa711911c98fc8d9bf6ee380/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d2c49530bb30888afa711911c98fc8d9bf6ee380", "patch": "@@ -878,6 +878,8 @@ static bool ix86_ms_bitfield_layout_p PARAMS ((tree));\n static tree ix86_handle_struct_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static int extended_reg_mentioned_1 PARAMS ((rtx *, void *));\n static bool ix86_rtx_costs PARAMS ((rtx, int, int, int *));\n+static int min_insn_size PARAMS ((rtx));\n+static void k8_avoid_jump_misspredicts PARAMS ((void));\n \n #if defined (DO_GLOBAL_CTORS_BODY) && defined (HAS_INIT_SECTION)\n static void ix86_svr3_asm_out_constructor PARAMS ((rtx, int));\n@@ -15526,6 +15528,117 @@ x86_function_profiler (file, labelno)\n     }\n }\n \n+/* We don't have exact information about the insn sizes, but we may assume\n+   quite safely that we are informed about all 1 byte insns and memory\n+   address sizes.  This is enought to elliminate unnecesary padding in\n+   99% of cases.  */\n+\n+static int\n+min_insn_size (insn)\n+     rtx insn;\n+{\n+  int l = 0;\n+\n+  if (!INSN_P (insn) || !active_insn_p (insn))\n+    return 0;\n+\n+  /* Discard alignments we've emit and jump instructions.  */\n+  if (GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n+      && XINT (PATTERN (insn), 1) == UNSPECV_ALIGN)\n+    return 0;\n+  if (GET_CODE (insn) == JUMP_INSN\n+      && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+    return 0;\n+\n+  /* Important case - calls are always 5 bytes.\n+     It is common to have many calls in the row.  */\n+  if (GET_CODE (insn) == CALL_INSN\n+      && symbolic_reference_mentioned_p (PATTERN (insn))\n+      && !SIBLING_CALL_P (insn))\n+    return 5;\n+  if (get_attr_length (insn) <= 1)\n+    return 1;\n+\n+  /* For normal instructions we may rely on the sizes of addresses\n+     and the presence of symbol to require 4 bytes of encoding.\n+     This is not the case for jumps where references are PC relative.  */\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    {\n+      l = get_attr_length_address (insn);\n+      if (l < 4 && symbolic_reference_mentioned_p (PATTERN (insn)))\n+\tl = 4;\n+    }\n+  if (l)\n+    return 1+l;\n+  else\n+    return 2;\n+}\n+\n+/* AMD K8 core misspredicts jumps when there are more than 3 jumps in 16 byte\n+   window.  */\n+\n+static void\n+k8_avoid_jump_misspredicts ()\n+{\n+  rtx insn, start = get_insns ();\n+  int nbytes = 0, njumps = 0;\n+  int isjump = 0;\n+\n+  /* Look for all minimal intervals of instructions containing 4 jumps.\n+     The intervals are bounded by START and INSN.  NBYTES is the total\n+     size of instructions in the interval including INSN and not including\n+     START.  When the NBYTES is smaller than 16 bytes, it is possible\n+     that the end of START and INSN ends up in the same 16byte page.\n+\n+     The smallest offset in the page INSN can start is the case where START\n+     ends on the offset 0.  Offset of INSN is then NBYTES - sizeof (INSN).\n+     We add p2align to 16byte window with maxskip 17 - NBYTES + sizeof (INSN).\n+     */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+\n+      nbytes += min_insn_size (insn);\n+      if (rtl_dump_file)\n+        fprintf(stderr,\"Insn %i estimated to %i bytes\\n\",\n+\t\tINSN_UID (insn), min_insn_size (insn));\n+      if ((GET_CODE (insn) == JUMP_INSN\n+\t   && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n+\t  || GET_CODE (insn) == CALL_INSN)\n+\tnjumps++;\n+      else\n+\tcontinue;\n+\n+      while (njumps > 3)\n+\t{\n+\t  start = NEXT_INSN (start);\n+\t  if ((GET_CODE (start) == JUMP_INSN\n+\t       && GET_CODE (PATTERN (start)) != ADDR_VEC\n+\t       && GET_CODE (PATTERN (start)) != ADDR_DIFF_VEC)\n+\t      || GET_CODE (start) == CALL_INSN)\n+\t    njumps--, isjump = 1;\n+\t  else\n+\t    isjump = 0;\n+\t  nbytes -= min_insn_size (start);\n+\t}\n+      if (njumps < 0)\n+\tabort ();\n+      if (rtl_dump_file)\n+        fprintf(stderr,\"Interval %i to %i has %i bytes\\n\",\n+\t\tINSN_UID (start), INSN_UID (insn), nbytes);\n+\n+      if (njumps == 3 && isjump && nbytes < 16)\n+\t{\n+\t  int padsize = 15 - nbytes + min_insn_size (insn);\n+\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Padding insn %i by %i bytes!\\n\", INSN_UID (insn), padsize);\n+          emit_insn_before (gen_align (GEN_INT (padsize)), insn);\n+\t}\n+    }\n+}\n+\n /* Implement machine specific optimizations.  \n    At the moment we implement single transformation: AMD Athlon works faster\n    when RET is not destination of conditional jump or directly preceded\n@@ -15577,6 +15690,7 @@ ix86_reorg ()\n \tdelete_insn (ret);\n       }\n   }\n+  k8_avoid_jump_misspredicts ();\n }\n \n /* Return nonzero when QImode register that must be represented via REX prefix"}, {"sha": "65b54ea9050e64f1d13813beb69bc32938f1ba55", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c49530bb30888afa711911c98fc8d9bf6ee380/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c49530bb30888afa711911c98fc8d9bf6ee380/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d2c49530bb30888afa711911c98fc8d9bf6ee380", "patch": "@@ -126,6 +126,7 @@\n    (UNSPECV_STMXCSR\t\t40)\n    (UNSPECV_FEMMS\t\t46)\n    (UNSPECV_CLFLUSH\t\t57)\n+   (UNSPECV_ALIGN\t\t68)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n@@ -14278,6 +14279,19 @@\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"ppro_uops\" \"one\")])\n \n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"align\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] UNSPECV_ALIGN)]\n+  \"\"\n+{\n+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN\n+  return \".p2align\\t4,,%c0\";\n+#endif\n+}\n+  [(set_attr \"length\" \"16\")])\n+\n (define_expand \"prologue\"\n   [(const_int 1)]\n   \"\""}]}