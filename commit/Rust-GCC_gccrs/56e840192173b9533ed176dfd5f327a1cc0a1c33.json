{"sha": "56e840192173b9533ed176dfd5f327a1cc0a1c33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZlODQwMTkyMTczYjk1MzNlZDE3NmRmZDVmMzI3YTFjYzBhMWMzMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2006-04-01T00:37:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-04-01T00:37:13Z"}, "message": "tree-cfg.c (make_ctrl_stmt_edges, [...]): Merge into...\n\n        * tree-cfg.c (make_ctrl_stmt_edges, make_exit_edges): Merge into...\n        (make_edges): ... here.  Control fallthru creation with a local\n        variable.  Do not play with fake edges.\n        (make_omp_sections_edges): Don't set EDGE_ABNORMAL.\n        (make_goto_expr_edges): Don't play with fake edges.  Make for_call\n        a boolean.\n\nFrom-SVN: r112603", "tree": {"sha": "bf91aa83218e2b3f69301a242b7f11d21ac6d97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf91aa83218e2b3f69301a242b7f11d21ac6d97f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56e840192173b9533ed176dfd5f327a1cc0a1c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e840192173b9533ed176dfd5f327a1cc0a1c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e840192173b9533ed176dfd5f327a1cc0a1c33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e840192173b9533ed176dfd5f327a1cc0a1c33/comments", "author": null, "committer": null, "parents": [{"sha": "0c33762a475087dc1996f79e400c5092863f27bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c33762a475087dc1996f79e400c5092863f27bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c33762a475087dc1996f79e400c5092863f27bf"}], "stats": {"total": 254, "additions": 102, "deletions": 152}, "files": [{"sha": "7f383beea2543262e9e611363cf07675ec99ac9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e840192173b9533ed176dfd5f327a1cc0a1c33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e840192173b9533ed176dfd5f327a1cc0a1c33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56e840192173b9533ed176dfd5f327a1cc0a1c33", "patch": "@@ -1,3 +1,12 @@\n+2004-03-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-cfg.c (make_ctrl_stmt_edges, make_exit_edges): Merge into...\n+\t(make_edges): ... here.  Control fallthru creation with a local\n+\tvariable.  Do not play with fake edges.\n+\t(make_omp_sections_edges): Don't set EDGE_ABNORMAL.\n+\t(make_goto_expr_edges): Don't play with fake edges.  Make for_call\n+\ta boolean.\n+\n 2006-04-01  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* dwarf2.h (DW64_CIE_ID): Define."}, {"sha": "a62331b56d8ef1761c1c3d9460a6b9cfafc9c000", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 93, "deletions": 152, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e840192173b9533ed176dfd5f327a1cc0a1c33/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e840192173b9533ed176dfd5f327a1cc0a1c33/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=56e840192173b9533ed176dfd5f327a1cc0a1c33", "patch": "@@ -1,5 +1,6 @@\n /* Control flow functions for trees.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -99,11 +100,10 @@ static void factor_computed_gotos (void);\n \n /* Edges.  */\n static void make_edges (void);\n-static void make_ctrl_stmt_edges (basic_block);\n-static void make_exit_edges (basic_block);\n static void make_cond_expr_edges (basic_block);\n static void make_switch_expr_edges (basic_block);\n static void make_goto_expr_edges (basic_block);\n+static void make_omp_sections_edges (basic_block);\n static edge tree_redirect_edge_and_branch (edge, basic_block);\n static edge tree_try_redirect_by_replacing_jump (edge, basic_block);\n static unsigned int split_critical_edges (void);\n@@ -455,30 +455,99 @@ make_edges (void)\n   /* Traverse the basic block array placing edges.  */\n   FOR_EACH_BB (bb)\n     {\n-      tree first = first_stmt (bb);\n       tree last = last_stmt (bb);\n+      bool fallthru;\n \n-      if (first)\n+      if (last)\n \t{\n-\t  /* Edges for statements that always alter flow control.  */\n-\t  if (is_ctrl_stmt (last))\n-\t    make_ctrl_stmt_edges (bb);\n+\t  switch (TREE_CODE (last))\n+\t    {\n+\t    case GOTO_EXPR:\n+\t      make_goto_expr_edges (bb);\n+\t      fallthru = false;\n+\t      break;\n+\t    case RETURN_EXPR:\n+\t      make_edge (bb, EXIT_BLOCK_PTR, 0);\n+\t      fallthru = false;\n+\t      break;\n+\t    case COND_EXPR:\n+\t      make_cond_expr_edges (bb);\n+\t      fallthru = false;\n+\t      break;\n+\t    case SWITCH_EXPR:\n+\t      make_switch_expr_edges (bb);\n+\t      fallthru = false;\n+\t      break;\n+\t    case RESX_EXPR:\n+\t      make_eh_edges (last);\n+\t      fallthru = false;\n+\t      break;\n+\n+\t    case CALL_EXPR:\n+\t      /* If this function receives a nonlocal goto, then we need to\n+\t\t make edges from this call site to all the nonlocal goto\n+\t\t handlers.  */\n+\t      if (TREE_SIDE_EFFECTS (last)\n+\t\t  && current_function_has_nonlocal_label)\n+\t\tmake_goto_expr_edges (bb);\n+\n+\t      /* If this statement has reachable exception handlers, then\n+\t\t create abnormal edges to them.  */\n+\t      make_eh_edges (last);\n+\n+\t      /* Some calls are known not to return.  */\n+\t      fallthru = !(call_expr_flags (last) & ECF_NORETURN);\n+\t      break;\n+\n+\t    case MODIFY_EXPR:\n+\t      if (is_ctrl_altering_stmt (last))\n+\t\t{\n+\t\t  /* A MODIFY_EXPR may have a CALL_EXPR on its RHS and the\n+\t\t     CALL_EXPR may have an abnormal edge.  Search the RHS for\n+\t\t     this case and create any required edges.  */\n+\t\t  tree op = get_call_expr_in (last);\n+\t\t  if (op && TREE_SIDE_EFFECTS (op)\n+\t\t      && current_function_has_nonlocal_label)\n+\t\t    make_goto_expr_edges (bb);\n+\n+\t\t  make_eh_edges (last);\n+\t\t}\n+\t      fallthru = true;\n+\t      break;\n+\n+\t    case OMP_PARALLEL:\n+\t    case OMP_FOR:\n+\t    case OMP_SINGLE:\n+\t    case OMP_MASTER:\n+\t    case OMP_ORDERED:\n+\t    case OMP_CRITICAL:\n+\t    case OMP_SECTION:\n+\t      fallthru = true;\n+\t      break;\n+\n+\t    case OMP_RETURN_EXPR:\n+\t      /* In the case of an OMP_SECTION, we may have already made\n+\t\t an edge in make_omp_sections_edges.  */\n+\t      fallthru = EDGE_COUNT (bb->succs) == 0;\n+\t      break;\n \n-\t  /* Edges for statements that sometimes alter flow control.  */\n-\t  if (is_ctrl_altering_stmt (last))\n-\t    make_exit_edges (bb);\n+\t    case OMP_SECTIONS:\n+\t      make_omp_sections_edges (bb);\n+\t      fallthru = false;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_assert (!stmt_ends_bb_p (last));\n+\t      fallthru = true;\n+\t    }\n \t}\n+      else\n+\tfallthru = true;\n \n-      /* Finally, if no edges were created above, this is a regular\n-\t basic block that only needs a fallthru edge.  */\n-      if (EDGE_COUNT (bb->succs) == 0)\n+      if (fallthru)\n \tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n     }\n \n-  /* We do not care about fake edges, so remove any that the CFG\n-     builder inserted for completeness.  */\n-  remove_fake_exit_edges ();\n-\n   /* Fold COND_EXPR_COND of each COND_EXPR.  */\n   fold_cond_expr_cond ();\n \n@@ -505,7 +574,7 @@ make_omp_sections_edges (basic_block bb)\n     {\n       basic_block start_bb = bb_for_stmt (TREE_VEC_ELT (vec, i));\n       basic_block end_bb = bb_for_stmt (TREE_VEC_ELT (vec, i + 1));\n-      make_edge (bb, start_bb, EDGE_ABNORMAL);\n+      make_edge (bb, start_bb, 0);\n       make_edge (end_bb, exit_bb, EDGE_FALLTHRU);\n     }\n \n@@ -516,130 +585,6 @@ make_omp_sections_edges (basic_block bb)\n   OMP_SECTIONS_SECTIONS (stmt) = NULL_TREE;\n }\n \n-\n-\n-/* Create edges for control statement at basic block BB.  */\n-\n-static void\n-make_ctrl_stmt_edges (basic_block bb)\n-{\n-  tree last = last_stmt (bb);\n-\n-  gcc_assert (last);\n-  switch (TREE_CODE (last))\n-    {\n-    case GOTO_EXPR:\n-      make_goto_expr_edges (bb);\n-      break;\n-\n-    case RETURN_EXPR:\n-      make_edge (bb, EXIT_BLOCK_PTR, 0);\n-      break;\n-\n-    case COND_EXPR:\n-      make_cond_expr_edges (bb);\n-      break;\n-\n-    case SWITCH_EXPR:\n-      make_switch_expr_edges (bb);\n-      break;\n-\n-    case RESX_EXPR:\n-      make_eh_edges (last);\n-      /* Yet another NORETURN hack.  */\n-      if (EDGE_COUNT (bb->succs) == 0)\n-\tmake_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-\n-/* Create exit edges for statements in block BB that alter the flow of\n-   control.  Statements that alter the control flow are 'goto', 'return'\n-   and calls to non-returning functions.  */\n-\n-static void\n-make_exit_edges (basic_block bb)\n-{\n-  tree last = last_stmt (bb), op;\n-\n-  gcc_assert (last);\n-  switch (TREE_CODE (last))\n-    {\n-    case RESX_EXPR:\n-      break;\n-    case CALL_EXPR:\n-      /* If this function receives a nonlocal goto, then we need to\n-\t make edges from this call site to all the nonlocal goto\n-\t handlers.  */\n-      if (TREE_SIDE_EFFECTS (last)\n-\t  && current_function_has_nonlocal_label)\n-\tmake_goto_expr_edges (bb);\n-\n-      /* If this statement has reachable exception handlers, then\n-\t create abnormal edges to them.  */\n-      make_eh_edges (last);\n-\n-      /* Some calls are known not to return.  For such calls we create\n-\t a fake edge.\n-\n-\t We really need to revamp how we build edges so that it's not\n-\t such a bloody pain to avoid creating edges for this case since\n-\t all we do is remove these edges when we're done building the\n-\t CFG.  */\n-      if (call_expr_flags (last) & ECF_NORETURN)\n-\t{\n-\t  make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n-\t  return;\n-\t}\n-\n-      /* Don't forget the fall-thru edge.  */\n-      make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n-      break;\n-\n-    case MODIFY_EXPR:\n-      /* A MODIFY_EXPR may have a CALL_EXPR on its RHS and the CALL_EXPR\n-\t may have an abnormal edge.  Search the RHS for this case and\n-\t create any required edges.  */\n-      op = get_call_expr_in (last);\n-      if (op && TREE_SIDE_EFFECTS (op)\n-\t  && current_function_has_nonlocal_label)\n-\tmake_goto_expr_edges (bb);\n-\n-      make_eh_edges (last);\n-      make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n-      break;\n-\n-    case OMP_PARALLEL:\n-    case OMP_FOR:\n-    case OMP_SINGLE:\n-    case OMP_MASTER:\n-    case OMP_ORDERED:\n-    case OMP_CRITICAL:\n-      make_edge (bb, bb->next_bb, EDGE_ABNORMAL);\n-\n-    case OMP_RETURN_EXPR:\n-      if (EDGE_COUNT (bb->succs) == 0)\n-\tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n-      break;\n-\n-    case OMP_SECTIONS:\n-      make_omp_sections_edges (bb);\n-      break;\n-\n-    case OMP_SECTION:\n-      make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-\n /* Create the edges for a COND_EXPR starting at block BB.\n    At this point, both clauses must contain only simple gotos.  */\n \n@@ -887,7 +832,7 @@ make_goto_expr_edges (basic_block bb)\n {\n   tree goto_t;\n   basic_block target_bb;\n-  int for_call;\n+  bool for_call;\n   block_stmt_iterator last = bsi_last (bb);\n \n   goto_t = bsi_stmt (last);\n@@ -896,11 +841,11 @@ make_goto_expr_edges (basic_block bb)\n      CALL_EXPR or MODIFY_EXPR), then the edge is an abnormal edge resulting\n      from a nonlocal goto.  */\n   if (TREE_CODE (goto_t) != GOTO_EXPR)\n-    for_call = 1;\n+    for_call = true;\n   else\n     {\n       tree dest = GOTO_DESTINATION (goto_t);\n-      for_call = 0;\n+      for_call = false;\n \n       /* A GOTO to a local label creates normal edges.  */\n       if (simple_goto_p (goto_t))\n@@ -939,21 +884,17 @@ make_goto_expr_edges (basic_block bb)\n \t  if (\n \t      /* Computed GOTOs.  Make an edge to every label block that has\n \t\t been marked as a potential target for a computed goto.  */\n-\t      (FORCED_LABEL (LABEL_EXPR_LABEL (target)) && for_call == 0)\n+\t      (FORCED_LABEL (LABEL_EXPR_LABEL (target)) && !for_call)\n \t      /* Nonlocal GOTO target.  Make an edge to every label block\n \t\t that has been marked as a potential target for a nonlocal\n \t\t goto.  */\n-\t      || (DECL_NONLOCAL (LABEL_EXPR_LABEL (target)) && for_call == 1))\n+\t      || (DECL_NONLOCAL (LABEL_EXPR_LABEL (target)) && for_call))\n \t    {\n \t      make_edge (bb, target_bb, EDGE_ABNORMAL);\n \t      break;\n \t    }\n \t}\n     }\n-\n-  /* Degenerate case of computed goto with no labels.  */\n-  if (!for_call && EDGE_COUNT (bb->succs) == 0)\n-    make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n \n "}]}