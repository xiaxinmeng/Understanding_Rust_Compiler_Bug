{"sha": "c477a66743648570f3a768e49723b5c2f8bc7633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ3N2E2Njc0MzY0ODU3MGYzYTc2OGU0OTcyM2I1YzJmOGJjNzYzMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-08-03T17:06:24Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-08-03T17:06:24Z"}, "message": "vector.md (VEC_L): Add KFmode and TFmode.\n\n2015-08-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/vector.md (VEC_L): Add KFmode and TFmode.\n\t(VEC_M): Likewise.\n\t(VEC_N): Likewise.\n\t(mov<mode>, VEC_M iterator): Add support for IEEE 128-bit floating\n\tpoint in VSX registers.\n\n\t* config/rs6000/constraints.md (wb constraint): Document unused\n\tw<x> constraint.\n\t(we constraint): Likewise.\n\t(wo constraint): Likewise.\n\t(wp constraint): New constraint for IEEE 128-bit floating point in\n\tVSX registers.\n\t(wq constraint): Likewise.\n\n\t* config/rs6000/predicates.md (easy_fp_constant): Add support for\n\tIEEE 128-bit floating point in VSX registers.\n\t(easy_scalar_constant): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Add new\n\tconstraints (wp, wq) for IEEE 128-bit floating point in VSX\n\tregisters.\n\t(rs6000_init_hard_regno_mode_ok): Likewise.\n\n\t* config/rs6000/vsx.md (VSX_LE_128): Add support for IEEE 128-bit\n\tfloating point in VSX registers.\n\t(VSX_L): Likewise.\n\t(VSX_M): Likewise.\n\t(VSX_M2): Likewise.\n\t(VSm): Likewise.\n\t(VSs): Likewise.\n\t(VSr): Likewise.\n\t(VSa): Likewise.\n\t(VSv): Likewise.\n\t(vsx_le_permute_<mode>): Add support to properly swap bytes for\n\tIEEE 128-bit floating point in VSX registers on little endian.\n\t(vsx_le_undo_permute_<mode>): Likewise.\n\t(vsx_le_perm_load_<mode>): Likewise.\n\t(vsx_le_perm_store_<mode>): Likewise.\n\t(splitters for IEEE 128-bit fp moves): Likewise.\n\n\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add wp and\n\twq constraints.\n\n\t* config/rs6000/altivec.md (VM): Add support for IEEE 128-bit\n\tfloating point in VSX registers.\n\t(VM2): Likewise.\n\n\t* doc/md.text (Machine Constraints): Document wp and wq\n\tconstraints on PowerPC.\n\nFrom-SVN: r226520", "tree": {"sha": "d99d6573e1a5ed43166742853e127b5acb371b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d99d6573e1a5ed43166742853e127b5acb371b73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c477a66743648570f3a768e49723b5c2f8bc7633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c477a66743648570f3a768e49723b5c2f8bc7633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c477a66743648570f3a768e49723b5c2f8bc7633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c477a66743648570f3a768e49723b5c2f8bc7633/comments", "author": null, "committer": null, "parents": [{"sha": "472fd3cce417da0584c30669e300d75a0bcdb3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472fd3cce417da0584c30669e300d75a0bcdb3d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472fd3cce417da0584c30669e300d75a0bcdb3d1"}], "stats": {"total": 296, "additions": 274, "deletions": 22}, "files": [{"sha": "770848af4fa0128e3116b8088634a10cb8fa5c35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -1,3 +1,55 @@\n+2015-08-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/vector.md (VEC_L): Add KFmode and TFmode.\n+\t(VEC_M): Likewise.\n+\t(VEC_N): Likewise.\n+\t(mov<mode>, VEC_M iterator): Add support for IEEE 128-bit floating\n+\tpoint in VSX registers.\n+\n+\t* config/rs6000/constraints.md (wb constraint): Document unused\n+\tw<x> constraint.\n+\t(we constraint): Likewise.\n+\t(wo constraint): Likewise.\n+\t(wp constraint): New constraint for IEEE 128-bit floating point in\n+\tVSX registers.\n+\t(wq constraint): Likewise.\n+\n+\t* config/rs6000/predicates.md (easy_fp_constant): Add support for\n+\tIEEE 128-bit floating point in VSX registers.\n+\t(easy_scalar_constant): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Add new\n+\tconstraints (wp, wq) for IEEE 128-bit floating point in VSX\n+\tregisters.\n+\t(rs6000_init_hard_regno_mode_ok): Likewise.\n+\n+\t* config/rs6000/vsx.md (VSX_LE_128): Add support for IEEE 128-bit\n+\tfloating point in VSX registers.\n+\t(VSX_L): Likewise.\n+\t(VSX_M): Likewise.\n+\t(VSX_M2): Likewise.\n+\t(VSm): Likewise.\n+\t(VSs): Likewise.\n+\t(VSr): Likewise.\n+\t(VSa): Likewise.\n+\t(VSv): Likewise.\n+\t(vsx_le_permute_<mode>): Add support to properly swap bytes for\n+\tIEEE 128-bit floating point in VSX registers on little endian.\n+\t(vsx_le_undo_permute_<mode>): Likewise.\n+\t(vsx_le_perm_load_<mode>): Likewise.\n+\t(vsx_le_perm_store_<mode>): Likewise.\n+\t(splitters for IEEE 128-bit fp moves): Likewise.\n+\n+\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add wp and\n+\twq constraints.\n+\n+\t* config/rs6000/altivec.md (VM): Add support for IEEE 128-bit\n+\tfloating point in VSX registers.\n+\t(VM2): Likewise.\n+\n+\t* doc/md.text (Machine Constraints): Document wp and wq\n+\tconstraints on PowerPC.\n+\n 2015-08-03  Jeff Law  <law@redhat.com>\n \n \tPR middle-end/66314"}, {"sha": "a8ea0fbdfe146a2fbdc8d84960a885c69901a0ab", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -167,10 +167,27 @@\n (define_mode_iterator V [V4SI V8HI V16QI V4SF])\n ;; Vec modes for move/logical/permute ops, include vector types for move not\n ;; otherwise handled by altivec (v2df, v2di, ti)\n-(define_mode_iterator VM [V4SI V8HI V16QI V4SF V2DF V2DI V1TI TI])\n+(define_mode_iterator VM [V4SI\n+\t\t\t  V8HI\n+\t\t\t  V16QI\n+\t\t\t  V4SF\n+\t\t\t  V2DF\n+\t\t\t  V2DI\n+\t\t\t  V1TI\n+\t\t\t  TI\n+\t\t\t  (KF \"FLOAT128_VECTOR_P (KFmode)\")\n+\t\t\t  (TF \"FLOAT128_VECTOR_P (TFmode)\")])\n \n ;; Like VM, except don't do TImode\n-(define_mode_iterator VM2 [V4SI V8HI V16QI V4SF V2DF V2DI V1TI])\n+(define_mode_iterator VM2 [V4SI\n+\t\t\t   V8HI\n+\t\t\t   V16QI\n+\t\t\t   V4SF\n+\t\t\t   V2DF\n+\t\t\t   V2DI\n+\t\t\t   V1TI\n+\t\t\t   (KF \"FLOAT128_VECTOR_P (KFmode)\")\n+\t\t\t   (TF \"FLOAT128_VECTOR_P (TFmode)\")])\n \n (define_mode_attr VI_char [(V2DI \"d\") (V4SI \"w\") (V8HI \"h\") (V16QI \"b\")])\n (define_mode_attr VI_scalar [(V2DI \"DI\") (V4SI \"SI\") (V8HI \"HI\") (V16QI \"QI\")])"}, {"sha": "2b8f4bb6066fbe6aed85e03530ad82818b632e8f", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -56,12 +56,16 @@\n (define_register_constraint \"wa\" \"rs6000_constraints[RS6000_CONSTRAINT_wa]\"\n   \"Any VSX register if the -mvsx option was used or NO_REGS.\")\n \n+;; wb is not currently used\n+\n ;; NOTE: For compatibility, \"wc\" is reserved to represent individual CR bits.\n ;; It is currently used for that purpose in LLVM.\n \n (define_register_constraint \"wd\" \"rs6000_constraints[RS6000_CONSTRAINT_wd]\"\n   \"VSX vector register to hold vector double data or NO_REGS.\")\n \n+;; we is not currently used\n+\n (define_register_constraint \"wf\" \"rs6000_constraints[RS6000_CONSTRAINT_wf]\"\n   \"VSX vector register to hold vector float data or NO_REGS.\")\n \n@@ -93,6 +97,14 @@\n ;; There is a mode_attr that resolves to wm for SDmode and wn for SFmode\n (define_register_constraint \"wn\" \"NO_REGS\" \"No register (NO_REGS).\")\n \n+;; wo is not currently used\n+\n+(define_register_constraint \"wp\" \"rs6000_constraints[RS6000_CONSTRAINT_wp]\"\n+  \"VSX register to use for IEEE 128-bit fp TFmode, or NO_REGS.\")\n+\n+(define_register_constraint \"wq\" \"rs6000_constraints[RS6000_CONSTRAINT_wq]\"\n+  \"VSX register to use for IEEE 128-bit fp KFmode, or NO_REGS.\")\n+\n (define_register_constraint \"wr\" \"rs6000_constraints[RS6000_CONSTRAINT_wr]\"\n   \"General purpose register if 64-bit instructions are enabled or NO_REGS.\")\n "}, {"sha": "5a6bb70c59fbc8c390e11db6533b152ec2ad47a3", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -460,6 +460,8 @@\n \n   switch (mode)\n     {\n+    case KFmode:\n+    case IFmode:\n     case TFmode:\n     case DFmode:\n     case SFmode:\n@@ -486,6 +488,12 @@\n   if (TARGET_PAIRED_FLOAT)\n     return false;\n \n+  /* Because IEEE 128-bit floating point is considered a vector type\n+     in order to pass it in VSX registers, it might use this function\n+     instead of easy_fp_constant.  */\n+  if (FLOAT128_VECTOR_P (mode))\n+    return easy_fp_constant (op, mode);\n+\n   if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n     {\n       if (zero_constant (op, mode))"}, {"sha": "bcd0cd074c10b3fc44bcf8aadd4d6ea9b829eb6d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -2168,6 +2168,8 @@ rs6000_debug_reg_global (void)\n \t   \"wk reg_class = %s\\n\"\n \t   \"wl reg_class = %s\\n\"\n \t   \"wm reg_class = %s\\n\"\n+\t   \"wp reg_class = %s\\n\"\n+\t   \"wq reg_class = %s\\n\"\n \t   \"wr reg_class = %s\\n\"\n \t   \"ws reg_class = %s\\n\"\n \t   \"wt reg_class = %s\\n\"\n@@ -2191,6 +2193,8 @@ rs6000_debug_reg_global (void)\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wk]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wl]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wm]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wp]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wq]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wr]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_ws]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wt]],\n@@ -2857,6 +2861,13 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_LFIWZX)\n     rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;\t/* DImode  */\n \n+  if (TARGET_FLOAT128)\n+    {\n+      rs6000_constraints[RS6000_CONSTRAINT_wq] = VSX_REGS;\t/* KFmode  */\n+      if (rs6000_ieeequad)\n+\trs6000_constraints[RS6000_CONSTRAINT_wp] = VSX_REGS;\t/* TFmode  */\n+    }\n+\n   /* Set up the reload helper and direct move functions.  */\n   if (TARGET_VSX || TARGET_ALTIVEC)\n     {"}, {"sha": "102bbce1525a4ccbeb439f3750ab238ab602490f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -1496,6 +1496,8 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_wk,\t\t/* FPR/VSX register for DFmode direct moves. */\n   RS6000_CONSTRAINT_wl,\t\t/* FPR register for LFIWAX */\n   RS6000_CONSTRAINT_wm,\t\t/* VSX register for direct move */\n+  RS6000_CONSTRAINT_wp,\t\t/* VSX reg for IEEE 128-bit fp TFmode. */\n+  RS6000_CONSTRAINT_wq,\t\t/* VSX reg for IEEE 128-bit fp KFmode.  */\n   RS6000_CONSTRAINT_wr,\t\t/* GPR register if 64-bit  */\n   RS6000_CONSTRAINT_ws,\t\t/* VSX register for DF */\n   RS6000_CONSTRAINT_wt,\t\t/* VSX register for TImode */"}, {"sha": "4a62fbbbdd48ef8274eee91d938312e67a8b871b", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -36,13 +36,14 @@\n (define_mode_iterator VEC_K [V16QI V8HI V4SI V4SF])\n \n ;; Vector logical modes\n-(define_mode_iterator VEC_L [V16QI V8HI V4SI V2DI V4SF V2DF V1TI TI])\n+(define_mode_iterator VEC_L [V16QI V8HI V4SI V2DI V4SF V2DF V1TI TI KF TF])\n \n-;; Vector modes for moves.  Don't do TImode here.\n-(define_mode_iterator VEC_M [V16QI V8HI V4SI V2DI V4SF V2DF V1TI])\n+;; Vector modes for moves.  Don't do TImode or TFmode here, since their\n+;; moves are handled elsewhere.\n+(define_mode_iterator VEC_M [V16QI V8HI V4SI V2DI V4SF V2DF V1TI KF])\n \n ;; Vector modes for types that don't need a realignment under VSX\n-(define_mode_iterator VEC_N [V4SI V4SF V2DI V2DF V1TI])\n+(define_mode_iterator VEC_N [V4SI V4SF V2DI V2DF V1TI KF TF])\n \n ;; Vector comparison modes\n (define_mode_iterator VEC_C [V16QI V8HI V4SI V2DI V4SF V2DF])\n@@ -95,12 +96,19 @@\n {\n   if (can_create_pseudo_p ())\n     {\n-      if (CONSTANT_P (operands[1])\n-\t  && !easy_vector_constant (operands[1], <MODE>mode))\n-\toperands[1] = force_const_mem (<MODE>mode, operands[1]);\n-\n-      else if (!vlogical_operand (operands[0], <MODE>mode)\n-\t       && !vlogical_operand (operands[1], <MODE>mode))\n+      if (CONSTANT_P (operands[1]))\n+\t{\n+\t  if (FLOAT128_VECTOR_P (<MODE>mode))\n+\t    {\n+\t      if (!easy_fp_constant (operands[1], <MODE>mode))\n+\t\toperands[1] = force_const_mem (<MODE>mode, operands[1]);\n+\t    }\n+\t  else if (!easy_vector_constant (operands[1], <MODE>mode))\n+\t    operands[1] = force_const_mem (<MODE>mode, operands[1]);\n+\t}\n+\n+      if (!vlogical_operand (operands[0], <MODE>mode)\n+\t  && !vlogical_operand (operands[1], <MODE>mode))\n \toperands[1] = force_reg (<MODE>mode, operands[1]);\n     }\n   if (!BYTES_BIG_ENDIAN"}, {"sha": "7f366b8d69a033e9276d146190a42aa668f56b35", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 139, "deletions": 4, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -31,6 +31,11 @@\n \t\t\t      V1TI\n \t\t\t      (TI\t\"VECTOR_MEM_VSX_P (TImode)\")])\n \n+;; Mode iterator to handle swapping words on little endian for the 128-bit\n+;; types that goes in a single vector register.\n+(define_mode_iterator VSX_LE_128 [(KF   \"FLOAT128_VECTOR_P (KFmode)\")\n+\t\t\t\t  (TF   \"FLOAT128_VECTOR_P (TFmode)\")])\n+\n ;; Iterator for the 2 32-bit vector types\n (define_mode_iterator VSX_W [V4SF V4SI])\n \n@@ -41,11 +46,31 @@\n (define_mode_iterator VSX_F [V4SF V2DF])\n \n ;; Iterator for logical types supported by VSX\n-(define_mode_iterator VSX_L [V16QI V8HI V4SI V2DI V4SF V2DF V1TI TI])\n+;; Note, IFmode won't actually be used since it isn't a VSX type, but it simplifies\n+;; the code by using 128-bit iterators for floating point.\n+(define_mode_iterator VSX_L [V16QI\n+\t\t\t     V8HI\n+\t\t\t     V4SI\n+\t\t\t     V2DI\n+\t\t\t     V4SF\n+\t\t\t     V2DF\n+\t\t\t     V1TI\n+\t\t\t     TI\n+\t\t\t     (KF\t\"FLOAT128_VECTOR_P (KFmode)\")\n+\t\t\t     (TF\t\"FLOAT128_VECTOR_P (TFmode)\")\n+\t\t\t     (IF\t\"FLOAT128_VECTOR_P (IFmode)\")])\n \n ;; Iterator for memory move.  Handle TImode specially to allow\n ;; it to use gprs as well as vsx registers.\n-(define_mode_iterator VSX_M [V16QI V8HI V4SI V2DI V4SF V2DF V1TI])\n+(define_mode_iterator VSX_M [V16QI\n+\t\t\t     V8HI\n+\t\t\t     V4SI\n+\t\t\t     V2DI\n+\t\t\t     V4SF\n+\t\t\t     V2DF\n+\t\t\t     V1TI\n+\t\t\t     (KF\t\"FLOAT128_VECTOR_P (KFmode)\")\n+\t\t\t     (TF\t\"FLOAT128_VECTOR_P (TFmode)\")])\n \n (define_mode_iterator VSX_M2 [V16QI\n \t\t\t      V8HI\n@@ -54,6 +79,8 @@\n \t\t\t      V4SF\n \t\t\t      V2DF\n \t\t\t      V1TI\n+\t\t\t      (KF\t\"FLOAT128_VECTOR_P (KFmode)\")\n+\t\t\t      (TF\t\"FLOAT128_VECTOR_P (TFmode)\")\n \t\t\t      (TI\t\"TARGET_VSX_TIMODE\")])\n \n ;; Map into the appropriate load/store name based on the type\n@@ -64,6 +91,8 @@\n \t\t\t(V2DF  \"vd2\")\n \t\t\t(V2DI  \"vd2\")\n \t\t\t(DF    \"d\")\n+\t\t\t(TF    \"vd2\")\n+\t\t\t(KF    \"vd2\")\n \t\t\t(V1TI  \"vd2\")\n \t\t\t(TI    \"vd2\")])\n \n@@ -76,6 +105,8 @@\n \t\t\t (V2DI  \"dp\")\n \t\t\t (DF    \"dp\")\n \t\t\t (SF\t\"sp\")\n+\t\t\t (TF    \"dp\")\n+\t\t\t (KF    \"dp\")\n \t\t\t (V1TI  \"dp\")\n \t\t\t (TI    \"dp\")])\n \n@@ -89,6 +120,8 @@\n \t\t\t (DI\t\"wi\")\n \t\t\t (DF    \"ws\")\n \t\t\t (SF\t\"ww\")\n+\t\t\t (TF\t\"wp\")\n+\t\t\t (KF\t\"wq\")\n \t\t\t (V1TI  \"v\")\n \t\t\t (TI    \"wt\")])\n \n@@ -132,7 +165,9 @@\n \t\t\t (DF    \"ws\")\n \t\t\t (SF\t\"ww\")\n \t\t\t (V1TI\t\"wa\")\n-\t\t\t (TI    \"wt\")])\n+\t\t\t (TI    \"wt\")\n+\t\t\t (TF\t\"wp\")\n+\t\t\t (KF\t\"wq\")])\n \n ;; Same size integer type for floating point data\n (define_mode_attr VSi [(V4SF  \"v4si\")\n@@ -157,7 +192,8 @@\n \t\t\t (V2DI  \"v\")\n \t\t\t (V2DF  \"v\")\n \t\t\t (V1TI  \"v\")\n-\t\t\t (DF    \"s\")])\n+\t\t\t (DF    \"s\")\n+\t\t\t (KF\t\"v\")])\n \n ;; Appropriate type for add ops (and other simple FP ops)\n (define_mode_attr VStype_simple\t[(V2DF \"vecdouble\")\n@@ -623,6 +659,105 @@\n                      (const_int 6) (const_int 7)])))]\n   \"\")\n \n+;; Little endian word swapping for 128-bit types that are either scalars or the\n+;; special V1TI container class, which it is not appropriate to use vec_select\n+;; for the type.\n+(define_insn \"*vsx_le_permute_<mode>\"\n+  [(set (match_operand:VSX_LE_128 0 \"nonimmediate_operand\" \"=<VSa>,<VSa>,Z\")\n+\t(rotate:VSX_LE_128\n+\t (match_operand:VSX_LE_128 1 \"input_operand\" \"<VSa>,Z,<VSa>\")\n+\t (const_int 64)))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"@\n+   xxpermdi %x0,%x1,%x1,2\n+   lxvd2x %x0,%y1\n+   stxvd2x %x1,%y0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecperm,vecload,vecstore\")])\n+\n+(define_insn_and_split \"*vsx_le_undo_permute_<mode>\"\n+  [(set (match_operand:VSX_LE_128 0 \"vsx_register_operand\" \"=<VSa>,<VSa>\")\n+\t(rotate:VSX_LE_128\n+\t (rotate:VSX_LE_128\n+\t  (match_operand:VSX_LE_128 1 \"vsx_register_operand\" \"0,<VSa>\")\n+\t  (const_int 64))\n+\t (const_int 64)))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"@\n+   #\n+   xxlor %x0,%x1\"\n+  \"\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  if (reload_completed && REGNO (operands[0]) == REGNO (operands[1]))\n+    {\n+      emit_note (NOTE_INSN_DELETED);\n+      DONE;\n+    }\n+}\n+  [(set_attr \"length\" \"0,4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_load_<mode>\"\n+  [(set (match_operand:VSX_LE_128 0 \"vsx_register_operand\" \"=<VSa>\")\n+        (match_operand:VSX_LE_128 1 \"memory_operand\" \"Z\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+\t(rotate:VSX_LE_128 (match_dup 1)\n+\t\t\t   (const_int 64)))\n+   (set (match_dup 0)\n+\t(rotate:VSX_LE_128 (match_dup 2)\n+\t\t\t   (const_int 64)))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n+                                       : operands[0];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecload\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"*vsx_le_perm_store_<mode>\"\n+  [(set (match_operand:VSX_LE_128 0 \"memory_operand\" \"=Z\")\n+        (match_operand:VSX_LE_128 1 \"vsx_register_operand\" \"+<VSa>\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  [(set_attr \"type\" \"vecstore\")\n+   (set_attr \"length\" \"12\")])\n+\n+(define_split\n+  [(set (match_operand:VSX_LE_128 0 \"memory_operand\" \"\")\n+        (match_operand:VSX_LE_128 1 \"vsx_register_operand\" \"\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX && !reload_completed\"\n+  [(set (match_dup 2)\n+\t(rotate:VSX_LE_128 (match_dup 1)\n+\t\t\t   (const_int 64)))\n+   (set (match_dup 0)\n+\t(rotate:VSX_LE_128 (match_dup 2)\n+\t\t\t   (const_int 64)))]\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n+                                       : operands[0];\n+})\n+\n+;; The post-reload split requires that we re-permute the source\n+;; register in case it is still live.\n+(define_split\n+  [(set (match_operand:VSX_LE_128 0 \"memory_operand\" \"\")\n+        (match_operand:VSX_LE_128 1 \"vsx_register_operand\" \"\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX && reload_completed\"\n+  [(set (match_dup 1)\n+\t(rotate:VSX_LE_128 (match_dup 1)\n+\t\t\t   (const_int 64)))\n+   (set (match_dup 0)\n+\t(rotate:VSX_LE_128 (match_dup 1)\n+\t\t\t   (const_int 64)))\n+   (set (match_dup 1)\n+\t(rotate:VSX_LE_128 (match_dup 1)\n+\t\t\t   (const_int 64)))]\n+  \"\")\n \n (define_insn \"*vsx_mov<mode>\"\n   [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ, v\")"}, {"sha": "0bffdc63388a99cc0e9ba81b9a38791c09f3952c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c477a66743648570f3a768e49723b5c2f8bc7633/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=c477a66743648570f3a768e49723b5c2f8bc7633", "patch": "@@ -3087,12 +3087,13 @@ Any VSX register if the -mvsx option was used or NO_REGS.\n \n When using any of the register constraints (@code{wa}, @code{wd},\n @code{wf}, @code{wg}, @code{wh}, @code{wi}, @code{wj}, @code{wk},\n-@code{wl}, @code{wm}, @code{ws}, @code{wt}, @code{wu}, @code{wv},\n-@code{ww}, or @code{wy}) that take VSX registers, you must use\n-@code{%x<n>} in the template so that the correct register is used.\n-Otherwise the register number output in the assembly file will be\n-incorrect if an Altivec register is an operand of a VSX instruction\n-that expects VSX register numbering.\n+@code{wl}, @code{wm}, @code{wp}, @code{wq}, @code{ws}, @code{wt},\n+@code{wu}, @code{wv}, @code{ww}, or @code{wy})\n+that take VSX registers, you must use @code{%x<n>} in the template so\n+that the correct register is used.  Otherwise the register number\n+output in the assembly file will be incorrect if an Altivec register\n+is an operand of a VSX instruction that expects VSX register\n+numbering.\n \n @smallexample\n asm (\"xvadddp %x0,%x1,%x2\" : \"=wa\" (v1) : \"wa\" (v2), \"wa\" (v3));\n@@ -3136,6 +3137,12 @@ VSX register if direct move instructions are enabled, or NO_REGS.\n @item wn\n No register (NO_REGS).\n \n+@item wp\n+VSX register to use for IEEE 128-bit floating point TFmode, or NO_REGS.\n+\n+@item wq\n+VSX register to use for IEEE 128-bit floating point, or NO_REGS.\n+\n @item wr\n General purpose register if 64-bit instructions are enabled or NO_REGS.\n "}]}