{"sha": "896102d0c667780bf95d2766b22ac29c365fd323", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk2MTAyZDBjNjY3NzgwYmY5NWQyNzY2YjIyYWMyOWMzNjVmZDMyMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-31T21:06:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-31T21:06:33Z"}, "message": "(expand_expr, case ADDR_EXPR): Allow taking the address of any object;\n\nused in call-by-reference situations.\n\nFrom-SVN: r3970", "tree": {"sha": "acfb7fb24a2d895ae22b4f5ee5c1a3dd44a519ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acfb7fb24a2d895ae22b4f5ee5c1a3dd44a519ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/896102d0c667780bf95d2766b22ac29c365fd323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896102d0c667780bf95d2766b22ac29c365fd323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896102d0c667780bf95d2766b22ac29c365fd323", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896102d0c667780bf95d2766b22ac29c365fd323/comments", "author": null, "committer": null, "parents": [{"sha": "475dd3b4b88e80fb96e705432da37501b798c99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475dd3b4b88e80fb96e705432da37501b798c99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/475dd3b4b88e80fb96e705432da37501b798c99f"}], "stats": {"total": 24, "additions": 24, "deletions": 0}, "files": [{"sha": "cdaf15f8d1bddc875a7a83ea87ea40a742ad668d", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896102d0c667780bf95d2766b22ac29c365fd323/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896102d0c667780bf95d2766b22ac29c365fd323/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=896102d0c667780bf95d2766b22ac29c365fd323", "patch": "@@ -5184,6 +5184,30 @@ expand_expr (exp, target, tmode, modifier)\n \t  op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode,\n \t\t\t     (modifier == EXPAND_INITIALIZER\n \t\t\t      ? modifier : EXPAND_CONST_ADDRESS));\n+\n+\t  /* We would like the object in memory.  If it is a constant,\n+\t     we can have it be statically allocated into memory.  For\n+\t     a non-constant (REG or SUBREG), we need to allocate some\n+\t     memory and store the value into it.  */\n+\n+\t  if (CONSTANT_P (op0))\n+\t    op0 = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n+\t\t\t\t   op0);\n+\n+\t  if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+\t    {\n+\t      /* If this object is in a register, it must be not\n+\t\t be BLKmode. */\n+\t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t      enum machine_mode inner_mode = TYPE_MODE (inner_type);\n+\t      rtx memloc\n+\t\t= assign_stack_temp (inner_mode,\n+\t\t\t\t     int_size_in_bytes (inner_type), 1);\n+\n+\t      emit_move_insn (memloc, op0);\n+\t      op0 = memloc;\n+\t    }\n+\n \t  if (GET_CODE (op0) != MEM)\n \t    abort ();\n   "}]}