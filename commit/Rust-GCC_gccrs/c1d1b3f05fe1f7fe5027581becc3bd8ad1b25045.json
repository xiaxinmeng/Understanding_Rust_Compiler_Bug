{"sha": "c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFkMWIzZjA1ZmUxZjdmZTUwMjc1ODFiZWNjM2JkOGFkMWIyNTA0NQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-01T11:15:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-01T11:15:59Z"}, "message": "pa.c (symbolic_expression_p): New function.\n\n        * pa.c (symbolic_expression_p): New function.\n        (hppa_legitimize_address): Old LEGITIMIZE_ADDRESS moved\n        here.  Handle symbol_ref + displacement addresses.\n        Use rounding instead of masking off lower bits.\n        Avoid creating useless pseudos and strip off CONST in\n        (const (...)) expressions to make processing easier.\n\nFrom-SVN: r3571", "tree": {"sha": "8cf951e32e0fb67a9c5e8e8910005815aa7e0aae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cf951e32e0fb67a9c5e8e8910005815aa7e0aae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045/comments", "author": null, "committer": null, "parents": [{"sha": "901a8cea7b6185e9fa595756c8cc8cff291ae2b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/901a8cea7b6185e9fa595756c8cc8cff291ae2b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/901a8cea7b6185e9fa595756c8cc8cff291ae2b9"}], "stats": {"total": 151, "additions": 151, "deletions": 0}, "files": [{"sha": "e5cf74fefb9ecbc29a53a9d286f7de9c7173f2ce", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c1d1b3f05fe1f7fe5027581becc3bd8ad1b25045", "patch": "@@ -67,6 +67,21 @@ call_operand_address (op, mode)\n \t  || (CONSTANT_P (op) && ! TARGET_LONG_CALLS));\n }\n \n+/* Return 1 if X contains a symbolic expression.  We know these \n+   expressions will have one of a few well defined forms, so \n+   we need only check those forms.  */\n+int\n+symbolic_expression_p (x)\n+     register rtx x;\n+{\n+\n+  /* Strip off any HIGH. */ \n+  if (GET_CODE (x) == HIGH)\n+    x = XEXP (x, 0);\n+\n+  return (symbolic_operand (x, VOIDmode));\n+}\n+\n int\n symbolic_operand (op, mode)\n      register rtx op;\n@@ -470,6 +485,142 @@ finalize_pic ()\n \n }\n \n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output. \n+\n+   For the PA, transform:\n+\n+\tmemory(X + <large int>)\n+\n+   into:\n+\n+\tif (<large int> & mask) >= 16\n+\t  Y = (<large int> & ~mask) + mask + 1\tRound up.\n+\telse\n+\t  Y = (<large int> & ~mask)\t\tRound down.\n+\tZ = X + Y\n+\tmemory (Z + (<large int> - Y));\n+\n+   This is for CSE to find several similar references, and only use one Z. \n+\n+   X can either be a SYMBOL_REF or REG, but because combine can not\n+   perform a 4->2 combination we do nothing for SYMBOL_REF + D where\n+   D will not fit in 14 bits.\n+\n+   MODE_FLOAT references allow displacements which fit in 5 bits, so use\n+   0x1f as the mask.  \n+\n+   MODE_INT references allow displacements which fit in 14 bits, so use\n+   0x3fff as the mask. \n+\n+   This relies on the fact that most mode MODE_FLOAT references will use FP\n+   registers and most mode MODE_INT references will use integer registers.\n+   (In the rare case of an FP register used in an integer MODE, we depend\n+   on secondary reloads to clean things up.)\n+\n+\n+   It is also beneficial to handle (plus (mult (X) (Y)) (Z)) in a special\n+   manner if Y is 2, 4, or 8.  (allows more shadd insns and shifted indexed\n+   adressing modes to be used).\n+\n+   Put X and Z into registers.  Then put the entire expression into\n+   a register.  */\n+\n+rtx\n+hppa_legitimize_address (x, oldx, mode)\n+     rtx x, oldx;\n+     enum machine_mode mode;\n+{\n+  \n+  rtx orig = x;\n+\n+  /* Strip off CONST. */\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (x, 0)) == REG))\n+    {\n+      rtx int_part, ptr_reg;\n+      int newoffset;\n+      int offset = INTVAL (XEXP (x, 1));\n+      int mask = GET_MODE_CLASS (mode) == MODE_FLOAT ? 0x1f : 0x3fff;\n+\n+      /* Choose which way to round the offset.  Round up if we \n+\t are >= halfway to the next boundary.  */\n+      if ((offset & mask) >= ((mask + 1) / 2))\n+\tnewoffset = (offset & ~ mask) + mask + 1;\n+      else\n+\tnewoffset = (offset & ~ mask);\n+\n+      /* If the newoffset will not fit in 14 bits (ldo), then\n+\t handling this would take 4 or 5 instructions (2 to load\n+\t the SYMBOL_REF + 1 or 2 to load the newoffset + 1 to\n+\t add the new offset and the SYMBOL_REF.)  Combine can\n+\t not handle 4->2 or 5->2 combinations, so do not create\n+\t them.  */\n+      if (! VAL_14_BITS_P (newoffset)\n+\t  && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n+\t{\n+\t  rtx const_part = gen_rtx (CONST, VOIDmode,\n+\t\t\t\t    gen_rtx (PLUS, SImode,\n+\t\t\t\t\t     XEXP (x, 0),\n+\t\t\t\t\t     GEN_INT (newoffset)));\n+\t  rtx tmp_reg\n+\t    = force_reg (SImode,\n+\t\t\t gen_rtx (HIGH, SImode, const_part));\n+\t  ptr_reg\n+\t    = force_reg (SImode,\n+\t\t\t gen_rtx (LO_SUM, SImode,\n+\t\t\t\t  tmp_reg, const_part));\n+\t}\n+      else\n+\t{\n+\t  if (! VAL_14_BITS_P (newoffset))\n+\t    int_part = force_reg (SImode, GEN_INT (newoffset));\n+\t  else\n+\t    int_part = GEN_INT (newoffset);\n+\n+\t  ptr_reg = force_reg (SImode,\n+\t\t\t       gen_rtx (PLUS, SImode,\n+\t\t\t\t\tforce_reg (SImode, XEXP (x, 0)),\n+\t\t\t\t\tint_part));\n+\t}\n+      return plus_constant (ptr_reg, offset - newoffset);\n+    }\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+    {\n+      int val = INTVAL (XEXP (XEXP (x, 0), 1));\n+      rtx reg1, reg2;\n+      reg1 = force_reg (SImode, force_operand (XEXP (x, 1), 0));\n+      reg2 = force_reg (SImode,\n+\t\t\tforce_operand (XEXP (XEXP (x, 0), 0), 0));\n+      return force_reg (SImode,\n+\t\t        gen_rtx (PLUS, SImode,\n+\t\t\t\t gen_rtx (MULT, SImode, reg2,\n+\t\t\t\t\t  GEN_INT (val)),\n+\t\t\t\t reg1));\n+    }\n+  if (flag_pic) \n+    return legitimize_pic_address (x, mode, gen_reg_rtx (Pmode));\n+\n+  return orig;\n+}\n+\n /* For the HPPA, REG and REG+CONST is cost 0\n    and addresses involving symbolic constants are cost 2.\n "}]}