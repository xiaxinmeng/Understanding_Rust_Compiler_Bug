{"sha": "60bd33bcbb75fbe040efe681f81e864a0df2244d", "node_id": "C_kwDOANBUbNoAKDYwYmQzM2JjYmI3NWZiZTA0MGVmZTY4MWY4MWU4NjRhMGRmMjI0NGQ", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-03-07T06:21:23Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-03-10T08:26:06Z"}, "message": "RISC-V: Add fault first load C/C++ support\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv-builtins.cc (riscv_gimple_fold_builtin): New function.\n\t* config/riscv/riscv-protos.h (riscv_gimple_fold_builtin): Ditto.\n\t(gimple_fold_builtin):  Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.cc (class read_vl): New class.\n\t(class vleff): Ditto.\n\t(BASE): Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n\t* config/riscv/riscv-vector-builtins-functions.def (read_vl): Ditto.\n\t(vleff): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.cc (struct read_vl_def): Ditto.\n\t(struct fault_load_def): Ditto.\n\t(SHAPE): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n\t* config/riscv/riscv-vector-builtins.cc\n\t(rvv_arg_type_info::get_tree_type): Add size_ptr.\n\t(gimple_folder::gimple_folder): New class.\n\t(gimple_folder::fold): Ditto.\n\t(gimple_fold_builtin): New function.\n\t(get_read_vl_instance): Ditto.\n\t(get_read_vl_decl): Ditto.\n\t* config/riscv/riscv-vector-builtins.def (size_ptr): Add size_ptr.\n\t* config/riscv/riscv-vector-builtins.h (class gimple_folder): New class.\n\t(get_read_vl_instance): New function.\n\t(get_read_vl_decl):  Ditto.\n\t* config/riscv/riscv-vsetvl.cc (fault_first_load_p): Ditto.\n\t(read_vl_insn_p): Ditto.\n\t(available_occurrence_p): Ditto.\n\t(backward_propagate_worthwhile_p): Ditto.\n\t(gen_vsetvl_pat): Adapt for vleff support.\n\t(get_forward_read_vl_insn): New function.\n\t(get_backward_fault_first_load_insn): Ditto.\n\t(source_equal_p): Adapt for vleff support.\n\t(first_ratio_invalid_for_second_sew_p): Remove.\n\t(first_ratio_invalid_for_second_lmul_p): Ditto.\n\t(first_lmul_less_than_second_lmul_p): Ditto.\n\t(first_ratio_less_than_second_ratio_p): Ditto.\n\t(support_relaxed_compatible_p): New function.\n\t(vector_insn_info::operator>): Remove.\n\t(vector_insn_info::operator>=): Refine.\n\t(vector_insn_info::parse_insn): Adapt for vleff support.\n\t(vector_insn_info::compatible_p): Ditto.\n\t(vector_insn_info::update_fault_first_load_avl): New function.\n\t(pass_vsetvl::transfer_after): Adapt for vleff support.\n\t(pass_vsetvl::demand_fusion): Ditto.\n\t(pass_vsetvl::cleanup_insns): Ditto.\n\t* config/riscv/riscv-vsetvl.def (DEF_INCOMPATIBLE_COND): Remove\n\tredundant condtions.\n\t* config/riscv/riscv-vsetvl.h (struct demands_cond): New function.\n\t* config/riscv/riscv.cc (TARGET_GIMPLE_FOLD_BUILTIN): New target hook.\n\t* config/riscv/riscv.md: Adapt for vleff support.\n\t* config/riscv/t-riscv: Ditto.\n\t* config/riscv/vector-iterators.md: New iterator.\n\t* config/riscv/vector.md (read_vlsi): New pattern.\n\t(read_vldi_zero_extend): Ditto.\n\t(@pred_fault_load<mode>): Ditto.", "tree": {"sha": "e496b9e31f92f26ec2f2c4abea27f403dcb1903c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e496b9e31f92f26ec2f2c4abea27f403dcb1903c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60bd33bcbb75fbe040efe681f81e864a0df2244d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60bd33bcbb75fbe040efe681f81e864a0df2244d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60bd33bcbb75fbe040efe681f81e864a0df2244d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60bd33bcbb75fbe040efe681f81e864a0df2244d/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a803c268c5529624bdb7d02131d4862516a63c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a803c268c5529624bdb7d02131d4862516a63c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a803c268c5529624bdb7d02131d4862516a63c22"}], "stats": {"total": 887, "additions": 575, "deletions": 312}, "files": [{"sha": "b1c4b7547d7086ff8d60768d5664cbcef2ecd68e", "filename": "gcc/config/riscv/riscv-builtins.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -38,6 +38,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"langhooks.h\"\n #include \"tm_p.h\"\n+#include \"backend.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n \n /* Macros to create an enumeration identifier for a function prototype.  */\n #define RISCV_FTYPE_NAME0(A) RISCV_##A##_FTYPE\n@@ -332,6 +335,34 @@ riscv_expand_builtin_direct (enum insn_code icode, rtx target, tree exp,\n   return riscv_expand_builtin_insn (icode, opno, ops, has_target_p);\n }\n \n+/* Implement TARGET_GIMPLE_FOLD_BUILTIN.  */\n+\n+bool\n+riscv_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n+{\n+  gcall *stmt = as_a<gcall *> (gsi_stmt (*gsi));\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  unsigned int code = DECL_MD_FUNCTION_CODE (fndecl);\n+  unsigned int subcode = code >> RISCV_BUILTIN_SHIFT;\n+  gimple *new_stmt = NULL;\n+  switch (code & RISCV_BUILTIN_CLASS)\n+    {\n+    case RISCV_BUILTIN_GENERAL:\n+      new_stmt = NULL;\n+      break;\n+\n+    case RISCV_BUILTIN_VECTOR:\n+      new_stmt = riscv_vector::gimple_fold_builtin (subcode, gsi, stmt);\n+      break;\n+    }\n+\n+  if (!new_stmt)\n+    return false;\n+\n+  gsi_replace (gsi, new_stmt, false);\n+  return true;\n+}\n+\n /* Implement TARGET_EXPAND_BUILTIN.  */\n \n rtx"}, {"sha": "f35aaf35b48d1d733f2f48e2b1e6b237c4507f27", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -85,6 +85,7 @@ void riscv_register_pragmas (void);\n \n /* Routines implemented in riscv-builtins.cc.  */\n extern void riscv_atomic_assign_expand_fenv (tree *, tree *, tree *);\n+extern bool riscv_gimple_fold_builtin (gimple_stmt_iterator *);\n extern rtx riscv_expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern tree riscv_builtin_decl (unsigned int, bool);\n extern void riscv_init_builtins (void);\n@@ -150,6 +151,7 @@ bool verify_type_context (location_t, type_context_kind, const_tree, bool);\n #endif\n void handle_pragma_vector (void);\n tree builtin_decl (unsigned, bool);\n+gimple *gimple_fold_builtin (unsigned int, gimple_stmt_iterator *, gcall *);\n rtx expand_builtin (unsigned int, tree, rtx);\n bool check_builtin_call (location_t, vec<location_t>, unsigned int,\n \t\t\t   tree, unsigned int, tree *);"}, {"sha": "3f0f809c71432d812abf27d8bdba54fd94836932", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -1577,13 +1577,93 @@ class vget : public function_base\n   {\n     rtx src = expand_normal (CALL_EXPR_ARG (e.exp, 0));\n     rtx index = expand_normal (CALL_EXPR_ARG (e.exp, 1));\n-    poly_int64 offset = INTVAL (index) * GET_MODE_SIZE (GET_MODE (src));\n+    poly_int64 offset = INTVAL (index) * GET_MODE_SIZE (GET_MODE (e.target));\n     rtx subreg\n       = simplify_gen_subreg (GET_MODE (e.target), src, GET_MODE (src), offset);\n     return subreg;\n   }\n };\n \n+class read_vl : public function_base\n+{\n+public:\n+  unsigned int call_properties (const function_instance &) const override\n+  {\n+    return CP_READ_CSR;\n+  }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (Pmode == SImode)\n+      emit_insn (gen_read_vlsi (e.target));\n+    else\n+      emit_insn (gen_read_vldi_zero_extend (e.target));\n+    return e.target;\n+  }\n+};\n+\n+class vleff : public function_base\n+{\n+public:\n+  unsigned int call_properties (const function_instance &) const override\n+  {\n+    return CP_READ_MEMORY | CP_WRITE_CSR;\n+  }\n+\n+  gimple *fold (gimple_folder &f) const override\n+  {\n+    /* fold vleff (const *base, size_t *new_vl, size_t vl)\n+\n+       ====> vleff (const *base, size_t vl)\n+\t     new_vl = MEM_REF[read_vl ()].  */\n+\n+    auto_vec<tree> vargs (gimple_call_num_args (f.call) - 1);\n+\n+    for (unsigned i = 0; i < gimple_call_num_args (f.call); i++)\n+      {\n+\t/* Exclude size_t *new_vl argument.  */\n+\tif (i == gimple_call_num_args (f.call) - 2)\n+\t  continue;\n+\n+\tvargs.quick_push (gimple_call_arg (f.call, i));\n+      }\n+\n+    gimple *repl = gimple_build_call_vec (gimple_call_fn (f.call), vargs);\n+    gimple_call_set_lhs (repl, f.lhs);\n+\n+    /* Handle size_t *new_vl by read_vl.  */\n+    tree new_vl = gimple_call_arg (f.call, gimple_call_num_args (f.call) - 2);\n+    if (integer_zerop (new_vl))\n+      {\n+\t/* This case happens when user passes the nullptr to new_vl argument.\n+\t   In this case, we just need to ignore the new_vl argument and return\n+\t   vleff instruction directly. */\n+\treturn repl;\n+      }\n+\n+    tree tmp_var = create_tmp_var (size_type_node, \"new_vl\");\n+    tree decl = get_read_vl_decl ();\n+    gimple *g = gimple_build_call (decl, 0);\n+    gimple_call_set_lhs (g, tmp_var);\n+    tree indirect\n+      = fold_build2 (MEM_REF, size_type_node,\n+\t\t     gimple_call_arg (f.call,\n+\t\t\t\t      gimple_call_num_args (f.call) - 2),\n+\t\t     build_int_cst (build_pointer_type (size_type_node), 0));\n+    gassign *assign = gimple_build_assign (indirect, tmp_var);\n+\n+    gsi_insert_after (f.gsi, assign, GSI_SAME_STMT);\n+    gsi_insert_after (f.gsi, g, GSI_SAME_STMT);\n+    return repl;\n+  }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_contiguous_load_insn (\n+      code_for_pred_fault_load (e.vector_mode ()));\n+  }\n+};\n+\n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vle_obj;\n@@ -1792,6 +1872,8 @@ static CONSTEXPR const vlmul_ext vlmul_ext_obj;\n static CONSTEXPR const vlmul_trunc vlmul_trunc_obj;\n static CONSTEXPR const vset vset_obj;\n static CONSTEXPR const vget vget_obj;\n+static CONSTEXPR const read_vl read_vl_obj;\n+static CONSTEXPR const vleff vleff_obj;\n \n /* Declare the function base NAME, pointing it to an instance\n    of class <NAME>_obj.  */\n@@ -2006,5 +2088,7 @@ BASE (vlmul_ext)\n BASE (vlmul_trunc)\n BASE (vset)\n BASE (vget)\n+BASE (read_vl)\n+BASE (vleff)\n \n } // end namespace riscv_vector"}, {"sha": "14e8a55cd9761066d6b183aa4b95d271ab01b7f2", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -238,6 +238,8 @@ extern const function_base *const vlmul_ext;\n extern const function_base *const vlmul_trunc;\n extern const function_base *const vset;\n extern const function_base *const vget;\n+extern const function_base *const read_vl;\n+extern const function_base *const vleff;\n }\n \n } // end namespace riscv_vector"}, {"sha": "198ccfd86b74c6d795054b8a1cf2383c2aedad4c", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -36,6 +36,9 @@ along with GCC; see the file COPYING3. If not see\n #define DEF_RVV_FUNCTION(NAME, SHAPE, PREDS, OPS_INFO)\n #endif\n \n+/* Internal helper functions for gimple fold use.  */\n+DEF_RVV_FUNCTION (read_vl, read_vl, none_preds, p_none_void_ops)\n+\n /* 6. Configuration-Setting Instructions.  */\n \n DEF_RVV_FUNCTION (vsetvl, vsetvl, none_preds, i_none_size_size_ops)\n@@ -71,7 +74,9 @@ DEF_RVV_FUNCTION (vsoxei16, indexed_loadstore, none_m_preds, all_v_scalar_ptr_ee\n DEF_RVV_FUNCTION (vsoxei32, indexed_loadstore, none_m_preds, all_v_scalar_ptr_eew32_index_ops)\n DEF_RVV_FUNCTION (vsoxei64, indexed_loadstore, none_m_preds, all_v_scalar_ptr_eew64_index_ops)\n \n-// TODO: 7.7. Unit-stride Fault-Only-First Loads\n+// 7.7. Unit-stride Fault-Only-First Loads\n+DEF_RVV_FUNCTION (vleff, fault_load, full_preds, all_v_scalar_const_ptr_size_ptr_ops)\n+\n // TODO: 7.8. Vector Load/Store Segment Instructions\n \n /* 11. Vector Integer Arithmetic Instructions.  */"}, {"sha": "edb0d34b81ce332d35d4303cfe73d5f60b60f17a", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -497,6 +497,62 @@ struct vget_def : public misc_def\n   }\n };\n \n+/* read_vl_def class.  */\n+struct read_vl_def : public function_shape\n+{\n+  void build (function_builder &b,\n+\t      const function_group_info &group) const override\n+  {\n+    auto_vec<tree> argument_types;\n+    b.add_unique_function (get_read_vl_instance (), (*group.shape),\n+\t\t\t   size_type_node, argument_types);\n+  }\n+\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    if (overloaded_p)\n+      return nullptr;\n+    b.append_base_name (instance.base_name);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* fault_load_def class.  */\n+struct fault_load_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    if (overloaded_p)\n+      if (instance.pred == PRED_TYPE_none || instance.pred == PRED_TYPE_mu)\n+\treturn nullptr;\n+    tree type = builtin_types[instance.type.index].vector;\n+    machine_mode mode = TYPE_MODE (type);\n+    int sew = GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n+    b.append_name (\"__riscv_\");\n+    b.append_name (\"vle\");\n+    b.append_sew (sew);\n+    b.append_name (\"ff\");\n+\n+    /* vop<sew>_v --> vop<sew>_v_<type>.  */\n+    if (!overloaded_p)\n+      {\n+\t/* vop<sew> --> vop<sew>_v.  */\n+\tb.append_name (operand_suffixes[instance.op_info->op]);\n+\t/* vop<sew>_v --> vop<sew>_v_<type>.  */\n+\tb.append_name (type_suffixes[instance.type.index].vector);\n+      }\n+\n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n SHAPE(vsetvl, vsetvl)\n SHAPE(vsetvl, vsetvlmax)\n SHAPE(loadstore, loadstore)\n@@ -514,5 +570,7 @@ SHAPE(vundefined, vundefined)\n SHAPE(misc, misc)\n SHAPE(vset, vset)\n SHAPE(vget, vget)\n+SHAPE(read_vl, read_vl)\n+SHAPE(fault_load, fault_load)\n \n } // end namespace riscv_vector"}, {"sha": "30780845f7b6414f62507bf1502b10c585cf24a2", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -41,6 +41,8 @@ extern const function_shape *const vundefined;\n extern const function_shape *const misc;\n extern const function_shape *const vset;\n extern const function_shape *const vget;\n+extern const function_shape *const read_vl;\n+extern const function_shape *const fault_load;\n }\n \n } // end namespace riscv_vector"}, {"sha": "fcda3863576678ad34bfafdb6cd36bb51d09d2fb", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -45,6 +45,9 @@\n #include \"targhooks.h\"\n #include \"regs.h\"\n #include \"emit-rtl.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n #include \"riscv-vector-builtins.h\"\n #include \"riscv-vector-builtins-shapes.h\"\n #include \"riscv-vector-builtins-bases.h\"\n@@ -118,6 +121,9 @@ const char *const predication_suffixes[NUM_PRED_TYPES] = {\n #include \"riscv-vector-builtins.def\"\n };\n \n+/* A list of all signed integer will be registered for intrinsic functions.  */\n+static const rvv_type_info none_ops[] = {{NUM_VECTOR_TYPES, 0}};\n+\n /* A list of all signed integer will be registered for intrinsic functions.  */\n static const rvv_type_info i_ops[] = {\n #define DEF_RVV_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n@@ -384,6 +390,12 @@ static CONSTEXPR const rvv_arg_type_info size_args[]\n static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_args[]\n   = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr), rvv_arg_type_info_end};\n \n+/* A list of args for vector_type func (const scalar_type *, size_t *) function.\n+ */\n+static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_size_ptr_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr),\n+     rvv_arg_type_info (RVV_BASE_size_ptr), rvv_arg_type_info_end};\n+\n /* A list of args for void func (scalar_type *, vector_type) function.  */\n static CONSTEXPR const rvv_arg_type_info scalar_ptr_args[]\n   = {rvv_arg_type_info (RVV_BASE_scalar_ptr),\n@@ -797,6 +809,14 @@ static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      scalar_const_ptr_args /* Args */};\n \n+/* A static operand information for vector_type func (const scalar_type *)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_size_ptr_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_size_ptr_args /* Args */};\n+\n /* A static operand information for void func (scalar_type *, vector_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info all_v_scalar_ptr_ops\n@@ -2103,6 +2123,13 @@ static CONSTEXPR const rvv_op_info all_v_vget_lmul4_x2_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      ext_x2_vget_args /* Args */};\n \n+/* A static operand information for size_t func () function registration. */\n+static CONSTEXPR const rvv_op_info p_none_void_ops\n+  = {none_ops,\t\t\t\t/* Types */\n+     OP_TYPE_none,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_size), /* Return type */\n+     void_args /* Args */};\n+\n /* A list of all RVV base function types.  */\n static CONSTEXPR const function_type_info function_types[] = {\n #define DEF_RVV_TYPE_INDEX(VECTOR, MASK, SIGNED, UNSIGNED, EEW8_INDEX, EEW16_INDEX, \\\n@@ -2155,6 +2182,7 @@ static CONSTEXPR const function_type_info function_types[] = {\n     VECTOR_TYPE_##X16_VLMUL_EXT,                                               \\\n     VECTOR_TYPE_##X32_VLMUL_EXT,                                               \\\n     VECTOR_TYPE_##X64_VLMUL_EXT,                                               \\\n+    VECTOR_TYPE_INVALID,                                                       \\\n   },\n #include \"riscv-vector-builtins.def\"\n }; // namespace riscv_vector\n@@ -2504,7 +2532,7 @@ rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n      satisfy the require extension of the type. For example,\n      vfloat32m1_t require floating-point extension. In this case,\n      just return NULL_TREE.  */\n-  if (!builtin_types[type_idx].vector)\n+  if (type_idx != VECTOR_TYPE_INVALID && !builtin_types[type_idx].vector)\n     return NULL_TREE;\n \n   switch (base_type)\n@@ -2857,6 +2885,32 @@ function_call_info::function_call_info (location_t location_in,\n   : function_instance (instance_in), location (location_in), fndecl (fndecl_in)\n {}\n \n+gimple_folder::gimple_folder (const function_instance &instance, tree fndecl,\n+\t\t\t      gimple_stmt_iterator *gsi_in, gcall *call_in)\n+  : function_call_info (gimple_location (call_in), instance, fndecl),\n+    gsi (gsi_in), call (call_in), lhs (gimple_call_lhs (call_in))\n+{\n+}\n+\n+/* Try to fold the call.  Return the new statement on success and null\n+   on failure.  */\n+gimple *\n+gimple_folder::fold ()\n+{\n+  /* Don't fold anything when RVV is disabled; emit an error during\n+     expansion instead.  */\n+  if (!TARGET_VECTOR)\n+    return NULL;\n+\n+  /* Punt if the function has a return type and no result location is\n+     provided.  The attributes should allow target-independent code to\n+     remove the calls if appropriate.  */\n+  if (!lhs && TREE_TYPE (gimple_call_fntype (call)) != void_type_node)\n+    return NULL;\n+\n+  return base->fold (*this);\n+}\n+\n function_expander::function_expander (const function_instance &instance,\n \t\t\t\t      tree fndecl_in, tree exp_in,\n \t\t\t\t      rtx target_in)\n@@ -3409,6 +3463,16 @@ builtin_decl (unsigned int code, bool)\n   return (*registered_functions)[code]->decl;\n }\n \n+/* Attempt to fold STMT, given that it's a call to the SVE function\n+   with subcode CODE.  Return the new statement on success and null\n+   on failure.  Insert any other new statements at GSI.  */\n+gimple *\n+gimple_fold_builtin (unsigned int code, gimple_stmt_iterator *gsi, gcall *stmt)\n+{\n+  registered_function &rfn = *(*registered_functions)[code];\n+  return gimple_folder (rfn.instance, rfn.decl, gsi, stmt).fold ();\n+}\n+\n /* Expand a call to the RVV function with subcode CODE.  EXP is the call\n    expression and TARGET is the preferred location for the result.\n    Return the value of the lhs.  */\n@@ -3435,6 +3499,23 @@ check_builtin_call (location_t location, vec<location_t>, unsigned int code,\n \t\t\t   TREE_TYPE (rfn.decl), nargs, args).check ();\n }\n \n+function_instance\n+get_read_vl_instance (void)\n+{\n+  return function_instance (\"read_vl\", bases::read_vl, shapes::read_vl,\n+\t\t\t    none_ops[0], PRED_TYPE_none, &p_none_void_ops);\n+}\n+\n+tree\n+get_read_vl_decl (void)\n+{\n+  function_instance instance = get_read_vl_instance ();\n+  hashval_t hash = instance.hash ();\n+  registered_function *rfn = function_table->find_with_hash (instance, hash);\n+  gcc_assert (rfn);\n+  return rfn->decl;\n+}\n+\n } // end namespace riscv_vector\n \n inline void"}, {"sha": "d4a74befd8a47d6e5da48acfdce0eb3505948406", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -375,6 +375,7 @@ DEF_RVV_BASE_TYPE (vlmul_ext_x8, get_vector_type (type_idx))\n DEF_RVV_BASE_TYPE (vlmul_ext_x16, get_vector_type (type_idx))\n DEF_RVV_BASE_TYPE (vlmul_ext_x32, get_vector_type (type_idx))\n DEF_RVV_BASE_TYPE (vlmul_ext_x64, get_vector_type (type_idx))\n+DEF_RVV_BASE_TYPE (size_ptr, build_pointer_type (size_type_node))\n \n #include \"riscv-vector-type-indexer.gen.def\"\n "}, {"sha": "84dfe67677389e76e44d3eef243f6c07eee4c22a", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -315,6 +315,25 @@ function_call_info::function_returns_void_p ()\n   return TREE_TYPE (TREE_TYPE (fndecl)) == void_type_node;\n }\n \n+/* A class for folding a gimple function call.  */\n+class gimple_folder : public function_call_info\n+{\n+public:\n+  gimple_folder (const function_instance &, tree, gimple_stmt_iterator *,\n+\t\t gcall *);\n+\n+  gimple *fold ();\n+\n+  /* Where to insert extra statements that feed the final replacement.  */\n+  gimple_stmt_iterator *gsi;\n+\n+  /* The call we're folding.  */\n+  gcall *call;\n+\n+  /* The result of the call, or null if none.  */\n+  tree lhs;\n+};\n+\n /* A class for expanding a function call into RTL.  */\n class function_expander : public function_call_info\n {\n@@ -390,6 +409,10 @@ class function_base\n   /* Return true if intrinsics has merge operand.  */\n   virtual bool has_merge_operand_p () const;\n \n+  /* Try to fold the given gimple call.  Return the new gimple statement\n+     on success, otherwise return null.  */\n+  virtual gimple *fold (gimple_folder &) const { return NULL; }\n+\n   /* Expand the given call into rtl.  Return the result of the function,\n      or an arbitrary value if the function doesn't return a result.  */\n   virtual rtx expand (function_expander &) const = 0;\n@@ -456,6 +479,8 @@ extern const char *const operand_suffixes[NUM_OP_TYPES];\n extern const rvv_builtin_suffixes type_suffixes[NUM_VECTOR_TYPES + 1];\n extern const char *const predication_suffixes[NUM_PRED_TYPES];\n extern rvv_builtin_types_t builtin_types[NUM_VECTOR_TYPES + 1];\n+extern function_instance get_read_vl_instance (void);\n+extern tree get_read_vl_decl (void);\n \n inline tree\n rvv_arg_type_info::get_scalar_type (vector_type_index type_idx) const"}, {"sha": "159e289ccb99282c51fabe36df9d5a4d68577a6d", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "modified", "additions": 203, "deletions": 120, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -106,8 +106,6 @@ using namespace riscv_vector;\n static CONSTEXPR const unsigned ALL_SEW[] = {8, 16, 32, 64};\n static CONSTEXPR const vlmul_type ALL_LMUL[]\n   = {LMUL_1, LMUL_2, LMUL_4, LMUL_8, LMUL_F8, LMUL_F4, LMUL_F2};\n-static CONSTEXPR const demand_type SEW_LMUL_RELATED_DEMAND[]\n-  = {DEMAND_SEW, DEMAND_LMUL, DEMAND_RATIO, DEMAND_GE_SEW};\n \n DEBUG_FUNCTION void\n debug (const vector_insn_info *info)\n@@ -198,6 +196,20 @@ scalar_move_insn_p (rtx_insn *rinsn)\n \t || get_attr_type (rinsn) == TYPE_VFMOVFV;\n }\n \n+/* Return true if the instruction is fault first load instruction.  */\n+static bool\n+fault_first_load_p (rtx_insn *rinsn)\n+{\n+  return recog_memoized (rinsn) >= 0 && get_attr_type (rinsn) == TYPE_VLDFF;\n+}\n+\n+/* Return true if the instruction is read vl instruction.  */\n+static bool\n+read_vl_insn_p (rtx_insn *rinsn)\n+{\n+  return recog_memoized (rinsn) >= 0 && get_attr_type (rinsn) == TYPE_RDVL;\n+}\n+\n /* Return true if it is a vsetvl instruction.  */\n static bool\n vector_config_insn_p (rtx_insn *rinsn)\n@@ -386,6 +398,8 @@ available_occurrence_p (const bb_info *bb, const vector_insn_info dem)\n \t  for (const insn_info *i = insn; real_insn_and_same_bb_p (i, bb);\n \t       i = i->next_nondebug_insn ())\n \t    {\n+\t      if (read_vl_insn_p (i->rtl ()))\n+\t\tcontinue;\n \t      /* rs1 (avl) are not modified by following statements in\n \t\t the basic block.  */\n \t      if (find_access (i->defs (), REGNO (dem.get_avl ())))\n@@ -400,72 +414,6 @@ available_occurrence_p (const bb_info *bb, const vector_insn_info dem)\n   return true;\n }\n \n-/* Return true if the block is worthwhile backward propagation.  */\n-static bool\n-backward_propagate_worthwhile_p (const basic_block cfg_bb,\n-\t\t\t\t const vector_block_info block_info)\n-{\n-  if (loop_basic_block_p (cfg_bb))\n-    {\n-      if (block_info.reaching_out.valid_or_dirty_p ())\n-\t{\n-\t  if (block_info.local_dem.compatible_p (block_info.reaching_out))\n-\t    {\n-\t      /* Case 1 (Can backward propagate):\n-\t\t ....\n-\t\t bb0:\n-\t\t ...\n-\t\t for (int i = 0; i < n; i++)\n-\t\t   {\n-\t\t     vint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n-\t\t     __riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n-\t\t   }\n-\t\t The local_dem is compatible with reaching_out. Such case is\n-\t\t worthwhile backward propagation.  */\n-\t      return true;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Case 2 (Don't backward propagate):\n-\t\t    ....\n-\t\t    bb0:\n-\t\t    ...\n-\t\t    for (int i = 0; i < n; i++)\n-\t\t      {\n-\t\t\tvint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n-\t\t\t__riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n-\t\t\tvint16mf2_t v2 = __riscv_vle16_v_i16mf2 (in + i + 6, 8);\n-\t\t\t__riscv_vse16_v_i16mf2 (out + i + 6, v, 8);\n-\t\t      }\n-\t\t The local_dem is incompatible with reaching_out.\n-\t\t It makes no sense to backward propagate the local_dem since we\n-\t\t can't avoid VSETVL inside the loop.  */\n-\t      return false;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (block_info.reaching_out.unknown_p ());\n-\t  /* Case 3 (Don't backward propagate):\n-\t\t....\n-\t\tbb0:\n-\t\t...\n-\t\tfor (int i = 0; i < n; i++)\n-\t\t  {\n-\t\t    vint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n-\t\t    __riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n-\t\t    fn3 ();\n-\t\t  }\n-\t    The local_dem is VALID, but the reaching_out is UNKNOWN.\n-\t    It makes no sense to backward propagate the local_dem since we\n-\t    can't avoid VSETVL inside the loop.  */\n-\t  return false;\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n static bool\n insn_should_be_added_p (const insn_info *insn, unsigned int types)\n {\n@@ -688,15 +636,20 @@ static rtx\n gen_vsetvl_pat (rtx_insn *rinsn, const vector_insn_info &info)\n {\n   rtx new_pat;\n+  vl_vtype_info new_info = info;\n+  if (info.get_insn () && info.get_insn ()->rtl ()\n+      && fault_first_load_p (info.get_insn ()->rtl ()))\n+    new_info.set_avl_info (\n+      avl_info (get_avl (info.get_insn ()->rtl ()), nullptr));\n   if (vsetvl_insn_p (rinsn) || vlmax_avl_p (info.get_avl ()))\n     {\n       rtx dest = get_vl (rinsn);\n-      new_pat = gen_vsetvl_pat (VSETVL_NORMAL, info, dest);\n+      new_pat = gen_vsetvl_pat (VSETVL_NORMAL, new_info, dest);\n     }\n   else if (INSN_CODE (rinsn) == CODE_FOR_vsetvl_vtype_change_only)\n-    new_pat = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, info, NULL_RTX);\n+    new_pat = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, new_info, NULL_RTX);\n   else\n-    new_pat = gen_vsetvl_pat (VSETVL_DISCARD_RESULT, info, NULL_RTX);\n+    new_pat = gen_vsetvl_pat (VSETVL_DISCARD_RESULT, new_info, NULL_RTX);\n   return new_pat;\n }\n \n@@ -978,6 +931,36 @@ change_insn (rtx_insn *rinsn, rtx new_pat)\n     }\n }\n \n+static const insn_info *\n+get_forward_read_vl_insn (const insn_info *insn)\n+{\n+  const bb_info *bb = insn->bb ();\n+  for (const insn_info *i = insn->next_nondebug_insn ();\n+       real_insn_and_same_bb_p (i, bb); i = i->next_nondebug_insn ())\n+    {\n+      if (find_access (i->defs (), VL_REGNUM))\n+\treturn nullptr;\n+      if (read_vl_insn_p (i->rtl ()))\n+\treturn i;\n+    }\n+  return nullptr;\n+}\n+\n+static const insn_info *\n+get_backward_fault_first_load_insn (const insn_info *insn)\n+{\n+  const bb_info *bb = insn->bb ();\n+  for (const insn_info *i = insn->prev_nondebug_insn ();\n+       real_insn_and_same_bb_p (i, bb); i = i->prev_nondebug_insn ())\n+    {\n+      if (fault_first_load_p (i->rtl ()))\n+\treturn i;\n+      if (find_access (i->defs (), VL_REGNUM))\n+\treturn nullptr;\n+    }\n+  return nullptr;\n+}\n+\n static bool\n change_insn (function_info *ssa, insn_change change, insn_info *insn,\n \t     rtx new_pat)\n@@ -1083,6 +1066,12 @@ source_equal_p (insn_info *insn1, insn_info *insn2)\n   rtx note2 = find_reg_equal_equiv_note (rinsn2);\n   rtx single_set1 = single_set (rinsn1);\n   rtx single_set2 = single_set (rinsn2);\n+  if (read_vl_insn_p (rinsn1) && read_vl_insn_p (rinsn2))\n+    {\n+      const insn_info *load1 = get_backward_fault_first_load_insn (insn1);\n+      const insn_info *load2 = get_backward_fault_first_load_insn (insn2);\n+      return load1 && load2 && load1 == load2;\n+    }\n \n   if (note1 && note2 && rtx_equal_p (note1, note2))\n     return true;\n@@ -1216,21 +1205,6 @@ possible_zero_avl_p (const vector_insn_info &info1,\n   return !info1.has_non_zero_avl () || !info2.has_non_zero_avl ();\n }\n \n-static bool\n-first_ratio_invalid_for_second_sew_p (const vector_insn_info &info1,\n-\t\t\t\t      const vector_insn_info &info2)\n-{\n-  return calculate_vlmul (info2.get_sew (), info1.get_ratio ())\n-\t == LMUL_RESERVED;\n-}\n-\n-static bool\n-first_ratio_invalid_for_second_lmul_p (const vector_insn_info &info1,\n-\t\t\t\t       const vector_insn_info &info2)\n-{\n-  return calculate_sew (info2.get_vlmul (), info1.get_ratio ()) == 0;\n-}\n-\n static bool\n second_ratio_invalid_for_first_sew_p (const vector_insn_info &info1,\n \t\t\t\t      const vector_insn_info &info2)\n@@ -1314,20 +1288,6 @@ second_lmul_less_than_first_lmul_p (const vector_insn_info &info1,\n   return compare_lmul (info2.get_vlmul (), info1.get_vlmul ()) == -1;\n }\n \n-static bool\n-first_lmul_less_than_second_lmul_p (const vector_insn_info &info1,\n-\t\t\t\t    const vector_insn_info &info2)\n-{\n-  return compare_lmul (info1.get_vlmul (), info2.get_vlmul ()) == -1;\n-}\n-\n-static bool\n-first_ratio_less_than_second_ratio_p (const vector_insn_info &info1,\n-\t\t\t\t      const vector_insn_info &info2)\n-{\n-  return info1.get_ratio () < info2.get_ratio ();\n-}\n-\n static bool\n second_ratio_less_than_first_ratio_p (const vector_insn_info &info1,\n \t\t\t\t      const vector_insn_info &info2)\n@@ -1537,6 +1497,100 @@ reg_available_p (const bb_info *bb, const vector_insn_info &info)\n \t\t\t   insn->bb ()->cfg_bb ());\n }\n \n+/* Return true if the instruction support relaxed compatible check.  */\n+static bool\n+support_relaxed_compatible_p (const vector_insn_info &info1,\n+\t\t\t      const vector_insn_info &info2)\n+{\n+  if (fault_first_load_p (info1.get_insn ()->rtl ())\n+      && info2.demand_p (DEMAND_AVL) && info2.has_avl_reg ()\n+      && info2.get_avl_source () && info2.get_avl_source ()->insn ()->is_phi ())\n+    {\n+      hash_set<set_info *> sets\n+\t= get_all_sets (info2.get_avl_source (), true, false, false);\n+      for (set_info *set : sets)\n+\t{\n+\t  if (read_vl_insn_p (set->insn ()->rtl ()))\n+\t    {\n+\t      const insn_info *insn\n+\t\t= get_backward_fault_first_load_insn (set->insn ());\n+\t      if (insn == info1.get_insn ())\n+\t\treturn info2.compatible_vtype_p (info1);\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return true if the block is worthwhile backward propagation.  */\n+static bool\n+backward_propagate_worthwhile_p (const basic_block cfg_bb,\n+\t\t\t\t const vector_block_info block_info)\n+{\n+  if (loop_basic_block_p (cfg_bb))\n+    {\n+      if (block_info.reaching_out.valid_or_dirty_p ())\n+\t{\n+\t  if (block_info.local_dem.compatible_p (block_info.reaching_out))\n+\t    {\n+\t      /* Case 1 (Can backward propagate):\n+\t\t ....\n+\t\t bb0:\n+\t\t ...\n+\t\t for (int i = 0; i < n; i++)\n+\t\t   {\n+\t\t     vint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n+\t\t     __riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n+\t\t   }\n+\t\t The local_dem is compatible with reaching_out. Such case is\n+\t\t worthwhile backward propagation.  */\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (support_relaxed_compatible_p (block_info.reaching_out,\n+\t\t\t\t\t\tblock_info.local_dem))\n+\t\treturn true;\n+\t      /* Case 2 (Don't backward propagate):\n+\t\t    ....\n+\t\t    bb0:\n+\t\t    ...\n+\t\t    for (int i = 0; i < n; i++)\n+\t\t      {\n+\t\t\tvint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n+\t\t\t__riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n+\t\t\tvint16mf2_t v2 = __riscv_vle16_v_i16mf2 (in + i + 6, 8);\n+\t\t\t__riscv_vse16_v_i16mf2 (out + i + 6, v, 8);\n+\t\t      }\n+\t\t The local_dem is incompatible with reaching_out.\n+\t\t It makes no sense to backward propagate the local_dem since we\n+\t\t can't avoid VSETVL inside the loop.  */\n+\t      return false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (block_info.reaching_out.unknown_p ());\n+\t  /* Case 3 (Don't backward propagate):\n+\t\t....\n+\t\tbb0:\n+\t\t...\n+\t\tfor (int i = 0; i < n; i++)\n+\t\t  {\n+\t\t    vint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n+\t\t    __riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n+\t\t    fn3 ();\n+\t\t  }\n+\t    The local_dem is VALID, but the reaching_out is UNKNOWN.\n+\t    It makes no sense to backward propagate the local_dem since we\n+\t    can't avoid VSETVL inside the loop.  */\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n avl_info::avl_info (const avl_info &other)\n {\n   m_value = other.get_value ();\n@@ -1738,27 +1792,29 @@ vl_vtype_info::same_vlmax_p (const vl_vtype_info &other) const\n    meaning Dem1 is easier be compatible with others than Dem2\n    or Dem2 is stricter than Dem1.\n    For example, Dem1 (demand SEW + LMUL) > Dem2 (demand RATIO).  */\n-bool\n-vector_insn_info::operator> (const vector_insn_info &other) const\n-{\n-  if (other.compatible_p (static_cast<const vl_vtype_info &> (*this))\n-      && !this->compatible_p (static_cast<const vl_vtype_info &> (other)))\n-    return true;\n-  return false;\n-}\n-\n bool\n vector_insn_info::operator>= (const vector_insn_info &other) const\n {\n-  if (*this > other)\n+  if (support_relaxed_compatible_p (*this, other))\n+    {\n+      unsigned array_size = sizeof (unavailable_conds) / sizeof (demands_cond);\n+      /* Bypass AVL unavailable cases.  */\n+      for (unsigned i = 2; i < array_size; i++)\n+\tif (unavailable_conds[i].pair.match_cond_p (this->get_demands (),\n+\t\t\t\t\t\t    other.get_demands ())\n+\t    && unavailable_conds[i].incompatible_p (*this, other))\n+\t  return false;\n+      return true;\n+    }\n+\n+  if (!other.compatible_p (static_cast<const vl_vtype_info &> (*this)))\n+    return false;\n+  if (!this->compatible_p (static_cast<const vl_vtype_info &> (other)))\n     return true;\n \n   if (*this == other)\n     return true;\n \n-  if (!compatible_p (other))\n-    return false;\n-\n   for (const auto &cond : unavailable_conds)\n     if (cond.pair.match_cond_p (this->get_demands (), other.get_demands ())\n \t&& cond.incompatible_p (*this, other))\n@@ -1837,7 +1893,7 @@ vector_insn_info::parse_insn (insn_info *insn)\n \n   /* If this is something that updates VL/VTYPE that we don't know about, set\n      the state to unknown.  */\n-  if (!vector_config_insn_p (insn->rtl ())\n+  if (!vector_config_insn_p (insn->rtl ()) && !has_vtype_op (insn->rtl ())\n       && (find_access (insn->defs (), VL_REGNUM)\n \t  || find_access (insn->defs (), VTYPE_REGNUM)))\n     {\n@@ -1922,8 +1978,7 @@ vector_insn_info::compatible_p (const vector_insn_info &other) const\n \t      && \"Can't compare invalid demanded infos\");\n \n   for (const auto &cond : incompatible_conds)\n-    if (cond.pair.match_cond_p (this->get_demands (), other.get_demands ())\n-\t&& cond.incompatible_p (*this, other))\n+    if (cond.dual_incompatible_p (*this, other))\n       return false;\n   return true;\n }\n@@ -2154,6 +2209,23 @@ vector_insn_info::merge (const vector_insn_info &merge_info,\n   return new_info;\n }\n \n+bool\n+vector_insn_info::update_fault_first_load_avl (insn_info *insn)\n+{\n+  // Update AVL to vl-output of the fault first load.\n+  const insn_info *read_vl = get_forward_read_vl_insn (insn);\n+  if (read_vl)\n+    {\n+      rtx vl = SET_DEST (PATTERN (read_vl->rtl ()));\n+      def_info *def = find_access (read_vl->defs (), REGNO (vl));\n+      set_info *set = safe_dyn_cast<set_info *> (def);\n+      set_avl_info (avl_info (vl, set));\n+      set_insn (insn);\n+      return true;\n+    }\n+  return false;\n+}\n+\n void\n vector_insn_info::dump (FILE *file) const\n {\n@@ -2524,6 +2596,7 @@ class pass_vsetvl : public rtl_opt_pass\n   bool hard_empty_block_p (const bb_info *, const vector_insn_info &) const;\n   bool backward_demand_fusion (void);\n   bool forward_demand_fusion (void);\n+  // bool local_demand_fusion (void);\n   bool cleanup_illegal_dirty_blocks (void);\n   void demand_fusion (void);\n \n@@ -2664,7 +2737,9 @@ pass_vsetvl::transfer_after (vector_insn_info &info, insn_info *insn) const\n       return;\n     }\n \n-  /* TODO: Support fault first load info update VL in the future.  */\n+  if (fault_first_load_p (insn->rtl ())\n+      && info.update_fault_first_load_avl (insn))\n+    return;\n \n   /* If this is something that updates VL/VTYPE that we don't know about, set\n      the state to unknown.  */\n@@ -3303,6 +3378,7 @@ pass_vsetvl::demand_fusion (void)\n \thelp for such cases.  */\n       changed_p |= backward_demand_fusion ();\n       changed_p |= forward_demand_fusion ();\n+      // chanded_p |= local_demand_fusion ();\n     }\n \n   changed_p = true;\n@@ -3840,9 +3916,16 @@ pass_vsetvl::cleanup_insns (void) const\n \t      use_array new_uses = use_array (uses_builder.finish ());\n \t      change.new_uses = new_uses;\n \t      change.move_range = insn->ebb ()->insn_range ();\n-\t      rtx set = single_set (rinsn);\n-\t      rtx src = simplify_replace_rtx (SET_SRC (set), avl, const0_rtx);\n-\t      rtx pat = gen_rtx_SET (SET_DEST (set), src);\n+\t      rtx pat;\n+\t      if (fault_first_load_p (rinsn))\n+\t\tpat = simplify_replace_rtx (PATTERN (rinsn), avl, const0_rtx);\n+\t      else\n+\t\t{\n+\t\t  rtx set = single_set (rinsn);\n+\t\t  rtx src\n+\t\t    = simplify_replace_rtx (SET_SRC (set), avl, const0_rtx);\n+\t\t  pat = gen_rtx_SET (SET_DEST (set), src);\n+\t\t}\n \t      gcc_assert (change_insn (crtl->ssa, change, insn, pat));\n \t    }\n \t}"}, {"sha": "7a73149f1dacba2c54295088cce69691d4e936df", "filename": "gcc/config/riscv/riscv-vsetvl.def", "status": "modified", "additions": 9, "deletions": 180, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.def?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -117,15 +117,6 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n \t\t       /*NONZERO_AVL*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_ANY,\n \t\t       DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ possible_zero_avl_p)\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_TRUE, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ possible_zero_avl_p)\n \n /* Case 8: First SEW/LMUL/GE_SEW <-> Second RATIO/SEW.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n@@ -156,36 +147,7 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ second_sew_less_than_first_sew_p)\n \n-/* Case 9: Second SEW/LMUL/GE_SEW <-> First RATIO/SEW.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ first_ratio_invalid_for_second_sew_p)\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ first_ratio_invalid_for_second_lmul_p)\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ first_sew_less_than_second_sew_p)\n-\n-/* Case 10: First (GE_SEW + LMUL) <-> Second RATIO.  */\n+/* Case 9: First (GE_SEW + LMUL) <-> Second RATIO.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n@@ -236,58 +198,7 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ first_sew_less_than_second_sew_p)\n \n-/* Case 16: Second (GE_SEW + LMUL) <-> First RATIO.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ first_ratio_less_than_second_ratio_p)\n-/* Case 17: Second (SEW + LMUL) <-> First RATIO.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_ratio_p)\n-/* Case 18: Second (GE_SEW/SEW + RATIO) <-> First LMUL.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_lmul_p)\n-/* Case 19: Second (LMUL + RATIO) <-> First SEW.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_sew_p)\n-/* Case 20: Second (LMUL + RATIO) <-> First GE_SEW.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ second_sew_less_than_first_sew_p)\n-\n-/* Case 18: First SEW + Second LMUL <-> First RATIO.  */\n+/* Case 16: First SEW + Second LMUL <-> First RATIO.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n@@ -297,7 +208,7 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ different_lmul_p)\n-/* Case 19: First SEW + Second LMUL <-> Second RATIO.  */\n+/* Case 17: First SEW + Second LMUL <-> Second RATIO.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n@@ -307,28 +218,8 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ different_sew_p)\n-/* Case 20: Second SEW + First LMUL <-> First RATIO.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_sew_p)\n-/* Case 21: Second SEW + First LMUL <-> Second RATIO.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_lmul_p)\n \n-/* Case 22: First SEW + Second RATIO <-> First LMUL.  */\n+/* Case 18: First SEW + Second RATIO <-> First LMUL.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n@@ -338,18 +229,8 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ different_ratio_p)\n-/* Case 23: Second SEW + First RATIO <-> Second LMUL.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_ratio_p)\n \n-/* Case 24: First GE_SEW + Second LMUL <-> First RATIO.  */\n+/* Case 19: First GE_SEW + Second LMUL <-> First RATIO.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n@@ -359,7 +240,7 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ second_lmul_less_than_first_lmul_p)\n-/* Case 25: First GE_SEW + Second LMUL <-> Second RATIO.  */\n+/* Case 20: First GE_SEW + Second LMUL <-> Second RATIO.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n@@ -369,28 +250,8 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ second_sew_less_than_first_sew_p)\n-/* Case 26: Second GE_SEW + First LMUL <-> First RATIO.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ first_sew_less_than_second_sew_p)\n-/* Case 27: Second GE_SEW + First LMUL <-> Second RATIO.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ first_lmul_less_than_second_lmul_p)\n \n-/* Case 28: First GE_SEW + Second RATIO <-> First LMUL.  */\n+/* Case 21: First GE_SEW + Second RATIO <-> First LMUL.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n@@ -400,18 +261,8 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ second_ratio_less_than_first_ratio_p)\n-/* Case 29: Second GE_SEW + First RATIO <-> Second LMUL.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ first_ratio_less_than_second_ratio_p)\n \n-/* Case 31: First GE_SEW + Second SEW + First LMUL + Second ratio.  */\n+/* Case 22: First GE_SEW + Second SEW + First LMUL + Second ratio.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n \t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n@@ -422,7 +273,7 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ different_lmul_p)\n \n-/* Case 32: First GE_SEW + Second SEW + Second LMUL + First ratio.  */\n+/* Case 23: First GE_SEW + Second SEW + Second LMUL + First ratio.  */\n DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n \t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n \t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n@@ -433,28 +284,6 @@ DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n \t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n \t\t       /*COND*/ different_ratio_p)\n \n-/* Case 33: Second GE_SEW + First SEW + First LMUL + Second ratio.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_ratio_p)\n-\n-/* Case 34: Second GE_SEW + First SEW + Second LMUL + First ratio.  */\n-DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n-\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n-\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n-\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n-\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n-\t\t       /*COND*/ different_lmul_p)\n-\n /* Merge rules.  */\n DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n \t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_TRUE,"}, {"sha": "887ff1bdec8f6fb23eb014b8e2497d88762fe8cf", "filename": "gcc/config/riscv/riscv-vsetvl.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -308,7 +308,6 @@ class vector_insn_info : public vl_vtype_info\n      We use RTL_SSA framework to initialize the insn_info.  */\n   void parse_insn (rtl_ssa::insn_info *);\n \n-  bool operator> (const vector_insn_info &) const;\n   bool operator>= (const vector_insn_info &) const;\n   bool operator== (const vector_insn_info &) const;\n \n@@ -392,6 +391,7 @@ class vector_insn_info : public vl_vtype_info\n   {\n     return gen_rtx_REG (Pmode, get_avl_source ()->regno ());\n   }\n+  bool update_fault_first_load_avl (rtl_ssa::insn_info *);\n \n   void dump (FILE *) const;\n };\n@@ -479,6 +479,14 @@ struct demands_cond\n   using CONDITION_TYPE\n     = bool (*) (const vector_insn_info &, const vector_insn_info &);\n   CONDITION_TYPE incompatible_p;\n+  bool dual_incompatible_p (const vector_insn_info &info1,\n+\t\t\t    const vector_insn_info &info2) const\n+  {\n+    return ((pair.match_cond_p (info1.get_demands (), info2.get_demands ())\n+\t     && incompatible_p (info1, info2))\n+\t    || (pair.match_cond_p (info2.get_demands (), info1.get_demands ())\n+\t\t&& incompatible_p (info2, info1)));\n+  }\n };\n \n struct demands_fuse_rule"}, {"sha": "c91fa3101aafa3b0e75406a54b836f321cc78989", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -7081,6 +7081,9 @@ riscv_shamt_matches_mask_p (int shamt, HOST_WIDE_INT mask)\n #undef TARGET_BUILTIN_DECL\n #define TARGET_BUILTIN_DECL riscv_builtin_decl\n \n+#undef TARGET_GIMPLE_FOLD_BUILTIN\n+#define TARGET_GIMPLE_FOLD_BUILTIN riscv_gimple_fold_builtin\n+\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN riscv_expand_builtin\n "}, {"sha": "371d6838c0bd503a270f2aaf23261c7f9a2b1784", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -1363,7 +1363,9 @@\n   [(set (match_operand:DI     0 \"register_operand\"     \"=r,r\")\n \t(zero_extend:DI\n \t    (match_operand:SI 1 \"nonimmediate_operand\" \" r,m\")))]\n-  \"TARGET_64BIT && !TARGET_ZBA\"\n+  \"TARGET_64BIT && !TARGET_ZBA\n+   && !(REG_P (operands[1])\n+        && REGNO (operands[1]) == VL_REGNUM)\"\n   \"@\n    #\n    lwu\\t%0,%1\"\n@@ -1743,7 +1745,9 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r, m,  *f,*f,*r,*m,r\")\n \t(match_operand:SI 1 \"move_operand\"         \" r,T,m,rJ,*r*J,*m,*f,*f,vp\"))]\n   \"(register_operand (operands[0], SImode)\n-    || reg_or_0_operand (operands[1], SImode))\"\n+    || reg_or_0_operand (operands[1], SImode))\n+    && !(register_operand (operands[1], SImode)\n+         && REGNO (operands[1]) == VL_REGNUM)\"\n   { return riscv_output_move (operands[0], operands[1]); }\n   [(set_attr \"move_type\" \"move,const,load,store,mtc,fpload,mfc,fpstore,rdvlenb\")\n    (set_attr \"mode\" \"SI\")"}, {"sha": "394e4e2a67a492bf4b4f91bba07922441951c05c", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -9,7 +9,8 @@ riscv-vector-builtins.o: $(srcdir)/config/riscv/riscv-vector-builtins.cc \\\n   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) $(TM_P_H) \\\n   memmodel.h insn-codes.h $(OPTABS_H) $(RECOG_H) $(DIAGNOSTIC_H) $(EXPR_H) \\\n   $(FUNCTION_H) fold-const.h gimplify.h explow.h stor-layout.h $(REGS_H) \\\n-  alias.h langhooks.h attribs.h stringpool.h emit-rtl.h \\\n+  alias.h langhooks.h attribs.h stringpool.h emit-rtl.h basic-block.h \\\n+  gimple.h gimple-iterator.h \\\n   $(srcdir)/config/riscv/riscv-vector-builtins.h \\\n   $(srcdir)/config/riscv/riscv-vector-builtins-shapes.h \\\n   $(srcdir)/config/riscv/riscv-vector-builtins-bases.h \\"}, {"sha": "d44943ae7c30a2e973eeab9e2fd07bb70b6ad44c", "filename": "gcc/config/riscv/vector-iterators.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -79,6 +79,7 @@\n   UNSPEC_VRGATHER\n   UNSPEC_VRGATHEREI16\n   UNSPEC_VCOMPRESS\n+  UNSPEC_VLEFF\n ])\n \n (define_mode_iterator V ["}, {"sha": "a4a68b67e24f215814626da3f2984b84da8fe895", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bd33bcbb75fbe040efe681f81e864a0df2244d/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=60bd33bcbb75fbe040efe681f81e864a0df2244d", "patch": "@@ -215,7 +215,7 @@\n \t\t\t\tvfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,vfclass,\\\n \t\t\t\tvired,viwred,vfredu,vfredo,vfwredu,vfwredo,vimovxv,vfmovfv,\\\n \t\t\t\tvslideup,vslidedown,vislide1up,vislide1down,vfslide1up,vfslide1down,\\\n-\t\t\t\tvgather\")\n+\t\t\t\tvgather,vldff\")\n \t       (const_int 2)\n \n \t       (eq_attr \"type\" \"vimerge,vfmerge,vcompress\")\n@@ -228,7 +228,7 @@\n ;; The index of operand[] to get the avl op.\n (define_attr \"vl_op_idx\" \"\"\n   (cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vmalu,vsts,vstux,\\\n-\t\t\t  vstox,vext,vmsfs,vmiota,vfsqrt,vfrecp,vfcvtitof,\\\n+\t\t\t  vstox,vext,vmsfs,vmiota,vfsqrt,vfrecp,vfcvtitof,vldff,\\\n \t\t\t  vfcvtftoi,vfwcvtitof,vfwcvtftoi,vfwcvtftof,vfncvtitof,\\\n \t\t\t  vfncvtftoi,vfncvtftof,vfclass,vimovxv,vfmovfv,vcompress\")\n \t   (const_int 4)\n@@ -260,7 +260,7 @@\n   (cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vext,vmiota,vfsqrt,vfrecp,\\\n \t\t\t  vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,vfwcvtftof,\\\n \t\t\t  vfncvtitof,vfncvtftoi,vfncvtftof,vfclass,vimovxv,vfmovfv,\\\n-\t\t\t  vcompress\")\n+\t\t\t  vcompress,vldff\")\n \t   (symbol_ref \"riscv_vector::get_ta(operands[5])\")\n \n \t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n@@ -289,7 +289,7 @@\n (define_attr \"ma\" \"\"\n   (cond [(eq_attr \"type\" \"vlde,vext,vmiota,vfsqrt,vfrecp,vfcvtitof,vfcvtftoi,\\\n \t\t\t  vfwcvtitof,vfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,\\\n-\t\t\t  vfncvtftof,vfclass\")\n+\t\t\t  vfncvtftof,vfclass,vldff\")\n \t   (symbol_ref \"riscv_vector::get_ma(operands[6])\")\n \n \t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n@@ -315,7 +315,7 @@\n \n ;; The avl type value.\n (define_attr \"avl_type\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vext,vimerge,\\\n+  (cond [(eq_attr \"type\" \"vlde,vldff,vste,vimov,vimov,vimov,vfmov,vext,vimerge,\\\n \t\t\t  vfsqrt,vfrecp,vfmerge,vfcvtitof,vfcvtftoi,vfwcvtitof,\\\n \t\t\t  vfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\\\n \t\t\t  vfclass,vired,viwred,vfredu,vfredo,vfwredu,vfwredo,\\\n@@ -6945,3 +6945,46 @@\n   \"vcompress.vm\\t%0,%2,%3\"\n   [(set_attr \"type\" \"vcompress\")\n    (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated Fault-Only-First loads\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 7.7. Unit-stride Fault-Only-First Loads\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"read_vlsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(reg:SI VL_REGNUM))]\n+  \"TARGET_VECTOR\"\n+  \"csrr\\t%0,vl\"\n+  [(set_attr \"type\" \"rdvl\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"read_vldi_zero_extend\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (reg:SI VL_REGNUM)))]\n+  \"TARGET_VECTOR && TARGET_64BIT\"\n+  \"csrr\\t%0,vl\"\n+  [(set_attr \"type\" \"rdvl\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"@pred_fault_load<mode>\"\n+  [(set (match_operand:V 0 \"register_operand\"              \"=vd,    vr\")\n+\t(if_then_else:V\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"   vm,   Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK,    rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i,     i\")\n+\t     (match_operand 6 \"const_int_operand\"        \"    i,     i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"    i,     i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:V\n+\t    [(match_operand:V 3 \"memory_operand\"         \"    m,     m\")] UNSPEC_VLEFF)\n+\t  (match_operand:V 2 \"vector_merge_operand\"      \"  0vu,   0vu\")))\n+   (set (reg:SI VL_REGNUM) (unspec:SI [(match_dup 0)] UNSPEC_VLEFF))]\n+  \"TARGET_VECTOR\"\n+  \"vle<sew>ff.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vldff\")\n+   (set_attr \"mode\" \"<MODE>\")])"}]}