{"sha": "69165332a914f1167c3077fa1f57afc64fd8a667", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkxNjUzMzJhOTE0ZjExNjdjMzA3N2ZhMWY1N2FmYzY0ZmQ4YTY2Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-19T21:24:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-19T21:24:10Z"}, "message": "expr: Fix up constant_byte_string bitfield handling [PR98366]\n\nconstant_byte_string now uses a convert_to_bytes function, which doesn't\nhandle bitfields at all (don't punt on them, just puts them into wrong bits\nor bytes).  Furthermore, I don't see a reason why that function should exist\nat all, it duplicates native_encode_initializer functionality.\nExcept that native_encode_initializer punted on flexible array members and 2\ntests in the testsuite relied on constant_byte_string handling those.\nSo, this patch throws away convert_to_bytes, uses native_encode_initializer\ninstead, but teaches it to handle flexible array members (only in the\nnon-mask mode with off == -1 for now), furthermore, it adds various corner\ncase checks that the old implementation was missing (like that STRING_CSTs\nuse int as length and therefore we shouldn't try to build larger than that\nstrings, or that native_encode*/native_interpret* APIs require sane\nhost and target bytes (8-bit on both).\n\n2020-12-19  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/98366\n\t* fold-const.c (native_encode_initializer): Don't try to\n\tmemset more than total_bytes with off == -1 even if len is large.\n\tHandle flexible array member initializers if off == -1 and mask is\n\tNULL.\n\t* expr.c (convert_to_bytes): Remove.\n\t(constant_byte_string): Use native_encode_initializer instead of\n\tconvert_to_bytes.  Remove extraneous semicolon.  Punt on various\n\tcorner-cases the APIs don't handle, like sizes > INT_MAX,\n\tBITS_PER_UNIT != 8, CHAR_BIT != 8.\n\n\t* gcc.c-torture/execute/pr98366.c: New test.", "tree": {"sha": "39b48d9a3a3ecc7f8913d238dd513dbdbc3a6d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39b48d9a3a3ecc7f8913d238dd513dbdbc3a6d1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69165332a914f1167c3077fa1f57afc64fd8a667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69165332a914f1167c3077fa1f57afc64fd8a667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69165332a914f1167c3077fa1f57afc64fd8a667", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69165332a914f1167c3077fa1f57afc64fd8a667/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e4ddfc5abbf9ee5e657d626264cef89f10b4c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e4ddfc5abbf9ee5e657d626264cef89f10b4c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e4ddfc5abbf9ee5e657d626264cef89f10b4c3"}], "stats": {"total": 226, "additions": 103, "deletions": 123}, "files": [{"sha": "33934d6134dd6aee903870038bda342169afc607", "filename": "gcc/expr.c", "status": "modified", "additions": 38, "deletions": 112, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69165332a914f1167c3077fa1f57afc64fd8a667/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69165332a914f1167c3077fa1f57afc64fd8a667/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=69165332a914f1167c3077fa1f57afc64fd8a667", "patch": "@@ -11631,111 +11631,6 @@ is_aligning_offset (const_tree offset, const_tree exp)\n   return TREE_CODE (offset) == ADDR_EXPR && TREE_OPERAND (offset, 0) == exp;\n }\n \n-/* If EXPR is a constant initializer (either an expression or CONSTRUCTOR),\n-   attempt to obtain its native representation as an array of nonzero BYTES.\n-   Return true on success and false on failure (the latter without modifying\n-   BYTES).  */\n-\n-static bool\n-convert_to_bytes (tree type, tree expr, vec<unsigned char> *bytes)\n-{\n-  if (TREE_CODE (expr) == CONSTRUCTOR)\n-    {\n-      /* Set to the size of the CONSTRUCTOR elements.  */\n-      unsigned HOST_WIDE_INT ctor_size = bytes->length ();\n-\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  tree val, idx;\n-\t  tree eltype = TREE_TYPE (type);\n-\t  unsigned HOST_WIDE_INT elsize =\n-\t    tree_to_uhwi (TYPE_SIZE_UNIT (eltype));\n-\n-\t  /* Jump through hoops to determine the lower bound for languages\n-\t     like Ada that can set it to an (almost) arbitrary value.  */\n-\t  tree dom = TYPE_DOMAIN (type);\n-\t  if (!dom)\n-\t    return false;\n-\t  tree min = TYPE_MIN_VALUE (dom);\n-\t  if (!min || !tree_fits_uhwi_p (min))\n-\t    return false;\n-\t  unsigned HOST_WIDE_INT i, last_idx = tree_to_uhwi (min) - 1;\n-\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, idx, val)\n-\t    {\n-\t      /* Append zeros for elements with no initializers.  */\n-\t      if (!tree_fits_uhwi_p (idx))\n-\t\treturn false;\n-\t      unsigned HOST_WIDE_INT cur_idx = tree_to_uhwi (idx);\n-\t      if (unsigned HOST_WIDE_INT size = cur_idx - (last_idx + 1))\n-\t\t{\n-\t\t  size = size * elsize + bytes->length ();\n-\t\t  bytes->safe_grow_cleared (size, true);\n-\t\t}\n-\n-\t      if (!convert_to_bytes (eltype, val, bytes))\n-\t\treturn false;\n-\n-\t      last_idx = cur_idx;\n-\t    }\n-\t}\n-      else if (TREE_CODE (type) == RECORD_TYPE)\n-\t{\n-\t  tree val, fld;\n-\t  unsigned HOST_WIDE_INT i;\n-\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, fld, val)\n-\t    {\n-\t      /* Append zeros for members with no initializers and\n-\t\t any padding.  */\n-\t      unsigned HOST_WIDE_INT cur_off = int_byte_position (fld);\n-\t      if (bytes->length () < cur_off)\n-\t\tbytes->safe_grow_cleared (cur_off, true);\n-\n-\t      if (!convert_to_bytes (TREE_TYPE (val), val, bytes))\n-\t\treturn false;\n-\t    }\n-\t}\n-      else\n-\treturn false;\n-\n-      /* Compute the size of the COSNTRUCTOR elements.  */\n-      ctor_size = bytes->length () - ctor_size;\n-\n-      /* Append zeros to the byte vector to the full size of the type.\n-\t The type size can be less than the size of the CONSTRUCTOR\n-\t if the latter contains initializers for a flexible array\n-\t member.  */\n-      tree size = TYPE_SIZE_UNIT (type);\n-      unsigned HOST_WIDE_INT type_size = tree_to_uhwi (size);\n-      if (ctor_size < type_size)\n-\tif (unsigned HOST_WIDE_INT size_grow = type_size - ctor_size)\n-\t  bytes->safe_grow_cleared (bytes->length () + size_grow, true);\n-\n-      return true;\n-    }\n-\n-  /* Except for RECORD_TYPE which may have an initialized flexible array\n-     member, the size of a type is the same as the size of the initializer\n-     (including any implicitly zeroed out members and padding).  Allocate\n-     just enough for that many bytes.  */\n-  tree expr_size = TYPE_SIZE_UNIT (TREE_TYPE (expr));\n-  if (!expr_size || !tree_fits_uhwi_p (expr_size))\n-    return false;\n-  const unsigned HOST_WIDE_INT expr_bytes = tree_to_uhwi (expr_size);\n-  const unsigned bytes_sofar = bytes->length ();\n-  /* native_encode_expr can convert at most INT_MAX bytes.  vec is limited\n-     to at most UINT_MAX.  */\n-  if (bytes_sofar + expr_bytes > INT_MAX)\n-    return false;\n-\n-  /* Unlike for RECORD_TYPE, there is no need to clear the memory since\n-     it's completely overwritten by native_encode_expr.  */\n-  bytes->safe_grow (bytes_sofar + expr_bytes, true);\n-  unsigned char *pnext = bytes->begin () + bytes_sofar;\n-  int nbytes = native_encode_expr (expr, pnext, expr_bytes, 0);\n-  /* NBYTES is zero on failure.  Otherwise it should equal EXPR_BYTES.  */\n-  return (unsigned HOST_WIDE_INT) nbytes == expr_bytes;\n-}\n-\n /* Return a STRING_CST corresponding to ARG's constant initializer either\n    if it's a string constant, or, when VALREP is set, any other constant,\n    or null otherwise.\n@@ -11748,7 +11643,7 @@ static tree\n constant_byte_string (tree arg, tree *ptr_offset, tree *mem_size, tree *decl,\n \t\t      bool valrep = false)\n {\n-  tree dummy = NULL_TREE;;\n+  tree dummy = NULL_TREE;\n   if (!mem_size)\n     mem_size = &dummy;\n \n@@ -11903,18 +11798,42 @@ constant_byte_string (tree arg, tree *ptr_offset, tree *mem_size, tree *decl,\n       if (!base_off.is_constant (&cstoff))\n \treturn NULL_TREE;\n \n+      /* Check that the host and target are sane.  */\n+      if (CHAR_BIT != 8 || BITS_PER_UNIT != 8)\n+\treturn NULL_TREE;\n+\n+      HOST_WIDE_INT typesz = int_size_in_bytes (TREE_TYPE (init));\n+      if (typesz <= 0 || (int) typesz != typesz)\n+\treturn NULL_TREE;\n+\n+      HOST_WIDE_INT size = typesz;\n+      if (VAR_P (array)\n+\t  && DECL_SIZE_UNIT (array)\n+\t  && tree_fits_shwi_p (DECL_SIZE_UNIT (array)))\n+\t{\n+\t  size = tree_to_shwi (DECL_SIZE_UNIT (array));\n+\t  gcc_checking_assert (size >= typesz);\n+\t}\n+\n       /* If value representation was requested convert the initializer\n \t for the whole array or object into a string of bytes forming\n \t its value representation and return it.  */\n-      auto_vec<unsigned char> bytes;\n-      if (!convert_to_bytes (TREE_TYPE (init), init, &bytes))\n-\treturn NULL_TREE;\n+      unsigned char *bytes = XNEWVEC (unsigned char, size);\n+      int r = native_encode_initializer (init, bytes, size);\n+      if (r < typesz)\n+\t{\n+\t  XDELETEVEC (bytes);\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (r < size)\n+\tmemset (bytes + r, '\\0', size - r);\n \n-      unsigned n = bytes.length ();\n-      const char *p = reinterpret_cast<const char *>(bytes.address ());\n-      init = build_string_literal (n, p, char_type_node);\n+      const char *p = reinterpret_cast<const char *>(bytes);\n+      init = build_string_literal (size, p, char_type_node);\n       init = TREE_OPERAND (init, 0);\n       init = TREE_OPERAND (init, 0);\n+      XDELETE (bytes);\n \n       *mem_size = size_int (TREE_STRING_LENGTH (init));\n       *ptr_offset = wide_int_to_tree (ssizetype, base_off);\n@@ -11965,6 +11884,10 @@ constant_byte_string (tree arg, tree *ptr_offset, tree *mem_size, tree *decl,\n       && (TREE_CODE (TREE_TYPE (array)) == INTEGER_TYPE\n \t  || TYPE_MAIN_VARIANT (inittype) == char_type_node))\n     {\n+      /* Check that the host and target are sane.  */\n+      if (CHAR_BIT != 8 || BITS_PER_UNIT != 8)\n+\treturn NULL_TREE;\n+\n       /* For a reference to (address of) a single constant character,\n \t store the native representation of the character in CHARBUF.\n \t If the reference is to an element of an array or a member\n@@ -12007,6 +11930,9 @@ constant_byte_string (tree arg, tree *ptr_offset, tree *mem_size, tree *decl,\n \t    initsize = integer_zero_node;\n \n \t  unsigned HOST_WIDE_INT size = tree_to_uhwi (initsize);\n+\t  if (size > (unsigned HOST_WIDE_INT) INT_MAX)\n+\t    return NULL_TREE;\n+\n \t  init = build_string_literal (size, NULL, chartype, size);\n \t  init = TREE_OPERAND (init, 0);\n \t  init = TREE_OPERAND (init, 0);"}, {"sha": "1694ba4554bf2f8c6f9b118f5e353040ce8d96cf", "filename": "gcc/fold-const.c", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69165332a914f1167c3077fa1f57afc64fd8a667/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69165332a914f1167c3077fa1f57afc64fd8a667/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=69165332a914f1167c3077fa1f57afc64fd8a667", "patch": "@@ -8197,7 +8197,7 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \n \t  gcc_assert (TREE_CODE (type) == RECORD_TYPE || mask == NULL);\n \t  if (ptr != NULL)\n-\t    memset (ptr, '\\0', MIN (total_bytes - off, len));\n+\t    memset (ptr, '\\0', MIN (total_bytes - o, len));\n \t  for (cnt = 0; ; cnt++)\n \t    {\n \t      tree val = NULL_TREE, field = NULL_TREE;\n@@ -8266,11 +8266,33 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t\t  && TYPE_DOMAIN (TREE_TYPE (field))\n \t\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))\n-\t\treturn 0;\n-\t      if (DECL_SIZE_UNIT (field) == NULL_TREE\n-\t\t  || !tree_fits_shwi_p (DECL_SIZE_UNIT (field)))\n-\t\treturn 0;\n-\t      fieldsize = tree_to_shwi (DECL_SIZE_UNIT (field));\n+\t\t{\n+\t\t  if (mask || off != -1)\n+\t\t    return 0;\n+\t\t  if (val == NULL_TREE)\n+\t\t    continue;\n+\t\t  if (TREE_CODE (TREE_TYPE (val)) != ARRAY_TYPE)\n+\t\t    return 0;\n+\t\t  fieldsize = int_size_in_bytes (TREE_TYPE (val));\n+\t\t  if (fieldsize < 0\n+\t\t      || (int) fieldsize != fieldsize\n+\t\t      || (pos + fieldsize) > INT_MAX)\n+\t\t    return 0;\n+\t\t  if (pos + fieldsize > total_bytes)\n+\t\t    {\n+\t\t      if (ptr != NULL && total_bytes - o < len)\n+\t\t\tmemset (ptr + (total_bytes - o),\n+\t\t\t\t'\\0', MIN (pos + fieldsize - o, len));\n+\t\t      total_bytes = pos + fieldsize;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (DECL_SIZE_UNIT (field) == NULL_TREE\n+\t\t      || !tree_fits_shwi_p (DECL_SIZE_UNIT (field)))\n+\t\t    return 0;\n+\t\t  fieldsize = tree_to_shwi (DECL_SIZE_UNIT (field));\n+\t\t}\n \t      if (fieldsize == 0)\n \t\tcontinue;\n \n@@ -8439,12 +8461,31 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t  || (pos >= off\n \t\t      && (pos + fieldsize <= (HOST_WIDE_INT) off + len)))\n \t\t{\n-\t\t  if (!native_encode_initializer (val, ptr ? ptr + pos - o\n-\t\t\t\t\t\t\t   : NULL,\n-\t\t\t\t\t\t  fieldsize,\n-\t\t\t\t\t\t  off == -1 ? -1 : 0,\n-\t\t\t\t\t\t  mask ? mask + pos : NULL))\n+\t\t  int fldsize = fieldsize;\n+\t\t  if (off == -1)\n+\t\t    {\n+\t\t      tree fld = DECL_CHAIN (field);\n+\t\t      while (fld)\n+\t\t\t{\n+\t\t\t  if (TREE_CODE (fld) == FIELD_DECL)\n+\t\t\t    break;\n+\t\t\t  fld = DECL_CHAIN (fld);\n+\t\t\t}\n+\t\t      if (fld == NULL_TREE)\n+\t\t\tfldsize = len - pos;\n+\t\t    }\n+\t\t  r = native_encode_initializer (val, ptr ? ptr + pos - o\n+\t\t\t\t\t\t\t  : NULL,\n+\t\t\t\t\t\t fldsize,\n+\t\t\t\t\t\t off == -1 ? -1 : 0,\n+\t\t\t\t\t\t mask ? mask + pos : NULL);\n+\t\t  if (!r)\n \t\t    return 0;\n+\t\t  if (off == -1\n+\t\t      && fldsize != fieldsize\n+\t\t      && r > fieldsize\n+\t\t      && pos + r > total_bytes)\n+\t\t    total_bytes = pos + r;\n \t\t}\n \t      else\n \t\t{"}, {"sha": "14415bfab9f7cac159efc55806ec65ec2990d1f3", "filename": "gcc/testsuite/gcc.c-torture/execute/pr98366.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69165332a914f1167c3077fa1f57afc64fd8a667/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr98366.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69165332a914f1167c3077fa1f57afc64fd8a667/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr98366.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr98366.c?ref=69165332a914f1167c3077fa1f57afc64fd8a667", "patch": "@@ -0,0 +1,13 @@\n+/* PR middle-end/98366 */\n+/* { dg-require-effective-target int32 } */\n+\n+typedef struct S { int a, b, c : 7, d : 8, e : 17; } S;\n+const S f[] = { {0, 3, 4, 2, 0} };\n+\n+int\n+main ()\n+{\n+  if (__builtin_memcmp (f, (S[]){{.b = 3, .c = 4, .d = 2, .e = 0}}, sizeof (S)))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}