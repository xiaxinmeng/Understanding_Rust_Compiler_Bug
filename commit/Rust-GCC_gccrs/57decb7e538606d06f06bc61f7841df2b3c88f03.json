{"sha": "57decb7e538606d06f06bc61f7841df2b3c88f03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkZWNiN2U1Mzg2MDZkMDZmMDZiYzYxZjc4NDFkZjJiM2M4OGYwMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-12-22T19:40:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-12-22T19:40:27Z"}, "message": "tree.c (tree_fold_gcd): Use build_int_cst where appropriate.\n\n2005-12-22  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.c (tree_fold_gcd): Use build_int_cst where appropriate.\n\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Likewise.\n\t* varasm.c (array_size_for_constructor): Likewise.\n\t* fold-const.c (size_diffop, invert_truthvalue,\n\toptimize_bit_field_compare, make_range, build_range_check,\n\tfold_cond_expr_with_comparison, fold_truthop,\n\tfold_single_bit_test_into_sign_test, fold_binary): Likewise.\n\nFrom-SVN: r108970", "tree": {"sha": "c59784926926ac0f42231782ef6431d50f532095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59784926926ac0f42231782ef6431d50f532095"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57decb7e538606d06f06bc61f7841df2b3c88f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57decb7e538606d06f06bc61f7841df2b3c88f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57decb7e538606d06f06bc61f7841df2b3c88f03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57decb7e538606d06f06bc61f7841df2b3c88f03/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42101c23d5c364cd509d8024853e342e4317027d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42101c23d5c364cd509d8024853e342e4317027d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42101c23d5c364cd509d8024853e342e4317027d"}], "stats": {"total": 58, "additions": 34, "deletions": 24}, "files": [{"sha": "161a1c777d6c4aa62352005f248adba1fe7f67f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57decb7e538606d06f06bc61f7841df2b3c88f03", "patch": "@@ -1,3 +1,13 @@\n+2005-12-22  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.c (tree_fold_gcd): Use build_int_cst where appropriate.\n+\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Likewise.\n+\t* varasm.c (array_size_for_constructor): Likewise.\n+\t* fold-const.c (size_diffop, invert_truthvalue,\n+\toptimize_bit_field_compare, make_range, build_range_check,\n+\tfold_cond_expr_with_comparison, fold_truthop,\n+\tfold_single_bit_test_into_sign_test, fold_binary): Likewise.\n+\n 2005-12-22  Dale Johannesen  <dalej@apple.com>\n \n \t* config/i386/sse.md (sse_movhlps):  Reverse operands for"}, {"sha": "eeb20cee40062a0583ee4c622b193d786ea81dc7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=57decb7e538606d06f06bc61f7841df2b3c88f03", "patch": "@@ -1762,11 +1762,11 @@ size_diffop (tree arg0, tree arg1)\n      overflow) and negate (which can't either).  Special-case a result\n      of zero while we're here.  */\n   if (tree_int_cst_equal (arg0, arg1))\n-    return fold_convert (ctype, integer_zero_node);\n+    return build_int_cst (ctype, 0);\n   else if (tree_int_cst_lt (arg1, arg0))\n     return fold_convert (ctype, size_binop (MINUS_EXPR, arg0, arg1));\n   else\n-    return size_binop (MINUS_EXPR, fold_convert (ctype, integer_zero_node),\n+    return size_binop (MINUS_EXPR, build_int_cst (ctype, 0),\n \t\t       fold_convert (ctype, size_binop (MINUS_EXPR,\n \t\t\t\t\t\t\targ1, arg0)));\n }\n@@ -3105,7 +3105,7 @@ invert_truthvalue (tree arg)\n       if (!integer_onep (TREE_OPERAND (arg, 1)))\n \tbreak;\n       return build2 (EQ_EXPR, type, arg,\n-\t\t     fold_convert (type, integer_zero_node));\n+\t\t     build_int_cst (type, 0));\n \n     case SAVE_EXPR:\n       return build1 (TRUTH_NOT_EXPR, type, arg);\n@@ -3383,7 +3383,7 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n   if (lbitsize == 1 && ! integer_zerop (rhs))\n     {\n       code = code == EQ_EXPR ? NE_EXPR : EQ_EXPR;\n-      rhs = fold_convert (type, integer_zero_node);\n+      rhs = build_int_cst (type, 0);\n     }\n \n   /* Make a new bitfield reference, shift the constant over the\n@@ -3720,7 +3720,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n      the switch, which will \"break\" the while.  */\n \n   in_p = 0;\n-  low = high = fold_convert (TREE_TYPE (exp), integer_zero_node);\n+  low = high = build_int_cst (TREE_TYPE (exp), 0);\n \n   while (1)\n     {\n@@ -3793,7 +3793,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t    {\n \t      if (! merge_ranges (&n_in_p, &n_low, &n_high,\n \t\t\t\t  in_p, low, high, 1,\n-\t\t\t\t  fold_convert (arg0_type, integer_zero_node),\n+\t\t\t\t  build_int_cst (arg0_type, 0),\n \t\t\t\t  NULL_TREE))\n \t\tbreak;\n \n@@ -3807,7 +3807,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t  in_p = ! in_p;\n \t\t  high = range_binop (MINUS_EXPR, NULL_TREE, low, 0,\n \t\t\t\t      integer_one_node, 0);\n-\t\t  low = fold_convert (arg0_type, integer_zero_node);\n+\t\t  low = build_int_cst (arg0_type, 0);\n \t\t}\n \t    }\n \n@@ -3817,10 +3817,10 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \tcase NEGATE_EXPR:\n \t  /* (-x) IN [a,b] -> x in [-b, -a]  */\n \t  n_low = range_binop (MINUS_EXPR, exp_type,\n-\t\t\t       fold_convert (exp_type, integer_zero_node),\n+\t\t\t       build_int_cst (exp_type, 0),\n \t\t\t       0, high, 1);\n \t  n_high = range_binop (MINUS_EXPR, exp_type,\n-\t\t\t\tfold_convert (exp_type, integer_zero_node),\n+\t\t\t\tbuild_int_cst (exp_type, 0),\n \t\t\t\t0, low, 0);\n \t  low = n_low, high = n_high;\n \t  exp = arg0;\n@@ -3829,7 +3829,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \tcase BIT_NOT_EXPR:\n \t  /* ~ X -> -X - 1  */\n \t  exp = build2 (MINUS_EXPR, exp_type, negate_expr (arg0),\n-\t\t\tfold_convert (exp_type, integer_one_node));\n+\t\t\tbuild_int_cst (exp_type, 1));\n \t  continue;\n \n \tcase PLUS_EXPR:  case MINUS_EXPR:\n@@ -4009,7 +4009,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n     }\n \n   if (low == 0 && high == 0)\n-    return fold_convert (type, integer_one_node);\n+    return build_int_cst (type, 1);\n \n   if (low == 0)\n     return fold_build2 (LE_EXPR, type, exp,\n@@ -4061,7 +4061,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t      exp = fold_convert (etype, exp);\n \t    }\n \t  return fold_build2 (GT_EXPR, type, exp,\n-\t\t\t      fold_convert (etype, integer_zero_node));\n+\t\t\t      build_int_cst (etype, 0));\n \t}\n     }\n \n@@ -4425,7 +4425,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n       if (comp_code == NE_EXPR)\n \treturn pedantic_non_lvalue (fold_convert (type, arg1));\n       else if (comp_code == EQ_EXPR)\n-\treturn fold_convert (type, integer_zero_node);\n+\treturn build_int_cst (type, 0);\n     }\n \n   /* Try some transformations of A op B ? A : B.\n@@ -4782,14 +4782,14 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n   if (lcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (lhs, 1)))\n     {\n       lhs = build2 (NE_EXPR, truth_type, lhs,\n-\t\t    fold_convert (TREE_TYPE (lhs), integer_zero_node));\n+\t\t    build_int_cst (TREE_TYPE (lhs), 0));\n       lcode = NE_EXPR;\n     }\n \n   if (rcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (rhs, 1)))\n     {\n       rhs = build2 (NE_EXPR, truth_type, rhs,\n-\t\t    fold_convert (TREE_TYPE (rhs), integer_zero_node));\n+\t\t    build_int_cst (TREE_TYPE (rhs), 0));\n       rcode = NE_EXPR;\n     }\n \n@@ -4848,7 +4848,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \treturn build2 (NE_EXPR, truth_type,\n \t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n \t\t\t       ll_arg, rl_arg),\n-\t\t       fold_convert (TREE_TYPE (ll_arg), integer_zero_node));\n+\t\t       build_int_cst (TREE_TYPE (ll_arg), 0));\n \n       /* Convert (a == 0) && (b == 0) into (a | b) == 0.  */\n       if (code == TRUTH_AND_EXPR\n@@ -4858,7 +4858,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \treturn build2 (EQ_EXPR, truth_type,\n \t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n \t\t\t       ll_arg, rl_arg),\n-\t\t       fold_convert (TREE_TYPE (ll_arg), integer_zero_node));\n+\t\t       build_int_cst (TREE_TYPE (ll_arg), 0));\n \n       if (LOGICAL_OP_NON_SHORT_CIRCUIT)\n \treturn build2 (code, truth_type, lhs, rhs);\n@@ -6146,7 +6146,7 @@ fold_single_bit_test_into_sign_test (enum tree_code code, tree arg0, tree arg1,\n \t  tree stype = lang_hooks.types.signed_type (TREE_TYPE (arg00));\n \t  return fold_build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n \t\t\t      result_type, fold_convert (stype, arg00),\n-\t\t\t      fold_convert (stype, integer_zero_node));\n+\t\t\t      build_int_cst (stype, 0));\n \t}\n     }\n \n@@ -9684,7 +9684,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \treturn build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n \t\t       build2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n \t\t\t       TREE_OPERAND (arg1, 1)),\n-\t\t       fold_convert (TREE_TYPE (arg0), integer_zero_node));\n+\t\t       build_int_cst (TREE_TYPE (arg0), 0));\n \n       else if ((code == LT_EXPR || code == GE_EXPR)\n \t       && TYPE_UNSIGNED (TREE_TYPE (arg0))\n@@ -9698,7 +9698,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\tbuild2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n \t\t\t\t\tTREE_OPERAND (TREE_OPERAND (arg1, 0),\n \t\t\t\t\t\t      1))),\n-\t\t  fold_convert (TREE_TYPE (arg0), integer_zero_node));\n+\t\t  build_int_cst (TREE_TYPE (arg0), 0));\n \n       /* Simplify comparison of something with itself.  (For IEEE\n \t floating-point, we can only do some of these simplifications.)  */"}, {"sha": "bd48fef38c0d342bde8d72e26f101691665132b7", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=57decb7e538606d06f06bc61f7841df2b3c88f03", "patch": "@@ -100,7 +100,7 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n \t\t       build_int_cst (type, 1));\n   incr_at = bsi_last (in->src);\n   create_iv (niter,\n-\t     fold_convert (type, integer_minus_one_node),\n+\t     build_int_cst (type, -1),\n \t     NULL_TREE, loop,\n \t     &incr_at, false, NULL, &var);\n "}, {"sha": "b9f73919b25115b2359256f9ba61005577fbce2f", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=57decb7e538606d06f06bc61f7841df2b3c88f03", "patch": "@@ -6770,11 +6770,11 @@ tree_fold_gcd (tree a, tree b)\n \n   if (tree_int_cst_sgn (a) == -1)\n     a = fold_build2 (MULT_EXPR, type, a,\n-\t\t     convert (type, integer_minus_one_node));\n+\t\t     build_int_cst (type, -1));\n \n   if (tree_int_cst_sgn (b) == -1)\n     b = fold_build2 (MULT_EXPR, type, b,\n-\t\t     convert (type, integer_minus_one_node));\n+\t\t     build_int_cst (type, -1));\n \n   while (1)\n     {"}, {"sha": "f304bb76e3f3eea55df94a5a028957fba32d0980", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57decb7e538606d06f06bc61f7841df2b3c88f03/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=57decb7e538606d06f06bc61f7841df2b3c88f03", "patch": "@@ -3883,7 +3883,7 @@ array_size_for_constructor (tree val)\n   i = size_binop (MINUS_EXPR, convert (sizetype, max_index),\n \t\t  convert (sizetype,\n \t\t\t   TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (val)))));\n-  i = size_binop (PLUS_EXPR, i, convert (sizetype, integer_one_node));\n+  i = size_binop (PLUS_EXPR, i, build_int_cst (sizetype, 1));\n \n   /* Multiply by the array element unit size to find number of bytes.  */\n   i = size_binop (MULT_EXPR, i, TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (val))));"}]}