{"sha": "2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZmYzI2NDU4ZGQ3YmE3YjNmYTAwODk3ZjJkOGM2Y2QyNGJhMDZmMw==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-02-24T15:08:44Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-02-25T21:29:12Z"}, "message": "c++: const_cast of null pointer in constant expr [PR99176]\n\nHere we reject\n\n  constexpr const int *p = nullptr;\n  constexpr int *q = const_cast<int*>(p);\n\nwith \"conversion of 'const int*' null pointer to 'int*' is not a\nconstant expression\", which seems bogus.  This code has been rejected\nsince r238909 which added the can_convert check when converting a null\npointer.  I'm not finding any standard rule that this check was supposed\nto enforce.  The original discussion was here\n<https://gcc.gnu.org/legacy-ml/gcc-patches/2016-06/msg01447.html>\nand here\n<https://gcc.gnu.org/legacy-ml/gcc-patches/2016-07/msg00280.html>.\n\nSince can_convert never assumes a C-style cast, it rejects casting\naway constness as in the test above and in:\n\n  constexpr int *q = (int *)(const int *) nullptr;\n\nRemoving the check only breaks constexpr-nullptr-2.C by not giving any\ndiagnostic for line 229:\n\n  constexpr B *pb2 = static_cast<B*>(pa0);  // { dg-error \"not a constant expression\" }\n\nbut the cast seems to be valid: we do [expr.static.cast]/7, and\n[expr.const] only says that a reinterpreter_cast and converting from\nvoid* is invalid in constexpr.  The can_convert check rejected convering\nfrom void *, but only when converting from a null pointer, so it's not\ngood enough.  So I've added a check to catch conversions from cv void*.\nI realize it's not a great time to be adding additional checking, but\nremoving the can_convert check would then technically be a regression.\n\nLet's limit the new check to only trigger for integer_zerop and then remove\nit in GCC 12.\n\ngcc/cp/ChangeLog:\n\n\tDR 1312\n\tPR c++/99176\n\t* constexpr.c (is_std_construct_at): New overload.\n\t(is_std_allocator_allocate): New overload.\n\t(cxx_eval_call_expression): Use the new overloads.\n\t(cxx_eval_constant_expression): Reject casting\n\tfrom void * as per DR 1312.  Don't check can_convert.\n\ngcc/testsuite/ChangeLog:\n\n\tDR 1312\n\tPR c++/99176\n\t* g++.dg/cpp0x/constexpr-nullptr-2.C: Adjust dg-error.\n\t* g++.dg/cpp0x/constexpr-cast2.C: New test.\n\t* g++.dg/cpp0x/constexpr-cast3.C: New test.", "tree": {"sha": "0887b9334bdb3b0d848a02f4334239776e8b0c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0887b9334bdb3b0d848a02f4334239776e8b0c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8ff3f8efeda02a6bedebfaf20b93645ae3bb5b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ff3f8efeda02a6bedebfaf20b93645ae3bb5b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ff3f8efeda02a6bedebfaf20b93645ae3bb5b8"}], "stats": {"total": 110, "additions": 85, "deletions": 25}, "files": [{"sha": "cd0a68e9fd6d9acd1f9cef6c2c450a6404a3bf0c", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "patch": "@@ -1837,6 +1837,16 @@ is_std_construct_at (tree fndecl)\n   return name && id_equal (name, \"construct_at\");\n }\n \n+/* Overload for the above taking constexpr_call*.  */\n+\n+static inline bool\n+is_std_construct_at (const constexpr_call *call)\n+{\n+  return (call\n+\t  && call->fundef\n+\t  && is_std_construct_at (call->fundef->decl));\n+}\n+\n /* Return true if FNDECL is std::allocator<T>::{,de}allocate.  */\n \n static inline bool\n@@ -1859,6 +1869,16 @@ is_std_allocator_allocate (tree fndecl)\n   return decl_in_std_namespace_p (decl);\n }\n \n+/* Overload for the above taking constexpr_call*.  */\n+\n+static inline bool\n+is_std_allocator_allocate (const constexpr_call *call)\n+{\n+  return (call\n+\t  && call->fundef\n+\t  && is_std_allocator_allocate (call->fundef->decl));\n+}\n+\n /* Return true if FNDECL is __dynamic_cast.  */\n \n static inline bool\n@@ -2313,9 +2333,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       if (TREE_CODE (t) == CALL_EXPR\n \t  && cxx_replaceable_global_alloc_fn (fun)\n \t  && (CALL_FROM_NEW_OR_DELETE_P (t)\n-\t      || (ctx->call\n-\t\t  && ctx->call->fundef\n-\t\t  && is_std_allocator_allocate (ctx->call->fundef->decl))))\n+\t      || is_std_allocator_allocate (ctx->call)))\n \t{\n \t  const int nargs = call_expr_nargs (t);\n \t  tree arg0 = NULL_TREE;\n@@ -2423,9 +2441,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t argument.  */\n       if (TREE_CODE (t) == CALL_EXPR\n \t  && cxx_placement_new_fn (fun)\n-\t  && ctx->call\n-\t  && ctx->call->fundef\n-\t  && is_std_construct_at (ctx->call->fundef->decl))\n+\t  && is_std_construct_at (ctx->call))\n \t{\n \t  const int nargs = call_expr_nargs (t);\n \t  tree arg1 = NULL_TREE;\n@@ -6653,6 +6669,36 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    return t;\n \t  }\n \n+\t/* [expr.const]: a conversion from type cv void* to a pointer-to-object\n+\t   type cannot be part of a core constant expression as a resolution to\n+\t   DR 1312.  */\n+\tif (integer_zerop (op) /* FIXME: Remove in GCC 12.  */\n+\t    && TYPE_PTROB_P (type)\n+\t    && TYPE_PTR_P (TREE_TYPE (op))\n+\t    && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (op)))\n+\t    /* Inside a call to std::construct_at or to\n+\t       std::allocator<T>::{,de}allocate, we permit casting from void*\n+\t       because that is compiler-generated code.  */\n+\t    && !is_std_construct_at (ctx->call)\n+\t    && !is_std_allocator_allocate (ctx->call))\n+\t  {\n+\t    /* Likewise, don't error when casting from void* when OP is\n+\t       &heap uninit and similar.  */\n+\t    tree sop = tree_strip_nop_conversions (op);\n+\t    if (TREE_CODE (sop) == ADDR_EXPR\n+\t\t&& VAR_P (TREE_OPERAND (sop, 0))\n+\t\t&& DECL_ARTIFICIAL (TREE_OPERAND (sop, 0)))\n+\t      /* OK */;\n+\t    else\n+\t      {\n+\t\tif (!ctx->quiet)\n+\t\t  error_at (loc, \"cast from %qT is not allowed\",\n+\t\t\t    TREE_TYPE (op));\n+\t\t*non_constant_p = true;\n+\t\treturn t;\n+\t      }\n+\t  }\n+\n \tif (TREE_CODE (op) == PTRMEM_CST && !TYPE_PTRMEM_P (type))\n \t  op = cplus_expand_constant (op);\n \n@@ -6671,26 +6717,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\tif (TYPE_REF_P (type))\n \t\t  {\n \t\t    if (!ctx->quiet)\n-\t\t      error_at (loc,\n-\t\t\t\t\"dereferencing a null pointer\");\n+\t\t      error_at (loc, \"dereferencing a null pointer\");\n \t\t    *non_constant_p = true;\n \t\t    return t;\n \t\t  }\n-\t\telse if (TYPE_PTR_P (TREE_TYPE (op)))\n-\t\t  {\n-\t\t    tree from = TREE_TYPE (op);\n-\n-\t\t    if (!can_convert (type, from, tf_none))\n-\t\t      {\n-\t\t\tif (!ctx->quiet)\n-\t\t\t  error_at (loc,\n-\t\t\t\t    \"conversion of %qT null pointer to %qT \"\n-\t\t\t\t    \"is not a constant expression\",\n-\t\t\t\t    from, type);\n-\t\t\t*non_constant_p = true;\n-\t\t\treturn t;\n-\t\t      }\n-\t\t  }\n \t      }\n \t    else\n \t      {"}, {"sha": "7c37f6a3f5afe2db06cc51352b48d84d29c68a21", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-cast2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast2.C?ref=2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "patch": "@@ -0,0 +1,16 @@\n+// DR 1312 - Simulated reinterpret_cast in constant expressions.\n+// PR c++/99176\n+// { dg-do compile { target c++11 } }\n+\n+static int i;\n+constexpr void *vp0 = nullptr;\n+constexpr void *vpi = &i;\n+constexpr int *p1 = (int *) vp0; // { dg-error \"cast from .void\\\\*. is not allowed\" }\n+constexpr int *p2 = (int *) vpi; // { dg-error \"cast from .void\\\\*. is not allowed\" \"integer_zerop\" { xfail *-*-* } }\n+constexpr int *p3 = static_cast<int *>(vp0); // { dg-error \"cast from .void\\\\*. is not allowed\" }\n+constexpr int *p4 = static_cast<int *>(vpi); // { dg-error \"cast from .void\\\\*. is not allowed\" \"integer_zerop\" { xfail *-*-* } }\n+constexpr void *p5 = vp0;\n+constexpr void *p6 = vpi;\n+\n+constexpr int *pi = &i;\n+constexpr bool b = ((int *)(void *) pi == pi); // { dg-error \"cast from .void\\\\*. is not allowed\" \"integer_zerop\" { xfail *-*-* } }"}, {"sha": "a330a99f7de57487e760ca8c81c01a73f3a3e259", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-cast3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast3.C?ref=2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/99176\n+// { dg-do compile { target c++11 } }\n+\n+constexpr const int *p = nullptr;\n+constexpr int *q1 = const_cast<int*>(p);\n+constexpr int *q2 = (int *)(const int *) nullptr;\n+\n+struct B { };\n+struct D : B { };\n+constexpr B *q3 = static_cast<B*>(nullptr);\n+constexpr D *pd = nullptr;\n+constexpr B *pb = nullptr;\n+constexpr B *q4 = static_cast<B*>(pd);\n+constexpr D *q5 = static_cast<D*>(pb);"}, {"sha": "92f3bbdc0a62c8998a0806823a10d14ab0755eb7", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-2.C?ref=2ffc26458dd7ba7b3fa00897f2d8c6cd24ba06f3", "patch": "@@ -163,7 +163,7 @@ constexpr const void *pv2 = pv0;\n constexpr void *pv3 = pv2;      // { dg-error \"invalid conversion|not a constant expression\" }\n constexpr const void *pv4 = pv2;\n \n-constexpr X *px4 = pv0;\t // { dg-error \"invalid conversion|not a constant expression\" }\n+constexpr X *px4 = pv0;\t // { dg-error \"cast from|invalid conversion|not a constant expression\" }\n \n }\n \n@@ -226,7 +226,7 @@ constexpr A *pa3 = pd0;\t\t   // { dg-error \"ambiguous base\" }\n constexpr A *pa4 = static_cast<A*>(pd0);  // { dg-error \"ambiguous base\" }\n \n constexpr B *pb1 = pa0;\t\t   // { dg-error \"invalid conversion|not a constant expression\" }\n-constexpr B *pb2 = static_cast<B*>(pa0);  // { dg-error \"not a constant expression\" }\n+constexpr B *pb2 = static_cast<B*>(pa0);\n \n constexpr C *pc1 = pa0;\t\t   // { dg-error \"invalid conversion|not a constant expression\" }\n constexpr D *pd1 = pa0;\t\t   // { dg-error \"ambiguous base|invalid conversion\" }"}]}