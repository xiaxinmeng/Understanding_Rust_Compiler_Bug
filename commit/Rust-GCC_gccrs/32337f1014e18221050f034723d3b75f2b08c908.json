{"sha": "32337f1014e18221050f034723d3b75f2b08c908", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIzMzdmMTAxNGUxODIyMTA1MGYwMzQ3MjNkM2I3NWYyYjA4YzkwOA==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2014-04-17T18:26:47Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2014-04-17T18:26:47Z"}, "message": "rs6000.md (addti3, subti3): New.\n\n\t* config/rs6000/rs6000.md (addti3, subti3): New.\n\n\t* gcc.target/powerpc/ti_math1.c: New.\n\t* gcc.target/powerpc/ti_math2.c: New.\n\nFrom-SVN: r209489", "tree": {"sha": "e8d5b6a26351367e7c9408cc08546e638d69cb9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8d5b6a26351367e7c9408cc08546e638d69cb9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32337f1014e18221050f034723d3b75f2b08c908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32337f1014e18221050f034723d3b75f2b08c908", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32337f1014e18221050f034723d3b75f2b08c908", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32337f1014e18221050f034723d3b75f2b08c908/comments", "author": null, "committer": null, "parents": [{"sha": "40ed344a3c6a77153fce93d27751560627a08bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ed344a3c6a77153fce93d27751560627a08bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40ed344a3c6a77153fce93d27751560627a08bfa"}], "stats": {"total": 145, "additions": 145, "deletions": 0}, "files": [{"sha": "11df5164e0ad9d478daf2e7184a146e676b7365f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32337f1014e18221050f034723d3b75f2b08c908/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32337f1014e18221050f034723d3b75f2b08c908/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32337f1014e18221050f034723d3b75f2b08c908", "patch": "@@ -1,3 +1,7 @@\n+2014-04-17  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.md (addti3, subti3): New.\n+\n 2014-04-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/60863"}, {"sha": "4daaeb01639036ba6e79b7c1daf9e2371262b5d6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=32337f1014e18221050f034723d3b75f2b08c908", "patch": "@@ -6534,6 +6534,49 @@\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"fpload\")])\n \f\n+;; Define the TImode operations that can be done in a small number\n+;; of instructions.  The & constraints are to prevent the register\n+;; allocator from allocating registers that overlap with the inputs\n+;; (for example, having an input in 7,8 and an output in 6,7).  We\n+;; also allow for the output being the same as one of the inputs.\n+\n+(define_insn \"addti3\"\n+  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"=&r,&r,r,r\")\n+\t(plus:TI (match_operand:TI 1 \"gpc_reg_operand\" \"%r,r,0,0\")\n+\t\t (match_operand:TI 2 \"reg_or_short_operand\" \"r,I,r,I\")))]\n+  \"TARGET_64BIT\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    return (GET_CODE (operands[2])) != CONST_INT\n+\t    ? \\\"addc %L0,%L1,%L2\\;adde %0,%1,%2\\\"\n+\t    : \\\"addic %L0,%L1,%2\\;add%G2e %0,%1\\\";\n+  else\n+    return (GET_CODE (operands[2])) != CONST_INT\n+\t    ? \\\"addc %0,%1,%2\\;adde %L0,%L1,%L2\\\"\n+\t    : \\\"addic %0,%1,%2\\;add%G2e %L0,%L1\\\";\n+}\n+  [(set_attr \"type\" \"two\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"subti3\"\n+  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"=&r,&r,r,r,r\")\n+\t(minus:TI (match_operand:TI 1 \"reg_or_short_operand\" \"r,I,0,r,I\")\n+\t\t  (match_operand:TI 2 \"gpc_reg_operand\" \"r,r,r,0,0\")))]\n+  \"TARGET_64BIT\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    return (GET_CODE (operands[1]) != CONST_INT)\n+\t    ? \\\"subfc %L0,%L2,%L1\\;subfe %0,%2,%1\\\"\n+\t    : \\\"subfic %L0,%L2,%1\\;subf%G1e %0,%2\\\";\n+  else\n+    return (GET_CODE (operands[1]) != CONST_INT)\n+\t    ? \\\"subfc %0,%2,%1\\;subfe %L0,%L2,%L1\\\"\n+\t    : \\\"subfic %0,%2,%1\\;subf%G1e %L0,%L2\\\";\n+}\n+  [(set_attr \"type\" \"two\")\n+   (set_attr \"length\" \"8\")])\n+\n+\n ;; Define the DImode operations that can be done in a small number\n ;; of instructions.  The & constraints are to prevent the register\n ;; allocator from allocating registers that overlap with the inputs"}, {"sha": "fe8f81e8165e7659b04d83283238d8179b4b2f64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32337f1014e18221050f034723d3b75f2b08c908", "patch": "@@ -1,3 +1,8 @@\n+2014-04-17  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* gcc.target/powerpc/ti_math1.c: New.\n+\t* gcc.target/powerpc/ti_math2.c: New.\n+\n 2014-04-17  Martin Jambor  <mjambor@suse.cz>\n \n \t* gnat.dg/opt34.adb: New."}, {"sha": "cdf925100484cc230b672eb7747244982bb0fbd2", "filename": "gcc/testsuite/gcc.target/powerpc/ti_math1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fti_math1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fti_math1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fti_math1.c?ref=32337f1014e18221050f034723d3b75f2b08c908", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"addc\" 1 } } */\n+/* { dg-final { scan-assembler-times \"adde\" 1 } } */\n+/* { dg-final { scan-assembler-times \"subfc\" 1 } } */\n+/* { dg-final { scan-assembler-times \"subfe\" 1 } } */\n+/* { dg-final { scan-assembler-not \"subf \" } } */\n+\n+__int128\n+add_128 (__int128 *ptr, __int128 val)\n+{\n+\treturn (*ptr + val);\n+}\n+\n+__int128\n+sub_128 (__int128 *ptr, __int128 val)\n+{\n+\treturn (*ptr - val);\n+}\n+"}, {"sha": "b9c03300d8463ed8f9090b13847951ad536704f2", "filename": "gcc/testsuite/gcc.target/powerpc/ti_math2.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fti_math2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32337f1014e18221050f034723d3b75f2b08c908/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fti_math2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fti_math2.c?ref=32337f1014e18221050f034723d3b75f2b08c908", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-options \"-O2 -fno-inline\" } */\n+\n+union U {\n+  __int128 i128;\n+  struct {\n+    long l1;\n+    long l2;\n+  } s;\n+};\n+\n+union U u1,u2;\n+\n+__int128\n+create_128 (long most_sig, long least_sig)\n+{\n+  union U u;\n+\n+#if __LITTLE_ENDIAN__\n+  u.s.l1 = least_sig;\n+  u.s.l2 = most_sig;\n+#else\n+  u.s.l1 = most_sig;\n+  u.s.l2 = least_sig;\n+#endif\n+  return u.i128;\n+}\n+\n+long most_sig (union U * u)\n+{\n+#if __LITTLE_ENDIAN__\n+  return (*u).s.l2;\n+#else\n+  return (*u).s.l1;\n+#endif\n+}\n+\n+long least_sig (union U * u)\n+{\n+#if __LITTLE_ENDIAN__\n+  return (*u).s.l1;\n+#else\n+  return (*u).s.l2;\n+#endif\n+}\n+\n+__int128\n+add_128 (__int128 *ptr, __int128 val)\n+{\n+\treturn (*ptr + val);\n+}\n+\n+__int128\n+sub_128 (__int128 *ptr, __int128 val)\n+{\n+\treturn (*ptr - val);\n+}\n+\n+int\n+main (void)\n+{\n+  /* Do a simple add/sub to make sure carry is happening between the dwords\n+     and that dwords are in correct endian order. */\n+  u1.i128 = create_128 (1, -1);\n+  u2.i128 = add_128 (&u1.i128, 1);\n+  if ((most_sig (&u2) != 2) || (least_sig (&u2) != 0))\n+    __builtin_abort ();\n+  u2.i128 = sub_128 (&u2.i128, 1);\n+  if ((most_sig (&u2) != 1) || (least_sig (&u2) != -1))\n+    __builtin_abort ();\n+  return 0;\n+}\n+"}]}