{"sha": "1a11a94fcd9cfe0759f6e37cac0177982697e45a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWExMWE5NGZjZDljZmUwNzU5ZjZlMzdjYWMwMTc3OTgyNjk3ZTQ1YQ==", "commit": {"author": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-09-16T07:14:34Z"}, "committer": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-09-16T07:14:34Z"}, "message": "Support using 'auto' in a function parameter list to introduce an implicit template parameter.\n\ngcc/cp/\n\t* cp-tree.h (type_uses_auto_or_concept): Declare.\n\t(is_auto_or_concept): Declare.\n\t* decl.c (grokdeclarator): Allow 'auto' parameters in lambdas with\n\t-std=gnu++1y or -std=c++1y or, as a GNU extension, in plain functions.\n\t* type-utils.h: New header defining ...\n\t(find_type_usage): ... this new function based on pt.c (type_uses_auto)\n\tfor searching a type tree given a predicate.\n\t* pt.c (type_uses_auto): Reimplement via type-utils.h (find_type_usage).\n\t(is_auto_or_concept): New function.\n\t(type_uses_auto_or_concept): New function.\n\t* parser.h (struct cp_parser): Add fully_implicit_function_template_p.\n\t* parser.c (cp_parser_new): Initialize fully_implicit_function_template_p.\n\t(cp_parser_new): Initialize fully_implicit_function_template_p.\n\t(cp_parser_lambda_expression): Copy and restore value of\n\tfully_implicit_function_template_p as per other parser fields.\n\t(cp_parser_parameter_declaration_list): Count generic\n\tparameters and call ...\n\t(add_implicit_template_parms): ... this new function to synthesize them\n\twith help from type-utils.h (find_type_usage), ...\n\t(tree_type_is_auto_or_concept): ... this new static function and ...\n\t(make_generic_type_name): ... this new static function.\n\t(cp_parser_direct_declarator): Account for implicit template parameters.\n\t(cp_parser_lambda_declarator_opt): Finish fully implicit template if\n\tnecessary by calling ...\n\t(finish_fully_implicit_template): ... this new function.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_function_definition_after_declarator): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\t* Make-lang.in (cp/pt.o): Add dependency on type-utils.h.\n\t(cp/parser.o): Likewise.\n\ngcc/testsuite/\n\tg++.dg/cpp0x/auto9.C: Downgrade two previously expected errors (now\n\tinterpreted as implicit templates) to be expected pedwarns instead.\n\nFrom-SVN: r202612", "tree": {"sha": "7b1d4ac4d3e611d0294babd60fb9894821a0f303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b1d4ac4d3e611d0294babd60fb9894821a0f303"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a11a94fcd9cfe0759f6e37cac0177982697e45a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a11a94fcd9cfe0759f6e37cac0177982697e45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a11a94fcd9cfe0759f6e37cac0177982697e45a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a11a94fcd9cfe0759f6e37cac0177982697e45a/comments", "author": null, "committer": null, "parents": [{"sha": "6a8b219b44bba840fed7e0994a70a60322a29e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8b219b44bba840fed7e0994a70a60322a29e59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a8b219b44bba840fed7e0994a70a60322a29e59"}], "stats": {"total": 425, "additions": 353, "deletions": 72}, "files": [{"sha": "985f22b72d9d646a24f93cd6503c39fc3aa94c16", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -312,7 +312,7 @@ cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/cp-objcp-common.h \\\n   toplev.h $(TREE_INLINE_H) pointer-set.h gt-cp-pt.h intl.h \\\n-  c-family/c-objc.h\n+  c-family/c-objc.h cp/type-utils.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_H) \\\n   $(FLAGS_H) $(REAL_H) $(LANGHOOKS_DEF_H) $(CXX_PRETTY_PRINT_H) \\\n   tree-diagnostic.h tree-pretty-print.h pointer-set.h c-family/c-objc.h\n@@ -331,7 +331,8 @@ cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H) $(CGRAPH_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n   gt-cp-parser.h $(TARGET_H) $(PLUGIN_H) intl.h cp/decl.h \\\n-  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR_H)\n+  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR_H) \\\n+  cp/type-utils.h\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h $(SPLAY_TREE_H)\n cp/vtable-class-hierarchy.o: cp/vtable-class-hierarchy.c \\"}, {"sha": "d7840aff89f52cc49ad05e7618ad49d2374ffeac", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -5453,10 +5453,12 @@ extern tree make_auto\t\t\t\t(void);\n extern tree make_decltype_auto\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);\n+extern tree type_uses_auto_or_concept\t\t(tree);\n extern void append_type_to_template_for_access_check (tree, tree, tree,\n \t\t\t\t\t\t      location_t);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n+extern bool is_auto_or_concept\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, location_t, tree, \n \t\t\t\t\t\t bool, bool);\n extern tree end_template_parm_list\t\t(tree);"}, {"sha": "80ceca138d8b743dc65ab4c81448ff43b16ebf02", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -10323,8 +10323,33 @@ grokdeclarator (const cp_declarator *declarator,\n \n       if (type_uses_auto (type))\n \t{\n-\t  error (\"parameter declared %<auto%>\");\n-\t  type = error_mark_node;\n+\t  if (template_parm_flag)\n+\t    {\n+\t      error (\"template parameter declared %<auto%>\");\n+\t      type = error_mark_node;\n+\t    }\n+\t  else if (decl_context == CATCHPARM)\n+\t    {\n+\t      error (\"catch parameter declared %<auto%>\");\n+\t      type = error_mark_node;\n+\t    }\n+\t  else if (current_class_type && LAMBDA_TYPE_P (current_class_type))\n+\t    {\n+\t      if (cxx_dialect < cxx1y)\n+\t\tpedwarn (location_of (type), 0,\n+\t\t\t \"use of %<auto%> in lambda parameter declaration \"\n+\t\t\t \"only available with \"\n+\t\t\t \"-std=c++1y or -std=gnu++1y\");\n+\t    }\n+\t  else if (cxx_dialect < cxx1y)\n+\t    pedwarn (location_of (type), 0,\n+\t\t     \"use of %<auto%> in parameter declaration \"\n+\t\t     \"only available with \"\n+\t\t     \"-std=c++1y or -std=gnu++1y\");\n+\t  else\n+\t    pedwarn (location_of (type), OPT_Wpedantic,\n+\t\t     \"ISO C++ forbids use of %<auto%> in parameter \"\n+\t\t     \"declaration\");\n \t}\n \n       /* A parameter declared as an array of T is really a pointer to T."}, {"sha": "2cd60f0db9d51036d0e95aa263f68bf3cead228b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 238, "deletions": 51, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"tree-pretty-print.h\"\n #include \"parser.h\"\n+#include \"type-utils.h\"\n \n \f\n /* The lexer.  */\n@@ -2063,6 +2064,11 @@ static vec<constructor_elt, va_gc> *cp_parser_initializer_list\n static bool cp_parser_ctor_initializer_opt_and_function_body\n   (cp_parser *, bool);\n \n+static tree add_implicit_template_parms\n+  (cp_parser *, size_t, tree);\n+static tree finish_fully_implicit_template\n+  (cp_parser *, tree);\n+\n /* Classes [gram.class] */\n \n static tree cp_parser_class_name\n@@ -3385,6 +3391,9 @@ cp_parser_new (void)\n   /* No template parameters apply.  */\n   parser->num_template_parameter_lists = 0;\n \n+  /* Not declaring an implicit function template.  */\n+  parser->fully_implicit_function_template_p = false;\n+\n   return parser;\n }\n \n@@ -8549,10 +8558,12 @@ cp_parser_lambda_expression (cp_parser* parser)\n         = parser->num_template_parameter_lists;\n     unsigned char in_statement = parser->in_statement;\n     bool in_switch_statement_p = parser->in_switch_statement_p;\n+    bool fully_implicit_function_template_p = parser->fully_implicit_function_template_p;\n \n     parser->num_template_parameter_lists = 0;\n     parser->in_statement = 0;\n     parser->in_switch_statement_p = false;\n+    parser->fully_implicit_function_template_p = false;\n \n     /* By virtue of defining a local class, a lambda expression has access to\n        the private variables of enclosing classes.  */\n@@ -8576,6 +8587,7 @@ cp_parser_lambda_expression (cp_parser* parser)\n     parser->num_template_parameter_lists = saved_num_template_parameter_lists;\n     parser->in_statement = in_statement;\n     parser->in_switch_statement_p = in_switch_statement_p;\n+    parser->fully_implicit_function_template_p = fully_implicit_function_template_p;\n   }\n \n   pop_deferring_access_checks ();\n@@ -8928,6 +8940,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t    finish_template_decl (template_param_list);\n \t    --parser->num_template_parameter_lists;\n \t  }\n+\telse if (parser->fully_implicit_function_template_p)\n+\t  fco = finish_fully_implicit_template (parser, fco);\n       }\n \n     finish_member_declaration (fco);\n@@ -16289,56 +16303,62 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n-  /* Check to see if the token indicates the start of a\n-     function-definition.  */\n-  if (function_declarator_p (declarator)\n-      && cp_parser_token_starts_function_definition_p (token))\n+\n+  if (function_declarator_p (declarator))\n     {\n-      if (!function_definition_allowed_p)\n+      /* Check to see if the token indicates the start of a\n+\t function-definition.  */\n+      if (cp_parser_token_starts_function_definition_p (token))\n \t{\n-\t  /* If a function-definition should not appear here, issue an\n-\t     error message.  */\n-\t  cp_parser_error (parser,\n-\t\t\t   \"a function-definition is not allowed here\");\n-\t  return error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  location_t func_brace_location\n-\t    = cp_lexer_peek_token (parser->lexer)->location;\n-\n-\t  /* Neither attributes nor an asm-specification are allowed\n-\t     on a function-definition.  */\n-\t  if (asm_specification)\n-\t    error_at (asm_spec_start_token->location,\n-\t\t      \"an asm-specification is not allowed \"\n-\t\t      \"on a function-definition\");\n-\t  if (attributes)\n-\t    error_at (attributes_start_token->location,\n-\t\t      \"attributes are not allowed on a function-definition\");\n-\t  /* This is a function-definition.  */\n-\t  *function_definition_p = true;\n-\n-\t  /* Parse the function definition.  */\n-\t  if (member_p)\n-\t    decl = cp_parser_save_member_function_body (parser,\n-\t\t\t\t\t\t\tdecl_specifiers,\n-\t\t\t\t\t\t\tdeclarator,\n-\t\t\t\t\t\t\tprefix_attributes);\n-\t  else\n-\t    decl\n-\t      = (cp_parser_function_definition_from_specifiers_and_declarator\n-\t\t (parser, decl_specifiers, prefix_attributes, declarator));\n-\n-\t  if (decl != error_mark_node && DECL_STRUCT_FUNCTION (decl))\n+\t  if (!function_definition_allowed_p)\n \t    {\n-\t      /* This is where the prologue starts...  */\n-\t      DECL_STRUCT_FUNCTION (decl)->function_start_locus\n-\t\t= func_brace_location;\n+\t      /* If a function-definition should not appear here, issue an\n+\t\t error message.  */\n+\t      cp_parser_error (parser,\n+\t\t\t       \"a function-definition is not allowed here\");\n+\t      return error_mark_node;\n \t    }\n+\t  else\n+\t    {\n+\t      location_t func_brace_location\n+\t\t= cp_lexer_peek_token (parser->lexer)->location;\n+\n+\t      /* Neither attributes nor an asm-specification are allowed\n+\t\t on a function-definition.  */\n+\t      if (asm_specification)\n+\t\terror_at (asm_spec_start_token->location,\n+\t\t\t  \"an asm-specification is not allowed \"\n+\t\t\t  \"on a function-definition\");\n+\t      if (attributes)\n+\t\terror_at (attributes_start_token->location,\n+\t\t\t  \"attributes are not allowed \"\n+\t\t\t  \"on a function-definition\");\n+\t      /* This is a function-definition.  */\n+\t      *function_definition_p = true;\n+\n+\t      /* Parse the function definition.  */\n+\t      if (member_p)\n+\t\tdecl = cp_parser_save_member_function_body (parser,\n+\t\t\t\t\t\t\t    decl_specifiers,\n+\t\t\t\t\t\t\t    declarator,\n+\t\t\t\t\t\t\t    prefix_attributes);\n+\t      else\n+\t\tdecl =\n+\t\t  (cp_parser_function_definition_from_specifiers_and_declarator\n+\t\t   (parser, decl_specifiers, prefix_attributes, declarator));\n \n-\t  return decl;\n+\t      if (decl != error_mark_node && DECL_STRUCT_FUNCTION (decl))\n+\t\t{\n+\t\t  /* This is where the prologue starts...  */\n+\t\t  DECL_STRUCT_FUNCTION (decl)->function_start_locus\n+\t\t    = func_brace_location;\n+\t\t}\n+\n+\t      return decl;\n+\t    }\n \t}\n+      else if (parser->fully_implicit_function_template_p)\n+\tdecl = finish_fully_implicit_template (parser, decl);\n     }\n \n   /* [dcl.dcl]\n@@ -16798,8 +16818,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      /* Parse the parameter-declaration-clause.  */\n \t      params = cp_parser_parameter_declaration_clause (parser);\n \n+\t      /* Restore saved template parameter lists accounting for implicit\n+\t\t template parameters.  */\n \t      parser->num_template_parameter_lists\n-\t\t= saved_num_template_parameter_lists;\n+\t\t+= saved_num_template_parameter_lists;\n \n \t      /* Consume the `)'.  */\n \t      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n@@ -17897,6 +17919,7 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   tree *tail = &parameters; \n   bool saved_in_unbraced_linkage_specification_p;\n   int index = 0;\n+  int implicit_template_parms = 0;\n \n   /* Assume all will go well.  */\n   *is_error = false;\n@@ -17924,11 +17947,18 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n       deprecated_state = DEPRECATED_SUPPRESS;\n \n       if (parameter)\n-\tdecl = grokdeclarator (parameter->declarator,\n-\t\t\t       &parameter->decl_specifiers,\n-\t\t\t       PARM,\n-\t\t\t       parameter->default_argument != NULL_TREE,\n-\t\t\t       &parameter->decl_specifiers.attributes);\n+\t{\n+\t  decl = grokdeclarator (parameter->declarator,\n+\t\t\t\t &parameter->decl_specifiers,\n+\t\t\t\t PARM,\n+\t\t\t\t parameter->default_argument != NULL_TREE,\n+\t\t\t\t &parameter->decl_specifiers.attributes);\n+\n+\t  if (TREE_TYPE (decl) != error_mark_node\n+\t      && parameter->decl_specifiers.type\n+\t      && is_auto_or_concept (parameter->decl_specifiers.type))\n+\t      ++implicit_template_parms;\n+\t}\n \n       deprecated_state = DEPRECATED_NORMAL;\n \n@@ -18016,6 +18046,11 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   parser->in_unbraced_linkage_specification_p\n     = saved_in_unbraced_linkage_specification_p;\n \n+  if (parameters != error_mark_node && implicit_template_parms)\n+    parameters = add_implicit_template_parms (parser,\n+\t\t\t\t\t      implicit_template_parms,\n+\t\t\t\t\t      parameters);\n+\n   return parameters;\n }\n \n@@ -20022,7 +20057,11 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t\t\t\t      attributes);\n \t\t  /* If the member was not a friend, declare it here.  */\n \t\t  if (!friend_p)\n-\t\t    finish_member_declaration (decl);\n+\t\t    {\n+\t\t      if (parser->fully_implicit_function_template_p)\n+\t\t\tdecl = finish_fully_implicit_template (parser, decl);\n+\t\t      finish_member_declaration (decl);\n+\t\t    }\n \t\t  /* Peek at the next token.  */\n \t\t  token = cp_lexer_peek_token (parser->lexer);\n \t\t  /* If the next token is a semicolon, consume it.  */\n@@ -20038,6 +20077,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t  initializer, /*init_const_expr_p=*/true,\n \t\t\t\t  asm_specification,\n \t\t\t\t  attributes);\n+\t\tif (parser->fully_implicit_function_template_p)\n+\t\t  decl = finish_fully_implicit_template (parser, decl);\n \t    }\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n@@ -22305,6 +22346,9 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n     = saved_num_template_parameter_lists;\n   parser->in_function_body = saved_in_function_body;\n \n+  if (parser->fully_implicit_function_template_p)\n+    finish_fully_implicit_template (parser, /*member_decl_opt=*/0);\n+\n   return fn;\n }\n \n@@ -28850,4 +28894,147 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n+/* Create an identifier for a generic parameter type (a synthesized\n+   template parameter implied by `auto' or a concept identifier). */\n+\n+static tree\n+make_generic_type_name (int i)\n+{\n+  char buf[32];\n+  sprintf (buf, \"__GenT%d\", i);\n+  return get_identifier (buf);\n+}\n+\n+/* Predicate that behaves as is_auto_or_concept but matches the parent\n+   node of the generic type rather than the generic type itself.  This\n+   allows for type transformation in add_implicit_template_parms.  */\n+\n+static inline bool\n+tree_type_is_auto_or_concept (const_tree t)\n+{\n+  return TREE_TYPE (t) && is_auto_or_concept (TREE_TYPE (t));\n+}\n+\n+/* Add COUNT implicit template parameters gleaned from the generic\n+   type parameters in PARAMETERS to the CURRENT_TEMPLATE_PARMS\n+   (creating a new template parameter list if necessary).  Returns\n+   PARAMETERS suitably rewritten to reference the newly created types\n+   or ERROR_MARK_NODE on failure.  */\n+\n+tree\n+add_implicit_template_parms (cp_parser *parser, size_t count, tree parameters)\n+{\n+  gcc_assert (current_binding_level->kind == sk_function_parms);\n+\n+  cp_binding_level *fn_parms_scope = current_binding_level;\n+\n+  bool become_template =\n+    fn_parms_scope->level_chain->kind != sk_template_parms;\n+\n+  size_t synth_idx = 0;\n+\n+  /* Roll back a scope level and either introduce a new template parameter list\n+     or update an existing one.  The function scope is added back after template\n+     parameter synthesis below.  */\n+  current_binding_level = fn_parms_scope->level_chain;\n+\n+  /* TPARMS tracks the function's template parameter list.  This is either a new\n+     chain in the case of a fully implicit function template or an extension of\n+     the function's explicitly specified template parameter list.  */\n+  tree tparms = NULL_TREE;\n+\n+  if (become_template)\n+    {\n+      push_deferring_access_checks (dk_deferred);\n+      begin_template_parm_list ();\n+\n+      parser->fully_implicit_function_template_p = true;\n+      ++parser->num_template_parameter_lists;\n+    }\n+  else\n+    {\n+      /* Roll back the innermost template parameter list such that it may be\n+\t extended in the loop below as if it were being explicitly declared.  */\n+\n+      gcc_assert (current_template_parms);\n+\n+      /* Pop the innermost template parms into TPARMS.  */\n+      tree inner_vec = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n+      current_template_parms = TREE_CHAIN (current_template_parms);\n+\n+      size_t inner_vec_len = TREE_VEC_LENGTH (inner_vec);\n+      if (inner_vec_len != 0)\n+\t{\n+\t  tree t = tparms = TREE_VEC_ELT (inner_vec, 0);\n+\t  for (size_t n = 1; n < inner_vec_len; ++n)\n+\t    t = TREE_CHAIN (t) = TREE_VEC_ELT (inner_vec, n);\n+\t}\n+\n+      ++processing_template_parmlist;\n+    }\n+\n+  for (tree p = parameters; p && synth_idx < count; p = TREE_CHAIN (p))\n+    {\n+      tree generic_type_ptr\n+\t= find_type_usage (TREE_VALUE (p), tree_type_is_auto_or_concept);\n+\n+      if (!generic_type_ptr)\n+\tcontinue;\n+\n+      tree synth_id = make_generic_type_name (synth_idx++);\n+      tree synth_tmpl_parm = finish_template_type_parm (class_type_node,\n+\t\t\t\t\t\t\tsynth_id);\n+      tparms = process_template_parm (tparms, DECL_SOURCE_LOCATION (TREE_VALUE\n+\t\t\t\t\t\t\t\t    (p)),\n+\t\t\t\t      build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t       synth_tmpl_parm),\n+\t\t\t\t      /*non_type=*/false,\n+\t\t\t\t      /*param_pack=*/false);\n+\n+      /* Rewrite the type of P to be the template_parm added above (getdecls is\n+         used to retrieve it since it is the most recent declaration in this\n+         scope).  Qualifiers need to be preserved also.  */\n+\n+      tree& cur_type = TREE_TYPE (generic_type_ptr);\n+      tree new_type = TREE_TYPE (getdecls ());\n+\n+      if (TYPE_QUALS (cur_type))\n+\tcur_type = cp_build_qualified_type (new_type, TYPE_QUALS (cur_type));\n+      else\n+\tcur_type = new_type;\n+    }\n+\n+  gcc_assert (synth_idx == count);\n+\n+  push_binding_level (fn_parms_scope);\n+\n+  end_template_parm_list (tparms);\n+\n+  return parameters;\n+}\n+\n+/* Finish the declaration of a fully implicit function template.  Such a\n+   template has no explicit template parameter list so has not been through the\n+   normal template head and tail processing.  add_implicit_template_parms tries\n+   to do the head; this tries to do the tail.  MEMBER_DECL_OPT should be\n+   provided if the declaration is a class member such that its template\n+   declaration can be completed.  If MEMBER_DECL_OPT is provided the finished\n+   form is returned.  Otherwise NULL_TREE is returned. */\n+\n+tree\n+finish_fully_implicit_template (cp_parser *parser, tree member_decl_opt)\n+{\n+  gcc_assert (parser->fully_implicit_function_template_p);\n+\n+  pop_deferring_access_checks ();\n+  if (member_decl_opt)\n+    member_decl_opt = finish_member_template_decl (member_decl_opt);\n+  end_template_decl ();\n+\n+  parser->fully_implicit_function_template_p = false;\n+  --parser->num_template_parameter_lists;\n+\n+  return member_decl_opt;\n+}\n+\n #include \"gt-cp-parser.h\""}, {"sha": "ffdddaf4a08f25d8b55a1b64b1f8d1f5b1907111", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -341,6 +341,12 @@ typedef struct GTY(()) cp_parser {\n   /* The number of template parameter lists that apply directly to the\n      current declaration.  */\n   unsigned num_template_parameter_lists;\n+\n+  /* TRUE if the function being declared was made a template due to its\n+     parameter list containing generic type specifiers (`auto' or concept\n+     identifiers) rather than an explicit template parameter list.  */\n+  bool fully_implicit_function_template_p;\n+\n } cp_parser;\n \n /* In parser.c  */"}, {"sha": "c2e251aaf859cb41476c41a3716fd4c7ee46b79c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"timevar.h\"\n #include \"tree-iterator.h\"\n+#include \"type-utils.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -21229,31 +21230,35 @@ is_auto (const_tree type)\n     return false;\n }\n \n-/* Returns true iff TYPE contains a use of 'auto'.  Since auto can only\n-   appear as a type-specifier for the declaration in question, we don't\n-   have to look through the whole type.  */\n+/* Returns the TEMPLATE_TYPE_PARM in TYPE representing `auto' iff TYPE contains\n+   a use of `auto'.  Returns NULL_TREE otherwise.  */\n \n tree\n type_uses_auto (tree type)\n {\n-  enum tree_code code;\n-  if (is_auto (type))\n-    return type;\n+  return find_type_usage (type, is_auto);\n+}\n \n-  code = TREE_CODE (type);\n+/* Returns true iff TYPE is a TEMPLATE_TYPE_PARM representing 'auto',\n+   'decltype(auto)' or a concept.  */\n \n-  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n-      || code == OFFSET_TYPE || code == FUNCTION_TYPE\n-      || code == METHOD_TYPE || code == ARRAY_TYPE)\n-    return type_uses_auto (TREE_TYPE (type));\n+bool\n+is_auto_or_concept (const_tree type)\n+{\n+  return is_auto (type); // or concept\n+}\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    return type_uses_auto (TREE_TYPE (TREE_TYPE\n-\t\t\t\t   (TYPE_PTRMEMFUNC_FN_TYPE (type))));\n+/* Returns the TEMPLATE_TYPE_PARM in TYPE representing a generic type (`auto' or\n+   a concept identifier) iff TYPE contains a use of a generic type.  Returns\n+   NULL_TREE otherwise.  */\n \n-  return NULL_TREE;\n+tree\n+type_uses_auto_or_concept (tree type)\n+{\n+  return find_type_usage (type, is_auto_or_concept);\n }\n \n+\n /* For a given template T, return the vector of typedefs referenced\n    in T for which access check is needed at T instantiation time.\n    T is either  a FUNCTION_DECL or a RECORD_TYPE."}, {"sha": "3e82ca4f9576b7d25d76f71eb888689d432e01b6", "filename": "gcc/cp/type-utils.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Ftype-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Fcp%2Ftype-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftype-utils.h?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -0,0 +1,55 @@\n+/* Utilities for querying and manipulating type trees.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CP_TYPE_UTILS_H\n+#define GCC_CP_TYPE_UTILS_H\n+\n+/* Returns the first tree within T that is directly matched by PRED.  T may be a\n+   type or PARM_DECL and is incrementally decomposed toward its type-specifier\n+   until a match is found.  NULL_TREE is returned if PRED does not match any\n+   part of T.\n+\n+   This is primarily intended for detecting whether T uses `auto' or a concept\n+   identifier.  Since either of these can only appear as a type-specifier for\n+   the declaration in question, only top-level qualifications are traversed;\n+   find_type_usage does not look through the whole type.  */\n+\n+inline tree\n+find_type_usage (tree t, bool (*pred) (const_tree))\n+{\n+  enum tree_code code;\n+  if (pred (t))\n+    return t;\n+\n+  code = TREE_CODE (t);\n+\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n+      || code == PARM_DECL || code == OFFSET_TYPE\n+      || code == FUNCTION_TYPE || code == METHOD_TYPE\n+      || code == ARRAY_TYPE)\n+    return find_type_usage (TREE_TYPE (t), pred);\n+\n+  if (TYPE_PTRMEMFUNC_P (t))\n+    return find_type_usage\n+      (TREE_TYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t))), pred);\n+\n+  return NULL_TREE;\n+}\n+\n+#endif // GCC_CP_TYPE_UTILS_H"}, {"sha": "f357f2b96636b447d75eaea7aee9db0c83c5aa87", "filename": "gcc/testsuite/g++.dg/cpp0x/auto9.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a11a94fcd9cfe0759f6e37cac0177982697e45a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C?ref=1a11a94fcd9cfe0759f6e37cac0177982697e45a", "patch": "@@ -117,8 +117,8 @@ template <auto V = 4> struct G {};\t\t// { dg-error \"auto\" }\n template <typename T> struct H { H (); ~H (); };\n H<auto> h;\t\t\t\t\t// { dg-error \"invalid\" }\n \n-void qq (auto);\t\t\t// { dg-error \"auto\" }\n-void qr (auto*);\t\t// { dg-error \"auto\" }\n+void qq (auto);\t\t\t// { dg-warning \"auto\" }\n+void qr (auto*);\t\t// { dg-warning \"auto\" }\n \n // PR c++/46145\n typedef auto autot;\t\t// { dg-error \"auto\" }"}]}