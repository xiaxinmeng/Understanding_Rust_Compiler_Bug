{"sha": "7177d104dda07e20323efae4d4560237987d77aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE3N2QxMDRkZGEwN2UyMDMyM2VmYWU0ZDQ1NjAyMzc5ODdkNzdhYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-21T23:30:18Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-21T23:30:18Z"}, "message": "33rd Cygnus<->FSF merge\n\nFrom-SVN: r7134", "tree": {"sha": "961e3713445be8eae59a2380b2d8ba42844fac0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/961e3713445be8eae59a2380b2d8ba42844fac0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7177d104dda07e20323efae4d4560237987d77aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7177d104dda07e20323efae4d4560237987d77aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7177d104dda07e20323efae4d4560237987d77aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7177d104dda07e20323efae4d4560237987d77aa/comments", "author": null, "committer": null, "parents": [{"sha": "0207efa210a8cf5c2777b9ebaf3cd0d34295afc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0207efa210a8cf5c2777b9ebaf3cd0d34295afc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0207efa210a8cf5c2777b9ebaf3cd0d34295afc5"}], "stats": {"total": 4880, "additions": 3545, "deletions": 1335}, "files": [{"sha": "2f79a78f1a8ca562b0ae3853270bb4b7d0240f02", "filename": "gcc/cp/ChangeLog", "status": "added", "additions": 2846, "deletions": 0, "changes": 2846, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7177d104dda07e20323efae4d4560237987d77aa"}, {"sha": "dabed98907012882b08fdc1853bb2af486c2dd47", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -3810,7 +3810,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   if (need_vtbl == needed)\n     {\n-      function = build_vfn_ref (&TREE_VALUE (parms), instance, DECL_VINDEX (function));\n+      function = build_vfn_ref (&TREE_VALUE (parms), instance,\n+\t\t\t\tDECL_VINDEX (function));\n       TREE_TYPE (function) = build_pointer_type (fntype);\n     }\n \n@@ -3975,7 +3976,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       return error_mark_node;\n     }\n \n-  if (! TREE_OVERLOADED (fnname))\n+  if (TREE_CODE (functions) == FUNCTION_DECL)\n     {\n       functions = DECL_MAIN_VARIANT (functions);\n       if (final_cp)"}, {"sha": "b595f53455c3aa756ca2efbbec6ce81af98af162", "filename": "gcc/cp/class.c", "status": "modified", "additions": 297, "deletions": 875, "changes": 1172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -339,29 +339,12 @@ build_vbase_path (code, type, expr, path, alias_this)\n \n /* Virtual function things.  */\n \n-/* Virtual functions to be dealt with after laying out our\n-   base classes.  Usually this is used only when classes have virtual\n-   baseclasses, but it can happen also when classes have non-virtual\n-   baseclasses if the derived class overrides baseclass functions\n-   at different offsets.  */\n+/* Virtual functions to be dealt with after laying out our base\n+   classes.  We do all overrides after we layout virtual base classes.\n+   */\n static tree pending_hard_virtuals;\n static int doing_hard_virtuals;\n \n-/* XXX This is set but never used.  (bpk) */\n-#if 0\n-/* Temporary binfo list to memoize lookups of the left-most non-virtual\n-   baseclass B in a lattice topped by T.  B can appear multiple times\n-   in the lattice.\n-   TREE_PURPOSE is B's TYPE_MAIN_VARIANT.\n-   TREE_VALUE is the path by which B is reached from T.\n-   TREE_TYPE is B's real type.\n-\n-   If TREE_TYPE is NULL_TREE, it means that B was reached via\n-   a virtual baseclass.\n-   N.B.: This list consists of nodes on the temporary obstack.  */\n-static tree leftmost_baseclasses;\n-#endif\n-\n /* Build an entry in the virtual function table.\n    DELTA is the offset for the `this' pointer.\n    PFN is an ADDR_EXPR containing a pointer to the virtual function.\n@@ -371,18 +354,6 @@ tree\n build_vtable_entry (delta, pfn)\n      tree delta, pfn;\n {\n-  extern tree abort_fndecl;\n-  if (TREE_CODE (pfn) == ADDR_EXPR)\n-    {\n-      tree fndecl = TREE_OPERAND (pfn, 0);\n-      if (TREE_CODE(fndecl) == FUNCTION_DECL\n-\t  && DECL_ABSTRACT_VIRTUAL_P(fndecl))\n-\t{\n-\t  tree d = copy_node (fndecl);\n-\t  DECL_RTL (d) = DECL_RTL (abort_fndecl);\n-\t  TREE_OPERAND (pfn, 0) = d;\n-\t}\n-    }\n \n   if (flag_vtable_thunks)\n     {\n@@ -525,32 +496,6 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n     }\n }\n \n-/* Set TREE_PUBLIC and/or TREE_EXTERN on the vtable DECL,\n-   based on TYPE and other static flags.\n-\n-   Note that anything public is tagged TREE_PUBLIC, whether\n-   it's public in this file or in another one.  */\n-\n-static void\n-import_export_vtable (decl, type)\n-  tree decl, type;\n-{\n-  if (write_virtuals >= 2)\n-    {\n-      if (CLASSTYPE_INTERFACE_KNOWN (type))\n-\t{\n-\t  TREE_PUBLIC (decl) = 1;\n-\t  DECL_EXTERNAL (decl) = ! CLASSTYPE_VTABLE_NEEDS_WRITING (type);\n-\t}\n-    }\n-  else if (write_virtuals != 0)\n-    {\n-      TREE_PUBLIC (decl) = 1;\n-      if (write_virtuals < 0)\n-\tDECL_EXTERNAL (decl) = 1;\n-    }\n-}\n-\n /* Return the name of the virtual function table (as an IDENTIFIER_NODE)\n    for the given TYPE.  */\n static tree\n@@ -602,8 +547,10 @@ build_vtable (binfo, type)\n   n_vtable_elems += list_length (virtuals);\n #endif\n \n+#if 0\t\t\t\t/* Now done from finish_vtable_vardecl */\n   /* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */\n   import_export_vtable (decl, type);\n+#endif\n \n   IDENTIFIER_GLOBAL_VALUE (name) = decl = pushdecl_top_level (decl);\n   /* Initialize the association list for this type, based\n@@ -624,17 +571,9 @@ build_vtable (binfo, type)\n   /* Why is this conditional? (mrs) */\n   if (binfo && write_virtuals >= 0)\n     DECL_VIRTUAL_P (decl) = 1;\n-#if 0\n-  /* Remember which class this vtable is really for.  */\n-  if (binfo)\n-    DECL_VPARENT (decl) = BINFO_TYPE (binfo);\n-  else\n-    DECL_VPARENT (decl) = type;\n-#endif\n   DECL_CONTEXT (decl) = type;\n \n   binfo = TYPE_BINFO (type);\n-  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n   return decl;\n }\n@@ -710,25 +649,21 @@ build_type_pathname (format, parent, type)\n    FOR_TYPE is the derived type which caused this table to\n    be needed.\n \n-   BINFO is the type association which provided TYPE for FOR_TYPE.\n-\n-   The way we update BASE_BINFO's vtable information is just to change the\n-   association information in FOR_TYPE's association list.  */\n+   BINFO is the type association which provided TYPE for FOR_TYPE.  */\n static void\n-prepare_fresh_vtable (binfo, base_binfo, for_type)\n-     tree binfo, base_binfo, for_type;\n+prepare_fresh_vtable (binfo, for_type)\n+     tree binfo, for_type;\n {\n   tree basetype = BINFO_TYPE (binfo);\n   tree orig_decl = BINFO_VTABLE (binfo);\n+  /* This name is too simplistic.  We can have multiple basetypes for\n+     for_type, and we really want different names.  (mrs) */\n   tree name = build_type_pathname (VTABLE_NAME_FORMAT, basetype, for_type);\n   tree new_decl = build_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n   tree path;\n   int result;\n \n   /* Remember which class this vtable is really for.  */\n-#if 0\n-  DECL_VPARENT (new_decl) = BINFO_TYPE (base_binfo);\n-#endif\n   DECL_CONTEXT (new_decl) = for_type;\n \n   TREE_STATIC (new_decl) = 1;\n@@ -753,64 +688,16 @@ prepare_fresh_vtable (binfo, base_binfo, for_type)\n   n_vtable_elems += list_length (BINFO_VIRTUALS (binfo));\n #endif\n \n+#if 0 /* Now done in finish_vtable_vardecl */\n   /* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */\n   import_export_vtable (new_decl, for_type);\n+#endif\n \n   if (TREE_VIA_VIRTUAL (binfo))\n     my_friendly_assert (binfo == binfo_member (BINFO_TYPE (binfo),\n \t\t\t\t   CLASSTYPE_VBASECLASSES (current_class_type)),\n \t\t\t170);\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n-  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n-\n-  /* Mark all types between FOR_TYPE and TYPE as having been\n-     touched, so that if we change virtual function table entries,\n-     new vtables will be initialized.  We may reach the virtual\n-     baseclass via ambiguous intervening baseclasses.  This\n-     loop makes sure we get through to the actual baseclass we marked.\n-\n-     Also, update the vtable entries to reflect the overrides\n-     of the top-most class (short of the top type).  */\n-\n-  do\n-    {\n-      result = get_base_distance (basetype, for_type, 0, &path);\n-      for_type = path;\n-      while (path)\n-\t{\n-\t  tree path_binfo = path;\n-\t  tree path_type = BINFO_TYPE (path);\n-\n-\t  if (TREE_VIA_VIRTUAL (path))\n-\t    path_binfo = binfo_member (path_type,\n-\t\t\t\t       CLASSTYPE_VBASECLASSES (current_class_type));\n-\n-\t  SET_BINFO_VTABLE_PATH_MARKED (path_binfo);\n-\t  if (BINFO_INHERITANCE_CHAIN (path)\n-\t      && CLASSTYPE_VFIELD (path_type) != NULL_TREE\n-\t      && (DECL_NAME (CLASSTYPE_VFIELD (BINFO_TYPE (binfo)))\n-\t\t  == DECL_NAME (CLASSTYPE_VFIELD (path_type)))\n-\t      /* This is the baseclass just before the original FOR_TYPE.  */\n-\t      && BINFO_INHERITANCE_CHAIN (BINFO_INHERITANCE_CHAIN (path)) == NULL_TREE)\n-\t    {\n-\t      tree old_virtuals = TREE_CHAIN (BINFO_VIRTUALS (binfo));\n-\t      tree new_virtuals = TREE_CHAIN (BINFO_VIRTUALS (path_binfo));\n-\t      if (flag_dossier)\n-\t\t{\n-\t\t  old_virtuals = TREE_CHAIN (old_virtuals);\n-\t\t  new_virtuals = TREE_CHAIN (new_virtuals);\n-\t\t}\n-\t      while (old_virtuals)\n-\t\t{\n-\t\t  TREE_VALUE (old_virtuals) = TREE_VALUE (new_virtuals);\n-\t\t  old_virtuals = TREE_CHAIN (old_virtuals);\n-\t\t  new_virtuals = TREE_CHAIN (new_virtuals);\n-\t\t}\n-\t    }\n-\t  path = BINFO_INHERITANCE_CHAIN (path);\n-\t}\n-    }\n-  while (result == -2);\n }\n \n /* Access the virtual function table entry that logically\n@@ -822,9 +709,6 @@ get_vtable_entry (virtuals, base_fndecl)\n      tree virtuals, base_fndecl;\n {\n   unsigned HOST_WIDE_INT i = (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n-#ifdef VTABLE_USES_MASK\n-\t   && 0\n-#endif\n \t   ? (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))\n \t      & (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1))\n \t   : TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl)));\n@@ -850,108 +734,23 @@ static void\n modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n      tree old_entry_in_list, new_entry, fndecl;\n {\n-  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (old_entry_in_list));\n-  tree vindex;\n+  tree base_fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (old_entry_in_list)), 0);\n \n #ifdef NOTQUITE\n-  cp_warning (\"replaced %D with %D\", DECL_ASSEMBLER_NAME (TREE_OPERAND (base_pfn, 0)), DECL_ASSEMBLER_NAME (fndecl));\n+  cp_warning (\"replaced %D with %D\", DECL_ASSEMBLER_NAME (base_fndecl),\n+\t      DECL_ASSEMBLER_NAME (fndecl));\n #endif\n-  /* We can't put in the really right offset information\n-     here, since we have not yet laid out the class to\n-     take into account virtual base classes.  */\n   TREE_VALUE (old_entry_in_list) = new_entry;\n-  vindex = DECL_VINDEX (TREE_OPERAND (base_pfn, 0));\n-  if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n-    DECL_VINDEX (fndecl) = vindex;\n-  else\n-    {\n-      if (! tree_int_cst_equal (DECL_VINDEX (fndecl), vindex)\n-\t  && ! doing_hard_virtuals)\n-\t{\n-\t  pending_hard_virtuals\n-\t    = tree_cons (fndecl, FNADDR_FROM_VTABLE_ENTRY (new_entry),\n-\t\t\t pending_hard_virtuals);\n-\t  TREE_TYPE (pending_hard_virtuals) = TREE_OPERAND (base_pfn, 0);\n-\t  return;\n-\t}\n-    }\n-}\n-\n-/* Check to ensure that the virtual function table slot in VFIELD,\n-   found by DECL_VINDEX of the BASE_FNDECL is in fact from a parent\n-   virtual function table that is the same parent as for the\n-   BASE_FNDECL given to us.  */\n-\n-static int\n-related_vslot (base_fndecl, vfields, type)\n-     tree base_fndecl, vfields, type;\n-{\n-  tree base_context = TYPE_MAIN_VARIANT (DECL_CONTEXT (base_fndecl));\n-  tree base;\n-  tree path;\n-  int distance;\n-\n-  if (TREE_CODE (vfields) != TREE_LIST)\n-    abort ();\n-  base = VF_NORMAL_VALUE (vfields);\n-  if (base == NULL_TREE)\n-    base = VF_BASETYPE_VALUE (vfields);\n-\n-  /* The simple right way to do this is to ensure that the context of\n-     the base virtual function is found along the leftmost path\n-     between the most derived type associated with the vfield and the\n-     current type.  */\n-  distance = get_base_distance (base, type, 0, &path);\n-  if (distance == -1)\n-    abort ();\n-  while (path)\n-    {\n-      if (BINFO_TYPE (path) == base_context)\n-\treturn 1;\n-      path = BINFO_INHERITANCE_CHAIN (path);\n-    }\n \n-  /* given:\n-\t\tRr\n-\t       / \\\n-\t      Mm  Hh\n-\t       \\ /\n-\t        P\n-\n-     make sure we fill in P's vtable for H with overrides of r,\n-     but be cautious of virtual base classes.  */\n-  /* Combine the two below after debugging. */\n-  if (get_base_distance (base_context, base, 0, &path) != -1)\n+  /* Now assign virtual dispatch information, if unset.  */\n+  /* We can dispatch this, through any overridden base function. */\n+  if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n     {\n-      while (path)\n-\t{\n-\t  if (TREE_VIA_VIRTUAL (path))\n-\t    return 0;\n-\t  path = BINFO_INHERITANCE_CHAIN (path);\n-\t}\n-      /* Make sure that:\n-\n-\t\t RRB\n-\t\t |\n-\t    RL   RR\n-\t      \\ /\n-\t   L   R\n-\t    \\ /\n-\t     C\n-\n-\t returns 0.   VF_BASETYPE_VALUE is RL, base_context is RRB, type is C,\n-\t and the vfield we are checking is R.  */\n-      if (VF_BASETYPE_VALUE (vfields)\n-\t  && get_base_distance (base_context, VF_BASETYPE_VALUE (vfields), 0, &path) == -1\n-\t  && get_base_distance (VF_BASETYPE_VALUE (vfields), base_context, 0, &path) == -1)\n-\treturn 0;\n-      return 1;\n+      DECL_VINDEX (fndecl) = DECL_VINDEX (base_fndecl);\n+      DECL_CONTEXT (fndecl) = DECL_CONTEXT (base_fndecl);\n     }\n-  return 0;\n }\n \n-static void modify_vtable_entries ();\n-\n /* Access the virtual function table entry i.  VIRTUALS is the virtual\n    function table's initializer.  */\n static tree\n@@ -967,462 +766,42 @@ get_vtable_entry_n (virtuals, i)\n   return virtuals;\n }\n \n-#if 0\n-/* Find the vfield (in the CLASSTYPE_VFIELDS chain) of the given binfo. */\n+/* Add a virtual function to all the appropriate vtables for the class\n+   T.  DECL_VINDEX(X) should be error_mark_node, if we want to\n+   allocate a new slot in our table.  If it is error_mark_node, we\n+   know that no other function from another vtable is overridden by X.\n+   HAS_VIRTUAL keeps track of how many virtuals there are in our main\n+   vtable for the type, and we build upon the PENDING_VIRTUALS list\n+   and return it.  */\n static tree\n-find_associated_vfield (binfo, t)\n-     tree t, binfo;\n-{\n-  tree vfields;\n-  tree save_vfields = 0;\n-  for (vfields = CLASSTYPE_VFIELDS (t); vfields; vfields = TREE_CHAIN (vfields))\n-    {\n-      if (VF_BINFO_VALUE (vfields) == binfo)\n-\treturn vfields;\n-    }\n-  for (vfields = CLASSTYPE_VFIELDS (t); vfields; vfields = TREE_CHAIN (vfields))\n-    {\n-      tree path;\n-      get_base_distance (VF_BASETYPE_VALUE (vfields), t, 0, &path);\n-      while (path)\n-\t{\n-\t  if (path == binfo)\n-\t    return vfields;\n-\t  path = BINFO_INHERITANCE_CHAIN (path);\n-\t}\n-    }      \n-  /* This is from a virtual base class's vtable, hopefully. */\n-  return 0;\n-}\n-#endif\n-\n-\n-/* Returns != 0 is the BINFO is the normal one for the main vfield, 0\n-   otherwise. We don't have to worry about the finding BINFO in\n-   CLASSTYPE_VBASECLASSES, if it is virtual, as we never inherit\n-   vtables from virtual base classes.  */\n-static int\n-is_normal (binfo, t)\n-     tree t, binfo;\n-{\n-  int i = CLASSTYPE_VFIELD_PARENT (t);\n-  if (i != -1)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (t)), i);\n-      if (base_binfo == binfo)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-/* Modify virtual function tables in lattice topped by T to place\n-   FNDECL in tables which previously held BASE_FNDECL.  This marches\n-   through the vtables directly, looking for exact mactes to\n-   modify. */\n-static void\n-modify_other_vtable_entries (t, binfo, fndecl, base_fndecl, pfn)\n-     tree t, binfo;\n-     tree fndecl, base_fndecl, pfn;\n-{\n-  tree virtuals;\n-  tree binfos;\n-  int i, n_baselinks;\n-  unsigned HOST_WIDE_INT n;\n-#if 0\n-  tree vfields;\n-#endif\n-  \n-  virtuals = BINFO_VIRTUALS (binfo);\n-  n = 0;\n-  while (virtuals)\n-    {\n-      tree current_fndecl = TREE_VALUE (virtuals);\n-      tree *binfo2_ptr;\n-      current_fndecl = FNADDR_FROM_VTABLE_ENTRY (current_fndecl);\n-      current_fndecl = TREE_OPERAND (current_fndecl, 0);\n-      if (current_fndecl && SAME_FN (current_fndecl, base_fndecl))\n-\t{\n-\t  /* Most of the below was copied from\n-\t     modify_vtable_entries (t, fndecl, base_fndecl, pfn); */\n-\t  tree base_offset, offset;\n-\t  tree context = DECL_CLASS_CONTEXT (fndecl);\n-\t  tree vfield = CLASSTYPE_VFIELD (t);\n-\t  int normal = 1;\n-\t  tree binfo2, this_offset;\n-\t  tree base, path;\n-\n-\t  offset = integer_zero_node;\n-\t  if (context != t && TYPE_USES_COMPLEX_INHERITANCE (t))\n-\t    {\n-\t      offset = virtual_offset (context, CLASSTYPE_VBASECLASSES (t), offset);\n-\t      if (offset == NULL_TREE)\n-\t\t{\n-\t\t  tree binfo = get_binfo (context, t, 0);\n-\t\t  offset = BINFO_OFFSET (binfo);\n-\t\t}\n-\t    }\n-\n-\t  /* Get the path starting from the deepest base class CONTEXT\n-\t     of T (i.e., first defn of BASE_FNDECL).  */\n-\t  get_base_distance (binfo, t, 0, &path);\n-\t  binfo2_ptr = 0;\n-\n-\t  /* Get our best approximation of what to use for constructing\n-\t     the virtual function table for T.  */\n-\t  do\n-\t    {\n-\t      /* Walk from base toward derived, stopping at the\n-\t\t most derived baseclass that matters.  That baseclass\n-\t\t is exactly the one which provides the vtable along\n-\t\t the VFIELD spine, but no more.  */\n-\t      if (TREE_VIA_VIRTUAL (path))\n-\t\t{\n-\t\t  base = path;\n-\t\t  binfo2 = binfo_member (BINFO_TYPE (base), CLASSTYPE_VBASECLASSES (t));\n-\t\t  /* This should never have TREE_USED set. */\n-\t\t  binfo2_ptr = 0;\n-\t\t  break;\n-\t\t}\n-\t      if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE\n-\t\t  || (BINFO_TYPE (BINFO_BASETYPE (BINFO_INHERITANCE_CHAIN (path), 0))\n-\t\t      != BINFO_TYPE (path))\n-\t\t  || BINFO_INHERITANCE_CHAIN (BINFO_INHERITANCE_CHAIN (path)) == NULL_TREE)\n-\t\t{\n-\t\t  base = path;\n-\t\t  binfo2 = base;\n-\t\t  binfo2_ptr = 0;\n-\t\t  break;\n-\t\t}\n-\t      path = BINFO_INHERITANCE_CHAIN (path);\n-\t      binfo2_ptr = &BINFO_INHERITANCE_CHAIN (path);\n-\t    }\n-\t  while (1);\n-\n-\t  /* Find the right offset for the this pointer based on the base\n-\t     class we just found.  */\n-\t  base_offset = BINFO_OFFSET (binfo2);\n-\t  this_offset = size_binop (MINUS_EXPR, offset, base_offset);\n-\n-\t  /* Make sure we can modify the derived association with immunity.  */\n-\t  if (TREE_USED (binfo2)) {\n-\t    my_friendly_assert (*binfo2_ptr == binfo2, 999);\n-\t    *binfo2_ptr = copy_binfo (binfo2);\n-\t  }\n-\n-#if 0\n-\t  vfields = find_associated_vfield (binfo2, t);\n-\n-\t  /* We call this case NORMAL iff this virtual function table\n-\t     pointer field has its storage reserved in this class.\n-\t     This is normally the case without virtual baseclasses\n-\t     or off-center multiple baseclasses.  */\n-\t  normal = (vfields && vfield != NULL_TREE\n-\t\t    && VF_BASETYPE_VALUE (vfields) == DECL_FCONTEXT (vfield)\n-\t\t    && (VF_BINFO_VALUE (vfields) == NULL_TREE\n-\t\t\t|| ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields))));\n-\n-\t  if (normal && VF_BINFO_VALUE (vfields))\n-\t    /* Everything looks normal so far...check that we are really\n-\t       working from VFIELD's basetype, and not some other appearance\n-\t       of that basetype in the lattice.  */\n-\t    normal = (VF_BINFO_VALUE (vfields)\n-\t\t      == get_binfo (VF_BASETYPE_VALUE (vfields), t, 0));\n-#else\n-\t  normal = is_normal (binfo2, t);\n-#endif\n-\n-\t  if (normal)\n-\t    {\n-\t      /* In this case, it is *type*'s vtable we are modifying.\n-\t\t We start with the approximation that it's vtable is that\n-\t\t of the immediate base class.  */\n-\t      binfo2 = TYPE_BINFO (t);\n-\t      if (! BINFO_NEW_VTABLE_MARKED (binfo2))\n-\t\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* This is our very own copy of `basetype' to play with.\n-\t\t Later, we will fill in all the virtual functions\n-\t\t that override the virtual functions in these base classes\n-\t\t which are not defined by the current type.  */\n-\t      if (! BINFO_NEW_VTABLE_MARKED (binfo2))\n-\t\tprepare_fresh_vtable (binfo2, base, t);\n-\t    }\n-\n-#ifdef NOTQUITE\n-\t  cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo2)));\n-#endif\n-\t  modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo2), n),\n-\t\t\t       build_vtable_entry (this_offset, pfn),\n-\t\t\t       fndecl);\n-\t} else if (current_fndecl && DECL_NAME (current_fndecl) == DECL_NAME (base_fndecl))\n-\t  {\n-#ifdef NOTQUITE\n-\t    cp_warning (\"%D not replaced (looking for %D) in %D\", DECL_ASSEMBLER_NAME (current_fndecl), DECL_ASSEMBLER_NAME (base_fndecl), DECL_NAME (BINFO_VTABLE (binfo)));\n-#endif\n-\t  }\n-      ++n;\n-      virtuals = TREE_CHAIN (virtuals);\n-    }\n-  binfos = BINFO_BASETYPES (binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      /* Don't modify virtual bases, as we share them down this way. */\n-      /* We hope that other places will get things down this direction. */\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tcontinue;\n-      modify_other_vtable_entries (t, base_binfo, fndecl, base_fndecl, pfn);\n-    }\n-}\n-\n-/* Modify virtual function tables in lattice topped by T to\n-   place FNDECL in tables which previously held BASE_FNDECL.\n-   PFN is just FNDECL wrapped in an ADDR_EXPR, so that it\n-   is suitable for placement directly into an initializer.\n-\n-   All distinct virtual function tables that this type uses\n-   must be updated.  */\n-static void\n-modify_vtable_entries (t, fndecl, base_fndecl, pfn)\n-     tree t;\n-     tree fndecl, base_fndecl, pfn;\n-{\n-  tree base_offset, offset;\n-  tree base_context = DECL_CONTEXT (base_fndecl);\n-  tree context = DECL_CLASS_CONTEXT (fndecl);\n-  tree vfield = CLASSTYPE_VFIELD (t);\n-  tree vfields, vbases;\n-  tree saved_pfn;\n-\n-#ifdef NOTQUITE\n-  cp_warning (\"modifing all %D into %D for %T\", base_fndecl, fndecl, t);\n-  if (DECL_CONTEXT (fndecl) != DECL_CONTEXT (base_fndecl))\n-    {\n-      cp_warning (\"switching contexts from %T to %T for %x\",\n-\t\t  DECL_CONTEXT (fndecl),\n-\t\t  DECL_CONTEXT (base_fndecl), fndecl);\n-      cp_warning (\"base was %D, new is %D\", DECL_ASSEMBLER_NAME (base_fndecl),\n-\t\t  DECL_ASSEMBLER_NAME(fndecl));\n-    }\n-#endif\n-#if 0\n-  /* this is wrong, see p4736a.C testcase */\n-  DECL_CONTEXT (fndecl) = DECL_CONTEXT (base_fndecl);\n-#endif\n-\n-  offset = integer_zero_node;\n-  if (context != t && TYPE_USES_COMPLEX_INHERITANCE (t))\n-    {\n-      offset = virtual_offset (context, CLASSTYPE_VBASECLASSES (t), offset);\n-      if (offset == NULL_TREE)\n-\t{\n-\t  tree binfo = get_binfo (context, t, 0);\n-\t  offset = BINFO_OFFSET (binfo);\n-\t}\n-    }\n-\n-  /* For each layer of base class (i.e., the first base class, and each\n-     virtual base class from that one), modify the virtual function table\n-     of the derived class to contain the new virtual function.\n-     A class has as many vfields as it has virtual base classes (total).  */\n-  for (vfields = CLASSTYPE_VFIELDS (t); vfields; vfields = TREE_CHAIN (vfields))\n-    {\n-      int normal = 1;\n-      tree binfo, this_offset;\n-      tree base, path;\n-\n-      if (!related_vslot (base_fndecl, vfields, t))\n-\t  continue;\n-\n-      /* Find the right base class for this derived class, call it BASE.  */\n-      base = VF_BASETYPE_VALUE (vfields);\n-\n-      /* Get the path starting from the deepest base class CONTEXT\n-\t of T (i.e., first defn of BASE_FNDECL).  */\n-      get_base_distance (DECL_CONTEXT (base_fndecl), t, 0, &path);\n-\n-      /* Get our best approximation of what to use for constructing\n-\t the virtual function table for T.  */\n-      do\n-\t{\n-\t  /* Walk from base toward derived, stopping at the\n-\t     most derived baseclass that matters.  That baseclass\n-\t     is exactly the one which provides the vtable along\n-\t     the VFIELD spine, but no more.  */\n-\t  if (TREE_VIA_VIRTUAL (path))\n-\t    {\n-\t      base = path;\n-\t      binfo = binfo_member (BINFO_TYPE (base), CLASSTYPE_VBASECLASSES (t));\n-\t      break;\n-\t    }\n-\t  if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE\n-\t      || (BINFO_TYPE (BINFO_BASETYPE (BINFO_INHERITANCE_CHAIN (path), 0))\n-\t\t  != BINFO_TYPE (path))\n-\t      || BINFO_INHERITANCE_CHAIN (BINFO_INHERITANCE_CHAIN (path)) == NULL_TREE)\n-\t    {\n-\t      base = path;\n-\t      binfo = base;\n-\t      break;\n-\t    }\n-\t  path = BINFO_INHERITANCE_CHAIN (path);\n-\t}\n-      while (1);\n-\n-      /* Find the right offset for the this pointer based on the base\n-\t class we just found.  */\n-      base_offset = BINFO_OFFSET (binfo);\n-      this_offset = size_binop (MINUS_EXPR, offset, base_offset);\n-\n-      /* Make sure we can modify the derived association with immunity.  */\n-      if (TREE_USED (TYPE_BINFO (t)))\n-\tTYPE_BINFO (t) = copy_binfo (TYPE_BINFO (t));\n-\n-      /* We call this case NORMAL iff this virtual function table\n-\t pointer field has its storage reserved in this class.\n-\t This is normally the case without virtual baseclasses\n-\t or off-center multiple baseclasses.  */\n-      normal = (vfield != NULL_TREE\n-\t\t&& VF_BASETYPE_VALUE (vfields) == DECL_FCONTEXT (vfield)\n-\t\t&& (VF_BINFO_VALUE (vfields) == NULL_TREE\n-\t\t    || ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields))));\n-\n-      if (normal && VF_BINFO_VALUE (vfields))\n-\t/* Everything looks normal so far...check that we are really\n-\t   working from VFIELD's basetype, and not some other appearance\n-\t   of that basetype in the lattice.  */\n-\tnormal = (VF_BINFO_VALUE (vfields)\n-\t\t  == get_binfo (VF_BASETYPE_VALUE (vfields), t, 0));\n-\n-      if (normal)\n-\t{\n-\t  /* In this case, it is *type*'s vtable we are modifying.\n-\t     We start with the approximation that it's vtable is that\n-\t     of the immediate base class.  */\n-\t  base_context = t;\n-\t  binfo = TYPE_BINFO (t);\n-\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t    build_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n-\t}\n-      else\n-\t{\n-\t  /* This is our very own copy of `basetype' to play with.\n-\t     Later, we will fill in all the virtual functions\n-\t     that override the virtual functions in these base classes\n-\t     which are not defined by the current type.  */\n-\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t    prepare_fresh_vtable (binfo, base, t);\n-\t}\n-\n-      saved_pfn = get_vtable_entry (BINFO_VIRTUALS (binfo), base_fndecl);\n-      if (saved_pfn)\n-\tsaved_pfn = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (saved_pfn)), 0);\n-#ifdef NOTQUITE\n-      cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo)));\n-#endif\n-      /* The this_offset can be wrong, if we try and modify an entry\n-\t that had been modified once before. */\n-      if (saved_pfn && ! SAME_FN (saved_pfn, fndecl))\n-        {\n-\t  modify_vtable_entry (get_vtable_entry (BINFO_VIRTUALS (binfo), base_fndecl),\n-\t\t\t       build_vtable_entry (this_offset, pfn),\n-\t\t\t       fndecl);\n-\t  modify_other_vtable_entries (t, TYPE_BINFO (t), fndecl, saved_pfn, pfn);\n-\t}\n-    }\n-  for (vbases = CLASSTYPE_VBASECLASSES (t); vbases; vbases = TREE_CHAIN (vbases))\n-    {\n-      tree this_offset;\n-      tree base, path;\n-\n-      if (! BINFO_VTABLE (vbases))\n-\t/* There are only two ways that a type can fail to have\n-\t   virtual functions: neither it nor any of its base\n-\t   types define virtual functions (in which case\n-\t   no updating need be done), or virtual functions\n-\t   accessible to it come from virtual base classes\n-\t   (in which case we have or will get them modified\n-\t   in other passes of this loop).  */\n-\tcontinue;\n-\n-      base = BINFO_TYPE (vbases);\n-      path = NULL_TREE;\n-\n-      if (base != base_context\n-\t  && get_base_distance (base_context, base, 0, &path) == -1)\n-\tcontinue;\n-\n-      if (path)\n-\tthis_offset = size_binop (MINUS_EXPR, offset, BINFO_OFFSET (path));\n-      else\n-\tthis_offset = offset;\n-\n-      /* Doesn't matter if not actually from this virtual base class,\n-         but shouldn't come from deeper virtual baseclasses.  The enclosing\n-\t loop should take care of such baseclasses.  */\n-      while (path)\n-\t{\n-\t  if (TREE_VIA_VIRTUAL (path))\n-\t    goto skip;\n-\t  path = BINFO_INHERITANCE_CHAIN (path);\n-\t}\n-\n-      base_offset = BINFO_OFFSET (vbases);\n-      this_offset = size_binop (MINUS_EXPR, this_offset, base_offset);\n-\n-      /* Make sure we can modify the derived association with immunity.  */\n-      if (TREE_USED (TYPE_BINFO (t)))\n-\tTYPE_BINFO (t) = copy_binfo (TYPE_BINFO (t));\n-\n-      /* This is our very own copy of `basetype' to play with.  */\n-      if (! BINFO_NEW_VTABLE_MARKED (vbases))\n-\t{\n-\t  tree context_binfo = binfo_value (base_context, base);\n-\t  prepare_fresh_vtable (vbases, context_binfo, t);\n-\t}\n-      saved_pfn = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (get_vtable_entry (BINFO_VIRTUALS (vbases), base_fndecl))), 0);\n-#ifdef NOTQUITE\n-      cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (vbases)));\n-#endif\n-      /* The this_offset can be wrong, if we try and modify an entry\n-\t that had been modified once before. */\n-      if (! SAME_FN (saved_pfn, fndecl))\n-\t{\n-\t  modify_vtable_entry (get_vtable_entry (BINFO_VIRTUALS (vbases),\n-\t\t\t\t\t\t base_fndecl),\n-\t\t\t       build_vtable_entry (this_offset, pfn),\n-\t\t\t       fndecl);\n-\t  modify_other_vtable_entries (t, TYPE_BINFO (t), fndecl, saved_pfn, pfn);\n-\t}\n-    skip: {}\n-    }\n-}\n-\n-static tree\n-add_virtual_function (pending_virtuals, has_virtual, x, t)\n+add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n      tree pending_virtuals;\n      int *has_virtual;\n-     tree x;\n+     tree fndecl;\n      tree t; /* Structure type. */\n {\n-  int debug_vbase = 1;\n-\n   /* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely\n      convert to void *.  Make such a conversion here.  */\n-  tree vfn = build1 (ADDR_EXPR, ptr_type_node, x);\n+  tree vfn = build1 (ADDR_EXPR, ptr_type_node, fndecl);\n   TREE_CONSTANT (vfn) = 1;\n \n-  /* current_class_type may be NULL_TREE in case of error.  */\n-  if (current_class_type && !flag_vtable_thunks)\n-    TREE_ADDRESSABLE (x) = CLASSTYPE_VTABLE_NEEDS_WRITING (current_class_type);\n+#ifndef DUMB_USER\n+  if (current_class_type == 0)\n+    cp_warning (\"internal problem, current_class_type is zero when adding `%D', please report\",\n+\t\tfndecl);\n+  if (current_class_type && t != current_class_type)\n+    cp_warning (\"internal problem, current_class_type differs when adding `%D', please report\",\n+\t\tfndecl);\n+#endif\n+\n+  if (!flag_vtable_thunks)\n+    TREE_ADDRESSABLE (fndecl) = CLASSTYPE_VTABLE_NEEDS_WRITING (t);\n \n   /* If the virtual function is a redefinition of a prior one,\n      figure out in which base class the new definition goes,\n      and if necessary, make a fresh virtual function table\n      to hold that entry.  */\n-  if (DECL_VINDEX (x) == error_mark_node)\n+  if (DECL_VINDEX (fndecl) == error_mark_node)\n     {\n       tree entry;\n \n@@ -1434,9 +813,6 @@ add_virtual_function (pending_virtuals, has_virtual, x, t)\n         }\n \n       /* Build a new INT_CST for this DECL_VINDEX.  */\n-#ifdef VTABLE_USES_MASK\n-      SET_DECL_VINDEX (x, build_int_2 (++(*has_virtual), 0));\n-#else\n       {\n \tstatic tree index_table[256];\n \ttree index;\n@@ -1451,66 +827,20 @@ add_virtual_function (pending_virtuals, has_virtual, x, t)\n \telse\n \t  index = index_table[i];\n \n-\tDECL_VINDEX (x) = index;\n+\t/* Now assign virtual dispatch information. */\n+\tDECL_VINDEX (fndecl) = index;\n+\tDECL_CONTEXT (fndecl) = t;\n       }\n-#endif\n       entry = build_vtable_entry (integer_zero_node, vfn);\n-      pending_virtuals = tree_cons (DECL_VINDEX (x), entry, pending_virtuals);\n+      pending_virtuals = tree_cons (DECL_VINDEX (fndecl), entry, pending_virtuals);\n     }\n-  /* Happens if declared twice in class or we're not in a class definition.\n-     We will give error later or we've already given it.  */\n-  else if (TREE_CODE (DECL_VINDEX (x)) == INTEGER_CST\n-\t   || current_class_type == NULL_TREE)\n-    return pending_virtuals;\n-  else if (debug_vbase && TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+  /* Might already be INTEGER_CST if declared twice in class.  We will\n+     give error later or we've already given it.  */\n+  else if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n     {\n       /* Need an entry in some other virtual function table.\n          Deal with this after we have laid out our virtual base classes.  */\n-      pending_hard_virtuals = temp_tree_cons (x, vfn, pending_hard_virtuals);\n-    }\n-  else\n-    {\n-      /* Need an entry in some other virtual function table.\n-         We can do this now.  */\n-      tree base_fndecl_list = DECL_VINDEX (x), base_fndecls, prev = 0;\n-      tree vtable_context = DECL_FCONTEXT (CLASSTYPE_VFIELD (current_class_type));\n-      tree true_base_fndecl = 0;\n-\n-      /* First assign DECL_VINDEX from the base vfn with which\n-\t we share our vtable.  */\n-      base_fndecls = base_fndecl_list;\n-      while (base_fndecls)\n-\t{\n-\t  if (TREE_CHAIN (base_fndecls) == NULL_TREE\n-\t      || DECL_FCONTEXT (CLASSTYPE_VFIELD (DECL_CLASS_CONTEXT (TREE_VALUE (base_fndecls)))) == vtable_context)\n-\t    {\n-\t      true_base_fndecl = TREE_VALUE (base_fndecls);\n-\t      modify_vtable_entries (current_class_type, x,\n-\t\t\t\t     true_base_fndecl, vfn);\n-\t      if (prev)\n-\t\tTREE_CHAIN (prev) = TREE_CHAIN (base_fndecls);\n-\t      else\n-\t\tbase_fndecl_list = prev;\n-\t      break;\n-\t    }\n-\t  prev = base_fndecls;\n-\t  base_fndecls = TREE_CHAIN (base_fndecls);\n-\t}\n-\n-      /* Now fill in the rest of the vtables.  */\n-      base_fndecls = base_fndecl_list;\n-      while (base_fndecls)\n-\t{\n-\t  /* If we haven't found one we like, first one wins.  */\n-\t  if (true_base_fndecl == 0)\n-\t    true_base_fndecl = TREE_VALUE (base_fndecls);\n-\n-\t  modify_vtable_entries (current_class_type, x,\n-\t\t\t\t TREE_VALUE (base_fndecls), vfn);\n-\t  base_fndecls = TREE_CHAIN (base_fndecls);\n-\t}\n-\n-      DECL_CONTEXT (x) = DECL_CONTEXT (true_base_fndecl);\n+      pending_hard_virtuals = temp_tree_cons (fndecl, vfn, pending_hard_virtuals);\n     }\n   return pending_virtuals;\n }\n@@ -2112,6 +1442,11 @@ finish_base_struct (t, b, t_binfo)\n \t      tree vfields;\n \t      first_vfn_base_index = i;\n \n+\t      /* Update these two, now that we know what vtable we are\n+\t\t going to extend.  This is so that we can add virtual\n+\t\t functions, and override them properly.  */\n+\t      BINFO_VTABLE (t_binfo) = TYPE_BINFO_VTABLE (basetype);\n+\t      BINFO_VIRTUALS (t_binfo) = TYPE_BINFO_VIRTUALS (basetype);\n \t      b->has_virtual = CLASSTYPE_VSIZE (basetype);\n \t      b->vfield = CLASSTYPE_VFIELD (basetype);\n \t      b->vfields = copy_list (CLASSTYPE_VFIELDS (basetype));\n@@ -2645,12 +1980,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n       }\n   }\n \n-#if 0\n-  TYPE_METHODS (t) = TREE_VEC_ELT (method_vec, 0)\n-    ? TREE_VEC_ELT (method_vec, 0) : TREE_VEC_ELT (method_vec, 1);\n-#else\n   TYPE_METHODS (t) = method_vec;\n-#endif\n \n   return method_vec;\n }\n@@ -2716,6 +2046,224 @@ duplicate_tag_error (t)\n   TYPE_CONTEXT (t) = NULL_TREE;\n }\n \n+/* finish up all new vtables. */\n+static void\n+finish_vtbls (binfo, do_self, t)\n+     tree binfo, t;\n+     int do_self;\n+{\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  /* Should we use something besides CLASSTYPE_VFIELDS? */\n+  if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+    {\n+      if (BINFO_NEW_VTABLE_MARKED (binfo))\n+\t{\n+\t  tree decl, context;\n+\n+\t  decl = BINFO_VTABLE (binfo);\n+\t  context = DECL_CONTEXT (decl);\n+\t  DECL_CONTEXT (decl) = 0;\n+\t  if (write_virtuals >= 0\n+\t      && DECL_INITIAL (decl) != BINFO_VIRTUALS (binfo))\n+\t    DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t\t\t    BINFO_VIRTUALS (binfo));\n+\t  finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n+\t  DECL_CONTEXT (decl) = context;\n+\t}\n+      CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n+    }\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int is_not_base_vtable =\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\t{\n+\t  base_binfo = binfo_member (BINFO_TYPE (base_binfo), CLASSTYPE_VBASECLASSES (t));\n+\t}\n+      finish_vtbls (base_binfo, is_not_base_vtable, t);\n+    }\n+}\n+\n+/* True if we should override the given BASE_FNDECL with the given\n+   FNDECL.  */\n+static int\n+overrides (fndecl, base_fndecl)\n+     tree fndecl, base_fndecl;\n+{\n+  /* Destructors have special names. */\n+  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl)) &&\n+      DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n+    return 1;\n+  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl)) ||\n+      DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n+    return 0;\n+  if (DECL_NAME (fndecl) == DECL_NAME (base_fndecl))\n+    {\n+      tree rettype, base_rettype, types, base_types;\n+#if 0\n+      retypes = TREE_TYPE (TREE_TYPE (fndecl));\n+      base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));\n+#endif\n+      types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+      base_types = TYPE_ARG_TYPES (TREE_TYPE (base_fndecl));\n+      if ((TYPE_READONLY (TREE_TYPE (TREE_VALUE (base_types)))\n+\t   == TYPE_READONLY (TREE_TYPE (TREE_VALUE (types))))\n+\t  && compparms (TREE_CHAIN (base_types), TREE_CHAIN (types), 3))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+static void\n+modify_one_vtable (binfo, t, fndecl, pfn)\n+     tree binfo, t, fndecl, pfn;\n+{\n+  tree virtuals;\n+  unsigned HOST_WIDE_INT n;\n+  \n+  virtuals = BINFO_VIRTUALS (binfo);\n+  n = 0;\n+  /* Skip RTTI fake object. */\n+  if (flag_dossier)\n+    {\n+      ++n;\n+      virtuals = TREE_CHAIN (virtuals);\n+    }\n+  while (virtuals)\n+    {\n+      tree current_fndecl = TREE_VALUE (virtuals);\n+      current_fndecl = FNADDR_FROM_VTABLE_ENTRY (current_fndecl);\n+      current_fndecl = TREE_OPERAND (current_fndecl, 0);\n+      if (current_fndecl && overrides (fndecl, current_fndecl))\n+\t{\n+\t  tree base_offset, offset;\n+\t  tree context = DECL_CLASS_CONTEXT (fndecl);\n+\t  tree vfield = CLASSTYPE_VFIELD (t);\n+\t  tree this_offset;\n+\n+\t  offset = integer_zero_node;\n+\t  if (context != t && TYPE_USES_COMPLEX_INHERITANCE (t))\n+\t    {\n+\t      offset = virtual_offset (context, CLASSTYPE_VBASECLASSES (t), offset);\n+\t      if (offset == NULL_TREE)\n+\t\t{\n+\t\t  tree binfo = get_binfo (context, t, 0);\n+\t\t  offset = BINFO_OFFSET (binfo);\n+\t\t}\n+\t    }\n+\n+\t  /* Find the right offset for the this pointer based on the base\n+\t     class we just found.  */\n+\t  base_offset = BINFO_OFFSET (binfo);\n+\t  this_offset = size_binop (MINUS_EXPR, offset, base_offset);\n+\n+\t  /* Make sure we can modify the derived association with immunity.  */\n+\t  if (TREE_USED (binfo)) {\n+\t    my_friendly_assert (0, 999);\n+#if 0\n+\t    my_friendly_assert (*binfo2_ptr == binfo, 999);\n+\t    *binfo2_ptr = copy_binfo (binfo);\n+#endif\n+\t  }\n+\t  if (binfo == TYPE_BINFO (t))\n+\t    {\n+\t      /* In this case, it is *type*'s vtable we are modifying.\n+\t\t We start with the approximation that it's vtable is that\n+\t\t of the immediate base class.  */\n+\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This is our very own copy of `basetype' to play with.\n+\t\t Later, we will fill in all the virtual functions\n+\t\t that override the virtual functions in these base classes\n+\t\t which are not defined by the current type.  */\n+\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t\tprepare_fresh_vtable (binfo, t);\n+\t    }\n+\n+#ifdef NOTQUITE\n+\t  cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo)));\n+#endif\n+\t  modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n+\t\t\t       build_vtable_entry (this_offset, pfn),\n+\t\t\t       fndecl);\n+\t}\n+      ++n;\n+      virtuals = TREE_CHAIN (virtuals);\n+    }\n+}\n+\n+/* These are the ones that are not through virtual base classes. */\n+static void\n+modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n+     tree binfo, t, fndecl, pfn;\n+     int do_self;\n+{\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  /* Should we use something besides CLASSTYPE_VFIELDS? */\n+  if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+    {\n+      modify_one_vtable (binfo, t, fndecl, pfn);\n+    }\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int is_not_base_vtable =\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      if (! TREE_VIA_VIRTUAL (base_binfo))\n+\tmodify_all_direct_vtables (base_binfo, is_not_base_vtable, t, fndecl, pfn);\n+    }\n+}\n+\n+/* These are the ones that are through virtual base classes. */\n+static void\n+modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl, pfn)\n+     tree binfo, t, fndecl, pfn;\n+     int do_self, via_virtual;\n+{\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  /* Should we use something besides CLASSTYPE_VFIELDS? */\n+  if (do_self && via_virtual && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+    {\n+      modify_one_vtable (binfo, t, fndecl, pfn);\n+    }\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int is_not_base_vtable =\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\t{\n+\t  via_virtual = 1;\n+\t  base_binfo = binfo_member (BINFO_TYPE (base_binfo), CLASSTYPE_VBASECLASSES (t));\n+\t}\n+      modify_all_indirect_vtables (base_binfo, is_not_base_vtable, via_virtual, t, fndecl, pfn);\n+    }\n+}\n+\n+static void\n+modify_all_vtables (t, fndecl, vfn)\n+     tree t, fndecl, vfn;\n+{\n+  /* Do these first, so that we will make use of any non-virtual class's\n+     vtable, over a virtual classes vtable. */\n+  modify_all_direct_vtables (TYPE_BINFO (t), 1, t, fndecl, vfn);\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n+    modify_all_indirect_vtables (TYPE_BINFO (t), 1, 0, t, fndecl, vfn);\n+}\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -2849,10 +2397,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (name))\n     warning (\"anonymous class type not used to declare any objects\");\n \n-#if 0\n-  /* This is set here, but it's never actually used anywhere.  (bpk) */\n-  leftmost_baseclasses = NULL_TREE;\n-#endif\n   if (TYPE_SIZE (t))\n     {\n       if (IS_AGGR_TYPE (t))\n@@ -3030,12 +2574,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      *tail_user_methods = x;\n \t      tail_user_methods = &DECL_NEXT_METHOD (x);\n \n-#if 0\n-\t      /* ??? What if we have duplicate declarations\n-\t\t in T's definition?  */\n-\t      if (DECL_CLASS_CONTEXT (x))\n-\t\tcontinue;\n-#endif\n \t      DECL_CLASS_CONTEXT (x) = t;\n \n \t      DECL_FIELD_SIZE (x) = 0;\n@@ -3125,19 +2663,20 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      if (DECL_INITIAL (x) == NULL_TREE)\n \t\tref_sans_init = 1;\n \n-\t      /* ARM $12.6.2: [A member initializer list] is the only\n-\t\t way to initialize a nonstatic const and reference\n-\t\t [member].  */\n+\t      /* ARM $12.6.2: [A member initializer list] (or, for an\n+\t\t aggregate, initialization by a brace-enclosed list) is the\n+\t\t only way to initialize nonstatic const and reference\n+\t\t members.  */\n \t      cant_synth_asn_ref = 1;\n \t      cant_have_default_ctor = 1;\n \t      TYPE_HAS_COMPLEX_INIT_REF (t) = 1;\n \n-\t      if (! TYPE_HAS_CONSTRUCTOR (t))\n+\t      if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n \t\t{\n \t\t  if (DECL_NAME (x))\n-\t\t    cp_pedwarn_at (\"non-static reference `%#D' in class without a constructor\", x);\n+\t\t    cp_warning_at (\"non-static reference `%#D' in class without a constructor\", x);\n \t\t  else\n-\t\t    cp_pedwarn_at (\"non-static reference in class without a constructor\", x);\n+\t\t    cp_warning_at (\"non-static reference in class without a constructor\", x);\n \t\t}\n \t    }\n \n@@ -3148,19 +2687,21 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      if (DECL_INITIAL (x) == NULL_TREE)\n \t\tconst_sans_init = 1;\n \n-\t      /* ARM $12.6.2: [A member initializer list] is the only\n-\t\t way to initialize a nonstatic const and reference\n-\t\t [member].  */\n+\t      /* ARM $12.6.2: [A member initializer list] (or, for an\n+\t\t aggregate, initialization by a brace-enclosed list) is the\n+\t\t only way to initialize nonstatic const and reference\n+\t\t members.  */\n \t      cant_synth_asn_ref = 1;\n \t      cant_have_default_ctor = 1;\n \t      TYPE_HAS_COMPLEX_INIT_REF (t) = 1;\n \n-\t      if (! TYPE_HAS_CONSTRUCTOR (t) && !IS_SIGNATURE (t))\n+\t      if (! TYPE_HAS_CONSTRUCTOR (t) && !IS_SIGNATURE (t)\n+\t\t  && extra_warnings)\n \t\t{\n \t\t  if (DECL_NAME (x))\n-\t\t    cp_pedwarn_at (\"non-static const member `%#D' in class without a constructor\", x);\n+\t\t    cp_warning_at (\"non-static const member `%#D' in class without a constructor\", x);\n \t\t  else\n-\t\t    cp_pedwarn_at (\"non-static const member in class without a constructor\", x);\n+\t\t    cp_warning_at (\"non-static const member in class without a constructor\", x);\n \t\t}\n \t    }\n \t  else\n@@ -3379,7 +2920,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t    DECL_VINDEX (dtor) = error_mark_node;\n \t  if (DECL_VINDEX (dtor))\n \t    pending_virtuals = add_virtual_function (pending_virtuals,\n-\t\t\t\t\t\t     &has_virtual, dtor, NULL_TREE);\n+\t\t\t\t\t\t     &has_virtual, dtor, t);\n \t  nonprivate_method = 1;\n \t}\n     }\n@@ -3711,9 +3252,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   if (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n     layout_decl (TYPE_NAME (t), 0);\n \n-  /* Now fix up any virtual base class types that we\n-     left lying around.  We must get these done\n-     before we try to lay out the virtual function table.  */\n+  /* Now fix up any virtual base class types that we left lying\n+     around.  We must get these done before we try to lay out the\n+     virtual function table.  */\n   doing_hard_virtuals = 1;\n   pending_hard_virtuals = nreverse (pending_hard_virtuals);\n \n@@ -3729,7 +3270,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t{\n \t  /* Update dossier info with offsets for virtual baseclasses.  */\n \t  if (flag_dossier && ! BINFO_NEW_VTABLE_MARKED (vbases))\n-\t    prepare_fresh_vtable (vbases, vbases, t);\n+\t    prepare_fresh_vtable (vbases, t);\n \n \t  vbases = TREE_CHAIN (vbases);\n \t}\n@@ -3740,113 +3281,11 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n #endif\n   while (pending_hard_virtuals)\n     {\n-      /* Need an entry in some other virtual function table.  */\n-      if (TREE_TYPE (pending_hard_virtuals))\n-\t{\n-\t  /* This is how we modify entries when a vfn's index changes\n-\t     between derived and base type.  */\n-\t  modify_vtable_entries (t, TREE_PURPOSE (pending_hard_virtuals),\n-\t\t\t\t TREE_TYPE (pending_hard_virtuals),\n-\t\t\t\t TREE_VALUE (pending_hard_virtuals));\n-\t}\n-      else\n-\t{\n-\t  /* This is how we modify entries when a vfn comes from\n-\t     a virtual baseclass.  */\n-\t  tree base_fndecls = DECL_VINDEX (TREE_PURPOSE (pending_hard_virtuals));\n-\t  /* Only do this, if it was missed before. */\n-\t  if (TREE_CODE (base_fndecls) != INTEGER_CST)\n-\t    {\n-\t      my_friendly_assert (base_fndecls != error_mark_node, 176);\n-\t      while (base_fndecls)\n-\t\t{\n-\t\t  modify_vtable_entries (t, TREE_PURPOSE (pending_hard_virtuals),\n-\t\t\t\t\t TREE_VALUE (base_fndecls),\n-\t\t\t\t\t TREE_VALUE (pending_hard_virtuals));\n-\t\t  modify_other_vtable_entries (t, TYPE_BINFO (t),\n-\t\t\t\t\t       TREE_PURPOSE (pending_hard_virtuals),\n-\t\t\t\t\t       TREE_VALUE (base_fndecls),\n-\t\t\t\t\t       TREE_VALUE (pending_hard_virtuals));\n-\t\t  base_fndecls = TREE_CHAIN (base_fndecls);\n-\t\t}\n-\t    } else {\n-#ifdef NOTQUITE\n-\t      cp_warning (\"missed bases for `%D'\", TREE_PURPOSE (pending_hard_virtuals));\n-#endif\n-\t    }\n-\t}\n+      modify_all_vtables (t,\n+\t\t\t  TREE_PURPOSE (pending_hard_virtuals),\n+\t\t\t  TREE_VALUE (pending_hard_virtuals));\n       pending_hard_virtuals = TREE_CHAIN (pending_hard_virtuals);\n     }\n-\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    {\n-      tree vbases;\n-\n-      vbases = CLASSTYPE_VBASECLASSES (t);\n-      CLASSTYPE_N_VBASECLASSES (t) = list_length (vbases);\n-\n-      /* This loop makes all the entries in the virtual function tables\n-\t of interest contain the \"latest\" version of the functions\n-\t we have defined.  */\n-\n-      while (vbases)\n-\t{\n-\t  tree virtuals = BINFO_VIRTUALS (vbases);\n-\n-\t  if (virtuals)\n-\t    {\n-\t      /* Get past the `null' vtable entry...  */\n-\t      virtuals = TREE_CHAIN (virtuals);\n-\t      /* and the `dossier' vtable entry if we're doing dossiers.  */\n-\t      if (flag_dossier)\n-\t\tvirtuals = TREE_CHAIN (virtuals);\n-\t    }\n-\n-\t  while (virtuals != NULL_TREE)\n-\t    {\n-\t      tree pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals));\n-\t      tree base_fndecl = TREE_OPERAND (pfn, 0);\n-\t      tree decl = get_first_matching_virtual (TYPE_BINFO (t), base_fndecl,\n-\t\t\t\t\t\t      DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl)));\n-\t      tree context = DECL_CLASS_CONTEXT (decl);\n-\t      if (! SAME_FN (decl, base_fndecl))\n-\t\t{\n-\t\t  tree base_context = DECL_CLASS_CONTEXT (base_fndecl);\n-\t\t  tree binfo = NULL_TREE;\n-#if 0\n-\t\t  tree these_virtuals;\n-\t\t  unsigned HOST_WIDE_INT i\n-\t\t    = (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))\n-\t\t       & (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1));\n-#endif\n-\n-\t\t  if (TYPE_USES_VIRTUAL_BASECLASSES (context))\n-\t\t    binfo = virtual_member (base_context,\n-\t\t\t\t\t    CLASSTYPE_VBASECLASSES (context));\n-\t\t  if (binfo == NULL_TREE)\n-\t\t    binfo = binfo_value (base_context, context);\n-\t\t  if (binfo != NULL_TREE)\n-\t\t    {\n-#if 1\n-\t\t      pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (get_vtable_entry (BINFO_VIRTUALS (binfo), base_fndecl)));\n-#else\n-\t\t      these_virtuals = BINFO_VIRTUALS (binfo);\n-\n-\t\t      while (i-- > 0)\n-\t\t\tthese_virtuals = TREE_CHAIN (these_virtuals);\n-\t\t      pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (these_virtuals));\n-#endif\n-\t\t      pfn = build1 (ADDR_EXPR, ptr_type_node, decl);\n-\t\t      TREE_CONSTANT (pfn) = 1;\n-\t\t      modify_vtable_entries (t, decl, base_fndecl, pfn);\n-\t\t    }\n-\t\t}\n-\t      virtuals = TREE_CHAIN (virtuals);\n-\t    }\n-\n-\t  vbases = TREE_CHAIN (vbases);\n-\t}\n-    }\n   doing_hard_virtuals = 0;\n \n   /* Under our model of GC, every C++ class gets its own virtual\n@@ -3890,13 +3329,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   else if (first_vfn_base_index >= 0)\n     {\n       tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), first_vfn_base_index);\n-#if 0\n-      /* For testing. */\n-      tree binfo1 = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0);\n-      if (binfo != binfo1)\n-\twarning (\"binfos are different in vtable creation\");\n-#endif\n-\n       /* This class contributes nothing new to the virtual function\n \t table.  However, it may have declared functions which\n \t went into the virtual function table \"inherited\" from the\n@@ -3916,13 +3348,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     max_has_virtual = has_virtual;\n   if (max_has_virtual || first_vfn_base_index >= 0)\n     {\n-#ifdef VTABLE_USES_MASK\n-      if (max_has_virtual >= VINDEX_MAX)\n-\t{\n-\t  cp_error (\"too many virtual functions for `%#T' (VINDEX_MAX < %d)\",\n-\t\t    t, has_virtual);\n-\t}\n-#endif\n       TYPE_VIRTUAL_P (t) = 1;\n       CLASSTYPE_VSIZE (t) = has_virtual;\n       if (first_vfn_base_index >= 0)\n@@ -4118,7 +3543,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n   /* Make the rtl for any new vtables we have created, and unmark\n      the base types we marked.  */\n-  unmark_finished_struct (t);\n+  finish_vtbls (TYPE_BINFO (t), 1, t);\n   TYPE_BEING_DEFINED (t) = 0;\n \n   if (flag_dossier && CLASSTYPE_VTABLE_NEEDS_WRITING (t))\n@@ -4142,9 +3567,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  build_t_desc (variants, 1);\n \t  variants = TYPE_NEXT_VARIANT (variants);\n \t}\n-#if 0\n-      DECL_VPARENT (tdecl) = t;\n-#endif\n       DECL_CONTEXT (tdecl) = t;\n     }\n   /* Still need to instantiate this C struct's type descriptor.  */"}, {"sha": "bfed8b2c5561b99d896c99a4c8008581aa27d52d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -1071,11 +1071,11 @@ struct lang_decl\n    or virtual baseclasses.  */\n #define TYPE_USES_COMPLEX_INHERITANCE(NODE) (TREE_LANG_FLAG_1 (NODE))\n \n+#if 0\t\t\t\t/* UNUSED */\n /* Nonzero in IDENTIFIER_NODE means that this name is overloaded, and\n    should be looked up in a non-standard way.  */\n #define TREE_OVERLOADED(NODE) (TREE_LANG_FLAG_0 (NODE))\n-#if 0\t\t\t\t/* UNUSED */\n-#define DECL_OVERLOADED(NODE) (DECL_LANG_FLAG_4 (NODE))\n+#define DECL_OVERLOADED(NODE) (NOTHING)\n #endif\n \n /* Nonzero if this (non-TYPE)_DECL has its virtual attribute set.\n@@ -1251,7 +1251,13 @@ struct lang_decl\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n \n-#define THUNK_DELTA(DECL) ((DECL)->decl.frame_size)\n+/* Macros for a DECL or TYPE generated from a template to indicate that it\n+   was explicitly instantiated.  */\n+#define DECL_EXPLICITLY_INSTANTIATED(NODE) (DECL_LANG_FLAG_4 (NODE))\n+#define CLASSTYPE_EXPLICITLY_INSTANTIATED(NODE) \\\n+  (DECL_EXPLICITLY_INSTANTIATED (TYPE_NAME (NODE)))\n+\n+#define THUNK_DELTA(DECL) ((DECL)->decl.frame_size.u)\n \n /* ...and for unexpanded-parameterized-type nodes.  */\n #define UPT_TEMPLATE(NODE)      TREE_PURPOSE(TYPE_VALUES(NODE))\n@@ -1334,14 +1340,6 @@ extern tree class_type_node, record_type_node, union_type_node, enum_type_node;\n extern tree exception_type_node, unknown_type_node;\n extern tree opaque_type_node, signature_type_node;\n \n-/* The largest size a virtual function table can be.\n-   Must be a (power of 2).  */\n-#ifndef VINDEX_MAX\n-#define VINDEX_MAX ((unsigned)128)\n-/* This is the integer ~ (vindex_max - 1).  */\n-#endif\n-extern tree vtbl_mask;\n-\n /* Array type `(void *)[]' */\n extern tree vtbl_type_node;\n extern tree delta_type_node;\n@@ -1952,7 +1950,7 @@ extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n /* in init.c */\n extern void emit_base_init\t\t\tPROTO((tree, int));\n extern void check_base_init\t\t\tPROTO((tree));\n-extern void init_vtbl_ptrs\t\t\tPROTO((tree, int, int));\n+extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n extern void do_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_aggr_init\t\t\tPROTO((tree, tree, int));\n@@ -2101,12 +2099,12 @@ extern tree lookup_nested_tag\t\t\tPROTO((tree, tree));\n extern HOST_WIDE_INT breadth_first_search\tPROTO((tree, int (*)(), int (*)()));\n extern int tree_needs_constructor_p\t\tPROTO((tree, int));\n extern int tree_has_any_destructor_p\t\tPROTO((tree, int));\n-extern tree get_first_matching_virtual\t\tPROTO((tree, tree, int));\n+extern tree get_matching_virtual\t\tPROTO((tree, tree, int));\n extern tree get_abstract_virtuals\t\tPROTO((tree));\n extern tree get_baselinks\t\t\tPROTO((tree, tree, tree));\n extern tree next_baselink\t\t\tPROTO((tree));\n extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n-extern void expand_vbase_vtables_init\t\tPROTO((tree, tree, tree, tree, int));\n+extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree, tree, int));\n extern void clear_search_slots\t\t\tPROTO((tree));\n extern tree get_vbase_types\t\t\tPROTO((tree));\n extern void build_mi_matrix\t\t\tPROTO((tree));"}, {"sha": "10e17e2d690498759c344d7d8694a19058ca2128", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -706,10 +706,11 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \n       else if (form == REFERENCE_TYPE)\n \t{\n-\t  rval = copy_node (expr);\n-\t  TREE_TYPE (rval) = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n+\t  rval = build1 (NOP_EXPR,\n+\t\t\t build_pointer_type (TREE_TYPE (TREE_TYPE (expr))),\n+\t\t\t expr);\n \t  rval = convert (build_pointer_type (TREE_TYPE (reftype)), rval);\n-\t  TREE_TYPE (rval) = reftype;\n+\t  rval = build1 (NOP_EXPR, reftype, rval);\n \t  return rval;\n \t}\n \n@@ -734,7 +735,7 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n       if (rval != error_mark_node)\n \trval = convert_force (build_pointer_type (TREE_TYPE (reftype)), rval);\n       if (rval != error_mark_node)\n-\tTREE_TYPE (rval) = reftype;\n+\trval = build1 (NOP_EXPR, reftype, rval);\n     }\n   else if (decl == error_mark_node || decl == NULL_TREE)\n     {\n@@ -1146,9 +1147,8 @@ convert_pointer_to_real (binfo, expr)\n \t but if it is, give them an error message that they can read.  */\n       if (distance < 0)\n \t{\n-\t  cp_error (\"cannot convert a pointer of type `%T'\",\n-\t\t    TREE_TYPE (intype));\n-\t  cp_error (\"to a pointer of type `%T'\", type);\n+\t  cp_error (\"cannot convert a pointer of type `%T' to a pointer of type `%T'\",\n+\t\t    TREE_TYPE (intype), type);\n \n \t  if (distance == -2)\n \t    cp_error (\"because `%T' is an ambiguous base class\", type);"}, {"sha": "5dd571def05b4c150b6b35462e6619aa6a357244", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 129, "deletions": 134, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -235,9 +235,6 @@ tree opaque_type_node, signature_type_node;\n tree sigtable_entry_type;\n tree maybe_gc_cleanup;\n \n-/* Used for virtual function tables.  */\n-tree vtbl_mask;\n-\n /* Array type `vtable_entry_type[]' */\n tree vtbl_type_node;\n \n@@ -310,11 +307,6 @@ static tree named_label_uses;\n    in the TREE_PURPOSE slot.  */\n tree static_aggregates;\n \n-/* A list of overloaded functions which we should forget ever\n-   existed, such as functions declared in a function's scope,\n-   once we leave that function's scope.  */\n-static tree overloads_to_forget;\n-\n /* -- end of C++ */\n \n /* Two expressions that are constants with value zero.\n@@ -340,6 +332,10 @@ int pending_invalid_xref_line;\n \n static tree enum_next_value;\n \n+/* Nonzero means that there was overflow computing enum_next_value.  */\n+\n+static int enum_overflow;\n+\n /* Parsing a function declarator leaves a list of parameter names\n    or a chain or parameter decls here.  */\n \n@@ -535,6 +531,9 @@ struct binding_level\n     /* Same, for IDENTIFIER_TYPE_VALUE.  */\n     tree type_shadowed;\n \n+    /* Same, for IDENTIFIER_GLOBAL_VALUE for overloaded functions.  */\n+    tree overloads_shadowed;\n+\n     /* For each level (except not the global one),\n        a chain of BLOCK nodes for all the levels\n        that were entered and exited one level down.  */\n@@ -1026,6 +1025,9 @@ poplevel (keep, reverse, functionbody)\n   for (link = current_binding_level->type_shadowed;\n        link; link = TREE_CHAIN (link))\n     IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+  for (link = current_binding_level->overloads_shadowed;\n+       link; link = TREE_CHAIN (link))\n+    IDENTIFIER_GLOBAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n \n   /* If the level being exited is the top level of a function,\n      check over all the labels.  */\n@@ -1739,7 +1741,8 @@ pushtag (name, type, globalize)\n      int globalize;\n {\n   register struct binding_level *b;\n-  tree t_context = 0;\n+  tree context = 0;\n+  tree cdecl = 0;\n \n   b = inner_binding_level;\n   while (b->tag_transparent\n@@ -1753,9 +1756,12 @@ pushtag (name, type, globalize)\n \n   if (name)\n     {\n-      t_context = type ? TYPE_CONTEXT(type) : NULL_TREE;\n-      if (!t_context && !globalize)\n-        t_context = current_class_type;\n+      context = type ? TYPE_CONTEXT (type) : NULL_TREE;\n+      if (! context && ! globalize)\n+        context = current_scope ();\n+      if (context)\n+\tcdecl = TREE_CODE (context) == FUNCTION_DECL\n+\t  ? context : TYPE_NAME (context);\n \n       /* Record the identifier as the type's name if it has none.  */\n       if (TYPE_NAME (type) == NULL_TREE)\n@@ -1774,8 +1780,7 @@ pushtag (name, type, globalize)\n \t      || TYPE_SIZE (current_class_type) != NULL_TREE)\n \t    {\n \t      if (current_lang_name == lang_name_cplusplus)\n-\t\td = lookup_nested_type (type, \n-\t\t\tt_context ? TYPE_NAME (t_context) : NULL_TREE);\n+\t\td = lookup_nested_type (type, cdecl);\n \t      else\n \t\td = NULL_TREE;\n \n@@ -1849,29 +1854,27 @@ pushtag (name, type, globalize)\n \t    }\n \t  TYPE_NAME (type) = d;\n \n-\t  if ((t_context == NULL_TREE\n-\t       && current_function_decl == NULL_TREE)\n-\t      || current_lang_name != lang_name_cplusplus)\n+\t  if (context == NULL_TREE || current_lang_name != lang_name_cplusplus)\n \t    /* Non-nested class.  */\n \t    DECL_NESTED_TYPENAME (d) = name;\n-\t  else if (current_function_decl != NULL_TREE)\n+\t  else if (context && TREE_CODE (context) == FUNCTION_DECL)\n \t    {\n \t      /* Function-nested class.  */\n-\t      set_nested_typename (d, \n-\t\tDECL_ASSEMBLER_NAME (current_function_decl), name, type);\n+\t      set_nested_typename (d, DECL_ASSEMBLER_NAME (cdecl),\n+\t\t\t\t   name, type);\n \t      /* This builds the links for classes nested in fn scope.  */\n-\t      DECL_CONTEXT (d) = current_function_decl;\n+\t      DECL_CONTEXT (d) = context;\n \t    }\n /*        else if (TYPE_SIZE (current_class_type) == NULL_TREE)\n */\n-\t  else if (t_context && TREE_CODE (t_context) == RECORD_TYPE)\n+\t  else if (context && TREE_CODE (context) == RECORD_TYPE)\n \t    {\n \t      /* Class-nested class.  */\n-\t      set_nested_typename (d, \n-\t\tDECL_NESTED_TYPENAME (TYPE_NAME (t_context)), name, type);\n+\t      set_nested_typename (d, DECL_NESTED_TYPENAME (cdecl),\n+\t\t\t\t   name, type);\n \t      /* This builds the links for classes nested in type scope.  */\n-\t      DECL_CONTEXT (d) = t_context;\n-\t      DECL_CLASS_CONTEXT (d) = t_context;\n+\t      DECL_CONTEXT (d) = context;\n+\t      DECL_CLASS_CONTEXT (d) = context;\n \t    }\n \t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n \t  if (newdecl)\n@@ -2315,6 +2318,7 @@ duplicate_decls (newdecl, olddecl)\n \t  CLASSTYPE_FRIEND_CLASSES (newtype)\n \t    = CLASSTYPE_FRIEND_CLASSES (oldtype);\n \t}\n+#if 0\n       /* why assert here?  Just because debugging information is\n \t messed up? (mrs) */\n       /* it happens on something like:\n@@ -2323,7 +2327,6 @@ duplicate_decls (newdecl, olddecl)\n \t\t        int     x;\n \t\t} Thing;\n       */\n-#if 0\n       my_friendly_assert (DECL_IGNORED_P (olddecl) == DECL_IGNORED_P (newdecl),\n \t\t\t  139);\n #endif\n@@ -2709,7 +2712,9 @@ pushdecl (x)\n \t      if (current_function_decl == x)\n \t\tcurrent_function_decl = t;\n #endif\n-\t      \n+\t      if (TREE_CODE (t) == TYPE_DECL)\n+\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n+\n \t      return t;\n \t    }\n \t}\n@@ -3088,6 +3093,31 @@ pushdecl_class_level (x)\n   return x;\n }\n \n+/* This function is used to push the mangled decls for nested types into\n+   the appropriate scope.  Previously pushdecl_top_level was used, but that\n+   is incorrect for members of local classes.  */\n+tree\n+pushdecl_nonclass_level (x)\n+     tree x;\n+{\n+  struct binding_level *b = current_binding_level;\n+\n+#if 0\n+  /* Get out of class scope -- this isn't necessary, because class scope\n+     doesn't make it into current_binding_level.  */\n+  while (b->parm_flag == 2)\n+    b = b->level_chain;\n+#else\n+  my_friendly_assert (b->parm_flag != 2, 180);\n+#endif\n+\n+  /* Get out of template binding levels */\n+  while (b->pseudo_global)\n+    b = b->level_chain;\n+\n+  pushdecl_with_scope (x, b);\n+}\n+\n /* Make the declaration(s) of X appear in CLASS scope\n    under the name NAME.  */\n void\n@@ -3142,13 +3172,6 @@ push_overloaded_decl (decl, forgettable)\n   tree orig_name = DECL_NAME (decl);\n   tree glob = IDENTIFIER_GLOBAL_VALUE (orig_name);\n \n-  if (forgettable\n-      && ! flag_traditional\n-      && (glob == NULL_TREE || TREE_PERMANENT (glob) == 1)\n-      && !global_bindings_p ()\n-      && !pseudo_global_level_p ())\n-    overloads_to_forget = tree_cons (orig_name, glob, overloads_to_forget);\n-\n   if (glob)\n     {\n       /* We cache the value of builtin functions as ADDR_EXPRs\n@@ -3197,6 +3220,16 @@ push_overloaded_decl (decl, forgettable)\n \t    }\n \t}\n     }\n+\n+  if (forgettable\n+      && ! flag_traditional\n+      && (glob == NULL_TREE || TREE_PERMANENT (glob) == 1)\n+      && !global_bindings_p ()\n+      && !pseudo_global_level_p ())\n+    current_binding_level->overloads_shadowed\n+      = tree_cons (orig_name, glob,\n+\t\t   current_binding_level->overloads_shadowed);\n+\n   if (glob || TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n       if (glob && is_overloaded_fn (glob))\n@@ -3832,7 +3865,6 @@ lookup_name (name, prefer_type)\n \t  else\n \t    val = lookup_field (got_scope, name, 0, 0);\n \n-\t  got_scope = NULL_TREE;\n \t  goto done;\n \t}\n     }\n@@ -4629,16 +4661,6 @@ init_decl_processing ()\n   else\n     vtable_entry_type = memptr_type;\n \n-#ifdef VTABLE_USES_MASK\n-  /* This is primarily for virtual function definition.  We\n-     declare an array of `void *', which can later be\n-     converted to the appropriate function pointer type.\n-     To do pointers to members, we need a mask which can\n-     distinguish an index value into a virtual function table\n-     from an address.  */\n-  vtbl_mask = build_int_2 (~((HOST_WIDE_INT) VINDEX_MAX - 1), -1);\n-#endif\n-\n   vtbl_type_node\n     = build_array_type (vtable_entry_type, NULL_TREE);\n   layout_type (vtbl_type_node);\n@@ -6562,7 +6584,7 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       if (check)\n \tcheck_classfn (ctype, declarator, decl);\n       grok_ctor_properties (ctype, decl);\n-      if (check == 0)\n+      if (check == 0 && ! current_function_decl)\n \t{\n \t  /* FIXME: this should only need to look at IDENTIFIER_GLOBAL_VALUE.  */\n \t  tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n@@ -6596,25 +6618,27 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       if (ctype == NULL_TREE || check)\n \treturn decl;\n \n-      /* Now install the declaration of this function so that\n-\t others may find it (esp. its DECL_FRIENDLIST).\n-\t Pretend we are at top level, we will get true\n-\t reference later, perhaps.\n-\n-\t FIXME: This should only need to look at IDENTIFIER_GLOBAL_VALUE.  */\n-      tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n-      if (tmp == NULL_TREE)\n-\tIDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n-      else if (TREE_CODE (tmp) != TREE_CODE (decl))\n-\tcp_error (\"inconsistent declarations for `%D'\", decl);\n-      else\n+      /* Now install the declaration of this function so that others may\n+\t find it (esp. its DECL_FRIENDLIST).  Don't do this for local class\n+\t methods, though.  */\n+      if (! current_function_decl)\n \t{\n-\t  duplicate_decls (decl, tmp);\n-\t  decl = tmp;\n-\t  /* avoid creating circularities.  */\n-\t  DECL_CHAIN (decl) = NULL_TREE;\n+\t  /* FIXME: this should only need to look at\n+             IDENTIFIER_GLOBAL_VALUE.  */\n+\t  tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n+\t  if (tmp == NULL_TREE)\n+\t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n+\t  else if (TREE_CODE (tmp) != TREE_CODE (decl))\n+\t    cp_error (\"inconsistent declarations for `%D'\", decl);\n+\t  else\n+\t    {\n+\t      duplicate_decls (decl, tmp);\n+\t      decl = tmp;\n+\t      /* avoid creating circularities.  */\n+\t      DECL_CHAIN (decl) = NULL_TREE;\n+\t    }\n+\t  make_decl_rtl (decl, NULL_PTR, 1);\n \t}\n-      make_decl_rtl (decl, NULL_PTR, 1);\n \n       /* If this declaration supersedes the declaration of\n \t a method declared virtual in the base class, then\n@@ -6629,8 +6653,8 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \t    if (TYPE_VIRTUAL_P (BINFO_TYPE (base_binfo))\n \t\t|| flag_all_virtual == 1)\n \t      {\n-\t\ttmp = get_first_matching_virtual (base_binfo, decl,\n-\t\t\t\t\t\t  flags == DTOR_FLAG);\n+\t\ttmp = get_matching_virtual (base_binfo, decl,\n+\t\t\t\t\t    flags == DTOR_FLAG);\n \t\tif (tmp)\n \t\t  {\n \t\t    /* If this function overrides some virtual in some base\n@@ -6652,34 +6676,25 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \t\t      }\n \t\t    virtualp = 1;\n \n-#if 0\n-\t\t    /* Disable this as we want the most recent fndecl, not the most\n-\t\t       base fndecl. */\n-\t\t    if ((TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (base_binfo))\n-\t\t\t || TYPE_USES_MULTIPLE_INHERITANCE (ctype))\n-\t\t\t&& BINFO_TYPE (base_binfo) != DECL_CONTEXT (tmp))\n-\t\t      tmp = get_first_matching_virtual (TYPE_BINFO (DECL_CONTEXT (tmp)),\n-\t\t\t\t\t\t\tdecl, flags == DTOR_FLAG);\n-#endif\n-\t\t    if (value_member (tmp, DECL_VINDEX (decl)) == NULL_TREE)\n-\t\t      {\n-\t\t\t/* The argument types may have changed... */\n-\t\t\ttree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\t\t\ttree base_variant = TREE_TYPE (TREE_VALUE (argtypes));\n-\n-\t\t\targtypes = commonparms (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (tmp))),\n-\t\t\t\t\t\tTREE_CHAIN (argtypes));\n-\t\t\t/* But the return type has not.  */\n-\t\t\ttype = build_cplus_method_type (base_variant, TREE_TYPE (type), argtypes);\n-\t\t\tif (raises)\n-\t\t\t  {\n-\t\t\t    type = build_exception_variant (ctype, type, raises);\n-\t\t\t    raises = TYPE_RAISES_EXCEPTIONS (type);\n-\t\t\t  }\n-\t\t\tTREE_TYPE (decl) = type;\n-\t\t\tDECL_VINDEX (decl)\n-\t\t\t  = tree_cons (NULL_TREE, tmp, DECL_VINDEX (decl));\n-\t\t      }\n+\t\t    {\n+\t\t      /* The argument types may have changed... */\n+\t\t      tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+\t\t      tree base_variant = TREE_TYPE (TREE_VALUE (argtypes));\n+\n+\t\t      argtypes = commonparms (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (tmp))),\n+\t\t\t\t\t      TREE_CHAIN (argtypes));\n+\t\t      /* But the return type has not.  */\n+\t\t      type = build_cplus_method_type (base_variant, TREE_TYPE (type), argtypes);\n+\t\t      if (raises)\n+\t\t\t{\n+\t\t\t  type = build_exception_variant (ctype, type, raises);\n+\t\t\t  raises = TYPE_RAISES_EXCEPTIONS (type);\n+\t\t\t}\n+\t\t      TREE_TYPE (decl) = type;\n+\t\t      DECL_VINDEX (decl)\n+\t\t\t= tree_cons (NULL_TREE, tmp, DECL_VINDEX (decl));\n+\t\t    }\n+\t\t    break;\n \t\t  }\n \t      }\n \t  }\n@@ -8852,9 +8867,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t   by the draft ANSI standard, though it appears to be in\n \t\t   common practice.  12.6.2: The argument list is used to\n \t\t   initialize the named nonstatic member....  This (or an\n-\t\t   aggregate) is the only way to initialize nonstatic const\n-\t\t   and reference members.  */\n-\t\telse\n+\t\t   initializer list) is the only way to initialize\n+\t\t   nonstatic const and reference members.  */\n+\t\telse if (pedantic || flag_ansi || ! constp)\n \t\t  pedwarn (\"ANSI C++ forbids initialization of %s `%s'\",\n \t\t\t   constp ? \"const member\" : \"member\",\n \t\t\t   IDENTIFIER_POINTER (declarator));\n@@ -9706,7 +9721,7 @@ xref_defn_tag (code_type_node, name, binfo)\n       else\n \tn1 = current_class_name;\n */\n-      n1 = TYPE_NAME(current_class_type);\n+      n1 = TYPE_NAME (current_class_type);\n       if (n1)\n \tn1 = DECL_NESTED_TYPENAME(n1);\n       else\n@@ -9737,7 +9752,7 @@ xref_defn_tag (code_type_node, name, binfo)\n \tif (write_symbols == DWARF_DEBUG)\n \t  DECL_IGNORED_P (type_decl) = 1;\n #endif /* DWARF_DEBUGGING_INFO */\n-\tpushdecl_top_level (type_decl);\n+\tpushdecl_nonclass_level (type_decl);\n       }\n     }\n   else\n@@ -10160,6 +10175,7 @@ start_enum (name)\n   /* We copy this value because enumerated type constants\n      are really of the type of the enumerator, not integer_type_node.  */\n   enum_next_value = copy_node (integer_zero_node);\n+  enum_overflow = 0;\n \n   GNU_xref_decl (current_function_decl, enumtype);\n   return enumtype;\n@@ -10299,7 +10315,11 @@ build_enumerator (name, value)\n      to keep that from happening.  */\n   /* Default based on previous value.  */\n   if (value == NULL_TREE)\n-    value = enum_next_value;\n+    {\n+      value = enum_next_value;\n+      if (enum_overflow)\n+\tcp_error (\"overflow in enumeration values at `%D'\", name);\n+    }\n \n   /* Remove no-op casts from the value.  */\n   if (value)\n@@ -10322,26 +10342,8 @@ build_enumerator (name, value)\n \n   /* C++ associates enums with global, function, or class declarations.  */\n \n-  /* There are a number of cases we need to be aware of here:\n-\t\t\t\tcurrent_class_type\tcurrent_function_decl\n-     * global enums\t\tNULL\t\t\tNULL\n-     * fn-local enum\t\tNULL\t\t\tSET\n-     * class-local enum\t\tSET\t\t\tNULL\n-     * class->fn->enum\t\tSET\t\t\tSET\n-     * fn->class->enum\t\tSET\t\t\tSET\n-\n-     Those last two make life interesting.  If it's a fn-local enum which is\n-     itself inside a class, we need the enum to go into the fn's decls (our\n-     second case below).  But if it's a class-local enum and the class itself\n-     is inside a function, we need that enum to go into the decls for the\n-     class.  To achieve this last goal, we must see if, when both\n-     current_class_decl and current_function_decl are set, the class was\n-     declared inside that function.  If so, we know to put the enum into\n-     the class's scope.  */\n-     \n-  if ((current_class_type && ! current_function_decl)\n-      || (current_class_type && current_function_decl\n-\t  && TYPE_CONTEXT (current_class_type) == current_function_decl))\n+  decl = current_scope ();\n+  if (decl && decl == current_class_type)\n     {\n       /* This enum declaration is local to the class, so we must put\n \t it in that class's list of decls.  */\n@@ -10366,6 +10368,8 @@ build_enumerator (name, value)\n   /* Set basis for default for next value.  */\n   enum_next_value = build_binary_op_nodefault (PLUS_EXPR, value,\n \t\t\t\t\t       integer_one_node, PLUS_EXPR);\n+  enum_overflow = tree_int_cst_lt (enum_next_value, value);\n+  \n   if (enum_next_value == integer_one_node)\n     enum_next_value = copy_node (enum_next_value);\n \n@@ -10610,9 +10614,9 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   if (interface_unknown == 0)\n     {\n       TREE_PUBLIC (decl1) = 1;\n-      DECL_EXTERNAL (decl1) = (interface_only\n-\t\t\t       || (DECL_INLINE (decl1)\n-\t\t\t\t   && ! flag_implement_inlines));\n+      DECL_EXTERNAL (decl1)\n+\t= ((interface_only && !DECL_EXPLICITLY_INSTANTIATED (decl1))\n+\t   || (DECL_INLINE (decl1) && ! flag_implement_inlines));\n     }\n   else\n     /* This is a definition, not a reference.\n@@ -11246,9 +11250,9 @@ finish_function (lineno, call_poplevel)\n       /* Make all virtual function table pointers in non-virtual base\n \t classes point to CURRENT_CLASS_TYPE's virtual function\n \t tables.  */\n-      init_vtbl_ptrs (binfo, 1, 0);\n+      expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_decl);\n       if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\texpand_vbase_vtables_init (binfo, binfo, C_C_D, current_class_decl, 0);\n+\texpand_indirect_vtbls_init (binfo, C_C_D, current_class_decl, 0);\n       if (! ok_to_optimize_dtor)\n \t{\n \t  cond = build_binary_op (NE_EXPR,\n@@ -11517,15 +11521,6 @@ finish_function (lineno, call_poplevel)\n   else\n     pop_memoized_context (1);\n \n-  /* Forget about all overloaded functions defined in\n-     this scope which go away.  */\n-  while (overloads_to_forget)\n-    {\n-      IDENTIFIER_GLOBAL_VALUE (TREE_PURPOSE (overloads_to_forget))\n-\t= TREE_VALUE (overloads_to_forget);\n-      overloads_to_forget = TREE_CHAIN (overloads_to_forget);\n-    }\n-\n   /* Generate rtl for function exit.  */\n   expand_function_end (input_filename, lineno, 1);\n "}, {"sha": "b910b6731ad55e15548d21fa963b61ddd166bffc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -1381,6 +1381,10 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n       if (DECL_FRIEND_P (value))\n \treturn void_type_node;\n \n+      if (current_function_decl)\n+\tcp_error (\"method `%#D' of local class must be defined in class body\",\n+\t\t  value);\n+\n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n     }\n@@ -2307,6 +2311,37 @@ mark_vtable_entries (decl)\n       tree fnaddr = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries));\n       tree fn = TREE_OPERAND (fnaddr, 0);\n       TREE_ADDRESSABLE (fn) = 1;\n+      if (DECL_ABSTRACT_VIRTUAL_P (fn))\n+\t{\n+\t  extern tree abort_fndecl;\n+\t  TREE_OPERAND (fnaddr, 0) = abort_fndecl;\n+\t}\n+    }\n+}\n+\n+/* Set TREE_PUBLIC and/or TREE_EXTERN on the vtable DECL,\n+   based on TYPE and other static flags.\n+\n+   Note that anything public is tagged TREE_PUBLIC, whether\n+   it's public in this file or in another one.  */\n+\n+static void\n+import_export_vtable (decl, type)\n+  tree decl, type;\n+{\n+  if (write_virtuals >= 2)\n+    {\n+      if (CLASSTYPE_INTERFACE_KNOWN (type))\n+\t{\n+\t  TREE_PUBLIC (decl) = 1;\n+\t  DECL_EXTERNAL (decl) = ! CLASSTYPE_VTABLE_NEEDS_WRITING (type);\n+\t}\n+    }\n+  else if (write_virtuals != 0)\n+    {\n+      TREE_PUBLIC (decl) = 1;\n+      if (write_virtuals < 0)\n+\tDECL_EXTERNAL (decl) = 1;\n     }\n }\n \n@@ -2315,6 +2350,8 @@ finish_vtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n   tree ctype = DECL_CONTEXT (vars);\n+  import_export_vtable (vars, ctype);\n+\n   if (flag_vtable_thunks && !CLASSTYPE_INTERFACE_KNOWN (ctype))\n     {\n       tree method;\n@@ -2578,6 +2615,10 @@ finish_file ()\n \t      lineno = DECL_SOURCE_LINE (decl);\n \t      emit_note (input_filename, lineno);\n \n+\t      /* 9.5p5: The initializer of a static member of a class has\n+\t\t the same acess rights as a member function.  */\n+\t      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n+\n \t      if (init)\n \t\t{\n \t\t  if (TREE_CODE (init) == VAR_DECL)\n@@ -2615,19 +2656,7 @@ finish_file ()\n \t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n \t\t  || init == 0\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\t\t{\n-#if 0\n-\t\t  /* Set this up so is_friend() works properly on _GLOBAL_\n-                     fns.  */\n-\t\t  tree old_dcc = DECL_CLASS_CONTEXT (current_function_decl);\n-\t\t  if (old_dcc == NULL_TREE && IS_AGGR_TYPE (TREE_TYPE (decl)))\n-\t\t    DECL_CLASS_CONTEXT (current_function_decl) = TREE_TYPE (decl);\n-\t\t  expand_aggr_init (decl, init, 0);\n-\t\t  DECL_CLASS_CONTEXT (current_function_decl) = old_dcc;\n-#else\n-\t\t  expand_aggr_init (decl, init, 0);\n-#endif\n-\t\t}\n+\t\texpand_aggr_init (decl, init, 0);\n \t      else if (TREE_CODE (init) == TREE_VEC)\n \t\t{\n \t\t  expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n@@ -2638,6 +2667,8 @@ finish_file ()\n \t\t}\n \t      else\n \t\texpand_assignment (decl, init, 0, 0);\n+\n+\t      DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n \t    }\n \t  else if (TREE_CODE (decl) == SAVE_EXPR)\n \t    {"}, {"sha": "294201fef4e7e3ad018915ce93d9bb9293adc3d1", "filename": "gcc/cp/error.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -186,8 +186,7 @@ dump_type (t, v)\n       break;\n \n     case TYPE_DECL:\n-      dump_readonly_or_volatile (t, after);\n-      OB_PUTID (DECL_NAME (t));\n+      dump_decl (t, v);\n       break;\n \n     case INTEGER_TYPE:\n@@ -553,6 +552,17 @@ dump_decl (t, v)\n       OB_PUTS (\" /* decl error */ \");\n       break;\n \n+    case TYPE_DECL:\n+      if (TYPE_NAME (TREE_TYPE (t)) != t)\n+\t{\n+\t  if (v > 0)\n+\t    OB_PUTS (\"typedef \");\n+\t  goto general;\n+\t}\n+\n+      dump_type (TREE_TYPE (t), v);\n+      break;\n+      \n     case VAR_DECL:\n       if (VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n@@ -563,24 +573,26 @@ dump_decl (t, v)\n       /* else fall through */\n     case FIELD_DECL:\n     case PARM_DECL:\n+    general:\n       if (v > 0)\n \t{\n \t  dump_type_prefix (TREE_TYPE (t), v);\n-\t  OB_PUTC(' ');\n+\t  OB_PUTC (' ');\n \t}\n       /* DECL_CLASS_CONTEXT isn't being set in some cases.  Hmm...  */\n       if (TREE_CODE (t) == FIELD_DECL\n \t  || (TREE_CODE (t) == VAR_DECL && DECL_CONTEXT (t)\n \t      && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) == 't'))\n \t{\n \t  dump_type (DECL_CONTEXT (t), 0);\n-\t  OB_PUTC2(':', ':');\n+\t  OB_PUTC2 (':', ':');\n \t}\n       if (DECL_NAME (t))\n \tdump_decl (DECL_NAME (t), v);\n       else\n \tOB_PUTS (\"{anon}\");\n-      if (v > 0) dump_type_suffix (TREE_TYPE (t), v);\n+      if (v > 0)\n+\tdump_type_suffix (TREE_TYPE (t), v);\n       break;\n \n     case ARRAY_REF:\n@@ -598,10 +610,6 @@ dump_decl (t, v)\n       dump_type (t, v);\n       break;\n \n-    case TYPE_DECL:\n-      dump_type (TREE_TYPE (t), v);\n-      break;\n-\n     case TYPE_EXPR:\n       my_friendly_abort (69);\n       break;"}, {"sha": "ffe3a0f60e4c9f04bdfb8f47bb145946f6e28ced", "filename": "gcc/cp/init.c", "status": "modified", "additions": 54, "deletions": 99, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -50,7 +50,7 @@ void expand_aggr_init ();\n static void expand_aggr_init_1 ();\n static void expand_recursive_init_1 ();\n static void expand_recursive_init ();\n-static void expand_virtual_init PROTO((tree, tree, tree));\n+static void expand_virtual_init PROTO((tree, tree));\n tree expand_vec_init ();\n \n static void add_friend (), add_friends ();\n@@ -101,34 +101,51 @@ void init_init_processing ()\n    virtual base classes.  Initialize binfo's vtable pointer, if\n    INIT_SELF is true.  CAN_ELIDE is true when we know that all virtual\n    function table pointers in all bases have been initialized already,\n-   probably because their constructors have just be run.  */\n+   probably because their constructors have just be run.  ADDR is the\n+   pointer to the object whos vtables we are going to initialize.\n+\n+   REAL_BINFO is usually the same as BINFO, except when addr is not of\n+   pointer to the type of the real derived type that we want to\n+   initialize for.  This is the case when addr is a pointer to a sub\n+   object of a complete object, and we only want to do part of the\n+   complete object's initiailzation of vtable pointers.  This is done\n+   for all virtual table pointers in virtual base classes.  REAL_BINFO\n+   is used to find the BINFO_VTABLE that we initialize with.  BINFO is\n+   used for conversions of addr to subobjects.\n+\n+   BINFO_TYPE (real_binfo) must be BINFO_TYPE (binfo).\n+\n+   Relies upon binfo being inside TYPE_BINFO (TREE_TYPE (TREE_TYPE\n+   (addr))).  */\n void\n-init_vtbl_ptrs (binfo, init_self, can_elide)\n-     tree binfo;\n+expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n+     tree real_binfo, binfo, addr;\n      int init_self, can_elide;\n {\n-  tree vfields;\n+  tree real_binfos = BINFO_BASETYPES (real_binfo);\n   tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  int i, n_baselinks = real_binfos ? TREE_VEC_LENGTH (real_binfos) : 0;\n \n   for (i = 0; i < n_baselinks; i++)\n     {\n+      tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       int is_not_base_vtable =\n-\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      if (! TREE_VIA_VIRTUAL (base_binfo))\n-\tinit_vtbl_ptrs (base_binfo, is_not_base_vtable, can_elide);\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (real_binfo));\n+      if (! TREE_VIA_VIRTUAL (real_base_binfo))\n+\texpand_direct_vtbls_init (real_base_binfo, base_binfo,\n+\t\t\t\t  is_not_base_vtable, can_elide, addr);\n     }\n #if 0\n   /* Before turning this on, make sure it is correct.  */\n   if (can_elide  && ! BINFO_MODIFIED (binfo))\n     return;\n #endif\n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (real_binfo)))\n     {\n-      tree base_ptr = convert_pointer_to_real (binfo, current_class_decl);\n-      expand_virtual_init (binfo, binfo, base_ptr);\n+      tree base_ptr = convert_pointer_to_real (binfo, addr);\n+      expand_virtual_init (real_binfo, base_ptr);\n     }\n }\n \f\n@@ -605,17 +622,13 @@ emit_base_init (t, immediately)\n   /* Initialize all the virtual function table fields that\n      do come from virtual base classes. */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    expand_vbase_vtables_init (t_binfo, t_binfo,\n-\t\t\t\tC_C_D, current_class_decl, 0);\n+    expand_indirect_vtbls_init (t_binfo, C_C_D, current_class_decl, 0);\n   for (vbases = CLASSTYPE_VBASECLASSES (t); vbases; vbases = TREE_CHAIN (vbases))\n     CLEAR_BINFO_BASEINIT_MARKED (vbases);\n \n   /* Initialize all the virtual function table fields that\n      do not come from virtual base classes.  */\n-  init_vtbl_ptrs (t_binfo, 0, 1);\n-\n-  if (CLASSTYPE_NEEDS_VIRTUAL_REINIT (t))\n-    expand_virtual_init (TYPE_BINFO (t), t, current_class_decl);\n+  expand_direct_vtbls_init (t_binfo, t_binfo, 1, 1, current_class_decl);\n \n   if (current_member_init_list)\n     {\n@@ -709,84 +722,31 @@ check_base_init (t)\n    BINFO is the exact type that DECL is supposed to be.  In\n    multiple inheritance, this might mean \"C's A\" if C : A, B.  */\n static void\n-expand_virtual_init (main_binfo, binfo, decl)\n-     tree main_binfo, binfo;\n-     tree decl;\n+expand_virtual_init (binfo, decl)\n+     tree binfo, decl;\n {\n-  tree type;\n+  tree type = BINFO_TYPE (binfo);\n   tree vtbl, vtbl_ptr;\n   tree vtype, vtype_binfo;\n \n-  if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n-  else if (TREE_CODE (binfo) == RECORD_TYPE)\n-    {\n-      type = binfo;\n-      binfo = TYPE_BINFO (type);\n-    }\n-  else\n-    my_friendly_abort (46);\n-\n+  /* This code is crusty.  Should be simple, like:\n+     vtbl = BINFO_VTABLE (binfo);\n+     */\n   vtype = DECL_CONTEXT (CLASSTYPE_VFIELD (type));\n   vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n-#if 0\n-  /* This code suggests that it's time to rewrite how we handle\n-     replicated baseclasses in G++.  */\n-  if (get_base_distance (vtype, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t 0, (tree *) 0) == -2)\n-    {\n-      tree binfos = TYPE_BINFO_BASETYPES (TREE_TYPE (TREE_TYPE (decl)));\n-      int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-      for (i = n_baselinks-1; i >= 0; i--)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t  tree this_decl;\n-\n-\t  if (get_base_distance (vtype, BINFO_TYPE (base_binfo), 0, 0) == -1)\n-\t    continue;\n-\n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n-\t    this_decl = build_vbase_pointer (build_indirect_ref (decl, NULL_PTR), BINFO_TYPE (base_binfo));\n-\t  else if (BINFO_OFFSET_ZEROP (base_binfo))\n-\t    this_decl = build1 (NOP_EXPR, TYPE_POINTER_TO (BINFO_TYPE (base_binfo)),\n-\t\t\t\tdecl);\n-\t  else\n-\t    this_decl = build (PLUS_EXPR, TYPE_POINTER_TO (BINFO_TYPE (base_binfo)),\n-\t\t\t       decl, BINFO_OFFSET (base_binfo));\n-\t  expand_virtual_init (main_binfo, base_binfo, this_decl);\n-\t}\n-      return;\n-    }\n-#endif\n-\n-    {\n-#if 1\n-#if 1\n-      vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (CLASSTYPE_VFIELD (type)), binfo));\n-#else\n-      /* The below does not work when we have to step through the\n-\t vfield, on our way down to the most base class for the\n-\t vfield. */\n-      vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (CLASSTYPE_VFIELD (type)),\n-\t\t\t\t\tBINFO_TYPE (main_binfo)));\n-#endif\n-#else\n-      my_friendly_assert (BINFO_TYPE (main_binfo) == BINFO_TYPE (binfo), 208);\n-      vtbl = BINFO_VTABLE (main_binfo);\n-#endif /* 1 */\n-      assemble_external (vtbl);\n-      TREE_USED (vtbl) = 1;\n-      vtbl = build1 (ADDR_EXPR, TYPE_POINTER_TO (TREE_TYPE (vtbl)), vtbl);\n-    }\n+  vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (CLASSTYPE_VFIELD (type)), binfo));\n+  if (!flag_vtable_thunks)\n+    assemble_external (vtbl);\n+  TREE_USED (vtbl) = 1;\n+  vtbl = build1 (ADDR_EXPR, TYPE_POINTER_TO (TREE_TYPE (vtbl)), vtbl);\n   decl = convert_pointer_to_real (vtype_binfo, decl);\n   vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL_PTR), vtype);\n   if (vtbl_ptr == error_mark_node)\n     return;\n \n   /* Have to convert VTBL since array sizes may be different.  */\n-  expand_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR,\n-\t\t\t\t       convert (TREE_TYPE (vtbl_ptr), vtbl)));\n+  vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl);\n+  expand_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl));\n }\n \n /* Subroutine of `expand_aggr_vbase_init'.\n@@ -1307,7 +1267,7 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n \t      tree addr = build_unary_op (ADDR_EXPR, exp, 0);\n \t      expand_aggr_vbase_init (binfo, exp, addr, NULL_TREE);\n \n-\t      expand_vbase_vtables_init (binfo, binfo, exp, addr, 1);\n+\t      expand_indirect_vtbls_init (binfo, exp, addr, 1);\n \t    }\n \t  expand_expr_stmt (build_modify_expr (exp, INIT_EXPR, init));\n \t  return;\n@@ -1716,14 +1676,16 @@ expand_recursive_init_1 (binfo, true_exp, addr, init_list, alias_this)\n \t\t are initializing the ultimate users of those vtables.  */\n \t      if (TREE_VALUE (init_list))\n \t\t{\n-\t\t  /* We have to ensure that the second argment to\n+\t\t  /* We have to ensure that the first argment to\n \t\t     expand_virtual_init is in binfo's hierarchy.  */\n-\t\t  expand_virtual_init (binfo,\n-\t\t\t\t      get_binfo (TREE_VALUE (init_list), binfo, 0),\n+\t\t  /* Is it the case that this is exactly the right binfo? */\n+\t\t  /* If it is ok, then fixup expand_virtual_init, to make\n+\t\t     it much simpler. */\n+\t\t  expand_virtual_init (get_binfo (TREE_VALUE (init_list), binfo, 0),\n \t\t\t\t      addr);\n \t\t  if (TREE_VALUE (init_list) == binfo\n \t\t      && TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n-\t\t    expand_vbase_vtables_init (binfo,binfo, true_exp, addr, 1);\n+\t\t    expand_indirect_vtbls_init (binfo, true_exp, addr, 1);\n \t\t}\n \t    }\n \t  else\n@@ -1772,7 +1734,7 @@ expand_recursive_init (binfo, true_exp, exp, init, init_list, alias_this)\n   if (true_exp == exp && TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n     {\n       expand_aggr_vbase_init (binfo, exp, addr, init_list);\n-      expand_vbase_vtables_init (binfo, binfo, true_exp, addr, 1);\n+      expand_indirect_vtbls_init (binfo, true_exp, addr, 1);\n     }\n   expand_recursive_init_1 (binfo, true_exp, addr, init_list, alias_this);\n \n@@ -2202,14 +2164,6 @@ get_member_function (exp_addr_ptr, exp, member)\n       /* Cast function to signed integer.  */\n       e0 = build1 (NOP_EXPR, integer_type_node, function);\n \n-#ifdef VTABLE_USES_MASK\n-      /* If we are willing to limit the number of\n-\t virtual functions a class may have to some\n-\t *small* number, then if, for a function address,\n-\t we are passed some small number, we know that\n-\t it is a virtual function index, and work from there.  */\n-      e1 = build (BIT_AND_EXPR, integer_type_node, e0, vtbl_mask);\n-#else\n       /* There is a hack here that takes advantage of\n \t twos complement arithmetic, and the fact that\n \t there are more than one UNITS to the WORD.\n@@ -2224,7 +2178,6 @@ get_member_function (exp_addr_ptr, exp, member)\n       e1 = build_compound_expr (tree_cons (NULL_TREE, exp_addr,\n \t\t\t\t\t   build_tree_list (NULL_TREE, e1)));\n       e1 = save_expr (e1);\n-#endif\n \n       if (TREE_SIDE_EFFECTS (*exp_addr_ptr))\n \t{\n@@ -2830,7 +2783,9 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n       add_friend (current_class_type, decl);\n \n       DECL_FRIEND_P (decl) = 1;\n+#if 0\n       TREE_OVERLOADED (declarator) = 1;\n+#endif\n     }\n   else\n     {"}, {"sha": "ec26d83ca23444b5c765c655f0b47670d9938bf7", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -1162,11 +1162,13 @@ do_pending_inlines ()\n   /* Pass back a handle on the rest of the inline functions, so that they\n      can be processed later.  */\n   yylval.ttype = build_tree_list ((tree) t, t->fndecl);\n+#if 0\n   if (flag_default_inline && t->fndecl\n       /* If we're working from a template, don't change\n \t the `inline' state.  */\n       && t->parm_vec == NULL_TREE)\n     DECL_INLINE (t->fndecl) = 1;\n+#endif\n   DECL_PENDING_INLINE_INFO (t->fndecl) = 0;\n }\n \n@@ -1215,11 +1217,13 @@ process_next_inline (t)\n       input_filename = i->filename;\n       yychar = PRE_PARSED_FUNCTION_DECL;\n       yylval.ttype = build_tree_list ((tree) i, i->fndecl);\n+#if 0\n       if (flag_default_inline\n \t  /* If we're working from a template, don't change\n \t     the `inline' state.  */\n \t  && i->parm_vec == NULL_TREE)\n \tDECL_INLINE (i->fndecl) = 1;\n+#endif\n       DECL_PENDING_INLINE_INFO (i->fndecl) = 0;\n     }\n   if (i)\n@@ -2577,7 +2581,7 @@ check_newline ()\n \t\t      else\n \t\t\terror (\"`#pragma implementation' can only appear at top-level\");\n \t\t      interface_only = 0;\n-#if 0\n+#if 1\n \t\t      /* We make this non-zero so that we infer decl linkage\n \t\t\t in the impl file only for variables first declared\n \t\t\t in the interface file.  */\n@@ -4576,6 +4580,7 @@ build_lang_decl (code, name, type)\n   if (current_lang_name == lang_name_cplusplus)\n     {\n       DECL_LANGUAGE (t) = lang_cplusplus;\n+#if 0\n #ifndef NO_AUTO_OVERLOAD\n       if (code == FUNCTION_DECL && name != 0\n \t  && ! (IDENTIFIER_LENGTH (name) == 4\n@@ -4586,6 +4591,7 @@ build_lang_decl (code, name, type)\n \t\t&& IDENTIFIER_POINTER (name)[1] == '_'\n \t\t&& strncmp (IDENTIFIER_POINTER (name)+2, \"builtin_\", 8) == 0))\n \tTREE_OVERLOADED (name) = 1;\n+#endif\n #endif\n     }\n   else if (current_lang_name == lang_name_c)"}, {"sha": "16dead8e41809be5860a32e10c447fc46addca8e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -111,8 +111,10 @@ do_inline_function_hair (type, friend_list)\n \t      args = TREE_CHAIN (args);\n \t    }\n \n-\t  /* Allow this decl to be seen in global scope */\n-\t  IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (method)) = method;\n+\t  /* Allow this decl to be seen in global scope.  Don't do this for\n+             local class methods, though.  */\n+\t  if (! current_function_decl)\n+\t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (method)) = method;\n \t}\n       method = TREE_CHAIN (method);\n     }\n@@ -1698,6 +1700,7 @@ emit_thunk (thunk_fndecl)\n   int delta = THUNK_DELTA (thunk_fndecl);\n   int tem;\n   int failure = 0;\n+  extern int current_call_is_indirect; /* Needed for (at least) HPPA. */\n \n   /* Used to remember which regs we need to emit a USE rtx for. */\n   rtx need_use[FIRST_PSEUDO_REGISTER];"}, {"sha": "11ee26b992608afbd8e6f752adaee442547dbe38", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -779,8 +779,9 @@ identifier_defn:\n \n explicit_instantiation:\n \t  TEMPLATE aggr template_type\n+\t\t{ do_type_instantiation ($3); }\n \t| TEMPLATE typed_declspecs declarator\n-\t  { do_function_instantiation ($2, $3); }\n+\t\t{ do_function_instantiation ($2, $3); }\n \t;\n \n template_type:\n@@ -844,6 +845,8 @@ template_instantiate_once:\n \t\t      pop_obstacks ();\n \t\t      pushdecl_top_level (decl);\n \t\t    }\n+\t\t  /* Kludge; see instantiate_class_template.  */\n+\t\t  TYPE_BEING_DEFINED (t) = 0;\n \t\t}\n \t  left_curly opt.component_decl_list '}'\n \t\t{"}, {"sha": "3bea33d118134b396e8c9618afdebea5d4f75833", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -1013,6 +1013,8 @@ instantiate_class_template (classname, setup_parse)\n       /* Get interface/implementation back in sync.  */\n       extract_interface_info ();\n       overload_template_name (classname, 0);\n+      /* Kludge so that we don't get screwed by our own base classes.  */\n+      TYPE_BEING_DEFINED (TREE_TYPE (classname)) = 1;\n       yychar = PRE_PARSED_CLASS_DECL;\n       yylval.ttype = classname;\n       processing_template_defn++;\n@@ -2187,6 +2189,10 @@ do_pending_expansions ()\n \t\t\t  || TREE_CODE (t) == VAR_DECL, 294);\n       if (TREE_ASM_WRITTEN (t))\n \tDECIDE (0);\n+\n+      if (DECL_EXPLICITLY_INSTANTIATED (t))\n+\tDECIDE (1);\n+\n       /* If it's a method, let the class type decide it.\n \t @@ What if the method template is in a separate file?\n \t Maybe both file contexts should be taken into account?\n@@ -2311,8 +2317,29 @@ do_function_instantiation (declspecs, declarator)\n \t      }\n \t  }\n     }\n-  if (!result)\n+  if (! result)\n     cp_error (\"no matching template for `%D' found\", decl);\n+\n+  DECL_EXPLICITLY_INSTANTIATED (result) = 1;\n+}\n+\n+void\n+do_type_instantiation (name)\n+     tree name;\n+{\n+  tree t = TREE_TYPE (name);\n+\n+  CLASSTYPE_EXPLICITLY_INSTANTIATED (t) = 1;\n+  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n+\n+  /* this should really be done by instantiate_member_templates */\n+  {\n+    tree method = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n+    for (; method; method = TREE_CHAIN (method))\n+      DECL_EXPLICITLY_INSTANTIATED (method) = 1;\n+  }\n+\n+  /* and data member templates, too */\n }\n \n tree"}, {"sha": "23ef5aed58fa32c1ca9761cd129a8c1d9906c0db", "filename": "gcc/cp/search.c", "status": "modified", "additions": 53, "deletions": 112, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -687,6 +687,22 @@ lookup_field_1 (type, name)\n   return NULL_TREE;\n }\n \n+/* There are a number of cases we need to be aware of here:\n+\t\t\t current_class_type\tcurrent_function_decl\n+   * global\t\t\tNULL\t\t\tNULL\n+   * fn-local\t\t\tNULL\t\t\tSET\n+   * class-local\t\tSET\t\t\tNULL\n+   * class->fn\t\t\tSET\t\t\tSET\n+   * fn->class\t\t\tSET\t\t\tSET\n+\n+   Those last two make life interesting.  If we're in a function which is\n+   itself inside a class, we need decls to go into the fn's decls (our\n+   second case below).  But if we're in a class and the class itself is\n+   inside a function, we need decls to go into the decls for the class.  To\n+   achieve this last goal, we must see if, when both current_class_decl and\n+   current_function_decl are set, the class was declared inside that\n+   function.  If so, we know to put the decls into the class's scope.  */\n+\n tree\n current_scope ()\n {\n@@ -1842,14 +1858,14 @@ int tree_has_any_destructor_p (binfo, i)\n   return TYPE_NEEDS_DESTRUCTOR (type);\n }\n \n-/* Given a class type TYPE, and a function decl FNDECL,\n-   look for the first function the TYPE's hierarchy which\n-   FNDECL could match as a virtual function.\n+/* Given a class type TYPE, and a function decl FNDECL, look for a\n+   virtual function in TYPE's hierarchy which FNDECL could match as a\n+   virtual function.  It doesn't matter which one we find.\n \n    DTORP is nonzero if we are looking for a destructor.  Destructors\n    need special treatment because they do not match by name.  */\n tree\n-get_first_matching_virtual (binfo, fndecl, dtorp)\n+get_matching_virtual (binfo, fndecl, dtorp)\n      tree binfo, fndecl;\n      int dtorp;\n {\n@@ -1863,22 +1879,11 @@ get_first_matching_virtual (binfo, fndecl, dtorp)\n \ttmp = get_virtual_destructor (binfo, -1);\n \n       if (tmp)\n-\t{\n-\t  if (get_base_distance (DECL_CONTEXT (tmp),\n-\t\t\t\t DECL_CONTEXT (fndecl), 0, 0) > 0)\n-\t    DECL_CONTEXT (fndecl) = DECL_CONTEXT (tmp);\n-\t  return tmp;\n-\t}\n+\treturn tmp;\n \n       tmp = (tree) breadth_first_search (binfo,\n \t\t\t\t\t (pfi) get_virtual_destructor,\n \t\t\t\t\t tree_has_any_destructor_p);\n-      if (tmp)\n-\t{\n-\t  if (get_base_distance (DECL_CONTEXT (tmp),\n-\t\t\t\t DECL_CONTEXT (fndecl), 0, 0) > 0)\n-\t    DECL_CONTEXT (fndecl) = DECL_CONTEXT (tmp);\n-\t}\n       return tmp;\n     }\n   else\n@@ -1931,33 +1936,20 @@ get_first_matching_virtual (binfo, fndecl, dtorp)\n \t    }\n \t  if (tmp)\n \t    {\n-\t      /* If this is ambiguous, we will warn about it later.  */\n-\t      if (best)\n-\t\t{\n-\t\t  if (get_base_distance (DECL_CLASS_CONTEXT (best),\n-\t\t\t\t\t DECL_CLASS_CONTEXT (tmp), 0, 0) > 0)\n-\t\t    best = tmp;\n-\t\t}\n-\t      else\n-\t\tbest = tmp;\n+\t      best = tmp;\n+\t      break;\n \t    }\n \t}\n       if (best == NULL_TREE && warn_overloaded_virtual)\n \tcp_warning_at (\"conflicting specification deriving virtual function `%D'\", fndecl);\n \n-      if (best)\n-\t{\n-\t  if (get_base_distance (DECL_CONTEXT (best),\n-\t\t\t\t DECL_CONTEXT (fndecl), 0, 0) > 0)\n-\t    DECL_CONTEXT (fndecl) = DECL_CONTEXT (best);\n-\t}\n       return best;\n     }\n }\n \n-/* Return the list of virtual functions which are abstract in type TYPE\n-   that come from non virtual base classes.  See init_vtbl_ptrs for\n-   the style of search we do.  */\n+/* Return the list of virtual functions which are abstract in type\n+   TYPE that come from non virtual base classes.  See\n+   expand_direct_vtbls_init for the style of search we do.  */\n static tree\n get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n      tree binfo, abstract_virtuals;\n@@ -2364,7 +2356,9 @@ dfs_debug_mark (binfo)\n }\n \f\n /*  Attach to the type of the virtual base class, the pointer to the\n-    virtual base class, given the global pointer vbase_decl_ptr.  */\n+    virtual base class, given the global pointer vbase_decl_ptr.\n+\n+    We use the global vbase_types.  ICK!  */\n static void\n dfs_find_vbases (binfo)\n      tree binfo;\n@@ -2471,71 +2465,58 @@ init_vbase_pointers (type, decl_ptr)\n \n /* Build a COMPOUND_EXPR which when expanded will generate the code\n    needed to initialize all the virtual function table slots of all\n-   the virtual baseclasses.  FOR_TYPE is the type which determines the\n-   virtual baseclasses to use; TYPE is the type of the object to which\n-   the initialization applies.  TRUE_EXP is the true object we are\n-   initializing, and DECL_PTR is the pointer to the sub-object we\n+   the virtual baseclasses.  MAIN_BINFO is the binfo which determines\n+   the virtual baseclasses to use; TYPE is the type of the object to\n+   which the initialization applies.  TRUE_EXP is the true object we\n+   are initializing, and DECL_PTR is the pointer to the sub-object we\n    are initializing.\n \n    When USE_COMPUTED_OFFSETS is non-zero, we can assume that the\n    object was laidout by a top-level contructor and the computed\n    offsets are valid to store vtables.  When zero, we must store new\n-   vtables through virtual baseclass pointers.  */\n+   vtables through virtual baseclass pointers.\n+\n+   We setup and use the globals: vbase_decl, vbase_decl_ptr, vbase_types\n+   ICK!  */\n \n void\n-expand_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n-\t\t\t   use_computed_offsets)\n-     tree main_binfo, binfo;\n+expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n+     tree binfo;\n      tree true_exp, decl_ptr;\n      int use_computed_offsets;\n {\n-  tree for_type = BINFO_TYPE (main_binfo);\n   tree type = BINFO_TYPE (binfo);\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n       int old_flag = flag_this_is_variable;\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n-\n-      vbase_types = CLASSTYPE_VBASECLASSES (for_type);\n+      vbase_types = vbases;\n       vbase_decl_ptr = true_exp ? build_unary_op (ADDR_EXPR, true_exp, 0) : decl_ptr;\n       vbase_decl = true_exp ? true_exp : build_indirect_ref (decl_ptr, NULL_PTR);\n \n       if (use_computed_offsets)\n \t{\n \t  /* This is an object of type IN_TYPE,  */\n \t  flag_this_is_variable = -2;\n-\t  dfs_walk (main_binfo, dfs_find_vbases, unmarked_new_vtablep);\n+\t  dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep);\n \t}\n \n       /* Initialized with vtables of type TYPE.  */\n       while (vbases)\n \t{\n-\t  /* This time through, not every class's vtable\n-\t     is going to be initialized.  That is, we only initialize\n-\t     the \"last\" vtable pointer.  */\n-\n-\t  if (CLASSTYPE_VSIZE (BINFO_TYPE (vbases)))\n-\t    {\n-\t      tree addr;\n-\t      tree vtbl = BINFO_VTABLE (vbases);\n-\t      tree init = build_unary_op (ADDR_EXPR, vtbl, 0);\n-\t      if (!flag_vtable_thunks)\n-\t\tassemble_external (vtbl);\n-\t      TREE_USED (vtbl) = 1;\n-\n-\t      if (use_computed_offsets)\n-\t\taddr = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbases));\n-\t      else\n-\t\taddr = convert_pointer_to (vbases, vbase_decl_ptr);\n+\t  tree addr;\n+\t  if (use_computed_offsets)\n+\t    addr = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbases));\n+\t  else\n+\t    addr = convert_pointer_to (vbases, vbase_decl_ptr);\n+\t  if (addr == error_mark_node)\n+\t    continue;\n \n-\t      if (addr)\n-\t\t{\n-\t\t  tree ref = build_vfield_ref (build_indirect_ref (addr, NULL_PTR),\n-\t\t\t\t\t       BINFO_TYPE (vbases));\n-\t\t  init = convert_force (TREE_TYPE (ref), init);\n-\t\t  expand_expr_stmt (build_modify_expr (ref, NOP_EXPR, init));\n-\t\t}\n-\t    }\n+\t  /* Do all vtables from this virtual base. */\n+\t  /* This assumes that virtual bases can never serve as parent\n+\t     binfos.  (in the CLASSTPE_VFIELD_PARENT sense)  */\n+\t  expand_direct_vtbls_init (vbases, TYPE_BINFO (BINFO_TYPE (vbases)),\n+\t\t\t\t    1, 0, addr);\n \t  vbases = TREE_CHAIN (vbases);\n \t}\n \n@@ -3114,46 +3095,6 @@ pop_class_decls (type)\n     search_stack = pop_search_level (search_stack);\n }\n \n-static int\n-bfs_unmark_finished_struct (binfo, i)\n-     tree binfo;\n-     int i;\n-{\n-  if (i >= 0)\n-    binfo = BINFO_BASETYPE (binfo, i);\n-\n-  if (BINFO_NEW_VTABLE_MARKED (binfo))\n-    {\n-      tree decl, context;\n-\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\tbinfo = binfo_member (BINFO_TYPE (binfo),\n-\t\t\t      CLASSTYPE_VBASECLASSES (current_class_type));\n-\n-      decl = BINFO_VTABLE (binfo);\n-      context = DECL_CONTEXT (decl);\n-      DECL_CONTEXT (decl) = 0;\n-      if (write_virtuals >= 0\n-\t  && DECL_INITIAL (decl) != BINFO_VIRTUALS (binfo))\n-\tDECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t\t\t\tBINFO_VIRTUALS (binfo));\n-      finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n-      DECL_CONTEXT (decl) = context;\n-    }\n-  CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n-  return 0;\n-}\n-\n-void\n-unmark_finished_struct (type)\n-     tree type;\n-{\n-  tree binfo = TYPE_BINFO (type);\n-  bfs_unmark_finished_struct (binfo, -1);\n-  breadth_first_search (binfo, bfs_unmark_finished_struct, bfs_marked_vtable_pathp);\n-}\n-\n void\n print_search_statistics ()\n {"}, {"sha": "e85be53e47622d3aaae36fc15bd4b0f5413c702f", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -311,7 +311,8 @@ yylex()\n \t      if (lastiddecl != trrr)\n \t\t{\n \t\t  lastiddecl = trrr;\n-\t\t  tmp_token.yylval.ttype = DECL_NESTED_TYPENAME (trrr);\n+\t\t  if (got_scope)\n+\t\t    tmp_token.yylval.ttype = DECL_NESTED_TYPENAME (trrr);\n \t\t}\n \t      break;\n \t    case IDENTIFIER:\n@@ -326,6 +327,7 @@ yylex()\n \t}\n       else\n \tlastiddecl = trrr;\n+      got_scope = NULL_TREE;\n       /* and fall through to... */\n     case TYPENAME:\n     case PTYPENAME:"}, {"sha": "092fc9339b392fa3d109c68a0c7645d7d93b7a40", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -585,6 +585,9 @@ layout_vbasetypes (rec, max)\n \n    Offsets for immediate nonvirtual baseclasses are also computed here.\n \n+   TYPE_BINFO (REC) should be NULL_TREE on entry, and this routine\n+   creates a list of base_binfos in TYPE_BINFO (REC) from BINFOS.\n+\n    Returns list of virtual base classes in a FIELD_DECL chain.  */\n tree\n layout_basetypes (rec, binfos)"}, {"sha": "4cb6506ac4039d4238b789854508519c78a7191d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -662,6 +662,8 @@ comp_target_types (ttl, ttr, nptrs)\n   ttr = TYPE_MAIN_VARIANT (ttr);\n   if (ttl == ttr)\n     return 1;\n+  if (TREE_CODE (ttr) == TEMPLATE_TYPE_PARM)\n+    return 1;\n \n   if (TREE_CODE (ttr) != TREE_CODE (ttl))\n     return 0;\n@@ -877,6 +879,9 @@ comp_target_parms (parms1, parms2, strict)\n       p2 = TREE_VALUE (t2);\n       if (p1 == p2)\n \tcontinue;\n+      if (TREE_CODE (p2) == TEMPLATE_TYPE_PARM)\n+\tcontinue;\n+\n       if ((TREE_CODE (p1) == POINTER_TYPE && TREE_CODE (p2) == POINTER_TYPE)\n \t  || (TREE_CODE (p1) == REFERENCE_TYPE && TREE_CODE (p2) == REFERENCE_TYPE))\n \t{\n@@ -885,6 +890,9 @@ comp_target_parms (parms1, parms2, strict)\n \t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (p2))))\n \t    continue;\n \n+\t  if (TREE_CODE (TREE_TYPE (p2)) == TEMPLATE_TYPE_PARM)\n+\t    continue;\n+\n \t  /* The following is wrong for contravariance,\n \t     but many programs depend on it.  */\n \t  if (TREE_TYPE (p1) == void_type_node)\n@@ -4591,24 +4599,28 @@ build_conditional_expr (ifexp, op1, op2)\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n       if (!integer_zerop (op2))\n-\twarning (\"pointer/integer type mismatch in conditional expression\");\n+\tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n \t  op2 = null_pointer_node;\n+#if 0\t\t\t\t/* Sez who? */\n \t  if (pedantic && TREE_CODE (type1) == FUNCTION_TYPE)\n \t    pedwarn (\"ANSI C++ forbids conditional expr between 0 and function pointer\");\n+#endif\n \t}\n       result_type = type1;\n     }\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n       if (!integer_zerop (op1))\n-\twarning (\"pointer/integer type mismatch in conditional expression\");\n+\tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n \t  op1 = null_pointer_node;\n+#if 0\t\t\t\t/* Sez who? */\n \t  if (pedantic && TREE_CODE (type2) == FUNCTION_TYPE)\n \t    pedwarn (\"ANSI C++ forbids conditional expr between 0 and function pointer\");\n+#endif\n \t}\n       result_type = type2;\n       op1 = null_pointer_node;\n@@ -6186,19 +6198,19 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t    {\n \t      if (fndecl)\n-\t\tcp_warning (\"passing `%T' as argument %P of `%D' discards const\",\n+\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n \t\t\t    rhstype, parmnum, fndecl);\n \t      else\n-\t\tcp_warning (\"%s to `%T' from `%T' discards const\",\n+\t\tcp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t    errtype, type, rhstype);\n \t    }\n \t  if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t    {\n \t      if (fndecl)\n-\t\tcp_warning (\"passing `%T' as argument %P of `%D' discards volatile\",\n+\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n \t\t\t    rhstype, parmnum, fndecl);\n \t      else\n-\t\tcp_warning (\"%s to `%T' from `%T' discards volatile\",\n+\t\tcp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t    errtype, type, rhstype);\n \t    }\n \t}\n@@ -6244,19 +6256,19 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_warning (\"passing `%T' as argument %P of `%D' discards const\",\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_warning (\"%s to `%T' from `%T' discards const\",\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_warning (\"passing `%T' as argument %P of `%D' discards volatile\",\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_warning (\"%s to `%T' from `%T' discards volatile\",\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t    }"}, {"sha": "a6e08b5084623afd67a80739a192e52e9e834321", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177d104dda07e20323efae4d4560237987d77aa/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=7177d104dda07e20323efae4d4560237987d77aa", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 355.  Free: 180.  */\n+/* First used: 0 (reserved), Last used: 357.  Free:  */\n \n static int abortcount = 0;\n \n@@ -707,56 +707,6 @@ digest_init (type, init, tail)\n       return element;\n     }\n \n-  /* Check for initializing a union by its first field.\n-     Such an initializer must use braces.  */\n-\n-  if (code == UNION_TYPE)\n-    {\n-      tree result, field = TYPE_FIELDS (type);\n-\n-      /* Find the first named field.  ANSI decided in September 1990\n-\t that only named fields count here.  */\n-      while (field && DECL_NAME (field) == 0)\n-\tfield = TREE_CHAIN (field);\n-\n-      if (field == 0)\n-\t{\n-\t  error (\"union with no named members cannot be initialized\");\n-\t  return error_mark_node;\n-\t}\n-\n-      if (raw_constructor && !TYPE_NEEDS_CONSTRUCTING (type))\n-\t{\n-\t  result = process_init_constructor (type, init, NULL_PTR);\n-\t  return result;\n-\t}\n-\n-      if (! raw_constructor)\n-\t{\n-\t  error (\"type mismatch in initialization\");\n-\t  return error_mark_node;\n-\t}\n-      if (element == 0)\n-\t{\n-\t  if (!TYPE_NEEDS_CONSTRUCTING (type))\n-\t    {\n-\t      error (\"union initializer requires one element\");\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Take just the first element from within the constructor\n-\t     and it should match the type of the first element.  */\n-\t  element = digest_init (TREE_TYPE (field), element, (tree *) 0);\n-\t  result = build (CONSTRUCTOR, type, 0, build_tree_list (field, element));\n-\t  TREE_CONSTANT (result) = TREE_CONSTANT (element);\n-\t  TREE_STATIC (result) = (initializer_constant_valid_p (element)\n-\t\t\t\t  && TREE_CONSTANT (element));\n-\t  return result;\n-\t}\n-    }\n-\n   /* Initialization of an array of chars from a string constant\n      optionally enclosed in braces.  */\n \n@@ -834,7 +784,8 @@ digest_init (type, init, tail)\n \n   if (TYPE_SIZE (type) && ! TREE_CONSTANT (TYPE_SIZE (type)))\n     {\n-      error (\"variable-sized object may not be initialized\");\n+      cp_error (\"variable-sized object of type `%T' may not be initialized\",\n+\t\ttype);\n       return error_mark_node;\n     }\n \n@@ -1097,6 +1048,12 @@ process_init_constructor (type, init, elts)\n \t  if (!win)\n \t    TREE_VALUE (tail) = error_mark_node;\n \t}\n+      else if (field == 0)\n+\t{\n+\t  cp_error (\"union `%T' with no named members cannot be initialized\",\n+\t\t    type);\n+\t  TREE_VALUE (tail) = error_mark_node;\n+\t}\n \n       if (TREE_VALUE (tail) != 0)\n \t{\n@@ -1105,7 +1062,7 @@ process_init_constructor (type, init, elts)\n \t  next1 = digest_init (TREE_TYPE (field),\n \t\t\t       TREE_VALUE (tail), &tail1);\n \t  if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n-\t    abort ();\n+\t    my_friendly_abort (357);\n \t  tail = tail1;\n \t}\n       else\n@@ -1129,7 +1086,7 @@ process_init_constructor (type, init, elts)\n   /* If arguments were specified as a constructor,\n      complain unless we used all the elements of the constructor.  */\n   else if (tail)\n-    warning (\"excess elements in aggregate initializer\");\n+    pedwarn (\"excess elements in aggregate initializer\");\n \n   if (erroneous)\n     return error_mark_node;"}]}