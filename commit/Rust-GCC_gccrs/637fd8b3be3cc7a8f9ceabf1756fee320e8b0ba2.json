{"sha": "637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM3ZmQ4YjNiZTNjYzdhOGY5Y2VhYmYxNzU2ZmVlMzIwZThiMGJhMg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-10-22T19:53:38Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-10-22T19:53:38Z"}, "message": "unordered_set.h (unordered_set<>): Prefer aggregation to inheritance with _Hashtable.\n\n2012-10-22  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/unordered_set.h (unordered_set<>): Prefer\n\taggregation to inheritance with _Hashtable.\n\t(unordered_multiset<>): Likewise.\n\t* include/debug/unordered_set (operator==): Adapt.\n\t* include/profile/unordered_set (operator==): Adapt.\n\nFrom-SVN: r192695", "tree": {"sha": "a2cf1c94b9e7e7849736885c79a89fe82bfc58d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2cf1c94b9e7e7849736885c79a89fe82bfc58d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/comments", "author": null, "committer": null, "parents": [{"sha": "9eda026ca02dca915d8bf30ae010985db3bc42ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eda026ca02dca915d8bf30ae010985db3bc42ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eda026ca02dca915d8bf30ae010985db3bc42ce"}], "stats": {"total": 1228, "additions": 1190, "deletions": 38}, "files": [{"sha": "ddace23a28a57c25e851069cadb91dc0413e5fe0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "patch": "@@ -1,3 +1,11 @@\n+2012-10-22  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/unordered_set.h (unordered_set<>): Prefer\n+\taggregation to inheritance with _Hashtable.\n+\t(unordered_multiset<>): Likewise.\n+\t* include/debug/unordered_set (operator==): Adapt.\n+\t* include/profile/unordered_set (operator==): Adapt.\n+\n 2012-10-22  Yufeng Zhang  <yufeng.zhang@arm.com>\n \t    Jonathan Wakely  <jwakely.gcc@gmail.com>\n "}, {"sha": "a822a886ff7d397772018d3d4c993a4425bf270f", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 1167, "deletions": 23, "changes": 1190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "patch": "@@ -91,41 +91,624 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Value>,\n \t   class _Alloc = std::allocator<_Value> >\n     class unordered_set\n-    : public __uset_hashtable<_Value, _Hash, _Pred, _Alloc>\n     {\n-      typedef __uset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __uset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Hashtable;\n+      _Hashtable _M_h;\n \n     public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n+      // typedefs:\n+      //@{\n+      /// Public typedefs.\n+      typedef typename _Hashtable::key_type\tkey_type;\n+      typedef typename _Hashtable::value_type\tvalue_type;\n+      typedef typename _Hashtable::hasher\thasher;\n+      typedef typename _Hashtable::key_equal\tkey_equal;\n+      typedef typename _Hashtable::allocator_type allocator_type;\n+      //@}\n \n+      //@{\n+      ///  Iterator-related typedefs.\n+      typedef typename allocator_type::pointer\t\tpointer;\n+      typedef typename allocator_type::const_pointer\tconst_pointer;\n+      typedef typename allocator_type::reference\treference;\n+      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::iterator\t\titerator;\n+      typedef typename _Hashtable::const_iterator\tconst_iterator;\n+      typedef typename _Hashtable::local_iterator\tlocal_iterator;\n+      typedef typename _Hashtable::const_local_iterator\tconst_local_iterator;\n+      typedef typename _Hashtable::size_type\t\tsize_type;\n+      typedef typename _Hashtable::difference_type\tdifference_type;\n+      //@}\n+\n+      // construct/destroy/copy\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       *  @param __n  Initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       */\n       explicit\n       unordered_set(size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n+      : _M_h(__n, __hf, __eql, __a)\n       { }\n \n+      /**\n+       *  @brief  Builds an %unordered_set from a range.\n+       *  @param  __first  An input iterator.\n+       *  @param  __last  An input iterator.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       *\n+       *  Create an %unordered_set consisting of copies of the elements from\n+       *  [__first,__last).  This is linear in N (where N is\n+       *  distance(__first,__last)).\n+       */\n       template<typename _InputIterator>\n \tunordered_set(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n \t\t      const hasher& __hf = hasher(),\n \t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+\t: _M_h(__f, __l, __n, __hf, __eql, __a)\n \t{ }\n \n+      /**\n+       *  @brief  %Unordered_set copy constructor.\n+       *  @param  __x  An %unordered_set of identical element and allocator\n+       *  types.\n+       *\n+       *  The newly-created %unordered_set uses a copy of the allocation object\n+       *  used by @a __x.\n+       */\n+      unordered_set(const unordered_set& __x)\n+\t: _M_h(__x._M_h) { }\n+\n+     /**\n+       *  @brief %Unordered_set move constructor\n+       *  @param __x  An %unordered_set of identical element and allocator\n+       *  types.\n+       *\n+       *  The newly-created %unordered_set contains the exact contents of @a\n+       *  __x. The contents of @a __x are a valid, but unspecified\n+       *  %unordered_set.\n+       */\n+      unordered_set(unordered_set&& __x)\n+\t: _M_h(std::move(__x._M_h))\n+      { }\n+\n+      /**\n+       *  @brief  Builds an %unordered_set from an initializer_list.\n+       *  @param  __l  An initializer_list.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param  __a  An allocator object.\n+       *\n+       *  Create an %unordered_set consisting of copies of the elements in the\n+       *  list. This is linear in N (where N is @a __l.size()).\n+       */\n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+\t: _M_h(__l, __n, __hf, __eql, __a)\n       { }\n+\n+      /**\n+       *  @brief  %Unordered_set assignment operator.\n+       *  @param  __x  An %unordered_set of identical element and allocator\n+       *  types.\n+       *\n+       *  All the elements of @a __x are copied, but unlike the copy\n+       *  constructor, the allocator object is not copied.\n+       */\n+      unordered_set&\n+      operator=(const unordered_set& __x)\n+      {\n+\t_M_h = __x._M_h;\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief %Unordered_set move assignment operator.\n+       *  @param __x  An %unordered_set of identical element and allocator\n+       *  types.\n+       *\n+       *  The contents of @a __x are moved into this %unordered_set (without\n+       *  copying). @a __x is a valid, but unspecified %unordered_set.\n+       */\n+      unordered_set&\n+      operator=(unordered_set&& __x)\n+      {\n+\t_M_h = std::move(__x._M_h);\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief  %Unordered_set list assignment operator.\n+       *  @param  __l  An initializer_list.\n+       *\n+       *  This function fills an %unordered_set with copies of the elements in\n+       *  the initializer list @a __l.\n+       *\n+       *  Note that the assignment completely changes the %unordered_set and\n+       *  that the resulting %unordered_set's size is the same as the number\n+       *  of elements assigned.  Old data may be lost.\n+       */\n+      unordered_set&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\t_M_h = __l;\n+\treturn *this;\n+      }\n+\n+      ///  Returns the allocator object with which the %unordered_set was\n+      ///  constructed.\n+      allocator_type\n+      get_allocator() const noexcept\n+      { return _M_h.get_allocator(); }\n+\n+      // size and capacity:\n+\n+      ///  Returns true if the %unordered_set is empty.\n+      bool\n+      empty() const noexcept\n+      { return _M_h.empty(); }\n+\n+      ///  Returns the size of the %unordered_set.\n+      size_type\n+      size() const noexcept\n+      { return _M_h.size(); }\n+\n+      ///  Returns the maximum size of the %unordered_set.\n+      size_type\n+      max_size() const noexcept\n+      { return _M_h.max_size(); }\n+\n+      // iterators.\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %unordered_set.\n+       */\n+      iterator\n+      begin() noexcept\n+      { return _M_h.begin(); }\n+\n+      const_iterator\n+      begin() const noexcept\n+      { return _M_h.begin(); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %unordered_set.\n+       */\n+      iterator\n+      end() noexcept\n+      { return _M_h.end(); }\n+\n+      const_iterator\n+      end() const noexcept\n+      { return _M_h.end(); }\n+      //@}\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %unordered_set.\n+       */\n+      const_iterator\n+      cbegin() const noexcept\n+      { return _M_h.begin(); }\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %unordered_set.\n+       */\n+      const_iterator\n+      cend() const noexcept\n+      { return _M_h.end(); }\n+\n+      // modifiers.\n+\n+      /**\n+       *  @brief Attempts to build and insert an element into the\n+       *  %unordered_set.\n+       *  @param __args  Arguments used to generate an element.\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted element, and the second is a bool\n+       *           that is true if the element was actually inserted.\n+       *\n+       *  This function attempts to build and insert an element into the\n+       *  %unordered_set. An %unordered_set relies on unique keys and thus an\n+       *  element is only inserted if it is not already present in the %set.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{ return _M_h.emplace(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Attempts to insert an element into the %unordered_set.\n+       *  @param  __pos  An iterator that serves as a hint as to where the\n+       *                element should be inserted.\n+       *  @param  __args  Arguments used to generate the element to be\n+       *                 inserted.\n+       *  @return An iterator that points to the element with key equivalent to\n+       *          the one generated from @a __args (may or may not be the\n+       *          element itself).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument emplace()\n+       *  does.  Note that the first parameter is only a hint and can\n+       *  potentially improve the performance of the insertion process.  A bad\n+       *  hint would cause no gains in efficiency.\n+       *\n+       *  For more on @a hinting, see:\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }\n+\n+      //@{\n+      /**\n+       *  @brief Attempts to insert an element into the %unordered_set.\n+       *  @param  __x  Element to be inserted.\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted element, and the second is a bool\n+       *           that is true if the element was actually inserted.\n+       *\n+       *  This function attempts to insert an element into the %unordered_set.\n+       *  An %unordered_set relies on unique keys and thus an element is only\n+       *  inserted if it is not already present in the %unordered_set.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      std::pair<iterator, bool>\n+      insert(const value_type& __x)\n+      { return _M_h.insert(__x); }\n+\n+      std::pair<iterator, bool>\n+      insert(value_type&& __x)\n+      { return _M_h.insert(std::move(__x)); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief Attempts to insert an element into the %unordered_set.\n+       *  @param  __hint  An iterator that serves as a hint as to where the\n+       *                 element should be inserted.\n+       *  @param  __x  Element to be inserted.\n+       *  @return An iterator that points to the element with key of\n+       *           @a __x (may or may not be the element passed in).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument insert()\n+       *  does.  Note that the first parameter is only a hint and can\n+       *  potentially improve the performance of the insertion process.  A bad\n+       *  hint would cause no gains in efficiency.\n+       *\n+       *  For more on @a hinting, see:\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *\n+       *  Insertion requires amortized constant.\n+       */\n+      iterator\n+      insert(const_iterator __hint, const value_type& __x)\n+      { return _M_h.insert(__hint, __x); }\n+\n+      iterator\n+      insert(const_iterator __hint, value_type&& __x)\n+      { return _M_h.insert(__hint, std::move(__x)); }\n+      //@}\n+\n+      /**\n+       *  @brief A template function that attempts to insert a range of\n+       *  elements.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                   inserted.\n+       *  @param  __last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template<typename _InputIterator>\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{ _M_h.insert(__first, __last); }\n+\n+      /**\n+       *  @brief Attempts to insert a list of elements into the %unordered_set.\n+       *  @param  __l  A std::initializer_list<value_type> of elements\n+       *               to be inserted.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { _M_h.insert(__l); }\n+\n+      //@{\n+      /**\n+       *  @brief Erases an element from an %unordered_set.\n+       *  @param  __position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a __position prior to the element being erased. If no such\n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from an %unordered_set.  Note that this function only erases the\n+       *  element, and that if the element is itself a pointer, the pointed-to\n+       *  memory is not touched in any way.  Managing the pointer is the user's\n+       *  responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __position)\n+      { return _M_h.erase(__position); }\n+\n+      // LWG 2059.\n+      iterator\n+      erase(iterator __it)\n+      { return _M_h.erase(__it); }\n+      //@}\n+\n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  __x  Key of element to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all the elements located by the given key from\n+       *  an %unordered_set. For an %unordered_set the result of this function\n+       *  can only be 0 (not present) or 1 (present).\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      size_type\n+      erase(const key_type& __x)\n+      { return _M_h.erase(__x); }\n+\n+      /**\n+       *  @brief Erases a [__first,__last) range of elements from an\n+       *  %unordered_set.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                  erased.\n+       *  @param __last  Iterator pointing to the end of the range to\n+       *                be erased.\n+       *  @return The iterator @a __last.\n+       *\n+       *  This function erases a sequence of elements from an %unordered_set.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      { return _M_h.erase(__first, __last); }\n+\n+      /**\n+       *  Erases all elements in an %unordered_set. Note that this function only\n+       *  erases the elements, and that if the elements themselves are pointers,\n+       *  the pointed-to memory is not touched in any way. Managing the pointer\n+       *  is the user's responsibility.\n+       */\n+      void\n+      clear() noexcept\n+      { _M_h.clear(); }\n+\n+      /**\n+       *  @brief  Swaps data with another %unordered_set.\n+       *  @param  __x  An %unordered_set of the same element and allocator\n+       *  types.\n+       *\n+       *  This exchanges the elements between two sets in constant time.\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(s1,s2) will feed to this function.\n+       */\n+      void\n+      swap(unordered_set& __x)\n+      { _M_h.swap(__x._M_h); }\n+\n+      // observers.\n+\n+      ///  Returns the hash functor object with which the %unordered_set was\n+      ///  constructed.\n+      hasher\n+      hash_function() const\n+      { return _M_h.hash_function(); }\n+\n+      ///  Returns the key comparison object with which the %unordered_set was\n+      ///  constructed.\n+      key_equal\n+      key_eq() const\n+      { return _M_h.key_eq(); }\n+\n+      // lookup.\n+\n+      //@{\n+      /**\n+       *  @brief Tries to locate an element in an %unordered_set.\n+       *  @param  __x  Element to be located.\n+       *  @return  Iterator pointing to sought-after element, or end() if not\n+       *           found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after element.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_h.find(__x); }\n+\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_h.find(__x); }\n+      //@}\n+\n+      /**\n+       *  @brief  Finds the number of elements.\n+       *  @param  __x  Element to located.\n+       *  @return  Number of elements with specified key.\n+       *\n+       *  This function only makes sense for unordered_multisets; for\n+       *  unordered_set the result will either be 0 (not present) or 1\n+       *  (present).\n+       */\n+      size_type\n+      count(const key_type& __x) const\n+      { return _M_h.count(__x); }\n+\n+      //@{\n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  __x  Key to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       *\n+       *  This function probably only makes sense for multisets.\n+       */\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __x)\n+      { return _M_h.equal_range(__x); }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __x) const\n+      { return _M_h.equal_range(__x); }\n+      //@}\n+\n+      // bucket interface.\n+\n+      /// Returns the number of buckets of the %unordered_set.\n+      size_type\n+      bucket_count() const noexcept\n+      { return _M_h.bucket_count(); }\n+\n+      /// Returns the maximum number of buckets of the %unordered_set.\n+      size_type\n+      max_bucket_count() const noexcept\n+      { return _M_h.max_bucket_count(); }\n+\n+      /*\n+       * @brief  Returns the number of elements in a given bucket.\n+       * @param  __n  A bucket index.\n+       * @return  The number of elements in the bucket.\n+       */\n+      size_type\n+      bucket_size(size_type __n) const\n+      { return _M_h.bucket_size(__n); }\n+\n+      /*\n+       * @brief  Returns the bucket index of a given element.\n+       * @param  __key  A key instance.\n+       * @return  The key bucket index.\n+       */\n+      size_type\n+      bucket(const key_type& __key) const\n+      { return _M_h.bucket(__key); }\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to the first\n+       *         bucket element.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      local_iterator\n+      begin(size_type __n)\n+      { return _M_h.begin(__n); }\n+\n+      const_local_iterator\n+      begin(size_type __n) const\n+      { return _M_h.begin(__n); }\n+\n+      const_local_iterator\n+      cbegin(size_type __n) const\n+      { return _M_h.cbegin(__n); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to one past\n+       *         the last bucket elements.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      local_iterator\n+      end(size_type __n)\n+      { return _M_h.end(__n); }\n+\n+      const_local_iterator\n+      end(size_type __n) const\n+      { return _M_h.end(__n); }\n+\n+      const_local_iterator\n+      cend(size_type __n) const\n+      { return _M_h.cend(__n); }\n+      //@}\n+\n+      // hash policy.\n+\n+      /// Returns the average number of elements per bucket.\n+      float\n+      load_factor() const noexcept\n+      { return _M_h.load_factor(); }\n+\n+      /// Returns a positive number that the %unordered_set tries to keep the\n+      /// load factor less than or equal to.\n+      float\n+      max_load_factor() const noexcept\n+      { return _M_h.max_load_factor(); }\n+\n+      /**\n+       *  @brief  Change the %unordered_set maximum load factor.\n+       *  @param  __z The new maximum load factor.\n+       */\n+      void\n+      max_load_factor(float __z)\n+      { _M_h.max_load_factor(__z); }\n+\n+      /**\n+       *  @brief  May rehash the %unordered_set.\n+       *  @param  __n The new number of buckets.\n+       *\n+       *  Rehash will occur only if the new number of buckets respect the\n+       *  %unordered_set maximum load factor.\n+       */\n+      void\n+      rehash(size_type __n)\n+      { _M_h.rehash(__n); }\n+\n+      /**\n+       *  @brief  Prepare the %unordered_set for a specified number of\n+       *          elements.\n+       *  @param  __n Number of elements required.\n+       *\n+       *  Same as rehash(ceil(n / max_load_factor())).\n+       */\n+      void\n+      reserve(size_type __n)\n+      { _M_h.reserve(__n); }\n+\n+      template<typename _Value1, typename _Hash1, typename _Pred1,\n+\t       typename _Alloc1>\n+        friend bool\n+      operator==(const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&,\n+\t\t const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&);\n     };\n \n   /**\n@@ -152,42 +735,603 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Value>,\n \t   class _Alloc = std::allocator<_Value> >\n     class unordered_multiset\n-    : public __umset_hashtable<_Value, _Hash, _Pred, _Alloc>\n     {\n-      typedef __umset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __umset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Hashtable;\n+      _Hashtable _M_h;\n \n     public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n+      // typedefs:\n+      //@{\n+      /// Public typedefs.\n+      typedef typename _Hashtable::key_type\tkey_type;\n+      typedef typename _Hashtable::value_type\tvalue_type;\n+      typedef typename _Hashtable::hasher\thasher;\n+      typedef typename _Hashtable::key_equal\tkey_equal;\n+      typedef typename _Hashtable::allocator_type allocator_type;\n+      //@}\n+\n+      //@{\n+      ///  Iterator-related typedefs.\n+      typedef typename allocator_type::pointer\t\tpointer;\n+      typedef typename allocator_type::const_pointer\tconst_pointer;\n+      typedef typename allocator_type::reference\treference;\n+      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::iterator\t\titerator;\n+      typedef typename _Hashtable::const_iterator\tconst_iterator;\n+      typedef typename _Hashtable::local_iterator\tlocal_iterator;\n+      typedef typename _Hashtable::const_local_iterator\tconst_local_iterator;\n+      typedef typename _Hashtable::size_type\t\tsize_type;\n+      typedef typename _Hashtable::difference_type\tdifference_type;\n+      //@}\n \n+      // construct/destroy/copy\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       *  @param __n  Initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       */\n       explicit\n       unordered_multiset(size_type __n = 10,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n+      : _M_h(__n, __hf, __eql, __a)\n       { }\n \n-\n+      /**\n+       *  @brief  Builds an %unordered_multiset from a range.\n+       *  @param  __first  An input iterator.\n+       *  @param  __last  An input iterator.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param __a  An allocator object.\n+       *\n+       *  Create an %unordered_multiset consisting of copies of the elements\n+       *  from [__first,__last).  This is linear in N (where N is\n+       *  distance(__first,__last)).\n+       */\n       template<typename _InputIterator>\n \tunordered_multiset(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n \t\t\t   const hasher& __hf = hasher(),\n \t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+\t: _M_h(__f, __l, __n, __hf, __eql, __a)\n \t{ }\n \n+      /**\n+       *  @brief  %Unordered_multiset copy constructor.\n+       *  @param  __x  An %unordered_multiset of identical element and allocator\n+       *  types.\n+       *\n+       *  The newly-created %unordered_multiset uses a copy of the allocation object\n+       *  used by @a __x.\n+       */\n+      unordered_multiset(const unordered_multiset& __x)\n+\t: _M_h(__x._M_h) { }\n+\n+     /**\n+       *  @brief %Unordered_multiset move constructor\n+       *  @param __x  An %unordered_multiset of identical element and allocator\n+       *  types.\n+       *\n+       *  The newly-created %unordered_multiset contains the exact contents of\n+       *  @a __x. The contents of @a __x are a valid, but unspecified\n+       *  %unordered_multiset.\n+       */\n+      unordered_multiset(unordered_multiset&& __x)\n+\t: _M_h(std::move(__x._M_h))\n+      { }\n+\n+      /**\n+       *  @brief  Builds an %unordered_multiset from an initializer_list.\n+       *  @param  __l  An initializer_list.\n+       *  @param __n  Minimal initial number of buckets.\n+       *  @param __hf  A hash functor.\n+       *  @param __eql  A key equality functor.\n+       *  @param  __a  An allocator object.\n+       *\n+       *  Create an %unordered_multiset consisting of copies of the elements in\n+       *  the list. This is linear in N (where N is @a __l.size()).\n+       */\n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+\t: _M_h(__l, __n, __hf, __eql, __a)\n       { }\n+\n+      /**\n+       *  @brief  %Unordered_multiset assignment operator.\n+       *  @param  __x  An %unordered_multiset of identical element and allocator\n+       *  types.\n+       *\n+       *  All the elements of @a __x are copied, but unlike the copy\n+       *  constructor, the allocator object is not copied.\n+       */\n+      unordered_multiset&\n+      operator=(const unordered_multiset& __x)\n+      {\n+\t_M_h = __x._M_h;\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief %Unordered_multiset move assignment operator.\n+       *  @param __x  An %unordered_multiset of identical element and allocator\n+       *  types.\n+       *\n+       *  The contents of @a __x are moved into this %unordered_multiset\n+       *  (without copying). @a __x is a valid, but unspecified\n+       *  %unordered_multiset.\n+       */\n+      unordered_multiset&\n+      operator=(unordered_multiset&& __x)\n+      {\n+\t_M_h = std::move(__x._M_h);\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief  %Unordered_multiset list assignment operator.\n+       *  @param  __l  An initializer_list.\n+       *\n+       *  This function fills an %unordered_multiset with copies of the elements\n+       *  in the initializer list @a __l.\n+       *\n+       *  Note that the assignment completely changes the %unordered_multiset\n+       *  and that the resulting %unordered_set's size is the same as the number\n+       *  of elements assigned.  Old data may be lost.\n+       */\n+      unordered_multiset&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\t_M_h = __l;\n+\treturn *this;\n+      }\n+\n+      ///  Returns the allocator object with which the %unordered_multiset was\n+      ///  constructed.\n+      allocator_type\n+      get_allocator() const noexcept\n+      { return _M_h.get_allocator(); }\n+\n+      // size and capacity:\n+\n+      ///  Returns true if the %unordered_multiset is empty.\n+      bool\n+      empty() const noexcept\n+      { return _M_h.empty(); }\n+\n+      ///  Returns the size of the %unordered_multiset.\n+      size_type\n+      size() const noexcept\n+      { return _M_h.size(); }\n+\n+      ///  Returns the maximum size of the %unordered_multiset.\n+      size_type\n+      max_size() const noexcept\n+      { return _M_h.max_size(); }\n+\n+      // iterators.\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %unordered_multiset.\n+       */\n+      iterator\n+      begin() noexcept\n+      { return _M_h.begin(); }\n+\n+      const_iterator\n+      begin() const noexcept\n+      { return _M_h.begin(); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %unordered_multiset.\n+       */\n+      iterator\n+      end() noexcept\n+      { return _M_h.end(); }\n+\n+      const_iterator\n+      end() const noexcept\n+      { return _M_h.end(); }\n+      //@}\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %unordered_multiset.\n+       */\n+      const_iterator\n+      cbegin() const noexcept\n+      { return _M_h.begin(); }\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %unordered_multiset.\n+       */\n+      const_iterator\n+      cend() const noexcept\n+      { return _M_h.end(); }\n+\n+      // modifiers.\n+\n+      /**\n+       *  @brief Builds and insert an element into the %unordered_multiset.\n+       *  @param __args  Arguments used to generate an element.\n+       *  @return  An iterator that points to the inserted element.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{ return _M_h.emplace(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Inserts an element into the %unordered_multiset.\n+       *  @param  __pos  An iterator that serves as a hint as to where the\n+       *                element should be inserted.\n+       *  @param  __args  Arguments used to generate the element to be\n+       *                 inserted.\n+       *  @return An iterator that points to the inserted element.\n+       *\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process.  A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  For more on @a hinting, see:\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }\n+\n+      //@{\n+      /**\n+       *  @brief Inserts an element into the %unordered_multiset.\n+       *  @param  __x  Element to be inserted.\n+       *  @return  An iterator that points to the inserted element.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      iterator\n+      insert(const value_type& __x)\n+      { return _M_h.insert(__x); }\n+\n+      iterator\n+      insert(value_type&& __x)\n+      { return _M_h.insert(std::move(__x)); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief Inserts an element into the %unordered_multiset.\n+       *  @param  __hint  An iterator that serves as a hint as to where the\n+       *                 element should be inserted.\n+       *  @param  __x  Element to be inserted.\n+       *  @return An iterator that points to the inserted element.\n+       *\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process.  A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  For more on @a hinting, see:\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *\n+       *  Insertion requires amortized constant.\n+       */\n+      iterator\n+      insert(const_iterator __hint, const value_type& __x)\n+      { return _M_h.insert(__hint, __x); }\n+\n+      iterator\n+      insert(const_iterator __hint, value_type&& __x)\n+      { return _M_h.insert(__hint, std::move(__x)); }\n+      //@}\n+\n+      /**\n+       *  @brief A template function that inserts a range of elements.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                   inserted.\n+       *  @param  __last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template<typename _InputIterator>\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{ _M_h.insert(__first, __last); }\n+\n+      /**\n+       *  @brief Inserts a list of elements into the %unordered_multiset.\n+       *  @param  __l  A std::initializer_list<value_type> of elements to be\n+       *              inserted.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { _M_h.insert(__l); }\n+\n+      //@{\n+      /**\n+       *  @brief Erases an element from an %unordered_multiset.\n+       *  @param  __position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a __position prior to the element being erased. If no such\n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from an %unordered_multiset.\n+       *\n+       *  Note that this function only erases the element, and that if the\n+       *  element is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __position)\n+      { return _M_h.erase(__position); }\n+\n+      // LWG 2059.\n+      iterator\n+      erase(iterator __it)\n+      { return _M_h.erase(__it); }\n+      //@}\n+\n+\n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  __x  Key of element to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all the elements located by the given key from\n+       *  an %unordered_multiset.\n+       *\n+       *  Note that this function only erases the element, and that if the\n+       *  element is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibility.\n+       */\n+      size_type\n+      erase(const key_type& __x)\n+      { return _M_h.erase(__x); }\n+\n+      /**\n+       *  @brief Erases a [__first,__last) range of elements from an\n+       *  %unordered_multiset.\n+       *  @param  __first  Iterator pointing to the start of the range to be\n+       *                  erased.\n+       *  @param __last  Iterator pointing to the end of the range to\n+       *                be erased.\n+       *  @return The iterator @a __last.\n+       *\n+       *  This function erases a sequence of elements from an\n+       *  %unordered_multiset.\n+       *\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      { return _M_h.erase(__first, __last); }\n+\n+      /**\n+       *  Erases all elements in an %unordered_multiset.\n+       *\n+       *  Note that this function only erases the elements, and that if the\n+       *  elements themselves are pointers, the pointed-to memory is not touched\n+       *  in any way. Managing the pointer is the user's responsibility.\n+       */\n+      void\n+      clear() noexcept\n+      { _M_h.clear(); }\n+\n+      /**\n+       *  @brief  Swaps data with another %unordered_multiset.\n+       *  @param  __x  An %unordered_multiset of the same element and allocator\n+       *  types.\n+       *\n+       *  This exchanges the elements between two sets in constant time.\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(s1,s2) will feed to this function.\n+       */\n+      void\n+      swap(unordered_multiset& __x)\n+      { _M_h.swap(__x._M_h); }\n+\n+      // observers.\n+\n+      ///  Returns the hash functor object with which the %unordered_multiset\n+      ///  was constructed.\n+      hasher\n+      hash_function() const\n+      { return _M_h.hash_function(); }\n+\n+      ///  Returns the key comparison object with which the %unordered_multiset\n+      ///  was constructed.\n+      key_equal\n+      key_eq() const\n+      { return _M_h.key_eq(); }\n+\n+      // lookup.\n+\n+      //@{\n+      /**\n+       *  @brief Tries to locate an element in an %unordered_multiset.\n+       *  @param  __x  Element to be located.\n+       *  @return  Iterator pointing to sought-after element, or end() if not\n+       *           found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after element.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_h.find(__x); }\n+\n+      const_iterator\n+      find(const key_type& __x) const\n+      { return _M_h.find(__x); }\n+      //@}\n+\n+      /**\n+       *  @brief  Finds the number of elements.\n+       *  @param  __x  Element to located.\n+       *  @return  Number of elements with specified key.\n+       */\n+      size_type\n+      count(const key_type& __x) const\n+      { return _M_h.count(__x); }\n+\n+      //@{\n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  __x  Key to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       */\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __x)\n+      { return _M_h.equal_range(__x); }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __x) const\n+      { return _M_h.equal_range(__x); }\n+      //@}\n+\n+      // bucket interface.\n+\n+      /// Returns the number of buckets of the %unordered_multiset.\n+      size_type\n+      bucket_count() const noexcept\n+      { return _M_h.bucket_count(); }\n+\n+      /// Returns the maximum number of buckets of the %unordered_multiset.\n+      size_type\n+      max_bucket_count() const noexcept\n+      { return _M_h.max_bucket_count(); }\n+\n+      /*\n+       * @brief  Returns the number of elements in a given bucket.\n+       * @param  __n  A bucket index.\n+       * @return  The number of elements in the bucket.\n+       */\n+      size_type\n+      bucket_size(size_type __n) const\n+      { return _M_h.bucket_size(__n); }\n+\n+      /*\n+       * @brief  Returns the bucket index of a given element.\n+       * @param  __key  A key instance.\n+       * @return  The key bucket index.\n+       */\n+      size_type\n+      bucket(const key_type& __key) const\n+      { return _M_h.bucket(__key); }\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to the first\n+       *         bucket element.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      local_iterator\n+      begin(size_type __n)\n+      { return _M_h.begin(__n); }\n+\n+      const_local_iterator\n+      begin(size_type __n) const\n+      { return _M_h.begin(__n); }\n+\n+      const_local_iterator\n+      cbegin(size_type __n) const\n+      { return _M_h.cbegin(__n); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief  Returns a read-only (constant) iterator pointing to one past\n+       *         the last bucket elements.\n+       *  @param  __n The bucket index.\n+       *  @return  A read-only local iterator.\n+       */\n+      local_iterator\n+      end(size_type __n)\n+      { return _M_h.end(__n); }\n+\n+      const_local_iterator\n+      end(size_type __n) const\n+      { return _M_h.end(__n); }\n+\n+      const_local_iterator\n+      cend(size_type __n) const\n+      { return _M_h.cend(__n); }\n+      //@}\n+\n+      // hash policy.\n+\n+      /// Returns the average number of elements per bucket.\n+      float\n+      load_factor() const noexcept\n+      { return _M_h.load_factor(); }\n+\n+      /// Returns a positive number that the %unordered_multiset tries to keep the\n+      /// load factor less than or equal to.\n+      float\n+      max_load_factor() const noexcept\n+      { return _M_h.max_load_factor(); }\n+\n+      /**\n+       *  @brief  Change the %unordered_multiset maximum load factor.\n+       *  @param  __z The new maximum load factor.\n+       */\n+      void\n+      max_load_factor(float __z)\n+      { _M_h.max_load_factor(__z); }\n+\n+      /**\n+       *  @brief  May rehash the %unordered_multiset.\n+       *  @param  __n The new number of buckets.\n+       *\n+       *  Rehash will occur only if the new number of buckets respect the\n+       *  %unordered_multiset maximum load factor.\n+       */\n+      void\n+      rehash(size_type __n)\n+      { _M_h.rehash(__n); }\n+\n+      /**\n+       *  @brief  Prepare the %unordered_multiset for a specified number of\n+       *          elements.\n+       *  @param  __n Number of elements required.\n+       *\n+       *  Same as rehash(ceil(n / max_load_factor())).\n+       */\n+      void\n+      reserve(size_type __n)\n+      { _M_h.reserve(__n); }\n+\n+      template<typename _Value1, typename _Hash1, typename _Pred1,\n+\t       typename _Alloc1>\n+        friend bool\n+      operator==(const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&,\n+\t\t const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&);\n     };\n \n   template<class _Value, class _Hash, class _Pred, class _Alloc>\n@@ -206,7 +1350,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     inline bool\n     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_h._M_equal(__y._M_h); }\n \n   template<class _Value, class _Hash, class _Pred, class _Alloc>\n     inline bool\n@@ -218,7 +1362,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     inline bool\n     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_h._M_equal(__y._M_h); }\n \n   template<class _Value, class _Hash, class _Pred, class _Alloc>\n     inline bool"}, {"sha": "8cae0c9c222f8a9c19fbe2bc55347f8fe9ecd098", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "patch": "@@ -479,7 +479,7 @@ namespace __debug\n     inline bool\n     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_base() == __y._M_base(); }\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n     inline bool\n@@ -912,7 +912,7 @@ namespace __debug\n     inline bool\n     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return __x._M_base() == __y._M_base(); }\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n     inline bool"}, {"sha": "529454cf64664954b88f34bc683ec6934613bd85", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=637fd8b3be3cc7a8f9ceabf1756fee320e8b0ba2", "patch": "@@ -50,7 +50,7 @@ namespace __profile\n     class unordered_set\n     : public _GLIBCXX_STD_BASE\n     {\n-      typedef typename _GLIBCXX_STD_BASE _Base;\n+      typedef _GLIBCXX_STD_BASE _Base;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -287,22 +287,22 @@ namespace __profile\n       }\n   };\n \n-  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n     inline void\n-    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    swap(unordered_set<_Key, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_set<_Key, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n-  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n     inline bool\n-    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    operator==(const unordered_set<_Key, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Key, _Hash, _Pred, _Alloc>& __y)\n+    { return static_cast<const _GLIBCXX_STD_BASE&>(__x) == __y; }\n \n-  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n     inline bool\n-    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    operator!=(const unordered_set<_Key, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Key, _Hash, _Pred, _Alloc>& __y)\n     { return !(__x == __y); }\n \n #undef _GLIBCXX_BASE\n@@ -318,7 +318,7 @@ namespace __profile\n     class unordered_multiset\n     : public _GLIBCXX_STD_BASE\n     {\n-      typedef typename _GLIBCXX_STD_BASE _Base;\n+      typedef _GLIBCXX_STD_BASE _Base;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -559,7 +559,7 @@ namespace __profile\n     inline bool\n     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n \t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_equal(__y); }\n+    { return static_cast<const _GLIBCXX_STD_BASE&>(__x) == __y; }\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n     inline bool"}]}