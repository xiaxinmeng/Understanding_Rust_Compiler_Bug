{"sha": "6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYyZmZiNGI5OWNjZmI2NGFkYzBlZGM5OTk4MzI5ZWU5ZGUzMmVmZg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2011-12-31T20:02:48Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2011-12-31T20:02:48Z"}, "message": "cselib.h (cselib_add_permanent_equiv): Declare.\n\n* cselib.h (cselib_add_permanent_equiv): Declare.\n(canonical_cselib_val): New.\n* cselib.c (new_elt_loc_list): Rework to support value\nequivalences.  Adjust all callers.\n(preserve_only_constants): Retain value equivalences.\n(references_value_p): Retain preserved values.\n(rtx_equal_for_cselib_1): Handle value equivalences.\n(cselib_invalidate_regno): Use canonical value.\n(cselib_add_permanent_equiv): New.\n* alias.c (find_base_term): Reset locs lists while recursing.\n* var-tracking.c (val_bind): New.  Don't add equivalences\npresent in cselib table, compared with code moved from...\n(val_store): ... here.\n(val_resolve): Use val_bind.\n(VAL_EXPR_HAS_REVERSE): Drop.\n(add_uses): Do not create MOps for addresses.  Do not mark\nnon-REG non-MEM expressions as requiring resolution.\n(reverse_op): Record reverse as a cselib equivalence.\n(add_stores): Use it.  Do not create MOps for addresses.\nDo not require resolution for non-REG non-MEM expressions.\nSimplify support for reverse operations.\n(compute_bb_dataflow): Drop reverse support.\n(emit_notes_in_bb): Likewise.\n(create_entry_value): Rename to...\n(record_entry_value): ... this.  Use cselib equivalences.\n(vt_add_function_parameter): Adjust.\n\nFrom-SVN: r182760", "tree": {"sha": "3e772ea68b4b52431218cb73789aabb374b906b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e772ea68b4b52431218cb73789aabb374b906b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/comments", "author": null, "committer": null, "parents": [{"sha": "32210fd616cd79ae540b9731e7efa9288ccc0b87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32210fd616cd79ae540b9731e7efa9288ccc0b87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32210fd616cd79ae540b9731e7efa9288ccc0b87"}], "stats": {"total": 500, "additions": 290, "deletions": 210}, "files": [{"sha": "bf05b56b77b7c1fd786315a33688f9a95207cccc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "patch": "@@ -1,3 +1,32 @@\n+2011-12-31  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* cselib.h (cselib_add_permanent_equiv): Declare.\n+\t(canonical_cselib_val): New.\n+\t* cselib.c (new_elt_loc_list): Rework to support value\n+\tequivalences.  Adjust all callers.\n+\t(preserve_only_constants): Retain value equivalences.\n+\t(references_value_p): Retain preserved values.\n+\t(rtx_equal_for_cselib_1): Handle value equivalences.\n+\t(cselib_invalidate_regno): Use canonical value.\n+\t(cselib_add_permanent_equiv): New.\n+\t* alias.c (find_base_term): Reset locs lists while recursing.\n+\t* var-tracking.c (val_bind): New.  Don't add equivalences\n+\tpresent in cselib table, compared with code moved from...\n+\t(val_store): ... here.\n+\t(val_resolve): Use val_bind.\n+\t(VAL_EXPR_HAS_REVERSE): Drop.\n+\t(add_uses): Do not create MOps for addresses.  Do not mark\n+\tnon-REG non-MEM expressions as requiring resolution.\n+\t(reverse_op): Record reverse as a cselib equivalence.\n+\t(add_stores): Use it.  Do not create MOps for addresses.\n+\tDo not require resolution for non-REG non-MEM expressions.\n+\tSimplify support for reverse operations.\n+\t(compute_bb_dataflow): Drop reverse support.\n+\t(emit_notes_in_bb): Likewise.\n+\t(create_entry_value): Rename to...\n+\t(record_entry_value): ... this.  Use cselib equivalences.\n+\t(vt_add_function_parameter): Adjust.\n+\n 2011-12-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_inner_target_options): Fix thinko"}, {"sha": "37c3fa062cf4b44285b54597e872dcf4bd9bb0f5", "filename": "gcc/alias.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "patch": "@@ -1542,7 +1542,8 @@ rtx\n find_base_term (rtx x)\n {\n   cselib_val *val;\n-  struct elt_loc_list *l;\n+  struct elt_loc_list *l, *f;\n+  rtx ret;\n \n #if defined (FIND_BASE_TERM)\n   /* Try machine-dependent ways to find the base term.  */\n@@ -1591,12 +1592,26 @@ find_base_term (rtx x)\n \n     case VALUE:\n       val = CSELIB_VAL_PTR (x);\n+      ret = NULL_RTX;\n+\n       if (!val)\n-\treturn 0;\n-      for (l = val->locs; l; l = l->next)\n-\tif ((x = find_base_term (l->loc)) != 0)\n-\t  return x;\n-      return 0;\n+\treturn ret;\n+\n+      f = val->locs;\n+      /* Temporarily reset val->locs to avoid infinite recursion.  */\n+      val->locs = NULL;\n+\n+      for (l = f; l; l = l->next)\n+\tif (GET_CODE (l->loc) == VALUE\n+\t    && CSELIB_VAL_PTR (l->loc)->locs\n+\t    && !CSELIB_VAL_PTR (l->loc)->locs->next\n+\t    && CSELIB_VAL_PTR (l->loc)->locs->loc == x)\n+\t  continue;\n+\telse if ((ret = find_base_term (l->loc)) != 0)\n+\t  break;\n+\n+      val->locs = f;\n+      return ret;\n \n     case LO_SUM:\n       /* The standard form is (lo_sum reg sym) so look only at the"}, {"sha": "4324ffe50297d5c7bf9dc07feb300b6f50af81b9", "filename": "gcc/cselib.c", "status": "modified", "additions": 124, "deletions": 40, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "patch": "@@ -55,7 +55,7 @@ static bool cselib_preserve_constants;\n static int entry_and_rtx_equal_p (const void *, const void *);\n static hashval_t get_value_hash (const void *);\n static struct elt_list *new_elt_list (struct elt_list *, cselib_val *);\n-static struct elt_loc_list *new_elt_loc_list (struct elt_loc_list *, rtx);\n+static void new_elt_loc_list (cselib_val *, rtx);\n static void unchain_one_value (cselib_val *);\n static void unchain_one_elt_list (struct elt_list **);\n static void unchain_one_elt_loc_list (struct elt_loc_list **);\n@@ -223,26 +223,75 @@ new_elt_list (struct elt_list *next, cselib_val *elt)\n   return el;\n }\n \n-/* Allocate a struct elt_loc_list and fill in its two elements with the\n-   arguments.  */\n+/* Allocate a struct elt_loc_list with LOC and prepend it to VAL's loc\n+   list.  */\n \n-static inline struct elt_loc_list *\n-new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n+static inline void\n+new_elt_loc_list (cselib_val *val, rtx loc)\n {\n-  struct elt_loc_list *el;\n-  el = (struct elt_loc_list *) pool_alloc (elt_loc_list_pool);\n-  el->next = next;\n-  el->loc = loc;\n-  el->setting_insn = cselib_current_insn;\n-  gcc_assert (!next || !next->setting_insn\n-\t      || !DEBUG_INSN_P (next->setting_insn));\n+  struct elt_loc_list *el, *next = val->locs;\n+\n+  gcc_checking_assert (!next || !next->setting_insn\n+\t\t       || !DEBUG_INSN_P (next->setting_insn)\n+\t\t       || cselib_current_insn == next->setting_insn);\n \n   /* If we're creating the first loc in a debug insn context, we've\n      just created a debug value.  Count it.  */\n   if (!next && cselib_current_insn && DEBUG_INSN_P (cselib_current_insn))\n     n_debug_values++;\n \n-  return el;\n+  val = canonical_cselib_val (val);\n+  next = val->locs;\n+\n+  if (GET_CODE (loc) == VALUE)\n+    {\n+      loc = canonical_cselib_val (CSELIB_VAL_PTR (loc))->val_rtx;\n+\n+      gcc_checking_assert (PRESERVED_VALUE_P (loc)\n+\t\t\t   == PRESERVED_VALUE_P (val->val_rtx));\n+\n+      if (val->val_rtx == loc)\n+\treturn;\n+      else if (val->uid > CSELIB_VAL_PTR (loc)->uid)\n+\t{\n+\t  /* Reverse the insertion.  */\n+\t  new_elt_loc_list (CSELIB_VAL_PTR (loc), val->val_rtx);\n+\t  return;\n+\t}\n+\n+      gcc_checking_assert (val->uid < CSELIB_VAL_PTR (loc)->uid);\n+\n+      if (CSELIB_VAL_PTR (loc)->locs)\n+\t{\n+\t  /* Bring all locs from LOC to VAL.  */\n+\t  for (el = CSELIB_VAL_PTR (loc)->locs; el->next; el = el->next)\n+\t    {\n+\t      /* Adjust values that have LOC as canonical so that VAL\n+\t\t becomes their canonical.  */\n+\t      if (el->loc && GET_CODE (el->loc) == VALUE)\n+\t\t{\n+\t\t  gcc_checking_assert (CSELIB_VAL_PTR (el->loc)->locs->loc\n+\t\t\t\t       == loc);\n+\t\t  CSELIB_VAL_PTR (el->loc)->locs->loc = val->val_rtx;\n+\t\t}\n+\t    }\n+\t  el->next = val->locs;\n+\t  next = val->locs = CSELIB_VAL_PTR (loc)->locs;\n+\t}\n+\n+      /* Chain LOC back to VAL.  */\n+      el = (struct elt_loc_list *) pool_alloc (elt_loc_list_pool);\n+      el->loc = val->val_rtx;\n+      el->setting_insn = cselib_current_insn;\n+      el->next = NULL;\n+      CSELIB_VAL_PTR (loc)->locs = el;\n+    }\n+\n+  el = (struct elt_loc_list *) pool_alloc (elt_loc_list_pool);\n+  el->loc = loc;\n+  el->setting_insn = cselib_current_insn;\n+  el->next = next;\n+  val->locs = el;\n }\n \n /* Promote loc L to a nondebug cselib_current_insn if L is marked as\n@@ -320,6 +369,7 @@ static int\n preserve_only_constants (void **x, void *info ATTRIBUTE_UNUSED)\n {\n   cselib_val *v = (cselib_val *)*x;\n+  struct elt_loc_list *l;\n \n   if (v->locs != NULL\n       && v->locs->next == NULL)\n@@ -328,6 +378,14 @@ preserve_only_constants (void **x, void *info ATTRIBUTE_UNUSED)\n \t  && (GET_CODE (v->locs->loc) != CONST\n \t      || !references_value_p (v->locs->loc, 0)))\n \treturn 1;\n+      /* Although a debug expr may be bound to different expressions,\n+\t we can preserve it as if it was constant, to get unification\n+\t and proper merging within var-tracking.  */\n+      if (GET_CODE (v->locs->loc) == DEBUG_EXPR\n+\t  || GET_CODE (v->locs->loc) == DEBUG_IMPLICIT_PTR\n+\t  || GET_CODE (v->locs->loc) == ENTRY_VALUE\n+\t  || GET_CODE (v->locs->loc) == DEBUG_PARAMETER_REF)\n+\treturn 1;\n       if (cfa_base_preserved_val)\n \t{\n \t  if (v == cfa_base_preserved_val)\n@@ -338,14 +396,11 @@ preserve_only_constants (void **x, void *info ATTRIBUTE_UNUSED)\n \t    return 1;\n \t}\n     }\n-  /* Keep around VALUEs that forward function invariant ENTRY_VALUEs\n-     to corresponding parameter VALUEs.  */\n-  if (v->locs != NULL\n-      && v->locs->next != NULL\n-      && v->locs->next->next == NULL\n-      && GET_CODE (v->locs->next->loc) == ENTRY_VALUE\n-      && GET_CODE (v->locs->loc) == VALUE)\n-    return 1;\n+\n+  /* Keep VALUE equivalences around.  */\n+  for (l = v->locs; l; l = l->next)\n+    if (GET_CODE (l->loc) == VALUE)\n+      return 1;\n \n   htab_clear_slot (cselib_hash_table, x);\n   return 1;\n@@ -490,7 +545,8 @@ references_value_p (const_rtx x, int only_useless)\n   int i, j;\n \n   if (GET_CODE (x) == VALUE\n-      && (! only_useless || CSELIB_VAL_PTR (x)->locs == 0))\n+      && (! only_useless ||\n+\t  (CSELIB_VAL_PTR (x)->locs == 0 && !PRESERVED_VALUE_P (x))))\n     return 1;\n \n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -744,38 +800,39 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, enum machine_mode memmode)\n   if (x == y)\n     return 1;\n \n-  if (GET_CODE (x) == VALUE && GET_CODE (y) == VALUE)\n-    return CSELIB_VAL_PTR (x) == CSELIB_VAL_PTR (y);\n-\n   if (GET_CODE (x) == VALUE)\n     {\n-      cselib_val *e = CSELIB_VAL_PTR (x);\n+      cselib_val *e = canonical_cselib_val (CSELIB_VAL_PTR (x));\n       struct elt_loc_list *l;\n \n+      if (GET_CODE (y) == VALUE)\n+\treturn e == canonical_cselib_val (CSELIB_VAL_PTR (y));\n+\n       for (l = e->locs; l; l = l->next)\n \t{\n \t  rtx t = l->loc;\n \n-\t  /* Avoid infinite recursion.  */\n-\t  if (REG_P (t) || MEM_P (t))\n+\t  /* Avoid infinite recursion.  We know we have the canonical\n+\t     value, so we can just skip any values in the equivalence\n+\t     list.  */\n+\t  if (REG_P (t) || MEM_P (t) || GET_CODE (t) == VALUE)\n \t    continue;\n \t  else if (rtx_equal_for_cselib_1 (t, y, memmode))\n \t    return 1;\n \t}\n \n       return 0;\n     }\n-\n-  if (GET_CODE (y) == VALUE)\n+  else if (GET_CODE (y) == VALUE)\n     {\n-      cselib_val *e = CSELIB_VAL_PTR (y);\n+      cselib_val *e = canonical_cselib_val (CSELIB_VAL_PTR (y));\n       struct elt_loc_list *l;\n \n       for (l = e->locs; l; l = l->next)\n \t{\n \t  rtx t = l->loc;\n \n-\t  if (REG_P (t) || MEM_P (t))\n+\t  if (REG_P (t) || MEM_P (t) || GET_CODE (t) == VALUE)\n \t    continue;\n \t  else if (rtx_equal_for_cselib_1 (x, t, memmode))\n \t    return 1;\n@@ -1217,9 +1274,8 @@ add_mem_for_addr (cselib_val *addr_elt, cselib_val *mem_elt, rtx x)\n       }\n \n   addr_elt->addr_list = new_elt_list (addr_elt->addr_list, mem_elt);\n-  mem_elt->locs\n-    = new_elt_loc_list (mem_elt->locs,\n-\t\t\treplace_equiv_address_nv (x, addr_elt->val_rtx));\n+  new_elt_loc_list (mem_elt,\n+\t\t    replace_equiv_address_nv (x, addr_elt->val_rtx));\n   if (mem_elt->next_containing_mem == NULL)\n     {\n       mem_elt->next_containing_mem = first_containing_mem;\n@@ -1858,7 +1914,7 @@ cselib_lookup_1 (rtx x, enum machine_mode mode,\n \t}\n \n       e = new_cselib_val (next_uid, GET_MODE (x), x);\n-      e->locs = new_elt_loc_list (e->locs, x);\n+      new_elt_loc_list (e, x);\n       if (REG_VALUES (i) == 0)\n \t{\n \t  /* Maintain the invariant that the first entry of\n@@ -1901,7 +1957,7 @@ cselib_lookup_1 (rtx x, enum machine_mode mode,\n \t      rtx sub = lowpart_subreg (mode, lwider->elt->val_rtx,\n \t\t\t\t\tGET_MODE (lwider->elt->val_rtx));\n \t      if (sub)\n-\t\te->locs->next = new_elt_loc_list (e->locs->next, sub);\n+\t\tnew_elt_loc_list (e, sub);\n \t    }\n \t}\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n@@ -1933,8 +1989,7 @@ cselib_lookup_1 (rtx x, enum machine_mode mode,\n      the hash table is inconsistent until we do so, and\n      cselib_subst_to_values will need to do lookups.  */\n   *slot = (void *) e;\n-  e->locs = new_elt_loc_list (e->locs,\n-\t\t\t      cselib_subst_to_values (x, memmode));\n+  new_elt_loc_list (e, cselib_subst_to_values (x, memmode));\n   return e;\n }\n \n@@ -2059,6 +2114,8 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t  else\n \t    unchain_one_elt_list (l);\n \n+\t  v = canonical_cselib_val (v);\n+\n \t  had_locs = v->locs != NULL;\n \t  setting_insn = v->locs ? v->locs->setting_insn : NULL;\n \n@@ -2245,7 +2302,7 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n \n       if (src_elt->locs == 0 && !PRESERVED_VALUE_P (src_elt->val_rtx))\n \tn_useless_values--;\n-      src_elt->locs = new_elt_loc_list (src_elt->locs, dest);\n+      new_elt_loc_list (src_elt, dest);\n     }\n   else if (MEM_P (dest) && dest_addr_elt != 0\n \t   && cselib_record_memory)\n@@ -2256,6 +2313,33 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n     }\n }\n \n+/* Make ELT and X's VALUE equivalent to each other at INSN.  */\n+\n+void\n+cselib_add_permanent_equiv (cselib_val *elt, rtx x, rtx insn)\n+{\n+  cselib_val *nelt;\n+  rtx save_cselib_current_insn = cselib_current_insn;\n+\n+  gcc_checking_assert (elt);\n+  gcc_checking_assert (PRESERVED_VALUE_P (elt->val_rtx));\n+  gcc_checking_assert (!side_effects_p (x));\n+\n+  cselib_current_insn = insn;\n+\n+  nelt = cselib_lookup (x, GET_MODE (elt->val_rtx), 1, VOIDmode);\n+\n+  if (nelt != elt)\n+    {\n+      if (!PRESERVED_VALUE_P (nelt->val_rtx))\n+\tcselib_preserve_value (nelt);\n+\n+      new_elt_loc_list (nelt, elt->val_rtx);\n+    }\n+\n+  cselib_current_insn = save_cselib_current_insn;\n+}\n+\n /* There is no good way to determine how many elements there can be\n    in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n #define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)"}, {"sha": "6a9d79537bce963e105e5c1b1c8afe3445d8db22", "filename": "gcc/cselib.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "patch": "@@ -96,5 +96,24 @@ extern void cselib_preserve_value (cselib_val *);\n extern bool cselib_preserved_value_p (cselib_val *);\n extern void cselib_preserve_only_values (void);\n extern void cselib_preserve_cfa_base_value (cselib_val *, unsigned int);\n+extern void cselib_add_permanent_equiv (cselib_val *, rtx, rtx);\n \n extern void dump_cselib_table (FILE *);\n+\n+/* Return the canonical value for VAL, following the equivalence chain\n+   towards the earliest (== lowest uid) equivalent value.  */\n+\n+static inline cselib_val *\n+canonical_cselib_val (cselib_val *val)\n+{\n+  cselib_val *canon;\n+\n+  if (!val->locs || val->locs->next\n+      || !val->locs->loc || GET_CODE (val->locs->loc) != VALUE\n+      || val->uid < CSELIB_VAL_PTR (val->locs->loc)->uid)\n+    return val;\n+\n+  canon = CSELIB_VAL_PTR (val->locs->loc);\n+  gcc_checking_assert (canonical_cselib_val (canon) == canon);\n+  return canon;\n+}"}, {"sha": "27bff38751c57f3214cc283c61f21e401ab8dae9", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 97, "deletions": 164, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2ffb4b99ccfb64adc0edc9998329ee9de32eff/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=6f2ffb4b99ccfb64adc0edc9998329ee9de32eff", "patch": "@@ -2027,6 +2027,50 @@ unsuitable_loc (rtx loc)\n     }\n }\n \n+/* Bind VAL to LOC in SET.  If MODIFIED, detach LOC from any values\n+   bound to it.  */\n+\n+static inline void\n+val_bind (dataflow_set *set, rtx val, rtx loc, bool modified)\n+{\n+  if (REG_P (loc))\n+    {\n+      if (modified)\n+\tvar_regno_delete (set, REGNO (loc));\n+      var_reg_decl_set (set, loc, VAR_INIT_STATUS_INITIALIZED,\n+\t\t\tdv_from_value (val), 0, NULL_RTX, INSERT);\n+    }\n+  else if (MEM_P (loc))\n+    {\n+      struct elt_loc_list *l = CSELIB_VAL_PTR (val)->locs;\n+\n+      if (l && GET_CODE (l->loc) == VALUE)\n+\tl = canonical_cselib_val (CSELIB_VAL_PTR (l->loc))->locs;\n+\n+      /* If this MEM is a global constant, we don't need it in the\n+\t dynamic tables.  ??? We should test this before emitting the\n+\t micro-op in the first place.  */\n+      while (l)\n+\tif (GET_CODE (l->loc) == MEM && XEXP (l->loc, 0) == XEXP (loc, 0))\n+\t  break;\n+\telse\n+\t  l = l->next;\n+\n+      if (!l)\n+\tvar_mem_decl_set (set, loc, VAR_INIT_STATUS_INITIALIZED,\n+\t\t\t  dv_from_value (val), 0, NULL_RTX, INSERT);\n+    }\n+  else\n+    {\n+      /* Other kinds of equivalences are necessarily static, at least\n+\t so long as we do not perform substitutions while merging\n+\t expressions.  */\n+      gcc_unreachable ();\n+      set_variable_part (set, loc, dv_from_value (val), 0,\n+\t\t\t VAR_INIT_STATUS_INITIALIZED, NULL_RTX, INSERT);\n+    }\n+}\n+\n /* Bind a value to a location it was just stored in.  If MODIFIED\n    holds, assume the location was modified, detaching it from any\n    values bound to it.  */\n@@ -2058,21 +2102,7 @@ val_store (dataflow_set *set, rtx val, rtx loc, rtx insn, bool modified)\n \n   gcc_checking_assert (!unsuitable_loc (loc));\n \n-  if (REG_P (loc))\n-    {\n-      if (modified)\n-\tvar_regno_delete (set, REGNO (loc));\n-      var_reg_decl_set (set, loc, VAR_INIT_STATUS_INITIALIZED,\n-\t\t\tdv_from_value (val), 0, NULL_RTX, INSERT);\n-    }\n-  else if (MEM_P (loc))\n-    var_mem_decl_set (set, loc, VAR_INIT_STATUS_INITIALIZED,\n-\t\t      dv_from_value (val), 0, NULL_RTX, INSERT);\n-  else\n-    /* ??? Ideally we wouldn't get these, and use them from the static\n-       cselib loc list.  */\n-    set_variable_part (set, loc, dv_from_value (val), 0,\n-\t\t       VAR_INIT_STATUS_INITIALIZED, NULL_RTX, INSERT);\n+  val_bind (set, val, loc, modified);\n }\n \n /* Reset this node, detaching all its equivalences.  Return the slot\n@@ -2187,20 +2217,13 @@ val_resolve (dataflow_set *set, rtx val, rtx loc, rtx insn)\n \n       /* If we didn't find any equivalence, we need to remember that\n \t this value is held in the named register.  */\n-      if (!found)\n-\tvar_reg_decl_set (set, loc, VAR_INIT_STATUS_INITIALIZED,\n-\t\t\t  dv_from_value (val), 0, NULL_RTX, INSERT);\n+      if (found)\n+\treturn;\n     }\n-  else if (MEM_P (loc))\n-    /* ??? Merge equivalent MEMs.  */\n-    var_mem_decl_set (set, loc, VAR_INIT_STATUS_INITIALIZED,\n-\t\t      dv_from_value (val), 0, NULL_RTX, INSERT);\n-  else\n-    /* ??? Ideally we wouldn't get these, and use them from the static\n-       cselib loc list.  */\n-    /* ??? Merge equivalent expressions.  */\n-    set_variable_part (set, loc, dv_from_value (val), 0,\n-\t\t       VAR_INIT_STATUS_INITIALIZED, NULL_RTX, INSERT);\n+  /* ??? Attempt to find and merge equivalent MEMs or other\n+     expressions too.  */\n+\n+  val_bind (set, val, loc, false);\n }\n \n /* Initialize dataflow set SET to be empty.\n@@ -5046,10 +5069,6 @@ log_op_type (rtx x, basic_block bb, rtx insn,\n    MO_CLOBBER as well.  */\n #define VAL_EXPR_IS_CLOBBERED(x) \\\n   (RTL_FLAG_CHECK1 (\"VAL_EXPR_IS_CLOBBERED\", (x), CONCAT)->unchanging)\n-/* Whether the location is a CONCAT of the MO_VAL_SET expression and\n-   a reverse operation that should be handled afterwards.  */\n-#define VAL_EXPR_HAS_REVERSE(x) \\\n-  (RTL_FLAG_CHECK1 (\"VAL_EXPR_HAS_REVERSE\", (x), CONCAT)->return_val)\n \n /* All preserved VALUEs.  */\n static VEC (rtx, heap) *preserved_values;\n@@ -5129,28 +5148,7 @@ add_uses (rtx *ploc, void *data)\n \t\t\t\t GET_MODE (mloc));\n \n \t      if (val && !cselib_preserved_value_p (val))\n-\t\t{\n-\t\t  micro_operation moa;\n-\t\t  preserve_value (val);\n-\n-\t\t  if (GET_CODE (XEXP (mloc, 0)) != ENTRY_VALUE\n-\t\t      && (GET_CODE (XEXP (mloc, 0)) != PLUS\n-\t\t\t  || XEXP (XEXP (mloc, 0), 0) != cfa_base_rtx\n-\t\t\t  || !CONST_INT_P (XEXP (XEXP (mloc, 0), 1))))\n-\t\t    {\n-\t\t      mloc = cselib_subst_to_values (XEXP (mloc, 0),\n-\t\t\t\t\t\t     GET_MODE (mloc));\n-\t\t      moa.type = MO_VAL_USE;\n-\t\t      moa.insn = cui->insn;\n-\t\t      moa.u.loc = gen_rtx_CONCAT (address_mode,\n-\t\t\t\t\t\t  val->val_rtx, mloc);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tlog_op_type (moa.u.loc, cui->bb, cui->insn,\n-\t\t\t\t     moa.type, dump_file);\n-\t\t      VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n-\t\t\t\t     &moa);\n-\t\t    }\n-\t\t}\n+\t\tpreserve_value (val);\n \t    }\n \n \t  if (CONSTANT_P (vloc)\n@@ -5162,7 +5160,11 @@ add_uses (rtx *ploc, void *data)\n \t    {\n \t      enum machine_mode mode2;\n \t      enum micro_operation_type type2;\n-\t      rtx nloc = replace_expr_with_values (vloc);\n+\t      rtx nloc = NULL;\n+\t      bool resolvable = REG_P (vloc) || MEM_P (vloc);\n+\n+\t      if (resolvable)\n+\t\tnloc = replace_expr_with_values (vloc);\n \n \t      if (nloc)\n \t\t{\n@@ -5180,7 +5182,7 @@ add_uses (rtx *ploc, void *data)\n \t      if (type2 == MO_CLOBBER\n \t\t  && !cselib_preserved_value_p (val))\n \t\t{\n-\t\t  VAL_NEEDS_RESOLUTION (oloc) = 1;\n+\t\t  VAL_NEEDS_RESOLUTION (oloc) = resolvable;\n \t\t  preserve_value (val);\n \t\t}\n \t    }\n@@ -5212,28 +5214,7 @@ add_uses (rtx *ploc, void *data)\n \t\t\t\t GET_MODE (mloc));\n \n \t      if (val && !cselib_preserved_value_p (val))\n-\t\t{\n-\t\t  micro_operation moa;\n-\t\t  preserve_value (val);\n-\n-\t\t  if (GET_CODE (XEXP (mloc, 0)) != ENTRY_VALUE\n-\t\t      && (GET_CODE (XEXP (mloc, 0)) != PLUS\n-\t\t\t  || XEXP (XEXP (mloc, 0), 0) != cfa_base_rtx\n-\t\t\t  || !CONST_INT_P (XEXP (XEXP (mloc, 0), 1))))\n-\t\t    {\n-\t\t      mloc = cselib_subst_to_values (XEXP (mloc, 0),\n-\t\t\t\t\t\t     GET_MODE (mloc));\n-\t\t      moa.type = MO_VAL_USE;\n-\t\t      moa.insn = cui->insn;\n-\t\t      moa.u.loc = gen_rtx_CONCAT (address_mode,\n-\t\t\t\t\t\t  val->val_rtx, mloc);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tlog_op_type (moa.u.loc, cui->bb, cui->insn,\n-\t\t\t\t     moa.type, dump_file);\n-\t\t      VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n-\t\t\t\t     &moa);\n-\t\t    }\n-\t\t}\n+\t\tpreserve_value (val);\n \t    }\n \n \t  type2 = use_type (loc, 0, &mode2);\n@@ -5256,6 +5237,7 @@ add_uses (rtx *ploc, void *data)\n \n \t  */\n \n+\t  gcc_checking_assert (REG_P (loc) || MEM_P (loc));\n \t  nloc = replace_expr_with_values (loc);\n \t  if (!nloc)\n \t    nloc = oloc;\n@@ -5307,22 +5289,22 @@ add_uses_1 (rtx *x, void *cui)\n    representable anyway.  */\n #define EXPR_USE_DEPTH (PARAM_VALUE (PARAM_MAX_VARTRACK_EXPR_DEPTH))\n \n-/* Attempt to reverse the EXPR operation in the debug info.  Say for\n-   reg1 = reg2 + 6 even when reg2 is no longer live we\n-   can express its value as VAL - 6.  */\n+/* Attempt to reverse the EXPR operation in the debug info and record\n+   it in the cselib table.  Say for reg1 = reg2 + 6 even when reg2 is\n+   no longer live we can express its value as VAL - 6.  */\n \n-static rtx\n-reverse_op (rtx val, const_rtx expr)\n+static void\n+reverse_op (rtx val, const_rtx expr, rtx insn)\n {\n   rtx src, arg, ret;\n   cselib_val *v;\n   enum rtx_code code;\n \n   if (GET_CODE (expr) != SET)\n-    return NULL_RTX;\n+    return;\n \n   if (!REG_P (SET_DEST (expr)) || GET_MODE (val) != GET_MODE (SET_DEST (expr)))\n-    return NULL_RTX;\n+    return;\n \n   src = SET_SRC (expr);\n   switch (GET_CODE (src))\n@@ -5333,30 +5315,30 @@ reverse_op (rtx val, const_rtx expr)\n     case NOT:\n     case NEG:\n       if (!REG_P (XEXP (src, 0)))\n-\treturn NULL_RTX;\n+\treturn;\n       break;\n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n       if (!REG_P (XEXP (src, 0)) && !MEM_P (XEXP (src, 0)))\n-\treturn NULL_RTX;\n+\treturn;\n       break;\n     default:\n-      return NULL_RTX;\n+      return;\n     }\n \n   if (!SCALAR_INT_MODE_P (GET_MODE (src)) || XEXP (src, 0) == cfa_base_rtx)\n-    return NULL_RTX;\n+    return;\n \n   v = cselib_lookup (XEXP (src, 0), GET_MODE (XEXP (src, 0)), 0, VOIDmode);\n   if (!v || !cselib_preserved_value_p (v))\n-    return NULL_RTX;\n+    return;\n \n   switch (GET_CODE (src))\n     {\n     case NOT:\n     case NEG:\n       if (GET_MODE (v->val_rtx) != GET_MODE (val))\n-\treturn NULL_RTX;\n+\treturn;\n       ret = gen_rtx_fmt_e (GET_CODE (src), GET_MODE (val), val);\n       break;\n     case SIGN_EXTEND:\n@@ -5374,15 +5356,15 @@ reverse_op (rtx val, const_rtx expr)\n       goto binary;\n     binary:\n       if (GET_MODE (v->val_rtx) != GET_MODE (val))\n-\treturn NULL_RTX;\n+\treturn;\n       arg = XEXP (src, 1);\n       if (!CONST_INT_P (arg) && GET_CODE (arg) != SYMBOL_REF)\n \t{\n \t  arg = cselib_expand_value_rtx (arg, scratch_regs, 5);\n \t  if (arg == NULL_RTX)\n-\t    return NULL_RTX;\n+\t    return;\n \t  if (!CONST_INT_P (arg) && GET_CODE (arg) != SYMBOL_REF)\n-\t    return NULL_RTX;\n+\t    return;\n \t}\n       ret = simplify_gen_binary (code, GET_MODE (val), val, arg);\n       if (ret == val)\n@@ -5395,7 +5377,7 @@ reverse_op (rtx val, const_rtx expr)\n       gcc_unreachable ();\n     }\n \n-  return gen_rtx_CONCAT (GET_MODE (v->val_rtx), v->val_rtx, ret);\n+  cselib_add_permanent_equiv (v, ret, insn);\n }\n \n /* Add stores (register and memory references) LOC which will be tracked\n@@ -5414,7 +5396,6 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n   bool track_p = false;\n   cselib_val *v;\n   bool resolve, preserve;\n-  rtx reverse;\n \n   if (type == MO_CLOBBER)\n     return;\n@@ -5479,26 +5460,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t\t\t\t\t   GET_MODE (mloc));\n \n \t  if (val && !cselib_preserved_value_p (val))\n-\t    {\n-\t      preserve_value (val);\n-\n-\t      if (GET_CODE (XEXP (mloc, 0)) != ENTRY_VALUE\n-\t\t  && (GET_CODE (XEXP (mloc, 0)) != PLUS\n-\t\t      || XEXP (XEXP (mloc, 0), 0) != cfa_base_rtx\n-\t\t      || !CONST_INT_P (XEXP (XEXP (mloc, 0), 1))))\n-\t\t{\n-\t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0),\n-\t\t\t\t\t\t GET_MODE (mloc));\n-\t\t  mo.type = MO_VAL_USE;\n-\t\t  mo.insn = cui->insn;\n-\t\t  mo.u.loc = gen_rtx_CONCAT (address_mode,\n-\t\t\t\t\t     val->val_rtx, mloc);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    log_op_type (mo.u.loc, cui->bb, cui->insn,\n-\t\t\t\t mo.type, dump_file);\n-\t\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n-\t\t}\n-\t    }\n+\t    preserve_value (val);\n \t}\n \n       if (GET_CODE (expr) == CLOBBER || !track_p)\n@@ -5578,7 +5540,10 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n     }\n   else if (resolve && GET_CODE (mo.u.loc) == SET)\n     {\n-      nloc = replace_expr_with_values (SET_SRC (expr));\n+      if (REG_P (SET_SRC (expr)) || MEM_P (SET_SRC (expr)))\n+\tnloc = replace_expr_with_values (SET_SRC (expr));\n+      else\n+\tnloc = NULL_RTX;\n \n       /* Avoid the mode mismatch between oexpr and expr.  */\n       if (!nloc && mode != mode2)\n@@ -5587,7 +5552,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t  gcc_assert (oloc == SET_DEST (expr));\n \t}\n \n-      if (nloc)\n+      if (nloc && nloc != SET_SRC (mo.u.loc))\n \toloc = gen_rtx_SET (GET_MODE (mo.u.loc), oloc, nloc);\n       else\n \t{\n@@ -5634,14 +5599,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n   */\n \n   if (GET_CODE (PATTERN (cui->insn)) != COND_EXEC)\n-    {\n-      reverse = reverse_op (v->val_rtx, expr);\n-      if (reverse)\n-\t{\n-\t  loc = gen_rtx_CONCAT (GET_MODE (mo.u.loc), loc, reverse);\n-\t  VAL_EXPR_HAS_REVERSE (loc) = 1;\n-\t}\n-    }\n+    reverse_op (v->val_rtx, expr, cui->insn);\n \n   mo.u.loc = loc;\n \n@@ -6299,14 +6257,9 @@ compute_bb_dataflow (basic_block bb)\n \t  case MO_VAL_SET:\n \t    {\n \t      rtx loc = mo->u.loc;\n-\t      rtx val, vloc, uloc, reverse = NULL_RTX;\n+\t      rtx val, vloc, uloc;\n \n \t      vloc = loc;\n-\t      if (VAL_EXPR_HAS_REVERSE (loc))\n-\t\t{\n-\t\t  reverse = XEXP (loc, 1);\n-\t\t  vloc = XEXP (loc, 0);\n-\t\t}\n \t      uloc = XEXP (vloc, 1);\n \t      val = XEXP (vloc, 0);\n \t      vloc = uloc;\n@@ -6382,10 +6335,6 @@ compute_bb_dataflow (basic_block bb)\n \t\tvar_regno_delete (out, REGNO (uloc));\n \n \t      val_store (out, val, vloc, insn, true);\n-\n-\t      if (reverse)\n-\t\tval_store (out, XEXP (reverse, 0), XEXP (reverse, 1),\n-\t\t\t   insn, false);\n \t    }\n \t    break;\n \n@@ -7698,6 +7647,7 @@ notify_dependents_of_resolved_value (variable ivar, htab_t vars)\n \t  /* We won't notify variables that are being expanded,\n \t     because their dependency list is cleared before\n \t     recursing.  */\n+\t  NO_LOC_P (value) = false;\n \t  VALUE_RECURSED_INTO (value) = false;\n \n \t  gcc_checking_assert (dv_changed_p (dv));\n@@ -7910,7 +7860,10 @@ vt_expand_loc_callback (rtx x, bitmap regs,\n   gcc_checking_assert (!VALUE_RECURSED_INTO (x) || NO_LOC_P (x));\n \n   if (NO_LOC_P (x))\n-    return NULL;\n+    {\n+      gcc_checking_assert (VALUE_RECURSED_INTO (x) || !dv_changed_p (dv));\n+      return NULL;\n+    }\n \n   var = (variable) htab_find_with_hash (elcd->vars, dv, dv_htab_hash (dv));\n \n@@ -8709,14 +8662,9 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t  case MO_VAL_SET:\n \t    {\n \t      rtx loc = mo->u.loc;\n-\t      rtx val, vloc, uloc, reverse = NULL_RTX;\n+\t      rtx val, vloc, uloc;\n \n \t      vloc = loc;\n-\t      if (VAL_EXPR_HAS_REVERSE (loc))\n-\t\t{\n-\t\t  reverse = XEXP (loc, 1);\n-\t\t  vloc = XEXP (loc, 0);\n-\t\t}\n \t      uloc = XEXP (vloc, 1);\n \t      val = XEXP (vloc, 0);\n \t      vloc = uloc;\n@@ -8787,10 +8735,6 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t      val_store (set, val, vloc, insn, true);\n \n-\t      if (reverse)\n-\t\tval_store (set, XEXP (reverse, 0), XEXP (reverse, 1),\n-\t\t\t   insn, false);\n-\n \t      emit_notes_for_changes (next_insn, EMIT_NOTE_BEFORE_INSN,\n \t\t\t\t      set->vars);\n \t    }\n@@ -8957,28 +8901,17 @@ vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n   return false;\n }\n \n-/* Mark the value for the ENTRY_VALUE of RTL as equivalent to EQVAL in\n-   OUT.  */\n+/* Record the value for the ENTRY_VALUE of RTL as a global equivalence\n+   of VAL.  */\n \n static void\n-create_entry_value (dataflow_set *out, rtx eqval, rtx rtl)\n+record_entry_value (cselib_val *val, rtx rtl)\n {\n   rtx ev = gen_rtx_ENTRY_VALUE (GET_MODE (rtl));\n-  cselib_val *val;\n \n   ENTRY_VALUE_EXP (ev) = rtl;\n \n-  val = cselib_lookup_from_insn (ev, GET_MODE (ev), true,\n-\t\t\t\t VOIDmode, get_insns ());\n-\n-  if (val->val_rtx != eqval)\n-    {\n-      preserve_value (val);\n-      set_variable_part (out, val->val_rtx, dv_from_value (eqval), 0,\n-\t\t\t VAR_INIT_STATUS_INITIALIZED, NULL_RTX, INSERT);\n-      set_variable_part (out, eqval, dv_from_value (val->val_rtx), 0,\n-\t\t\t VAR_INIT_STATUS_INITIALIZED, NULL_RTX, INSERT);\n-    }\n+  cselib_add_permanent_equiv (val, ev, get_insns ());\n }\n \n /* Insert function parameter PARM in IN and OUT sets of ENTRY_BLOCK.  */\n@@ -9137,7 +9070,7 @@ vt_add_function_parameter (tree parm)\n \t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n       if (dv_is_value_p (dv))\n \t{\n-\t  create_entry_value (out, dv_as_value (dv), incoming);\n+\t  record_entry_value (CSELIB_VAL_PTR (dv_as_value (dv)), incoming);\n \t  if (TREE_CODE (TREE_TYPE (parm)) == REFERENCE_TYPE\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (parm))))\n \t    {\n@@ -9150,9 +9083,9 @@ vt_add_function_parameter (tree parm)\n \t      if (val)\n \t\t{\n \t\t  preserve_value (val);\n+\t\t  record_entry_value (val, mem);\n \t\t  set_variable_part (out, mem, dv_from_value (val->val_rtx), 0,\n \t\t\t\t     VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n-\t\t  create_entry_value (out, val->val_rtx, mem);\n \t\t}\n \t    }\n \t}"}]}