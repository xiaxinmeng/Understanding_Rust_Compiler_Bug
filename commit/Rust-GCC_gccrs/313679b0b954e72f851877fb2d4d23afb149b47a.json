{"sha": "313679b0b954e72f851877fb2d4d23afb149b47a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEzNjc5YjBiOTU0ZTcyZjg1MTg3N2ZiMmQ0ZDIzYWZiMTQ5YjQ3YQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-06-09T22:58:29Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-06-09T22:58:29Z"}, "message": "Move SSA_NAME annotations into tree_ssa_name.\n\n\t* tree-dfa.c (create_ssa_name_ann): Remove.\n\t* tree-flow-inline.h (ssa_name_ann, get_ssa_name_ann): Remove.\n\t* tree-flow.h (enum tree_ann_type): Remove SSA_NAME_ANN.\n\t(struct ssa_name_ann_d): Remove.\n\t(union tree_ann_d): Update.\n\t(ssa_name_ann_t): Remove.\n\t* tree-ssa-alias.c: (get_ptr_info): New local function.\n\tReplace references to ssa_name_ann_t with struct ptr_info_def.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree.h (SSA_NAME_PTR_INFO): Define.\n\t(struct ptr_info_def): Declare.\n\t(struct tree_ssa_name): Add field 'ptr_info'.\n\nFrom-SVN: r82864", "tree": {"sha": "52208f13553d9abd4e95b2d4e1d9fbb2d75f2bc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52208f13553d9abd4e95b2d4e1d9fbb2d75f2bc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/313679b0b954e72f851877fb2d4d23afb149b47a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313679b0b954e72f851877fb2d4d23afb149b47a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/313679b0b954e72f851877fb2d4d23afb149b47a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313679b0b954e72f851877fb2d4d23afb149b47a/comments", "author": null, "committer": null, "parents": [{"sha": "8041d6ab144891243a56c55dd1702a32aeb3f484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8041d6ab144891243a56c55dd1702a32aeb3f484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8041d6ab144891243a56c55dd1702a32aeb3f484"}], "stats": {"total": 302, "additions": 153, "deletions": 149}, "files": [{"sha": "637a9bfa24fa51baa605ff45d1db58fcf9606a42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=313679b0b954e72f851877fb2d4d23afb149b47a", "patch": "@@ -1,3 +1,20 @@\n+2004-06-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMove SSA_NAME annotations into tree_ssa_name.\n+\n+\t* tree-dfa.c (create_ssa_name_ann): Remove.\n+\t* tree-flow-inline.h (ssa_name_ann, get_ssa_name_ann): Remove.\n+\t* tree-flow.h (enum tree_ann_type): Remove SSA_NAME_ANN.\n+\t(struct ssa_name_ann_d): Remove.\n+\t(union tree_ann_d): Update.\n+\t(ssa_name_ann_t): Remove.\n+\t* tree-ssa-alias.c: (get_ptr_info): New local function.\n+\tReplace references to ssa_name_ann_t with struct ptr_info_def.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree.h (SSA_NAME_PTR_INFO): Define.\n+\t(struct ptr_info_def): Declare.\n+\t(struct tree_ssa_name): Add field 'ptr_info'.\n+\n 2004-06-09  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* config/i386/winnt.c (i386_pe_output_labelref): Correct"}, {"sha": "00d008fbaaf9023f33c560b8e8f4d79a36a5f635", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=313679b0b954e72f851877fb2d4d23afb149b47a", "patch": "@@ -462,30 +462,6 @@ create_stmt_ann (tree t)\n }\n \n \n-/* Create a new annotation for an SSA name T.  */\n-\n-ssa_name_ann_t\n-create_ssa_name_ann (tree t)\n-{\n-  ssa_name_ann_t ann;\n-\n-#if defined ENABLE_CHECKING\n-  if (t == NULL_TREE\n-      || (t->common.ann\n-\t  && t->common.ann->common.type != SSA_NAME_ANN))\n-    abort ();\n-#endif\n-\n-  ann = ggc_alloc (sizeof (*ann));\n-  memset ((void *) ann, 0, sizeof (*ann));\n-\n-  ann->common.type = SSA_NAME_ANN;\n-  t->common.ann = (tree_ann) ann;\n-\n-  return ann;\n-}\n-\n-\n /* Build a temporary.  Make sure and register it to be renamed.  */\n \n tree"}, {"sha": "5ef287abff48efc3e33085e114da9ded0bc5ca42", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=313679b0b954e72f851877fb2d4d23afb149b47a", "patch": "@@ -64,27 +64,6 @@ get_stmt_ann (tree stmt)\n   return (ann) ? ann : create_stmt_ann (stmt);\n }\n \n-static inline ssa_name_ann_t\n-ssa_name_ann (tree t)\n-{\n-#if defined ENABLE_CHECKING\n-  if (t == NULL_TREE\n-      || TREE_CODE (t) != SSA_NAME\n-      || (t->common.ann\n-\t  && t->common.ann->common.type != SSA_NAME_ANN))\n-    abort ();\n-#endif\n-\n-  return (ssa_name_ann_t) t->common.ann;\n-}\n-\n-static inline ssa_name_ann_t\n-get_ssa_name_ann (tree var)\n-{\n-  ssa_name_ann_t ann = ssa_name_ann (var);\n-  return (ann) ? ann : create_ssa_name_ann (var);\n-}\n-\n \n static inline enum tree_ann_type\n ann_type (tree_ann ann)"}, {"sha": "41701e333f994b02a6cf072e432356994542498b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=313679b0b954e72f851877fb2d4d23afb149b47a", "patch": "@@ -40,7 +40,7 @@ typedef struct basic_block_def *basic_block;\n /*---------------------------------------------------------------------------\n \t\t   Tree annotations stored in tree_common.ann\n ---------------------------------------------------------------------------*/\n-enum tree_ann_type { TREE_ANN_COMMON, VAR_ANN, STMT_ANN, SSA_NAME_ANN };\n+enum tree_ann_type { TREE_ANN_COMMON, VAR_ANN, STMT_ANN };\n \n struct tree_ann_common_d GTY(())\n {\n@@ -255,50 +255,21 @@ struct stmt_ann_d GTY(())\n };\n \n \n-struct ssa_name_ann_d GTY(())\n-{\n-  struct tree_ann_common_d common;\n-\n-  /* Nonzero if points-to analysis couldn't determine where this pointer\n-     is pointing to.  */\n-  unsigned int pt_anything : 1;\n-\n-  /* Nonzero if this pointer is the result of a call to malloc.  */\n-  unsigned int pt_malloc : 1;\n-\n-  /* Nonzero if the value of this pointer escapes the current function.  */\n-  unsigned int value_escapes_p : 1;\n-\n-  /* Set of variables that this pointer may point to.  */\n-  bitmap pt_vars;\n-\n-  /* If this pointer has been dereferenced, and points-to information is\n-     more precise than type-based aliasing, indirect references to this\n-     pointer will be represented by this memory tag, instead of the type\n-     tag computed by TBAA.  */\n-  tree name_mem_tag;\n-};\n-\n-\n union tree_ann_d GTY((desc (\"ann_type ((tree_ann)&%h)\")))\n {\n   struct tree_ann_common_d GTY((tag (\"TREE_ANN_COMMON\"))) common;\n   struct var_ann_d GTY((tag (\"VAR_ANN\"))) decl;\n   struct stmt_ann_d GTY((tag (\"STMT_ANN\"))) stmt;\n-  struct ssa_name_ann_d GTY((tag (\"SSA_NAME_ANN\"))) ssa_name;\n };\n \n typedef union tree_ann_d *tree_ann;\n typedef struct var_ann_d *var_ann_t;\n typedef struct stmt_ann_d *stmt_ann_t;\n-typedef struct ssa_name_ann_d *ssa_name_ann_t;\n \n static inline var_ann_t var_ann (tree);\n static inline var_ann_t get_var_ann (tree);\n static inline stmt_ann_t stmt_ann (tree);\n static inline stmt_ann_t get_stmt_ann (tree);\n-static inline ssa_name_ann_t ssa_name_ann (tree);\n-static inline ssa_name_ann_t get_ssa_name_ann (tree);\n static inline enum tree_ann_type ann_type (tree_ann);\n static inline basic_block bb_for_stmt (tree);\n extern void set_bb_for_stmt (tree, basic_block);\n@@ -487,7 +458,6 @@ extern void dump_generic_bb (FILE *, basic_block, int, int);\n /* In tree-dfa.c  */\n extern var_ann_t create_var_ann (tree);\n extern stmt_ann_t create_stmt_ann (tree);\n-extern ssa_name_ann_t create_ssa_name_ann (tree);\n extern tree create_phi_node (tree, basic_block);\n extern void add_phi_arg (tree *, tree, edge);\n extern void remove_phi_arg (tree, basic_block);"}, {"sha": "1fa94c3771ca9511e81ff42415599d34833407b4", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 95, "deletions": 67, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=313679b0b954e72f851877fb2d4d23afb149b47a", "patch": "@@ -155,6 +155,7 @@ static void collect_points_to_info_for (struct alias_info *, tree);\n static bool ptr_is_dereferenced_by (tree, tree, bool *);\n static void maybe_create_global_var (struct alias_info *ai);\n static void group_aliases (struct alias_info *);\n+static struct ptr_info_def *get_ptr_info (tree t);\n \n /* Global declarations.  */\n \n@@ -427,7 +428,7 @@ collect_points_to_info_for (struct alias_info *ai, tree ptr)\n \n   if (!bitmap_bit_p (ai->ssa_names_visited, SSA_NAME_VERSION (ptr)))\n     {\n-      ssa_name_ann_t ann;\n+      struct ptr_info_def *pi;\n \n       bitmap_set_bit (ai->ssa_names_visited, SSA_NAME_VERSION (ptr));\n       walk_use_def_chains (ptr, collect_points_to_info_r, ai);\n@@ -436,11 +437,11 @@ collect_points_to_info_for (struct alias_info *ai, tree ptr)\n \n       /* If we could not determine where PTR was pointing to, clear all the\n \t other points-to information.  */\n-      ann = ssa_name_ann (ptr);\n-      if (ann->pt_anything)\n+      pi = SSA_NAME_PTR_INFO (ptr);\n+      if (pi->pt_anything)\n \t{\n-\t  ann->pt_malloc = 0;\n-\t  ann->pt_vars = NULL;\n+\t  pi->pt_malloc = 0;\n+\t  pi->pt_vars = NULL;\n \t}\n     }\n }\n@@ -559,12 +560,13 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  if (stmt_escapes_p)\n \t    block_ann->has_escape_site = 1;\n \n-\t  /* Special case for silly ADDR_EXPR tricks.  If this\n-\t     statement is an assignment to a non-pointer variable and\n-\t     the RHS takes the address of a variable, assume that the\n-\t     variable on the RHS is call-clobbered.  We could add the\n-\t     LHS to the list of \"pointers\" and follow it to see if it\n-\t     really escapes, but it's not worth the pain.  */\n+\t  /* Special case for silly ADDR_EXPR tricks\n+\t     (gcc.c-torture/unsorted/pass.c).  If this statement is an\n+\t     assignment to a non-pointer variable and the RHS takes the\n+\t     address of a variable, assume that the variable on the RHS is\n+\t     call-clobbered.  We could add the LHS to the list of\n+\t     \"pointers\" and follow it to see if it really escapes, but it's\n+\t     not worth the pain.  */\n \t  if (addr_taken\n \t      && TREE_CODE (stmt) == MODIFY_EXPR\n \t      && !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 0))))\n@@ -580,7 +582,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t    {\n \t      tree op = USE_OP (uses, i);\n \t      var_ann_t v_ann = var_ann (SSA_NAME_VAR (op));\n-\t      ssa_name_ann_t ptr_ann;\n+\t      struct ptr_info_def *pi;\n \t      bool is_store;\n \n \t      /* If the operand's variable may be aliased, keep track\n@@ -598,7 +600,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \n \t      collect_points_to_info_for (ai, op);\n \n-\t      ptr_ann = ssa_name_ann (op);\n+\t      pi =  SSA_NAME_PTR_INFO (op);\n \t      if (ptr_is_dereferenced_by (op, stmt, &is_store))\n \t\t{\n \t\t  /* If we found OP to point to a set of variables or\n@@ -609,8 +611,8 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t     FIXME: Cycles in the SSA web and the lack of SSA \n \t\t     information for structures will prevent the creation\n \t\t     of name tags.  Find ways around this limitation.  */\n-\t\t  if (ptr_ann->pt_malloc || ptr_ann->pt_vars)\n-\t\t    ptr_ann->name_mem_tag = get_nmt_for (op);\n+\t\t  if (pi->pt_malloc || pi->pt_vars)\n+\t\t    pi->name_mem_tag = get_nmt_for (op);\n \n \t\t  /* Keep track of how many time we've dereferenced each\n \t\t     pointer.  Again, we don't need to grow\n@@ -632,7 +634,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t     will not escape if it is being dereferenced.  That's\n \t\t     why we only check for escape points if OP is not\n \t\t     dereferenced by STMT.  */\n-\t\t  ptr_ann->value_escapes_p = 1;\n+\t\t  pi->value_escapes_p = 1;\n \n \t\t  /* If the statement makes a function call, assume\n \t\t     that pointer OP will be dereferenced in a store\n@@ -695,23 +697,23 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n     {\n       size_t j;\n       tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n-      ssa_name_ann_t ann = ssa_name_ann (ptr);\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n       var_ann_t v_ann = var_ann (SSA_NAME_VAR (ptr));\n \n-      if (ann->value_escapes_p || ann->pt_anything)\n+      if (pi->value_escapes_p || pi->pt_anything)\n \t{\n \t  /* If PTR escapes or may point to anything, then its associated\n \t     memory tags are call-clobbered.  */\n-\t  if (ann->name_mem_tag)\n-\t    mark_call_clobbered (ann->name_mem_tag);\n+\t  if (pi->name_mem_tag)\n+\t    mark_call_clobbered (pi->name_mem_tag);\n \n \t  if (v_ann->type_mem_tag)\n \t    mark_call_clobbered (v_ann->type_mem_tag);\n \n \t  /* If PTR may point to anything, mark call-clobbered all the\n \t     addressables with the same alias set as the type pointed-to by\n \t     PTR.  */\n-\t  if (ann->pt_anything)\n+\t  if (pi->pt_anything)\n \t    {\n \t      HOST_WIDE_INT ptr_set;\n \t      ptr_set = get_alias_set (TREE_TYPE (TREE_TYPE (ptr)));\n@@ -730,23 +732,25 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n \t     name memory tag, which will have been marked call-clobbered.\n \t     This will in turn mark the pointed-to variables as\n \t     call-clobbered when we call add_may_alias below.  */\n-\t  if (ann->value_escapes_p && !ann->name_mem_tag && ann->pt_vars)\n-\t    EXECUTE_IF_SET_IN_BITMAP (ann->pt_vars, 0, j,\n+\t  if (pi->value_escapes_p\n+\t      && pi->name_mem_tag == NULL_TREE\n+\t      && pi->pt_vars)\n+\t    EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j,\n \t\tmark_call_clobbered (referenced_var (j)));\n \t}\n \n       /* Set up aliasing information for PTR's name memory tag (if it has\n \t one).  Note that only pointers that have been dereferenced will\n \t have a name memory tag.  */\n-      if (ann->name_mem_tag && ann->pt_vars)\n-\tEXECUTE_IF_SET_IN_BITMAP (ann->pt_vars, 0, j,\n-\t    add_may_alias (ann->name_mem_tag, referenced_var (j)));\n+      if (pi->name_mem_tag && pi->pt_vars)\n+\tEXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j,\n+\t    add_may_alias (pi->name_mem_tag, referenced_var (j)));\n \n       /* If the name tag is call clobbered, so is the type tag\n \t associated with the base VAR_DECL.  */\n-      if (ann->name_mem_tag\n+      if (pi->name_mem_tag\n \t  && v_ann->type_mem_tag\n-\t  && is_call_clobbered (ann->name_mem_tag))\n+\t  && is_call_clobbered (pi->name_mem_tag))\n \tmark_call_clobbered (v_ann->type_mem_tag);\n     }\n }\n@@ -1050,7 +1054,7 @@ group_aliases (struct alias_info *ai)\n     {\n       size_t j;\n       tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n-      tree name_tag = ssa_name_ann (ptr)->name_mem_tag;\n+      tree name_tag = SSA_NAME_PTR_INFO (ptr)->name_mem_tag;\n       varray_type aliases;\n       \n       if (name_tag == NULL_TREE)\n@@ -1509,31 +1513,31 @@ add_may_alias (tree var, tree alias)\n static void\n merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n {\n-  ssa_name_ann_t dest_ann, orig_ann;\n+  struct ptr_info_def *dest_pi, *orig_pi;\n \n   /* Make sure we have points-to information for ORIG.  */\n   collect_points_to_info_for (ai, orig);\n \n-  dest_ann = get_ssa_name_ann (dest);\n-  orig_ann = ssa_name_ann (orig);\n+  dest_pi = get_ptr_info (dest);\n+  orig_pi = SSA_NAME_PTR_INFO (orig);\n \n-  if (orig_ann)\n+  if (orig_pi)\n     {\n-      dest_ann->pt_anything |= orig_ann->pt_anything;\n-      dest_ann->pt_malloc |= orig_ann->pt_malloc;\n+      dest_pi->pt_anything |= orig_pi->pt_anything;\n+      dest_pi->pt_malloc |= orig_pi->pt_malloc;\n \n-      if (orig_ann->pt_vars)\n+      if (orig_pi->pt_vars)\n \t{\n-\t  if (dest_ann->pt_vars == NULL)\n+\t  if (dest_pi->pt_vars == NULL)\n \t    {\n-\t      dest_ann->pt_vars = BITMAP_GGC_ALLOC ();\n-\t      bitmap_copy (dest_ann->pt_vars, orig_ann->pt_vars);\n+\t      dest_pi->pt_vars = BITMAP_GGC_ALLOC ();\n+\t      bitmap_copy (dest_pi->pt_vars, orig_pi->pt_vars);\n \t    }\n \t  else\n-\t    bitmap_a_or_b (dest_ann->pt_vars,\n-\t\t\t   dest_ann->pt_vars,\n-\t\t\t   orig_ann->pt_vars);\n-\t}\n+\t    bitmap_a_or_b (dest_pi->pt_vars,\n+\t\t\t   dest_pi->pt_vars,\n+\t\t\t   orig_pi->pt_vars);\n+      }\n     }\n }\n \n@@ -1543,7 +1547,7 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n static void\n add_pointed_to_expr (tree ptr, tree value)\n {\n-  ssa_name_ann_t ann;\n+  struct ptr_info_def *pi;\n \n #if defined ENABLE_CHECKING\n   /* Pointer variables should have been handled by merge_pointed_to_info.  */\n@@ -1552,22 +1556,22 @@ add_pointed_to_expr (tree ptr, tree value)\n     abort ();\n #endif\n \n-  ann = get_ssa_name_ann (ptr);\n+  pi = get_ptr_info (ptr);\n \n   /* If VALUE is the result of a malloc-like call, then the area pointed to\n      PTR is guaranteed to not alias with anything else.  */\n   if (TREE_CODE (value) == CALL_EXPR\n       && (call_expr_flags (value) & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n-    ann->pt_malloc = 1;\n+    pi->pt_malloc = 1;\n   else\n-    ann->pt_anything = 1;\n+    pi->pt_anything = 1;\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \"Pointer \");\n       print_generic_expr (dump_file, ptr, dump_flags);\n       fprintf (dump_file, \" points to \");\n-      if (ann->pt_malloc)\n+      if (pi->pt_malloc)\n \tfprintf (dump_file, \"malloc space: \");\n       else\n \tfprintf (dump_file, \"an arbitrary address: \");\n@@ -1587,7 +1591,7 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n   if (TREE_CODE (value) == ADDR_EXPR)\n     {\n       tree pt_var;\n-      ssa_name_ann_t ann;\n+      struct ptr_info_def *pi;\n       size_t uid;\n \n       pt_var = TREE_OPERAND (value, 0);\n@@ -1596,11 +1600,11 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n \n       if (pt_var && SSA_VAR_P (pt_var))\n \t{\n-\t  ann = get_ssa_name_ann (ptr);\n+\t  pi = get_ptr_info (ptr);\n \t  uid = var_ann (pt_var)->uid;\n-\t  if (ann->pt_vars == NULL)\n-\t    ann->pt_vars = BITMAP_GGC_ALLOC ();\n-\t  bitmap_set_bit (ann->pt_vars, uid);\n+\t  if (pi->pt_vars == NULL)\n+\t    pi->pt_vars = BITMAP_GGC_ALLOC ();\n+\t  bitmap_set_bit (pi->pt_vars, uid);\n \t  bitmap_set_bit (ai->addresses_needed, uid);\n \t}\n       else\n@@ -1675,8 +1679,7 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n   else if (TREE_CODE (stmt) == ASM_EXPR)\n     {\n       /* Pointers defined by __asm__ statements can point anywhere.  */\n-      ssa_name_ann_t ann = get_ssa_name_ann (var);\n-      ann->pt_anything = 1;\n+      get_ptr_info (var)->pt_anything = 1;\n     }\n   else if (IS_EMPTY_STMT (stmt))\n     {\n@@ -1810,8 +1813,8 @@ create_memory_tag (tree type, bool is_type_tag)\n static tree\n get_nmt_for (tree ptr)\n {\n-  ssa_name_ann_t ptr_ann = ssa_name_ann (ptr);\n-  tree tag = ptr_ann->name_mem_tag;\n+  struct ptr_info_def *pi = get_ptr_info (ptr);\n+  tree tag = pi->name_mem_tag;\n \n   if (tag == NULL_TREE)\n     {\n@@ -1823,7 +1826,7 @@ get_nmt_for (tree ptr)\n \tmark_call_clobbered (tag);\n \n       /* Similarly, if PTR points to malloc, then TAG is a global.  */\n-      if (ptr_ann->pt_malloc)\n+      if (pi->pt_malloc)\n \tmark_call_clobbered (tag);\n     }\n \n@@ -1976,40 +1979,65 @@ debug_alias_info (void)\n }\n \n \n+/* Return the alias information associated with pointer T.  It creates a\n+   new instance if none existed.  */\n+\n+static struct ptr_info_def *\n+get_ptr_info (tree t)\n+{\n+  struct ptr_info_def *pi;\n+\n+#if defined ENABLE_CHECKING\n+  if (!POINTER_TYPE_P (TREE_TYPE (t)))\n+    abort ();\n+#endif\n+\n+  pi = SSA_NAME_PTR_INFO (t);\n+  if (pi == NULL)\n+    {\n+      pi = ggc_alloc (sizeof (*pi));\n+      memset ((void *)pi, 0, sizeof (*pi));\n+      SSA_NAME_PTR_INFO (t) = pi;\n+    }\n+\n+  return pi;\n+}\n+\n+\n /* Dump points-to information for SSA_NAME PTR into FILE.  */\n \n static void\n dump_points_to_info_for (FILE *file, tree ptr)\n {\n-  ssa_name_ann_t ann = ssa_name_ann (ptr);\n+  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n \n   fprintf (file, \"Pointer \");\n   print_generic_expr (file, ptr, dump_flags);\n \n-  if (ann == NULL)\n+  if (pi == NULL)\n     return;\n \n-  if (ann->name_mem_tag)\n+  if (pi->name_mem_tag)\n     {\n       fprintf (file, \", name memory tag: \");\n-      print_generic_expr (file, ann->name_mem_tag, dump_flags);\n+      print_generic_expr (file, pi->name_mem_tag, dump_flags);\n     }\n \n-  if (ann->value_escapes_p)\n+  if (pi->value_escapes_p)\n     fprintf (file, \", its value escapes\");\n \n-  if (ann->pt_anything)\n+  if (pi->pt_anything)\n     fprintf (file, \", points-to anything\");\n \n-  if (ann->pt_malloc)\n+  if (pi->pt_malloc)\n     fprintf (file, \", points-to malloc\");\n \n-  if (ann->pt_vars)\n+  if (pi->pt_vars)\n     {\n       unsigned ix;\n \n       fprintf (file, \", points-to vars: { \");\n-      EXECUTE_IF_SET_IN_BITMAP (ann->pt_vars, 0, ix,\n+      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix,\n \t  {\n \t    print_generic_expr (file, referenced_var (ix), dump_flags);\n \t    fprintf (file, \" \");"}, {"sha": "cc246ce45be259ae051cf4597dac4baa16ebfeec", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=313679b0b954e72f851877fb2d4d23afb149b47a", "patch": "@@ -886,16 +886,16 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \t    }\n \t  else\n \t    {\n-\t      ssa_name_ann_t ptr_ann = NULL;\n+\t      struct ptr_info_def *pi = NULL;\n \n \t      /* If we have computed aliasing already, check if PTR has\n \t\t flow-sensitive points-to information.  */\n \t      if (TREE_CODE (ptr) == SSA_NAME\n-\t\t  && (ptr_ann = ssa_name_ann (ptr)) != NULL\n-\t\t  && ptr_ann->name_mem_tag)\n+\t\t  && (pi = SSA_NAME_PTR_INFO (ptr)) != NULL\n+\t\t  && pi->name_mem_tag)\n \t\t{\n \t\t  /* PTR has its own memory tag.  Use it.  */\n-\t\t  add_stmt_operand (&ptr_ann->name_mem_tag, stmt, flags,\n+\t\t  add_stmt_operand (&pi->name_mem_tag, stmt, flags,\n \t\t                    prev_vops);\n \t\t}\n \t      else\n@@ -910,7 +910,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \t\t     aliasing again.  */\n \t\t  if (dump_file\n \t\t      && TREE_CODE (ptr) == SSA_NAME\n-\t\t      && ptr_ann == NULL)\n+\t\t      && pi == NULL)\n \t\t    {\n \t\t      fprintf (dump_file,\n \t\t\t  \"NOTE: no flow-sensitive alias info for \");"}, {"sha": "8cdcd92aeeb3b5c0d617a7ae13ebcf53017a09db", "filename": "gcc/tree.h", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313679b0b954e72f851877fb2d4d23afb149b47a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=313679b0b954e72f851877fb2d4d23afb149b47a", "patch": "@@ -1174,12 +1174,43 @@ struct tree_exp GTY(())\n #define SSA_NAME_OCCURS_IN_ABNORMAL_PHI(NODE) \\\n     SSA_NAME_CHECK (NODE)->common.asm_written_flag\n \n-/* Nonzero if this SSA_NAME expression is currently on the freelist of\n+/* Nonzero if this SSA_NAME expression is currently on the free list of\n    SSA_NAMES.  Using NOTHROW_FLAG seems reasonably safe since throwing\n    has no meaning for an SSA_NAME.  */\n #define SSA_NAME_IN_FREE_LIST(NODE) \\\n     SSA_NAME_CHECK (NODE)->common.nothrow_flag\n \n+/* Attributes for SSA_NAMEs for pointer-type variables.  */\n+#define SSA_NAME_PTR_INFO(N) \\\n+    SSA_NAME_CHECK (N)->ssa_name.ptr_info\n+\n+#ifndef GCC_BITMAP_H\n+struct bitmap_head_def;\n+#endif\n+\n+/* Aliasing information for SSA_NAMEs representing pointer variables.  */\n+struct ptr_info_def GTY(())\n+{\n+  /* Nonzero if points-to analysis couldn't determine where this pointer\n+     is pointing to.  */\n+  unsigned int pt_anything : 1;\n+\n+  /* Nonzero if this pointer is the result of a call to malloc.  */\n+  unsigned int pt_malloc : 1;\n+\n+  /* Nonzero if the value of this pointer escapes the current function.  */\n+  unsigned int value_escapes_p : 1;\n+\n+  /* Set of variables that this pointer may point to.  */\n+  struct bitmap_head_def *pt_vars;\n+\n+  /* If this pointer has been dereferenced, and points-to information is\n+     more precise than type-based aliasing, indirect references to this\n+     pointer will be represented by this memory tag, instead of the type\n+     tag computed by TBAA.  */\n+  tree name_mem_tag;\n+};\n+\n struct tree_ssa_name GTY(())\n {\n   struct tree_common common;\n@@ -1189,6 +1220,9 @@ struct tree_ssa_name GTY(())\n \n   /* SSA version number.  */\n   unsigned int version;\n+\n+  /* Pointer attributes used for alias analysis.  */\n+  struct ptr_info_def *ptr_info;\n };\n \f\n /* In a PHI_NODE node.  */"}]}