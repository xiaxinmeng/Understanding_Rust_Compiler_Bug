{"sha": "028a407463ce341487103abc877032384e6427bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4YTQwNzQ2M2NlMzQxNDg3MTAzYWJjODc3MDMyMzg0ZTY0MjdiZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-21T07:40:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-21T08:45:08Z"}, "message": "Simplify CFG copying tables\n\nThis simplifies the maps between original and new basic blocks and\nloops as used for CFG copying.  Instead of using a pointer hash\ntable to allocated mapping entries use a hash_map with int_hash,\nremoving the indirection and code duplication.  We can use -1 and\n-2 as empty/deleted values as those are not valid basic-block\nindices or loop numbers.\n\n2020-10-21  Richard Biener  <rguenther@suse.de>\n\n\t* cfg.c (htab_bb_copy_original_entry): Remove.\n\t(bb_copy_hasher): Likewise.\n\t(bb_original, bb_copy, loop_copy): Use\n\thash_map<int_hash<int, -1, -2>, int>.\n\t(original_copy_bb_pool): Remove.\n\t(initialize_original_copy_tables): Adjust.\n\t(reset_original_copy_tables): Likewise.\n\t(free_original_copy_tables): Likewise.\n\t(original_copy_tables_initialized_p): Likewise.\n\t(copy_original_table_clear): Simplify.\n\t(copy_original_table_set): Likewise.\n\t(get_bb_original): Likewise.\n\t(get_bb_copy): Likewise.\n\t(get_loop_copy): Likewise.", "tree": {"sha": "4f08d357d27880f5d5144b31fb8f15ba307cea46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f08d357d27880f5d5144b31fb8f15ba307cea46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/028a407463ce341487103abc877032384e6427bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028a407463ce341487103abc877032384e6427bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028a407463ce341487103abc877032384e6427bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028a407463ce341487103abc877032384e6427bf/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fa5dc951e9b22b61da8a4a5e0c1731d8b12a763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa5dc951e9b22b61da8a4a5e0c1731d8b12a763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fa5dc951e9b22b61da8a4a5e0c1731d8b12a763"}], "stats": {"total": 114, "additions": 23, "deletions": 91}, "files": [{"sha": "d82324faf037f86bc9448c111349d26909480297", "filename": "gcc/cfg.c", "status": "modified", "additions": 23, "deletions": 91, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028a407463ce341487103abc877032384e6427bf/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028a407463ce341487103abc877032384e6427bf/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=028a407463ce341487103abc877032384e6427bf", "patch": "@@ -959,55 +959,23 @@ scale_bbs_frequencies (basic_block *bbs, int nbbs,\n     bbs[i]->count = bbs[i]->count.apply_probability (p);\n }\n \n-/* Helper types for hash tables.  */\n-\n-struct htab_bb_copy_original_entry\n-{\n-  /* Block we are attaching info to.  */\n-  int index1;\n-  /* Index of original or copy (depending on the hashtable) */\n-  int index2;\n-};\n-\n-struct bb_copy_hasher : nofree_ptr_hash <htab_bb_copy_original_entry>\n-{\n-  static inline hashval_t hash (const htab_bb_copy_original_entry *);\n-  static inline bool equal (const htab_bb_copy_original_entry *existing,\n-\t\t\t    const htab_bb_copy_original_entry * candidate);\n-};\n-\n-inline hashval_t\n-bb_copy_hasher::hash (const htab_bb_copy_original_entry *data)\n-{\n-  return data->index1;\n-}\n-\n-inline bool\n-bb_copy_hasher::equal (const htab_bb_copy_original_entry *data,\n-\t\t       const htab_bb_copy_original_entry *data2)\n-{\n-  return data->index1 == data2->index1;\n-}\n-\n /* Data structures used to maintain mapping between basic blocks and\n    copies.  */\n-static hash_table<bb_copy_hasher> *bb_original;\n-static hash_table<bb_copy_hasher> *bb_copy;\n+typedef hash_map<int_hash<int, -1, -2>, int> copy_map_t;\n+static copy_map_t *bb_original;\n+static copy_map_t *bb_copy;\n \n /* And between loops and copies.  */\n-static hash_table<bb_copy_hasher> *loop_copy;\n-static object_allocator<htab_bb_copy_original_entry> *original_copy_bb_pool;\n+static copy_map_t *loop_copy;\n \n /* Initialize the data structures to maintain mapping between blocks\n    and its copies.  */\n void\n initialize_original_copy_tables (void)\n {\n-  original_copy_bb_pool = new object_allocator<htab_bb_copy_original_entry>\n-    (\"original_copy\");\n-  bb_original = new hash_table<bb_copy_hasher> (10);\n-  bb_copy = new hash_table<bb_copy_hasher> (10);\n-  loop_copy = new hash_table<bb_copy_hasher> (10);\n+  bb_original = new copy_map_t (10);\n+  bb_copy = new copy_map_t (10);\n+  loop_copy = new copy_map_t (10);\n }\n \n /* Reset the data structures to maintain mapping between blocks and\n@@ -1016,7 +984,6 @@ initialize_original_copy_tables (void)\n void\n reset_original_copy_tables (void)\n {\n-  gcc_assert (original_copy_bb_pool);\n   bb_original->empty ();\n   bb_copy->empty ();\n   loop_copy->empty ();\n@@ -1027,15 +994,12 @@ reset_original_copy_tables (void)\n void\n free_original_copy_tables (void)\n {\n-  gcc_assert (original_copy_bb_pool);\n   delete bb_copy;\n   bb_copy = NULL;\n   delete bb_original;\n   bb_original = NULL;\n   delete loop_copy;\n   loop_copy = NULL;\n-  delete original_copy_bb_pool;\n-  original_copy_bb_pool = NULL;\n }\n \n /* Return true iff we have had a call to initialize_original_copy_tables\n@@ -1044,51 +1008,31 @@ free_original_copy_tables (void)\n bool\n original_copy_tables_initialized_p (void)\n {\n-  return original_copy_bb_pool != NULL;\n+  return bb_copy != NULL;\n }\n \n /* Removes the value associated with OBJ from table TAB.  */\n \n static void\n-copy_original_table_clear (hash_table<bb_copy_hasher> *tab, unsigned obj)\n+copy_original_table_clear (copy_map_t *tab, unsigned obj)\n {\n-  htab_bb_copy_original_entry **slot;\n-  struct htab_bb_copy_original_entry key, *elt;\n-\n-  if (!original_copy_bb_pool)\n+  if (!original_copy_tables_initialized_p ())\n     return;\n \n-  key.index1 = obj;\n-  slot = tab->find_slot (&key, NO_INSERT);\n-  if (!slot)\n-    return;\n-\n-  elt = *slot;\n-  tab->clear_slot (slot);\n-  original_copy_bb_pool->remove (elt);\n+  tab->remove (obj);\n }\n \n /* Sets the value associated with OBJ in table TAB to VAL.\n    Do nothing when data structures are not initialized.  */\n \n static void\n-copy_original_table_set (hash_table<bb_copy_hasher> *tab,\n+copy_original_table_set (copy_map_t *tab,\n \t\t\t unsigned obj, unsigned val)\n {\n-  struct htab_bb_copy_original_entry **slot;\n-  struct htab_bb_copy_original_entry key;\n-\n-  if (!original_copy_bb_pool)\n+  if (!original_copy_tables_initialized_p ())\n     return;\n \n-  key.index1 = obj;\n-  slot = tab->find_slot (&key, INSERT);\n-  if (!*slot)\n-    {\n-      *slot = original_copy_bb_pool->allocate ();\n-      (*slot)->index1 = obj;\n-    }\n-  (*slot)->index2 = val;\n+  tab->put (obj, val);\n }\n \n /* Set original for basic block.  Do nothing when data structures are not\n@@ -1103,15 +1047,11 @@ set_bb_original (basic_block bb, basic_block original)\n basic_block\n get_bb_original (basic_block bb)\n {\n-  struct htab_bb_copy_original_entry *entry;\n-  struct htab_bb_copy_original_entry key;\n-\n-  gcc_assert (original_copy_bb_pool);\n+  gcc_assert (original_copy_tables_initialized_p ());\n \n-  key.index1 = bb->index;\n-  entry = bb_original->find (&key);\n+  int *entry = bb_original->get (bb->index);\n   if (entry)\n-    return BASIC_BLOCK_FOR_FN (cfun, entry->index2);\n+    return BASIC_BLOCK_FOR_FN (cfun, *entry);\n   else\n     return NULL;\n }\n@@ -1128,15 +1068,11 @@ set_bb_copy (basic_block bb, basic_block copy)\n basic_block\n get_bb_copy (basic_block bb)\n {\n-  struct htab_bb_copy_original_entry *entry;\n-  struct htab_bb_copy_original_entry key;\n+  gcc_assert (original_copy_tables_initialized_p ());\n \n-  gcc_assert (original_copy_bb_pool);\n-\n-  key.index1 = bb->index;\n-  entry = bb_copy->find (&key);\n+  int *entry = bb_copy->get (bb->index);\n   if (entry)\n-    return BASIC_BLOCK_FOR_FN (cfun, entry->index2);\n+    return BASIC_BLOCK_FOR_FN (cfun, *entry);\n   else\n     return NULL;\n }\n@@ -1158,15 +1094,11 @@ set_loop_copy (class loop *loop, class loop *copy)\n class loop *\n get_loop_copy (class loop *loop)\n {\n-  struct htab_bb_copy_original_entry *entry;\n-  struct htab_bb_copy_original_entry key;\n-\n-  gcc_assert (original_copy_bb_pool);\n+  gcc_assert (original_copy_tables_initialized_p ());\n \n-  key.index1 = loop->num;\n-  entry = loop_copy->find (&key);\n+  int *entry = loop_copy->get (loop->num);\n   if (entry)\n-    return get_loop (cfun, entry->index2);\n+    return get_loop (cfun, *entry);\n   else\n     return NULL;\n }"}]}