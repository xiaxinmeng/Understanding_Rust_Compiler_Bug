{"sha": "68fca5952947613ca6239242cbd498ac7ce12b7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhmY2E1OTUyOTQ3NjEzY2E2MjM5MjQyY2JkNDk4YWM3Y2UxMmI3ZQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2014-01-30T16:15:36Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2014-01-30T16:15:36Z"}, "message": "re PR c/59940 (Imprecise column number for -Wconversion)\n\n\tPR c/59940\nc-family/\n\t* c-common.h (unsafe_conversion_p): Adjust declaration.\n\t(warnings_for_convert_and_check): Likewise.\n\t(convert_and_check): Likewise.\n\t* c-common.c (unsafe_conversion_p): Add location parameter.  Call\n\texpansion_point_location_if_in_system_header on it.\n\t(warnings_for_convert_and_check): Add location parameter.  Call\n\texpansion_point_location_if_in_system_header on it.  Use it.\n\t(convert_and_check): Add location parameter.  Use it.\n\t(conversion_warning): Likewise.\n\t(c_add_case_label): Adjust convert_and_check calls.\n\t(scalar_to_vector): Adjust unsafe_conversion_p calls.\ncp/\n\t* typeck.c (build_ptrmemfunc1): Call convert_and_check with\n\tinput_location.\n\t* cvt.c (cp_convert_and_check): Call warnings_for_convert_and_check\n\twith input_location.\n\t* call.c (build_conditional_expr_1): Call unsafe_conversion_p with\n\tloc parameter.\nc/\n\t* c-typeck.c (build_function_call_vec): Use loc parameter.\n\t(convert_arguments): Add location parameter.  Use it.\n\t(ep_convert_and_check): Likewise.\n\t(build_atomic_assign): Adjust convert_for_assignment call.\n\t(build_modify_expr): Likewise.\n\t(digest_init): Likewise.\n\t(c_finish_return): Likewise.\n\t(build_conditional_expr): Adjust ep_convert_and_check calls.\n\t(convert_for_assignment): Add rhs_loc parameter.  Use it.\n\t(build_binary_op): Adjust convert_and_check and ep_convert_and_check\n\tcalls.\ntestsuite/\n\t* gcc.dg/pr59940.c: New test.\n\t* gcc.dg/pr35635.c (func3): Move dg-warning.\n\nFrom-SVN: r207309", "tree": {"sha": "1864e86fe52740bb3329849e59bfb3edd8b05587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1864e86fe52740bb3329849e59bfb3edd8b05587"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68fca5952947613ca6239242cbd498ac7ce12b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68fca5952947613ca6239242cbd498ac7ce12b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68fca5952947613ca6239242cbd498ac7ce12b7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68fca5952947613ca6239242cbd498ac7ce12b7e/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2d70f6d43551f5e6344909b8f2020a92ae7e4839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d70f6d43551f5e6344909b8f2020a92ae7e4839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d70f6d43551f5e6344909b8f2020a92ae7e4839"}], "stats": {"total": 251, "additions": 168, "deletions": 83}, "files": [{"sha": "35546ee1c8863c77c2e4e497ee0fcf2f2d645bd8", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -1,3 +1,18 @@\n+2014-01-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/59940\n+\t* c-common.h (unsafe_conversion_p): Adjust declaration.\n+\t(warnings_for_convert_and_check): Likewise.\n+\t(convert_and_check): Likewise.\n+\t* c-common.c (unsafe_conversion_p): Add location parameter.  Call\n+\texpansion_point_location_if_in_system_header on it.\n+\t(warnings_for_convert_and_check): Add location parameter.  Call\n+\texpansion_point_location_if_in_system_header on it.  Use it.\n+\t(convert_and_check): Add location parameter.  Use it.\n+\t(conversion_warning): Likewise.\n+\t(c_add_case_label): Adjust convert_and_check calls.\n+\t(scalar_to_vector): Adjust unsafe_conversion_p calls.\n+\n 2014-01-24  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-common.c (c_define_builtins): Replaced flag_enable_cilkplus with"}, {"sha": "e5d1075fc87838e1a1bdcf42b7584973bd5fe377", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -2526,23 +2526,24 @@ shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n   return result_type;\n }\n \n-/* Checks if expression EXPR of real/integer type cannot be converted \n+/* Checks if expression EXPR of real/integer type cannot be converted\n    to the real/integer type TYPE. Function returns non-zero when:\n-\t* EXPR is a constant which cannot be exactly converted to TYPE \n-\t* EXPR is not a constant and size of EXPR's type > than size of TYPE, \n+\t* EXPR is a constant which cannot be exactly converted to TYPE.\n+\t* EXPR is not a constant and size of EXPR's type > than size of TYPE,\n \t  for EXPR type and TYPE being both integers or both real.\n-\t* EXPR is not a constant of real type and TYPE is an integer.  \n-\t* EXPR is not a constant of integer type which cannot be \n-\t  exactly converted to real type.  \n+\t* EXPR is not a constant of real type and TYPE is an integer.\n+\t* EXPR is not a constant of integer type which cannot be\n+\t  exactly converted to real type.\n    Function allows conversions between types of different signedness and\n    can return SAFE_CONVERSION (zero) in that case.  Function can produce\n    signedness warnings if PRODUCE_WARNS is true.  */\n+\n enum conversion_safety\n-unsafe_conversion_p (tree type, tree expr, bool produce_warns)\n+unsafe_conversion_p (location_t loc, tree type, tree expr, bool produce_warns)\n {\n   enum conversion_safety give_warning = SAFE_CONVERSION; /* is 0 or false */\n   tree expr_type = TREE_TYPE (expr);\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  loc = expansion_point_location_if_in_system_header (loc);\n \n   if (TREE_CODE (expr) == REAL_CST || TREE_CODE (expr) == INTEGER_CST)\n     {\n@@ -2705,10 +2706,9 @@ unsafe_conversion_p (tree type, tree expr, bool produce_warns)\n    This is a helper function for warnings_for_convert_and_check.  */\n \n static void\n-conversion_warning (tree type, tree expr)\n+conversion_warning (location_t loc, tree type, tree expr)\n {\n   tree expr_type = TREE_TYPE (expr);\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n   enum conversion_safety conversion_kind;\n \n   if (!warn_conversion && !warn_sign_conversion && !warn_float_conversion)\n@@ -2738,7 +2738,7 @@ conversion_warning (tree type, tree expr)\n \n     case REAL_CST:\n     case INTEGER_CST:\n-      conversion_kind = unsafe_conversion_p (type, expr, true);\n+      conversion_kind = unsafe_conversion_p (loc, type, expr, true);\n       if (conversion_kind == UNSAFE_REAL)\n \twarning_at (loc, OPT_Wfloat_conversion,\n \t\t    \"conversion to %qT alters %qT constant value\",\n@@ -2756,13 +2756,13 @@ conversion_warning (tree type, tree expr)\n         tree op1 = TREE_OPERAND (expr, 1);\n         tree op2 = TREE_OPERAND (expr, 2);\n         \n-        conversion_warning (type, op1);\n-        conversion_warning (type, op2);\n+        conversion_warning (loc, type, op1);\n+        conversion_warning (loc, type, op2);\n         return;\n       }\n \n     default: /* 'expr' is not a constant.  */\n-      conversion_kind = unsafe_conversion_p (type, expr, true);\n+      conversion_kind = unsafe_conversion_p (loc, type, expr, true);\n       if (conversion_kind == UNSAFE_REAL)\n \twarning_at (loc, OPT_Wfloat_conversion,\n \t\t    \"conversion to %qT from %qT may alter its value\",\n@@ -2779,9 +2779,10 @@ conversion_warning (tree type, tree expr)\n    convert_and_check and cp_convert_and_check.  */\n \n void\n-warnings_for_convert_and_check (tree type, tree expr, tree result)\n+warnings_for_convert_and_check (location_t loc, tree type, tree expr,\n+\t\t\t\ttree result)\n {\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  loc = expansion_point_location_if_in_system_header (loc);\n \n   if (TREE_CODE (expr) == INTEGER_CST\n       && (TREE_CODE (type) == INTEGER_TYPE\n@@ -2801,10 +2802,10 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n             warning_at (loc, OPT_Woverflow,\n \t\t\t\"large integer implicitly truncated to unsigned type\");\n           else\n-            conversion_warning (type, expr);\n+            conversion_warning (loc, type, expr);\n         }\n       else if (!int_fits_type_p (expr, c_common_unsigned_type (type)))\n-\twarning (OPT_Woverflow,\n+\twarning_at (loc, OPT_Woverflow,\n \t\t \"overflow in implicit constant conversion\");\n       /* No warning for converting 0x80000000 to int.  */\n       else if (pedantic\n@@ -2815,14 +2816,14 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n \t\t    \"overflow in implicit constant conversion\");\n \n       else\n-\tconversion_warning (type, expr);\n+\tconversion_warning (loc, type, expr);\n     }\n   else if ((TREE_CODE (result) == INTEGER_CST\n \t    || TREE_CODE (result) == FIXED_CST) && TREE_OVERFLOW (result))\n     warning_at (loc, OPT_Woverflow,\n \t\t\"overflow in implicit constant conversion\");\n   else\n-    conversion_warning (type, expr);\n+    conversion_warning (loc, type, expr);\n }\n \n \n@@ -2831,7 +2832,7 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n    i.e. because of language rules and not because of an explicit cast.  */\n \n tree\n-convert_and_check (tree type, tree expr)\n+convert_and_check (location_t loc, tree type, tree expr)\n {\n   tree result;\n   tree expr_for_warning;\n@@ -2858,7 +2859,7 @@ convert_and_check (tree type, tree expr)\n   if (c_inhibit_evaluation_warnings == 0\n       && !TREE_OVERFLOW_P (expr)\n       && result != error_mark_node)\n-    warnings_for_convert_and_check (type, expr_for_warning, result);\n+    warnings_for_convert_and_check (loc, type, expr_for_warning, result);\n \n   return result;\n }\n@@ -5960,14 +5961,14 @@ c_add_case_label (location_t loc, splay_tree cases, tree cond, tree orig_type,\n   if (low_value)\n     {\n       low_value = check_case_value (low_value);\n-      low_value = convert_and_check (type, low_value);\n+      low_value = convert_and_check (loc, type, low_value);\n       if (low_value == error_mark_node)\n \tgoto error_out;\n     }\n   if (high_value)\n     {\n       high_value = check_case_value (high_value);\n-      high_value = convert_and_check (type, high_value);\n+      high_value = convert_and_check (loc, type, high_value);\n       if (high_value == error_mark_node)\n \tgoto error_out;\n     }\n@@ -11725,7 +11726,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n \tif (TREE_CODE (type0) == INTEGER_TYPE\n \t    && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE)\n \t  {\n-\t    if (unsafe_conversion_p (TREE_TYPE (type1), op0, false))\n+\t    if (unsafe_conversion_p (loc, TREE_TYPE (type1), op0, false))\n \t      {\n \t\tif (complain)\n \t\t  error_at (loc, \"conversion of scalar %qT to vector %qT \"\n@@ -11775,7 +11776,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n \tif (TREE_CODE (type0) == INTEGER_TYPE\n \t    && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE)\n \t  {\n-\t    if (unsafe_conversion_p (TREE_TYPE (type1), op0, false))\n+\t    if (unsafe_conversion_p (loc, TREE_TYPE (type1), op0, false))\n \t      {\n \t\tif (complain)\n \t\t  error_at (loc, \"conversion of scalar %qT to vector %qT \"\n@@ -11790,7 +11791,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n \t\t     || TREE_CODE (type0) == INTEGER_TYPE)\n \t\t && SCALAR_FLOAT_TYPE_P (TREE_TYPE (type1)))\n \t  {\n-\t    if (unsafe_conversion_p (TREE_TYPE (type1), op0, false))\n+\t    if (unsafe_conversion_p (loc, TREE_TYPE (type1), op0, false))\n \t      {\n \t\tif (complain)\n \t\t  error_at (loc, \"conversion of scalar %qT to vector %qT \""}, {"sha": "e47d035e63994ff23d6f0fb863b80317549e2c3d", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -749,7 +749,8 @@ extern tree c_common_signed_type (tree);\n extern tree c_common_signed_or_unsigned_type (int, tree);\n extern void c_common_init_ts (void);\n extern tree c_build_bitfield_integer_type (unsigned HOST_WIDE_INT, int);\n-extern enum conversion_safety unsafe_conversion_p (tree, tree, bool);\n+extern enum conversion_safety unsafe_conversion_p (location_t, tree, tree,\n+\t\t\t\t\t\t   bool);\n extern bool decl_with_nonnull_addr_p (const_tree);\n extern tree c_fully_fold (tree, bool, bool *);\n extern tree decl_constant_value_for_optimization (tree);\n@@ -769,8 +770,8 @@ extern bool strict_aliasing_warning (tree, tree, tree);\n extern void sizeof_pointer_memaccess_warning (location_t *, tree,\n \t\t\t\t\t      vec<tree, va_gc> *, tree *,\n \t\t\t\t\t      bool (*) (tree, tree));\n-extern void warnings_for_convert_and_check (tree, tree, tree);\n-extern tree convert_and_check (tree, tree);\n+extern void warnings_for_convert_and_check (location_t, tree, tree, tree);\n+extern tree convert_and_check (location_t, tree, tree);\n extern void overflow_warning (location_t, tree);\n extern bool warn_if_unused_value (const_tree, location_t);\n extern void warn_logical_operator (location_t, enum tree_code, tree,"}, {"sha": "7c6ffbc1f35423f15d33dc40df6bc69d77a7eaae", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -1,3 +1,18 @@\n+2014-01-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/59940\n+\t* c-typeck.c (build_function_call_vec): Use loc parameter.\n+\t(convert_arguments): Add location parameter.  Use it.\n+\t(ep_convert_and_check): Likewise.\n+\t(build_atomic_assign): Adjust convert_for_assignment call.\n+\t(build_modify_expr): Likewise.\n+\t(digest_init): Likewise.\n+\t(c_finish_return): Likewise.\n+\t(build_conditional_expr): Adjust ep_convert_and_check calls.\n+\t(convert_for_assignment): Add rhs_loc parameter.  Use it.\n+\t(build_binary_op): Adjust convert_and_check and ep_convert_and_check\n+\tcalls.\n+\n 2014-01-30  Richard Biener  <rguenther@suse.de>\n \n \tPR c/59905"}, {"sha": "4b9f4bf72aeeeadbac843f343ca8ab18dc626add", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 56, "deletions": 47, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -89,10 +89,10 @@ static int function_types_compatible_p (const_tree, const_tree, bool *,\n \t\t\t\t\tbool *);\n static int type_lists_compatible_p (const_tree, const_tree, bool *, bool *);\n static tree lookup_field (tree, tree);\n-static int convert_arguments (tree, vec<tree, va_gc> *, vec<tree, va_gc> *,\n-\t\t\t      tree, tree);\n+static int convert_arguments (location_t, tree, vec<tree, va_gc> *,\n+\t\t\t      vec<tree, va_gc> *, tree, tree);\n static tree pointer_diff (location_t, tree, tree);\n-static tree convert_for_assignment (location_t, tree, tree, tree,\n+static tree convert_for_assignment (location_t, location_t, tree, tree, tree,\n \t\t\t\t    enum impl_conv, bool, tree, tree, int);\n static tree valid_compound_expr_initializer (tree, tree);\n static void push_string (const char *);\n@@ -2901,7 +2901,7 @@ build_function_call_vec (location_t loc, tree function,\n   /* Convert the parameters to the types declared in the\n      function prototype, or apply default promotions.  */\n \n-  nargs = convert_arguments (TYPE_ARG_TYPES (fntype), params, origtypes,\n+  nargs = convert_arguments (loc, TYPE_ARG_TYPES (fntype), params, origtypes,\n \t\t\t     function, fundecl);\n   if (nargs < 0)\n     return error_mark_node;\n@@ -2986,7 +2986,7 @@ build_function_call_vec (location_t loc, tree function,\n    failure.  */\n \n static int\n-convert_arguments (tree typelist, vec<tree, va_gc> *values,\n+convert_arguments (location_t loc, tree typelist, vec<tree, va_gc> *values,\n \t\t   vec<tree, va_gc> *origtypes, tree function, tree fundecl)\n {\n   tree typetail, val;\n@@ -3051,11 +3051,9 @@ convert_arguments (tree typelist, vec<tree, va_gc> *values,\n       if (type == void_type_node)\n \t{\n \t  if (selector)\n-\t    error_at (input_location,\n-\t\t      \"too many arguments to method %qE\", selector);\n+\t    error_at (loc, \"too many arguments to method %qE\", selector);\n \t  else\n-\t    error_at (input_location,\n-\t\t      \"too many arguments to function %qE\", function);\n+\t    error_at (loc, \"too many arguments to function %qE\", function);\n \t  inform_declaration (fundecl);\n \t  return parmnum;\n \t}\n@@ -3230,9 +3228,9 @@ convert_arguments (tree typelist, vec<tree, va_gc> *values,\n \t      if (excess_precision)\n \t\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n \t      origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n-\t      parmval = convert_for_assignment (input_location, type, val,\n-\t\t\t\t\t\torigtype, ic_argpass, npc,\n-\t\t\t\t\t\tfundecl, function,\n+\t      parmval = convert_for_assignment (loc, UNKNOWN_LOCATION, type,\n+\t\t\t\t\t\tval, origtype, ic_argpass,\n+\t\t\t\t\t\tnpc, fundecl, function,\n \t\t\t\t\t\tparmnum + 1);\n \n \t      if (targetm.calls.promote_prototypes (fundecl ? TREE_TYPE (fundecl) : 0)\n@@ -3287,8 +3285,7 @@ convert_arguments (tree typelist, vec<tree, va_gc> *values,\n \n   if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n     {\n-      error_at (input_location,\n-\t\t\"too few arguments to function %qE\", function);\n+      error_at (loc, \"too few arguments to function %qE\", function);\n       inform_declaration (fundecl);\n       return -1;\n     }\n@@ -3673,8 +3670,8 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n \n   /* newval = old + val;  */\n   rhs = build_binary_op (loc, modifycode, old, val, 1);\n-  rhs = convert_for_assignment (loc, nonatomic_lhs_type, rhs, NULL_TREE,\n-\t\t\t\tic_assign, false, NULL_TREE,\n+  rhs = convert_for_assignment (loc, UNKNOWN_LOCATION, nonatomic_lhs_type,\n+\t\t\t\trhs, NULL_TREE, ic_assign, false, NULL_TREE,\n \t\t\t\tNULL_TREE, 0);\n   if (rhs != error_mark_node)\n     {\n@@ -4351,20 +4348,21 @@ c_mark_addressable (tree exp)\n    the usual ones because of excess precision.  */\n \n static tree\n-ep_convert_and_check (tree type, tree expr, tree semantic_type)\n+ep_convert_and_check (location_t loc, tree type, tree expr,\n+\t\t      tree semantic_type)\n {\n   if (TREE_TYPE (expr) == type)\n     return expr;\n \n   if (!semantic_type)\n-    return convert_and_check (type, expr);\n+    return convert_and_check (loc, type, expr);\n \n   if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n       && TREE_TYPE (expr) != semantic_type)\n     {\n       /* For integers, we need to check the real conversion, not\n \t the conversion to the excess precision type.  */\n-      expr = convert_and_check (semantic_type, expr);\n+      expr = convert_and_check (loc, semantic_type, expr);\n     }\n   /* Result type is the excess precision type, which should be\n      large enough, so do not check.  */\n@@ -4648,8 +4646,10 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t\t\t  TYPE_READONLY (type1) || TYPE_READONLY (type2),\n \t\t\t  TYPE_VOLATILE (type1) || TYPE_VOLATILE (type2));\n \n-  op1 = ep_convert_and_check (result_type, op1, semantic_result_type);\n-  op2 = ep_convert_and_check (result_type, op2, semantic_result_type);\n+  op1 = ep_convert_and_check (colon_loc, result_type, op1,\n+\t\t\t      semantic_result_type);\n+  op2 = ep_convert_and_check (colon_loc, result_type, op2,\n+\t\t\t      semantic_result_type);\n \n   if (ifexp_bcp && ifexp == truthvalue_true_node)\n     {\n@@ -5349,9 +5349,9 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n       newrhs = c_fully_fold (newrhs, false, NULL);\n       if (rhs_semantic_type)\n \tnewrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n-      newrhs = convert_for_assignment (location, lhstype, newrhs, rhs_origtype,\n-\t\t\t\t       ic_assign, npc, NULL_TREE,\n-\t\t\t\t       NULL_TREE, 0);\n+      newrhs = convert_for_assignment (location, rhs_loc, lhstype, newrhs,\n+\t\t\t\t       rhs_origtype, ic_assign, npc,\n+\t\t\t\t       NULL_TREE, NULL_TREE, 0);\n       if (TREE_CODE (newrhs) == ERROR_MARK)\n \treturn error_mark_node;\n     }\n@@ -5386,8 +5386,9 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   if (olhstype == TREE_TYPE (result))\n     goto return_result;\n \n-  result = convert_for_assignment (location, olhstype, result, rhs_origtype,\n-\t\t\t\t   ic_assign, false, NULL_TREE, NULL_TREE, 0);\n+  result = convert_for_assignment (location, rhs_loc, olhstype, result,\n+\t\t\t\t   rhs_origtype, ic_assign, false, NULL_TREE,\n+\t\t\t\t   NULL_TREE, 0);\n   protected_set_expr_location (result, location);\n \n return_result:\n@@ -5518,13 +5519,14 @@ convert_to_anonymous_field (location_t location, tree type, tree rhs)\n    ERRTYPE says whether it is argument passing, assignment,\n    initialization or return.\n \n-   LOCATION is the location of the RHS.\n+   LOCATION is the location of the assignment, RHS_LOC is the location of\n+   the RHS.\n    FUNCTION is a tree for the function being called.\n    PARMNUM is the number of the argument, for printing in error messages.  */\n \n static tree\n-convert_for_assignment (location_t location, tree type, tree rhs,\n-\t\t\ttree origtype, enum impl_conv errtype,\n+convert_for_assignment (location_t location, location_t rhs_loc, tree type,\n+\t\t\ttree rhs, tree origtype, enum impl_conv errtype,\n \t\t\tbool null_pointer_constant, tree fundecl,\n \t\t\ttree function, int parmnum)\n {\n@@ -5696,9 +5698,11 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n       rhs = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (rhs)), rhs);\n       SET_EXPR_LOCATION (rhs, location);\n \n-      rhs = convert_for_assignment (location, build_pointer_type (TREE_TYPE (type)),\n-\t\t\t\t    rhs, origtype, errtype, null_pointer_constant,\n-\t\t\t\t    fundecl, function, parmnum);\n+      rhs = convert_for_assignment (location, rhs_loc,\n+\t\t\t\t    build_pointer_type (TREE_TYPE (type)),\n+\t\t\t\t    rhs, origtype, errtype,\n+\t\t\t\t    null_pointer_constant, fundecl, function,\n+\t\t\t\t    parmnum);\n       if (rhs == error_mark_node)\n \treturn error_mark_node;\n \n@@ -5724,7 +5728,8 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n       bool save = in_late_binary_op;\n       if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE)\n \tin_late_binary_op = true;\n-      ret = convert_and_check (type, orig_rhs);\n+      ret = convert_and_check (rhs_loc != UNKNOWN_LOCATION\n+\t\t\t       ? rhs_loc : location, type, orig_rhs);\n       if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE)\n \tin_late_binary_op = save;\n       return ret;\n@@ -5734,7 +5739,8 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n   if ((codel == RECORD_TYPE || codel == UNION_TYPE)\n       && codel == coder\n       && comptypes (type, rhstype))\n-    return convert_and_check (type, rhs);\n+    return convert_and_check (rhs_loc != UNKNOWN_LOCATION\n+\t\t\t      ? rhs_loc : location, type, rhs);\n \n   /* Conversion to a transparent union or record from its member types.\n      This applies only to function arguments.  */\n@@ -6693,8 +6699,8 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \n       /* Added to enable additional -Wsuggest-attribute=format warnings.  */\n       if (TREE_CODE (TREE_TYPE (inside_init)) == POINTER_TYPE)\n-\tinside_init = convert_for_assignment (init_loc, type, inside_init,\n-\t    \t\t\t\t      origtype,\n+\tinside_init = convert_for_assignment (init_loc, UNKNOWN_LOCATION,\n+\t\t\t\t\t      type, inside_init, origtype,\n \t\t\t\t\t      ic_init, null_pointer_constant,\n \t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n       return inside_init;\n@@ -6714,9 +6720,10 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \tinside_init = build1 (EXCESS_PRECISION_EXPR, semantic_type,\n \t\t\t      inside_init);\n       inside_init\n-\t= convert_for_assignment (init_loc, type, inside_init, origtype,\n-\t    \t\t\t  ic_init, null_pointer_constant,\n-\t\t\t\t  NULL_TREE, NULL_TREE, 0);\n+\t= convert_for_assignment (init_loc, UNKNOWN_LOCATION, type,\n+\t\t\t\t  inside_init, origtype, ic_init,\n+\t\t\t\t  null_pointer_constant, NULL_TREE, NULL_TREE,\n+\t\t\t\t  0);\n \n       /* Check to see if we have already given an error message.  */\n       if (inside_init == error_mark_node)\n@@ -9161,8 +9168,8 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n     }\n   else\n     {\n-      tree t = convert_for_assignment (loc, valtype, retval, origtype,\n-\t  \t\t\t       ic_return,\n+      tree t = convert_for_assignment (loc, UNKNOWN_LOCATION, valtype,\n+\t\t\t\t       retval, origtype, ic_return,\n \t\t\t\t       npc, NULL_TREE, NULL_TREE, 0);\n       tree res = DECL_RESULT (current_function_decl);\n       tree inner;\n@@ -10735,16 +10742,16 @@ build_binary_op (location_t location, enum tree_code code,\n \t  if (first_complex)\n \t    {\n \t      if (TREE_TYPE (op0) != result_type)\n-\t\top0 = convert_and_check (result_type, op0);\n+\t\top0 = convert_and_check (location, result_type, op0);\n \t      if (TREE_TYPE (op1) != real_type)\n-\t\top1 = convert_and_check (real_type, op1);\n+\t\top1 = convert_and_check (location, real_type, op1);\n \t    }\n \t  else\n \t    {\n \t      if (TREE_TYPE (op0) != real_type)\n-\t\top0 = convert_and_check (real_type, op0);\n+\t\top0 = convert_and_check (location, real_type, op0);\n \t      if (TREE_TYPE (op1) != result_type)\n-\t\top1 = convert_and_check (result_type, op1);\n+\t\top1 = convert_and_check (location, result_type, op1);\n \t    }\n \t  if (TREE_CODE (op0) == ERROR_MARK || TREE_CODE (op1) == ERROR_MARK)\n \t    return error_mark_node;\n@@ -10943,8 +10950,10 @@ build_binary_op (location_t location, enum tree_code code,\n \n   if (!converted)\n     {\n-      op0 = ep_convert_and_check (result_type, op0, semantic_result_type);\n-      op1 = ep_convert_and_check (result_type, op1, semantic_result_type);\n+      op0 = ep_convert_and_check (location, result_type, op0,\n+\t\t\t\t  semantic_result_type);\n+      op1 = ep_convert_and_check (location, result_type, op1,\n+\t\t\t\t  semantic_result_type);\n \n       /* This can happen if one operand has a vector type, and the other\n \t has a different type.  */"}, {"sha": "392fd1d766343fb709021980f9c51cbc6b7041dc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -1,3 +1,13 @@\n+2014-01-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/59940\n+\t* typeck.c (build_ptrmemfunc1): Call convert_and_check with\n+\tinput_location.\n+\t* cvt.c (cp_convert_and_check): Call warnings_for_convert_and_check\n+\twith input_location.\n+\t* call.c (build_conditional_expr_1): Call unsafe_conversion_p with\n+\tloc parameter.\n+\n 2014-01-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58843"}, {"sha": "71f95dbed4a2ba088bafd55145168ed74f82a498", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -4484,14 +4484,14 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t     but the warnings (like Wsign-conversion) have already been\n \t     given by the scalar build_conditional_expr_1. We still check\n \t     unsafe_conversion_p to forbid truncating long long -> float.  */\n-\t  if (unsafe_conversion_p (stype, arg2, false))\n+\t  if (unsafe_conversion_p (loc, stype, arg2, false))\n \t    {\n \t      if (complain & tf_error)\n \t\terror_at (loc, \"conversion of scalar %qT to vector %qT \"\n \t\t\t       \"involves truncation\", arg2_type, vtype);\n \t      return error_mark_node;\n \t    }\n-\t  if (unsafe_conversion_p (stype, arg3, false))\n+\t  if (unsafe_conversion_p (loc, stype, arg3, false))\n \t    {\n \t      if (complain & tf_error)\n \t\terror_at (loc, \"conversion of scalar %qT to vector %qT \""}, {"sha": "e8ece0e0b13206057e5a9d8a545142abfd5d8318", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -639,7 +639,8 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n \n       if (!TREE_OVERFLOW_P (stripped)\n \t  && folded_result != error_mark_node)\n-\twarnings_for_convert_and_check (type, folded, folded_result);\n+\twarnings_for_convert_and_check (input_location, type, folded,\n+\t\t\t\t\tfolded_result);\n     }\n \n   return result;"}, {"sha": "924937832f578439d8e77a6be9b432db84a6ccef", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -7715,7 +7715,7 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n   delta_field = DECL_CHAIN (pfn_field);\n \n   /* Make sure DELTA has the type we want.  */\n-  delta = convert_and_check (delta_type_node, delta);\n+  delta = convert_and_check (input_location, delta_type_node, delta);\n \n   /* Convert to the correct target type if necessary.  */\n   pfn = fold_convert (TREE_TYPE (pfn_field), pfn);"}, {"sha": "5283614f9c23992d44a2d1d8d0ce401d2164b55b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -1,3 +1,9 @@\n+2014-01-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/59940\n+\t* gcc.dg/pr59940.c: New test.\n+\t* gcc.dg/pr35635.c (func3): Move dg-warning.\n+\n 2014-01-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59903"}, {"sha": "86612d5283f0c88fd6d77519a8c3d82a2c139b95", "filename": "gcc/testsuite/gcc.dg/pr35635.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr35635.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr35635.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr35635.c?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -62,9 +62,9 @@ void func3()\n   /* At least one branch of ? does not fit in the destination, thus\n      warn.  */\n   uchar_x = bar != 0 ? 2.1 : 10; /* { dg-warning \"conversion\" } */\n-  uchar_x = bar != 0 \n+  uchar_x = bar != 0  /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n     ? (unsigned char) 1024 \n-    : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+    : -1;\n }\n \n void func4()"}, {"sha": "63e9ce554e0d881fc182b6b9e0c9f3b85f6cf5ec", "filename": "gcc/testsuite/gcc.dg/pr59940.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59940.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68fca5952947613ca6239242cbd498ac7ce12b7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59940.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59940.c?ref=68fca5952947613ca6239242cbd498ac7ce12b7e", "patch": "@@ -0,0 +1,27 @@\n+/* PR c/59940 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wconversion -Woverflow\" } */\n+\n+int f (unsigned int);\n+\n+int\n+g (void)\n+{\n+  int si = 12;\n+  unsigned int ui = -1; /* { dg-warning \"21:negative integer implicitly converted to unsigned type\" } */\n+  unsigned char uc;\n+  ui = si; /* { dg-warning \"8:conversion\" } */\n+  si = 0x80000000; /* { dg-warning \"8:conversion of unsigned constant value to negative integer\" } */\n+  si = 3.2f; /* { dg-warning \"8:conversion\" } */\n+  uc = 256; /* { dg-warning \"8:large integer implicitly truncated to unsigned type\" } */\n+  si = 0x800000000; /* { dg-warning \"8:overflow in implicit constant conversion\" } */\n+  return f (si) /* { dg-warning \"12:conversion\" } */\n+         + f (si); /* { dg-warning \"14:conversion\" } */\n+}\n+\n+int\n+y (void)\n+{\n+  f (); /* { dg-error \"5:too few arguments to function\" } */\n+  g (0xa); /* { dg-error \"5:too many arguments to function\" } */\n+}"}]}