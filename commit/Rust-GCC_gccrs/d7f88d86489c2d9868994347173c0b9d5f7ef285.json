{"sha": "d7f88d86489c2d9868994347173c0b9d5f7ef285", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdmODhkODY0ODljMmQ5ODY4OTk0MzQ3MTczYzBiOWQ1ZjdlZjI4NQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-06-15T09:35:15Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-06-15T09:35:15Z"}, "message": "Makefile.in (local-alloc.o): Depend on $(GGC_H) and reload.h.\n\n\t* Makefile.in (local-alloc.o): Depend on $(GGC_H) and reload.h.\n\t* local-alloc.c: Include \"ggc.h\" and \"reload.h\".\n\t(struct equivalence): New member is_arg_equivalence.\n\t(local_alloc): Always call update_equiv_regs.\n\t(update_equiv_regs): Allocate reg_equiv_init; set reg_equiv_init_size.\n\tDetect equivalences made by stores to memory in a second pass.\n\tReturn early if not optimizing.\n\tInitialize reg_equiv_init for all equivalences; treat equivalences for\n\tREG_EQUIV notes existing before this pass specially.\n\t(no_equiv): Don't clear reg_equiv_init or remove notes if the\n\tis_arg_equivalence field is set.\n\t* reload.h (reg_equiv_init, reg_equiv_init_size): Declare.\n\t* reload1.c (reg_equiv_init): No longer static.\n\t(reg_equiv_init_size): New variable.\n\t(reload): Don't allocate reg_equiv_init; don't free it when done but\n\tclear it.\n\tRestructure equivalence set up code not to set reg_equiv_init, but to\n\tclear it when we can't use an equivalence.\n\tUndo change disabling equivalences for MEM_READONLY_P memrefs.\n\tDump equivalencing insns to dump_file.\n\nFrom-SVN: r100975", "tree": {"sha": "b40cadba77aa51e2ccdab31a99a181393d469ee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b40cadba77aa51e2ccdab31a99a181393d469ee4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7f88d86489c2d9868994347173c0b9d5f7ef285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7f88d86489c2d9868994347173c0b9d5f7ef285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7f88d86489c2d9868994347173c0b9d5f7ef285", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7f88d86489c2d9868994347173c0b9d5f7ef285/comments", "author": null, "committer": null, "parents": [{"sha": "ae973d6ae8d82bb7612603c8a08b21374a8aab29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae973d6ae8d82bb7612603c8a08b21374a8aab29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae973d6ae8d82bb7612603c8a08b21374a8aab29"}], "stats": {"total": 366, "additions": 227, "deletions": 139}, "files": [{"sha": "c37f31bb721230746e10f480121d5da3ef0bee33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7f88d86489c2d9868994347173c0b9d5f7ef285", "patch": "@@ -1,3 +1,26 @@\n+2005-06-15  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* Makefile.in (local-alloc.o): Depend on $(GGC_H) and reload.h.\n+\t* local-alloc.c: Include \"ggc.h\" and \"reload.h\".\n+\t(struct equivalence): New member is_arg_equivalence.\n+\t(local_alloc): Always call update_equiv_regs.\n+\t(update_equiv_regs): Allocate reg_equiv_init; set reg_equiv_init_size.\n+\tDetect equivalences made by stores to memory in a second pass.\n+\tReturn early if not optimizing.\n+\tInitialize reg_equiv_init for all equivalences; treat equivalences for\n+\tREG_EQUIV notes existing before this pass specially.\n+\t(no_equiv): Don't clear reg_equiv_init or remove notes if the\n+\tis_arg_equivalence field is set.\n+\t* reload.h (reg_equiv_init, reg_equiv_init_size): Declare.\n+\t* reload1.c (reg_equiv_init): No longer static.\n+\t(reg_equiv_init_size): New variable.\n+\t(reload): Don't allocate reg_equiv_init; don't free it when done but\n+\tclear it.\n+\tRestructure equivalence set up code not to set reg_equiv_init, but to\n+\tclear it when we can't use an equivalence.\n+\tUndo change disabling equivalences for MEM_READONLY_P memrefs.\n+\tDump equivalencing insns to dump_file.\n+\n 2005-06-14  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/mips/mips.c (machine_function): Add varargs_size field."}, {"sha": "7a1ae761078e0029122874101c9acc5f7512fe36", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d7f88d86489c2d9868994347173c0b9d5f7ef285", "patch": "@@ -2241,8 +2241,8 @@ regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TM_P_H) $(EXPR_H) $(TIMEVAR_H) gt-regclass.h $(HASHTAB_H)\n local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n-   output.h function.h $(INSN_ATTR_H) toplev.h  except.h $(TM_P_H) \\\n-   $(INTEGRATE_H)\n+   output.h function.h $(INSN_ATTR_H) toplev.h  except.h reload.h $(TM_P_H) \\\n+   $(GGC_H) $(INTEGRATE_H)\n bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(GGC_H) gt-bitmap.h bitmap.h $(OBSTACK_H)\n global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "78b2ede46d785a2b0e13773558ba41fab9cede2d", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 125, "deletions": 54, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=d7f88d86489c2d9868994347173c0b9d5f7ef285", "patch": "@@ -76,6 +76,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"except.h\"\n #include \"integrate.h\"\n+#include \"reload.h\"\n+#include \"ggc.h\"\n \f\n /* Next quantity number available for allocation.  */\n \n@@ -260,6 +262,10 @@ struct equivalence\n   /* The list of each instruction which initializes this register.  */\n \n   rtx init_insns;\n+\n+  /* Nonzero if this had a preexisting REG_EQUIV note.  */\n+\n+  int is_arg_equivalence;\n };\n \n /* reg_equiv[N] (where N is a pseudo reg number) is the equivalence\n@@ -344,8 +350,7 @@ local_alloc (void)\n \n   /* Promote REG_EQUAL notes to REG_EQUIV notes and adjust status of affected\n      registers.  */\n-  if (optimize)\n-    update_equiv_regs ();\n+  update_equiv_regs ();\n \n   /* This sets the maximum number of quantities we can have.  Quantity\n      numbers start at zero and we can have one for each pseudo.  */\n@@ -761,7 +766,9 @@ memref_used_between_p (rtx memref, rtx start, rtx end)\n \n    If such a register is only referenced once, try substituting its value\n    into the using insn.  If it succeeds, we can eliminate the register\n-   completely.  */\n+   completely.\n+\n+   Initialize the REG_EQUIV_INIT array of initializing insns.  */\n \n static void\n update_equiv_regs (void)\n@@ -774,6 +781,8 @@ update_equiv_regs (void)\n \n   reg_equiv = xcalloc (max_regno, sizeof *reg_equiv);\n   INIT_REG_SET (&cleared_regs);\n+  reg_equiv_init = ggc_alloc_cleared (max_regno * sizeof (rtx));\n+  reg_equiv_init_size = max_regno;\n \n   init_alias_analysis ();\n \n@@ -824,44 +833,30 @@ update_equiv_regs (void)\n \t  dest = SET_DEST (set);\n \t  src = SET_SRC (set);\n \n-\t  /* If this sets a MEM to the contents of a REG that is only used\n-\t     in a single basic block, see if the register is always equivalent\n-\t     to that memory location and if moving the store from INSN to the\n-\t     insn that set REG is safe.  If so, put a REG_EQUIV note on the\n-\t     initializing insn.\n-\n-\t     Don't add a REG_EQUIV note if the insn already has one.  The existing\n-\t     REG_EQUIV is likely more useful than the one we are adding.\n-\n-\t     If one of the regs in the address has reg_equiv[REGNO].replace set,\n-\t     then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n-\t     optimization may move the set of this register immediately before\n-\t     insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n-\t     the mention in the REG_EQUIV note would be to an uninitialized\n-\t     pseudo.  */\n-\t  /* ????? This test isn't good enough; we might see a MEM with a use of\n-\t     a pseudo register before we see its setting insn that will cause\n-\t     reg_equiv[].replace for that pseudo to be set.\n-\t     Equivalences to MEMs should be made in another pass, after the\n-\t     reg_equiv[].replace information has been gathered.  */\n-\n-\t  if (MEM_P (dest) && REG_P (src)\n-\t      && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n-\t      && REG_BASIC_BLOCK (regno) >= 0\n-\t      && REG_N_SETS (regno) == 1\n-\t      && reg_equiv[regno].init_insns != 0\n-\t      && reg_equiv[regno].init_insns != const0_rtx\n-\t      && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n-\t\t\t\t  REG_EQUIV, NULL_RTX)\n-\t      && ! contains_replace_regs (XEXP (dest, 0)))\n+\t  /* See if this is setting up the equivalence between an argument\n+\t     register and its stack slot.  */\n+\t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n+\t  if (note)\n \t    {\n-\t      rtx init_insn = XEXP (reg_equiv[regno].init_insns, 0);\n-\t      if (validate_equiv_mem (init_insn, src, dest)\n-\t\t  && ! memref_used_between_p (dest, init_insn, insn))\n-\t\tREG_NOTES (init_insn)\n-\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, dest, REG_NOTES (init_insn));\n+\t      gcc_assert (REG_P (dest));\n+\t      regno = REGNO (dest);\n+\n+\t      /* Note that we don't want to clear reg_equiv_init even if there\n+\t\t are multiple sets of this register.  */\n+\t      reg_equiv[regno].is_arg_equivalence = 1;\n+\n+\t      /* Record for reload that this is an equivalencing insn.  */\n+\t      if (rtx_equal_p (src, XEXP (note, 0)))\n+\t\treg_equiv_init[regno]\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n+\n+\t      /* Continue normally in case this is a candidate for\n+\t\t replacements.  */\n \t    }\n \n+\t  if (!optimize)\n+\t    continue;\n+\n \t  /* We only handle the case of a pseudo register being set\n \t     once, or always to the same value.  */\n \t  /* ??? The mn10200 port breaks if we add equivalences for\n@@ -878,7 +873,7 @@ update_equiv_regs (void)\n \t      || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n \t      || reg_equiv[regno].init_insns == const0_rtx\n \t      || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n-\t\t  && MEM_P (src)))\n+\t\t  && MEM_P (src) && ! reg_equiv[regno].is_arg_equivalence))\n \t    {\n \t      /* This might be setting a SUBREG of a pseudo, a pseudo that is\n \t\t also set somewhere else to a constant.  */\n@@ -944,20 +939,27 @@ update_equiv_regs (void)\n \t  if (note)\n \t    {\n \t      int regno = REGNO (dest);\n+\t      rtx x = XEXP (note, 0);\n+\n+\t      /* If we haven't done so, record for reload that this is an\n+\t\t equivalencing insn.  */\n+\t      if (!reg_equiv[regno].is_arg_equivalence\n+\t\t  && (!MEM_P (x) || rtx_equal_p (src, x)))\n+\t\treg_equiv_init[regno]\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n \n \t      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n \t\t We might end up substituting the LABEL_REF for uses of the\n \t\t pseudo here or later.  That kind of transformation may turn an\n \t\t indirect jump into a direct jump, in which case we must rerun the\n \t\t jump optimizer to ensure that the JUMP_LABEL fields are valid.  */\n-\t      if (GET_CODE (XEXP (note, 0)) == LABEL_REF\n-\t\t  || (GET_CODE (XEXP (note, 0)) == CONST\n-\t\t      && GET_CODE (XEXP (XEXP (note, 0), 0)) == PLUS\n-\t\t      && (GET_CODE (XEXP (XEXP (XEXP (note, 0), 0), 0))\n-\t\t\t  == LABEL_REF)))\n+\t      if (GET_CODE (x) == LABEL_REF\n+\t\t  || (GET_CODE (x) == CONST\n+\t\t      && GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)))\n \t\trecorded_label_ref = 1;\n \n-\t      reg_equiv[regno].replacement = XEXP (note, 0);\n+\t      reg_equiv[regno].replacement = x;\n \t      reg_equiv[regno].src_p = &SET_SRC (set);\n \t      reg_equiv[regno].loop_depth = loop_depth;\n \n@@ -968,7 +970,6 @@ update_equiv_regs (void)\n \t\t     in local-alloc!  */\n \t\t  REG_LIVE_LENGTH (regno) *= 2;\n \n-\n \t\t  /* If the register is referenced exactly twice, meaning it is\n \t\t     set once and used once, indicate that the reference may be\n \t\t     replaced by the equivalence we computed above.  Do this\n@@ -978,17 +979,79 @@ update_equiv_regs (void)\n \t\t     and to reduce the number of registers alive across\n \t\t     calls.  */\n \n-\t\t    if (REG_N_REFS (regno) == 2\n-\t\t\t&& (rtx_equal_p (XEXP (note, 0), src)\n-\t\t\t    || ! equiv_init_varies_p (src))\n-\t\t\t&& NONJUMP_INSN_P (insn)\n-\t\t\t&& equiv_init_movable_p (PATTERN (insn), regno))\n-\t\t      reg_equiv[regno].replace = 1;\n+\t\t  if (REG_N_REFS (regno) == 2\n+\t\t      && (rtx_equal_p (x, src)\n+\t\t\t  || ! equiv_init_varies_p (src))\n+\t\t      && NONJUMP_INSN_P (insn)\n+\t\t      && equiv_init_movable_p (PATTERN (insn), regno))\n+\t\t    reg_equiv[regno].replace = 1;\n \t\t}\n \t    }\n \t}\n     }\n \n+  if (!optimize)\n+    goto out;\n+\n+  /* A second pass, to gather additional equivalences with memory.  This needs\n+     to be done after we know which registers we are going to replace.  */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx set, src, dest;\n+      unsigned regno;\n+\n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      set = single_set (insn);\n+      if (! set)\n+\tcontinue;\n+\n+      dest = SET_DEST (set);\n+      src = SET_SRC (set);\n+\n+      /* If this sets a MEM to the contents of a REG that is only used\n+\t in a single basic block, see if the register is always equivalent\n+\t to that memory location and if moving the store from INSN to the\n+\t insn that set REG is safe.  If so, put a REG_EQUIV note on the\n+\t initializing insn.\n+\n+\t Don't add a REG_EQUIV note if the insn already has one.  The existing\n+\t REG_EQUIV is likely more useful than the one we are adding.\n+\n+\t If one of the regs in the address has reg_equiv[REGNO].replace set,\n+\t then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n+\t optimization may move the set of this register immediately before\n+\t insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n+\t the mention in the REG_EQUIV note would be to an uninitialized\n+\t pseudo.  */\n+\n+      if (MEM_P (dest) && REG_P (src)\n+\t  && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n+\t  && REG_BASIC_BLOCK (regno) >= 0\n+\t  && REG_N_SETS (regno) == 1\n+\t  && reg_equiv[regno].init_insns != 0\n+\t  && reg_equiv[regno].init_insns != const0_rtx\n+\t  && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n+\t\t\t      REG_EQUIV, NULL_RTX)\n+\t  && ! contains_replace_regs (XEXP (dest, 0)))\n+\t{\n+\t  rtx init_insn = XEXP (reg_equiv[regno].init_insns, 0);\n+\t  if (validate_equiv_mem (init_insn, src, dest)\n+\t      && ! memref_used_between_p (dest, init_insn, insn))\n+\t    {\n+\t      REG_NOTES (init_insn)\n+\t\t= gen_rtx_EXPR_LIST (REG_EQUIV, dest,\n+\t\t\t\t     REG_NOTES (init_insn));\n+\t      /* This insn makes the equivalence, not the one initializing\n+\t\t the register.  */\n+\t      reg_equiv_init[regno]\n+\t\t= gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+\t    }\n+\t}\n+    }\n+\n   /* Now scan all regs killed in an insn to see if any of them are\n      registers only used that once.  If so, see if we can replace the\n      reference with the equivalent form.  If we can, delete the\n@@ -1082,6 +1145,7 @@ update_equiv_regs (void)\n \t\t\t info.  */\n \t\t      SET_REGNO_REG_SET (&cleared_regs, regno);\n \t\t      clear_regnos++;\n+\t\t      reg_equiv_init[regno] = NULL_RTX;\n \t\t    }\n \t\t  /* Move the initialization of the register to just before\n \t\t     INSN.  Update the flow information.  */\n@@ -1113,6 +1177,7 @@ update_equiv_regs (void)\n \t\t\t info.  */\n \t\t      SET_REGNO_REG_SET (&cleared_regs, regno);\n \t\t      clear_regnos++;\n+\t\t      reg_equiv_init[regno] = NULL_RTX;\n \t\t    }\n \t\t}\n \t    }\n@@ -1146,6 +1211,7 @@ update_equiv_regs (void)\n \t}\n     }\n \n+  out:\n   /* Clean up.  */\n   end_alias_analysis ();\n   CLEAR_REG_SET (&cleared_regs);\n@@ -1171,13 +1237,18 @@ no_equiv (rtx reg, rtx store ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n   list = reg_equiv[regno].init_insns;\n   if (list == const0_rtx)\n     return;\n+  reg_equiv[regno].init_insns = const0_rtx;\n+  reg_equiv[regno].replacement = NULL_RTX;\n+  /* This doesn't matter for equivalences made for argument registers, we\n+     should keep their initialization insns.  */\n+  if (reg_equiv[regno].is_arg_equivalence)\n+    return;\n+  reg_equiv_init[regno] = NULL_RTX;\n   for (; list; list =  XEXP (list, 1))\n     {\n       rtx insn = XEXP (list, 0);\n       remove_note (insn, find_reg_note (insn, REG_EQUIV, NULL_RTX));\n     }\n-  reg_equiv[regno].init_insns = const0_rtx;\n-  reg_equiv[regno].replacement = NULL_RTX;\n }\n \f\n /* Allocate hard regs to the pseudo regs used only within block number B."}, {"sha": "bbf235ef3b2ae866021ca214334ad2b61ece59f6", "filename": "gcc/reload.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=d7f88d86489c2d9868994347173c0b9d5f7ef285", "patch": "@@ -170,6 +170,13 @@ extern rtx *reg_equiv_memory_loc;\n extern rtx *reg_equiv_address;\n extern rtx *reg_equiv_mem;\n \n+/* Element N is the list of insns that initialized reg N from its equivalent\n+   constant or memory slot.  */\n+extern GTY((length(\"reg_equiv_init_size\"))) rtx *reg_equiv_init;\n+\n+/* The size of the previous array, for GC purposes.  */\n+extern GTY(()) int reg_equiv_init_size;\n+\n /* All the \"earlyclobber\" operands of the current insn\n    are recorded here.  */\n extern int n_earlyclobbers;"}, {"sha": "3176dcae6d265fa8b8a47f88c7d5dfcc9edfecce", "filename": "gcc/reload1.c", "status": "modified", "additions": 70, "deletions": 83, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f88d86489c2d9868994347173c0b9d5f7ef285/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d7f88d86489c2d9868994347173c0b9d5f7ef285", "patch": "@@ -120,7 +120,8 @@ static unsigned int *reg_max_ref_width;\n \n /* Element N is the list of insns that initialized reg N from its equivalent\n    constant or memory slot.  */\n-static rtx *reg_equiv_init;\n+rtx *reg_equiv_init;\n+int reg_equiv_init_size;\n \n /* Vector to remember old contents of reg_renumber before spilling.  */\n static short *reg_old_renumber;\n@@ -693,7 +694,6 @@ reload (rtx first, int global)\n \n   reg_equiv_constant = xcalloc (max_regno, sizeof (rtx));\n   reg_equiv_mem = xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_init = xcalloc (max_regno, sizeof (rtx));\n   reg_equiv_address = xcalloc (max_regno, sizeof (rtx));\n   reg_max_ref_width = xcalloc (max_regno, sizeof (int));\n   reg_old_renumber = xcalloc (max_regno, sizeof (short));\n@@ -719,101 +719,88 @@ reload (rtx first, int global)\n \t  && GET_MODE (insn) != VOIDmode)\n \tPUT_MODE (insn, VOIDmode);\n \n+      if (INSN_P (insn))\n+\tscan_paradoxical_subregs (PATTERN (insn));\n+\n       if (set != 0 && REG_P (SET_DEST (set)))\n \t{\n \t  rtx note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-\t  if (note\n-\t      && (! function_invariant_p (XEXP (note, 0))\n-\t\t  || ! flag_pic\n-\t\t  /* A function invariant is often CONSTANT_P but may\n-\t\t     include a register.  We promise to only pass\n-\t\t     CONSTANT_P objects to LEGITIMATE_PIC_OPERAND_P.  */\n-\t\t  || (CONSTANT_P (XEXP (note, 0))\n-\t\t      && LEGITIMATE_PIC_OPERAND_P (XEXP (note, 0)))))\n+\t  rtx x;\n+\n+\t  if (! note)\n+\t    continue;\n+\n+\t  i = REGNO (SET_DEST (set));\n+\t  x = XEXP (note, 0);\n+\n+\t  if (i <= LAST_VIRTUAL_REGISTER)\n+\t    continue;\n+\n+\t  if (! function_invariant_p (x)\n+\t      || ! flag_pic\n+\t      /* A function invariant is often CONSTANT_P but may\n+\t\t include a register.  We promise to only pass\n+\t\t CONSTANT_P objects to LEGITIMATE_PIC_OPERAND_P.  */\n+\t      || (CONSTANT_P (x)\n+\t\t  && LEGITIMATE_PIC_OPERAND_P (x)))\n \t    {\n-\t      rtx x = XEXP (note, 0);\n-\t      i = REGNO (SET_DEST (set));\n-\t      if (i > LAST_VIRTUAL_REGISTER)\n+\t      /* It can happen that a REG_EQUIV note contains a MEM\n+\t\t that is not a legitimate memory operand.  As later\n+\t\t stages of reload assume that all addresses found\n+\t\t in the reg_equiv_* arrays were originally legitimate,\n+\t\t we ignore such REG_EQUIV notes.  */\n+\t      if (memory_operand (x, VOIDmode))\n \t\t{\n-\t\t  /* It can happen that a REG_EQUIV note contains a MEM\n-\t\t     that is not a legitimate memory operand.  As later\n-\t\t     stages of reload assume that all addresses found\n-\t\t     in the reg_equiv_* arrays were originally legitimate,\n-\n-\t\t     It can also happen that a REG_EQUIV note contains a\n-\t\t     readonly memory location.  If the destination pseudo\n-\t\t     is set from some other value (typically a different\n-\t\t     pseudo), and the destination pseudo does not get a\n-\t\t     hard reg, then reload will replace the destination\n-\t\t     pseudo with its equivalent memory location.  This\n-\t\t     is horribly bad as it creates a store to a readonly\n-\t\t     memory location and a runtime segfault.  To avoid\n-\t\t     this problem we reject readonly memory locations\n-\t\t     for equivalences.  This is overly conservative as\n-\t\t     we could find all sets of the destination pseudo\n-\t\t     and remove them as they should be redundant.  */\n-\t\t  if (memory_operand (x, VOIDmode) && ! MEM_READONLY_P (x))\n+\t\t  /* Always unshare the equivalence, so we can\n+\t\t     substitute into this insn without touching the\n+\t\t       equivalence.  */\n+\t\t  reg_equiv_memory_loc[i] = copy_rtx (x);\n+\t\t}\n+\t      else if (function_invariant_p (x))\n+\t\t{\n+\t\t  if (GET_CODE (x) == PLUS)\n \t\t    {\n-\t\t      /* Always unshare the equivalence, so we can\n-\t\t\t substitute into this insn without touching the\n-\t\t\t equivalence.  */\n-\t\t      reg_equiv_memory_loc[i] = copy_rtx (x);\n+\t\t      /* This is PLUS of frame pointer and a constant,\n+\t\t\t and might be shared.  Unshare it.  */\n+\t\t      reg_equiv_constant[i] = copy_rtx (x);\n+\t\t      num_eliminable_invariants++;\n \t\t    }\n-\t\t  else if (function_invariant_p (x))\n+\t\t  else if (x == frame_pointer_rtx\n+\t\t\t   || x == arg_pointer_rtx)\n \t\t    {\n-\t\t      if (GET_CODE (x) == PLUS)\n-\t\t\t{\n-\t\t\t  /* This is PLUS of frame pointer and a constant,\n-\t\t\t     and might be shared.  Unshare it.  */\n-\t\t\t  reg_equiv_constant[i] = copy_rtx (x);\n-\t\t\t  num_eliminable_invariants++;\n-\t\t\t}\n-\t\t      else if (x == frame_pointer_rtx\n-\t\t\t       || x == arg_pointer_rtx)\n-\t\t\t{\n-\t\t\t  reg_equiv_constant[i] = x;\n-\t\t\t  num_eliminable_invariants++;\n-\t\t\t}\n-\t\t      else if (LEGITIMATE_CONSTANT_P (x))\n-\t\t\treg_equiv_constant[i] = x;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  reg_equiv_memory_loc[i]\n-\t\t\t    = force_const_mem (GET_MODE (SET_DEST (set)), x);\n-\t\t\t  if (!reg_equiv_memory_loc[i])\n-\t\t\t    continue;\n-\t\t\t}\n+\t\t      reg_equiv_constant[i] = x;\n+\t\t      num_eliminable_invariants++;\n \t\t    }\n+\t\t  else if (LEGITIMATE_CONSTANT_P (x))\n+\t\t    reg_equiv_constant[i] = x;\n \t\t  else\n-\t\t    continue;\n-\n-\t\t  /* If this register is being made equivalent to a MEM\n-\t\t     and the MEM is not SET_SRC, the equivalencing insn\n-\t\t     is one with the MEM as a SET_DEST and it occurs later.\n-\t\t     So don't mark this insn now.  */\n-\t\t  if (!MEM_P (x)\n-\t\t      || rtx_equal_p (SET_SRC (set), x))\n-\t\t    reg_equiv_init[i]\n-\t\t      = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[i]);\n+\t\t    {\n+\t\t      reg_equiv_memory_loc[i]\n+\t\t\t= force_const_mem (GET_MODE (SET_DEST (set)), x);\n+\t\t      if (! reg_equiv_memory_loc[i])\n+\t\t\treg_equiv_init[i] = NULL_RTX;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  reg_equiv_init[i] = NULL_RTX;\n+\t\t  continue;\n \t\t}\n \t    }\n+\t  else\n+\t    reg_equiv_init[i] = NULL_RTX;\n \t}\n-\n-      /* If this insn is setting a MEM from a register equivalent to it,\n-\t this is the equivalencing insn.  */\n-      else if (set && MEM_P (SET_DEST (set))\n-\t       && REG_P (SET_SRC (set))\n-\t       && reg_equiv_memory_loc[REGNO (SET_SRC (set))]\n-\t       && rtx_equal_p (SET_DEST (set),\n-\t\t\t       reg_equiv_memory_loc[REGNO (SET_SRC (set))]))\n-\treg_equiv_init[REGNO (SET_SRC (set))]\n-\t  = gen_rtx_INSN_LIST (VOIDmode, insn,\n-\t\t\t       reg_equiv_init[REGNO (SET_SRC (set))]);\n-\n-      if (INSN_P (insn))\n-\tscan_paradoxical_subregs (PATTERN (insn));\n     }\n \n+  if (dump_file)\n+    for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+      if (reg_equiv_init[i])\n+\t{\n+\t  fprintf (dump_file, \"init_insns for %u: \", i);\n+\t  print_inline_rtx (dump_file, reg_equiv_init[i], 20);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n   init_elim_table ();\n \n   first_label_num = get_first_label_num ();\n@@ -1260,7 +1247,7 @@ reload (rtx first, int global)\n     free (offsets_at);\n \n   free (reg_equiv_mem);\n-  free (reg_equiv_init);\n+  reg_equiv_init = 0;\n   free (reg_equiv_address);\n   free (reg_max_ref_width);\n   free (reg_old_renumber);"}]}