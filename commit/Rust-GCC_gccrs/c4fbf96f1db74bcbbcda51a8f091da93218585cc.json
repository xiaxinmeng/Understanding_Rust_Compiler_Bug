{"sha": "c4fbf96f1db74bcbbcda51a8f091da93218585cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRmYmY5NmYxZGI3NGJjYmJjZGE1MWE4ZjA5MWRhOTMyMTg1ODVjYw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-06-29T20:46:51Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-06-29T20:46:51Z"}, "message": "(delay_slots_for_epilogue, eligible_for_epilogue_delay,\n\n\tok_for_epilogue_p): Delete epilogue delay slot functions.\n\t(m88k_begin_prologue m88k_end_prologue m88k_expand_prologue): New\n\tfunctions replacing m88k_output_prologue.\n\t(m88k_begin_epilogue m88k_end_epilogue m88k_expand_epilogue): Ditto.\n\t(preserve_registers): Delete epilogue delay slot mechanism and\n\tchange to output insns.\n\t(emit_add, emit_ldst): New functions.\n\nFrom-SVN: r1346", "tree": {"sha": "46e22a6a8dda252ab8d57e87680cbf0fc01833d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e22a6a8dda252ab8d57e87680cbf0fc01833d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4fbf96f1db74bcbbcda51a8f091da93218585cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fbf96f1db74bcbbcda51a8f091da93218585cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4fbf96f1db74bcbbcda51a8f091da93218585cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fbf96f1db74bcbbcda51a8f091da93218585cc/comments", "author": null, "committer": null, "parents": [{"sha": "3e72128498c6e557e19a6692dd900add55fbf21f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e72128498c6e557e19a6692dd900add55fbf21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e72128498c6e557e19a6692dd900add55fbf21f"}], "stats": {"total": 356, "additions": 103, "deletions": 253}, "files": [{"sha": "9984464d1621a6f45767cdb13f3baa366c7a457d", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 103, "deletions": 253, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fbf96f1db74bcbbcda51a8f091da93218585cc/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fbf96f1db74bcbbcda51a8f091da93218585cc/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=c4fbf96f1db74bcbbcda51a8f091da93218585cc", "patch": "@@ -46,7 +46,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.1.11.11 29 May 1992 11:12:23\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.2.3.6 29 Jun 1992 16:06:14\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -1619,8 +1619,9 @@ m88k_handle_pragma_token (string, token)\n   variable space.\n   */\n \n-static void output_reg_adjust ();\n+static void emit_add ();\n static void preserve_registers ();\n+static void emit_ldst ();\n static void output_tdesc ();\n \n static int  nregs;\n@@ -1629,6 +1630,7 @@ static char save_regs[FIRST_PSEUDO_REGISTER];\n static int  frame_laid_out;\n static int  frame_size;\n static int  variable_args_p;\n+static int  epilogue_marked;\n \n extern char call_used_regs[];\n extern int  current_function_pretend_args_size;\n@@ -1770,97 +1772,6 @@ null_epilogue ()\n \t  && m88k_stack_size == 0);\n }\n \n-/* Determine the number of instructions needed for the function epilogue.  */\n-\n-#define MAX_EPILOGUE_DELAY_INSNS 4\n-\n-static char epilogue_dead_regs[FIRST_PSEUDO_REGISTER];\n-\n-delay_slots_for_epilogue ()\n-{\n-  register int insns = save_regs[1] + save_regs[FRAME_POINTER_REGNUM];\n-  register int regs = nregs - insns;\n-\n-  if (regs > 3)\n-    insns += 1 + (regs & 1);\n-  else if (nregs == 4)\n-    /* This is a special cases of ld/ld/ld.d which has no start-up delay.  */\n-    return 0;\n-\n-  if (insns)\n-    {\n-      bzero ((char *) &epilogue_dead_regs[0], sizeof (epilogue_dead_regs));\n-      epilogue_dead_regs[1] = save_regs[1];\n-      epilogue_dead_regs[STACK_POINTER_REGNUM] = frame_pointer_needed;\n-      epilogue_dead_regs[TEMP_REGNUM] = ! ADD_INTVAL (m88k_fp_offset);\n-    }\n-\n-  return insns;\n-}\n-\n-/* Return 1 if X is safe to use as an epilogue insn.  */\n-\n-int\n-ok_for_epilogue_p (x)\n-     rtx x;\n-{\n-  register char *fmt;\n-  register int i, j;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case REG:\n-      for (i = REGNO (x), j = i + HARD_REGNO_NREGS (i, GET_MODE (x));\n-\t   i < j;\n-\t   i++)\n-\tif (epilogue_dead_regs[i])\n-\t  return 0;\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST:\n-    case PC:\n-    case CC0:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CODE_LABEL:\n-      return 1;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (!ok_for_epilogue_p (XEXP (x, i)))\n-\t    return 0;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (!ok_for_epilogue_p (XVECEXP (x, i, j)))\n-\t      return 0;\n-\t}\n-    }\n-  return 1;\n-}\n-\n-int\n-eligible_for_epilogue_delay (insn)\n-     rtx insn;\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_STORE:\n-    case TYPE_LOADA:\n-    case TYPE_ARITH:\n-    case TYPE_MARITH:\n-      return ok_for_epilogue_p (PATTERN (insn));\n-    default:\n-      return 0;\n-    }\n-}\n-\n /* Determine if the current function has any references to the arg pointer.\n    This is done indirectly by examining the DECL_ARGUMENTS' DECL_RTL.\n    It is OK to return TRUE if there are no references, but FALSE must be\n@@ -1892,9 +1803,26 @@ uses_arg_area_p ()\n }\n \f\n void\n-m88k_output_prologue (stream, size)\n+m88k_begin_prologue (stream, size)\n      FILE *stream;\n      int size;\n+{\n+  epilogue_marked = 0;\n+  m88k_prologue_done = 1;\t/* it's ok now to put out ln directives */\n+}\n+\n+void\n+m88k_end_prologue (stream)\n+     FILE *stream;\n+{\n+  if (TARGET_OCS_DEBUG_INFO)\n+    PUT_OCS_FUNCTION_START (stream);\n+  if (epilogue_marked)\n+    abort ();\n+}\n+\n+void\n+m88k_expand_prologue ()\n {\n   int old_fp_offset = m88k_fp_offset;\n   int old_stack_size = m88k_stack_size;\n@@ -1924,43 +1852,34 @@ m88k_output_prologue (stream, size)\n     }\n \n   if (m88k_stack_size)\n-    output_reg_adjust (stream, 31, 31, -m88k_stack_size, 0);\n+    emit_add (stack_pointer_rtx, stack_pointer_rtx, -m88k_stack_size);\n \n   if (nregs || nxregs)\n-    preserve_registers (stream, m88k_fp_offset + 4, 1);\n+    preserve_registers (m88k_fp_offset + 4, 1);\n \n   if (frame_pointer_needed)\n-    output_reg_adjust (stream, 30, 31, m88k_fp_offset, 0);\n-\n-  if (TARGET_OCS_DEBUG_INFO)\n-    PUT_OCS_FUNCTION_START (stream);\n+    emit_add (frame_pointer_rtx, stack_pointer_rtx, m88k_fp_offset);\n \n   if (flag_pic && save_regs[PIC_OFFSET_TABLE_REGNUM])\n     {\n-      char label[256];\n+      rtx return_reg = gen_rtx (REG, SImode, 1);\n+      rtx label = gen_label_rtx ();\n+      rtx temp_reg;\n \n       if (! save_regs[1])\n-\tfprintf (stream, \"\\tor\\t %s,%s,0\\n\",\n-\t\t reg_names[TEMP_REGNUM], reg_names[1]);\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"Lab\", m88k_function_number);\n-      fprintf (stream, \"\\tbsr.n\\t %s\\n\", &label[1]);\n-      fprintf (stream, \"\\tor.u\\t %s,%s,%shi16(%s#abdiff)\\n\",\n-\t       reg_names[PIC_OFFSET_TABLE_REGNUM], reg_names[0],\n-\t       m88k_pound_sign, &label[1]);\n-      ASM_OUTPUT_INTERNAL_LABEL (stream, \"Lab\", m88k_function_number);\n-      fprintf (stream, \"\\tor\\t %s,%s,%slo16(%s#abdiff)\\n\",\n-\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n-\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n-\t       m88k_pound_sign, &label[1]);\n-      fprintf (stream, \"\\taddu\\t %s,%s,%s\\n\",\n-\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n-\t       reg_names[PIC_OFFSET_TABLE_REGNUM], reg_names[1]);\n+\t{\n+\t  temp_reg = gen_rtx (REG, SImode, TEMP_REGNUM);\n+\t  emit_move_insn (temp_reg, return_reg);\n+\t}\n+      emit_insn (gen_locate1 (pic_offset_table_rtx, label));\n+      emit_insn (gen_locate2 (pic_offset_table_rtx, label));\n+      emit_insn (gen_addsi3 (pic_offset_table_rtx,\n+\t\t\t     pic_offset_table_rtx, return_reg));\n       if (! save_regs[1])\n-\tfprintf (stream, \"\\tor\\t %s,%s,0\\n\",\n-\t\t reg_names[1], reg_names[TEMP_REGNUM]);\n+\temit_move_insn (return_reg, temp_reg);\n     }\n-\n-  m88k_prologue_done = 1;\t/* it's ok now to put out ln directives */\n+  if (profile_flag || profile_block_flag)\n+    emit_insn (gen_profiler ());\n }\n \f\n /* This function generates the assembly code for function exit,\n@@ -1972,39 +1891,23 @@ m88k_output_prologue (stream, size)\n    omit stack adjustments before returning.  */\n \n void\n-m88k_output_epilogue (stream, size)\n+m88k_begin_epilogue (stream)\n      FILE *stream;\n-     int size;\n {\n-  rtx insn = get_last_insn ();\n-#if (MONITOR_GCC & 0x4) /* What are interesting prologue/epilogue values?  */\n-  fprintf (stream, \"; size = %d, m88k_fp_offset = %d, m88k_stack_size = %d\\n\",\n-\t   size, m88k_fp_offset, m88k_stack_size);\n-#endif\n-\n-  output_short_branch_defs (stream);\n-\n   if (TARGET_OCS_DEBUG_INFO)\n     PUT_OCS_FUNCTION_END (stream);\n+  epilogue_marked = 1;\n+}\n \n-  /* If the last insn was a BARRIER, we don't have to write any code.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn && GET_CODE (insn) == BARRIER)\n-    {\n-      if (current_function_epilogue_delay_list)\n-\tabort ();\n-    }\n-  else\n-    {\n-      if (frame_pointer_needed)\n-\toutput_reg_adjust (stream, 31, 30, -m88k_fp_offset, 0);\n-\n-      if (nregs || nxregs)\n-\tpreserve_registers (stream, m88k_fp_offset + 4, 0);\n+void\n+m88k_end_epilogue (stream, size)\n+     FILE *stream;\n+     int size;\n+{\n+  if (TARGET_OCS_DEBUG_INFO && !epilogue_marked)\n+    PUT_OCS_FUNCTION_END (stream);\n \n-      output_reg_adjust (stream, 31, 31, m88k_stack_size, 1);\n-    }\n+  output_short_branch_defs (stream);\n \n   fprintf (stream, \"\\n\");\n \n@@ -2015,68 +1918,54 @@ m88k_output_epilogue (stream, size)\n   m88k_prologue_done\t= 0;\t\t/* don't put out ln directives */\n   variable_args_p\t= 0;\t\t/* has variable args */\n }\n-\f\n-/* Output code to STREAM to set DSTREG to SRCREG + AMOUNT.  Issue\n-   a return instruction and use it's delay slot based on RETURN_P.  */\n \n-static void\n-output_reg_adjust (stream, dstreg, srcreg, amount, return_p)\n-     FILE *stream;\n-     int dstreg, srcreg, amount, return_p;\n+void\n+m88k_expand_epilogue ()\n {\n-  char *opname;\n-  char incr[256];\n+#if (MONITOR_GCC & 0x4) /* What are interesting prologue/epilogue values?  */\n+  fprintf (stream, \"; size = %d, m88k_fp_offset = %d, m88k_stack_size = %d\\n\",\n+\t   size, m88k_fp_offset, m88k_stack_size);\n+#endif\n \n-  if (amount < 0)\n-    {\n-      opname = \"subu\";\n-      amount = -amount;\n-    }\n-  else\n-    opname = \"addu\";\n+  if (frame_pointer_needed)\n+    emit_add (stack_pointer_rtx, frame_pointer_rtx, -m88k_fp_offset);\n \n-  if (amount == 0 && dstreg == srcreg)\n-    {\n-      if (return_p)\n-\tfprintf (stream, \"\\tjmp\\t %s\\n\", reg_names[1]);\n-      return;\n-    }\n-  else if (SMALL_INTVAL (amount))\n-    sprintf (incr, \"\\t%s\\t %s,%s,%d\", opname,\n-\t     reg_names[dstreg], reg_names[srcreg], amount);\n-  else\n+  if (nregs || nxregs)\n+    preserve_registers (m88k_fp_offset + 4, 0);\n+\n+  if (m88k_stack_size)\n+    emit_add (stack_pointer_rtx, stack_pointer_rtx, m88k_stack_size);\n+}\n+\f\n+/* Emit insns to set DSTREG to SRCREG + AMOUNT during the prologue or\n+   epilogue.  */\n+\n+static void\n+emit_add (dstreg, srcreg, amount)\n+     rtx dstreg;\n+     rtx srcreg;\n+     int amount;\n+{\n+  rtx incr = gen_rtx (CONST_INT, VOIDmode, abs (amount));\n+  if (! ADD_INTVAL (amount))\n     {\n-      rtx operands[2];\n-\n-      operands[0] = gen_rtx (REG, SImode, TEMP_REGNUM);\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, amount);\n-      output_asm_insn (output_load_const_int (SImode, operands),\n-\t\t       operands);\n-      sprintf (incr, \"\\t%s\\t %s,%s,%s\", opname,\n-\t       reg_names[dstreg], reg_names[srcreg], reg_names[TEMP_REGNUM]);\n+      rtx temp = gen_rtx (REG, SImode, TEMP_REGNUM);\n+      emit_move_insn (temp, incr);\n+      incr = temp;\n     }\n-\n-  if (!return_p)\n-    fprintf (stream, \"%s\\n\", incr);\n-  else if (flag_delayed_branch)\n-    fprintf (stream, \"\\tjmp.n\\t %s\\n%s\\n\", reg_names[1], incr);\n-  else\n-    fprintf (stream, \"%s\\n\\tjmp\\t %s\\n\", incr, reg_names[1]);\n+  emit_insn ((amount < 0 ? gen_subsi3 : gen_addsi3) (dstreg, srcreg, incr));\n }\n \n /* Save/restore the preserve registers.  base is the highest offset from\n    r31 at which a register is stored.  store_p is true if stores are to\n-   be done; otherwise loads.  When loading, output the epilogue delay\n-   insns.  */\n+   be done; otherwise loads.  */\n \n static void\n-preserve_registers (stream, base, store_p)\n-     FILE *stream;\n+preserve_registers (base, store_p)\n      int base;\n      int store_p;\n {\n   int regno, offset;\n-  char *fmt = (store_p ? \"\\tst%s\\t %s,%s,%d\\n\" : \"\\tld%s\\t %s,%s,%d\\n\");\n   struct mem_op {\n     int regno;\n     int nregs;\n@@ -2095,7 +1984,7 @@ preserve_registers (stream, base, store_p)\n \t memory ops.  */\n       if (nregs > 2 && !save_regs[FRAME_POINTER_REGNUM])\n \toffset -= 4;\n-      fprintf (stream, fmt, \"\", reg_names[1], reg_names[31], offset);\n+      emit_ldst (store_p, 1, SImode, offset);\n       offset -= 4;\n       base = offset;\n     }\n@@ -2156,71 +2045,32 @@ preserve_registers (stream, base, store_p)\n \n   mo_ptr->regno = 0;\n \n-  /* Output the delay insns interleaved with the memory operations.  */\n-  if (! store_p && current_function_epilogue_delay_list)\n-    {\n-      rtx delay_insns = current_function_epilogue_delay_list;\n-      rtx insn;\n-\n-      /* The first delay insn goes after the restore of r1.  */\n-      if (save_regs[1])\n-\t{\n-\t  final_scan_insn (XEXP (delay_insns, 0), stream, 1, 0, 1);\n-\t  delay_insns = XEXP (delay_insns, 1);\n-\t}\n-\n-      while (delay_insns)\n-\t{\n-\t  /* Find a memory operation that doesn't conflict with this insn.  */\n-\t  for (mo_ptr = mem_op; mo_ptr->regno != 0; mo_ptr++)\n-\t    {\n-\t      if (mo_ptr->nregs)\n-\t\t{\n-\t\t  int nregs = (mo_ptr->regno < FIRST_EXTENDED_REGISTER\n-\t\t\t       ? mo_ptr->nregs : 1);\n-\t\t  rtx ok_insns = delay_insns;\n-\t\t  int i;\n-\n-\t\t  for (i = 0; i < nregs; i++)\n-\t\t    epilogue_dead_regs[mo_ptr->regno + i] = 1;\n-\n-\t\t  while (ok_insns)\n-\t\t    {\n-\t\t      insn = XEXP (ok_insns, 0);\n-\t\t      ok_insns = XEXP (ok_insns, 1);\n-\n-\t\t      if (! ok_for_epilogue_p (PATTERN (insn)))\n-\t\t\t{\n-\t\t\t  for (i = 0; i < nregs; i++)\n-\t\t\t    epilogue_dead_regs[mo_ptr->regno + i] = 0;\n-\t\t\t  insn = 0;\n-\t\t\t  break; /* foreach delay insn */\n-\t\t\t}\n-\t\t    }\n-\t\t  if (insn)\n-\t\t    {\n-\t\t      fprintf (stream, fmt, mo_ptr->nregs > 1 ? \".d\" : \"\",\n-\t\t\t       reg_names[mo_ptr->regno], reg_names[31],\n-\t\t\t       mo_ptr->offset);\n-\t\t      mo_ptr->nregs = 0;\n-\t\t      break; /* foreach memory operation */\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  final_scan_insn (XEXP (delay_insns, 0), stream, 1, 0, 1);\n-\t  delay_insns = XEXP (delay_insns, 1);\n-\t}\n-    }\n-\n   /* Output the memory operations.  */\n   for (mo_ptr = mem_op; mo_ptr->regno; mo_ptr++)\n     {\n       if (mo_ptr->nregs)\n-\tfprintf (stream, fmt, mo_ptr->nregs > 1 ? \".d\" : \"\",\n-\t\t reg_names[mo_ptr->regno], reg_names[31], mo_ptr->offset);\n+\temit_ldst (store_p, mo_ptr->regno,\n+\t\t   (mo_ptr->nregs > 1 ? DImode : SImode),\n+\t\t   mo_ptr->offset);\n     }\n }\n \n+static void\n+emit_ldst (store_p, regno, mode, offset)\n+     int store_p;\n+     int regno;\n+     enum machine_mode mode;\n+     int offset;\n+{\n+  rtx reg = gen_rtx (REG, mode, regno);\n+  rtx mem = gen_rtx (MEM, mode, plus_constant (stack_pointer_rtx, offset));\n+\n+  if (store_p)\n+    emit_move_insn (mem, reg);\n+  else\n+    emit_move_insn (reg, mem);\n+}\n+\n /* Convert the address expression REG to a CFA offset.  */\n \n int\n@@ -2348,7 +2198,7 @@ output_tdesc (file, offset)\n \n   text_section ();\n }\n-\n+\f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  NAME is the mcount function name\n    (varies), SAVEP indicates whether the parameter registers need to"}]}