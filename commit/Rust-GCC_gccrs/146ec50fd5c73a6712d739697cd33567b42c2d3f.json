{"sha": "146ec50fd5c73a6712d739697cd33567b42c2d3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ2ZWM1MGZkNWM3M2E2NzEyZDczOTY5N2NkMzM1NjdiNDJjMmQzZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-09-16T19:20:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-09-16T19:20:44Z"}, "message": "Add inline functions for various bitwise operations.\n\n\t* hwint.h (least_bit_hwi, pow2_or_zerop, pow2p_hwi, ctz_or_zero):\n\tNew.\n\t* hwint.c (exact_log2): Use pow2p_hwi.\n\t(ctz_hwi, ffs_hwi): Use least_bit_hwi.\n\t* alias.c (memrefs_conflict_p): Use pow2_or_zerop.\n\t* builtins.c (get_object_alignment_2, get_object_alignment)\n\t(get_pointer_alignment, fold_builtin_atomic_always_lock_free): Use\n\tleast_bit_hwi.\n\t* calls.c (compute_argument_addresses, store_one_arg): Use\n\tleast_bit_hwi.\n\t* cfgexpand.c (expand_one_stack_var_at): Use least_bit_hwi.\n\t* combine.c (force_to_mode): Use least_bit_hwi.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos, adjust_address_1):\n\tUse least_bit_hwi.\n\t* expmed.c (synth_mult, expand_divmod): Use ctz_or_zero, ctz_hwi.\n\t(init_expmed_one_conv): Use pow2p_hwi.\n\t* fold-const.c (round_up_loc, round_down_loc): Use pow2_or_zerop.\n\t(fold_binary_loc): Use pow2p_hwi.\n\t* function.c (assign_parm_find_stack_rtl): Use least_bit_hwi.\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Use pow2p_hwi.\n\t* gimple-ssa-strength-reduction.c (replace_ref): Use least_bit_hwi.\n\t* hsa-gen.c (gen_hsa_addr_with_align, hsa_bitmemref_alignment):\n\tUse least_bit_hwi.\n\t* ipa-cp.c (ipcp_alignment_lattice::meet_with_1): Use least_bit_hwi.\n\t* ipa-prop.c (ipa_modify_call_arguments): Use least_bit_hwi.\n\t* omp-low.c (oacc_loop_fixed_partitions)\n\t(oacc_loop_auto_partitions): Use least_bit_hwi.\n\t* rtlanal.c (nonzero_bits1): Use ctz_or_zero.\n\t* stor-layout.c (place_field): Use least_bit_hwi.\n\t* tree-pretty-print.c (dump_generic_node): Use pow2p_hwi.\n\t* tree-sra.c (build_ref_for_offset): Use least_bit_hwi.\n\t* tree-ssa-ccp.c (ccp_finalize): Use least_bit_hwi.\n\t* tree-ssa-math-opts.c (bswap_replace): Use least_bit_hwi.\n\t* tree-ssa-strlen.c (handle_builtin_memcmp): Use pow2p_hwi.\n\t* tree-vect-data-refs.c (vect_analyze_group_access_1)\n\t(vect_grouped_store_supported, vect_grouped_load_supported)\n\t(vect_permute_load_chain, vect_shift_permute_load_chain)\n\t(vect_transform_grouped_load): Use pow2p_hwi.\n\t* tree-vect-generic.c (expand_vector_divmod): Use ctz_or_zero.\n\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Use ctz_or_zero.\n\t* tree-vect-stmts.c (vectorizable_mask_load_store): Use\n\tleast_bit_hwi.\n\t* tsan.c (instrument_expr): Use least_bit_hwi.\n\t* var-tracking.c (negative_power_of_two_p): Use pow2_or_zerop.\n\nFrom-SVN: r240194", "tree": {"sha": "0e81e898dacea27b3882ec8c6cf7ae31690b19d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e81e898dacea27b3882ec8c6cf7ae31690b19d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/146ec50fd5c73a6712d739697cd33567b42c2d3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/146ec50fd5c73a6712d739697cd33567b42c2d3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/146ec50fd5c73a6712d739697cd33567b42c2d3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/146ec50fd5c73a6712d739697cd33567b42c2d3f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "299910482fcd0627fe1162c1fedbcd09b5630ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299910482fcd0627fe1162c1fedbcd09b5630ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/299910482fcd0627fe1162c1fedbcd09b5630ffe"}], "stats": {"total": 272, "additions": 180, "deletions": 92}, "files": [{"sha": "660bd9580b456899e73dab6cc642245a4807c9b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1,3 +1,57 @@\n+2016-09-16  Jason Merrill  <jason@redhat.com>\n+\n+\t* hwint.h (least_bit_hwi, pow2_or_zerop, pow2p_hwi, ctz_or_zero):\n+\tNew.\n+\t* hwint.c (exact_log2): Use pow2p_hwi.\n+\t(ctz_hwi, ffs_hwi): Use least_bit_hwi.\n+\t* alias.c (memrefs_conflict_p): Use pow2_or_zerop.\n+\t* builtins.c (get_object_alignment_2, get_object_alignment)\n+\t(get_pointer_alignment, fold_builtin_atomic_always_lock_free): Use\n+\tleast_bit_hwi.\n+\t* calls.c (compute_argument_addresses, store_one_arg): Use\n+\tleast_bit_hwi.\n+\t* cfgexpand.c (expand_one_stack_var_at): Use least_bit_hwi.\n+\t* combine.c (force_to_mode): Use least_bit_hwi.\n+\t(contains_muldiv, find_split_point, combine_simplify_rtx)\n+\t(simplify_if_then_else, simplify_set, force_to_mode)\n+\t(if_then_else_cond, simplify_and_const_int_1)\n+\t(simplify_compare_const): Use pow2p_hwi.\n+\t* cse.c (fold_rtx): Use pow2p_hwi.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos, adjust_address_1):\n+\tUse least_bit_hwi.\n+\t* expmed.c (synth_mult, expand_divmod): Use ctz_or_zero, ctz_hwi.\n+\t(init_expmed_one_conv): Use pow2p_hwi.\n+\t* expr.c (is_aligning_offset): Use pow2p_hwi.\n+\t* fold-const.c (round_up_loc, round_down_loc): Use pow2_or_zerop.\n+\t(fold_binary_loc): Use pow2p_hwi.\n+\t* function.c (assign_parm_find_stack_rtl): Use least_bit_hwi.\n+\t* gimple-fold.c (gimple_fold_builtin_memory_op): Use pow2p_hwi.\n+\t* gimple-ssa-strength-reduction.c (replace_ref): Use least_bit_hwi.\n+\t* hsa-gen.c (gen_hsa_addr_with_align, hsa_bitmemref_alignment):\n+\tUse least_bit_hwi.\n+\t* ifcvt.c (noce_try_store_flag_constants): Use pow2p_hwi.\n+\t* ipa-cp.c (ipcp_alignment_lattice::meet_with_1): Use least_bit_hwi.\n+\t* ipa-prop.c (ipa_modify_call_arguments): Use least_bit_hwi.\n+\t* omp-low.c (oacc_loop_fixed_partitions)\n+\t(oacc_loop_auto_partitions): Use least_bit_hwi.\n+\t* rtlanal.c (nonzero_bits1): Use ctz_or_zero.\n+\t* stor-layout.c (place_field): Use least_bit_hwi.\n+\t* tree-pretty-print.c (dump_generic_node): Use pow2p_hwi.\n+\t* tree-sra.c (build_ref_for_offset): Use least_bit_hwi.\n+\t* tree-ssa-ccp.c (ccp_finalize): Use least_bit_hwi.\n+\t* tree-ssa-math-opts.c (bswap_replace): Use least_bit_hwi.\n+\t* tree-ssa-strlen.c (handle_builtin_memcmp): Use pow2p_hwi.\n+\t* tree-vect-data-refs.c (vect_analyze_group_access_1)\n+\t(vect_grouped_store_supported, vect_grouped_load_supported)\n+\t(vect_permute_load_chain, vect_shift_permute_load_chain)\n+\t(vect_transform_grouped_load): Use pow2p_hwi.\n+\t* tree-vect-generic.c (expand_vector_divmod): Use ctz_or_zero.\n+\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Use ctz_or_zero.\n+\t* tree-vect-stmts.c (vectorizable_mask_load_store): Use\n+\tleast_bit_hwi.\n+\t* tsan.c (instrument_expr): Use least_bit_hwi.\n+\t* var-tracking.c (negative_power_of_two_p): Use pow2_or_zerop.\n+\n 2016-09-16  Andreas Schwab  <schwab@suse.de>\n \n \t* config/ia64/ia64.h (ASM_OUTPUT_DWARF_OFFSET): Use parameter"}, {"sha": "277125e01ae641fa96dc1619c668c3767dd9fb71", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2534,7 +2534,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n     {\n       HOST_WIDE_INT sc = INTVAL (XEXP (x, 1));\n       unsigned HOST_WIDE_INT uc = sc;\n-      if (sc < 0 && -uc == (uc & -uc))\n+      if (sc < 0 && pow2_or_zerop (-uc))\n \t{\n \t  if (xsize > 0)\n \t    xsize = -xsize;\n@@ -2549,7 +2549,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n     {\n       HOST_WIDE_INT sc = INTVAL (XEXP (y, 1));\n       unsigned HOST_WIDE_INT uc = sc;\n-      if (sc < 0 && -uc == (uc & -uc))\n+      if (sc < 0 && pow2_or_zerop (-uc))\n \t{\n \t  if (ysize > 0)\n \t    ysize = -ysize;"}, {"sha": "189aeac69127b5df14bc86ff8a91e74160603171", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -305,7 +305,7 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n \t{\n \t  ptr_bitmask = TREE_INT_CST_LOW (TREE_OPERAND (addr, 1));\n \t  ptr_bitmask *= BITS_PER_UNIT;\n-\t  align = ptr_bitmask & -ptr_bitmask;\n+\t  align = least_bit_hwi (ptr_bitmask);\n \t  addr = TREE_OPERAND (addr, 0);\n \t}\n \n@@ -325,7 +325,7 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n \t      unsigned HOST_WIDE_INT step = 1;\n \t      if (TMR_STEP (exp))\n \t\tstep = TREE_INT_CST_LOW (TMR_STEP (exp));\n-\t      align = MIN (align, (step & -step) * BITS_PER_UNIT);\n+\t      align = MIN (align, least_bit_hwi (step) * BITS_PER_UNIT);\n \t    }\n \t  if (TMR_INDEX2 (exp))\n \t    align = BITS_PER_UNIT;\n@@ -404,7 +404,7 @@ get_object_alignment (tree exp)\n      ptr & (align - 1) == bitpos.  */\n \n   if (bitpos != 0)\n-    align = (bitpos & -bitpos);\n+    align = least_bit_hwi (bitpos);\n   return align;\n }\n \n@@ -502,7 +502,7 @@ get_pointer_alignment (tree exp)\n      ptr & (align - 1) == bitpos.  */\n \n   if (bitpos != 0)\n-    align = (bitpos & -bitpos);\n+    align = least_bit_hwi (bitpos);\n \n   return align;\n }\n@@ -5559,7 +5559,7 @@ fold_builtin_atomic_always_lock_free (tree arg0, tree arg1)\n \n       /* Either this argument is null, or it's a fake pointer encoding\n          the alignment of the object.  */\n-      val = val & -val;\n+      val = least_bit_hwi (val);\n       val *= BITS_PER_UNIT;\n \n       if (val == 0 || mode_align < val)"}, {"sha": "86369e9cfdc832a13599172a3b7f02827dce09c7", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1805,7 +1805,7 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t  else if (CONST_INT_P (offset))\n \t    {\n \t      align = INTVAL (offset) * BITS_PER_UNIT | boundary;\n-\t      align = align & -align;\n+\t      align = least_bit_hwi (align);\n \t    }\n \t  set_mem_align (args[i].stack, align);\n \n@@ -5026,7 +5026,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t  int pad = used - size;\n \t  if (pad)\n \t    {\n-\t      unsigned int pad_align = (pad & -pad) * BITS_PER_UNIT;\n+\t      unsigned int pad_align = least_bit_hwi (pad) * BITS_PER_UNIT;\n \t      parm_align = MIN (parm_align, pad_align);\n \t    }\n \t}\n@@ -5086,7 +5086,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t    parm_align = BITS_PER_UNIT;\n \t  else if (excess)\n \t    {\n-\t      unsigned int excess_align = (excess & -excess) * BITS_PER_UNIT;\n+\t      unsigned int excess_align = least_bit_hwi (excess) * BITS_PER_UNIT;\n \t      parm_align = MIN (parm_align, excess_align);\n \t    }\n \t}"}, {"sha": "4190f7f0aed12a85b4a2d0045a562eb95ba390fc", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1008,7 +1008,7 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n \t important, we'll simply use the alignment that is already set.  */\n       if (base == virtual_stack_vars_rtx)\n \toffset -= frame_phase;\n-      align = offset & -offset;\n+      align = least_bit_hwi (offset);\n       align *= BITS_PER_UNIT;\n       if (align == 0 || align > base_align)\n \talign = base_align;"}, {"sha": "b22a274802990133dcbb1b68ce1d49f334c515bb", "filename": "gcc/combine.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2251,7 +2251,7 @@ contains_muldiv (rtx x)\n \n     case MULT:\n       return ! (CONST_INT_P (XEXP (x, 1))\n-\t\t&& exact_log2 (UINTVAL (XEXP (x, 1))) >= 0);\n+\t\t&& pow2p_hwi (UINTVAL (XEXP (x, 1))));\n     default:\n       if (BINARY_P (x))\n \treturn contains_muldiv (XEXP (x, 0))\n@@ -5100,7 +5100,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t instead if this isn't a multiply by a power of two.  */\n       if (set_src && code == MINUS && GET_CODE (XEXP (x, 1)) == MULT\n \t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n-\t  && exact_log2 (INTVAL (XEXP (XEXP (x, 1), 1))) < 0)\n+\t  && !pow2p_hwi (INTVAL (XEXP (XEXP (x, 1), 1))))\n \t{\n \t  machine_mode mode = GET_MODE (x);\n \t  unsigned HOST_WIDE_INT this_int = INTVAL (XEXP (XEXP (x, 1), 1));\n@@ -5916,7 +5916,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t (and <foo> (const_int pow2-1))  */\n       if (GET_CODE (XEXP (x, 1)) == AND\n \t  && CONST_INT_P (XEXP (XEXP (x, 1), 1))\n-\t  && exact_log2 (-UINTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n+\t  && pow2p_hwi (-UINTVAL (XEXP (XEXP (x, 1), 1)))\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n \treturn simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n \t\t\t\t       -INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n@@ -6236,7 +6236,7 @@ simplify_if_then_else (rtx x)\n \t not equal to zero.  Similarly if it is known to be -1 or 0.  */\n \n       if (true_code == EQ && true_val == const0_rtx\n-\t  && exact_log2 (nzb = nonzero_bits (from, GET_MODE (from))) >= 0)\n+\t  && pow2p_hwi (nzb = nonzero_bits (from, GET_MODE (from))))\n \t{\n \t  false_code = EQ;\n \t  false_val = gen_int_mode (nzb, GET_MODE (from));\n@@ -6673,7 +6673,7 @@ simplify_set (rtx x)\n \t       || (old_code == EQ && new_code == NE))\n \t      && ! other_changed_previously && op1 == const0_rtx\n \t      && HWI_COMPUTABLE_MODE_P (GET_MODE (op0))\n-\t      && exact_log2 (mask = nonzero_bits (op0, GET_MODE (op0))) >= 0)\n+\t      && pow2p_hwi (mask = nonzero_bits (op0, GET_MODE (op0))))\n \t    {\n \t      rtx pat = PATTERN (other_insn), note = 0;\n \n@@ -8525,7 +8525,7 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  smask |= HOST_WIDE_INT_M1U << width;\n \n \tif (CONST_INT_P (XEXP (x, 1))\n-\t    && exact_log2 (- smask) >= 0\n+\t    && pow2p_hwi (- smask)\n \t    && (nonzero_bits (XEXP (x, 0), mode) & ~smask) == 0\n \t    && (INTVAL (XEXP (x, 1)) & ~smask) != 0)\n \t  return force_to_mode (plus_constant (GET_MODE (x), XEXP (x, 0),\n@@ -8557,7 +8557,7 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* If X is (minus C Y) where C's least set bit is larger than any bit\n \t in the mask, then we may replace with (neg Y).  */\n       if (CONST_INT_P (XEXP (x, 0))\n-\t  && ((UINTVAL (XEXP (x, 0)) & -UINTVAL (XEXP (x, 0))) > mask))\n+\t  && least_bit_hwi (UINTVAL (XEXP (x, 0))) > mask)\n \t{\n \t  x = simplify_gen_unary (NEG, GET_MODE (x), XEXP (x, 1),\n \t\t\t\t  GET_MODE (x));\n@@ -8701,7 +8701,7 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  && ((INTVAL (XEXP (x, 1))\n \t       + num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0))))\n \t      >= GET_MODE_PRECISION (GET_MODE (x)))\n-\t  && exact_log2 (mask + 1) >= 0\n+\t  && pow2p_hwi (mask + 1)\n \t  /* Number of bits left after the shift must be more than the mask\n \t     needs.  */\n \t  && ((INTVAL (XEXP (x, 1)) + exact_log2 (mask + 1))\n@@ -8875,7 +8875,7 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n       if ((mask & ~STORE_FLAG_VALUE) == 0\n \t  && XEXP (x, 1) == const0_rtx\n \t  && GET_MODE (XEXP (x, 0)) == mode\n-\t  && exact_log2 (nonzero_bits (XEXP (x, 0), mode)) >= 0\n+\t  && pow2p_hwi (nonzero_bits (XEXP (x, 0), mode))\n \t  && (nonzero_bits (XEXP (x, 0), mode)\n \t      == (unsigned HOST_WIDE_INT) STORE_FLAG_VALUE))\n \treturn force_to_mode (XEXP (x, 0), mode, mask, next_select);\n@@ -9105,7 +9105,7 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \n   /* Likewise for 0 or a single bit.  */\n   else if (HWI_COMPUTABLE_MODE_P (mode)\n-\t   && exact_log2 (nz = nonzero_bits (x, mode)) >= 0)\n+\t   && pow2p_hwi (nz = nonzero_bits (x, mode)))\n     {\n       *ptrue = gen_int_mode (nz, mode), *pfalse = const0_rtx;\n       return x;\n@@ -9793,7 +9793,7 @@ simplify_and_const_int_1 (machine_mode mode, rtx varop,\n      may eliminate it.  */\n \n   if (GET_CODE (varop) == PLUS\n-      && exact_log2 (constop + 1) >= 0)\n+      && pow2p_hwi (constop + 1))\n     {\n       rtx o0, o1;\n \n@@ -11335,7 +11335,7 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       && (code == EQ || code == NE || code == GE || code == GEU\n \t  || code == LT || code == LTU)\n       && mode_width - 1 < HOST_BITS_PER_WIDE_INT\n-      && exact_log2 (const_op & GET_MODE_MASK (mode)) >= 0\n+      && pow2p_hwi (const_op & GET_MODE_MASK (mode))\n       && (nonzero_bits (op0, mode)\n \t  == (unsigned HOST_WIDE_INT) (const_op & GET_MODE_MASK (mode))))\n     {"}, {"sha": "1b5140fe3d0f6398ab6aca3c9a133b3875faddee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1,3 +1,10 @@\n+2016-09-16  Jason Merrill  <jason@redhat.com>\n+\n+\t* class.c (check_bases, set_one_vmethod_tm_attributes): Use\n+\tleast_bit_hwi.\n+\t* decl.c (cxx_init_decl_processing): Use pow2p_hwi.\n+\t* parser.c (cp_parser_cilk_simd_vectorlength): Use pow2p_hwi.\n+\n 2016-09-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/77549"}, {"sha": "150f46f6e19dffb1c58d358105f3f8819f8b5ae1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1843,7 +1843,7 @@ check_bases (tree t,\n      doesn't define its own, then the current class inherits one.  */\n   if (seen_tm_mask && !find_tm_attribute (TYPE_ATTRIBUTES (t)))\n     {\n-      tree tm_attr = tm_mask_to_attr (seen_tm_mask & -seen_tm_mask);\n+      tree tm_attr = tm_mask_to_attr (least_bit_hwi (seen_tm_mask));\n       TYPE_ATTRIBUTES (t) = tree_cons (tm_attr, NULL, TYPE_ATTRIBUTES (t));\n     }\n }\n@@ -5074,7 +5074,7 @@ set_one_vmethod_tm_attributes (tree type, tree fndecl)\n      restrictive one.  */\n   else if (tm_attr == NULL)\n     {\n-      apply_tm_attr (fndecl, tm_mask_to_attr (found & -found));\n+      apply_tm_attr (fndecl, tm_mask_to_attr (least_bit_hwi (found)));\n     }\n   /* Otherwise validate that we're not weaker than a function\n      that is being overridden.  */"}, {"sha": "2f444656842ea164901936140f5c59f4584f9677", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -4133,7 +4133,7 @@ cxx_init_decl_processing (void)\n   current_lang_name = lang_name_cplusplus;\n \n   if (aligned_new_threshhold > 1\n-      && exact_log2 (aligned_new_threshhold) == -1)\n+      && !pow2p_hwi (aligned_new_threshhold))\n     {\n       error (\"-faligned-new=%d is not a power of two\", aligned_new_threshhold);\n       aligned_new_threshhold = 1;"}, {"sha": "fb88021e23763eb428fe9cc8f7694e2f79e22966", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -37753,7 +37753,7 @@ cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses,\n \t   || !INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n     error_at (loc, \"vectorlength must be an integer constant\");\n   else if (TREE_CONSTANT (expr)\n-\t   && exact_log2 (TREE_INT_CST_LOW (expr)) == -1)\n+\t   && !pow2p_hwi (TREE_INT_CST_LOW (expr)))\n     error_at (loc, \"vectorlength must be a power of 2\");\n   else \n     {"}, {"sha": "99949f0abd5896b8b2198a224d796fcbedd152fc", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -3643,13 +3643,13 @@ fold_rtx (rtx x, rtx_insn *insn)\n \n \t      if (code == PLUS && const_arg1 == inner_const\n \t\t  && ((HAVE_PRE_INCREMENT\n-\t\t\t  && exact_log2 (INTVAL (const_arg1)) >= 0)\n+\t\t\t  && pow2p_hwi (INTVAL (const_arg1)))\n \t\t      || (HAVE_POST_INCREMENT\n-\t\t\t  && exact_log2 (INTVAL (const_arg1)) >= 0)\n+\t\t\t  && pow2p_hwi (INTVAL (const_arg1)))\n \t\t      || (HAVE_PRE_DECREMENT\n-\t\t\t  && exact_log2 (- INTVAL (const_arg1)) >= 0)\n+\t\t\t  && pow2p_hwi (- INTVAL (const_arg1)))\n \t\t      || (HAVE_POST_DECREMENT\n-\t\t\t  && exact_log2 (- INTVAL (const_arg1)) >= 0)))\n+\t\t\t  && pow2p_hwi (- INTVAL (const_arg1)))))\n \t\tbreak;\n \n \t      /* ??? Vector mode shifts by scalar"}, {"sha": "9e0bda2cc4196e0c2533051caeec800a677b8146", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1964,7 +1964,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       get_object_alignment_1 (t, &obj_align, &obj_bitpos);\n       obj_bitpos = (obj_bitpos - bitpos) & (obj_align - 1);\n       if (obj_bitpos != 0)\n-\tobj_align = (obj_bitpos & -obj_bitpos);\n+\tobj_align = least_bit_hwi (obj_bitpos);\n       attrs.align = MAX (attrs.align, obj_align);\n     }\n \n@@ -2298,7 +2298,7 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n      if zero.  */\n   if (offset != 0)\n     {\n-      max_align = (offset & -offset) * BITS_PER_UNIT;\n+      max_align = least_bit_hwi (offset) * BITS_PER_UNIT;\n       attrs.align = MIN (attrs.align, max_align);\n     }\n "}, {"sha": "2f789a2f07539ea0207d8deea20375fa37c07d92", "filename": "gcc/expmed.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -127,10 +127,10 @@ init_expmed_one_conv (struct init_expmed_rtl *all, machine_mode to_mode,\n      comparison purposes here, reduce the bit size by one in that\n      case.  */\n   if (GET_MODE_CLASS (to_mode) == MODE_PARTIAL_INT\n-      && exact_log2 (to_size) != -1)\n+      && pow2p_hwi (to_size))\n     to_size --;\n   if (GET_MODE_CLASS (from_mode) == MODE_PARTIAL_INT\n-      && exact_log2 (from_size) != -1)\n+      && pow2p_hwi (from_size))\n     from_size --;\n   \n   /* Assume cost of zero-extend and sign-extend is the same.  */\n@@ -2635,7 +2635,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   if ((t & 1) == 0)\n     {\n     do_alg_shift:\n-      m = floor_log2 (t & -t);\t/* m = number of low zero bits */\n+      m = ctz_or_zero (t); /* m = number of low zero bits */\n       if (m < maxm)\n \t{\n \t  q = t >> m;\n@@ -2872,9 +2872,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n     {\n     do_alg_add_t2_m:\n       q = t - 1;\n-      q = q & -q;\n-      m = exact_log2 (q);\n-      if (m >= 0 && m < maxm)\n+      m = ctz_hwi (q);\n+      if (q && m < maxm)\n \t{\n \t  op_cost = shiftadd_cost (speed, mode, m);\n \t  new_limit.cost = best_cost.cost - op_cost;\n@@ -2896,9 +2895,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \n     do_alg_sub_t2_m:\n       q = t + 1;\n-      q = q & -q;\n-      m = exact_log2 (q);\n-      if (m >= 0 && m < maxm)\n+      m = ctz_hwi (q);\n+      if (q && m < maxm)\n \t{\n \t  op_cost = shiftsub0_cost (speed, mode, m);\n \t  new_limit.cost = best_cost.cost - op_cost;\n@@ -4214,7 +4212,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t   initial right shift.  */\n \t\t\tif (mh != 0 && (d & 1) == 0)\n \t\t\t  {\n-\t\t\t    pre_shift = floor_log2 (d & -d);\n+\t\t\t    pre_shift = ctz_or_zero (d);\n \t\t\t    mh = choose_multiplier (d >> pre_shift, size,\n \t\t\t\t\t\t    size - pre_shift,\n \t\t\t\t\t\t    &ml, &post_shift, &dummy);\n@@ -4872,7 +4870,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t    int pre_shift;\n \t    rtx t1;\n \n-\t    pre_shift = floor_log2 (d & -d);\n+\t    pre_shift = ctz_or_zero (d);\n \t    ml = invert_mod2n (d >> pre_shift, size);\n \t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t       pre_shift, NULL_RTX, unsignedp);"}, {"sha": "73e000efca65351c7c2cc7e1a4a9e58c9f0dfcbe", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -11065,7 +11065,7 @@ is_aligning_offset (const_tree offset, const_tree exp)\n       || !tree_fits_uhwi_p (TREE_OPERAND (offset, 1))\n       || compare_tree_int (TREE_OPERAND (offset, 1),\n \t\t\t   BIGGEST_ALIGNMENT / BITS_PER_UNIT) <= 0\n-      || exact_log2 (tree_to_uhwi (TREE_OPERAND (offset, 1)) + 1) < 0)\n+      || !pow2p_hwi (tree_to_uhwi (TREE_OPERAND (offset, 1)) + 1))\n     return 0;\n \n   /* Look at the first operand of BIT_AND_EXPR and strip any conversion."}, {"sha": "e040b2a279b206b23c1dcfd5bd7f68d26df91324", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -10006,7 +10006,7 @@ fold_binary_loc (location_t loc,\n \t         mode which allows further optimizations.  */\n \t      int pop = wi::popcount (warg1);\n \t      if (!(pop >= BITS_PER_UNIT\n-\t\t    && exact_log2 (pop) != -1\n+\t\t    && pow2p_hwi (pop)\n \t\t    && wi::mask (pop, false, warg1.get_precision ()) == warg1))\n \t\treturn fold_build2_loc (loc, code, type, op0,\n \t\t\t\t\twide_int_to_tree (type, masked));\n@@ -14252,7 +14252,7 @@ round_up_loc (location_t loc, tree value, unsigned int divisor)\n     }\n \n   /* If divisor is a power of two, simplify this to bit manipulation.  */\n-  if (divisor == (divisor & -divisor))\n+  if (pow2_or_zerop (divisor))\n     {\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n@@ -14315,7 +14315,7 @@ round_down_loc (location_t loc, tree value, int divisor)\n     }\n \n   /* If divisor is a power of two, simplify this to bit manipulation.  */\n-  if (divisor == (divisor & -divisor))\n+  if (pow2_or_zerop (divisor))\n     {\n       tree t;\n "}, {"sha": "94ed786dbc7183e564b78a26ded08f441b39faf3", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2716,7 +2716,7 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n   else if (CONST_INT_P (offset_rtx))\n     {\n       align = INTVAL (offset_rtx) * BITS_PER_UNIT | boundary;\n-      align = align & -align;\n+      align = least_bit_hwi (align);\n     }\n   set_mem_align (stack_parm, align);\n "}, {"sha": "2e0bd806987d51dacf37c72e0cbe79005c55f50c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -699,7 +699,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t  && !c_strlen (src, 2))\n \t{\n \t  unsigned ilen = tree_to_uhwi (len);\n-\t  if (exact_log2 (ilen) != -1)\n+\t  if (pow2p_hwi (ilen))\n \t    {\n \t      tree type = lang_hooks.types.type_for_size (ilen * 8, 1);\n \t      if (type"}, {"sha": "68115ee7896c438a04afc2e44c34dd497129ffec", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1874,7 +1874,7 @@ replace_ref (tree *expr, slsr_cand_t c)\n      requirement for the data type.  See PR58041.  */\n   get_object_alignment_1 (*expr, &align, &misalign);\n   if (misalign != 0)\n-    align = (misalign & -misalign);\n+    align = least_bit_hwi (misalign);\n   if (align < TYPE_ALIGN (acc_type))\n     acc_type = build_aligned_type (acc_type, align);\n "}, {"sha": "4d1b2767441cfea3a947dad21baa2ca5062a357c", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2207,7 +2207,7 @@ gen_hsa_addr_with_align (tree ref, hsa_bb *hbb, BrigAlignment8_t *output_align)\n       unsigned align = hsa_byte_alignment (addr->m_symbol->m_align);\n       unsigned misalign = addr->m_imm_offset & (align - 1);\n       if (misalign)\n-        align = (misalign & -misalign);\n+        align = least_bit_hwi (misalign);\n       *output_align = hsa_alignment_encoding (BITS_PER_UNIT * align);\n     }\n   return addr;\n@@ -2434,7 +2434,7 @@ hsa_bitmemref_alignment (tree ref)\n   BrigAlignment8_t base = hsa_object_alignment (ref);\n   if (byte_bits == 0)\n     return base;\n-  return MIN (base, hsa_alignment_encoding (byte_bits & -byte_bits));\n+  return MIN (base, hsa_alignment_encoding (least_bit_hwi (byte_bits)));\n }\n \n /* Generate HSAIL instructions loading something into register DEST.  RHS is"}, {"sha": "53730285dd7a6d72ee447e468c5563286011b895", "filename": "gcc/hwint.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fhwint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fhwint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -74,7 +74,7 @@ ceil_log2 (unsigned HOST_WIDE_INT x)\n int\n exact_log2 (unsigned HOST_WIDE_INT x)\n {\n-  if (x != (x & -x))\n+  if (!pow2p_hwi (x))\n     return -1;\n   return floor_log2 (x);\n }\n@@ -85,7 +85,7 @@ exact_log2 (unsigned HOST_WIDE_INT x)\n int\n ctz_hwi (unsigned HOST_WIDE_INT x)\n {\n-  return x ? floor_log2 (x & -x) : HOST_BITS_PER_WIDE_INT;\n+  return x ? floor_log2 (least_bit_hwi (x)) : HOST_BITS_PER_WIDE_INT;\n }\n \n /* Similarly for most significant bits.  */\n@@ -102,7 +102,7 @@ clz_hwi (unsigned HOST_WIDE_INT x)\n int\n ffs_hwi (unsigned HOST_WIDE_INT x)\n {\n-  return 1 + floor_log2 (x & -x);\n+  return 1 + floor_log2 (least_bit_hwi (x));\n }\n \n /* Return the number of set bits in X.  */"}, {"sha": "ea87b2158b1f708ea0baf0b219678505bcc724d9", "filename": "gcc/hwint.h", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -134,6 +134,31 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n #endif\n \n /* Inline functions operating on HOST_WIDE_INT.  */\n+\n+/* Return X with all but the lowest bit masked off.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+least_bit_hwi (unsigned HOST_WIDE_INT x)\n+{\n+  return (x & -x);\n+}\n+\n+/* True if X is zero or a power of two.  */\n+\n+static inline bool\n+pow2_or_zerop (unsigned HOST_WIDE_INT x)\n+{\n+  return least_bit_hwi (x) == x;\n+}\n+\n+/* True if X is a power of two.  */\n+\n+static inline bool\n+pow2p_hwi (unsigned HOST_WIDE_INT x)\n+{\n+  return x && pow2_or_zerop (x);\n+}\n+\n #if GCC_VERSION < 3004\n \n extern int clz_hwi (unsigned HOST_WIDE_INT x);\n@@ -222,7 +247,7 @@ ceil_log2 (unsigned HOST_WIDE_INT x)\n static inline int\n exact_log2 (unsigned HOST_WIDE_INT x)\n {\n-  return x == (x & -x) && x ? ctz_hwi (x) : -1;\n+  return pow2p_hwi (x) ? ctz_hwi (x) : -1;\n }\n \n #endif /* GCC_VERSION >= 3004 */\n@@ -238,6 +263,14 @@ extern HOST_WIDE_INT pos_mul_hwi (HOST_WIDE_INT, HOST_WIDE_INT);\n extern HOST_WIDE_INT mul_hwi (HOST_WIDE_INT, HOST_WIDE_INT);\n extern HOST_WIDE_INT least_common_multiple (HOST_WIDE_INT, HOST_WIDE_INT);\n \n+/* Like ctz_hwi, except 0 when x == 0.  */\n+\n+static inline int\n+ctz_or_zero (unsigned HOST_WIDE_INT x)\n+{\n+  return ffs_hwi (x) - 1;\n+}\n+\n /* Sign extend SRC starting from PREC.  */\n \n static inline HOST_WIDE_INT"}, {"sha": "24542f008485e6c28e068030fa301f2ce040efc1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1417,11 +1417,11 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \t    gcc_unreachable ();\n \t}\n       /* Is this (cond) ? 2^n : 0?  */\n-      else if (ifalse == 0 && exact_log2 (itrue) >= 0\n+      else if (ifalse == 0 && pow2p_hwi (itrue)\n \t       && STORE_FLAG_VALUE == 1)\n \tnormalize = 1;\n       /* Is this (cond) ? 0 : 2^n?  */\n-      else if (itrue == 0 && exact_log2 (ifalse) >= 0 && can_reverse\n+      else if (itrue == 0 && pow2p_hwi (ifalse) && can_reverse\n \t       && STORE_FLAG_VALUE == 1)\n \t{\n \t  normalize = 1;"}, {"sha": "60fcd023bf80f27ca68ed20ffbd4652e9a95d557", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -929,7 +929,7 @@ ipcp_alignment_lattice::meet_with_1 (unsigned new_align, unsigned new_misalign)\n   if (misalign != (new_misalign % align))\n     {\n       int diff = abs ((int) misalign - (int) (new_misalign % align));\n-      align = (unsigned) diff & -diff;\n+      align = least_bit_hwi (diff);\n       if (align)\n \tmisalign = misalign % align;\n       else"}, {"sha": "b86a4a0621813d3986edf28932b03de28905ec01", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -4170,7 +4170,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t\t\t   * BITS_PER_UNIT);\n \t      misalign = misalign & (align - 1);\n \t      if (misalign != 0)\n-\t\talign = (misalign & -misalign);\n+\t\talign = least_bit_hwi (misalign);\n \t      if (align < TYPE_ALIGN (type))\n \t\ttype = build_aligned_type (type, align);\n \t      base = force_gimple_operand_gsi (&gsi, base,"}, {"sha": "bf52d849d9e345fa6db82ce5fc9cdfc290d066bc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -19452,7 +19452,7 @@ oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n     }\n   else\n     {\n-      unsigned outermost = this_mask & -this_mask;\n+      unsigned outermost = least_bit_hwi (this_mask);\n \n       if (outermost && outermost <= outer_mask)\n \t{\n@@ -19533,7 +19533,7 @@ oacc_loop_auto_partitions (oacc_loop *loop, unsigned outer_mask)\n       \n       /* Determine the outermost partitioning used within this loop. */\n       this_mask = loop->inner | GOMP_DIM_MASK (GOMP_DIM_MAX);\n-      this_mask = (this_mask & -this_mask);\n+      this_mask = least_bit_hwi (this_mask);\n \n       /* Pick the partitioning just inside that one.  */\n       this_mask >>= 1;"}, {"sha": "470c143fcf2b02df3d016c394d636201ba3f82fc", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -4483,8 +4483,8 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \tint sign_index = GET_MODE_PRECISION (GET_MODE (x)) - 1;\n \tint width0 = floor_log2 (nz0) + 1;\n \tint width1 = floor_log2 (nz1) + 1;\n-\tint low0 = floor_log2 (nz0 & -nz0);\n-\tint low1 = floor_log2 (nz1 & -nz1);\n+\tint low0 = ctz_or_zero (nz0);\n+\tint low1 = ctz_or_zero (nz1);\n \tunsigned HOST_WIDE_INT op0_maybe_minusp\n \t  = nz0 & (HOST_WIDE_INT_1U << sign_index);\n \tunsigned HOST_WIDE_INT op1_maybe_minusp"}, {"sha": "07eac87490892c4cfaa0ec3c17ccbd75f33f06c1", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1169,14 +1169,12 @@ place_field (record_layout_info rli, tree field)\n   /* Work out the known alignment so far.  Note that A & (-A) is the\n      value of the least-significant bit in A that is one.  */\n   if (! integer_zerop (rli->bitpos))\n-    known_align = (tree_to_uhwi (rli->bitpos)\n-\t\t   & - tree_to_uhwi (rli->bitpos));\n+    known_align = least_bit_hwi (tree_to_uhwi (rli->bitpos));\n   else if (integer_zerop (rli->offset))\n     known_align = 0;\n   else if (tree_fits_uhwi_p (rli->offset))\n     known_align = (BITS_PER_UNIT\n-\t\t   * (tree_to_uhwi (rli->offset)\n-\t\t      & - tree_to_uhwi (rli->offset)));\n+\t\t   * least_bit_hwi (tree_to_uhwi (rli->offset)));\n   else\n     known_align = rli->offset_align;\n \n@@ -1479,14 +1477,12 @@ place_field (record_layout_info rli, tree field)\n      approximate this by seeing if its position changed), lay out the field\n      again; perhaps we can use an integral mode for it now.  */\n   if (! integer_zerop (DECL_FIELD_BIT_OFFSET (field)))\n-    actual_align = (tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field))\n-\t\t    & - tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field)));\n+    actual_align = least_bit_hwi (tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field)));\n   else if (integer_zerop (DECL_FIELD_OFFSET (field)))\n     actual_align = MAX (BIGGEST_ALIGNMENT, rli->record_align);\n   else if (tree_fits_uhwi_p (DECL_FIELD_OFFSET (field)))\n     actual_align = (BITS_PER_UNIT\n-\t\t   * (tree_to_uhwi (DECL_FIELD_OFFSET (field))\n-\t\t      & - tree_to_uhwi (DECL_FIELD_OFFSET (field))));\n+\t\t    * least_bit_hwi (tree_to_uhwi (DECL_FIELD_OFFSET (field))));\n   else\n     actual_align = DECL_OFFSET_ALIGN (field);\n   /* ACTUAL_ALIGN is still the actual alignment *within the record* ."}, {"sha": "0915fd4243e578ff179f36929c516302132f174d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1353,7 +1353,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n \t\t\t\t      ? \"unsigned long long\"\n \t\t\t\t      : \"signed long long\"));\n \t\telse if (TYPE_PRECISION (node) >= CHAR_TYPE_SIZE\n-\t\t\t && exact_log2 (TYPE_PRECISION (node)) != -1)\n+\t\t\t && pow2p_hwi (TYPE_PRECISION (node)))\n \t\t  {\n \t\t    pp_string (pp, (TYPE_UNSIGNED (node) ? \"uint\" : \"int\"));\n \t\t    pp_decimal_int (pp, TYPE_PRECISION (node));"}, {"sha": "4a2ff0d174c200715b031e6117b403b56c272f65", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1680,7 +1680,7 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n \n   misalign = (misalign + offset) & (align - 1);\n   if (misalign != 0)\n-    align = (misalign & -misalign);\n+    align = least_bit_hwi (misalign);\n   if (align != TYPE_ALIGN (exp_type))\n     exp_type = build_aligned_type (exp_type, align);\n "}, {"sha": "b6ccb59d2414b9aa0bb5aaf710cecd7a7f74007f", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -928,7 +928,7 @@ ccp_finalize (bool nonzero_p)\n \t  /* Trailing mask bits specify the alignment, trailing value\n \t     bits the misalignment.  */\n \t  tem = val->mask.to_uhwi ();\n-\t  align = (tem & -tem);\n+\t  align = least_bit_hwi (tem);\n \t  if (align > 1)\n \t    set_ptr_info_alignment (get_ptr_info (name), align,\n \t\t\t\t    (TREE_INT_CST_LOW (val->value)"}, {"sha": "0cea1a8472d5d9c4f0e4a7bd82930e201948c4ec", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2647,7 +2647,7 @@ bswap_replace (gimple *cur_stmt, gimple *src_stmt, tree fndecl,\n \t      unsigned HOST_WIDE_INT l\n \t\t= (load_offset * BITS_PER_UNIT) & (align - 1);\n \t      if (l)\n-\t\talign = l & -l;\n+\t\talign = least_bit_hwi (l);\n \t    }\n \t}\n "}, {"sha": "339812e91c0d212628c8ed235b389cd8ec102a19", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1983,7 +1983,7 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n \n   if (tree_fits_uhwi_p (len)\n       && (leni = tree_to_uhwi (len)) <= GET_MODE_SIZE (word_mode)\n-      && exact_log2 (leni) != -1)\n+      && pow2p_hwi (leni))\n     {\n       leni *= CHAR_TYPE_SIZE;\n       unsigned align1 = get_pointer_alignment (arg1);"}, {"sha": "03c4a66103e2da8ea88f7d826a5187a68d8816fd", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2241,7 +2241,7 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n       if (DR_IS_READ (dr)\n \t  && (dr_step % type_size) == 0\n \t  && groupsize > 0\n-\t  && exact_log2 (groupsize) != -1)\n+\t  && pow2p_hwi (groupsize))\n \t{\n \t  GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = stmt;\n \t  GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n@@ -4736,7 +4736,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n       else\n \t{\n \t  /* If length is not equal to 3 then only power of 2 is supported.  */\n-\t  gcc_assert (exact_log2 (count) != -1);\n+\t  gcc_assert (pow2p_hwi (count));\n \n \t  for (i = 0; i < nelt / 2; i++)\n \t    {\n@@ -4914,7 +4914,7 @@ vect_permute_store_chain (vec<tree> dr_chain,\n   else\n     {\n       /* If length is not equal to 3 then only power of 2 is supported.  */\n-      gcc_assert (exact_log2 (length) != -1);\n+      gcc_assert (pow2p_hwi (length));\n \n       for (i = 0, n = nelt / 2; i < n; i++)\n \t{\n@@ -5309,7 +5309,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n       else\n \t{\n \t  /* If length is not equal to 3 then only power of 2 is supported.  */\n-\t  gcc_assert (exact_log2 (count) != -1);\n+\t  gcc_assert (pow2p_hwi (count));\n \t  for (i = 0; i < nelt; i++)\n \t    sel[i] = i * 2;\n \t  if (can_vec_perm_p (mode, false, sel))\n@@ -5483,7 +5483,7 @@ vect_permute_load_chain (vec<tree> dr_chain,\n   else\n     {\n       /* If length is not equal to 3 then only power of 2 is supported.  */\n-      gcc_assert (exact_log2 (length) != -1);\n+      gcc_assert (pow2p_hwi (length));\n \n       for (i = 0; i < nelt; ++i)\n \tsel[i] = i * 2;\n@@ -5632,7 +5632,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n   memcpy (result_chain->address (), dr_chain.address (),\n \t  length * sizeof (tree));\n \n-  if (exact_log2 (length) != -1 && LOOP_VINFO_VECT_FACTOR (loop_vinfo) > 4)\n+  if (pow2p_hwi (length) && LOOP_VINFO_VECT_FACTOR (loop_vinfo) > 4)\n     {\n       unsigned int j, log_length = exact_log2 (length);\n       for (i = 0; i < nelt / 2; ++i)\n@@ -5880,7 +5880,7 @@ vect_transform_grouped_load (gimple *stmt, vec<tree> dr_chain, int size,\n      get chain for loads group using vect_shift_permute_load_chain.  */\n   mode = TYPE_MODE (STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt)));\n   if (targetm.sched.reassociation_width (VEC_PERM_EXPR, mode) > 1\n-      || exact_log2 (size) != -1\n+      || pow2p_hwi (size)\n       || !vect_shift_permute_load_chain (dr_chain, size, stmt,\n \t\t\t\t\t gsi, &result_chain))\n     vect_permute_load_chain (dr_chain, size, stmt, gsi, &result_chain);"}, {"sha": "5d4273fcd0eb7ae6781cdc9a321a74d774b11b8e", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -494,7 +494,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t      || (!has_vector_shift && pre_shift != -1))\n \t    {\n \t      if (has_vector_shift)\n-\t\tpre_shift = floor_log2 (d & -d);\n+\t\tpre_shift = ctz_or_zero (d);\n \t      else if (pre_shift == -1)\n \t\t{\n \t\t  unsigned int j;"}, {"sha": "3dfbc7bb63dece204986826f58cecef5faa87a86", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2736,7 +2736,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \t for even divisors, using an initial right shift.  */\n       if (mh != 0 && (d & 1) == 0)\n \t{\n-\t  pre_shift = floor_log2 (d & -d);\n+\t  pre_shift = ctz_or_zero (d);\n \t  mh = choose_multiplier (d >> pre_shift, prec, prec - pre_shift,\n \t\t\t\t  &ml, &post_shift, &dummy_int);\n \t  gcc_assert (!mh);"}, {"sha": "a83071c1a700bb27754f7582588d1a9a6cf0d488", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2340,7 +2340,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  set_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n \t\t\t\t  misalign);\n \t  tree ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)),\n-\t\t\t\t    misalign ? misalign & -misalign : align);\n+\t\t\t\t    misalign ? least_bit_hwi (misalign) : align);\n \t  new_stmt\n \t    = gimple_build_call_internal (IFN_MASK_STORE, 4, dataref_ptr,\n \t\t\t\t\t  ptr, vec_mask, vec_rhs);\n@@ -2390,7 +2390,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  set_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n \t\t\t\t  misalign);\n \t  tree ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)),\n-\t\t\t\t    misalign ? misalign & -misalign : align);\n+\t\t\t\t    misalign ? least_bit_hwi (misalign) : align);\n \t  new_stmt\n \t    = gimple_build_call_internal (IFN_MASK_LOAD, 3, dataref_ptr,\n \t\t\t\t\t  ptr, vec_mask);"}, {"sha": "aba21f81bd66627c4ea221736c80d4aa15235b17", "filename": "gcc/tsan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -175,7 +175,7 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n       if ((align - 1) & bitpos)\n \t{\n \t  align = (align - 1) & bitpos;\n-\t  align = align & -align;\n+\t  align = least_bit_hwi (align);\n \t}\n       expr = build_fold_addr_expr (unshare_expr (base));\n       expr = build2 (MEM_REF, char_type_node, expr,"}, {"sha": "07b3e079aaa8f7d925b942ccdb4cdbede3e0df3e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -1983,7 +1983,7 @@ static bool\n negative_power_of_two_p (HOST_WIDE_INT i)\n {\n   unsigned HOST_WIDE_INT x = -(unsigned HOST_WIDE_INT)i;\n-  return x == (x & -x);\n+  return pow2_or_zerop (x);\n }\n \n /* Strip constant offsets and alignments off of LOC.  Return the base"}, {"sha": "ba866ce8044c9a9ffd9d16000aaedea815605bb0", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/146ec50fd5c73a6712d739697cd33567b42c2d3f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=146ec50fd5c73a6712d739697cd33567b42c2d3f", "patch": "@@ -2632,7 +2632,7 @@ assemble_trampoline_template (void)\n static inline unsigned\n min_align (unsigned int a, unsigned int b)\n {\n-  return (a | b) & -(a | b);\n+  return least_bit_hwi (a | b);\n }\n \n /* Return the assembler directive for creating a given kind of integer"}]}