{"sha": "5f02387d745a334a9bce1df61e6193cf110b425f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYwMjM4N2Q3NDVhMzM0YTliY2UxZGY2MWU2MTkzY2YxMTBiNDI1Zg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-03-23T01:56:12Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-03-23T01:56:12Z"}, "message": "refactor emit_*_{after,before}_noloc using common functions\n\nrefactor emit_*_{after,before}_noloc using common functions\n\t* emit-rtl.c (emit_pattern_before_noloc): New function.\n\t(emit_insn_before_noloc, emit_jump_insn_before_noloc): Call it.\n\t(emit_call_insn_before_noloc, emit_debug_insn_before_noloc): Likewise.\n\t(emit_pattern_after_noloc): New function.\n\t(emit_insn_after_noloc, emit_jump_insn_after_noloc): Call it.\n\t(emit_call_insn_after_noloc, emit_debug_insn_after_noloc): Likewise.\n\nFrom-SVN: r171339", "tree": {"sha": "898e364063c7140cb2fd979e014de3648e422e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/898e364063c7140cb2fd979e014de3648e422e48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f02387d745a334a9bce1df61e6193cf110b425f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f02387d745a334a9bce1df61e6193cf110b425f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f02387d745a334a9bce1df61e6193cf110b425f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f02387d745a334a9bce1df61e6193cf110b425f/comments", "author": null, "committer": null, "parents": [{"sha": "fdf3e18a143c7e5a40f0466fa910f49df9632db2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdf3e18a143c7e5a40f0466fa910f49df9632db2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdf3e18a143c7e5a40f0466fa910f49df9632db2"}], "stats": {"total": 250, "additions": 43, "deletions": 207}, "files": [{"sha": "6b5c14c5d06239628bd0c0f0740ec498505b0845", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f02387d745a334a9bce1df61e6193cf110b425f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f02387d745a334a9bce1df61e6193cf110b425f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f02387d745a334a9bce1df61e6193cf110b425f", "patch": "@@ -1,3 +1,12 @@\n+2011-03-22  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* emit-rtl.c (emit_pattern_before_noloc): New function.\n+\t(emit_insn_before_noloc, emit_jump_insn_before_noloc): Call it.\n+\t(emit_call_insn_before_noloc, emit_debug_insn_before_noloc): Likewise.\n+\t(emit_pattern_after_noloc): New function.\n+\t(emit_insn_after_noloc, emit_jump_insn_after_noloc): Call it.\n+\t(emit_call_insn_after_noloc, emit_debug_insn_after_noloc): Likewise.\n+\n 2011-03-22  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* libgcc2.c (__lshrdi3, __ashldi3, __ashrdi3): Use W_TYPE_SIZE."}, {"sha": "9b6f0f85fc96064ce8504bab83e885eabb25b7c4", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 34, "deletions": 207, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f02387d745a334a9bce1df61e6193cf110b425f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f02387d745a334a9bce1df61e6193cf110b425f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5f02387d745a334a9bce1df61e6193cf110b425f", "patch": "@@ -4022,12 +4022,10 @@ reorder_insns (rtx from, rtx to, rtx after)\n    SEQUENCE rtl results in much fragmented RTL memory since the SEQUENCE\n    generated would almost certainly die right after it was created.  */\n \n-/* Make X be output before the instruction BEFORE.  */\n-\n-rtx\n-emit_insn_before_noloc (rtx x, rtx before, basic_block bb)\n+static rtx\n+emit_pattern_before_noloc (rtx x, rtx before, rtx last, basic_block bb,\n+                           rtx (*make_raw) (rtx))\n {\n-  rtx last = before;\n   rtx insn;\n \n   gcc_assert (before);\n@@ -4061,56 +4059,30 @@ emit_insn_before_noloc (rtx x, rtx before, basic_block bb)\n #endif\n \n     default:\n-      last = make_insn_raw (x);\n+      last = (*make_raw) (x);\n       add_insn_before (last, before, bb);\n       break;\n     }\n \n   return last;\n }\n \n+/* Make X be output before the instruction BEFORE.  */\n+\n+rtx\n+emit_insn_before_noloc (rtx x, rtx before, basic_block bb)\n+{\n+  return emit_pattern_before_noloc (x, before, before, bb, make_insn_raw);\n+}\n+\n /* Make an instruction with body X and code JUMP_INSN\n    and output it before the instruction BEFORE.  */\n \n rtx\n emit_jump_insn_before_noloc (rtx x, rtx before)\n {\n-  rtx insn, last = NULL_RTX;\n-\n-  gcc_assert (before);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case DEBUG_INSN:\n-    case INSN:\n-    case JUMP_INSN:\n-    case CALL_INSN:\n-    case CODE_LABEL:\n-    case BARRIER:\n-    case NOTE:\n-      insn = x;\n-      while (insn)\n-\t{\n-\t  rtx next = NEXT_INSN (insn);\n-\t  add_insn_before (insn, before, NULL);\n-\t  last = insn;\n-\t  insn = next;\n-\t}\n-      break;\n-\n-#ifdef ENABLE_RTL_CHECKING\n-    case SEQUENCE:\n-      gcc_unreachable ();\n-      break;\n-#endif\n-\n-    default:\n-      last = make_jump_insn_raw (x);\n-      add_insn_before (last, before, NULL);\n-      break;\n-    }\n-\n-  return last;\n+  return emit_pattern_before_noloc (x, before, NULL_RTX, NULL,\n+\t\t\t\t    make_jump_insn_raw);\n }\n \n /* Make an instruction with body X and code CALL_INSN\n@@ -4119,42 +4091,8 @@ emit_jump_insn_before_noloc (rtx x, rtx before)\n rtx\n emit_call_insn_before_noloc (rtx x, rtx before)\n {\n-  rtx last = NULL_RTX, insn;\n-\n-  gcc_assert (before);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case DEBUG_INSN:\n-    case INSN:\n-    case JUMP_INSN:\n-    case CALL_INSN:\n-    case CODE_LABEL:\n-    case BARRIER:\n-    case NOTE:\n-      insn = x;\n-      while (insn)\n-\t{\n-\t  rtx next = NEXT_INSN (insn);\n-\t  add_insn_before (insn, before, NULL);\n-\t  last = insn;\n-\t  insn = next;\n-\t}\n-      break;\n-\n-#ifdef ENABLE_RTL_CHECKING\n-    case SEQUENCE:\n-      gcc_unreachable ();\n-      break;\n-#endif\n-\n-    default:\n-      last = make_call_insn_raw (x);\n-      add_insn_before (last, before, NULL);\n-      break;\n-    }\n-\n-  return last;\n+  return emit_pattern_before_noloc (x, before, NULL_RTX, NULL,\n+\t\t\t\t    make_call_insn_raw);\n }\n \n /* Make an instruction with body X and code DEBUG_INSN\n@@ -4163,42 +4101,8 @@ emit_call_insn_before_noloc (rtx x, rtx before)\n rtx\n emit_debug_insn_before_noloc (rtx x, rtx before)\n {\n-  rtx last = NULL_RTX, insn;\n-\n-  gcc_assert (before);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case DEBUG_INSN:\n-    case INSN:\n-    case JUMP_INSN:\n-    case CALL_INSN:\n-    case CODE_LABEL:\n-    case BARRIER:\n-    case NOTE:\n-      insn = x;\n-      while (insn)\n-\t{\n-\t  rtx next = NEXT_INSN (insn);\n-\t  add_insn_before (insn, before, NULL);\n-\t  last = insn;\n-\t  insn = next;\n-\t}\n-      break;\n-\n-#ifdef ENABLE_RTL_CHECKING\n-    case SEQUENCE:\n-      gcc_unreachable ();\n-      break;\n-#endif\n-\n-    default:\n-      last = make_debug_insn_raw (x);\n-      add_insn_before (last, before, NULL);\n-      break;\n-    }\n-\n-  return last;\n+  return emit_pattern_before_noloc (x, before, NULL_RTX, NULL,\n+\t\t\t\t    make_debug_insn_raw);\n }\n \n /* Make an insn of code BARRIER\n@@ -4292,11 +4196,9 @@ emit_insn_after_1 (rtx first, rtx after, basic_block bb)\n   return last;\n }\n \n-/* Make X be output after the insn AFTER and set the BB of insn.  If\n-   BB is NULL, an attempt is made to infer the BB from AFTER.  */\n-\n-rtx\n-emit_insn_after_noloc (rtx x, rtx after, basic_block bb)\n+static rtx\n+emit_pattern_after_noloc (rtx x, rtx after, basic_block bb,\n+\t\t\t  rtx (*make_raw)(rtx))\n {\n   rtx last = after;\n \n@@ -4324,50 +4226,31 @@ emit_insn_after_noloc (rtx x, rtx after, basic_block bb)\n #endif\n \n     default:\n-      last = make_insn_raw (x);\n+      last = (*make_raw) (x);\n       add_insn_after (last, after, bb);\n       break;\n     }\n \n   return last;\n }\n \n+/* Make X be output after the insn AFTER and set the BB of insn.  If\n+   BB is NULL, an attempt is made to infer the BB from AFTER.  */\n+\n+rtx\n+emit_insn_after_noloc (rtx x, rtx after, basic_block bb)\n+{\n+  return emit_pattern_after_noloc (x, after, bb, make_insn_raw);\n+}\n+\n \n /* Make an insn of code JUMP_INSN with body X\n    and output it after the insn AFTER.  */\n \n rtx\n emit_jump_insn_after_noloc (rtx x, rtx after)\n {\n-  rtx last;\n-\n-  gcc_assert (after);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case DEBUG_INSN:\n-    case INSN:\n-    case JUMP_INSN:\n-    case CALL_INSN:\n-    case CODE_LABEL:\n-    case BARRIER:\n-    case NOTE:\n-      last = emit_insn_after_1 (x, after, NULL);\n-      break;\n-\n-#ifdef ENABLE_RTL_CHECKING\n-    case SEQUENCE:\n-      gcc_unreachable ();\n-      break;\n-#endif\n-\n-    default:\n-      last = make_jump_insn_raw (x);\n-      add_insn_after (last, after, NULL);\n-      break;\n-    }\n-\n-  return last;\n+  return emit_pattern_after_noloc (x, after, NULL, make_jump_insn_raw);\n }\n \n /* Make an instruction with body X and code CALL_INSN\n@@ -4376,35 +4259,7 @@ emit_jump_insn_after_noloc (rtx x, rtx after)\n rtx\n emit_call_insn_after_noloc (rtx x, rtx after)\n {\n-  rtx last;\n-\n-  gcc_assert (after);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case DEBUG_INSN:\n-    case INSN:\n-    case JUMP_INSN:\n-    case CALL_INSN:\n-    case CODE_LABEL:\n-    case BARRIER:\n-    case NOTE:\n-      last = emit_insn_after_1 (x, after, NULL);\n-      break;\n-\n-#ifdef ENABLE_RTL_CHECKING\n-    case SEQUENCE:\n-      gcc_unreachable ();\n-      break;\n-#endif\n-\n-    default:\n-      last = make_call_insn_raw (x);\n-      add_insn_after (last, after, NULL);\n-      break;\n-    }\n-\n-  return last;\n+  return emit_pattern_after_noloc (x, after, NULL, make_call_insn_raw);\n }\n \n /* Make an instruction with body X and code CALL_INSN\n@@ -4413,35 +4268,7 @@ emit_call_insn_after_noloc (rtx x, rtx after)\n rtx\n emit_debug_insn_after_noloc (rtx x, rtx after)\n {\n-  rtx last;\n-\n-  gcc_assert (after);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case DEBUG_INSN:\n-    case INSN:\n-    case JUMP_INSN:\n-    case CALL_INSN:\n-    case CODE_LABEL:\n-    case BARRIER:\n-    case NOTE:\n-      last = emit_insn_after_1 (x, after, NULL);\n-      break;\n-\n-#ifdef ENABLE_RTL_CHECKING\n-    case SEQUENCE:\n-      gcc_unreachable ();\n-      break;\n-#endif\n-\n-    default:\n-      last = make_debug_insn_raw (x);\n-      add_insn_after (last, after, NULL);\n-      break;\n-    }\n-\n-  return last;\n+  return emit_pattern_after_noloc (x, after, NULL, make_debug_insn_raw);\n }\n \n /* Make an insn of code BARRIER"}]}