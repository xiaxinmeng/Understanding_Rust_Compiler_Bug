{"sha": "e59d83aa39bdf6bc545649db1737cbe3cc62a136", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5ZDgzYWEzOWJkZjZiYzU0NTY0OWRiMTczN2NiZTNjYzYyYTEzNg==", "commit": {"author": {"name": "Roman Zippel", "email": "zippel@linux-m68k.org", "date": "2007-09-19T15:20:59Z"}, "committer": {"name": "Roman Zippel", "email": "zippel@gcc.gnu.org", "date": "2007-09-19T15:20:59Z"}, "message": "m68k.c (output_move_himode): Remove jump table recognition.\n\n\t* config/m68k/m68k.c (output_move_himode): Remove jump table\n\trecognition.\n\tconfig/m68k/m68k.md (lea): Likewise.\n\t* config/m68k/m68k.c (print_operand_address): Use simple pc\n\trelative addressing.\n\nFrom-SVN: r128601", "tree": {"sha": "9059fb89841a20f8454f33d3c0e95a0d409428c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9059fb89841a20f8454f33d3c0e95a0d409428c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e59d83aa39bdf6bc545649db1737cbe3cc62a136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59d83aa39bdf6bc545649db1737cbe3cc62a136", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e59d83aa39bdf6bc545649db1737cbe3cc62a136", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59d83aa39bdf6bc545649db1737cbe3cc62a136/comments", "author": null, "committer": null, "parents": [{"sha": "4ceb424220b30f4634cf61f10eb543f320129cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ceb424220b30f4634cf61f10eb543f320129cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ceb424220b30f4634cf61f10eb543f320129cf9"}], "stats": {"total": 67, "additions": 12, "deletions": 55}, "files": [{"sha": "2e4a1907503a8f50f6bdb605e259e9c82c0d84b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59d83aa39bdf6bc545649db1737cbe3cc62a136/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59d83aa39bdf6bc545649db1737cbe3cc62a136/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e59d83aa39bdf6bc545649db1737cbe3cc62a136", "patch": "@@ -1,3 +1,11 @@\n+2007-09-19  Roman Zippel <zippel@linux-m68k.org>\n+\n+\t* config/m68k/m68k.c (output_move_himode): Remove jump table\n+\trecognition.\n+\tconfig/m68k/m68k.md (lea): Likewise.\n+\t* config/m68k/m68k.c (print_operand_address): Use simple pc\n+\trelative addressing.\n+\n 2007-09-19  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* doc/tm.texi (IS_ASM_LOGICAL_LINE_SEPARATOR): Document new argument."}, {"sha": "c8e5a6f4a05809539d12e679ce08ad62bb5a98ca", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59d83aa39bdf6bc545649db1737cbe3cc62a136/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59d83aa39bdf6bc545649db1737cbe3cc62a136/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=e59d83aa39bdf6bc545649db1737cbe3cc62a136", "patch": "@@ -2359,25 +2359,6 @@ output_move_himode (rtx *operands)\n     }\n   else if (CONSTANT_P (operands[1]))\n     return \"move%.l %1,%0\";\n-  /* Recognize the insn before a tablejump, one that refers\n-     to a table of offsets.  Such an insn will need to refer\n-     to a label on the insn.  So output one.  Use the label-number\n-     of the table of offsets to generate this label.  This code,\n-     and similar code below, assumes that there will be at most one\n-     reference to each table.  */\n-  if (GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == LABEL_REF\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS)\n-    {\n-      rtx labelref = XEXP (XEXP (operands[1], 0), 1);\n-      if (MOTOROLA)\n-\tasm_fprintf (asm_out_file, \"\\t.set %LLI%d,.+2\\n\",\n-\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-      else\n-\t(*targetm.asm_out.internal_label) (asm_out_file, \"LI\",\n-\t\t\t\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-    }\n   return \"move%.w %1,%0\";\n }\n \n@@ -3819,19 +3800,6 @@ print_operand (FILE *file, rtx op, int letter)\n    It is possible for PIC to generate a (plus (label_ref...) (reg...))\n    and we handle that just like we would a (plus (symbol_ref...) (reg...)).\n \n-   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n-   fails to assemble.  Luckily \"Lnnn(pc,d0.l*2)\" produces the results\n-   we want.  This difference can be accommodated by using an assembler\n-   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n-   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n-   macro.  See m68k/sgs.h for an example; for versions without the bug.\n-   Some assemblers refuse all the above solutions.  The workaround is to\n-   emit \"K(pc,d0.l*2)\" with K being a small constant known to give the\n-   right behavior.\n-\n-   They also do not like things like \"pea 1.w\", so we simple leave off\n-   the .w on small constants. \n-\n    This routine is responsible for distinguishing between -fpic and -fPIC \n    style relocations in an address.  When generating -fpic code the\n    offset is output in word mode (e.g. movel a5@(_foo:w), a0).  When generating\n@@ -3902,7 +3870,7 @@ print_operand_address (FILE *file, rtx addr)\n \t{\n \t  /* Print the \"offset(base\" component.  */\n \t  if (labelno >= 0)\n-\t    asm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,\", labelno, labelno);\n+\t    asm_fprintf (file, \"%LL%d(%Rpc,\", labelno);\n \t  else\n \t    {\n \t      if (address.offset)\n@@ -3940,7 +3908,7 @@ print_operand_address (FILE *file, rtx addr)\n \t    {\n \t      /* Print the \"base@(offset\" component.  */\n \t      if (labelno >= 0)\n-\t\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b\", labelno, labelno);\n+\t\tasm_fprintf (file, \"%Rpc@(%LL%d\", labelno);\n \t      else\n \t\t{\n \t\t  if (address.base)"}, {"sha": "b3f12d8b6162b37ebfcc823db9664cf6c30716af", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59d83aa39bdf6bc545649db1737cbe3cc62a136/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59d83aa39bdf6bc545649db1737cbe3cc62a136/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=e59d83aa39bdf6bc545649db1737cbe3cc62a136", "patch": "@@ -7297,30 +7297,11 @@\n \f\n ;; This should not be used unless the add/sub insns can't be.\n \n-(define_insn \"\"\n+(define_insn \"*lea\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=a\")\n \t(match_operand:QI 1 \"address_operand\" \"p\"))]\n   \"\"\n-{\n-  /* Recognize an insn that refers to a table of offsets.  Such an insn will\n-     need to refer to a label on the insn.  So output one.  Use the\n-     label-number of the table of offsets to generate this label.  This code,\n-     and similar code above, assumes that there will be at most one reference\n-     to each table.  */\n-  if (GET_CODE (operands[1]) == PLUS\n-      && GET_CODE (XEXP (operands[1], 1)) == LABEL_REF\n-      && GET_CODE (XEXP (operands[1], 0)) != PLUS)\n-    {\n-      rtx labelref = XEXP (operands[1], 1);\n-      if (MOTOROLA)\n-        asm_fprintf (asm_out_file, \"\\\\t.set %LLI%d,.+2\\\\n\",\n-\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-      else\n-        (*targetm.asm_out.internal_label) (asm_out_file, \"LI\",\n-\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-    }\n-  return \"lea %a1,%0\";\n-})\n+  \"lea %a1,%0\")\n \f\n ;; This is the first machine-dependent peephole optimization.\n ;; It is useful when a floating value is returned from a function call"}]}