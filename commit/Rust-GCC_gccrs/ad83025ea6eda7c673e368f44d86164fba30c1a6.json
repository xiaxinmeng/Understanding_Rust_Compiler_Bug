{"sha": "ad83025ea6eda7c673e368f44d86164fba30c1a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ4MzAyNWVhNmVkYTdjNjczZTM2OGY0NGQ4NjE2NGZiYTMwYzFhNg==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2013-08-10T03:48:01Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2013-08-10T03:48:01Z"}, "message": "Implement -mmemcpy-strategy= and -mmemset-strategy= options\n\nFrom-SVN: r201645", "tree": {"sha": "b6fc4e33d02396162f83c0a7295536e37068bd98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6fc4e33d02396162f83c0a7295536e37068bd98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad83025ea6eda7c673e368f44d86164fba30c1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad83025ea6eda7c673e368f44d86164fba30c1a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad83025ea6eda7c673e368f44d86164fba30c1a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad83025ea6eda7c673e368f44d86164fba30c1a6/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d1d05602c1c36e8eab381f649dd699191e82197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1d05602c1c36e8eab381f649dd699191e82197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d1d05602c1c36e8eab381f649dd699191e82197"}], "stats": {"total": 783, "additions": 603, "deletions": 180}, "files": [{"sha": "5e0f269d68b1188f2e8ab85cf16e969139c9fec3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -1,3 +1,15 @@\n+2013-08-09  Xinliang David Li  <davidxl@google.com>\n+\n+\t* config/i386/stringop.def: New file.\n+\t* config/i386/stringop.opt: New file.\n+\t* config/i386/i386-opts.h: Include stringopt.def.\n+\t* config/i386/i386.opt: Include stringopt.opt.\n+\t* config/i386/i386.c (ix86_option_override_internal):\n+\tOverride default size based stringop inline strategies\n+\twith options.\n+\t* config/i386/i386.c (ix86_parse_stringop_strategy_string):\n+\tNew function.\n+\n 2013-08-09  Jan Hubicka  <jh@suse.cz>\n \n \t * ipa-ref.c (ipa_clear_stmts_in_references): Clear lto_stmt_uid, too."}, {"sha": "5fcbd6b57767214752e6c10eda3cf5c1d0bd9e4a", "filename": "gcc/config/i386/i386-opts.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-opts.h?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -28,15 +28,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Algorithm to expand string function with.  */\n enum stringop_alg\n {\n-   no_stringop,\n-   libcall,\n-   rep_prefix_1_byte,\n-   rep_prefix_4_byte,\n-   rep_prefix_8_byte,\n-   loop_1_byte,\n-   loop,\n-   unrolled_loop,\n-   vector_loop\n+#undef DEF_ENUM\n+#define DEF_ENUM\n+\n+#undef DEF_ALG\n+#define DEF_ALG(alg, name) alg, \n+\n+#include \"stringop.def\"\n+last_alg\n+\n+#undef DEF_ENUM\n+#undef DEF_ALG\n };\n \n /* Available call abi.  */"}, {"sha": "509cb6e8f832d1fc42300f85ce97375c3a7b5310", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 433, "deletions": 170, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -87,6 +87,13 @@ static rtx legitimize_pe_coff_symbol (rtx, bool);\n \n #define DUMMY_STRINGOP_ALGS {libcall, {{-1, libcall, false}}}\n \n+static stringop_algs ix86_size_memcpy[2] = {\n+  {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n+  {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}}};\n+static stringop_algs ix86_size_memset[2] = {\n+  {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n+  {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}}};\n+\n const\n struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* cost of an add instruction */\n@@ -140,10 +147,8 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n-   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}}},\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n-   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}}},\n+  ix86_size_memcpy,\n+  ix86_size_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -158,6 +163,13 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n };\n \n /* Processor costs (relative to an add) */\n+static stringop_algs i386_memcpy[2] = {\n+  {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs i386_memset[2] = {\n+  {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+\n static const\n struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -211,10 +223,8 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (22),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (122),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  i386_memcpy,\n+  i386_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -228,6 +238,13 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs i486_memcpy[2] = {\n+  {rep_prefix_4_byte, {{-1, rep_prefix_4_byte, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs i486_memset[2] = {\n+  {rep_prefix_4_byte, {{-1, rep_prefix_4_byte, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+\n static const\n struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -283,10 +300,8 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (83),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  i486_memcpy,\n+  i486_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -300,6 +315,13 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs pentium_memcpy[2] = {\n+  {libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs pentium_memset[2] = {\n+  {libcall, {{-1, rep_prefix_4_byte, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+\n static const\n struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -353,10 +375,8 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{-1, rep_prefix_4_byte, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  pentium_memcpy,\n+  pentium_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -370,6 +390,21 @@ struct processor_costs pentium_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+/* PentiumPro has optimized rep instructions for blocks aligned by 8 bytes\n+   (we ensure the alignment).  For small blocks inline loop is still a\n+   noticeable win, for bigger blocks either rep movsl or rep movsb is\n+   way to go.  Rep movsb has apparently more expensive startup time in CPU,\n+   but after 4K the difference is down in the noise.  */\n+static stringop_algs pentiumpro_memcpy[2] = {\n+  {rep_prefix_4_byte, {{128, loop, false}, {1024, unrolled_loop, false},\n+                       {8192, rep_prefix_4_byte, false},\n+                       {-1, rep_prefix_1_byte, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs pentiumpro_memset[2] = {\n+  {rep_prefix_4_byte, {{1024, unrolled_loop, false},\n+                       {8192, rep_prefix_4_byte, false},\n+                       {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -423,19 +458,8 @@ struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n-  /* PentiumPro has optimized rep instructions for blocks aligned by 8 bytes\n-     (we ensure the alignment).  For small blocks inline loop is still a\n-     noticeable win, for bigger blocks either rep movsl or rep movsb is\n-     way to go.  Rep movsb has apparently more expensive startup time in CPU,\n-     but after 4K the difference is down in the noise.  */\n-  {{rep_prefix_4_byte, {{128, loop, false}, {1024, unrolled_loop, false},\n-\t\t\t{8192, rep_prefix_4_byte, false},\n-\t\t        {-1, rep_prefix_1_byte, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_4_byte, {{1024, unrolled_loop, false},\n-  \t\t\t{8192, rep_prefix_4_byte, false},\n-\t\t\t{-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  pentiumpro_memcpy,\n+  pentiumpro_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -449,6 +473,12 @@ struct processor_costs pentiumpro_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs geode_memcpy[2] = {\n+  {libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs geode_memset[2] = {\n+  {libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -503,10 +533,8 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (54),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  geode_memcpy,\n+  geode_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -520,6 +548,12 @@ struct processor_costs geode_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs k6_memcpy[2] = {\n+  {libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs k6_memset[2] = {\n+  {libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs k6_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -576,10 +610,8 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  k6_memcpy,\n+  k6_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -593,6 +625,15 @@ struct processor_costs k6_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+/* For some reason, Athlon deals better with REP prefix (relative to loops)\n+   compared to K8. Alignment becomes important after 8 bytes for memcpy and\n+   128 bytes for memset.  */\n+static stringop_algs athlon_memcpy[2] = {\n+  {libcall, {{2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs athlon_memset[2] = {\n+  {libcall, {{2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -646,13 +687,8 @@ struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n-  /* For some reason, Athlon deals better with REP prefix (relative to loops)\n-     compared to K8. Alignment becomes important after 8 bytes for memcpy and\n-     128 bytes for memset.  */\n-  {{libcall, {{2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  athlon_memcpy,\n+  athlon_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -666,6 +702,19 @@ struct processor_costs athlon_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+/* K8 has optimized REP instruction for medium sized blocks, but for very\n+   small blocks it is better to use loop. For large blocks, libcall can\n+   do nontemporary accesses and beat inline considerably.  */\n+static stringop_algs k8_memcpy[2] = {\n+  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+             {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs k8_memset[2] = {\n+  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{48, unrolled_loop, false},\n+             {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs k8_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -724,17 +773,9 @@ struct processor_costs k8_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n-  /* K8 has optimized REP instruction for medium sized blocks, but for very\n-     small blocks it is better to use loop. For large blocks, libcall can\n-     do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-\t      {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{48, unrolled_loop, false},\n-\t      {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n+\n+  k8_memcpy,\n+  k8_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -748,6 +789,19 @@ struct processor_costs k8_cost = {\n   2,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+/* AMDFAM10 has optimized REP instruction for medium sized blocks, but for\n+   very small blocks it is better to use loop. For large blocks, libcall can\n+   do nontemporary accesses and beat inline considerably.  */\n+static stringop_algs amdfam10_memcpy[2] = {\n+  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+             {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs amdfam10_memset[2] = {\n+  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n struct processor_costs amdfam10_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n@@ -814,17 +868,8 @@ struct processor_costs amdfam10_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n-  /* AMDFAM10 has optimized REP instruction for medium sized blocks, but for\n-     very small blocks it is better to use loop. For large blocks, libcall can\n-     do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-\t      {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n+  amdfam10_memcpy,\n+  amdfam10_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -838,7 +883,21 @@ struct processor_costs amdfam10_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-struct processor_costs bdver1_cost = {\n+/*  BDVER1 has optimized REP instruction for medium sized blocks, but for\n+    very small blocks it is better to use loop. For large blocks, libcall\n+    can do nontemporary accesses and beat inline considerably.  */\n+static stringop_algs bdver1_memcpy[2] = {\n+  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+             {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs bdver1_memset[2] = {\n+  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+\n+const struct processor_costs bdver1_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -904,17 +963,8 @@ struct processor_costs bdver1_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n \n-  /*  BDVER1 has optimized REP instruction for medium sized blocks, but for\n-      very small blocks it is better to use loop. For large blocks, libcall\n-      can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-\t      {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n+  bdver1_memcpy,\n+  bdver1_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -928,7 +978,22 @@ struct processor_costs bdver1_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-struct processor_costs bdver2_cost = {\n+/*  BDVER2 has optimized REP instruction for medium sized blocks, but for\n+    very small blocks it is better to use loop. For large blocks, libcall\n+    can do nontemporary accesses and beat inline considerably.  */\n+\n+static stringop_algs bdver2_memcpy[2] = {\n+  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+             {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs bdver2_memset[2] = {\n+  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+\n+const struct processor_costs bdver2_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -994,17 +1059,8 @@ struct processor_costs bdver2_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n \n-  /*  BDVER2 has optimized REP instruction for medium sized blocks, but for\n-      very small blocks it is better to use loop. For large blocks, libcall\n-      can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-\t      {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n+  bdver2_memcpy,\n+  bdver2_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1018,6 +1074,20 @@ struct processor_costs bdver2_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+\n+  /*  BDVER3 has optimized REP instruction for medium sized blocks, but for\n+      very small blocks it is better to use loop. For large blocks, libcall\n+      can do nontemporary accesses and beat inline considerably.  */\n+static stringop_algs bdver3_memcpy[2] = {\n+  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+             {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs bdver3_memset[2] = {\n+  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n struct processor_costs bdver3_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -1076,17 +1146,8 @@ struct processor_costs bdver3_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n \n-  /*  BDVER3 has optimized REP instruction for medium sized blocks, but for\n-      very small blocks it is better to use loop. For large blocks, libcall\n-      can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-\t      {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n+  bdver3_memcpy,\n+  bdver3_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1100,7 +1161,20 @@ struct processor_costs bdver3_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-struct processor_costs btver1_cost = {\n+  /* BTVER1 has optimized REP instruction for medium sized blocks, but for\n+     very small blocks it is better to use loop. For large blocks, libcall can\n+     do nontemporary accesses and beat inline considerably.  */\n+static stringop_algs btver1_memcpy[2] = {\n+  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+             {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs btver1_memset[2] = {\n+  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+const struct processor_costs btver1_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1161,17 +1235,8 @@ struct processor_costs btver1_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n-  /* BTVER1 has optimized REP instruction for medium sized blocks, but for\n-     very small blocks it is better to use loop. For large blocks, libcall can\n-     do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-\t      {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n+  btver1_memcpy,\n+  btver1_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1185,7 +1250,17 @@ struct processor_costs btver1_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-struct processor_costs btver2_cost = {\n+static stringop_algs btver2_memcpy[2] = {\n+  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+             {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs btver2_memset[2] = {\n+  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+const struct processor_costs btver2_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1245,15 +1320,8 @@ struct processor_costs btver2_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-\t      {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n+  btver2_memcpy,\n+  btver2_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1267,6 +1335,14 @@ struct processor_costs btver2_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs pentium4_memcpy[2] = {\n+  {libcall, {{12, loop_1_byte, false}, {-1, rep_prefix_4_byte, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs pentium4_memset[2] = {\n+  {libcall, {{6, loop_1_byte, false}, {48, loop, false},\n+             {20480, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+\n static const\n struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1320,11 +1396,8 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{12, loop_1_byte, false}, {-1, rep_prefix_4_byte, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{6, loop_1_byte, false}, {48, loop, false},\n-\t      {20480, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  pentium4_memcpy,\n+  pentium4_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1338,6 +1411,17 @@ struct processor_costs pentium4_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs nocona_memcpy[2] = {\n+  {libcall, {{12, loop_1_byte, false}, {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{32, loop, false}, {20000, rep_prefix_8_byte, false},\n+             {100000, unrolled_loop, false}, {-1, libcall, false}}}};\n+\n+static stringop_algs nocona_memset[2] = {\n+  {libcall, {{6, loop_1_byte, false}, {48, loop, false},\n+             {20480, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{24, loop, false}, {64, unrolled_loop, false},\n+             {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n+\n static const\n struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1391,13 +1475,8 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{12, loop_1_byte, false}, {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{32, loop, false}, {20000, rep_prefix_8_byte, false},\n-\t      {100000, unrolled_loop, false}, {-1, libcall, false}}}},\n-  {{libcall, {{6, loop_1_byte, false}, {48, loop, false},\n-\t      {20480, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{24, loop, false}, {64, unrolled_loop, false},\n-\t      {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n+  nocona_memcpy,\n+  nocona_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1411,6 +1490,15 @@ struct processor_costs nocona_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs atom_memcpy[2] = {\n+  {libcall, {{11, loop, false}, {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{32, loop, false}, {64, rep_prefix_4_byte, false},\n+             {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n+static stringop_algs atom_memset[2] = {\n+  {libcall, {{8, loop, false}, {15, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{24, loop, false}, {32, unrolled_loop, false},\n+             {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs atom_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1464,13 +1552,8 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{11, loop, false}, {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{32, loop, false}, {64, rep_prefix_4_byte, false},\n-\t  {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {15, unrolled_loop, false},\n-\t  {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{24, loop, false}, {32, unrolled_loop, false},\n-\t  {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n+  atom_memcpy,\n+  atom_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1484,6 +1567,15 @@ struct processor_costs atom_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static stringop_algs slm_memcpy[2] = {\n+  {libcall, {{11, loop, false}, {-1, rep_prefix_4_byte, false}}},\n+  {libcall, {{32, loop, false}, {64, rep_prefix_4_byte, false},\n+             {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n+static stringop_algs slm_memset[2] = {\n+  {libcall, {{8, loop, false}, {15, unrolled_loop, false},\n+             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+  {libcall, {{24, loop, false}, {32, unrolled_loop, false},\n+             {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs slm_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1537,13 +1629,8 @@ struct processor_costs slm_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{11, loop, false}, {-1, rep_prefix_4_byte, false}}},\n-   {libcall, {{32, loop, false}, {64, rep_prefix_4_byte, false},\n-          {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n-  {{libcall, {{8, loop, false}, {15, unrolled_loop, false},\n-          {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-   {libcall, {{24, loop, false}, {32, unrolled_loop, false},\n-          {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n+  slm_memcpy,\n+  slm_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1558,6 +1645,15 @@ struct processor_costs slm_cost = {\n };\n \n /* Generic64 should produce code tuned for Nocona and K8.  */\n+\n+static stringop_algs generic64_memcpy[2] = {\n+  DUMMY_STRINGOP_ALGS,\n+  {libcall, {{32, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n+static stringop_algs generic64_memset[2] = {\n+  DUMMY_STRINGOP_ALGS,\n+  {libcall, {{32, loop, false}, {8192, rep_prefix_8_byte, false},\n+             {-1, libcall, false}}}};\n static const\n struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1617,12 +1713,8 @@ struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {DUMMY_STRINGOP_ALGS,\n-   {libcall, {{32, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n-  {DUMMY_STRINGOP_ALGS,\n-   {libcall, {{32, loop, false}, {8192, rep_prefix_8_byte, false},\n-\t      {-1, libcall, false}}}},\n+  generic64_memcpy,\n+  generic64_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1637,6 +1729,18 @@ struct processor_costs generic64_cost = {\n };\n \n /* core_cost should produce code tuned for Core familly of CPUs.  */\n+static stringop_algs core_memcpy[2] = {\n+  {libcall, {{1024, rep_prefix_4_byte, true}, {-1, libcall, false}}},\n+  {libcall, {{24, loop, true}, {128, rep_prefix_8_byte, true},\n+             {-1, libcall, false}}}};\n+static stringop_algs core_memset[2] = {\n+  {libcall, {{6, loop_1_byte, true},\n+             {24, loop, true},\n+             {8192, rep_prefix_4_byte, true},\n+             {-1, libcall, false}}},\n+  {libcall, {{24, loop, true}, {512, rep_prefix_8_byte, true},\n+             {-1, libcall, false}}}};\n+\n static const\n struct processor_costs core_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1695,15 +1799,8 @@ struct processor_costs core_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{1024, rep_prefix_4_byte, true}, {-1, libcall, false}}},\n-   {libcall, {{24, loop, true}, {128, rep_prefix_8_byte, true},\n-              {-1, libcall, false}}}},\n-  {{libcall, {{6, loop_1_byte, true},\n-              {24, loop, true},\n-              {8192, rep_prefix_4_byte, true},\n-              {-1, libcall, false}}},\n-   {libcall, {{24, loop, true}, {512, rep_prefix_8_byte, true},\n-              {-1, libcall, false}}}},\n+  core_memcpy,\n+  core_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1719,6 +1816,14 @@ struct processor_costs core_cost = {\n \n /* Generic32 should produce code tuned for PPro, Pentium4, Nocona,\n    Athlon and K8.  */\n+static stringop_algs generic32_memcpy[2] = {\n+  {libcall, {{32, loop, false}, {8192, rep_prefix_4_byte, false},\n+             {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n+static stringop_algs generic32_memset[2] = {\n+  {libcall, {{32, loop, false}, {8192, rep_prefix_4_byte, false},\n+             {-1, libcall, false}}},\n+  DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1772,12 +1877,8 @@ struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{32, loop, false}, {8192, rep_prefix_4_byte, false},\n-\t      {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{32, loop, false}, {8192, rep_prefix_4_byte, false},\n-\t      {-1, libcall, false}}},\n-   DUMMY_STRINGOP_ALGS},\n+  generic32_memcpy,\n+  generic32_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -2926,6 +3027,149 @@ ix86_debug_options (void)\n \n   return;\n }\n+\n+static const char *stringop_alg_names[] = {\n+#define DEF_ENUM\n+#define DEF_ALG(alg, name) #name,\n+#include \"stringop.def\"\n+#undef DEF_ENUM\n+#undef DEF_ALG\n+};\n+\n+/* Parse parameter string passed to -mmemcpy-strategy= or -mmemset-strategy=.\n+   The string is of the following form (or comma separated list of it):\n+\n+     strategy_alg:max_size:[align|noalign]\n+\n+   where the full size range for the strategy is either [0, max_size] or\n+   [min_size, max_size], in which min_size is the max_size + 1 of the\n+   preceding range.  The last size range must have max_size == -1.\n+\n+   Examples:\n+\n+    1.\n+       -mmemcpy-strategy=libcall:-1:noalign\n+\n+      this is equivalent to (for known size memcpy) -mstringop-strategy=libcall\n+\n+\n+   2.\n+      -mmemset-strategy=rep_8byte:16:noalign,vector_loop:2048:align,libcall:-1:noalign\n+\n+      This is to tell the compiler to use the following strategy for memset\n+      1) when the expected size is between [1, 16], use rep_8byte strategy;\n+      2) when the size is between [17, 2048], use vector_loop;\n+      3) when the size is > 2048, use libcall.  */\n+\n+struct stringop_size_range\n+{\n+  int min;\n+  int max;\n+  stringop_alg alg;\n+  bool noalign;\n+};\n+\n+static void\n+ix86_parse_stringop_strategy_string (char *strategy_str, bool is_memset)\n+{\n+  const struct stringop_algs *default_algs;\n+  stringop_size_range input_ranges[MAX_STRINGOP_ALGS];\n+  char *curr_range_str, *next_range_str;\n+  int i = 0, n = 0;\n+\n+  if (is_memset)\n+    default_algs = &ix86_cost->memset[TARGET_64BIT != 0];\n+  else\n+    default_algs = &ix86_cost->memcpy[TARGET_64BIT != 0];\n+\n+  curr_range_str = strategy_str;\n+\n+  do\n+    {\n+      int mins, maxs;\n+      stringop_alg alg;\n+      char alg_name[128];\n+      char align[16];\n+      next_range_str = strchr (curr_range_str, ',');\n+      if (next_range_str)\n+        *next_range_str++ = '\\0';\n+\n+      if (3 != sscanf (curr_range_str, \"%20[^:]:%d:%10s\",\n+                       alg_name, &maxs, align))\n+        {\n+          error (\"wrong arg %s to option %s\", curr_range_str,\n+                 is_memset ? \"-mmemset_strategy=\" : \"-mmemcpy_strategy=\");\n+          return;\n+        }\n+\n+      if (n > 0 && (maxs < (mins = input_ranges[n - 1].max + 1) && maxs != -1))\n+        {\n+          error (\"size ranges of option %s should be increasing\",\n+                 is_memset ? \"-mmemset_strategy=\" : \"-mmemcpy_strategy=\");\n+          return;\n+        }\n+\n+      for (i = 0; i < last_alg; i++)\n+        {\n+          if (!strcmp (alg_name, stringop_alg_names[i]))\n+            {\n+              alg = (stringop_alg) i;\n+              break;\n+            }\n+        }\n+\n+      if (i == last_alg)\n+        {\n+          error (\"wrong stringop strategy name %s specified for option %s\",\n+                 alg_name,\n+                 is_memset ? \"-mmemset_strategy=\" : \"-mmemcpy_strategy=\");\n+          return;\n+        }\n+\n+      input_ranges[n].min = mins;\n+      input_ranges[n].max = maxs;\n+      input_ranges[n].alg = alg;\n+      if (!strcmp (align, \"align\"))\n+        input_ranges[n].noalign = false;\n+      else if (!strcmp (align, \"noalign\"))\n+        input_ranges[n].noalign = true;\n+      else\n+        {\n+          error (\"unknown alignment %s specified for option %s\",\n+                 align, is_memset ? \"-mmemset_strategy=\" : \"-mmemcpy_strategy=\");\n+          return;\n+        }\n+      n++;\n+      curr_range_str = next_range_str;\n+    }\n+  while (curr_range_str);\n+\n+  if (input_ranges[n - 1].max != -1)\n+    {\n+      error (\"the max value for the last size range should be -1\"\n+             \" for option %s\",\n+             is_memset ? \"-mmemset_strategy=\" : \"-mmemcpy_strategy=\");\n+      return;\n+    }\n+\n+  if (n > MAX_STRINGOP_ALGS)\n+    {\n+      error (\"too many size ranges specified in option %s\",\n+             is_memset ? \"-mmemset_strategy=\" : \"-mmemcpy_strategy=\");\n+      return;\n+    }\n+\n+  /* Now override the default algs array.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      *const_cast<int *>(&default_algs->size[i].max) = input_ranges[i].max;\n+      *const_cast<stringop_alg *>(&default_algs->size[i].alg)\n+          = input_ranges[i].alg;\n+      *const_cast<int *>(&default_algs->size[i].noalign)\n+          = input_ranges[i].noalign;\n+    }\n+}\n+\n \f\n /* Override various settings based on options.  If MAIN_ARGS_P, the\n    options are from the command line, otherwise they are from\n@@ -4081,6 +4325,21 @@ ix86_option_override_internal (bool main_args_p)\n   /* Handle stack protector */\n   if (!global_options_set.x_ix86_stack_protector_guard)\n     ix86_stack_protector_guard = TARGET_HAS_BIONIC ? SSP_GLOBAL : SSP_TLS;\n+\n+  /* Handle -mmemcpy-strategy= and -mmemset-strategy=  */\n+  if (ix86_tune_memcpy_strategy)\n+    {\n+      char *str = xstrdup (ix86_tune_memcpy_strategy);\n+      ix86_parse_stringop_strategy_string (str, false);\n+      free (str);\n+    }\n+\n+  if (ix86_tune_memset_strategy)\n+    {\n+      char *str = xstrdup (ix86_tune_memset_strategy);\n+      ix86_parse_stringop_strategy_string (str, true);\n+      free (str);\n+    }\n }\n \n /* Implement the TARGET_OPTION_OVERRIDE hook.  */\n@@ -22964,6 +23223,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n     {\n     case libcall:\n     case no_stringop:\n+    case last_alg:\n       gcc_unreachable ();\n     case loop_1_byte:\n       need_zero_guard = true;\n@@ -23154,6 +23414,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n     {\n     case libcall:\n     case no_stringop:\n+    case last_alg:\n       gcc_unreachable ();\n     case loop_1_byte:\n     case loop:\n@@ -23365,6 +23626,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n     {\n     case libcall:\n     case no_stringop:\n+    case last_alg:\n       gcc_unreachable ();\n     case loop:\n       need_zero_guard = true;\n@@ -23542,6 +23804,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n     {\n     case libcall:\n     case no_stringop:\n+    case last_alg:\n       gcc_unreachable ();\n     case loop_1_byte:\n     case loop:"}, {"sha": "aa1335384611cfe9a07846c55d681fdb82327900", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -170,7 +170,7 @@ struct processor_costs {\n   const int fsqrt;\t\t/* cost of FSQRT instruction.  */\n \t\t\t\t/* Specify what algorithm\n \t\t\t\t   to use for stringops on unknown size.  */\n-  struct stringop_algs memcpy[2], memset[2];\n+  struct stringop_algs *memcpy, *memset;\n   const int scalar_stmt_cost;   /* Cost of any scalar operation, excluding\n \t\t\t\t   load and store.  */\n   const int scalar_load_cost;   /* Cost of scalar load.  */"}, {"sha": "37e62f5bce816fa76c2422010c7820cc79751c4f", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -316,6 +316,14 @@ mstack-arg-probe\n Target Report Mask(STACK_PROBE) Save\n Enable stack probing\n \n+mmemcpy-strategy=\n+Target RejectNegative Joined Var(ix86_tune_memcpy_strategy)\n+Specify memcpy expansion strategy when expected size is known\n+\n+mmemset-strategy=\n+Target RejectNegative Joined Var(ix86_tune_memset_strategy)\n+Specify memset expansion strategy when expected size is known\n+\n mstringop-strategy=\n Target RejectNegative Joined Enum(stringop_alg) Var(ix86_stringop_alg) Init(no_stringop)\n Chose strategy to generate stringop using"}, {"sha": "1a7d1e88f658c443e6ffd5d5261a5c63f932c2a4", "filename": "gcc/config/i386/stringop.def", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fstringop.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fstringop.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fstringop.def?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -0,0 +1,37 @@\n+/* Definitions for stringop strategy for IA-32.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License \n+along with GCC; see the files COPYING3.  If not,\n+see <http://www.gnu.org/licenses/>.  */\n+\n+DEF_ENUM\n+DEF_ALG (no_stringop, no_stringop)\n+DEF_ENUM\n+DEF_ALG (libcall, libcall)\n+DEF_ENUM\n+DEF_ALG (rep_prefix_1_byte, rep_byte)\n+DEF_ENUM\n+DEF_ALG (rep_prefix_4_byte, rep_4byte)\n+DEF_ENUM\n+DEF_ALG (rep_prefix_8_byte, rep_8byte)\n+DEF_ENUM\n+DEF_ALG (loop_1_byte, byte_loop)\n+DEF_ENUM\n+DEF_ALG (loop, loop)\n+DEF_ENUM\n+DEF_ALG (unrolled_loop, unrolled_loop)\n+DEF_ENUM\n+DEF_ALG (vector_loop, vector_loop)"}, {"sha": "5c5fc906a33e36f588d0890562f9d5daa3e8821e", "filename": "gcc/config/i386/stringop.opt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fstringop.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fconfig%2Fi386%2Fstringop.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fstringop.opt?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -0,0 +1,31 @@\n+/* Definitions for stringop option handling for IA-32.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the files COPYING3.  If not,\n+see <http://www.gnu.org/licenses/>.  */\n+\n+Enum(stringop_alg) String(rep_byte) Value(rep_prefix_1_byte)\n+\n+#undef DEF_ENUM\n+#define DEF_ENUM EnumValue\n+\n+#undef DEF_ALG\n+#define DEF_ALG(alg, name) Enum(stringop_alg) String(name) Value(alg)\n+\n+#include \"stringop.def\"\n+\n+#undef DEF_ENUM\n+#undef DEF_ALG"}, {"sha": "70f09e72773509330f6b1e0cddd1bfced10ff7a8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -652,6 +652,7 @@ Objective-C and Objective-C++ Dialects}.\n -mbmi2 -mrtm -mlwp -mthreads @gol\n -mno-align-stringops  -minline-all-stringops @gol\n -minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol\n+-mmemcpy-strategy=@var{strategy} -mmemset-strategy=@var{strategy} \n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n -m96bit-long-double -mlong-double-64 -mlong-double-80 @gol\n -mregparm=@var{num}  -msseregparm @gol\n@@ -14651,6 +14652,24 @@ Expand into an inline loop.\n Always use a library call.\n @end table\n \n+@item -mmemcpy-strategy=@var{strategy}\n+@opindex mmemcpy-strategy=@var{strategy}\n+Override the internal decision heuristic to decide if @code{__builtin_memcpy}\n+should be inlined and what inline algorithm to use when the expected size\n+of the copy operation is known. @var{strategy} \n+is a comma-separated list of @var{alg}:@var{max_size}:@var{dest_align} triplets. \n+@var{alg} is specified in @option{-mstringop-strategy}, @var{max_size} specifies\n+the max byte size with which inline algorithm @var{alg} is allowed.  For the last\n+triplet, the @var{max_size} must be @code{-1}. The @var{max_size} of the triplets\n+in the list must be specified in increasing order.  The minimal byte size for \n+@var{alg} is @code{0} for the first triplet and @code{@var{max_size} + 1} of the \n+preceding range.\n+\n+@item -mmemset-strategy=@var{strategy}\n+@opindex mmemset-strategy=@var{strategy}\n+The option is similar to @option{-mmemcpy-strategy=} except that it is to control\n+@code{__builtin_memset} expansion.\n+\n @item -momit-leaf-frame-pointer\n @opindex momit-leaf-frame-pointer\n Don't keep the frame pointer in a register for leaf functions.  This"}, {"sha": "6ecfe7ea01b42d69da7e217c37edfcb1dfa963e4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -1,3 +1,10 @@\n+2013-08-09  Xinliang David Li  <davidxl@google.com>\n+\n+\t* gcc.target/i386/memcpy-strategy-1.c: New test.\n+\t* gcc.target/i386/memcpy-strategy-2.c: Ditto.\n+\t* gcc.target/i386/memset-strategy-1.c: Ditto.\n+\t* gcc.target/i386/memcpy-strategy-3.c: Ditto.\n+\n 2013-08-09  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/tree-prof/crossmodule-indircall-1.c: New testcase."}, {"sha": "a2b66d966d00daa8c2a28350ef725da37f2c7f8a", "filename": "gcc/testsuite/gcc.target/i386/memcpy-strategy-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-1.c?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=atom -mmemcpy-strategy=vector_loop:-1:align\" } */\n+/* { dg-final { scan-assembler-times \"movdqa\" 8 { target { ! { ia32 } } } } } */\n+/* { dg-final { scan-assembler-times \"movdqa\" 4 { target { ia32 } } } } */\n+\n+char a[2048];\n+char b[2048];\n+void t (void)\n+{\n+  __builtin_memcpy (a, b, 2048);\n+}\n+"}, {"sha": "c2f49f0cc5f816250836d7cf742e7f685a404d51", "filename": "gcc/testsuite/gcc.target/i386/memcpy-strategy-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-2.c?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=atom -mmemcpy-strategy=vector_loop:3000:align,libcall:-1:align\" } */\n+/* { dg-final { scan-assembler-times \"movdqa\" 8 { target { ! { ia32 } } } } } */\n+/* { dg-final { scan-assembler-times \"movdqa\" 4 { target { ia32 } } } } */\n+\n+char a[2048];\n+char b[2048];\n+void t (void)\n+{\n+  __builtin_memcpy (a, b, 2048);\n+}\n+"}, {"sha": "ddd1ef7c0b2315b98d640266b5cb4ca9fdf82f16", "filename": "gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-3.c?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=atom -mmemcpy-strategy=vector_loop:2000:align,libcall:-1:align\" } */\n+/* { dg-final { scan-assembler-times \"memcpy\" 2  } } */\n+\n+char a[2048];\n+char b[2048];\n+void t (void)\n+{\n+  __builtin_memcpy (a, b, 2048);\n+}"}, {"sha": "d1b97c5df10a851071d28be2e9080e776764d418", "filename": "gcc/testsuite/gcc.target/i386/memset-strategy-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad83025ea6eda7c673e368f44d86164fba30c1a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-1.c?ref=ad83025ea6eda7c673e368f44d86164fba30c1a6", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=atom -mmemset-strategy=libcall:-1:align\" } */\n+/* { dg-final { scan-assembler-times \"memset\" 2  } } */\n+\n+char a[2048];\n+void t (void)\n+{\n+  __builtin_memset (a, 1, 2048);\n+}\n+"}]}