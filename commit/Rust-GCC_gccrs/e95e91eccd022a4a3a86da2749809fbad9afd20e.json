{"sha": "e95e91eccd022a4a3a86da2749809fbad9afd20e", "node_id": "C_kwDOANBUbNoAKGU5NWU5MWVjY2QwMjJhNGEzYTg2ZGEyNzQ5ODA5ZmJhZDlhZmQyMGU", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-09-18T13:27:18Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-10-09T11:38:34Z"}, "message": "pru: Add cbranchdi4 pattern\n\nManually expanding into 32-bit comparisons is much more efficient than\nthe default expansion into word-size comparisons.  Note that word for PRU\nis 8-bit.\n\n\tPR target/106562\n\ngcc/ChangeLog:\n\n\t* config/pru/pru-protos.h (pru_noteq_condition): New\n\tfunction declaration.\n\t* config/pru/pru.cc (pru_noteq_condition): New function.\n\t* config/pru/pru.md (cbranchdi4): Define new pattern.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/pru/pr106562-1.c: New test.\n\t* gcc.target/pru/pr106562-2.c: New test.\n\t* gcc.target/pru/pr106562-3.c: New test.\n\t* gcc.target/pru/pr106562-4.c: New test.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "a7dbe3b491bf1869d761f3d7222f47412d87dc06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7dbe3b491bf1869d761f3d7222f47412d87dc06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e95e91eccd022a4a3a86da2749809fbad9afd20e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95e91eccd022a4a3a86da2749809fbad9afd20e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95e91eccd022a4a3a86da2749809fbad9afd20e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95e91eccd022a4a3a86da2749809fbad9afd20e/comments", "author": null, "committer": null, "parents": [{"sha": "73137f365a01327ae245fa0a9f0b127cb06e0cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73137f365a01327ae245fa0a9f0b127cb06e0cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73137f365a01327ae245fa0a9f0b127cb06e0cb3"}], "stats": {"total": 388, "additions": 388, "deletions": 0}, "files": [{"sha": "517fa02e272925e9e6f75939ff4a6d555352e0a4", "filename": "gcc/config/pru/pru-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-protos.h?ref=e95e91eccd022a4a3a86da2749809fbad9afd20e", "patch": "@@ -52,6 +52,7 @@ extern const char *pru_output_signed_cbranch (rtx *, bool);\n extern const char *pru_output_signed_cbranch_ubyteop2 (rtx *, bool);\n extern const char *pru_output_signed_cbranch_zeroop2 (rtx *, bool);\n \n+extern enum rtx_code pru_noteq_condition (enum rtx_code code);\n extern rtx pru_expand_fp_compare (rtx comparison, machine_mode mode);\n \n extern void pru_emit_doloop (rtx *, int);"}, {"sha": "0029dcbc6aaddd02ba835d0fc4eb83ff220ed11d", "filename": "gcc/config/pru/pru.cc", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Fconfig%2Fpru%2Fpru.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Fconfig%2Fpru%2Fpru.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.cc?ref=e95e91eccd022a4a3a86da2749809fbad9afd20e", "patch": "@@ -895,6 +895,27 @@ pru_init_libfuncs (void)\n   set_optab_libfunc (udivmod_optab, DImode, \"__pruabi_divremull\");\n }\n \n+/* Given a comparison CODE, return a similar comparison but without\n+   the \"equals\" condition.  In other words, it strips GE/GEU/LE/LEU\n+   and instead returns GT/GTU/LT/LTU.  */\n+\n+enum rtx_code\n+pru_noteq_condition (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case GT: return GT;\n+    case GTU: return GTU;\n+    case GE: return GT;\n+    case GEU: return GTU;\n+    case LT: return LT;\n+    case LTU: return LTU;\n+    case LE: return LT;\n+    case LEU: return LTU;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n /* Emit comparison instruction if necessary, returning the expression\n    that holds the compare result in the proper mode.  Return the comparison"}, {"sha": "bdc5ad79ba06008e9fbf2aade395b4195e1b2a76", "filename": "gcc/config/pru/pru.md", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=e95e91eccd022a4a3a86da2749809fbad9afd20e", "patch": "@@ -1309,6 +1309,186 @@\n   operands[2] = XEXP (t, 1);\n })\n \n+;; Expand the cbranchdi pattern in order to avoid the default\n+;; expansion into word_mode operations, which is not efficient for PRU.\n+;; In pseudocode this expansion outputs:\n+;;\n+;; /* EQ */\n+;; if (OP1_hi {reverse_condition (cmp)} OP2_hi)\n+;;     goto fallthrough\n+;; if (OP1_lo {cmp} OP2_lo)\n+;;     goto label3\n+;; fallthrough:\n+;;\n+;; /* NE */\n+;; if (OP1_hi {cmp} OP2_hi)\n+;;     goto label3\n+;; if (OP1_lo {cmp} OP2_lo)\n+;;     goto label3\n+;;\n+;; The LT comparisons with zero take one machine instruction to simply\n+;; check the sign bit.  The GT comparisons with zero take two - one\n+;; to check the sign bit, and one to check for zero.  Hence arrange\n+;; the expand such that only LT comparison is used for OP1_HI, because\n+;; OP2_HI is const0_rtx.\n+;;\n+;; The LTU comparisons with zero will be removed by subsequent passes.\n+;;\n+;;  /* LT/LTU/LE/LEU */\n+;;  if (OP1_hi {noteq_condition (cmp)} OP2_hi)\n+;;     goto label3\t\t/* DI comparison obviously true.  */\n+;;  if (OP1_hi != OP2_hi)\n+;;     goto fallthrough\t\t/* DI comparison obviously not true.  */\n+;;  if (OP1_lo {unsigned_condition (cmp)} OP2_lo)\n+;;     goto label3\t\t/* Comparison was deferred to lo parts.  */\n+;;  fallthrough:\n+\n+;;  /* GT/GTU/GE/GEU */\n+;;  if (OP1_hi {reverse_condition (noteq_condition (cmp))} OP2_hi)\n+;;     goto fallthrough \t/* DI comparison obviously not true.  */\n+;;  if (OP1_hi != OP2_hi)\n+;;     goto label3\t\t/* DI comparison obviously true.  */\n+;;  if (OP1_lo {unsigned_condition (cmp)} OP2_lo)\n+;;     goto label3\t\t/* Comparison was deferred to lo parts.  */\n+;;  fallthrough:\n+\n+(define_expand \"cbranchdi4\"\n+  [(set (pc)\n+     (if_then_else\n+       (match_operator 0 \"ordered_comparison_operator\"\n+\t [(match_operand:DI 1 \"register_operand\")\n+\t  (match_operand:DI 2 \"reg_or_ubyte_operand\")])\n+       (label_ref (match_operand 3 \"\"))\n+       (pc)))]\n+  \"\"\n+{\n+  const enum rtx_code code = GET_CODE (operands[0]);\n+  rtx label3 = operands[3];\n+  rtx op1_lo = simplify_gen_subreg (SImode, operands[1], DImode, 0);\n+  rtx op1_hi = simplify_gen_subreg (SImode, operands[1], DImode, 4);\n+  rtx op2_lo = simplify_gen_subreg (SImode, operands[2], DImode, 0);\n+  rtx op2_hi = simplify_gen_subreg (SImode, operands[2], DImode, 4);\n+  rtx j;\n+\n+  if (code == EQ)\n+    {\n+      rtx label_fallthrough = gen_label_rtx ();\n+      rtx label_fallthrough_ref = gen_rtx_LABEL_REF (Pmode, label_fallthrough);\n+\n+      rtx cond_hi = gen_rtx_fmt_ee (NE, VOIDmode, op1_hi, op2_hi);\n+      rtx check_hi = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_hi,\n+\t\t\t\t\t   label_fallthrough_ref, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_hi));\n+      JUMP_LABEL (j) = label_fallthrough;\n+      LABEL_NUSES (label_fallthrough)++;\n+\n+      rtx label3_ref = gen_rtx_LABEL_REF (Pmode, label3);\n+      rtx cond_lo = gen_rtx_fmt_ee (EQ, VOIDmode, op1_lo, op2_lo);\n+      rtx check_lo = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_lo,\n+\t\t\t\t\t   label3_ref, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_lo));\n+      JUMP_LABEL (j) = label3;\n+      LABEL_NUSES (label3)++;\n+\n+      emit_label (label_fallthrough);\n+      DONE;\n+    }\n+  if (code == NE)\n+    {\n+      rtx label3_ref1 = gen_rtx_LABEL_REF (Pmode, label3);\n+      rtx cond_hi = gen_rtx_fmt_ee (NE, VOIDmode, op1_hi, op2_hi);\n+      rtx check_hi = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_hi,\n+\t\t\t\t\t   label3_ref1, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_hi));\n+      JUMP_LABEL (j) = label3;\n+      LABEL_NUSES (label3)++;\n+\n+      rtx label3_ref2 = gen_rtx_LABEL_REF (Pmode, label3);\n+      rtx cond_lo = gen_rtx_fmt_ee (NE, VOIDmode, op1_lo, op2_lo);\n+      rtx check_lo = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_lo,\n+\t\t\t\t\t   label3_ref2, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_lo));\n+      JUMP_LABEL (j) = label3;\n+      LABEL_NUSES (label3)++;\n+\n+      DONE;\n+    }\n+\n+  if (code == LT || code == LTU || code == LE || code == LEU)\n+    {\n+      /* Check for \"DI comparison obviously true\".  */\n+      rtx label3_ref1 = gen_rtx_LABEL_REF (Pmode, label3);\n+      rtx cond_hi = gen_rtx_fmt_ee (pru_noteq_condition (code),\n+\t\t\t\t    VOIDmode, op1_hi, op2_hi);\n+      rtx check_hi = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_hi,\n+\t\t\t\t\t   label3_ref1, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_hi));\n+      JUMP_LABEL (j) = label3;\n+      LABEL_NUSES (label3)++;\n+\n+      /* Check for \"DI comparison obviously not true\".  */\n+      rtx label_fallthrough = gen_label_rtx ();\n+      rtx label_fallthrough_ref = gen_rtx_LABEL_REF (Pmode, label_fallthrough);\n+      rtx cond_hine = gen_rtx_fmt_ee (NE, VOIDmode, op1_hi, op2_hi);\n+      rtx check_hine = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_hine,\n+\t\t\t\t\t     label_fallthrough_ref, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_hine));\n+      JUMP_LABEL (j) = label_fallthrough;\n+      LABEL_NUSES (label_fallthrough)++;\n+\n+      /* Comparison deferred to the lo parts.  */\n+      rtx label3_ref2 = gen_rtx_LABEL_REF (Pmode, label3);\n+      rtx cond_lo = gen_rtx_fmt_ee (unsigned_condition (code),\n+\t\t\t\t    VOIDmode, op1_lo, op2_lo);\n+      rtx check_lo = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_lo,\n+\t\t\t\t\t   label3_ref2, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_lo));\n+      JUMP_LABEL (j) = label3;\n+      LABEL_NUSES (label3)++;\n+\n+      emit_label (label_fallthrough);\n+      DONE;\n+    }\n+\n+  if (code == GT || code == GTU || code == GE || code == GEU)\n+    {\n+      /* Check for \"DI comparison obviously not true\".  */\n+      const enum rtx_code reversed_code = reverse_condition (code);\n+      rtx label_fallthrough = gen_label_rtx ();\n+      rtx label_fallthrough_ref = gen_rtx_LABEL_REF (Pmode, label_fallthrough);\n+      rtx cond_hi = gen_rtx_fmt_ee (pru_noteq_condition (reversed_code),\n+\t\t\t\t    VOIDmode, op1_hi, op2_hi);\n+      rtx check_hi = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_hi,\n+\t\t\t\t\t   label_fallthrough_ref, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_hi));\n+      JUMP_LABEL (j) = label_fallthrough;\n+      LABEL_NUSES (label_fallthrough)++;\n+\n+      /* Check for \"DI comparison obviously true\".  */\n+      rtx label3_ref1 = gen_rtx_LABEL_REF (Pmode, label3);\n+      rtx cond_hine = gen_rtx_fmt_ee (NE, VOIDmode, op1_hi, op2_hi);\n+      rtx check_hine = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_hine,\n+\t\t\t\t\t     label3_ref1, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_hine));\n+      JUMP_LABEL (j) = label3;\n+      LABEL_NUSES (label3)++;\n+\n+      /* Comparison deferred to the lo parts.  */\n+      rtx label3_ref2 = gen_rtx_LABEL_REF (Pmode, label3);\n+      rtx cond_lo = gen_rtx_fmt_ee (unsigned_condition (code),\n+\t\t\t\t    VOIDmode, op1_lo, op2_lo);\n+      rtx check_lo = gen_rtx_IF_THEN_ELSE (VOIDmode, cond_lo,\n+\t\t\t\t\t   label3_ref2, pc_rtx);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, check_lo));\n+      JUMP_LABEL (j) = label3;\n+      LABEL_NUSES (label3)++;\n+\n+      emit_label (label_fallthrough);\n+      DONE;\n+    }\n+    gcc_unreachable ();\n+})\n+\n ;\n ; Bit test branch\n "}, {"sha": "5bfbe52bb01425e8a61e9141322342d2968faf67", "filename": "gcc/testsuite/gcc.target/pru/pr106562-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-1.c?ref=e95e91eccd022a4a3a86da2749809fbad9afd20e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { object-size text <= 40 } } */\n+\n+\n+char test(unsigned long long a, unsigned long long b)\n+{\n+        return a && b;\n+}"}, {"sha": "ec5f82ad89f2b077e7cdafa959af725eacd8f0ff", "filename": "gcc/testsuite/gcc.target/pru/pr106562-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-2.c?ref=e95e91eccd022a4a3a86da2749809fbad9afd20e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { object-size text <= 32 } } */\n+\n+\n+char test(long long a)\n+{\n+        return a > 10;\n+}"}, {"sha": "d0980581f1df0c44a46f924222765a3c76c7643f", "filename": "gcc/testsuite/gcc.target/pru/pr106562-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-3.c?ref=e95e91eccd022a4a3a86da2749809fbad9afd20e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { object-size text <= 32 } } */\n+\n+\n+char test(long long a)\n+{\n+        return a < 10;\n+}"}, {"sha": "b29e426b01250d246b02a4ad6a60483dc2caad55", "filename": "gcc/testsuite/gcc.target/pru/pr106562-4.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95e91eccd022a4a3a86da2749809fbad9afd20e/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106562-4.c?ref=e95e91eccd022a4a3a86da2749809fbad9afd20e", "patch": "@@ -0,0 +1,159 @@\n+/* Functional test for DI comparisons.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-pedantic-errors\" } */\n+\n+/* The default test suite options use \"-ansi\", which\n+   generates spurious errors by enabling \"-Wlong-long\".\n+   Thus override the options and drop \"-ansi\", in order\n+   to freely use 64-bit (long long) types for PRU.  */\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+extern void abort (void);\n+\n+char __attribute__((noinline)) test_lt (int64_t a, int64_t b)\n+{\n+  return a < b;\n+}\n+\n+char __attribute__((noinline)) test_ltu (uint64_t a, uint64_t b)\n+{\n+  return a < b;\n+}\n+\n+char __attribute__((noinline)) test_le (int64_t a, int64_t b)\n+{\n+  return a <= b;\n+}\n+\n+char __attribute__((noinline)) test_leu (uint64_t a, uint64_t b)\n+{\n+  return a <= b;\n+}\n+\n+char __attribute__((noinline)) test_gt (int64_t a, int64_t b)\n+{\n+  return a > b;\n+}\n+\n+char __attribute__((noinline)) test_gtu (uint64_t a, uint64_t b)\n+{\n+  return a > b;\n+}\n+\n+char __attribute__((noinline)) test_ge (int64_t a, int64_t b)\n+{\n+  return a >= b;\n+}\n+\n+char __attribute__((noinline)) test_geu (uint64_t a, uint64_t b)\n+{\n+  return a >= b;\n+}\n+\n+char __attribute__((noinline)) test_eq (uint64_t a, uint64_t b)\n+{\n+  return a == b;\n+}\n+\n+char __attribute__((noinline)) test_ne (uint64_t a, uint64_t b)\n+{\n+  return a != b;\n+}\n+\n+struct test_case {\n+    uint64_t a;\n+    uint64_t b;\n+    char lt;\n+    char ltu;\n+    char le;\n+    char leu;\n+    char gt;\n+    char gtu;\n+    char ge;\n+    char geu;\n+    char eq;\n+    char ne;\n+};\n+\n+const struct test_case cases[] = {\n+  /*                       LT,LTU,LE,LEU,GT,GTU,GE,GEU,EQ,NE */\n+  { 0x1234567800112233ULL,\n+    0x1234567800112233ULL, 0,  0, 1,  1, 0,  0, 1,  1, 1, 0 },\n+  { 0x0000000000000000ULL,\n+    0x0000000000000000ULL, 0,  0, 1,  1, 0,  0, 1,  1, 1, 0 },\n+  { 0xffffffffffffffffULL,\n+    0xffffffffffffffffULL, 0,  0, 1,  1, 0,  0, 1,  1, 1, 0 },\n+\n+  { 0xffffffffffffffefULL,\n+    0xffffffffffffffffULL, 1,  1, 1,  1, 0,  0, 0,  0, 0, 1 },\n+  { 0x8000000000000000ULL,\n+    0xffffffffffffffffULL, 1,  1, 1,  1, 0,  0, 0,  0, 0, 1 },\n+  { 0x80000000ffffffffULL,\n+    0xffffffffffffffffULL, 1,  1, 1,  1, 0,  0, 0,  0, 0, 1 },\n+  { 0x80000000ffffffffULL,\n+    0xffffffff00000000ULL, 1,  1, 1,  1, 0,  0, 0,  0, 0, 1 },\n+  { 0xffefffffffffffffULL,\n+    0xffffffffffffffffULL, 1,  1, 1,  1, 0,  0, 0,  0, 0, 1 },\n+\n+  { 0x0000000000000000ULL,\n+    0xffffffffffffffffULL, 0,  1, 0,  1, 1,  0, 1,  0, 0, 1 },\n+  { 0x0000000000000001ULL,\n+    0xffffffffffffffffULL, 0,  1, 0,  1, 1,  0, 1,  0, 0, 1 },\n+  { 0x0000000000000001ULL,\n+    0x8000000000000000ULL, 0,  1, 0,  1, 1,  0, 1,  0, 0, 1 },\n+  { 0x7fffffffffffffffULL,\n+    0x8000000000000000ULL, 0,  1, 0,  1, 1,  0, 1,  0, 0, 1 },\n+\n+  /* Ensure lo uses unsigned comparison if hi parts are same.  */\n+  { 0x12345678ffffffffULL,\n+    0x1234567800000001ULL, 0,  0, 0,  0, 1,  1, 1,  1, 0, 1 },\n+  { 0xf23456780fffffffULL,\n+    0xf234567800000001ULL, 0,  0, 0,  0, 1,  1, 1,  1, 0, 1 },\n+  { 0xf2345678ffffffffULL,\n+    0xf234567800000001ULL, 0,  0, 0,  0, 1,  1, 1,  1, 0, 1 },\n+  { 0x1234567800000002ULL,\n+    0x1234567800000001ULL, 0,  0, 0,  0, 1,  1, 1,  1, 0, 1 },\n+  { 0x1234567800000002ULL,\n+    0x1234567800000003ULL, 1,  1, 1,  1, 0,  0, 0,  0, 0, 1 },\n+};\n+\n+int\n+main (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < (sizeof (cases)/sizeof (cases[0])); i++)\n+    {\n+      const int64_t sa = (int64_t)cases[i].a;\n+      const int64_t sb = (int64_t)cases[i].b;\n+      const uint64_t ua = cases[i].a;\n+      const uint64_t ub = cases[i].b;\n+\n+      if (cases[i].lt != test_lt (sa, sb))\n+\tabort ();\n+      if (cases[i].ltu != test_ltu (ua, ub))\n+\tabort ();\n+      if (cases[i].le != test_le (sa, sb))\n+\tabort ();\n+      if (cases[i].leu != test_leu (ua, ub))\n+\tabort ();\n+      if (cases[i].gt != test_gt (sa, sb))\n+\tabort ();\n+      if (cases[i].gtu != test_gtu (ua, ub))\n+\tabort ();\n+      if (cases[i].ge != test_ge (sa, sb))\n+\tabort ();\n+      if (cases[i].geu != test_geu (ua, ub))\n+\tabort ();\n+      if (cases[i].eq != test_eq (ua, ub))\n+\tabort ();\n+      if (cases[i].ne != test_ne (ua, ub))\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+"}]}