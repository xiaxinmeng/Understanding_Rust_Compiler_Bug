{"sha": "86882d9feb6a534325d7162216696266898e36d0", "node_id": "C_kwDOANBUbNoAKDg2ODgyZDlmZWI2YTUzNDMyNWQ3MTYyMjE2Njk2MjY2ODk4ZTM2ZDA", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-06-20T12:44:21Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-06-20T12:44:21Z"}, "message": "vect: Respect slp decision when applying suggested uf [PR105940]\n\nThis follows Richi's suggestion in PR105940, it aims to avoid\ninconsistent slp decision between when the suggested unroll\nfactor is worked out and when the suggested unroll factor is\napplied.\n\nIf the previous slp decision is true when the suggested unroll\nfactor is worked out, when we are applying unroll factor we\ndon't need to start over with slp off if the analysis with slp\non fails.  On the other hand, if the previous slp decision is\nfalse when the suggested unroll factor is worked out, when we\nare applying unroll factor we can skip the slp handlings.\n\nFunction vect_is_simple_reduction saves reduction chains for\nsubsequent slp analyses, we have to disable this early otherwise\nthere is an ICE in vectorizable_reduction for below:\n\n  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n    gcc_assert (slp_node\n\t\t&& REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n\t\t   == stmt_info);\n\n\tPR tree-optimization/105940\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop.cc (vect_analyze_loop_2): Add new parameter\n\tslp_done_for_suggested_uf and adjust with it accordingly.\n\t(vect_analyze_loop_1): Add new variable slp_done_for_suggested_uf,\n\tpass it down to vect_analyze_loop_2 for the initial analysis and\n\tapplying suggested unroll factor.\n\t(vect_is_simple_reduction): Add parameter slp and adjust with it.\n\t(vect_analyze_scalar_cycles_1): Add parameter slp and pass down.\n\t(vect_analyze_scalar_cycles): Likewise.", "tree": {"sha": "791d7aad659e956a70043ffbe70d1b743caf09c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/791d7aad659e956a70043ffbe70d1b743caf09c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86882d9feb6a534325d7162216696266898e36d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86882d9feb6a534325d7162216696266898e36d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86882d9feb6a534325d7162216696266898e36d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86882d9feb6a534325d7162216696266898e36d0/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c56f7983bedd6a36af6ba141cad92e1415682a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56f7983bedd6a36af6ba141cad92e1415682a70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56f7983bedd6a36af6ba141cad92e1415682a70"}], "stats": {"total": 101, "additions": 67, "deletions": 34}, "files": [{"sha": "78dfe8519aa0fb115613cb26f5ec086b5aba4efd", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 67, "deletions": 34, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86882d9feb6a534325d7162216696266898e36d0/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86882d9feb6a534325d7162216696266898e36d0/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=86882d9feb6a534325d7162216696266898e36d0", "patch": "@@ -157,7 +157,7 @@ along with GCC; see the file COPYING3.  If not see\n static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *,\n \t\t\t\t\t\tunsigned *);\n static stmt_vec_info vect_is_simple_reduction (loop_vec_info, stmt_vec_info,\n-\t\t\t\t\t       bool *, bool *);\n+\t\t\t\t\t       bool *, bool *, bool);\n \n /* Subroutine of vect_determine_vf_for_stmt that handles only one\n    statement.  VECTYPE_MAYBE_SET_P is true if STMT_VINFO_VECTYPE\n@@ -463,10 +463,12 @@ vect_inner_phi_in_double_reduction_p (loop_vec_info loop_vinfo, gphi *phi)\n    Examine the cross iteration def-use cycles of scalar variables\n    in LOOP.  LOOP_VINFO represents the loop that is now being\n    considered for vectorization (can be LOOP, or an outer-loop\n-   enclosing LOOP).  */\n+   enclosing LOOP).  SLP indicates there will be some subsequent\n+   slp analyses or not.  */\n \n static void\n-vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, class loop *loop)\n+vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, class loop *loop,\n+\t\t\t      bool slp)\n {\n   basic_block bb = loop->header;\n   tree init, step;\n@@ -545,7 +547,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, class loop *loop)\n \n       stmt_vec_info reduc_stmt_info\n \t= vect_is_simple_reduction (loop_vinfo, stmt_vinfo, &double_reduc,\n-\t\t\t\t    &reduc_chain);\n+\t\t\t\t    &reduc_chain, slp);\n       if (reduc_stmt_info)\n         {\n \t  STMT_VINFO_REDUC_DEF (stmt_vinfo) = reduc_stmt_info;\n@@ -616,11 +618,11 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, class loop *loop)\n                  a[i] = i;  */\n \n static void\n-vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n+vect_analyze_scalar_cycles (loop_vec_info loop_vinfo, bool slp)\n {\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n-  vect_analyze_scalar_cycles_1 (loop_vinfo, loop);\n+  vect_analyze_scalar_cycles_1 (loop_vinfo, loop, slp);\n \n   /* When vectorizing an outer-loop, the inner-loop is executed sequentially.\n      Reductions in such inner-loop therefore have different properties than\n@@ -632,7 +634,7 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n         current checks are too strict.  */\n \n   if (loop->inner)\n-    vect_analyze_scalar_cycles_1 (loop_vinfo, loop->inner);\n+    vect_analyze_scalar_cycles_1 (loop_vinfo, loop->inner, slp);\n }\n \n /* Transfer group and reduction information from STMT_INFO to its\n@@ -2223,12 +2225,18 @@ vect_determine_partial_vectors_and_peeling (loop_vec_info loop_vinfo,\n \n /* Function vect_analyze_loop_2.\n \n-   Apply a set of analyses on LOOP, and create a loop_vec_info struct\n-   for it.  The different analyses will record information in the\n-   loop_vec_info struct.  */\n+   Apply a set of analyses on LOOP specified by LOOP_VINFO, the different\n+   analyses will record information in some members of LOOP_VINFO.  FATAL\n+   indicates if some analysis meets fatal error.  If one non-NULL pointer\n+   SUGGESTED_UNROLL_FACTOR is provided, it's intent to be filled with one\n+   worked out suggested unroll factor, while one NULL pointer shows it's\n+   going to apply the suggested unroll factor.  SLP_DONE_FOR_SUGGESTED_UF\n+   is to hold the slp decision when the suggested unroll factor is worked\n+   out.  */\n static opt_result\n vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal,\n-\t\t     unsigned *suggested_unroll_factor)\n+\t\t     unsigned *suggested_unroll_factor,\n+\t\t     bool& slp_done_for_suggested_uf)\n {\n   opt_result ok = opt_result::success ();\n   int res;\n@@ -2290,9 +2298,18 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal,\n       return ok;\n     }\n \n+  /* Check if we are applying unroll factor now.  */\n+  bool applying_suggested_uf = loop_vinfo->suggested_unroll_factor > 1;\n+  gcc_assert (!applying_suggested_uf || !suggested_unroll_factor);\n+\n+  /* If the slp decision is false when suggested unroll factor is worked\n+     out, and we are applying suggested unroll factor, we can simply skip\n+     all slp related analyses this time.  */\n+  bool slp = !applying_suggested_uf || slp_done_for_suggested_uf;\n+\n   /* Classify all cross-iteration scalar data-flow cycles.\n      Cross-iteration cycles caused by virtual phis are analyzed separately.  */\n-  vect_analyze_scalar_cycles (loop_vinfo);\n+  vect_analyze_scalar_cycles (loop_vinfo, slp);\n \n   vect_pattern_recog (loop_vinfo);\n \n@@ -2359,26 +2376,30 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal,\n \n   poly_uint64 saved_vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n-  /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo, LOOP_VINFO_N_STMTS (loop_vinfo));\n-  if (!ok)\n-    return ok;\n-\n-  /* If there are any SLP instances mark them as pure_slp.  */\n-  bool slp = vect_make_slp_decision (loop_vinfo);\n   if (slp)\n     {\n-      /* Find stmts that need to be both vectorized and SLPed.  */\n-      vect_detect_hybrid_slp (loop_vinfo);\n+      /* Check the SLP opportunities in the loop, analyze and build\n+\t SLP trees.  */\n+      ok = vect_analyze_slp (loop_vinfo, LOOP_VINFO_N_STMTS (loop_vinfo));\n+      if (!ok)\n+\treturn ok;\n+\n+      /* If there are any SLP instances mark them as pure_slp.  */\n+      slp = vect_make_slp_decision (loop_vinfo);\n+      if (slp)\n+\t{\n+\t  /* Find stmts that need to be both vectorized and SLPed.  */\n+\t  vect_detect_hybrid_slp (loop_vinfo);\n \n-      /* Update the vectorization factor based on the SLP decision.  */\n-      vect_update_vf_for_slp (loop_vinfo);\n+\t  /* Update the vectorization factor based on the SLP decision.  */\n+\t  vect_update_vf_for_slp (loop_vinfo);\n \n-      /* Optimize the SLP graph with the vectorization factor fixed.  */\n-      vect_optimize_slp (loop_vinfo);\n+\t  /* Optimize the SLP graph with the vectorization factor fixed.  */\n+\t  vect_optimize_slp (loop_vinfo);\n \n-      /* Gather the loads reachable from the SLP graph entries.  */\n-      vect_gather_slp_loads (loop_vinfo);\n+\t  /* Gather the loads reachable from the SLP graph entries.  */\n+\t  vect_gather_slp_loads (loop_vinfo);\n+\t}\n     }\n \n   bool saved_can_use_partial_vectors_p\n@@ -2394,7 +2415,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal,\n   /* Apply the suggested unrolling factor, this was determined by the backend\n      during finish_cost the first time we ran the analyzis for this\n      vector mode.  */\n-  if (loop_vinfo->suggested_unroll_factor > 1)\n+  if (applying_suggested_uf)\n     LOOP_VINFO_VECT_FACTOR (loop_vinfo) *= loop_vinfo->suggested_unroll_factor;\n \n   /* Now the vectorization factor is final.  */\n@@ -2665,6 +2686,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal,\n   gcc_assert (known_eq (vectorization_factor,\n \t\t\tLOOP_VINFO_VECT_FACTOR (loop_vinfo)));\n \n+  slp_done_for_suggested_uf = slp;\n+\n   /* Ok to vectorize!  */\n   LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n   return opt_result::success ();\n@@ -2678,6 +2701,12 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal,\n   if (!slp)\n     return ok;\n \n+  /* If the slp decision is true when suggested unroll factor is worked\n+     out, and we are applying suggested unroll factor, we don't need to\n+     re-try any more.  */\n+  if (applying_suggested_uf && slp_done_for_suggested_uf)\n+    return ok;\n+\n   /* If there are reduction chains re-trying will fail anyway.  */\n   if (! LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo).is_empty ())\n     return ok;\n@@ -2864,10 +2893,12 @@ vect_analyze_loop_1 (class loop *loop, vec_info_shared *shared,\n   machine_mode vector_mode = vector_modes[mode_i];\n   loop_vinfo->vector_mode = vector_mode;\n   unsigned int suggested_unroll_factor = 1;\n+  bool slp_done_for_suggested_uf;\n \n   /* Run the main analysis.  */\n   opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal,\n-\t\t\t\t\t&suggested_unroll_factor);\n+\t\t\t\t\t&suggested_unroll_factor,\n+\t\t\t\t\tslp_done_for_suggested_uf);\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"***** Analysis %s with vector mode %s\\n\",\n@@ -2879,13 +2910,15 @@ vect_analyze_loop_1 (class loop *loop, vec_info_shared *shared,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"***** Re-trying analysis for unrolling\"\n-\t\t\t \" with unroll factor %d.\\n\",\n-\t\t\t suggested_unroll_factor);\n+\t\t\t \" with unroll factor %d and slp %s.\\n\",\n+\t\t\t suggested_unroll_factor,\n+\t\t\t slp_done_for_suggested_uf ? \"on\" : \"off\");\n       loop_vec_info unroll_vinfo\n \t= vect_create_loop_vinfo (loop, shared, loop_form_info, main_loop_vinfo);\n       unroll_vinfo->vector_mode = vector_mode;\n       unroll_vinfo->suggested_unroll_factor = suggested_unroll_factor;\n-      opt_result new_res = vect_analyze_loop_2 (unroll_vinfo, fatal, NULL);\n+      opt_result new_res = vect_analyze_loop_2 (unroll_vinfo, fatal, NULL,\n+\t\t\t\t\t\tslp_done_for_suggested_uf);\n       if (new_res)\n \t{\n \t  delete loop_vinfo;\n@@ -3598,7 +3631,7 @@ check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n \n static stmt_vec_info\n vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n-\t\t\t  bool *double_reduc, bool *reduc_chain_p)\n+\t\t\t  bool *double_reduc, bool *reduc_chain_p, bool slp)\n {\n   gphi *phi = as_a <gphi *> (phi_info->stmt);\n   gimple *phi_use_stmt = NULL;\n@@ -3787,7 +3820,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n \t    continue;\n \t  reduc_chain.safe_push (stmt_info);\n \t}\n-      if (is_slp_reduc && reduc_chain.length () > 1)\n+      if (slp && is_slp_reduc && reduc_chain.length () > 1)\n \t{\n \t  for (unsigned i = 0; i < reduc_chain.length () - 1; ++i)\n \t    {"}]}