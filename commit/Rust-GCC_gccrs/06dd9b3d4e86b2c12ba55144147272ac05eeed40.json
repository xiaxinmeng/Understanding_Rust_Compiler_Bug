{"sha": "06dd9b3d4e86b2c12ba55144147272ac05eeed40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkZDliM2Q0ZTg2YjJjMTJiYTU1MTQ0MTQ3MjcyYWMwNWVlZWQ0MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-06-07T08:14:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-06-07T08:14:04Z"}, "message": "Make aliasing_component_refs_p to work harder when same_type_for_tbaa returns -1\n\n\t* tree-ssa-alias.c (aliasing_component_refs_p): Do not give up\n\timmediately after same_types_for_tbaa_p returns -1 and continue\n\tlooking for possible exact match; if matching types are arrays\n\twatch for partial overlaps.\n\t(indirect_ref_may_alias_decl_p): Watch for partial array overlaps.\n\t(indirect_refs_may_alias_p): Do type based disambiguation first;\n\tupdate comment.\n\n\t* gcc.dg/lto/alias-access-path-2.0.c: New testcase.\n\nFrom-SVN: r272036", "tree": {"sha": "bcae61cc6b9edd79728bdaf5e9785f3b7ddba52b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcae61cc6b9edd79728bdaf5e9785f3b7ddba52b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06dd9b3d4e86b2c12ba55144147272ac05eeed40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06dd9b3d4e86b2c12ba55144147272ac05eeed40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06dd9b3d4e86b2c12ba55144147272ac05eeed40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06dd9b3d4e86b2c12ba55144147272ac05eeed40/comments", "author": null, "committer": null, "parents": [{"sha": "6c202d9dc65833e04e35f566c645fde8278c1a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c202d9dc65833e04e35f566c645fde8278c1a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c202d9dc65833e04e35f566c645fde8278c1a24"}], "stats": {"total": 127, "additions": 109, "deletions": 18}, "files": [{"sha": "dbe6909a76580875e417eca92c9dda7a17ee63b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06dd9b3d4e86b2c12ba55144147272ac05eeed40", "patch": "@@ -1,3 +1,13 @@\n+2019-06-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (aliasing_component_refs_p): Do not give up\n+\timmediately after same_types_for_tbaa_p returns -1 and continue\n+\tlooking for possible exact match; if matching types are arrays\n+\twatch for partial overlaps.\n+\t(indirect_ref_may_alias_decl_p): Watch for partial array overlaps.\n+\t(indirect_refs_may_alias_p): Do type based disambiguation first;\n+\tupdate comment.\n+\n 2019-06-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* fwprop.c (propagate_rtx): Fix call to paradoxical_subreg_p."}, {"sha": "9410686a9f700bdd65c03baed40c707e8348a1ad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06dd9b3d4e86b2c12ba55144147272ac05eeed40", "patch": "@@ -1,3 +1,7 @@\n+2019-06-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/lto/alias-access-path-2.0.c: New testcase.\n+\n 2019-06-07  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/78902"}, {"sha": "7a53a1a83288dfa84d0be88d5eb2bc7493076bb0", "filename": "gcc/testsuite/gcc.dg/lto/alias-access-path-2_0.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Falias-access-path-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Falias-access-path-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Falias-access-path-2_0.c?ref=06dd9b3d4e86b2c12ba55144147272ac05eeed40", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options { { -O3 -flto -fno-early-inlining } } } */\n+\n+/* In this test the access patch orracle (aliasing_component_refs_p)\n+   can disambiguage array[0] from array[1] by base+offset but it needs to be\n+   able to find the common type and not give up by not being able to compare\n+   types earlier.  */\n+\n+typedef int (*fnptr) ();\n+\n+__attribute__ ((used))\n+struct a\n+{\n+  void *array[2];\n+} a, *aptr = &a;\n+\n+__attribute__ ((used))\n+struct b\n+{\n+ struct a a;\n+} *bptr;\n+\n+static void\n+inline_me_late (int argc)\n+{\n+  if (argc == -1)\n+    bptr->a.array[1] = bptr;\n+}\n+\n+int\n+main (int argc)\n+{\n+  aptr->array[0] = 0;\n+  inline_me_late (argc);\n+  if (!__builtin_constant_p (aptr->array[0] == 0))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "ebe05544bad09e0e61df3c075f13b62b8deada8a", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06dd9b3d4e86b2c12ba55144147272ac05eeed40/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=06dd9b3d4e86b2c12ba55144147272ac05eeed40", "patch": "@@ -860,6 +860,7 @@ aliasing_component_refs_p (tree ref1,\n   tree type1, type2;\n   tree *refp;\n   int same_p1 = 0, same_p2 = 0;\n+  bool maybe_match = false;\n \n   /* Choose bases and base types to search for.  */\n   base1 = ref1;\n@@ -890,8 +891,14 @@ aliasing_component_refs_p (tree ref1,\n \t  if (cmp == 0)\n \t    {\n \t      same_p2 = same_type_for_tbaa (TREE_TYPE (*refp), type1);\n-\t      if (same_p2 != 0)\n+\t      if (same_p2 == 1)\n \t\tbreak;\n+\t      /* In case we can't decide whether types are same try to\n+\t\t continue looking for the exact match.\n+\t\t Remember however that we possibly saw a match\n+\t\t to bypass the access path continuations tests we do later.  */\n+\t      if (same_p2 == -1)\n+\t\tmaybe_match = true;\n \t    }\n \t  if (!handled_component_p (*refp))\n \t    break;\n@@ -901,6 +908,21 @@ aliasing_component_refs_p (tree ref1,\n \t{\n \t  poly_int64 offadj, sztmp, msztmp;\n \t  bool reverse;\n+\n+\t  /* We assume that arrays can overlap by multiple of their elements\n+\t     size as tested in gcc.dg/torture/alias-2.c.\n+\t     This partial overlap happen only when both arrays are bases of\n+\t     the access and not contained within another component ref.\n+\t     To be safe we also assume partial overlap for VLAs.  */\n+\t  if (TREE_CODE (TREE_TYPE (base1)) == ARRAY_TYPE\n+\t      && (!TYPE_SIZE (TREE_TYPE (base1))\n+\t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) != INTEGER_CST\n+\t\t  || (*refp == base2 && !ref2_is_decl)))\n+\t    {\n+\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n+\t      return true;\n+\t    }\n+\n \t  get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n \t  offset2 -= offadj;\n \t  get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp, &reverse);\n@@ -932,8 +954,10 @@ aliasing_component_refs_p (tree ref1,\n \t  if (cmp == 0)\n \t    {\n \t      same_p1 = same_type_for_tbaa (TREE_TYPE (*refp), type2);\n-\t      if (same_p1 != 0)\n+\t      if (same_p1 == 1)\n \t\tbreak;\n+\t      if (same_p1 == -1)\n+\t\tmaybe_match = true;\n \t    }\n \t  if (!handled_component_p (*refp))\n \t    break;\n@@ -944,6 +968,15 @@ aliasing_component_refs_p (tree ref1,\n \t  poly_int64 offadj, sztmp, msztmp;\n \t  bool reverse;\n \n+\t  if (TREE_CODE (TREE_TYPE (base2)) == ARRAY_TYPE\n+\t      && (!TYPE_SIZE (TREE_TYPE (base2))\n+\t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base2))) != INTEGER_CST\n+\t\t  || (*refp == base1 && !ref2_is_decl)))\n+\t    {\n+\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n+\t      return true;\n+\t    }\n+\n \t  get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n \t  offset1 -= offadj;\n \t  get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n@@ -965,7 +998,7 @@ aliasing_component_refs_p (tree ref1,\n      paths do not overlap and thus accesses alias only if one path can be\n      continuation of another.  If we was not able to decide about equivalence,\n      we need to give up.  */\n-  if (same_p1 == -1 || same_p2 == -1)\n+  if (maybe_match)\n     return true;\n \n   /* If we have two type access paths B1.path1 and B2.path2 they may\n@@ -1350,10 +1383,17 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n      For MEM_REFs we require that the component-ref offset we computed\n      is relative to the start of the type which we ensure by\n      comparing rvalue and access type and disregarding the constant\n-     pointer offset.  */\n+     pointer offset.\n+\n+     But avoid treating variable length arrays as \"objects\", instead assume they\n+     can overlap by an exact multiple of their element size.\n+     See gcc.dg/torture/alias-2.c.  */\n   if ((TREE_CODE (base1) != TARGET_MEM_REF\n        || (!TMR_INDEX (base1) && !TMR_INDEX2 (base1)))\n-      && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (dbase2)) == 1)\n+      && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (dbase2)) == 1\n+      && (TREE_CODE (TREE_TYPE (base1)) != ARRAY_TYPE\n+\t  || (TYPE_SIZE (TREE_TYPE (base1))\n+\t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) == INTEGER_CST)))\n     return ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2);\n \n   if (ref1 && ref2\n@@ -1446,32 +1486,31 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       || base2_alias_set == 0)\n     return true;\n \n+  /* Do type-based disambiguation.  */\n+  if (base1_alias_set != base2_alias_set\n+      && !alias_sets_conflict_p (base1_alias_set, base2_alias_set))\n+    return false;\n+\n+  /* If either reference is view-converted, give up now.  */\n+  if (same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) != 1\n+      || same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) != 1)\n+    return true;\n+\n   /* If both references are through the same type, they do not alias\n      if the accesses do not overlap.  This does extra disambiguation\n      for mixed/pointer accesses but requires strict aliasing.  */\n   if ((TREE_CODE (base1) != TARGET_MEM_REF\n        || (!TMR_INDEX (base1) && !TMR_INDEX2 (base1)))\n       && (TREE_CODE (base2) != TARGET_MEM_REF\n \t  || (!TMR_INDEX (base2) && !TMR_INDEX2 (base2)))\n-      && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1\n-      && same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) == 1\n       && same_type_for_tbaa (TREE_TYPE (ptrtype1),\n \t\t\t     TREE_TYPE (ptrtype2)) == 1\n       /* But avoid treating arrays as \"objects\", instead assume they\n-         can overlap by an exact multiple of their element size.  */\n+         can overlap by an exact multiple of their element size.\n+         See gcc.dg/torture/alias-2.c.  */\n       && TREE_CODE (TREE_TYPE (ptrtype1)) != ARRAY_TYPE)\n     return ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2);\n \n-  /* Do type-based disambiguation.  */\n-  if (base1_alias_set != base2_alias_set\n-      && !alias_sets_conflict_p (base1_alias_set, base2_alias_set))\n-    return false;\n-\n-  /* If either reference is view-converted, give up now.  */\n-  if (same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) != 1\n-      || same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) != 1)\n-    return true;\n-\n   if (ref1 && ref2\n       && nonoverlapping_component_refs_p (ref1, ref2))\n     return false;"}]}