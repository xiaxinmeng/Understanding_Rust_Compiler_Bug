{"sha": "108fdcc56ee49dd7dc8314ce5022191f406a125f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA4ZmRjYzU2ZWU0OWRkN2RjODMxNGNlNTAyMjE5MWY0MDZhMTI1Zg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-07-27T22:19:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-07-28T00:05:17Z"}, "message": "compiler,runtime: pass only ptr and len to some runtime calls\n\nThis ports https://golang.org/cl/227163 to the Go frontend.\nThis is a step toward moving up to the go1.15rc1 release.\n\nOriginal CL description:\n\n    cmd/compile,runtime: pass only ptr and len to some runtime calls\n\n    Some runtime calls accept a slice, but only use ptr and len.\n    This change modifies most such routines to accept only ptr and len.\n\n    After this change, the only runtime calls that accept an unnecessary\n    cap arg are concatstrings and slicerunetostring.\n    Neither is particularly common, and both are complicated to modify.\n\n    Negligible compiler performance impact. Shrinks binaries a little.\n    There are only a few regressions; the one I investigated was\n    due to register allocation fluctuation.\n\n    Passes 'go test -race std cmd', modulo golang/go#38265 and golang/go#38266.\n    Wow, does that take a long time to run.\n\n    file      before    after     \u0394       %\n    compile   19655024  19655152  +128    +0.001%\n    cover     5244840   5236648   -8192   -0.156%\n    dist      3662376   3658280   -4096   -0.112%\n    link      6680056   6675960   -4096   -0.061%\n    pprof     14789844  14777556  -12288  -0.083%\n    test2json 2824744   2820648   -4096   -0.145%\n    trace     11647876  11639684  -8192   -0.070%\n    vet       8260472   8256376   -4096   -0.050%\n    total     115163736 115118808 -44928  -0.039%\n\nFor golang/go#36890\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/245099", "tree": {"sha": "60009bd42da0b9f335a0f4ab9d0179e9db0fd778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60009bd42da0b9f335a0f4ab9d0179e9db0fd778"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/108fdcc56ee49dd7dc8314ce5022191f406a125f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108fdcc56ee49dd7dc8314ce5022191f406a125f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108fdcc56ee49dd7dc8314ce5022191f406a125f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108fdcc56ee49dd7dc8314ce5022191f406a125f/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d3a86fd3e91ccdbc702fc99595116adeded0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1d3a86fd3e91ccdbc702fc99595116adeded0d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1d3a86fd3e91ccdbc702fc99595116adeded0d5"}], "stats": {"total": 206, "additions": 108, "deletions": 98}, "files": [{"sha": "64a655e911efa49965f5431381ab2c8547d72b6a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -1,4 +1,4 @@\n-8b9c7fb00ccaf1d4bcc8d581a1a4d46a35771b77\n+63bc2430187efe5ff47e9c7b9cd6d40b350ee7d7\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "90f860bd7353a19b490795e44375a27c2ebc2687", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -4157,45 +4157,43 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n       go_assert(e->integer_type() != NULL);\n       go_assert(this->expr_->is_variable());\n \n-      Runtime::Function code;\n+      Expression* buf;\n+      if (this->no_escape_ && !this->no_copy_)\n+        {\n+          Type* byte_type = Type::lookup_integer_type(\"uint8\");\n+          Expression* buflen =\n+            Expression::make_integer_ul(tmp_string_buf_size, NULL, loc);\n+          Type* array_type = Type::make_array_type(byte_type, buflen);\n+          buf = Expression::make_allocation(array_type, loc);\n+          buf->allocation_expression()->set_allocate_on_stack();\n+          buf->allocation_expression()->set_no_zero();\n+        }\n+      else\n+        buf = Expression::make_nil(loc);\n+\n       if (e->integer_type()->is_byte())\n         {\n+\t  Expression* ptr =\n+\t    Expression::make_slice_info(this->expr_, SLICE_INFO_VALUE_POINTER,\n+\t\t\t\t\tloc);\n+\t  Expression* len =\n+\t    Expression::make_slice_info(this->expr_, SLICE_INFO_LENGTH, loc);\n           if (this->no_copy_)\n             {\n               if (gogo->debug_optimization())\n                 go_debug(loc, \"no copy string([]byte)\");\n-              Expression* ptr = Expression::make_slice_info(this->expr_,\n-                                                            SLICE_INFO_VALUE_POINTER,\n-                                                            loc);\n-              Expression* len = Expression::make_slice_info(this->expr_,\n-                                                            SLICE_INFO_LENGTH,\n-                                                            loc);\n               Expression* str = Expression::make_string_value(ptr, len, loc);\n               return str->get_backend(context);\n             }\n-          code = Runtime::SLICEBYTETOSTRING;\n+\t  return Runtime::make_call(Runtime::SLICEBYTETOSTRING, loc, 3, buf,\n+\t\t\t\t    ptr, len)->get_backend(context);\n         }\n       else\n         {\n           go_assert(e->integer_type()->is_rune());\n-          code = Runtime::SLICERUNETOSTRING;\n-        }\n-\n-      Expression* buf;\n-      if (this->no_escape_)\n-        {\n-          Type* byte_type = Type::lookup_integer_type(\"uint8\");\n-          Expression* buflen =\n-            Expression::make_integer_ul(tmp_string_buf_size, NULL, loc);\n-          Type* array_type = Type::make_array_type(byte_type, buflen);\n-          buf = Expression::make_allocation(array_type, loc);\n-          buf->allocation_expression()->set_allocate_on_stack();\n-          buf->allocation_expression()->set_no_zero();\n-        }\n-      else\n-        buf = Expression::make_nil(loc);\n-      return Runtime::make_call(code, loc, 2, buf,\n-\t\t\t\tthis->expr_)->get_backend(context);\n+\t  return Runtime::make_call(Runtime::SLICERUNETOSTRING, loc, 2, buf,\n+\t\t\t\t    this->expr_)->get_backend(context);\n+\t}\n     }\n   else if (type->is_slice_type() && expr_type->is_string_type())\n     {\n@@ -8397,8 +8395,16 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n         if (et->has_pointer())\n           {\n             Expression* td = Expression::make_type_descriptor(et, loc);\n+\t    Expression* pd =\n+\t      Expression::make_slice_info(arg1, SLICE_INFO_VALUE_POINTER, loc);\n+\t    Expression* ld =\n+\t      Expression::make_slice_info(arg1, SLICE_INFO_LENGTH, loc);\n+\t    Expression* ps =\n+\t      Expression::make_slice_info(arg2, SLICE_INFO_VALUE_POINTER, loc);\n+\t    Expression* ls =\n+\t      Expression::make_slice_info(arg2, SLICE_INFO_LENGTH, loc);\n             ret = Runtime::make_call(Runtime::TYPEDSLICECOPY, loc,\n-                                     3, td, arg1, arg2);\n+                                     5, td, pd, ld, ps, ls);\n           }\n         else\n           {"}, {"sha": "a9500797b4d4b196ebcc2e507bed1427433e50db", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -47,7 +47,7 @@ DEF_GO_RUNTIME(INTSTRING, \"runtime.intstring\", P2(POINTER, INT64), R1(STRING))\n \n // Convert a []byte to a string.\n DEF_GO_RUNTIME(SLICEBYTETOSTRING, \"runtime.slicebytetostring\",\n-\t       P2(POINTER, SLICE), R1(STRING))\n+\t       P3(POINTER, POINTER, INT), R1(STRING))\n \n // Convert a []rune to a string.\n DEF_GO_RUNTIME(SLICERUNETOSTRING, \"runtime.slicerunetostring\",\n@@ -249,17 +249,16 @@ DEF_GO_RUNTIME(CLOSE, \"runtime.closechan\", P1(CHAN), R0())\n \n \n // Copy.\n-DEF_GO_RUNTIME(SLICECOPY, \"runtime.slicecopy\", P3(SLICE, SLICE, UINTPTR),\n-\t       R1(INT))\n+DEF_GO_RUNTIME(SLICECOPY, \"runtime.slicecopy\",\n+\t       P5(POINTER, INT, POINTER, INT, UINTPTR), R1(INT))\n \n // Copy from string.\n-DEF_GO_RUNTIME(SLICESTRINGCOPY, \"runtime.slicestringcopy\", P2(SLICE, STRING),\n-\t       R1(INT))\n+DEF_GO_RUNTIME(SLICESTRINGCOPY, \"runtime.slicestringcopy\",\n+\t       P3(POINTER, INT, STRING), R1(INT))\n \n // Copy of value containing pointers.\n DEF_GO_RUNTIME(TYPEDSLICECOPY, \"runtime.typedslicecopy\",\n-\t       P3(TYPE, SLICE, SLICE), R1(INT))\n-\n+\t       P5(TYPE, POINTER, INT, POINTER, INT), R1(INT))\n \n // Grow a slice for append.\n DEF_GO_RUNTIME(GROWSLICE, \"runtime.growslice\","}, {"sha": "42fdfe80280b1ec1c652410b3724e72285b17b92", "filename": "libgo/go/runtime/cgocheck.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fcgocheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fcgocheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgocheck.go?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -76,23 +76,24 @@ func cgoCheckMemmove(typ *_type, dst, src unsafe.Pointer, off, size uintptr) {\n \tcgoCheckTypedBlock(typ, src, off, size)\n }\n \n-// cgoCheckSliceCopy is called when copying n elements of a slice from\n-// src to dst.  typ is the element type of the slice.\n+// cgoCheckSliceCopy is called when copying n elements of a slice.\n+// src and dst are pointers to the first element of the slice.\n+// typ is the element type of the slice.\n // It throws if the program is copying slice elements that contain Go pointers\n // into non-Go memory.\n //go:nosplit\n //go:nowritebarrier\n-func cgoCheckSliceCopy(typ *_type, dst, src slice, n int) {\n+func cgoCheckSliceCopy(typ *_type, dst, src unsafe.Pointer, n int) {\n \tif typ.ptrdata == 0 {\n \t\treturn\n \t}\n-\tif !cgoIsGoPointer(src.array) {\n+\tif !cgoIsGoPointer(src) {\n \t\treturn\n \t}\n-\tif cgoIsGoPointer(dst.array) {\n+\tif cgoIsGoPointer(dst) {\n \t\treturn\n \t}\n-\tp := src.array\n+\tp := src\n \tfor i := 0; i < n; i++ {\n \t\tcgoCheckTypedBlock(typ, p, 0, typ.size)\n \t\tp = add(p, typ.size)"}, {"sha": "a4f9b3c03506594dc212e97bcab30a87e825c1bc", "filename": "libgo/go/runtime/mbarrier.go", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbarrier.go?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -219,16 +219,14 @@ func reflect_typedmemmovepartial(typ *_type, dst, src unsafe.Pointer, off, size\n }\n \n //go:nosplit\n-func typedslicecopy(typ *_type, dst, src slice) int {\n-\tn := dst.len\n-\tif n > src.len {\n-\t\tn = src.len\n+func typedslicecopy(typ *_type, dstPtr unsafe.Pointer, dstLen int, srcPtr unsafe.Pointer, srcLen int) int {\n+\tn := dstLen\n+\tif n > srcLen {\n+\t\tn = srcLen\n \t}\n \tif n == 0 {\n \t\treturn 0\n \t}\n-\tdstp := dst.array\n-\tsrcp := src.array\n \n \t// The compiler emits calls to typedslicecopy before\n \t// instrumentation runs, so unlike the other copying and\n@@ -237,19 +235,19 @@ func typedslicecopy(typ *_type, dst, src slice) int {\n \tif raceenabled {\n \t\tcallerpc := getcallerpc()\n \t\tpc := funcPC(slicecopy)\n-\t\tracewriterangepc(dstp, uintptr(n)*typ.size, callerpc, pc)\n-\t\tracereadrangepc(srcp, uintptr(n)*typ.size, callerpc, pc)\n+\t\tracewriterangepc(dstPtr, uintptr(n)*typ.size, callerpc, pc)\n+\t\tracereadrangepc(srcPtr, uintptr(n)*typ.size, callerpc, pc)\n \t}\n \tif msanenabled {\n-\t\tmsanwrite(dstp, uintptr(n)*typ.size)\n-\t\tmsanread(srcp, uintptr(n)*typ.size)\n+\t\tmsanwrite(dstPtr, uintptr(n)*typ.size)\n+\t\tmsanread(srcPtr, uintptr(n)*typ.size)\n \t}\n \n \tif writeBarrier.cgo {\n-\t\tcgoCheckSliceCopy(typ, dst, src, n)\n+\t\tcgoCheckSliceCopy(typ, dstPtr, srcPtr, n)\n \t}\n \n-\tif dstp == srcp {\n+\tif dstPtr == srcPtr {\n \t\treturn n\n \t}\n \n@@ -259,11 +257,11 @@ func typedslicecopy(typ *_type, dst, src slice) int {\n \t// before calling typedslicecopy.\n \tsize := uintptr(n) * typ.size\n \tif writeBarrier.needed {\n-\t\tbulkBarrierPreWrite(uintptr(dstp), uintptr(srcp), size)\n+\t\tbulkBarrierPreWrite(uintptr(dstPtr), uintptr(srcPtr), size)\n \t}\n \t// See typedmemmove for a discussion of the race between the\n \t// barrier and memmove.\n-\tmemmove(dstp, srcp, size)\n+\tmemmove(dstPtr, srcPtr, size)\n \treturn n\n }\n \n@@ -293,7 +291,7 @@ func reflect_typedslicecopy(elemType *_type, dst, src slice) int {\n \t\tmemmove(dst.array, src.array, size)\n \t\treturn n\n \t}\n-\treturn typedslicecopy(elemType, dst, src)\n+\treturn typedslicecopy(elemType, dst.array, dst.len, src.array, src.len)\n }\n \n // typedmemclr clears the typed memory at ptr with type typ. The"}, {"sha": "5d5506467156e65fc93778088ab3f7d7cf3d4c3e", "filename": "libgo/go/runtime/os_linux.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fos_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fos_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux.go?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -207,13 +207,14 @@ func getHugePageSize() uintptr {\n \tif fd < 0 {\n \t\treturn 0\n \t}\n-\tn := read(fd, noescape(unsafe.Pointer(&numbuf[0])), int32(len(numbuf)))\n+\tptr := noescape(unsafe.Pointer(&numbuf[0]))\n+\tn := read(fd, ptr, int32(len(numbuf)))\n \tclosefd(fd)\n \tif n <= 0 {\n \t\treturn 0\n \t}\n-\tl := n - 1 // remove trailing newline\n-\tv, ok := atoi(slicebytetostringtmp(numbuf[:l]))\n+\tn-- // remove trailing newline\n+\tv, ok := atoi(slicebytetostringtmp((*byte)(ptr), int(n)))\n \tif !ok || v < 0 {\n \t\tv = 0\n \t}"}, {"sha": "519735392a9b766f0eead008c1f150d0622f25fa", "filename": "libgo/go/runtime/slice.go", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fslice.go?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -199,14 +199,14 @@ func isPowerOfTwo(x uintptr) bool {\n \treturn x&(x-1) == 0\n }\n \n-func slicecopy(to, fm slice, width uintptr) int {\n-\tif fm.len == 0 || to.len == 0 {\n+func slicecopy(toPtr unsafe.Pointer, toLen int, fmPtr unsafe.Pointer, fmLen int, width uintptr) int {\n+\tif fmLen == 0 || toLen == 0 {\n \t\treturn 0\n \t}\n \n-\tn := fm.len\n-\tif to.len < n {\n-\t\tn = to.len\n+\tn := fmLen\n+\tif toLen < n {\n+\t\tn = toLen\n \t}\n \n \tif width == 0 {\n@@ -216,43 +216,43 @@ func slicecopy(to, fm slice, width uintptr) int {\n \tif raceenabled {\n \t\tcallerpc := getcallerpc()\n \t\tpc := funcPC(slicecopy)\n-\t\tracewriterangepc(to.array, uintptr(n*int(width)), callerpc, pc)\n-\t\tracereadrangepc(fm.array, uintptr(n*int(width)), callerpc, pc)\n+\t\tracewriterangepc(toPtr, uintptr(n*int(width)), callerpc, pc)\n+\t\tracereadrangepc(fmPtr, uintptr(n*int(width)), callerpc, pc)\n \t}\n \tif msanenabled {\n-\t\tmsanwrite(to.array, uintptr(n*int(width)))\n-\t\tmsanread(fm.array, uintptr(n*int(width)))\n+\t\tmsanwrite(toPtr, uintptr(n*int(width)))\n+\t\tmsanread(fmPtr, uintptr(n*int(width)))\n \t}\n \n \tsize := uintptr(n) * width\n \tif size == 1 { // common case worth about 2x to do here\n \t\t// TODO: is this still worth it with new memmove impl?\n-\t\t*(*byte)(to.array) = *(*byte)(fm.array) // known to be a byte pointer\n+\t\t*(*byte)(toPtr) = *(*byte)(fmPtr) // known to be a byte pointer\n \t} else {\n-\t\tmemmove(to.array, fm.array, size)\n+\t\tmemmove(toPtr, fmPtr, size)\n \t}\n \treturn n\n }\n \n-func slicestringcopy(to []byte, fm string) int {\n-\tif len(fm) == 0 || len(to) == 0 {\n+func slicestringcopy(toPtr *byte, toLen int, fm string) int {\n+\tif len(fm) == 0 || toLen == 0 {\n \t\treturn 0\n \t}\n \n \tn := len(fm)\n-\tif len(to) < n {\n-\t\tn = len(to)\n+\tif toLen < n {\n+\t\tn = toLen\n \t}\n \n \tif raceenabled {\n \t\tcallerpc := getcallerpc()\n \t\tpc := funcPC(slicestringcopy)\n-\t\tracewriterangepc(unsafe.Pointer(&to[0]), uintptr(n), callerpc, pc)\n+\t\tracewriterangepc(unsafe.Pointer(toPtr), uintptr(n), callerpc, pc)\n \t}\n \tif msanenabled {\n-\t\tmsanwrite(unsafe.Pointer(&to[0]), uintptr(n))\n+\t\tmsanwrite(unsafe.Pointer(toPtr), uintptr(n))\n \t}\n \n-\tmemmove(unsafe.Pointer(&to[0]), stringStructOf(&fm).str, uintptr(n))\n+\tmemmove(unsafe.Pointer(toPtr), stringStructOf(&fm).str, uintptr(n))\n \treturn n\n }"}, {"sha": "7b66a1b447d95f6f783252d1cbe5edbc5255195f", "filename": "libgo/go/runtime/string.go", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fstring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108fdcc56ee49dd7dc8314ce5022191f406a125f/libgo%2Fgo%2Fruntime%2Fstring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstring.go?ref=108fdcc56ee49dd7dc8314ce5022191f406a125f", "patch": "@@ -70,47 +70,50 @@ func concatstrings(buf *tmpBuf, p *string, n int) string {\n \treturn s\n }\n \n+// slicebytetostring converts a byte slice to a string.\n+// It is inserted by the compiler into generated code.\n+// ptr is a pointer to the first element of the slice;\n+// n is the length of the slice.\n // Buf is a fixed-size buffer for the result,\n // it is not nil if the result does not escape.\n-func slicebytetostring(buf *tmpBuf, b []byte) (str string) {\n-\tl := len(b)\n-\tif l == 0 {\n+func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) {\n+\tif n == 0 {\n \t\t// Turns out to be a relatively common case.\n \t\t// Consider that you want to parse out data between parens in \"foo()bar\",\n \t\t// you find the indices and convert the subslice to string.\n \t\treturn \"\"\n \t}\n \tif raceenabled {\n-\t\tracereadrangepc(unsafe.Pointer(&b[0]),\n-\t\t\tuintptr(l),\n+\t\tracereadrangepc(unsafe.Pointer(ptr),\n+\t\t\tuintptr(n),\n \t\t\tgetcallerpc(),\n \t\t\tfuncPC(slicebytetostring))\n \t}\n \tif msanenabled {\n-\t\tmsanread(unsafe.Pointer(&b[0]), uintptr(l))\n+\t\tmsanread(unsafe.Pointer(ptr), uintptr(n))\n \t}\n-\tif l == 1 {\n-\t\tstringStructOf(&str).str = unsafe.Pointer(&staticbytes[b[0]])\n+\tif n == 1 {\n+\t\tstringStructOf(&str).str = unsafe.Pointer(&staticbytes[*ptr])\n \t\tstringStructOf(&str).len = 1\n \t\treturn\n \t}\n \n \tvar p unsafe.Pointer\n-\tif buf != nil && len(b) <= len(buf) {\n+\tif buf != nil && n <= len(buf) {\n \t\tp = unsafe.Pointer(buf)\n \t} else {\n-\t\tp = mallocgc(uintptr(len(b)), nil, false)\n+\t\tp = mallocgc(uintptr(n), nil, false)\n \t}\n \tstringStructOf(&str).str = p\n-\tstringStructOf(&str).len = len(b)\n-\tmemmove(p, (*(*slice)(unsafe.Pointer(&b))).array, uintptr(len(b)))\n+\tstringStructOf(&str).len = n\n+\tmemmove(p, unsafe.Pointer(ptr), uintptr(n))\n \treturn\n }\n \n func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {\n \tif buf != nil && l <= len(buf) {\n \t\tb = buf[:l]\n-\t\ts = slicebytetostringtmp(b)\n+\t\ts = slicebytetostringtmp(&b[0], len(b))\n \t} else {\n \t\ts, b = rawstring(l)\n \t}\n@@ -131,17 +134,19 @@ func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {\n //   where k is []byte, T1 to Tn is a nesting of struct and array literals.\n // - Used for \"<\"+string(b)+\">\" concatenation where b is []byte.\n // - Used for string(b)==\"foo\" comparison where b is []byte.\n-func slicebytetostringtmp(b []byte) string {\n-\tif raceenabled && len(b) > 0 {\n-\t\tracereadrangepc(unsafe.Pointer(&b[0]),\n-\t\t\tuintptr(len(b)),\n+func slicebytetostringtmp(ptr *byte, n int) (str string) {\n+\tif raceenabled && n > 0 {\n+\t\tracereadrangepc(unsafe.Pointer(ptr),\n+\t\t\tuintptr(n),\n \t\t\tgetcallerpc(),\n \t\t\tfuncPC(slicebytetostringtmp))\n \t}\n-\tif msanenabled && len(b) > 0 {\n-\t\tmsanread(unsafe.Pointer(&b[0]), uintptr(len(b)))\n+\tif msanenabled && n > 0 {\n+\t\tmsanread(unsafe.Pointer(ptr), uintptr(n))\n \t}\n-\treturn *(*string)(unsafe.Pointer(&b))\n+\tstringStructOf(&str).str = unsafe.Pointer(ptr)\n+\tstringStructOf(&str).len = n\n+\treturn\n }\n \n func stringtoslicebyte(buf *tmpBuf, s string) []byte {\n@@ -232,7 +237,7 @@ func intstring(buf *[4]byte, v int64) (s string) {\n \tvar b []byte\n \tif buf != nil {\n \t\tb = buf[:]\n-\t\ts = slicebytetostringtmp(b)\n+\t\ts = slicebytetostringtmp(&b[0], len(b))\n \t} else {\n \t\ts, b = rawstring(4)\n \t}"}]}