{"sha": "58891cf9e614622fca52dd4b06d467ae08e47314", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg4OTFjZjllNjE0NjIyZmNhNTJkZDRiMDZkNDY3YWUwOGU0NzMxNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-09T00:31:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-09T00:31:40Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r710", "tree": {"sha": "d6984aa5591b1ab61dc874c1517039b982d1a509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6984aa5591b1ab61dc874c1517039b982d1a509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58891cf9e614622fca52dd4b06d467ae08e47314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58891cf9e614622fca52dd4b06d467ae08e47314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58891cf9e614622fca52dd4b06d467ae08e47314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58891cf9e614622fca52dd4b06d467ae08e47314/comments", "author": null, "committer": null, "parents": [{"sha": "2eef2ef1e8c33e55f98ae259956fa93057b205fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eef2ef1e8c33e55f98ae259956fa93057b205fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eef2ef1e8c33e55f98ae259956fa93057b205fb"}], "stats": {"total": 196, "additions": 167, "deletions": 29}, "files": [{"sha": "f2012424df7fd808dc33f242c792697822139f9d", "filename": "gcc/halfpic.c", "status": "modified", "additions": 165, "deletions": 29, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58891cf9e614622fca52dd4b06d467ae08e47314/gcc%2Fhalfpic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58891cf9e614622fca52dd4b06d467ae08e47314/gcc%2Fhalfpic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.c?ref=58891cf9e614622fca52dd4b06d467ae08e47314", "patch": "@@ -34,6 +34,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"tree.h\"\n #include \"rtl.h\"\n #include <stdio.h>\n+#include <string.h>\n #include \"obstack.h\"\n \n #define obstack_chunk_alloc xmalloc\n@@ -42,6 +43,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n extern char *xmalloc ();\n extern void  free ();\n extern rtx eliminate_constant_term ();\n+extern void assemble_name ();\n+extern void output_addr_const ();\n \n int flag_half_pic;\t\t/* Global half-pic flag.  */\n \n@@ -51,8 +54,10 @@ static struct obstack half_pic_obstack;\n /* List of pointers created to pic references.  */\n \n struct all_refs {\n+  struct all_refs *hash_next;\t/* next name in hash chain */\n   struct all_refs *next;\t/* next name created */\n-  rtx\t\t   ref;\t\t/* reference rtl */\n+  int\t\t   external_p;\t/* name is an external reference */\n+  int\t\t   pointer_p;\t/* pointer created.  */\n   char\t\t  *ref_name;\t/* reference name to ptr to real_name */\n   int\t\t   ref_len;\t/* reference name length */\n   char\t\t  *real_name;\t/* real function/data name */\n@@ -61,13 +66,103 @@ struct all_refs {\n \n static struct all_refs *half_pic_names;\n \n+static char *half_pic_prefix;\n+static int   half_pic_prefix_len;\n+\n+\f\n+/* Return the hash bucket of a name or NULL.  The hash chain is\n+   organized as a self reorganizing circularly linked chain.  It is\n+   assumed that any name passed to use will never be reallocated.  For\n+   names in SYMBOL_REF's this is true, because the names are allocated\n+   on the permanent obstack.  */\n+\n+#ifndef MAX_HASH_TABLE\n+#define MAX_HASH_TABLE 1009\n+#endif\n+\n+#define HASHBITS 30\n+\n+static struct all_refs *\n+half_pic_hash (name, len, create_p)\n+     char *name;\t\t/* name to hash */\n+     int len;\t\t\t/* length of the name (or 0 to call strlen) */\n+     int create_p;\t\t/* != 0 to create new hash bucket if new */\n+{\n+  static struct all_refs *hash_table[MAX_HASH_TABLE];\n+  static struct all_refs  zero_all_refs;\n+\n+  unsigned char *uname;\n+  int hash;\n+  int i;\n+  int ch;\n+  struct all_refs *first;\n+  struct all_refs *ptr;\n+\n+  if (len == 0)\n+    len = strlen (name);\n+\n+  /* Compute hash code */\n+  uname = (unsigned char *)name;\n+  ch = uname[0];\n+  hash = len * 613 + ch;\n+  for (i = 1; i < len; i += 2)\n+    hash = (hash * 613) + uname[i];\n+\n+  hash &= (1 << HASHBITS) - 1;\n+  hash %= MAX_HASH_TABLE;\n+\n+  /* See if the name is in the hash table.  */\n+  ptr = first = hash_table[hash];\n+  if (ptr)\n+    {\n+      do\n+\t{\n+\t  if (len == ptr->real_len\n+\t      && ch == *(ptr->real_name)\n+\t      && !strcmp (name, ptr->real_name))\n+\t    {\n+\t      hash_table[hash] = ptr;\n+\t      return ptr;\n+\t    }\n+\n+\t  ptr = ptr->hash_next;\n+\t}\n+      while (ptr != first);\n+    }\n+\n+  /* name not in hash table.  */\n+  if (!create_p)\n+    return (struct all_refs *)0;\n+\n+  ptr = (struct all_refs *) obstack_alloc (&half_pic_obstack, sizeof (struct all_refs));\n+  *ptr = zero_all_refs;\n+\n+  ptr->real_name = name;\n+  ptr->real_len  = len;\n+\n+  /* Update circular links.  */\n+  if (first == (struct all_refs *)0)\n+    ptr->hash_next = ptr;\n+\n+  else\n+    {\n+      ptr->hash_next = first->hash_next;\n+      first->hash_next = ptr;\n+    }\n+\n+  hash_table[hash] = ptr;\n+  return ptr;\n+}\n+\n \f\n /* Do any half-pic initializations.  */\n \n void\n half_pic_init ()\n {\n   flag_half_pic = TRUE;\n+  half_pic_prefix = HALF_PIC_PREFIX;\n+  half_pic_prefix_len = strlen (half_pic_prefix);\n   obstack_init (&half_pic_obstack);\n }\n \n@@ -86,8 +181,12 @@ half_pic_finish (stream)\n   data_section ();\n   for (; p != 0; p = p->next)\n     {\n-      ASM_OUTPUT_LABEL (stream, p->ref_name);\n-      ASM_OUTPUT_INT (stream, gen_rtx (SYMBOL_REF, Pmode, p->real_name));\n+      /* Emit the pointer if used.  */\n+      if (p->pointer_p)\n+\t{\n+\t  ASM_OUTPUT_LABEL (stream, p->ref_name);\n+\t  ASM_OUTPUT_INT (stream, gen_rtx (SYMBOL_REF, Pmode, p->real_name));\n+\t}\n     }\n }\n \n@@ -100,6 +199,7 @@ half_pic_encode (decl)\n {\n   enum tree_code code = TREE_CODE (decl);\n   tree asm_name;\n+  struct all_refs *ptr;\n \n   if (!flag_half_pic)\n     return;\n@@ -115,7 +215,11 @@ half_pic_encode (decl)\n   if (!asm_name)\n     return;\n \n-  TREE_PUBLIC (asm_name) = TRUE;\n+  ptr = half_pic_hash (IDENTIFIER_POINTER (asm_name),\n+\t\t       IDENTIFIER_LENGTH (asm_name),\n+\t\t       TRUE);\n+\n+  ptr->external_p = TRUE;\n \n #ifdef HALF_PIC_DEBUG\n   if (HALF_PIC_DEBUG)\n@@ -125,6 +229,30 @@ half_pic_encode (decl)\n #endif\n }\n \n+\f\n+/* Mark that an object is now local, and no longer needs half-pic.  */\n+\n+void\n+half_pic_declare (name)\n+     char *name;\n+{\n+  struct all_refs *ptr;\n+\n+  if (!flag_half_pic)\n+    return;\n+\n+  ptr = half_pic_hash (name, 0, FALSE);\n+  if (!ptr)\n+    return;\n+\n+  ptr->external_p = FALSE;\n+\n+#ifdef HALF_PIC_DEBUG\n+  if (HALF_PIC_DEBUG)\n+    fprintf (stderr, \"\\n========== Half_pic_declare %s\\n\", name);\n+#endif\n+}\n+\n \f\n /* Return whether an address is half-pic.  */\n \n@@ -133,13 +261,17 @@ half_pic_address_p (addr)\n      rtx addr;\n {\n   char *name;\n-  tree tname;\n+  int len;\n+  struct all_refs *ptr;\n \n   if (!flag_half_pic)\n     return FALSE;\n \n   switch (GET_CODE (addr))\n     {\n+    default:\n+      break;\n+\n     case CONST:\n       {\n \trtx offset = const0_rtx;\n@@ -161,8 +293,20 @@ half_pic_address_p (addr)\n       if (name[0] == '*')\n \treturn FALSE;\n \n-      tname = get_identifier (name);\n-      if (TREE_PUBLIC (tname))\n+      /* If this is a reference to the actual half-pic pointer, it\n+\t is obviously not half-pic.  */\n+\n+      len = strlen (name);\n+      if (len > half_pic_prefix_len\n+\t  && half_pic_prefix[0] == name[0]\n+\t  && !strncmp (name, half_pic_prefix, half_pic_prefix_len))\n+\treturn FALSE;\n+\n+      ptr = half_pic_hash (name, len, FALSE);\n+      if (ptr == (struct all_refs *)0)\n+\treturn FALSE;\n+\n+      if (ptr->external_p)\n \t{\n #ifdef HALF_PIC_DEBUG\n \t  if (HALF_PIC_DEBUG)\n@@ -184,40 +328,32 @@ half_pic_ptr (operand)\n      rtx operand;\n {\n   char *name;\n-  tree tname;\n   struct all_refs *p;\n-  int ch;\n   int len;\n-  int prefix_len;\n \n   if (GET_CODE (operand) != SYMBOL_REF)\n     return operand;\n \n   name = XSTR (operand, 0);\n   len = strlen (name);\n-  ch = name[0];\n-  for (p = half_pic_names; p != 0; p = p->next)\n-    {\n-      if (ch == *(p->ref_name)\n-\t  && len == p->real_len\n-\t  && !strcmp (name, p->real_name))\n-\treturn p->ref;\n-    }\n+  p = half_pic_hash (name, len, FALSE);\n+  if (p == (struct all_refs *)0 || !p->external_p)\n+    return operand;\n \n-  p = (struct all_refs *) obstack_alloc (&half_pic_obstack, sizeof (struct all_refs));\n+  if (!p->pointer_p)\n+    {\t\t\t\t/* first time, create pointer */\n+      obstack_grow (&half_pic_obstack, half_pic_prefix, half_pic_prefix_len);\n+      obstack_grow (&half_pic_obstack, name, len);\n \n-  prefix_len = strlen (HALF_PIC_PREFIX);\n-  obstack_grow (&half_pic_obstack, HALF_PIC_PREFIX, prefix_len);\n-  obstack_grow (&half_pic_obstack, name, len);\n+      p->next      = half_pic_names;\n+      p->ref_name  = (char *) obstack_finish (&half_pic_obstack);\n+      p->ref_len   = len + half_pic_prefix_len;\n+      p->pointer_p = TRUE;\n \n-  p->next      = half_pic_names;\n-  p->real_name = name;\n-  p->real_len  = len;\n-  p->ref_len   = len + prefix_len;\n-  p->ref_name  = (char *) obstack_finish (&half_pic_obstack);\n-  p->ref       = gen_rtx (SYMBOL_REF, Pmode, p->ref_name);\n+      half_pic_names = p;\n+    }\n \n-  half_pic_names = p;\n+  return gen_rtx (SYMBOL_REF, Pmode, p->ref_name);\n }\n \n #endif /* HALF_PIC_INIT */"}, {"sha": "b972ff9d17d912d293017167902da21efa92cb89", "filename": "gcc/halfpic.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58891cf9e614622fca52dd4b06d467ae08e47314/gcc%2Fhalfpic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58891cf9e614622fca52dd4b06d467ae08e47314/gcc%2Fhalfpic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.h?ref=58891cf9e614622fca52dd4b06d467ae08e47314", "patch": "@@ -19,6 +19,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n extern int  flag_half_pic;\t\t/* Global half-pic flag.  */\n extern void half_pic_encode ();\t\t/* encode whether half-pic */\n+extern void half_pic_declare ();\t/* declare object local */\n extern void half_pic_init ();\t\t/* half_pic initialization */\n extern void half_pic_finish ();\t\t/* half_pic termination */\n extern int  half_pic_address_p ();\t/* true if an address is half-pic */\n@@ -29,6 +30,7 @@ extern struct rtx_def *half_pic_ptr ();\t/* return RTX for half-pic pointer */\n \n #define HALF_PIC_P()\t\t(flag_half_pic)\n #define HALF_PIC_ENCODE(DECL)\thalf_pic_encode (DECL)\n+#define HALF_PIC_DECLARE(NAME)\thalf_pic_declare (NAME)\n #define HALF_PIC_INIT()\t\thalf_pic_init ()\n #define HALF_PIC_FINISH(STREAM)\thalf_pic_finish (STREAM)\n #define HALF_PIC_ADDRESS_P(X)\thalf_pic_address_p (X)"}]}