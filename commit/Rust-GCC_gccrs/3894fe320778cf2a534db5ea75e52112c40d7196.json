{"sha": "3894fe320778cf2a534db5ea75e52112c40d7196", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg5NGZlMzIwNzc4Y2YyYTUzNGRiNWVhNzVlNTIxMTJjNDBkNzE5Ng==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-02-27T10:52:41Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-02-27T10:52:41Z"}, "message": "Beans.java, [...]: Reformated to GNU style.\n\n2003-02-27  Michael Koch  <konqueror@gmx.de>\n\n\t* java/beans/Beans.java,\n\tjava/beans/FeatureDescriptor.java\n\tjava/beans/PropertyEditorManager.java:\n\tReformated to GNU style.\n\nFrom-SVN: r63501", "tree": {"sha": "b0a92336e36e9838a343c9809c423fdcb9d7413e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0a92336e36e9838a343c9809c423fdcb9d7413e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3894fe320778cf2a534db5ea75e52112c40d7196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3894fe320778cf2a534db5ea75e52112c40d7196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3894fe320778cf2a534db5ea75e52112c40d7196", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3894fe320778cf2a534db5ea75e52112c40d7196/comments", "author": null, "committer": null, "parents": [{"sha": "6fc19dc9299b0fcbb9c2b2af125860488ae808d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc19dc9299b0fcbb9c2b2af125860488ae808d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fc19dc9299b0fcbb9c2b2af125860488ae808d6"}], "stats": {"total": 929, "additions": 533, "deletions": 396}, "files": [{"sha": "76f5ddec3772f92f4d2b75d6b0468c94535db9ca", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3894fe320778cf2a534db5ea75e52112c40d7196", "patch": "@@ -1,3 +1,10 @@\n+2003-02-27  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/beans/Beans.java,\n+\tjava/beans/FeatureDescriptor.java\n+\tjava/beans/PropertyEditorManager.java:\n+\tReformated to GNU style.\n+\n 2003-02-25  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/nio/MappedByteFileBuffer.java,"}, {"sha": "aa52c03d236fa942b3a6b3122b2afd4a7e15a93f", "filename": "libjava/java/beans/Beans.java", "status": "modified", "additions": 207, "deletions": 157, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2Fjava%2Fbeans%2FBeans.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2Fjava%2Fbeans%2FBeans.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FBeans.java?ref=3894fe320778cf2a534db5ea75e52112c40d7196", "patch": "@@ -43,166 +43,216 @@\n import gnu.java.io.*;\n \n /**\n- * <code>Beans</code> provides some helper methods that allow the basic operations of Bean-ness.\n+ * <code>Beans</code> provides some helper methods that allow the basic\n+ * operations of Bean-ness.\n  *\n  * @author John Keiser\n- * @since JDK1.1\n+ * @since 1.1\n  * @version 1.1.0, 29 Jul 1998\n  *\n  */\n-public class Beans {\n-\tstatic boolean designTime = false;\n-\tstatic boolean guiAvailable = true;\n-\n-\n-\t/**\n-\t * Once again, we have a java.beans class with only\n-\t * static methods that can be instantiated.  When\n-\t * will the madness end? :)\n-\t */\n-\tpublic Beans() {\n-\t}\n-\n-\t/**\n-\t * Allows you to instantiate a Bean.  This method takes\n-\t * a ClassLoader from which to read the Bean and the\n-\t * name of the Bean.<P>\n-\t *\n-\t * The Bean name should be a dotted name, like a class.\n-\t * It can represent several things.  Beans will search\n-\t * for the Bean using the name like this:<P>\n-\t * <OL>\n-\t * <LI>Searches for a serialized instance of the Bean\n-\t * using getResource(), mangling the Bean name by\n-\t * replacing the dots with slashes and appending .ser\n-\t * (for example, gnu.beans.BlahDeBlah would cause\n-\t * Beans to search for gnu/beans/BlahDeBlah.ser using\n-\t * getResource()).</LI>\n-\t * <LI>Searches for the Bean class using the beanName,\n-\t * and then instantiates it with the no-arg constructor.\n-\t * At that point, if it is an Applet, it provides it\n-\t * with AppletContext and AppletStub, and then calls\n-\t * init().</LI>\n-\t * </OL>\n-\t * @param cl the ClassLoader to use, or <CODE>null</CODE>\n-\t *        to use the default ClassLoader.\n-\t * @param beanName the name of the Bean.\n-\t * @return the Bean.\n-\t * @XXX\n-\t */\n-\tpublic static Object instantiate(ClassLoader cl, String beanName) throws IOException, ClassNotFoundException {\n-\t\tObject bean;\n-\n-\t\tInputStream serStream;\n-\t\tif(cl == null) {\n-\t\t\tserStream = ClassLoader.getSystemResourceAsStream(beanName.replace('.','/')+\".ser\");\n-\t\t} else {\n-\t\t\tserStream = cl.getResourceAsStream(beanName.replace('.','/')+\".ser\");\n-\t\t}\n-\t\tif(serStream != null) {\n-\t\t\tif(cl == null) {\n-\t\t\t\tObjectInputStream ois = new ObjectInputStream(serStream);\n-\t\t\t\tbean = ois.readObject();\n-\t\t\t} else {\n-\t\t\t\tClassLoaderObjectInputStream ois = new ClassLoaderObjectInputStream(serStream, cl);\n-\t\t\t\tbean = ois.readObject();\n-\t\t\t}\n-\t\t} else if(cl == null) {\n-\t\t\tClass beanClass = Class.forName(beanName);\n-\t\t\ttry {\n-\t\t\t\tbean = beanClass.newInstance();\n-\t\t\t} catch(IllegalAccessException E) {\n-\t\t\t\tbean = null;\n-\t\t\t} catch(InstantiationException E) {\n-\t\t\t\tbean = null;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tClass beanClass = cl.loadClass(beanName);\n-\t\t\ttry {\n-\t\t\t\tbean = beanClass.newInstance();\n-\t\t\t} catch(IllegalAccessException E) {\n-\t\t\t\tbean = null;\n-\t\t\t} catch(InstantiationException E) {\n-\t\t\t\tbean = null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif(bean instanceof Applet) {\n-\t\t\tApplet a = (Applet)bean;\n-\t\t\t//a.setAppletContext(???);\n-\t\t\t//a.setStub(???);\n-\t\t\tif(serStream == null) {\n-\t\t\t\ta.init();\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn bean;\n-\t}\n-\n-\t/**\n-\t * Get the Bean as a different class type.\n-\t * This should be used instead of casting to get a new\n-\t * type view of a Bean, because in the future there may\n-\t * be new types of Bean, even Beans spanning multiple\n-\t * Objects.\n-\t * @param bean the Bean to cast.\n-\t * @param newClass the Class to cast it to.\n-\t * @return the Bean as a new view, or if the operation\n-\t *         could not be performed, the Bean itself.\n-\t */\n-\tpublic static Object getInstanceOf(Object bean, Class newClass) {\n-\t\treturn bean;\n-\t}\n-\n-\t/**\n-\t * Determine whether the Bean can be cast to a different\n-\t * class type.\n-\t * This should be used instead of instanceof to determine\n-\t * a Bean's castability, because in the future there may\n-\t * be new types of Bean, even Beans spanning multiple\n-\t * Objects.\n-\t * @param bean the Bean to cast.\n-\t * @param newClass the Class to cast it to.\n-\t * @return whether the Bean can be cast to the class type\n-\t *         in question.\n-\t */\n-\tpublic static boolean isInstanceOf(Object bean, Class newBeanClass) {\n-\t\treturn newBeanClass.isInstance(bean);\n-\t}\n-\n-\t/**\n-\t * Find out whether the GUI is available to use.\n-\t * Defaults to true.\n-\t * @return whether the GUI is available to use.\n-\t */\n-\tpublic static boolean isGuiAvailable() {\n-\t\treturn guiAvailable;\n-\t}\n-\n-\t/**\n-\t * Find out whether it is design time.  Design time means\n-\t * we are in a RAD tool.\n-\t * Defaults to false.\n-\t * @return whether it is design time.\n-\t */\n-\tpublic static boolean isDesignTime() {\n-\t\treturn designTime;\n-\t}\n-\n-\t/**\n-\t * Set whether the GUI is available to use.\n-\t * @param guiAvailable whether the GUI is available to use.\n-\t */\n-\tpublic static void setGuiAvailable(boolean guiAvailable) throws SecurityException {\n-\t\tBeans.guiAvailable = guiAvailable;\n-\t}\n-\n-\t/**\n-\t * Set whether it is design time.  Design time means we\n-\t * are in a RAD tool.\n-\t * @param designTime whether it is design time.\n-\t */\n-\tpublic static void setDesignTime(boolean designTime) throws SecurityException {\n-\t\tBeans.designTime = designTime;\n-\t}\n+public class Beans\n+{\n+  static boolean designTime = false;\n+  static boolean guiAvailable = true;\n+\n+  /**\n+   * Once again, we have a java.beans class with only\n+   * static methods that can be instantiated.  When\n+   * will the madness end? :)\n+   */\n+  public Beans()\n+  {\n+    // Do nothing here.\n+  }\n+\n+  /**\n+   * Allows you to instantiate a Bean.  This method takes\n+   * a ClassLoader from which to read the Bean and the\n+   * name of the Bean.<P>\n+   *\n+   * The Bean name should be a dotted name, like a class.\n+   * It can represent several things.  Beans will search\n+   * for the Bean using the name like this:<P>\n+   * <OL>\n+   * <LI>Searches for a serialized instance of the Bean\n+   * using getResource(), mangling the Bean name by\n+   * replacing the dots with slashes and appending .ser\n+   * (for example, gnu.beans.BlahDeBlah would cause\n+   * Beans to search for gnu/beans/BlahDeBlah.ser using\n+   * getResource()).</LI>\n+   * <LI>Searches for the Bean class using the beanName,\n+   * and then instantiates it with the no-arg constructor.\n+   * At that point, if it is an Applet, it provides it\n+   * with AppletContext and AppletStub, and then calls\n+   * init().</LI>\n+   * </OL>\n+   *\n+   * @param cl the ClassLoader to use, or <CODE>null</CODE>\n+   *        to use the default ClassLoader.\n+   * @param beanName the name of the Bean.\n+   *\n+   * @return the Bean.\n+   *\n+   * @XXX\n+   */\n+  public static Object instantiate (ClassLoader cl, String beanName)\n+    throws IOException, ClassNotFoundException\n+  {\n+    Object bean;\n+    InputStream serStream;\n+    \n+    if (cl == null)\n+      {\n+        serStream = ClassLoader.getSystemResourceAsStream\n+          (beanName.replace ('.','/')+\".ser\");\n+      }\n+    else\n+      {\n+        serStream = cl.getResourceAsStream (beanName.replace ('.', '/')\n+                                            + \".ser\");\n+      }\n+    \n+    if (serStream != null)\n+      {\n+        if(cl == null)\n+          {\n+            ObjectInputStream ois = new ObjectInputStream(serStream);\n+            bean = ois.readObject();\n+          }\n+        else\n+          {\n+            ClassLoaderObjectInputStream ois =\n+              new ClassLoaderObjectInputStream (serStream, cl);\n+            bean = ois.readObject();\n+          }\n+      }\n+    else if(cl == null)\n+      {\n+        Class beanClass = Class.forName(beanName);\n+        try\n+          {\n+            bean = beanClass.newInstance();\n+          }\n+        catch(IllegalAccessException E)\n+          {\n+            bean = null;\n+          }\n+        catch(InstantiationException E)\n+          {\n+            bean = null;\n+          }\n+      }\n+    else\n+      {\n+        Class beanClass = cl.loadClass(beanName);\n+        try\n+          {\n+            bean = beanClass.newInstance();\n+          }\n+        catch(IllegalAccessException E)\n+          {\n+            bean = null;\n+          }\n+        catch(InstantiationException E)\n+          {\n+            bean = null;\n+          }\n+      }\n+\n+    if(bean instanceof Applet)\n+      {\n+        Applet a = (Applet)bean;\n+        //a.setAppletContext(???);\n+        //a.setStub(???);\n+        if(serStream == null)\n+          {\n+            a.init();\n+          }\n+      }\n+\n+    return bean;\n+  }\n+\n+  /**\n+   * Get the Bean as a different class type.\n+   * This should be used instead of casting to get a new\n+   * type view of a Bean, because in the future there may\n+   * be new types of Bean, even Beans spanning multiple\n+   * Objects.\n+   *\n+   * @param bean the Bean to cast.\n+   * @param newClass the Class to cast it to.\n+   *\n+   * @return the Bean as a new view, or if the operation\n+   *         could not be performed, the Bean itself.\n+   */\n+  public static Object getInstanceOf(Object bean, Class newClass)\n+  {\n+    return bean;\n+  }\n+\n+  /**\n+   * Determine whether the Bean can be cast to a different\n+   * class type.\n+   * This should be used instead of instanceof to determine\n+   * a Bean's castability, because in the future there may\n+   * be new types of Bean, even Beans spanning multiple\n+   * Objects.\n+   *\n+   * @param bean the Bean to cast.\n+   * @param newClass the Class to cast it to.\n+   *\n+   * @return whether the Bean can be cast to the class type\n+   *         in question.\n+   */\n+  public static boolean isInstanceOf(Object bean, Class newBeanClass)\n+  {\n+    return newBeanClass.isInstance(bean);\n+  }\n+\n+  /**\n+   * Find out whether the GUI is available to use.\n+   * Defaults to true.\n+   *\n+   * @return whether the GUI is available to use.\n+   */\n+  public static boolean isGuiAvailable()\n+  {\n+    return guiAvailable;\n+  }\n+\n+  /**\n+   * Find out whether it is design time.  Design time means\n+   * we are in a RAD tool.\n+   * Defaults to false.\n+   *\n+   * @return whether it is design time.\n+   */\n+  public static boolean isDesignTime()\n+  {\n+    return designTime;\n+  }\n+\n+  /**\n+   * Set whether the GUI is available to use.\n+   * @param guiAvailable whether the GUI is available to use.\n+   */\n+  public static void setGuiAvailable(boolean guiAvailable)\n+    throws SecurityException\n+  {\n+    Beans.guiAvailable = guiAvailable;\n+  }\n+\n+  /**\n+   * Set whether it is design time.  Design time means we\n+   * are in a RAD tool.\n+   *\n+   * @param designTime whether it is design time.\n+   */\n+  public static void setDesignTime(boolean designTime)\n+    throws SecurityException\n+  {\n+    Beans.designTime = designTime;\n+  }\n }"}, {"sha": "90a3c1557f4b3be6c6611e5bd7479d73d9e36149", "filename": "libjava/java/beans/FeatureDescriptor.java", "status": "modified", "additions": 171, "deletions": 122, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2Fjava%2Fbeans%2FFeatureDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2Fjava%2Fbeans%2FFeatureDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FFeatureDescriptor.java?ref=3894fe320778cf2a534db5ea75e52112c40d7196", "patch": "@@ -41,126 +41,175 @@\n import java.util.*;\n \n /**\n- ** FeatureDescriptor is the common superclass for all JavaBeans Descriptor classes.\n- ** JavaBeans descriptors are abstract descriptors of properties,\n- ** events, methods, beans, etc.<P>\n- **\n- ** <STRONG>Documentation Convention:</STRONG> for proper\n- ** Internalization of Beans inside an RAD tool, sometimes there\n- ** are two names for a property or method: a programmatic, or\n- ** locale-independent name, which can be used anywhere, and a\n- ** localized, display name, for ease of use.  In the\n- ** documentation I will specify different String values as\n- ** either <EM>programmatic</EM> or <EM>localized</EM> to\n- ** make this distinction clear.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 31 May 1998\n- **/\n-\n-public class FeatureDescriptor {\n-\tString name;\n-\tString displayName;\n-\tString shortDescription;\n-\tboolean expert;\n-\tboolean hidden;\n-\n-\tHashtable valueHash;\n-\n-\t/** Instantiate this FeatureDescriptor with appropriate default values.**/\n-\tpublic FeatureDescriptor() {\n-\t\tvalueHash = new Hashtable();\n-\t}\n-\n-\t/** Get the programmatic name of this feature. **/\n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n-\n-\t/** Set the programmatic name of this feature.\n-\t ** @param name the new name for this feature.\n-\t **/\n-\tpublic void setName(String name) {\n-\t\tthis.name = name;\n-\t}\n-\n-\t/** Get the localized (display) name of this feature. **/\n-\tpublic String getDisplayName() {\n-\t\treturn displayName;\n-\t}\n-\n-\t/** Set the localized (display) name of this feature.\n-\t ** @param displayName the new display name for this feature.\n-\t **/\n-\tpublic void setDisplayName(String displayName) {\n-\t\tthis.displayName = displayName;\n-\t}\n-\n-\t/** Get the localized short description for this feature. **/\n-\tpublic String getShortDescription() {\n-\t\treturn shortDescription;\n-\t}\n-\n-\t/** Set the localized short description for this feature.\n-\t ** @param shortDescription the new short description for this feature.\n-\t **/\n-\tpublic void setShortDescription(String shortDescription) {\n-\t\tthis.shortDescription = shortDescription;\n-\t}\n-\n-\t/** Indicates whether this feature is for expert use only.\n-\t ** @return true if for use by experts only, or false if anyone can use it.\n-\t **/\n-\tpublic boolean isExpert() {\n-\t\treturn expert;\n-\t}\n-\n-\t/** Set whether this feature is for expert use only.\n-\t ** @param expert true if for use by experts only, or false if anyone can use it.\n-\t **/\n-\tpublic void setExpert(boolean expert) {\n-\t\tthis.expert = expert;\n-\t}\n-\n-\t/** Indicates whether this feature is for use by tools only.\n-\t ** If it is for use by tools only, then it should not be displayed.\n-\t ** @return true if tools only should use it, or false if anyone can see it.\n-\t **/\n-\tpublic boolean isHidden() {\n-\t\treturn hidden;\n-\t}\n-\n-\t/** Set whether this feature is for use by tools only.\n-\t ** If it is for use by tools only, then it should not be displayed.\n-\t ** @param hidden true if tools only should use it, or false if anyone can see it.\n-\t **/\n-\tpublic void setHidden(boolean hidden) {\n-\t\tthis.hidden = hidden;\n-\t}\n-\n-\n-\t/** Get an arbitrary value set with setValue().\n-\t ** @param name the programmatic name of the key.\n-\t ** @return the value associated with this name, or null if there is none.\n-\t **/\n-\tpublic Object getValue(String name) {\n-\t\treturn valueHash.get(name);\n-\t}\n-\n-\t/** Set an arbitrary string-value pair with this feature.\n-\t ** @param name the programmatic name of the key.\n-\t ** @param value the value to associate with the name.\n-\t **/\n-\tpublic void setValue(String name, Object value) {\n-\t\tvalueHash.put(name, value);\n-\t}\n-\n-\t/** Get a list of the programmatic key names set with setValue().\n-\t ** @return an Enumerator over all the programmatic key names associated\n-\t ** with this feature.\n-\t **/\n-\tpublic Enumeration attributeNames() {\n-\t\treturn valueHash.keys();\n-\t}\n+ * FeatureDescriptor is the common superclass for all JavaBeans Descriptor\n+ * classes. JavaBeans descriptors are abstract descriptors of properties,\n+ * events, methods, beans, etc.<P>\n+ *\n+ * <STRONG>Documentation Convention:</STRONG> for proper\n+ * Internalization of Beans inside an RAD tool, sometimes there\n+ * are two names for a property or method: a programmatic, or\n+ * locale-independent name, which can be used anywhere, and a\n+ * localized, display name, for ease of use.  In the\n+ * documentation I will specify different String values as\n+ * either <EM>programmatic</EM> or <EM>localized</EM> to\n+ * make this distinction clear.\n+ *\n+ * @author John Keiser\n+ * @since 1.1\n+ * @version 1.1.0, 31 May 1998\n+ */\n+\n+public class FeatureDescriptor\n+{\n+  String name;\n+  String displayName;\n+  String shortDescription;\n+  boolean expert;\n+  boolean hidden;\n+\n+  Hashtable valueHash;\n+\n+  /**\n+   * Instantiate this FeatureDescriptor with appropriate default values.\n+   */\n+  public FeatureDescriptor()\n+  {\n+    valueHash = new Hashtable();\n+  }\n+\n+  /**\n+   * Get the programmatic name of this feature.\n+   */\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  /**\n+   * Set the programmatic name of this feature.\n+   *\n+   * @param name the new name for this feature.\n+   */\n+  public void setName(String name)\n+  {\n+    this.name = name;\n+  }\n+\n+  /**\n+   * Get the localized (display) name of this feature.\n+   */\n+  public String getDisplayName()\n+  {\n+    return displayName;\n+  }\n+\n+  /**\n+   * Set the localized (display) name of this feature.\n+   *\n+   * @param displayName the new display name for this feature.\n+   */\n+  public void setDisplayName(String displayName)\n+  {\n+    this.displayName = displayName;\n+  }\n+\n+  /**\n+   * Get the localized short description for this feature.\n+   */\n+  public String getShortDescription()\n+  {\n+    return shortDescription;\n+  }\n+\n+  /**\n+   * Set the localized short description for this feature.\n+   *\n+   * @param shortDescription the new short description for this feature.\n+   */\n+  public void setShortDescription(String shortDescription)\n+  {\n+    this.shortDescription = shortDescription;\n+  }\n+\n+  /**\n+   * Indicates whether this feature is for expert use only.\n+   *\n+   * @return true if for use by experts only,\n+   * or false if anyone can use it.\n+   */\n+  public boolean isExpert()\n+  {\n+    return expert;\n+  }\n+\n+  /**\n+   * Set whether this feature is for expert use only.\n+   *\n+   * @param expert true if for use by experts only,\n+   * or false if anyone can use it.\n+   */\n+  public void setExpert(boolean expert)\n+  {\n+    this.expert = expert;\n+  }\n+\n+  /**\n+   * Indicates whether this feature is for use by tools only.\n+   * If it is for use by tools only, then it should not be displayed.\n+   *\n+   * @return true if tools only should use it,\n+   * or false if anyone can see it.\n+   */\n+  public boolean isHidden()\n+  {\n+    return hidden;\n+  }\n+\n+  /**\n+   * Set whether this feature is for use by tools only.\n+   * If it is for use by tools only, then it should not be displayed.\n+   *\n+   * @param hidden true if tools only should use it,\n+   * or false if anyone can see it.\n+   */\n+  public void setHidden(boolean hidden)\n+  {\n+    this.hidden = hidden;\n+  }\n+\n+\n+  /**\n+   * Get an arbitrary value set with setValue().\n+   *\n+   * @param name the programmatic name of the key.\n+   *\n+   * @return the value associated with this name,\n+   * or null if there is none.\n+   */\n+  public Object getValue(String name)\n+  {\n+    return valueHash.get(name);\n+  }\n+\n+  /**\n+   * Set an arbitrary string-value pair with this feature.\n+   *\n+   * @param name the programmatic name of the key.\n+   * @param value the value to associate with the name.\n+   */\n+  public void setValue(String name, Object value)\n+  {\n+    valueHash.put(name, value);\n+  }\n+\n+  /**\n+   * Get a list of the programmatic key names set with setValue().\n+   *\n+   * @return an Enumerator over all the programmatic key names associated\n+   * with this feature.\n+   */\n+  public Enumeration attributeNames()\n+  {\n+    return valueHash.keys();\n+  }\n }"}, {"sha": "4bd4a9f7edf7c16496619cd424824a632b7d65a4", "filename": "libjava/java/beans/PropertyEditorManager.java", "status": "modified", "additions": 148, "deletions": 117, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3894fe320778cf2a534db5ea75e52112c40d7196/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java?ref=3894fe320778cf2a534db5ea75e52112c40d7196", "patch": "@@ -41,121 +41,152 @@\n import gnu.java.lang.ClassHelper;\n \n /**\n- ** PropertyEditorManager is used to find property editors\n- ** for various types (not necessarily Beans).<P>\n- **\n- ** It first checks to see if the property editor is\n- ** already registered; if it is, that property editor is\n- ** used.  Next it takes the type's classname and appends\n- ** \"Editor\" to it, and searches first in the class's\n- ** package and then in the property editor search path.<P>\n- **\n- ** Default property editors are provided for:<P>\n- ** <OL>\n- ** <LI>boolean, byte, short, int, long, float, and double</LI>\n- ** <LI>java.lang.String</LI>\n- ** <LI>java.awt.Color</LI>\n- ** <LI>java.awt.Font</LI>\n- ** <OL>\n- **\n- ** <STRONG>Spec Suggestion:</STRONG> Perhaps an editor for\n- ** Filename or something like it should be provided.  As well\n- ** as char.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 29 Jul 1998\n- **/\n-\n-public class PropertyEditorManager {\n-\tstatic java.util.Hashtable editors = new java.util.Hashtable();\n-\tstatic String[] editorSearchPath = {\"gnu.java.beans.editors\",\"sun.beans.editors\"};\n-\n-\tstatic {\n-\t\tregisterEditor(java.lang.Boolean.TYPE, gnu.java.beans.editors.NativeBooleanEditor.class);\n-\t\tregisterEditor(java.lang.Byte.TYPE,    gnu.java.beans.editors.NativeByteEditor.class);\n-\t\tregisterEditor(java.lang.Short.TYPE,   gnu.java.beans.editors.NativeShortEditor.class);\n-\t\tregisterEditor(java.lang.Integer.TYPE, gnu.java.beans.editors.NativeIntEditor.class);\n-\t\tregisterEditor(java.lang.Long.TYPE,    gnu.java.beans.editors.NativeLongEditor.class);\n-\t\tregisterEditor(java.lang.Float.TYPE,   gnu.java.beans.editors.NativeFloatEditor.class);\n-\t\tregisterEditor(java.lang.Double.TYPE,  gnu.java.beans.editors.NativeDoubleEditor.class);\n-\t\tregisterEditor(java.lang.String.class, gnu.java.beans.editors.StringEditor.class);\n-\t\tregisterEditor(java.awt.Color.class,   gnu.java.beans.editors.ColorEditor.class);\n-\t\tregisterEditor(java.awt.Font.class,    gnu.java.beans.editors.FontEditor.class);\n-\t}\n-\n-\t/** Beats me why this class can be instantiated, but there\n-\t ** you have it.\n-\t **/\n-\tpublic PropertyEditorManager() { }\n-\n-\t/** Register an editor for a class.  Replaces old editor\n-\t ** if there was one registered before.\n-\t ** @param editedClass the class that the property editor\n-\t **        will edit.\n-\t ** @param editorClass the PropertyEditor class.\n-\t **/\n-\tpublic static void registerEditor(Class editedClass, Class editorClass) {\n-\t\teditors.put(editedClass, editorClass);\n-\t}\n-\n-\t/** Returns a new instance of the property editor for the\n-\t ** specified class.\n-\t ** @param editedClass the class that the property editor\n-\t **        will edit.\n-\t ** @return a PropertyEditor instance that can edit the\n-\t **         specified class.\n-\t **/\n-\tpublic static PropertyEditor findEditor(Class editedClass) {\n-\t\ttry {\n-\n-\t\tClass found = (Class)editors.get(editedClass);\n-\t\tif(found != null) {\n-\t\t\treturn (PropertyEditor)found.newInstance();\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tfound = Class.forName(editedClass.getName()+\"Editor\");\n-\t\t\tregisterEditor(editedClass,found);\n-\t\t\treturn (PropertyEditor)found.newInstance();\n-\t\t} catch(ClassNotFoundException E) {\n-\t\t}\n-\n-\t\tString appendName = \".\" + ClassHelper.getTruncatedClassName(editedClass) + \"Editor\";\n-\t\tsynchronized(editorSearchPath) {\n-\t\t\tfor(int i=0;i<editorSearchPath.length;i++) {\n-\t\t\t\ttry {\n-\t\t\t\t\tfound = Class.forName(editorSearchPath[i] + appendName);\n-\t\t\t\t\tregisterEditor(editedClass,found);\n-\t\t\t\t\treturn (PropertyEditor)found.newInstance();\n-\t\t\t\t} catch(ClassNotFoundException E) {\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t} catch(InstantiationException E) {\n-\t\t} catch(IllegalAccessException E) {\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/** Get the editor search path.\n-\t ** As a minor departure from the spec, the default value\n-\t ** for the editor search path is \"gnu.java.beans.editors\",\n-\t ** \"sun.beans.editors\".\n-\t ** @return the editor search path.\n-\t **/\n-\tpublic static String[] getEditorSearchPath() {\n-\t\treturn editorSearchPath;\n-\t}\n-\n-\t/** Set the editor search path.\n-\t ** @param editorSearchPath the new value for the editor\n-\t **        search path.\n-\t **/\n-\tpublic static void setEditorSearchPath(String[] editorSearchPath) {\n-\t\tsynchronized(editorSearchPath) {\n-\t\t\tPropertyEditorManager.editorSearchPath = editorSearchPath;\n-\t\t}\n-\t}\n+ * PropertyEditorManager is used to find property editors\n+ * for various types (not necessarily Beans).<P>\n+ *\n+ * It first checks to see if the property editor is\n+ * already registered; if it is, that property editor is\n+ * used.  Next it takes the type's classname and appends\n+ * \"Editor\" to it, and searches first in the class's\n+ * package and then in the property editor search path.<P>\n+ *\n+ * Default property editors are provided for:<P>\n+ * <OL>\n+ * <LI>boolean, byte, short, int, long, float, and double</LI>\n+ * <LI>java.lang.String</LI>\n+ * <LI>java.awt.Color</LI>\n+ * <LI>java.awt.Font</LI>\n+ * <OL>\n+ *\n+ * <STRONG>Spec Suggestion:</STRONG> Perhaps an editor for\n+ * Filename or something like it should be provided.  As well\n+ * as char.\n+ *\n+ * @author John Keiser\n+ * @since 1.1\n+ * @version 1.1.0, 29 Jul 1998\n+ */\n+\n+public class PropertyEditorManager\n+{\n+  static java.util.Hashtable editors = new java.util.Hashtable();\n+  static String[] editorSearchPath = {\"gnu.java.beans.editors\",\"sun.beans.editors\"};\n+\n+  static\n+    {\n+      registerEditor(java.lang.Boolean.TYPE, gnu.java.beans.editors.NativeBooleanEditor.class);\n+      registerEditor(java.lang.Byte.TYPE,    gnu.java.beans.editors.NativeByteEditor.class);\n+      registerEditor(java.lang.Short.TYPE,   gnu.java.beans.editors.NativeShortEditor.class);\n+      registerEditor(java.lang.Integer.TYPE, gnu.java.beans.editors.NativeIntEditor.class);\n+      registerEditor(java.lang.Long.TYPE,    gnu.java.beans.editors.NativeLongEditor.class);\n+      registerEditor(java.lang.Float.TYPE,   gnu.java.beans.editors.NativeFloatEditor.class);\n+      registerEditor(java.lang.Double.TYPE,  gnu.java.beans.editors.NativeDoubleEditor.class);\n+      registerEditor(java.lang.String.class, gnu.java.beans.editors.StringEditor.class);\n+      registerEditor(java.awt.Color.class,   gnu.java.beans.editors.ColorEditor.class);\n+      registerEditor(java.awt.Font.class,    gnu.java.beans.editors.FontEditor.class);\n+    }\n+\n+  /**\n+   * Beats me why this class can be instantiated, but there\n+   * you have it.\n+   */\n+  public PropertyEditorManager()\n+  {\n+    // Do nothing here\n+  }\n+\n+  /**\n+   * Register an editor for a class.  Replaces old editor\n+   * if there was one registered before.\n+   *\n+   * @param editedClass the class that the property editor\n+   *        will edit.\n+   * @param editorClass the PropertyEditor class.\n+   */\n+  public static void registerEditor(Class editedClass, Class editorClass)\n+  {\n+    editors.put(editedClass, editorClass);\n+  }\n+\n+  /**\n+   * Returns a new instance of the property editor for the\n+   * specified class.\n+   *\n+   * @param editedClass the class that the property editor\n+   *        will edit.\n+   * @return a PropertyEditor instance that can edit the\n+   *         specified class.\n+   */\n+  public static PropertyEditor findEditor(Class editedClass)\n+  {\n+    try\n+      {\n+        Class found = (Class)editors.get(editedClass);\n+        if(found != null)\n+          {\n+            return (PropertyEditor)found.newInstance();\n+          }\n+\n+        try\n+          {\n+            found = Class.forName(editedClass.getName()+\"Editor\");\n+            registerEditor(editedClass,found);\n+            return (PropertyEditor)found.newInstance();\n+          }\n+        catch(ClassNotFoundException E)\n+          {\n+          }\n+\n+        String appendName = \".\" + ClassHelper.getTruncatedClassName(editedClass) + \"Editor\";\n+        synchronized(editorSearchPath)\n+          {\n+            for(int i=0;i<editorSearchPath.length;i++)\n+              {\n+                try\n+                  {\n+                    found = Class.forName(editorSearchPath[i] + appendName);\n+                    registerEditor(editedClass,found);\n+                    return (PropertyEditor)found.newInstance();\n+                  }\n+                catch(ClassNotFoundException E)\n+                  {\n+                  }\n+              }\n+          }\n+      }\n+    catch(InstantiationException E)\n+      {\n+      }\n+    catch(IllegalAccessException E)\n+      {\n+      }\n+    \n+    return null;\n+  }\n+\n+  /**\n+   * Get the editor search path.\n+   * As a minor departure from the spec, the default value\n+   * for the editor search path is \"gnu.java.beans.editors\",\n+   * \"sun.beans.editors\".\n+   *\n+   * @return the editor search path.\n+   */\n+  public static String[] getEditorSearchPath()\n+  {\n+    return editorSearchPath;\n+  }\n+\n+  /**\n+   * Set the editor search path.\n+   *\n+   * @param editorSearchPath the new value for the editor search path.\n+   */\n+  public static void setEditorSearchPath(String[] editorSearchPath)\n+  {\n+    synchronized(editorSearchPath)\n+      {\n+        PropertyEditorManager.editorSearchPath = editorSearchPath;\n+      }\n+  }\n }"}]}