{"sha": "f6129d66bce280604f349fe2144ae5649964a476", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxMjlkNjZiY2UyODA2MDRmMzQ5ZmUyMTQ0YWU1NjQ5OTY0YTQ3Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2008-10-12T20:26:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2008-10-12T20:26:24Z"}, "message": "re PR middle-end/37447 (test pr28982b.c fails execution on power4 or later with ira change)\n\n        PR middle-end/37447\n        * Makefile.in (reload1.o): Depend on EMIT_RTL_H.\n        * alias.c (value_addr_p, stack_addr_p): Remove.\n        (nonoverlapping_memrefs_p): Remove IRA special case.\n        * emit-rtl.c (get_spill_slot_decl, set_mem_attrs_for_spill): New.\n        * emit-rtl.h (set_mem_attrs_for_spill): Declare.\n        * reload1.c (alter_reg): Use it.\n\nFrom-SVN: r141077", "tree": {"sha": "bbec7b5c162660943ed96247083662af72606da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbec7b5c162660943ed96247083662af72606da7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6129d66bce280604f349fe2144ae5649964a476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6129d66bce280604f349fe2144ae5649964a476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6129d66bce280604f349fe2144ae5649964a476", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6129d66bce280604f349fe2144ae5649964a476/comments", "author": null, "committer": null, "parents": [{"sha": "dc8bd8d973f962ff4ea11f455e0daf398aa8d732", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc8bd8d973f962ff4ea11f455e0daf398aa8d732", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc8bd8d973f962ff4ea11f455e0daf398aa8d732"}], "stats": {"total": 202, "additions": 94, "deletions": 108}, "files": [{"sha": "a7da2148d27b92e0267e53d6a9f4425093dbc7cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6129d66bce280604f349fe2144ae5649964a476/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6129d66bce280604f349fe2144ae5649964a476/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6129d66bce280604f349fe2144ae5649964a476", "patch": "@@ -1,3 +1,13 @@\n+2008-10-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/37447\n+\t* Makefile.in (reload1.o): Depend on EMIT_RTL_H.\n+\t* alias.c (value_addr_p, stack_addr_p): Remove.\n+\t(nonoverlapping_memrefs_p): Remove IRA special case.\n+\t* emit-rtl.c (get_spill_slot_decl, set_mem_attrs_for_spill): New.\n+\t* emit-rtl.h (set_mem_attrs_for_spill): Declare.\n+\t* reload1.c (alter_reg): Use it.\n+\n 2008-10-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/driver-i386.c (detect_caches_cpuid2): Use array"}, {"sha": "5cb12414056cb5811c3656607d9ab29ad1771043", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6129d66bce280604f349fe2144ae5649964a476/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6129d66bce280604f349fe2144ae5649964a476/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f6129d66bce280604f349fe2144ae5649964a476", "patch": "@@ -2868,7 +2868,7 @@ reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(RECOG_H) output.h $(FUNCTION_H) $(TOPLEV_H) $(TM_P_H) \\\n    addresses.h except.h $(TREE_H) $(REAL_H) $(FLAGS_H) $(MACHMODE_H) \\\n-   $(OBSTACK_H) $(DF_H) $(TARGET_H) dse.h ira.h\n+   $(OBSTACK_H) $(DF_H) $(TARGET_H) $(EMIT_RTL_H) ira.h\n rtlhooks.o :  rtlhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    rtlhooks-def.h $(EXPR_H) $(RECOG_H)\n postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\"}, {"sha": "4cadb6b2a2783c14f1b3b5b5d79825f7ad6e6085", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f6129d66bce280604f349fe2144ae5649964a476", "patch": "@@ -1983,34 +1983,6 @@ adjust_offset_for_component_ref (tree x, rtx offset)\n   return GEN_INT (ioffset);\n }\n \n-/* The function returns nonzero if X is an address containg VALUE.  */\n-static int\n-value_addr_p (rtx x)\n-{\n-  if (GET_CODE (x) == VALUE)\n-    return 1;\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == VALUE)\n-    return 1;\n-  return 0;\n-}\n-\n-/* The function returns nonzero if X is a stack address.  */\n-static int\n-stack_addr_p (rtx x)\n-{\n-  if (x == hard_frame_pointer_rtx || x == frame_pointer_rtx\n-      || x == arg_pointer_rtx || x == stack_pointer_rtx)\n-    return 1;\n-  if (GET_CODE (x) == PLUS\n-      && (XEXP (x, 0) == hard_frame_pointer_rtx\n-\t  || XEXP (x, 0) == frame_pointer_rtx\n-\t  || XEXP (x, 0) == arg_pointer_rtx\n-\t  || XEXP (x, 0) == stack_pointer_rtx)\n-      && CONSTANT_P (XEXP (x, 1)))\n-    return 1;\n-  return 0;\n-}\n-\n /* Return nonzero if we can determine the exprs corresponding to memrefs\n    X and Y and they do not overlap.  */\n \n@@ -2020,27 +1992,9 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y)\n   tree exprx = MEM_EXPR (x), expry = MEM_EXPR (y);\n   rtx rtlx, rtly;\n   rtx basex, basey;\n-  rtx x_addr, y_addr;\n   rtx moffsetx, moffsety;\n   HOST_WIDE_INT offsetx = 0, offsety = 0, sizex, sizey, tem;\n \n-  if (flag_ira && optimize && reload_completed)\n-    {\n-      /* We need this code for IRA because of stack slot sharing.  RTL\n-\t in decl can be different than RTL used in insns.  It is a\n-\t safe code although it can be conservative sometime.  */\n-      x_addr = canon_rtx (get_addr (XEXP (x, 0)));\n-      y_addr = canon_rtx (get_addr (XEXP (y, 0)));\n-      \n-      if (value_addr_p (x_addr) || value_addr_p (y_addr))\n-\treturn 0;\n-       \n-      if (stack_addr_p (x_addr) && stack_addr_p (y_addr)\n-\t  && memrefs_conflict_p (SIZE_FOR_MODE (y), y_addr,\n-\t\t\t\t SIZE_FOR_MODE (x), x_addr, 0))\n-\treturn 0;\n-    }\n-\n   /* Unless both have exprs, we can't tell anything.  */\n   if (exprx == 0 || expry == 0)\n     return 0;"}, {"sha": "46fefda614b1ab81ae4e40a6c957f9950fba52e6", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f6129d66bce280604f349fe2144ae5649964a476", "patch": "@@ -2138,6 +2138,65 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n   return new_rtx;\n }\n \f\n+/* A fake decl that is used as the MEM_EXPR of spill slots.  */\n+static GTY(()) tree spill_slot_decl;\n+\n+static tree\n+get_spill_slot_decl (void)\n+{\n+  tree d = spill_slot_decl;\n+  rtx rd;\n+\n+  if (d)\n+    return d;\n+\n+  d = build_decl (VAR_DECL, get_identifier (\"%sfp\"), void_type_node);\n+  DECL_ARTIFICIAL (d) = 1;\n+  DECL_IGNORED_P (d) = 1;\n+  TREE_USED (d) = 1;\n+  TREE_THIS_NOTRAP (d) = 1;\n+  spill_slot_decl = d;\n+\n+  rd = gen_rtx_MEM (BLKmode, frame_pointer_rtx);\n+  MEM_NOTRAP_P (rd) = 1;\n+  MEM_ATTRS (rd) = get_mem_attrs (new_alias_set (), d, const0_rtx,\n+\t\t\t\t  NULL_RTX, 0, BLKmode);\n+  SET_DECL_RTL (d, rd);\n+\n+  return d;\n+}\n+\n+/* Given MEM, a result from assign_stack_local, fill in the memory\n+   attributes as appropriate for a register allocator spill slot.\n+   These slots are not aliasable by other memory.  We arrange for\n+   them all to use a single MEM_EXPR, so that the aliasing code can\n+   work properly in the case of shared spill slots.  */\n+\n+void\n+set_mem_attrs_for_spill (rtx mem)\n+{\n+  alias_set_type alias;\n+  rtx addr, offset;\n+  tree expr;\n+\n+  expr = get_spill_slot_decl ();\n+  alias = MEM_ALIAS_SET (DECL_RTL (expr));\n+\n+  /* We expect the incoming memory to be of the form:\n+\t(mem:MODE (plus (reg sfp) (const_int offset)))\n+     with perhaps the plus missing for offset = 0.  */\n+  addr = XEXP (mem, 0);\n+  offset = const0_rtx;\n+  if (GET_CODE (addr) == PLUS\n+      && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+    offset = XEXP (addr, 1);\n+\n+  MEM_ATTRS (mem) = get_mem_attrs (alias, expr, offset,\n+\t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem),\n+\t\t\t\t   GET_MODE (mem));\n+  MEM_NOTRAP_P (mem) = 1;\n+}\n+\f\n /* Return a newly created CODE_LABEL rtx with a unique label number.  */\n \n rtx"}, {"sha": "6d4249f518eca2cf3cc1891459a687c7a075f052", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=f6129d66bce280604f349fe2144ae5649964a476", "patch": "@@ -35,6 +35,9 @@ extern void set_mem_offset (rtx, rtx);\n /* Set the size for MEM to SIZE.  */\n extern void set_mem_size (rtx, rtx);\n \n+/* Set the attributes for MEM appropriate for a spill slot.  */\n+extern void set_mem_attrs_for_spill (rtx);\n+\n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as"}, {"sha": "76175e3ecf3c324f71d4003a59962a15f7a79ec1", "filename": "gcc/reload1.c", "status": "modified", "additions": 21, "deletions": 61, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6129d66bce280604f349fe2144ae5649964a476/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f6129d66bce280604f349fe2144ae5649964a476", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira.h\"\n #include \"df.h\"\n #include \"target.h\"\n-#include \"dse.h\"\n+#include \"emit-rtl.h\"\n \n /* This file contains the reload pass of the compiler, which is\n    run after register allocation has been done.  It checks that\n@@ -2150,22 +2150,25 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n       && (reg_equiv_invariant[i] == 0 || reg_equiv_init[i] == 0)\n       && reg_equiv_memory_loc[i] == 0)\n     {\n-      rtx x;\n+      rtx x = NULL_RTX;\n       enum machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n       unsigned int inherent_size = PSEUDO_REGNO_BYTES (i);\n       unsigned int inherent_align = GET_MODE_ALIGNMENT (mode);\n       unsigned int total_size = MAX (inherent_size, reg_max_ref_width[i]);\n       unsigned int min_align = reg_max_ref_width[i] * BITS_PER_UNIT;\n       int adjust = 0;\n-      bool shared_p = false;\n \n       if (flag_ira && optimize)\n-\t/* Mark the spill for IRA.  */\n-\tSET_REGNO_REG_SET (&spilled_pseudos, i);\n-      x = (dont_share_p || ! flag_ira || ! optimize\n-\t   ? NULL_RTX : ira_reuse_stack_slot (i, inherent_size, total_size));\n+\t{\n+\t  /* Mark the spill for IRA.  */\n+\t  SET_REGNO_REG_SET (&spilled_pseudos, i);\n+\t  if (!dont_share_p)\n+\t    x = ira_reuse_stack_slot (i, inherent_size, total_size);\n+\t}\n+\n       if (x)\n-\tshared_p = true;\n+\t;\n+\n       /* Each pseudo reg has an inherent size which comes from its own mode,\n \t and a total size which provides room for paradoxical subregs\n \t which refer to the pseudo reg in wider modes.\n@@ -2174,10 +2177,9 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t enough inherent space and enough total space.\n \t Otherwise, we allocate a new slot, making sure that it has no less\n \t inherent space, and no less total space, then the previous slot.  */\n-      else if (from_reg == -1 || (! dont_share_p && flag_ira && optimize))\n+      else if (from_reg == -1 || (!dont_share_p && flag_ira && optimize))\n \t{\n \t  rtx stack_slot;\n-\t  alias_set_type alias_set = new_alias_set ();\n \n \t  /* No known place to spill from => no slot to reuse.  */\n \t  x = assign_stack_local (mode, total_size,\n@@ -2186,12 +2188,11 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \n \t  stack_slot = x;\n \n+\t  /* Cancel the big-endian correction done in assign_stack_local.\n+\t     Get the address of the beginning of the slot.  This is so we\n+\t     can do a big-endian correction unconditionally below.  */\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n-\t      /* Cancel the  big-endian correction done in assign_stack_local.\n-\t\t Get the address of the beginning of the slot.\n-\t\t This is so we can do a big-endian correction unconditionally\n-\t\t below.  */\n \t      adjust = inherent_size - total_size;\n \t      if (adjust)\n \t\tstack_slot\n@@ -2201,10 +2202,6 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t\t\t\t       adjust);\n \t    }\n \n-\t  /* Nothing can alias this slot except this pseudo.  */\n-\t  set_mem_alias_set (x, alias_set);\n-\t  dse_record_singleton_alias_set (alias_set, mode);\n-\n \t  if (! dont_share_p && flag_ira && optimize)\n \t    /* Inform IRA about allocation a new stack slot.  */\n \t    ira_mark_new_stack_slot (stack_slot, i, total_size);\n@@ -2217,6 +2214,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t\t   >= inherent_size)\n \t       && MEM_ALIGN (spill_stack_slot[from_reg]) >= min_align)\n \tx = spill_stack_slot[from_reg];\n+\n       /* Allocate a bigger slot.  */\n       else\n \t{\n@@ -2241,27 +2239,11 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t\t\t\t  || total_size > inherent_size ? -1 : 0);\n \t  stack_slot = x;\n \n-\t  /* All pseudos mapped to this slot can alias each other.  */\n-\t  if (spill_stack_slot[from_reg])\n-\t    {\n-\t      alias_set_type alias_set \n-\t\t= MEM_ALIAS_SET (spill_stack_slot[from_reg]);\n-\t      set_mem_alias_set (x, alias_set);\n-\t      dse_invalidate_singleton_alias_set (alias_set);\n-\t    }\n-\t  else\n-\t    {\n-\t      alias_set_type alias_set = new_alias_set ();\n-\t      set_mem_alias_set (x, alias_set);\n-\t      dse_record_singleton_alias_set (alias_set, mode);\n-\t    }\n-\n+\t  /* Cancel the  big-endian correction done in assign_stack_local.\n+\t     Get the address of the beginning of the slot.  This is so we\n+\t     can do a big-endian correction unconditionally below.  */\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n-\t      /* Cancel the  big-endian correction done in assign_stack_local.\n-\t\t Get the address of the beginning of the slot.\n-\t\t This is so we can do a big-endian correction unconditionally\n-\t\t below.  */\n \t      adjust = GET_MODE_SIZE (mode) - total_size;\n \t      if (adjust)\n \t\tstack_slot\n@@ -2284,30 +2266,8 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t wrong mode, make a new stack slot.  */\n       x = adjust_address_nv (x, GET_MODE (regno_reg_rtx[i]), adjust);\n \n-      /* If we have a decl for the original register, set it for the\n-\t memory.  If this is a shared MEM, make a copy.  */\n-      if (shared_p)\n-\t{\n-\t  x = copy_rtx (x);\n-\t  set_mem_attrs_from_reg (x, regno_reg_rtx[i]);\n-\t}\n-      else if (REG_EXPR (regno_reg_rtx[i])\n-\t       && DECL_P (REG_EXPR (regno_reg_rtx[i])))\n-\t{\n-\t  rtx decl = DECL_RTL_IF_SET (REG_EXPR (regno_reg_rtx[i]));\n-\n-\t  /* We can do this only for the DECLs home pseudo, not for\n-\t     any copies of it, since otherwise when the stack slot\n-\t     is reused, nonoverlapping_memrefs_p might think they\n-\t     cannot overlap.  */\n-\t  if (decl && REG_P (decl) && REGNO (decl) == (unsigned) i)\n-\t    {\n-\t      if (from_reg != -1 && spill_stack_slot[from_reg] == x)\n-\t\tx = copy_rtx (x);\n-\n-\t      set_mem_attrs_from_reg (x, regno_reg_rtx[i]);\n-\t    }\n-\t}\n+      /* Set all of the memory attributes as appropriate for a spill.  */\n+      set_mem_attrs_for_spill (x);\n \n       /* Save the stack slot for later.  */\n       reg_equiv_memory_loc[i] = x;"}]}