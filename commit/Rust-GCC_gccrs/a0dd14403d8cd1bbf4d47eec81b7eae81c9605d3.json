{"sha": "a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBkZDE0NDAzZDhjZDFiYmY0ZDQ3ZWVjODFiN2VhZTgxYzk2MDVkMw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-11-25T04:54:30Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T04:54:30Z"}, "message": "graphite-dependences.c (reduction_ddr): New.\n\n2009-10-05  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-dependences.c (reduction_ddr): New.\n\t(graphite_legal_transform_bb): Call reduction_ddr.\n\t* graphite-poly.c (new_poly_bb): Pass a new bool parameter.\n\tInitialize PBB_IS_REDUCTION.\n\t* graphite-poly.h (struct poly_bb): New bool field is_reduction.\n\t(PBB_IS_REDUCTION): New.\n\t(new_poly_bb): Update declaration.\n\t* graphite-scop-detection.h (build_scop_bbs): Removed.\n\t(nb_reductions_in_loop): Removed.\n\t* graphite-sese-to-poly.c (try_generate_gimple_bb): Pass a sbitmap\n\tparameter for reductions.\n\t(try_generate_gimple_bb): Update call to new_poly_bb.\n\t(build_scop_bbs_1): Same.\n\t(build_scop_bbs): Same.\n\t(gsi_for_phi_node): New.\n\t(scalar_close_phi_node_p): Remove gcc_assert.\n\t(split_reduction_stmt): New.\n\t(is_reduction_operation_p): New.\n\t(phi_contains_arg): New.\n\t(follow_ssa_with_commutative_ops): New.\n\t(detect_commutative_reduction_arg): New.\n\t(detect_commutative_reduction_assign): New.\n\t(follow_inital_value_to_phi): New.\n\t(edge_initial_value_for_loop_phi): New.\n\t(initial_value_for_loop_phi): New.\n\t(detect_commutative_reduction): New.\n\t(translate_scalar_reduction_to_array_for_stmt): New.\n\t(insert_copyout): New.\n\t(insert_copyin): New.\n\t(translate_scalar_reduction_to_array): New.\n\t(rewrite_commutative_reductions_out_of_ssa_close_phi): New.\n\t(rewrite_commutative_reductions_out_of_ssa_loop): New.\n\t(rewrite_commutative_reductions_out_of_ssa): New.\n\t(build_poly_scop): Call rewrite_commutative_reductions_out_of_ssa.\n\t* sese.h (split_region_for_bb): New.\n\n\t* gcc.dg/graphite/graphite.exp (DEFAULT_CFLAGS_GRAPHITE_BLOCK): Add -ffast-math.\n\t* gcc.dg/graphite/interchange-1.c: Fix format.\n\t* gcc.dg/graphite/interchange-10.c: New.\n\nFrom-SVN: r154561", "tree": {"sha": "b5e1d1cd97c6ef8d389112a92df304c433f8bd89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5e1d1cd97c6ef8d389112a92df304c433f8bd89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db7e948531737bf2998079c58934664977678741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7e948531737bf2998079c58934664977678741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db7e948531737bf2998079c58934664977678741"}], "stats": {"total": 507, "additions": 487, "deletions": 20}, "files": [{"sha": "f8c3ff1f098099dcaf98a58302f786a2be4c9d12", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -1,3 +1,45 @@\n+2009-10-05  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-dependences.c (reduction_ddr): New.\n+\t(graphite_legal_transform_bb): Call reduction_ddr.\n+\t* graphite-poly.c (new_poly_bb): Pass a new bool parameter.\n+\tInitialize PBB_IS_REDUCTION.\n+\t* graphite-poly.h (struct poly_bb): New bool field is_reduction.\n+\t(PBB_IS_REDUCTION): New.\n+\t(new_poly_bb): Update declaration.\n+\t* graphite-scop-detection.h (build_scop_bbs): Removed.\n+\t(nb_reductions_in_loop): Removed.\n+\t* graphite-sese-to-poly.c (try_generate_gimple_bb): Pass a sbitmap\n+\tparameter for reductions.\n+\t(try_generate_gimple_bb): Update call to new_poly_bb.\n+\t(build_scop_bbs_1): Same.\n+\t(build_scop_bbs): Same.\n+\t(gsi_for_phi_node): New.\n+\t(scalar_close_phi_node_p): Remove gcc_assert.\n+\t(split_reduction_stmt): New.\n+\t(is_reduction_operation_p): New.\n+\t(phi_contains_arg): New.\n+\t(follow_ssa_with_commutative_ops): New.\n+\t(detect_commutative_reduction_arg): New.\n+\t(detect_commutative_reduction_assign): New.\n+\t(follow_inital_value_to_phi): New.\n+\t(edge_initial_value_for_loop_phi): New.\n+\t(initial_value_for_loop_phi): New.\n+\t(detect_commutative_reduction): New.\n+\t(translate_scalar_reduction_to_array_for_stmt): New.\n+\t(insert_copyout): New.\n+\t(insert_copyin): New.\n+\t(translate_scalar_reduction_to_array): New.\n+\t(rewrite_commutative_reductions_out_of_ssa_close_phi): New.\n+\t(rewrite_commutative_reductions_out_of_ssa_loop): New.\n+\t(rewrite_commutative_reductions_out_of_ssa): New.\n+\t(build_poly_scop): Call rewrite_commutative_reductions_out_of_ssa.\n+\t* sese.h (split_region_for_bb): New.\n+\n+\t* gcc.dg/graphite/graphite.exp (DEFAULT_CFLAGS_GRAPHITE_BLOCK): Add -ffast-math.\n+\t* gcc.dg/graphite/interchange-1.c: Fix format.\n+\t* gcc.dg/graphite/interchange-10.c: New.\n+\n 2009-10-05  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-sese-to-poly.c (insert_out_of_ssa_copy): Remove"}, {"sha": "2e777b3508d99f8e512d62cd253479d544bf0b79", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -585,6 +585,15 @@ graphite_legal_transform_dr (poly_bb_p pbb1, poly_bb_p pbb2,\n   return is_empty_p;\n }\n \n+/* Return true when the data dependence relation for PBB1 and PBB2 is\n+   part of a reduction.  */\n+\n+static inline bool\n+reduction_ddr (poly_bb_p pbb1, poly_bb_p pbb2)\n+{\n+  return pbb1 == pbb2 && PBB_IS_REDUCTION (pbb1);\n+}\n+\n /* Iterates over the data references of PBB1 and PBB2 and detect\n    whether the transformed schedule is correct.  */\n \n@@ -600,6 +609,9 @@ graphite_legal_transform_bb (poly_bb_p pbb1, poly_bb_p pbb2)\n   if (!PBB_PDR_DUPLICATES_REMOVED (pbb2))\n     pbb_remove_duplicate_pdrs (pbb2);\n \n+  if (reduction_ddr (pbb1, pbb2))\n+    return true;\n+\n   for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), i, pdr1); i++)\n     for (j = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), j, pdr2); j++)\n       if (!graphite_legal_transform_dr (pbb1, pbb2, pdr1, pdr2))"}, {"sha": "e97b0a863fd847789d5dd94fee5aa39bf7cf6fd2", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -337,7 +337,7 @@ free_poly_dr (poly_dr_p pdr)\n /* Create a new polyhedral black box.  */\n \n void\n-new_poly_bb (scop_p scop, void *black_box)\n+new_poly_bb (scop_p scop, void *black_box, bool reduction)\n {\n   poly_bb_p pbb = XNEW (struct poly_bb);\n \n@@ -348,6 +348,7 @@ new_poly_bb (scop_p scop, void *black_box)\n   PBB_SAVED (pbb) = NULL;\n   PBB_ORIGINAL (pbb) = NULL;\n   PBB_DRS (pbb) = VEC_alloc (poly_dr_p, heap, 3);\n+  PBB_IS_REDUCTION (pbb) = reduction;\n   VEC_safe_push (poly_bb_p, heap, SCOP_BBS (scop), pbb);\n }\n "}, {"sha": "c397f6ad63c2f6368c77a8ff605f1bc6ad9f042e", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -306,6 +306,9 @@ struct poly_bb\n \n   /* True when the PDR duplicates have already been removed.  */\n   bool pdr_duplicates_removed;\n+\n+  /* True when this PBB contains only a reduction statement.  */\n+  bool is_reduction;\n };\n \n #define PBB_BLACK_BOX(PBB) ((gimple_bb_p) PBB->black_box)\n@@ -320,8 +323,9 @@ struct poly_bb\n #define PBB_NB_LOCAL_VARIABLES(PBB) (PBB->transformed->nb_local_variables)\n #define PBB_NB_SCATTERING_TRANSFORM(PBB) (PBB->transformed->nb_scattering)\n #define PBB_PDR_DUPLICATES_REMOVED(PBB) (PBB->pdr_duplicates_removed)\n+#define PBB_IS_REDUCTION(PBB) (PBB->is_reduction)\n \n-extern void new_poly_bb (scop_p, void *);\n+extern void new_poly_bb (scop_p, void *, bool);\n extern void free_poly_bb (poly_bb_p);\n extern void debug_loop_vec (poly_bb_p);\n extern void schedule_to_scattering (poly_bb_p, int);"}, {"sha": "44c2223588d69289ee44ed0815c2478eb44f6399", "filename": "gcc/graphite-scop-detection.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-scop-detection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-scop-detection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.h?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -21,7 +21,5 @@ along with GCC; see the file COPYING3.  If not see\n \n \n extern void build_scops (VEC (scop_p, heap) **);\n-extern void build_scop_bbs (scop_p);\n-extern int nb_reductions_in_loop (loop_p);\n extern void dot_all_scops (VEC (scop_p, heap) *);\n extern void dot_scop (scop_p);"}, {"sha": "56f89cc3f1aaebd62677aea0cf16fbb7232dd208", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 396, "deletions": 13, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -346,7 +346,7 @@ free_scops (VEC (scop_p, heap) *scops)\n    information.  */\n \n static void\n-try_generate_gimple_bb (scop_p scop, basic_block bb)\n+try_generate_gimple_bb (scop_p scop, basic_block bb, sbitmap reductions)\n {\n   VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 5);\n   loop_p nest = outermost_loop_in_sese (SCOP_REGION (scop), bb);\n@@ -362,7 +362,8 @@ try_generate_gimple_bb (scop_p scop, basic_block bb)\n   if (!graphite_stmt_p (SCOP_REGION (scop), bb, drs))\n     free_data_refs (drs);\n   else\n-    new_poly_bb (scop, new_gimple_bb (bb, drs));\n+    new_poly_bb (scop, new_gimple_bb (bb, drs), TEST_BIT (reductions,\n+\t\t\t\t\t\t\t  bb->index));\n }\n \n /* Returns true if all predecessors of BB, that are not dominated by BB, are\n@@ -417,7 +418,7 @@ graphite_sort_dominated_info (VEC (basic_block, heap) *dom)\n /* Recursive helper function for build_scops_bbs.  */\n \n static void\n-build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n+build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb, sbitmap reductions)\n {\n   sese region = SCOP_REGION (scop);\n   VEC (basic_block, heap) *dom;\n@@ -426,7 +427,7 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n       || !bb_in_sese_p (bb, region))\n     return;\n \n-  try_generate_gimple_bb (scop, bb);\n+  try_generate_gimple_bb (scop, bb, reductions);\n   SET_BIT (visited, bb->index);\n \n   dom = get_dominated_by (CDI_DOMINATORS, bb);\n@@ -444,7 +445,7 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n       for (i = 0; VEC_iterate (basic_block, dom, i, dom_bb); i++)\n \tif (all_non_dominated_preds_marked_p (dom_bb, visited))\n \t  {\n-\t    build_scop_bbs_1 (scop, visited, dom_bb);\n+\t    build_scop_bbs_1 (scop, visited, dom_bb, reductions);\n \t    VEC_unordered_remove (basic_block, dom, i);\n \t    break;\n \t  }\n@@ -455,15 +456,14 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n \n /* Gather the basic blocks belonging to the SCOP.  */\n \n-void\n-build_scop_bbs (scop_p scop)\n+static void\n+build_scop_bbs (scop_p scop, sbitmap reductions)\n {\n   sbitmap visited = sbitmap_alloc (last_basic_block);\n   sese region = SCOP_REGION (scop);\n \n   sbitmap_zero (visited);\n-  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region));\n-\n+  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region), reductions);\n   sbitmap_free (visited);\n }\n \n@@ -1857,6 +1857,22 @@ build_scop_drs (scop_p scop)\n     build_pbb_drs (pbb);\n }\n \n+/* Return a gsi at the position of the phi node STMT.  */\n+\n+static gimple_stmt_iterator\n+gsi_for_phi_node (gimple stmt)\n+{\n+  gimple_stmt_iterator psi;\n+  basic_block bb = gimple_bb (stmt);\n+\n+  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+    if (stmt == gsi_stmt (psi))\n+      return psi;\n+\n+  gcc_unreachable ();\n+  return psi;\n+}\n+\n /* Insert the assignment \"RES := VAR\" just after the definition of VAR.  */\n \n static void\n@@ -1927,9 +1943,8 @@ create_zero_dim_array (tree var)\n static bool\n scalar_close_phi_node_p (gimple phi)\n {\n-  gcc_assert (gimple_code (phi) == GIMPLE_PHI);\n-\n-  if (!is_gimple_reg (gimple_phi_result (phi)))\n+  if (gimple_code (phi) != GIMPLE_PHI\n+      || !is_gimple_reg (gimple_phi_result (phi)))\n     return false;\n \n   return (gimple_phi_num_args (phi) == 1);\n@@ -2198,14 +2213,382 @@ nb_pbbs_in_loops (scop_p scop)\n   return res;\n }\n \n+/* Splits STMT out of its current BB.  */\n+\n+static basic_block\n+split_reduction_stmt (gimple stmt)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb = gimple_bb (stmt);\n+  edge e;\n+\n+  split_block (bb, stmt);\n+\n+  gsi = gsi_last_bb (bb);\n+  gsi_prev (&gsi);\n+  e = split_block (bb, gsi_stmt (gsi));\n+\n+  return e->dest;\n+}\n+\n+/* Return true when stmt is a reduction operation.  */\n+\n+static inline bool\n+is_reduction_operation_p (gimple stmt)\n+{\n+  return flag_associative_math\n+    && commutative_tree_code (gimple_assign_rhs_code (stmt))\n+    && associative_tree_code (gimple_assign_rhs_code (stmt));\n+}\n+\n+/* Returns true when PHI contains an argument ARG.  */\n+\n+static bool\n+phi_contains_arg (gimple phi, tree arg)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    if (operand_equal_p (arg, gimple_phi_arg_def (phi, i), 0))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return a loop phi node that corresponds to a reduction containing LHS.  */\n+\n+static gimple\n+follow_ssa_with_commutative_ops (tree arg, tree lhs)\n+{\n+  gimple stmt;\n+\n+  if (TREE_CODE (arg) != SSA_NAME)\n+    return NULL;\n+\n+  stmt = SSA_NAME_DEF_STMT (arg);\n+\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    {\n+      if (phi_contains_arg (stmt, lhs))\n+\treturn stmt;\n+      return NULL;\n+    }\n+\n+  if (gimple_num_ops (stmt) == 2)\n+    return follow_ssa_with_commutative_ops (gimple_assign_rhs1 (stmt), lhs);\n+\n+  if (is_reduction_operation_p (stmt))\n+    {\n+      gimple res = follow_ssa_with_commutative_ops (gimple_assign_rhs1 (stmt), lhs);\n+\n+      return res ? res :\n+\tfollow_ssa_with_commutative_ops (gimple_assign_rhs2 (stmt), lhs);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Detect commutative and associative scalar reductions starting at\n+   the STMT.  */\n+\n+static gimple\n+detect_commutative_reduction_arg (tree lhs, gimple stmt, tree arg,\n+\t\t\t\t  VEC (gimple, heap) **in,\n+\t\t\t\t  VEC (gimple, heap) **out)\n+{\n+  gimple phi = follow_ssa_with_commutative_ops (arg, lhs);\n+\n+  if (phi)\n+    {\n+      VEC_safe_push (gimple, heap, *in, stmt);\n+      VEC_safe_push (gimple, heap, *out, stmt);\n+      return phi;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Detect commutative and associative scalar reductions starting at\n+   the STMT.  */\n+\n+static gimple\n+detect_commutative_reduction_assign (gimple stmt, VEC (gimple, heap) **in,\n+\t\t\t\t     VEC (gimple, heap) **out)\n+{\n+  tree lhs = gimple_assign_lhs (stmt);\n+\n+  if (gimple_num_ops (stmt) == 2)\n+    return detect_commutative_reduction_arg (lhs, stmt,\n+\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t     in, out);\n+\n+  if (is_reduction_operation_p (stmt))\n+    {\n+      gimple res = detect_commutative_reduction_arg (lhs, stmt,\n+\t\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t\t     in, out);\n+      return res ? res\n+\t: detect_commutative_reduction_arg (lhs, stmt,\n+\t\t\t\t\t    gimple_assign_rhs2 (stmt),\n+\t\t\t\t\t    in, out);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Return a loop phi node that corresponds to a reduction containing LHS.  */\n+\n+static gimple\n+follow_inital_value_to_phi (tree arg, tree lhs)\n+{\n+  gimple stmt;\n+\n+  if (!arg || TREE_CODE (arg) != SSA_NAME)\n+    return NULL;\n+\n+  stmt = SSA_NAME_DEF_STMT (arg);\n+\n+  if (gimple_code (stmt) == GIMPLE_PHI\n+      && phi_contains_arg (stmt, lhs))\n+    return stmt;\n+\n+  return NULL;\n+}\n+\n+\n+/* Return the argument of the loop PHI that is the inital value coming\n+   from outside the loop.  */\n+\n+static edge\n+edge_initial_value_for_loop_phi (gimple phi)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      edge e = gimple_phi_arg_edge (phi, i);\n+\n+      if (loop_depth (e->src->loop_father)\n+\t  < loop_depth (e->dest->loop_father))\n+\treturn e;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Return the argument of the loop PHI that is the inital value coming\n+   from outside the loop.  */\n+\n+static tree\n+initial_value_for_loop_phi (gimple phi)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      edge e = gimple_phi_arg_edge (phi, i);\n+\n+      if (loop_depth (e->src->loop_father)\n+\t  < loop_depth (e->dest->loop_father))\n+\treturn gimple_phi_arg_def (phi, i);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Detect commutative and associative scalar reductions starting at\n+   the loop closed phi node CLOSE_PHI.  */\n+\n+static gimple\n+detect_commutative_reduction (gimple stmt, VEC (gimple, heap) **in,\n+\t\t\t      VEC (gimple, heap) **out)\n+{\n+  if (scalar_close_phi_node_p (stmt))\n+    {\n+      tree arg = gimple_phi_arg_def (stmt, 0);\n+      gimple def = SSA_NAME_DEF_STMT (arg);\n+      gimple loop_phi = detect_commutative_reduction (def, in, out);\n+\n+      if (loop_phi)\n+\t{\n+\t  tree lhs = gimple_phi_result (stmt);\n+\t  tree init = initial_value_for_loop_phi (loop_phi);\n+\t  gimple phi = follow_inital_value_to_phi (init, lhs);\n+\n+\t  VEC_safe_push (gimple, heap, *in, loop_phi);\n+\t  VEC_safe_push (gimple, heap, *out, stmt);\n+\t  return phi;\n+\t}\n+      else\n+\treturn NULL;\n+    }\n+\n+  if (gimple_code (stmt) == GIMPLE_ASSIGN)\n+    return detect_commutative_reduction_assign (stmt, in, out);\n+\n+  return NULL;\n+}\n+\n+/* Translate the scalar reduction statement STMT to an array RED\n+   knowing that its recursive phi node is LOOP_PHI.  */\n+\n+static void\n+translate_scalar_reduction_to_array_for_stmt (tree red, gimple stmt,\n+\t\t\t\t\t      gimple loop_phi)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+  gimple_stmt_iterator insert_gsi = gsi_after_labels (bb);\n+  tree res = gimple_phi_result (loop_phi);\n+  gimple assign = gimple_build_assign (res, red);\n+\n+  gsi_insert_before (&insert_gsi, assign, GSI_SAME_STMT);\n+\n+  assign = gimple_build_assign (red, gimple_assign_lhs (stmt));\n+  insert_gsi = gsi_last_bb (bb);\n+  gsi_insert_after (&insert_gsi, assign, GSI_SAME_STMT);\n+}\n+\n+/* Insert the assignment \"result (CLOSE_PHI) = RED\".  */\n+\n+static void\n+insert_copyout (tree red, gimple close_phi)\n+{\n+  tree res = gimple_phi_result (close_phi);\n+  basic_block bb = gimple_bb (close_phi);\n+  gimple_stmt_iterator insert_gsi = gsi_after_labels (bb);\n+  gimple assign = gimple_build_assign (res, red);\n+\n+  gsi_insert_before (&insert_gsi, assign, GSI_SAME_STMT);\n+}\n+\n+/* Insert the assignment \"RED = initial_value (LOOP_PHI)\".  */\n+\n+static void\n+insert_copyin (tree red, gimple loop_phi)\n+{\n+  gimple_seq stmts;\n+  tree init = initial_value_for_loop_phi (loop_phi);\n+  edge e = edge_initial_value_for_loop_phi (loop_phi);\n+  basic_block bb = e->src;\n+  gimple_stmt_iterator insert_gsi = gsi_last_bb (bb);\n+  tree expr = build2 (MODIFY_EXPR, TREE_TYPE (init), red, init);\n+\n+  force_gimple_operand (expr, &stmts, true, NULL);\n+  gsi_insert_seq_before (&insert_gsi, stmts, GSI_SAME_STMT);\n+}\n+\n+/* Rewrite out of SSA the reduction described by the loop phi nodes\n+   IN, and the close phi nodes OUT.  IN and OUT are structured by loop\n+   levels like this:\n+\n+   IN: stmt, loop_n, ..., loop_0\n+   OUT: stmt, close_n, ..., close_0\n+\n+   the first element is the reduction statement, and the next elements\n+   are the loop and close phi nodes of each of the outer loops.  */\n+\n+static void\n+translate_scalar_reduction_to_array (VEC (gimple, heap) *in,\n+\t\t\t\t     VEC (gimple, heap) *out,\n+\t\t\t\t     sbitmap reductions)\n+{\n+  unsigned int i;\n+  gimple loop_phi;\n+  tree red;\n+  gimple_stmt_iterator gsi;\n+\n+  for (i = 0; VEC_iterate (gimple, in, i, loop_phi); i++)\n+    {\n+      gimple close_phi = VEC_index (gimple, out, i);\n+\n+      if (i == 0)\n+\t{\n+\t  gimple stmt = loop_phi;\n+\t  basic_block bb = split_reduction_stmt (stmt);\n+\n+\t  SET_BIT (reductions, bb->index);\n+\t  gcc_assert (close_phi == loop_phi);\n+\n+\t  red = create_zero_dim_array (gimple_assign_lhs (stmt));\n+\t  translate_scalar_reduction_to_array_for_stmt\n+\t    (red, stmt, VEC_index (gimple, in, 1));\n+\t  continue;\n+\t}\n+\n+      if (i == VEC_length (gimple, in) - 1)\n+\t{\n+\t  insert_copyout (red, close_phi);\n+\t  insert_copyin (red, loop_phi);\n+\t}\n+\n+      gsi = gsi_for_phi_node (loop_phi);\n+      remove_phi_node (&gsi, false);\n+\n+      gsi = gsi_for_phi_node (close_phi);\n+      remove_phi_node (&gsi, false);\n+    }\n+}\n+\n+/* Rewrites out of SSA a commutative reduction at CLOSE_PHI.  */\n+\n+static void\n+rewrite_commutative_reductions_out_of_ssa_close_phi (gimple close_phi,\n+\t\t\t\t\t\t     sbitmap reductions)\n+{\n+  VEC (gimple, heap) *in = VEC_alloc (gimple, heap, 10);\n+  VEC (gimple, heap) *out = VEC_alloc (gimple, heap, 10);\n+\n+  detect_commutative_reduction (close_phi, &in, &out);\n+  if (VEC_length (gimple, in) > 0)\n+    translate_scalar_reduction_to_array (in, out, reductions);\n+\n+  VEC_free (gimple, heap, in);\n+  VEC_free (gimple, heap, out);\n+}\n+\n+/* Rewrites all the commutative reductions from LOOP out of SSA.  */\n+\n+static void\n+rewrite_commutative_reductions_out_of_ssa_loop (loop_p loop,\n+\t\t\t\t\t\tsbitmap reductions)\n+{\n+  gimple_stmt_iterator gsi;\n+  edge exit = single_exit (loop);\n+\n+  if (!exit)\n+    return;\n+\n+  for (gsi = gsi_start_phis (exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    rewrite_commutative_reductions_out_of_ssa_close_phi (gsi_stmt (gsi),\n+\t\t\t\t\t\t\t reductions);\n+}\n+\n+/* Rewrites all the commutative reductions from SCOP out of SSA.  */\n+\n+static void\n+rewrite_commutative_reductions_out_of_ssa (sese region, sbitmap reductions)\n+{\n+  loop_iterator li;\n+  loop_p loop;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    if (loop_in_sese_p (loop, region))\n+      rewrite_commutative_reductions_out_of_ssa_loop (loop, reductions);\n+}\n+\n /* Builds the polyhedral representation for a SESE region.  */\n \n bool\n build_poly_scop (scop_p scop)\n {\n   sese region = SCOP_REGION (scop);\n+  sbitmap reductions = sbitmap_alloc (last_basic_block * 2);\n+\n+  sbitmap_zero (reductions);\n+  rewrite_commutative_reductions_out_of_ssa (region, reductions);\n   rewrite_reductions_out_of_ssa (scop);\n-  build_scop_bbs (scop);\n+  build_scop_bbs (scop, reductions);\n+  sbitmap_free (reductions);\n \n   /* FIXME: This restriction is needed to avoid a problem in CLooG.\n      Once CLooG is fixed, remove this guard.  Anyways, it makes no"}, {"sha": "ca167f53ce615d8510bec560a47ca04f589986f7", "filename": "gcc/sese.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -188,6 +188,33 @@ sese_loop_depth (sese region, loop_p loop)\n   return depth;\n }\n \n+/* Splits BB to make a single entry single exit region.  */\n+\n+static inline sese\n+split_region_for_bb (basic_block bb)\n+{\n+  edge entry, exit;\n+\n+  if (single_pred_p (bb))\n+    entry = single_pred_edge (bb);\n+  else\n+    {\n+      entry = split_block_after_labels (bb);\n+      bb = single_succ (bb);\n+    }\n+\n+  if (single_succ_p (bb))\n+    exit = single_succ_edge (bb);\n+  else\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+      gsi_prev (&gsi);\n+      exit = split_block (bb, gsi_stmt (gsi));\n+    }\n+\n+  return new_sese (entry, exit);\n+}\n+\n /* Returns the block preceding the entry of a SESE.  */\n \n static inline basic_block"}, {"sha": "ae0fa16830e745d3ad270ca32db38baefe709fa0", "filename": "gcc/testsuite/gcc.dg/graphite/graphite.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -55,7 +55,7 @@ dg-runtest $id_files \"\" $DEFAULT_CFLAGS_GRAPHITE_IDENTITY\n foreach id_file $id_files {lremove wait_to_run_files $id_file}\n \n # Flags using for interchange-* files.\n-set DEFAULT_CFLAGS_GRAPHITE_BLOCK \"-O2 -fdump-tree-graphite-all -floop-interchange\"\n+set DEFAULT_CFLAGS_GRAPHITE_BLOCK \"-O2 -fdump-tree-graphite-all -floop-interchange -ffast-math\"\n set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.c ] ]\n dg-runtest $interchange_files \"\" $DEFAULT_CFLAGS_GRAPHITE_BLOCK\n foreach interchange_file $interchange_files {lremove wait_to_run_files $interchange_file}"}, {"sha": "cd9197d4d1a0b58b26ba869dd76a9b9275e52d31", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c?ref=a0dd14403d8cd1bbf4d47eec81b7eae81c9605d3", "patch": "@@ -12,11 +12,11 @@ int foo(int N, int *res)\n     {\n       for (j = 0; j < N; j++)\n \tsum = sum + u[i + 1335 * j];\n-      \n+\n       u[1336 * i] *= 2;\n     }\n   *res = sum + N;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */ \n+/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}]}