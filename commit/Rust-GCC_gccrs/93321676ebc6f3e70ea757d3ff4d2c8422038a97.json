{"sha": "93321676ebc6f3e70ea757d3ff4d2c8422038a97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMzMjE2NzZlYmM2ZjNlNzBlYTc1N2QzZmY0ZDJjODQyMjAzOGE5Nw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T00:16:51Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T00:16:51Z"}, "message": "combine.c: Use rtx_insn\n\ngcc/\n2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n\n\t* combine.c (i2mod): Strengthen this variable from rtx to rtx_insn *.\n\t(struct reg_stat_struct): Likewise for fields \"last_death\", \"last_set\".\n\t(subst_insn): Likewise for this variable.\n\t(added_links_insn): Likewise.\n\t(struct insn_link): Likewise for field \"insn\".\n\t(alloc_insn_link): Likewise for param \"insn\".\n\t(struct undobuf): Likewise for field \"other_insn\".\n\t(find_single_use): Likewise for param \"insn\" and local \"next\".\n\t(combine_validate_cost): Likewise for params \"i0\", \"i1\", \"i2\", \"i3\".\n\t(delete_noop_moves): Likewise for locals \"insn\", \"next\".\n\t(create_log_links): Likewise for locals \"insn\", \"use_insn\".\n\tStrengthen local \"next_use\" from rtx * to rtx_insn **.\n\t(insn_a_feeds_b): Likewise for params \"a\", \"b\".\n\t(combine_instructions): Likewise for param \"f\" and locals \"insn\",\n\t\"next\", \"prev\", \"first\", \"last_combined_insn\", \"link\", \"link1\",\n\t\"temp\".  Replace use of NULL_RTX with NULL when referring to\n\tinsns.\n\t(setup_incoming_promotions): Likewise for param \"first\"\n\t(set_nonzero_bits_and_sign_copies): Likewise for local \"insn\".\n\t(can_combine_p): Likewise for params \"insn\", \"i3\", \"pred\",\n\t\"pred2\", \"succ\", \"succ2\" and for local \"p\".\n\t(combinable_i3pat): Likewise for param \"i3\".\n\t(cant_combine_insn_p): Likewise for param \"insn\".\n\t(likely_spilled_retval_p): Likewise.\n\t(adjust_for_new_dest): Likewise.\n\t(update_cfg_for_uncondjump): Likewise, also for local \"insn\".\n\t(try_combine): Likewise for return type and for params \"i3\", \"i2\",\n\t\"i1\", \"i0\", \"last_combined_insn\", and for locals \"insn\",\n\t\"cc_use_insn\", \"p\", \"first\", \"last\", \"i2_insn\", \"i1_insn\",\n\t\"i0_insn\".  Eliminate local \"tem\" in favor of new locals\n\t\"tem_note\" and \"tem_insn\", the latter being an rtx_insn *.  Add a\n\tchecked cast for now to rtx_insn * on the return type of\n\tgen_rtx_INSN.  Replace use of NULL_RTX with NULL when referring to\n\tinsns.\n\t(find_split_point): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(simplify_set): Likewise for local \"other_insn\".\n\t(recog_for_combine): Likewise for param \"insn\".\n\t(record_value_for_reg): Likewise.\n\t(record_dead_and_set_regs_1): Likewise for local\n\t\"record_dead_insn\".\n\t(record_dead_and_set_regs): Likewise for param \"insn\".\n\t(record_promoted_value): Likewise.\n\t(check_promoted_subreg): Likewise.\n\t(get_last_value_validate): Likewise.\n\t(reg_dead_at_p): Likewise.\n\t(move_deaths): Likewise for param \"to_insn\".\n\t(distribute_notes): Likewise for params \"from_insn\", \"i3\", \"i2\"\n\tand locals \"place\", \"place2\", \"cc0_setter\".  Eliminate local \"tem\n\tin favor of new locals \"tem_note\" and \"tem_insn\", the latter being\n\tan rtx_insn *.\n\t(distribute_links): Strengthen locals \"place\", \"insn\" from rtx to\n\trtx_insn *.\n\nFrom-SVN: r214299", "tree": {"sha": "a63d88c2b750b2e70d00bce86657cdb95be004a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a63d88c2b750b2e70d00bce86657cdb95be004a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93321676ebc6f3e70ea757d3ff4d2c8422038a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93321676ebc6f3e70ea757d3ff4d2c8422038a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93321676ebc6f3e70ea757d3ff4d2c8422038a97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93321676ebc6f3e70ea757d3ff4d2c8422038a97/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8879d71c144425a6a52f6ae22fbcab265ef5eea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8879d71c144425a6a52f6ae22fbcab265ef5eea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8879d71c144425a6a52f6ae22fbcab265ef5eea9"}], "stats": {"total": 454, "additions": 260, "deletions": 194}, "files": [{"sha": "0800be6d7853ce75530e0df5b261bc309522a36f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93321676ebc6f3e70ea757d3ff4d2c8422038a97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93321676ebc6f3e70ea757d3ff4d2c8422038a97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93321676ebc6f3e70ea757d3ff4d2c8422038a97", "patch": "@@ -1,3 +1,59 @@\n+2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* combine.c (i2mod): Strengthen this variable from rtx to rtx_insn *.\n+\t(struct reg_stat_struct): Likewise for fields \"last_death\", \"last_set\".\n+\t(subst_insn): Likewise for this variable.\n+\t(added_links_insn): Likewise.\n+\t(struct insn_link): Likewise for field \"insn\".\n+\t(alloc_insn_link): Likewise for param \"insn\".\n+\t(struct undobuf): Likewise for field \"other_insn\".\n+\t(find_single_use): Likewise for param \"insn\" and local \"next\".\n+\t(combine_validate_cost): Likewise for params \"i0\", \"i1\", \"i2\", \"i3\".\n+\t(delete_noop_moves): Likewise for locals \"insn\", \"next\".\n+\t(create_log_links): Likewise for locals \"insn\", \"use_insn\".\n+\tStrengthen local \"next_use\" from rtx * to rtx_insn **.\n+\t(insn_a_feeds_b): Likewise for params \"a\", \"b\".\n+\t(combine_instructions): Likewise for param \"f\" and locals \"insn\",\n+\t\"next\", \"prev\", \"first\", \"last_combined_insn\", \"link\", \"link1\",\n+\t\"temp\".  Replace use of NULL_RTX with NULL when referring to\n+\tinsns.\n+\t(setup_incoming_promotions): Likewise for param \"first\"\n+\t(set_nonzero_bits_and_sign_copies): Likewise for local \"insn\".\n+\t(can_combine_p): Likewise for params \"insn\", \"i3\", \"pred\",\n+\t\"pred2\", \"succ\", \"succ2\" and for local \"p\".\n+\t(combinable_i3pat): Likewise for param \"i3\".\n+\t(cant_combine_insn_p): Likewise for param \"insn\".\n+\t(likely_spilled_retval_p): Likewise.\n+\t(adjust_for_new_dest): Likewise.\n+\t(update_cfg_for_uncondjump): Likewise, also for local \"insn\".\n+\t(try_combine): Likewise for return type and for params \"i3\", \"i2\",\n+\t\"i1\", \"i0\", \"last_combined_insn\", and for locals \"insn\",\n+\t\"cc_use_insn\", \"p\", \"first\", \"last\", \"i2_insn\", \"i1_insn\",\n+\t\"i0_insn\".  Eliminate local \"tem\" in favor of new locals\n+\t\"tem_note\" and \"tem_insn\", the latter being an rtx_insn *.  Add a\n+\tchecked cast for now to rtx_insn * on the return type of\n+\tgen_rtx_INSN.  Replace use of NULL_RTX with NULL when referring to\n+\tinsns.\n+\t(find_split_point): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(simplify_set): Likewise for local \"other_insn\".\n+\t(recog_for_combine): Likewise for param \"insn\".\n+\t(record_value_for_reg): Likewise.\n+\t(record_dead_and_set_regs_1): Likewise for local\n+\t\"record_dead_insn\".\n+\t(record_dead_and_set_regs): Likewise for param \"insn\".\n+\t(record_promoted_value): Likewise.\n+\t(check_promoted_subreg): Likewise.\n+\t(get_last_value_validate): Likewise.\n+\t(reg_dead_at_p): Likewise.\n+\t(move_deaths): Likewise for param \"to_insn\".\n+\t(distribute_notes): Likewise for params \"from_insn\", \"i3\", \"i2\"\n+\tand locals \"place\", \"place2\", \"cc0_setter\".  Eliminate local \"tem\n+\tin favor of new locals \"tem_note\" and \"tem_insn\", the latter being\n+\tan rtx_insn *.\n+\t(distribute_links): Strengthen locals \"place\", \"insn\" from rtx to\n+\trtx_insn *.\n+\n 2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* cfgrtl.c (can_delete_note_p): Require a const rtx_note * rather"}, {"sha": "64142c9743e98815257e43d8836dca2b8b897fbd", "filename": "gcc/combine.c", "status": "modified", "additions": 204, "deletions": 194, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93321676ebc6f3e70ea757d3ff4d2c8422038a97/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93321676ebc6f3e70ea757d3ff4d2c8422038a97/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=93321676ebc6f3e70ea757d3ff4d2c8422038a97", "patch": "@@ -134,7 +134,7 @@ static int total_attempts, total_merges, total_extras, total_successes;\n    and can cause distribute_notes to do wrong things.  This is the\n    second instruction if it has been so modified, null otherwise.  */\n \n-static rtx i2mod;\n+static rtx_insn *i2mod;\n \n /* When I2MOD is nonnull, this is a copy of the old right hand side.  */\n \n@@ -146,10 +146,10 @@ static rtx i2mod_new_rhs;\n \f\n typedef struct reg_stat_struct {\n   /* Record last point of death of (hard or pseudo) register n.  */\n-  rtx\t\t\t\tlast_death;\n+  rtx_insn\t\t\t*last_death;\n \n   /* Record last point of modification of (hard or pseudo) register n.  */\n-  rtx\t\t\t\tlast_set;\n+  rtx_insn\t\t\t*last_set;\n \n   /* The next group of fields allows the recording of the last value assigned\n      to (hard or pseudo) register n.  We use this information to see if an\n@@ -272,7 +272,7 @@ static int last_call_luid;\n    looked at, but this may be used to examine the successors of the insn\n    to judge whether a simplification is valid.  */\n \n-static rtx subst_insn;\n+static rtx_insn *subst_insn;\n \n /* This is the lowest LUID that `subst' is currently dealing with.\n    get_last_value will not return a value if the register was set at or\n@@ -292,7 +292,7 @@ static HARD_REG_SET newpat_used_regs;\n    insn is the earlier than I2 or I3, combine should rescan starting at\n    that location.  */\n \n-static rtx added_links_insn;\n+static rtx_insn *added_links_insn;\n \n /* Basic block in which we are performing combines.  */\n static basic_block this_basic_block;\n@@ -312,7 +312,7 @@ static int *uid_insn_cost;\n    instruction stream as struct insn_link pointers.  */\n \n struct insn_link {\n-  rtx insn;\n+  rtx_insn *insn;\n   struct insn_link *next;\n };\n \n@@ -331,7 +331,7 @@ static struct obstack insn_link_obstack;\n /* Allocate a link.  */\n \n static inline struct insn_link *\n-alloc_insn_link (rtx insn, struct insn_link *next)\n+alloc_insn_link (rtx_insn *insn, struct insn_link *next)\n {\n   struct insn_link *l\n     = (struct insn_link *) obstack_alloc (&insn_link_obstack,\n@@ -386,7 +386,7 @@ struct undobuf\n {\n   struct undo *undos;\n   struct undo *frees;\n-  rtx other_insn;\n+  rtx_insn *other_insn;\n };\n \n static struct undobuf undobuf;\n@@ -406,16 +406,18 @@ static rtx reg_num_sign_bit_copies_for_combine (const_rtx, enum machine_mode, co\n static void do_SUBST (rtx *, rtx);\n static void do_SUBST_INT (int *, int);\n static void init_reg_last (void);\n-static void setup_incoming_promotions (rtx);\n+static void setup_incoming_promotions (rtx_insn *);\n static void set_nonzero_bits_and_sign_copies (rtx, const_rtx, void *);\n-static int cant_combine_insn_p (rtx);\n-static int can_combine_p (rtx, rtx, rtx, rtx, rtx, rtx, rtx *, rtx *);\n-static int combinable_i3pat (rtx, rtx *, rtx, rtx, rtx, int, int, rtx *);\n+static int cant_combine_insn_p (rtx_insn *);\n+static int can_combine_p (rtx_insn *, rtx_insn *, rtx_insn *, rtx_insn *,\n+\t\t\t  rtx_insn *, rtx_insn *, rtx *, rtx *);\n+static int combinable_i3pat (rtx_insn *, rtx *, rtx, rtx, rtx, int, int, rtx *);\n static int contains_muldiv (rtx);\n-static rtx try_combine (rtx, rtx, rtx, rtx, int *, rtx);\n+static rtx_insn *try_combine (rtx_insn *, rtx_insn *, rtx_insn *, rtx_insn *,\n+\t\t\t      int *, rtx_insn *);\n static void undo_all (void);\n static void undo_commit (void);\n-static rtx *find_split_point (rtx *, rtx, bool);\n+static rtx *find_split_point (rtx *, rtx_insn *, bool);\n static rtx subst (rtx, rtx, rtx, int, int, int);\n static rtx combine_simplify_rtx (rtx, enum machine_mode, int, int);\n static rtx simplify_if_then_else (rtx);\n@@ -446,27 +448,27 @@ static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n static rtx simplify_shift_const_1 (enum rtx_code, enum machine_mode, rtx, int);\n static rtx simplify_shift_const (rtx, enum rtx_code, enum machine_mode, rtx,\n \t\t\t\t int);\n-static int recog_for_combine (rtx *, rtx, rtx *);\n+static int recog_for_combine (rtx *, rtx_insn *, rtx *);\n static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n static enum rtx_code simplify_compare_const (enum rtx_code, enum machine_mode,\n \t\t\t\t\t     rtx, rtx *);\n static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n static void update_table_tick (rtx);\n-static void record_value_for_reg (rtx, rtx, rtx);\n-static void check_promoted_subreg (rtx, rtx);\n+static void record_value_for_reg (rtx, rtx_insn *, rtx);\n+static void check_promoted_subreg (rtx_insn *, rtx);\n static void record_dead_and_set_regs_1 (rtx, const_rtx, void *);\n-static void record_dead_and_set_regs (rtx);\n-static int get_last_value_validate (rtx *, rtx, int, int);\n+static void record_dead_and_set_regs (rtx_insn *);\n+static int get_last_value_validate (rtx *, rtx_insn *, int, int);\n static rtx get_last_value (const_rtx);\n static int use_crosses_set_p (const_rtx, int);\n static void reg_dead_at_p_1 (rtx, const_rtx, void *);\n-static int reg_dead_at_p (rtx, rtx);\n-static void move_deaths (rtx, rtx, int, rtx, rtx *);\n+static int reg_dead_at_p (rtx, rtx_insn *);\n+static void move_deaths (rtx, rtx, int, rtx_insn *, rtx *);\n static int reg_bitfield_target_p (rtx, rtx);\n-static void distribute_notes (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+static void distribute_notes (rtx, rtx_insn *, rtx_insn *, rtx_insn *, rtx, rtx, rtx);\n static void distribute_links (struct insn_link *);\n static void mark_used_regs_combine (rtx);\n-static void record_promoted_value (rtx, rtx);\n+static void record_promoted_value (rtx_insn *, rtx);\n static int unmentioned_reg_p_1 (rtx *, void *);\n static bool unmentioned_reg_p (rtx, rtx);\n static int record_truncated_value (rtx *, void *);\n@@ -639,10 +641,10 @@ find_single_use_1 (rtx dest, rtx *loc)\n    and last insn referencing DEST.  */\n \n static rtx *\n-find_single_use (rtx dest, rtx insn, rtx *ploc)\n+find_single_use (rtx dest, rtx_insn *insn, rtx_insn **ploc)\n {\n   basic_block bb;\n-  rtx next;\n+  rtx_insn *next;\n   rtx *result;\n   struct insn_link *link;\n \n@@ -835,8 +837,8 @@ do_SUBST_LINK (struct insn_link **into, struct insn_link *newval)\n    expensive than the original sequence.  */\n \n static bool\n-combine_validate_cost (rtx i0, rtx i1, rtx i2, rtx i3, rtx newpat,\n-\t\t       rtx newi2pat, rtx newotherpat)\n+combine_validate_cost (rtx_insn *i0, rtx_insn *i1, rtx_insn *i2, rtx_insn *i3,\n+\t\t       rtx newpat, rtx newi2pat, rtx newotherpat)\n {\n   int i0_cost, i1_cost, i2_cost, i3_cost;\n   int new_i2_cost, new_i3_cost;\n@@ -960,7 +962,7 @@ combine_validate_cost (rtx i0, rtx i1, rtx i2, rtx i3, rtx newpat,\n static void\n delete_noop_moves (void)\n {\n-  rtx insn, next;\n+  rtx_insn *insn, *next;\n   basic_block bb;\n \n   FOR_EACH_BB_FN (bb, cfun)\n@@ -986,10 +988,11 @@ static void\n create_log_links (void)\n {\n   basic_block bb;\n-  rtx *next_use, insn;\n+  rtx_insn **next_use;\n+  rtx_insn *insn;\n   df_ref def, use;\n \n-  next_use = XCNEWVEC (rtx, max_reg_num ());\n+  next_use = XCNEWVEC (rtx_insn *, max_reg_num ());\n \n   /* Pass through each block from the end, recording the uses of each\n      register and establishing log links when def is encountered.\n@@ -1013,7 +1016,7 @@ create_log_links (void)\n \t  FOR_EACH_INSN_DEF (def, insn)\n             {\n               int regno = DF_REF_REGNO (def);\n-              rtx use_insn;\n+              rtx_insn *use_insn;\n \n               if (!next_use[regno])\n                 continue;\n@@ -1059,7 +1062,7 @@ create_log_links (void)\n \t\t\t  = alloc_insn_link (insn, LOG_LINKS (use_insn));\n \t\t    }\n                 }\n-              next_use[regno] = NULL_RTX;\n+              next_use[regno] = NULL;\n             }\n \n \t  FOR_EACH_INSN_USE (use, insn)\n@@ -1087,7 +1090,7 @@ create_log_links (void)\n    pair.  */\n \n static bool\n-insn_a_feeds_b (rtx a, rtx b)\n+insn_a_feeds_b (rtx_insn *a, rtx_insn *b)\n {\n   struct insn_link *links;\n   FOR_EACH_LOG_LINK (links, b)\n@@ -1106,14 +1109,14 @@ insn_a_feeds_b (rtx a, rtx b)\n    Return nonzero if the combiner has turned an indirect jump\n    instruction into a direct jump.  */\n static int\n-combine_instructions (rtx f, unsigned int nregs)\n+combine_instructions (rtx_insn *f, unsigned int nregs)\n {\n-  rtx insn, next;\n+  rtx_insn *insn, *next;\n #ifdef HAVE_cc0\n-  rtx prev;\n+  rtx_insn *prev;\n #endif\n   struct insn_link *links, *nextlinks;\n-  rtx first;\n+  rtx_insn *first;\n   basic_block last_bb;\n \n   int new_direct_jump_p = 0;\n@@ -1215,7 +1218,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   FOR_EACH_BB_FN (this_basic_block, cfun)\n     {\n-      rtx last_combined_insn = NULL_RTX;\n+      rtx_insn *last_combined_insn = NULL;\n       optimize_this_for_speed_p = optimize_bb_for_speed_p (this_basic_block);\n       last_call_luid = 0;\n       mem_last_set = -1;\n@@ -1256,8 +1259,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \t  /* Try this insn with each insn it links back to.  */\n \n \t  FOR_EACH_LOG_LINK (links, insn)\n-\t    if ((next = try_combine (insn, links->insn, NULL_RTX,\n-\t\t\t\t     NULL_RTX, &new_direct_jump_p,\n+\t    if ((next = try_combine (insn, links->insn, NULL,\n+\t\t\t\t     NULL, &new_direct_jump_p,\n \t\t\t\t     last_combined_insn)) != 0)\n \t      {\n \t\tstatistics_counter_event (cfun, \"two-insn combine\", 1);\n@@ -1269,7 +1272,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t  if (max_combine >= 3)\n \t    FOR_EACH_LOG_LINK (links, insn)\n \t      {\n-\t\trtx link = links->insn;\n+\t\trtx_insn *link = links->insn;\n \n \t\t/* If the linked insn has been replaced by a note, then there\n \t\t   is no point in pursuing this chain any further.  */\n@@ -1278,7 +1281,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n \t\tFOR_EACH_LOG_LINK (nextlinks, link)\n \t\t  if ((next = try_combine (insn, link, nextlinks->insn,\n-\t\t\t\t\t   NULL_RTX, &new_direct_jump_p,\n+\t\t\t\t\t   NULL, &new_direct_jump_p,\n \t\t\t\t\t   last_combined_insn)) != 0)\n \t\t    {\n \t\t      statistics_counter_event (cfun, \"three-insn combine\", 1);\n@@ -1299,14 +1302,14 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      && NONJUMP_INSN_P (prev)\n \t      && sets_cc0_p (PATTERN (prev)))\n \t    {\n-\t      if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n+\t      if ((next = try_combine (insn, prev, NULL, NULL,\n \t\t\t\t       &new_direct_jump_p,\n \t\t\t\t       last_combined_insn)) != 0)\n \t\tgoto retry;\n \n \t      FOR_EACH_LOG_LINK (nextlinks, prev)\n \t\t  if ((next = try_combine (insn, prev, nextlinks->insn,\n-\t\t\t\t\t   NULL_RTX, &new_direct_jump_p,\n+\t\t\t\t\t   NULL, &new_direct_jump_p,\n \t\t\t\t\t   last_combined_insn)) != 0)\n \t\t    goto retry;\n \t    }\n@@ -1319,14 +1322,14 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n \t    {\n-\t      if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n+\t      if ((next = try_combine (insn, prev, NULL, NULL,\n \t\t\t\t       &new_direct_jump_p,\n \t\t\t\t       last_combined_insn)) != 0)\n \t\tgoto retry;\n \n \t      FOR_EACH_LOG_LINK (nextlinks, prev)\n \t\t  if ((next = try_combine (insn, prev, nextlinks->insn,\n-\t\t\t\t\t   NULL_RTX, &new_direct_jump_p,\n+\t\t\t\t\t   NULL, &new_direct_jump_p,\n \t\t\t\t\t   last_combined_insn)) != 0)\n \t\t    goto retry;\n \t    }\n@@ -1342,7 +1345,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t  && NONJUMP_INSN_P (prev)\n \t\t  && sets_cc0_p (PATTERN (prev))\n \t\t  && (next = try_combine (insn, links->insn,\n-\t\t\t\t\t  prev, NULL_RTX, &new_direct_jump_p,\n+\t\t\t\t\t  prev, NULL, &new_direct_jump_p,\n \t\t\t\t\t  last_combined_insn)) != 0)\n \t\tgoto retry;\n #endif\n@@ -1354,7 +1357,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      for (nextlinks = links->next; nextlinks;\n \t\t   nextlinks = nextlinks->next)\n \t\tif ((next = try_combine (insn, links->insn,\n-\t\t\t\t\t nextlinks->insn, NULL_RTX,\n+\t\t\t\t\t nextlinks->insn, NULL,\n \t\t\t\t\t &new_direct_jump_p,\n \t\t\t\t\t last_combined_insn)) != 0)\n \n@@ -1368,7 +1371,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t    FOR_EACH_LOG_LINK (links, insn)\n \t      {\n \t\tstruct insn_link *next1;\n-\t\trtx link = links->insn;\n+\t\trtx_insn *link = links->insn;\n \n \t\t/* If the linked insn has been replaced by a note, then there\n \t\t   is no point in pursuing this chain any further.  */\n@@ -1377,7 +1380,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n \t\tFOR_EACH_LOG_LINK (next1, link)\n \t\t  {\n-\t\t    rtx link1 = next1->insn;\n+\t\t    rtx_insn *link1 = next1->insn;\n \t\t    if (NOTE_P (link1))\n \t\t      continue;\n \t\t    /* I0 -> I1 -> I2 -> I3.  */\n@@ -1405,7 +1408,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n \t\tfor (next1 = links->next; next1; next1 = next1->next)\n \t\t  {\n-\t\t    rtx link1 = next1->insn;\n+\t\t    rtx_insn *link1 = next1->insn;\n \t\t    if (NOTE_P (link1))\n \t\t      continue;\n \t\t    /* I0 -> I2; I1, I2 -> I3.  */\n@@ -1435,7 +1438,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t  FOR_EACH_LOG_LINK (links, insn)\n \t    {\n \t      rtx set, note;\n-\t      rtx temp = links->insn;\n+\t      rtx_insn *temp = links->insn;\n \t      if ((set = single_set (temp)) != 0\n \t\t  && (note = find_reg_equal_equiv_note (temp)) != 0\n \t\t  && (note = XEXP (note, 0), GET_CODE (note)) != EXPR_LIST\n@@ -1454,10 +1457,10 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t  i2mod = temp;\n \t\t  i2mod_old_rhs = copy_rtx (orig);\n \t\t  i2mod_new_rhs = copy_rtx (note);\n-\t\t  next = try_combine (insn, i2mod, NULL_RTX, NULL_RTX,\n+\t\t  next = try_combine (insn, i2mod, NULL, NULL,\n \t\t\t\t      &new_direct_jump_p,\n \t\t\t\t      last_combined_insn);\n-\t\t  i2mod = NULL_RTX;\n+\t\t  i2mod = NULL;\n \t\t  if (next)\n \t\t    {\n \t\t      statistics_counter_event (cfun, \"insn-with-note combine\", 1);\n@@ -1525,7 +1528,7 @@ init_reg_last (void)\n /* Set up any promoted values for incoming argument registers.  */\n \n static void\n-setup_incoming_promotions (rtx first)\n+setup_incoming_promotions (rtx_insn *first)\n {\n   tree arg;\n   bool strictly_local = false;\n@@ -1614,7 +1617,7 @@ setup_incoming_promotions (rtx first)\n static void\n set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n {\n-  rtx insn = (rtx) data;\n+  rtx_insn *insn = (rtx_insn *) data;\n   unsigned int num;\n \n   if (REG_P (x)\n@@ -1723,14 +1726,14 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n    will return 1.  */\n \n static int\n-can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED,\n-\t       rtx pred2 ATTRIBUTE_UNUSED, rtx succ, rtx succ2,\n+can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n+\t       rtx_insn *pred2 ATTRIBUTE_UNUSED, rtx_insn *succ, rtx_insn *succ2,\n \t       rtx *pdest, rtx *psrc)\n {\n   int i;\n   const_rtx set = 0;\n   rtx src, dest;\n-  rtx p;\n+  rtx_insn *p;\n #ifdef AUTO_INC_DEC\n   rtx link;\n #endif\n@@ -2088,7 +2091,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED,\n    Return 1 if the combination is valid, zero otherwise.  */\n \n static int\n-combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest, rtx i0dest,\n+combinable_i3pat (rtx_insn *i3, rtx *loc, rtx i2dest, rtx i1dest, rtx i0dest,\n \t\t  int i1_not_in_src, int i0_not_in_src, rtx *pi3dest_killed)\n {\n   rtx x = *loc;\n@@ -2213,7 +2216,7 @@ contains_muldiv (rtx x)\n    can't perform combinations.  */\n \n static int\n-cant_combine_insn_p (rtx insn)\n+cant_combine_insn_p (rtx_insn *insn)\n {\n   rtx set;\n   rtx src, dest;\n@@ -2290,7 +2293,7 @@ likely_spilled_retval_1 (rtx x, const_rtx set, void *data)\n    second copy insn for a complex value.  */\n \n static int\n-likely_spilled_retval_p (rtx insn)\n+likely_spilled_retval_p (rtx_insn *insn)\n {\n   rtx use = BB_END (this_basic_block);\n   rtx reg, p;\n@@ -2339,7 +2342,7 @@ likely_spilled_retval_p (rtx insn)\n    the results of the insn and a LOG_LINK pointing to the insn.  */\n \n static void\n-adjust_for_new_dest (rtx insn)\n+adjust_for_new_dest (rtx_insn *insn)\n {\n   /* For notes, be conservative and simply remove them.  */\n   remove_reg_equal_equiv_notes (insn);\n@@ -2401,7 +2404,7 @@ reg_subword_p (rtx x, rtx reg)\n    but not for a (set (pc) (label_ref FOO)).  */\n \n static void\n-update_cfg_for_uncondjump (rtx insn)\n+update_cfg_for_uncondjump (rtx_insn *insn)\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n   gcc_assert (BB_END (bb) == insn);\n@@ -2411,7 +2414,7 @@ update_cfg_for_uncondjump (rtx insn)\n   delete_insn (insn);\n   if (EDGE_COUNT (bb->succs) == 1)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n \n@@ -2452,9 +2455,9 @@ update_cfg_for_uncondjump (rtx insn)\n    been I3 passed to an earlier try_combine within the same basic\n    block.  */\n \n-static rtx\n-try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n-\t     rtx last_combined_insn)\n+static rtx_insn *\n+try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n+\t     int *new_direct_jump_p, rtx_insn *last_combined_insn)\n {\n   /* New patterns for I3 and I2, respectively.  */\n   rtx newpat, newi2pat = 0;\n@@ -2496,7 +2499,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n   int changed_i3_dest = 0;\n \n   int maxreg;\n-  rtx temp;\n+  rtx_insn *temp_insn;\n+  rtx temp_expr;\n   struct insn_link *link;\n   rtx other_pat = 0;\n   rtx new_other_notes;\n@@ -2516,7 +2520,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \n       for (i = 0; i < 4; i++)\n \t{\n-\t  rtx insn = i == 0 ? i0 : i == 1 ? i1 : i == 2 ? i2 : i3;\n+\t  rtx_insn *insn = i == 0 ? i0 : i == 1 ? i1 : i == 2 ? i2 : i3;\n \t  rtx set = single_set (insn);\n \t  rtx src;\n \t  if (!set)\n@@ -2568,11 +2572,11 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n   /* If multiple insns feed into one of I2 or I3, they can be in any\n      order.  To simplify the code below, reorder them in sequence.  */\n   if (i0 && DF_INSN_LUID (i0) > DF_INSN_LUID (i2))\n-    temp = i2, i2 = i0, i0 = temp;\n+    temp_insn = i2, i2 = i0, i0 = temp_insn;\n   if (i0 && DF_INSN_LUID (i0) > DF_INSN_LUID (i1))\n-    temp = i1, i1 = i0, i0 = temp;\n+    temp_insn = i1, i1 = i0, i0 = temp_insn;\n   if (i1 && DF_INSN_LUID (i1) > DF_INSN_LUID (i2))\n-    temp = i1, i1 = i2, i2 = temp;\n+    temp_insn = i1, i1 = i2, i2 = temp_insn;\n \n   added_links_insn = 0;\n \n@@ -2656,11 +2660,11 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n      sub-part of it to another constant, merge them by making a new\n      constant.  */\n   if (i1 == 0\n-      && (temp = single_set (i2)) != 0\n-      && CONST_SCALAR_INT_P (SET_SRC (temp))\n+      && (temp_expr = single_set (i2)) != 0\n+      && CONST_SCALAR_INT_P (SET_SRC (temp_expr))\n       && GET_CODE (PATTERN (i3)) == SET\n       && CONST_SCALAR_INT_P (SET_SRC (PATTERN (i3)))\n-      && reg_subword_p (SET_DEST (PATTERN (i3)), SET_DEST (temp)))\n+      && reg_subword_p (SET_DEST (PATTERN (i3)), SET_DEST (temp_expr)))\n     {\n       rtx dest = SET_DEST (PATTERN (i3));\n       int offset = -1;\n@@ -2692,7 +2696,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t  if (subreg_lowpart_p (dest))\n \t    ;\n \t  /* Handle the case where inner is twice the size of outer.  */\n-\t  else if (GET_MODE_PRECISION (GET_MODE (SET_DEST (temp)))\n+\t  else if (GET_MODE_PRECISION (GET_MODE (SET_DEST (temp_expr)))\n \t\t   == 2 * GET_MODE_PRECISION (GET_MODE (dest)))\n \t    offset += GET_MODE_PRECISION (GET_MODE (dest));\n \t  /* Otherwise give up for now.  */\n@@ -2703,25 +2707,25 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       if (offset >= 0)\n \t{\n \t  rtx inner = SET_SRC (PATTERN (i3));\n-\t  rtx outer = SET_SRC (temp);\n+\t  rtx outer = SET_SRC (temp_expr);\n \n \t  wide_int o\n-\t    = wi::insert (std::make_pair (outer, GET_MODE (SET_DEST (temp))),\n+\t    = wi::insert (std::make_pair (outer, GET_MODE (SET_DEST (temp_expr))),\n \t\t\t  std::make_pair (inner, GET_MODE (dest)),\n \t\t\t  offset, width);\n \n \t  combine_merges++;\n \t  subst_insn = i3;\n \t  subst_low_luid = DF_INSN_LUID (i2);\n \t  added_sets_2 = added_sets_1 = added_sets_0 = 0;\n-\t  i2dest = SET_DEST (temp);\n+\t  i2dest = SET_DEST (temp_expr);\n \t  i2dest_killed = dead_or_set_p (i2, i2dest);\n \n \t  /* Replace the source in I2 with the new constant and make the\n \t     resulting insn the new pattern for I3.  Then skip to where we\n \t     validate the pattern.  Everything was set up above.  */\n-\t  SUBST (SET_SRC (temp),\n-\t\t immed_wide_int_const (o, GET_MODE (SET_DEST (temp))));\n+\t  SUBST (SET_SRC (temp_expr),\n+\t\t immed_wide_int_const (o, GET_MODE (SET_DEST (temp_expr))));\n \n \t  newpat = PATTERN (i2);\n \n@@ -2768,9 +2772,10 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t     never appear in the insn stream so giving it the same INSN_UID\n \t     as I2 will not cause a problem.  */\n \n-\t  i1 = gen_rtx_INSN (VOIDmode, NULL_RTX, i2, BLOCK_FOR_INSN (i2),\n-\t\t\t     XVECEXP (PATTERN (i2), 0, 1), INSN_LOCATION (i2),\n-\t\t\t     -1, NULL_RTX);\n+\t  i1 = as_a <rtx_insn *> (\n+\t\t gen_rtx_INSN (VOIDmode, NULL_RTX, i2, BLOCK_FOR_INSN (i2),\n+\t\t\t       XVECEXP (PATTERN (i2), 0, 1), INSN_LOCATION (i2),\n+\t\t\t       -1, NULL_RTX));\n \t  INSN_UID (i1) = INSN_UID (i2);\n \n \t  SUBST (PATTERN (i2), XVECEXP (PATTERN (i2), 0, 0));\n@@ -2782,10 +2787,10 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n #endif\n \n   /* Verify that I2 and I1 are valid for combining.  */\n-  if (! can_combine_p (i2, i3, i0, i1, NULL_RTX, NULL_RTX, &i2dest, &i2src)\n-      || (i1 && ! can_combine_p (i1, i3, i0, NULL_RTX, i2, NULL_RTX,\n+  if (! can_combine_p (i2, i3, i0, i1, NULL, NULL, &i2dest, &i2src)\n+      || (i1 && ! can_combine_p (i1, i3, i0, NULL, i2, NULL,\n \t\t\t\t &i1dest, &i1src))\n-      || (i0 && ! can_combine_p (i0, i3, NULL_RTX, NULL_RTX, i1, i2,\n+      || (i0 && ! can_combine_p (i0, i3, NULL, NULL, i1, i2,\n \t\t\t\t &i0dest, &i0src)))\n     {\n       undo_all ();\n@@ -2958,7 +2963,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       && rtx_equal_p (XEXP (SET_SRC (PATTERN (i3)), 0), i2dest))\n     {\n       rtx newpat_dest;\n-      rtx *cc_use_loc = NULL, cc_use_insn = NULL_RTX;\n+      rtx *cc_use_loc = NULL;\n+      rtx_insn *cc_use_insn = NULL;\n       rtx op0 = i2src, op1 = XEXP (SET_SRC (PATTERN (i3)), 1);\n       enum machine_mode compare_mode, orig_compare_mode;\n       enum rtx_code compare_code = UNKNOWN, orig_compare_code = UNKNOWN;\n@@ -3111,7 +3117,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t   /* Before we can do this substitution, we must redo the test done\n \t      above (see detailed comments there) that ensures I1DEST isn't\n \t      mentioned in any SETs in NEWPAT that are field assignments.  */\n-\t  || !combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX, NULL_RTX,\n+\t  || !combinable_i3pat (NULL, &newpat, i1dest, NULL_RTX, NULL_RTX,\n \t\t\t\t0, 0, 0))\n \t{\n \t  undo_all ();\n@@ -3146,7 +3152,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t   && ((i0_feeds_i2_n && dead_or_set_p (i2, i0dest))\n \t       || (i0_feeds_i1_n && dead_or_set_p (i1, i0dest)))\n \t   && !reg_overlap_mentioned_p (i0dest, newpat))\n-\t  || !combinable_i3pat (NULL_RTX, &newpat, i0dest, NULL_RTX, NULL_RTX,\n+\t  || !combinable_i3pat (NULL, &newpat, i0dest, NULL_RTX, NULL_RTX,\n \t\t\t\t0, 0, 0))\n \t{\n \t  undo_all ();\n@@ -3661,20 +3667,20 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t\t\t\t   DF_INSN_LUID (i2))\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != ZERO_EXTRACT\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n-\t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n-\t\t (REG_P (temp)\n-\t\t  && reg_stat[REGNO (temp)].nonzero_bits != 0\n-\t\t  && GET_MODE_PRECISION (GET_MODE (temp)) < BITS_PER_WORD\n-\t\t  && GET_MODE_PRECISION (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t  && (reg_stat[REGNO (temp)].nonzero_bits\n+\t   && ! (temp_expr = SET_DEST (XVECEXP (newpat, 0, 1)),\n+\t\t (REG_P (temp_expr)\n+\t\t  && reg_stat[REGNO (temp_expr)].nonzero_bits != 0\n+\t\t  && GET_MODE_PRECISION (GET_MODE (temp_expr)) < BITS_PER_WORD\n+\t\t  && GET_MODE_PRECISION (GET_MODE (temp_expr)) < HOST_BITS_PER_INT\n+\t\t  && (reg_stat[REGNO (temp_expr)].nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n-\t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n-\t\t     (REG_P (temp)\n-\t\t      && reg_stat[REGNO (temp)].nonzero_bits != 0\n-\t\t      && GET_MODE_PRECISION (GET_MODE (temp)) < BITS_PER_WORD\n-\t\t      && GET_MODE_PRECISION (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t      && (reg_stat[REGNO (temp)].nonzero_bits\n+\t\t && (temp_expr = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n+\t\t     (REG_P (temp_expr)\n+\t\t      && reg_stat[REGNO (temp_expr)].nonzero_bits != 0\n+\t\t      && GET_MODE_PRECISION (GET_MODE (temp_expr)) < BITS_PER_WORD\n+\t\t      && GET_MODE_PRECISION (GET_MODE (temp_expr)) < HOST_BITS_PER_INT\n+\t\t      && (reg_stat[REGNO (temp_expr)].nonzero_bits\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t\t SET_SRC (XVECEXP (newpat, 0, 1)))\n@@ -3821,7 +3827,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n   /* If I2 is the CC0 setter and I3 is the CC0 user then check whether\n      they are adjacent to each other or not.  */\n   {\n-    rtx p = prev_nonnote_insn (i3);\n+    rtx_insn *p = prev_nonnote_insn (i3);\n     if (p && p != i2 && NONJUMP_INSN_P (p) && newi2pat\n \t&& sets_cc0_p (newi2pat))\n       {\n@@ -3869,7 +3875,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t    else\n \t      {\n \t\trtx tempreg = gen_raw_REG (old_mode, REGNO (reg));\n-\t\trtx first, last;\n+\t\trtx_insn *first, *last;\n \n \t\tif (reg == i2dest)\n \t\t  {\n@@ -3940,14 +3946,14 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t    remove_note (undobuf.other_insn, note);\n \t}\n \n-      distribute_notes (new_other_notes, undobuf.other_insn,\n-\t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX,\n+      distribute_notes  (new_other_notes, undobuf.other_insn,\n+\t\t\tundobuf.other_insn, NULL, NULL_RTX, NULL_RTX,\n \t\t\tNULL_RTX);\n     }\n \n   if (swap_i2i3)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       struct insn_link *link;\n       rtx ni2dest;\n \n@@ -4087,13 +4093,13 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t      && SET_DEST (XVECEXP (PATTERN (i2), 0, i)) != i2dest\n \t      && ! find_reg_note (i2, REG_UNUSED,\n \t\t\t\t  SET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n-\t    for (temp = NEXT_INSN (i2);\n-\t\t temp\n+\t    for (temp_insn = NEXT_INSN (i2);\n+\t\t temp_insn\n \t\t && (this_basic_block->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t\t\t  || BB_HEAD (this_basic_block) != temp);\n-\t\t temp = NEXT_INSN (temp))\n-\t      if (temp != i3 && INSN_P (temp))\n-\t\tFOR_EACH_LOG_LINK (link, temp)\n+\t\t\t  || BB_HEAD (this_basic_block) != temp_insn);\n+\t\t temp_insn = NEXT_INSN (temp_insn))\n+\t      if (temp_insn != i3 && INSN_P (temp_insn))\n+\t\tFOR_EACH_LOG_LINK (link, temp_insn)\n \t\t  if (link->insn == i2)\n \t\t    link->insn = i3;\n \n@@ -4167,31 +4173,31 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \n     /* Distribute all the LOG_LINKS and REG_NOTES from I1, I2, and I3.  */\n     if (i3notes)\n-      distribute_notes (i3notes, i3, i3, newi2pat ? i2 : NULL_RTX,\n+      distribute_notes (i3notes, i3, i3, newi2pat ? i2 : NULL,\n \t\t\telim_i2, elim_i1, elim_i0);\n     if (i2notes)\n-      distribute_notes (i2notes, i2, i3, newi2pat ? i2 : NULL_RTX,\n+      distribute_notes (i2notes, i2, i3, newi2pat ? i2 : NULL,\n \t\t\telim_i2, elim_i1, elim_i0);\n     if (i1notes)\n-      distribute_notes (i1notes, i1, i3, newi2pat ? i2 : NULL_RTX,\n+      distribute_notes (i1notes, i1, i3, newi2pat ? i2 : NULL,\n \t\t\telim_i2, elim_i1, elim_i0);\n     if (i0notes)\n-      distribute_notes (i0notes, i0, i3, newi2pat ? i2 : NULL_RTX,\n+      distribute_notes (i0notes, i0, i3, newi2pat ? i2 : NULL,\n \t\t\telim_i2, elim_i1, elim_i0);\n     if (midnotes)\n-      distribute_notes (midnotes, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+      distribute_notes (midnotes, NULL, i3, newi2pat ? i2 : NULL,\n \t\t\telim_i2, elim_i1, elim_i0);\n \n     /* Distribute any notes added to I2 or I3 by recog_for_combine.  We\n        know these are REG_UNUSED and want them to go to the desired insn,\n        so we always pass it as i3.  */\n \n     if (newi2pat && new_i2_notes)\n-      distribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX,\n+      distribute_notes (new_i2_notes, i2, i2, NULL, NULL_RTX, NULL_RTX,\n \t\t\tNULL_RTX);\n \n     if (new_i3_notes)\n-      distribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX,\n+      distribute_notes (new_i3_notes, i3, i3, NULL, NULL_RTX, NULL_RTX,\n \t\t\tNULL_RTX);\n \n     /* If I3DEST was used in I3SRC, it really died in I3.  We may need to\n@@ -4205,43 +4211,43 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       {\n \trtx new_note = alloc_reg_note (REG_DEAD, i3dest_killed, NULL_RTX);\n \tif (newi2pat && reg_set_p (i3dest_killed, newi2pat))\n-\t  distribute_notes (new_note, NULL_RTX, i2, NULL_RTX, elim_i2,\n+\t  distribute_notes (new_note, NULL, i2, NULL, elim_i2,\n \t\t\t    elim_i1, elim_i0);\n \telse\n-\t  distribute_notes (new_note, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t  distribute_notes (new_note, NULL, i3, newi2pat ? i2 : NULL,\n \t\t\t    elim_i2, elim_i1, elim_i0);\n       }\n \n     if (i2dest_in_i2src)\n       {\n \trtx new_note = alloc_reg_note (REG_DEAD, i2dest, NULL_RTX);\n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n-\t  distribute_notes (new_note,  NULL_RTX, i2, NULL_RTX, NULL_RTX,\n+\t  distribute_notes (new_note,  NULL, i2, NULL, NULL_RTX,\n \t\t\t    NULL_RTX, NULL_RTX);\n \telse\n-\t  distribute_notes (new_note, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t  distribute_notes (new_note, NULL, i3, newi2pat ? i2 : NULL,\n \t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n     if (i1dest_in_i1src)\n       {\n \trtx new_note = alloc_reg_note (REG_DEAD, i1dest, NULL_RTX);\n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n-\t  distribute_notes (new_note, NULL_RTX, i2, NULL_RTX, NULL_RTX,\n+\t  distribute_notes (new_note, NULL, i2, NULL, NULL_RTX,\n \t\t\t    NULL_RTX, NULL_RTX);\n \telse\n-\t  distribute_notes (new_note, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t  distribute_notes (new_note, NULL, i3, newi2pat ? i2 : NULL,\n \t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n     if (i0dest_in_i0src)\n       {\n \trtx new_note = alloc_reg_note (REG_DEAD, i0dest, NULL_RTX);\n \tif (newi2pat && reg_set_p (i0dest, newi2pat))\n-\t  distribute_notes (new_note, NULL_RTX, i2, NULL_RTX, NULL_RTX,\n+\t  distribute_notes (new_note, NULL, i2, NULL, NULL_RTX,\n \t\t\t    NULL_RTX, NULL_RTX);\n \telse\n-\t  distribute_notes (new_note, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t  distribute_notes (new_note, NULL, i3, newi2pat ? i2 : NULL,\n \t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n@@ -4253,7 +4259,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n     if (REG_P (i2dest))\n       {\n \tstruct insn_link *link;\n-\trtx i2_insn = 0, i2_val = 0, set;\n+\trtx_insn *i2_insn = 0;\n+\trtx i2_val = 0, set;\n \n \t/* The insn that used to set this register doesn't exist, and\n \t   this life of the register may not exist either.  See if one of\n@@ -4280,7 +4287,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n     if (i1 && REG_P (i1dest))\n       {\n \tstruct insn_link *link;\n-\trtx i1_insn = 0, i1_val = 0, set;\n+\trtx_insn *i1_insn = 0;\n+\trtx i1_val = 0, set;\n \n \tFOR_EACH_LOG_LINK (link, i3)\n \t  if ((set = single_set (link->insn)) != 0\n@@ -4296,7 +4304,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n     if (i0 && REG_P (i0dest))\n       {\n \tstruct insn_link *link;\n-\trtx i0_insn = 0, i0_val = 0, set;\n+\trtx_insn *i0_insn = 0;\n+\trtx i0_val = 0, set;\n \n \tFOR_EACH_LOG_LINK (link, i3)\n \t  if ((set = single_set (link->insn)) != 0\n@@ -4476,7 +4485,7 @@ undo_commit (void)\n    two insns.  */\n \n static rtx *\n-find_split_point (rtx *loc, rtx insn, bool set_src)\n+find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n {\n   rtx x = *loc;\n   enum rtx_code code = GET_CODE (x);\n@@ -4686,7 +4695,7 @@ find_split_point (rtx *loc, rtx insn, bool set_src)\n \t      && REG_P (XEXP (SET_SRC (x), 0))\n \t      && (pos = exact_log2 (UINTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n \t      && REG_P (SET_DEST (x))\n-\t      && (split = find_single_use (SET_DEST (x), insn, (rtx*) 0)) != 0\n+\t      && (split = find_single_use (SET_DEST (x), insn, NULL)) != 0\n \t      && (GET_CODE (*split) == EQ || GET_CODE (*split) == NE)\n \t      && XEXP (*split, 0) == SET_DEST (x)\n \t      && XEXP (*split, 1) == const0_rtx)\n@@ -6264,7 +6273,7 @@ simplify_set (rtx x)\n   rtx dest = SET_DEST (x);\n   enum machine_mode mode\n     = GET_MODE (src) != VOIDmode ? GET_MODE (src) : GET_MODE (dest);\n-  rtx other_insn;\n+  rtx_insn *other_insn;\n   rtx *cc_use;\n \n   /* (set (pc) (return)) gets written as (return).  */\n@@ -10580,7 +10589,7 @@ simplify_shift_const (rtx x, enum rtx_code code, enum machine_mode result_mode,\n    or -1.  */\n \n static int\n-recog_for_combine (rtx *pnewpat, rtx insn, rtx *pnotes)\n+recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n {\n   rtx pat = *pnewpat;\n   rtx pat_without_clobbers;\n@@ -12200,7 +12209,7 @@ update_table_tick (rtx x)\n    register.  */\n \n static void\n-record_value_for_reg (rtx reg, rtx insn, rtx value)\n+record_value_for_reg (rtx reg, rtx_insn *insn, rtx value)\n {\n   unsigned int regno = REGNO (reg);\n   unsigned int endregno = END_REGNO (reg);\n@@ -12318,15 +12327,15 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n static void\n record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)\n {\n-  rtx record_dead_insn = (rtx) data;\n+  rtx_insn *record_dead_insn = (rtx_insn *) data;\n \n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n   if (!record_dead_insn)\n     {\n       if (REG_P (dest))\n-\trecord_value_for_reg (dest, NULL_RTX, NULL_RTX);\n+\trecord_value_for_reg (dest, NULL, NULL_RTX);\n       return;\n     }\n \n@@ -12365,7 +12374,7 @@ record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)\n    most recent subroutine call).  */\n \n static void\n-record_dead_and_set_regs (rtx insn)\n+record_dead_and_set_regs (rtx_insn *insn)\n {\n   rtx link;\n   unsigned int i;\n@@ -12430,7 +12439,7 @@ record_dead_and_set_regs (rtx insn)\n    missed because of that.  */\n \n static void\n-record_promoted_value (rtx insn, rtx subreg)\n+record_promoted_value (rtx_insn *insn, rtx subreg)\n {\n   struct insn_link *links;\n   rtx set;\n@@ -12552,7 +12561,7 @@ record_truncated_values (rtx *x, void *data ATTRIBUTE_UNUSED)\n    note what it implies to the registers used in it.  */\n \n static void\n-check_promoted_subreg (rtx insn, rtx x)\n+check_promoted_subreg (rtx_insn *insn, rtx x)\n {\n   if (GET_CODE (x) == SUBREG\n       && SUBREG_PROMOTED_VAR_P (x)\n@@ -12589,7 +12598,7 @@ check_promoted_subreg (rtx insn, rtx x)\n    was produced from.  */\n \n static int\n-get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n+get_last_value_validate (rtx *loc, rtx_insn *insn, int tick, int replace)\n {\n   rtx x = *loc;\n   const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n@@ -12837,7 +12846,7 @@ reg_dead_at_p_1 (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n    must be assumed to be always live.  */\n \n static int\n-reg_dead_at_p (rtx reg, rtx insn)\n+reg_dead_at_p (rtx reg, rtx_insn *insn)\n {\n   basic_block block;\n   unsigned int i;\n@@ -13009,7 +13018,7 @@ remove_death (unsigned int regno, rtx insn)\n    notes will then be distributed as needed.  */\n \n static void\n-move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx to_insn,\n+move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx_insn *to_insn,\n \t     rtx *pnotes)\n {\n   const char *fmt;\n@@ -13210,15 +13219,16 @@ reg_bitfield_target_p (rtx x, rtx body)\n    on the type of note.  */\n \n static void\n-distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n-\t\t  rtx elim_i1, rtx elim_i0)\n+distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n+\t\t  rtx elim_i2, rtx elim_i1, rtx elim_i0)\n {\n   rtx note, next_note;\n-  rtx tem;\n+  rtx tem_note;\n+  rtx_insn *tem_insn;\n \n   for (note = notes; note; note = next_note)\n     {\n-      rtx place = 0, place2 = 0;\n+      rtx_insn *place = 0, *place2 = 0;\n \n       next_note = XEXP (note, 1);\n       switch (REG_NOTE_KIND (note))\n@@ -13389,16 +13399,16 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t     a REG_EQUAL note.  */\n \t  /* ??? Ignore the without-reg_equal-note problem for now.  */\n \t  if (reg_mentioned_p (XEXP (note, 0), PATTERN (i3))\n-\t      || ((tem = find_reg_note (i3, REG_EQUAL, NULL_RTX))\n-\t\t  && GET_CODE (XEXP (tem, 0)) == LABEL_REF\n-\t\t  && XEXP (XEXP (tem, 0), 0) == XEXP (note, 0)))\n+\t      || ((tem_note = find_reg_note (i3, REG_EQUAL, NULL_RTX))\n+\t\t  && GET_CODE (XEXP (tem_note, 0)) == LABEL_REF\n+\t\t  && XEXP (XEXP (tem_note, 0), 0) == XEXP (note, 0)))\n \t    place = i3;\n \n \t  if (i2\n \t      && (reg_mentioned_p (XEXP (note, 0), PATTERN (i2))\n-\t\t  || ((tem = find_reg_note (i2, REG_EQUAL, NULL_RTX))\n-\t\t      && GET_CODE (XEXP (tem, 0)) == LABEL_REF\n-\t\t      && XEXP (XEXP (tem, 0), 0) == XEXP (note, 0))))\n+\t\t  || ((tem_note = find_reg_note (i2, REG_EQUAL, NULL_RTX))\n+\t\t      && GET_CODE (XEXP (tem_note, 0)) == LABEL_REF\n+\t\t      && XEXP (XEXP (tem_note, 0), 0) == XEXP (note, 0))))\n \t    {\n \t      if (place)\n \t\tplace2 = i2;\n@@ -13470,7 +13480,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  if (from_insn\n \t      && from_insn == i2mod\n \t      && !reg_overlap_mentioned_p (XEXP (note, 0), i2mod_new_rhs))\n-\t    tem = from_insn;\n+\t    tem_insn = from_insn;\n \t  else\n \t    {\n \t      if (from_insn\n@@ -13489,34 +13499,34 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t       || rtx_equal_p (XEXP (note, 0), elim_i1)\n \t\t       || rtx_equal_p (XEXP (note, 0), elim_i0))\n \t\tbreak;\n-\t      tem = i3;\n+\t      tem_insn = i3;\n \t    }\n \n \t  if (place == 0)\n \t    {\n \t      basic_block bb = this_basic_block;\n \n-\t      for (tem = PREV_INSN (tem); place == 0; tem = PREV_INSN (tem))\n+\t      for (tem_insn = PREV_INSN (tem_insn); place == 0; tem_insn = PREV_INSN (tem_insn))\n \t\t{\n-\t\t  if (!NONDEBUG_INSN_P (tem))\n+\t\t  if (!NONDEBUG_INSN_P (tem_insn))\n \t\t    {\n-\t\t      if (tem == BB_HEAD (bb))\n+\t\t      if (tem_insn == BB_HEAD (bb))\n \t\t\tbreak;\n \t\t      continue;\n \t\t    }\n \n-\t\t  /* If the register is being set at TEM, see if that is all\n-\t\t     TEM is doing.  If so, delete TEM.  Otherwise, make this\n+\t\t  /* If the register is being set at TEM_INSN, see if that is all\n+\t\t     TEM_INSN is doing.  If so, delete TEM_INSN.  Otherwise, make this\n \t\t     into a REG_UNUSED note instead. Don't delete sets to\n \t\t     global register vars.  */\n \t\t  if ((REGNO (XEXP (note, 0)) >= FIRST_PSEUDO_REGISTER\n \t\t       || !global_regs[REGNO (XEXP (note, 0))])\n-\t\t      && reg_set_p (XEXP (note, 0), PATTERN (tem)))\n+\t\t      && reg_set_p (XEXP (note, 0), PATTERN (tem_insn)))\n \t\t    {\n-\t\t      rtx set = single_set (tem);\n+\t\t      rtx set = single_set (tem_insn);\n \t\t      rtx inner_dest = 0;\n #ifdef HAVE_cc0\n-\t\t      rtx cc0_setter = NULL_RTX;\n+\t\t      rtx_insn *cc0_setter = NULL;\n #endif\n \n \t\t      if (set != 0)\n@@ -13539,27 +13549,27 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t  && rtx_equal_p (XEXP (note, 0), inner_dest)\n #ifdef HAVE_cc0\n \t\t\t  && (! reg_mentioned_p (cc0_rtx, SET_SRC (set))\n-\t\t\t      || ((cc0_setter = prev_cc0_setter (tem)) != NULL\n+\t\t\t      || ((cc0_setter = prev_cc0_setter (tem_insn)) != NULL\n \t\t\t\t  && sets_cc0_p (PATTERN (cc0_setter)) > 0))\n #endif\n \t\t\t  )\n \t\t\t{\n-\t\t\t  /* Move the notes and links of TEM elsewhere.\n+\t\t\t  /* Move the notes and links of TEM_INSN elsewhere.\n \t\t\t     This might delete other dead insns recursively.\n \t\t\t     First set the pattern to something that won't use\n \t\t\t     any register.  */\n-\t\t\t  rtx old_notes = REG_NOTES (tem);\n+\t\t\t  rtx old_notes = REG_NOTES (tem_insn);\n \n-\t\t\t  PATTERN (tem) = pc_rtx;\n-\t\t\t  REG_NOTES (tem) = NULL;\n+\t\t\t  PATTERN (tem_insn) = pc_rtx;\n+\t\t\t  REG_NOTES (tem_insn) = NULL;\n \n-\t\t\t  distribute_notes (old_notes, tem, tem, NULL_RTX,\n+\t\t\t  distribute_notes (old_notes, tem_insn, tem_insn, NULL,\n \t\t\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n-\t\t\t  distribute_links (LOG_LINKS (tem));\n+\t\t\t  distribute_links (LOG_LINKS (tem_insn));\n \n-\t\t\t  SET_INSN_DELETED (tem);\n-\t\t\t  if (tem == i2)\n-\t\t\t    i2 = NULL_RTX;\n+\t\t\t  SET_INSN_DELETED (tem_insn);\n+\t\t\t  if (tem_insn == i2)\n+\t\t\t    i2 = NULL;\n \n #ifdef HAVE_cc0\n \t\t\t  /* Delete the setter too.  */\n@@ -13570,13 +13580,13 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t      REG_NOTES (cc0_setter) = NULL;\n \n \t\t\t      distribute_notes (old_notes, cc0_setter,\n-\t\t\t\t\t\tcc0_setter, NULL_RTX,\n+\t\t\t\t\t\tcc0_setter, NULL,\n \t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n \t\t\t      distribute_links (LOG_LINKS (cc0_setter));\n \n \t\t\t      SET_INSN_DELETED (cc0_setter);\n \t\t\t      if (cc0_setter == i2)\n-\t\t\t\ti2 = NULL_RTX;\n+\t\t\t\ti2 = NULL;\n \t\t\t    }\n #endif\n \t\t\t}\n@@ -13590,17 +13600,17 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t      match the algorithm used in lifetime analysis\n \t\t\t      and can cause the consistency check in the\n \t\t\t      scheduler to fail.  */\n-\t\t\t  if (! find_regno_note (tem, REG_UNUSED,\n+\t\t\t  if (! find_regno_note (tem_insn, REG_UNUSED,\n \t\t\t\t\t\t REGNO (XEXP (note, 0))))\n-\t\t\t    place = tem;\n+\t\t\t    place = tem_insn;\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n-\t\t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (tem))\n-\t\t\t   || (CALL_P (tem)\n-\t\t\t       && find_reg_fusage (tem, USE, XEXP (note, 0))))\n+\t\t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (tem_insn))\n+\t\t\t   || (CALL_P (tem_insn)\n+\t\t\t       && find_reg_fusage (tem_insn, USE, XEXP (note, 0))))\n \t\t    {\n-\t\t      place = tem;\n+\t\t      place = tem_insn;\n \n \t\t      /* If we are doing a 3->2 combination, and we have a\n \t\t\t register which formerly died in i3 and was not used\n@@ -13620,7 +13630,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t      break;\n \t\t    }\n \n-\t\t  if (tem == BB_HEAD (bb))\n+\t\t  if (tem_insn == BB_HEAD (bb))\n \t\t    break;\n \t\t}\n \n@@ -13694,26 +13704,26 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t\t\t\t\t     NULL_RTX);\n \n \t\t\t      distribute_notes (new_note, place, place,\n-\t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t\tNULL, NULL_RTX, NULL_RTX,\n \t\t\t\t\t\tNULL_RTX);\n \t\t\t    }\n \t\t\t  else if (! refers_to_regno_p (i, i + 1,\n \t\t\t\t\t\t\tPATTERN (place), 0)\n \t\t\t\t   && ! find_regno_fusage (place, USE, i))\n-\t\t\t    for (tem = PREV_INSN (place); ;\n-\t\t\t\t tem = PREV_INSN (tem))\n+\t\t\t    for (tem_insn = PREV_INSN (place); ;\n+\t\t\t\t tem_insn = PREV_INSN (tem_insn))\n \t\t\t      {\n-\t\t\t\tif (!NONDEBUG_INSN_P (tem))\n+\t\t\t\tif (!NONDEBUG_INSN_P (tem_insn))\n \t\t\t\t  {\n-\t\t\t\t    if (tem == BB_HEAD (bb))\n+\t\t\t\t    if (tem_insn == BB_HEAD (bb))\n \t\t\t \t      break;\n \t\t\t\t    continue;\n \t\t\t\t  }\n-\t\t\t\tif (dead_or_set_p (tem, piece)\n+\t\t\t\tif (dead_or_set_p (tem_insn, piece)\n \t\t\t\t    || reg_bitfield_target_p (piece,\n-\t\t\t\t\t\t\t      PATTERN (tem)))\n+\t\t\t\t\t\t\t      PATTERN (tem_insn)))\n \t\t\t\t  {\n-\t\t\t\t    add_reg_note (tem, REG_UNUSED, piece);\n+\t\t\t\t    add_reg_note (tem_insn, REG_UNUSED, piece);\n \t\t\t\t    break;\n \t\t\t\t  }\n \t\t\t      }\n@@ -13753,8 +13763,8 @@ distribute_links (struct insn_link *links)\n \n   for (link = links; link; link = next_link)\n     {\n-      rtx place = 0;\n-      rtx insn;\n+      rtx_insn *place = 0;\n+      rtx_insn *insn;\n       rtx set, reg;\n \n       next_link = link->next;"}]}