{"sha": "76a318e97704888c8bd117ba04e7c6bf017fd7cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZhMzE4ZTk3NzA0ODg4YzhiZDExN2JhMDRlN2M2YmYwMTdmZDdjZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-01-23T18:10:46Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-01-23T18:10:46Z"}, "message": "arm.c (thumb_base_register_rtx_p): New function.\n\n* arm.c (thumb_base_register_rtx_p): New function.\n(thumb_index_register_rtx_p): New function.\n(thumb_legitimate_address_p): New function.\n(thumb_legitimate_offset_p): New function.\n* arm.h (REG_STRICT_P): Define according to setting of REG_OK_STRICT.\n(ARM_GO_IF_LEGITIMATE_ADDRESS): Use REG_STRICT_P to avoid dumplicate\ndefinitions.\n(THUMB_GO_IF_LEGITIMATE_ADDRESS): Use thumb_legitimate_address_p.\n(THUMB_LEGITIMATE_OFFSET): Delte.\n(THUMB_LEGITIMIZE_RELOAD_ADDRESS): Use thumb_legitimate_offset.\n* arm-protos.h (thumb_legitimate_address_p): Add prototype.\n(thumb_legitimate_offset_p): Likewise.\n\nFrom-SVN: r61662", "tree": {"sha": "e8d19178bb816ae2229bc33e1640cc22d9ef98be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8d19178bb816ae2229bc33e1640cc22d9ef98be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76a318e97704888c8bd117ba04e7c6bf017fd7cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a318e97704888c8bd117ba04e7c6bf017fd7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a318e97704888c8bd117ba04e7c6bf017fd7cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a318e97704888c8bd117ba04e7c6bf017fd7cd/comments", "author": null, "committer": null, "parents": [{"sha": "0f0ff6ec541f245d32475c7dabe65d2a303a7fdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0ff6ec541f245d32475c7dabe65d2a303a7fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f0ff6ec541f245d32475c7dabe65d2a303a7fdd"}], "stats": {"total": 336, "additions": 210, "deletions": 126}, "files": [{"sha": "4eac1f684052bee983596bbd8dbb69be4d99bd21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76a318e97704888c8bd117ba04e7c6bf017fd7cd", "patch": "@@ -1,3 +1,18 @@\n+2003-01-23  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (thumb_base_register_rtx_p): New function.\n+\t(thumb_index_register_rtx_p): New function.\n+\t(thumb_legitimate_address_p): New function.\n+\t(thumb_legitimate_offset_p): New function.\n+\t* arm.h (REG_STRICT_P): Define according to setting of REG_OK_STRICT.\n+\t(ARM_GO_IF_LEGITIMATE_ADDRESS): Use REG_STRICT_P to avoid dumplicate\n+\tdefinitions.\n+\t(THUMB_GO_IF_LEGITIMATE_ADDRESS): Use thumb_legitimate_address_p.\n+\t(THUMB_LEGITIMATE_OFFSET): Delte.\n+\t(THUMB_LEGITIMIZE_RELOAD_ADDRESS): Use thumb_legitimate_offset.\n+\t* arm-protos.h (thumb_legitimate_address_p): Add prototype.\n+\t(thumb_legitimate_offset_p): Likewise.\n+\n 2003-01-23  Andreas Schwab  <schwab@suse.de>\n \n \t* unwind.h (_Unwind_GetTextRelBase): Mark parameter as unused."}, {"sha": "af0320e0eac0b6e36bdcd3329ad12b8017cecf11", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=76a318e97704888c8bd117ba04e7c6bf017fd7cd", "patch": "@@ -53,6 +53,10 @@ extern RTX_CODE arm_canonicalize_comparison PARAMS ((RTX_CODE, rtx *));\n extern int    legitimate_pic_operand_p\tPARAMS ((rtx));\n extern rtx    legitimize_pic_address\tPARAMS ((rtx, enum machine_mode, rtx));\n extern int    arm_legitimate_address_p  PARAMS ((enum machine_mode, rtx, int));\n+extern int    thumb_legitimate_address_p PARAMS ((enum machine_mode, rtx,\n+\t\t\t\t\t\t  int));\n+extern int    thumb_legitimate_offset_p\tPARAMS ((enum machine_mode,\n+\t\t\t\t\t\t HOST_WIDE_INT));\n extern int    arm_rtx_costs\t\tPARAMS ((rtx, RTX_CODE, RTX_CODE));\n extern int    const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n extern int    neg_const_double_rtx_ok_for_fpu\tPARAMS ((rtx));"}, {"sha": "4bffcb5258321330013fc7956465687299147bce", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 175, "deletions": 1, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=76a318e97704888c8bd117ba04e7c6bf017fd7cd", "patch": "@@ -71,6 +71,10 @@ static unsigned  bit_count \t\t\tPARAMS ((Ulong));\n static int\t arm_address_register_rtx_p\tPARAMS ((rtx, int));\n static int\t arm_legitimate_index_p\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t rtx, int));\n+static int\t thumb_base_register_rtx_p\tPARAMS ((rtx, \n+\t\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t\t int));\n+inline static int thumb_index_register_rtx_p\tPARAMS ((rtx, int));\n static int       const_ok_for_op \t\tPARAMS ((Hint, enum rtx_code));\n static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n@@ -2717,7 +2721,177 @@ arm_legitimate_index_p (mode, index, strict_p)\n   return (code == CONST_INT\n \t  && INTVAL (index) < range\n \t  && INTVAL (index) > -range);\n-}  \n+}\n+\n+/* Return nonzero if X is valid as an ARM state addressing register.  */\n+static int\n+thumb_base_register_rtx_p (x, mode, strict_p)\n+     rtx x;\n+     enum machine_mode mode;\n+     int strict_p;\n+{\n+  int regno;\n+\n+  if (GET_CODE (x) != REG)\n+    return 0;\n+\n+  regno = REGNO (x);\n+\n+  if (strict_p)\n+    return THUMB_REGNO_MODE_OK_FOR_BASE_P (regno, mode);\n+\n+  return (regno <= LAST_LO_REGNUM\n+\t  || regno >= FIRST_PSEUDO_REGISTER\n+\t  || regno == FRAME_POINTER_REGNUM\n+\t  || (GET_MODE_SIZE (mode) >= 4\n+\t      && (regno == STACK_POINTER_REGNUM\n+\t\t  || x == hard_frame_pointer_rtx\n+\t\t  || x == arg_pointer_rtx)));\n+}\n+\n+/* Return nonzero if x is a legitimate index register.  This is the case\n+   for any base register that can access a QImode object.  */\n+inline static int\n+thumb_index_register_rtx_p (x, strict_p)\n+     rtx x;\n+     int strict_p;\n+{\n+  return thumb_base_register_rtx_p (x, QImode, strict_p);\n+}\n+\n+/* Return nonzero if x is a legitimate Thumb-state address.\n+ \n+   The AP may be eliminated to either the SP or the FP, so we use the\n+   least common denominator, e.g. SImode, and offsets from 0 to 64.\n+\n+   ??? Verify whether the above is the right approach.\n+\n+   ??? Also, the FP may be eliminated to the SP, so perhaps that\n+   needs special handling also.\n+\n+   ??? Look at how the mips16 port solves this problem.  It probably uses\n+   better ways to solve some of these problems.\n+\n+   Although it is not incorrect, we don't accept QImode and HImode\n+   addresses based on the frame pointer or arg pointer until the\n+   reload pass starts.  This is so that eliminating such addresses\n+   into stack based ones won't produce impossible code.  */\n+int\n+thumb_legitimate_address_p (mode, x, strict_p)\n+     enum machine_mode mode;\n+     rtx x;\n+     int strict_p;\n+{\n+  /* ??? Not clear if this is right.  Experiment.  */\n+  if (GET_MODE_SIZE (mode) < 4\n+      && !(reload_in_progress || reload_completed)\n+      && (reg_mentioned_p (frame_pointer_rtx, x)\n+\t  || reg_mentioned_p (arg_pointer_rtx, x)\n+\t  || reg_mentioned_p (virtual_incoming_args_rtx, x)\n+\t  || reg_mentioned_p (virtual_outgoing_args_rtx, x)\n+\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, x)\n+\t  || reg_mentioned_p (virtual_stack_vars_rtx, x)))\n+    return 0;\n+\n+  /* Accept any base register.  SP only in SImode or larger.  */\n+  else if (thumb_base_register_rtx_p (x, mode, strict_p))\n+    return 1;\n+\n+  /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\n+  else if (GET_MODE_SIZE (mode) >= 4 && CONSTANT_P (x)\n+\t   && GET_CODE (x) == SYMBOL_REF\n+           && CONSTANT_POOL_ADDRESS_P (x) && ! flag_pic)\n+    return 1;\n+\n+  /* This is PC relative data after MACHINE_DEPENDENT_REORG runs.  */\n+  else if (GET_MODE_SIZE (mode) >= 4 && reload_completed\n+\t   && (GET_CODE (x) == LABEL_REF\n+\t       || (GET_CODE (x) == CONST\n+\t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n+    return 1;\n+\n+  /* Post-inc indexing only supported for SImode and larger.  */\n+  else if (GET_CODE (x) == POST_INC && GET_MODE_SIZE (mode) >= 4\n+\t   && thumb_index_register_rtx_p (XEXP (x, 0), strict_p))\n+    return 1;\n+\n+  else if (GET_CODE (x) == PLUS)\n+    {\n+      /* REG+REG address can be any two index registers.  */\n+      /* We disallow FRAME+REG addressing since we know that FRAME\n+\t will be replaced with STACK, and SP relative addressing only\n+\t permits SP+OFFSET.  */\n+      if (GET_MODE_SIZE (mode) <= 4\n+\t  && XEXP (x, 0) != frame_pointer_rtx\n+\t  && XEXP (x, 1) != frame_pointer_rtx\n+\t  && XEXP (x, 0) != virtual_stack_vars_rtx\n+\t  && XEXP (x, 1) != virtual_stack_vars_rtx\n+\t  && thumb_index_register_rtx_p (XEXP (x, 0), strict_p)\n+\t  && thumb_index_register_rtx_p (XEXP (x, 1), strict_p))\n+\treturn 1;\n+\n+      /* REG+const has 5-7 bit offset for non-SP registers.  */\n+      else if ((thumb_index_register_rtx_p (XEXP (x, 0), strict_p)\n+\t\t|| XEXP (x, 0) == arg_pointer_rtx)\n+\t       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && thumb_legitimate_offset_p (mode, INTVAL (XEXP (x, 1))))\n+\treturn 1;\n+\n+      /* REG+const has 10 bit offset for SP, but only SImode and\n+\t larger is supported.  */\n+      /* ??? Should probably check for DI/DFmode overflow here\n+\t just like GO_IF_LEGITIMATE_OFFSET does.  */\n+      else if (GET_CODE (XEXP (x, 0)) == REG\n+\t       && REGNO (XEXP (x, 0)) == STACK_POINTER_REGNUM\n+\t       && GET_MODE_SIZE (mode) >= 4\n+\t       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && INTVAL (XEXP (x, 1)) >= 0\n+\t       && INTVAL (XEXP (x, 1)) + GET_MODE_SIZE (mode) <= 1024\n+\t       && (INTVAL (XEXP (x, 1)) & 3) == 0)\n+\treturn 1;\n+\n+      else if (GET_CODE (XEXP (x, 0)) == REG\n+\t       && REGNO (XEXP (x, 0)) == FRAME_POINTER_REGNUM\n+\t       && GET_MODE_SIZE (mode) >= 4\n+\t       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && (INTVAL (XEXP (x, 1)) & 3) == 0)\n+\treturn 1;\n+    }\n+\n+  else if (GET_MODE_CLASS (mode) != MODE_FLOAT\n+\t   && GET_CODE (x) == SYMBOL_REF\n+\t   && CONSTANT_POOL_ADDRESS_P (x)\n+\t   && !(flag_pic\n+\t\t&& symbol_mentioned_p (get_pool_constant (x))))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if VAL can be used as an offset in a Thumb-state address\n+   instruction of mode MODE.  */\n+int\n+thumb_legitimate_offset_p (mode, val)\n+     enum machine_mode mode;\n+     HOST_WIDE_INT val;\n+{\n+  switch (GET_MODE_SIZE (mode))\n+    {\n+    case 1:\n+      return val >= 0 && val < 32;\n+\n+    case 2:\n+      return val >= 0 && val < 64 && (val & 1) == 0;\n+\n+    default:\n+      return (val >= 0\n+\t      && (val + GET_MODE_SIZE (mode)) <= 128\n+\t      && (val & 3) == 0);\n+    }\n+}\n+\n \f\n \n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\"}, {"sha": "2b205fc2092db3b572cf42c6e2c7472c6c5196e2", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 16, "deletions": 125, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a318e97704888c8bd117ba04e7c6bf017fd7cd/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=76a318e97704888c8bd117ba04e7c6bf017fd7cd", "patch": "@@ -1268,7 +1268,7 @@ enum reg_class\n       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n       && XEXP (X, 0) == stack_pointer_rtx\t\t\t\t\\\n       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-      && ! THUMB_LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n+      && ! thumb_legitimate_offset_p (MODE, INTVAL (XEXP (X, 1))))\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx orig_X = X;\t\t\t\t\t\t\t\\\n       X = copy_rtx (X);\t\t\t\t\t\t\t\\\n@@ -1897,6 +1897,8 @@ typedef struct\n \t   || (X) == hard_frame_pointer_rtx\t\\\n \t   || (X) == arg_pointer_rtx)))\n \n+#define REG_STRICT_P 0\n+\n #else /* REG_OK_STRICT */\n \n #define ARM_REG_OK_FOR_BASE_P(X) \t\t\\\n@@ -1905,6 +1907,8 @@ typedef struct\n #define THUMB_REG_MODE_OK_FOR_BASE_P(X, MODE)\t\\\n   THUMB_REGNO_MODE_OK_FOR_BASE_P (REGNO (X), MODE)\n \n+#define REG_STRICT_P 1\n+\n #endif /* REG_OK_STRICT */\n \n /* Now define some helpers in terms of the above.  */\n@@ -1932,145 +1936,32 @@ typedef struct\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS. */\n+   that wants to use this address.  */\n      \n-/* --------------------------------arm version----------------------------- */\n #define ARM_BASE_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && ARM_REG_OK_FOR_BASE_P (X))\n \n #define ARM_INDEX_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && ARM_REG_OK_FOR_INDEX_P (X))\n \n-#ifdef REG_OK_STRICT\n-#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (arm_legitimate_address_p (MODE, X, 1))\t\t\\\n-      goto WIN;\t\t\t\t\t\t\\\n-  }\n-#else\n-#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (arm_legitimate_address_p (MODE, X, 0))\t\t\\\n-      goto WIN;\t\t\t\t\t\t\\\n+#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    if (arm_legitimate_address_p (MODE, X, REG_STRICT_P))\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n   }\n-#endif\n-\n-/* ---------------------thumb version----------------------------------*/     \n-#define THUMB_LEGITIMATE_OFFSET(MODE, VAL)\t\t\t\t\\\n-  (GET_MODE_SIZE (MODE) == 1 ? ((unsigned HOST_WIDE_INT) (VAL) < 32)\t\\\n-   : GET_MODE_SIZE (MODE) == 2 ? ((unsigned HOST_WIDE_INT) (VAL) < 64\t\\\n-\t \t\t\t  && ((VAL) & 1) == 0)\t\t\t\\\n-   : ((VAL) >= 0 && ((VAL) + GET_MODE_SIZE (MODE)) <= 128\t\t\\\n-      && ((VAL) & 3) == 0))\n-\n-/* The AP may be eliminated to either the SP or the FP, so we use the\n-   least common denominator, e.g. SImode, and offsets from 0 to 64.  */\n-\n-/* ??? Verify whether the above is the right approach.  */\n \n-/* ??? Also, the FP may be eliminated to the SP, so perhaps that\n-   needs special handling also.  */\n-\n-/* ??? Look at how the mips16 port solves this problem.  It probably uses\n-   better ways to solve some of these problems.  */\n-\n-/* Although it is not incorrect, we don't accept QImode and HImode\n-   addresses based on the frame pointer or arg pointer until the\n-   reload pass starts.  This is so that eliminating such addresses\n-   into stack based ones won't produce impossible code.  */\n-#define THUMB_GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-/* ??? Not clear if this is right.  Experiment.  */\t\t\t\\\n-  if (GET_MODE_SIZE (MODE) < 4\t\t\t\t\t\t\\\n-      && ! (reload_in_progress || reload_completed)\t\t\t\\\n-      && (   reg_mentioned_p (frame_pointer_rtx, X)\t\t\t\\\n-\t  || reg_mentioned_p (arg_pointer_rtx, X)\t\t\t\\\n-\t  || reg_mentioned_p (virtual_incoming_args_rtx, X)\t\t\\\n-\t  || reg_mentioned_p (virtual_outgoing_args_rtx, X)\t\t\\\n-\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, X)\t\t\\\n-\t  || reg_mentioned_p (virtual_stack_vars_rtx, X)))\t\t\\\n-    ;\t\t\t\t\t\t\t\t\t\\\n-  /* Accept any base register.  SP only in SImode or larger.  */\t\\\n-  else if (GET_CODE (X) == REG\t\t\t\t\t\t\\\n-\t   && THUMB_REG_MODE_OK_FOR_BASE_P (X, MODE))\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\t\\\n-  else if (GET_MODE_SIZE (MODE) >= 4 && CONSTANT_P (X)\t\t\t\\\n-\t   && GET_CODE (X) == SYMBOL_REF \t\t\t\t\\\n-           && CONSTANT_POOL_ADDRESS_P (X) && ! flag_pic)\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  /* This is PC relative data after MACHINE_DEPENDENT_REORG runs.  */\t\\\n-  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n-\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t\\\n-\t       || (GET_CODE (X) == CONST\t\t\t\t\\\n-\t\t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)))\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  /* Post-inc indexing only supported for SImode and larger.  */\t\\\n-  else if (GET_CODE (X) == POST_INC && GET_MODE_SIZE (MODE) >= 4\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* REG+REG address can be any two index registers.  */\t\t\\\n-      /* We disallow FRAME+REG addressing since we know that FRAME\t\\\n-\t will be replaced with STACK, and SP relative addressing only\t\\\n-\t permits SP+OFFSET.  */\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t  && XEXP (X, 0) != frame_pointer_rtx\t\t\t\t\\\n-\t  && XEXP (X, 1) != frame_pointer_rtx\t\t\t\t\\\n-\t  && XEXP (X, 0) != virtual_stack_vars_rtx\t\t\t\\\n-\t  && XEXP (X, 1) != virtual_stack_vars_rtx\t\t\t\\\n-\t  && THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\\\n-\t  && THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      /* REG+const has 5-7 bit offset for non-SP registers.  */\t\t\\\n-      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t       && (THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\\\n-\t\t   || XEXP (X, 0) == arg_pointer_rtx)\t\t\t\\\n-\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t       && THUMB_LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      /* REG+const has 10 bit offset for SP, but only SImode and\t\\\n-\t larger is supported.  */\t\t\t\t\t\\\n-      /* ??? Should probably check for DI/DFmode overflow here\t\t\\\n-\t just like GO_IF_LEGITIMATE_OFFSET does.  */\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t       && REGNO (XEXP (X, 0)) == STACK_POINTER_REGNUM\t\t\\\n-\t       && GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n-\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t       && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (X, 1))\t\\\n-\t\t   + GET_MODE_SIZE (MODE)) <= 1024\t\t\t\\\n-\t       && (INTVAL (XEXP (X, 1)) & 3) == 0)\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t       && REGNO (XEXP (X, 0)) == FRAME_POINTER_REGNUM\t\t\\\n-\t       && GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n-\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t       && (INTVAL (XEXP (X, 1)) & 3) == 0)\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n-\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n-\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n-\t   && ! (flag_pic\t\t\t\t\t\t\\\n-\t\t && symbol_mentioned_p (get_pool_constant (X))))\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-}\n+#define THUMB_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    if (thumb_legitimate_address_p (MODE, X, REG_STRICT_P))\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+  }\n \n-/* ------------------------------------------------------------------- */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\t\t\\\n   if (TARGET_ARM)\t\t\t\t\t\t\t\\\n     ARM_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)  \t\t\t\\\n   else /* if (TARGET_THUMB) */\t\t\t\t\t\t\\\n     THUMB_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)\t\n-/* ------------------------------------------------------------------- */\n+\n \f\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address."}]}