{"sha": "bbcb0c056be0883aa970eb5552bb713d516d9c1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJjYjBjMDU2YmUwODgzYWE5NzBlYjU1NTJiYjcxM2Q1MTZkOWMxZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-02-01T10:03:15Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-02-01T10:03:15Z"}, "message": "re PR rtl-optimization/15242 (pessimization of \"goto *\")\n\n\tPR optimization/15242\n\t* params.def (PARAM_MAX_GOTO_DUPLICATION_INSNS): New param.\n\t* basic-block.h (duplicate_computed_gotos): Add prototype.\n\t* bb-reorder.c (duplicate_computed_gotos): New function to\n\tduplicate sufficiently small blocks ending in a computed jump.\n\t* passes.c (rest_of_compilation): Call duplicate_computed_gotos\n\tif not optimizing for size.\n\t* cfgcleanup.c (try_crossjump_bb): If not optimizing for size,\n\tnever do tail merging for blocks ending in a computed jump.\n\t* doc/invoke.texi: Document the max-goto-duplication-insns param.\n\nFrom-SVN: r94531", "tree": {"sha": "87553ed6cbe3253976ee763b34f7a58ef2a27ed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87553ed6cbe3253976ee763b34f7a58ef2a27ed1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbcb0c056be0883aa970eb5552bb713d516d9c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbcb0c056be0883aa970eb5552bb713d516d9c1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbcb0c056be0883aa970eb5552bb713d516d9c1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbcb0c056be0883aa970eb5552bb713d516d9c1e/comments", "author": null, "committer": null, "parents": [{"sha": "e88334a68f98bc5ca30180787f9c67512b568ab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e88334a68f98bc5ca30180787f9c67512b568ab7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e88334a68f98bc5ca30180787f9c67512b568ab7"}], "stats": {"total": 142, "additions": 140, "deletions": 2}, "files": [{"sha": "b5b35c8169f46260f6d92f91c797429ed40f8798", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbcb0c056be0883aa970eb5552bb713d516d9c1e", "patch": "@@ -1,3 +1,16 @@\n+2005-02-01  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR optimization/15242\n+\t* params.def (PARAM_MAX_GOTO_DUPLICATION_INSNS): New param.\n+\t* basic-block.h (duplicate_computed_gotos): Add prototype.\n+\t* bb-reorder.c (duplicate_computed_gotos): New function to\n+\tduplicate sufficiently small blocks ending in a computed jump.\n+\t* passes.c (rest_of_compilation): Call duplicate_computed_gotos\n+\tif not optimizing for size.\n+\t* cfgcleanup.c (try_crossjump_bb): If not optimizing for size,\n+\tnever do tail merging for blocks ending in a computed jump.\n+\t* doc/invoke.texi: Document the max-goto-duplication-insns param.\n+\n 2005-02-01  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPatch from Richard Sandiford <rsandifo@redhat.com>"}, {"sha": "47cd99d22c444e6355dccfd5100f43e30738980b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=bbcb0c056be0883aa970eb5552bb713d516d9c1e", "patch": "@@ -812,6 +812,7 @@ extern bool control_flow_insn_p (rtx);\n \n /* In bb-reorder.c */\n extern void reorder_basic_blocks (unsigned int);\n+extern void duplicate_computed_gotos (void);\n extern void partition_hot_cold_basic_blocks (void);\n \n /* In cfg.c */"}, {"sha": "f454ce0a3c37f50ef0e67ab33adbaf19bc138432", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 100, "deletions": 2, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=bbcb0c056be0883aa970eb5552bb713d516d9c1e", "patch": "@@ -81,6 +81,7 @@\n #include \"tm_p.h\"\n #include \"obstack.h\"\n #include \"expr.h\"\n+#include \"params.h\"\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but\n    when partitioning hot and cold basic blocks into separate sections of\n@@ -1189,8 +1190,7 @@ copy_bb_p (basic_block bb, int code_may_grow)\n   if (code_may_grow && maybe_hot_bb_p (bb))\n     max_size *= 8;\n \n-  for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n-       insn = NEXT_INSN (insn))\n+  FOR_BB_INSNS (bb, insn)\n     {\n       if (INSN_P (insn))\n \tsize += get_attr_length (insn);\n@@ -1985,6 +1985,104 @@ reorder_basic_blocks (unsigned int flags)\n   timevar_pop (TV_REORDER_BLOCKS);\n }\n \n+/* Duplicate the blocks containing computed gotos.  This basically unfactors\n+   computed gotos that were factored early on in the compilation process to\n+   speed up edge based data flow.  We used to not unfactoring them again,\n+   which can seriously pessimize code with many computed jumps in the source\n+   code, such as interpreters.  See e.g. PR15242.  */\n+\n+void\n+duplicate_computed_gotos (void)\n+{\n+  basic_block bb, new_bb;\n+  bitmap candidates;\n+  int max_size;\n+\n+  if (n_basic_blocks <= 1)\n+    return;\n+\n+  if (targetm.cannot_modify_jumps_p ())\n+    return;\n+\n+  timevar_push (TV_REORDER_BLOCKS);\n+\n+  cfg_layout_initialize (0);\n+\n+  /* We are estimating the length of uncond jump insn only once\n+     since the code for getting the insn length always returns\n+     the minimal length now.  */\n+  if (uncond_jump_length == 0)\n+    uncond_jump_length = get_uncond_jump_length ();\n+\n+  max_size = uncond_jump_length * PARAM_VALUE (PARAM_MAX_GOTO_DUPLICATION_INSNS);\n+  candidates = BITMAP_XMALLOC ();\n+\n+  /* Build the reorder chain for the original order of blocks.\n+     Look for a computed jump while we are at it.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->next_bb != EXIT_BLOCK_PTR)\n+\tbb->rbi->next = bb->next_bb;\n+\n+      /* If the block ends in a computed jump and it is small enough,\n+\t make it a candidate for duplication.  */\n+      if (computed_jump_p (BB_END (bb)))\n+\t{\n+\t  rtx insn;\n+\t  int size = 0;\n+\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    {\n+\t      if (INSN_P (insn))\n+\t        size += get_attr_length (insn);\n+\t      if (size > max_size)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (size <= max_size)\n+\t    bitmap_set_bit (candidates, bb->index);\n+\t}\n+    }\n+\n+  /* Nothing to do if there is no computed jump here.  */\n+  if (bitmap_empty_p (candidates))\n+    goto done;\n+\n+  /* Duplicate computed gotos.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->rbi->visited)\n+\tcontinue;\n+\n+      bb->rbi->visited = 1;\n+\n+      /* BB must have one outgoing edge.  That edge must not lead to\n+         the exit block or the next block.\n+\t The destination must have more than one predecessor.  */\n+      if (EDGE_COUNT(bb->succs) != 1\n+\t  || EDGE_SUCC(bb,0)->dest == EXIT_BLOCK_PTR\n+\t  || EDGE_SUCC(bb,0)->dest == bb->next_bb\n+\t  || EDGE_COUNT(EDGE_SUCC(bb,0)->dest->preds) <= 1)\n+\tcontinue;\n+\n+      /* The successor block has to be a duplication candidate.  */\n+      if (!bitmap_bit_p (candidates, EDGE_SUCC(bb,0)->dest->index))\n+\tcontinue;\n+\n+      new_bb = duplicate_block (EDGE_SUCC(bb,0)->dest, EDGE_SUCC(bb,0));\n+      new_bb->rbi->next = bb->rbi->next;\n+      bb->rbi->next = new_bb;\n+      new_bb->rbi->visited = 1;\n+    }\n+\n+done:\n+  cfg_layout_finalize ();\n+\n+  BITMAP_XFREE (candidates);\n+\n+  timevar_pop (TV_REORDER_BLOCKS);\n+}\n+\n /* This function is the main 'entrance' for the optimization that\n    partitions hot and cold basic blocks into separate sections of the\n    .o file (to improve performance and cache locality).  Ideally it"}, {"sha": "3d04a55b2d50478159d02470045c2b16bb840134", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=bbcb0c056be0883aa970eb5552bb713d516d9c1e", "patch": "@@ -1707,6 +1707,13 @@ try_crossjump_bb (int mode, basic_block bb)\n   if (EDGE_COUNT (bb->preds) < 2)\n     return false;\n \n+  /* Don't crossjump if this block ends in a computed jump,\n+     unless we are optimizing for size.  */\n+  if (!optimize_size\n+      && bb != EXIT_BLOCK_PTR\n+      && computed_jump_p (BB_END (bb)))\n+    return false;\n+\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n      and cold sections. "}, {"sha": "1247f648aa931e61661bf12bf08b7d573ada6943", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bbcb0c056be0883aa970eb5552bb713d516d9c1e", "patch": "@@ -5344,6 +5344,14 @@ of two blocks before crossjumping will be performed on them.  This\n value is ignored in the case where all instructions in the block being\n crossjumped from are matched.  The default value is 5.\n \n+@item max-goto-duplication-insns\n+The maximum number of instructions to duplicate to a block that jumps\n+to a computed goto.  To avoid @math{O(N^2)} behavior in a number of\n+passes, GCC factors computed gotos early in the compilation process,\n+and unfactors them as late as possible.  Only computed jumps at the\n+end of a basic blocks with no more than max-goto-duplication-insns are\n+unfactored.  The default value is 8.\n+\n @item max-delay-slot-insn-search\n The maximum number of instructions to consider when looking for an\n instruction to fill a delay slot.  If more than this arbitrary number of"}, {"sha": "c424ad59f107e5cfbe4dce6dd0b91c676cc3bb6d", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=bbcb0c056be0883aa970eb5552bb713d516d9c1e", "patch": "@@ -317,6 +317,12 @@ DEFPARAM(PARAM_MIN_CROSSJUMP_INSNS,\n      \"The minimum number of matching instructions to consider for crossjumping\",\n      5, 0, 0)\n \n+/* The maximum number of insns to duplicate when unfactoring computed gotos.  */\n+DEFPARAM(PARAM_MAX_GOTO_DUPLICATION_INSNS,\n+     \"max-goto-duplication-insns\",\n+     \"The maximum number of insns to duplicate when unfactoring computed gotos\",\n+     8, 0, 0)\n+\n /* The maximum length of path considered in cse.  */\n DEFPARAM(PARAM_MAX_CSE_PATH_LENGTH,\n \t \"max-cse-path-length\","}, {"sha": "723656f4cd85d7e17db8b0648bf60769cf6127c7", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcb0c056be0883aa970eb5552bb713d516d9c1e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=bbcb0c056be0883aa970eb5552bb713d516d9c1e", "patch": "@@ -1713,6 +1713,11 @@ rest_of_compilation (void)\n \n   compute_alignments ();\n \n+  /* Aggressively duplicate basic blocks ending in computed gotos to the\n+     tails of their predecessors, unless we are optimizing for size.  */\n+  if (flag_expensive_optimizations && !optimize_size)\n+    duplicate_computed_gotos ();\n+\n   if (flag_var_tracking)\n     rest_of_handle_variable_tracking ();\n "}]}