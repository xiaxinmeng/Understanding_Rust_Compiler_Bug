{"sha": "64f3e71c302b4a13e61656ee509e7050b9bce978", "node_id": "C_kwDOANBUbNoAKDY0ZjNlNzFjMzAyYjRhMTNlNjE2NTZlZTUwOWU3MDUwYjliY2U5Nzg", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-14T17:49:15Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-14T17:49:15Z"}, "message": "Extend modref to track kills\n\nThis patch adds kill tracking to ipa-modref.  This is representd by array\nof accesses to memory locations that are known to be overwritten by the\nfunction.\n\ngcc/ChangeLog:\n\n2021-11-14  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref-tree.c (modref_access_node::update_for_kills): New\n\tmember function.\n\t(modref_access_node::merge_for_kills): Likewise.\n\t(modref_access_node::insert_kill): Likewise.\n\t* ipa-modref-tree.h (modref_access_node::update_for_kills,\n\tmodref_access_node::merge_for_kills, modref_access_node::insert_kill):\n\tDeclare.\n\t(modref_access_node::useful_for_kill): New member function.\n\t* ipa-modref.c (modref_summary::useful_p): Release useless kills.\n\t(lto_modref_summary): Add kills.\n\t(modref_summary::dump): Dump kills.\n\t(record_access): Add mdoref_access_node parameter.\n\t(record_access_lto): Likewise.\n\t(merge_call_side_effects): Merge kills.\n\t(analyze_call): Add ALWAYS_EXECUTED param and pass it around.\n\t(struct summary_ptrs): Add always_executed filed.\n\t(analyze_load): Update.\n\t(analyze_store): Update; record kills.\n\t(analyze_stmt): Add always_executed; record kills in clobbers.\n\t(analyze_function): Track always_executed.\n\t(modref_summaries::duplicate): Duplicate kills.\n\t(update_signature): Release kills.\n\t* ipa-modref.h (struct modref_summary): Add kills.\n\t* tree-ssa-alias.c (alias_stats): Add kill stats.\n\t(dump_alias_stats): Dump kill stats.\n\t(store_kills_ref_p): Break out from ...\n\t(stmt_kills_ref_p): Use it; handle modref info based kills.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-14  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/tree-ssa/modref-dse-3.c: New test.", "tree": {"sha": "bb221243513a5106c4390058d808a46342bc7de2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb221243513a5106c4390058d808a46342bc7de2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64f3e71c302b4a13e61656ee509e7050b9bce978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f3e71c302b4a13e61656ee509e7050b9bce978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64f3e71c302b4a13e61656ee509e7050b9bce978", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f3e71c302b4a13e61656ee509e7050b9bce978/comments", "author": null, "committer": null, "parents": [{"sha": "8a601f9bc45f9faaa91f18d58ba71b141acff701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a601f9bc45f9faaa91f18d58ba71b141acff701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a601f9bc45f9faaa91f18d58ba71b141acff701"}], "stats": {"total": 550, "additions": 471, "deletions": 79}, "files": [{"sha": "bbe23a5a211e8c4b9d263a9f0cb34aabacc73b84", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=64f3e71c302b4a13e61656ee509e7050b9bce978", "patch": "@@ -638,6 +638,185 @@ modref_access_node::get_ao_ref (const gcall *stmt, ao_ref *ref) const\n   return true;\n }\n \n+/* Return true A is a subkill.  */\n+bool\n+modref_access_node::contains_for_kills (const modref_access_node &a) const\n+{\n+  poly_int64 aoffset_adj = 0;\n+\n+  gcc_checking_assert (parm_index != MODREF_UNKNOWN_PARM\n+\t\t       && a.parm_index != MODREF_UNKNOWN_PARM);\n+  if (parm_index != a.parm_index)\n+    return false;\n+  gcc_checking_assert (parm_offset_known && a.parm_offset_known);\n+  aoffset_adj = (a.parm_offset - parm_offset)\n+\t\t* BITS_PER_UNIT;\n+  gcc_checking_assert (range_info_useful_p () && a.range_info_useful_p ());\n+  return known_subrange_p (a.offset + aoffset_adj,\n+\t\t\t   a.max_size, offset, max_size);\n+}\n+\n+/* Merge two ranges both starting at parm_offset1 and update THIS\n+   with result.  */\n+bool\n+modref_access_node::update_for_kills (poly_int64 parm_offset1,\n+\t\t\t\t      poly_int64 offset1,\n+\t\t\t\t      poly_int64 max_size1,\n+\t\t\t\t      poly_int64 offset2,\n+\t\t\t\t      poly_int64 max_size2,\n+\t\t\t\t      bool record_adjustments)\n+{\n+  if (known_le (offset1, offset2))\n+    ;\n+  else if (known_le (offset2, offset1))\n+    {\n+      std::swap (offset1, offset2);\n+      std::swap (max_size1, max_size2);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  poly_int64 new_max_size = max_size2 + offset2 - offset1;\n+  if (known_le (new_max_size, max_size1))\n+    new_max_size = max_size1;\n+  if (known_eq (parm_offset, parm_offset1)\n+      && known_eq (offset, offset1)\n+      && known_eq (size, new_max_size)\n+      && known_eq (max_size, new_max_size))\n+    return false;\n+\n+  if (!record_adjustments\n+      || (++adjustments) < param_modref_max_adjustments)\n+    {\n+      parm_offset = parm_offset1;\n+      offset = offset1;\n+      max_size = new_max_size;\n+      size = new_max_size;\n+      gcc_checking_assert (useful_for_kill_p ());\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Merge in access A if it is possible to do without losing\n+   precision.  Return true if successful.\n+   Unlike merge assume that both accesses are always executed\n+   and merge size the same was as max_size.  */\n+bool\n+modref_access_node::merge_for_kills (const modref_access_node &a,\n+\t\t\t\t     bool record_adjustments)\n+{\n+  poly_int64 offset1 = 0;\n+  poly_int64 aoffset1 = 0;\n+  poly_int64 new_parm_offset = 0;\n+\n+  /* We assume that containment was tested earlier.  */\n+  gcc_checking_assert (!contains_for_kills (a) && !a.contains_for_kills (*this)\n+\t\t       && useful_for_kill_p () && a.useful_for_kill_p ());\n+\n+  if (parm_index != a.parm_index\n+      || !combined_offsets (a, &new_parm_offset, &offset1, &aoffset1))\n+    return false;\n+\n+  if (known_le (offset1, aoffset1))\n+   {\n+     if (!known_size_p (max_size)\n+\t || known_ge (offset1 + max_size, aoffset1))\n+       return update_for_kills (new_parm_offset, offset1, max_size,\n+\t\t\t\taoffset1, a.max_size, record_adjustments);\n+   }\n+  else if (known_le (aoffset1, offset1))\n+   {\n+     if (!known_size_p (a.max_size)\n+\t || known_ge (aoffset1 + a.max_size, offset1))\n+       return update_for_kills (new_parm_offset, offset1, max_size,\n+\t\t\t\taoffset1, a.max_size, record_adjustments);\n+   }\n+  return false;\n+}\n+\n+/* Insert new kill A into KILLS.  If RECORD_ADJUSTMENTS is true limit number\n+   of changes to each entry.  Return true if something changed.  */\n+\n+bool\n+modref_access_node::insert_kill (vec<modref_access_node> &kills,\n+\t\t\t\t modref_access_node &a, bool record_adjustments)\n+{\n+  size_t index;\n+  modref_access_node *a2;\n+  bool merge = false;\n+\n+  gcc_checking_assert (a.useful_for_kill_p ());\n+\n+  /* See if we have corresponding entry already or we can merge with\n+     neighbouring entry.  */\n+  FOR_EACH_VEC_ELT (kills, index, a2)\n+    {\n+      if (a2->contains_for_kills (a))\n+\treturn false;\n+      if (a.contains_for_kills (*a2))\n+\t{\n+\t  a.adjustments = 0;\n+\t  *a2 = a;\n+\t  merge = true;\n+\t  break;\n+\t}\n+      if (a2->merge_for_kills (a, record_adjustments))\n+\t{\n+\t  merge = true;\n+\t  break;\n+\t}\n+    }\n+  /* If entry was not found, insert it.  */\n+  if (!merge)\n+    {\n+      if ((int)kills.length () >= param_modref_max_accesses)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"--param param=modref-max-accesses limit reached:\");\n+\t  return false;\n+\t}\n+      a.adjustments = 0;\n+      kills.safe_push (a);\n+      return true;\n+    }\n+  /* Extending range in an entry may make it possible to merge it with\n+     other entries.  */\n+  size_t i;\n+\n+  for (i = 0; i < kills.length ();)\n+    if (i != index)\n+      {\n+\tbool found = false, restart = false;\n+\tmodref_access_node *a = &kills[i];\n+\tmodref_access_node *n = &kills[index];\n+\n+\tif (n->contains_for_kills (*a))\n+\t  found = true;\n+\tif (!found && n->merge_for_kills (*a, false))\n+\t  found = restart = true;\n+\tgcc_checking_assert (found || !a->merge_for_kills (*n, false));\n+\tif (found)\n+\t  {\n+\t    kills.unordered_remove (i);\n+\t    if (index == kills.length ())\n+\t      {\n+\t\tindex = i;\n+\t\ti++;\n+\t      }\n+\t    if (restart)\n+\t      i = 0;\n+\t  }\n+\telse\n+\t  i++;\n+      }\n+    else\n+      i++;\n+  return true;\n+}\n+\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "1bf2aa8460e9a9016e4c2fa27f569291ba0ab195", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=64f3e71c302b4a13e61656ee509e7050b9bce978", "patch": "@@ -82,6 +82,13 @@ struct GTY(()) modref_access_node\n     {\n       return parm_index != MODREF_UNKNOWN_PARM;\n     }\n+  /* Return true if access can be used to determine a kill.  */\n+  bool useful_for_kill_p () const\n+    {\n+      return parm_offset_known && parm_index != MODREF_UNKNOWN_PARM\n+\t     && parm_index != MODREF_RETSLOT_PARM && known_size_p (size)\n+\t     && known_eq (max_size, size);\n+    }\n   /* Dump range to debug OUT.  */\n   void dump (FILE *out);\n   /* Return true if both accesses are the same.  */\n@@ -98,10 +105,18 @@ struct GTY(()) modref_access_node\n   static int insert (vec <modref_access_node, va_gc> *&accesses,\n \t\t     modref_access_node a, size_t max_accesses,\n \t\t     bool record_adjustments);\n+  /* Same as insert but for kills where we are conservative the other way\n+     around: if information is lost, the kill is lost.  */\n+  static bool insert_kill (vec<modref_access_node> &kills,\n+\t\t\t   modref_access_node &a, bool record_adjustments);\n private:\n   bool contains (const modref_access_node &) const;\n+  bool contains_for_kills (const modref_access_node &) const;\n   void update (poly_int64, poly_int64, poly_int64, poly_int64, bool);\n+  bool update_for_kills (poly_int64, poly_int64, poly_int64,\n+\t\t\t poly_int64, poly_int64, bool);\n   bool merge (const modref_access_node &, bool);\n+  bool merge_for_kills (const modref_access_node &, bool);\n   static bool closer_pair_p (const modref_access_node &,\n \t\t\t     const modref_access_node &,\n \t\t\t     const modref_access_node &,"}, {"sha": "df4612bbff91776186ad279a67ae7f0f2fa966c8", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 108, "deletions": 18, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=64f3e71c302b4a13e61656ee509e7050b9bce978", "patch": "@@ -335,6 +335,8 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n     return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   if (loads && !loads->every_base)\n     return true;\n+  else\n+    kills.release ();\n   if (ecf_flags & ECF_PURE)\n     return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   return stores && !stores->every_base;\n@@ -351,6 +353,7 @@ struct GTY(()) modref_summary_lto\n      more verbose and thus more likely to hit the limits.  */\n   modref_records_lto *loads;\n   modref_records_lto *stores;\n+  auto_vec<modref_access_node> GTY((skip)) kills;\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   eaf_flags_t retslot_flags;\n   eaf_flags_t static_chain_flags;\n@@ -570,6 +573,15 @@ modref_summary::dump (FILE *out)\n       fprintf (out, \"  stores:\\n\");\n       dump_records (stores, out);\n     }\n+  if (kills.length ())\n+    {\n+      fprintf (out, \"  kills:\\n\");\n+      for (auto kill : kills)\n+\t{\n+\t  fprintf (out, \"    \");\n+\t  kill.dump (out);\n+\t}\n+    }\n   if (writes_errno)\n     fprintf (out, \"  Writes errno\\n\");\n   if (side_effects)\n@@ -762,13 +774,12 @@ get_access (ao_ref *ref)\n /* Record access into the modref_records data structure.  */\n \n static void\n-record_access (modref_records *tt, ao_ref *ref)\n+record_access (modref_records *tt, ao_ref *ref, modref_access_node &a)\n {\n   alias_set_type base_set = !flag_strict_aliasing ? 0\n \t\t\t    : ao_ref_base_alias_set (ref);\n   alias_set_type ref_set = !flag_strict_aliasing ? 0\n \t\t\t    : (ao_ref_alias_set (ref));\n-  modref_access_node a = get_access (ref);\n   if (dump_file)\n     {\n        fprintf (dump_file, \"   - Recording base_set=%i ref_set=%i \",\n@@ -781,7 +792,7 @@ record_access (modref_records *tt, ao_ref *ref)\n /* IPA version of record_access_tree.  */\n \n static void\n-record_access_lto (modref_records_lto *tt, ao_ref *ref)\n+record_access_lto (modref_records_lto *tt, ao_ref *ref, modref_access_node &a)\n {\n   /* get_alias_set sometimes use different type to compute the alias set\n      than TREE_TYPE (base).  Do same adjustments.  */\n@@ -828,7 +839,6 @@ record_access_lto (modref_records_lto *tt, ao_ref *ref)\n \t\t       || variably_modified_type_p (ref_type, NULL_TREE)))\n \tref_type = NULL_TREE;\n     }\n-  modref_access_node a = get_access (ref);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"   - Recording base type:\");\n@@ -932,13 +942,17 @@ bool\n merge_call_side_effects (modref_summary *cur_summary,\n \t\t\t gimple *stmt, modref_summary *callee_summary,\n \t\t\t bool ignore_stores, cgraph_node *callee_node,\n-\t\t\t bool record_adjustments)\n+\t\t\t bool record_adjustments, bool always_executed)\n {\n   auto_vec <modref_parm_map, 32> parm_map;\n   modref_parm_map chain_map;\n   bool changed = false;\n   int flags = gimple_call_flags (stmt);\n \n+  if ((flags & (ECF_CONST | ECF_NOVOPS))\n+      && !(flags & ECF_LOOPING_CONST_OR_PURE))\n+    return changed;\n+\n   if (!cur_summary->side_effects && callee_summary->side_effects)\n     {\n       if (dump_file)\n@@ -950,6 +964,38 @@ merge_call_side_effects (modref_summary *cur_summary,\n   if (flags & (ECF_CONST | ECF_NOVOPS))\n     return changed;\n \n+  if (always_executed\n+      && callee_summary->kills.length ()\n+      && (!cfun->can_throw_non_call_exceptions\n+\t  || !stmt_could_throw_p (cfun, stmt)))\n+    {\n+      /* Watch for self recursive updates.  */\n+      auto_vec<modref_access_node, 32> saved_kills;\n+\n+      saved_kills.reserve_exact (callee_summary->kills.length ());\n+      saved_kills.splice (callee_summary->kills);\n+      for (auto kill : saved_kills)\n+\t{\n+\t  if (kill.parm_index >= (int)parm_map.length ())\n+\t    continue;\n+\t  modref_parm_map &m\n+\t\t  = kill.parm_index == MODREF_STATIC_CHAIN_PARM\n+\t\t    ? chain_map\n+\t\t    : parm_map[kill.parm_index];\n+\t  if (m.parm_index == MODREF_LOCAL_MEMORY_PARM\n+\t      || m.parm_index == MODREF_UNKNOWN_PARM\n+\t      || m.parm_index == MODREF_RETSLOT_PARM\n+\t      || !m.parm_offset_known)\n+\t    continue;\n+\t  modref_access_node n = kill;\n+\t  n.parm_index = m.parm_index;\n+\t  n.parm_offset += m.parm_offset;\n+\t  if (modref_access_node::insert_kill (cur_summary->kills, n,\n+\t\t\t\t\t       record_adjustments))\n+\t    changed = true;\n+\t}\n+    }\n+\n   /* We can not safely optimize based on summary of callee if it does\n      not always bind to current def: it is possible that memory load\n      was optimized out earlier which may not happen in the interposed\n@@ -1218,7 +1264,8 @@ process_fnspec (modref_summary *cur_summary,\n \n static bool\n analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n-\t      gcall *stmt, vec <gimple *> *recursive_calls)\n+\t      gcall *stmt, vec <gimple *> *recursive_calls,\n+\t      bool always_executed)\n {\n   /* Check flags on the function call.  In certain cases, analysis can be\n      simplified.  */\n@@ -1305,7 +1352,7 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n     }\n \n   merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores,\n-\t\t\t   callee_node, false);\n+\t\t\t   callee_node, false, always_executed);\n \n   return true;\n }\n@@ -1316,6 +1363,7 @@ struct summary_ptrs\n {\n   struct modref_summary *nolto;\n   struct modref_summary_lto *lto;\n+  bool always_executed;\n };\n \n /* Helper for analyze_stmt.  */\n@@ -1350,18 +1398,19 @@ analyze_load (gimple *, tree, tree op, void *data)\n \n   ao_ref r;\n   ao_ref_init (&r, op);\n+  modref_access_node a = get_access (&r);\n \n   if (summary)\n-    record_access (summary->loads, &r);\n+    record_access (summary->loads, &r, a);\n   if (summary_lto)\n-    record_access_lto (summary_lto->loads, &r);\n+    record_access_lto (summary_lto->loads, &r, a);\n   return false;\n }\n \n /* Helper for analyze_stmt.  */\n \n static bool\n-analyze_store (gimple *, tree, tree op, void *data)\n+analyze_store (gimple *stmt, tree, tree op, void *data)\n {\n   modref_summary *summary = ((summary_ptrs *)data)->nolto;\n   modref_summary_lto *summary_lto = ((summary_ptrs *)data)->lto;\n@@ -1390,11 +1439,22 @@ analyze_store (gimple *, tree, tree op, void *data)\n \n   ao_ref r;\n   ao_ref_init (&r, op);\n+  modref_access_node a = get_access (&r);\n \n   if (summary)\n-    record_access (summary->stores, &r);\n+    record_access (summary->stores, &r, a);\n   if (summary_lto)\n-    record_access_lto (summary_lto->stores, &r);\n+    record_access_lto (summary_lto->stores, &r, a);\n+  if (summary\n+      && ((summary_ptrs *)data)->always_executed\n+      && a.useful_for_kill_p ()\n+      && (!cfun->can_throw_non_call_exceptions\n+\t  || !stmt_could_throw_p (cfun, stmt)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"   - Recording kill\\n\");\n+      modref_access_node::insert_kill (summary->kills, a, false);\n+    }\n   return false;\n }\n \n@@ -1403,16 +1463,32 @@ analyze_store (gimple *, tree, tree op, void *data)\n \n static bool\n analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n-\t      gimple *stmt, bool ipa, vec <gimple *> *recursive_calls)\n+\t      gimple *stmt, bool ipa, vec <gimple *> *recursive_calls,\n+\t      bool always_executed)\n {\n   /* In general we can not ignore clobbers because they are barriers for code\n      motion, however after inlining it is safe to do because local optimization\n      passes do not consider clobbers from other functions.\n      Similar logic is in ipa-pure-const.c.  */\n   if ((ipa || cfun->after_inlining) && gimple_clobber_p (stmt))\n-    return true;\n+    {\n+      if (summary\n+\t  && always_executed && record_access_p (gimple_assign_lhs (stmt)))\n+\t{\n+\t  ao_ref r;\n+\t  ao_ref_init (&r, gimple_assign_lhs (stmt));\n+\t  modref_access_node a = get_access (&r);\n+\t  if (a.useful_for_kill_p ())\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"   - Recording kill\\n\");\n+\t      modref_access_node::insert_kill (summary->kills, a, false);\n+\t    }\n+\t}\n+      return true;\n+    }\n \n-  struct summary_ptrs sums = {summary, summary_lto};\n+  struct summary_ptrs sums = {summary, summary_lto, always_executed};\n \n   /* Analyze all loads and stores in STMT.  */\n   walk_stmt_load_store_ops (stmt, &sums,\n@@ -1441,7 +1517,8 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n    case GIMPLE_CALL:\n      if (!ipa || gimple_call_internal_p (stmt))\n        return analyze_call (summary, summary_lto,\n-\t\t\t    as_a <gcall *> (stmt), recursive_calls);\n+\t\t\t    as_a <gcall *> (stmt), recursive_calls,\n+\t\t\t    always_executed);\n      else\n       {\n \tattr_fnspec fnspec = gimple_call_fnspec (as_a <gcall *>(stmt));\n@@ -2779,11 +2856,15 @@ analyze_function (function *f, bool ipa)\n   FOR_EACH_BB_FN (bb, f)\n     {\n       gimple_stmt_iterator si;\n+      bool always_executed\n+\t      = bb == single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->dest;\n+\n       for (si = gsi_start_nondebug_after_labels_bb (bb);\n \t   !gsi_end_p (si); gsi_next_nondebug (&si))\n \t{\n \t  if (!analyze_stmt (summary, summary_lto,\n-\t\t\t     gsi_stmt (si), ipa, &recursive_calls)\n+\t\t\t     gsi_stmt (si), ipa, &recursive_calls,\n+\t\t\t     always_executed)\n \t      || ((!summary || !summary->useful_p (ecf_flags, false))\n \t\t  && (!summary_lto\n \t\t      || !summary_lto->useful_p (ecf_flags, false))))\n@@ -2792,6 +2873,9 @@ analyze_function (function *f, bool ipa)\n \t      collapse_stores (summary, summary_lto);\n \t      break;\n \t    }\n+\t  if (always_executed\n+\t      && stmt_can_throw_external (cfun, gsi_stmt (si)))\n+\t    always_executed = false;\n \t}\n     }\n \n@@ -2811,7 +2895,7 @@ analyze_function (function *f, bool ipa)\n \t\t\t   ignore_stores_p (current_function_decl,\n \t\t\t\t\t    gimple_call_flags\n \t\t\t\t\t\t (recursive_calls[i])),\n-\t\t\t   fnode, !first);\n+\t\t\t   fnode, !first, false);\n \t      if (!summary->useful_p (ecf_flags, false))\n \t\t{\n \t\t  remove_summary (lto, nolto, ipa);\n@@ -3061,6 +3145,8 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n \t\t\t src_data->loads->max_refs,\n \t\t\t src_data->loads->max_accesses);\n   dst_data->loads->copy_from (src_data->loads);\n+  dst_data->kills.reserve_exact (src_data->kills.length ());\n+  dst_data->kills.splice (src_data->kills);\n   dst_data->writes_errno = src_data->writes_errno;\n   dst_data->side_effects = src_data->side_effects;\n   if (src_data->arg_flags.length ())\n@@ -3710,13 +3796,17 @@ update_signature (struct cgraph_node *node)\n     {\n       r->loads->remap_params (&map);\n       r->stores->remap_params (&map);\n+      /* TODO: One we do IPA kills analysis, update the table here.  */\n+      r->kills.release ();\n       if (r->arg_flags.length ())\n \tremap_arg_flags (r->arg_flags, info);\n     }\n   if (r_lto)\n     {\n       r_lto->loads->remap_params (&map);\n       r_lto->stores->remap_params (&map);\n+      /* TODO: One we do IPA kills analysis, update the table here.  */\n+      r_lto->kills.release ();\n       if (r_lto->arg_flags.length ())\n \tremap_arg_flags (r_lto->arg_flags, info);\n     }"}, {"sha": "9e8a30fd80a5b14ae642cc709fb5c8bc6a7fbe2e", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=64f3e71c302b4a13e61656ee509e7050b9bce978", "patch": "@@ -30,6 +30,7 @@ struct GTY(()) modref_summary\n   /* Load and stores in function (transitively closed to all callees)  */\n   modref_records *loads;\n   modref_records *stores;\n+  auto_vec<modref_access_node> GTY((skip)) kills;\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   eaf_flags_t retslot_flags;\n   eaf_flags_t static_chain_flags;"}, {"sha": "c69e423c6fd60148031553ef1f5d498f95f7e68d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-dse-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-3.c?ref=64f3e71c302b4a13e61656ee509e7050b9bce978", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse1-details\"  } */\n+__attribute__ ((noinline))\n+void write (int *a)\n+{\n+\t*a=1;\n+\ta[1]=2;\n+}\n+int test ()\n+{\n+\tint a;\n+\ta=2;\n+\twrite (&a);\n+\treturn a;\n+}\n+int test2 (int *a)\n+{\n+\t*a=2;\n+\twrite (a);\n+\treturn *a;\n+}\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 2 \"dse1\"} } */"}, {"sha": "093d65cc0031fbafb5ce171fa3afdd24518b176c", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 146, "deletions": 61, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f3e71c302b4a13e61656ee509e7050b9bce978/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=64f3e71c302b4a13e61656ee509e7050b9bce978", "patch": "@@ -116,10 +116,14 @@ static struct {\n   unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_may_alias;\n   unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_must_overlap;\n   unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_no_alias;\n+  unsigned HOST_WIDE_INT stmt_kills_ref_p_no;\n+  unsigned HOST_WIDE_INT stmt_kills_ref_p_yes;\n   unsigned HOST_WIDE_INT modref_use_may_alias;\n   unsigned HOST_WIDE_INT modref_use_no_alias;\n   unsigned HOST_WIDE_INT modref_clobber_may_alias;\n   unsigned HOST_WIDE_INT modref_clobber_no_alias;\n+  unsigned HOST_WIDE_INT modref_kill_no;\n+  unsigned HOST_WIDE_INT modref_kill_yes;\n   unsigned HOST_WIDE_INT modref_tests;\n   unsigned HOST_WIDE_INT modref_baseptr_tests;\n } alias_stats;\n@@ -146,6 +150,12 @@ dump_alias_stats (FILE *s)\n \t   alias_stats.call_may_clobber_ref_p_no_alias,\n \t   alias_stats.call_may_clobber_ref_p_no_alias\n \t   + alias_stats.call_may_clobber_ref_p_may_alias);\n+  fprintf (s, \"  stmt_kills_ref_p: \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" kills, \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n+\t   alias_stats.stmt_kills_ref_p_yes + alias_stats.modref_kill_yes,\n+\t   alias_stats.stmt_kills_ref_p_yes + alias_stats.modref_kill_yes\n+\t   + alias_stats.stmt_kills_ref_p_no + alias_stats.modref_kill_no);\n   fprintf (s, \"  nonoverlapping_component_refs_p: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n@@ -169,6 +179,12 @@ dump_alias_stats (FILE *s)\n \t   + alias_stats.aliasing_component_refs_p_may_alias);\n   dump_alias_stats_in_alias_c (s);\n   fprintf (s, \"\\nModref stats:\\n\");\n+  fprintf (s, \"  modref kill: \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" kills, \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n+\t   alias_stats.modref_kill_yes,\n+\t   alias_stats.modref_kill_yes\n+\t   + alias_stats.modref_kill_no);\n   fprintf (s, \"  modref use: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n@@ -3220,6 +3236,51 @@ same_addr_size_stores_p (tree base1, poly_int64 offset1, poly_int64 size1,\n \t  && known_eq (wi::to_poly_offset (DECL_SIZE (obj)), size1));\n }\n \n+/* Return true if REF is killed by an store described by\n+   BASE, OFFSET, SIZE and MAX_SIZE.  */\n+\n+static bool\n+store_kills_ref_p (tree base, poly_int64 offset, poly_int64 size,\n+\t\t   poly_int64 max_size, ao_ref *ref)\n+{\n+  poly_int64 ref_offset = ref->offset;\n+  /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n+     so base == ref->base does not always hold.  */\n+  if (base != ref->base)\n+    {\n+      /* Try using points-to info.  */\n+      if (same_addr_size_stores_p (base, offset, size, max_size, ref->base,\n+\t\t\t\t   ref->offset, ref->size, ref->max_size))\n+\treturn true;\n+\n+      /* If both base and ref->base are MEM_REFs, only compare the\n+\t first operand, and if the second operand isn't equal constant,\n+\t try to add the offsets into offset and ref_offset.  */\n+      if (TREE_CODE (base) == MEM_REF && TREE_CODE (ref->base) == MEM_REF\n+\t  && TREE_OPERAND (base, 0) == TREE_OPERAND (ref->base, 0))\n+\t{\n+\t  if (!tree_int_cst_equal (TREE_OPERAND (base, 1),\n+\t\t\t\t   TREE_OPERAND (ref->base, 1)))\n+\t    {\n+\t      poly_offset_int off1 = mem_ref_offset (base);\n+\t      off1 <<= LOG2_BITS_PER_UNIT;\n+\t      off1 += offset;\n+\t      poly_offset_int off2 = mem_ref_offset (ref->base);\n+\t      off2 <<= LOG2_BITS_PER_UNIT;\n+\t      off2 += ref_offset;\n+\t      if (!off1.to_shwi (&offset) || !off2.to_shwi (&ref_offset))\n+\t\tsize = -1;\n+\t    }\n+\t}\n+      else\n+\tsize = -1;\n+    }\n+  /* For a must-alias check we need to be able to constrain\n+     the access properly.  */\n+  return (known_eq (size, max_size)\n+\t  && known_subrange_p (ref_offset, ref->max_size, offset, size));\n+}\n+\n /* If STMT kills the memory reference REF return true, otherwise\n    return false.  */\n \n@@ -3293,60 +3354,83 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t      && operand_equal_p (lhs, base,\n \t\t\t\t\t  OEP_ADDRESS_OF\n \t\t\t\t\t  | OEP_MATCH_SIDE_EFFECTS))))\n-\t    return true;\n+\t    {\n+\t      ++alias_stats.stmt_kills_ref_p_yes;\n+\t      return true;\n+\t    }\n \t}\n \n       /* Now look for non-literal equal bases with the restriction of\n          handling constant offset and size.  */\n       /* For a must-alias check we need to be able to constrain\n \t the access properly.  */\n       if (!ref->max_size_known_p ())\n-\treturn false;\n-      poly_int64 size, offset, max_size, ref_offset = ref->offset;\n+\t{\n+\t  ++alias_stats.stmt_kills_ref_p_no;\n+\t  return false;\n+\t}\n+      poly_int64 size, offset, max_size;\n       bool reverse;\n       tree base = get_ref_base_and_extent (lhs, &offset, &size, &max_size,\n \t\t\t\t\t   &reverse);\n-      /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n-\t so base == ref->base does not always hold.  */\n-      if (base != ref->base)\n+      if (store_kills_ref_p (base, offset, size, max_size, ref))\n \t{\n-\t  /* Try using points-to info.  */\n-\t  if (same_addr_size_stores_p (base, offset, size, max_size, ref->base,\n-\t\t\t\t       ref->offset, ref->size, ref->max_size))\n-\t    return true;\n-\n-\t  /* If both base and ref->base are MEM_REFs, only compare the\n-\t     first operand, and if the second operand isn't equal constant,\n-\t     try to add the offsets into offset and ref_offset.  */\n-\t  if (TREE_CODE (base) == MEM_REF && TREE_CODE (ref->base) == MEM_REF\n-\t      && TREE_OPERAND (base, 0) == TREE_OPERAND (ref->base, 0))\n-\t    {\n-\t      if (!tree_int_cst_equal (TREE_OPERAND (base, 1),\n-\t\t\t\t       TREE_OPERAND (ref->base, 1)))\n-\t\t{\n-\t\t  poly_offset_int off1 = mem_ref_offset (base);\n-\t\t  off1 <<= LOG2_BITS_PER_UNIT;\n-\t\t  off1 += offset;\n-\t\t  poly_offset_int off2 = mem_ref_offset (ref->base);\n-\t\t  off2 <<= LOG2_BITS_PER_UNIT;\n-\t\t  off2 += ref_offset;\n-\t\t  if (!off1.to_shwi (&offset) || !off2.to_shwi (&ref_offset))\n-\t\t    size = -1;\n-\t\t}\n-\t    }\n-\t  else\n-\t    size = -1;\n+\t  ++alias_stats.stmt_kills_ref_p_yes;\n+\t  return true;\n \t}\n-      /* For a must-alias check we need to be able to constrain\n-\t the access properly.  */\n-      if (known_eq (size, max_size)\n-\t  && known_subrange_p (ref_offset, ref->max_size, offset, size))\n-\treturn true;\n     }\n \n   if (is_gimple_call (stmt))\n     {\n       tree callee = gimple_call_fndecl (stmt);\n+      struct cgraph_node *node;\n+      modref_summary *summary;\n+\n+      /* Try to disambiguate using modref summary.  Modref records a vector\n+\t of stores with known offsets relative to function parameters that must\n+\t happen every execution of function.  Find if we have a matching\n+\t store and verify that function can not use the value.  */\n+      if (callee != NULL_TREE\n+\t  && (node = cgraph_node::get (callee)) != NULL\n+\t  && node->binds_to_current_def_p ()\n+\t  && (summary = get_modref_function_summary (node)) != NULL\n+\t  && summary->kills.length ()\n+\t  && (!cfun->can_throw_non_call_exceptions\n+\t      || !stmt_can_throw_internal (cfun, stmt)))\n+\t{\n+\t  for (auto kill : summary->kills)\n+\t    {\n+\t      ao_ref dref;\n+\n+\t      /* We only can do useful compares if we know the access range\n+\t\t precisely.  */\n+\t      if (!kill.get_ao_ref (as_a <gcall *> (stmt), &dref))\n+\t\tcontinue;\n+\t      if (store_kills_ref_p (ao_ref_base (&dref), dref.offset,\n+\t\t\t\t     dref.size, dref.max_size, ref))\n+\t\t{\n+\t\t  /* For store to be killed it needs to not be used\n+\t\t     earlier.  */\n+\t\t  if (ref_maybe_used_by_call_p_1 (as_a <gcall *> (stmt), ref,\n+\t\t\t\t\t\t  true)\n+\t\t      || !dbg_cnt (ipa_mod_ref))\n+\t\t    break;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"ipa-modref: call stmt \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0);\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"ipa-modref: call to %s kills \",\n+\t\t\t       node->dump_name ());\n+\t\t      print_generic_expr (dump_file, ref->base);\n+\t\t    }\n+\t\t    ++alias_stats.modref_kill_yes;\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\t  ++alias_stats.modref_kill_no;\n+\t}\n       if (callee != NULL_TREE\n \t  && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n \tswitch (DECL_FUNCTION_CODE (callee))\n@@ -3357,7 +3441,10 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t      tree base = ao_ref_base (ref);\n \t      if (base && TREE_CODE (base) == MEM_REF\n \t\t  && TREE_OPERAND (base, 0) == ptr)\n-\t\treturn true;\n+\t\t{\n+\t\t  ++alias_stats.stmt_kills_ref_p_yes;\n+\t\t  return true;\n+\t\t}\n \t      break;\n \t    }\n \n@@ -3376,7 +3463,10 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t      /* For a must-alias check we need to be able to constrain\n \t\t the access properly.  */\n \t      if (!ref->max_size_known_p ())\n-\t\treturn false;\n+\t\t{\n+\t\t  ++alias_stats.stmt_kills_ref_p_no;\n+\t\t  return false;\n+\t\t}\n \t      tree dest;\n \t      tree len;\n \n@@ -3391,11 +3481,17 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t  tree arg1 = gimple_call_arg (stmt, 1);\n \t\t  if (TREE_CODE (arg0) != INTEGER_CST\n \t\t      || TREE_CODE (arg1) != INTEGER_CST)\n-\t\t    return false;\n+\t\t    {\n+\t\t      ++alias_stats.stmt_kills_ref_p_no;\n+\t\t      return false;\n+\t\t    }\n \n \t\t  dest = gimple_call_lhs (stmt);\n \t\t  if (!dest)\n-\t\t    return false;\n+\t\t    {\n+\t\t      ++alias_stats.stmt_kills_ref_p_no;\n+\t\t      return false;\n+\t\t    }\n \t\t  len = fold_build2 (MULT_EXPR, TREE_TYPE (arg0), arg0, arg1);\n \t\t}\n \t      else\n@@ -3405,29 +3501,14 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t}\n \t      if (!poly_int_tree_p (len))\n \t\treturn false;\n-\t      tree rbase = ref->base;\n-\t      poly_offset_int roffset = ref->offset;\n \t      ao_ref dref;\n \t      ao_ref_init_from_ptr_and_size (&dref, dest, len);\n-\t      tree base = ao_ref_base (&dref);\n-\t      poly_offset_int offset = dref.offset;\n-\t      if (!base || !known_size_p (dref.size))\n-\t\treturn false;\n-\t      if (TREE_CODE (base) == MEM_REF)\n+\t      if (store_kills_ref_p (ao_ref_base (&dref), dref.offset,\n+\t\t\t\t     dref.size, dref.max_size, ref))\n \t\t{\n-\t\t  if (TREE_CODE (rbase) != MEM_REF)\n-\t\t    return false;\n-\t\t  // Compare pointers.\n-\t\t  offset += mem_ref_offset (base) << LOG2_BITS_PER_UNIT;\n-\t\t  roffset += mem_ref_offset (rbase) << LOG2_BITS_PER_UNIT;\n-\t\t  base = TREE_OPERAND (base, 0);\n-\t\t  rbase = TREE_OPERAND (rbase, 0);\n+\t\t  ++alias_stats.stmt_kills_ref_p_yes;\n+\t\t  return true;\n \t\t}\n-\t      if (base == rbase\n-\t\t  && known_subrange_p (roffset, ref->max_size, offset,\n-\t\t\t\t       wi::to_poly_offset (len)\n-\t\t\t\t       << LOG2_BITS_PER_UNIT))\n-\t\treturn true;\n \t      break;\n \t    }\n \n@@ -3438,14 +3519,18 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t{\n \t\t  tree base = ao_ref_base (ref);\n \t\t  if (TREE_OPERAND (ptr, 0) == base)\n-\t\t    return true;\n+\t\t    {\n+\t\t      ++alias_stats.stmt_kills_ref_p_yes;\n+\t\t      return true;\n+\t\t    }\n \t\t}\n \t      break;\n \t    }\n \n \t  default:;\n \t  }\n     }\n+  ++alias_stats.stmt_kills_ref_p_no;\n   return false;\n }\n "}]}