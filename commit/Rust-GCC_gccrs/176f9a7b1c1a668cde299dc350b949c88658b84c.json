{"sha": "176f9a7b1c1a668cde299dc350b949c88658b84c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2ZjlhN2IxYzFhNjY4Y2RlMjk5ZGMzNTBiOTQ5Yzg4NjU4Yjg0Yw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-24T17:36:47Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-24T17:36:47Z"}, "message": "Treat ready list as a (for now, semi-)abstract datatype.  Lose max_priority.\n\nFrom-SVN: r37710", "tree": {"sha": "c113fcfa73194129f57f67d538c636483dd3ad63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c113fcfa73194129f57f67d538c636483dd3ad63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/176f9a7b1c1a668cde299dc350b949c88658b84c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176f9a7b1c1a668cde299dc350b949c88658b84c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176f9a7b1c1a668cde299dc350b949c88658b84c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176f9a7b1c1a668cde299dc350b949c88658b84c/comments", "author": null, "committer": null, "parents": [{"sha": "222de5be4569807aa48134cbe09b60861bea5893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/222de5be4569807aa48134cbe09b60861bea5893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/222de5be4569807aa48134cbe09b60861bea5893"}], "stats": {"total": 197, "additions": 140, "deletions": 57}, "files": [{"sha": "031d454d26fa3904d9c0701727906832e8dfabc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176f9a7b1c1a668cde299dc350b949c88658b84c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176f9a7b1c1a668cde299dc350b949c88658b84c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=176f9a7b1c1a668cde299dc350b949c88658b84c", "patch": "@@ -1,5 +1,17 @@\n 2000-11-24  Bernd Schmidt  <bernds@redhat.co.uk>\n \n+\t* haifa-sched.c (struct ready_list): New.\n+\t(ready_lastpos, ready_add, ready_remove_first, ready_sort): New static\n+\tfunctions.\n+\t(schedule_insn): Replace args READY and N_READY with a pointer to a\n+\tready_list; return void.  Use the new functions to access the ready\n+\tlist.  All callers changed.\n+\t(queue_to_ready, debug_ready_list): Likewise.\n+\t(schedule_block): Initialize a ready_list structure.  Use new\n+\tfunctions to access it.\n+\t(max_priority): Remove unused variable.\n+\t(schedule_insn): Don't set it.\n+\n \t* c-common.c (verify_tree): Don't recurse into CONSTRUCTORs.\n \n \t* combine.c (cant_combine_insn_p): New function."}, {"sha": "6ad7441f9e7967d35dd4cc93bc291763e80a4549", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 128, "deletions": 57, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176f9a7b1c1a668cde299dc350b949c88658b84c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176f9a7b1c1a668cde299dc350b949c88658b84c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=176f9a7b1c1a668cde299dc350b949c88658b84c", "patch": "@@ -477,6 +477,22 @@ static int q_size = 0;\n #define NEXT_Q(X) (((X)+1) & (INSN_QUEUE_SIZE-1))\n #define NEXT_Q_AFTER(X, C) (((X)+C) & (INSN_QUEUE_SIZE-1))\n \n+/* Describe the ready list of the scheduler.\n+   VEC holds space enough for all insns in the current region.  VECLEN\n+   says how many exactly.\n+   FIRST is the index of the element with the highest priority; i.e. the\n+   last one in the ready list, since elements are ordered by ascending\n+   priority.\n+   N_READY determines how many insns are on the ready list.  */\n+\n+struct ready_list\n+{\n+  rtx *vec;\n+  int veclen;\n+  int first;\n+  int n_ready;\n+};\n+\n /* Forward declarations.  */\n static void add_dependence PARAMS ((rtx, rtx, enum reg_note));\n static void remove_dependence PARAMS ((rtx, rtx));\n@@ -502,7 +518,7 @@ static void sched_analyze PARAMS ((struct deps *, rtx, rtx));\n static int rank_for_schedule PARAMS ((const PTR, const PTR));\n static void swap_sort PARAMS ((rtx *, int));\n static void queue_insn PARAMS ((rtx, int));\n-static int schedule_insn PARAMS ((rtx, rtx *, int, int));\n+static void schedule_insn PARAMS ((rtx, struct ready_list *, int));\n static void find_insn_reg_weight PARAMS ((int));\n static int schedule_block PARAMS ((int, int));\n static char *safe_concat PARAMS ((char *, char *, const char *));\n@@ -773,9 +789,14 @@ static rtx reemit_notes PARAMS ((rtx, rtx));\n static void get_block_head_tail PARAMS ((int, rtx *, rtx *));\n static void get_bb_head_tail PARAMS ((int, rtx *, rtx *));\n \n-static int queue_to_ready PARAMS ((rtx[], int));\n+static void ready_add PARAMS ((struct ready_list *, rtx));\n+static rtx *ready_lastpos PARAMS ((struct ready_list *));\n+static void ready_sort PARAMS ((struct ready_list *));\n+static rtx ready_remove_first PARAMS ((struct ready_list *));\n \n-static void debug_ready_list PARAMS ((rtx[], int));\n+static void queue_to_ready PARAMS ((struct ready_list *));\n+\n+static void debug_ready_list PARAMS ((struct ready_list *));\n static void init_target_units PARAMS ((void));\n static void insn_print_units PARAMS ((rtx));\n static int get_visual_tbl_length PARAMS ((void));\n@@ -4184,8 +4205,6 @@ swap_sort (a, n)\n   a[i + 1] = insn;\n }\n \n-static int max_priority;\n-\n /* Add INSN to the insn queue so that it can be executed at least\n    N_CYCLES after the currently executing insn.  Preserve insns\n    chain for debugging purposes.  */\n@@ -4209,7 +4228,66 @@ queue_insn (insn, n_cycles)\n \n       fprintf (dump, \"queued for %d cycles.\\n\", n_cycles);\n     }\n+}\n+\n+/* Return a pointer to the bottom of the ready list, i.e. the insn\n+   with the lowest priority.  */\n+\n+HAIFA_INLINE static rtx *\n+ready_lastpos (ready)\n+     struct ready_list *ready;\n+{\n+  if (ready->n_ready == 0)\n+    abort ();\n+  return ready->vec + ready->first - ready->n_ready + 1;\n+}\n+\n+/* Add an element INSN to the ready list so that it ends up with the lowest\n+   priority.  */\n+\n+HAIFA_INLINE static void\n+ready_add (ready, insn)\n+     struct ready_list *ready;\n+     rtx insn;\n+{\n+  if (ready->first == ready->n_ready)\n+    {\n+      memmove (ready->vec + ready->veclen - ready->n_ready,\n+\t       ready_lastpos (ready),\n+\t       ready->n_ready * sizeof (rtx));\n+      ready->first = ready->veclen - 1;\n+    }\n+  ready->vec[ready->first - ready->n_ready] = insn;\n+  ready->n_ready++;\n+}\n \n+/* Remove the element with the highest priority from the ready list and\n+   return it.  */\n+\n+HAIFA_INLINE static rtx\n+ready_remove_first (ready)\n+     struct ready_list *ready;\n+{\n+  rtx t;\n+  if (ready->n_ready == 0)\n+    abort ();\n+  t = ready->vec[ready->first--];\n+  ready->n_ready--;\n+  /* If the queue becomes empty, reset it.  */\n+  if (ready->n_ready == 0)\n+    ready->first = ready->veclen - 1;\n+  return t;\n+}\n+\n+/* Sort the ready list READY by ascending priority, using the SCHED_SORT\n+   macro.  */\n+\n+HAIFA_INLINE static void\n+ready_sort (ready)\n+     struct ready_list *ready;\n+{\n+  rtx *first = ready_lastpos (ready);\n+  SCHED_SORT (first, ready->n_ready);\n }\n \n /* PREV is an insn that is ready to execute.  Adjust its priority if that\n@@ -4236,15 +4314,14 @@ adjust_priority (prev)\n static int last_clock_var;\n \n /* INSN is the \"currently executing insn\".  Launch each insn which was\n-   waiting on INSN.  READY is a vector of insns which are ready to fire.\n-   N_READY is the number of elements in READY.  CLOCK is the current\n-   cycle.  */\n+   waiting on INSN.  READY is the ready list which contains the insns\n+   that are ready to fire.  CLOCK is the current cycle.\n+   */\n \n-static int\n-schedule_insn (insn, ready, n_ready, clock)\n+static void\n+schedule_insn (insn, ready, clock)\n      rtx insn;\n-     rtx *ready;\n-     int n_ready;\n+     struct ready_list *ready;\n      int clock;\n {\n   rtx link;\n@@ -4267,13 +4344,7 @@ schedule_insn (insn, ready, n_ready, clock)\n     schedule_unit (unit, insn, clock);\n \n   if (INSN_DEPEND (insn) == 0)\n-    return n_ready;\n-\n-  /* This is used by the function adjust_priority above.  */\n-  if (n_ready > 0)\n-    max_priority = MAX (INSN_PRIORITY (ready[0]), INSN_PRIORITY (insn));\n-  else\n-    max_priority = INSN_PRIORITY (insn);\n+    return;\n \n   for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n     {\n@@ -4315,7 +4386,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \t     list or queue it.  */\n \t  adjust_priority (next);\n \t  if (effective_cost < 1)\n-\t    ready[n_ready++] = next;\n+\t    ready_add (ready, next);\n \t  else\n \t    queue_insn (next, effective_cost);\n \t}\n@@ -4331,8 +4402,6 @@ schedule_insn (insn, ready, n_ready, clock)\n       PUT_MODE (insn, clock > last_clock_var ? TImode : VOIDmode);\n       last_clock_var = clock;\n     }\n-\n-  return n_ready;\n }\n \n /* Functions for handling of notes.  */\n@@ -4729,10 +4798,9 @@ static int clock_var;\n \n /* Move insns that became ready to fire from queue to ready list.  */\n \n-static int\n-queue_to_ready (ready, n_ready)\n-     rtx ready[];\n-     int n_ready;\n+static void\n+queue_to_ready (ready)\n+     struct ready_list *ready;\n {\n   rtx insn;\n   rtx link;\n@@ -4743,7 +4811,6 @@ queue_to_ready (ready, n_ready)\n      ready list.  */\n   for (link = insn_queue[q_ptr]; link; link = XEXP (link, 1))\n     {\n-\n       insn = XEXP (link, 0);\n       q_size -= 1;\n \n@@ -4753,15 +4820,15 @@ queue_to_ready (ready, n_ready)\n       if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n \tfprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n \n-      ready[n_ready++] = insn;\n+      ready_add (ready, insn);\n       if (sched_verbose >= 2)\n \tfprintf (dump, \"moving to ready without stalls\\n\");\n     }\n   insn_queue[q_ptr] = 0;\n \n   /* If there are no ready insns, stall until one is ready and add all\n      of the pending insns at that point to the ready list.  */\n-  if (n_ready == 0)\n+  if (ready->n_ready == 0)\n     {\n       register int stalls;\n \n@@ -4781,13 +4848,13 @@ queue_to_ready (ready, n_ready)\n \t\t  if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n \t\t    fprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n \n-\t\t  ready[n_ready++] = insn;\n+\t\t  ready_add (ready, insn);\n \t\t  if (sched_verbose >= 2)\n \t\t    fprintf (dump, \"moving to ready with %d stalls\\n\", stalls);\n \t\t}\n \t      insn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = 0;\n \n-\t      if (n_ready)\n+\t      if (ready->n_ready)\n \t\tbreak;\n \t    }\n \t}\n@@ -4797,23 +4864,26 @@ queue_to_ready (ready, n_ready)\n       q_ptr = NEXT_Q_AFTER (q_ptr, stalls);\n       clock_var += stalls;\n     }\n-  return n_ready;\n }\n \n /* Print the ready list for debugging purposes.  Callable from debugger.  */\n \n static void\n-debug_ready_list (ready, n_ready)\n-     rtx ready[];\n-     int n_ready;\n+debug_ready_list (ready)\n+     struct ready_list *ready;\n {\n+  rtx *p;\n   int i;\n \n-  for (i = 0; i < n_ready; i++)\n+  if (ready->n_ready == 0)\n+    return;\n+\n+  p = ready_lastpos (ready);\n+  for (i = 0; i < ready->n_ready; i++)\n     {\n-      fprintf (dump, \"  %d\", INSN_UID (ready[i]));\n-      if (current_nr_blocks > 1 && INSN_BB (ready[i]) != target_bb)\n-\tfprintf (dump, \"/b%d\", BLOCK_NUM (ready[i]));\n+      fprintf (dump, \"  %d\", INSN_UID (p[i]));\n+      if (current_nr_blocks > 1 && INSN_BB (p[i]) != target_bb)\n+\tfprintf (dump, \"/b%d\", BLOCK_NUM (p[i]));\n     }\n   fprintf (dump, \"\\n\");\n }\n@@ -5817,8 +5887,7 @@ schedule_block (bb, rgn_n_insns)\n {\n   /* Local variables.  */\n   rtx insn, last;\n-  rtx *ready;\n-  int n_ready = 0;\n+  struct ready_list ready;\n   int can_issue_more;\n \n   /* Flow block of this bb.  */\n@@ -5933,15 +6002,17 @@ schedule_block (bb, rgn_n_insns)\n   clear_units ();\n \n   /* Allocate the ready list.  */\n-  ready = (rtx *) xmalloc ((rgn_n_insns + 1) * sizeof (rtx));\n+  ready.veclen = rgn_n_insns + 1 + ISSUE_RATE;\n+  ready.first = ready.veclen - 1;\n+  ready.vec = (rtx *) xmalloc (ready.veclen * sizeof (rtx));\n+  ready.n_ready = 0;\n \n   /* Print debugging information.  */\n   if (sched_verbose >= 5)\n     debug_dependencies ();\n \n   /* Initialize ready list with all 'ready' insns in target block.\n      Count number of insns in the target block being scheduled.  */\n-  n_ready = 0;\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n       rtx next;\n@@ -5952,7 +6023,7 @@ schedule_block (bb, rgn_n_insns)\n \n       if (INSN_DEP_COUNT (insn) == 0\n \t  && (SCHED_GROUP_P (next) == 0 || ! INSN_P (next)))\n-\tready[n_ready++] = insn;\n+\tready_add (&ready, insn);\n       if (!(SCHED_GROUP_P (insn)))\n \ttarget_n_insns++;\n     }\n@@ -5995,7 +6066,7 @@ schedule_block (bb, rgn_n_insns)\n \t\t    && (! next\n \t\t\t|| SCHED_GROUP_P (next) == 0\n \t\t\t|| ! INSN_P (next)))\n-\t\t  ready[n_ready++] = insn;\n+\t\t  ready_add (&ready, insn);\n \t      }\n \t  }\n       }\n@@ -6034,40 +6105,40 @@ schedule_block (bb, rgn_n_insns)\n          If there are no ready insns, increment clock until one\n          is ready and add all pending insns at that point to the ready\n          list.  */\n-      n_ready = queue_to_ready (ready, n_ready);\n+      queue_to_ready (&ready);\n \n-      if (n_ready == 0)\n+      if (ready.n_ready == 0)\n \tabort ();\n \n       if (sched_verbose >= 2)\n \t{\n \t  fprintf (dump, \";;\\t\\tReady list after queue_to_ready:  \");\n-\t  debug_ready_list (ready, n_ready);\n+\t  debug_ready_list (&ready);\n \t}\n \n       /* Sort the ready list based on priority.  */\n-      SCHED_SORT (ready, n_ready);\n+      ready_sort (&ready);\n \n       /* Allow the target to reorder the list, typically for\n \t better instruction bundling.  */\n #ifdef MD_SCHED_REORDER\n-      MD_SCHED_REORDER (dump, sched_verbose, ready, n_ready, clock_var,\n-\t\t\tcan_issue_more);\n+      MD_SCHED_REORDER (dump, sched_verbose, ready_lastpos (&ready),\n+\t\t\tready.n_ready, clock_var, can_issue_more);\n #else\n       can_issue_more = issue_rate;\n #endif\n \n       if (sched_verbose)\n \t{\n \t  fprintf (dump, \"\\n;;\\tReady list (t =%3d):  \", clock_var);\n-\t  debug_ready_list (ready, n_ready);\n+\t  debug_ready_list (&ready);\n \t}\n \n       /* Issue insns from ready list.  */\n-      while (n_ready != 0 && can_issue_more)\n+      while (ready.n_ready != 0 && can_issue_more)\n \t{\n \t  /* Select and remove the insn from the ready list.  */\n-\t  rtx insn = ready[--n_ready];\n+\t  rtx insn = ready_remove_first (&ready);\n \t  int cost = actual_hazard (insn_unit (insn), insn, clock_var, 0);\n \n \t  if (cost >= 1)\n@@ -6148,7 +6219,7 @@ schedule_block (bb, rgn_n_insns)\n \t  can_issue_more--;\n #endif\n \n-\t  n_ready = schedule_insn (insn, ready, n_ready, clock_var);\n+\t  schedule_insn (insn, &ready, clock_var);\n \n \t  /* Close this block after scheduling its jump.  */\n \t  if (GET_CODE (last_scheduled_insn) == JUMP_INSN)\n@@ -6164,7 +6235,7 @@ schedule_block (bb, rgn_n_insns)\n   if (sched_verbose)\n     {\n       fprintf (dump, \";;\\tReady list (final):  \");\n-      debug_ready_list (ready, n_ready);\n+      debug_ready_list (&ready);\n       print_block_visualization (b, \"\");\n     }\n \n@@ -6220,7 +6291,7 @@ schedule_block (bb, rgn_n_insns)\n       free (bblst_table);\n       free (bitlst_table);\n     }\n-  free (ready);\n+  free (ready.vec);\n \n   return (sched_n_insns);\n }"}]}