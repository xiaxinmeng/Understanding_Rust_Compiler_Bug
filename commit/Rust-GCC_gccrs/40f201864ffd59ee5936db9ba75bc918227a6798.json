{"sha": "40f201864ffd59ee5936db9ba75bc918227a6798", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmMjAxODY0ZmZkNTllZTU5MzZkYjliYTc1YmM5MTgyMjdhNjc5OA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-25T16:50:13Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-25T16:50:13Z"}, "message": "re PR fortran/17144 (Not Implemented: Character string array constructors / Assignment to char array)\n\n\tPR fortran/17144\n\t* trans-array.c (gfc_trans_allocate_temp_array): Remove\n\tstring_length argument.\n\t(gfc_trans_array_ctor_element): New function.\n\t(gfc_trans_array_constructor_subarray): Use it.\n\t(gfc_trans_array_constructor_value): Ditto.  Handle constant\n\tcharacter arrays.\n\t(get_array_ctor_var_strlen, get_array_ctor_strlen): New functions.\n\t(gfc_trans_array_constructor): Use them.\n\t(gfc_add_loop_ss_code): Update to new gfc_ss layout.\n\t(gfc_conv_ss_descriptor): Remember section string length.\n\t(gfc_conv_scalarized_array_ref): Ditto.  Remove dead code.\n\t(gfc_conv_resolve_dependencies): Update to new gfc_ss layout.\n\t(gfc_conv_expr_descriptor): Ditto.\n\t(gfc_conv_loop_setup): Ditto.  Spelling fixes.\n\t* trans-array.h (gfc_trans_allocate_temp_array): Update prototype.\n\t* trans-const.c (gfc_conv_constant):  Update to new gfc_ss layout.\n\t* trans-expr.c (gfc_conv_component_ref): Turn error into ICE.\n\t(gfc_conv_variable): Set string_length from section.\n\t(gfc_conv_function_call): Remove extra argument.\n\t(gfc_conv_expr, gfc_conv_expr_reference): Update to new gfc_ss layout.\n\t* trans-types.c (gfc_get_character_type_len): New function.\n\t(gfc_get_character_type): Use it.\n\t(gfc_get_dtype): Return zero for internal types.\n\t* trans-types.h (gfc_get_character_type_len): Add prototype.\n\t* trans.h (struct gfc_ss): Move string_length out of union.\ntestsuite/\n\t* gfortran.dg/string_ctor_1.f90: New test.\n\nFrom-SVN: r86558", "tree": {"sha": "894c624fd13417c22a3668caf4fef82e9246c6b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/894c624fd13417c22a3668caf4fef82e9246c6b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40f201864ffd59ee5936db9ba75bc918227a6798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f201864ffd59ee5936db9ba75bc918227a6798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f201864ffd59ee5936db9ba75bc918227a6798", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f201864ffd59ee5936db9ba75bc918227a6798/comments", "author": null, "committer": null, "parents": [{"sha": "923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4"}], "stats": {"total": 352, "additions": 292, "deletions": 60}, "files": [{"sha": "85be102968294dca10b388cb4ec6955e1bf68f99", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -1,3 +1,32 @@\n+2004-08-25  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/17144\n+\t* trans-array.c (gfc_trans_allocate_temp_array): Remove\n+\tstring_length argument.\n+\t(gfc_trans_array_ctor_element): New function.\n+\t(gfc_trans_array_constructor_subarray): Use it.\n+\t(gfc_trans_array_constructor_value): Ditto.  Handle constant\n+\tcharacter arrays.\n+\t(get_array_ctor_var_strlen, get_array_ctor_strlen): New functions.\n+\t(gfc_trans_array_constructor): Use them.\n+\t(gfc_add_loop_ss_code): Update to new gfc_ss layout.\n+\t(gfc_conv_ss_descriptor): Remember section string length.\n+\t(gfc_conv_scalarized_array_ref): Ditto.  Remove dead code.\n+\t(gfc_conv_resolve_dependencies): Update to new gfc_ss layout.\n+\t(gfc_conv_expr_descriptor): Ditto.\n+\t(gfc_conv_loop_setup): Ditto.  Spelling fixes.\n+\t* trans-array.h (gfc_trans_allocate_temp_array): Update prototype.\n+\t* trans-const.c (gfc_conv_constant):  Update to new gfc_ss layout.\n+\t* trans-expr.c (gfc_conv_component_ref): Turn error into ICE.\n+\t(gfc_conv_variable): Set string_length from section.\n+\t(gfc_conv_function_call): Remove extra argument.\n+\t(gfc_conv_expr, gfc_conv_expr_reference): Update to new gfc_ss layout.\n+\t* trans-types.c (gfc_get_character_type_len): New function.\n+\t(gfc_get_character_type): Use it.\n+\t(gfc_get_dtype): Return zero for internal types.\n+\t* trans-types.h (gfc_get_character_type_len): Add prototype.\n+\t* trans.h (struct gfc_ss): Move string_length out of union.\n+\n 2004-08-25  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans.h (build2_v, build3_v): New macros."}, {"sha": "5bccd96cfd76c37055f04c97e6ba22c06f3e01d5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 177, "deletions": 42, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -527,7 +527,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \n tree\n gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n-\t\t\t       tree eltype, tree string_length)\n+\t\t\t       tree eltype)\n {\n   tree type;\n   tree desc;\n@@ -617,10 +617,6 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n       size = gfc_evaluate_now (size, &loop->pre);\n     }\n \n-  /* TODO: Where does the string length go?  */\n-  if (string_length)\n-    gfc_todo_error (\"temporary arrays of strings\");\n-\n   /* Get the size of the array.  */\n   nelem = size;\n   if (size)\n@@ -651,6 +647,55 @@ gfc_put_offset_into_var (stmtblock_t * pblock, tree * poffset,\n }\n \n \n+/* Assign an element of an array constructor.  */\n+\n+static void\n+gfc_trans_array_ctor_element (stmtblock_t * pblock, tree pointer,\n+\t\t\t      tree offset, gfc_se * se, gfc_expr * expr)\n+{\n+  tree tmp;\n+  tree args;\n+\n+  gfc_conv_expr (se, expr);\n+\n+  /* Store the value.  */\n+  tmp = gfc_build_indirect_ref (pointer);\n+  tmp = gfc_build_array_ref (tmp, offset);\n+  if (expr->ts.type == BT_CHARACTER)\n+    {\n+      gfc_conv_string_parameter (se);\n+      if (POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\t{\n+\t  /* The temporary is an array of pointers.  */\n+\t  se->expr = fold_convert (TREE_TYPE (tmp), se->expr);\n+\t  gfc_add_modify_expr (&se->pre, tmp, se->expr);\n+\t}\n+      else\n+\t{\n+\t  /* The temporary is an array of string values.  */\n+\t  tmp = gfc_build_addr_expr (pchar_type_node, tmp);\n+\t  /* We know the temporary and the value will be the same length,\n+\t     so can use memcpy.  */\n+\t  args = gfc_chainon_list (NULL_TREE, tmp);\n+\t  args = gfc_chainon_list (args, se->expr);\n+\t  args = gfc_chainon_list (args, se->string_length);\n+\t  tmp = built_in_decls[BUILT_IN_MEMCPY];\n+\t  tmp = gfc_build_function_call (tmp, args);\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t}\n+    }\n+  else\n+    {\n+      /* TODO: Should the frontend already have done this conversion?  */\n+      se->expr = fold_convert (TREE_TYPE (tmp), se->expr);\n+      gfc_add_modify_expr (&se->pre, tmp, se->expr);\n+    }\n+\n+  gfc_add_block_to_block (pblock, &se->pre);\n+  gfc_add_block_to_block (pblock, &se->post);\n+}\n+\n+\n /* Add the contents of an array to the constructor.  */\n \n static void\n@@ -688,21 +733,17 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   gfc_copy_loopinfo_to_se (&se, &loop);\n   se.ss = ss;\n \n-  gfc_conv_expr (&se, expr);\n-  gfc_add_block_to_block (&body, &se.pre);\n+  if (expr->ts.type == BT_CHARACTER)\n+    gfc_todo_error (\"character arrays in constructors\");\n \n-  /* Store the value.  */\n-  tmp = gfc_build_indirect_ref (pointer);\n-  tmp = gfc_build_array_ref (tmp, *poffset);\n-  gfc_add_modify_expr (&body, tmp, se.expr);\n+  gfc_trans_array_ctor_element (&body, pointer, *poffset, &se, expr);\n+  assert (se.ss == gfc_ss_terminator);\n \n   /* Increment the offset.  */\n   tmp = build2 (PLUS_EXPR, gfc_array_index_type, *poffset, gfc_index_one_node);\n   gfc_add_modify_expr (&body, *poffset, tmp);\n \n   /* Finish the loop.  */\n-  gfc_add_block_to_block (&body, &se.post);\n-  assert (se.ss == gfc_ss_terminator);\n   gfc_trans_scalarizing_loops (&loop, &body);\n   gfc_add_block_to_block (&loop.pre, &loop.post);\n   tmp = gfc_finish_block (&loop.pre);\n@@ -720,7 +761,6 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t   tree * poffset, tree * offsetvar)\n {\n   tree tmp;\n-  tree ref;\n   stmtblock_t body;\n   tree loopbody;\n   gfc_se se;\n@@ -763,14 +803,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t    {\n \t      /* Scalar values.  */\n \t      gfc_init_se (&se, NULL);\n-\t      gfc_conv_expr (&se, c->expr);\n-\t      gfc_add_block_to_block (&body, &se.pre);\n-\n-\t      ref = gfc_build_indirect_ref (pointer);\n-\t      ref = gfc_build_array_ref (ref, *poffset);\n-\t      gfc_add_modify_expr (&body, ref,\n-\t\t\t\t   fold_convert (TREE_TYPE (ref), se.expr));\n-\t      gfc_add_block_to_block (&body, &se.post);\n+\t      gfc_trans_array_ctor_element (&body, pointer, *poffset, &se,\n+\t\t\t\t\t    c->expr);\n \n \t      *poffset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t\t       *poffset, gfc_index_one_node));\n@@ -791,6 +825,16 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t{\n \t\t  gfc_init_se (&se, NULL);\n \t\t  gfc_conv_constant (&se, p->expr);\n+\t\t  if (p->expr->ts.type == BT_CHARACTER\n+\t\t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE\n+\t\t\t  (TREE_TYPE (pointer)))))\n+\t\t    {\n+\t\t      /* For constant character array constructors we build\n+\t\t\t an array of pointers.  */\n+\t\t      se.expr = gfc_build_addr_expr (pchar_type_node,\n+\t\t\t\t\t\t      se.expr);\n+\t\t    }\n+\t\t    \n \t\t  list = tree_cons (NULL_TREE, se.expr, list);\n \t\t  c = p;\n \t\t  p = p->next;\n@@ -974,6 +1018,86 @@ gfc_get_array_cons_size (mpz_t * size, gfc_constructor * c)\n }\n \n \n+/* Figure out the string length of a variable reference expression.\n+   Used by get_array_ctor_strlen.  */\n+\n+static void\n+get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n+{\n+  gfc_ref *ref;\n+  gfc_typespec *ts;\n+\n+  /* Don't bother if we already know the length is a constant.  */\n+  if (*len && INTEGER_CST_P (*len))\n+    return;\n+\n+  ts = &expr->symtree->n.sym->ts;\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    {\n+      switch (ref->type)\n+\t{\n+\tcase REF_ARRAY:\n+\t  /* Array references don't change teh sting length.  */\n+\t  break;\n+\n+\tcase COMPONENT_REF:\n+\t  /* Use the length of the component. */\n+\t  ts = &ref->u.c.component->ts;\n+\t  break;\n+\n+\tdefault:\n+\t  /* TODO: Substrings are tricky because we can't evaluate the\n+\t     expression more than once.  For now we just give up, and hope\n+\t     we can figure it out elsewhere.  */\n+\t  return;\n+\t}\n+    }\n+\n+  *len = ts->cl->backend_decl;\n+}\n+\n+\n+/* Figure out the string length of a character array constructor.\n+   Returns TRUE if all elements are character constants.  */\n+\n+static bool\n+get_array_ctor_strlen (gfc_constructor * c, tree * len)\n+{\n+  bool is_const;\n+  \n+  is_const = TRUE;\n+  for (; c; c = c->next)\n+    {\n+      switch (c->expr->expr_type)\n+\t{\n+\tcase EXPR_CONSTANT:\n+\t  if (!(*len && INTEGER_CST_P (*len)))\n+\t    *len = build_int_cstu (gfc_strlen_type_node,\n+\t\t\t\t   c->expr->value.character.length);\n+\t  break;\n+\n+\tcase EXPR_ARRAY:\n+\t  if (!get_array_ctor_strlen (c->expr->value.constructor, len))\n+\t    is_const = FALSE;\n+\t  break;\n+\n+\tcase EXPR_VARIABLE:\n+\t  is_const = false;\n+\t  get_array_ctor_var_strlen (c->expr, len);\n+\t  break;\n+\n+\tdefault:\n+\t  is_const = FALSE;\n+\t  /* TODO: For now we just ignore anything we don't know how to\n+\t     handle, and hope we can figure it out a different way.  */\n+\t  break;\n+\t}\n+    }\n+\n+  return is_const;\n+}\n+\n+\n /* Array constructors are handled by constructing a temporary, then using that\n    within the scalarization loop.  This is not optimal, but seems by far the\n    simplest method.  */\n@@ -986,13 +1110,28 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n   tree desc;\n   tree size;\n   tree type;\n+  bool const_string;\n \n-  if (ss->expr->ts.type == BT_CHARACTER)\n-    gfc_todo_error (\"Character string array constructors\");\n-  type = gfc_typenode_for_spec (&ss->expr->ts);\n   ss->data.info.dimen = loop->dimen;\n-  size =\n-    gfc_trans_allocate_temp_array (loop, &ss->data.info, type, NULL_TREE);\n+\n+  if (ss->expr->ts.type == BT_CHARACTER)\n+    {\n+      const_string = get_array_ctor_strlen (ss->expr->value.constructor,\n+\t\t\t\t\t    &ss->string_length);\n+      if (!ss->string_length)\n+\tgfc_todo_error (\"complex character array constructors\");\n+\n+      type = gfc_get_character_type_len (ss->expr->ts.kind, ss->string_length);\n+      if (const_string)\n+\ttype = build_pointer_type (type);\n+    }\n+  else\n+    {\n+      const_string = TRUE;\n+      type = gfc_typenode_for_spec (&ss->expr->ts);\n+    }\n+\n+  size = gfc_trans_allocate_temp_array (loop, &ss->data.info, type);\n \n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n@@ -1057,7 +1196,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n             gfc_add_block_to_block (&loop->post, &se.post);\n \n \t  ss->data.scalar.expr = se.expr;\n-\t  ss->data.scalar.string_length = se.string_length;\n+\t  ss->string_length = se.string_length;\n \t  break;\n \n \tcase GFC_SS_REFERENCE:\n@@ -1068,7 +1207,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n \t  gfc_add_block_to_block (&loop->post, &se.post);\n \n \t  ss->data.scalar.expr = gfc_evaluate_now (se.expr, &loop->pre);\n-\t  ss->data.scalar.string_length = se.string_length;\n+\t  ss->string_length = se.string_length;\n \t  break;\n \n \tcase GFC_SS_SECTION:\n@@ -1129,6 +1268,7 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n   gfc_conv_expr_lhs (&se, ss->expr);\n   gfc_add_block_to_block (block, &se.pre);\n   ss->data.info.descriptor = se.expr;\n+  ss->string_length = se.string_length;\n \n   if (base)\n     {\n@@ -1496,11 +1636,7 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n void\n gfc_conv_tmp_array_ref (gfc_se * se)\n {\n-  tree desc;\n-\n-  desc = se->ss->data.info.descriptor;\n-  /* TODO: We need the string length for string variables.  */\n-\n+  se->string_length = se->ss->string_length;\n   gfc_conv_scalarized_array_ref (se, NULL);\n }\n \n@@ -2247,7 +2383,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n       loop->temp_ss->type = GFC_SS_TEMP;\n       loop->temp_ss->data.temp.type =\n \tgfc_get_element_type (TREE_TYPE (dest->data.info.descriptor));\n-      loop->temp_ss->data.temp.string_length = NULL_TREE;\n+      loop->temp_ss->string_length = NULL_TREE;\n       loop->temp_ss->data.temp.dimen = loop->dimen;\n       loop->temp_ss->next = gfc_ss_terminator;\n       gfc_add_ss_to_loop (loop, loop->temp_ss);\n@@ -2295,7 +2431,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t  if (ss->type == GFC_SS_CONSTRUCTOR)\n \t    {\n \t      /* An unknown size constructor will always be rank one.\n-\t\t Higher rank constructors will wither have known shape,\n+\t\t Higher rank constructors will either have known shape,\n \t\t or still be wrapped in a call to reshape.  */\n \t      assert (loop->dimen == 1);\n \t      /* Try to figure out the size of the constructor.  */\n@@ -2337,7 +2473,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t   */\n \t  if (!specinfo)\n \t    loopspec[n] = ss;\n-\t  /* TODO: Is != contructor correct?  */\n+\t  /* TODO: Is != constructor correct?  */\n \t  else if (loopspec[n]->type != GFC_SS_CONSTRUCTOR)\n \t    {\n \t      if (integer_onep (info->stride[n])\n@@ -2433,13 +2569,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n     {\n       assert (loop->temp_ss->type == GFC_SS_TEMP);\n       tmp = loop->temp_ss->data.temp.type;\n-      len = loop->temp_ss->data.temp.string_length;\n+      len = loop->temp_ss->string_length;\n       n = loop->temp_ss->data.temp.dimen;\n       memset (&loop->temp_ss->data.info, 0, sizeof (gfc_ss_info));\n       loop->temp_ss->type = GFC_SS_SECTION;\n       loop->temp_ss->data.info.dimen = n;\n-      gfc_trans_allocate_temp_array (loop, &loop->temp_ss->data.info,\n-\t\t\t\t     tmp, len);\n+      gfc_trans_allocate_temp_array (loop, &loop->temp_ss->data.info, tmp);\n     }\n \n   for (n = 0; n < loop->temp_dim; n++)\n@@ -3502,10 +3637,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n       /* Which can hold our string, if present.  */\n       if (expr->ts.type == BT_CHARACTER)\n-\tse->string_length = loop.temp_ss->data.temp.string_length\n+\tse->string_length = loop.temp_ss->string_length\n \t  = TYPE_SIZE_UNIT (loop.temp_ss->data.temp.type);\n       else\n-\tloop.temp_ss->data.temp.string_length = NULL;\n+\tloop.temp_ss->string_length = NULL;\n       loop.temp_ss->data.temp.dimen = loop.dimen;\n       gfc_add_ss_to_loop (&loop, loop.temp_ss);\n     }"}, {"sha": "9cd0fcecd78dae5f9b5c92bcb4af7cfc61292b0d", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -27,8 +27,7 @@ tree gfc_array_deallocate (tree);\n void gfc_array_allocate (gfc_se *, gfc_ref *, tree);\n \n /* Generate code to allocate a temporary array.  */\n-tree gfc_trans_allocate_temp_array (gfc_loopinfo *, gfc_ss_info *, tree,\n-\t\t\t\t    tree);\n+tree gfc_trans_allocate_temp_array (gfc_loopinfo *, gfc_ss_info *, tree);\n \n /* Generate function entry code for allocation of compiler allocated array\n    variables.  */"}, {"sha": "8ea0d5cc1191d12dc6d62dff0d9bcb73a4c64f34", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -353,7 +353,7 @@ gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n       assert (se->ss->expr == expr);\n \n       se->expr = se->ss->data.scalar.expr;\n-      se->string_length = se->ss->data.scalar.string_length;\n+      se->string_length = se->ss->string_length;\n       gfc_advance_se_ss_chain (se);\n       return;\n     }"}, {"sha": "cbf2dd1fb67462b514ca415b53ca661077dc84c7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -231,9 +231,8 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   if (c->ts.type == BT_CHARACTER)\n     {\n       tmp = c->ts.cl->backend_decl;\n-      assert (tmp);\n-      if (!INTEGER_CST_P (tmp))\n-\tgfc_todo_error (\"Unknown length character component\");\n+      /* Components must always be constant length.  */\n+      assert (tmp && INTEGER_CST_P (tmp));\n       se->string_length = tmp;\n     }\n \n@@ -260,6 +259,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \n       /* A scalarized term.  We already know the descriptor.  */\n       se->expr = se->ss->data.info.descriptor;\n+      se->string_length = se->ss->string_length;\n       ref = se->ss->data.info.ref;\n     }\n   else\n@@ -1040,7 +1040,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  tmp = gfc_typenode_for_spec (&sym->ts);\n \t  info->dimen = se->loop->dimen;\n \t  /* Allocate a temporary to store the result.  */\n-\t  gfc_trans_allocate_temp_array (se->loop, info, tmp, NULL_TREE);\n+\t  gfc_trans_allocate_temp_array (se->loop, info, tmp);\n \n \t  /* Zero the first stride to indicate a temporary.  */\n \t  tmp =\n@@ -1711,7 +1711,7 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n       /* Substitute a scalar expression evaluated outside the scalarization\n          loop.  */\n       se->expr = se->ss->data.scalar.expr;\n-      se->string_length = se->ss->data.scalar.string_length;\n+      se->string_length = se->ss->string_length;\n       gfc_advance_se_ss_chain (se);\n       return;\n     }\n@@ -1799,7 +1799,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n       && se->ss->type == GFC_SS_REFERENCE)\n     {\n       se->expr = se->ss->data.scalar.expr;\n-      se->string_length = se->ss->data.scalar.string_length;\n+      se->string_length = se->ss->string_length;\n       gfc_advance_se_ss_chain (se);\n       return;\n     }"}, {"sha": "e88842d1a21610d32846724ec3c9c9a0352e4dc0", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -267,15 +267,14 @@ gfc_get_logical_type (int kind)\n     }\n }\n \f\n-/* Get a type node for a character kind.  */\n+/* Create a character type with the given kind and length.  */\n \n tree\n-gfc_get_character_type (int kind, gfc_charlen * cl)\n+gfc_get_character_type_len (int kind, tree len)\n {\n   tree base;\n-  tree type;\n-  tree len;\n   tree bounds;\n+  tree type;\n \n   switch (kind)\n     {\n@@ -287,14 +286,25 @@ gfc_get_character_type (int kind, gfc_charlen * cl)\n       fatal_error (\"character kind=%d not available\", kind);\n     }\n \n-  len = (cl == 0) ? NULL_TREE : cl->backend_decl;\n-\n   bounds = build_range_type (gfc_array_index_type, gfc_index_one_node, len);\n   type = build_array_type (base, bounds);\n   TYPE_STRING_FLAG (type) = 1;\n \n   return type;\n }\n+\n+\n+/* Get a type node for a character kind.  */\n+\n+tree\n+gfc_get_character_type (int kind, gfc_charlen * cl)\n+{\n+  tree len;\n+\n+  len = (cl == NULL) ? NULL_TREE : cl->backend_decl;\n+\n+  return gfc_get_character_type_len (kind, len);\n+}\n \f\n /* Covert a basic type.  This will be an array for character types.  */\n \n@@ -480,6 +490,9 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n   return 1;\n }\n \n+\n+/* Create an array descriptor type.  */\n+\n static tree\n gfc_build_array_type (tree type, gfc_array_spec * as)\n {\n@@ -584,7 +597,9 @@ gfc_get_dtype (tree type, int rank)\n       break;\n \n     default:\n-      abort ();\n+      /* TODO: Don't do dtype for temporary descriptorless arrays.  */\n+      /* We can strange array types for temporary arrays.  */\n+      return gfc_index_zero_node;\n     }\n \n   assert (rank <= GFC_DTYPE_RANK_MASK);"}, {"sha": "ebab5a1acc0bb9283d13ac549772ba54771c0c8e", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -112,6 +112,7 @@ tree gfc_get_real_type (int);\n tree gfc_get_complex_type (int);\n tree gfc_get_logical_type (int);\n tree gfc_get_character_type (int, gfc_charlen *);\n+tree gfc_get_character_type_len (int, tree);\n \n tree gfc_sym_type (gfc_symbol *);\n tree gfc_typenode_for_spec (gfc_typespec *);"}, {"sha": "504504689ecb7b5e6f75f93ef2fc611092747ef3", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -162,13 +162,13 @@ typedef struct gfc_ss\n   gfc_ss_type type;\n   gfc_expr *expr;\n   mpz_t *shape;\n+  tree string_length;\n   union\n   {\n     /* If type is GFC_SS_SCALAR or GFC_SS_REFERENCE.  */\n     struct\n     {\n       tree expr;\n-      tree string_length;\n     }\n     scalar;\n \n@@ -179,7 +179,6 @@ typedef struct gfc_ss\n          assigned expression.  */\n       int dimen;\n       tree type;\n-      tree string_length;\n     }\n     temp;\n     /* All other types.  */"}, {"sha": "888b38a94d2191fe384b2bf1e49b39c086f8beb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -1,3 +1,8 @@\n+2004-08-25  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/17144\n+\t* gfortran.dg/string_ctor_1.f90: New test.\n+\n 2004-08-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/14428"}, {"sha": "3242ea8f9e38667358056344128a965d49050273", "filename": "gcc/testsuite/gfortran.dg/string_ctor_1.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_ctor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f201864ffd59ee5936db9ba75bc918227a6798/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_ctor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_ctor_1.f90?ref=40f201864ffd59ee5936db9ba75bc918227a6798", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! Program to test character array constructors.\n+! PR17144\n+subroutine test1 (n, t, u)\n+  integer n\n+  character(len=n) :: s(2)\n+  character(len=*) :: t\n+  character(len=*) :: u\n+\n+  ! A variable array constructor.\n+  s = (/t, u/)\n+  ! An array constructor as part of an expression.\n+  if (any (s .ne. (/\"Hell\", \"Worl\"/))) call abort\n+end subroutine\n+\n+subroutine test2\n+  character*5 :: s(2)\n+\n+  ! A constant array constructor\n+  s = (/\"Hello\", \"World\"/)\n+  if ((s(1) .ne. \"Hello\") .or. (s(2) .ne. \"World\")) call abort\n+end subroutine\n+\n+subroutine test3\n+  character*1 s(26)\n+  character*26 t\n+  integer i\n+\n+  ! A large array constructor\n+  s = (/'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', &\n+        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'/)\n+  do i=1, 26\n+    t(i:i) = s(i)\n+  end do\n+\n+  ! Assignment with dependency\n+  s = (/(s(27-i), i=1, 26)/)\n+  do i=1, 26\n+    t(i:i) = s(i)\n+  end do\n+  if (t .ne. \"zyxwvutsrqponmlkjihgfedcba\") call abort\n+end subroutine\n+\n+program string_ctor_1\n+  call test1 (4, \"Hello\", \"World\")\n+  call test2\n+  call test3\n+end program\n+"}]}