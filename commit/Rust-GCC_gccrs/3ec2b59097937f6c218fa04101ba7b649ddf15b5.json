{"sha": "3ec2b59097937f6c218fa04101ba7b649ddf15b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VjMmI1OTA5NzkzN2Y2YzIxOGZhMDQxMDFiYTdiNjQ5ZGRmMTViNQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-01-27T15:45:50Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-01-27T15:45:50Z"}, "message": "rtl.h (insn_first_p): Declare.\n\n\t* rtl.h (insn_first_p): Declare.\n\t* rtlanal.c (insn_first_p): New function.\n\t* loop.h (varray.h): Include.\n\t(struct induction): Change combined_with to unsigned.\n\tNew members derived, ix and last_use.\n\t(reg_iv_type, reg_iv_info): Now varray_type.  All references changed.\n\t(REG_IV_TYPE, REG_IV_INFO): Define.\n\t(first_increment_giv, last_increment_giv): Declare.\n\t* loop.c (loop_number_loop_cont): New static variable.\n\t(loop_number_cont_dominator): Likewise.\n\t(reg_iv_type, reg_iv_info): Now varray_type.\n\t(first_increment_giv, last_increment_giv): New variables.\n\t(compute_luids, verify_dominator, find_life_end): New functions.\n\t(cmp_recombine_givs_stats, recombine_givs): Likewise.\n\t(loop_optimize): Allocate loop_number_loop_cont and\n\tloop_number_cont_dominator.  Use compute_luids.\n\t(find_and_verify_loops): Initialize loop_number_loop_cont and\n\tloop_number_cont_dominator.\n\t(strength_reduce): Try to find bivs that can be expressed as givs\n\tof another biv, and to convert biv increments into givs.\n\tCall recombine_givs.  Handle derived givs.\n\t(record_biv): New argument location.  All callers changed.\n\t(record_giv): Initialize derived and last_use fields.\n\t(basic_induction_var): New argument location.  All callers changed.\n\t(combine_givs): Don't combine a DEST_REG giv with a DEST_ADDR giv.\n\tIncrement combined_with instead of setting to 1.\n\t* unroll.c (derived_regs): New static variable.\n\t(unroll_loop): Initialize it.\n\tAllocate local_regno according to max_reg_num.\n\t(copy_loop_body): Cope with derived givs.\n\t(find_splittable_givs): Check for Givs made from biv increments.\n\tSet derived_regs for givs.\n\t* Makefile.in (stmt.o, loop.o, unroll.o): Depend on loop.h .\n\nFrom-SVN: r24889", "tree": {"sha": "40543c10fc8ef8193cefb6be07456d72f2575894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40543c10fc8ef8193cefb6be07456d72f2575894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ec2b59097937f6c218fa04101ba7b649ddf15b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec2b59097937f6c218fa04101ba7b649ddf15b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec2b59097937f6c218fa04101ba7b649ddf15b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec2b59097937f6c218fa04101ba7b649ddf15b5/comments", "author": null, "committer": null, "parents": [{"sha": "a9c70c222668111f1e5924c5a383f7d10057866d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c70c222668111f1e5924c5a383f7d10057866d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c70c222668111f1e5924c5a383f7d10057866d"}], "stats": {"total": 1134, "additions": 1040, "deletions": 94}, "files": [{"sha": "c11933cbaf4c04fe28f443fd68de5acb5a919abe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ec2b59097937f6c218fa04101ba7b649ddf15b5", "patch": "@@ -1,3 +1,39 @@\n+Wed Jan 27 23:39:53 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* rtl.h (insn_first_p): Declare.\n+\t* rtlanal.c (insn_first_p): New function.\n+\t* loop.h (varray.h): Include.\n+\t(struct induction): Change combined_with to unsigned.\n+\tNew members derived, ix and last_use.\n+\t(reg_iv_type, reg_iv_info): Now varray_type.  All references changed.\n+\t(REG_IV_TYPE, REG_IV_INFO): Define.\n+\t(first_increment_giv, last_increment_giv): Declare.\n+\t* loop.c (loop_number_loop_cont): New static variable.\n+\t(loop_number_cont_dominator): Likewise.\n+\t(reg_iv_type, reg_iv_info): Now varray_type.\n+\t(first_increment_giv, last_increment_giv): New variables.\n+\t(compute_luids, verify_dominator, find_life_end): New functions.\n+\t(cmp_recombine_givs_stats, recombine_givs): Likewise.\n+\t(loop_optimize): Allocate loop_number_loop_cont and\n+\tloop_number_cont_dominator.  Use compute_luids.\n+\t(find_and_verify_loops): Initialize loop_number_loop_cont and\n+\tloop_number_cont_dominator.\n+\t(strength_reduce): Try to find bivs that can be expressed as givs\n+\tof another biv, and to convert biv increments into givs.\n+\tCall recombine_givs.  Handle derived givs.\n+\t(record_biv): New argument location.  All callers changed.\n+\t(record_giv): Initialize derived and last_use fields.\n+\t(basic_induction_var): New argument location.  All callers changed.\n+\t(combine_givs): Don't combine a DEST_REG giv with a DEST_ADDR giv.\n+\tIncrement combined_with instead of setting to 1.\n+\t* unroll.c (derived_regs): New static variable.\n+\t(unroll_loop): Initialize it.\n+\tAllocate local_regno according to max_reg_num.\n+\t(copy_loop_body): Cope with derived givs.\n+\t(find_splittable_givs): Check for Givs made from biv increments.\n+\tSet derived_regs for givs.\n+\t* Makefile.in (stmt.o, loop.o, unroll.o): Depend on loop.h .\n+\n Wed Jan 27 19:31:36 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* function.c (purge_addressof_1): Handle case when a register"}, {"sha": "ac2879d0abc29d2f67e24f7ef0002840d8cd7bf8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3ec2b59097937f6c218fa04101ba7b649ddf15b5", "patch": "@@ -1474,7 +1474,7 @@ function.o : function.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h\n stmt.o : stmt.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-config.h insn-codes.h hard-reg-set.h $(EXPR_H) except.h \\\n-   loop.h $(RECOG_H) toplev.h output.h\n+   loop.h $(RECOG_H) toplev.h output.h varray.h\n except.o : except.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-flags.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h except.h toplev.h\n@@ -1527,9 +1527,9 @@ profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h insn-config.h\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h loop.h insn-config.h \\\n    insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n-   toplev.h\n+   toplev.h varray.h\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n-   integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h\n+   integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h varray.h\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h recog.h\n combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h  \\"}, {"sha": "c72b212a4a0c2ab47b5cd3810327f47e84c09682", "filename": "gcc/loop.c", "status": "modified", "additions": 893, "deletions": 65, "changes": 958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3ec2b59097937f6c218fa04101ba7b649ddf15b5", "patch": "@@ -78,6 +78,16 @@ static int max_loop_num;\n \n static rtx *loop_number_loop_starts, *loop_number_loop_ends;\n \n+/* Likewise for the continue insn */\n+static rtx *loop_number_loop_cont;\n+\n+/* The first code_label that is reached in every loop iteration.\n+   0 when not computed yet, initially const0_rtx if a jump couldn't be\n+   followed.\n+   Also set to 0 when there is no such label before the NOTE_INSN_LOOP_CONT\n+   of this loop, or in verify_dominator, if a jump couldn't be followed.  */\n+static rtx *loop_number_cont_dominator;\n+\n /* For each loop, gives the containing loop number, -1 if none.  */\n \n int *loop_outer_loop;\n@@ -267,6 +277,7 @@ FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n \n+static void verify_dominator PROTO((int));\n static void find_and_verify_loops PROTO((rtx));\n static void mark_loop_jump PROTO((rtx, int));\n static void prescan_loop PROTO((rtx, rtx));\n@@ -298,12 +309,12 @@ static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, int, int));\n static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));\n-static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, int, int));\n+static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int));\n static void check_final_value PROTO((struct induction *, rtx, rtx, \n \t\t\t\t     unsigned HOST_WIDE_INT));\n static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, rtx *, rtx, rtx));\n static void update_giv_derive PROTO((rtx));\n-static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *));\n+static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *, rtx **));\n static rtx simplify_giv_expr PROTO((rtx, int *));\n static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n@@ -312,6 +323,9 @@ static rtx express_from_1 PROTO((rtx, rtx, rtx));\n static rtx express_from PROTO((struct induction *, struct induction *));\n static rtx combine_givs_p PROTO((struct induction *, struct induction *));\n static void combine_givs PROTO((struct iv_class *));\n+struct recombine_givs_stats;\n+static int find_life_end (rtx,  struct recombine_givs_stats *, rtx, rtx);\n+static void recombine_givs PROTO((struct iv_class *, rtx, rtx));\n static int product_cheap_p PROTO((rtx, rtx));\n static int maybe_eliminate_biv PROTO((struct iv_class *, rtx, rtx, int, int, int));\n static int maybe_eliminate_biv_1 PROTO((rtx, rtx, struct iv_class *, int, rtx));\n@@ -355,6 +369,7 @@ static void instrument_loop_bct PROTO((rtx, rtx, rtx));\n int indirect_jump_in_function = 0;\n static int indirect_jump_in_function_p PROTO((rtx));\n \n+static int compute_luids PROTO ((rtx, rtx, int));\n \f\n /* Relative gain of eliminating various kinds of operations.  */\n static int add_cost;\n@@ -398,6 +413,35 @@ init_loop ()\n   gcc_obstack_init (&temp_obstack);\n }\n \f\n+/* Compute the mapping from uids to luids.\n+   LUIDs are numbers assigned to insns, like uids,\n+   except that luids increase monotonically through the code.\n+   Start at insn START and stop just before END.  Assign LUIDs\n+   starting with PREV_LUID + 1.  Return the last assigned LUID + 1.  */\n+static int\n+compute_luids (start, end, prev_luid)\n+     rtx start, end;\n+     int prev_luid;\n+{\n+  int i;\n+  rtx insn;\n+\n+  for (insn = start, i = prev_luid; insn != end; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_UID (insn) >= max_uid_for_loop)\n+\tcontinue;\n+      /* Don't assign luids to line-number NOTEs, so that the distance in\n+\t luids between two insns is not affected by -g.  */\n+      if (GET_CODE (insn) != NOTE\n+\t  || NOTE_LINE_NUMBER (insn) <= 0)\n+\tuid_luid[INSN_UID (insn)] = ++i;\n+      else\n+\t/* Give a line number note the same luid as preceding insn.  */\n+\tuid_luid[INSN_UID (insn)] = i;\n+    }\n+  return i + 1;\n+}\n+\f\n /* Entry point of this file.  Perform loop optimization\n    on the current function.  F is the first insn of the function\n    and DUMPFILE is a stream for output of a trace of actions taken\n@@ -412,7 +456,6 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n {\n   register rtx insn;\n   register int i;\n-  rtx last_insn;\n \n   loop_dump_stream = dumpfile;\n \n@@ -453,6 +496,8 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n      not be zeroed.  */\n   loop_number_loop_starts = (rtx *) alloca (max_loop_num * sizeof (rtx));\n   loop_number_loop_ends = (rtx *) alloca (max_loop_num * sizeof (rtx));\n+  loop_number_loop_cont = (rtx *) alloca (max_loop_num * sizeof (rtx));\n+  loop_number_cont_dominator = (rtx *) alloca (max_loop_num * sizeof (rtx));\n   loop_outer_loop = (int *) alloca (max_loop_num * sizeof (int));\n   loop_invalid = (char *) alloca (max_loop_num * sizeof (char));\n   loop_number_exit_labels = (rtx *) alloca (max_loop_num * sizeof (rtx));\n@@ -486,24 +531,9 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   /* Now reset it to the actual size we need.  See above.  */\n   max_uid_for_loop = get_max_uid () + 1;\n \n-  /* Compute the mapping from uids to luids.\n-     LUIDs are numbers assigned to insns, like uids,\n-     except that luids increase monotonically through the code.\n-     Don't assign luids to line-number NOTEs, so that the distance in luids\n-     between two insns is not affected by -g.  */\n-\n-  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n-    {\n-      last_insn = insn;\n-      if (GET_CODE (insn) != NOTE\n-\t  || NOTE_LINE_NUMBER (insn) <= 0)\n-\tuid_luid[INSN_UID (insn)] = ++i;\n-      else\n-\t/* Give a line number note the same luid as preceding insn.  */\n-\tuid_luid[INSN_UID (insn)] = i;\n-    }\n-\n-  max_luid = i + 1;\n+  /* find_and_verify_loops has already called compute_luids, but it might\n+     have rearranged code afterwards, so we need to recompute the luids now.  */\n+  max_luid = compute_luids (f, NULL_RTX, 0);\n \n   /* Don't leave gaps in uid_luid for insns that have been\n      deleted.  It is possible that the first or last insn\n@@ -1121,7 +1151,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n     if (VARRAY_INT (set_in_loop, i) < 0)\n       VARRAY_INT (set_in_loop, i) = VARRAY_INT (n_times_set, i);\n \n-  /* Now that we've moved some things out of the loop, we able to\n+  /* Now that we've moved some things out of the loop, we might be able to\n      hoist even more memory references.  There's no need to pass\n      reg_single_usage this time, since we're done with it.  */\n   load_mems_and_recount_loop_regs_set (scan_start, end, loop_top,\n@@ -2487,6 +2517,53 @@ prescan_loop (start, end)\n       for_each_rtx (&insn, insert_loop_mem, 0);\n }\n \f\n+/* LOOP_NUMBER_CONT_DOMINATOR is now the last label between the loop start\n+   and the continue note that is a the destination of a (cond)jump after\n+   the continue note.  If there is any (cond)jump between the loop start\n+   and what we have so far as LOOP_NUMBER_CONT_DOMINATOR that has a\n+   target between LOOP_DOMINATOR and the continue note, move\n+   LOOP_NUMBER_CONT_DOMINATOR forward to that label; if a jump's\n+   destination cannot be determined, clear LOOP_NUMBER_CONT_DOMINATOR.  */\n+\n+static void\n+verify_dominator (loop_number)\n+     int loop_number;\n+{\n+  rtx insn;\n+\n+  if (! loop_number_cont_dominator[loop_number])\n+    /* This can happen for an empty loop, e.g. in\n+       gcc.c-torture/compile/920410-2.c  */\n+    return;\n+  if (loop_number_cont_dominator[loop_number] == const0_rtx)\n+    {\n+      loop_number_cont_dominator[loop_number] = 0;\n+      return;\n+    }\n+  for (insn = loop_number_loop_starts[loop_number];\n+       insn != loop_number_cont_dominator[loop_number];\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == JUMP_INSN\n+\t  && GET_CODE (PATTERN (insn)) != RETURN)\n+\t{\n+\t  rtx label = JUMP_LABEL (insn);\n+\t  int label_luid = INSN_LUID (label);\n+\n+\t  if (! condjump_p (insn)\n+\t      && ! condjump_in_parallel_p (insn))\n+\t    {\n+\t      loop_number_cont_dominator[loop_number] = NULL_RTX;\n+\t      return;\n+\t    }\n+\t  if (label_luid < INSN_LUID (loop_number_loop_cont[loop_number])\n+\t      && (label_luid\n+\t\t  > INSN_LUID (loop_number_cont_dominator[loop_number])))\n+\t    loop_number_cont_dominator[loop_number] = label;\n+\t}\n+    }\n+}\n+\n /* Scan the function looking for loops.  Record the start and end of each loop.\n    Also mark as invalid loops any loops that contain a setjmp or are branched\n    to from outside the loop.  */\n@@ -2500,6 +2577,8 @@ find_and_verify_loops (f)\n   int next_loop = -1;\n   int loop;\n \n+  compute_luids (f, NULL_RTX, 0);\n+\n   /* If there are jumps to undefined labels,\n      treat them as jumps out of any/all loops.\n      This also avoids writing past end of tables when there are no loops.  */\n@@ -2516,6 +2595,8 @@ find_and_verify_loops (f)\n \t  case NOTE_INSN_LOOP_BEG:\n \t    loop_number_loop_starts[++next_loop] =  insn;\n \t    loop_number_loop_ends[next_loop] = 0;\n+\t    loop_number_loop_cont[next_loop] = 0;\n+\t    loop_number_cont_dominator[next_loop] = 0;\n \t    loop_outer_loop[next_loop] = current_loop;\n \t    loop_invalid[next_loop] = 0;\n \t    loop_number_exit_labels[next_loop] = 0;\n@@ -2536,17 +2617,63 @@ find_and_verify_loops (f)\n \t      }\n \t    break;\n \n+\t  case NOTE_INSN_LOOP_CONT:\n+\t    loop_number_loop_cont[current_loop] = insn;\n+\t    break;\n \t  case NOTE_INSN_LOOP_END:\n \t    if (current_loop == -1)\n \t      abort ();\n \n \t    loop_number_loop_ends[current_loop] = insn;\n+\t    verify_dominator (current_loop);\n \t    current_loop = loop_outer_loop[current_loop];\n \t    break;\n \n \t  default:\n \t    break;\n \t  }\n+      /* If for any loop, this is a jump insn between the NOTE_INSN_LOOP_CONT\n+\t and NOTE_INSN_LOOP_END notes, update loop_number_loop_dominator.  */\n+      else if (GET_CODE (insn) == JUMP_INSN\n+\t       && GET_CODE (PATTERN (insn)) != RETURN\n+\t       && current_loop >= 0)\n+\t{\n+\t  int this_loop;\n+\t  rtx label = JUMP_LABEL (insn);\n+\n+\t  if (! condjump_p (insn) && ! condjump_in_parallel_p (insn))\n+\t    label = NULL_RTX;\n+\n+\t  this_loop = current_loop;\n+\t  do\n+\t    {\n+\t      /* First see if we care about this loop.  */\n+\t      if (loop_number_loop_cont[this_loop]\n+\t\t  && loop_number_cont_dominator[this_loop] != const0_rtx)\n+\t\t{\n+\t\t  /* If the jump destination is not known, invalidate\n+\t\t     loop_number_const_dominator.  */\n+\t\t  if (! label)\n+\t\t    loop_number_cont_dominator[this_loop] = const0_rtx;\n+\t\t  else\n+\t\t    /* Check if the destination is between loop start and\n+\t\t       cont.  */\n+\t\t    if ((INSN_LUID (label)\n+\t\t\t < INSN_LUID (loop_number_loop_cont[this_loop]))\n+\t\t\t&& (INSN_LUID (label)\n+\t\t\t    > INSN_LUID (loop_number_loop_starts[this_loop]))\n+\t\t\t/* And if there is no later destination already\n+\t\t\t   recorded.  */\n+\t\t\t&& (! loop_number_cont_dominator[this_loop]\n+\t\t\t    || (INSN_LUID (label)\n+\t\t\t\t> INSN_LUID (loop_number_cont_dominator\n+\t\t\t\t\t     [this_loop]))))\n+\t\t      loop_number_cont_dominator[this_loop] = label;\n+\t\t}\n+\t      this_loop = loop_outer_loop[this_loop];\n+\t    }\n+\t  while (this_loop >= 0);\n+\t}\n \n       /* Note that this will mark the NOTE_INSN_LOOP_END note as being in the\n \t enclosing loop, but this doesn't matter.  */\n@@ -3433,13 +3560,13 @@ loop_reg_used_before_p (set, insn, loop_start, scan_start, loop_end)\n /* Indexed by register number, indicates whether or not register is an\n    induction variable, and if so what type.  */\n \n-enum iv_mode *reg_iv_type;\n+varray_type reg_iv_type;\n \n /* Indexed by register number, contains pointer to `struct induction'\n    if register is an induction variable.  This holds general info for\n    all induction variables.  */\n \n-struct induction **reg_iv_info;\n+varray_type reg_iv_info;\n \n /* Indexed by register number, contains pointer to `struct iv_class'\n    if register is a basic induction variable.  This holds info describing\n@@ -3453,6 +3580,11 @@ struct iv_class **reg_biv_class;\n \n struct iv_class *loop_iv_list;\n \n+/* Givs made from biv increments are always splittable for loop unrolling.\n+   Since there is no regscan info for them, we have to keep track of them\n+   separately.  */\n+int first_increment_giv, last_increment_giv;\n+\n /* Communication with routines called via `note_stores'.  */\n \n static rtx note_insn;\n@@ -3517,6 +3649,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   rtx inc_val;\n   rtx mult_val;\n   rtx dest_reg;\n+  rtx *location;\n   /* This is 1 if current insn is not executed at least once for every loop\n      iteration.  */\n   int not_every_iteration = 0;\n@@ -3537,6 +3670,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   rtx test;\n   rtx end_insert_before;\n   int loop_depth = 0;\n+  int n_extra_increment;\n   struct loop_info loop_iteration_info;\n   struct loop_info *loop_info = &loop_iteration_info;\n \n@@ -3545,13 +3679,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   if (prev_nonnote_insn (scan_start) != prev_nonnote_insn (loop_start))\n     maybe_multiple = back_branch_in_range_p (scan_start, loop_start, loop_end);\n \n-  reg_iv_type = (enum iv_mode *) alloca (max_reg_before_loop\n-\t\t\t\t\t * sizeof (enum iv_mode));\n-  bzero ((char *) reg_iv_type, max_reg_before_loop * sizeof (enum iv_mode));\n-  reg_iv_info = (struct induction **)\n-    alloca (max_reg_before_loop * sizeof (struct induction *));\n-  bzero ((char *) reg_iv_info, (max_reg_before_loop\n-\t\t\t\t* sizeof (struct induction *)));\n+  VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n+  VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n   reg_biv_class = (struct iv_class **)\n     alloca (max_reg_before_loop * sizeof (struct iv_class *));\n   bzero ((char *) reg_biv_class, (max_reg_before_loop\n@@ -3585,23 +3714,24 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  dest_reg = SET_DEST (set);\n \t  if (REGNO (dest_reg) < max_reg_before_loop\n \t      && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n-\t      && reg_iv_type[REGNO (dest_reg)] != NOT_BASIC_INDUCT)\n+\t      && REG_IV_TYPE (REGNO (dest_reg)) != NOT_BASIC_INDUCT)\n \t    {\n \t      if (basic_induction_var (SET_SRC (set), GET_MODE (SET_SRC (set)),\n-\t\t\t\t       dest_reg, p, &inc_val, &mult_val))\n+\t\t\t\t       dest_reg, p, &inc_val, &mult_val,\n+\t\t\t\t       &location))\n \t\t{\n \t\t  /* It is a possible basic induction variable.\n \t\t     Create and initialize an induction structure for it.  */\n \n \t\t  struct induction *v\n \t\t    = (struct induction *) alloca (sizeof (struct induction));\n \n-\t\t  record_biv (v, p, dest_reg, inc_val, mult_val,\n+\t\t  record_biv (v, p, dest_reg, inc_val, mult_val, location,\n \t\t\t      not_every_iteration, maybe_multiple);\n-\t\t  reg_iv_type[REGNO (dest_reg)] = BASIC_INDUCT;\n+\t\t  REG_IV_TYPE (REGNO (dest_reg)) = BASIC_INDUCT;\n \t\t}\n \t      else if (REGNO (dest_reg) < max_reg_before_loop)\n-\t\treg_iv_type[REGNO (dest_reg)] = NOT_BASIC_INDUCT;\n+\t\tREG_IV_TYPE (REGNO (dest_reg)) = NOT_BASIC_INDUCT;\n \t    }\n \t}\n \n@@ -3711,7 +3841,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      Make a sanity check against n_times_set.  */\n   for (backbl = &loop_iv_list, bl = *backbl; bl; bl = bl->next)\n     {\n-      if (reg_iv_type[bl->regno] != BASIC_INDUCT\n+      if (REG_IV_TYPE (bl->regno) != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n \t  /* Make sure it is not recognized as a basic induction var: */\n \t  || VARRAY_INT (n_times_set, bl->regno) != bl->biv_count\n@@ -3722,12 +3852,12 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"Reg %d: biv discarded, %s\\n\",\n \t\t     bl->regno,\n-\t\t     (reg_iv_type[bl->regno] != BASIC_INDUCT\n+\t\t     (REG_IV_TYPE (bl->regno) != BASIC_INDUCT\n \t\t      ? \"not induction variable\"\n \t\t      : (! bl->incremented ? \"never incremented\"\n \t\t\t : \"count error\")));\n \t  \n-\t  reg_iv_type[bl->regno] = NOT_BASIC_INDUCT;\n+\t  REG_IV_TYPE (bl->regno) = NOT_BASIC_INDUCT;\n \t  *backbl = bl->next;\n \t}\n       else\n@@ -3794,7 +3924,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   /* Look at the each biv and see if we can say anything better about its\n      initial value from any initializing insns set up above.  (This is done\n      in two passes to avoid missing SETs in a PARALLEL.)  */\n-  for (bl = loop_iv_list; bl; bl = bl->next)\n+  for (backbl = &loop_iv_list; bl = *backbl; backbl = &bl->next)\n     {\n       rtx src;\n       rtx note;\n@@ -3839,14 +3969,278 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t}\n       else\n \t{\n-\t  /* Biv initial value is not simple move,\n-\t     so let it keep initial value of \"itself\".  */\n+\t  struct iv_class *bl2 = 0;\n+\t  rtx increment;\n+\n+\t  /* Biv initial value is not a simple move.  If it is the sum of\n+\t     another biv and a constant, check if both bivs are incremented\n+\t     in lockstep.  Then we are actually looking at a giv.\n+\t     For simplicity, we only handle the case where there is but a\n+\t     single increment, and the register is not used elsewhere.  */\n+\t  if (bl->biv_count == 1\n+\t      && bl->regno < max_reg_before_loop\n+\t      && uid_luid[REGNO_LAST_UID (bl->regno)] < INSN_LUID (loop_end)\n+\t      && GET_CODE (src) == PLUS\n+\t      && GET_CODE (XEXP (src, 0)) == REG\n+\t      && CONSTANT_P (XEXP (src, 1))\n+\t      && ((increment = biv_total_increment (bl, loop_start, loop_end))\n+\t\t  != NULL_RTX))\n+\t    {\n+\t      int regno = REGNO (XEXP (src, 0));\n \n-\t  if (loop_dump_stream)\n+\t      for (bl2 = loop_iv_list; bl2; bl2 = bl2->next)\n+\t\tif (bl2->regno == regno)\n+\t\t  break;\n+\t    }\n+\t\n+\t  /* Now, can we transform this biv into a giv?  */\n+\t  if (bl2\n+\t      && bl2->biv_count == 1\n+\t      && rtx_equal_p (increment,\n+\t\t\t      biv_total_increment (bl2, loop_start, loop_end))\n+\t      /* init_insn is only set to insns that are before loop_start\n+\t\t without any intervening labels.  */\n+\t      && ! reg_set_between_p (bl2->biv->src_reg,\n+\t\t\t\t      PREV_INSN (bl->init_insn), loop_start)\n+\t      /* The register from BL2 must be set before the register from\n+\t\t BL is set, or we must be able to move the latter set after\n+\t\t the former set.  Currently there can't be any labels\n+\t         in-between when biv_toal_increment returns nonzero both times\n+\t\t but we test it here in case some day some real cfg analysis\n+\t\t gets used to set always_computable.  */\n+\t      && ((insn_first_p (bl2->biv->insn, bl->biv->insn)\n+\t\t   && no_labels_between_p (bl2->biv->insn, bl->biv->insn))\n+\t\t  || (! reg_used_between_p (bl->biv->src_reg, bl->biv->insn,\n+\t\t\t\t\t    bl2->biv->insn)\n+\t\t      && no_jumps_between_p (bl->biv->insn, bl2->biv->insn)))\n+\t      && validate_change (bl->biv->insn,\n+\t\t\t\t  &SET_SRC (single_set (bl->biv->insn)),\n+\t\t\t\t  copy_rtx (src), 0))\n+\t    {\n+\t      int loop_num = uid_loop_num[INSN_UID (loop_start)];\n+\t      rtx dominator = loop_number_cont_dominator[loop_num];\n+\t      rtx cont = loop_number_loop_cont[loop_num];\n+\t      rtx giv = bl->biv->src_reg;\n+\t      rtx giv_insn = bl->biv->insn;\n+\t      rtx after_giv = NEXT_INSN (giv_insn);\n+\n+\t      if (loop_dump_stream)\n+\t\tfprintf (loop_dump_stream, \"is giv of biv %d\\n\", bl2->regno);\n+\t      /* Let this giv be discovered by the generic code.  */\n+\t      REG_IV_TYPE (bl->regno) = UNKNOWN_INDUCT;\n+\t      /* We can get better optimization if we can move the giv setting\n+\t\t before the first giv use.  */\n+\t      if (dominator\n+\t\t  && ! reg_set_between_p (bl2->biv->src_reg, loop_start,\n+\t\t\t\t\t  dominator)\n+\t\t  && ! reg_used_between_p (giv, loop_start, dominator)\n+\t\t  && ! reg_used_between_p (giv, giv_insn, loop_end))\n+\t\t{\n+\t\t  rtx p;\n+\n+\t\t  for (;;)\n+\t\t    {\n+\t\t      rtx next = NEXT_INSN (dominator);\n+\n+\t\t      if ((GET_RTX_CLASS (GET_CODE (next)) == 'i'\n+\t\t\t   && (reg_mentioned_p (giv, PATTERN (next))\n+\t\t\t       || reg_set_p (bl2->biv->src_reg, next)))\n+\t\t\t  || GET_CODE (next) == JUMP_INSN)\n+\t\t\tbreak;\n+#ifdef HAVE_cc0\n+\t\t      if (GET_RTX_CLASS (GET_CODE (next)) != 'i'\n+\t\t\t  || ! sets_cc0_p (PATTERN (next)))\n+#endif\n+\t\t\tdominator = next;\n+\t\t    }\n+\t\t  if (loop_dump_stream)\n+\t\t    fprintf (loop_dump_stream, \"move after insn %d\\n\",\n+\t\t\t     INSN_UID (dominator));\n+\t\t  /* Avoid problems with luids by actually moving the insn\n+\t\t     and adjusting all luids in the range.  */\n+\t\t  reorder_insns (giv_insn, giv_insn, dominator);\n+\t\t  for (p = dominator; INSN_UID (p) >= max_uid_for_loop; )\n+\t\t    p = PREV_INSN (p);\n+\t\t  compute_luids (giv_insn, after_giv, INSN_LUID (p));\n+\t\t  /* If the only purpose of the init insn is to initialize\n+\t\t     this giv, delete it.  */\n+\t\t  if (single_set (bl->init_insn)\n+\t\t      && ! reg_used_between_p (giv, bl->init_insn, loop_start))\n+\t\t    delete_insn (bl->init_insn);\n+\t\t}\n+\t      else if (! insn_first_p (bl2->biv->insn, bl->biv->insn))\n+\t\t{\n+\t\t  rtx p = PREV_INSN (giv_insn);\n+\t\t  while (INSN_UID (p) >= max_uid_for_loop)\n+\t\t    p = PREV_INSN (p);\n+\t\t  reorder_insns (giv_insn, giv_insn, bl2->biv->insn);\n+\t\t  compute_luids (after_giv, NEXT_INSN (giv_insn),\n+\t\t\t\t INSN_LUID (p));\n+\t\t}\n+\t      /* Remove this biv from the chain.  */\n+\t      if (bl->next)\n+\t\t*bl = *bl->next;\n+\t      else\n+\t\t{\n+\t\t  *backbl = 0;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* If we can't make it a giv,\n+\t     let biv keep initial value of \"itself\".  */\n+\t  else if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"is complex\\n\");\n \t}\n     }\n \n+  /* If a biv is unconditionally incremented several times in a row, convert\n+     all but the last increment into a giv.  */\n+\n+  /* Get an upper bound for the number of registers\n+     we might have after all bivs have been processed.  */\n+  first_increment_giv = max_reg_num ();\n+  for (n_extra_increment = 0, bl = loop_iv_list; bl; bl = bl->next)\n+    n_extra_increment += bl->biv_count - 1;\n+  if (n_extra_increment)\n+    {\n+      int nregs = first_increment_giv + n_extra_increment;\n+\n+      /* Reallocate reg_iv_type and reg_iv_info.  */\n+      VARRAY_GROW (reg_iv_type, nregs);\n+      VARRAY_GROW (reg_iv_info, nregs);\n+\n+      for (bl = loop_iv_list; bl; bl = bl->next)\n+\t{\n+\t  struct induction **vp, *v, *next;\n+    \n+\t  /* The biv increments lists are in reverse order.  Fix this first.  */\n+\t  for (v = bl->biv, bl->biv = 0; v; v = next)\n+\t    {\n+\t      next = v->next_iv;\n+\t      v->next_iv = bl->biv;\n+\t      bl->biv = v;\n+\t    }\n+    \n+\t  for (vp = &bl->biv, next = *vp; v = next, next = v->next_iv;)\n+\t    {\n+\t      HOST_WIDE_INT offset;\n+\t      rtx set, add_val, old_reg, dest_reg, last_use_insn;\n+\t      int old_regno, new_regno;\n+    \n+\t      if (! v->always_executed\n+\t\t  || v->maybe_multiple\n+\t\t  || GET_CODE (v->add_val) != CONST_INT\n+\t\t  || ! next->always_executed\n+\t\t  || next->maybe_multiple\n+\t\t  || ! CONSTANT_P (next->add_val))\n+\t\t{\n+\t\t  vp = &v->next_iv;\n+\t\t  continue;\n+\t\t}\n+\t      offset = INTVAL (v->add_val);\n+\t      set = single_set (v->insn);\n+\t      add_val = plus_constant (next->add_val, offset);\n+\t      old_reg = v->dest_reg;\n+\t      dest_reg = gen_reg_rtx (v->mode);\n+    \n+\t      if ((unsigned) max_reg_num () > n_times_set->num_elements)\n+\t\t{\n+\t\t  int nregs = max_reg_before_loop + n_extra_increment;\n+    \n+\t\t  /* Grow all the arrays.  */\n+\t\t  VARRAY_GROW (set_in_loop, nregs);\n+\t\t  VARRAY_GROW (n_times_set, nregs);\n+\t\t  VARRAY_GROW (may_not_optimize, nregs);\n+\t\t}\n+    \n+\t      validate_change (v->insn, &SET_DEST (set), dest_reg, 1);\n+\t      validate_change (next->insn, next->location, add_val, 1);\n+\t      if (! apply_change_group ())\n+\t\t{\n+\t\t  vp = &v->next_iv;\n+\t\t  continue;\n+\t\t}\n+\t      next->add_val = add_val;\n+\t      v->dest_reg = dest_reg;\n+\t      v->giv_type = DEST_REG;\n+\t      v->location = &SET_SRC (set);\n+\t      v->cant_derive = 0;\n+\t      v->combined_with = 0;\n+\t      v->maybe_dead = 0;\n+\t      v->derive_adjustment = 0;\n+\t      v->same = 0;\n+\t      v->ignore = 0;\n+\t      v->new_reg = 0;\n+\t      v->final_value = 0;\n+\t      v->same_insn = 0;\n+\t      v->auto_inc_opt = 0;\n+\t      v->unrolled = 0;\n+\t      v->shared = 0;\n+\t      v->derived = 0;\n+\t      v->always_computable = 1;\n+\t      v->always_executed = 1;\n+\t      v->replaceable = 1;\n+\t      v->no_const_addval = 0;\n+    \n+\t      old_regno = REGNO (old_reg);\n+\t      new_regno = REGNO (dest_reg);\n+\t      VARRAY_INT (set_in_loop, old_regno)--;\n+\t      VARRAY_INT (set_in_loop, new_regno) = 1;\n+\t      VARRAY_INT (n_times_set, old_regno)--;\n+\t      VARRAY_INT (n_times_set, new_regno) = 1;\n+\t      VARRAY_CHAR (may_not_optimize, new_regno) = 0;\n+    \n+\t      REG_IV_TYPE (new_regno) = GENERAL_INDUCT;\n+\t      REG_IV_INFO (new_regno) = v;\n+    \n+\t      /* Remove the increment from the list of biv increments,\n+\t\t and record it as a giv.  */\n+\t      *vp = next;\n+\t      bl->biv_count--;\n+\t      v->next_iv = bl->giv;\n+\t      bl->giv = v;\n+\t      bl->giv_count++;\n+\t      v->benefit = rtx_cost (SET_SRC (set), SET);\n+\t      bl->total_benefit += v->benefit;\n+    \n+\t      /* Now replace the biv with DEST_REG in all insns between\n+\t\t the replaced increment and the next increment, and\n+\t\t remember the last insn that needed a replacement.  */\n+\t      for (last_use_insn = v->insn, p = NEXT_INSN (v->insn);\n+\t\t   p != next->insn;\n+\t\t   p = next_insn_in_loop (p, scan_start, end, loop_top))\n+\t\t{\n+\t\t  rtx note;\n+    \n+\t\t  if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\t\t    continue;\n+\t\t  if (reg_mentioned_p (old_reg, PATTERN (p)))\n+\t\t    {\n+\t\t      last_use_insn = p;\n+\t\t      if (! validate_replace_rtx (old_reg, dest_reg, p))\n+\t\t\tabort ();\n+\t\t    }\n+\t\t  for (note = REG_NOTES (p); note; note = XEXP (note, 1))\n+\t\t    {\n+\t\t      if (GET_CODE (note) == EXPR_LIST)\n+\t\t\tXEXP (note, 0)\n+\t\t\t  = replace_rtx (XEXP (note, 0), old_reg, dest_reg);\n+\t\t    }\n+\t\t}\n+    \n+\t      v->last_use = last_use_insn;\n+\t      v->lifetime = INSN_LUID (v->insn) - INSN_LUID (last_use_insn);\n+\t      /* If the lifetime is zero, it means that this register is really\n+\t\t a dead store.  So mark this as a giv that can be ignored.\n+\t\t This will not prevent the biv from being eliminated.  */\n+\t      if (v->lifetime == 0)\n+\t\tv->ignore = 1;\n+\t    }\n+\t}\n+    }\n+  last_increment_giv = max_reg_num () - 1;\n+\n   /* Search the loop for general induction variables.  */\n \n   /* A register is a giv if: it is only set once, it is a function of a\n@@ -4188,6 +4582,10 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t    }\n \t}\n \n+      /* Now that we know which givs will be reduced, try to rearrange the\n+         combinations to reduce register pressure.  */\n+      recombine_givs (bl, loop_start, loop_end);\n+\n       /* Reduce each giv that we decided to reduce.  */\n \n       for (v = bl->giv; v; v = v->next_iv)\n@@ -4199,6 +4597,29 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n \t      v->new_reg = gen_reg_rtx (v->mode);\n \n+\t      if (v->derived)\n+\t\t{\n+\t\t  PATTERN (v->insn)\n+\t\t    = replace_rtx (PATTERN (v->insn), v->dest_reg, v->new_reg);\n+\t\t  if (bl->biv_count != 1)\n+\t\t    {\n+\t\t      /* For each place where the biv is incremented, add an\n+\t\t\t insn to set the new, reduced reg for the giv.  */\n+\t\t      for (tv = bl->biv; tv; tv = tv->next_iv)\n+\t\t\t{\n+\t\t\t  /* We always emit reduced giv increments before the\n+\t\t\t     biv increment when bl->biv_count != 1.  So by\n+\t\t\t     emitting the add insns for derived givs after the\n+\t\t\t     biv increment, they pick up the updated value of\n+\t\t\t     the reduced giv.  */\n+\t\t\t  emit_insn_after (copy_rtx (PATTERN (v->insn)),\n+\t\t\t\t\t   tv->insn);\n+\n+\t\t\t}\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\n #ifdef AUTO_INC_DEC\n \t      /* If the target has auto-increment addressing modes, and\n \t\t this is an address giv, then try to put the increment\n@@ -4324,7 +4745,15 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  if (v->ignore)\n \t    continue;\n \n-\t  if (v->giv_type == DEST_REG\n+\t  if (v->last_use)\n+\t    {\n+\t      struct induction *v1;\n+\n+\t      for (v1 = bl->giv; v1; v1 = v1->next_iv)\n+\t\tif (v->last_use == v1->insn)\n+\t\t  v->maybe_dead = 1;\n+\t    }\n+\t  else if (v->giv_type == DEST_REG\n \t      && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n \t    {\n \t      struct induction *v1;\n@@ -4539,6 +4968,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"\\n\");\n+  VARRAY_FREE (reg_iv_type);\n+  VARRAY_FREE (reg_iv_info);\n }\n \f\n /* Return 1 if X is a valid source for an initial value (or as value being\n@@ -4678,13 +5109,14 @@ find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)\n    executed exactly once per iteration.  */\n \n static void\n-record_biv (v, insn, dest_reg, inc_val, mult_val,\n+record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n \t    not_every_iteration, maybe_multiple)\n      struct induction *v;\n      rtx insn;\n      rtx dest_reg;\n      rtx inc_val;\n      rtx mult_val;\n+     rtx *location;\n      int not_every_iteration;\n      int maybe_multiple;\n {\n@@ -4695,6 +5127,7 @@ record_biv (v, insn, dest_reg, inc_val, mult_val,\n   v->dest_reg = dest_reg;\n   v->mult_val = mult_val;\n   v->add_val = inc_val;\n+  v->location = location;\n   v->mode = GET_MODE (dest_reg);\n   v->always_computable = ! not_every_iteration;\n   v->always_executed = ! not_every_iteration;\n@@ -4815,6 +5248,8 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->auto_inc_opt = 0;\n   v->unrolled = 0;\n   v->shared = 0;\n+  v->derived = 0;\n+  v->last_use = 0;\n \n   /* The v->always_computable field is used in update_giv_derive, to\n      determine whether a giv can be used to derive another giv.  For a\n@@ -4849,8 +5284,8 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n       if (v->lifetime == 0)\n \tv->ignore = 1;\n \n-      reg_iv_type[REGNO (dest_reg)] = GENERAL_INDUCT;\n-      reg_iv_info[REGNO (dest_reg)] = v;\n+      REG_IV_TYPE (REGNO (dest_reg)) = GENERAL_INDUCT;\n+      REG_IV_INFO (REGNO (dest_reg)) = v;\n     }\n \n   /* Add the giv to the class of givs computed from one biv.  */\n@@ -5265,7 +5700,8 @@ update_giv_derive (p)\n      REG = INVARIANT + REG\n \n    If X is suitable, we return 1, set *MULT_VAL to CONST1_RTX,\n-   and store the additive term into *INC_VAL.\n+   store the additive term into *INC_VAL, and store the place where\n+   we found the additive term into *LOCATION.\n \n    If X is an assignment of an invariant into DEST_REG, we set\n    *MULT_VAL to CONST0_RTX, and store the invariant into *INC_VAL.\n@@ -5292,16 +5728,17 @@ update_giv_derive (p)\n    If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n+basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n      register rtx x;\n      enum machine_mode mode;\n      rtx p;\n      rtx dest_reg;\n      rtx *inc_val;\n      rtx *mult_val;\n+     rtx **location;\n {\n   register enum rtx_code code;\n-  rtx arg;\n+  rtx *argp, arg;\n   rtx insn, set = 0;\n \n   code = GET_CODE (x);\n@@ -5312,28 +5749,34 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n \t  || (GET_CODE (XEXP (x, 0)) == SUBREG\n \t      && SUBREG_PROMOTED_VAR_P (XEXP (x, 0))\n \t      && SUBREG_REG (XEXP (x, 0)) == dest_reg))\n- \targ = XEXP (x, 1);\n+\t{\n+\t  argp = &XEXP (x, 1);\n+\t}\n       else if (rtx_equal_p (XEXP (x, 1), dest_reg)\n \t       || (GET_CODE (XEXP (x, 1)) == SUBREG\n \t\t   && SUBREG_PROMOTED_VAR_P (XEXP (x, 1))\n \t\t   && SUBREG_REG (XEXP (x, 1)) == dest_reg))\n-\targ = XEXP (x, 0);\n+\t{\n+\t  argp = &XEXP (x, 0);\n+\t}\n       else\n  \treturn 0;\n \n+      arg = *argp;\n       if (invariant_p (arg) != 1)\n \treturn 0;\n \n       *inc_val = convert_modes (GET_MODE (dest_reg), GET_MODE (x), arg, 0);\n       *mult_val = const1_rtx;\n+      *location = argp;\n       return 1;\n \n     case SUBREG:\n       /* If this is a SUBREG for a promoted variable, check the inner\n \t value.  */\n       if (SUBREG_PROMOTED_VAR_P (x))\n \treturn basic_induction_var (SUBREG_REG (x), GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t    dest_reg, p, inc_val, mult_val);\n+\t\t\t\t    dest_reg, p, inc_val, mult_val, location);\n       return 0;\n \n     case REG:\n@@ -5364,7 +5807,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n \t\t\t\t       ? GET_MODE (x)\n \t\t\t\t       : GET_MODE (SET_SRC (set))),\n \t\t\t\t      dest_reg, insn,\n-\t\t\t\t      inc_val, mult_val))\n+\t\t\t\t      inc_val, mult_val, location))\n \t    return 1;\n \t}\n       /* ... fall through ...  */\n@@ -5396,7 +5839,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n \n     case SIGN_EXTEND:\n       return basic_induction_var (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, p, inc_val, mult_val);\n+\t\t\t\t  dest_reg, p, inc_val, mult_val, location);\n \n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n@@ -5416,7 +5859,8 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n \t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1))\n \treturn basic_induction_var (XEXP (SET_SRC (set), 0),\n \t\t\t\t    GET_MODE (XEXP (x, 0)),\n-\t\t\t\t    dest_reg, insn, inc_val, mult_val);\n+\t\t\t\t    dest_reg, insn, inc_val, mult_val,\n+\t\t\t\t    location);\n       return 0;\n \n     default:\n@@ -5783,13 +6227,13 @@ simplify_giv_expr (x, benefit)\n \treturn 0;\n \n       /* Check for biv or giv.  */\n-      switch (reg_iv_type[REGNO (x)])\n+      switch (REG_IV_TYPE (REGNO (x)))\n \t{\n \tcase BASIC_INDUCT:\n \t  return x;\n \tcase GENERAL_INDUCT:\n \t  {\n-\t    struct induction *v = reg_iv_info[REGNO (x)];\n+\t    struct induction *v = REG_IV_INFO (REGNO (x));\n \n \t    /* Form expression from giv and add benefit.  Ensure this giv\n \t       can derive another and subtract any needed adjustment if so.  */\n@@ -6000,8 +6444,8 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n   v->cant_derive = 0;\n   v->derive_adjustment = 0;\n \n-  reg_iv_type[REGNO (dest_reg)] = GENERAL_INDUCT;\n-  reg_iv_info[REGNO (dest_reg)] = v;\n+  REG_IV_TYPE (REGNO (dest_reg)) = GENERAL_INDUCT;\n+  REG_IV_INFO (REGNO (dest_reg)) = v;\n \n   count = VARRAY_INT (n_times_set, REGNO (dest_reg)) - 1;\n \n@@ -6045,7 +6489,7 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n \t      && CONSTANT_P (SET_SRC (set)))\n \t    continue;\n \n-\t  reg_iv_type[REGNO (dest_reg)] = UNKNOWN_INDUCT;\n+\t  REG_IV_TYPE (REGNO (dest_reg)) = UNKNOWN_INDUCT;\n \t  return 0;\n \t}\n     }\n@@ -6231,7 +6675,10 @@ combine_givs_p (g1, g2)\n   /* If these givs are identical, they can be combined.  We use the results\n      of express_from because the addends are not in a canonical form, so\n      rtx_equal_p is a weaker test.  */\n-  if (tem == g1->dest_reg)\n+  /* But don't combine a DEST_REG giv with a DEST_ADDR giv; we want the\n+     combination to be the other way round.  */\n+  if (tem == g1->dest_reg\n+      && (g1->giv_type == DEST_REG || g2->giv_type == DEST_ADDR))\n     {\n       return g1->dest_reg;\n     }\n@@ -6411,7 +6858,7 @@ combine_givs (bl)\n \n \t      g2->new_reg = can_combine[i*giv_count + j];\n \t      g2->same = g1;\n-\t      g1->combined_with = 1;\n+\t      g1->combined_with++;\n \t      g1->lifetime += g2->lifetime;\n \n \t      g1_add_benefit += combine_givs_benefit_from (g1, g2);\n@@ -6470,6 +6917,387 @@ combine_givs (bl)\n     }\n }\n \f\n+struct recombine_givs_stats\n+{\n+  int giv_number;\n+  int start_luid, end_luid;\n+};\n+\n+/* Used below as comparison function for qsort.  We want a ascending luid\n+   when scanning the array starting at the end, thus the arguments are\n+   used in reverse.  */\n+static int\n+cmp_recombine_givs_stats (x, y)\n+     struct recombine_givs_stats *x, *y;\n+{\n+  int d;\n+  d = y->start_luid - x->start_luid;\n+  /* Stabilize the sort.  */\n+  if (!d)\n+    d = y->giv_number - x->giv_number;\n+  return d;\n+}\n+\n+/* Scan X, which is a part of INSN, for the end of life of a giv.  Also\n+   look for the start of life of a giv where the start has not been seen\n+   yet to unlock the search for the end of its life.\n+   Only consider givs that belong to BIV.\n+   Return the total number of lifetime ends that have been found.  */\n+static int\n+find_life_end (x, stats, insn, biv)\n+     rtx x, insn, biv;\n+     struct recombine_givs_stats *stats;\n+{\n+  enum rtx_code code;\n+  char *fmt;\n+  int i, j;\n+  int retval;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case SET:\n+      {\n+\trtx reg = SET_DEST (x);\n+\tif (GET_CODE (reg) == REG)\n+\t  {\n+\t    int regno = REGNO (reg);\n+\t    struct induction *v = REG_IV_INFO (regno);\n+\n+\t    if (REG_IV_TYPE (regno) == GENERAL_INDUCT\n+\t\t&& ! v->ignore\n+\t\t&& v->src_reg == biv\n+\t\t&& stats[v->ix].end_luid <= 0)\n+\t      {\n+\t\t/* If we see a 0 here for end_luid, it means that we have\n+\t\t   scanned the entire loop without finding any use at all.\n+\t\t   We must not predicate this code on a start_luid match\n+\t\t   since that would make the test fail for givs that have\n+\t\t   been hoisted out of inner loops.  */\n+\t\tif (stats[v->ix].end_luid == 0)\n+\t\t  {\n+\t\t    stats[v->ix].end_luid = stats[v->ix].start_luid;\n+\t\t    return 1 + find_life_end (SET_SRC (x), stats, insn, biv);\n+\t\t  }\n+\t\telse if (stats[v->ix].start_luid == INSN_LUID (insn))\n+\t\t  stats[v->ix].end_luid = 0;\n+\t      }\n+\t    return find_life_end (SET_SRC (x), stats, insn, biv);\n+\t  }\n+\tbreak;\n+      }\n+    case REG:\n+      {\n+\tint regno = REGNO (x);\n+\tstruct induction *v = REG_IV_INFO (regno);\n+\n+\tif (REG_IV_TYPE (regno) == GENERAL_INDUCT\n+\t    && ! v->ignore\n+\t    && v->src_reg == biv\n+\t    && stats[v->ix].end_luid == 0)\n+\t  {\n+\t    while (INSN_UID (insn) >= max_uid_for_loop)\n+\t      insn = NEXT_INSN (insn);\n+\t    stats[v->ix].end_luid = INSN_LUID (insn);\n+\t    return 1;\n+\t  }\n+\treturn 0;\n+      }\n+    case LABEL_REF:\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+    case CONST:\n+      return 0;\n+    default:\n+      break;\n+    }\n+  fmt = GET_RTX_FORMAT (code);\n+  retval = 0;\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tretval += find_life_end (XEXP (x, i), stats, insn, biv);\n+\n+      else if (fmt[i] == 'E')\n+        for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  retval += find_life_end (XVECEXP (x, i, j), stats, insn, biv);\n+    }\n+  return retval;\n+}\n+\n+/* For each giv that has been combined with another, look if\n+   we can combine it with the most recently used one instead.\n+   This tends to shorten giv lifetimes, and helps the next step:\n+   try to derive givs from other givs.  */\n+static void\n+recombine_givs (bl, loop_start, loop_end)\n+     struct iv_class *bl;\n+     rtx loop_start, loop_end;\n+{\n+  struct induction *v, **giv_array, *last_giv;\n+  struct recombine_givs_stats *stats;\n+  int giv_count;\n+  int i, rescan;\n+  int ends_need_computing;\n+\n+  for (giv_count = 0, v = bl->giv; v; v = v->next_iv)\n+    {\n+      if (! v->ignore)\n+\tgiv_count++;\n+    }\n+  giv_array\n+    = (struct induction **) alloca (giv_count * sizeof (struct induction *));\n+  stats = (struct recombine_givs_stats *) alloca (giv_count * sizeof *stats);\n+\n+  /* Initialize stats and set up the ix field for each giv in stats to name\n+     the corresponding index into stats.  */\n+  for (i = 0, v = bl->giv; v; v = v->next_iv)\n+    {\n+      rtx p;\n+\n+      if (v->ignore)\n+\tcontinue;\n+      giv_array[i] = v;\n+      stats[i].giv_number = i;\n+      /* If this giv has been hoisted out of an inner loop, use the luid of\n+\t the previous insn.  */\n+      for (p = v->insn; INSN_UID (p) >= max_uid_for_loop; )\n+\tp = PREV_INSN (p);\n+      stats[i].start_luid = INSN_LUID (p);\n+      v->ix = i;\n+      i++;\n+    }\n+\n+  qsort (stats, giv_count, sizeof(*stats), cmp_recombine_givs_stats);\n+\n+  /* Do the actual most-recently-used recombination.  */\n+  for (last_giv = 0, i = giv_count - 1; i >= 0; i--)\n+    {\n+      v = giv_array[stats[i].giv_number];\n+      if (v->same)\n+\t{\n+\t  struct induction *old_same = v->same;\n+\t  rtx new_combine;\n+\n+\t  /* combine_givs_p actually says if we can make this transformation.\n+\t     The other tests are here only to avoid keeping a giv alive\n+\t     that could otherwise be eliminated.  */\n+\t  if (last_giv\n+\t      && ((old_same->maybe_dead && ! old_same->combined_with)\n+\t\t  || ! last_giv->maybe_dead\n+\t\t  || last_giv->combined_with)\n+\t      && (new_combine = combine_givs_p (last_giv, v)))\n+\t    {\n+\t      old_same->combined_with--;\n+\t      v->new_reg = new_combine;\n+\t      v->same = last_giv;\n+\t      last_giv->combined_with++;\n+\t      /* No need to update lifetimes / benefits here since we have\n+\t\t already decided what to reduce.  */\n+\t      continue;\n+\t    }\n+\t  v = v->same;\n+\t}\n+      else if (v->giv_type != DEST_REG)\n+\tcontinue;\n+      if (! last_giv\n+\t  || (last_giv->maybe_dead && ! last_giv->combined_with)\n+\t  || ! v->maybe_dead\n+\t  || v->combined_with)\n+\tlast_giv = v;\n+    }\n+\n+  ends_need_computing = 0;\n+  /* For each DEST_REG giv, compute lifetime starts, and try to compute\n+     lifetime ends from regscan info.  */\n+  for (i = 0, v = bl->giv; v; v = v->next_iv)\n+    {\n+      if (v->ignore)\n+\tcontinue;\n+      if (v->giv_type == DEST_ADDR)\n+\t{\n+\t  /* Loop unrolling of an inner loop can even create new DEST_REG\n+\t     givs.  */\n+\t  rtx p;\n+\t  for (p = v->insn; INSN_UID (p) >= max_uid_for_loop; )\n+\t    p = PREV_INSN (p);\n+\t  stats[i].start_luid = stats[i].end_luid = INSN_LUID (p);\n+\t  if (p != v->insn)\n+\t    stats[i].end_luid++;\n+\t}\n+      else /* v->giv_type == DEST_REG */\n+\t{\n+\t  if (v->last_use)\n+\t    {\n+\t      stats[i].start_luid = INSN_LUID (v->insn);\n+\t      stats[i].end_luid = INSN_LUID (v->last_use);\n+\t    }\n+\t  else if (INSN_UID (v->insn) >= max_uid_for_loop)\n+\t    {\n+\t      rtx p;\n+\t      /* This insn has been created by loop optimization on an inner\n+\t\t loop.  We don't have a proper start_luid that will match\n+\t\t when we see the first set.  But we do know that there will\n+\t\t be no use before the set, so we can set end_luid to 0 so that\n+\t\t we'll start looking for the last use right away.  */\n+\t      for (p = PREV_INSN (v->insn); INSN_UID (p) >= max_uid_for_loop; )\n+\t\tp = PREV_INSN (p);\n+\t      stats[i].start_luid = INSN_LUID (p);\n+\t      stats[i].end_luid = 0;\n+\t      ends_need_computing++;\n+\t    }\n+\t  else\n+\t    {\n+\t      int regno = REGNO (v->dest_reg);\n+\t      int count = VARRAY_INT (n_times_set, regno) - 1;\n+\t      rtx p = v->insn;\n+\n+\t      /* Find the first insn that sets the giv, so that we can verify\n+\t\t if this giv's lifetime wraps around the loop.  We also need\n+\t\t the luid of the first setting insn in order to detect the\n+\t\t last use properly.  */\n+\t      while (count)\n+\t\t{\n+\t\t  p = prev_nonnote_insn (p);\n+\t\t  if (reg_set_p (v->dest_reg, p))\n+\t\t  count--;\n+\t\t}\n+\n+\t      stats[i].start_luid = INSN_LUID (p);\n+\t      if (stats[i].start_luid > uid_luid[REGNO_FIRST_UID (regno)])\n+\t\t{\n+\t\t  stats[i].end_luid = -1;\n+\t\t  ends_need_computing++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  stats[i].end_luid = uid_luid[REGNO_LAST_UID (regno)];\n+\t\t  if (stats[i].end_luid > INSN_LUID (loop_end))\n+\t\t    {\n+\t\t      stats[i].end_luid = -1;\n+\t\t      ends_need_computing++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      i++;\n+    }\n+\n+  /* If the regscan information was unconclusive for one or more DEST_REG\n+     givs, scan the all insn in the loop to find out lifetime ends.  */\n+  if (ends_need_computing)\n+    {\n+      rtx biv = bl->biv->src_reg;\n+      rtx p = loop_end;\n+\n+      do\n+\t{\n+\t  if (p == loop_start)\n+\t    p = loop_end;\n+\t  p = PREV_INSN (p);\n+\t  if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\t    continue;\n+\t  ends_need_computing -= find_life_end (PATTERN (p), stats, p, biv);\n+\t}\n+      while (ends_need_computing);\n+    }\n+\n+  /* Set start_luid back to the last insn that sets the giv.  This allows\n+     more combinations.  */\n+  for (i = 0, v = bl->giv; v; v = v->next_iv)\n+    {\n+      if (v->ignore)\n+\tcontinue;\n+      if (INSN_UID (v->insn) < max_uid_for_loop)\n+\tstats[i].start_luid = INSN_LUID (v->insn);\n+      i++;\n+    }\n+\n+  /* Now adjust lifetime ends by taking combined givs into account.  */\n+  for (i = 0, v = bl->giv; v; v = v->next_iv)\n+    {\n+      unsigned luid;\n+      int j;\n+\n+      if (v->ignore)\n+\tcontinue;\n+      if (v->same && ! v->same->ignore)\n+\t{\n+\t  j = v->same->ix;\n+\t  luid = stats[i].start_luid;\n+\t  /* Use unsigned arithmetic to model loop wrap-around.  */\n+\t  if (luid - stats[j].start_luid\n+\t      > (unsigned) stats[j].end_luid - stats[j].start_luid)\n+\t    stats[j].end_luid = luid;\n+\t}\n+      i++;\n+    }\n+\n+  qsort (stats, giv_count, sizeof(*stats), cmp_recombine_givs_stats);\n+\n+  /* Try to derive DEST_REG givs from previous DEST_REG givs with the\n+     same mult_val and non-overlapping lifetime.  This reduces register\n+     pressure.\n+     Once we find a DEST_REG giv that is suitable to derive others from,\n+     we set last_giv to this giv, and try to derive as many other DEST_REG\n+     givs from it without joining overlapping lifetimes.  If we then\n+     encounter a DEST_REG giv that we can't derive, we set rescan to the\n+     index for this giv (unless rescan is already set).\n+     When we are finished with the current LAST_GIV (i.e. the inner loop\n+     terminates), we start again with rescan, which then becomes the new\n+     LAST_GIV.  */\n+  for (i = giv_count - 1; i >= 0; i = rescan)\n+    {\n+      int life_start, life_end;\n+\n+      for (last_giv = 0, rescan = -1; i >= 0; i--)\n+\t{\n+\t  rtx sum;\n+\n+\t  v = giv_array[stats[i].giv_number];\n+\t  if (v->giv_type != DEST_REG || v->derived)\n+\t    continue;\n+\t  if (! last_giv)\n+\t    {\n+\t      if (! v->same)\n+\t\t{\n+\t\t  last_giv = v;\n+\t\t  life_start = stats[i].start_luid;\n+\t\t  life_end = stats[i].end_luid;\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  /* Use unsigned arithmetic to model loop wrap around.  */\n+\t  if (((unsigned) stats[i].start_luid - life_start\n+\t       >= (unsigned) life_end - life_start)\n+\t      && ((unsigned) stats[i].end_luid - life_start\n+\t\t  >= (unsigned) life_end - life_start)\n+\t      && rtx_equal_p (last_giv->mult_val, v->mult_val)\n+\t      /* ??? Could handle libcalls, but would need more logic.  */\n+\t      && ! find_reg_note (v->insn, REG_RETVAL, NULL_RTX)\n+\t      /* We would really like to know if for any giv that v\n+\t\t is combined with, v->insn or any intervening biv increment\n+\t\t dominates that combined giv.  However, we\n+\t\t don't have this detailed control flow information.\n+\t\t N.B. since last_giv will be reduced, it is valid\n+\t\t anywhere in the loop, so we don't need to check the\n+\t\t validity of last_giv.  */\n+\t      && (v->always_executed || ! v->combined_with)\n+\t      && (sum = express_from (last_giv, v))\n+\t      && validate_change (v->insn, &PATTERN (v->insn),\n+\t\t\t\t  gen_rtx_SET (GET_MODE (v->dest_reg),\n+\t\t\t\t\t       v->dest_reg, sum), 0))\n+\t    {\n+\t      v->derived = 1;\n+\t      v->new_reg = v->dest_reg;\n+\t      life_end = stats[i].end_luid;\n+\t    }\n+\t  else if (rescan < 0)\n+\t    rescan = i;\n+\t}\n+    }\n+}\n+\f\n /* EMIT code before INSERT_BEFORE to set REG = B * M + A.  */\n \n void\n@@ -7473,7 +8301,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n #if 0\n \t  /* Otherwise the reg compared with had better be a biv.  */\n \t  if (GET_CODE (arg) != REG\n-\t      || reg_iv_type[REGNO (arg)] != BASIC_INDUCT)\n+\t      || REG_IV_TYPE (REGNO (arg)) != BASIC_INDUCT)\n \t    return 0;\n \n \t  /* Look for a pair of givs, one for each biv,\n@@ -7586,7 +8414,7 @@ record_initial (dest, set)\n \n   if (GET_CODE (dest) != REG\n       || REGNO (dest) >= max_reg_before_loop\n-      || reg_iv_type[REGNO (dest)] != BASIC_INDUCT)\n+      || REG_IV_TYPE (REGNO (dest)) != BASIC_INDUCT)\n     return;\n \n   bl = reg_biv_class[REGNO (dest)];"}, {"sha": "d03facf105eb6ddee3dcadbbfd4bdb4cc00eec39", "filename": "gcc/loop.h", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=3ec2b59097937f6c218fa04101ba7b649ddf15b5", "patch": "@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#include \"varray.h\"\n+\n /* Get the luid of an insn.  Catch the error of trying to reference the LUID\n    of an insn added during loop, since these don't have LUIDs.  */\n \n@@ -54,6 +56,8 @@ struct induction\n \t\t\t\t   For a DEST_ADDR type giv, this is 0.  */\n   rtx *location;\t\t/* Place in the insn where this giv occurs.\n \t\t\t\t   If GIV_TYPE is DEST_REG, this is 0.  */\n+\t\t\t\t/* For a biv, this is the place where add_val\n+\t\t\t\t   was found.  */\n   enum machine_mode mode;\t/* The mode of this biv or giv */\n   enum machine_mode mem_mode;\t/* For DEST_ADDR, mode of the memory object. */\n   rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n@@ -63,6 +67,9 @@ struct induction\n \t\t\t\t   final value could be calculated, it is put\n \t\t\t\t   here, and the giv is made replaceable.  Set\n \t\t\t\t   the giv to this value before the loop.  */\n+  unsigned combined_with;\t/* The number of givs this giv has been\n+\t\t\t\t   combined with.  If nonzero, this giv\n+\t\t\t\t   cannot combine with any other giv.  */\n   unsigned replaceable : 1;\t/* 1 if we can substitute the strength-reduced\n \t\t\t\t   variable for the original variable.\n \t\t\t\t   0 means they must be kept separate and the\n@@ -85,8 +92,6 @@ struct induction\n \t\t\t\t   another giv.  This occurs in many cases\n \t\t\t\t   where a giv's lifetime spans an update to\n \t\t\t\t   a biv. */\n-  unsigned combined_with : 1;\t/* 1 if this giv has been combined with.  It\n-\t\t\t\t   then cannot combine with any other giv.  */\n   unsigned maybe_dead : 1;\t/* 1 if this giv might be dead.  In that case,\n \t\t\t\t   we won't use it to eliminate a biv, it\n \t\t\t\t   would probably lose. */\n@@ -96,6 +101,8 @@ struct induction\n \t\t\t\t   initialized in unrolled loop.  */\n   unsigned shared : 1;\n   unsigned no_const_addval : 1; /* 1 if add_val does not contain a const. */\n+  unsigned derived : 1;         /* For a giv, 1 if we decided to derive this\n+\t\t\t\t   giv from another one.  */\n   int lifetime;\t\t\t/* Length of life of this giv */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n \t\t\t\t   subtracted from add_val when this giv\n@@ -112,10 +119,14 @@ struct induction\n \t\t\t\t   is split, and a constant is eliminated from\n \t\t\t\t   the address, the -constant is stored here\n \t\t\t\t   for later use. */\n+  int ix;\t\t\t/* Used by recombine_givs, as n index into\n+\t\t\t\t   the stats array.  */\n   struct induction *same_insn;\t/* If there are multiple identical givs in\n \t\t\t\t   the same insn, then all but one have this\n \t\t\t\t   field set, and they all point to the giv\n \t\t\t\t   that doesn't have this field set.  */\n+  rtx last_use;\t\t\t/* For a giv made from a biv increment, this is\n+\t\t\t\t   a substitute for the lifetime information. */\n };\n \n /* A `struct iv_class' is created for each biv.  */\n@@ -197,11 +208,19 @@ extern int max_reg_before_loop;\n \n extern FILE *loop_dump_stream;\n \n-extern enum iv_mode *reg_iv_type;\n-extern struct induction **reg_iv_info;\n+extern varray_type reg_iv_type;\n+extern varray_type reg_iv_info;\n+\n+#define REG_IV_TYPE(n) \\\n+  (*(enum iv_mode *) &VARRAY_INT(reg_iv_type, (n)))\n+#define REG_IV_INFO(n) \\\n+  (*(struct induction **) &VARRAY_GENERIC_PTR(reg_iv_info, (n)))\n+\n extern struct iv_class **reg_biv_class;\n extern struct iv_class *loop_iv_list;\n \n+extern int first_increment_giv, last_increment_giv;\n+\n /* Forward declarations for non-static functions declared in loop.c and\n    unroll.c.  */\n int invariant_p PROTO((rtx));"}, {"sha": "eb9b8258649252f6b261143df271cb4675a40e2c", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3ec2b59097937f6c218fa04101ba7b649ddf15b5", "patch": "@@ -1008,6 +1008,7 @@ extern int reg_set_between_p\t\tPROTO((rtx, rtx, rtx));\n extern int regs_set_between_p\t\tPROTO((rtx, rtx, rtx));\n extern int modified_between_p\t\tPROTO((rtx, rtx, rtx));\n extern int no_labels_between_p\t\tPROTO((rtx, rtx));\n+extern int no_jumps_between_p\t\tPROTO((rtx, rtx));\n extern int modified_in_p\t\tPROTO((rtx, rtx));\n extern int reg_set_p\t\t\tPROTO((rtx, rtx));\n extern rtx single_set\t\t\tPROTO((rtx));\n@@ -1035,6 +1036,7 @@ extern rtx replace_regs\t\t\tPROTO((rtx, rtx *, int, int));\n extern int computed_jump_p\t\tPROTO((rtx));\n typedef int (*rtx_function)             PROTO((rtx *, void *));\n extern int for_each_rtx                 PROTO((rtx *, rtx_function, void *));\n+extern int insn_first_p\t\t\tPROTO((rtx, rtx));\n \n /* flow.c */\n "}, {"sha": "8983b5e2afde2e4f214f314915245eeacf9e00f9", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=3ec2b59097937f6c218fa04101ba7b649ddf15b5", "patch": "@@ -326,6 +326,20 @@ no_labels_between_p (beg, end)\n   return 1;\n }\n \n+/* Return 1 if in between BEG and END, exclusive of BEG and END, there is\n+   no JUMP_INSN insn.  */\n+\n+int\n+no_jumps_between_p (beg, end)\n+     rtx beg, end;\n+{\n+  register rtx p;\n+  for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n+    if (GET_CODE (p) == JUMP_INSN)\n+      return 0;\n+  return 1;\n+}\n+\n /* Nonzero if register REG is used in an insn between\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n@@ -2187,3 +2201,20 @@ for_each_rtx (x, f, data)\n \n   return 0;\n }\n+\n+/* INSN and REFERENCE are instructions in the same insn chain.\n+   Return non-zero if INSN is first.  */\n+int\n+insn_first_p (insn, reference)\n+     rtx insn, reference;\n+{\n+  rtx p, q;\n+\n+  for (p = insn, q = reference; ; p = NEXT_INSN (p), q = NEXT_INSN (q))\n+    {\n+      if (p == reference || ! q)\n+\treturn 1;\n+      if (q == insn || ! p)\n+\treturn 0;\n+    }\n+}"}, {"sha": "b3a7f507fec1d3a33a80f583adac4cbe388c3649", "filename": "gcc/unroll.c", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec2b59097937f6c218fa04101ba7b649ddf15b5/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=3ec2b59097937f6c218fa04101ba7b649ddf15b5", "patch": "@@ -179,6 +179,10 @@ static struct induction **addr_combined_regs;\n \n static rtx *splittable_regs;\n \n+/* Indexed by register number, if this is a splittable induction variable,\n+   this indicates if it was made from a derived giv.  */\n+static char *derived_regs;\n+\n /* Indexed by register number, if this is a splittable induction variable,\n    then this will hold the number of instructions in the loop that modify\n    the induction variable.  Used to ensure that only the last insn modifying\n@@ -761,16 +765,15 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   splittable_regs = (rtx *) alloca (maxregnum * sizeof (rtx));\n   bzero ((char *) splittable_regs, maxregnum * sizeof (rtx));\n+  derived_regs = alloca (maxregnum);\n+  bzero (derived_regs, maxregnum);\n   splittable_regs_updates = (int *) alloca (maxregnum * sizeof (int));\n   bzero ((char *) splittable_regs_updates, maxregnum * sizeof (int));\n   addr_combined_regs\n     = (struct induction **) alloca (maxregnum * sizeof (struct induction *));\n   bzero ((char *) addr_combined_regs, maxregnum * sizeof (struct induction *));\n-  /* We must limit it to max_reg_before_loop, because only these pseudo\n-     registers have valid regno_first_uid info.  Any register created after\n-     that is unlikely to be local to the loop anyways.  */\n-  local_regno = (char *) alloca (max_reg_before_loop);\n-  bzero (local_regno, max_reg_before_loop);\n+  local_regno = (char *) alloca (maxregnum);\n+  bzero (local_regno, maxregnum);\n \n   /* Mark all local registers, i.e. the ones which are referenced only\n      inside the loop.  */\n@@ -793,6 +796,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     /* If a pseudo's lifetime is entirely contained within this loop, then we\n        can use a different pseudo in each unrolled copy of the loop.  This\n        results in better code.  */\n+    /* We must limit the generic test to max_reg_before_loop, because only\n+       these pseudo registers have valid regno_first_uid info.  */\n     for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; ++j)\n       if (REGNO_FIRST_UID (j) > 0 && REGNO_FIRST_UID (j) <= max_uid_for_loop\n \t  && uid_luid[REGNO_FIRST_UID (j)] >= copy_start_luid\n@@ -821,6 +826,14 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\t\t j);\n \t    }\n \t}\n+    /* Givs that have been created from multiple biv increments always have\n+       local registers.  */\n+    for (j = first_increment_giv; j <= last_increment_giv; j++)\n+      {\n+\tlocal_regno[j] = 1;\n+\tif (loop_dump_stream)\n+\t  fprintf (loop_dump_stream, \"Marked reg %d as local\\n\", j);\n+      }\n   }\n \n   /* If this loop requires exit tests when unrolled, check to see if we\n@@ -1041,7 +1054,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\tif (local_label[j])\n \t\t  set_label_in_map (map, j, gen_label_rtx ());\n \n-\t      for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; j++)\n+\t      for (j = FIRST_PSEUDO_REGISTER; j < maxregnum; j++)\n \t\tif (local_regno[j])\n \t\t  {\n \t\t    map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n@@ -1197,7 +1210,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \tif (local_label[j])\n \t  set_label_in_map (map, j, gen_label_rtx ());\n \n-      for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; j++)\n+      for (j = FIRST_PSEUDO_REGISTER; j < maxregnum; j++)\n \tif (local_regno[j])\n \t  {\n \t    map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n@@ -1701,7 +1714,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t we might accidentally delete insns generated immediately\n \t\t below by emit_unrolled_add.  */\n \n-\t      giv_inc = calculate_giv_inc (set, insn, regno);\n+\t      if (! derived_regs[regno])\n+\t\tgiv_inc = calculate_giv_inc (set, insn, regno);\n \n \t      /* Now find all address giv's that were combined with this\n \t\t giv 'v'.  */\n@@ -1780,16 +1794,25 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      && splittable_regs[REGNO (SET_DEST (set))])\n \t    {\n \t      int regno = REGNO (SET_DEST (set));\n+\t      int src_regno;\n \t      \n \t      dest_reg_was_split = 1;\n \t      \n-\t      /* Compute the increment value for the giv, if it wasn't\n-\t\t already computed above.  */\n-\n-\t      if (giv_inc == 0)\n-\t\tgiv_inc = calculate_giv_inc (set, insn, regno);\n \t      giv_dest_reg = SET_DEST (set);\n-\t      giv_src_reg = SET_DEST (set);\n+\t      if (derived_regs[regno])\n+\t\t{\n+\t\t  giv_src_reg = XEXP (SET_SRC (set), 0);\n+\t\t  giv_inc = XEXP (SET_SRC (set), 1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  giv_src_reg = giv_dest_reg;\n+\t\t  /* Compute the increment value for the giv, if it wasn't\n+\t\t     already computed above.  */\n+\t\t  if (giv_inc == 0)\n+\t\t    giv_inc = calculate_giv_inc (set, insn, regno);\n+\t\t}\n+\t      src_regno = REGNO (giv_src_reg);\n \n \t      if (unroll_type == UNROLL_COMPLETELY)\n \t\t{\n@@ -1799,7 +1822,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t  /* The value in splittable_regs may be an invariant\n \t\t     value, so we must use plus_constant here.  */\n \t\t  splittable_regs[regno]\n-\t\t    = plus_constant (splittable_regs[regno], INTVAL (giv_inc));\n+\t\t    = plus_constant (splittable_regs[src_regno],\n+\t\t\t\t     INTVAL (giv_inc));\n \n \t\t  if (GET_CODE (splittable_regs[regno]) == PLUS)\n \t\t    {\n@@ -1830,7 +1854,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t     induction entry by find_splittable_regs.  */\n \n \t\t  if (regno < max_reg_before_loop\n-\t\t      && reg_iv_type[regno] == BASIC_INDUCT)\n+\t\t      && REG_IV_TYPE (regno) == BASIC_INDUCT)\n \t\t    {\n \t\t      giv_src_reg = reg_biv_class[regno]->biv->src_reg;\n \t\t      giv_dest_reg = giv_src_reg;\n@@ -1844,7 +1868,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t  \n \t\t  splittable_regs[regno]\n \t\t    = GEN_INT (INTVAL (giv_inc)\n-\t\t\t       + INTVAL (splittable_regs[regno]));\n+\t\t\t       + INTVAL (splittable_regs[src_regno]));\n \t\t  giv_inc = splittable_regs[regno];\n \t\t  \n \t\t  /* Now split the induction variable by changing the dest\n@@ -2338,7 +2362,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n \n   /* If this is a new register, can't handle it since we don't have any\n      reg_iv_type entry for it.  */\n-  if (REGNO (iteration_var) >= max_reg_before_loop)\n+  if ((unsigned) REGNO (iteration_var) > reg_iv_type->num_elements)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -2364,15 +2388,15 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n \t\t \"Loop unrolling: Iteration var not an integer.\\n\");\n       return;\n     }\n-  else if (reg_iv_type[REGNO (iteration_var)] == BASIC_INDUCT)\n+  else if (REG_IV_TYPE (REGNO (iteration_var)) == BASIC_INDUCT)\n     {\n       /* Grab initial value, only useful if it is a constant.  */\n       bl = reg_biv_class[REGNO (iteration_var)];\n       *initial_value = bl->initial_value;\n \n       *increment = biv_total_increment (bl, loop_start, loop_end);\n     }\n-  else if (reg_iv_type[REGNO (iteration_var)] == GENERAL_INDUCT)\n+  else if (REG_IV_TYPE (REGNO (iteration_var)) == GENERAL_INDUCT)\n     {\n #if 1\n       /* ??? The code below does not work because the incorrect number of\n@@ -2390,7 +2414,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n #else\n       /* Initial value is mult_val times the biv's initial value plus\n \t add_val.  Only useful if it is a constant.  */\n-      v = reg_iv_info[REGNO (iteration_var)];\n+      v = REG_IV_INFO (REGNO (iteration_var));\n       bl = reg_biv_class[REGNO (v->src_reg)];\n       *initial_value = fold_rtx_mult_add (v->mult_val, bl->initial_value,\n \t\t\t\t\t  v->add_val, v->mode);\n@@ -2708,6 +2732,10 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t      /* Line above always fails if INSN was moved by loop opt.  */\n \t      || (uid_luid[REGNO_LAST_UID (REGNO (v->dest_reg))]\n \t\t  >= INSN_LUID (loop_end)))\n+\t  /* Givs made from biv increments are missed by the above test, so\n+\t     test explicitly for them.  */\n+\t  && (REGNO (v->dest_reg) < first_increment_giv\n+\t      || REGNO (v->dest_reg) > last_increment_giv)\n \t  && ! (final_value = v->final_value))\n \tcontinue;\n \n@@ -2808,6 +2836,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t}\n \t\t\n \t      splittable_regs[REGNO (v->new_reg)] = value;\n+\t      derived_regs[REGNO (v->new_reg)] = v->derived;\n \t    }\n \t  else\n \t    {\n@@ -2991,6 +3020,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t     Make sure that it's giv is marked as splittable here.  */\n \t\t  \n \t\t  splittable_regs[REGNO (v->new_reg)] = value;\n+\t\t  derived_regs[REGNO (v->new_reg)] = v->derived;\n \t\t  \n \t\t  /* Make it appear to depend upon itself, so that the\n \t\t     giv will be properly split in the main loop above.  */\n@@ -3902,7 +3932,7 @@ remap_split_bivs (x)\n \t have to remap those givs also.  */\n #endif\n       if (REGNO (x) < max_reg_before_loop\n-\t  && reg_iv_type[REGNO (x)] == BASIC_INDUCT)\n+\t  && REG_IV_TYPE (REGNO (x)) == BASIC_INDUCT)\n \treturn reg_biv_class[REGNO (x)]->biv->src_reg;\n       break;\n       "}]}