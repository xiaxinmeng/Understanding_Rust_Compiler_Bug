{"sha": "171262081c9cd444023acbd55ef265e9cffcd47b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcxMjYyMDgxYzljZDQ0NDAyM2FjYmQ1NWVmMjY1ZTljZmZjZDQ3Yg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-08-17T21:07:07Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-08-17T21:07:07Z"}, "message": "[multiple changes]\n\n2001-08-16  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* jcf-parse.c (load_class): New locals saved and class_loaded. If\n\tloading a class_or_name fails, try considering an innerclass name\n\tand load the enclosing context.\n\t* parse.y (resolve_inner_class): New function.\n\t(find_as_inner_class): Added leading comment.\n\t(register_incomplete_type): Keep the current context as enclosing\n\tcontext for JDEP_FIELD dependencies.\n\t(do_resolve_class): Locals new_class_decl and super initialized to\n\tNULL. Call resolve_inner_class, explore the enclosing context\n\tsuperclass if necessary.\n\tFixes PR java/4007\n\n2001-08-12  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* decl.c (init_decl_processing): exception_type_node,\n\tclass_not_found_type_node, and no_class_def_found_type_node\n\tinitialized. predef_filenames augmented accordingly.\n\tinstinit_identifier_node initialized.\n\t* java-tree.def (INSTANCE_INITIALIZERS_EXPR): Entry removed.\n\t* java-tree.h (enum java_tree_index): New entries\n\tJTI_EXCEPTION_TYPE_NODE, JTI_CLASS_NOT_FOUND_TYPE_NODE,\n\tJTI_NO_CLASS_DEF_FOUND_TYPE_NODE, JTI_INSTINIT_IDENTIFIER_NODE.\n\t(exception_type_node): New macro.\n\t(class_not_found_type_node): Likewise.\n\t(no_class_def_found_type_node): Likewise.\n\t(instinit_identifier_node): Likewise.\n\t(PREDEF_FILENAMES_SIZE): Adjusted.\n\t(TYPE_HAS_FINAL_VARIABLE): Fixed typo.\n\t(struct lang_type): Fixed typo in bitfield name.\n\t(DECL_INSTINIT_P): New macro.\n\t(ID_INSTINIT_P): Likewise.\n\t* jcf-write.c (generate_classfile): instinit$ bears the Synthetic\n\tattribute.\n\t* parse.y (encapsulate_with_try_catch): New function.\n\t(generate_instinit): Likewise.\n\t(build_instinit_invocation): Likewise.\n\t(ctors_unchecked_throws_clause_p): Likewise.\n\t(add_instance_initializer): Deleted.\n\t(build_instance_initializer): Likewise.\n\t(in_instance_initializer): Likewise.\n\t(check_method_redefinition): instinit$ not to be verified.\n\t(java_complete_expand_methods): Generate instinit$, simplified code.\n\t(build_dot_class_method): Eliminated unnecessary locals. Use\n\tencapsulate_with_try_catch, removed unnecessary code.\n\t(fix_constructors): New local iii. Use build_instinit_invocation.\n\t(patch_method_invocation): Added comment.\n\t(maybe_use_access_method): Don't consider instinit$.\n\t(find_applicable_accessible_methods_list): Shorten the search for\n\tinstinit$ too.\n\t(java_complete_lhs): case INSTANCE_INITIALIZERS_EXPR removed.\n\t(patch_return): Use DECL_INSTINIT_P instead of in_instance_initializer.\n\t(patch_throw_statement): Likewise. Fixed typo.\n\n2001-08-09  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* expr.c (java_lang_expand_expr): Call `expand_end_bindings' and\n\t`poplevel' in the right order.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-08/msg01061.html )\n\nFrom-SVN: r44982", "tree": {"sha": "48423fd61c7cb8b8e91a0e83679b52ebad7e88a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48423fd61c7cb8b8e91a0e83679b52ebad7e88a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/171262081c9cd444023acbd55ef265e9cffcd47b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/171262081c9cd444023acbd55ef265e9cffcd47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/171262081c9cd444023acbd55ef265e9cffcd47b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/171262081c9cd444023acbd55ef265e9cffcd47b/comments", "author": null, "committer": null, "parents": [{"sha": "0779eeb2815ca0a74eed65f8f558123e5e953a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0779eeb2815ca0a74eed65f8f558123e5e953a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0779eeb2815ca0a74eed65f8f558123e5e953a81"}], "stats": {"total": 528, "additions": 371, "deletions": 157}, "files": [{"sha": "6db866fd59b69c30f7b2452b8a5531ea5369560b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -1,3 +1,17 @@\n+2001-08-16  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* jcf-parse.c (load_class): New locals saved and class_loaded. If\n+\tloading a class_or_name fails, try considering an innerclass name\n+\tand load the enclosing context.\n+\t* parse.y (resolve_inner_class): New function.\n+\t(find_as_inner_class): Added leading comment.\n+\t(register_incomplete_type): Keep the current context as enclosing\n+\tcontext for JDEP_FIELD dependencies.\n+\t(do_resolve_class): Locals new_class_decl and super initialized to\n+\tNULL. Call resolve_inner_class, explore the enclosing context\n+\tsuperclass if necessary.\n+\tFixes PR java/4007\n+\n 2001-08-16  Tom Tromey  <tromey@redhat.com>\n \n \t* jcf-dump.c (main): Updated for change to jcf_path_seal.\n@@ -13,6 +27,47 @@\n \t* Make-lang.in (java/decl.o): Update dependencies.\n \t* decl.c: Include libfuncs.h, don't include toplev.h.\n \n+2001-08-12  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* decl.c (init_decl_processing): exception_type_node,\n+\tclass_not_found_type_node, and no_class_def_found_type_node\n+\tinitialized. predef_filenames augmented accordingly.\n+\tinstinit_identifier_node initialized.\n+\t* java-tree.def (INSTANCE_INITIALIZERS_EXPR): Entry removed.\n+\t* java-tree.h (enum java_tree_index): New entries\n+\tJTI_EXCEPTION_TYPE_NODE, JTI_CLASS_NOT_FOUND_TYPE_NODE,\n+\tJTI_NO_CLASS_DEF_FOUND_TYPE_NODE, JTI_INSTINIT_IDENTIFIER_NODE.\n+\t(exception_type_node): New macro.\n+\t(class_not_found_type_node): Likewise.\n+\t(no_class_def_found_type_node): Likewise.\n+\t(instinit_identifier_node): Likewise.\n+\t(PREDEF_FILENAMES_SIZE): Adjusted.\n+\t(TYPE_HAS_FINAL_VARIABLE): Fixed typo.\n+\t(struct lang_type): Fixed typo in bitfield name.\n+\t(DECL_INSTINIT_P): New macro.\n+\t(ID_INSTINIT_P): Likewise.\n+\t* jcf-write.c (generate_classfile): instinit$ bears the Synthetic\n+\tattribute.\n+\t* parse.y (encapsulate_with_try_catch): New function.\n+\t(generate_instinit): Likewise.\n+\t(build_instinit_invocation): Likewise.\n+\t(ctors_unchecked_throws_clause_p): Likewise.\n+\t(add_instance_initializer): Deleted.\n+\t(build_instance_initializer): Likewise.\n+\t(in_instance_initializer): Likewise.\n+\t(check_method_redefinition): instinit$ not to be verified.\n+\t(java_complete_expand_methods): Generate instinit$, simplified code.\n+\t(build_dot_class_method): Eliminated unnecessary locals. Use\n+\tencapsulate_with_try_catch, removed unnecessary code.\n+\t(fix_constructors): New local iii. Use build_instinit_invocation.\n+\t(patch_method_invocation): Added comment.\n+\t(maybe_use_access_method): Don't consider instinit$.\n+\t(find_applicable_accessible_methods_list): Shorten the search for\n+\tinstinit$ too.\n+\t(java_complete_lhs): case INSTANCE_INITIALIZERS_EXPR removed.\n+\t(patch_return): Use DECL_INSTINIT_P instead of in_instance_initializer.\n+\t(patch_throw_statement): Likewise. Fixed typo.\n+\t\n 2001-08-12  David Edelsohn  <edelsohn@gnu.org>\n \n \tRevert:\n@@ -31,6 +86,11 @@\n \t* lex.h: Don't include setjmp.h.  Don't define\n \tSET_FLOAT_HANDLER or prototype set_float_handler.\n \n+2001-08-09  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* expr.c (java_lang_expand_expr): Call `expand_end_bindings' and\n+\t`poplevel' in the right order.\n+\n 2001-08-09  Richard Henderson  <rth@redhat.com>\n \n \t* Make-lang.in (class.o): Depend on TARGET_H.\n@@ -390,7 +450,7 @@\n \n 2001-05-07  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n-\t* parse.y (fix_constructors): Removed unecessary assignment to\n+\t* parse.y (fix_constructors): Removed unnecessary assignment to\n \tlocal. Moved assignment to `this$<n>', fixed comments and\n \tindentation.\n \t(build_wfl_wrap): Fixed indentation.\n@@ -2912,7 +2972,7 @@ Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n 2000-06-25  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (do_resolve_class): Minor optimiztion in the package\n-\tlist search. Removed unecessary test and return statement.\n+\tlist search. Removed unnecessary test and return statement.\n \t(valid_ref_assignconv_cast_p): Order of arguments to\n \tenclosing_context_p fixed.\n \n@@ -3296,7 +3356,7 @@ Mon Apr 24 14:59:36 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n 2000-04-24  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* parse.y (source_start_java_method): Deleted unecessary code.\n+\t* parse.y (source_start_java_method): Deleted unnecessary code.\n \t(patch_method_invocation): Fixed comment.\n \n 2000-04-24  Robert Lipe <robertlipe@usa.net>\n@@ -3860,7 +3920,7 @@ Fri Feb 25 18:00:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (resolve_expression_name): Use `orig' as a second\n  \targument to resolve_field_access.\n-\t(resolve_field_access): Removed unecessary code when dealing with\n+\t(resolve_field_access): Removed unnecessary code when dealing with\n  \tstatic fields.\n \n Wed Feb 23 17:41:50 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n@@ -11650,7 +11710,7 @@ Thu Sep 11 19:45:18 1997  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \tlayout.\n \t* typeck.c: (parse_signature_string): Temporary use permanent_obstack.\n \t(build_java_signature): Temporary use permanent_obstack.\n-\t* verify.c: (verify_jvm_instruction): removed unecessary verification\n+\t* verify.c: (verify_jvm_instruction): removed unnecessary verification\n \ton ACC_SUPER flag.\n \t* java-tree.h (METHOD_NATIVE, METHOD_TRANSIENT): Defined.\n \t(FIELD_VOLATILE, FIELD_TRANSIENT): Defined."}, {"sha": "ecfa9aa17bc5722995007c70b97d8b8d33a6e465", "filename": "gcc/java/decl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -541,10 +541,16 @@ init_decl_processing ()\n   string_ptr_type_node = promote_type (string_type_node);\n   class_type_node = lookup_class (get_identifier (\"java.lang.Class\"));\n   throwable_type_node = lookup_class (get_identifier (\"java.lang.Throwable\"));\n+  exception_type_node = lookup_class (get_identifier (\"java.lang.Exception\"));\n   runtime_exception_type_node = \n     lookup_class (get_identifier (\"java.lang.RuntimeException\"));\n   error_exception_type_node = \n     lookup_class (get_identifier (\"java.lang.Error\"));\n+  class_not_found_type_node = \n+    lookup_class (get_identifier (\"java.lang.ClassNotFoundException\"));\n+  no_class_def_found_type_node = \n+    lookup_class (get_identifier (\"java.lang.NoClassDefFoundError\"));\n+\n   rawdata_ptr_type_node\n     = promote_type (lookup_class (get_identifier (\"gnu.gcj.RawData\")));\n \n@@ -557,6 +563,9 @@ init_decl_processing ()\n   predef_filenames [4] = get_identifier (\"java/lang/String.java\");\n   predef_filenames [5] = get_identifier (\"java/lang/Throwable.java\");\n   predef_filenames [6] = get_identifier (\"gnu/gcj/RawData.java\");\n+  predef_filenames [7] = get_identifier (\"java/lang/Exception\");\n+  predef_filenames [8] = get_identifier (\"java/lang/ClassNotFoundException\");\n+  predef_filenames [9] = get_identifier (\"java/lang/NoClassDefFoundError\");\n \n   methodtable_type = make_node (RECORD_TYPE);\n   layout_type (methodtable_type);\n@@ -572,6 +581,7 @@ init_decl_processing ()\n   /* The new `finit$' special method identifier. This one is now\n      generated in place of `$finit$'.  */\n   finit_identifier_node = get_identifier (\"finit$\");\n+  instinit_identifier_node = get_identifier (\"instinit$\");\n   void_signature_node = get_identifier (\"()V\");\n   length_identifier_node = get_identifier (\"length\");\n   this_identifier_node = get_identifier (\"this\");"}, {"sha": "d1cc19e93b84ef7dbcdfa255b10c17a3079b4483", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -2505,8 +2505,8 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t    }\n \t  expand_expr (body, const0_rtx, VOIDmode, 0);\n \t  emit_queue ();\n-\t  poplevel (1, 1, 0);\n \t  expand_end_bindings (getdecls (), 1, 0);\n+\t  poplevel (1, 1, 0);\n \t  return const0_rtx;\n \t}\n       return const0_rtx;"}, {"sha": "f15bc38701fc28d889b1b91223854c35310ff0f2", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -88,12 +88,6 @@ DEFTREECODE (NEW_ARRAY_INIT, \"new_array_init\", '1', 1)\n    reference from.  */\n DEFTREECODE (CLASS_LITERAL, \"class_literal\", '1', 1)\n \n-/* Instance initializer.\n-   Operand 0 contains the intance initializer statement. This tree node\n-   is used for context detection, so that special rules can be\n-   enforced. */\n-DEFTREECODE (INSTANCE_INITIALIZERS_EXPR, \"instance_initializers_expr\", '1', 1)\n-\n /* The Java object within the exception object from the runtime.  */\n DEFTREECODE (JAVA_EXC_OBJ_EXPR, \"java_exc_obj_expr\", 'e', 0)\n "}, {"sha": "ef4e0632b79f1a48887022aba1898784e67cd754", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -251,9 +251,12 @@ enum java_tree_index\n   JTI_STRING_TYPE_NODE,\n   JTI_STRING_PTR_TYPE_NODE,\n   JTI_THROWABLE_TYPE_NODE,\n+  JTI_EXCEPTION_TYPE_NODE,\n   JTI_RUNTIME_EXCEPTION_TYPE_NODE,\n   JTI_ERROR_EXCEPTION_TYPE_NODE,\n   JTI_RAWDATA_PTR_TYPE_NODE,\n+  JTI_CLASS_NOT_FOUND_TYPE_NODE,\n+  JTI_NO_CLASS_DEF_FOUND_TYPE_NODE,\n \n   JTI_BYTE_ARRAY_TYPE_NODE,\n   JTI_SHORT_ARRAY_TYPE_NODE,\n@@ -278,6 +281,7 @@ enum java_tree_index\n   JTI_INIT_IDENTIFIER_NODE,      \n   JTI_CLINIT_IDENTIFIER_NODE,      \n   JTI_FINIT_IDENTIFIER_NODE,      \n+  JTI_INSTINIT_IDENTIFIER_NODE,\n   JTI_FINIT_LEG_IDENTIFIER_NODE,  \n   JTI_VOID_SIGNATURE_NODE,       \n   JTI_LENGTH_IDENTIFIER_NODE,  \n@@ -408,12 +412,18 @@ extern tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_STRING_PTR_TYPE_NODE]\n #define throwable_type_node \\\n   java_global_trees[JTI_THROWABLE_TYPE_NODE]\n+#define exception_type_node \\\n+  java_global_trees[JTI_EXCEPTION_TYPE_NODE]\n #define runtime_exception_type_node \\\n   java_global_trees[JTI_RUNTIME_EXCEPTION_TYPE_NODE]\n #define error_exception_type_node \\\n   java_global_trees[JTI_ERROR_EXCEPTION_TYPE_NODE]\n #define rawdata_ptr_type_node \\\n   java_global_trees[JTI_RAWDATA_PTR_TYPE_NODE]\n+#define class_not_found_type_node \\\n+  java_global_trees[JTI_CLASS_NOT_FOUND_TYPE_NODE]\n+#define no_class_def_found_type_node \\\n+  java_global_trees[JTI_NO_CLASS_DEF_FOUND_TYPE_NODE]\n \n #define byte_array_type_node \\\n   java_global_trees[JTI_BYTE_ARRAY_TYPE_NODE]\n@@ -463,6 +473,8 @@ extern tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_FINIT_IDENTIFIER_NODE]      /* \"finit$\" */\n #define finit_leg_identifier_node \\\n   java_global_trees[JTI_FINIT_LEG_IDENTIFIER_NODE]  /* \"$finit$\" */\n+#define instinit_identifier_node \\\n+  java_global_trees[JTI_INSTINIT_IDENTIFIER_NODE]  /* \"instinit$\" */\n #define void_signature_node \\\n   java_global_trees[JTI_VOID_SIGNATURE_NODE]       /* \"()V\" */\n #define length_identifier_node \\\n@@ -598,7 +610,7 @@ extern tree java_global_trees[JTI_MAX];\n #define nativecode_ptr_array_type_node \\\n   java_global_trees[JTI_NATIVECODE_PTR_ARRAY_TYPE_NODE]\n \n-#define PREDEF_FILENAMES_SIZE 7\n+#define PREDEF_FILENAMES_SIZE 10\n extern tree predef_filenames[PREDEF_FILENAMES_SIZE];\n \n #define nativecode_ptr_type_node ptr_type_node\n@@ -937,7 +949,7 @@ struct lang_decl_var\n #define TYPE_PACKAGE_LIST(T)     (TYPE_LANG_SPECIFIC(T)->package_list)\n #define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->pic)\n #define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->poic)\n-#define TYPE_HAS_FINAL_VARIABLE(T) (TYPE_LANG_SPECIFIC(T)->afv)\n+#define TYPE_HAS_FINAL_VARIABLE(T) (TYPE_LANG_SPECIFIC(T)->hfv)\n \n struct lang_type\n {\n@@ -955,7 +967,7 @@ struct lang_type\n   tree package_list;\t\t/* List of package names, progressive */\n   unsigned pic:1;\t\t/* Private Inner Class. */\n   unsigned poic:1;\t\t/* Protected Inner Class. */\n-  unsigned afv:1;\t\t/* Has final variables */\n+  unsigned hfv:1;\t\t/* Has final variables */\n };\n \n #ifdef JAVA_USE_HANDLES\n@@ -1197,6 +1209,7 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define DECL_INIT_P(DECL)   (ID_INIT_P (DECL_NAME (DECL)))\n #define DECL_FINIT_P(DECL)  (ID_FINIT_P (DECL_NAME (DECL)))\n #define DECL_CLINIT_P(DECL) (ID_CLINIT_P (DECL_NAME (DECL)))\n+#define DECL_INSTINIT_P(DECL) (ID_INSTINIT_P (DECL_NAME (DECL)))\n \n /* Predicates on method identifiers. Kept close to other macros using\n    them  */\n@@ -1209,6 +1222,7 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n \t\t\t || (ID) == finit_leg_identifier_node)\n #define ID_CLINIT_P(ID) ((ID) == clinit_identifier_node)\n #define ID_CLASSDOLLAR_P(ID) ((ID) == classdollar_identifier_node)\n+#define ID_INSTINIT_P(ID) ((ID) == instinit_identifier_node)\n \n /* Access flags etc for a variable/field (a FIELD_DECL): */\n "}, {"sha": "e258167feb1b20f17d5df8896ed75e7ff42cd988", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -650,7 +650,8 @@ load_class (class_or_name, verbose)\n      tree class_or_name;\n      int verbose;\n {\n-  tree name;\n+  tree name, saved;\n+  int class_loaded;\n \n   /* class_or_name can be the name of the class we want to load */\n   if (TREE_CODE (class_or_name) == IDENTIFIER_NODE)\n@@ -663,8 +664,31 @@ load_class (class_or_name, verbose)\n   else\n     name = DECL_NAME (TYPE_NAME (class_or_name));\n \n-  if (read_class (name) == 0 && verbose)\n-    error (\"Cannot find file for class %s.\", IDENTIFIER_POINTER (name));\n+  saved = name;\n+  while (1)\n+    {\n+      char *dollar;\n+\n+      if ((class_loaded = read_class (name)))\n+\tbreak;\n+\n+      /* We failed loading name. Now consider that we might be looking\n+\t for a inner class but it's only available in source for in\n+\t its enclosing context. */\n+      if ((dollar = strrchr (IDENTIFIER_POINTER (name), '$')))\n+\t{\n+\t  int c = *dollar;\n+\t  *dollar = '\\0';\n+\t  name = get_identifier (IDENTIFIER_POINTER (name));\n+\t  *dollar = c;\n+\t}\n+      /* Otherwise, we failed, we bail. */\n+      else\n+\tbreak;\n+    }\n+\n+  if (!class_loaded && verbose)\n+    error (\"Cannot find file for class %s.\", IDENTIFIER_POINTER (saved));\n }\n \n /* Parse the .class file JCF. */"}, {"sha": "7339e95315be6b35453db9c9ed96c7bd50b7b6eb", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -2935,7 +2935,8 @@ generate_classfile (clas, state)\n       i = (body != NULL_TREE) + (DECL_FUNCTION_THROWS (part) != NULL_TREE);\n \n       /* Make room for the Synthetic attribute (of zero length.)  */\n-      if (DECL_FINIT_P (part) \n+      if (DECL_FINIT_P (part)\n+\t  || DECL_INSTINIT_P (part)\n \t  || OUTER_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (part))\n \t  || TYPE_DOT_CLASS (clas) == part)\n \t{"}, {"sha": "b4eb9301df50849507b818baa409ba9e1296d1f0", "filename": "gcc/java/parse.y", "status": "modified", "additions": 249, "deletions": 138, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/171262081c9cd444023acbd55ef265e9cffcd47b/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=171262081c9cd444023acbd55ef265e9cffcd47b", "patch": "@@ -221,6 +221,7 @@ static tree string_constant_concatenation PARAMS ((tree, tree));\n static tree build_string_concatenation PARAMS ((tree, tree));\n static tree patch_string_cst PARAMS ((tree));\n static tree patch_string PARAMS ((tree));\n+static tree encapsulate_with_try_catch PARAMS ((int, tree, tree, tree));\n static tree build_try_statement PARAMS ((int, tree, tree));\n static tree build_try_finally_statement PARAMS ((int, tree, tree));\n static tree patch_try_statement PARAMS ((tree));\n@@ -229,6 +230,7 @@ static tree patch_throw_statement PARAMS ((tree, tree));\n static void check_thrown_exceptions PARAMS ((int, tree));\n static int check_thrown_exceptions_do PARAMS ((tree));\n static void purge_unchecked_exceptions PARAMS ((tree));\n+static bool ctors_unchecked_throws_clause_p PARAMS ((tree));\n static void check_throws_clauses PARAMS ((tree, tree, tree));\n static void finish_method_declaration PARAMS ((tree));\n static tree build_super_invocation PARAMS ((tree));\n@@ -239,8 +241,8 @@ static tree build_this_super_qualified_invocation PARAMS ((int, tree, tree,\n static const char *get_printable_method_name PARAMS ((tree));\n static tree patch_conditional_expr PARAMS ((tree, tree, tree));\n static tree generate_finit PARAMS ((tree));\n-static void add_instance_initializer PARAMS ((tree));\n-static tree build_instance_initializer PARAMS ((tree));\n+static tree generate_instinit PARAMS ((tree));\n+static tree build_instinit_invocation PARAMS ((tree));\n static void fix_constructors PARAMS ((tree));\n static tree build_alias_initializer_parameter_list PARAMS ((int, tree,\n \t\t\t\t\t\t\t    tree, int *));\n@@ -300,6 +302,8 @@ static tree maybe_make_nested_class_name PARAMS ((tree));\n static void make_nested_class_name PARAMS ((tree));\n static void set_nested_class_simple_name_value PARAMS ((tree, int));\n static void link_nested_class_to_enclosing PARAMS ((void));\n+static tree resolve_inner_class PARAMS ((struct hash_table *, tree, tree *,\n+\t\t\t\t\t tree *, tree));\n static tree find_as_inner_class PARAMS ((tree, tree, tree));\n static tree find_as_inner_class_do PARAMS ((tree, tree));\n static int check_inner_class_redefinition PARAMS ((tree, tree));\n@@ -349,9 +353,6 @@ int do_not_fold;\n /* Cyclic inheritance report, as it can be set by layout_class */\n const char *cyclic_inheritance_report;\n  \n-/* Tell when we're within an instance initializer */\n-static int in_instance_initializer;\n-\n /* The current parser context */\n struct parser_ctxt *ctxp;\n \n@@ -3528,6 +3529,74 @@ check_inner_class_redefinition (raw_name, cl)\n   return 0;\n }\n \n+/* Tries to find a decl for CLASS_TYPE within ENCLOSING. If we fail,\n+   we remember ENCLOSING and SUPER.  */\n+\n+static tree\n+resolve_inner_class (circularity_hash, cl, enclosing, super, class_type)\n+     struct hash_table *circularity_hash;\n+     tree cl, *enclosing, *super, class_type;\n+{\n+  tree local_enclosing = *enclosing;\n+  tree local_super = NULL_TREE;\n+\n+  while (local_enclosing)\n+    {\n+      tree intermediate, decl;\n+\n+      hash_lookup (circularity_hash, \n+\t\t   (const  hash_table_key) local_enclosing, TRUE, NULL);\n+\n+      if ((decl = find_as_inner_class (local_enclosing, class_type, cl)))\n+\treturn decl;\n+\n+      intermediate = local_enclosing;\n+      /* Explore enclosing contexts. */\n+      while (INNER_CLASS_DECL_P (intermediate))\n+\t{\n+\t  intermediate = DECL_CONTEXT (intermediate);\n+\t  if ((decl = find_as_inner_class (intermediate, class_type, cl)))\n+\t    return decl;\n+\t}\n+\n+      /* Now go to the upper classes, bail out if necessary. We will\n+\t analyze the returned SUPER and act accordingly (see\n+\t do_resolve_class.) */\n+      local_super = CLASSTYPE_SUPER (TREE_TYPE (local_enclosing));\n+      if (!local_super || local_super == object_type_node)\n+        break;\n+\n+      if (TREE_CODE (local_super) == POINTER_TYPE)\n+        local_super = do_resolve_class (NULL, local_super, NULL, NULL);\n+      else\n+\tlocal_super = TYPE_NAME (local_super);\n+\n+      /* We may not have checked for circular inheritance yet, so do so\n+         here to prevent an infinite loop. */\n+      if (hash_lookup (circularity_hash,\n+\t\t       (const hash_table_key) local_super, FALSE, NULL))\n+        {\n+          if (!cl)\n+            cl = lookup_cl (local_enclosing);\n+\t  \n+          parse_error_context\n+            (cl, \"Cyclic inheritance involving %s\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (local_enclosing)));\n+\t  local_enclosing = NULL_TREE;\n+        }\n+      local_enclosing = local_super;\n+    }\n+\n+  /* We failed. Return LOCAL_SUPER and LOCAL_ENCLOSING. */\n+  *super = local_super;\n+  *enclosing = local_enclosing;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Within ENCLOSING, find a decl for NAME and return it. NAME can be\n+   qualified. */\n+\n static tree\n find_as_inner_class (enclosing, name, cl)\n      tree enclosing, name, cl;\n@@ -4363,29 +4432,71 @@ generate_finit (class_type)\n   return mdecl;\n }\n \n+/* Generate a function to run the instance initialization code. The\n+   private method is called `instinit$'. Unless we're dealing with an\n+   anonymous class, we determine whether all ctors of CLASS_TYPE\n+   declare a checked exception in their `throws' clause in order to\n+   see whether it's necessary to encapsulate the instance initializer\n+   statements in a try/catch/rethrow sequence.  */\n+\n static tree\n-build_instance_initializer (mdecl)\n-     tree mdecl;\n+generate_instinit (class_type)\n+     tree class_type;\n {\n-  tree compound = NULL_TREE;\n-  tree stmt_list = TYPE_II_STMT_LIST (DECL_CONTEXT (mdecl));\n   tree current;\n+  tree compound = NULL_TREE;\n+  tree parms = tree_cons (this_identifier_node,\n+\t\t\t  build_pointer_type (class_type), end_params_node);\n+  tree mdecl = create_artificial_method (class_type, ACC_PRIVATE,\n+\t\t\t\t\t void_type_node,\n+\t\t\t\t\t instinit_identifier_node, parms);\n+\n+  layout_class_method (class_type, CLASSTYPE_SUPER (class_type),\n+\t\t       mdecl, NULL_TREE);\n \n-  for (current = stmt_list; current; current = TREE_CHAIN (current))\n+  /* Gather all the statements in a compound */\n+  for (current = TYPE_II_STMT_LIST (class_type); \n+       current; current = TREE_CHAIN (current))\n     compound = add_stmt_to_compound (compound, NULL_TREE, current);\n \n-  return compound;\n+  /* We need to encapsulate COMPOUND by a try/catch statement to\n+     rethrow exceptions that might occur in the instance initializer.\n+     We do that only if all ctors of CLASS_TYPE are set to catch a\n+     checked exception. This doesn't apply to anonymous classes (since\n+     they don't have declared ctors.) */\n+  if (!ANONYMOUS_CLASS_P (class_type) && \n+      ctors_unchecked_throws_clause_p (class_type))\n+    {\n+      compound = encapsulate_with_try_catch (0, exception_type_node, compound, \n+\t\t\t\t\t     build1 (THROW_EXPR, NULL_TREE,\n+\t\t\t\t\t\t     build_wfl_node (wpv_id)));\n+      DECL_FUNCTION_THROWS (mdecl) = build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t      exception_type_node);\n+    }\n+\n+  start_artificial_method_body (mdecl);\n+  java_method_add_stmt (mdecl, compound);\n+  end_artificial_method_body (mdecl);\n+\n+  return mdecl;\n }\n \n-static void\n-add_instance_initializer (mdecl)\n-     tree mdecl;\n+/* FIXME */\n+static tree\n+build_instinit_invocation (class_type)\n+     tree class_type;\n {\n-  tree compound = build_instance_initializer (mdecl);\n+  tree to_return = NULL_TREE;\n \n-  if (compound)\n-    java_method_add_stmt (mdecl, build1 (INSTANCE_INITIALIZERS_EXPR,\n-\t\t\t\t\t NULL_TREE, compound));\n+  if (TYPE_II_STMT_LIST (class_type))\n+    {\n+      tree parm = build_tree_list (NULL_TREE,\n+\t\t\t\t   build_wfl_node (this_identifier_node));\n+      to_return =\n+\tbuild_method_invocation (build_wfl_node (instinit_identifier_node),\n+\t\t\t\t parm);\n+    }\n+  return to_return;\n }\n \n /* Shared accros method_declarator and method_header to remember the\n@@ -5095,7 +5206,7 @@ register_incomplete_type (kind, wfl, decl, ptr)\n   /* For some dependencies, set the enclosing class of the current\n      class to be the enclosing context */\n   if ((kind == JDEP_SUPER || kind == JDEP_INTERFACE \n-       || kind == JDEP_ANONYMOUS || kind == JDEP_FIELD)\n+       || kind == JDEP_ANONYMOUS)\n       && GET_ENCLOSING_CPC ())\n     JDEP_ENCLOSING (new) = TREE_VALUE (GET_ENCLOSING_CPC ());\n   else\n@@ -5574,7 +5685,7 @@ tree\n do_resolve_class (enclosing, class_type, decl, cl)\n      tree enclosing, class_type, decl, cl;\n {\n-  tree new_class_decl, super;\n+  tree new_class_decl = NULL_TREE, super = NULL_TREE;\n   struct hash_table _ht, *circularity_hash = &_ht;\n \n   /* This hash table is used to register the classes we're going\n@@ -5590,58 +5701,25 @@ do_resolve_class (enclosing, class_type, decl, cl)\n      being loaded from class file. FIXME. */\n   while (enclosing)\n     {\n-      tree intermediate;\n-\n-      hash_lookup (circularity_hash, \n-\t\t   (const  hash_table_key) enclosing, TRUE, NULL);\n-\n-      if ((new_class_decl = find_as_inner_class (enclosing, class_type, cl)))\n-\t{\n-\t  hash_table_free (circularity_hash);\n-\t  return new_class_decl;\n-\t}\n-\n-      intermediate = enclosing;\n-      /* Explore enclosing contexts. */\n-      while (INNER_CLASS_DECL_P (intermediate))\n-\t{\n-\t  intermediate = DECL_CONTEXT (intermediate);\n-\t  if ((new_class_decl = find_as_inner_class (intermediate, \n-\t\t\t\t\t\t     class_type, cl)))\n-\t    {\n-\t      hash_table_free (circularity_hash);\n-\t      return new_class_decl;\n-\t    }\n-\t}\n-\n-      /* Now go to the upper classes, bail out if necessary. */\n-      super = CLASSTYPE_SUPER (TREE_TYPE (enclosing));\n-      if (!super || super == object_type_node)\n-        break;\n+      new_class_decl = resolve_inner_class (circularity_hash, cl, &enclosing,\n+\t\t\t\t\t    &super, class_type);\n+      if (new_class_decl)\n+\tbreak;\n \n-      if (TREE_CODE (super) == POINTER_TYPE)\n-        super = do_resolve_class (NULL, super, NULL, NULL);\n+      /* If we haven't found anything because SUPER reached Object and\n+\t ENCLOSING happens to be an innerclass, try the enclosing context. */\n+      if ((!super || super == object_type_node) && \n+\t  enclosing && INNER_CLASS_DECL_P (enclosing))\n+\tenclosing = DECL_CONTEXT (enclosing);\n       else\n-\tsuper = TYPE_NAME (super);\n-\n-      /* We may not have checked for circular inheritance yet, so do so\n-         here to prevent an infinite loop. */\n-      if (hash_lookup (circularity_hash,\n-\t\t       (const hash_table_key) super, FALSE, NULL))\n-        {\n-          if (!cl)\n-            cl = lookup_cl (enclosing);\n-\t  \n-          parse_error_context\n-            (cl, \"Cyclic inheritance involving %s\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (enclosing)));\n-          break;\n-        }\n-      enclosing = super;\n+\tenclosing = NULL_TREE;\n     }\n \n   hash_table_free (circularity_hash);\n \n+  if (new_class_decl)\n+    return new_class_decl;\n+\n   /* 1- Check for the type in single imports. This will change\n      TYPE_NAME() if something relevant is found */\n   find_in_imports (class_type);\n@@ -5920,8 +5998,9 @@ check_method_redefinition (class, method)\n {\n   tree redef, sig;\n \n-  /* There's no need to verify <clinit> and finit$ */\n-  if (DECL_CLINIT_P (method) || DECL_FINIT_P (method))\n+  /* There's no need to verify <clinit> and finit$ and instinit$ */\n+  if (DECL_CLINIT_P (method)\n+      || DECL_FINIT_P (method) || DECL_INSTINIT_P (method))\n     return 0;\n \n   sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));\n@@ -7460,7 +7539,7 @@ static void\n java_complete_expand_methods (class_decl)\n      tree class_decl;\n {\n-  tree clinit, finit, decl, first_decl;\n+  tree clinit, decl, first_decl;\n \n   current_class = TREE_TYPE (class_decl);\n \n@@ -7482,13 +7561,15 @@ java_complete_expand_methods (class_decl)\n   first_decl = TYPE_METHODS (current_class);\n   clinit = maybe_generate_pre_expand_clinit (current_class);\n \n-  /* Then generate finit$ (if we need to) because constructor will\n+  /* Then generate finit$ (if we need to) because constructors will\n    try to use it.*/\n   if (TYPE_FINIT_STMT_LIST (current_class))\n-    {\n-      finit = generate_finit (current_class);\n-      java_complete_expand_method (finit);\n-    }\n+    java_complete_expand_method (generate_finit (current_class));\n+\n+  /* Then generate instinit$ (if we need to) because constructors will\n+     try to use it. */\n+  if (TYPE_II_STMT_LIST (current_class))\n+    java_complete_expand_method (generate_instinit (current_class));\n \n   /* Now do the constructors */\n   for (decl = first_decl ; !java_error_count && decl; decl = TREE_CHAIN (decl))\n@@ -8498,9 +8579,7 @@ build_dot_class_method (class)\n #define BWF(S) build_wfl_node (get_identifier ((S)))\n #define MQN(X,Y) make_qualified_name ((X), (Y), 0)\n   tree args, tmp, saved_current_function_decl, mdecl;\n-  tree stmt, throw_stmt, catch, catch_block, try_block;\n-  tree catch_clause_param;\n-  tree class_not_found_exception, no_class_def_found_error;\n+  tree stmt, throw_stmt;\n \n   static tree get_message_wfl, type_parm_wfl;\n \n@@ -8520,33 +8599,24 @@ build_dot_class_method (class)\n   /* Build the qualified name java.lang.Class.forName */\n   tmp = MQN (MQN (MQN (BWF (\"java\"), \n \t\t       BWF (\"lang\")), BWF (\"Class\")), BWF (\"forName\"));\n-\n-  /* For things we have to catch and throw */\n-  class_not_found_exception = \n-    lookup_class (get_identifier (\"java.lang.ClassNotFoundException\"));\n-  no_class_def_found_error = \n-    lookup_class (get_identifier (\"java.lang.NoClassDefFoundError\"));\n-  load_class (class_not_found_exception, 1);\n-  load_class (no_class_def_found_error, 1);\n-\n+  load_class (class_not_found_type_node, 1);\n+  load_class (no_class_def_found_type_node, 1);\n+  \n   /* Create the \"class$\" function */\n   mdecl = create_artificial_method (class, ACC_STATIC, \n \t\t\t\t    build_pointer_type (class_type_node),\n \t\t\t\t    classdollar_identifier_node, args);\n-  DECL_FUNCTION_THROWS (mdecl) = build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t  no_class_def_found_error);\n-  \n+  DECL_FUNCTION_THROWS (mdecl) = \n+    build_tree_list (NULL_TREE, no_class_def_found_type_node);\n+\n   /* We start by building the try block. We need to build:\n        return (java.lang.Class.forName (type)); */\n   stmt = build_method_invocation (tmp, \n \t\t\t\t  build_tree_list (NULL_TREE, type_parm_wfl));\n   stmt = build_return (0, stmt);\n-  /* Put it in a block. That's the try block */\n-  try_block = build_expr_block (stmt, NULL_TREE);\n \n   /* Now onto the catch block. We start by building the expression\n-     throwing a new exception: \n-       throw new NoClassDefFoundError (_.getMessage); */\n+     throwing a new exception: throw new NoClassDefFoundError (_.getMessage) */\n   throw_stmt = make_qualified_name (build_wfl_node (wpv_id), \n \t\t\t\t    get_message_wfl, 0);\n   throw_stmt = build_method_invocation (throw_stmt, NULL_TREE);\n@@ -8559,27 +8629,9 @@ build_dot_class_method (class)\n   /* Build the throw, (it's too early to use BUILD_THROW) */\n   throw_stmt = build1 (THROW_EXPR, NULL_TREE, throw_stmt);\n \n-  /* Build the catch block to encapsulate all this. We begin by\n-     building an decl for the catch clause parameter and link it to\n-     newly created block, the catch block. */\n-  catch_clause_param = \n-    build_decl (VAR_DECL, wpv_id, \n-\t\tbuild_pointer_type (class_not_found_exception));\n-  catch_block = build_expr_block (NULL_TREE, catch_clause_param);\n-  \n-  /* We initialize the variable with the exception handler. */\n-  catch = build (MODIFY_EXPR, NULL_TREE, catch_clause_param,\n-\t\t build (JAVA_EXC_OBJ_EXPR, ptr_type_node));\n-  add_stmt_to_block (catch_block, NULL_TREE, catch);\n-\n-  /* We add the statement throwing the new exception */\n-  add_stmt_to_block (catch_block, NULL_TREE, throw_stmt);\n-\n-  /* Build a catch expression for all this */\n-  catch_block = build1 (CATCH_EXPR, NULL_TREE, catch_block);\n-\n-  /* Build the try/catch sequence */\n-  stmt = build_try_statement (0, try_block, catch_block);\n+  /* Encapsulate STMT in a try block. The catch clause executes THROW_STMT */\n+  stmt = encapsulate_with_try_catch (0, class_not_found_type_node,\n+\t\t\t\t     stmt, throw_stmt);\n \n   fix_method_argument_names (args, mdecl);\n   layout_class_method (class, NULL_TREE, mdecl, NULL_TREE);\n@@ -8620,6 +8672,7 @@ static void\n fix_constructors (mdecl)\n      tree mdecl;\n {\n+  tree iii;\t\t\t/* Instance Initializer Invocation */\n   tree body = DECL_FUNCTION_BODY (mdecl);\n   tree thisn_assign, compound = NULL_TREE;\n   tree class_type = DECL_CONTEXT (mdecl);\n@@ -8661,9 +8714,9 @@ fix_constructors (mdecl)\n \t of that. */\n       java_method_add_stmt (mdecl, build_super_invocation (mdecl));\n \n-      /* Insert the instance initializer block right here, after the\n-         super invocation. */\n-      add_instance_initializer (mdecl);\n+      /* FIXME */\n+      if ((iii = build_instinit_invocation (class_type)))\n+\tjava_method_add_stmt (mdecl, iii);\n \n       end_artificial_method_body (mdecl);\n     }\n@@ -8674,7 +8727,6 @@ fix_constructors (mdecl)\n       int invokes_this = 0;\n       tree found_call = NULL_TREE;\n       tree main_block = BLOCK_EXPR_BODY (body);\n-      tree ii;\t\t\t/* Instance Initializer */\n       \n       while (body)\n \tswitch (TREE_CODE (body))\n@@ -8717,8 +8769,8 @@ fix_constructors (mdecl)\n \t}\n       \n       /* Insert the instance initializer block right after. */\n-      if (!invokes_this && (ii = build_instance_initializer (mdecl)))\n-\tcompound = add_stmt_to_compound (compound, NULL_TREE, ii);\n+      if (!invokes_this && (iii = build_instinit_invocation (class_type)))\n+\tcompound = add_stmt_to_compound (compound, NULL_TREE, iii);\n \n       /* Fix the constructor main block if we're adding extra stmts */\n       if (compound)\n@@ -10285,6 +10337,8 @@ patch_method_invocation (patch, primary, where, from_super,\n   if (ret_decl)\n     *ret_decl = list;\n   patch = patch_invoke (patch, list, args);\n+\n+  /* Now is a good time to insert the call to finit$ */\n   if (is_super_init && CLASS_HAS_FINIT_P (current_class))\n     {\n       tree finit_parms, finit_call;\n@@ -10346,7 +10400,8 @@ maybe_use_access_method (is_super_init, mdecl, this_arg)\n   if (is_super_init \n       || DECL_CONTEXT (md) == current_class\n       || !PURE_INNER_CLASS_TYPE_P (current_class) \n-      || DECL_FINIT_P (md))\n+      || DECL_FINIT_P (md)\n+      || DECL_INSTINIT_P (md))\n     return 0;\n   \n   /* If we're calling a method found in an enclosing class, generate\n@@ -10717,10 +10772,10 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n       search_applicable_methods_list (lc, TYPE_METHODS (class), \n \t\t\t\t      name, arglist, &list, &all_list);\n \n-      /* When looking finit$ or class$, we turn LC to 1 so that we\n-\t only search in class. Note that we should have found\n+      /* When looking finit$, class$ or instinit$, we turn LC to 1 so\n+\t that we only search in class. Note that we should have found\n \t something at this point. */\n-      if (ID_FINIT_P (name) || ID_CLASSDOLLAR_P (name))\n+      if (ID_FINIT_P (name) || ID_CLASSDOLLAR_P (name) || ID_INSTINIT_P (name))\n \t{\n \t  lc = 1;\n \t  if (!list)\n@@ -12001,16 +12056,6 @@ java_complete_lhs (node)\n \treturn error_mark_node;\n       break;\n \n-    case INSTANCE_INITIALIZERS_EXPR:\n-      in_instance_initializer++;\n-      node = java_complete_tree (TREE_OPERAND (node, 0));\n-      in_instance_initializer--;\n-      if (node != error_mark_node)\n-\tTREE_TYPE (node) = void_type_node;\n-      else\n-\treturn error_mark_node;\n-      break;\n-\n     default:\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Ok: may be we have a STRING_CST or a crafted `StringBuffer'\n@@ -14709,12 +14754,12 @@ patch_return (node)\n   if (!return_exp && (mtype != void_type_node && !DECL_CONSTRUCTOR_P (meth)))\n     error_found = 2;\n   \n-  if (in_instance_initializer)\n+  if (DECL_INSTINIT_P (current_function_decl))\n     error_found = 1;\n \n   if (error_found)\n     {\n-      if (in_instance_initializer)\n+      if (DECL_INSTINIT_P (current_function_decl))\n \tparse_error_context (wfl_operator,\n \t\t\t     \"`return' inside instance initializer\");\n \t\n@@ -15234,6 +15279,39 @@ patch_switch_statement (node)\n \n /* 14.18 The try/catch statements */\n \n+/* Encapsulate TRY_STMTS' in a try catch sequence. The catch clause\n+   catches TYPE and executes CATCH_STMTS.  */\n+\n+static tree\n+encapsulate_with_try_catch (location, type, try_stmts, catch_stmts)\n+     int location;\n+     tree type, try_stmts, catch_stmts;\n+{\n+  tree try_block, catch_clause_param, catch_block, catch;\n+\n+  /* First build a try block */\n+  try_block = build_expr_block (try_stmts, NULL_TREE);\n+\n+  /* Build a catch block: we need a catch clause parameter */\n+  catch_clause_param = build_decl (VAR_DECL, \n+\t\t\t\t   wpv_id, build_pointer_type (type));\n+  /* And a block */\n+  catch_block = build_expr_block (NULL_TREE, catch_clause_param);\n+  \n+  /* Initialize the variable and store in the block */\n+  catch = build (MODIFY_EXPR, NULL_TREE, catch_clause_param,\n+\t\t build (JAVA_EXC_OBJ_EXPR, ptr_type_node));\n+  add_stmt_to_block (catch_block, NULL_TREE, catch);\n+\n+  /* Add the catch statements */\n+  add_stmt_to_block (catch_block, NULL_TREE, catch_stmts);\n+\n+  /* Now we can build a CATCH_EXPR */\n+  catch_block = build1 (CATCH_EXPR, NULL_TREE, catch_block);\n+\n+  return build_try_statement (location, try_block, catch_block);\n+}\n+\n static tree\n build_try_statement (location, try_block, catches)\n      int location;\n@@ -15468,12 +15546,13 @@ patch_throw_statement (node, wfl_op1)\n   unchecked_ok = IS_UNCHECKED_EXCEPTION_P (TREE_TYPE (type));\n \n   SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n-  /* An instance can't throw a checked excetion unless that exception\n+  /* An instance can't throw a checked exception unless that exception\n      is explicitely declared in the `throws' clause of each\n      constructor. This doesn't apply to anonymous classes, since they\n      don't have declared constructors. */\n   if (!unchecked_ok \n-      && in_instance_initializer && !ANONYMOUS_CLASS_P (current_class))\n+      && DECL_INSTINIT_P (current_function_decl)\n+      && !ANONYMOUS_CLASS_P (current_class))\n     {\n       tree current;\n       for (current = TYPE_METHODS (current_class); current; \n@@ -15621,6 +15700,38 @@ purge_unchecked_exceptions (mdecl)\n   DECL_FUNCTION_THROWS (mdecl) = new;\n }\n \n+/* This function goes over all of CLASS_TYPE ctors and checks whether\n+   each of then features at least one unchecked exception in it\n+   `throws' clause. If it's the case, it returns `true', `false'\n+   otherwise.  */\n+\n+static bool\n+ctors_unchecked_throws_clause_p (class_type)\n+     tree class_type;\n+{\n+  tree current;\n+\n+  for (current = TYPE_METHODS (class_type); current;\n+       current = TREE_CHAIN (current))\n+    {\n+      bool ctu = false;\t/* Ctor Throws Unchecked */\n+      if (DECL_CONSTRUCTOR_P (current))\n+\t{\n+\t  tree throws;\n+\t  for (throws = DECL_FUNCTION_THROWS (current); throws && !ctu;\n+\t       throws = TREE_CHAIN (throws))\n+\t    if (inherits_from_p (TREE_VALUE (throws), exception_type_node))\n+\t      ctu = true;\n+\t}\n+      /* We return false as we found one ctor that is unfit. */\n+      if (!ctu && DECL_CONSTRUCTOR_P (current))\n+\treturn false;\n+    }\n+  /* All ctors feature at least one unchecked exception in their\n+     `throws' clause. */\n+  return true;\n+}\n+\n /* 15.24 Conditional Operator ?: */\n \n static tree"}]}