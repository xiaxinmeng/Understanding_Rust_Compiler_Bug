{"sha": "38163d9a4ec690c5853cce608ac2eb8eb7d4ea00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgxNjNkOWE0ZWM2OTBjNTg1M2NjZTYwOGFjMmViOGViN2Q0ZWEwMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-27T21:12:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-27T21:12:32Z"}, "message": "Initial revision\n\nFrom-SVN: r19445", "tree": {"sha": "9300a68261793482c850ffcb7437485ca5b7d90b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9300a68261793482c850ffcb7437485ca5b7d90b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38163d9a4ec690c5853cce608ac2eb8eb7d4ea00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38163d9a4ec690c5853cce608ac2eb8eb7d4ea00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38163d9a4ec690c5853cce608ac2eb8eb7d4ea00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38163d9a4ec690c5853cce608ac2eb8eb7d4ea00/comments", "author": null, "committer": null, "parents": [{"sha": "ee6d4817d889a18e3aa3fd4483777af7e5798bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee6d4817d889a18e3aa3fd4483777af7e5798bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee6d4817d889a18e3aa3fd4483777af7e5798bae"}], "stats": {"total": 624, "additions": 624, "deletions": 0}, "files": [{"sha": "c4c7a2c7d148cb172425d61f180d262b28e24902", "filename": "gcc/intl/dcgettext.c", "status": "added", "additions": 624, "deletions": 0, "changes": 624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38163d9a4ec690c5853cce608ac2eb8eb7d4ea00/gcc%2Fintl%2Fdcgettext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38163d9a4ec690c5853cce608ac2eb8eb7d4ea00/gcc%2Fintl%2Fdcgettext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Fdcgettext.c?ref=38163d9a4ec690c5853cce608ac2eb8eb7d4ea00", "patch": "@@ -0,0 +1,624 @@\n+/* Implementation of the dcgettext(3) function.\n+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+#include <sys/types.h>\n+\n+#ifdef __GNUC__\n+# define alloca __builtin_alloca\n+# define HAVE_ALLOCA 1\n+#else\n+# if defined HAVE_ALLOCA_H || defined _LIBC\n+#  include <alloca.h>\n+# else\n+#  ifdef _AIX\n+ #pragma alloca\n+#  else\n+#   ifndef alloca\n+char *alloca ();\n+#   endif\n+#  endif\n+# endif\n+#endif\n+\n+#include <errno.h>\n+#ifndef errno\n+extern int errno;\n+#endif\n+#ifndef __set_errno\n+# define __set_errno(val) errno = (val)\n+#endif\n+\n+#if defined STDC_HEADERS || defined _LIBC\n+# include <stdlib.h>\n+#else\n+char *getenv ();\n+# ifdef HAVE_MALLOC_H\n+#  include <malloc.h>\n+# else\n+void free ();\n+# endif\n+#endif\n+\n+#if defined HAVE_STRING_H || defined _LIBC\n+# ifndef _GNU_SOURCE\n+#  define _GNU_SOURCE\t1\n+# endif\n+# include <string.h>\n+#else\n+# include <strings.h>\n+#endif\n+#if !HAVE_STRCHR && !defined _LIBC\n+# ifndef strchr\n+#  define strchr index\n+# endif\n+#endif\n+\n+#if defined HAVE_UNISTD_H || defined _LIBC\n+# include <unistd.h>\n+#endif\n+\n+#include \"gettext.h\"\n+#include \"gettextP.h\"\n+#ifdef _LIBC\n+# include <libintl.h>\n+#else\n+# include \"libgettext.h\"\n+#endif\n+#include \"hash-string.h\"\n+\n+/* @@ end of prolog @@ */\n+\n+#ifdef _LIBC\n+/* Rename the non ANSI C functions.  This is required by the standard\n+   because some ANSI C functions will require linking with this object\n+   file and the name space must not be polluted.  */\n+# define getcwd __getcwd\n+# ifndef stpcpy\n+#  define stpcpy __stpcpy\n+# endif\n+#else\n+# if !defined HAVE_GETCWD\n+char *getwd ();\n+#  define getcwd(buf, max) getwd (buf)\n+# else\n+char *getcwd ();\n+# endif\n+# ifndef HAVE_STPCPY\n+static char *stpcpy PARAMS ((char *dest, const char *src));\n+# endif\n+#endif\n+\n+/* Amount to increase buffer size by in each try.  */\n+#define PATH_INCR 32\n+\n+/* The following is from pathmax.h.  */\n+/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define\n+   PATH_MAX but might cause redefinition warnings when sys/param.h is\n+   later included (as on MORE/BSD 4.3).  */\n+#if defined(_POSIX_VERSION) || (defined(HAVE_LIMITS_H) && !defined(__GNUC__))\n+# include <limits.h>\n+#endif\n+\n+#ifndef _POSIX_PATH_MAX\n+# define _POSIX_PATH_MAX 255\n+#endif\n+\n+#if !defined(PATH_MAX) && defined(_PC_PATH_MAX)\n+# define PATH_MAX (pathconf (\"/\", _PC_PATH_MAX) < 1 ? 1024 : pathconf (\"/\", _PC_PATH_MAX))\n+#endif\n+\n+/* Don't include sys/param.h if it already has been.  */\n+#if defined(HAVE_SYS_PARAM_H) && !defined(PATH_MAX) && !defined(MAXPATHLEN)\n+# include <sys/param.h>\n+#endif\n+\n+#if !defined(PATH_MAX) && defined(MAXPATHLEN)\n+# define PATH_MAX MAXPATHLEN\n+#endif\n+\n+#ifndef PATH_MAX\n+# define PATH_MAX _POSIX_PATH_MAX\n+#endif\n+\n+/* XPG3 defines the result of `setlocale (category, NULL)' as:\n+   ``Directs `setlocale()' to query `category' and return the current\n+     setting of `local'.''\n+   However it does not specify the exact format.  And even worse: POSIX\n+   defines this not at all.  So we can use this feature only on selected\n+   system (e.g. those using GNU C Library).  */\n+#ifdef _LIBC\n+# define HAVE_LOCALE_NULL\n+#endif\n+\n+/* Name of the default domain used for gettext(3) prior any call to\n+   textdomain(3).  The default value for this is \"messages\".  */\n+const char _nl_default_default_domain[] = \"messages\";\n+\n+/* Value used as the default domain for gettext(3).  */\n+const char *_nl_current_default_domain = _nl_default_default_domain;\n+\n+/* Contains the default location of the message catalogs.  */\n+const char _nl_default_dirname[] = GNULOCALEDIR;\n+\n+/* List with bindings of specific domains created by bindtextdomain()\n+   calls.  */\n+struct binding *_nl_domain_bindings;\n+\n+/* Prototypes for local functions.  */\n+static char *find_msg PARAMS ((struct loaded_l10nfile *domain_file,\n+\t\t\t       const char *msgid)) internal_function;\n+static const char *category_to_name PARAMS ((int category)) internal_function;\n+static const char *guess_category_value PARAMS ((int category,\n+\t\t\t\t\t\t const char *categoryname))\n+     internal_function;\n+\n+\n+/* For those loosing systems which don't have `alloca' we have to add\n+   some additional code emulating it.  */\n+#ifdef HAVE_ALLOCA\n+/* Nothing has to be done.  */\n+# define ADD_BLOCK(list, address) /* nothing */\n+# define FREE_BLOCKS(list) /* nothing */\n+#else\n+struct block_list\n+{\n+  void *address;\n+  struct block_list *next;\n+};\n+# define ADD_BLOCK(list, addr)\t\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \\\n+    /* If we cannot get a free block we cannot add the new element to\t      \\\n+       the list.  */\t\t\t\t\t\t\t      \\\n+    if (newp != NULL) {\t\t\t\t\t\t\t      \\\n+      newp->address = (addr);\t\t\t\t\t\t      \\\n+      newp->next = (list);\t\t\t\t\t\t      \\\n+      (list) = newp;\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  } while (0)\n+# define FREE_BLOCKS(list)\t\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    while (list != NULL) {\t\t\t\t\t\t      \\\n+      struct block_list *old = list;\t\t\t\t\t      \\\n+      list = list->next;\t\t\t\t\t\t      \\\n+      free (old);\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  } while (0)\n+# undef alloca\n+# define alloca(size) (malloc (size))\n+#endif\t/* have alloca */\n+\n+\n+/* Names for the libintl functions are a problem.  They must not clash\n+   with existing names and they should follow ANSI C.  But this source\n+   code is also used in GNU C Library where the names have a __\n+   prefix.  So we have to make a difference here.  */\n+#ifdef _LIBC\n+# define DCGETTEXT __dcgettext\n+#else\n+# define DCGETTEXT dcgettext__\n+#endif\n+\n+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY\n+   locale.  */\n+char *\n+DCGETTEXT (domainname, msgid, category)\n+     const char *domainname;\n+     const char *msgid;\n+     int category;\n+{\n+#ifndef HAVE_ALLOCA\n+  struct block_list *block_list = NULL;\n+#endif\n+  struct loaded_l10nfile *domain;\n+  struct binding *binding;\n+  const char *categoryname;\n+  const char *categoryvalue;\n+  char *dirname, *xdomainname;\n+  char *single_locale;\n+  char *retval;\n+  int saved_errno = errno;\n+\n+  /* If no real MSGID is given return NULL.  */\n+  if (msgid == NULL)\n+    return NULL;\n+\n+  /* If DOMAINNAME is NULL, we are interested in the default domain.  If\n+     CATEGORY is not LC_MESSAGES this might not make much sense but the\n+     defintion left this undefined.  */\n+  if (domainname == NULL)\n+    domainname = _nl_current_default_domain;\n+\n+  /* First find matching binding.  */\n+  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)\n+    {\n+      int compare = strcmp (domainname, binding->domainname);\n+      if (compare == 0)\n+\t/* We found it!  */\n+\tbreak;\n+      if (compare < 0)\n+\t{\n+\t  /* It is not in the list.  */\n+\t  binding = NULL;\n+\t  break;\n+\t}\n+    }\n+\n+  if (binding == NULL)\n+    dirname = (char *) _nl_default_dirname;\n+  else if (binding->dirname[0] == '/')\n+    dirname = binding->dirname;\n+  else\n+    {\n+      /* We have a relative path.  Make it absolute now.  */\n+      size_t dirname_len = strlen (binding->dirname) + 1;\n+      size_t path_max;\n+      char *ret;\n+\n+      path_max = (unsigned) PATH_MAX;\n+      path_max += 2;\t\t/* The getcwd docs say to do this.  */\n+\n+      dirname = (char *) alloca (path_max + dirname_len);\n+      ADD_BLOCK (block_list, dirname);\n+\n+      __set_errno (0);\n+      while ((ret = getcwd (dirname, path_max)) == NULL && errno == ERANGE)\n+\t{\n+\t  path_max += PATH_INCR;\n+\t  dirname = (char *) alloca (path_max + dirname_len);\n+\t  ADD_BLOCK (block_list, dirname);\n+\t  __set_errno (0);\n+\t}\n+\n+      if (ret == NULL)\n+\t{\n+\t  /* We cannot get the current working directory.  Don't signal an\n+\t     error but simply return the default string.  */\n+\t  FREE_BLOCKS (block_list);\n+\t  __set_errno (saved_errno);\n+\t  return (char *) msgid;\n+\t}\n+\n+      stpcpy (stpcpy (strchr (dirname, '\\0'), \"/\"), binding->dirname);\n+    }\n+\n+  /* Now determine the symbolic name of CATEGORY and its value.  */\n+  categoryname = category_to_name (category);\n+  categoryvalue = guess_category_value (category, categoryname);\n+\n+  xdomainname = (char *) alloca (strlen (categoryname)\n+\t\t\t\t + strlen (domainname) + 5);\n+  ADD_BLOCK (block_list, xdomainname);\n+\n+  stpcpy (stpcpy (stpcpy (stpcpy (xdomainname, categoryname), \"/\"),\n+\t\t  domainname),\n+\t  \".mo\");\n+\n+  /* Creating working area.  */\n+  single_locale = (char *) alloca (strlen (categoryvalue) + 1);\n+  ADD_BLOCK (block_list, single_locale);\n+\n+\n+  /* Search for the given string.  This is a loop because we perhaps\n+     got an ordered list of languages to consider for th translation.  */\n+  while (1)\n+    {\n+      /* Make CATEGORYVALUE point to the next element of the list.  */\n+      while (categoryvalue[0] != '\\0' && categoryvalue[0] == ':')\n+\t++categoryvalue;\n+      if (categoryvalue[0] == '\\0')\n+\t{\n+\t  /* The whole contents of CATEGORYVALUE has been searched but\n+\t     no valid entry has been found.  We solve this situation\n+\t     by implicitly appending a \"C\" entry, i.e. no translation\n+\t     will take place.  */\n+\t  single_locale[0] = 'C';\n+\t  single_locale[1] = '\\0';\n+\t}\n+      else\n+\t{\n+\t  char *cp = single_locale;\n+\t  while (categoryvalue[0] != '\\0' && categoryvalue[0] != ':')\n+\t    *cp++ = *categoryvalue++;\n+\t  *cp = '\\0';\n+\t}\n+\n+      /* If the current locale value is C (or POSIX) we don't load a\n+\t domain.  Return the MSGID.  */\n+      if (strcmp (single_locale, \"C\") == 0\n+\t  || strcmp (single_locale, \"POSIX\") == 0)\n+\t{\n+\t  FREE_BLOCKS (block_list);\n+\t  __set_errno (saved_errno);\n+\t  return (char *) msgid;\n+\t}\n+\n+\n+      /* Find structure describing the message catalog matching the\n+\t DOMAINNAME and CATEGORY.  */\n+      domain = _nl_find_domain (dirname, single_locale, xdomainname);\n+\n+      if (domain != NULL)\n+\t{\n+\t  retval = find_msg (domain, msgid);\n+\n+\t  if (retval == NULL)\n+\t    {\n+\t      int cnt;\n+\n+\t      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)\n+\t\t{\n+\t\t  retval = find_msg (domain->successor[cnt], msgid);\n+\n+\t\t  if (retval != NULL)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\n+\t  if (retval != NULL)\n+\t    {\n+\t      FREE_BLOCKS (block_list);\n+\t      __set_errno (saved_errno);\n+\t      return retval;\n+\t    }\n+\t}\n+    }\n+  /* NOTREACHED */\n+}\n+\n+#ifdef _LIBC\n+/* Alias for function name in GNU C Library.  */\n+weak_alias (__dcgettext, dcgettext);\n+#endif\n+\n+\n+static char *\n+internal_function\n+find_msg (domain_file, msgid)\n+     struct loaded_l10nfile *domain_file;\n+     const char *msgid;\n+{\n+  size_t top, act, bottom;\n+  struct loaded_domain *domain;\n+\n+  if (domain_file->decided == 0)\n+    _nl_load_domain (domain_file);\n+\n+  if (domain_file->data == NULL)\n+    return NULL;\n+\n+  domain = (struct loaded_domain *) domain_file->data;\n+\n+  /* Locate the MSGID and its translation.  */\n+  if (domain->hash_size > 2 && domain->hash_tab != NULL)\n+    {\n+      /* Use the hashing table.  */\n+      nls_uint32 len = strlen (msgid);\n+      nls_uint32 hash_val = hash_string (msgid);\n+      nls_uint32 idx = hash_val % domain->hash_size;\n+      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));\n+      nls_uint32 nstr = W (domain->must_swap, domain->hash_tab[idx]);\n+\n+      if (nstr == 0)\n+\t/* Hash table entry is empty.  */\n+\treturn NULL;\n+\n+      if (W (domain->must_swap, domain->orig_tab[nstr - 1].length) == len\n+\t  && strcmp (msgid,\n+\t\t     domain->data + W (domain->must_swap,\n+\t\t\t\t       domain->orig_tab[nstr - 1].offset)) == 0)\n+\treturn (char *) domain->data + W (domain->must_swap,\n+\t\t\t\t\t  domain->trans_tab[nstr - 1].offset);\n+\n+      while (1)\n+\t{\n+\t  if (idx >= domain->hash_size - incr)\n+\t    idx -= domain->hash_size - incr;\n+\t  else\n+\t    idx += incr;\n+\n+\t  nstr = W (domain->must_swap, domain->hash_tab[idx]);\n+\t  if (nstr == 0)\n+\t    /* Hash table entry is empty.  */\n+\t    return NULL;\n+\n+\t  if (W (domain->must_swap, domain->orig_tab[nstr - 1].length) == len\n+\t      && strcmp (msgid,\n+\t\t\t domain->data + W (domain->must_swap,\n+\t\t\t\t\t   domain->orig_tab[nstr - 1].offset))\n+\t         == 0)\n+\t    return (char *) domain->data\n+\t      + W (domain->must_swap, domain->trans_tab[nstr - 1].offset);\n+\t}\n+      /* NOTREACHED */\n+    }\n+\n+  /* Now we try the default method:  binary search in the sorted\n+     array of messages.  */\n+  bottom = 0;\n+  top = domain->nstrings;\n+  while (bottom < top)\n+    {\n+      int cmp_val;\n+\n+      act = (bottom + top) / 2;\n+      cmp_val = strcmp (msgid, domain->data\n+\t\t\t       + W (domain->must_swap,\n+\t\t\t\t    domain->orig_tab[act].offset));\n+      if (cmp_val < 0)\n+\ttop = act;\n+      else if (cmp_val > 0)\n+\tbottom = act + 1;\n+      else\n+\tbreak;\n+    }\n+\n+  /* If an translation is found return this.  */\n+  return bottom >= top ? NULL : (char *) domain->data\n+                                + W (domain->must_swap,\n+\t\t\t\t     domain->trans_tab[act].offset);\n+}\n+\n+\n+/* Return string representation of locale CATEGORY.  */\n+static const char *\n+internal_function\n+category_to_name (category)\n+     int category;\n+{\n+  const char *retval;\n+\n+  switch (category)\n+  {\n+#ifdef LC_COLLATE\n+  case LC_COLLATE:\n+    retval = \"LC_COLLATE\";\n+    break;\n+#endif\n+#ifdef LC_CTYPE\n+  case LC_CTYPE:\n+    retval = \"LC_CTYPE\";\n+    break;\n+#endif\n+#ifdef LC_MONETARY\n+  case LC_MONETARY:\n+    retval = \"LC_MONETARY\";\n+    break;\n+#endif\n+#ifdef LC_NUMERIC\n+  case LC_NUMERIC:\n+    retval = \"LC_NUMERIC\";\n+    break;\n+#endif\n+#ifdef LC_TIME\n+  case LC_TIME:\n+    retval = \"LC_TIME\";\n+    break;\n+#endif\n+#ifdef LC_MESSAGES\n+  case LC_MESSAGES:\n+    retval = \"LC_MESSAGES\";\n+    break;\n+#endif\n+#ifdef LC_RESPONSE\n+  case LC_RESPONSE:\n+    retval = \"LC_RESPONSE\";\n+    break;\n+#endif\n+#ifdef LC_ALL\n+  case LC_ALL:\n+    /* This might not make sense but is perhaps better than any other\n+       value.  */\n+    retval = \"LC_ALL\";\n+    break;\n+#endif\n+  default:\n+    /* If you have a better idea for a default value let me know.  */\n+    retval = \"LC_XXX\";\n+  }\n+\n+  return retval;\n+}\n+\n+/* Guess value of current locale from value of the environment variables.  */\n+static const char *\n+internal_function\n+guess_category_value (category, categoryname)\n+     int category;\n+     const char *categoryname;\n+{\n+  const char *retval;\n+\n+  /* The highest priority value is the `LANGUAGE' environment\n+     variable.  This is a GNU extension.  */\n+  retval = getenv (\"LANGUAGE\");\n+  if (retval != NULL && retval[0] != '\\0')\n+    return retval;\n+\n+  /* `LANGUAGE' is not set.  So we have to proceed with the POSIX\n+     methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some\n+     systems this can be done by the `setlocale' function itself.  */\n+#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n+  return setlocale (category, NULL);\n+#else\n+  /* Setting of LC_ALL overwrites all other.  */\n+  retval = getenv (\"LC_ALL\");\n+  if (retval != NULL && retval[0] != '\\0')\n+    return retval;\n+\n+  /* Next comes the name of the desired category.  */\n+  retval = getenv (categoryname);\n+  if (retval != NULL && retval[0] != '\\0')\n+    return retval;\n+\n+  /* Last possibility is the LANG environment variable.  */\n+  retval = getenv (\"LANG\");\n+  if (retval != NULL && retval[0] != '\\0')\n+    return retval;\n+\n+  /* We use C as the default domain.  POSIX says this is implementation\n+     defined.  */\n+  return \"C\";\n+#endif\n+}\n+\n+/* @@ begin of epilog @@ */\n+\n+/* We don't want libintl.a to depend on any other library.  So we\n+   avoid the non-standard function stpcpy.  In GNU C Library this\n+   function is available, though.  Also allow the symbol HAVE_STPCPY\n+   to be defined.  */\n+#if !_LIBC && !HAVE_STPCPY\n+static char *\n+stpcpy (dest, src)\n+     char *dest;\n+     const char *src;\n+{\n+  while ((*dest++ = *src++) != '\\0')\n+    /* Do nothing. */ ;\n+  return dest - 1;\n+}\n+#endif\n+\n+\n+#ifdef _LIBC\n+/* If we want to free all resources we have to do some work at\n+   program's end.  */\n+static void __attribute__ ((unused))\n+free_mem (void)\n+{\n+  struct binding *runp;\n+\n+  for (runp = _nl_domain_bindings; runp != NULL; runp = runp->next)\n+    {\n+      free (runp->domainname);\n+      if (runp->dirname != _nl_default_dirname)\n+\t/* Yes, this is a pointer comparison.  */\n+\tfree (runp->dirname);\n+    }\n+\n+  if (_nl_current_default_domain != _nl_default_default_domain)\n+    /* Yes, again a pointer comparison.  */\n+    free ((char *) _nl_current_default_domain);\n+}\n+\n+text_set_element (__libc_subfreeres, free_mem);\n+#endif"}]}