{"sha": "869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY5YjBhZjVjNWMzNzkwZWY3N2ZmY2MwY2RkZjM1MWE5OWI2Yzc2Mg==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2011-02-20T17:37:03Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-02-20T17:37:03Z"}, "message": "re PR c++/46394 ([C++0X] [4.6 Regression] no matching function with default template parameter)\n\nPR c++/46394\n\ngcc/cp/\n\n\tPR c++/46394\n\t* pt.c (tsubst_pack_expansion): do not use\n\tcp_tree_equal/same_type_p to detect an expansion of a parameter\n\tpack.\n\ngcc/testsuite/\n\n\tPR c++/46394\n\t* g++.dg/template/typedef38.C: New test.\n\nFrom-SVN: r170341", "tree": {"sha": "57dd167d0699fc05779ecc1add424c426cb2f953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57dd167d0699fc05779ecc1add424c426cb2f953"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/comments", "author": null, "committer": null, "parents": [{"sha": "67ad6c8252dad5b26708db00ec1fda7c573af397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ad6c8252dad5b26708db00ec1fda7c573af397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67ad6c8252dad5b26708db00ec1fda7c573af397"}], "stats": {"total": 85, "additions": 78, "deletions": 7}, "files": [{"sha": "a40fd02141bc7f1d52f191e0b2047682dd97a532", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "patch": "@@ -1,3 +1,10 @@\n+2011-02-20  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/46394\n+\t* pt.c (tsubst_pack_expansion): do not use\n+\tcp_tree_equal/same_type_p to detect an expansion of a parameter\n+\tpack.\n+\n 2011-02-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/47503"}, {"sha": "8867225bc4da423e75afdc11012fcfd02dd234a4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "patch": "@@ -8711,19 +8711,51 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t  return result;\n \t}\n \n+      /* For clarity in the comments below let's use the\n+\t representation 'argument_pack<elements>' to denote an\n+\t argument pack and its elements.\n+\n+\t In the 'if' block below, we want to detect cases where\n+\t ARG_PACK is argument_pack<PARM_PACK...>.  I.e, we want to\n+\t check if ARG_PACK is an argument pack which sole element is\n+\t the expansion of PARM_PACK.  That argument pack is typically\n+\t created by template_parm_to_arg when passed a parameter\n+\t pack.  */\n       if (arg_pack\n           && TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg_pack)) == 1\n           && PACK_EXPANSION_P (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0)))\n         {\n           tree expansion = TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0);\n           tree pattern = PACK_EXPANSION_PATTERN (expansion);\n-          if ((TYPE_P (pattern) && same_type_p (pattern, parm_pack))\n-              || (!TYPE_P (pattern) && cp_tree_equal (parm_pack, pattern)))\n-            /* The argument pack that the parameter maps to is just an\n-               expansion of the parameter itself, such as one would\n-               find in the implicit typedef of a class inside the\n-               class itself.  Consider this parameter \"unsubstituted\",\n-               so that we will maintain the outer pack expansion.  */\n+\t  /* So we have an argument_pack<P...>.  We want to test if P\n+\t     is actually PARM_PACK.  We will not use cp_tree_equal to\n+\t     test P and PARM_PACK because during type fixup (by\n+\t     fixup_template_parm) P can be a pre-fixup version of a\n+\t     type and PARM_PACK be its post-fixup version.\n+\t     cp_tree_equal would consider them as different even\n+\t     though we would want to consider them compatible for our\n+\t     precise purpose here.\n+\n+\t     Thus we are going to consider that P and PARM_PACK are\n+\t     compatible if they have the same DECL.  */\n+\t  if ((/* If ARG_PACK is a type parameter pack named by the\n+\t\t  same DECL as parm_pack ...  */\n+\t       (TYPE_P (pattern)\n+\t\t&& TYPE_P (parm_pack)\n+\t\t&& TYPE_NAME (pattern) == TYPE_NAME (parm_pack))\n+\t       /* ... or if ARG_PACK is a non-type parameter\n+\t\t  named by the same DECL as parm_pack ...  */\n+\t       || (TREE_CODE (pattern) == TEMPLATE_PARM_INDEX\n+\t\t   && TREE_CODE (parm_pack) == PARM_DECL\n+\t\t   && TEMPLATE_PARM_DECL (pattern)\n+\t\t   == TEMPLATE_PARM_DECL (DECL_INITIAL (parm_pack))))\n+\t      && template_parameter_pack_p (pattern))\n+            /* ... then the argument pack that the parameter maps to\n+               is just an expansion of the parameter itself, such as\n+               one would find in the implicit typedef of a class\n+               inside the class itself.  Consider this parameter\n+               \"unsubstituted\", so that we will maintain the outer\n+               pack expansion.  */\n             arg_pack = NULL_TREE;\n         }\n           "}, {"sha": "ff5650a0815a6a148271c9865146fbc86990092a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "patch": "@@ -1,3 +1,8 @@\n+2011-02-20  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/46394\n+\t* g++.dg/template/typedef38.C: New test.\n+\n 2011-02-20  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/46818"}, {"sha": "1c764042946760ff1d7a9612dc43650559af79fe", "filename": "gcc/testsuite/g++.dg/template/typedef38.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef38.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869b0af5c5c3790ef77ffcc0cddf351a99b6c762/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef38.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef38.C?ref=869b0af5c5c3790ef77ffcc0cddf351a99b6c762", "patch": "@@ -0,0 +1,27 @@\n+// Origin: PR c++/46394\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do \"compile\" }\n+\n+template<class T>\n+struct S0\n+{\n+  typedef T type;\n+};\n+\n+template<class... X>\n+struct S1\n+{\n+  typedef int I;\n+};\n+\n+struct A\n+{\n+  template<class...U, class V=typename S1<typename S0<U>::type...>::I>\n+  A(U...u);\n+};\n+\n+int\n+main()\n+{\n+  A a(1, 2);\n+}"}]}