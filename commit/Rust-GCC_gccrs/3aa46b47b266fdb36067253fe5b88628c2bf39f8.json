{"sha": "3aa46b47b266fdb36067253fe5b88628c2bf39f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FhNDZiNDdiMjY2ZmRiMzYwNjcyNTNmZTViODg2MjhjMmJmMzlmOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-31T21:44:53Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-31T21:44:53Z"}, "message": "dwarf2out.c (debug_line_str_section): New variable.\n\n\t* dwarf2out.c (debug_line_str_section): New variable.\n\t(debug_line_str_hash): Likewise.\n\t(DEBUG_LINE_STR_SECTION): Define.\n\t(set_indirect_string): Handle DW_FORM_line_strp like\n\tDW_FORM_strp.\n\t(find_string_form): Fix up formatting.\n\t(size_of_die): Handle DW_FORM_line_strp like DW_FORM_strp.\n\tFix up indentation.\n\t(output_die): Handle DW_FORM_line_strp.\n\t(DWARF5_USE_DEBUG_LINE_STR): Define.\n\t(output_line_string): New function.\n\t(output_file_names): Add -gdwarf-5 support.\n\t(output_line_info): Likewise.\n\t(init_sections_and_labels): Initialize debug_line_str_section.\n\t(output_indirect_string): Change 2nd argument from void *\n\tto enum dwarf_form form, compare with form rather than\n\tDW_FORM_strp.\n\t(output_indirect_strings): Pass DW_FORM_strp to\n\toutput_indirect_string traversion.\n\t(dwarf2out_finish): Output .debug_line_str strings.\n\t(dwarf2out_c_finalize): Clear debug_line_str_section and\n\tdebug_line_str_hash.\n\nFrom-SVN: r241723", "tree": {"sha": "c58a1539f5f9eb591fb0a1b3039809bd587f0dc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c58a1539f5f9eb591fb0a1b3039809bd587f0dc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aa46b47b266fdb36067253fe5b88628c2bf39f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa46b47b266fdb36067253fe5b88628c2bf39f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aa46b47b266fdb36067253fe5b88628c2bf39f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa46b47b266fdb36067253fe5b88628c2bf39f8/comments", "author": null, "committer": null, "parents": [{"sha": "f3a5a02f6382f33cf2539aefbb71725bad6742df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a5a02f6382f33cf2539aefbb71725bad6742df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3a5a02f6382f33cf2539aefbb71725bad6742df"}], "stats": {"total": 331, "additions": 289, "deletions": 42}, "files": [{"sha": "9bea1988eff0bcc9acbd8cf73326f45798560580", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa46b47b266fdb36067253fe5b88628c2bf39f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa46b47b266fdb36067253fe5b88628c2bf39f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aa46b47b266fdb36067253fe5b88628c2bf39f8", "patch": "@@ -1,6 +1,31 @@\n+2016-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dwarf2out.c (debug_line_str_section): New variable.\n+\t(debug_line_str_hash): Likewise.\n+\t(DEBUG_LINE_STR_SECTION): Define.\n+\t(set_indirect_string): Handle DW_FORM_line_strp like\n+\tDW_FORM_strp.\n+\t(find_string_form): Fix up formatting.\n+\t(size_of_die): Handle DW_FORM_line_strp like DW_FORM_strp.\n+\tFix up indentation.\n+\t(output_die): Handle DW_FORM_line_strp.\n+\t(DWARF5_USE_DEBUG_LINE_STR): Define.\n+\t(output_line_string): New function.\n+\t(output_file_names): Add -gdwarf-5 support.\n+\t(output_line_info): Likewise.\n+\t(init_sections_and_labels): Initialize debug_line_str_section.\n+\t(output_indirect_string): Change 2nd argument from void *\n+\tto enum dwarf_form form, compare with form rather than\n+\tDW_FORM_strp.\n+\t(output_indirect_strings): Pass DW_FORM_strp to\n+\toutput_indirect_string traversion.\n+\t(dwarf2out_finish): Output .debug_line_str strings.\n+\t(dwarf2out_c_finalize): Clear debug_line_str_section and\n+\tdebug_line_str_hash.\n+\n 2016-10-31  Tom Tromey  <tom@tromey.com>\n \n-\tPR debug/77315:\n+\tPR debug/77315\n \t* dwarf2out.c (mem_loc_descriptor): Use DW_OP_form_tls_address.\n \t(resolve_args_picking_1): Move DW_OP_form_tls_address case next to\n \tDW_OP_GNU_push_tls_address case."}, {"sha": "319cd6318d7912bbdd91016ea7f8060e650108b8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 263, "deletions": 41, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa46b47b266fdb36067253fe5b88628c2bf39f8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa46b47b266fdb36067253fe5b88628c2bf39f8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3aa46b47b266fdb36067253fe5b88628c2bf39f8", "patch": "@@ -167,6 +167,7 @@ static GTY(()) section *debug_loc_section;\n static GTY(()) section *debug_pubnames_section;\n static GTY(()) section *debug_pubtypes_section;\n static GTY(()) section *debug_str_section;\n+static GTY(()) section *debug_line_str_section;\n static GTY(()) section *debug_str_dwo_section;\n static GTY(()) section *debug_str_offsets_section;\n static GTY(()) section *debug_ranges_section;\n@@ -225,15 +226,17 @@ struct indirect_string_hasher : ggc_ptr_hash<indirect_string_node>\n \n static GTY (()) hash_table<indirect_string_hasher> *debug_str_hash;\n \n+static GTY (()) hash_table<indirect_string_hasher> *debug_line_str_hash;\n+\n /* With split_debug_info, both the comp_dir and dwo_name go in the\n    main object file, rather than the dwo, similar to the force_direct\n    parameter elsewhere but with additional complications:\n \n    1) The string is needed in both the main object file and the dwo.\n    That is, the comp_dir and dwo_name will appear in both places.\n \n-   2) Strings can use three forms: DW_FORM_string, DW_FORM_strp or\n-   DW_FORM_GNU_str_index.\n+   2) Strings can use four forms: DW_FORM_string, DW_FORM_strp,\n+   DW_FORM_line_strp or DW_FORM_GNU_str_index.\n \n    3) GCC chooses the form to use late, depending on the size and\n    reference count.\n@@ -3702,6 +3705,9 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #ifndef DEBUG_RANGES_SECTION\n #define DEBUG_RANGES_SECTION\t\".debug_ranges\"\n #endif\n+#ifndef DEBUG_LINE_STR_SECTION\n+#define DEBUG_LINE_STR_SECTION  \".debug_line_str\"\n+#endif\n \n /* Standard ELF section names for compiled code and data.  */\n #ifndef TEXT_SECTION_NAME\n@@ -4281,7 +4287,9 @@ set_indirect_string (struct indirect_string_node *node)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   /* Already indirect is a no op.  */\n-  if (node->form == DW_FORM_strp || node->form == DW_FORM_GNU_str_index)\n+  if (node->form == DW_FORM_strp\n+      || node->form == DW_FORM_line_strp\n+      || node->form == DW_FORM_GNU_str_index)\n     {\n       gcc_assert (node->label);\n       return;\n@@ -4325,7 +4333,7 @@ find_string_form (struct indirect_string_node *node)\n      single module.  */\n   if (DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET\n       || ((debug_str_section->common.flags & SECTION_MERGE) == 0\n-      && (len - DWARF_OFFSET_SIZE) * node->refcount <= len))\n+\t  && (len - DWARF_OFFSET_SIZE) * node->refcount <= len))\n     return node->form = DW_FORM_string;\n \n   set_indirect_string (node);\n@@ -8914,10 +8922,10 @@ size_of_die (dw_die_ref die)\n \t  break;\n \tcase dw_val_class_str:\n           form = AT_string_form (a);\n-          if (form == DW_FORM_strp)\n+\t  if (form == DW_FORM_strp || form == DW_FORM_line_strp)\n \t    size += DWARF_OFFSET_SIZE;\n-         else if (form == DW_FORM_GNU_str_index)\n-            size += size_of_uleb128 (AT_index (a));\n+\t  else if (form == DW_FORM_GNU_str_index)\n+\t    size += size_of_uleb128 (AT_index (a));\n \t  else\n \t    size += strlen (a->dw_attr_val.v.val_str->str) + 1;\n \t  break;\n@@ -10053,6 +10061,11 @@ output_die (dw_die_ref die)\n                                    a->dw_attr_val.v.val_str->label,\n                                    debug_str_section,\n                                    \"%s: \\\"%s\\\"\", name, AT_string (a));\n+\t  else if (a->dw_attr_val.v.val_str->form == DW_FORM_line_strp)\n+\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n+\t\t\t\t   a->dw_attr_val.v.val_str->label,\n+\t\t\t\t   debug_line_str_section,\n+\t\t\t\t   \"%s: \\\"%s\\\"\", name, AT_string (a));\n           else if (a->dw_attr_val.v.val_str->form == DW_FORM_GNU_str_index)\n             dw2_asm_output_data_uleb128 (AT_index (a),\n                                          \"%s: \\\"%s\\\"\", name, AT_string (a));\n@@ -10885,6 +10898,15 @@ output_ranges (void)\n     }\n }\n \n+/* Non-zero if .debug_line_str should be used for .debug_line section\n+   strings or strings that are likely shareable with those.  */\n+#define DWARF5_USE_DEBUG_LINE_STR \\\n+  (!DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET\t\t\\\n+   && (DEBUG_STR_SECTION_FLAGS & SECTION_MERGE) != 0\t\t\\\n+   /* FIXME: there is no .debug_line_str.dwo section,\t\t\\\n+      for -gsplit-dwarf we should use DW_FORM_strx instead.  */\t\\\n+   && !dwarf_split_debug_info)\n+\n /* Data structure containing information about input files.  */\n struct file_info\n {\n@@ -10997,6 +11019,37 @@ file_name_acquire (dwarf_file_data **slot, file_name_acquire_data *fnad)\n   return 1;\n }\n \n+/* Helper function for output_file_names.  Emit a FORM encoded\n+   string STR, with assembly comment start ENTRY_KIND and\n+   index IDX */\n+\n+static void\n+output_line_string (enum dwarf_form form, const char *str,\n+\t\t    const char *entry_kind, unsigned int idx)\n+{\n+  switch (form)\n+    {\n+    case DW_FORM_string:\n+      dw2_asm_output_nstring (str, -1, \"%s: %#x\", entry_kind, idx);\n+      break;\n+    case DW_FORM_line_strp:\n+      if (!debug_line_str_hash)\n+\tdebug_line_str_hash\n+\t  = hash_table<indirect_string_hasher>::create_ggc (10);\n+\n+      struct indirect_string_node *node;\n+      node = find_AT_string_in_table (str, debug_line_str_hash);\n+      set_indirect_string (node);\n+      node->form = form;\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE, node->label,\n+\t\t\t     debug_line_str_section, \"%s: %#x: \\\"%s\\\"\",\n+\t\t\t     entry_kind, 0, node->str);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Output the directory table and the file name table.  We try to minimize\n    the total amount of memory needed.  A heuristic is used to avoid large\n    slowdowns with many input files.  */\n@@ -11017,8 +11070,18 @@ output_file_names (void)\n \n   if (!last_emitted_file)\n     {\n-      dw2_asm_output_data (1, 0, \"End directory table\");\n-      dw2_asm_output_data (1, 0, \"End file name table\");\n+      if (dwarf_version >= 5)\n+\t{\n+\t  dw2_asm_output_data (1, 0, \"Directory entry format count\");\n+\t  dw2_asm_output_data_uleb128 (0, \"Directories count\");\n+\t  dw2_asm_output_data (1, 0, \"File name entry format count\");\n+\t  dw2_asm_output_data_uleb128 (0, \"File names count\");\n+\t}\n+      else\n+\t{\n+\t  dw2_asm_output_data (1, 0, \"End directory table\");\n+\t  dw2_asm_output_data (1, 0, \"End file name table\");\n+\t}\n       return;\n     }\n \n@@ -11141,13 +11204,52 @@ output_file_names (void)\n \n   /* Emit the directory name table.  */\n   idx_offset = dirs[0].length > 0 ? 1 : 0;\n-  for (i = 1 - idx_offset; i < ndirs; i++)\n-    dw2_asm_output_nstring (dirs[i].path,\n-\t\t\t    dirs[i].length\n-\t\t\t     - !DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,\n-\t\t\t    \"Directory Entry: %#x\", i + idx_offset);\n+  enum dwarf_form str_form = DW_FORM_string;\n+  enum dwarf_form idx_form = DW_FORM_udata;\n+  if (dwarf_version >= 5)\n+    {\n+      const char *comp_dir = comp_dir_string ();\n+      if (comp_dir == NULL)\n+\tcomp_dir = \"\";\n+      dw2_asm_output_data (1, 1, \"Directory entry format count\");\n+      if (DWARF5_USE_DEBUG_LINE_STR)\n+\tstr_form = DW_FORM_line_strp;\n+      dw2_asm_output_data_uleb128 (DW_LNCT_path, \"DW_LNCT_path\");\n+      dw2_asm_output_data_uleb128 (str_form, get_DW_FORM_name (str_form));\n+      dw2_asm_output_data_uleb128 (ndirs + idx_offset, \"Directories count\");\n+      if (str_form == DW_FORM_string)\n+\t{\n+\t  dw2_asm_output_nstring (comp_dir, -1, \"Directory Entry: %#x\", 0);\n+\t  for (i = 1 - idx_offset; i < ndirs; i++)\n+\t    dw2_asm_output_nstring (dirs[i].path,\n+\t\t\t\t    dirs[i].length\n+\t\t\t\t    - !DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,\n+\t\t\t\t    \"Directory Entry: %#x\", i + idx_offset);\n+\t}\n+      else\n+\t{\n+\t  output_line_string (str_form, comp_dir, \"Directory Entry\", 0);\n+\t  for (i = 1 - idx_offset; i < ndirs; i++)\n+\t    {\n+\t      const char *str\n+\t\t= ggc_alloc_string (dirs[i].path,\n+\t\t\t\t    dirs[i].length\n+\t\t\t\t    - !DWARF2_DIR_SHOULD_END_WITH_SEPARATOR);\n+\t      output_line_string (str_form, str, \"Directory Entry\",\n+\t\t\t\t  (unsigned) i + idx_offset);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 1 - idx_offset; i < ndirs; i++)\n+\tdw2_asm_output_nstring (dirs[i].path,\n+\t\t\t\tdirs[i].length\n+\t\t\t\t- !DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,\n+\t\t\t\t\"Directory Entry: %#x\", i + idx_offset);\n \n-  dw2_asm_output_data (1, 0, \"End directory table\");\n+      dw2_asm_output_data (1, 0, \"End directory table\");\n+    }\n \n   /* We have to emit them in the order of emitted_number since that's\n      used in the debug info generation.  To do this efficiently we\n@@ -11156,6 +11258,70 @@ output_file_names (void)\n   for (i = 0; i < numfiles; i++)\n     backmap[files[i].file_idx->emitted_number - 1] = i;\n \n+  if (dwarf_version >= 5)\n+    {\n+      const char *filename0 = get_AT_string (comp_unit_die (), DW_AT_name);\n+      if (filename0 == NULL)\n+\tfilename0 = \"\";\n+      /* DW_LNCT_directory_index can use DW_FORM_udata, DW_FORM_data1 and\n+\t DW_FORM_data2.  Choose one based on the number of directories\n+\t and how much space would they occupy in each encoding.\n+\t If we have at most 256 directories, all indexes fit into\n+\t a single byte, so DW_FORM_data1 is most compact (if there\n+\t are at most 128 directories, DW_FORM_udata would be as\n+\t compact as that, but not shorter and slower to decode).  */\n+      if (ndirs + idx_offset <= 256)\n+\tidx_form = DW_FORM_data1;\n+      /* If there are more than 65536 directories, we have to use\n+\t DW_FORM_udata, DW_FORM_data2 can't refer to them.\n+\t Otherwise, compute what space would occupy if all the indexes\n+\t used DW_FORM_udata - sum - and compare that to how large would\n+\t be DW_FORM_data2 encoding, and pick the more efficient one.  */\n+      else if (ndirs + idx_offset <= 65536)\n+\t{\n+\t  unsigned HOST_WIDE_INT sum = 1;\n+\t  for (i = 0; i < numfiles; i++)\n+\t    {\n+\t      int file_idx = backmap[i];\n+\t      int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;\n+\t      sum += size_of_uleb128 (dir_idx);\n+\t    }\n+\t  if (sum >= HOST_WIDE_INT_UC (2) * (numfiles + 1))\n+\t    idx_form = DW_FORM_data2;\n+\t}\n+#ifdef VMS_DEBUGGING_INFO\n+      dw2_asm_output_data (1, 4, \"File name entry format count\");\n+#else\n+      dw2_asm_output_data (1, 2, \"File name entry format count\");\n+#endif\n+      dw2_asm_output_data_uleb128 (DW_LNCT_path, \"DW_LNCT_path\");\n+      dw2_asm_output_data_uleb128 (str_form, get_DW_FORM_name (str_form));\n+      dw2_asm_output_data_uleb128 (DW_LNCT_directory_index,\n+\t\t\t\t   \"DW_LNCT_directory_index\");\n+      dw2_asm_output_data_uleb128 (idx_form, get_DW_FORM_name (idx_form));\n+#ifdef VMS_DEBUGGING_INFO\n+      dw2_asm_output_data_uleb128 (DW_LNCT_timestamp, \"DW_LNCT_timestamp\");\n+      dw2_asm_output_data_uleb128 (DW_FORM_udata, \"DW_FORM_udata\");\n+      dw2_asm_output_data_uleb128 (DW_LNCT_size, \"DW_LNCT_size\");\n+      dw2_asm_output_data_uleb128 (DW_FORM_udata, \"DW_FORM_udata\");\n+#endif\n+      dw2_asm_output_data_uleb128 (numfiles + 1, \"File names count\");\n+\n+      output_line_string (str_form, filename0, \"File Entry\", 0);\n+\n+      /* Include directory index.  */\n+      if (dwarf_version >= 5 && idx_form != DW_FORM_udata)\n+\tdw2_asm_output_data (idx_form == DW_FORM_data1 ? 1 : 2,\n+\t\t\t     0, NULL);\n+      else\n+\tdw2_asm_output_data_uleb128 (0, NULL);\n+\n+#ifdef VMS_DEBUGGING_INFO\n+      dw2_asm_output_data_uleb128 (0, NULL);\n+      dw2_asm_output_data_uleb128 (0, NULL);\n+#endif\n+    }\n+\n   /* Now write all the file names.  */\n   for (i = 0; i < numfiles; i++)\n     {\n@@ -11171,38 +11337,47 @@ output_file_names (void)\n       int ver;\n       long long cdt;\n       long siz;\n-      int maxfilelen = strlen (files[file_idx].path)\n-\t\t\t       + dirs[dir_idx].length\n-\t\t\t       + MAX_VMS_VERSION_LEN + 1;\n+      int maxfilelen = (strlen (files[file_idx].path)\n+\t\t\t+ dirs[dir_idx].length\n+\t\t\t+ MAX_VMS_VERSION_LEN + 1);\n       char *filebuf = XALLOCAVEC (char, maxfilelen);\n \n       vms_file_stats_name (files[file_idx].path, 0, 0, 0, &ver);\n       snprintf (filebuf, maxfilelen, \"%s;%d\",\n \t        files[file_idx].path + dirs[dir_idx].length, ver);\n \n-      dw2_asm_output_nstring\n-\t(filebuf, -1, \"File Entry: %#x\", (unsigned) i + 1);\n+      output_line_string (str_form, filebuf, \"File Entry\", (unsigned) i + 1);\n \n       /* Include directory index.  */\n-      dw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);\n+      if (dwarf_version >= 5 && idx_form != DW_FORM_udata)\n+\tdw2_asm_output_data (idx_form == DW_FORM_data1 ? 1 : 2,\n+\t\t\t     dir_idx + idx_offset, NULL);\n+      else\n+\tdw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);\n \n       /* Modification time.  */\n-      dw2_asm_output_data_uleb128\n-        ((vms_file_stats_name (files[file_idx].path, &cdt, 0, 0, 0) == 0)\n-\t  ? cdt : 0,\n-\t NULL);\n+      dw2_asm_output_data_uleb128 ((vms_file_stats_name (files[file_idx].path,\n+\t\t\t\t\t\t\t &cdt, 0, 0, 0) == 0)\n+\t\t\t\t   ? cdt : 0, NULL);\n \n       /* File length in bytes.  */\n-      dw2_asm_output_data_uleb128\n-        ((vms_file_stats_name (files[file_idx].path, 0, &siz, 0, 0) == 0)\n-      \t  ? siz : 0,\n-\t NULL);\n+      dw2_asm_output_data_uleb128 ((vms_file_stats_name (files[file_idx].path,\n+\t\t\t\t\t\t\t 0, &siz, 0, 0) == 0)\n+\t\t\t\t   ? siz : 0, NULL);\n #else\n-      dw2_asm_output_nstring (files[file_idx].path + dirs[dir_idx].length, -1,\n-\t\t\t      \"File Entry: %#x\", (unsigned) i + 1);\n+      output_line_string (str_form,\n+\t\t\t  files[file_idx].path + dirs[dir_idx].length,\n+\t\t\t  \"File Entry\", (unsigned) i + 1);\n \n       /* Include directory index.  */\n-      dw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);\n+      if (dwarf_version >= 5 && idx_form != DW_FORM_udata)\n+\tdw2_asm_output_data (idx_form == DW_FORM_data1 ? 1 : 2,\n+\t\t\t     dir_idx + idx_offset, NULL);\n+      else\n+\tdw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);\n+\n+      if (dwarf_version >= 5)\n+\tcontinue;\n \n       /* Modification time.  */\n       dw2_asm_output_data_uleb128 (0, NULL);\n@@ -11212,7 +11387,8 @@ output_file_names (void)\n #endif /* VMS_DEBUGGING_INFO */\n     }\n \n-  dw2_asm_output_data (1, 0, \"End file name table\");\n+  if (dwarf_version < 5)\n+    dw2_asm_output_data (1, 0, \"End file name table\");\n }\n \n \n@@ -11336,8 +11512,6 @@ output_line_info (bool prologue_only)\n   static unsigned int generation;\n   char l1[MAX_ARTIFICIAL_LABEL_BYTES], l2[MAX_ARTIFICIAL_LABEL_BYTES];\n   char p1[MAX_ARTIFICIAL_LABEL_BYTES], p2[MAX_ARTIFICIAL_LABEL_BYTES];\n-  /* We don't support DWARFv5 line tables yet.  */\n-  int ver = dwarf_version < 5 ? dwarf_version : 4;\n   bool saw_one = false;\n   int opc;\n \n@@ -11357,7 +11531,12 @@ output_line_info (bool prologue_only)\n \n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n-  dw2_asm_output_data (2, ver, \"DWARF Version\");\n+  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n+  if (dwarf_version >= 5)\n+    {\n+      dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Address Size\");\n+      dw2_asm_output_data (1, 0, \"Segment Size\");\n+    }\n   dw2_asm_output_delta (DWARF_OFFSET_SIZE, p2, p1, \"Prolog Length\");\n   ASM_OUTPUT_LABEL (asm_out_file, p1);\n \n@@ -11371,7 +11550,7 @@ output_line_info (bool prologue_only)\n      and don't let the target override.  */\n   dw2_asm_output_data (1, 1, \"Minimum Instruction Length\");\n \n-  if (ver >= 4)\n+  if (dwarf_version >= 4)\n     dw2_asm_output_data (1, DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN,\n \t\t\t \"Maximum Operations Per Instruction\");\n   dw2_asm_output_data (1, DWARF_LINE_DEFAULT_IS_STMT_START,\n@@ -26409,6 +26588,10 @@ init_sections_and_labels (void)\n \t\t\t\t\tSECTION_DEBUG, NULL);\n   debug_str_section = get_section (DEBUG_STR_SECTION,\n \t\t\t\t   DEBUG_STR_SECTION_FLAGS, NULL);\n+  if (!dwarf_split_debug_info && !DWARF2_ASM_LINE_DEBUG_INFO)\n+    debug_line_str_section = get_section (DEBUG_LINE_STR_SECTION,\n+\t\t\t\t\t  DEBUG_STR_SECTION_FLAGS, NULL);\n+\n   debug_ranges_section = get_section (DEBUG_RANGES_SECTION,\n \t\t\t\t      SECTION_DEBUG, NULL);\n   debug_frame_section = get_section (DEBUG_FRAME_SECTION,\n@@ -26583,12 +26766,12 @@ output_index_string (indirect_string_node **h, unsigned int *cur_idx)\n    htab_traverse.  Emit one queued .debug_str string.  */\n \n int\n-output_indirect_string (indirect_string_node **h, void *)\n+output_indirect_string (indirect_string_node **h, enum dwarf_form form)\n {\n   struct indirect_string_node *node = *h;\n \n   node->form = find_string_form (node);\n-  if (node->form == DW_FORM_strp && node->refcount > 0)\n+  if (node->form == form && node->refcount > 0)\n     {\n       ASM_OUTPUT_LABEL (asm_out_file, node->label);\n       assemble_string (node->str, strlen (node->str) + 1);\n@@ -26604,13 +26787,15 @@ output_indirect_strings (void)\n {\n   switch_to_section (debug_str_section);\n   if (!dwarf_split_debug_info)\n-    debug_str_hash->traverse<void *, output_indirect_string> (NULL);\n+    debug_str_hash->traverse<enum dwarf_form,\n+\t\t\t     output_indirect_string> (DW_FORM_strp);\n   else\n     {\n       unsigned int offset = 0;\n       unsigned int cur_idx = 0;\n \n-      skeleton_debug_str_hash->traverse<void *, output_indirect_string> (NULL);\n+      skeleton_debug_str_hash->traverse<enum dwarf_form,\n+\t\t\t\t\toutput_indirect_string> (DW_FORM_strp);\n \n       switch_to_section (debug_str_offsets_section);\n       debug_str_hash->traverse_noresize\n@@ -28998,6 +29183,13 @@ dwarf2out_finish (const char *)\n   /* If we emitted any indirect strings, output the string table too.  */\n   if (debug_str_hash || skeleton_debug_str_hash)\n     output_indirect_strings ();\n+  if (debug_line_str_hash)\n+    {\n+      switch_to_section (debug_line_str_section);\n+      const enum dwarf_form form = DW_FORM_line_strp;\n+      debug_line_str_hash->traverse<enum dwarf_form,\n+\t\t\t\t    output_indirect_string> (form);\n+    }\n }\n \n /* Perform any cleanups needed after the early debug generation pass\n@@ -29021,6 +29213,34 @@ dwarf2out_early_finish (const char *filename)\n   add_name_attribute (comp_unit_die (), remap_debug_filename (filename));\n   add_comp_dir_attribute (comp_unit_die ());\n \n+  /* When emitting DWARF5 .debug_line_str, move DW_AT_name and\n+     DW_AT_comp_dir into .debug_line_str section.  */\n+  if (!DWARF2_ASM_LINE_DEBUG_INFO\n+      && dwarf_version >= 5\n+      && DWARF5_USE_DEBUG_LINE_STR)\n+    {\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  dw_attr_node *a = get_AT (comp_unit_die (),\n+\t\t\t\t    i ? DW_AT_comp_dir : DW_AT_name);\n+\t  if (a == NULL\n+\t      || AT_class (a) != dw_val_class_str\n+\t      || strlen (AT_string (a)) + 1 <= DWARF_OFFSET_SIZE)\n+\t    continue;\n+\n+\t  if (! debug_line_str_hash)\n+\t    debug_line_str_hash\n+\t      = hash_table<indirect_string_hasher>::create_ggc (10);\n+\n+\t  struct indirect_string_node *node\n+\t    = find_AT_string_in_table (AT_string (a), debug_line_str_hash);\n+\t  set_indirect_string (node);\n+\t  node->form = DW_FORM_line_strp;\n+\t  a->dw_attr_val.v.val_str->refcount--;\n+\t  a->dw_attr_val.v.val_str = node;\n+\t}\n+    }\n+\n   /* With LTO early dwarf was really finished at compile-time, so make\n      sure to adjust the phase after annotating the LTRANS CU DIE.  */\n   if (in_lto_p)\n@@ -29126,12 +29346,14 @@ dwarf2out_c_finalize (void)\n   debug_pubnames_section = NULL;\n   debug_pubtypes_section = NULL;\n   debug_str_section = NULL;\n+  debug_line_str_section = NULL;\n   debug_str_dwo_section = NULL;\n   debug_str_offsets_section = NULL;\n   debug_ranges_section = NULL;\n   debug_frame_section = NULL;\n   fde_vec = NULL;\n   debug_str_hash = NULL;\n+  debug_line_str_hash = NULL;\n   skeleton_debug_str_hash = NULL;\n   dw2_string_counter = 0;\n   have_multiple_function_sections = false;"}]}