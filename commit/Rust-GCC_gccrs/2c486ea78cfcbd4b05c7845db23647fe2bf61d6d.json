{"sha": "2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM0ODZlYTc4Y2ZjYmQ0YjA1Yzc4NDVkYjIzNjQ3ZmUyYmY2MWQ2ZA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-06-21T08:34:12Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-06-21T08:34:12Z"}, "message": "fold-const.c (fold_cond_expr_with_comparison): New function, extracted from fold.\n\n2004-06-21  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* fold-const.c (fold_cond_expr_with_comparison):\n\tNew function, extracted from fold.\n\t(fold): Extract code to fold A op B ? A : C, use\n\tit to fold A op B ? C : A.  Really optimize\n\tA & N ? N : 0 where N is a power of two.  Avoid\n\trelying on canonicalization and recursion for\n\tfoldings of COND_EXPR to happen.\n\nFrom-SVN: r83428", "tree": {"sha": "9aa35f475aa9c3a7ad4403b4e6b48555f71e3187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aa35f475aa9c3a7ad4403b4e6b48555f71e3187"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "992d907d5caac2269f88788826824df7914fc3ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992d907d5caac2269f88788826824df7914fc3ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/992d907d5caac2269f88788826824df7914fc3ef"}], "stats": {"total": 523, "additions": 305, "deletions": 218}, "files": [{"sha": "e2d9993f9e0ee1c7f02717989a2802e7d1f8d0f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "patch": "@@ -1,3 +1,13 @@\n+2004-06-21  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* fold-const.c (fold_cond_expr_with_comparison):\n+\tNew function, extracted from fold.\n+\t(fold): Extract code to fold A op B ? A : C, use\n+\tit to fold A op B ? C : A.  Really optimize\n+\tA & N ? N : 0 where N is a power of two.  Avoid\n+\trelying on canonicalization and recursion for\n+\tfoldings of COND_EXPR to happen.\n+\t\n 2004-06-20  David Ayers  <d.ayers@inode.at>\n \n \t* objc/objc-act.h (get_object_reference): Rename to"}, {"sha": "220d1af95ac1b49da136c929335a6892c97a97d9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 295, "deletions": 218, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "patch": "@@ -116,6 +116,7 @@ static tree build_range_check (tree, tree, int, tree, tree);\n static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,\n \t\t\t tree);\n static tree fold_range_test (tree);\n+static tree fold_cond_expr_with_comparison (tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n static tree fold_truthop (enum tree_code, tree, tree, tree);\n static tree optimize_minmax_comparison (tree);\n@@ -4088,6 +4089,234 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n   *pin_p = in_p, *plow = low, *phigh = high;\n   return 1;\n }\n+\f\n+\n+/* Subroutine of fold, looking inside expressions of the form\n+   A op B ? A : C, where ARG0 is A op B and ARG2 is C.  This\n+   function is being used also to optimize A op B ? C : A, by\n+   reversing the comparison first.\n+\n+   Return a folded expression whose code is not a COND_EXPR\n+   anymore, or NULL_TREE if no folding opportunity is found.  */\n+\n+static tree\n+fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n+{\n+  enum tree_code comp_code = TREE_CODE (arg0);\n+  tree arg00 = TREE_OPERAND (arg0, 0);\n+  tree arg01 = TREE_OPERAND (arg0, 1);\n+  tree tem;\n+  STRIP_NOPS (arg2);\n+\n+  /* If we have A op 0 ? A : -A, consider applying the following\n+     transformations:\n+\n+     A == 0? A : -A    same as -A\n+     A != 0? A : -A    same as A\n+     A >= 0? A : -A    same as abs (A)\n+     A > 0?  A : -A    same as abs (A)\n+     A <= 0? A : -A    same as -abs (A)\n+     A < 0?  A : -A    same as -abs (A)\n+\n+     None of these transformations work for modes with signed\n+     zeros.  If A is +/-0, the first two transformations will\n+     change the sign of the result (from +0 to -0, or vice\n+     versa).  The last four will fix the sign of the result,\n+     even though the original expressions could be positive or\n+     negative, depending on the sign of A.\n+\n+     Note that all these transformations are correct if A is\n+     NaN, since the two alternatives (A and -A) are also NaNs.  */\n+  if ((FLOAT_TYPE_P (TREE_TYPE (arg01))\n+       ? real_zerop (arg01)\n+       : integer_zerop (arg01))\n+      && TREE_CODE (arg2) == NEGATE_EXPR\n+      && operand_equal_p (TREE_OPERAND (arg2, 0), arg00, 0))\n+    switch (comp_code)\n+      {\n+      case EQ_EXPR:\n+\treturn fold_convert (type, negate_expr (arg00));\n+      case NE_EXPR:\n+\treturn pedantic_non_lvalue (fold_convert (type, arg00));\n+      case GE_EXPR:\n+      case GT_EXPR:\n+\tif (TYPE_UNSIGNED (TREE_TYPE (arg00)))\n+\t  arg00 = fold_convert (lang_hooks.types.signed_type\n+\t\t\t        (TREE_TYPE (arg00)), arg00);\n+\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg00), arg00));\n+\treturn pedantic_non_lvalue (fold_convert (type, tem));\n+      case LE_EXPR:\n+      case LT_EXPR:\n+\tif (TYPE_UNSIGNED (TREE_TYPE (arg00)))\n+\t  arg00 = fold_convert (lang_hooks.types.signed_type\n+\t\t\t        (TREE_TYPE (arg00)), arg00);\n+\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg00), arg00));\n+\treturn negate_expr (fold_convert (type, tem));\n+      default:\n+\tabort ();\n+      }\n+\n+  /* A != 0 ? A : 0 is simply A, unless A is -0.  Likewise\n+     A == 0 ? A : 0 is always 0 unless A is -0.  Note that\n+     both transformations are correct when A is NaN: A != 0\n+     is then true, and A == 0 is false.  */\n+\n+  if (integer_zerop (arg01) && integer_zerop (arg2))\n+    {\n+      if (comp_code == NE_EXPR)\n+\treturn pedantic_non_lvalue (fold_convert (type, arg00));\n+      else if (comp_code == EQ_EXPR)\n+\treturn pedantic_non_lvalue (fold_convert (type, integer_zero_node));\n+    }\n+\n+  /* Try some transformations of A op B ? A : B.\n+\n+     A == B? A : B    same as B\n+     A != B? A : B    same as A\n+     A >= B? A : B    same as max (A, B)\n+     A > B?  A : B    same as max (B, A)\n+     A <= B? A : B    same as min (A, B)\n+     A < B?  A : B    same as min (B, A)\n+\n+     As above, these transformations don't work in the presence\n+     of signed zeros.  For example, if A and B are zeros of\n+     opposite sign, the first two transformations will change\n+     the sign of the result.  In the last four, the original\n+     expressions give different results for (A=+0, B=-0) and\n+     (A=-0, B=+0), but the transformed expressions do not.\n+\n+     The first two transformations are correct if either A or B\n+     is a NaN.  In the first transformation, the condition will\n+     be false, and B will indeed be chosen.  In the case of the\n+     second transformation, the condition A != B will be true,\n+     and A will be chosen.\n+\n+     The conversions to max() and min() are not correct if B is\n+     a number and A is not.  The conditions in the original\n+     expressions will be false, so all four give B.  The min()\n+     and max() versions would give a NaN instead.  */\n+  if (operand_equal_for_comparison_p (arg01, arg2, arg00))\n+    {\n+      tree comp_op0 = arg00;\n+      tree comp_op1 = arg01;\n+      tree comp_type = TREE_TYPE (comp_op0);\n+\n+      /* Avoid adding NOP_EXPRs in case this is an lvalue.  */\n+      if (TYPE_MAIN_VARIANT (comp_type) == TYPE_MAIN_VARIANT (type))\n+\t{\n+\t  comp_type = type;\n+\t  comp_op0 = arg00;\n+\t  comp_op1 = arg2;\n+\t}\n+\n+      switch (comp_code)\n+\t{\n+\tcase EQ_EXPR:\n+\t  return pedantic_non_lvalue (fold_convert (type, arg2));\n+\tcase NE_EXPR:\n+\t  return pedantic_non_lvalue (fold_convert (type, arg00));\n+\tcase LE_EXPR:\n+\tcase LT_EXPR:\n+\t  /* In C++ a ?: expression can be an lvalue, so put the\n+\t     operand which will be used if they are equal first\n+\t     so that we can convert this back to the\n+\t     corresponding COND_EXPR.  */\n+\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00))))\n+\t    return pedantic_non_lvalue (\n+\t\t     fold_convert (type, fold (build2 (MIN_EXPR, comp_type,\n+\t\t\t\t         (comp_code == LE_EXPR\n+\t\t\t\t          ? comp_op0 : comp_op1),\n+\t\t\t\t         (comp_code == LE_EXPR\n+\t\t\t\t          ? comp_op1 : comp_op0)))));\n+\t  break;\n+\tcase GE_EXPR:\n+\tcase GT_EXPR:\n+\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00))))\n+\t    return pedantic_non_lvalue (\n+\t\t     fold_convert (type, fold (build2 (MAX_EXPR, comp_type,\n+\t\t\t\t         (comp_code == GE_EXPR\n+\t\t\t\t          ? comp_op0 : comp_op1),\n+\t\t\t\t         (comp_code == GE_EXPR\n+\t\t\t\t          ? comp_op1 : comp_op0)))));\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  /* If this is A op C1 ? A : C2 with C1 and C2 constant integers,\n+     we might still be able to simplify this.  For example,\n+     if C1 is one less or one more than C2, this might have started\n+     out as a MIN or MAX and been transformed by this function.\n+     Only good for INTEGER_TYPEs, because we need TYPE_MAX_VALUE.  */\n+\n+  if (INTEGRAL_TYPE_P (type)\n+      && TREE_CODE (arg01) == INTEGER_CST\n+      && TREE_CODE (arg2) == INTEGER_CST)\n+    switch (comp_code)\n+      {\n+      case EQ_EXPR:\n+\t/* We can replace A with C1 in this case.  */\n+\targ00 = fold_convert (type, arg01);\n+\treturn fold (build3 (COND_EXPR, type, arg0, arg00, arg2));\n+\n+      case LT_EXPR:\n+\t/* If C1 is C2 + 1, this is min(A, C2).  */\n+\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type),\n+\t\t\t       OEP_ONLY_CONST)\n+\t    && operand_equal_p (arg01,\n+\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n+\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\tOEP_ONLY_CONST))\n+\t  return pedantic_non_lvalue (fold (build2 (MIN_EXPR,\n+\t\t\t\t\t\t    type, arg00, arg2)));\n+\tbreak;\n+\n+      case LE_EXPR:\n+\t/* If C1 is C2 - 1, this is min(A, C2).  */\n+\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type),\n+\t\t\t       OEP_ONLY_CONST)\n+\t    && operand_equal_p (arg01,\n+\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n+\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\tOEP_ONLY_CONST))\n+\t  return pedantic_non_lvalue (fold (build2 (MIN_EXPR,\n+\t\t\t\t\t\t    type, arg00, arg2)));\n+\tbreak;\n+\n+      case GT_EXPR:\n+\t/* If C1 is C2 - 1, this is max(A, C2).  */\n+\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type),\n+\t\t\t       OEP_ONLY_CONST)\n+\t    && operand_equal_p (arg01,\n+\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n+\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\tOEP_ONLY_CONST))\n+\t  return pedantic_non_lvalue (fold (build2 (MAX_EXPR,\n+\t\t\t\t\t\t    type, arg00, arg2)));\n+\tbreak;\n+\n+      case GE_EXPR:\n+\t/* If C1 is C2 + 1, this is max(A, C2).  */\n+\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type),\n+\t\t\t       OEP_ONLY_CONST)\n+\t    && operand_equal_p (arg01,\n+\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n+\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\tOEP_ONLY_CONST))\n+\t  return pedantic_non_lvalue (fold (build2 (MAX_EXPR,\n+\t\t\t\t\t\t    type, arg00, arg2)));\n+\tbreak;\n+      case NE_EXPR:\n+\tbreak;\n+      default:\n+\tabort ();\n+      }\n+\n+  return NULL_TREE;\n+}\n+\n+\n \f\n #ifndef RANGE_TEST_NON_SHORT_CIRCUIT\n #define RANGE_TEST_NON_SHORT_CIRCUIT (BRANCH_COST >= 2)\n@@ -8325,227 +8554,33 @@ fold (tree expr)\n       /* If we have A op B ? A : C, we may be able to convert this to a\n \t simpler expression, depending on the operation and the values\n \t of B and C.  Signed zeros prevent all of these transformations,\n-\t for reasons given above each one.  */\n+\t for reasons given above each one.\n \n+         Also try swapping the arguments and inverting the conditional.  */\n       if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1))\n \t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n \t{\n-\t  tree arg2 = TREE_OPERAND (t, 2);\n-\t  enum tree_code comp_code = TREE_CODE (arg0);\n-\n-\t  STRIP_NOPS (arg2);\n-\n-\t  /* If we have A op 0 ? A : -A, consider applying the following\n-\t     transformations:\n-\n-\t     A == 0? A : -A    same as -A\n-\t     A != 0? A : -A    same as A\n-\t     A >= 0? A : -A    same as abs (A)\n-\t     A > 0?  A : -A    same as abs (A)\n-\t     A <= 0? A : -A    same as -abs (A)\n-\t     A < 0?  A : -A    same as -abs (A)\n-\n-\t     None of these transformations work for modes with signed\n-\t     zeros.  If A is +/-0, the first two transformations will\n-\t     change the sign of the result (from +0 to -0, or vice\n-\t     versa).  The last four will fix the sign of the result,\n-\t     even though the original expressions could be positive or\n-\t     negative, depending on the sign of A.\n-\n-\t     Note that all these transformations are correct if A is\n-\t     NaN, since the two alternatives (A and -A) are also NaNs.  */\n-\t  if ((FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 1)))\n-\t       ? real_zerop (TREE_OPERAND (arg0, 1))\n-\t       : integer_zerop (TREE_OPERAND (arg0, 1)))\n-\t      && TREE_CODE (arg2) == NEGATE_EXPR\n-\t      && operand_equal_p (TREE_OPERAND (arg2, 0), arg1, 0))\n-\t    switch (comp_code)\n-\t      {\n-\t      case EQ_EXPR:\n-\t\ttem = fold_convert (TREE_TYPE (TREE_OPERAND (t, 1)), arg1);\n-\t\ttem = fold_convert (type, negate_expr (tem));\n-\t\treturn pedantic_non_lvalue (tem);\n-\t      case NE_EXPR:\n-\t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n-\t      case GE_EXPR:\n-\t      case GT_EXPR:\n-\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  arg1 = fold_convert (lang_hooks.types.signed_type\n-\t\t\t\t       (TREE_TYPE (arg1)), arg1);\n-\t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n-\t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n-\t      case LE_EXPR:\n-\t      case LT_EXPR:\n-\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  arg1 = fold_convert (lang_hooks.types.signed_type\n-\t\t\t\t       (TREE_TYPE (arg1)), arg1);\n-\t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n-\t\targ1 = negate_expr (fold_convert (type, arg1));\n-\t\treturn pedantic_non_lvalue (arg1);\n-\t      default:\n-\t\tabort ();\n-\t      }\n-\n-\t  /* A != 0 ? A : 0 is simply A, unless A is -0.  Likewise\n-\t     A == 0 ? A : 0 is always 0 unless A is -0.  Note that\n-\t     both transformations are correct when A is NaN: A != 0\n-\t     is then true, and A == 0 is false.  */\n-\n-\t  if (integer_zerop (TREE_OPERAND (arg0, 1)) && integer_zerop (arg2))\n-\t    {\n-\t      if (comp_code == NE_EXPR)\n-\t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n-\t      else if (comp_code == EQ_EXPR)\n-\t\treturn pedantic_non_lvalue (fold_convert (type, integer_zero_node));\n-\t    }\n+\t  tem = fold_cond_expr_with_comparison (type, arg0,\n+\t\t\t\t\t\tTREE_OPERAND (t, 2));\n+\t  if (tem)\n+\t    return tem;\n+\t}\n \n-\t  /* Try some transformations of A op B ? A : B.\n-\n-\t     A == B? A : B    same as B\n-\t     A != B? A : B    same as A\n-\t     A >= B? A : B    same as max (A, B)\n-\t     A > B?  A : B    same as max (B, A)\n-\t     A <= B? A : B    same as min (A, B)\n-\t     A < B?  A : B    same as min (B, A)\n-\n-\t     As above, these transformations don't work in the presence\n-\t     of signed zeros.  For example, if A and B are zeros of\n-\t     opposite sign, the first two transformations will change\n-\t     the sign of the result.  In the last four, the original\n-\t     expressions give different results for (A=+0, B=-0) and\n-\t     (A=-0, B=+0), but the transformed expressions do not.\n-\n-\t     The first two transformations are correct if either A or B\n-\t     is a NaN.  In the first transformation, the condition will\n-\t     be false, and B will indeed be chosen.  In the case of the\n-\t     second transformation, the condition A != B will be true,\n-\t     and A will be chosen.\n-\n-\t     The conversions to max() and min() are not correct if B is\n-\t     a number and A is not.  The conditions in the original\n-\t     expressions will be false, so all four give B.  The min()\n-\t     and max() versions would give a NaN instead.  */\n-\t  if (operand_equal_for_comparison_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t      arg2, TREE_OPERAND (arg0, 0)))\n+      if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+\t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t     TREE_OPERAND (t, 2),\n+\t\t\t\t\t     TREE_OPERAND (arg0, 1))\n+\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 2)))))\n+\t{\n+\t  tem = invert_truthvalue (arg0);\n+\t  if (TREE_CODE_CLASS (TREE_CODE (tem)) == '<')\n \t    {\n-\t      tree comp_op0 = TREE_OPERAND (arg0, 0);\n-\t      tree comp_op1 = TREE_OPERAND (arg0, 1);\n-\t      tree comp_type = TREE_TYPE (comp_op0);\n-\n-\t      /* Avoid adding NOP_EXPRs in case this is an lvalue.  */\n-\t      if (TYPE_MAIN_VARIANT (comp_type) == TYPE_MAIN_VARIANT (type))\n-\t\t{\n-\t\t  comp_type = type;\n-\t\t  comp_op0 = arg1;\n-\t\t  comp_op1 = arg2;\n-\t\t}\n-\n-\t      switch (comp_code)\n-\t\t{\n-\t\tcase EQ_EXPR:\n-\t\t  return pedantic_non_lvalue (fold_convert (type, arg2));\n-\t\tcase NE_EXPR:\n-\t\t  return pedantic_non_lvalue (fold_convert (type, arg1));\n-\t\tcase LE_EXPR:\n-\t\tcase LT_EXPR:\n-\t\t  /* In C++ a ?: expression can be an lvalue, so put the\n-\t\t     operand which will be used if they are equal first\n-\t\t     so that we can convert this back to the\n-\t\t     corresponding COND_EXPR.  */\n-\t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t\t    return pedantic_non_lvalue (fold_convert\n-\t\t      (type, fold (build2 (MIN_EXPR, comp_type,\n-\t\t\t\t\t   (comp_code == LE_EXPR\n-\t\t\t\t\t    ? comp_op0 : comp_op1),\n-\t\t\t\t\t   (comp_code == LE_EXPR\n-\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n-\t\t  break;\n-\t\tcase GE_EXPR:\n-\t\tcase GT_EXPR:\n-\t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t\t    return pedantic_non_lvalue (fold_convert\n-\t\t      (type, fold (build2 (MAX_EXPR, comp_type,\n-\t\t\t\t\t   (comp_code == GE_EXPR\n-\t\t\t\t\t    ? comp_op0 : comp_op1),\n-\t\t\t\t\t   (comp_code == GE_EXPR\n-\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n-\t\t  break;\n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n+\t      tem = fold_cond_expr_with_comparison (type, tem, arg1);\n+\t      if (tem)\n+\t\treturn tem;\n \t    }\n-\n-\t  /* If this is A op C1 ? A : C2 with C1 and C2 constant integers,\n-\t     we might still be able to simplify this.  For example,\n-\t     if C1 is one less or one more than C2, this might have started\n-\t     out as a MIN or MAX and been transformed by this function.\n-\t     Only good for INTEGER_TYPEs, because we need TYPE_MAX_VALUE.  */\n-\n-\t  if (INTEGRAL_TYPE_P (type)\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t      && TREE_CODE (arg2) == INTEGER_CST)\n-\t    switch (comp_code)\n-\t      {\n-\t      case EQ_EXPR:\n-\t\t/* We can replace A with C1 in this case.  */\n-\t\targ1 = fold_convert (type, TREE_OPERAND (arg0, 1));\n-\t\treturn fold (build3 (code, type, TREE_OPERAND (t, 0), arg1,\n-\t\t\t\t     TREE_OPERAND (t, 2)));\n-\n-\t      case LT_EXPR:\n-\t\t/* If C1 is C2 + 1, this is min(A, C2).  */\n-\t\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type),\n-\t\t\t\t       OEP_ONLY_CONST)\n-\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node, 0),\n-\t\t\t\t\tOEP_ONLY_CONST))\n-\t\t  return pedantic_non_lvalue\n-\t\t    (fold (build2 (MIN_EXPR, type, arg1, arg2)));\n-\t\tbreak;\n-\n-\t      case LE_EXPR:\n-\t\t/* If C1 is C2 - 1, this is min(A, C2).  */\n-\t\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type),\n-\t\t\t\t       OEP_ONLY_CONST)\n-\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node, 0),\n-\t\t\t\t\tOEP_ONLY_CONST))\n-\t\t  return pedantic_non_lvalue\n-\t\t    (fold (build2 (MIN_EXPR, type, arg1, arg2)));\n-\t\tbreak;\n-\n-\t      case GT_EXPR:\n-\t\t/* If C1 is C2 - 1, this is max(A, C2).  */\n-\t\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type),\n-\t\t\t\t       OEP_ONLY_CONST)\n-\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node, 0),\n-\t\t\t\t\tOEP_ONLY_CONST))\n-\t\t  return pedantic_non_lvalue\n-\t\t    (fold (build2 (MAX_EXPR, type, arg1, arg2)));\n-\t\tbreak;\n-\n-\t      case GE_EXPR:\n-\t\t/* If C1 is C2 + 1, this is max(A, C2).  */\n-\t\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type),\n-\t\t\t\t       OEP_ONLY_CONST)\n-\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node, 0),\n-\t\t\t\t\tOEP_ONLY_CONST))\n-\t\t  return pedantic_non_lvalue\n-\t\t    (fold (build2 (MAX_EXPR, type, arg1, arg2)));\n-\t\tbreak;\n-\t      case NE_EXPR:\n-\t\tbreak;\n-\t      default:\n-\t\tabort ();\n-\t      }\n \t}\n \n       /* If the second operand is simpler than the third, swap them\n@@ -8581,9 +8616,34 @@ fold (tree expr)\n \treturn pedantic_non_lvalue (fold_convert (type,\n \t\t\t\t\t\t  invert_truthvalue (arg0)));\n \n-      /* Look for expressions of the form A & 2 ? 2 : 0.  The result of this\n-\t operation is simply A & 2.  */\n+      /* A < 0 ? <sign bit of A> : 0 is simply (A & <sign bit of A>).  */\n+      if (TREE_CODE (arg0) == LT_EXPR\n+          && integer_zerop (TREE_OPERAND (arg0, 1))\n+          && integer_zerop (TREE_OPERAND (t, 2))\n+          && (tem = sign_bit_p (TREE_OPERAND (arg0, 0), arg1)))\n+        return fold_convert (type, fold (build2 (BIT_AND_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (tem), tem, arg1)));\n \n+      /* (A >> N) & 1 ? (1 << N) : 0 is simply A & (1 << N).  A & 1 was\n+\t already handled above.  */\n+      if (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && integer_onep (TREE_OPERAND (arg0, 1))\n+\t  && integer_zerop (TREE_OPERAND (t, 2))\n+\t  && integer_pow2p (arg1))\n+\t{\n+\t  tree tem = TREE_OPERAND (arg0, 0);\n+\t  STRIP_NOPS (tem);\n+\t  if (TREE_CODE (tem) == RSHIFT_EXPR\n+              && (unsigned HOST_WIDE_INT) tree_log2 (arg1) ==\n+\t         TREE_INT_CST_LOW (TREE_OPERAND (tem, 1)))\n+\t    return fold (build2 (BIT_AND_EXPR, type,\n+\t\t\t\t TREE_OPERAND (tem, 0), arg1));\n+\t}\n+\n+      /* A & N ? N : 0 is simply A & N if N is a power of two.  This\n+\t is probably obsolete because the first operand should be a\n+\t truth value (that's why we have the two cases above), but let's\n+\t leave it in until we can confirm this for all front-ends.  */\n       if (integer_zerop (TREE_OPERAND (t, 2))\n \t  && TREE_CODE (arg0) == NE_EXPR\n \t  && integer_zerop (TREE_OPERAND (arg0, 1))\n@@ -8598,8 +8658,7 @@ fold (tree expr)\n       if (integer_zerop (TREE_OPERAND (t, 2))\n \t  && truth_value_p (TREE_CODE (arg0))\n \t  && truth_value_p (TREE_CODE (arg1)))\n-\treturn pedantic_non_lvalue (fold (build2 (TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t\t\t  arg0, arg1)));\n+\treturn fold (build2 (TRUTH_ANDIF_EXPR, type, arg0, arg1));\n \n       /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n       if (integer_onep (TREE_OPERAND (t, 2))\n@@ -8609,10 +8668,28 @@ fold (tree expr)\n \t  /* Only perform transformation if ARG0 is easily inverted.  */\n \t  tem = invert_truthvalue (arg0);\n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return pedantic_non_lvalue (fold (build2 (TRUTH_ORIF_EXPR, type,\n-\t\t\t\t\t\t      tem, arg1)));\n+\t    return fold (build2 (TRUTH_ORIF_EXPR, type, tem, arg1));\n \t}\n \n+      /* Convert A ? 0 : B into !A && B if A and B are truth values.  */\n+      if (integer_zerop (arg1)\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n+\t{\n+\t  /* Only perform transformation if ARG0 is easily inverted.  */\n+\t  tem = invert_truthvalue (arg0);\n+\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n+\t    return fold (build2 (TRUTH_ANDIF_EXPR, type, tem,\n+\t\t\t\t TREE_OPERAND (t, 2)));\n+\t}\n+\n+      /* Convert A ? 1 : B into A || B if A and B are truth values.  */\n+      if (integer_onep (arg1)\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n+\treturn fold (build2 (TRUTH_ORIF_EXPR, type, arg0,\n+\t\t\t     TREE_OPERAND (t, 2)));\n+\n       return t;\n \n     case COMPOUND_EXPR:"}]}