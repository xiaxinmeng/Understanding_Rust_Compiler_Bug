{"sha": "c9e7a60950592e24cc380f0237bea7e652b9f3ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzllN2E2MDk1MDU5MmUyNGNjMzgwZjAyMzdiZWE3ZTY1MmI5ZjNjZQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-27T12:59:38Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-27T12:59:38Z"}, "message": "cpphash.h: Update comment.\n\n\t* cpphash.h: Update comment.\n\t* cpplex.c: Update comments.\n\t(_cpp_can_paste): Remove.\n\t* cpplib.h (_cpp_can_paste): Remove.\n\t* cppmacro.c (paste_tokens, paste_all_tokens): Update to use the\n\tlexer rather than _cpp_can_paste.\n\nFrom-SVN: r45840", "tree": {"sha": "d835d4e32aff0f03e3639d3951a23a7302f304db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d835d4e32aff0f03e3639d3951a23a7302f304db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9e7a60950592e24cc380f0237bea7e652b9f3ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e7a60950592e24cc380f0237bea7e652b9f3ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e7a60950592e24cc380f0237bea7e652b9f3ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e7a60950592e24cc380f0237bea7e652b9f3ce/comments", "author": null, "committer": null, "parents": [{"sha": "4cf817a7ebc85c4c12a3480b3179fb517964fdde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf817a7ebc85c4c12a3480b3179fb517964fdde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cf817a7ebc85c4c12a3480b3179fb517964fdde"}], "stats": {"total": 252, "additions": 65, "deletions": 187}, "files": [{"sha": "cc5d46d896669e292b802ae3f475ff60ca4c5dec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9e7a60950592e24cc380f0237bea7e652b9f3ce", "patch": "@@ -1,3 +1,12 @@\n+2001-09-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h: Update comment.\n+\t* cpplex.c: Update comments.\n+\t(_cpp_can_paste): Remove.\n+\t* cpplib.h (_cpp_can_paste): Remove.\n+\t* cppmacro.c (paste_tokens, paste_all_tokens): Update to use the\n+\tlexer rather than _cpp_can_paste.\n+\n 2001-09-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* doc/cppinternals.texi: Update."}, {"sha": "5bb2ce5e68192ba193401947a448cfa570992352", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=c9e7a60950592e24cc380f0237bea7e652b9f3ce", "patch": "@@ -134,7 +134,7 @@ struct cpp_context\n   union utoken last;\n \n   /* If non-NULL, a buffer used for storage related to this context.\n-     When the context is popped, the buffer is freed.  */\n+     When the context is popped, the buffer is released.  */\n   _cpp_buff *buff;\n \n   /* For a macro context, these are the macro and its arguments.  */"}, {"sha": "1c6d0dd48ac55b94d2d39040726d300c4e40789d", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 108, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=c9e7a60950592e24cc380f0237bea7e652b9f3ce", "patch": "@@ -1218,7 +1218,6 @@ _cpp_lex_direct (pfile)\n \n       /* Save the comment as a token in its own right.  */\n       save_comment (pfile, result, comment_start);\n-      /* Don't do MI optimisation.  */\n       break;\n \n     case '<':\n@@ -1588,112 +1587,6 @@ _cpp_equiv_tokens (a, b)\n   return 0;\n }\n \n-/* Determine whether two tokens can be pasted together, and if so,\n-   what the resulting token is.  Returns CPP_EOF if the tokens cannot\n-   be pasted, or the appropriate type for the merged token if they\n-   can.  */\n-enum cpp_ttype\n-cpp_can_paste (pfile, token1, token2, digraph)\n-     cpp_reader * pfile;\n-     const cpp_token *token1, *token2;\n-     int* digraph;\n-{\n-  enum cpp_ttype a = token1->type, b = token2->type;\n-  int cxx = CPP_OPTION (pfile, cplusplus);\n-\n-  /* Treat named operators as if they were ordinary NAMEs.  */\n-  if (token1->flags & NAMED_OP)\n-    a = CPP_NAME;\n-  if (token2->flags & NAMED_OP)\n-    b = CPP_NAME;\n-\n-  if ((int) a <= (int) CPP_LAST_EQ && b == CPP_EQ)\n-    return (enum cpp_ttype) ((int) a + ((int) CPP_EQ_EQ - (int) CPP_EQ));\n-\n-  switch (a)\n-    {\n-    case CPP_GREATER:\n-      if (b == a) return CPP_RSHIFT;\n-      if (b == CPP_QUERY && cxx)\treturn CPP_MAX;\n-      if (b == CPP_GREATER_EQ)\treturn CPP_RSHIFT_EQ;\n-      break;\n-    case CPP_LESS:\n-      if (b == a) return CPP_LSHIFT;\n-      if (b == CPP_QUERY && cxx)\treturn CPP_MIN;\n-      if (b == CPP_LESS_EQ)\treturn CPP_LSHIFT_EQ;\n-      if (CPP_OPTION (pfile, digraphs))\n-\t{\n-\t  if (b == CPP_COLON)\n-\t    {*digraph = 1; return CPP_OPEN_SQUARE;} /* <: digraph */\n-\t  if (b == CPP_MOD)\n-\t    {*digraph = 1; return CPP_OPEN_BRACE;}\t/* <% digraph */\n-\t}\n-      break;\n-\n-    case CPP_PLUS: if (b == a)\treturn CPP_PLUS_PLUS; break;\n-    case CPP_AND:  if (b == a)\treturn CPP_AND_AND; break;\n-    case CPP_OR:   if (b == a)\treturn CPP_OR_OR;   break;\n-\n-    case CPP_MINUS:\n-      if (b == a)\t\treturn CPP_MINUS_MINUS;\n-      if (b == CPP_GREATER)\treturn CPP_DEREF;\n-      break;\n-    case CPP_COLON:\n-      if (b == a && cxx)\treturn CPP_SCOPE;\n-      if (b == CPP_GREATER && CPP_OPTION (pfile, digraphs))\n-\t{*digraph = 1; return CPP_CLOSE_SQUARE;} /* :> digraph */\n-      break;\n-\n-    case CPP_MOD:\n-      if (CPP_OPTION (pfile, digraphs))\n-\t{\n-\t  if (b == CPP_GREATER)\n-\t    {*digraph = 1; return CPP_CLOSE_BRACE;}  /* %> digraph */\n-\t  if (b == CPP_COLON)\n-\t    {*digraph = 1; return CPP_HASH;}         /* %: digraph */\n-\t}\n-      break;\n-    case CPP_DEREF:\n-      if (b == CPP_MULT && cxx)\treturn CPP_DEREF_STAR;\n-      break;\n-    case CPP_DOT:\n-      if (b == CPP_MULT && cxx)\treturn CPP_DOT_STAR;\n-      if (b == CPP_NUMBER)\treturn CPP_NUMBER;\n-      break;\n-\n-    case CPP_HASH:\n-      if (b == a && (token1->flags & DIGRAPH) == (token2->flags & DIGRAPH))\n-\t/* %:%: digraph */\n-\t{*digraph = (token1->flags & DIGRAPH); return CPP_PASTE;}\n-      break;\n-\n-    case CPP_NAME:\n-      if (b == CPP_NAME)\treturn CPP_NAME;\n-      if (b == CPP_NUMBER\n-\t  && name_p (pfile, &token2->val.str)) return CPP_NAME;\n-      if (b == CPP_CHAR\n-\t  && token1->val.node == pfile->spec_nodes.n_L) return CPP_WCHAR;\n-      if (b == CPP_STRING\n-\t  && token1->val.node == pfile->spec_nodes.n_L) return CPP_WSTRING;\n-      break;\n-\n-    case CPP_NUMBER:\n-      if (b == CPP_NUMBER)\treturn CPP_NUMBER;\n-      if (b == CPP_NAME)\treturn CPP_NUMBER;\n-      if (b == CPP_DOT)\t\treturn CPP_NUMBER;\n-      /* Numbers cannot have length zero, so this is safe.  */\n-      if ((b == CPP_PLUS || b == CPP_MINUS)\n-\t  && VALID_SIGN ('+', token1->val.str.text[token1->val.str.len - 1]))\n-\treturn CPP_NUMBER;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return CPP_EOF;\n-}\n-\n /* Returns nonzero if a space should be inserted to avoid an\n    accidental token paste for output.  For simplicity, it is\n    conservative, and occasionally advises a space where one is not\n@@ -2139,7 +2032,8 @@ struct dummy\n #define DEFAULT_ALIGNMENT (offsetof (struct dummy, u))\n #define CPP_ALIGN(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n \n-/* Create a new allocation buffer.  */\n+/* Create a new allocation buffer.  Place the control block at the end\n+   of the buffer, so that buffer overflows will cause immediate chaos.  */\n static _cpp_buff *\n new_buff (len)\n      unsigned int len;"}, {"sha": "4404a40e5efdb3ef7e46527fc7478dc4a81e2c83", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c9e7a60950592e24cc380f0237bea7e652b9f3ce", "patch": "@@ -496,8 +496,6 @@ extern int cpp_start_read PARAMS ((cpp_reader *, const char *));\n extern void cpp_finish PARAMS ((cpp_reader *));\n extern int cpp_avoid_paste PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t    const cpp_token *));\n-extern enum cpp_ttype cpp_can_paste PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t\t     const cpp_token *, int *));\n extern const cpp_token *cpp_get_token PARAMS ((cpp_reader *));\n extern const unsigned char *cpp_macro_definition PARAMS ((cpp_reader *,\n \t\t\t\t\t\t  const cpp_hashnode *));"}, {"sha": "47c44716807c2fbbb050e252ac028070a459169e", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 53, "deletions": 76, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e7a60950592e24cc380f0237bea7e652b9f3ce/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=c9e7a60950592e24cc380f0237bea7e652b9f3ce", "patch": "@@ -74,8 +74,8 @@ static const cpp_token *new_string_token PARAMS ((cpp_reader *, U_CHAR *,\n static const cpp_token *new_number_token PARAMS ((cpp_reader *, int));\n static const cpp_token *stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n static void paste_all_tokens PARAMS ((cpp_reader *, const cpp_token *));\n-static int paste_tokens PARAMS ((cpp_reader *, cpp_token *,\n-\t\t\t\t const cpp_token *));\n+static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n+\t\t\t\t  const cpp_token *));\n static int funlike_invocation_p PARAMS ((cpp_reader *, const cpp_hashnode *));\n static void replace_args PARAMS ((cpp_reader *, cpp_macro *, macro_arg *));\n \n@@ -330,71 +330,49 @@ stringify_arg (pfile, arg)\n   return new_string_token (pfile, start, total_len);\n }\n \n-/* Try to paste two tokens.  On success, the LHS becomes the pasted\n-   token, and 0 is returned.  For failure, we update the flags of the\n-   RHS appropriately and return non-zero.  */\n-static int\n-paste_tokens (pfile, lhs, rhs)\n+/* Try to paste two tokens.  On success, return non-zero.  In any\n+   case, PLHS is updated to point to the pasted token, which is\n+   guaranteed to not have the PASTE_LEFT flag set.  */\n+static bool\n+paste_tokens (pfile, plhs, rhs)\n      cpp_reader *pfile;\n-     cpp_token *lhs;\n-     const cpp_token *rhs;\n+     const cpp_token **plhs, *rhs;\n {\n-  unsigned char flags = 0;\n-  int digraph = 0;\n-  enum cpp_ttype type;\n-\n-  type = cpp_can_paste (pfile, lhs, rhs, &digraph);\n-  \n-  if (type == CPP_EOF)\n-    {\n-      /* Mandatory warning for all apart from assembler.  */\n-      if (CPP_OPTION (pfile, lang) != CLK_ASM)\n-\tcpp_warning (pfile,\n-\t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n-\t\t     cpp_token_as_text (pfile, lhs),\n-\t\t     cpp_token_as_text (pfile, rhs));\n-      return 1;\n-    }\n-\n-  if (digraph)\n-    flags |= DIGRAPH;\n-\n-  /* Identifiers and numbers need spellings to be pasted.  */\n-  if (type == CPP_NAME || type == CPP_NUMBER)\n-    {\n-      unsigned int total_len = cpp_token_len (lhs) + cpp_token_len (rhs);\n-      unsigned char *result, *end;\n-\n-      result = _cpp_pool_alloc (&pfile->ident_pool, total_len + 1);\n-\n-      /* Paste the spellings and null terminate.  */\n-      end = cpp_spell_token (pfile, rhs, cpp_spell_token (pfile, lhs, result));\n-      *end = '\\0';\n-      total_len = end - result;\n-\n-      if (type == CPP_NAME)\n-\t{\n-\t  lhs->val.node = cpp_lookup (pfile, result, total_len);\n-\t  if (lhs->val.node->flags & NODE_OPERATOR)\n-\t    {\n-\t      flags |= NAMED_OP;\n-\t      lhs->type = lhs->val.node->value.operator;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  lhs->val.str.text = result;\n-\t  lhs->val.str.len = total_len;\n-\t}\n-    }\n-  else if (type == CPP_WCHAR || type == CPP_WSTRING)\n-    lhs->val.str = rhs->val.str;\n-\n-  /* Set type and flags after pasting spellings.  */\n-  lhs->type = type;\n-  lhs->flags = flags;\n-\n-  return 0;\n+  unsigned char *buf, *end;\n+  const cpp_token *lhs;\n+  unsigned int len;\n+  bool valid;\n+\n+  lhs = *plhs;\n+  len = cpp_token_len (lhs) + cpp_token_len (rhs) + 1;\n+  buf = (unsigned char *) alloca (len);\n+  end = cpp_spell_token (pfile, lhs, buf);\n+\n+  /* Avoid comment headers, since they are still processed in stage 3.\n+     It is simpler to insert a space here, rather than modifying the\n+     lexer to ignore comments in some circumstances.  Simply returning\n+     false doesn't work, since we want to clear the PASTE_LEFT flag.  */\n+  if (lhs->type == CPP_DIV\n+      && (rhs->type == CPP_MULT || rhs->type == CPP_DIV))\n+    *end++ = ' ';\n+  end = cpp_spell_token (pfile, rhs, end);\n+\n+  cpp_push_buffer (pfile, buf, end - buf, /* from_stage3 */ true, 1);\n+\n+  /* Tweak the column number the lexer will report.  */\n+  pfile->buffer->col_adjust = pfile->cur_token[-1].col - 1;\n+\n+  /* We don't want a leading # to be interpreted as a directive.  */\n+  pfile->buffer->saved_flags = 0;\n+\n+  /* Set pfile->cur_token as required by _cpp_lex_direct.  */\n+  pfile->cur_token = _cpp_temp_token (pfile);\n+  *plhs = _cpp_lex_direct (pfile);\n+  valid = (pfile->buffer->cur == pfile->buffer->rlimit\n+\t   && pfile->buffer->read_ahead == EOF);\n+  _cpp_pop_buffer (pfile);\n+\n+  return valid;\n }\n \n /* Handles an arbitrarily long sequence of ## operators.  This\n@@ -407,16 +385,9 @@ paste_all_tokens (pfile, lhs)\n      cpp_reader *pfile;\n      const cpp_token *lhs;\n {\n-  cpp_token *pasted;\n   const cpp_token *rhs;\n   cpp_context *context = pfile->context;\n \n-  /* Copy lhs to pasted, but preserve original line and column.  */\n-  pasted = _cpp_temp_token (pfile);\n-  pasted->type = lhs->type;\n-  pasted->flags = lhs->flags;\n-  pasted->val.str = lhs->val.str;\n-\n   do\n     {\n       /* Take the token directly from the current context.  We can do\n@@ -432,17 +403,23 @@ paste_all_tokens (pfile, lhs)\n       if (rhs->type == CPP_PADDING)\n \tabort ();\n \n-      if (paste_tokens (pfile, pasted, rhs))\n+      if (!paste_tokens (pfile, &lhs, rhs))\n \t{\n \t  _cpp_backup_tokens (pfile, 1);\n+\n+\t  /* Mandatory warning for all apart from assembler.  */\n+\t  if (CPP_OPTION (pfile, lang) != CLK_ASM)\n+\t    cpp_warning (pfile,\n+\t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n+\t\t\t cpp_token_as_text (pfile, lhs),\n+\t\t\t cpp_token_as_text (pfile, rhs));\n \t  break;\n \t}\n     }\n   while (rhs->flags & PASTE_LEFT);\n \n-  /* Clear PASTE_LEFT flag, put the token in its own context.  */\n-  pasted->flags &= ~PASTE_LEFT;\n-  push_token_context (pfile, NULL, pasted, 1);\n+  /* Put the resulting token in its own context.  */\n+  push_token_context (pfile, NULL, lhs, 1);\n }\n \n /* Reads and returns the arguments to a function-like macro invocation."}]}