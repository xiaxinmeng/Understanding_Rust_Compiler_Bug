{"sha": "e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBhNjA3MzExY2MxY2IxNTA3MGRhNmNkMmMyZTEwZjhlZWFlODY3Yg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-04-22T11:26:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-04-22T11:26:49Z"}, "message": "re PR tree-optimization/29789 (Missed invariant out of the loop with conditionals and shifts)\n\n2007-04-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/29789\n\t* tree-ssa-loop-im.c (stmt_cost): Adjust cost of shifts.\n\t(rewrite_reciprocal): New helper split out from\n\tdetermine_invariantness_stmt.\n\t(rewrite_bittest): Likewise.\n\t(determine_invariantness_stmt): Rewrite (A >> B) & 1 to\n\tA & (1 << B) if (1 << B) is loop invariant but (A >> B)\n\tis not.\n\n\t* gcc.dg/tree-ssa/ssa-lim-1.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-lim-2.c: Likewise.\n\nFrom-SVN: r124042", "tree": {"sha": "989716dba1a060e7c03260037932273b5ed3d9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/989716dba1a060e7c03260037932273b5ed3d9a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c9be806047605b254e608d583c371725d2bc7b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9be806047605b254e608d583c371725d2bc7b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9be806047605b254e608d583c371725d2bc7b4"}], "stats": {"total": 226, "additions": 196, "deletions": 30}, "files": [{"sha": "3f284697be188573ef6f6757217d9c2c096c8be5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "patch": "@@ -1,3 +1,14 @@\n+2007-04-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/29789\n+\t* tree-ssa-loop-im.c (stmt_cost): Adjust cost of shifts.\n+\t(rewrite_reciprocal): New helper split out from\n+\tdetermine_invariantness_stmt.\n+\t(rewrite_bittest): Likewise.\n+\t(determine_invariantness_stmt): Rewrite (A >> B) & 1 to\n+\tA & (1 << B) if (1 << B) is loop invariant but (A >> B)\n+\tis not.\n+\n 2007-04-22  Revital Eres  <eres@il.ibm.com>\n \n         * loop-unroll.c (var_to_expand): New field to support also"}, {"sha": "bcabfafbbfb99a4f81a08bcc5685dec038383c32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "patch": "@@ -1,3 +1,9 @@\n+2007-04-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/29789\n+\t* gcc.dg/tree-ssa/ssa-lim-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-lim-2.c: Likewise.\n+\n 2007-04-22  Revital Eres  <eres@il.ibm.com>\n \n         * gcc.dg/var-expand2.c: New test."}, {"sha": "f76c5d492ceb44d44c95de860ab9af43d59e2318", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-1.c?ref=e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-lim\" } */\n+\n+/* This is a variant that does cause fold to place a cast to\n+   int before testing bit 1.  */\n+\n+void\n+quantum_toffoli (int control1, int control2, int target,\n+\t\t unsigned long *state, int size)\n+{\n+  int i;\n+\n+  for(i=0; i<size; i++)\n+    {\n+       if (state[i] & ((unsigned long) 1 << control1))\n+         if (state[i] & ((unsigned long) 1 << control2))\n+           state[i] ^= ((unsigned long) 1 << target);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"shifttmp\" 6 \"lim\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim\" } } */"}, {"sha": "286e0e85af629eaad44332aaef0fd97d898e12ca", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-2.c?ref=e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-lim\" } */\n+\n+/* This is a variant that doesn't cause fold to place a cast to\n+   int before testing bit 1.  */\n+\n+void\n+quantum_toffoli(int control1, int control2, int target, int *state,\n+int size)\n+{\n+  int i;\n+\n+  for(i=0; i<size; i++)\n+    {\n+       if (state[i] & ( 1 << control1))\n+         if (state[i] & ( 1 << control2))\n+           state[i] ^= ( 1 << target);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"shifttmp\" 6 \"lim\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim\" } } */"}, {"sha": "340e6a1aef4cf15a3aeda0466729f6fd666747fe", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 135, "deletions": 30, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a607311cc1cb15070da6cd2c2e10f8eeae867b/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=e0a607311cc1cb15070da6cd2c2e10f8eeae867b", "patch": "@@ -460,6 +460,11 @@ stmt_cost (tree stmt)\n       cost += 20;\n       break;\n \n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      cost += 20;\n+      break;\n+\n     default:\n       break;\n     }\n@@ -571,6 +576,123 @@ free_lim_aux_data (struct lim_aux_data *data)\n   free (data);\n }\n \n+/* Rewrite a/b to a*(1/b).  Return the invariant stmt to process.  */\n+\n+static tree\n+rewrite_reciprocal (block_stmt_iterator *bsi)\n+{\n+  tree stmt, lhs, rhs, stmt1, stmt2, var, name, tmp;\n+\n+  stmt = bsi_stmt (*bsi);\n+  lhs = GENERIC_TREE_OPERAND (stmt, 0);\n+  rhs = GENERIC_TREE_OPERAND (stmt, 1);\n+\n+  /* stmt must be GIMPLE_MODIFY_STMT.  */\n+  var = create_tmp_var (TREE_TYPE (rhs), \"reciptmp\");\n+  add_referenced_var (var);\n+\n+  tmp = build2 (RDIV_EXPR, TREE_TYPE (rhs),\n+\t\tbuild_real (TREE_TYPE (rhs), dconst1),\n+\t\tTREE_OPERAND (rhs, 1));\n+  stmt1 = build_gimple_modify_stmt (var, tmp);\n+  name = make_ssa_name (var, stmt1);\n+  GIMPLE_STMT_OPERAND (stmt1, 0) = name;\n+  tmp = build2 (MULT_EXPR, TREE_TYPE (rhs),\n+\t\tname, TREE_OPERAND (rhs, 0));\n+  stmt2 = build_gimple_modify_stmt (lhs, tmp);\n+\n+  /* Replace division stmt with reciprocal and multiply stmts.\n+     The multiply stmt is not invariant, so update iterator\n+     and avoid rescanning.  */\n+  bsi_replace (bsi, stmt1, true);\n+  bsi_insert_after (bsi, stmt2, BSI_NEW_STMT);\n+  SSA_NAME_DEF_STMT (lhs) = stmt2;\n+\n+  /* Continue processing with invariant reciprocal statement.  */\n+  return stmt1;\n+}\n+\n+/* Check if the pattern at *BSI is a bittest of the form\n+   (A >> B) & 1 != 0 and in this case rewrite it to A & (1 << B) != 0.  */\n+\n+static tree\n+rewrite_bittest (block_stmt_iterator *bsi)\n+{\n+  tree stmt, lhs, rhs, var, name, stmt1, stmt2, t;\n+  use_operand_p use;\n+\n+  stmt = bsi_stmt (*bsi);\n+  lhs = GENERIC_TREE_OPERAND (stmt, 0);\n+  rhs = GENERIC_TREE_OPERAND (stmt, 1);\n+\n+  /* Verify that the single use of lhs is a comparison against zero.  */\n+  if (TREE_CODE (lhs) != SSA_NAME\n+      || !single_imm_use (lhs, &use, &stmt1)\n+      || TREE_CODE (stmt1) != COND_EXPR)\n+    return stmt;\n+  t = COND_EXPR_COND (stmt1);\n+  if (TREE_OPERAND (t, 0) != lhs\n+      || (TREE_CODE (t) != NE_EXPR\n+\t  && TREE_CODE (t) != EQ_EXPR)\n+      || !integer_zerop (TREE_OPERAND (t, 1)))\n+    return stmt;\n+\n+  /* Get at the operands of the shift.  The rhs is TMP1 & 1.  */\n+  stmt1 = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n+  if (TREE_CODE (stmt1) != GIMPLE_MODIFY_STMT)\n+    return stmt;\n+\n+  /* There is a conversion inbetween possibly inserted by fold.  */\n+  t = GIMPLE_STMT_OPERAND (stmt1, 1);\n+  if (TREE_CODE (t) == NOP_EXPR\n+      || TREE_CODE (t) == CONVERT_EXPR)\n+    {\n+      t = TREE_OPERAND (t, 0);\n+      if (TREE_CODE (t) != SSA_NAME\n+\t  || !has_single_use (t))\n+\treturn stmt;\n+      stmt1 = SSA_NAME_DEF_STMT (t);\n+      if (TREE_CODE (stmt1) != GIMPLE_MODIFY_STMT)\n+\treturn stmt;\n+      t = GIMPLE_STMT_OPERAND (stmt1, 1);\n+    }\n+\n+  /* Verify that B is loop invariant but A is not.  Verify that with\n+     all the stmt walking we are still in the same loop.  */\n+  if (TREE_CODE (t) == RSHIFT_EXPR\n+      && loop_containing_stmt (stmt1) == loop_containing_stmt (stmt)\n+      && outermost_invariant_loop_expr (TREE_OPERAND (t, 1),\n+                                        loop_containing_stmt (stmt1)) != NULL\n+      && outermost_invariant_loop_expr (TREE_OPERAND (t, 0),\n+                                        loop_containing_stmt (stmt1)) == NULL)\n+    {\n+      tree a = TREE_OPERAND (t, 0);\n+      tree b = TREE_OPERAND (t, 1);\n+\n+      /* 1 << B */\n+      var = create_tmp_var (TREE_TYPE (a), \"shifttmp\");\n+      add_referenced_var (var);\n+      t = fold_build2 (LSHIFT_EXPR, TREE_TYPE (a),\n+\t\t       build_int_cst (TREE_TYPE (a), 1), b);\n+      stmt1 = build_gimple_modify_stmt (var, t);\n+      name = make_ssa_name (var, stmt1);\n+      GIMPLE_STMT_OPERAND (stmt1, 0) = name;\n+\n+      /* A & (1 << B) */\n+      t = fold_build2 (BIT_AND_EXPR, TREE_TYPE (a), a, name);\n+      stmt2 = build_gimple_modify_stmt (lhs, t);\n+\n+      bsi_insert_before (bsi, stmt1, BSI_SAME_STMT);\n+      bsi_replace (bsi, stmt2, true);\n+      SSA_NAME_DEF_STMT (lhs) = stmt2;\n+\n+      return stmt1;\n+    }\n+\n+  return stmt;\n+}\n+\n+\n /* Determine the outermost loops in that statements in basic block BB are\n    invariant, and record them to the LIM_DATA associated with the statements.\n    Callback for walk_dominator_tree.  */\n@@ -607,46 +729,29 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t  continue;\n \t}\n \n+      rhs = GENERIC_TREE_OPERAND (stmt, 1);\n+\n       /* If divisor is invariant, convert a/b to a*(1/b), allowing reciprocal\n \t to be hoisted out of loop, saving expensive divide.  */\n       if (pos == MOVE_POSSIBLE\n-\t  && (rhs = GENERIC_TREE_OPERAND (stmt, 1)) != NULL\n \t  && TREE_CODE (rhs) == RDIV_EXPR\n \t  && flag_unsafe_math_optimizations\n \t  && !flag_trapping_math\n \t  && outermost_invariant_loop_expr (TREE_OPERAND (rhs, 1),\n \t\t\t\t\t    loop_containing_stmt (stmt)) != NULL\n \t  && outermost_invariant_loop_expr (rhs,\n \t\t\t\t\t    loop_containing_stmt (stmt)) == NULL)\n-\t{\n-\t  tree lhs, stmt1, stmt2, var, name, tmp;\n-\n-\t  lhs = GENERIC_TREE_OPERAND (stmt, 0);\n-\n-\t  /* stmt must be GIMPLE_MODIFY_STMT.  */\n-\t  var = create_tmp_var (TREE_TYPE (rhs), \"reciptmp\");\n-\t  add_referenced_var (var);\n-\n-\t  tmp = build2 (RDIV_EXPR, TREE_TYPE (rhs),\n-\t\t\tbuild_real (TREE_TYPE (rhs), dconst1),\n-\t\t\tTREE_OPERAND (rhs, 1));\n-\t  stmt1 = build_gimple_modify_stmt (var, tmp);\n-\t  name = make_ssa_name (var, stmt1);\n-\t  GIMPLE_STMT_OPERAND (stmt1, 0) = name;\n-\t  tmp = build2 (MULT_EXPR, TREE_TYPE (rhs),\n-\t\t\tname, TREE_OPERAND (rhs, 0));\n-\t  stmt2 = build_gimple_modify_stmt (lhs, tmp);\n-\n-\t  /* Replace division stmt with reciprocal and multiply stmts.\n-\t     The multiply stmt is not invariant, so update iterator\n-\t     and avoid rescanning.  */\n-\t  bsi_replace (&bsi, stmt1, true);\n-\t  bsi_insert_after (&bsi, stmt2, BSI_NEW_STMT);\n-\t  SSA_NAME_DEF_STMT (lhs) = stmt2;\n-\n-\t  /* Continue processing with invariant reciprocal statement.  */\n-\t  stmt = stmt1;\n-\t}\n+\tstmt = rewrite_reciprocal (&bsi);\n+\n+      /* If the shift count is invariant, convert (A >> B) & 1 to\n+\t A & (1 << B) allowing the bit mask to be hoisted out of the loop\n+\t saving an expensive shift.  */\n+      if (pos == MOVE_POSSIBLE\n+\t  && TREE_CODE (rhs) == BIT_AND_EXPR\n+\t  && integer_onep (TREE_OPERAND (rhs, 1))\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t  && has_single_use (TREE_OPERAND (rhs, 0)))\n+\tstmt = rewrite_bittest (&bsi);\n \n       stmt_ann (stmt)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n       LIM_DATA (stmt)->always_executed_in = outermost;"}]}