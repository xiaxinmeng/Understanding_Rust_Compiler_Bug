{"sha": "1b31321b1834aac1bd455e5a457145827dee562f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIzMTMyMWIxODM0YWFjMWJkNDU1ZTVhNDU3MTQ1ODI3ZGVlNTYyZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T16:58:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T16:58:19Z"}, "message": "[multiple changes]\n\n2014-02-24  Robert Dewar  <dewar@adacore.com>\n\n\t* a-direct.adb, sem_ch5.adb, a-cfdlli.adb, a-cfhase.adb, a-tags.adb,\n\ts-filatt.ads, a-cforma.adb, sem_ch6.adb, g-socthi-mingw.adb,\n\ta-cfhama.adb, a-cforse.adb, a-cofove.adb: Minor reformatting and code\n\treorganization.\n\n2014-02-24  Thomas Quinot  <quinot@adacore.com>\n\n\t* Make-generated.in (OSCONS_CPP, OSCONS_EXTRACT): Make sure\n\tthat the source directory containing s-oscons-tmplt.c is on the\n\tinclude path, so that all internal header files are available.\n\nFrom-SVN: r208081", "tree": {"sha": "1add74aa9da3e051e5836c81c36ab340e705ba01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1add74aa9da3e051e5836c81c36ab340e705ba01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b31321b1834aac1bd455e5a457145827dee562f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b31321b1834aac1bd455e5a457145827dee562f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b31321b1834aac1bd455e5a457145827dee562f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b31321b1834aac1bd455e5a457145827dee562f/comments", "author": null, "committer": null, "parents": [{"sha": "2810861847cca82646c1c7e14249fe198acbbc0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2810861847cca82646c1c7e14249fe198acbbc0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2810861847cca82646c1c7e14249fe198acbbc0f"}], "stats": {"total": 291, "additions": 163, "deletions": 128}, "files": [{"sha": "a7b2b9c32687558be62807ad22cc54d4a2ce3864", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -1,3 +1,16 @@\n+2014-02-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-direct.adb, sem_ch5.adb, a-cfdlli.adb, a-cfhase.adb, a-tags.adb,\n+\ts-filatt.ads, a-cforma.adb, sem_ch6.adb, g-socthi-mingw.adb,\n+\ta-cfhama.adb, a-cforse.adb, a-cofove.adb: Minor reformatting and code\n+\treorganization.\n+\n+2014-02-24  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* Make-generated.in (OSCONS_CPP, OSCONS_EXTRACT): Make sure\n+\tthat the source directory containing s-oscons-tmplt.c is on the\n+\tinclude path, so that all internal header files are available.\n+\n 2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch5.adb (Analyze_Loop_Parameter_Specification): If the"}, {"sha": "5c5812c94c9b4a01061d7195ec3199912fee16f5", "filename": "gcc/ada/Make-generated.in", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2FMake-generated.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2FMake-generated.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-generated.in?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -68,26 +68,30 @@ $(ADA_GEN_SUBDIR)/stamp-nmake: $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/nma\n \n # GCC_FOR_TARGET has paths relative to the gcc directory, so we need to adjust\n # for running it from $(ADA_GEN_SUBDIR)/bldtools/oscons\n-OSCONS_CC=`echo \"$(GCC_FOR_TARGET)\" \\\n-  | sed -e 's^\\./xgcc^../../../xgcc^' -e 's^-B./^-B../../../^'`\n+OSCONS_CC=$(subst ./xgcc,../../../xgcc,$(subst -B./, -B../../../,$(GCC_FOR_TARGET)))\n+OSCONS_SRCDIR=$${_oscons_srcdir}\n OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS) -E -C \\\n-  -DTARGET=\\\"$(target)\\\" s-oscons-tmplt.c > s-oscons-tmplt.i\n-OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i\n+  -DTARGET=\\\"$(target)\\\" -I$(OSCONS_SRCDIR) s-oscons-tmplt.c > s-oscons-tmplt.i\n+OSCONS_EXTRACT=$(OSCONS_CC) -I$(OSCONS_SRCDIR) -S s-oscons-tmplt.i\n \n # Note: if you need to build with a non-GNU compiler, you could adapt the\n # following definitions (written for VMS DEC-C)\n #OSCONS_CPP=../../../$(DECC) -E /comment=as_is -DNATIVE \\\n-#             -DTARGET='\"\"$(target)\"\"' s-oscons-tmplt.c\n+#             -DTARGET='\"\"$(target)\"\"' -I$(OSCONS_SRCDIR) s-oscons-tmplt.c\n #\n #OSCONS_EXTRACT=../../../$(DECC) -DNATIVE \\\n-#                 -DTARGET='\"\"$(target)\"\"' s-oscons-tmplt.c ; \\\n+#                 -DTARGET='\"\"$(target)\"\"' -I$(OSCONS_SRCDIR) s-oscons-tmplt.c ; \\\n #  ld -o s-oscons-tmplt.exe s-oscons-tmplt.obj; \\\n #  ./s-oscons-tmplt.exe > s-oscons-tmplt.s\n \n-$(ADA_GEN_SUBDIR)/s-oscons.ads : $(ADA_GEN_SUBDIR)/s-oscons-tmplt.c $(ADA_GEN_SUBDIR)/gsocket.h $(ADA_GEN_SUBDIR)/adaint.h $(ADA_GEN_SUBDIR)/xoscons.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n+# Note: the first dependency of s-oscons.ads *must* remain s-oscons-tmplt.c, as\n+# we use $(<D) to locate the main ada/ source directory and pass it to OSCONS_CPP\n+# as a -I argument.\n+$(ADA_GEN_SUBDIR)/s-oscons.ads : $(ADA_GEN_SUBDIR)/s-oscons-tmplt.c $(ADA_GEN_SUBDIR)/xoscons.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n \t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/oscons\n \t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/oscons/,$(notdir $^))\n \t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/oscons\n+\t_oscons_srcdir=`cd $(<D) && pwd` ; \\\n \t(cd $(ADA_GEN_SUBDIR)/bldtools/oscons ; gnatmake -q xoscons ; \\\n \t\t$(RM) s-oscons-tmplt.i s-oscons-tmplt.s ; \\\n \t\t$(OSCONS_CPP) ; \\"}, {"sha": "993f966f2e1b8bf9086e910497a30f85d478fc41", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -507,27 +507,28 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    function First_To_Previous\n      (Container : List;\n-      Current : Cursor) return List is\n+      Current   : Cursor) return List\n+   is\n       Curs : Cursor := Current;\n       C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n \n    begin\n       if Curs = No_Element then\n          return C;\n-      end if;\n \n-      if not Has_Element (Container, Curs) then\n+      elsif not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= 0 loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end First_To_Previous;\n \n    ----------\n@@ -907,6 +908,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if Container.Last = 0 then\n          return No_Element;\n       end if;\n+\n       return (Node => Container.Last);\n    end Last;\n \n@@ -1192,16 +1194,18 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n       if Container.Length = 0 then\n          return No_Element;\n-      end if;\n \n-      while CFirst /= 0 loop\n-         if Container.Nodes (CFirst).Element = Item then\n-            return (Node => CFirst);\n-         end if;\n-         CFirst := Container.Nodes (CFirst).Prev;\n-      end loop;\n+      else\n+         while CFirst /= 0 loop\n+            if Container.Nodes (CFirst).Element = Item then\n+               return (Node => CFirst);\n+            else\n+               CFirst := Container.Nodes (CFirst).Prev;\n+            end if;\n+         end loop;\n \n-      return No_Element;\n+         return No_Element;\n+      end if;\n    end Reverse_Find;\n \n    ------------"}, {"sha": "ea506d8ddc46d2d0885e039dfa5bd1ea848d0dfa", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -242,26 +242,26 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    function Current_To_Last (Container : Map; Current : Cursor) return Map is\n       Curs : Cursor := First (Container);\n       C    : Map (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n \n    begin\n       if Curs = No_Element then\n          Clear (C);\n          return C;\n-      end if;\n \n-      if Current /= No_Element and not Has_Element (Container, Current) then\n+      elsif Current /= No_Element and not Has_Element (Container, Current) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= Current.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= Current.Node loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end Current_To_Last;\n \n    ---------------------\n@@ -467,27 +467,27 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Current : Cursor) return Map is\n       Curs : Cursor;\n       C    : Map (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n \n    begin\n       Curs := Current;\n \n       if Curs = No_Element then\n          return C;\n-      end if;\n \n-      if not Has_Element (Container, Curs) then\n+      elsif not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= 0 loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end First_To_Previous;\n \n    ----------"}, {"sha": "de09ce84f9bf08e2630416487e0742e2c403d2b1", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -268,26 +268,26 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Current_To_Last (Container : Set; Current : Cursor) return Set is\n       Curs : Cursor := First (Container);\n       C    : Set (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n \n    begin\n       if Curs = No_Element then\n          Clear (C);\n          return C;\n-      end if;\n \n-      if Current /= No_Element and not Has_Element (Container, Current) then\n+      elsif Current /= No_Element and not Has_Element (Container, Current) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= Current.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= Current.Node loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end Current_To_Last;\n \n    ---------------------\n@@ -661,28 +661,29 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function First_To_Previous\n      (Container : Set;\n-      Current : Cursor) return Set is\n+      Current   : Cursor) return Set\n+   is\n       Curs : Cursor := Current;\n       C    : Set (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n \n    begin\n       if Curs = No_Element then\n          return C;\n-      end if;\n \n-      if not Has_Element (Container, Curs) then\n+      elsif not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= 0 loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end First_To_Previous;\n \n    ----------"}, {"sha": "69f2cc7b6d72e290d04cbbdb7f86d33dbc09cd0f", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -336,18 +336,18 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          Clear (C);\n          return C;\n \n-      end if;\n-      if Current /= No_Element and not Has_Element (Container, Current) then\n+      elsif Current /= No_Element and not Has_Element (Container, Current) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= Current.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= Current.Node loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end Current_To_Last;\n \n    ------------\n@@ -524,27 +524,28 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    function First_To_Previous\n      (Container : Map;\n-      Current : Cursor) return Map is\n+      Current   : Cursor) return Map\n+   is\n       Curs : Cursor := Current;\n       C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n \n    begin\n       if Curs = No_Element then\n          return C;\n-      end if;\n \n-      if not Has_Element (Container, Curs) then\n+      elsif not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= 0 loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end First_To_Previous;\n \n    -----------"}, {"sha": "bc8ffbaac881940487ced0f6a780ce458389c3ce", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -600,27 +600,28 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function First_To_Previous\n      (Container : Set;\n-      Current : Cursor) return Set is\n+      Current   : Cursor) return Set\n+   is\n       Curs : Cursor := Current;\n       C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n \n    begin\n       if Curs = No_Element then\n          return C;\n-      end if;\n \n-      if not Has_Element (Container, Curs) then\n+      elsif not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n-      end if;\n \n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n+      else\n+         while Curs.Node /= 0 loop\n+            Node := Curs.Node;\n+            Delete (C, Curs);\n+            Curs := Next (Container, (Node => Node));\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end First_To_Previous;\n \n    -----------"}, {"sha": "a12f8c243dff5c490517eff1ba628d082e7d397b", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -319,24 +319,25 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Current_To_Last\n      (Container : Vector;\n-      Current : Cursor) return Vector is\n+      Current   : Cursor) return Vector\n+   is\n       C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n \n    begin\n       if Current = No_Element then\n          Clear (C);\n          return C;\n-      end if;\n \n-      if not Has_Element (Container, Current) then\n+      elsif not Has_Element (Container, Current) then\n          raise Constraint_Error;\n-      end if;\n \n-      while C.Last /= Container.Last - Current.Index + 1 loop\n-         Delete_First (C);\n-      end loop;\n+      else\n+         while C.Last /= Container.Last - Current.Index + 1 loop\n+            Delete_First (C);\n+         end loop;\n \n-      return C;\n+         return C;\n+      end if;\n    end Current_To_Last;\n \n    ------------\n@@ -610,22 +611,24 @@ package body Ada.Containers.Formal_Vectors is\n \n    function First_To_Previous\n      (Container : Vector;\n-      Current : Cursor) return Vector is\n+      Current   : Cursor) return Vector\n+   is\n       C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n \n    begin\n       if Current = No_Element then\n          return C;\n-      end if;\n \n-      if not Has_Element (Container, Current) then\n+      elsif not Has_Element (Container, Current) then\n          raise Constraint_Error;\n-      end if;\n \n-      while C.Last /= Current.Index - 1 loop\n-         Delete_Last (C);\n-      end loop;\n-      return C;\n+      else\n+         while C.Last /= Current.Index - 1 loop\n+            Delete_Last (C);\n+         end loop;\n+\n+         return C;\n+      end if;\n    end First_To_Previous;\n \n    ---------------------"}, {"sha": "c6d2b7ceda36ccffb84f1d19a1cfbb5a42b2d43c", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -759,10 +759,11 @@ package body Ada.Directories is\n          if Match (Name (1 .. Last), Search.Value.Pattern) then\n             declare\n                C_Full_Name : constant String :=\n-                 Compose (To_String (Search.Value.Name), Name (1 .. Last))\n-                   & ASCII.NUL;\n-               Full_Name   : String renames C_Full_Name\n-                               (C_Full_Name'First .. C_Full_Name'Last - 1);\n+                               Compose (To_String (Search.Value.Name),\n+                                        Name (1 .. Last)) & ASCII.NUL;\n+               Full_Name   : String renames\n+                               C_Full_Name\n+                                 (C_Full_Name'First .. C_Full_Name'Last - 1);\n                Found       : Boolean := False;\n                Attr        : aliased File_Attributes;\n                Exists      : Integer;"}, {"sha": "6c096c00b41aef13d3867e5d53129ffbf7a24ecf", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -283,9 +283,9 @@ package body Ada.Tags is\n \n       procedure Set_HT_Link (T : Tag; Next : Tag) is\n          TSD_Ptr : constant Addr_Ptr :=\n-           To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                     To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n          TSD     : constant Type_Specific_Data_Ptr :=\n-           To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+                     To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       begin\n          TSD.HT_Link.all := Next;\n       end Set_HT_Link;\n@@ -309,8 +309,9 @@ package body Ada.Tags is\n       T : Tag;\n \n       E_Tag_Len : constant Integer :=\n-        Integer (strlen (TSD.External_Tag.all'Address));\n-      E_Tag     : String (1 .. E_Tag_Len);\n+                    Integer (strlen (TSD.External_Tag.all'Address));\n+\n+      E_Tag : String (1 .. E_Tag_Len);\n       for E_Tag'Address use TSD.External_Tag.all'Address;\n       pragma Import (Ada, E_Tag);\n \n@@ -344,13 +345,12 @@ package body Ada.Tags is\n \n    function Descendant_Tag (External : String; Ancestor : Tag) return Tag is\n       Int_Tag : constant Tag := Internal_Tag (External);\n-\n    begin\n       if not Is_Descendant_At_Same_Level (Int_Tag, Ancestor) then\n          raise Tag_Error;\n+      else\n+         return Int_Tag;\n       end if;\n-\n-      return Int_Tag;\n    end Descendant_Tag;\n \n    --------------"}, {"sha": "98f4c7cb942435fc74864ba6a2f971d877d0c6fe", "filename": "gcc/ada/g-socthi-mingw.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fg-socthi-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fg-socthi-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-mingw.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -628,6 +628,7 @@ package body GNAT.Sockets.Thin is\n \n          when others =>          Errm := N_OTHERS;\n       end case;\n+\n       return Value (Errm);\n    end Socket_Error_Message;\n "}, {"sha": "ba23e3653c50a5899cacaec477afe91ed58e4868", "filename": "gcc/ada/s-filatt.ads", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fs-filatt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fs-filatt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-filatt.ads?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -39,23 +39,27 @@ package System.File_Attributes is\n    type File_Attributes is private;\n \n    procedure Reset_Attributes (A : access File_Attributes);\n+\n    function Error_Attributes (A : access File_Attributes) return Integer;\n+\n    function File_Exists_Attr\n      (N : System.Address;\n       A : access File_Attributes) return Integer;\n+\n    function Is_Regular_File_Attr\n      (N : System.Address;\n       A : access File_Attributes) return Integer;\n+\n    function Is_Directory_Attr\n      (N : System.Address;\n       A : access File_Attributes) return Integer;\n \n private\n-\n    package SOSC renames System.OS_Constants;\n \n-   type File_Attributes is new System.Storage_Elements.Storage_Array\n-     (1 .. SOSC.SIZEOF_struct_file_attributes);\n+   type File_Attributes is new\n+     System.Storage_Elements.Storage_Array\n+       (1 .. SOSC.SIZEOF_struct_file_attributes);\n    for File_Attributes'Alignment use Standard'Maximum_Alignment;\n \n    pragma Import (C, Reset_Attributes,     \"__gnat_reset_attributes\");"}, {"sha": "a4eaa566c68dfd738124110ca4ef7dffcbb5d186", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -2376,7 +2376,7 @@ package body Sem_Ch5 is\n            or else (Is_Entity_Name (DS_Copy)\n                      and then not Is_Type (Entity (DS_Copy)))\n            or else (Nkind (DS_Copy) = N_Attribute_Reference\n-             and then Attribute_Name (DS_Copy) = Name_Old)\n+                     and then Attribute_Name (DS_Copy) = Name_Old)\n          then\n             --  This is an iterator specification. Rewrite it as such and\n             --  analyze it to capture function calls that may require"}, {"sha": "00fafc858b0f465c1471cb3dfddb6eb78261f878", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b31321b1834aac1bd455e5a457145827dee562f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1b31321b1834aac1bd455e5a457145827dee562f", "patch": "@@ -372,11 +372,13 @@ package body Sem_Ch6 is\n          --  An expression function that is a completion freezes the\n          --  expression. This means freezing the return type, and if it is\n          --  an access type, freezing its designated type as well.\n+\n          --  Note that we cannot defer this freezing to the analysis of the\n-         --  expression itself, because a freeze node might appear in a\n-         --  nested scope, leading to an elaboration order issue in gigi.\n+         --  expression itself, because a freeze node might appear in a nested\n+         --  scope, leading to an elaboration order issue in gigi.\n \n          Freeze_Before (N, Etype (Prev));\n+\n          if Is_Access_Type (Etype (Prev)) then\n             Freeze_Before (N, Designated_Type (Etype (Prev)));\n          end if;"}]}