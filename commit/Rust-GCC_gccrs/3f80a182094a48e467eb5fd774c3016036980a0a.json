{"sha": "3f80a182094a48e467eb5fd774c3016036980a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y4MGExODIwOTRhNDhlNDY3ZWI1ZmQ3NzRjMzAxNjAzNjk4MGEwYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T13:37:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T13:37:03Z"}, "message": "[multiple changes]\n\n2014-07-29  Robert Dewar  <dewar@adacore.com>\n\n\t* sinfo.ads, inline.adb, inline.ads, sem_ch6.adb: Minor reformatting.\n\t* snames.ads-tmpl: Minor reformatting.\n\t* xsnamest.adb (XSnamesT): Remove special casing of Name_Error\n\tto give <Error>.  Not clear why this was there, but the compiler\n\tsources do not reference Name_Error, and this interfered with\n\tthe circuits for pragma Unevaluated_Use_Of_Old.\n\n2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Allow volatile\n\ttypes in SPARK 2014 (again).\n\t* sem_res.adb (Is_OK_Volatile_Context): New routine.\n\t(Resolve_Entity_Name): Ensure that a volatile object with\n\tenabled properties Async_Writers or Effectire_Reads appears in\n\ta non-interfering context.\n\nFrom-SVN: r213180", "tree": {"sha": "6b8b25a56c74476a3930e7269e11e6bc4c6c6880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b8b25a56c74476a3930e7269e11e6bc4c6c6880"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f80a182094a48e467eb5fd774c3016036980a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f80a182094a48e467eb5fd774c3016036980a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f80a182094a48e467eb5fd774c3016036980a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f80a182094a48e467eb5fd774c3016036980a0a/comments", "author": null, "committer": null, "parents": [{"sha": "540d86108f31f56f513f542b910b909dd4d6df09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540d86108f31f56f513f542b910b909dd4d6df09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/540d86108f31f56f513f542b910b909dd4d6df09"}], "stats": {"total": 401, "additions": 223, "deletions": 178}, "files": [{"sha": "1543bdc167a391469abe9d6655293c9a506501c9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -1,3 +1,21 @@\n+2014-07-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinfo.ads, inline.adb, inline.ads, sem_ch6.adb: Minor reformatting.\n+\t* snames.ads-tmpl: Minor reformatting.\n+\t* xsnamest.adb (XSnamesT): Remove special casing of Name_Error\n+\tto give <Error>.  Not clear why this was there, but the compiler\n+\tsources do not reference Name_Error, and this interfered with\n+\tthe circuits for pragma Unevaluated_Use_Of_Old.\n+\n+2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Allow volatile\n+\ttypes in SPARK 2014 (again).\n+\t* sem_res.adb (Is_OK_Volatile_Context): New routine.\n+\t(Resolve_Entity_Name): Ensure that a volatile object with\n+\tenabled properties Async_Writers or Effectire_Reads appears in\n+\ta non-interfering context.\n+\n 2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb: Move Build_Body_To_Inline,"}, {"sha": "2dc8be7359c7f6ec8081f306b5e6826d0ffc7ec6", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 114, "deletions": 121, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -108,9 +108,9 @@ package body Inline is\n       Next : Succ_Index;\n    end record;\n \n-   --  The following table stores list elements for the successor lists.\n-   --  These lists cannot be chained directly through entries in the Inlined\n-   --  table, because a given subprogram can appear in several such lists.\n+   --  The following table stores list elements for the successor lists. These\n+   --  lists cannot be chained directly through entries in the Inlined table,\n+   --  because a given subprogram can appear in several such lists.\n \n    package Successors is new Table.Table (\n       Table_Component_Type => Succ_Info,\n@@ -143,8 +143,8 @@ package body Inline is\n \n    function Get_Code_Unit_Entity (E : Entity_Id) return Entity_Id;\n    pragma Inline (Get_Code_Unit_Entity);\n-   --  Return the entity node for the unit containing E. Always return\n-   --  the spec for a package.\n+   --  Return the entity node for the unit containing E. Always return the spec\n+   --  for a package.\n \n    function In_Main_Unit_Or_Subunit (E : Entity_Id) return Boolean;\n    --  Return True if E is in the main unit or its spec or in a subunit\n@@ -163,12 +163,11 @@ package body Inline is\n    --  non-trivial initialization procedures, they are not worth inlining.\n \n    function Is_Nested (E : Entity_Id) return Boolean;\n-   --  If the function is nested inside some other function, it will\n-   --  always be compiled if that function is, so don't add it to the\n-   --  inline list. We cannot compile a nested function outside the\n-   --  scope of the containing function anyway. This is also the case if\n-   --  the function is defined in a task body or within an entry (for\n-   --  example, an initialization procedure).\n+   --  If the function is nested inside some other function, it will always\n+   --  be compiled if that function is, so don't add it to the inline list.\n+   --  We cannot compile a nested function outside the scope of the containing\n+   --  function anyway. This is also the case if the function is defined in a\n+   --  task body or within an entry (for example, an initialization procedure).\n \n    procedure Add_Inlined_Subprogram (Index : Subp_Index);\n    --  Add the subprogram to the list of inlined subprogram for the unit\n@@ -178,12 +177,12 @@ package body Inline is\n    ------------------------------\n \n    --  The cleanup actions for scopes that contain instantiations is delayed\n-   --  until after expansion of those instantiations, because they may\n-   --  contain finalizable objects or tasks that affect the cleanup code.\n-   --  A scope that contains instantiations only needs to be finalized once,\n-   --  even if it contains more than one instance. We keep a list of scopes\n-   --  that must still be finalized, and call cleanup_actions after all the\n-   --  instantiations have been completed.\n+   --  until after expansion of those instantiations, because they may contain\n+   --  finalizable objects or tasks that affect the cleanup code. A scope\n+   --  that contains instantiations only needs to be finalized once, even\n+   --  if it contains more than one instance. We keep a list of scopes\n+   --  that must still be finalized, and call cleanup_actions after all\n+   --  the instantiations have been completed.\n \n    To_Clean : Elist_Id;\n \n@@ -299,9 +298,7 @@ package body Inline is\n          while Scope (Scop) /= Standard_Standard\n            and then not Is_Child_Unit (Scop)\n          loop\n-            if Is_Overloadable (Scop)\n-              and then Is_Inlined (Scop)\n-            then\n+            if Is_Overloadable (Scop) and then Is_Inlined (Scop) then\n                Add_Call (E, Scop);\n \n                if Inline_Level = 1 then\n@@ -430,9 +427,9 @@ package body Inline is\n          end if;\n \n          if Present\n-          (Exception_Handlers\n-            (Handled_Statement_Sequence\n-              (Unit_Declaration_Node (Corresponding_Body (Decl)))))\n+              (Exception_Handlers\n+                 (Handled_Statement_Sequence\n+                    (Unit_Declaration_Node (Corresponding_Body (Decl)))))\n          then\n             return True;\n          end if;\n@@ -462,8 +459,8 @@ package body Inline is\n \n       if Is_Inlined (E)\n         and then (Is_Inlined (Pack)\n-                    or else Is_Generic_Instance (Pack)\n-                    or else Is_Internal (E))\n+                   or else Is_Generic_Instance (Pack)\n+                   or else Is_Internal (E))\n         and then not In_Main_Unit_Or_Subunit (E)\n         and then not Is_Nested (E)\n         and then not Has_Initialized_Type (E)\n@@ -848,9 +845,9 @@ package body Inline is\n       --  elementary statements, as a measure of acceptable size.\n \n       function Has_Pending_Instantiation return Boolean;\n-      --  If some enclosing body contains instantiations that appear before the\n-      --  corresponding generic body, the enclosing body has a freeze node so\n-      --  that it can be elaborated after the generic itself. This might\n+      --  If some enclosing body contains instantiations that appear before\n+      --  the corresponding generic body, the enclosing body has a freeze node\n+      --  so that it can be elaborated after the generic itself. This might\n       --  conflict with subsequent inlinings, so that it is unsafe to try to\n       --  inline in such a case.\n \n@@ -919,7 +916,7 @@ package body Inline is\n          D := First (Decls);\n          while Present (D) loop\n             if (Nkind (D) = N_Function_Instantiation\n-                  and then not Is_Unchecked_Conversion (D))\n+                 and then not Is_Unchecked_Conversion (D))\n               or else Nkind_In (D, N_Protected_Type_Declaration,\n                                    N_Package_Declaration,\n                                    N_Package_Instantiation,\n@@ -972,10 +969,10 @@ package body Inline is\n                elsif Present (Handled_Statement_Sequence (S))\n                   and then\n                     (Present\n-                      (Exception_Handlers (Handled_Statement_Sequence (S)))\n-                     or else\n-                       Has_Excluded_Statement\n-                         (Statements (Handled_Statement_Sequence (S))))\n+                       (Exception_Handlers (Handled_Statement_Sequence (S)))\n+                      or else\n+                        Has_Excluded_Statement\n+                          (Statements (Handled_Statement_Sequence (S))))\n                then\n                   return True;\n                end if;\n@@ -1019,9 +1016,10 @@ package body Inline is\n \n             elsif Nkind (S) = N_Extended_Return_Statement then\n                if Has_Excluded_Statement\n-                  (Statements (Handled_Statement_Sequence (S)))\n-                 or else Present\n-                   (Exception_Handlers (Handled_Statement_Sequence (S)))\n+                    (Statements (Handled_Statement_Sequence (S)))\n+                 or else\n+                   Present\n+                     (Exception_Handlers (Handled_Statement_Sequence (S)))\n                then\n                   return True;\n                end if;\n@@ -1251,9 +1249,9 @@ package body Inline is\n                First (Exception_Handlers (Handled_Statement_Sequence (N))),\n                Subp);\n             return;\n+\n          elsif\n-           Has_Excluded_Statement\n-             (Statements (Handled_Statement_Sequence (N)))\n+           Has_Excluded_Statement (Statements (Handled_Statement_Sequence (N)))\n          then\n             return;\n          end if;\n@@ -1293,11 +1291,11 @@ package body Inline is\n \n       --  We need to capture references to the formals in order to substitute\n       --  the actuals at the point of inlining, i.e. instantiation. To treat\n-      --  the formals as globals to the body to inline, we nest it within\n-      --  a dummy parameterless subprogram, declared within the real one.\n-      --  To avoid generating an internal name (which is never public, and\n-      --  which affects serial numbers of other generated names), we use\n-      --  an internal symbol that cannot conflict with user declarations.\n+      --  the formals as globals to the body to inline, we nest it within a\n+      --  dummy parameterless subprogram, declared within the real one. To\n+      --  avoid generating an internal name (which is never public, and which\n+      --  affects serial numbers of other generated names), we use an internal\n+      --  symbol that cannot conflict with user declarations.\n \n       Set_Parameter_Specifications (Specification (Original_Body), No_List);\n       Set_Defining_Unit_Name\n@@ -1421,7 +1419,7 @@ package body Inline is\n                   Gen_P : constant Entity_Id := Generic_Parent (Parent (Subp));\n                begin\n                   if Is_Predefined_File_Name\n-                    (Unit_File_Name (Get_Source_Unit (Gen_P)))\n+                       (Unit_File_Name (Get_Source_Unit (Gen_P)))\n                   then\n                      Set_Is_Inlined (Subp, False);\n                      Error_Msg_NE (Msg & \"p?\", N, Subp);\n@@ -1681,7 +1679,7 @@ package body Inline is\n             D := First (Decls);\n             while Present (D) loop\n                if (Nkind (D) = N_Function_Instantiation\n-                   and then not Is_Unchecked_Conversion (D))\n+                    and then not Is_Unchecked_Conversion (D))\n                  or else Nkind_In (D, N_Protected_Type_Declaration,\n                                    N_Package_Declaration,\n                                    N_Package_Instantiation,\n@@ -1734,17 +1732,17 @@ package body Inline is\n \n                   elsif Present (Handled_Statement_Sequence (S)) then\n                      if Present\n-                       (Exception_Handlers (Handled_Statement_Sequence (S)))\n+                          (Exception_Handlers (Handled_Statement_Sequence (S)))\n                      then\n                         Cannot_Inline\n                           (\"cannot inline& (exception handler)?\",\n                            First (Exception_Handlers\n-                             (Handled_Statement_Sequence (S))),\n+                                    (Handled_Statement_Sequence (S))),\n                            Subp);\n                         return True;\n \n                      elsif Has_Excluded_Statement\n-                       (Statements (Handled_Statement_Sequence (S)))\n+                             (Statements (Handled_Statement_Sequence (S)))\n                      then\n                         return True;\n                      end if;\n@@ -1797,7 +1795,7 @@ package body Inline is\n                   elsif Present (Handled_Statement_Sequence (S))\n                     and then\n                       Present (Exception_Handlers\n-                               (Handled_Statement_Sequence (S)))\n+                                (Handled_Statement_Sequence (S)))\n                   then\n                      Cannot_Inline\n                        (\"cannot inline& (exception handler)?\",\n@@ -1824,9 +1822,7 @@ package body Inline is\n          begin\n             S := Current_Scope;\n             while Present (S) loop\n-               if Is_Compilation_Unit (S)\n-                 or else Is_Child_Unit (S)\n-               then\n+               if Is_Compilation_Unit (S) or else Is_Child_Unit (S) then\n                   return False;\n \n                elsif Ekind (S) = E_Package\n@@ -1862,12 +1858,12 @@ package body Inline is\n                   if Present (Expression (N)) then\n                      declare\n                         Orig_Expr : constant Node_Id :=\n-                          Original_Node (Expression (N));\n+                                      Original_Node (Expression (N));\n \n                      begin\n                         if Nkind_In (Orig_Expr, N_Integer_Literal,\n-                                     N_Real_Literal,\n-                                     N_Character_Literal)\n+                                                N_Real_Literal,\n+                                                N_Character_Literal)\n                         then\n                            return OK;\n \n@@ -2060,14 +2056,12 @@ package body Inline is\n             then\n                Cannot_Inline\n                  (\"cannot inline& (exception handler)?\",\n-                  First\n-                    (Exception_Handlers (Handled_Statement_Sequence (N))),\n+                  First (Exception_Handlers (Handled_Statement_Sequence (N))),\n                   Subp);\n-\n                return False;\n \n             elsif Has_Excluded_Statement\n-              (Statements (Handled_Statement_Sequence (N)))\n+                    (Statements (Handled_Statement_Sequence (N)))\n             then\n                return False;\n             end if;\n@@ -2096,7 +2090,6 @@ package body Inline is\n             Cannot_Inline\n               (\"cannot inline& (forward instance within enclosing body)?\",\n                N, Subp);\n-\n             return False;\n          end if;\n \n@@ -2318,61 +2311,65 @@ package body Inline is\n          --  Build a procedure containing the statements found in the extended\n          --  return statement of the unconstrained function body N.\n \n+         ---------------------\n+         -- Build_Procedure --\n+         ---------------------\n+\n          procedure Build_Procedure\n            (Proc_Id   : out Entity_Id;\n             Decl_List : out List_Id)\n          is\n-            Formal      : Entity_Id;\n-            Formal_List : constant List_Id := New_List;\n-            Proc_Spec   : Node_Id;\n-            Proc_Body   : Node_Id;\n-            Subp_Name   : constant Name_Id := New_Internal_Name ('F');\n+            Formal         : Entity_Id;\n+            Formal_List    : constant List_Id := New_List;\n+            Proc_Spec      : Node_Id;\n+            Proc_Body      : Node_Id;\n+            Subp_Name      : constant Name_Id := New_Internal_Name ('F');\n             Body_Decl_List : List_Id := No_List;\n-            Param_Type  : Node_Id;\n+            Param_Type     : Node_Id;\n \n          begin\n             if Nkind (Object_Definition (Ret_Obj)) = N_Identifier then\n-               Param_Type := New_Copy (Object_Definition (Ret_Obj));\n+               Param_Type :=\n+                 New_Copy (Object_Definition (Ret_Obj));\n             else\n                Param_Type :=\n                  New_Copy (Subtype_Mark (Object_Definition (Ret_Obj)));\n             end if;\n \n             Append_To (Formal_List,\n               Make_Parameter_Specification (Loc,\n-                Defining_Identifier =>\n+                Defining_Identifier    =>\n                   Make_Defining_Identifier (Loc,\n                     Chars => Chars (Defining_Identifier (Ret_Obj))),\n-                In_Present  => False,\n-                Out_Present => True,\n+                In_Present             => False,\n+                Out_Present            => True,\n                 Null_Exclusion_Present => False,\n-                Parameter_Type => Param_Type));\n+                Parameter_Type         => Param_Type));\n \n             Formal := First_Formal (Spec_Id);\n             while Present (Formal) loop\n                Append_To (Formal_List,\n                  Make_Parameter_Specification (Loc,\n-                   Defining_Identifier =>\n+                   Defining_Identifier    =>\n                      Make_Defining_Identifier (Sloc (Formal),\n                        Chars => Chars (Formal)),\n-                   In_Present  => In_Present (Parent (Formal)),\n-                   Out_Present => Out_Present (Parent (Formal)),\n+                   In_Present             => In_Present (Parent (Formal)),\n+                   Out_Present            => Out_Present (Parent (Formal)),\n                    Null_Exclusion_Present =>\n                      Null_Exclusion_Present (Parent (Formal)),\n-                   Parameter_Type =>\n+                   Parameter_Type         =>\n                      New_Occurrence_Of (Etype (Formal), Loc),\n-                   Expression =>\n+                   Expression             =>\n                      Copy_Separate_Tree (Expression (Parent (Formal)))));\n \n                Next_Formal (Formal);\n             end loop;\n \n-            Proc_Id :=\n-              Make_Defining_Identifier (Loc, Chars => Subp_Name);\n+            Proc_Id := Make_Defining_Identifier (Loc, Chars => Subp_Name);\n \n             Proc_Spec :=\n               Make_Procedure_Specification (Loc,\n-                Defining_Unit_Name => Proc_Id,\n+                Defining_Unit_Name       => Proc_Id,\n                 Parameter_Specifications => Formal_List);\n \n             Decl_List := New_List;\n@@ -2434,7 +2431,7 @@ package body Inline is\n \n       begin\n          --  Build the associated procedure, analyze it and insert it before\n-         --  the function body N\n+         --  the function body N.\n \n          declare\n             Scope     : constant Entity_Id := Current_Scope;\n@@ -2468,7 +2465,7 @@ package body Inline is\n \n             Proc_Call :=\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (Proc_Id, Loc),\n+                Name                   => New_Occurrence_Of (Proc_Id, Loc),\n                 Parameter_Associations => Actual_List);\n          end;\n \n@@ -2483,7 +2480,7 @@ package body Inline is\n \n          Blk_Stmt :=\n            Make_Block_Statement (Loc,\n-             Declarations => New_List (New_Obj),\n+             Declarations               => New_List (New_Obj),\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n                  Statements => New_List (\n@@ -2501,14 +2498,14 @@ package body Inline is\n    --  Start of processing for Check_And_Build_Body_To_Inline\n \n    begin\n-      --  Do not inline any subprogram that contains nested subprograms, since\n-      --  the backend inlining circuit seems to generate uninitialized\n+      --  Do not inline any subprogram that contains nested subprograms,\n+      --  since the backend inlining circuit seems to generate uninitialized\n       --  references in this case. We know this happens in the case of front\n-      --  end ZCX support, but it also appears it can happen in other cases as\n-      --  well. The backend often rejects attempts to inline in the case of\n-      --  nested procedures anyway, so little if anything is lost by this.\n-      --  Note that this is test is for the benefit of the back-end. There is\n-      --  a separate test for front-end inlining that also rejects nested\n+      --  end ZCX support, but it also appears it can happen in other cases\n+      --  as well. The backend often rejects attempts to inline in the case\n+      --  of nested procedures anyway, so little if anything is lost by this.\n+      --  Note that this is test is for the benefit of the back-end. There\n+      --  is a separate test for front-end inlining that also rejects nested\n       --  subprograms.\n \n       --  Do not do this test if errors have been detected, because in some\n@@ -2517,7 +2514,7 @@ package body Inline is\n \n       if Comes_From_Source (Body_Id)\n         and then (Has_Pragma_Inline_Always (Spec_Id)\n-                    or else Optimization_Level > 0)\n+                   or else Optimization_Level > 0)\n         and then Serious_Errors_Detected = 0\n       then\n          declare\n@@ -2561,6 +2558,7 @@ package body Inline is\n          end if;\n       end if;\n    end Check_And_Build_Body_To_Inline;\n+\n    -----------------------------\n    -- Check_Body_For_Inlining --\n    -----------------------------\n@@ -2635,7 +2633,7 @@ package body Inline is\n                                  Ent := First_Entity (P);\n                                  while Present (Ent) loop\n                                     if Is_Type (Ent)\n-                                       and then Has_Completion_In_Body (Ent)\n+                                      and then Has_Completion_In_Body (Ent)\n                                     then\n                                        Set_Full_View (Ent, Empty);\n \n@@ -2692,12 +2690,12 @@ package body Inline is\n            and then Is_Protected_Type (Scope (Scop))\n            and then Present (Protected_Body_Subprogram (Scop))\n          then\n-            --  If a protected operation contains an instance, its\n-            --  cleanup operations have been delayed, and the subprogram\n-            --  has been rewritten in the expansion of the enclosing\n-            --  protected body. It is the corresponding subprogram that\n-            --  may require the cleanup operations, so propagate the\n-            --  information that triggers cleanup activity.\n+            --  If a protected operation contains an instance, its cleanup\n+            --  operations have been delayed, and the subprogram has been\n+            --  rewritten in the expansion of the enclosing protected body. It\n+            --  is the corresponding subprogram that may require the cleanup\n+            --  operations, so propagate the information that triggers cleanup\n+            --  activity.\n \n             Set_Uses_Sec_Stack\n               (Protected_Body_Subprogram (Scop),\n@@ -2712,9 +2710,9 @@ package body Inline is\n          else\n             Decl := Unit_Declaration_Node (Scop);\n \n-            if Nkind (Decl) = N_Subprogram_Declaration\n-              or else Nkind (Decl) = N_Task_Type_Declaration\n-              or else Nkind (Decl) = N_Subprogram_Body_Stub\n+            if Nkind_In (Decl, N_Subprogram_Declaration,\n+                               N_Task_Type_Declaration,\n+                               N_Subprogram_Body_Stub)\n             then\n                Decl := Unit_Declaration_Node (Corresponding_Body (Decl));\n             end if;\n@@ -2739,15 +2737,15 @@ package body Inline is\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Is_Predef : constant Boolean :=\n-                   Is_Predefined_File_Name\n-                     (Unit_File_Name (Get_Source_Unit (Subp)));\n+                    Is_Predefined_File_Name\n+                      (Unit_File_Name (Get_Source_Unit (Subp)));\n       Orig_Bod  : constant Node_Id :=\n                     Body_To_Inline (Unit_Declaration_Node (Subp));\n \n       Blk      : Node_Id;\n       Decl     : Node_Id;\n       Decls    : constant List_Id := New_List;\n-      Exit_Lab : Entity_Id := Empty;\n+      Exit_Lab : Entity_Id        := Empty;\n       F        : Entity_Id;\n       A        : Node_Id;\n       Lab_Decl : Node_Id;\n@@ -2823,8 +2821,8 @@ package body Inline is\n             Exit_Lab := Make_Label (Loc, Lab_Id);\n             Lab_Decl :=\n               Make_Implicit_Label_Declaration (Loc,\n-                Defining_Identifier  => Lab_Ent,\n-                Label_Construct      => Exit_Lab);\n+                Defining_Identifier => Lab_Ent,\n+                Label_Construct     => Exit_Lab);\n          end if;\n       end Make_Exit_Label;\n \n@@ -2922,7 +2920,7 @@ package body Inline is\n                   Ret :=\n                     Make_Qualified_Expression (Sloc (N),\n                       Subtype_Mark => New_Occurrence_Of (Ret_Type, Sloc (N)),\n-                      Expression => Relocate_Node (Expression (N)));\n+                      Expression   => Relocate_Node (Expression (N)));\n                else\n                   Ret :=\n                     Unchecked_Convert_To\n@@ -3333,7 +3331,7 @@ package body Inline is\n             Bod := Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n             Blk :=\n               Make_Block_Statement (Loc,\n-                Declarations => Declarations (Bod),\n+                Declarations               => Declarations (Bod),\n                 Handled_Statement_Sequence =>\n                   Handled_Statement_Sequence (Bod));\n \n@@ -3386,9 +3384,9 @@ package body Inline is\n                  Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n                Blk :=\n                  Make_Block_Statement (Loc,\n-                                       Declarations => Declarations (Bod),\n-                                       Handled_Statement_Sequence =>\n-                                         Handled_Statement_Sequence (Bod));\n+                   Declarations               => Declarations (Bod),\n+                   Handled_Statement_Sequence =>\n+                     Handled_Statement_Sequence (Bod));\n \n             --  Inline a call to a function that returns an unconstrained type.\n             --  The semantic analyzer checked that frontend-inlined functions\n@@ -3402,18 +3400,14 @@ package body Inline is\n                pragma Assert\n                  (Nkind\n                    (First\n-                     (Statements (Handled_Statement_Sequence (Orig_Bod))))\n-                  = N_Block_Statement);\n+                     (Statements (Handled_Statement_Sequence (Orig_Bod)))) =\n+                                                         N_Block_Statement);\n \n                declare\n                   Blk_Stmt    : constant Node_Id :=\n-                    First\n-                      (Statements\n-                        (Handled_Statement_Sequence (Orig_Bod)));\n+                    First (Statements (Handled_Statement_Sequence (Orig_Bod)));\n                   First_Stmt  : constant Node_Id :=\n-                    First\n-                      (Statements\n-                        (Handled_Statement_Sequence (Blk_Stmt)));\n+                    First (Statements (Handled_Statement_Sequence (Blk_Stmt)));\n                   Second_Stmt : constant Node_Id := Next (First_Stmt);\n \n                begin\n@@ -3652,8 +3646,7 @@ package body Inline is\n             --  eventually be possible to remove that temporary and use the\n             --  result variable directly.\n \n-            if Is_Unc\n-              and then Nkind (Parent (N)) /= N_Assignment_Statement\n+            if Is_Unc and then Nkind (Parent (N)) /= N_Assignment_Statement\n             then\n                Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -3857,6 +3850,7 @@ package body Inline is\n          Next_Formal (F);\n       end loop;\n    end Expand_Inlined_Call;\n+\n    --------------------------\n    -- Get_Code_Unit_Entity --\n    --------------------------\n@@ -3887,7 +3881,6 @@ package body Inline is\n       else\n          Decl := First (Declarations (E_Body));\n          while Present (Decl) loop\n-\n             if Nkind (Decl) = N_Full_Type_Declaration\n               and then Present (Init_Proc (Defining_Identifier (Decl)))\n             then"}, {"sha": "4c1dbf92fe9bb9faa58a54d400dc989af2d5049c", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -35,12 +35,12 @@\n --  of them uses a workpile algorithm, but they are called independently from\n --  Frontend, and thus are not mutually recursive.\n \n---  Front-end inlining for subprograms marked Inline_Always. This is primarily\n---  an expansion activity that is performed for performance reasons, and when\n---  the target does not use the gcc backend.  Inline_Always can also be used\n---  in the context of GNATprove, to perform source transformations to simplify\n---  proof obligations. The machinery used in both cases is similar, but there\n---  are fewer restrictions on the source of subprograms in the latter case.\n+--  c) Front-end inlining for Inline_Always subprograms. This is primarily an\n+--  expansion activity that is performed for performance reasons, and when the\n+--  target does not use the gcc backend. Inline_Always can also be used in the\n+--  context of GNATprove, to perform source transformations to simplify proof\n+--  obligations. The machinery used in both cases is similar, but there are\n+--  fewer restrictions on the source of subprograms in the latter case.\n \n with Alloc;\n with Opt;    use Opt;\n@@ -133,7 +133,7 @@ package Inline is\n    Backend_Calls : Elist_Id := No_Elist;\n    --  List of frontend inlined calls and inline calls passed to the backend\n \n------------------\n+   -----------------\n    -- Subprograms --\n    -----------------\n \n@@ -168,7 +168,7 @@ package Inline is\n    --  that cannot be inlined, the offending construct is flagged accordingly.\n \n    procedure Cannot_Inline\n-      (Msg        : String;\n+     (Msg        : String;\n       N          : Node_Id;\n       Subp       : Entity_Id;\n       Is_Serious : Boolean := False);"}, {"sha": "8caf19c49a6ff326f37603b57a2262d1f6cdd258", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -1942,7 +1942,7 @@ package body Sem_Ch6 is\n                   if From_Limited_With (Typ) and then In_Package_Body then\n                      Error_Msg_NE\n                        (\"invalid use of incomplete type&\",\n-                          Result_Definition (N), Typ);\n+                        Result_Definition (N), Typ);\n \n                   elsif Is_Tagged_Type (Typ) then\n                      null;\n@@ -3960,7 +3960,8 @@ package body Sem_Ch6 is\n                   Error_Msg_N\n                     (\"interface procedure % must be abstract or null\", N);\n                else\n-                  Error_Msg_N (\"interface function % must be abstract\", N);\n+                  Error_Msg_N\n+                    (\"interface function % must be abstract\", N);\n                end if;\n             end if;\n          end;\n@@ -4168,9 +4169,9 @@ package body Sem_Ch6 is\n          --  the check is applied later (see Analyze_Subprogram_Declaration).\n \n          if not Nkind_In (Original_Node (Parent (N)),\n-                            N_Subprogram_Renaming_Declaration,\n-                            N_Abstract_Subprogram_Declaration,\n-                            N_Formal_Abstract_Subprogram_Declaration)\n+                          N_Subprogram_Renaming_Declaration,\n+                          N_Abstract_Subprogram_Declaration,\n+                          N_Formal_Abstract_Subprogram_Declaration)\n          then\n             if Is_Abstract_Type (Etype (Designator))\n               and then not Is_Interface (Etype (Designator))\n@@ -4188,7 +4189,7 @@ package body Sem_Ch6 is\n               and then Ada_Version >= Ada_2012\n             then\n                Error_Msg_N (\"function whose access result designates \"\n-                 & \"abstract type must be abstract\", N);\n+                            & \"abstract type must be abstract\", N);\n             end if;\n          end if;\n       end if;"}, {"sha": "f33f268732ad2deec1245e61d08889279ca30cb6", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -6317,14 +6317,6 @@ package body Sem_Prag is\n             Set_Treat_As_Volatile (E);\n             Set_Treat_As_Volatile (Underlying_Type (E));\n \n-            --  The following check is only relevant when SPARK_Mode is on as\n-            --  this is not a standard Ada legality rule. Volatile types are\n-            --  not allowed (SPARK RM C.6(1)).\n-\n-            if SPARK_Mode = On and then Prag_Id = Pragma_Volatile then\n-               Error_Msg_N (\"volatile type not allowed\", E);\n-            end if;\n-\n          elsif K = N_Object_Declaration\n            or else (K = N_Component_Declaration\n                      and then Original_Record_Component (E) = E)"}, {"sha": "9f304eedb8b9b94f0c4c9b8ddd1cf155c6f937cc", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 70, "deletions": 25, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -6420,6 +6420,13 @@ package body Sem_Res is\n       function Appears_In_Check (Nod : Node_Id) return Boolean;\n       --  Denote whether an arbitrary node Nod appears in a check node\n \n+      function Is_OK_Volatile_Context\n+        (Context : Node_Id;\n+         Obj_Ref : Node_Id) return Boolean;\n+      --  Determine whether node Context denotes a \"non-interfering context\"\n+      --  (as defined in SPARK RM 7.1.3(13)) where volatile reference Obj_Ref\n+      --  can safely reside.\n+\n       ----------------------\n       -- Appears_In_Check --\n       ----------------------\n@@ -6447,6 +6454,64 @@ package body Sem_Res is\n          return False;\n       end Appears_In_Check;\n \n+      ----------------------------\n+      -- Is_OK_Volatile_Context --\n+      ----------------------------\n+\n+      function Is_OK_Volatile_Context\n+        (Context : Node_Id;\n+         Obj_Ref : Node_Id) return Boolean\n+      is\n+      begin\n+         --  The volatile object appears on either side of an assignment\n+\n+         if Nkind (Context) = N_Assignment_Statement then\n+            return True;\n+\n+         --  The volatile object is part of the initialization expression of\n+         --  another object. Ensure that the climb of the parent chain came\n+         --  from the expression side and not from the name side.\n+\n+         elsif Nkind (Context) = N_Object_Declaration\n+           and then Present (Expression (Context))\n+           and then Expression (Context) = Obj_Ref\n+         then\n+            return True;\n+\n+         --  The volatile object appears as an actual parameter in a call to an\n+         --  instance of Unchecked_Conversion whose result is renamed.\n+\n+         elsif Nkind (Context) = N_Function_Call\n+           and then Is_Unchecked_Conversion_Instance (Entity (Name (Context)))\n+           and then Nkind (Parent (Context)) = N_Object_Renaming_Declaration\n+         then\n+            return True;\n+\n+         --  The volatile object appears as the prefix of a name occurring\n+         --  in a non-interfering context.\n+\n+         elsif Nkind_In (Context, N_Attribute_Reference,\n+                                  N_Indexed_Component,\n+                                  N_Selected_Component,\n+                                  N_Slice)\n+           and then Prefix (Context) = Obj_Ref\n+           and then Is_OK_Volatile_Context\n+                      (Context => Parent (Context),\n+                       Obj_Ref => Context)\n+         then\n+            return True;\n+\n+         --  Allow references to volatile objects in various checks. This is\n+         --  not a direct SPARK 2014 requirement.\n+\n+         elsif Appears_In_Check (Context) then\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_OK_Volatile_Context;\n+\n       --  Local variables\n \n       E   : constant Entity_Id := Entity (N);\n@@ -6568,28 +6633,10 @@ package body Sem_Res is\n         and then\n           (Async_Writers_Enabled (E) or else Effective_Reads_Enabled (E))\n       then\n-         --  The volatile object can appear on either side of an assignment\n+         --  The volatile objects appears in a \"non-interfering context\" as\n+         --  defined in SPARK RM 7.1.3(13).\n \n-         if Nkind (Par) = N_Assignment_Statement then\n-            null;\n-\n-         --  The volatile object is part of the initialization expression of\n-         --  another object. Ensure that the climb of the parent chain came\n-         --  from the expression side and not from the name side.\n-\n-         elsif Nkind (Par) = N_Object_Declaration\n-           and then Present (Expression (Par))\n-           and then N = Expression (Par)\n-         then\n-            null;\n-\n-         --  The volatile object appears as an actual parameter in a call to an\n-         --  instance of Unchecked_Conversion whose result is renamed.\n-\n-         elsif Nkind (Par) = N_Function_Call\n-           and then Is_Unchecked_Conversion_Instance (Entity (Name (Par)))\n-           and then Nkind (Parent (Par)) = N_Object_Renaming_Declaration\n-         then\n+         if Is_OK_Volatile_Context (Par, N) then\n             null;\n \n          --  Assume that references to volatile objects that appear as actual\n@@ -6599,10 +6646,8 @@ package body Sem_Res is\n          elsif Nkind (Par) = N_Procedure_Call_Statement then\n             null;\n \n-         --  Allow references to volatile objects in various checks\n-\n-         elsif Appears_In_Check (Par) then\n-            null;\n+         --  Otherwise the context causes a side effect with respect to the\n+         --  volatile object.\n \n          else\n             Error_Msg_N"}, {"sha": "5c0854105715558d714d2bb54892ad40a751d3b5", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -1851,9 +1851,9 @@ package Sinfo is\n    --    to assist in detecting this illegal use of Unrestricted_Access.\n \n    --  Null_Excluding_Subtype (Flag16)\n-   --   Present in N_Access_To_Object_Definition. Indicates that the subtype\n-   --   indication carries a null-exclusion indicator, which is distinct from\n-   --   the null-exclusion indicator that may precede the access keyword.\n+   --    Present in N_Access_To_Object_Definition. Indicates that the subtype\n+   --    indication carries a null-exclusion indicator, which is distinct from\n+   --    the null-exclusion indicator that may precede the access keyword.\n \n    --  Original_Discriminant (Node2-Sem)\n    --    Present in identifiers. Used in references to discriminants that"}, {"sha": "e6ee6f1e1ded2c8f8562d5c2f3c898dca9d33471", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -56,8 +56,8 @@ package Snames is\n \n    --  First we have the one character names used to optimize the lookup\n    --  process for one character identifiers (to avoid the hashing in this\n-   --  case) There are a full 256 of these, but only the entries for lower case\n-   --  and upper case letters have identifiers\n+   --  case) There are a full 256 of these, but only the entries for lower\n+   --  case and upper case letters have identifiers\n \n    --  The lower case letter entries are used for one character identifiers\n    --  appearing in the source, for example in pragma Interface (C)."}, {"sha": "a7fbb2ad649db598ac68c50ede8a5e8011db5bd8", "filename": "gcc/ada/xsnamest.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fxsnamest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f80a182094a48e467eb5fd774c3016036980a0a/gcc%2Fada%2Fxsnamest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxsnamest.adb?ref=3f80a182094a48e467eb5fd774c3016036980a0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -255,10 +255,6 @@ begin\n                Name0 := 'O' & Translate (Name0, Lower_Case_Map);\n             end if;\n \n-            if Name0 = \"error\" then\n-               Name0 := V (\"<error>\");\n-            end if;\n-\n             if not Match (Name0, Chk_Low) then\n                Put_Line (OutB, \"     \"\"\" & Name0 & \"#\"\" &\");\n             end if;"}]}