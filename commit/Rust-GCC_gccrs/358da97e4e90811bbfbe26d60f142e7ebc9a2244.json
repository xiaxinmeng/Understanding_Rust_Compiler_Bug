{"sha": "358da97e4e90811bbfbe26d60f142e7ebc9a2244", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU4ZGE5N2U0ZTkwODExYmJmYmUyNmQ2MGYxNDJlN2ViYzlhMjI0NA==", "commit": {"author": {"name": "Hari Sandanagobalane", "email": "hariharan@picochip.com", "date": "2008-09-03T12:10:49Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2008-09-03T12:10:49Z"}, "message": "Add picoChip port.\n\n2008-09-03  Hari Sandanagobalane  <hariharan@picochip.com>\n\n\tAdd picoChip port.\n\t* MAINTAINERS: Add picoChip maintainers.\n\tlibgcc/\n\t* config.host: Add picochip-*-*.\n\tgcc/\n\t* doc/extend.texi: Document picoChip builtin functions.\n\t* doc/invoke.texi: Document picoChip options.\n\t* doc/contrib.texi: Add picoChip contribution.\n\t* doc/md.texi: Document picoChip constraints.\n\t* config.gcc: Add picochip-*-*.\n\t* config/picochip/: Add new port.\n\nFrom-SVN: r139932", "tree": {"sha": "646b39b9d13d74c6e891802aeb4609ac1500539a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/646b39b9d13d74c6e891802aeb4609ac1500539a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/358da97e4e90811bbfbe26d60f142e7ebc9a2244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358da97e4e90811bbfbe26d60f142e7ebc9a2244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358da97e4e90811bbfbe26d60f142e7ebc9a2244", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358da97e4e90811bbfbe26d60f142e7ebc9a2244/comments", "author": null, "committer": null, "parents": [{"sha": "44299c960128427cf464bd1d8f6497e2b4cfb2ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44299c960128427cf464bd1d8f6497e2b4cfb2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44299c960128427cf464bd1d8f6497e2b4cfb2ed"}], "stats": {"total": 12560, "additions": 12560, "deletions": 0}, "files": [{"sha": "ff4e81e61d2badefe8eefc4392ffb0528a96b66c", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -1,3 +1,8 @@\n+2008-09-03  Hari Sandanagobalane  <hariharan@picochip.com>\n+\n+\tAdd picoChip port.\n+\t* MAINTAINERS: Add picoChip maintainers.\n+\n 2008-09-02  Sebastian Pop  <sebastian.pop@amd.com>\n \t    Tobias Grosser  <grosser@fim.uni-passau.de>\n \t    Jan Sjodin  <jan.sjodin@amd.com>"}, {"sha": "35832ae80233f7586dd229c4568a5cf81bb8d5e9", "filename": "MAINTAINERS", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -69,6 +69,8 @@ mmix port\t\tHans-Peter Nilsson\thp@bitrange.com\n mn10300 port\t\tJeff Law\t\tlaw@redhat.com\n mn10300 port\t\tAlexandre Oliva\t\taoliva@redhat.com\n pdp11 port\t\tPaul Koning\t\tni1d@arrl.net\n+picochip port\t\tHari Sandanagobalane\thariharan@picochip.com\n+picochip port\t\tDaniel Towner\t\tdant@picochip.com\n rs6000 port\t\tGeoff Keating\t\tgeoffk@geoffk.org\n rs6000 port\t\tDavid Edelsohn\t\tedelsohn@gnu.org\n rs6000 vector extns\tAldy Hernandez\t\taldyh@redhat.com"}, {"sha": "2b100b6c79e8babaa3a363c758097d6cd8aabffe", "filename": "config/picochip/constraints.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fconstraints.md?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,68 @@\n+;; GCC machine description for picochip\n+;; Copyright (C) 2008 Free Software Foundation, Inc.\n+;; Contributed by picoChip Designs Ltd (http://www.picochip.com)\n+;; Maintained by Daniel Towner (dant@picochip.com) and Hariharan\n+;; Sandanagobalane (hariharan@picochip.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not, see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_constraint \"I\"\n+ \"4-bits signed value\"\n+ (and (match_code \"const_int\")\n+      (match_test \" ival >= -8 && ival< 8\")))\n+\n+(define_constraint \"J\"\n+ \"4-bits unsigned value\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival>=0 && ival < 16\")))\n+\n+(define_constraint \"K\"\n+ \"8-bits signed value\"\n+ (and (match_code \"const_int\")\n+      (match_test \" ival >= -128 && ival < 128\")))\n+\n+(define_constraint \"M\"\n+ \"4-bits magnitude\"\n+ (and (match_code \"const_int\")\n+      (match_test \" abs(ival) < 16\")))\n+\n+(define_constraint \"N\"\n+ \"10-bits signed value\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival >= -512 && ival < 512\")))\n+\n+(define_constraint \"O\"\n+ \"16-bits signed value\"\n+ (and (match_code \"const_int\")\n+      (match_test \" ival >= -32768 && ival < 32768 \")))\n+\n+(define_constraint \"a\"\n+ \"See if this is an absolute address in memory\"\n+  (and (match_code \"mem\")\n+       (match_test \"picochip_absolute_memory_operand(op,mode) == 1\")))\n+\n+(define_constraint \"b\"\n+ \"See if this is an address in memory, non-strict version\"\n+  (match_test \"picochip_legitimate_address_p(mode,op,0) == 1\"))\n+\n+(define_register_constraint \"k\" \"FRAME_REGS\"\n+  \"Frame regs\")\n+(define_register_constraint \"f\" \"PTR_REGS\"\n+  \"Pointer regs\")\n+(define_register_constraint \"t\" \"TWIN_REGS\"\n+  \"Twin regs\")\n+"}, {"sha": "9a6d8c2a0f3579c3ac6fdbc7361033d8de39ca08", "filename": "config/picochip/dfa_space.md", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fdfa_space.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fdfa_space.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fdfa_space.md?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,43 @@\n+;; GCC machine description for picochip\n+;; Copyright (C) 2008 Free Software Foundation, Inc.\n+;; Contributed by picoChip Designs Ltd (http://www.picochip.com)\n+;; Maintained by Daniel Towner (dant@picochip.com) and Hariharan\n+;; Sandanagobalane (hariharan@picochip.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not, see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; The following DFA description schedules instructions for space.  The\n+;; schedule seeks to avoid stall cycles (e.g., memory load), but the\n+;; instructions are not VLIW packed (whenever instructions are packed\n+;; together, an additional byte is used to denote this, which\n+;; increases the code size).\n+\n+;; No special handling of the long constants is necessary (as in\n+;; dfa_speed.md), since VLIW packing is not used.\n+\n+;; Memory instructions stall for one cycle.  All other instructions\n+;; complete ready for the next cycle.\n+\n+(define_insn_reservation \"nonStallInsn\" 1\n+  (and (eq_attr \"schedType\" \"space\")\n+       (eq_attr \"type\" \"!mem\"))\n+  \"slot0+slot1+slot2\")\n+\n+(define_insn_reservation \"stallInsn\" 2\n+  (and (eq_attr \"schedType\" \"space\")\n+       (eq_attr \"type\" \"mem\"))\n+  \"slot0+slot1+slot2\")"}, {"sha": "6f2f7562abb6e43a71ec10db0d11b73b55f0ef52", "filename": "config/picochip/dfa_speed.md", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fdfa_speed.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fdfa_speed.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fdfa_speed.md?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,123 @@\n+;; GCC machine description for picochip\n+;; Copyright (C) 2008 Free Software Foundation, Inc.\n+;; Contributed by picoChip Designs Ltd (http://www.picochip.com)\n+;; Maintained by Daniel Towner (dant@picochip.com) and Hariharan\n+;; Sandanagobalane (hariharan@picochip.com).\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not, see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; The following DFA description schedules instructions for speed.  In\n+;; addition to the scheduling of instructions to remove stall cycles\n+;; (e.g., memory load), the scheduler will also pack multiple\n+;; instructions into a single cycle, using VLIW.\n+\n+;; Each instruction comes in forms with and without long\n+;; constants.  The long constant is treated as though it were also an\n+;; instruction.  Thus, an instruction which used slot0, will use slot0\n+;; plus one of the other slots for the constant.  This mechanism\n+;; ensures that it is impossible for 3 instructions to be issued, if\n+;; one of them has a long constant.  This is necessary, because the\n+;; encoding of 3 instructions, plus a constant, will overrun the\n+;; 64-bit limit.\n+\n+; Extended ALU - Slot 0\n+(define_insn_reservation \"picoAluInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"picoAlu\") (eq_attr \"longConstant\" \"false\")))\n+  \"slot0\")\n+(define_insn_reservation \"picoAluInsnWithConst\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"picoAlu\") (eq_attr \"longConstant\" \"true\")))\n+  \"(slot0+slot1)|(slot0+slot2)\")\n+\n+; Basic ALU - Slot 0 or 1\n+(define_insn_reservation \"basicAluInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"basicAlu\") (eq_attr \"longConstant\" \"false\")))\n+  \"(slot0|slot1)\")\n+(define_insn_reservation \"basicAluInsnWithConst\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"basicAlu\") (eq_attr \"longConstant\" \"true\")))\n+  \"(slot0+slot1) | (slot1+slot2) | (slot0+slot2)\")\n+\n+; ALU which must not set flags - Slot 1\n+(define_insn_reservation \"nonCcAluInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"nonCcAlu\") (eq_attr \"longConstant\" \"false\")))\n+  \"slot1\")\n+(define_insn_reservation \"nonCcAluInsnWithConst\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"nonCcAlu\") (eq_attr \"longConstant\" \"true\")))\n+  \"(slot1+slot0) | (slot1+slot2)\")\n+\n+; Memory - Slot 1\n+(define_insn_reservation \"memInsn\" 2\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"mem\") (eq_attr \"longConstant\" \"false\")))\n+  \"slot1,nothing\")\n+(define_insn_reservation \"memInsnWithConst\" 2\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"mem\") (eq_attr \"longConstant\" \"true\")))\n+  \"slot1+(slot0|slot2),nothing\")\n+\n+; Multiply - Slot 2\n+(define_insn_reservation \"mulInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"mul\") (eq_attr \"longConstant\" \"false\")))\n+  \"slot2\")\n+(define_insn_reservation \"mulInsnWithConst\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"mul\") (eq_attr \"longConstant\" \"true\")))\n+  \"(slot2+slot0)|(slot2+slot1)\")\n+\n+; MAC - Slot 2\n+(define_insn_reservation \"macInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"mac\") (eq_attr \"longConstant\" \"false\")))\n+  \"slot2\")\n+(define_insn_reservation \"macInsnWithConst\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"mac\") (eq_attr \"longConstant\" \"true\")))\n+  \"(slot2+slot0)|(slot2+slot1)\")\n+\n+; Branch - Real branches use slot2, while macro branches use unknown\n+; resources.\n+(define_insn_reservation \"branchInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"realBranch\") (eq_attr \"longConstant\" \"false\")))\n+  \"slot2\")\n+(define_insn_reservation \"branchInsnWithConst\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (and (eq_attr \"type\" \"realBranch\") (eq_attr \"longConstant\" \"true\")))\n+  \"(slot2+slot0)|(slot2+slot1)\")\n+(define_insn_reservation \"branchInsnMacro\" 1\n+  (and (eq_attr \"schedType\" \"speed\")\n+       (eq_attr \"type\" \"realBranch\"))\n+  \"(slot0+slot1+slot2)\")\n+\n+; Call instructions use all slots to prevent inadvertent scheduling\n+; alongside instructions which set R12.\n+\n+(define_insn_reservation \"callInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\") (eq_attr \"type\" \"call\"))\n+  \"slot0+slot1+slot2\")\n+\n+; Communications - Slot 1\n+(define_insn_reservation \"commsInsn\" 1\n+  (and (eq_attr \"schedType\" \"speed\") (eq_attr \"type\" \"comms\"))\n+  \"slot1\")\n+"}, {"sha": "99fb6932627ce54869cd34b6620196dfe316e2ec", "filename": "config/picochip/libgccExtras/adddi3.asm", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fadddi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fadddi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fadddi3.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,199 @@\n+// picoChip ASM file\n+//\n+//   Support for 64-bit addition.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Hariharan Sandanagobalane (hariharan@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\n+.section .text\n+\n+.align 8\t\t\n+.global __adddi3\n+__adddi3:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &__adddi3 = 12 bytes\n+\n+        // The first operand of add is completely in registers r[2-5]\n+        // The second operand of sub is in stack FP(0-3)\n+        // and result need to be written pointed to by the register r0.\n+        // All we need to do is to load the appropriate values, add them\n+        // appropriately (with add or addc ) and then store the values back.\n+\n+\tldw (FP)0, r1\n+\tstl r[7:6], (FP)-1\n+\tadd.0 r2, r1, r6\n+\tldw (FP)1, r1\n+\taddc.0 r3, r1, r7\n+\tldl (FP)1, r[3:2]\n+\tstl r[7:6], (r0)0\n+\taddc.0 r4, r2, r6\n+\taddc.0 r5, r3, r7\n+\tstl r[7:6], (r0)1\n+\tjr (r12)\n+=->\tldl (FP)-1, r[7:6]\n+\n+_picoMark_FUNCTION_END=\n+\n+// picoChip Function Epilogue : __adddi3\n+\t\n+\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0xe\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#61# 16#64# 16#64# 16#63# 16#69# 16#33# 16#0# // Function name `_adddi3'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile"}, {"sha": "413ae50939825657023ab5da49dc1c7aa8213f89", "filename": "config/picochip/libgccExtras/ashlsi3.asm", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashlsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashlsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fashlsi3.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,197 @@\n+// picoChip ASM file\n+// picoChip ASM file\n+//\n+//   Support for 32-bit arithmetic shift left.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Hariharan Sandanagobalane (hariharan@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+.section .text\n+\n+.global ___ashlsi3\n+___ashlsi3:\n+_picoMark_FUNCTION_BEGIN=\n+// picoChip Function Prologue : &___ashlsi3 = 0 bytes\n+\n+\t// if (R2 > 15) goto _L2\n+\tSUB.0 15,R2,r15\n+\tJMPLT _L2\n+=->\tSUB.0 16,R2,R5   // R5 := R5 - R4 (HI)\n+\n+\tLSL.0 R1,R2,R1    // R3 := R1 << R2\n+\tLSL.0 R0,R2,R4    // R2 := R0 << R2\n+\n+\tLSR.0 R0,R5,R5 // R5 := R12 >> R5 NEED TO CHECK - HARI\n+\tOR.0 R5,R1,R5 // R3 := R5 IOR R0 (HI)\n+\tSUB.0 R2,0,r15  \n+\tCOPYNE R5,R1\n+\tJR (R12)\t// Return to caller \n+=->\tCOPY.0 R4,R0\n+\n+_L2:\n+\tLSL.0 R0,R2,R1  // R3 := R0 << R2\n+\tJR (R12)\t// Return to caller \n+=->\tCOPY.0 0,R0\t// R2 := 0 (short constant)\n+\n+_picoMark_FUNCTION_END=\n+\n+// picoChip Function Epilogue : __ashlsi3\n+\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#61# 16#73# 16#68# 16#6c# 16#73# 16#69# 16#33# 16#0# // Function name `_ashlsi3'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile"}, {"sha": "7bab0ef4789435603200051ba82e6d10f835040b", "filename": "config/picochip/libgccExtras/ashlsi3.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashlsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashlsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fashlsi3.c?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,87 @@\n+/*\n+\n+picoChip GCC support for 32-bit shift left.\n+\n+Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+Contributed by picoChip Designs Ltd.\n+Maintained by Daniel Towner (daniel.towner@picochip.com)\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA. */\n+\n+#ifndef PICOCHIP\n+#error \"Intended for compilation for PICOCHIP only.\"\n+#endif\n+\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+\n+typedef struct USIstruct {\n+  UHItype low, high;\n+} USIstruct;\n+\n+typedef union USIunion {\n+  USItype l;\n+  USIstruct s;\n+} USIunion;\n+\n+USItype __ashlsi3(USIunion value, HItype count) {\n+  USIunion result;\n+  int temp;\n+\n+  /* Ignore a zero count until we get into the (count < 16)\n+     clause. This is slightly slower when shifting by zero, but faster\n+     and smaller in all other cases (due to the better scheduling\n+     opportunities available by putting the test near computational\n+     instructions. */\n+  /* if (count == 0) return value.l; */\n+\n+  if (count < 16) {\n+    /* Shift low and high words by the count. */\n+    result.s.low = value.s.low << count;\n+    result.s.high = value.s.high << count;\n+     \n+    /* There is now a hole in the lower `count' bits of the high\n+       word. Shift the upper `count' bits of the low word into the\n+       high word. This is only required when the count is non-zero. */\n+    if (count != 0) {\n+      temp = 16 - count;\n+      temp = value.s.low >> temp;\n+      result.s.high |= temp;\n+    }\n+  \n+  } else {\n+    /* Shift the lower word of the source into the upper word of the\n+       result, and zero the result's lower word. */\n+    count -= 16;\n+    result.s.high = value.s.low << count;\n+    result.s.low = 0;\n+\n+  }\n+\n+  return result.l;\n+\n+}\n+"}, {"sha": "da540d7f86bbef3484b4fbb85dcf476478614cfe", "filename": "config/picochip/libgccExtras/ashrsi3.asm", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashrsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashrsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fashrsi3.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,207 @@\n+// picoChip ASM file\n+//\n+//   Support for 32-bit arithmetic shift right.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Hariharan Sandanagobalane (hariharan@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\n+.section .text\n+\n+.global ___ashrsi3\n+___ashrsi3:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &___ashrsi3 = 0 bytes\n+\n+\t// if (R2 > 15) goto _L2\n+\tSUB.0 15,R2,r15\n+\tJMPLT _L2\n+=->\tCOPY.0 R1,R3\n+\n+\tLSR.0 R1,R2,R1 // R1 := R1 >> R2\n+\t// if (R2 == 0) goto _L4\n+\tSUB.0 R2,0,r15\n+\tJMPEQ _L4\n+=->\tLSR.0 R0,R2,R0 // R2 := R0 >> R2\n+\n+\tSUB.0 16,R2,R4 // R4 := R4 - R2 (HI)\n+\tASR.0 R3,15,R5\t// R5 = R1 >>{arith} 15\n+\tLSL.0 R5,R4,R5 // R5 := R5 << R4\n+\tLSL.0 R3,R4,R4 // R4 := R1 << R4\n+\tOR.0 R5,R1,R1 // R3 := R5 IOR R3 (HI)\n+\tBRA _L4\n+\t=->\tOR.0 R4,R0,R0 // R2 := R4 IOR R0 (HI)\n+_L2:\n+\tASR.0 R1,15,R1\t// R4 = R1 >>{arith} 15\n+\tSUB.0 16,R2,R5  // R5 := R5 - R2 (HI)\n+\tLSR.0 R3,R2,R0 // R2 := R1 >> R2\n+\tLSL.0 R1,R5,R5 // R5 := R4 << R5\n+\tOR.0 R5,R0,R5 // R2 := R5 IOR R2 (HI)\n+\tSUB.0 R2,16,r15  // R5 := R5 - R2 (HI)\n+\tCOPYNE R5,R0\n+_L4:\n+\tJR (R12)\t// Return to caller \n+\n+_picoMark_FUNCTION_END=\n+\n+// picoChip Function Epilogue : __ashrsi3\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#61# 16#73# 16#68# 16#72# 16#73# 16#69# 16#33# 16#0# // Function name `_ashrsi3'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "fee3342112b9746026f8a179d61991c448ea5939", "filename": "config/picochip/libgccExtras/ashrsi3.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashrsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fashrsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fashrsi3.c?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,118 @@\n+/*\n+\n+picoChip GCC support for 32-bit arithmetic shift right.\n+\n+Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+Contributed by picoChip Designs Ltd.\n+Maintained by Daniel Towner (daniel.towner@picochip.com)\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA. */\n+\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+\n+typedef struct USIstruct {\n+  UHItype low, high;\n+} USIstruct;\n+\n+typedef union USIunion {\n+  USItype l;\n+  USIstruct s;\n+} USIunion;\n+\n+USItype __ashrsi3(USIunion value, HItype count) {\n+  USIunion result;\n+  int temp;\n+  int wordOfSignBits;\n+\n+  /* Ignore a zero count until we get into the (count < 16)\n+     clause. This is slightly slower when shifting by zero, but faster\n+     and smaller in all other cases (due to the better scheduling\n+     opportunities available by putting the test near computational\n+     instructions. */\n+  /* if (count == 0) return value.l; */\n+  \n+  if (count < 16) {\n+    /* Shift low and high words by the count. The high word must use\n+       an arithmetic shift. There is no arithmetic shift-right by\n+       variable, so synthesise it. */\n+    int signWord;\n+    int reverseCount;\n+\n+    /* Shift low and high parts by the count. The upper word now has\n+       invalid signed bits. */\n+    result.s.low = value.s.low >> count;\n+    result.s.high = value.s.high >> count;\n+\n+    if (count != 0) {\n+\n+      reverseCount = 16 - count;\n+  \n+      /* Given a word of sign bits, shift back left to create the\n+\t destination sign bits. */\n+      wordOfSignBits = __builtin_asri(value.s.high, 15);\n+      signWord = wordOfSignBits << reverseCount;\n+      result.s.high |= signWord;\n+     \n+      /* There is now a hole in the upper `count' bits of the low\n+\t word. Shift the lower `count' bits of the upper word into the\n+\t low word. */\n+      temp = value.s.high << reverseCount;\n+      result.s.low |= temp;\n+    }\n+\n+  } else {\n+    int signWord;\n+\n+    /* Shift is greater than one word, so top word will always be set\n+       to sign bits, and bottom word will be shifted from top word. */\n+    result.s.low = value.s.high >> count;\n+    result.s.high = __builtin_asri(value.s.high, 15);\n+\n+    if (count != 16) {\n+\n+      /* Shift the upper word of the source into the lower word of the\n+\t result. Arithmetically shift the upper word as well, to retain\n+\t the sign. This shift must be synthesised, as no such shift\n+\t exists in the instruction set. */\n+      int signWord;\n+ \n+\n+      /* Given a complete word of sign-bits, shift this back left to\n+\t create the destination sign bits. */\n+      signWord = result.s.high << (16 - count);\n+      //      signWord = wordOfSignBits << (16 - count);\n+\n+      /* Insert the sign bits to the result's low word. */\n+      result.s.low |= signWord;\n+\n+    }\n+\n+  }\n+\n+  return result.l;\n+\n+}"}, {"sha": "c4a0923dede9501381c2b7e44da2d48a39240772", "filename": "config/picochip/libgccExtras/clzsi2.asm", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fclzsi2.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fclzsi2.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fclzsi2.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,166 @@\n+// picoChip ASM file\n+//.file \"clzsi2.asm\"\n+\n+.section .text\n+\n+.global __clzsi2\n+__clzsi2:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &__clzsi2 = 0 bytes\n+\n+\t// What value should be operated on? If the top word is empty\n+\t// then count the bits in the bottom word, and add 16. If the\n+\t// top word is not empty, then count the bits in the top word.\n+\n+\t// R4 stores the constant 0\n+\n+\tsub.0 R1,0,r15 \\ copy.1 16,r2\n+\tcopyeq r0,r1\n+\tcopyne 0,r2\n+\n+\t// R1 now stores value to count, and R2 stores current bit offset.\n+\tsbc r1,r0\n+\tasr.0 r1,15,r15 \\ add.1 r0,1,r0\n+\tjr (lr) \\ copyne 0,r0\n+=->\tadd.0 r0,r2,r0\n+\n+_picoMark_FUNCTION_END=\n+\n+// picoChip Function Epilogue : __clzsi2\n+\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5F# 16#63# 16#6C# 16#7A# 16#73# 16#69# 16#32# 16#0# // Function name `_clzsi2'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "36a65d096df617df367f7b2f4aacfe6e2dfd365b", "filename": "config/picochip/libgccExtras/cmpsi2.asm", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fcmpsi2.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fcmpsi2.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fcmpsi2.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,217 @@\n+// picoChip ASM file\n+//.file \"ucmpsi2.c\"\n+//\n+//   Support for 32-bit signed compare.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+//\n+// Compiled from the following, and then hand optimised.\n+//\n+// int __cmpsi2 (USItype x, USItype y)\n+// {\n+//\n+//   SIunion lx; lx.l = x;\n+//   SIunion ly; ly.l = y;\n+//\n+//   if (lx.s.high < ly.s.high)\n+//     return 0;\n+//   else if (lx.s.high > ly.s.high)\n+//     return 2;\n+//   if (lx.s.low < ly.s.low)\n+//     return 0;\n+//   else if (lx.s.low > ly.s.low)\n+//     return 2;\n+//   return 1;\n+// }\n+\t\n+.section .text\n+\n+.align 8\n+.global ___cmpsi2\n+___cmpsi2:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &___cmpsi2 = 0 bytes\n+\n+\tSUB.0 R1,R3,r15\n+\n+        BLT _L1\n+=->     SUB.0 R3,R1,r15 \\ COPY.1 0,R5\n+\n+        BLT _L1\n+=->     SUB.0 R0,R2,r15 \\ COPY.1 2,R5\n+\n+        BLO _L1\n+=->     SUB.0 R2,R0,r15 \\ COPY.1 0,R5\n+\n+        BLO _L1\n+=->\tCOPY.0 2,R5\n+\t\n+        COPY.0 1,R5\n+_L1:\n+\tJR (R12)\n+=->     COPY.0 R5,R0\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __cmpsi2\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#5f# 16#63# 16#6d# 16#70# 16#73# 16#69# 16#32# 16#0# // Function name `__cmpsi2'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "da59e09a5a3d0261b804e307e4a81cb41322aad3", "filename": "config/picochip/libgccExtras/divmod15.asm", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fdivmod15.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fdivmod15.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fdivmod15.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,268 @@\n+// picoChip ASM file\n+//\n+//   Support for 16-bit unsigned division/modulus.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\t\n+.section .text\n+\n+.global __divmod15\n+__divmod15:\n+_picoMark_FUNCTION_BEGIN=\n+\t\n+// picoChip Function Prologue : &__divmod15 = 0 bytes\n+\n+__divmod15:\t\n+\n+\t// The picoChip instruction set has a divstep instruction which\n+\t// is used to perform one iteration of a binary division algorithm.\n+\t// The instruction allows 16-bit signed division to be implemented.\n+\t// It does not directly allow 16-bit unsigned division to be\n+\t// implemented. Thus, this function pulls out the common division\n+\t// iteration for 15-bits unsigned, and then special wrappers\n+\t// provide the logic to change this into a 16-bit signed or\n+\t// unsigned division, as appropriate. This allows the two\n+\t// versions of division to share a common implementation, reducing\n+\t// code size when the two are used together. It also reduces\n+\t// the maintenance overhead.\n+\n+\t// Input:\n+\t//\tr0 - dividend\n+\t//\tr1 - divisor\n+\t// Output:\n+\t//\tr0 - quotient\n+\t//\tr1 - remainder\n+\t// R5 is unused\n+\t\n+\t// Check for special cases. The emphasis is on detecting these as\n+\t// quickly as possible, so that the main division can be started. If \n+\t// the user requests division by one, division by self, and so on\n+\t// then they will just have to accept that this won't be particularly\n+\t// quick (relatively), whereas a real division (e.g., dividing a \n+\t// large value by a small value) will run as fast as possible\n+\t// (i.e., special case detection should not slow down the common case)\n+\t//\n+\t// Special cases to consider:\n+\t//\n+\t//\tDivision by zero.\n+\t//\tDivision of zero.\n+\t//\tInputs are equal\n+\t//\tDivisor is bigger than dividend\n+\t//\tDivision by power of two (can be shifted instead).\n+\t//\tDivision by 1 (special case of power of two division)\n+\t//\n+\t// Division/modulus by zero is undefined (ISO C:6.5.5), so\n+\t// don't bother handling this special case.\n+\t//\n+\t// The special cases of division by a power of 2 are ignored, since \n+\t// they cause the general case to slow down. Omitting these\n+\t// special cases also reduces code size considerably.\n+\n+\t// Handle divisor >= dividend separately. Note that this also handles \n+\t// the case where the dividend is zero.\tNote that the flags must be\n+\t// preserved, since they are also used at the branch destination.\n+\tsub.0 r1,r0,r15\n+\tsbc r0,r2 \\ bge divisorGeDividend\n+=->\tsbc r1,r4\n+\t\n+\t// Compute the shift count. The amount by which the divisor\n+\t// must be shifted left to be aligned with the dividend.\t\n+\tsub.0 r4,r2,r3\n+\t\t\n+\t// Align the divisor to the dividend. Execute a divstep (since at \n+\t// least one will always be executed). Skip the remaining loop\n+\t// if the shift count is zero.\n+\tlsl.0 r1,r3,r1 \\ beq skipLoop\n+=->\tdivstep r0,r1 \\ add.1 r3,1,r2\n+\n+\t// Execute the divstep loop until temp is 0. This assumes that the\n+\t// loop count is at least one.\n+\tsub.0 r3,1,r4\n+divLoop:\t\n+\tdivstep r0,r1 \\ bne divLoop\n+=->\tsub.0 r4,1,r4\n+\n+skipLoop:\n+\t\t\t\t\n+\t// The top bits of the result are the remainder. The bottom\n+\t// bits are the quotient.\n+\tlsr.0 r0,r2,r1 \\ sub.1 16,r2,r4\n+\tjr (lr ) \\ lsl.0 r0,r4,r0\n+=->\tlsr.0 r0,r4,r0\n+\n+// Special case.\n+\n+divisorGeDividend:\t\n+\t// The divisor is greater than or equal to the dividend. The flags\n+\t// indicate which of these alternatives it is. The COPYNE can be used \n+\t// to set the result appropriately, without introducing any more\n+\t// branches.\n+\tcopy.0 r0,r1 \\ copy.1 0,r0\n+\tjr (lr) \\ copyeq r0,r1\n+=->\tcopyeq 1,r0\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __divmod15\n+\n+\t\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#64# 16#69# 16#76# 16#6d# 16#6f# 16#64# 16#31# 16#35# 16#0# // Function name `_divmod15'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "78a0673e5b5e9d19339506f42a3484fcf6f539f2", "filename": "config/picochip/libgccExtras/divmodhi4.asm", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fdivmodhi4.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fdivmodhi4.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fdivmodhi4.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,251 @@\n+// picoChip ASM file\n+//\n+//   Support for 16-bit signed division/modulus.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\n+.section .text\n+\n+.align 8\t\t\n+.global __divmodhi4\n+__divmodhi4:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &__divmodhi4 = 4 bytes\n+\n+\t// 16-bit signed division. Most of the special cases are dealt\n+\t// with by the 15-bit signed division library (e.g., division by\n+\t// zero, division by 1, and so on). This wrapper simply inverts\t\n+\t// any negative inputs, calls the 15-bit library, and flips any\n+\t// results as necessary.  The\n+\t// only special cases to be handled here are where either the \n+\t// divisor or the dividend are the maximum negative values.\n+\n+\t// Encode r5 with a bit pattern which indicates whether the\n+\t// outputs of the division must be negated. The MSB will be set\n+\t// to the sign of the dividend (which controls the remainder's\n+\t// sign), while the LSB will store the XOR of the two signs,\n+\t// which indicates the quotient's sign. R5 is not modified by the\n+\t// 15-bit divmod routine.\n+\tsub.0 r1,16#8000#,r15 \\ asr.1 r0,15,r4\n+\tbeq divisorIsLargestNegative \\ lsr.0 r1,15,r3\n+=->\tsub.0 r0,16#8000#,r15 \\ xor.1 r3,r4,r5\n+\n+\t// Handle least negative dividend with a special case. Note that the\n+\t// absolute value of the divisor is also computed here.\n+\tadd.0 [asr r1,15],r1,r3\t\\ beq dividendIsLargestNegative\n+=->\txor.0 [asr r1,15],r3,r1 \\ stw lr,(fp)-1\t\n+\t\n+\t// Compute the absolute value of the dividend, and call the main\n+\t// divide routine.\n+\tadd.0 r4,r0,r2 \\ jl (&__divmod15)  // fn_call &__divmod15\n+=->\txor.0 r4,r2,r0\n+\n+handleNegatedResults:\t\n+\t// Speculatively store the negation of the results.\n+\tsub.0 0,r0,r2 \\ sub.1 0,r1,r3\n+\n+\t// Does the quotient need negating? The LSB indicates this.\n+\tand.0 r5,1,r15 \\ ldw (fp)-1,lr\n+\tcopyne r2,r0\n+\t\t\n+\tasr.0 r5,15,r15 \\ jr (lr)\n+=->\tcopyne r3,r1\n+\t\n+dividendIsLargestNegative:\n+\n+\t// Divide the constant -32768. Use the Hacker's Delight\n+\t// algorithm (i.e., ((dividend / 2) / divisor) * 2) gives\n+\t// approximate answer). This code is a special case, so no\n+\t// great effort is made to make it fast, only to make it\n+\t// small.\n+\n+\tlsr.0 r0,1,r0 \\ jl (&__divmod15)  // fn_call &__divmod15\n+=->\tstw r1,(fp)-2\n+\n+\t// Load the original divisor, and compute the new quotient and\n+\t// remainder.\t\n+\tlsl.0 r0,1,r0 \\ ldw (fp)-2,r3\n+\tlsl.0 r1,1,r1 // Fill stall slot\n+\n+\t// The error in the quotient is 0 or 1. The error can be determined\n+\t// by comparing the remainder to the original divisor. If the\n+\t// remainder is bigger, then an error of 1 has been introduced,\n+\t// which must be fixed.\n+\tsub.0 r1,r3,r15\n+\tblo noCompensationForError\n+=->\tnop\t\n+\tadd.0 r0,1,r0 \\ sub.1 r1,r3,r1\n+noCompensationForError:\n+\tbra handleNegatedResults\n+=->\tnop\n+\n+divisorIsLargestNegative:\t\n+\t// The flags indicate whether the dividend is also the maximum negative\n+\tcopy.0 r0,r1 \\ copy.1 0,r0\n+\tcopyeq r0,r1 \\ jr (lr)\n+=->\tcopyeq 1,r0\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __divmodhi4\n+\t\n+\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x4\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#64# 16#69# 16#76# 16#6d# 16#6f# 16#64# 16#68# 16#69# 16#34# 16#0# // Function name `_divmodhi4'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+.section .endFile"}, {"sha": "5cc59bdfc691465decf60a2222c3a6b1e685e354", "filename": "config/picochip/libgccExtras/divmodsi4.asm", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fdivmodsi4.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fdivmodsi4.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fdivmodsi4.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,239 @@\n+// picoChip ASM file\n+//\n+//   Support for 32-bit signed division/modulus.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\n+//\t\n+.section .text\n+\n+.align 8\n+.global __divmodsi4\n+__divmodsi4:\n+_picoMark_FUNCTION_BEGIN=\n+// picoChip Function Prologue : &__divmodsi4 = 8 bytes\n+\n+\t// Note: optimising for size is preferred over optimising for speed.\n+\n+\t// Note: the frame is setup throughout the following instructions,\n+\t// and is complete at the point the udivmodsi4 function is called. \t\n+\n+\t// Note that R9 is encoded with a pattern which indicates\n+\t// whether the remainder and quotient should be negated on\n+\t// completion. The MSB is set to the sign of the dividend\n+\t// (i.e., the sign of the remainder), while the LSB encodes\n+\t// the XOR of the two input's signs (i.e., the sign of the\n+\t// quotient.\n+\t\n+\t// If dividend is negative, invert the dividend and flag.\n+\tASR.0 r1,15,r4\n+\tBEQ dividendNotNegative\n+=->\tSTL R[9:8],(FP)-2\n+\n+\t// Dividend is negative - negate dividend.\n+        SUB.0 0,R0,R0\n+        SUBB.0 0,R1,R1\n+\n+dividendNotNegative:\n+\t\t\t\n+\t// If divisor is negative, invert the divisor.\n+\tAND.0 [lsr r3,15],1,r5\n+\tSUB.0 R3,0, r15\n+\tBGE divisorNotNegative\n+=->\tXOR.0 r4,r5,r9\n+\n+\t// Divisor is negative - negate divisor.\n+        SUB.0 0,R2,R2\n+        SUBB.0 0,R3,R3\n+\n+divisorNotNegative:\n+\t\n+        STL R[13:12],(FP)-1 \\ JL (&__udivmodsi4)\n+=->\tSUB.0 FP,8,FP  // udivmodsi expects the frame to be valid still.\n+\t\n+\t// The LSB of R9 indicates whether the quotient should be negated.\n+\tAND.0 r9,1,r15\n+\tBEQ skipQuotientNegation\n+=->\tLDL (FP)1,R[13:12]\t// Convenient point to restore link/fp\n+\t\n+        SUB.0 0,R4,R4\n+        SUBB.0 0,R5,R5\t\n+\n+skipQuotientNegation:\t\t\n+\n+\t// The MSB of R9 indicates whether the remainder should be negated.\n+\tASR.0 R9,15,r15\n+\tBEQ epilogue\n+\n+        SUB.0 0,R6,R6\n+        SUBB.0 0,R7,R7\n+\n+epilogue:\t\n+\n+\tJR (R12)\n+=->\tLDL (FP)-2,R[9:8]\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __divmodsi4\n+\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x8\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#64# 16#69# 16#76# 16#6d# 16#6f# 16#64# 16#73# 16#69# 16#34# 16#0# // Function name `_divmodsi4'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "e4b78f1e1f1d076fa868296b971f1742e0e5571b", "filename": "config/picochip/libgccExtras/fake_libgcc.asm", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Ffake_libgcc.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Ffake_libgcc.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Ffake_libgcc.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,6 @@\n+// picoChip ASM file\n+// Fake libgcc asm file. This contains nothing, but is used to prevent gcc\n+// getting upset about the lack of a libgcc.S file when LIB1ASMFUNCS is defined\n+// to switch off the compilation of parts of libgcc.\n+\n+"}, {"sha": "d8e12b438b0715da6eb5173b9ca68d55f0d92f44", "filename": "config/picochip/libgccExtras/longjmp.asm", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Flongjmp.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Flongjmp.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Flongjmp.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,187 @@\n+// picoChip ASM file\n+//\n+//   Support for 32-bit arithmetic shift right.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Hariharan Sandanagobalane (hariharan@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\n+.section .text\n+\n+.global _longjmp\n+_longjmp:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &_longjmp = 0 bytes\n+\n+        LDL (R0)0, R[3:2]\n+        LDL (R0)1, R[5:4]\n+        LDL (R0)2, R[7:6]\n+        LDL (R0)3, R[9:8]\n+        LDL (R0)4, R[11:10]\n+        LDL (R0)5, R[13:12]\n+        LDW (R0)12, R14\n+        LDW (R0)13, R1\n+        JR (R12)\n+=->\tCOPY.0 1,R0\n+        \n+// picoChip Function Epilogue : longjmp\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#6c# 16#6f# 16#6e# 16#67# 16#6a# 16#6d# 16#70# 16#0# // Function name `longjmp'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "aada2936bc30a1a40160a7c249e3651642386801", "filename": "config/picochip/libgccExtras/lshrsi3.asm", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Flshrsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Flshrsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Flshrsi3.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,195 @@\n+// picoChip ASM file\n+//\n+//   Support for 32-bit logical shift right.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Hariharan Sandanagobalane (hariharan@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+.section .text\n+\n+.global ___lshrsi3\n+___lshrsi3:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &___lshrsi3 = 4 bytes\n+\n+\t// if (R2 > 15) goto _L2\n+\tSUB.0 15,R2,r15\n+\tJMPLT _L2\n+=->\tSUB.0 16,R2,R5 // R5 := R5 - R2 (HI)\n+\n+\tLSR.0 R0,R2,R0 // R4 := R0 >> R2\n+\tLSR.0 R1,R2,R3 // R3 := R1 >> R2\n+\t// if (R2 == 0) goto _L4\n+\tLSL.0 R1,R5,R5 // R5 := R1 << R5\n+\tOR.0 R5,R0,R4 // R2 := R5 IOR R2 (HI)\n+\tSUB.0 R2,0,r15\n+\tCOPYNE R4,R0\t\t// R0 := R2\n+\tJR (R12)\t// Return to caller \n+=->\tCOPY.0 R3,R1\t\t// R1 := R3\n+\n+_L2:\n+\tLSR.0 R1,R2,R0  // R2 := R1 >> R2\n+\tJR (R12)\t// Return to caller \n+=->\tCOPY.0 0,R1\t// R3 := 0 (short constant)\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __lshrsi3\n+\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x4\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#5f# 16#6c# 16#73# 16#68# 16#72# 16#72# 16#73# 16#69# 16#33# 16#0# // Function name `__lshrsi3'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+.section .endFile"}, {"sha": "e9b85242cbbc83afd666f202aff113edf1cc676e", "filename": "config/picochip/libgccExtras/lshrsi3.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Flshrsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Flshrsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Flshrsi3.c?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,81 @@\n+/*\n+\n+picoChip GCC support for 32-bit logical shift right.\n+\n+Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+Contributed by picoChip Designs Ltd.\n+Maintained by Daniel Towner (daniel.towner@picochip.com)\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA. */\n+\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+\n+typedef struct USIstruct {\n+  UHItype low, high;\n+} USIstruct;\n+\n+typedef union USIunion {\n+  USItype l;\n+  USIstruct s;\n+} USIunion;\n+\n+USItype __lshrsi3(USIunion value, HItype count) {\n+  USIunion result;\n+  int temp;\n+\n+  /* Ignore a zero count until we get into the (count < 16)\n+     clause. This is slightly slower when shifting by zero, but faster\n+     and smaller in all other cases (due to the better scheduling\n+     opportunities available by putting the test near computational\n+     instructions. */\n+\n+  if (count < 16) {\n+    /* Shift low and high words by the count. */\n+    result.s.low = value.s.low >> count;\n+    result.s.high = value.s.high >> count;\n+     \n+    /* There is now a hole in the upper `count' bits of the low\n+       word. Shift the lower `count' bits of the upper word into the\n+       low word. This only works when count isn't zero. */\n+    if (count != 0) {\n+      temp = value.s.high << (16 - count);\n+      result.s.low |= temp;\n+    }\n+\n+  } else {\n+    /* Shift the upper word of the source into the lower word of the\n+       result, and zero the result's upper word. Note that we actually\n+       ned to shift by (count - 16), but as we are only using the\n+       bottom 4 bits, this is equivalent to shifting by count. */\n+    result.s.low = value.s.high >> count;\n+    result.s.high = 0;\n+\n+  }\n+\n+  return result.l;\n+\n+}"}, {"sha": "1ef87bf99191d7a05bbec665c6815a90f7593f7b", "filename": "config/picochip/libgccExtras/parityhi2.asm", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fparityhi2.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fparityhi2.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fparityhi2.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,184 @@\n+// picoChip ASM file\n+//.file \"ucmpsi2.c\"\n+//\n+//   Support for parity checks.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\t\n+.section .text\n+\n+.align 8\n+.global ___parityhi2\n+___parityhi2:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &___parityhi2 = 0 bytes\n+\tXOR.0 [LSR R0,8],R0,R0\n+        XOR.0 [LSR R0,4],R0,R0\n+        XOR.0 [LSR R0,2],R0,R0\n+        JR (R12) \\ XOR.0 [LSR R0,1],R0,R0\n+=->\tAND.0 R0,1,R0\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __parityhi2\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#5f# 16#70# 16#61# 16#72# 16#69# 16#74# 16#79# 16#68# 16#69# 16#32# 16#0# // Function name `__parityhi2'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "79f2f4c48d264ecb87d60e343264450068ebbc74", "filename": "config/picochip/libgccExtras/popcounthi2.asm", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fpopcounthi2.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fpopcounthi2.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fpopcounthi2.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,206 @@\n+// picoChip ASM file\n+//.file \"popcounthi2.S\"\n+//\n+//   Support for 16-bit population count.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\t\n+.section .text\n+\n+// The following code (taken from a newsgroup posting) was compiled, and then\n+// hand assembled (a similar version is given in the Hacker's Delight\n+// book, chapter 5).\n+//\n+// int \n+// popcount (int value)\n+// {\n+//    value = ((value & 0xAAAA) >> 1) + (value & 0x5555);\n+//    value = ((value & 0xCCCC) >> 2) + (value & 0x3333);\n+//    value = ((value & 0xF0F0) >> 4) + (value & 0x0F0F);\n+//    return ((value & 0xFF00) >> 8) + (value & 0x00FF);\n+// }\t\n+//\n+// This assembly function is approx. 20x faster than a naive loop\n+// implementation of the population count, but about 30% bigger\n+// (45 bytes v. 34 bytes).\n+\n+.align 8\n+.global ___popcounthi2\n+___popcounthi2:\n+\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &___popcounthi2 = 0 bytes\n+\n+        AND.0 [LSR R0,1],21845,R0 \\ AND.1 R0,21845,R5\n+        ADD.0 R0,R5,R0\n+        AND.0 [LSR R0,2],13107,R0 \\ AND.1 R0,13107,R5\n+        ADD.0 R0,R5,R0 \\ COPY.1 1807,R2\n+        AND.0 [LSR R0,4],R2,R0 \\ AND.1 R0,3855,R5\n+        ADD.0 R0,R5,R0\n+        JR (R12) \\ AND.0 R0, 255, R5\n+=->\tADD.0 [LSR R0,8],R5,R0\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : ___popcounthi2\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#5f# 16#70# 16#6f# 16#70# 16#63# 16#6f# 16#75# 16#6e# 16#74# 16#68# 16#69# 16#32# 16#0# // Function name `__popcounthi2'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "77f89d7913ad8f3ff0c4a71ce071081c1bd9e864", "filename": "config/picochip/libgccExtras/setjmp.asm", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fsetjmp.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fsetjmp.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fsetjmp.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,187 @@\n+// picoChip ASM file\n+//\n+//   Support for 32-bit arithmetic shift right.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Hariharan Sandanagobalane (hariharan@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\n+.section .text\n+\n+.global _setjmp\n+_setjmp:\n+_picoMark_FUNCTION_BEGIN=\n+\n+// picoChip Function Prologue : &_setjmp = 0 bytes\n+\n+        STL R[3:2],(R0)0\n+        STL R[5:4],(R0)1\n+        STL R[7:6],(R0)2\n+        STL R[9:8],(R0)3\n+        STL R[11:10],(R0)4\n+        STL R[13:12],(R0)5\n+        STW R14,(R0)12\n+        STW R1,(R0)13\n+        JR (R12)\n+=->\tCOPY.0 0,R0\n+        \n+// picoChip Function Epilogue : setjmp\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#73# 16#65# 16#74# 16#6a# 16#6d# 16#70# 16#0# // Function name `setjmp'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "4175d056419865c554fcfa3175390cabb317d189", "filename": "config/picochip/libgccExtras/subdi3.asm", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fsubdi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fsubdi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fsubdi3.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,196 @@\n+// picoChip ASM file\n+//\n+//   Support for 64-bit subtraction.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Hariharan Sandanagobalane (hariharan@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA..global __divmodhi4\n+\n+.section .text\n+\n+.align 8\t\t\n+.global __subdi3\n+__subdi3:\n+\n+_picoMark_FUNCTION_BEGIN=\n+// picoChip Function Prologue : &__subdi3 = 4 bytes\n+\n+\t// The first operand of sub is completely in registers r[2-5]\n+        // The second operand of sub is in stack FP(0-3)\n+        // and result need to be written pointed to by the register r0.\n+\t// All we need to do is to load the appropriate values, sub them \n+        // appropriately (with sub or subb) and then store the values back.\n+\tldw (FP)0, r1\n+\tstl r[7:6], (FP)-1\n+\tsub.0 r2, r1, r6\n+\tldw (FP)1, r1\n+\tsubb.0 r3, r1, r7\n+\tldl (FP)1, r[3:2]\n+\tstl r[7:6], (r0)0\n+\tsubb.0 r4, r2, r6\n+\tsubb.0 r5, r3, r7\n+\tstl r[7:6], (r0)1\n+\tjr (r12)\n+=->\tldl (FP)2, r[7:6]\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __subdi3\n+\t\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x4\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#73# 16#75# 16#62# 16#64# 16#69# 16#33# 16#0# // Function name `_subdi3'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+.section .endFile\n+"}, {"sha": "7a623624e2f734333e02d8e7b20e1d909573abfe", "filename": "config/picochip/libgccExtras/ucmpsi2.asm", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fucmpsi2.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fucmpsi2.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fucmpsi2.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,214 @@\n+// picoChip ASM file\n+//.file \"ucmpsi2.c\"\n+//\t\n+//   Support for 32-bit unsigned compare.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\t\n+//\n+// Compiled from the following, and then hand optimised.\n+//\n+// int __ucmpsi2 (USItype x, USItype y)\n+// {\n+//\n+//   USIunion lx; lx.l = x;\n+//   USIunion ly; ly.l = y;\n+//\n+//   if (lx.s.high < ly.s.high)\n+//     return 0;\n+//   else if (lx.s.high > ly.s.high)\n+//     return 2;\n+//   if (lx.s.low < ly.s.low)\n+//     return 0;\n+//   else if (lx.s.low > ly.s.low)\n+//     return 2;\n+//   return 1;\n+// }\n+\t\n+.section .text\n+\n+.align 8\n+.global ___ucmpsi2\n+___ucmpsi2:\n+_picoMark_FUNCTION_BEGIN=\n+// picoChip Function Prologue : &___ucmpsi2 = 0 bytes\n+        SUB.0 R1,R3,r15\n+\n+        BLO _L1\n+=->     SUB.0 R3,R1,r15 \\ COPY.1 0,R5\n+\t\n+        BLO _L1\n+=->     SUB.0 R0,R2,r15 \\ COPY.1 2,R5\n+\t\n+        BLO _L1\n+=->     SUB.0 R2,R0,r15 \\ COPY.1 0,R5\n+\n+        BLO _L1\n+=->\tCOPY.0 2,R5\n+\t\n+        COPY.0 1,R5\n+_L1:\n+\tJR (R12)\n+=->\tCOPY.0 R5,R0            // R0 := R5\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : __ucmpsi2\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#5f# 16#75# 16#63# 16#6d# 16#70# 16#73# 16#69# 16#32# 16#0# // Function name `__ucmpsi2'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "9eb6224a63021d2f3cdb162d8e4184d0f8422be7", "filename": "config/picochip/libgccExtras/udivmodhi4.asm", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fudivmodhi4.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fudivmodhi4.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fudivmodhi4.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,243 @@\n+// picoChip ASM file\n+//\n+//   Support for 16-bit unsigned division/modulus.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\t\n+.section .text\n+\n+.global __udivmodhi4\n+__udivmodhi4:\n+_picoMark_FUNCTION_BEGIN=\n+\t\n+// picoChip Function Prologue : &__udivmodhi4 = 6 bytes\n+\n+\t// 16-bit unsigned division. The divstep function is only capable of\n+\t// handling 15-bit division (plus a sign to give 16-bits). It is not \n+\t// capable of handling unsigned division directly. Instead, take \n+\t// advantage of the special property that \n+\t// ((divisor / 2) / dividend) * 2 will be almost good enough. The \n+\t// error in the result is only 0 or 1, and this can be easily\n+\t// tested and corrected. A full description of the algorithm can\n+\t// be found in `Hacker's Delight', by Henry Warren, page 146.\n+\n+\t// Input:\n+\t//\tr0 - dividend\n+\t//\tr1 - divisor\n+\t// Output:\n+\t//\tr0 - quotient\n+\t//\tr1 - remainder\n+\t\n+\t// Note that the lr, and original inputs are speculatively saved. They\n+\t// will only be restored if the 15-bit division function is called.\n+\t\n+\tsub.0 r1,0,r15 \\ stl r[0:1],(fp)-1\n+\tbge divisorIs15bit\n+=->\tsub.0 r0,r1,r2 \\ stw lr,(fp)-3\n+\t\n+\t// The divisor is >= 2^15.\n+\tbhs quotientIs1\n+\n+\t// The dividend < divisor. The quotient is thus 0, and the\n+\t// remainder is the dividend.\n+\tcopy.0 r0,r1 \\ jr (lr)\n+=->\tcopy.0 0,r0\n+\t\n+quotientIs1:\t\n+\t// The dividend >= divisor. The quotient is thus 1, and the\n+\t// remainder can be computed directly by subtraction (i.e., the\n+\t// result of the comparison already performed to branch here).\n+\tjr (lr) \\ copy.0 r2,r1\n+=->\tcopy.0 1,r0\n+\t\n+divisorIs15bit:\n+\t// The divisor is < 2^15.\n+\n+\t// Divide the original dividend by 2, and call the 15-bit division.\n+\t// Note that the original dividend is stored in r5, which is\n+\t// known to be unused by the called function, so that\n+\t// a memory stall isn't introduced immediately after the\n+\t// function returns, to reload this value from memory.\n+\t\n+\tjl (&__divmod15) \\ copy.0 r0,r5  // fn_call &__divmod15\n+=->     lsr.0 r0,1,r0\n+\t\n+\t// Compute the new quotient and remainder by multiplying them by 2.\n+\t// The remainder will be 1 out, if the original dividend was odd.\n+\tand.0 r5,1,r5 \\ ldl (fp)-1,r[2:3]\n+\tadd.0 [lsl r1,1],r5,r1 \\ lsl.1 r0,1,r0\n+\t\n+\t// The error in the quotient is 0 or 1. The error can be determined\n+\t// by comparing the remainder to the original divisor. If the \n+\t// remainder is bigger, then an error of 1 has been introduced.\n+\tsub.0 r1,r3,r15 \\ ldw (fp)-3,lr\n+\tblo noCompensation\n+=->\tnop\t\n+\tadd.0 r0,1,r0 \\ sub.1 r1,r3,r1\n+noCompensation:\n+\tjr (lr)\n+\n+_picoMark_FUNCTION_END=\n+// picoChip Function Epilogue : udivmodhi4\n+\n+\t\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x6\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#75# 16#64# 16#69# 16#76# 16#6d# 16#6f# 16#64# 16#68# 16#69# 16#34# 16#0# // Function name `_udivmodhi4'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "b992206af6929490d5321b4d6cae585f91da5d12", "filename": "config/picochip/libgccExtras/udivmodsi4.asm", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fudivmodsi4.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2FlibgccExtras%2Fudivmodsi4.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2FlibgccExtras%2Fudivmodsi4.asm?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,323 @@\n+// picoChip ASM file\n+//\n+//   Support for 32-bit unsigned division/modulus.\n+//\n+//   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+//   Contributed by picoChip Designs Ltd.\n+//   Maintained by Daniel Towner (daniel.towner@picochip.com)\n+//\n+//   This file is free software; you can redistribute it and/or modify it\n+//   under the terms of the GNU General Public License as published by the\n+//   Free Software Foundation; either version 2, or (at your option) any\n+//   later version.\n+//\n+//   In addition to the permissions in the GNU General Public License, the\n+//   Free Software Foundation gives you unlimited permission to link the\n+//   compiled version of this file into combinations with other programs,\n+//   and to distribute those combinations without any restriction coming\n+//   from the use of this file.  (The General Public License restrictions\n+//   do apply in other respects; for example, they cover modification of\n+//   the file, and distribution when not linked into a combine\n+//   executable.)\n+//\n+//   This file is distributed in the hope that it will be useful, but\n+//   WITHOUT ANY WARRANTY; without even the implied warranty of\n+//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+//   General Public License for more details.\n+//\n+//   You should have received a copy of the GNU General Public License\n+//   along with this program; see the file COPYING.  If not, write to\n+//   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+//   Boston, MA 02110-1301, USA.\n+\t\n+.section .text\n+\n+.align 8\n+.global __udivmodsi4\n+__udivmodsi4:\n+_picoMark_FUNCTION_BEGIN=\n+// picoChip Function Prologue : &__udivmodsi4 = 24 bytes\n+\t\n+\t// Schedule the register saves alongside the special cases, so that\n+\t// if the special cases fail, the registers will have already\n+\t// been stored onto the stack.\n+\tSUB.0 R3,R1,r15 \\ STL R[13:12],(FP)-1\n+\tBHS skipCommonCase \\ STL R[9:8],(FP)-4\n+=->\tSUB.0 R2,1,r15 \\ STL R[11:10],(FP)-3\n+\t\n+_L2:\n+\t// Flags set above, and in _L2 caller.\n+\tBNE restOfCode\n+=->\tSUB.0 R3,0,r15\n+\tBNE restOfCode \n+=->\tCOPY.0 R0,R4 \\ COPY.1 R1,R5\n+\tJR (R12)\t// Return to caller\n+=->\tCOPY.0 0,R6 \\ COPY.1 0,R7\n+\t// Never reach here\n+\n+skipCommonCase:\n+\tSUB.0 R3,R1,r15\n+\tBNE _L3\t// (Reversed branch) \n+=->\tSUB.0 R2,R0,r15 // Must be set in delay slot, so ready by _L9\n+\n+_L9:\n+\tBLO _L2\t// (Reversed branch)\n+=->\tSUB.0 R2,1,r15\n+\t\n+_L3:\n+\tSUB.0 R2,R0,r15\n+\tBEQ _L10\t// (Reversed branch)\n+=->\tSUB.0 R1,R3,r15 // Set flags for branch at _L10 \n+\t\n+_L4:\n+\t// greater than\n+\tCOPY.0 0,R4 \\ COPY.1 0,R5 \\ JR (R12)\t// Return to caller\n+=->\tCOPY.0 R0,R6 \\ COPY.1 R1,R7\n+\t// Doesn't reach here.\n+\t\t\n+_L10:\n+\t// Flags set in _L10 call delay slot.\n+\tBNE _L4 \n+=->\tCOPY.0 1,R4 \\ COPY.1 0,R5\n+\tJR (R12)\t// Return to caller\n+=->\tCOPY.0 0,R6 \\ COPY.1 0,R7\n+\n+restOfCode:\t\n+\n+// Prologue\n+\t\n+\t// Register saves scheduled alongside special cases above.\n+\tADD.0 FP,-20,FP \\ STW R14,(FP)-4\n+\n+\t// The following can be scheduled together.\n+\t// dividend in R[9:8] (from R[1:0])\n+\t// divisor in R[7:6] (from R[3:2])\n+\t// R14 := clzsi2 (dividend)\t\n+\t// R0 := clzsi2 (divisor)\n+\tJL (&__clzsi2) \\ COPY.0 R0,R8 \\ COPY.1 R1,R9\n+=->\tCOPY.0 R2,R6 \\ COPY.1 R3,R7\n+\tCOPY.0 R0,R14 \\ JL (&__clzsi2)\n+=->\tCOPY.0 R6,R0 \\ COPY.1 R7,R1\n+\n+\t// R14 := R0 - R14\n+\tSUB.0 R0,R14,R14\n+\n+\tADD.0 R14,1,R0\t// R0 := R14 + 1 (HI)\n+\t\n+\t// R[11:10] = R[7,6] << R14\n+\tSUB.0 15,R14,r15\n+\tLSL.0 R6,R14,R11 \\ BLT setupDivstepLoop\n+=->\tSUB.0 0,R14,R4 \\ COPY.1 0,R10\n+\n+\t// Zero shift is a special case. Shifting by zero within a 16-bit\n+\t// source object is fine, but don't execute the OR of the right-shift\n+\t// into the final result.\n+\tLSL.0 R7,R14,R11 \\ BEQ setupDivstepLoop\n+=->\tLSL.0 R6,R14,R10\n+\t\n+\tLSR.0 R6,R4,R4\n+\tOR.0 R11,R4,R11\n+\t\n+setupDivstepLoop:\n+\n+\t// R[5:4] := R[9:8] (SI)\n+\tCOPY.0 R8,R4 \\ COPY.1 R9,R5\n+\tCOPY.0 0,R6 \\ COPY.1 R0,R8\n+\n+\t// Store original value of loopCount for use after the loop.\n+\t// The Subtraction is handled in the tail of the loop iteration\n+\t// after this point.\n+\tSUB.0 R4,R10,R0 \\ COPY.1 R8,R14\n+\t\n+\t// workingResult in R4,5,6\n+\t// temps in r0,1,2 and r7\n+\t// alignedDivisor in R10,11\n+\t// loopCount in r8\n+\t// r3, r9 scratch, used for renaming.\n+\t\n+loopStart:\t\n+\t// R0 := R4 - zeroExtend (R10) - only need 33-bits (i.e., 48-bits)\n+\tSUBB.0 R5,R11,R1 \\ LSR.1 R0,15,R3\n+\tSUBB.0 R6,0,R2 \\ LSR.1 R1,15,R6\n+\n+\t// if (carry) goto shiftOnly\n+\tSUB.0 R8,1,R8 \\ BNE shiftOnly\n+=->\tLSR.0 R4,15,R7 \\ LSL.1 R1,1,R9\n+\t\n+\tOR.0 [LSL R0,1],1,R4 \\ BNE loopStart\n+=->\tSUB.0 R4,R10,R0 \\ OR.1 R9,R3,R5\n+\t\n+\tBRA loopEnd\n+\t\n+shiftOnly:\t\n+\n+\tOR.0 [LSL R5,1],R7,R5 \\ BNE loopStart \\ LSR.1 R5,15,R6\n+=->\tSUB.0 [LSL R4,1],R10,R0 \\LSL.1 R4,1,R4\n+\t\n+// End of loop\n+loopEnd:\n+\n+\t// Schedule the computation of the upper word after shifting\n+\t// alongside the decision over whether to branch, and the register\n+\t// restores.\n+\t// R10 is filled with a useful constant.\n+\tSUB.0 15,r14,r15 \\ LDL (FP)4,R[13:12]\n+\tSUB.1 0,R14,R1 // Don't set flags!\n+\tLSL.0 R6,R1,R3 \\ LDL (FP)-4,R[9:8]\n+\n+\tBLT remainderHasMoreThan16Bits \\ LSR.0 R5,R14,R7 \\ COPY.1 -1,R10\n+=->\tLSL.0 R5,R1,R2 \\ OR.1 R7,R3,R3\n+\n+\tLSR.0 R4,R14,R3 \\ COPY.1 R3,R7\n+\tBRA epilogue \\ LSR.0 -1,R1,R0 \\ COPY.1 0,R5\n+=->\tOR.0 R3,R2,R6 \\ AND.1 R0,R4,R4\n+\t\n+remainderHasMoreThan16Bits:\t\n+\n+\tLSL.0 R10,R14,R1 \\ COPY.1 R3,R6\n+\tXOR.0 R10,R1,R1 \\ COPY.1 0,R7\n+\tAND.0 R1,R5,R5\n+\n+epilogue:\n+\t\n+\tJR (R12) \\ LDW (FP)-4,R14\n+=->\tLDL (FP)-3,R[11:10]\n+\n+_picoMark_FUNCTION_END=\n+\t\n+// picoChip Function Epilogue : udivmodsi4\n+\n+//============================================================================\n+// All DWARF information between this marker, and the END OF DWARF\n+// marker should be included in the source file. Search for\n+// FUNCTION_STACK_SIZE_GOES_HERE and FUNCTION NAME GOES HERE, and\n+// provide the relevent information. Add markers called\n+// _picoMark_FUNCTION_BEGIN and _picoMark_FUNCTION_END around the\n+// function in question.\n+//============================================================================\n+\n+//============================================================================\n+// Frame information. \n+//============================================================================\n+\n+.section .debug_frame\n+_picoMark_DebugFrame=\n+\n+// Common CIE header.\n+.unalignedInitLong _picoMark_CieEnd-_picoMark_CieBegin\n+_picoMark_CieBegin=\n+.unalignedInitLong 0xffffffff\n+.initByte 0x1\t// CIE Version\n+.ascii 16#0#\t// CIE Augmentation\n+.uleb128 0x1\t// CIE Code Alignment Factor\n+.sleb128 2\t// CIE Data Alignment Factor\n+.initByte 0xc\t// CIE RA Column\n+.initByte 0xc\t// DW_CFA_def_cfa\n+.uleb128 0xd\n+.uleb128 0x0\n+.align 2\n+_picoMark_CieEnd=\n+\n+// FDE \n+_picoMark_LSFDE0I900821033007563=\n+.unalignedInitLong _picoMark_FdeEnd-_picoMark_FdeBegin\n+_picoMark_FdeBegin=\n+.unalignedInitLong _picoMark_DebugFrame\t// FDE CIE offset\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// FDE initial location\n+.unalignedInitWord _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x18\t// <-- FUNCTION_STACK_SIZE_GOES_HERE\n+.initByte 0x4\t// DW_CFA_advance_loc4\n+.unalignedInitLong _picoMark_FUNCTION_END-_picoMark_FUNCTION_BEGIN\n+.initByte 0xe\t// DW_CFA_def_cfa_offset\n+.uleb128 0x0\n+.align 2\n+_picoMark_FdeEnd=\n+\n+//============================================================================\n+// Abbrevation information.\n+//============================================================================\n+\n+.section .debug_abbrev\n+_picoMark_ABBREVIATIONS=\n+\n+.section .debug_abbrev\n+\t.uleb128 0x1\t// (abbrev code)\n+\t.uleb128 0x11\t// (TAG: DW_TAG_compile_unit)\n+\t.initByte 0x1\t// DW_children_yes\n+\t.uleb128 0x10\t// (DW_AT_stmt_list)\n+\t.uleb128 0x6\t// (DW_FORM_data4)\n+\t.uleb128 0x12\t// (DW_AT_high_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x11\t// (DW_AT_low_pc)\n+\t.uleb128 0x1\t// (DW_FORM_addr)\n+\t.uleb128 0x25\t// (DW_AT_producer)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+\t.uleb128 0x13\t// (DW_AT_language)\n+\t.uleb128 0x5\t// (DW_FORM_data2)\n+\t.uleb128 0x3\t// (DW_AT_name)\n+\t.uleb128 0x8\t// (DW_FORM_string)\n+.initByte 0x0\n+.initByte 0x0\n+\n+\t.uleb128 0x2\t;# (abbrev code)\n+\t.uleb128 0x2e\t;# (TAG: DW_TAG_subprogram)\n+.initByte 0x0\t;# DW_children_no\n+\t.uleb128 0x3\t;# (DW_AT_name)\n+\t.uleb128 0x8\t;# (DW_FORM_string)\n+\t.uleb128 0x11\t;# (DW_AT_low_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+\t.uleb128 0x12\t;# (DW_AT_high_pc)\n+\t.uleb128 0x1\t;# (DW_FORM_addr)\n+.initByte 0x0\n+.initByte 0x0\n+\n+.initByte 0x0\n+\n+//============================================================================\n+// Line information. DwarfLib requires this to be present, but it can\n+// be empty.\n+//============================================================================\n+\n+.section .debug_line\n+_picoMark_LINES=\n+\n+//============================================================================\n+// Debug Information\n+//============================================================================\n+.section .debug_info\n+\n+//Fixed header.\n+.unalignedInitLong _picoMark_DEBUG_INFO_END-_picoMark_DEBUG_INFO_BEGIN\n+_picoMark_DEBUG_INFO_BEGIN=\n+.unalignedInitWord 0x2\n+.unalignedInitLong _picoMark_ABBREVIATIONS\n+.initByte 0x2\n+\n+// Compile unit information.\n+.uleb128 0x1\t// (DIE 0xb) DW_TAG_compile_unit)\n+.unalignedInitLong _picoMark_LINES\n+.unalignedInitWord _picoMark_FUNCTION_END\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\n+// Producer is `picoChip'\n+.ascii 16#70# 16#69# 16#63# 16#6f# 16#43# 16#68# 16#69# 16#70# 16#00#\n+.unalignedInitWord 0xcafe // ASM language\n+.ascii 16#0# // Name. DwarfLib expects this to be present.\n+\n+.uleb128 0x2\t;# (DIE DW_TAG_subprogram)\n+\n+// FUNCTION NAME GOES HERE. Use `echo name | od -t x1' to get the hex. Each hex\n+// digit is specified using the format 16#XX#\n+.ascii 16#5f# 16#75# 16#64# 16#69# 16#76# 16#6d# 16#6f# 16#64# 16#73# 16#69# 16#34# 16#0# // Function name `_udivmodsi4'\n+.unalignedInitWord _picoMark_FUNCTION_BEGIN\t// DW_AT_low_pc\n+.unalignedInitWord _picoMark_FUNCTION_END\t// DW_AT_high_pc\n+\n+.initByte 0x0\t// end of compile unit children.\n+\n+_picoMark_DEBUG_INFO_END=\n+\n+//============================================================================\n+// END OF DWARF\n+//============================================================================\n+.section .endFile\n+// End of picoChip ASM file"}, {"sha": "9b2c824ee26d10a28bb09d7bfde8cba3459ab554", "filename": "config/picochip/picochip-protos.h", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fpicochip-protos.h?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,140 @@\n+/* Prototypes for exported functions defined in picochip.c\n+\n+   Copyright (C) 2000, 2001, 2008 Free Software Foundation, Inc.\n+   Contributed by picoChip Designs Ltd. (http://www.picochip.com)\n+   Maintained by Daniel Towner (daniel.towner@picochip.com) and\n+   Hariharan Sandanagobalane (hariharan@picochip.com).\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"target.h\"\n+extern void picochip_function_prologue (FILE *, HOST_WIDE_INT);\n+extern void picochip_function_epilogue (FILE *, HOST_WIDE_INT);\n+\n+extern enum reg_class picochip_reg_class_from_letter (unsigned);\n+extern int picochip_legitimate_address_p (int, struct rtx_def *, unsigned);\n+extern int picochip_const_ok_for_letter_p (unsigned HOST_WIDE_INT value, unsigned c);\n+\n+#ifdef RTX_CODE\t\t\t/* inside TREE_CODE */\n+\n+extern int picochip_reg_mode_ok_for_base_p (int mode, rtx x, unsigned strict);\n+extern void picochip_print_operand (FILE * file, rtx op, int letter);\n+extern void picochip_print_operand_address (FILE * file, rtx operand);\n+\n+extern const char *picochip_output_cbranch (rtx operands[]);\n+extern const char *picochip_output_branch (rtx operands[], rtx insn);\n+extern const char *picochip_output_compare (rtx operands[]);\n+extern const char *picochip_output_jump (rtx insn);\n+\n+extern const char *picochip_output_put_array (int alternative,\n+\t\t\t\t\t      rtx operands[]);\n+extern const char *picochip_output_get_array (int alternative,\n+\t\t\t\t\t      rtx operands[]);\n+extern const char *picochip_output_testport_array (int alternative,\n+\t\t\t\t\t\t   rtx operands[]);\n+\n+extern rtx gen_SImode_mem(rtx opnd1,rtx opnd2);\n+extern bool ok_to_peephole_stw(rtx opnd0, rtx opnd1, rtx opnd2, rtx opnd3);\n+extern bool ok_to_peephole_ldw(rtx opnd0, rtx opnd1, rtx opnd2, rtx opnd3);\n+\n+extern rtx gen_min_reg(rtx opnd1,rtx opnd2);\n+\n+extern rtx picochip_function_arg (CUMULATIVE_ARGS cum, int mode, tree type,\n+\t\t\t   int named);\n+\n+extern rtx picochip_incoming_function_arg (CUMULATIVE_ARGS, int, tree, int);\n+extern CUMULATIVE_ARGS picochip_arg_advance (CUMULATIVE_ARGS cum, int mode,\n+\t\t\t\t      tree type, int named);\n+\n+extern int picochip_regno_nregs (int regno, int mode);\n+extern int picochip_class_max_nregs (int class, int mode);\n+\n+extern void picochip_order_regs_for_local_alloc (void);\n+\n+extern int picochip_word_aligned_memory_reference (rtx operand);\n+extern int picochip_alignable_memory_operand (rtx operand, enum machine_mode mode);\n+extern int picochip_absolute_memory_operand (rtx op, enum machine_mode mode);\n+\n+extern rtx picochip_function_value (const_tree valtype, const_tree func, bool outgoing);\n+extern int picochip_symbol_offset (rtx operand);\n+\n+extern int picochip_get_function_arg_boundary (enum machine_mode mode);\n+\n+extern enum reg_class picochip_secondary_reload(bool in_p,\n+                                 rtx x,\n+                                 enum reg_class cla,\n+                                 enum machine_mode mode,\n+                                 secondary_reload_info *sri);\n+\n+extern void picochip_get_hi_aligned_mem (rtx ref, rtx * paligned_mem, rtx * pbitnum);\n+\n+extern rtx picochip_get_low_const (rtx value);\n+extern rtx picochip_get_high_const (rtx value);\n+\n+extern void picochip_expand_prologue (void);\n+extern void picochip_expand_epilogue (int is_sibling_call);\n+\n+extern void picochip_final_prescan_insn (rtx insn, rtx * operand, int num_operands);\n+extern const char *picochip_asm_output_opcode (FILE * f, const char *ptr);\n+extern void picochip_override_options (void);\n+\n+extern int picochip_check_conditional_copy (rtx * operands);\n+\n+extern rtx picochip_return_addr_rtx(int count, rtx frameaddr);\n+extern rtx picochip_struct_value_rtx(tree fntype ATTRIBUTE_UNUSED,\n+                              int incoming ATTRIBUTE_UNUSED);\n+\n+#endif /* RTX_CODE inside TREE_CODE */\n+\n+void picochip_output_ascii (FILE * file, const char *str, int length);\n+\n+extern int picochip_hard_regno_mode_ok (int regno, enum machine_mode mode);\n+extern void picochip_generate_internal_label (char *str, const char *prefix,\n+\t\t\t\t\t      long num);\n+\n+extern bool picochip_return_in_memory(const_tree type,\n+                                      const_tree fntype ATTRIBUTE_UNUSED);\n+\n+extern int initial_elimination_offset (int from, int to);\n+\n+extern void picochip_output_aligned_common (FILE * stream, const char *name,\n+\t\t\t\t\t    unsigned size, unsigned align);\n+\n+extern void picochip_output_global (FILE * stream, const char *name);\n+\n+extern void picochip_output_aligned_local (FILE * stream, const char *name,\n+\t\t\t\t\t   unsigned size, unsigned alignment);\n+\n+extern void picochip_output_label (FILE * stream, const char name[]);\n+extern void picochip_output_labelref (FILE * stream, const char name[]);\n+extern void picochip_weaken_label (FILE * stream, const char name[]);\n+extern void picochip_output_internal_label (FILE * stream, const char *prefix,\n+\t\t\t\t     unsigned long num);\n+\n+extern void warn_of_byte_access (void);\n+\n+/* True if VLIW scheduling is enabled (i.e., second scheduling pass). */\n+extern int picochip_flag_schedule_insns2;\n+\n+extern void picochip_asm_output_anchor (rtx symbol);\n+\n+/* Instruction set capability flags.  These are initialised to the\n+   appropriate values by picochip_override_options, once the user has\n+   selected a CPU type. */\n+extern bool picochip_has_mul_unit;\n+extern bool picochip_has_mac_unit;\n+"}, {"sha": "48f877c5c13d68326f7cfd3bc9d6337f1fe796c4", "filename": "config/picochip/picochip.c", "status": "added", "additions": 4421, "deletions": 0, "changes": 4421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fpicochip.c?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244"}, {"sha": "6c92fb48a6956f651df0e7d5b4f4153a3bd0ea6e", "filename": "config/picochip/picochip.h", "status": "added", "additions": 749, "deletions": 0, "changes": 749, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fpicochip.h?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,749 @@\n+/* Definitions of target machine for GNU compiler for picoChip\n+   Copyright (C) 2001, 2008 Free Software Foundation, Inc.\n+\n+   Contributed by picoChip Designs Ltd. (http://www.picochip.com)\n+   Maintained by Daniel Towner (daniel.towner@picochip.com) and\n+   Hariharan Sandanagobalane (hariharan@picochip.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not, see\n+<http://www.gnu.org/licenses/>. */\n+\n+/* Which type of DFA scheduling to use - schedule for speed (VLIW), or\n+   schedule for space.  When scheduling for space, attempt to schedule\n+   into stall cycles, but don't pack instructions. */\n+\n+enum picochip_dfa_type\n+{\n+  DFA_TYPE_NONE,\n+  DFA_TYPE_SPACE,\n+  DFA_TYPE_SPEED\n+};\n+\n+extern enum picochip_dfa_type picochip_schedule_type;\n+\n+/* Controlling the Compilation Driver */\n+\n+/* Pass through the save-temps command option. */\n+#define LINK_SPEC \" %{save-temps:--save-temps}\"\n+\n+/* This is an embedded processor, and only supports a cut-down version of\n+ * the standard C library. */\n+#define LIB_SPEC \"-lpicoC\"\n+\n+/* The start file is automatically provided by the linker. */\n+#define STARTFILE_SPEC \"\"\n+\f\n+/* Run-time Target Specification  */\n+\n+/* Define some additional pre-processor macros. */\n+#define TARGET_CPU_CPP_BUILTINS()                       \\\n+  do                                                    \\\n+    {                                                   \\\n+      builtin_define (\"NO_TRAMPOLINES\");                \\\n+      builtin_define (\"PICOCHIP\");                      \\\n+      builtin_define (\"__PICOCHIP__\");                      \\\n+    }                                                   \\\n+  while (0)\n+\n+/* Translate requests for particular AEs into their respective ISA\n+   options. Note that byte access is enabled by default. */\n+#define TARGET_OPTION_TRANSLATE_TABLE\t\t\t      \\\n+  { \"-mae=ANY\",   \"-mmul-type=none -mno-byte-access\" },\t      \\\n+  { \"-mae=ANY2\",  \"-mmul-type=none -mno-byte-access\" },\t      \\\n+  { \"-mae=ANY3\",  \"-mmul-type=none\" },\t\t\t      \\\n+  { \"-mae=STAN\",  \"-mmul-type=none -mno-byte-access\" },\t      \\\n+  { \"-mae=STAN2\", \"-mmul-type=mac -mno-byte-access\" },\t      \\\n+  { \"-mae=STAN3\", \"-mmul-type=mac \" },\t\t\t      \\\n+  { \"-mae=MAC\",   \"-mmul-type=mac -mno-byte-access\" },\t      \\\n+  { \"-mae=MUL\",   \"-mmul-type=mul\" },\t\t\t      \\\n+  { \"-mae=MEM\",   \"-mmul-type=mul\" },\t\t\t      \\\n+  { \"-mae=MEM2\",  \"-mmul-type=mul\" },\t\t\t      \\\n+  { \"-mae=CTRL\",  \"-mmul-type=mul\" },\t\t\t      \\\n+  { \"-mae=CTRL2\", \"-mmul-type=mul\" }\n+\n+/* Specify the default options, so that the multilib build doesn't\n+   need to provide special cases for the defaults. */\n+#define MULTILIB_DEFAULTS \\\n+  { \"mmul-type=mul\", \"mbyte-access\"}\n+\n+#define TARGET_HAS_BYTE_ACCESS (picochip_has_byte_access)\n+#define TARGET_HAS_MUL_UNIT (picochip_has_mul_unit)\n+#define TARGET_HAS_MAC_UNIT (picochip_has_mac_unit)\n+#define TARGET_HAS_MULTIPLY (picochip_has_mac_unit || picochip_has_mul_unit)\n+\n+/* Allow some options to be overriden.  In particular, the 2nd\n+   scheduling pass option is switched off, and a machine dependent\n+   reorganisation ensures that it is run later on, after the second\n+   jump optimisation. */\n+#define OVERRIDE_OPTIONS picochip_override_options()\n+\n+#define CAN_DEBUG_WITHOUT_FP 1\n+\n+#define TARGET_VERSION fprintf(stderr, \"(picoChip)\");\n+\f\n+/* Storage Layout */\n+\n+/* picoChip processors are 16-bit machines, little endian. */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+#define BITS_PER_UNIT 8\n+\n+#define BITS_PER_WORD 16\n+#define UNITS_PER_WORD (BITS_PER_WORD / BITS_PER_UNIT)\n+\n+#define POINTER_SIZE BITS_PER_WORD\n+\n+/* Promote those modes that are smaller than an int, to int mode.  */\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \\\n+  ((GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\\\n+      ? (MODE) = HImode : 0)\n+\n+/* All parameters are at least this aligned.  Parameters are passed\n+   one-per-register. */\n+#define PARM_BOUNDARY BITS_PER_WORD\n+\n+/* The main stack pointer is guaranteed to be aligned to the most\n+   strict data alignment. */\n+#define STACK_BOUNDARY 32\n+\n+/* Function entry point is byte aligned. */\n+#define FUNCTION_BOUNDARY 8\n+\n+/* This is the biggest alignment that can be allowed on this machine.\n+   Since the STANs have only 256 byte memory, it doesnt make sense\n+   to have alignments greater than 32 bytes. Hence the value */\n+#define MAX_OFILE_ALIGNMENT 32*8\n+\n+/* The strictest data object alignment, which repesents a register pair. */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* The hardware doesn't allow unaligned memory access.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* We want the 'unix' style bitfield packing algorithm.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Support up to 64-bit integers. */\n+#define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)\n+\n+/* We don't support floating point, but give it a sensible definition. */\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\f\n+/* Layout of Source Language Data Types.  */\n+\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+\n+/* The normal sizes for C scalar data. */\n+#define CHAR_TYPE_SIZE 8\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+/* We don't support the following data types, but still give them\n+   sensible values.  */\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 32\n+#define LONG_DOUBLE_TYPE_SIZE 32\n+\n+/* Plain `char' is a signed type, since the hardware sign-extends\n+   bytes when loading them from memory into a register. */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Note that the names of the types used in the following macros must\n+   be precisely the same as those defined internally in gcc.  For\n+   example, `unsigned short' wouldn't work as a type string, since gcc\n+   doesn't define any type with this exact string.  The correct string\n+   to use is `short unsigned int'. */\n+\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#define PTRDIFF_TYPE \"int\"\n+\n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE 16\n+\n+#define WINT_TYPE \"unsigned int\"\n+\f\n+/* Register Usage  */\n+\n+/* Picochip has 16 16-bit registers, a condition code register and an\n+   (inaccessible) instruction pointer.  One of these registers (r15) is\n+   special, and is either used to load a constant anywhere a register\n+   can normally be used, or is used to specify a dummy destination\n+   (e.g., when setting condition flags).  We also define some pseudo\n+   registers to represent condition codes, the frame pointer and the\n+   argument pointer.  The latter two are eliminated wherever possible.\n+\n+   Pairs of general registers may be combined to form 32-bit registers.\n+\n+   The picoChip registers are as follows:\n+\n+   0..1 - function return value\n+   0..5 - first 6 function parameters\n+   6..11 - General purpose\n+   12 - link register\n+   13 - stack pointer\n+   14 - specialized pointer\n+   15 - long constant or /dev/null\n+   (16) acc0\n+   (17) pseudo condition code\n+   (18) pseudo frame pointer\n+   (19) pseudo arg pointer\n+\n+   Registers 0..6, 12, 13, 14, 15 are caller save\n+   Registers 0..12, 14 are available to the register allocator.\n+\n+   In addition, the DSP variant of the ISA allows extra accumulator\n+   registers to be accessed.  These are special purpose registers,\n+   which are not currently used by the compiler.\n+\n+  */\n+\n+/* Basic Characteristics of Registers  */\n+\n+/* We have 16 hard registers plus 3 pseudo hard registers and an accumulator.  */\n+#define FIRST_PSEUDO_REGISTER 20\n+\n+/* The first non-hard register.  Only used internally by the picoChip port. */\n+#define FIRST_NONHARD_REGISTER 18\n+\n+/* Cannot use SP, CST, CC, FP, AP */\n+#define FIXED_REGISTERS {0,0,0,0,0,0,0,0, 0,0,0,0,0,1,0,1, 1,1,1,1}\n+\n+/* Those that are clobbered by a function call (includes pseudo-regs) */\n+#define CALL_USED_REGISTERS {1,1,1,1,1,1,0,0, 0,0,0,0,1,1,0,1, 1,1,1,1}\n+#define CALL_REALLY_USED_REGISTERS {1,1,1,1,1,1,0,0, 0,0,0,0,1,1,0,0, 0,1,0,0}\n+\n+/* Define the number of the picoChip link and condition psuedo registers. */\n+#define LINK_REGNUM 12\n+#define CC_REGNUM 17\n+#define ACC_REGNUM 16\n+\n+/* Order of Allocation of Registers  */\n+\n+/* The registers are allocated starting with the caller-clobbered\n+   registers, in reverse order.  The registers are then listed in an\n+   order which means that they are efficiently saved in pairs (i.e.,\n+   one 32-bit store can be used instead of two 16-bit stores to save\n+   the registers into the stack). The exception to this is the use of\n+   r14 (AP) register, which also appears early on.  This is because the\n+   AP register can be used to encode memory operations more\n+   efficiently than other registers.  Some code can be made more\n+   compact as a result. */\n+   /* My current feeling is that r14 should go to the end and maybe even r12.\n+   It seems like the overhead of store/load that will occur since we cant\n+   pair anything up with r14 will be higher than the advantage of smaller\n+   encoding.\n+   Also r12 is put towards the end for leaf functions. Since leaf functions\n+   do not have any calls, the prologue/epilogue for them wouldnt save up/\n+   restore its value. So, it doesnt make sense for us to use it in the middle,\n+   if we can avoid it. */\n+#define REG_ALLOC_ORDER {5,4,3,2,1,0,12,6,7,8,9,10,11,14,16,0,0,0,0,0}\n+#define LEAF_REG_ALLOC_ORDER {5,4,3,2,1,0,6,7,8,9,10,11,14,12,16,0,0,0,0,0}\n+\n+/* We can dynamically change the REG_ALLOC_ORDER using the following hook.\n+   It would be desirable to change it for leaf functions so we can put\n+   r12 at the end of this list.*/\n+#define ORDER_REGS_FOR_LOCAL_ALLOC picochip_order_regs_for_local_alloc ()\n+\n+/* How Values Fit in Registers  */\n+\n+/* Number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE) picochip_regno_nregs((REGNO), (MODE))\n+\n+/* Is it ok to place MODE in REGNO?  Require that the register number\n+   be aligned. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\tpicochip_hard_regno_mode_ok(REGNO, MODE)\n+\n+#define MODES_TIEABLE_P(MODE1,MODE2) 1\n+\n+/* Don't copy the cc register ('cos you can't put it back).  */\n+#define AVOID_CCMODE_COPIES 1\n+\f\n+/* Register Classes */\n+\n+enum reg_class\n+{\n+  NO_REGS,\t\t\t/* no registers in set */\n+  FRAME_REGS,\t\t\t/* registers with a long offset  */\n+  PTR_REGS,\t\t\t/* registers without an offset  */\n+  CONST_REGS,\t\t\t/* registers for long constants  */\n+  NULL_REGS,\t\t\t/* registers which ignore writes  */\n+  CC_REGS,\t\t\t/* condition code registers  */\n+  ACC_REGS,\t\t\t/* Accumulator registers  */\n+  TWIN_REGS,\t\t\t/* registers which can be paired */\n+  GR_REGS,\t\t\t/* general purpose registers */\n+  ALL_REGS,\t\t\t/* all registers */\n+  LIM_REG_CLASSES,\t\t/* max value + 1 */\n+\n+  /* Some aliases  */\n+  GENERAL_REGS = GR_REGS\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES \t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  GR_REGS, LIM_REG_CLASSES\t\t\t\t\t\t\\\n+}\n+\n+\n+/* The names of the register classes  */\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FRAME_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"PTR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"CONST_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"NULL_REGS\", \t\t\t\t\t\t\t\t\\\n+  \"CC_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ACC_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"TWIN_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Each reg class is an array of 32-bit integers.  Each array must be\n+   long enough to store one bit for every pseudo register. Thus in the\n+   following code, each array only stores one 32-bit value. */\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  {0x00000000}, /* no registers */\t\t\t\t\t\\\n+  {0x00002000},\t/* frame */\t\t\t\t\t\t\\\n+  {0x00004000},\t/* pointer  */\t\t\t\t\t\t\\\n+  {0x00008000}, /* const */\t\t\t\t\t\t\\\n+  {0x00008000},\t/* null  */\t\t\t\t\t\t\\\n+  {0x00020000}, /* cc */\t\t\t\t\t\t\\\n+  {0x00010000}, /* acc0 */\t\t\t\t\t\t\\\n+  {0x00000FFF},\t/* twin */\t\t\t\t\t\t\\\n+  {0x000CFFFF},\t/* general registers - includes pseudo-arg */    \t\\\n+  {0x000FFFFF}\t/* all registers - includes pseudo-arg */               \\\n+}\n+\n+/* The earliest register class containing the given register.  */\n+extern const enum reg_class picochip_regno_reg_class[FIRST_PSEUDO_REGISTER];\n+#define REGNO_REG_CLASS(REGNO) picochip_regno_reg_class[REGNO]\n+\n+/* Any register can be a base pointer.  */\n+#define BASE_REG_CLASS GR_REGS\n+\n+/* Any register can be an index.  */\n+#define INDEX_REG_CLASS GR_REGS\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) \t\t\t\t\t\\\n+  (REGNO_REG_CLASS (REGNO) != CC_REGS && REGNO_REG_CLASS (REGNO) != ACC_REGS)\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) CLASS\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) picochip_class_max_nregs(CLASS, MODE)\n+\n+\f\n+/* Stack Layout and Calling Conventions  */\n+\n+#define STACK_GROWS_DOWNWARD 1\n+\n+/* The frame pointer points to the outgoing argument area, so the\n+   locals are above that.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Specify where the return address lives before entry to the\n+   prologue.  This is required to enable DWARF debug information to be\n+   generated. */\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, LINK_REGNUM)\n+\n+#define RETURN_ADDR_RTX(count,frameaddr) picochip_return_addr_rtx(count,frameaddr)\n+\n+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (LINK_REGNUM)\n+\n+/* Registers that Address the Stack Frame  */\n+\n+#define STACK_POINTER_REGNUM 13\n+#define FRAME_POINTER_REGNUM 18\n+#define ARG_POINTER_REGNUM   19\n+\n+/* Static chain is used to pass the local variables of the enclosing function.\n+   The static chain is passed in memory. The first long-word location\n+   beneath the stack pointer is used. In the presence of pretend\n+   arguments, which are written into that location, this mechanism\n+   complicates matters. */\n+\n+/* Location seen by the caller. */\n+#define STATIC_CHAIN\t\t\t\t\t\t\t\\\n+  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, -2 * UNITS_PER_WORD))\n+\n+/* Location seen by the callee. */\n+#define STATIC_CHAIN_INCOMING\t\t\t\t\t\t\\\n+  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, 0))\n+\n+/* Eliminating Frame Pointer and Arg Pointer.  The frame and argument\n+   pointers are eliminated wherever possible, by replacing them with\n+   offsets from the stack pointer. */\n+\n+/* We want to get rid of the frame pointer.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+#define ELIMINABLE_REGS \t\t\t\t\t\t\\\n+  {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM,TO,OFFSET) \\\n+  OFFSET = initial_elimination_offset(FROM, TO);\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define PUSH_ARGS 0\n+\n+/* Functions don't pop their args.  */\n+#define RETURN_POPS_ARGS(FNDECL, FNTYPE, STACK) 0\n+\n+/* Passing Arguments in Registers  */\n+\n+/* Store the offset of the next argument. */\n+#define CUMULATIVE_ARGS unsigned\n+\n+/* Decide how function arguments are handled. */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  picochip_function_arg (CUM, MODE, TYPE, NAMED)\n+\n+/* Incoming arguments are always the same as normal arguments, except\n+   for a function which uses variadic arguments, in which case all\n+   arguments are effectively passed on the stack. */\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n+  picochip_incoming_function_arg(CUM, MODE, TYPE, NAMED)\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT,N_NAMED_ARGS) \\\n+  ((CUM) = 0)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM,MODE,TYPE,NAMED) \\\n+  (CUM) = picochip_arg_advance (CUM, MODE, TYPE, NAMED)\n+\n+/* Originally this used TYPE_ALIGN to determine the\n+   alignment.  Unfortunately, this fails in some cases, because the\n+   type is unknown (e.g., libcall's). Instead, use GET_MODE_ALIGNMENT\n+   since the mode is always present. */\n+#define FUNCTION_ARG_BOUNDARY(MODE,TYPE) \\\n+  picochip_get_function_arg_boundary(MODE)\n+\n+/* The first 6 registers can hold parameters.  */\n+#define FUNCTION_ARG_REGNO_P(REGNO) ((REGNO) < 6)\n+\n+/* How Scalar Function Values are Returned\n+   Do we need this?? */\n+#define FUNCTION_VALUE(VALTYPE,FUNC) picochip_function_value(VALTYPE, FUNC, 0)\n+\n+#define LIBCALL_VALUE(MODE) (gen_rtx_REG (MODE, 0))\n+\n+/* Results are in register zero.  If an SImode register is returned,\n+   reg0 will suffice to mean R[0:1]. */\n+#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == 0)\n+\n+/* Don't automatically pass struct's in memory - use the\n+ * RETURN_IN_MEMORY macro to determine when structs are returned in\n+ * memory, and when in registers. */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Function Entry and Exit  */\n+\n+/* The epilogue doesn't clobber anything.  */\n+#define EPILOGUE_USES(REGNO) 0\n+\n+/* Generating Code for Profiling.  No profiling implemented  */\n+\n+#define FUNCTION_PROFILER(FILE,LABELNO)\n+\f\n+/* Trampolines for Nested Functions  */\n+\n+/* No trampolines.  */\n+#define TRAMPOLINE_SIZE 0\n+#define INITIALIZE_TRAMPOLINE(ADDR,FNADDR,CHAIN)\n+\f\n+/* Addressing Modes  */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P(X)\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#ifdef REG_OK_STRICT\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\t\\\n+ if (picochip_legitimate_address_p (MODE, X, 1)) goto LABEL;\n+\n+#else /* REG_OK_STRICT */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\t\\\n+  if (picochip_legitimate_address_p (MODE, X, 0)) goto LABEL;\n+\n+#endif /* !REG_OK_STRICT */\n+\n+/* extern struct rtx_def *picochip_legitimize_address */\n+/* \tPARAMS ((struct rtx_def *, struct rtx_def *, int)); */\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN);\n+\n+/* Legitimize reload address tries machine dependent means of\n+   reloading addresses.  There seems to be a strange error in gcc,\n+   which necessitates this macro.  Consider:\n+\n+     set (reg A) (symbol_ref)\n+     set (reg B) (plus (reg A) (const_int))\t\n+\t\t\t\n+   A symbol_ref is a valid constant, so the symbol_ref is propagated\n+   into the second instruction to generate the instruction:\n+\n+     set (reg B) (plus (symbol_ref) (const_int))\n+\n+   This is an invalid address, and find_reloads_address correctly\n+   determines this.  However, that function doesn't generate a valid\n+   replacement for the now invalid address, and the invalid address is\n+   output into the assembly language.  To fix the problem without\n+   changing gcc itself, the following macro tests when such an invalid\n+   address has been computed, and wraps it up inside a constant rtx.  A\n+   constant rtx can be correctly reloaded by the function, and hence\n+   correct code is generated. */\n+\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t     \\\n+if (picochip_symbol_offset(X)) { X = gen_rtx_CONST(MODE, X); }\n+\n+/* There are no mode dependent addresses.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL) do {} while (0)\n+\n+/* Nonzero if the constant rtx X is a legitimate general operand.  X\n+   satisfies CONSTANT_P.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+\f\n+/* Condition Code Status  */\n+\n+#define CC_STATUS_MDEP unsigned\n+#define CC_STATUS_MDEP_INIT (cc_status.mdep = 0)\n+\f\n+/* Describing Relative Costs of Operations  */\n+\n+/* Bytes are no faster than words.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* The assembler is often able to optimise function call branches, so\n+   don't try to CSE them in the compiler. This was the thinking before.\n+   But now, we realise that the benefits from CSE would mostly outweigh\n+   the disadvantages. */\n+#define NO_FUNCTION_CSE\n+\n+\f\n+/* Dividing the Output into Sections  */\n+\n+#define TEXT_SECTION_ASM_OP \".section .text\\n\"\n+#define DATA_SECTION_ASM_OP \".section .data\\n\"\n+#define BSS_SECTION_ASM_OP \".section .bss\\n\"\n+/* picoChip is Harvard (separate data/instruction memories), so\n+   read-only data must go into the data section. */\n+#define READONLY_DATA_SECTION_ASM_OP \".section .data\\n\"\n+\f\n+/* Defining the Output Assembler Language  */\n+\n+/* The Overall Framework of an Assembler File  */\n+\n+#define ASM_FILE_COMMENT \"// \"\n+\n+#define ASM_APP_ON \"// High-level ASM start\\n\"\n+#define ASM_APP_OFF \"// High-level ASM end\\n\"\n+\n+#define ASM_OUTPUT_IDENT(STREAM,STRING) fprintf(STREAM, \".ident %s\\n\", STRING)\n+\n+/* Output of Data  */\n+\n+#define ASM_OUTPUT_ASCII(FILE, PTR, LEN) picochip_output_ascii(FILE, PTR, LEN);\n+\n+/* Output of Uninitialized Variables  */\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE,NAME,SIZE,ALIGN) \\\n+  picochip_output_aligned_common(FILE, NAME, SIZE, ALIGN)\n+\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE,NAME,SIZE,ALIGN) \\\n+  picochip_output_aligned_local(FILE, NAME, SIZE, ALIGN)\n+\n+/* Output and Generation of Labels  */\n+\n+#define ASM_OUTPUT_LABEL(STREAM,NAME) \\\n+  do { picochip_output_label(STREAM, NAME); } while (0);\n+\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+  { picochip_output_labelref(STREAM, NAME); }\n+\n+/* Format must match that of picochip_output_label. */\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING,PREFIX,NUM) \\\n+ picochip_generate_internal_label(STRING,PREFIX,(long)NUM)\n+\n+#define ASM_WEAKEN_LABEL(STREAM,NAME) picochip_weaken_label(STREAM,NAME);\n+\n+/* Store in OUTPUT a string (made with alloca) containing an\n+   assembler-name for a local static variable named NAME.  LABELNO is\n+   an integer which is different for each call.  The assembler can't\n+   use periods to generate the name, so we use a ___ separator\n+   instead. */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 15),    \\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+/* Macros Controlling Initialization Routines  */\n+\n+/* By defining this, the main function won't try to call `__main'. */\n+#define HAS_INIT_SECTION\n+\n+/* Output of Assembler Instructions  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\"R0\",  \"R1\",  \"R2\",  \"R3\",\t\t\t\t\t\t\\\n+ \"R4\",  \"R5\",  \"R6\",  \"R7\",\t\t\t\t\t\t\\\n+ \"R8\",  \"R9\",  \"R10\", \"R11\",\t\t\t\t\t\t\\\n+ \"R12\", \"FP\", \"R14\", \"R15\",\t\t\t\t\t\t\\\n+ \"acc0\", \"pseudoCC\", \"pseudoFP\", \"pseudoAP\"}\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"R0\",\t 0},\t\t\t\t\t\t\t\\\n+  { \"R1\",\t 1},\t\t\t\t\t\t\t\\\n+  { \"R2\",\t 2},\t\t\t\t\t\t\t\\\n+  { \"R3\",\t 3},\t\t\t\t\t\t\t\\\n+  { \"R4\",\t 4},\t\t\t\t\t\t\t\\\n+  { \"R5\",\t 5},\t\t\t\t\t\t\t\\\n+  { \"R6\",\t 6},\t\t\t\t\t\t\t\\\n+  { \"R7\",\t 7},\t\t\t\t\t\t\t\\\n+  { \"R8\",\t 8},\t\t\t\t\t\t\t\\\n+  { \"R9\",\t 9},\t\t\t\t\t\t\t\\\n+  { \"R10\",\t10},\t\t\t\t\t\t\t\\\n+  { \"R11\",\t11},\t\t\t\t\t\t\t\\\n+  { \"R12\",\t12},\t\t\t\t\t\t\t\\\n+  { \"FP\",\t13},\t\t\t\t\t\t\t\\\n+  { \"R14\",\t14},\t\t\t\t\t\t\t\\\n+  { \"R15\",\t15},\t\t\t\t\t\t\t\\\n+  { \"acc0\",\t16},\t\t\t\t\t\t\t\\\n+  { \"sp\",\t12}, /* ABI stack pointer */\t\t\t\t\\\n+  { \"ln\",\t13}, /* arch link register */\t\t\t\t\\\n+  { \"ptr\",\t14}, /* arch constant pointer */\t\t\t\\\n+  { \"rc\",\t15}, /* arch constant register */\t\t\t\\\n+  { \"rz\",\t15}, /* arch zero */\t\t\t\t\t\\\n+}\n+\n+/* Final prescan insn is called just before an instruction is\n+   output.  In our case, we use this to detect the VLIW slot to which\n+   the instruction has been assigned, preparatory to generating the\n+   VLIW output in ASM_OUTPUT_OPCODE. */\n+#define FINAL_PRESCAN_INSN(insn, operand, nop) \\\n+  picochip_final_prescan_insn (insn, operand,nop)\n+\n+#define ASM_OUTPUT_OPCODE(FILE,PTR) \\\n+  { PTR = picochip_asm_output_opcode(FILE, PTR); }\n+\n+#define PRINT_OPERAND(STREAM,X,CODE) \\\n+  picochip_print_operand(STREAM, X, CODE)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(code) \\\n+  (((code) == '|') || ((code) == '#') || ((code) == '>'))\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM,X) \\\n+  picochip_print_operand_address(STREAM,X)\n+\n+/* Output of Dispatch Tables  */\n+\n+/* Initialise a data memory location to an absolute code label.  Used\n+   for building switch statement jump tables.  Note - the format of the\n+   label must match that of the function picochip_output_label. */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(stream, value) \\\n+  fprintf (stream, \".initWord _L%d\\n\", value);\n+\n+/* Assembler Commands for Alignment  */\n+\n+#define ASM_OUTPUT_SKIP(STREAM,BYTES) \\\n+  fprintf(STREAM, \".skip %u\\n\", BYTES);\n+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \\\n+  fprintf(STREAM, \".align %u\\n\", 1 << POWER);\n+\n+/* The elaborator doesn't output zero bytes in the text section. */\n+#define ASM_NO_SKIP_IN_TEXT 1\n+\f\n+/* Controlling Debugging Information Format  */\n+\n+/* Macros Affecting All Debugging Formats  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+#define DWARF2_DEBUGGING_INFO\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+#define DWARF2_FRAME_INFO 1\n+\n+/* Generate .file/.loc directives, so that the assembler generates the\n+   line table. */\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+\f\n+/* Miscellaneous Parameters  */\n+\n+#define CASE_VECTOR_MODE HImode\n+#define WORD_REGISTER_OPERATIONS\n+#define LOAD_EXTEND_OP(MODE) ((MODE) == QImode ? SIGN_EXTEND : ZERO_EXTEND)\n+#define MOVE_MAX 4\n+#define SHIFT_COUNT_TRUNCATED 1\n+#define Pmode HImode\n+#define FUNCTION_MODE QImode\n+#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC) 1\n+\n+#define ASM_LONG \":TODO:.word\\t\"\n+\n+/* Define builtins for selected special-purpose instructions. */\n+enum picochip_builtins\n+{\n+  PICOCHIP_BUILTIN_SBC,\n+  PICOCHIP_BUILTIN_PUT,\n+  PICOCHIP_BUILTIN_GET,\n+  PICOCHIP_BUILTIN_TESTPORT,\n+  PICOCHIP_BUILTIN_COPYSW,\n+  PICOCHIP_BUILTIN_ADDS,\n+  PICOCHIP_BUILTIN_SUBS,\n+  PICOCHIP_BUILTIN_BREV,\n+  PICOCHIP_BUILTIN_BYTESWAP,\n+  PICOCHIP_BUILTIN_GET_ARRAY,\n+  PICOCHIP_BUILTIN_PUT_ARRAY,\n+  PICOCHIP_BUILTIN_TESTPORT_ARRAY,\n+  PICOCHIP_BUILTIN_ASRI,\n+  PICOCHIP_BUILTIN_PROFILE,\n+  PICOCHIP_BUILTIN_HALT\n+};\n+\n+#define NO_DOT_IN_LABEL 1\n+\n+/* The assembler does support LEB128, despite the auto-configure test\n+   not detecting this. */\n+#define HAVE_AS_LEB128 1\n+\n+/* The End */"}, {"sha": "3fe66526eaa5bb5a8bd91dca802e78069789c60f", "filename": "config/picochip/picochip.md", "status": "added", "additions": 2699, "deletions": 0, "changes": 2699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fpicochip.md?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244"}, {"sha": "0e4bc4e2fce201c8cd5207fa7fe4513b9cb02e6f", "filename": "config/picochip/picochip.opt", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpicochip.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fpicochip.opt?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,48 @@\n+; Options for the picoChip port of the compiler.\n+\n+; Copyright (C) 2008 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+mae=\n+Target RejectNegative Joined Var(picochip_ae_type_string)\n+Specify which type of AE to target. This option sets the mul-type\n+and byte-access.\n+\n+mmul-type=\n+Target RejectNegative Undocumented Joined Var(picochip_mul_type_string)\n+Specify which type of multiplication to use. Can be mem, mac or none.\n+\n+mbyte-access\n+Target Undocumented Var(picochip_has_byte_access,1) Init(1)\n+Specify whether the byte access instructions should be used. Enabled by default.\n+\n+mdebug\n+Target RejectNegative Undocumented Mask(DEBUG)\n+Enable debug output to be generated.\n+\n+msymbol-as-address\n+Target Mask(SYMBOL_AS_ADDRESS)\n+Allow a symbol value to be used as an immediate value in an\n+instruction.\n+\n+minefficient-warnings\n+Target Mask(INEFFICIENT_WARNINGS)\n+Generate warnings when inefficient code is known to be generated.\n+\n+minefficient\n+Target Mask(INEFFICIENT_WARNINGS) MaskExists Undocumented"}, {"sha": "b69439d39f234213b90ab3fa0ab516dc4d5f4c3a", "filename": "config/picochip/predicates.md", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Fpredicates.md?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,72 @@\n+;; GCC machine description for picochip\n+;; Copyright (C) 2008 Free Software Foundation, Inc.\n+;; Contributed by picoChip Designs Ltd (http://www.picochip.com)\n+;; Maintained by Daniel Towner (dant@picochip.com) and Hariharan\n+;; Sandanagobalane (hariharan@picochip.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not, see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_predicate \"picochip_register_or_immediate_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"immediate_operand\")))\n+\n+(define_predicate \"power_of_2_imm_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (exact_log2 (INTVAL (op)) <= 16 && exact_log2 (INTVAL (op)) > 0)\n+        return 1;\n+    }\n+\n+  return 0;\n+})\n+\n+;; Limit the comparison operators to a selected subset.\n+(define_predicate \"picochip_supported_comparison_operator\"\n+  (and (match_operand 0 \"comparison_operator\")\n+       (match_code \"ne,eq,ge,geu,lt,ltu\")))\n+(define_predicate \"picochip_peephole_comparison_operator\"\n+  (and (match_operand 0 \"comparison_operator\")\n+       (match_code \"ne,eq\")))\n+\n+;; Allow selected arithmetic operators to apply a shift to their first\n+;; operands\n+\n+(define_predicate \"picochip_first_op_shift_operator\"\n+  (match_code \"and,plus,minus,ior,xor\"))\n+\n+;; The same as the previous predicate, but only allowing those\n+;; operators which can accept an immediate.\n+(define_predicate \"picochip_first_op_shift_operator_imm\"\n+  (match_code \"plus,minus\"))\n+\n+;; Predicate on a J type integer.\n+(define_predicate \"picochip_J_operand\"\n+  (match_operand 0 \"immediate_operand\")\n+  {\n+    return (CONST_INT == GET_CODE(op) &&\n+            picochip_const_ok_for_letter_p (INTVAL(op), 'J'));\n+  })\n+\n+;; Is the operand suitable for use in a compare?\n+\n+(define_predicate \"picochip_comparison_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_operand 0 \"immediate_operand\")\n+            (match_test \"picochip_const_ok_for_letter_p(INTVAL(op), 'O')\"))))\n+"}, {"sha": "db96a6ed5f98b8c7d29977ed86ec32cbf3090d5b", "filename": "config/picochip/t-picochip", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Ft-picochip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/config%2Fpicochip%2Ft-picochip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fpicochip%2Ft-picochip?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -0,0 +1,62 @@\n+# Compile the extra library functions.\n+\n+LIB2FUNCS_EXTRA = \\\n+\t$(srcdir)/config/picochip/libgccExtras/ashrsi3.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/ashlsi3.asm\t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/divmodhi4.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/udivmodhi4.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/divmodsi4.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/udivmodsi4.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/divmod15.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/ucmpsi2.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/cmpsi2.asm \t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/clzsi2.asm\t\t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/adddi3.asm\t\t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/subdi3.asm\t\t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/lshrsi3.asm\t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/parityhi2.asm\t\t\\\n+\t$(srcdir)/config/picochip/libgccExtras/popcounthi2.asm\n+\n+# Prevent some of the more complicated libgcc functions from being\n+# compiled. This is because they are generally too big to fit into an\n+# AE anyway, so there is no point in having them. Also, some don't\n+# compile properly so we'll ignore them for the moment.\n+\n+LIB1ASMFUNCS = _mulsc3 _divsc3\n+LIB1ASMSRC = picochip/libgccExtras/fake_libgcc.asm\n+\n+# Turn off the building of exception handling libraries.\n+LIB2ADDEH =\n+LIB2ADDEHDEP =\n+\n+# Turn off ranlib on target libraries.\n+RANLIB_FOR_TARGET = cat\n+\n+# Special libgcc setup. Make single/double floating point the same,\n+# and use our own include files.\n+TARGET_LIBGCC2_CFLAGS = -DDF=SF -I../../includes/\n+\n+# Switch off all debugging for the embedded libraries.\n+# (embedded processors need small libraries by default).\n+# NOTE: If the debug level is increased, turn off instruction scheduling.\n+LIBGCC2_DEBUG_CFLAGS = -g0\n+\n+# Build all combinations of library for different multiply units, and\n+# presence/absence of byte access.\n+MULTILIB_OPTIONS = mmul-type=none/mmul-type=mac/mmul-type=mul mno-byte-access/mbyte-access\n+\n+# Using a mul unit (currently) implies that byte access is available.\n+MULTILIB_EXCEPTIONS = mmul-type=mul/mno-byte-access\n+\n+# We want fine grained libraries, so use the new code\n+# to build the floating point emulation libraries.\n+FPBIT = fp-bit.c\n+\n+# Software floating point support. Floating point is not properly\n+# supported, but is existence can be useful for some types of testing.\n+fp-bit.c:\t$(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#define FLOAT_ONLY' >> fp-bit.c\n+\techo '#define SMALL_MACHINE' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+"}, {"sha": "5f6fe227ec97e16f556bb0d7c98e5c84e17b6421", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -1,3 +1,13 @@\n+2008-09-03  Hari Sandanagobalane  <hariharan@picochip.com>\n+\n+\tAdd picoChip port.\n+\t* doc/extend.texi: Document picoChip builtin functions.\n+\t* doc/invoke.texi: Document picoChip options.\n+\t* doc/contrib.texi: Add picoChip contribution.\n+\t* doc/md.texi: Document picoChip constraints.\n+\t* config.gcc: Add picochip-*-*.\n+\t* config/picochip/: Add new port.\n+\n 2008-09-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37328"}, {"sha": "22bca4d57a1858ba6e0b029ceae611b68cc3f541", "filename": "gcc/config.gcc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -329,6 +329,9 @@ mips*-*-*)\n \tneed_64bit_hwint=yes\n \textra_headers=\"loongson.h\"\n \t;;\n+picochip-*-*)\n+        cpu_type=picochip\n+        ;;\n powerpc*-*-*)\n \tcpu_type=rs6000\n \textra_headers=\"ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h\"\n@@ -1707,6 +1710,9 @@ pdp11-*-bsd)\n         ;;\n pdp11-*-*)\n \t;;\n+picochip-*)\n+        # Nothing special\n+        ;;\n # port not yet contributed\n #powerpc-*-openbsd*)\n #\ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-fprules-fpbit \""}, {"sha": "2ae03c9a96605473d8d41d32334d7a0cfd7dde1d", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -917,6 +917,10 @@ Teemu Torma for thread safe exception handling support.\n Leonard Tower wrote parts of the parser, RTL generator, and RTL\n definitions, and of the VAX machine description.\n \n+@item \n+Daniel Towner and Hariharan Sandanagobalane contributed and \n+maintain the picoChip port.\n+\n @item\n Tom Tromey for internationalization support and for his many Java\n contributions and libgcj maintainership."}, {"sha": "21debf746791154536800fd319951dd8fdd4968f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -6985,6 +6985,7 @@ instructions, but allow the compiler to schedule those calls.\n * MIPS DSP Built-in Functions::\n * MIPS Paired-Single Support::\n * MIPS Loongson Built-in Functions::\n+* picoChip Built-in Functions::\n * PowerPC AltiVec Built-in Functions::\n * SPARC VIS Built-in Functions::\n * SPU Built-in Functions::\n@@ -9403,6 +9404,42 @@ else\n @end smallexample\n @end table\n \n+@node picoChip Built-in Functions\n+@subsection picoChip Built-in Functions\n+\n+GCC provides an interface to selected machine instructions from the\n+picoChip instruction set.\n+\n+@table @code\n+@item int __builtin_sbc (int @var{value})\n+Sign bit count.  Return the number of consecutive bits in @var{value}\n+which have the same value as the sign-bit.  The result is the number of\n+leading sign bits minus one, giving the number of redundant sign bits in\n+@var{value}.\n+\n+@item int __builtin_byteswap (int @var{value})\n+Byte swap.  Return the result of swapping the upper and lower bytes of\n+@var{value}.\n+\n+@item int __builtin_brev (int @var{value})\n+Bit reversal.  Return the result of reversing the bits in\n+@var{value}.  Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1,\n+and so on.\n+\n+@item int __builtin_adds (int @var{x}, int @var{y})\n+Saturating addition.  Return the result of adding @var{x} and @var{y},\n+storing the value 32767 if the result overflows.\n+\n+@item int __builtin_subs (int @var{x}, int @var{y})\n+Saturating subtraction.  Return the result of subtracting @var{y} from\n+@var{x}, storing the value -32768 if the result overflows.\n+\n+@item void __builtin_halt (void)\n+Halt.  The processor will stop execution.  This built-in is useful for\n+implementing assertions.\n+\n+@end table\n+\n @node PowerPC AltiVec Built-in Functions\n @subsection PowerPC AltiVec Built-in Functions\n "}, {"sha": "2b2ebc85aef0fd2da41b2981da1462aa343855b3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -691,6 +691,10 @@ Objective-C and Objective-C++ Dialects}.\n -mbranch-expensive  -mbranch-cheap @gol\n -msplit  -mno-split  -munix-asm  -mdec-asm}\n \n+@emph{picoChip Options}\n+@gccoptlist{-mae=@var{ae_type} -mvliw-lookahead=@var{N}\n+-msymbol-as-address -mno-inefficient-warnings}\n+\n @emph{PowerPC Options}\n See RS/6000 and PowerPC Options.\n \n@@ -8603,6 +8607,7 @@ platform.\n * MMIX Options::\n * MN10300 Options::\n * PDP-11 Options::\n+* picoChip Options::\n * PowerPC Options::\n * RS/6000 and PowerPC Options::\n * S/390 and zSeries Options::\n@@ -13095,6 +13100,54 @@ Use DEC assembler syntax.  This is the default when configured for any\n PDP-11 target other than @samp{pdp11-*-bsd}.\n @end table\n \n+@node picoChip Options\n+@subsection picoChip Options\n+@cindex picoChip options\n+\n+These @samp{-m} options are defined for picoChip implementations:\n+\n+@table @gcctabopt\n+\n+@item -mae=@var{ae_type}\n+@opindex mcpu\n+Set the instruction set, register set, and instruction scheduling\n+parameters for array element type @var{ae_type}.  Supported values\n+for @var{ae_type} are @samp{ANY}, @samp{MUL}, and @samp{MAC}.\n+\n+@option{-mae=ANY} selects a completely generic AE type.  Code\n+generated with this option will run on any of the other AE types.  The\n+code will not be as efficient as it would be if compiled for a specific\n+AE type, and some types of operation (e.g., multiplication) will not\n+work properly on all types of AE.\n+\n+@option{-mae=MUL} selects a MUL AE type.  This is the most useful AE type\n+for compiled code, and is the default.\n+\n+@option{-mae=MAC} selects a DSP-style MAC AE.  Code compiled with this\n+option may suffer from poor performance of byte (char) manipulation,\n+since the DSP AE does not provide hardware support for byte load/stores.\n+\n+@item -msymbol-as-address\n+Enable the compiler to directly use a symbol name as an address in a\n+load/store instruction, without first loading it into a\n+register.  Typically, the use of this option will generate larger\n+programs, which run faster than when the option isn't used.  However, the\n+results vary from program to program, so it is left as a user option,\n+rather than being permanently enabled.\n+\n+@item -mno-inefficient-warnings\n+Disables warnings about the generation of inefficient code.  These\n+warnings can be generated, for example, when compiling code which\n+performs byte-level memory operations on the MAC AE type.  The MAC AE has\n+no hardware support for byte-level memory operations, so all byte\n+load/stores must be synthesised from word load/store operations.  This is\n+inefficient and a warning will be generated indicating to the programmer\n+that they should rewrite the code to avoid byte operations, or to target\n+an AE type which has the necessary hardware support.  This option enables\n+the warning to be turned off.\n+\n+@end table\n+\n @node PowerPC Options\n @subsection PowerPC Options\n @cindex PowerPC options"}, {"sha": "528c6a1c34f6db7ccc2c70bb7a6b7f530c253236", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -1855,6 +1855,46 @@ A memory operand for floating-point loads and stores\n A register indirect memory operand\n @end table\n \n+@item picoChip family---@file{picochip.h}\n+@table @code\n+@item k\n+Stack register.\n+\n+@item f\n+Pointer register.  A register which can be used to access memory without\n+supplying an offset.  Any other register can be used to access memory,\n+but will need a constant offset.  In the case of the offset being zero,\n+it is more efficient to use a pointer register, since this reduces code\n+size.\n+\n+@item t\n+A twin register.  A register which may be paired with an adjacent\n+register to create a 32-bit register.\n+\n+@item a\n+Any absolute memory address (e.g., symbolic constant, symbolic\n+constant + offset).\n+\n+@item I\n+4-bit signed integer.\n+\n+@item J\n+4-bit unsigned integer.\n+\n+@item K\n+8-bit signed integer.\n+\n+@item M\n+Any constant whose absolute value is no greater than 4-bits.\n+\n+@item N\n+10-bit signed integer\n+\n+@item O\n+16-bit signed integer.\n+\n+@end table\n+\n @item PowerPC and IBM RS6000---@file{config/rs6000/rs6000.h}\n @table @code\n @item b"}, {"sha": "5fc628b6840fcafb0d52160006ca8daf870ac0c1", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -1,3 +1,8 @@\n+2008-09-03  Hari Sandanagobalane  <hariharan@picochip.com>\n+\n+\tAdd picoChip port.\n+\t* config.host: Add picochip-*-*.\n+\n 2008-08-06  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config.host: Match more processor names for Xtensa."}, {"sha": "cf33e04de443c10e662fce10a6d6c977079d4e54", "filename": "libgcc/config.host", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358da97e4e90811bbfbe26d60f142e7ebc9a2244/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358da97e4e90811bbfbe26d60f142e7ebc9a2244/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=358da97e4e90811bbfbe26d60f142e7ebc9a2244", "patch": "@@ -428,6 +428,8 @@ pdp11-*-bsd)\n         ;;\n pdp11-*-*)\n \t;;\n+picochip-*-*)\n+        ;;\n powerpc64-*-linux*)\n \ttmake_file=\"${tmake_file} rs6000/t-ppccomm rs6000/t-ldbl128\"\n \t;;"}]}