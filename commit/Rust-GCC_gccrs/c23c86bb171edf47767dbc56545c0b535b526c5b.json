{"sha": "c23c86bb171edf47767dbc56545c0b535b526c5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIzYzg2YmIxNzFlZGY0Nzc2N2RiYzU2NTQ1YzBiNTM1YjUyNmM1Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T09:51:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T09:51:24Z"}, "message": "[multiple changes]\n\n2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb, sem_ch7.adb, sem_util.adb, g-debpoo.adb, sem_ch4.adb,\n\tsem_ch6.adb, sem_ch8.adb: Minor reformatting.\n\t* exp_util.adb (Is_Source_Object): Account for\n\tthe cases where the source object may appear as a dereference\n\tor within a type conversion.\n\t* exp_ch6.adb: Fix missing space in error message.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb: Update description of Eliminate.\n\nFrom-SVN: r251762", "tree": {"sha": "a55fd8a82fe22b7605e7c9fe9025fbb807d74577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a55fd8a82fe22b7605e7c9fe9025fbb807d74577"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c23c86bb171edf47767dbc56545c0b535b526c5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23c86bb171edf47767dbc56545c0b535b526c5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c23c86bb171edf47767dbc56545c0b535b526c5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23c86bb171edf47767dbc56545c0b535b526c5b/comments", "author": null, "committer": null, "parents": [{"sha": "6376a3c640009ed25a250d677fc7ff0fdd0a2c1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6376a3c640009ed25a250d677fc7ff0fdd0a2c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6376a3c640009ed25a250d677fc7ff0fdd0a2c1c"}], "stats": {"total": 553, "additions": 293, "deletions": 260}, "files": [{"sha": "5667112694db844104c3d14e87a5db6b0fd01f6b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -1,3 +1,17 @@\n+2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb, sem_ch7.adb, sem_util.adb, g-debpoo.adb, sem_ch4.adb,\n+\tsem_ch6.adb, sem_ch8.adb: Minor reformatting.\n+\t* exp_util.adb (Is_Source_Object): Account for\n+\tthe cases where the source object may appear as a dereference\n+\tor within a type conversion.\n+\t* exp_ch6.adb: Fix missing space in error message.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb: Update description of Eliminate.\n+\n+\n 2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_attr.adb (Analyze_Attribute, case 'Loop_Entry): Handle"}, {"sha": "3101b7c35c19f980bb1ab307201bd75a8e53fc37", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -3515,7 +3515,7 @@ package body Exp_Ch6 is\n                elsif Etype (Call_Node) /= Root_Type (Etype (Name (Ass))) then\n                   Error_Msg_NE\n                     (\"tag-indeterminate expression must have type&\"\n-                     & \"(RM 5.2 (6))\",\n+                     & \" (RM 5.2 (6))\",\n                      Call_Node, Root_Type (Etype (Name (Ass))));\n \n                else"}, {"sha": "7f7bc0bd977f7327f6439615f8cf92d3829b8e4e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -7648,11 +7648,12 @@ package body Exp_Util is\n       ----------------------\n \n       function Is_Displace_Call (N : Node_Id) return Boolean is\n-         Call : Node_Id := N;\n+         Call : Node_Id;\n \n       begin\n          --  Strip various actions which may precede a call to Displace\n \n+         Call := N;\n          loop\n             if Nkind (Call) = N_Explicit_Dereference then\n                Call := Prefix (Call);\n@@ -7678,12 +7679,31 @@ package body Exp_Util is\n       ----------------------\n \n       function Is_Source_Object (N : Node_Id) return Boolean is\n+         Obj : Node_Id;\n+\n       begin\n+         --  Strip various actions which may be associated with the object\n+\n+         Obj := N;\n+         loop\n+            if Nkind (Obj) = N_Explicit_Dereference then\n+               Obj := Prefix (Obj);\n+\n+            elsif Nkind_In (Obj, N_Type_Conversion,\n+                                 N_Unchecked_Type_Conversion)\n+            then\n+               Obj := Expression (Obj);\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n          return\n-           Present (N)\n-             and then Nkind (N) in N_Has_Entity\n-             and then Is_Object (Entity (N))\n-             and then Comes_From_Source (N);\n+           Present (Obj)\n+             and then Nkind (Obj) in N_Has_Entity\n+             and then Is_Object (Entity (Obj))\n+             and then Comes_From_Source (Obj);\n       end Is_Source_Object;\n \n       --  Local variables"}, {"sha": "9934e6185e43f1f097dd1fbb52ce6b0ff1734e52", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 79, "deletions": 71, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -389,13 +389,13 @@ package body GNAT.Debug_Pools is\n \n    type Scope_Lock is\n      new Ada.Finalization.Limited_Controlled with null record;\n-   --  to handle Lock_Task/Unlock_Task calls\n+   --  Used to handle Lock_Task/Unlock_Task calls\n \n    overriding procedure Initialize (This : in out Scope_Lock);\n-   --  lock task on initialization\n+   --  Lock task on initialization\n \n    overriding procedure Finalize   (This : in out Scope_Lock);\n-   --  unlock task on finalization\n+   --  Unlock task on finalization\n \n    ----------------\n    -- Initialize --\n@@ -431,11 +431,13 @@ package body GNAT.Debug_Pools is\n    -- Header_Of --\n    ---------------\n \n-   function Header_Of (Address : System.Address)\n-     return Allocation_Header_Access\n+   function Header_Of\n+     (Address : System.Address) return Allocation_Header_Access\n    is\n-      function Convert is new Ada.Unchecked_Conversion\n-        (System.Address, Allocation_Header_Access);\n+      function Convert is\n+        new Ada.Unchecked_Conversion\n+                  (System.Address,\n+                   Allocation_Header_Access);\n    begin\n       return Convert (Address - Header_Offset);\n    end Header_Of;\n@@ -457,7 +459,8 @@ package body GNAT.Debug_Pools is\n    ----------\n \n    function Next\n-     (E : Traceback_Htable_Elem_Ptr) return Traceback_Htable_Elem_Ptr is\n+     (E : Traceback_Htable_Elem_Ptr) return Traceback_Htable_Elem_Ptr\n+   is\n    begin\n       return E.Next;\n    end Next;\n@@ -1366,6 +1369,7 @@ package body GNAT.Debug_Pools is\n       procedure Reset_Marks is\n          Current : System.Address := Pool.First_Free_Block;\n          Header  : Allocation_Header_Access;\n+\n       begin\n          while Current /= System.Null_Address loop\n             Header := Header_Of (Current);\n@@ -1377,10 +1381,9 @@ package body GNAT.Debug_Pools is\n       Lock : Scope_Lock;\n       pragma Unreferenced (Lock);\n \n-      --  Start of processing for Free_Physically\n+   --  Start of processing for Free_Physically\n \n    begin\n-\n       if Pool.Advanced_Scanning then\n \n          --  Reset the mark for each freed block\n@@ -1393,15 +1396,14 @@ package body GNAT.Debug_Pools is\n       Free_Blocks (Ignore_Marks => not Pool.Advanced_Scanning);\n \n       --  The contract is that we need to free at least Minimum_To_Free bytes,\n-      --  even if this means freeing marked blocks in the advanced scheme\n+      --  even if this means freeing marked blocks in the advanced scheme.\n \n       if Total_Freed < Pool.Minimum_To_Free\n         and then Pool.Advanced_Scanning\n       then\n          Pool.Marked_Blocks_Deallocated := True;\n          Free_Blocks (Ignore_Marks => True);\n       end if;\n-\n    end Free_Physically;\n \n    --------------\n@@ -1411,19 +1413,19 @@ package body GNAT.Debug_Pools is\n    procedure Get_Size\n      (Storage_Address          : Address;\n       Size_In_Storage_Elements : out Storage_Count;\n-      Valid                    : out Boolean) is\n-\n+      Valid                    : out Boolean)\n+   is\n       Lock : Scope_Lock;\n       pragma Unreferenced (Lock);\n \n    begin\n-\n       Valid := Is_Valid (Storage_Address);\n \n       if Is_Valid (Storage_Address) then\n          declare\n-            Header   : constant Allocation_Header_Access :=\n-              Header_Of (Storage_Address);\n+            Header : constant Allocation_Header_Access :=\n+                       Header_Of (Storage_Address);\n+\n          begin\n             if Header.Block_Size >= 0 then\n                Valid := True;\n@@ -1435,7 +1437,6 @@ package body GNAT.Debug_Pools is\n       else\n          Valid := False;\n       end if;\n-\n    end Get_Size;\n \n    ---------------------\n@@ -1445,7 +1446,8 @@ package body GNAT.Debug_Pools is\n    procedure Print_Traceback\n      (Output_File : File_Type;\n       Prefix      : String;\n-      Traceback   : Traceback_Htable_Elem_Ptr) is\n+      Traceback   : Traceback_Htable_Elem_Ptr)\n+   is\n    begin\n       if Traceback /= null then\n          Put (Output_File, Prefix);\n@@ -1466,9 +1468,10 @@ package body GNAT.Debug_Pools is\n       pragma Unreferenced (Alignment);\n \n       Header   : constant Allocation_Header_Access :=\n-        Header_Of (Storage_Address);\n-      Valid    : Boolean;\n+                   Header_Of (Storage_Address);\n       Previous : System.Address;\n+      Valid    : Boolean;\n+\n       Header_Block_Size_Was_Less_Than_0 : Boolean := True;\n \n    begin\n@@ -1477,16 +1480,17 @@ package body GNAT.Debug_Pools is\n       declare\n          Lock : Scope_Lock;\n          pragma Unreferenced (Lock);\n+\n       begin\n          Valid := Is_Valid (Storage_Address);\n \n          if Valid and then not (Header.Block_Size < 0) then\n             Header_Block_Size_Was_Less_Than_0 := False;\n \n             --  Some sort of codegen problem or heap corruption caused the\n-            --  Size_In_Storage_Elements to be wrongly computed.\n-            --  The code below is all based on the assumption that Header.all\n-            --  is not corrupted, such that the error is non-fatal.\n+            --  Size_In_Storage_Elements to be wrongly computed. The code\n+            --  below is all based on the assumption that Header.all is not\n+            --  corrupted, such that the error is non-fatal.\n \n             if Header.Block_Size /= Size_In_Storage_Elements and then\n               Size_In_Storage_Elements /= Storage_Count'Last\n@@ -1591,11 +1595,9 @@ package body GNAT.Debug_Pools is\n             --  Do not physically release the memory here, but in Alloc.\n             --  See comment there for details.\n          end if;\n-\n       end;\n \n       if not Valid then\n-\n          if Storage_Address = System.Null_Address then\n             if Pool.Raise_Exceptions and then\n               Size_In_Storage_Elements /= Storage_Count'Last\n@@ -1611,14 +1613,15 @@ package body GNAT.Debug_Pools is\n             end if;\n          end if;\n \n-         if Allow_Unhandled_Memory and then not Is_Handled (Storage_Address)\n+         if Allow_Unhandled_Memory\n+           and then not Is_Handled (Storage_Address)\n          then\n             System.CRTL.free (Storage_Address);\n             return;\n          end if;\n \n-         if Pool.Raise_Exceptions and then\n-           Size_In_Storage_Elements /= Storage_Count'Last\n+         if Pool.Raise_Exceptions\n+           and then Size_In_Storage_Elements /= Storage_Count'Last\n          then\n             raise Freeing_Not_Allocated_Storage;\n          else\n@@ -1630,7 +1633,6 @@ package body GNAT.Debug_Pools is\n          end if;\n \n       elsif Header_Block_Size_Was_Less_Than_0 then\n-\n          if Pool.Raise_Exceptions then\n             raise Freeing_Deallocated_Storage;\n          else\n@@ -1645,9 +1647,7 @@ package body GNAT.Debug_Pools is\n             Print_Traceback (Output_File (Pool), \"   Memory was allocated at \",\n                              Header.Alloc_Traceback);\n          end if;\n-\n       end if;\n-\n    end Deallocate;\n \n    --------------------\n@@ -1750,7 +1750,6 @@ package body GNAT.Debug_Pools is\n       Display_Slots : Boolean := False;\n       Display_Leaks : Boolean := False)\n    is\n-\n       package Backtrace_Htable_Cumulate is new GNAT.HTable.Static_HTable\n         (Header_Num => Header,\n          Element    => Traceback_Htable_Elem,\n@@ -1764,9 +1763,9 @@ package body GNAT.Debug_Pools is\n          Equal      => Equal);\n       --  This needs a comment ??? probably some of the ones below do too???\n \n+      Current : System.Address;\n       Data    : Traceback_Htable_Elem_Ptr;\n       Elem    : Traceback_Htable_Elem_Ptr;\n-      Current : System.Address;\n       Header  : Allocation_Header_Access;\n       K       : Traceback_Kind;\n \n@@ -1805,13 +1804,13 @@ package body GNAT.Debug_Pools is\n             if Data.Kind in Alloc .. Dealloc then\n                Elem :=\n                  new Traceback_Htable_Elem'\n-                      (Traceback => new Tracebacks_Array'(Data.Traceback.all),\n-                       Count       => Data.Count,\n-                       Kind        => Data.Kind,\n-                       Total       => Data.Total,\n-                       Frees       => Data.Frees,\n-                       Total_Frees => Data.Total_Frees,\n-                       Next        => null);\n+                       (Traceback => new Tracebacks_Array'(Data.Traceback.all),\n+                        Count       => Data.Count,\n+                        Kind        => Data.Kind,\n+                        Total       => Data.Total,\n+                        Frees       => Data.Frees,\n+                        Total_Frees => Data.Total_Frees,\n+                        Next        => null);\n                Backtrace_Htable_Cumulate.Set (Elem);\n \n                if Cumulate then\n@@ -1828,15 +1827,18 @@ package body GNAT.Debug_Pools is\n                      --  If not, insert it\n \n                      if Elem = null then\n-                        Elem := new Traceback_Htable_Elem'\n-                          (Traceback => new Tracebacks_Array'\n-                             (Data.Traceback (T .. Data.Traceback'Last)),\n-                           Count       => Data.Count,\n-                           Kind        => K,\n-                           Total       => Data.Total,\n-                           Frees       => Data.Frees,\n-                           Total_Frees => Data.Total_Frees,\n-                           Next        => null);\n+                        Elem :=\n+                          new Traceback_Htable_Elem'\n+                                (Traceback =>\n+                                   new Tracebacks_Array'\n+                                         (Data.Traceback\n+                                           (T .. Data.Traceback'Last)),\n+                                 Count       => Data.Count,\n+                                 Kind        => K,\n+                                 Total       => Data.Total,\n+                                 Frees       => Data.Frees,\n+                                 Total_Frees => Data.Total_Frees,\n+                                 Next        => null);\n                         Backtrace_Htable_Cumulate.Set (Elem);\n \n                         --  Properly take into account that the subprograms\n@@ -1924,11 +1926,15 @@ package body GNAT.Debug_Pools is\n    procedure Dump\n      (Pool   : Debug_Pool;\n       Size   : Positive;\n-      Report : Report_Type := All_Reports) is\n-\n+      Report : Report_Type := All_Reports)\n+   is\n       procedure Do_Report (Sort : Report_Type);\n       --  Do a specific type of report\n \n+      ---------------\n+      -- Do_Report --\n+      ---------------\n+\n       procedure Do_Report (Sort : Report_Type) is\n          Elem        : Traceback_Htable_Elem_Ptr;\n          Bigger      : Boolean;\n@@ -1991,7 +1997,6 @@ package body GNAT.Debug_Pools is\n          end;\n \n          while Elem /= null loop\n-\n             declare\n                Lock : Scope_Lock;\n                pragma Unreferenced (Lock);\n@@ -2005,13 +2010,13 @@ package body GNAT.Debug_Pools is\n                --  gain speed.\n \n                if (Sort = Memory_Usage\n-                   and then Elem_Safe.Total - Elem_Safe.Total_Frees >= 1_000)\n+                    and then Elem_Safe.Total - Elem_Safe.Total_Frees >= 1_000)\n                  or else (Sort = Allocations_Count\n-                          and then Elem_Safe.Count - Elem_Safe.Frees >= 1)\n+                           and then Elem_Safe.Count - Elem_Safe.Frees >= 1)\n                  or else (Sort = Sort_Total_Allocs\n-                          and then Elem_Safe.Count > 1)\n+                           and then Elem_Safe.Count > 1)\n                  or else (Sort = Marked_Blocks\n-                          and then Elem_Safe.Total = 0)\n+                           and then Elem_Safe.Total = 0)\n                then\n                   if Sort = Marked_Blocks then\n                      Grand_Total := Grand_Total + Float (Elem_Safe.Count);\n@@ -2020,7 +2025,6 @@ package body GNAT.Debug_Pools is\n                   for M in Max'Range loop\n                      Bigger := Max (M) = null;\n                      if not Bigger then\n-\n                         declare\n                            Lock : Scope_Lock;\n                            pragma Unreferenced (Lock);\n@@ -2063,7 +2067,6 @@ package body GNAT.Debug_Pools is\n             begin\n                Elem := Backtrace_Htable.Get_Next;\n             end;\n-\n          end loop;\n \n          if Grand_Total = 0.0 then\n@@ -2074,10 +2077,11 @@ package body GNAT.Debug_Pools is\n             exit when Max (M) = null;\n             declare\n                type Percent is delta 0.1 range 0.0 .. 100.0;\n+\n+               P     : Percent;\n                Total : Byte_Count;\n-               P : Percent;\n-            begin\n \n+            begin\n                declare\n                   Lock : Scope_Lock;\n                   pragma Unreferenced (Lock);\n@@ -2104,6 +2108,7 @@ package body GNAT.Debug_Pools is\n                   --  In multi tasking configuration, memory deallocations\n                   --  during Do_Report processing can lead to Total >\n                   --  Grand_Total. As Percent requires Total <= Grand_Total\n+\n                begin\n                   if Normalized_Total > Grand_Total then\n                      P := 100.0;\n@@ -2113,17 +2118,22 @@ package body GNAT.Debug_Pools is\n                end;\n \n                case Sort is\n-                  when Memory_Usage | Allocations_Count | All_Reports =>\n+                  when All_Reports\n+                     | Allocations_Count\n+                     | Memory_Usage\n+                  =>\n                      declare\n                         Count : constant Natural :=\n                           Max_M_Safe.Count - Max_M_Safe.Frees;\n                      begin\n                         Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n                              & Count'Img & \" chunks at\");\n                      end;\n+\n                   when Sort_Total_Allocs =>\n                      Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n                           & Max_M_Safe.Count'Img & \" chunks at\");\n+\n                   when Marked_Blocks =>\n                      Put (P'Img & \"%:\"\n                           & Max_M_Safe.Count'Img & \" chunks /\"\n@@ -2257,8 +2267,7 @@ package body GNAT.Debug_Pools is\n    -- High_Water_Mark --\n    ---------------------\n \n-   function High_Water_Mark\n-     (Pool : Debug_Pool) return Byte_Count is\n+   function High_Water_Mark (Pool : Debug_Pool) return Byte_Count is\n       Lock : Scope_Lock;\n       pragma Unreferenced (Lock);\n    begin\n@@ -2269,8 +2278,7 @@ package body GNAT.Debug_Pools is\n    -- Current_Water_Mark --\n    ------------------------\n \n-   function Current_Water_Mark\n-     (Pool : Debug_Pool) return Byte_Count is\n+   function Current_Water_Mark (Pool : Debug_Pool) return Byte_Count is\n       Lock : Scope_Lock;\n       pragma Unreferenced (Lock);\n    begin\n@@ -2283,7 +2291,8 @@ package body GNAT.Debug_Pools is\n    ------------------------------\n \n    procedure System_Memory_Debug_Pool\n-     (Has_Unhandled_Memory : Boolean := True) is\n+     (Has_Unhandled_Memory : Boolean := True)\n+   is\n       Lock : Scope_Lock;\n       pragma Unreferenced (Lock);\n    begin\n@@ -2329,9 +2338,9 @@ package body GNAT.Debug_Pools is\n       Header  : Allocation_Header_Access;\n \n    begin\n-      --  We might get Null_Address if the call from gdb was done\n-      --  incorrectly. For instance, doing a \"print_pool(my_var)\" passes 0x0,\n-      --  instead of passing the value of my_var\n+      --  We might get Null_Address if the call from gdb was done incorrectly.\n+      --  For instance, doing a \"print_pool(my_var)\" passes 0x0, instead of\n+      --  passing the value of my_var.\n \n       if A = System.Null_Address then\n          Put_Line\n@@ -2369,7 +2378,6 @@ package body GNAT.Debug_Pools is\n       Display_Slots : Boolean := False;\n       Display_Leaks : Boolean := False)\n    is\n-\n       procedure Internal is new Print_Info\n         (Put_Line => Stdout_Put_Line,\n          Put      => Stdout_Put);"}, {"sha": "7929f0256bd5cddb4ddc9f804b6eeb0431b7f8a8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -20785,16 +20785,16 @@ package body Sem_Ch3 is\n          --  corresponding subtype of the full view.\n \n          elsif Ekind (Priv_Dep) = E_Incomplete_Subtype\n-            and then Comes_From_Source (Priv_Dep)\n+           and then Comes_From_Source (Priv_Dep)\n          then\n             Set_Subtype_Indication\n               (Parent (Priv_Dep), New_Occurrence_Of (Full_T, Sloc (Priv_Dep)));\n             Set_Etype (Priv_Dep, Full_T);\n             Set_Ekind (Priv_Dep, Subtype_Kind (Ekind (Full_T)));\n             Set_Analyzed (Parent (Priv_Dep), False);\n \n-            --  Reanalyze the declaration, suppressing the call to\n-            --  Enter_Name to avoid duplicate names.\n+            --  Reanalyze the declaration, suppressing the call to Enter_Name\n+            --  to avoid duplicate names.\n \n             Analyze_Subtype_Declaration\n               (N    => Parent (Priv_Dep),"}, {"sha": "8952a9ef7e5a6a0c391b1fa6130355fe41bdbef8", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -2936,8 +2936,8 @@ package body Sem_Ch4 is\n \n                   Set_Etype (Alt, It.Typ);\n \n-                  --  If the alternative is an enumeration literal, use\n-                  --  the one for this interpretation.\n+                  --  If the alternative is an enumeration literal, use the one\n+                  --  for this interpretation.\n \n                   if Is_Entity_Name (Alt) then\n                      Set_Entity (Alt, It.Nam);\n@@ -2948,7 +2948,6 @@ package body Sem_Ch4 is\n                   if No (It.Typ) then\n                      Set_Is_Overloaded (Alt, False);\n                      Common_Type := Etype (Alt);\n-\n                   end if;\n \n                   Candidate_Interps := Alt;"}, {"sha": "837f390a2ef8b14e2866a20ac212e82e84a06b34", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -1468,8 +1468,7 @@ package body Sem_Ch6 is\n          --  there are various error checks that are applied on this body\n          --  when it is analyzed (e.g. correct aspect placement).\n \n-         if Has_Completion (Prev)\n-         then\n+         if Has_Completion (Prev) then\n             Error_Msg_Sloc := Sloc (Prev);\n             Error_Msg_NE (\"duplicate body for & declared#\", N, Prev);\n          end if;"}, {"sha": "1ec33951c78c3b945a2f7668342b30256a0c9352", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -1441,8 +1441,8 @@ package body Sem_Ch7 is\n \n          --  Check on incomplete types\n \n-         --  AI05-0213: A formal incomplete type has no completion,\n-         --  and neither does the corresponding subtype in an instance.\n+         --  AI05-0213: A formal incomplete type has no completion, and neither\n+         --  does the corresponding subtype in an instance.\n \n          if Is_Incomplete_Type (E)\n            and then No (Full_View (E))"}, {"sha": "ca9ac47950f97220fc13b116b259e335001a8321", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -2892,7 +2892,6 @@ package body Sem_Ch8 is\n       --  Case of Renaming_As_Body\n \n       if Present (Rename_Spec) then\n-\n          Check_Previous_Null_Procedure (N, Rename_Spec);\n \n          --  Renaming declaration is the completion of the declaration of"}, {"sha": "bfca18d87df7b1b5f8587cf54ce7b4361994640d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -14734,25 +14734,11 @@ package body Sem_Prag is\n          ---------------\n \n          --  pragma Eliminate (\n-         --      [Unit_Name  =>] IDENTIFIER | SELECTED_COMPONENT,\n-         --    [,[Entity     =>] IDENTIFIER |\n-         --                      SELECTED_COMPONENT |\n-         --                      STRING_LITERAL]\n-         --    [,                OVERLOADING_RESOLUTION]);\n-\n-         --  OVERLOADING_RESOLUTION ::= PARAMETER_AND_RESULT_TYPE_PROFILE |\n-         --                             SOURCE_LOCATION\n-\n-         --  PARAMETER_AND_RESULT_TYPE_PROFILE ::= PROCEDURE_PROFILE |\n-         --                                        FUNCTION_PROFILE\n-\n-         --  PROCEDURE_PROFILE ::= Parameter_Types => PARAMETER_TYPES\n-\n-         --  FUNCTION_PROFILE ::= [Parameter_Types => PARAMETER_TYPES,]\n-         --                       Result_Type => result_SUBTYPE_NAME]\n-\n-         --  PARAMETER_TYPES ::= (SUBTYPE_NAME {, SUBTYPE_NAME})\n-         --  SUBTYPE_NAME    ::= STRING_LITERAL\n+         --      [Unit_Name        =>] IDENTIFIER | SELECTED_COMPONENT,\n+         --      [Entity           =>] IDENTIFIER |\n+         --                            SELECTED_COMPONENT |\n+         --                            STRING_LITERAL]\n+         --      [, Source_Location => SOURCE_TRACE]);\n \n          --  SOURCE_LOCATION ::= Source_Location => SOURCE_TRACE\n          --  SOURCE_TRACE    ::= STRING_LITERAL\n@@ -14766,6 +14752,11 @@ package body Sem_Prag is\n                       Name_Result_Type,\n                       Name_Source_Location);\n \n+            --  Note : Parameter_Types and Result_Type are leftovers from\n+            --  prior implementations of the pragma. They are not generated\n+            --  by the gnatelim tool, and play no role in selecting which\n+            --  of a set of overloaded names is chosen for elimination.\n+\n             Unit_Name       : Node_Id renames Args (1);\n             Entity          : Node_Id renames Args (2);\n             Parameter_Types : Node_Id renames Args (3);"}, {"sha": "a0fcc41be375a691b43929bf1ecd5fd9fb7b8dfc", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 156, "deletions": 153, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23c86bb171edf47767dbc56545c0b535b526c5b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c23c86bb171edf47767dbc56545c0b535b526c5b", "patch": "@@ -1900,157 +1900,6 @@ package body Sem_Util is\n       end if;\n    end Cannot_Raise_Constraint_Error;\n \n-   ------------------------------------\n-   --  Check_Previous_Null_Procedure --\n-   ------------------------------------\n-\n-   procedure Check_Previous_Null_Procedure\n-     (Decl : Node_Id;\n-      Prev : Entity_Id)\n-   is\n-   begin\n-      if Ekind (Prev) = E_Procedure\n-        and then Nkind (Parent (Prev)) = N_Procedure_Specification\n-        and then Null_Present (Parent (Prev))\n-      then\n-         Error_Msg_Sloc := Sloc (Prev);\n-         Error_Msg_N\n-           (\"declaration cannot complete previous null procedure#\", Decl);\n-      end if;\n-   end Check_Previous_Null_Procedure;\n-\n-   -----------------------------\n-   -- Check_Part_Of_Reference --\n-   -----------------------------\n-\n-   procedure Check_Part_Of_Reference (Var_Id : Entity_Id; Ref : Node_Id) is\n-      Conc_Typ : constant Entity_Id := Encapsulating_State (Var_Id);\n-      Decl     : Node_Id;\n-      OK_Use   : Boolean := False;\n-      Par      : Node_Id;\n-      Prag_Nam : Name_Id;\n-      Spec_Id  : Entity_Id;\n-\n-   begin\n-      --  Traverse the parent chain looking for a suitable context for the\n-      --  reference to the concurrent constituent.\n-\n-      Par := Parent (Ref);\n-      while Present (Par) loop\n-         if Nkind (Par) = N_Pragma then\n-            Prag_Nam := Pragma_Name (Par);\n-\n-            --  A concurrent constituent is allowed to appear in pragmas\n-            --  Initial_Condition and Initializes as this is part of the\n-            --  elaboration checks for the constituent (SPARK RM 9.3).\n-\n-            if Nam_In (Prag_Nam, Name_Initial_Condition, Name_Initializes) then\n-               OK_Use := True;\n-               exit;\n-\n-            --  When the reference appears within pragma Depends or Global,\n-            --  check whether the pragma applies to a single task type. Note\n-            --  that the pragma is not encapsulated by the type definition,\n-            --  but this is still a valid context.\n-\n-            elsif Nam_In (Prag_Nam, Name_Depends, Name_Global) then\n-               Decl := Find_Related_Declaration_Or_Body (Par);\n-\n-               if Nkind (Decl) = N_Object_Declaration\n-                 and then Defining_Entity (Decl) = Conc_Typ\n-               then\n-                  OK_Use := True;\n-                  exit;\n-               end if;\n-            end if;\n-\n-         --  The reference appears somewhere in the definition of the single\n-         --  protected/task type (SPARK RM 9.3).\n-\n-         elsif Nkind_In (Par, N_Single_Protected_Declaration,\n-                              N_Single_Task_Declaration)\n-           and then Defining_Entity (Par) = Conc_Typ\n-         then\n-            OK_Use := True;\n-            exit;\n-\n-         --  The reference appears within the expanded declaration or the body\n-         --  of the single protected/task type (SPARK RM 9.3).\n-\n-         elsif Nkind_In (Par, N_Protected_Body,\n-                              N_Protected_Type_Declaration,\n-                              N_Task_Body,\n-                              N_Task_Type_Declaration)\n-         then\n-            Spec_Id := Unique_Defining_Entity (Par);\n-\n-            if Present (Anonymous_Object (Spec_Id))\n-              and then Anonymous_Object (Spec_Id) = Conc_Typ\n-            then\n-               OK_Use := True;\n-               exit;\n-            end if;\n-\n-         --  The reference has been relocated within an internally generated\n-         --  package or subprogram. Assume that the reference is legal as the\n-         --  real check was already performed in the original context of the\n-         --  reference.\n-\n-         elsif Nkind_In (Par, N_Package_Body,\n-                              N_Package_Declaration,\n-                              N_Subprogram_Body,\n-                              N_Subprogram_Declaration)\n-           and then not Comes_From_Source (Par)\n-         then\n-            --  Continue to examine the context if the reference appears in a\n-            --  subprogram body which was previously an expression function.\n-\n-            if Nkind (Par) = N_Subprogram_Body\n-              and then Was_Expression_Function (Par)\n-            then\n-               null;\n-\n-            --  Otherwise the reference is legal\n-\n-            else\n-               OK_Use := True;\n-               exit;\n-            end if;\n-\n-         --  The reference has been relocated to an inlined body for GNATprove.\n-         --  Assume that the reference is legal as the real check was already\n-         --  performed in the original context of the reference.\n-\n-         elsif GNATprove_Mode\n-           and then Nkind (Par) = N_Subprogram_Body\n-           and then Chars (Defining_Entity (Par)) = Name_uParent\n-         then\n-            OK_Use := True;\n-            exit;\n-         end if;\n-\n-         Par := Parent (Par);\n-      end loop;\n-\n-      --  The reference is illegal as it appears outside the definition or\n-      --  body of the single protected/task type.\n-\n-      if not OK_Use then\n-         Error_Msg_NE\n-           (\"reference to variable & cannot appear in this context\",\n-            Ref, Var_Id);\n-         Error_Msg_Name_1 := Chars (Var_Id);\n-\n-         if Ekind (Conc_Typ) = E_Protected_Type then\n-            Error_Msg_NE\n-              (\"\\% is constituent of single protected type &\", Ref, Conc_Typ);\n-         else\n-            Error_Msg_NE\n-              (\"\\% is constituent of single task type &\", Ref, Conc_Typ);\n-         end if;\n-      end if;\n-   end Check_Part_Of_Reference;\n-\n    -----------------------------------------\n    -- Check_Dynamically_Tagged_Expression --\n    -----------------------------------------\n@@ -3333,6 +3182,138 @@ package body Sem_Util is\n       end if;\n    end Check_Nonvolatile_Function_Profile;\n \n+   -----------------------------\n+   -- Check_Part_Of_Reference --\n+   -----------------------------\n+\n+   procedure Check_Part_Of_Reference (Var_Id : Entity_Id; Ref : Node_Id) is\n+      Conc_Typ : constant Entity_Id := Encapsulating_State (Var_Id);\n+      Decl     : Node_Id;\n+      OK_Use   : Boolean := False;\n+      Par      : Node_Id;\n+      Prag_Nam : Name_Id;\n+      Spec_Id  : Entity_Id;\n+\n+   begin\n+      --  Traverse the parent chain looking for a suitable context for the\n+      --  reference to the concurrent constituent.\n+\n+      Par := Parent (Ref);\n+      while Present (Par) loop\n+         if Nkind (Par) = N_Pragma then\n+            Prag_Nam := Pragma_Name (Par);\n+\n+            --  A concurrent constituent is allowed to appear in pragmas\n+            --  Initial_Condition and Initializes as this is part of the\n+            --  elaboration checks for the constituent (SPARK RM 9.3).\n+\n+            if Nam_In (Prag_Nam, Name_Initial_Condition, Name_Initializes) then\n+               OK_Use := True;\n+               exit;\n+\n+            --  When the reference appears within pragma Depends or Global,\n+            --  check whether the pragma applies to a single task type. Note\n+            --  that the pragma is not encapsulated by the type definition,\n+            --  but this is still a valid context.\n+\n+            elsif Nam_In (Prag_Nam, Name_Depends, Name_Global) then\n+               Decl := Find_Related_Declaration_Or_Body (Par);\n+\n+               if Nkind (Decl) = N_Object_Declaration\n+                 and then Defining_Entity (Decl) = Conc_Typ\n+               then\n+                  OK_Use := True;\n+                  exit;\n+               end if;\n+            end if;\n+\n+         --  The reference appears somewhere in the definition of the single\n+         --  protected/task type (SPARK RM 9.3).\n+\n+         elsif Nkind_In (Par, N_Single_Protected_Declaration,\n+                              N_Single_Task_Declaration)\n+           and then Defining_Entity (Par) = Conc_Typ\n+         then\n+            OK_Use := True;\n+            exit;\n+\n+         --  The reference appears within the expanded declaration or the body\n+         --  of the single protected/task type (SPARK RM 9.3).\n+\n+         elsif Nkind_In (Par, N_Protected_Body,\n+                              N_Protected_Type_Declaration,\n+                              N_Task_Body,\n+                              N_Task_Type_Declaration)\n+         then\n+            Spec_Id := Unique_Defining_Entity (Par);\n+\n+            if Present (Anonymous_Object (Spec_Id))\n+              and then Anonymous_Object (Spec_Id) = Conc_Typ\n+            then\n+               OK_Use := True;\n+               exit;\n+            end if;\n+\n+         --  The reference has been relocated within an internally generated\n+         --  package or subprogram. Assume that the reference is legal as the\n+         --  real check was already performed in the original context of the\n+         --  reference.\n+\n+         elsif Nkind_In (Par, N_Package_Body,\n+                              N_Package_Declaration,\n+                              N_Subprogram_Body,\n+                              N_Subprogram_Declaration)\n+           and then not Comes_From_Source (Par)\n+         then\n+            --  Continue to examine the context if the reference appears in a\n+            --  subprogram body which was previously an expression function.\n+\n+            if Nkind (Par) = N_Subprogram_Body\n+              and then Was_Expression_Function (Par)\n+            then\n+               null;\n+\n+            --  Otherwise the reference is legal\n+\n+            else\n+               OK_Use := True;\n+               exit;\n+            end if;\n+\n+         --  The reference has been relocated to an inlined body for GNATprove.\n+         --  Assume that the reference is legal as the real check was already\n+         --  performed in the original context of the reference.\n+\n+         elsif GNATprove_Mode\n+           and then Nkind (Par) = N_Subprogram_Body\n+           and then Chars (Defining_Entity (Par)) = Name_uParent\n+         then\n+            OK_Use := True;\n+            exit;\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      --  The reference is illegal as it appears outside the definition or\n+      --  body of the single protected/task type.\n+\n+      if not OK_Use then\n+         Error_Msg_NE\n+           (\"reference to variable & cannot appear in this context\",\n+            Ref, Var_Id);\n+         Error_Msg_Name_1 := Chars (Var_Id);\n+\n+         if Ekind (Conc_Typ) = E_Protected_Type then\n+            Error_Msg_NE\n+              (\"\\% is constituent of single protected type &\", Ref, Conc_Typ);\n+         else\n+            Error_Msg_NE\n+              (\"\\% is constituent of single task type &\", Ref, Conc_Typ);\n+         end if;\n+      end if;\n+   end Check_Part_Of_Reference;\n+\n    ------------------------------------------\n    -- Check_Potentially_Blocking_Operation --\n    ------------------------------------------\n@@ -3363,6 +3344,25 @@ package body Sem_Util is\n       end loop;\n    end Check_Potentially_Blocking_Operation;\n \n+   ------------------------------------\n+   --  Check_Previous_Null_Procedure --\n+   ------------------------------------\n+\n+   procedure Check_Previous_Null_Procedure\n+     (Decl : Node_Id;\n+      Prev : Entity_Id)\n+   is\n+   begin\n+      if Ekind (Prev) = E_Procedure\n+        and then Nkind (Parent (Prev)) = N_Procedure_Specification\n+        and then Null_Present (Parent (Prev))\n+      then\n+         Error_Msg_Sloc := Sloc (Prev);\n+         Error_Msg_N\n+           (\"declaration cannot complete previous null procedure#\", Decl);\n+      end if;\n+   end Check_Previous_Null_Procedure;\n+\n    ---------------------------------\n    -- Check_Result_And_Post_State --\n    ---------------------------------\n@@ -14175,7 +14175,10 @@ package body Sem_Util is\n             --  Note that predefined operators are functions as well, and so\n             --  are attributes that are (can be renamed as) functions.\n \n-            when N_Function_Call | N_Binary_Op | N_Unary_Op =>\n+            when N_Binary_Op\n+               | N_Function_Call\n+               | N_Unary_Op\n+            =>\n                return Etype (N) /= Standard_Void_Type;\n \n             --  Attributes references 'Loop_Entry, 'Old, and 'Result yield\n@@ -14186,7 +14189,7 @@ package body Sem_Util is\n                  Nam_In (Attribute_Name (N), Name_Loop_Entry,\n                                              Name_Old,\n                                              Name_Result)\n-                  or else Is_Function_Attribute_Name (Attribute_Name (N));\n+                   or else Is_Function_Attribute_Name (Attribute_Name (N));\n \n             when N_Selected_Component =>\n                return"}]}