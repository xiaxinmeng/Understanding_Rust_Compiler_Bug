{"sha": "a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxY2QwZWNlNWY0Njc2MWZkZjkxZGRjNTYyYjgzMjg5NzRkYmZjOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-04T10:55:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-04T10:55:41Z"}, "message": "[multiple changes]\n\n2011-11-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_warn.adb (Warn_On_Useless_Assignment): More accurate test\n\tfor call vs assign.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\n2011-11-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb: Detect more cases of Long_Float inconsistencies at\n\tcompile time.\n\n2011-11-04  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Added a-sfecin.ads,\n\t* a-sfhcin.ads, a-sflcin.ads, a-sbecin.ad[sb], a-sbhcin.ad[sb],\n\ta-sblcin.ad[sb], a-suecin.ad[sb], a-suhcin.ad[sb], a-sulcin.ad[sb]\n\t* a-sfecin.ads, a-sfhcin.ads, a-sflcin.ads, a-sbecin.ad[sb],\n\ta-sbhcin.ad[sb], a-sblcin.ad[sb], a-suecin.ad[sb], a-suhcin.ad[sb],\n\ta-sulcin.ad[sb]: New files.\n\n2011-11-04  Geert Bosch  <bosch@adacore.com>\n\n\t* i-forbla-unimplemented.ads, s-gecola.adb, s-gecola.ads,\n\ts-gerebl.adb, s-gerebl.ads, i-forbla.adb, i-forbla.ads,\n\ti-forlap.ads, i-forbla-darwin.adb, s-gecobl.adb, s-gecobl.ads,\n\ts-gerela.adb, s-gerela.ads: Remove partial interface to BLAS/LAPACK.\n\t* gcc-interface/Makefile.in: Remove libgnala and related objects.\n\nFrom-SVN: r180935", "tree": {"sha": "a2ed65f5513e0ee836542dd2d9c685f3e21743b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2ed65f5513e0ee836542dd2d9c685f3e21743b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/comments", "author": null, "committer": null, "parents": [{"sha": "635c6321d455dd13aeb1d5d19615fd10407dd71d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635c6321d455dd13aeb1d5d19615fd10407dd71d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635c6321d455dd13aeb1d5d19615fd10407dd71d"}], "stats": {"total": 3663, "additions": 696, "deletions": 2967}, "files": [{"sha": "752037820fcfdbccfb0f745b58beb061775d6541", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -1,7 +1,30 @@\n-2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n+2011-11-04  Robert Dewar  <dewar@adacore.com>\n \n-\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Function>: Do not assert\n-\tthat the type of the parameters isn't dummy in type_annotate_only mode.\n+\t* sem_warn.adb (Warn_On_Useless_Assignment): More accurate test\n+\tfor call vs assign.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n+2011-11-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb: Detect more cases of Long_Float inconsistencies at\n+\tcompile time.\n+\n+2011-11-04  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Added a-sfecin.ads,\n+\t* a-sfhcin.ads, a-sflcin.ads, a-sbecin.ad[sb], a-sbhcin.ad[sb],\n+\ta-sblcin.ad[sb], a-suecin.ad[sb], a-suhcin.ad[sb], a-sulcin.ad[sb]\n+\t* a-sfecin.ads, a-sfhcin.ads, a-sflcin.ads, a-sbecin.ad[sb],\n+\ta-sbhcin.ad[sb], a-sblcin.ad[sb], a-suecin.ad[sb], a-suhcin.ad[sb],\n+\ta-sulcin.ad[sb]: New files.\n+\n+2011-11-04  Geert Bosch  <bosch@adacore.com>\n+\n+\t* i-forbla-unimplemented.ads, s-gecola.adb, s-gecola.ads,\n+\ts-gerebl.adb, s-gerebl.ads, i-forbla.adb, i-forbla.ads,\n+\ti-forlap.ads, i-forbla-darwin.adb, s-gecobl.adb, s-gecobl.ads,\n+\ts-gerela.adb, s-gerela.ads: Remove partial interface to BLAS/LAPACK.\n+\t* gcc-interface/Makefile.in: Remove libgnala and related objects.\n \n 2011-11-04  Matthew Heaney  <heaney@adacore.com>\n \n@@ -11,6 +34,11 @@\n \ta-convec.ad[sb], a-coinve.ad[sb] (Assign, Copy): New operations\n \tadded to package.\n \n+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Function>: Do not assert\n+\tthat the type of the parameters isn't dummy in type_annotate_only mode.\n+\n 2011-11-04  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch12.adb: Minor reformatting"}, {"sha": "4c481d17f651e429b31201ec26c85bbcad137457", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -214,9 +214,15 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-rbtgbo$(objext) \\\n   a-rbtgbk$(objext) \\\n   a-rbtgso$(objext) \\\n+  a-sbecin$(objext) \\\n+  a-sbhcin$(objext) \\\n+  a-sblcin$(objext) \\\n   a-scteio$(objext) \\\n   a-secain$(objext) \\\n   a-sequio$(objext) \\\n+  a-sfecin$(objext) \\\n+  a-sfhcin$(objext) \\\n+  a-sflcin$(objext) \\\n   a-sfteio$(objext) \\\n   a-sfwtio$(objext) \\\n   a-sfztio$(objext) \\\n@@ -261,10 +267,13 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-stzsea$(objext) \\\n   a-stzsup$(objext) \\\n   a-stzunb$(objext) \\\n+  a-suecin$(objext) \\\n   a-suenco$(objext) \\\n   a-suenst$(objext) \\\n   a-suewst$(objext) \\\n   a-suezst$(objext) \\\n+  a-suhcin$(objext) \\\n+  a-sulcin$(objext) \\\n   a-suteio$(objext) \\\n   a-swbwha$(objext) \\\n   a-swfwha$(objext) \\"}, {"sha": "780001768448c4f5d8898268e2a6c8ea41e6768b", "filename": "gcc/ada/a-sbecin.adb", "status": "renamed", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbecin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbecin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sbecin.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n+--                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---               I N T E R F A C E S . F O R T R A N . B L A S              --\n+--                ADA.STRINGS.BOUNDED.EQUAL_CASE_INSENSITIVE                --\n --                                                                          --\n---                                 B o d y                                  --\n+--                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 2006-2010, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,15 +24,17 @@\n -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n -- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  Version for Mac OS X\n+with Ada.Strings.Equal_Case_Insensitive;\n \n-package body Interfaces.Fortran.BLAS is\n-   pragma Linker_Options (\"-lgnala\");\n-   pragma Linker_Options (\"-lm\");\n-   pragma Linker_Options (\"-Wl,-framework,vecLib\");\n-end Interfaces.Fortran.BLAS;\n+function Ada.Strings.Bounded.Equal_Case_Insensitive\n+  (Left, Right : Bounded.Bounded_String)\n+  return Boolean\n+is\n+begin\n+   return Ada.Strings.Equal_Case_Insensitive\n+     (Left  => Bounded.To_String (Left),\n+      Right => Bounded.To_String (Right));\n+end Ada.Strings.Bounded.Equal_Case_Insensitive;", "previous_filename": "gcc/ada/i-forbla-darwin.adb"}, {"sha": "115c72206065f4f99b5fd1d77fa7fab823137df3", "filename": "gcc/ada/a-sbecin.ads", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbecin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbecin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sbecin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -1,12 +1,16 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n+--                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---               I N T E R F A C E S . F O R T R A N . B L A S              --\n+--                ADA.STRINGS.BOUNDED.EQUAL_CASE_INSENSITIVE                --\n --                                                                          --\n---                                 B o d y                                  --\n+--                                 S p e c                                  --\n --                                                                          --\n---         Copyright (C) 2006-2009, Free Software Foundation, Inc.          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,19 +28,15 @@\n -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n -- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  This Interfaces.Fortran.Blas package body contains the required linker\n---  pragmas for automatically linking with the LAPACK linear algebra support\n---  library, and the systems math library. Alternative bodies can be supplied\n---  if different sets of libraries are needed.\n+generic\n+   with package Bounded is\n+     new Ada.Strings.Bounded.Generic_Bounded_Length (<>);\n+\n+function Ada.Strings.Bounded.Equal_Case_Insensitive\n+  (Left, Right : Bounded.Bounded_String)\n+  return Boolean;\n \n-package body Interfaces.Fortran.BLAS is\n-   pragma Linker_Options (\"-lgnala\");\n-   pragma Linker_Options (\"-llapack\");\n-   pragma Linker_Options (\"-lblas\");\n-   pragma Linker_Options (\"-lm\");\n-end Interfaces.Fortran.BLAS;\n+pragma Preelaborate (Ada.Strings.Bounded.Equal_Case_Insensitive);", "previous_filename": "gcc/ada/i-forbla.adb"}, {"sha": "8c69290e0d02f68d0273126a928d43b3a6cd8d6d", "filename": "gcc/ada/a-sbhcin.adb", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbhcin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbhcin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sbhcin.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,38 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.STRINGS.BOUNDED.HASH_CASE_INSENSITIVE                --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Hash_Case_Insensitive;\n+\n+function Ada.Strings.Bounded.Hash_Case_Insensitive\n+  (Key : Bounded.Bounded_String)\n+  return Containers.Hash_Type\n+is\n+begin\n+   return Ada.Strings.Hash_Case_Insensitive (Bounded.To_String (Key));\n+end Ada.Strings.Bounded.Hash_Case_Insensitive;"}, {"sha": "c291f53db9a8f6d9aa513f68e04d6a82e85deb6f", "filename": "gcc/ada/a-sbhcin.ads", "status": "renamed", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbhcin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sbhcin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sbhcin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -1,12 +1,16 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n+--                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---               I N T E R F A C E S . F O R T R A N . B L A S              --\n+--                 ADA.STRINGS.BOUNDED.HASH_CASE_INSENSITIVE                --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---         Copyright (C) 2006-2009, Free Software Foundation, Inc.          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,22 +28,17 @@\n -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n -- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  This package provides a thin binding to the standard Fortran BLAS library.\n---  Documentation and a reference BLAS implementation is available from\n---  ftp://ftp.netlib.org. The main purpose of this package is to facilitate\n---  implementation of the Ada 2005 Ada.Numerics.Generic_Real_Arrays and\n---  Ada.Numerics.Generic_Complex_Arrays packages. Bindings to other BLAS\n---  routines may be added over time.\n-\n---  This unit is not implemented in this GNAT configuration\n+with Ada.Containers;\n \n-package Interfaces.Fortran.BLAS is\n+generic\n+   with package Bounded is\n+     new Ada.Strings.Bounded.Generic_Bounded_Length (<>);\n \n-   pragma Unimplemented_Unit;\n+function Ada.Strings.Bounded.Hash_Case_Insensitive\n+  (Key : Bounded.Bounded_String)\n+  return Containers.Hash_Type;\n \n-end Interfaces.Fortran.BLAS;\n+pragma Preelaborate (Ada.Strings.Bounded.Hash_Case_Insensitive);", "previous_filename": "gcc/ada/i-forbla-unimplemented.ads"}, {"sha": "e2ce4d3f384ae054e731c804a08dbe278ce559ee", "filename": "gcc/ada/a-sblcin.adb", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sblcin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sblcin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sblcin.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.STRINGS.BOUNDED.LESS_CASE_INSENSITIVE                --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Less_Case_Insensitive;\n+\n+function Ada.Strings.Bounded.Less_Case_Insensitive\n+  (Left, Right : Bounded.Bounded_String)\n+  return Boolean\n+is\n+begin\n+   return Ada.Strings.Less_Case_Insensitive\n+     (Left  => Bounded.To_String (Left),\n+      Right => Bounded.To_String (Right));\n+end Ada.Strings.Bounded.Less_Case_Insensitive;"}, {"sha": "d7284110aefb8a4bef8968e1b8c0c3497d39f57c", "filename": "gcc/ada/a-sblcin.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sblcin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sblcin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sblcin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,42 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.STRINGS.BOUNDED.LESS_CASE_INSENSITIVE                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+generic\n+   with package Bounded is\n+     new Ada.Strings.Bounded.Generic_Bounded_Length (<>);\n+\n+function Ada.Strings.Bounded.Less_Case_Insensitive\n+  (Left, Right : Bounded.Bounded_String)\n+  return Boolean;\n+\n+pragma Preelaborate (Ada.Strings.Bounded.Less_Case_Insensitive);"}, {"sha": "592b69166c99577adb53cee7e0667e10692a8aa1", "filename": "gcc/ada/a-sfecin.ads", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sfecin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sfecin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sfecin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.STRINGS.FIXED.EQUAL_CASE_INSENSITIVE                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Equal_Case_Insensitive;\n+\n+function Ada.Strings.Fixed.Equal_Case_Insensitive\n+  (Left, Right : String)\n+  return Boolean renames Ada.Strings.Equal_Case_Insensitive;\n+\n+pragma Pure (Ada.Strings.Fixed.Equal_Case_Insensitive);"}, {"sha": "86f60f68944ef06648b34de464230e3023d05c89", "filename": "gcc/ada/a-sfhcin.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sfhcin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sfhcin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sfhcin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.STRINGS.FIXED.HASH_CASE_INSENSITIVE                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers;\n+with Ada.Strings.Hash_Case_Insensitive;\n+\n+function Ada.Strings.Fixed.Hash_Case_Insensitive\n+  (Key : String)\n+  return Containers.Hash_Type renames Ada.Strings.Hash_Case_Insensitive;\n+\n+pragma Pure (Ada.Strings.Fixed.Hash_Case_Insensitive);"}, {"sha": "8af21fe9e55b076d862c78f4bb6655ede46a9978", "filename": "gcc/ada/a-sflcin.ads", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sflcin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sflcin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sflcin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.STRINGS.FIXED.LESS_CASE_INSENSITIVE                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Less_Case_Insensitive;\n+\n+function Ada.Strings.Fixed.Less_Case_Insensitive\n+  (Left, Right : String)\n+  return Boolean renames Ada.Strings.Less_Case_Insensitive;\n+\n+pragma Pure (Ada.Strings.Fixed.Less_Case_Insensitive);"}, {"sha": "73ebae5715676c885a166ec871100ef47f0924b6", "filename": "gcc/ada/a-suecin.adb", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suecin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suecin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suecin.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.STRINGS.UNBOUNDED.EQUAL_CASE_INSENSITIVE               --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Unbounded.Aux;\n+with Ada.Strings.Equal_Case_Insensitive;\n+\n+function Ada.Strings.Unbounded.Equal_Case_Insensitive\n+  (Left, Right : Unbounded.Unbounded_String)\n+  return Boolean\n+is\n+   SL, SR : Aux.Big_String_Access;\n+   LL, LR : Natural;\n+\n+begin\n+   Aux.Get_String (Left, SL, LL);\n+   Aux.Get_String (Right, SR, LR);\n+\n+   return Ada.Strings.Equal_Case_Insensitive\n+     (Left  => SL (1 .. LL),\n+      Right => SR (1 .. LR));\n+end Ada.Strings.Unbounded.Equal_Case_Insensitive;"}, {"sha": "08960241c8e8ec76594b1f27ae576b7ad3020181", "filename": "gcc/ada/a-suecin.ads", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suecin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suecin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suecin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,38 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.STRINGS.UNBOUNDED.EQUAL_CASE_INSENSITIVE               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+function Ada.Strings.Unbounded.Equal_Case_Insensitive\n+  (Left, Right : Unbounded.Unbounded_String)\n+  return Boolean;\n+\n+pragma Preelaborate (Ada.Strings.Unbounded.Equal_Case_Insensitive);"}, {"sha": "0417c15db24a6ced627def6fe05af8bb2bb6a187", "filename": "gcc/ada/a-suhcin.adb", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suhcin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suhcin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suhcin.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,43 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.STRINGS.UNBOUNDED.HASH_CASE_INSENSITIVE                --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Unbounded.Aux;\n+with Ada.Strings.Hash_Case_Insensitive;\n+\n+function Ada.Strings.Unbounded.Hash_Case_Insensitive\n+  (Key : Unbounded.Unbounded_String)\n+  return Containers.Hash_Type\n+is\n+   S : Aux.Big_String_Access;\n+   L : Natural;\n+\n+begin\n+   Aux.Get_String (Key, S, L);\n+   return Ada.Strings.Hash_Case_Insensitive (S (1 .. L));\n+end Ada.Strings.Unbounded.Hash_Case_Insensitive;"}, {"sha": "180d4a4391a527821f49dd12e8cc9fd2392d98d0", "filename": "gcc/ada/a-suhcin.ads", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suhcin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-suhcin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suhcin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.STRINGS.UNBOUNDED.HASH_CASE_INSENSITIVE                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers;\n+\n+function Ada.Strings.Unbounded.Hash_Case_Insensitive\n+  (Key : Unbounded.Unbounded_String)\n+  return Containers.Hash_Type;\n+\n+pragma Preelaborate (Ada.Strings.Unbounded.Hash_Case_Insensitive);"}, {"sha": "9f1f3c4aca9cbe00bc2cacd9be3728b330d16757", "filename": "gcc/ada/a-sulcin.adb", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sulcin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sulcin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sulcin.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.STRINGS.UNBOUNDED.LESS_CASE_INSENSITIVE                --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Unbounded.Aux;\n+with Ada.Strings.Less_Case_Insensitive;\n+\n+function Ada.Strings.Unbounded.Less_Case_Insensitive\n+  (Left, Right : Unbounded.Unbounded_String)\n+  return Boolean\n+is\n+   SL, SR : Aux.Big_String_Access;\n+   LL, LR : Natural;\n+\n+begin\n+   Aux.Get_String (Left, SL, LL);\n+   Aux.Get_String (Right, SR, LR);\n+\n+   return Ada.Strings.Less_Case_Insensitive\n+     (Left  => SL (1 .. LL),\n+      Right => SR (1 .. LR));\n+end Ada.Strings.Unbounded.Less_Case_Insensitive;"}, {"sha": "fafb546ca77fc8d2dcf1a8763dad2a03920777ef", "filename": "gcc/ada/a-sulcin.ads", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sulcin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fa-sulcin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sulcin.ads?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -0,0 +1,38 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.STRINGS.UNBOUNDED.LESS_CASE_INSENSITIVE                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+function Ada.Strings.Unbounded.Less_Case_Insensitive\n+  (Left, Right : Unbounded.Unbounded_String)\n+  return Boolean;\n+\n+pragma Preelaborate (Ada.Strings.Unbounded.Less_Case_Insensitive);"}, {"sha": "d178f65aa01039f3edcd7efbf904bc0049f75e5a", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -1953,32 +1953,35 @@ ada/exp_ch13.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/exp_ch2.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n-   ada/atree.adb ada/casing.ads ada/csets.ads ada/debug.ads \\\n-   ada/debug_a.ads ada/einfo.ads ada/einfo.adb ada/elists.ads \\\n-   ada/elists.adb ada/err_vars.ads ada/errout.ads ada/errout.adb \\\n-   ada/erroutc.ads ada/erroutc.adb ada/exp_ch2.ads ada/exp_ch2.adb \\\n-   ada/exp_code.ads ada/exp_smem.ads ada/exp_tss.ads ada/exp_util.ads \\\n-   ada/exp_vfpt.ads ada/expander.ads ada/fname.ads ada/gnat.ads \\\n-   ada/g-htable.ads ada/gnatvsn.ads ada/hlo.ads ada/hostparm.ads \\\n-   ada/inline.ads ada/interfac.ads ada/lib.ads ada/lib-load.ads \\\n-   ada/namet.ads ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads \\\n-   ada/nmake.adb ada/opt.ads ada/output.ads ada/par_sco.ads ada/rident.ads \\\n-   ada/rtsfind.ads ada/scans.ads ada/sem.ads ada/sem.adb ada/sem_attr.ads \\\n-   ada/sem_aux.ads ada/sem_ch10.ads ada/sem_ch11.ads ada/sem_ch12.ads \\\n-   ada/sem_ch13.ads ada/sem_ch2.ads ada/sem_ch3.ads ada/sem_ch4.ads \\\n-   ada/sem_ch5.ads ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads \\\n-   ada/sem_ch9.ads ada/sem_eval.ads ada/sem_prag.ads ada/sem_res.ads \\\n-   ada/sem_util.ads ada/sem_warn.ads ada/sem_warn.adb ada/sinfo.ads \\\n-   ada/sinfo.adb ada/sinput.ads ada/sinput.adb ada/snames.ads \\\n-   ada/stand.ads ada/stringt.ads ada/stylesw.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tbuild.ads ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/widechar.ads \n+   ada/atree.adb ada/casing.ads ada/checks.ads ada/checks.adb \\\n+   ada/csets.ads ada/debug.ads ada/debug_a.ads ada/einfo.ads ada/einfo.adb \\\n+   ada/elists.ads ada/elists.adb ada/err_vars.ads ada/errout.ads \\\n+   ada/errout.adb ada/erroutc.ads ada/erroutc.adb ada/eval_fat.ads \\\n+   ada/exp_ch11.ads ada/exp_ch2.ads ada/exp_ch2.adb ada/exp_ch4.ads \\\n+   ada/exp_code.ads ada/exp_pakd.ads ada/exp_smem.ads ada/exp_tss.ads \\\n+   ada/exp_util.ads ada/exp_vfpt.ads ada/expander.ads ada/fname.ads \\\n+   ada/freeze.ads ada/get_targ.ads ada/gnat.ads ada/g-htable.ads \\\n+   ada/gnatvsn.ads ada/hlo.ads ada/hostparm.ads ada/inline.ads \\\n+   ada/interfac.ads ada/lib.ads ada/lib-load.ads ada/namet.ads \\\n+   ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n+   ada/opt.ads ada/output.ads ada/par_sco.ads ada/restrict.ads \\\n+   ada/rident.ads ada/rtsfind.ads ada/scans.ads ada/sem.ads ada/sem.adb \\\n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_ch10.ads ada/sem_ch11.ads \\\n+   ada/sem_ch12.ads ada/sem_ch13.ads ada/sem_ch2.ads ada/sem_ch3.ads \\\n+   ada/sem_ch4.ads ada/sem_ch5.ads ada/sem_ch6.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_ch9.ads ada/sem_eval.ads ada/sem_prag.ads \\\n+   ada/sem_res.ads ada/sem_util.ads ada/sem_warn.ads ada/sem_warn.adb \\\n+   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/sinput.adb \\\n+   ada/snames.ads ada/sprint.ads ada/stand.ads ada/stringt.ads \\\n+   ada/stylesw.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tree_io.ads \\\n+   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \\\n+   ada/widechar.ads \n \n ada/exp_ch3.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\"}, {"sha": "d9215dfb0920f09255ae74b4689537771421601e", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -2116,7 +2116,6 @@ ifeq ($(strip $(filter-out darwin%,$(osys))),)\n   SO_OPTS = -shared-libgcc\n   LIBGNAT_TARGET_PAIRS = \\\n     a-intnam.ads<a-intnam-darwin.ads \\\n-    i-forbla.adb<i-forbla-darwin.adb \\\n     s-inmaop.adb<s-inmaop-posix.adb \\\n     s-osinte.adb<s-osinte-darwin.adb \\\n     s-osinte.ads<s-osinte-darwin.ads \\\n@@ -2238,10 +2237,8 @@ LIBGNAT_OBJS = adadecode.o adaint.o argv.o cio.o cstreams.o ctrl_c.o\t\\\n \n include $(fsrcdir)/ada/Makefile.rtl\n \n-GNATRTL_LINEARALGEBRA_OBJS = i-forbla.o i-forlap.o\n-\n GNATRTL_OBJS = $(GNATRTL_NONTASKING_OBJS) $(GNATRTL_TASKING_OBJS) \\\n-  $(GNATRTL_LINEARALGEBRA_OBJS) memtrack.o\n+  memtrack.o\n \n # Default run time files\n \n@@ -2538,9 +2535,6 @@ gnatlib: ../stamp-gnatlib1-$(RTSDIR) ../stamp-gnatlib2-$(RTSDIR)\n \t$(AR_FOR_TARGET) $(AR_FLAGS) $(RTSDIR)/libgnarl$(arext) \\\n \t   $(addprefix $(RTSDIR)/,$(GNATRTL_TASKING_OBJS))\n \t$(RANLIB_FOR_TARGET) $(RTSDIR)/libgnarl$(arext)\n-\t$(AR_FOR_TARGET) $(AR_FLAGS) $(RTSDIR)/libgnala$(arext) \\\n-\t   $(addprefix $(RTSDIR)/,$(GNATRTL_LINEARALGEBRA_OBJS))\n-\t$(RANLIB_FOR_TARGET) $(RTSDIR)/libgnala$(arext)\n         ifeq ($(GMEM_LIB),gmemlib)\n \t\t$(AR_FOR_TARGET) $(AR_FLAGS) $(RTSDIR)/libgmem$(arext) \\\n \t\t  $(RTSDIR)/memtrack.o"}, {"sha": "3910349a652bf5f98afd049d224d4870913fd7b9", "filename": "gcc/ada/i-forbla.ads", "status": "removed", "additions": 0, "deletions": 261, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fi-forbla.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fi-forbla.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-forbla.ads?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,261 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---               I N T E R F A C E S . F O R T R A N . B L A S              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---         Copyright (C) 2006-2009, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides a thin binding to the standard Fortran BLAS library.\n---  Documentation and a reference BLAS implementation is available from\n---  ftp://ftp.netlib.org. The main purpose of this package is to facilitate\n---  implementation of the Ada 2005 Ada.Numerics.Generic_Real_Arrays and\n---  Ada.Numerics.Generic_Complex_Arrays packages. Bindings to other BLAS\n---  routines may be added over time.\n-\n---  As actual linker arguments to link with the BLAS implementation differs\n---  according to platform and chosen BLAS implementation, the linker arguments\n---  are given in the body of this package. The body may need to be modified in\n---  order to link with different BLAS implementations tuned to the specific\n---  target.\n-\n-package Interfaces.Fortran.BLAS is\n-   pragma Pure;\n-   pragma Elaborate_Body;\n-\n-   No_Trans   : aliased constant Character := 'N';\n-   Trans      : aliased constant Character := 'T';\n-   Conj_Trans : aliased constant Character := 'C';\n-\n-   --  Vector types\n-\n-   type Real_Vector is array (Integer range <>) of Real;\n-\n-   type Complex_Vector is array (Integer range <>) of Complex;\n-\n-   type Double_Precision_Vector is array (Integer range <>)\n-     of Double_Precision;\n-\n-   type Double_Complex_Vector is array (Integer range <>) of Double_Complex;\n-\n-   --  Matrix types\n-\n-   type Real_Matrix is array (Integer range <>, Integer range <>)\n-     of Real;\n-\n-   type Double_Precision_Matrix is array (Integer range <>, Integer range <>)\n-     of Double_Precision;\n-\n-   type Complex_Matrix is array (Integer range <>, Integer range <>)\n-     of Complex;\n-\n-   type Double_Complex_Matrix is array (Integer range <>, Integer range <>)\n-     of Double_Complex;\n-\n-   --  BLAS Level 1\n-\n-   function sdot\n-     (N     : Positive;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Real_Vector;\n-      Inc_Y : Integer := 1) return Real;\n-\n-   function ddot\n-     (N     : Positive;\n-      X     : Double_Precision_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Double_Precision_Vector;\n-      Inc_Y : Integer := 1) return Double_Precision;\n-\n-   function cdotu\n-     (N     : Positive;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Complex_Vector;\n-      Inc_Y : Integer := 1) return Complex;\n-\n-   function zdotu\n-     (N     : Positive;\n-      X     : Double_Complex_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Double_Complex_Vector;\n-      Inc_Y : Integer := 1) return Double_Complex;\n-\n-   function snrm2\n-     (N     : Natural;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1) return Real;\n-\n-   function dnrm2\n-     (N     : Natural;\n-      X     : Double_Precision_Vector;\n-      Inc_X : Integer := 1) return Double_Precision;\n-\n-   function scnrm2\n-     (N     : Natural;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1) return Real;\n-\n-   function dznrm2\n-     (N     : Natural;\n-      X     : Double_Complex_Vector;\n-      Inc_X : Integer := 1) return Double_Precision;\n-\n-   --  BLAS Level 2\n-\n-   procedure sgemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Real := 1.0;\n-      A     : Real_Matrix;\n-      Ld_A  : Positive;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1;  -- must be non-zero\n-      Beta  : Real := 0.0;\n-      Y     : in out Real_Vector;\n-      Inc_Y : Integer := 1); -- must be non-zero\n-\n-   procedure dgemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Double_Precision := 1.0;\n-      A     : Double_Precision_Matrix;\n-      Ld_A  : Positive;\n-      X     : Double_Precision_Vector;\n-      Inc_X : Integer := 1;  -- must be non-zero\n-      Beta  : Double_Precision := 0.0;\n-      Y     : in out Double_Precision_Vector;\n-      Inc_Y : Integer := 1); -- must be non-zero\n-\n-   procedure cgemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Complex := (1.0, 1.0);\n-      A     : Complex_Matrix;\n-      Ld_A  : Positive;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1;  -- must be non-zero\n-      Beta  : Complex := (0.0, 0.0);\n-      Y     : in out Complex_Vector;\n-      Inc_Y : Integer := 1); -- must be non-zero\n-\n-   procedure zgemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Double_Complex := (1.0, 1.0);\n-      A     : Double_Complex_Matrix;\n-      Ld_A  : Positive;\n-      X     : Double_Complex_Vector;\n-      Inc_X : Integer := 1;  -- must be non-zero\n-      Beta  : Double_Complex := (0.0, 0.0);\n-      Y     : in out Double_Complex_Vector;\n-      Inc_Y : Integer := 1); -- must be non-zero\n-\n-   --  BLAS Level 3\n-\n-   procedure sgemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Real := 1.0;\n-      A       : Real_Matrix;\n-      Ld_A    : Integer;\n-      B       : Real_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Real := 0.0;\n-      C       : in out Real_Matrix;\n-      Ld_C    : Integer);\n-\n-   procedure dgemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Double_Precision := 1.0;\n-      A       : Double_Precision_Matrix;\n-      Ld_A    : Integer;\n-      B       : Double_Precision_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Double_Precision := 0.0;\n-      C       : in out Double_Precision_Matrix;\n-      Ld_C    : Integer);\n-\n-   procedure cgemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Complex := (1.0, 1.0);\n-      A       : Complex_Matrix;\n-      Ld_A    : Integer;\n-      B       : Complex_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Complex := (0.0, 0.0);\n-      C       : in out Complex_Matrix;\n-      Ld_C    : Integer);\n-\n-   procedure zgemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Double_Complex := (1.0, 1.0);\n-      A       : Double_Complex_Matrix;\n-      Ld_A    : Integer;\n-      B       : Double_Complex_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Double_Complex := (0.0, 0.0);\n-      C       : in out Double_Complex_Matrix;\n-      Ld_C    : Integer);\n-\n-private\n-   pragma Import (Fortran, cdotu,  \"cdotu_\");\n-   pragma Import (Fortran, cgemm,  \"cgemm_\");\n-   pragma Import (Fortran, cgemv,  \"cgemv_\");\n-   pragma Import (Fortran, ddot,   \"ddot_\");\n-   pragma Import (Fortran, dgemm,  \"dgemm_\");\n-   pragma Import (Fortran, dgemv,  \"dgemv_\");\n-   pragma Import (Fortran, dnrm2,  \"dnrm2_\");\n-   pragma Import (Fortran, dznrm2, \"dznrm2_\");\n-   pragma Import (Fortran, scnrm2, \"scnrm2_\");\n-   pragma Import (Fortran, sdot,   \"sdot_\");\n-   pragma Import (Fortran, sgemm,  \"sgemm_\");\n-   pragma Import (Fortran, sgemv,  \"sgemv_\");\n-   pragma Import (Fortran, snrm2,  \"snrm2_\");\n-   pragma Import (Fortran, zdotu,  \"zdotu_\");\n-   pragma Import (Fortran, zgemm,  \"zgemm_\");\n-   pragma Import (Fortran, zgemv,  \"zgemv_\");\n-end Interfaces.Fortran.BLAS;"}, {"sha": "ebb08abe65435bb8775c01fb4067b7d441516e33", "filename": "gcc/ada/i-forlap.ads", "status": "removed", "additions": 0, "deletions": 414, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fi-forlap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fi-forlap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-forlap.ads?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,414 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---             I N T E R F A C E S . F O R T R A N . L A P A C K            --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Package comment required if non-RM package ???\n-\n-with Interfaces.Fortran.BLAS;\n-package Interfaces.Fortran.LAPACK is\n-   pragma Pure;\n-\n-   type Integer_Vector is array (Integer range <>) of Integer;\n-\n-   Upper : aliased constant Character := 'U';\n-   Lower : aliased constant Character := 'L';\n-\n-   subtype Real_Vector is BLAS.Real_Vector;\n-   subtype Real_Matrix is BLAS.Real_Matrix;\n-   subtype Double_Precision_Vector is BLAS.Double_Precision_Vector;\n-   subtype Double_Precision_Matrix is BLAS.Double_Precision_Matrix;\n-   subtype Complex_Vector is BLAS.Complex_Vector;\n-   subtype Complex_Matrix is BLAS.Complex_Matrix;\n-   subtype Double_Complex_Vector is BLAS.Double_Complex_Vector;\n-   subtype Double_Complex_Matrix is BLAS.Double_Complex_Matrix;\n-\n-   --  LAPACK Computational Routines\n-\n-   --  gerfs  Refines the solution of a system of linear equations with\n-   --         a general matrix and estimates its error\n-   --  getrf  Computes LU factorization of a general m-by-n matrix\n-   --  getri  Computes inverse of an LU-factored general matrix\n-   --         square matrix, with multiple right-hand sides\n-   --  getrs  Solves a system of linear equations with an LU-factored\n-   --         square matrix, with multiple right-hand sides\n-   --  hetrd  Reduces a complex Hermitian matrix to tridiagonal form\n-   --  heevr  Computes selected eigenvalues and, optionally, eigenvectors of\n-   --         a Hermitian matrix using the Relatively Robust Representations\n-   --  orgtr  Generates the real orthogonal matrix Q determined by sytrd\n-   --  steqr  Computes all eigenvalues and eigenvectors of a symmetric or\n-   --         Hermitian matrix reduced to tridiagonal form (QR algorithm)\n-   --  sterf  Computes all eigenvalues of a real symmetric\n-   --         tridiagonal matrix using QR algorithm\n-   --  sytrd  Reduces a real symmetric matrix to tridiagonal form\n-\n-   procedure sgetrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Real_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer);\n-\n-   procedure dgetrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Double_Precision_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer);\n-\n-   procedure cgetrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Complex_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer);\n-\n-   procedure zgetrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Double_Complex_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer);\n-\n-   procedure sgetri\n-     (N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure dgetri\n-     (N      : Natural;\n-      A      : in out Double_Precision_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Double_Precision_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure cgetri\n-     (N      : Natural;\n-      A      : in out Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Complex_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure zgetri\n-     (N      : Natural;\n-      A      : in out Double_Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Double_Complex_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure sgetrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Real_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Real_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer);\n-\n-   procedure dgetrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Double_Precision_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Double_Precision_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer);\n-\n-   procedure cgetrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Complex_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer);\n-\n-   procedure zgetrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Double_Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Double_Complex_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer);\n-\n-   procedure cheevr\n-     (Job_Z    : access constant Character;\n-      Rng      : access constant Character;\n-      Uplo     : access constant Character;\n-      N        : Natural;\n-      A        : in out Complex_Matrix;\n-      Ld_A     : Positive;\n-      Vl, Vu   : Real := 0.0;\n-      Il, Iu   : Integer := 1;\n-      Abs_Tol  : Real := 0.0;\n-      M        : out Integer;\n-      W        : out Real_Vector;\n-      Z        : out Complex_Matrix;\n-      Ld_Z     : Positive;\n-      I_Supp_Z : out Integer_Vector;\n-      Work     : out Complex_Vector;\n-      L_Work   : Integer;\n-      R_Work   : out Real_Vector;\n-      LR_Work  : Integer;\n-      I_Work   : out Integer_Vector;\n-      LI_Work  : Integer;\n-      Info     : access Integer);\n-\n-   procedure zheevr\n-     (Job_Z    : access constant Character;\n-      Rng      : access constant Character;\n-      Uplo     : access constant Character;\n-      N        : Natural;\n-      A        : in out Double_Complex_Matrix;\n-      Ld_A     : Positive;\n-      Vl, Vu   : Double_Precision := 0.0;\n-      Il, Iu   : Integer := 1;\n-      Abs_Tol  : Double_Precision := 0.0;\n-      M        : out Integer;\n-      W        : out Double_Precision_Vector;\n-      Z        : out Double_Complex_Matrix;\n-      Ld_Z     : Positive;\n-      I_Supp_Z : out Integer_Vector;\n-      Work     : out Double_Complex_Vector;\n-      L_Work   : Integer;\n-      R_Work   : out Double_Precision_Vector;\n-      LR_Work  : Integer;\n-      I_Work   : out Integer_Vector;\n-      LI_Work  : Integer;\n-      Info     : access Integer);\n-\n-   procedure chetrd\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Complex_Matrix;\n-      Ld_A   : Positive;\n-      D      : out Real_Vector;\n-      E      : out Real_Vector;\n-      Tau    : out Complex_Vector;\n-      Work   : out Complex_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure zhetrd\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Double_Complex_Matrix;\n-      Ld_A   : Positive;\n-      D      : out Double_Precision_Vector;\n-      E      : out Double_Precision_Vector;\n-      Tau    : out Double_Complex_Vector;\n-      Work   : out Double_Complex_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure ssytrd\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      D      : out Real_Vector;\n-      E      : out Real_Vector;\n-      Tau    : out Real_Vector;\n-      Work   : out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure dsytrd\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Double_Precision_Matrix;\n-      Ld_A   : Positive;\n-      D      : out Double_Precision_Vector;\n-      E      : out Double_Precision_Vector;\n-      Tau    : out Double_Precision_Vector;\n-      Work   : out Double_Precision_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure ssterf\n-     (N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Info   : access Integer);\n-\n-   procedure dsterf\n-     (N      : Natural;\n-      D      : in out Double_Precision_Vector;\n-      E      : in out Double_Precision_Vector;\n-      Info   : access Integer);\n-\n-   procedure sorgtr\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      Tau    : Real_Vector;\n-      Work   : out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure dorgtr\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Double_Precision_Matrix;\n-      Ld_A   : Positive;\n-      Tau    : Double_Precision_Vector;\n-      Work   : out Double_Precision_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure sstebz\n-     (Rng      : access constant Character;\n-      Order    : access constant Character;\n-      N        : Natural;\n-      Vl, Vu   : Real := 0.0;\n-      Il, Iu   : Integer := 1;\n-      Abs_Tol  : Real := 0.0;\n-      D        : Real_Vector;\n-      E        : Real_Vector;\n-      M        : out Natural;\n-      N_Split  : out Natural;\n-      W        : out Real_Vector;\n-      I_Block  : out Integer_Vector;\n-      I_Split  : out Integer_Vector;\n-      Work     : out Real_Vector;\n-      I_Work   : out Integer_Vector;\n-      Info     : access Integer);\n-\n-   procedure dstebz\n-     (Rng      : access constant Character;\n-      Order    : access constant Character;\n-      N        : Natural;\n-      Vl, Vu   : Double_Precision := 0.0;\n-      Il, Iu   : Integer := 1;\n-      Abs_Tol  : Double_Precision := 0.0;\n-      D        : Double_Precision_Vector;\n-      E        : Double_Precision_Vector;\n-      M        : out Natural;\n-      N_Split  : out Natural;\n-      W        : out Double_Precision_Vector;\n-      I_Block  : out Integer_Vector;\n-      I_Split  : out Integer_Vector;\n-      Work     : out Double_Precision_Vector;\n-      I_Work   : out Integer_Vector;\n-      Info     : access Integer);\n-\n-   procedure ssteqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Z      : in out Real_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Real_Vector;\n-      Info   : access Integer);\n-\n-   procedure dsteqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Double_Precision_Vector;\n-      E      : in out Double_Precision_Vector;\n-      Z      : in out Double_Precision_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Double_Precision_Vector;\n-      Info   : access Integer);\n-\n-   procedure csteqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Z      : in out Complex_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Real_Vector;\n-      Info   : access Integer);\n-\n-   procedure zsteqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Double_Precision_Vector;\n-      E      : in out Double_Precision_Vector;\n-      Z      : in out Double_Complex_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Double_Precision_Vector;\n-      Info   : access Integer);\n-\n-private\n-   pragma Import (Fortran, csteqr, \"csteqr_\");\n-   pragma Import (Fortran, cgetrf, \"cgetrf_\");\n-   pragma Import (Fortran, cgetri, \"cgetri_\");\n-   pragma Import (Fortran, cgetrs, \"cgetrs_\");\n-   pragma Import (Fortran, cheevr, \"cheevr_\");\n-   pragma Import (Fortran, chetrd, \"chetrd_\");\n-   pragma Import (Fortran, dgetrf, \"dgetrf_\");\n-   pragma Import (Fortran, dgetri, \"dgetri_\");\n-   pragma Import (Fortran, dgetrs, \"dgetrs_\");\n-   pragma Import (Fortran, dsytrd, \"dsytrd_\");\n-   pragma Import (Fortran, dstebz, \"dstebz_\");\n-   pragma Import (Fortran, dsterf, \"dsterf_\");\n-   pragma Import (Fortran, dorgtr, \"dorgtr_\");\n-   pragma Import (Fortran, dsteqr, \"dsteqr_\");\n-   pragma Import (Fortran, sgetrf, \"sgetrf_\");\n-   pragma Import (Fortran, sgetri, \"sgetri_\");\n-   pragma Import (Fortran, sgetrs, \"sgetrs_\");\n-   pragma Import (Fortran, sorgtr, \"sorgtr_\");\n-   pragma Import (Fortran, sstebz, \"sstebz_\");\n-   pragma Import (Fortran, ssterf, \"ssterf_\");\n-   pragma Import (Fortran, ssteqr, \"ssteqr_\");\n-   pragma Import (Fortran, ssytrd, \"ssytrd_\");\n-   pragma Import (Fortran, zgetrf, \"zgetrf_\");\n-   pragma Import (Fortran, zgetri, \"zgetri_\");\n-   pragma Import (Fortran, zgetrs, \"zgetrs_\");\n-   pragma Import (Fortran, zheevr, \"zheevr_\");\n-   pragma Import (Fortran, zhetrd, \"zhetrd_\");\n-   pragma Import (Fortran, zsteqr, \"zsteqr_\");\n-end Interfaces.Fortran.LAPACK;"}, {"sha": "8f4fc298ddf4a48d6519c83e282e5e68b9c670a6", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -487,16 +487,25 @@ package body Impunit is\n     (\"a-ciormu\", F),  -- Ada.Containers.Indefinite_Ordered_Multisets\n     (\"a-coormu\", F),  -- Ada.Containers.Ordered_Multisets\n     (\"a-crdlli\", F),  -- Ada.Containers.Restricted_Doubly_Linked_Lists\n-    (\"a-secain\", F),  -- Ada.Strings.Equal_Case_Insensitive\n-    (\"a-shcain\", F),  -- Ada.Strings.Hash_Case_Insensitive\n-    (\"a-slcain\", F),  -- Ada.Strings.Less_Case_Insensitive\n     (\"a-szuzti\", F),  -- Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO\n     (\"a-zchuni\", F),  -- Ada.Wide_Wide_Characters.Unicode\n     (\"a-ztcstr\", F),  -- Ada.Wide_Wide_Text_IO.C_Streams\n \n       --  Note: strictly the following should be Ada 2012 units, but it seems\n       --  harmless (and useful) to make then available in Ada 2005 mode.\n \n+    (\"a-secain\", T),  -- Ada.Strings.Equal_Case_Insensitive\n+    (\"a-shcain\", T),  -- Ada.Strings.Hash_Case_Insensitive\n+    (\"a-slcain\", T),  -- Ada.Strings.Less_Case_Insensitive\n+    (\"a-sfecin\", T),  -- Ada.Strings.Fixed.Equal_Case_Insensitive\n+    (\"a-sfhcin\", T),  -- Ada.Strings.Fixed.Hash_Case_Insensitive\n+    (\"a-sflcin\", T),  -- Ada.Strings.Fixed.Less_Case_Insensitive\n+    (\"a-sbecin\", T),  -- Ada.Strings.Bounded.Equal_Case_Insensitive\n+    (\"a-sbhcin\", T),  -- Ada.Strings.Bounded.Hash_Case_Insensitive\n+    (\"a-sblcin\", T),  -- Ada.Strings.Bounded.Less_Case_Insensitive\n+    (\"a-suecin\", T),  -- Ada.Strings.Unbounded.Equal_Case_Insensitive\n+    (\"a-suhcin\", T),  -- Ada.Strings.Unbounded.Hash_Case_Insensitive\n+    (\"a-sulcin\", T),  -- Ada.Strings.Unbounded.Less_Case_Insensitive\n     (\"a-suezst\", T),  -- Ada.Strings.UTF_Encoding.Wide_Wide_Strings\n \n    ---------------------------"}, {"sha": "d20b53f31b4792c0599861925a4b667fd1e945e7", "filename": "gcc/ada/s-gecobl.adb", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecobl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecobl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecobl.adb?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,350 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . G E N E R I C _ C O M P L E X _ B L A S          --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---         Copyright (C) 2006-2009, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Unchecked_Conversion;        use Ada;\n-with Interfaces;                      use Interfaces;\n-with Interfaces.Fortran;              use Interfaces.Fortran;\n-with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n-with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n-\n-package body System.Generic_Complex_BLAS is\n-\n-   Is_Single : constant Boolean :=\n-                 Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n-                  and then Fortran.Real (Real'First) = Fortran.Real'First\n-                  and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n-\n-   Is_Double : constant Boolean :=\n-                 Real'Machine_Mantissa = Double_Precision'Machine_Mantissa\n-                  and then\n-                    Double_Precision (Real'First) = Double_Precision'First\n-                  and then\n-                    Double_Precision (Real'Last) = Double_Precision'Last;\n-\n-   subtype Complex is Complex_Types.Complex;\n-\n-   --  Local subprograms\n-\n-   function To_Double_Precision (X : Real) return Double_Precision;\n-   pragma Inline (To_Double_Precision);\n-\n-   function To_Double_Complex (X : Complex) return Double_Complex;\n-   pragma Inline (To_Double_Complex);\n-\n-   function To_Complex (X : Double_Complex) return Complex;\n-   function To_Complex (X : Fortran.Complex) return Complex;\n-   pragma Inline (To_Complex);\n-\n-   function To_Fortran (X : Complex) return Fortran.Complex;\n-   pragma Inline (To_Fortran);\n-\n-   --  Instantiations\n-\n-   function To_Double_Complex is new\n-      Vector_Elementwise_Operation\n-       (X_Scalar      => Complex_Types.Complex,\n-        Result_Scalar => Fortran.Double_Complex,\n-        X_Vector      => Complex_Vector,\n-        Result_Vector => BLAS.Double_Complex_Vector,\n-        Operation     => To_Double_Complex);\n-\n-   function To_Complex is new\n-      Vector_Elementwise_Operation\n-       (X_Scalar      => Fortran.Double_Complex,\n-        Result_Scalar => Complex,\n-        X_Vector      => BLAS.Double_Complex_Vector,\n-        Result_Vector => Complex_Vector,\n-        Operation     => To_Complex);\n-\n-   function To_Double_Complex is new\n-      Matrix_Elementwise_Operation\n-       (X_Scalar      => Complex,\n-        Result_Scalar => Double_Complex,\n-        X_Matrix      => Complex_Matrix,\n-        Result_Matrix => BLAS.Double_Complex_Matrix,\n-        Operation     => To_Double_Complex);\n-\n-   function To_Complex is new\n-     Matrix_Elementwise_Operation\n-       (X_Scalar      => Double_Complex,\n-        Result_Scalar => Complex,\n-        X_Matrix      => BLAS.Double_Complex_Matrix,\n-        Result_Matrix => Complex_Matrix,\n-        Operation     => To_Complex);\n-\n-   function To_Double_Precision (X : Real) return Double_Precision is\n-   begin\n-      return Double_Precision (X);\n-   end To_Double_Precision;\n-\n-   function To_Double_Complex (X : Complex) return Double_Complex is\n-   begin\n-      return (To_Double_Precision (X.Re), To_Double_Precision (X.Im));\n-   end To_Double_Complex;\n-\n-   function To_Complex (X : Double_Complex) return Complex is\n-   begin\n-      return (Real (X.Re), Real (X.Im));\n-   end To_Complex;\n-\n-   function To_Complex (X : Fortran.Complex) return Complex is\n-   begin\n-      return (Real (X.Re), Real (X.Im));\n-   end To_Complex;\n-\n-   function To_Fortran (X : Complex) return Fortran.Complex is\n-   begin\n-      return (Fortran.Real (X.Re), Fortran.Real (X.Im));\n-   end To_Fortran;\n-\n-   ---------\n-   -- dot --\n-   ---------\n-\n-   function dot\n-     (N     : Positive;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Complex_Vector;\n-      Inc_Y : Integer := 1) return Complex\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            type X_Ptr is access all BLAS.Complex_Vector (X'Range);\n-            type Y_Ptr is access all BLAS.Complex_Vector (Y'Range);\n-            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n-            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            return To_Complex (BLAS.cdotu (N, Conv_X (X'Address).all, Inc_X,\n-                                  Conv_Y (Y'Address).all, Inc_Y));\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            type X_Ptr is access all BLAS.Double_Complex_Vector (X'Range);\n-            type Y_Ptr is access all BLAS.Double_Complex_Vector (Y'Range);\n-            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n-            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            return To_Complex (BLAS.zdotu (N, Conv_X (X'Address).all, Inc_X,\n-                                     Conv_Y (Y'Address).all, Inc_Y));\n-         end;\n-\n-      else\n-         return To_Complex (BLAS.zdotu (N, To_Double_Complex (X), Inc_X,\n-                                  To_Double_Complex (Y), Inc_Y));\n-      end if;\n-   end dot;\n-\n-   ----------\n-   -- gemm --\n-   ----------\n-\n-   procedure gemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Complex := (1.0, 0.0);\n-      A       : Complex_Matrix;\n-      Ld_A    : Integer;\n-      B       : Complex_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Complex := (0.0, 0.0);\n-      C       : in out Complex_Matrix;\n-      Ld_C    : Integer)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            subtype A_Type is BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n-            subtype B_Type is BLAS.Complex_Matrix (B'Range (1), B'Range (2));\n-            type C_Ptr is\n-              access all BLAS.Complex_Matrix (C'Range (1), C'Range (2));\n-            function Conv_A is\n-               new Unchecked_Conversion (Complex_Matrix, A_Type);\n-            function Conv_B is\n-               new Unchecked_Conversion (Complex_Matrix, B_Type);\n-            function Conv_C is\n-               new Unchecked_Conversion (Address, C_Ptr);\n-         begin\n-            BLAS.cgemm (Trans_A, Trans_B, M, N, K, To_Fortran (Alpha),\n-                   Conv_A (A), Ld_A, Conv_B (B), Ld_B, To_Fortran (Beta),\n-                   Conv_C (C'Address).all, Ld_C);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            subtype A_Type is\n-               BLAS.Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            subtype B_Type is\n-               BLAS.Double_Complex_Matrix (B'Range (1), B'Range (2));\n-            type C_Ptr is access all\n-               BLAS.Double_Complex_Matrix (C'Range (1), C'Range (2));\n-            function Conv_A is\n-               new Unchecked_Conversion (Complex_Matrix, A_Type);\n-            function Conv_B is\n-               new Unchecked_Conversion (Complex_Matrix, B_Type);\n-            function Conv_C is new Unchecked_Conversion (Address, C_Ptr);\n-         begin\n-            BLAS.zgemm (Trans_A, Trans_B, M, N, K, To_Double_Complex (Alpha),\n-                   Conv_A (A), Ld_A, Conv_B (B), Ld_B,\n-                   To_Double_Complex (Beta),\n-                   Conv_C (C'Address).all, Ld_C);\n-         end;\n-\n-      else\n-         declare\n-            DP_C : BLAS.Double_Complex_Matrix (C'Range (1), C'Range (2));\n-         begin\n-            if Beta.Re /= 0.0 or else Beta.Im /= 0.0 then\n-               DP_C := To_Double_Complex (C);\n-            end if;\n-\n-            BLAS.zgemm (Trans_A, Trans_B, M, N, K, To_Double_Complex (Alpha),\n-                   To_Double_Complex (A), Ld_A,\n-                   To_Double_Complex (B), Ld_B, To_Double_Complex (Beta),\n-                   DP_C, Ld_C);\n-\n-            C := To_Complex (DP_C);\n-         end;\n-      end if;\n-   end gemm;\n-\n-   ----------\n-   -- gemv --\n-   ----------\n-\n-   procedure gemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Complex := (1.0, 0.0);\n-      A     : Complex_Matrix;\n-      Ld_A  : Positive;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1;\n-      Beta  : Complex := (0.0, 0.0);\n-      Y     : in out Complex_Vector;\n-      Inc_Y : Integer := 1)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            subtype A_Type is BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n-            subtype X_Type is BLAS.Complex_Vector (X'Range);\n-            type Y_Ptr is access all BLAS.Complex_Vector (Y'Range);\n-            function Conv_A is\n-               new Unchecked_Conversion (Complex_Matrix, A_Type);\n-            function Conv_X is\n-               new Unchecked_Conversion (Complex_Vector, X_Type);\n-            function Conv_Y is\n-               new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            BLAS.cgemv (Trans, M, N, To_Fortran (Alpha),\n-                   Conv_A (A), Ld_A, Conv_X (X), Inc_X, To_Fortran (Beta),\n-                   Conv_Y (Y'Address).all, Inc_Y);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            subtype A_Type is\n-               BLAS.Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            subtype X_Type is\n-               BLAS.Double_Complex_Vector (X'Range);\n-            type Y_Ptr is access all BLAS.Double_Complex_Vector (Y'Range);\n-            function Conv_A is\n-               new Unchecked_Conversion (Complex_Matrix, A_Type);\n-            function Conv_X is\n-               new Unchecked_Conversion (Complex_Vector, X_Type);\n-            function Conv_Y is\n-               new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            BLAS.zgemv (Trans, M, N, To_Double_Complex (Alpha),\n-                   Conv_A (A), Ld_A, Conv_X (X), Inc_X,\n-                   To_Double_Complex (Beta),\n-                   Conv_Y (Y'Address).all, Inc_Y);\n-         end;\n-\n-      else\n-         declare\n-            DP_Y : BLAS.Double_Complex_Vector (Y'Range);\n-         begin\n-            if Beta.Re /= 0.0 or else Beta.Im /= 0.0 then\n-               DP_Y := To_Double_Complex (Y);\n-            end if;\n-\n-            BLAS.zgemv (Trans, M, N, To_Double_Complex (Alpha),\n-                   To_Double_Complex (A), Ld_A,\n-                   To_Double_Complex (X), Inc_X, To_Double_Complex (Beta),\n-                   DP_Y, Inc_Y);\n-\n-            Y := To_Complex (DP_Y);\n-         end;\n-      end if;\n-   end gemv;\n-\n-   ----------\n-   -- nrm2 --\n-   ----------\n-\n-   function nrm2\n-     (N     : Natural;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1) return Real\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            subtype X_Type is BLAS.Complex_Vector (X'Range);\n-            function Conv_X is\n-               new Unchecked_Conversion (Complex_Vector, X_Type);\n-         begin\n-            return Real (BLAS.scnrm2 (N, Conv_X (X), Inc_X));\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            subtype X_Type is BLAS.Double_Complex_Vector (X'Range);\n-            function Conv_X is\n-               new Unchecked_Conversion (Complex_Vector, X_Type);\n-         begin\n-            return Real (BLAS.dznrm2 (N, Conv_X (X), Inc_X));\n-         end;\n-\n-      else\n-         return Real (BLAS.dznrm2 (N, To_Double_Complex (X), Inc_X));\n-      end if;\n-   end nrm2;\n-\n-end System.Generic_Complex_BLAS;"}, {"sha": "85bd3b50bf06384128e09e6a6ea42cd04244f3b6", "filename": "gcc/ada/s-gecobl.ads", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecobl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecobl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecobl.ads?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,102 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . G E N E R I C _ C O M P L E X _ B L A S          --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---         Copyright (C) 2006-2009, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Package comment required ???\n-\n-with Ada.Numerics.Generic_Complex_Types;\n-\n-generic\n-   type Real is digits <>;\n-   with package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Real);\n-   use Complex_Types;\n-\n-   type Complex_Vector is array (Integer range <>) of Complex;\n-   type Complex_Matrix is array (Integer range <>, Integer range <>)\n-      of Complex;\n-package System.Generic_Complex_BLAS is\n-   pragma Pure;\n-\n-   --  Although BLAS support is only available for IEEE single and double\n-   --  compatible floating-point types, this unit will accept any type\n-   --  and apply conversions as necessary, with possible loss of\n-   --  precision and range.\n-\n-   No_Trans   : aliased constant Character := 'N';\n-   Trans      : aliased constant Character := 'T';\n-   Conj_Trans : aliased constant Character := 'C';\n-\n-   --  BLAS Level 1 Subprograms and Types\n-\n-   function dot\n-     (N     : Positive;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Complex_Vector;\n-      Inc_Y : Integer := 1) return Complex;\n-\n-   function nrm2\n-     (N     : Natural;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1) return Real;\n-\n-   procedure gemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Complex := (1.0, 0.0);\n-      A     : Complex_Matrix;\n-      Ld_A  : Positive;\n-      X     : Complex_Vector;\n-      Inc_X : Integer := 1;  -- must be non-zero\n-      Beta  : Complex := (0.0, 0.0);\n-      Y     : in out Complex_Vector;\n-      Inc_Y : Integer := 1); -- must be non-zero\n-\n-   --  BLAS Level 3\n-\n-   --  gemm   s, d, c, z  Matrix-matrix product of general matrices\n-\n-   procedure gemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Complex := (1.0, 0.0);\n-      A       : Complex_Matrix;\n-      Ld_A    : Integer;\n-      B       : Complex_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Complex := (0.0, 0.0);\n-      C       : in out Complex_Matrix;\n-      Ld_C    : Integer);\n-\n-end System.Generic_Complex_BLAS;"}, {"sha": "ad69fee9bc5ff2fcb49c85f0107ad171bc0d241f", "filename": "gcc/ada/s-gecola.adb", "status": "removed", "additions": 0, "deletions": 493, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecola.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecola.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecola.adb?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,493 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---         S Y S T E M . G E N E R I C _ C O M P L E X _ L A P A C K        --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Unchecked_Conversion;        use Ada;\n-with Interfaces;                      use Interfaces;\n-with Interfaces.Fortran;              use Interfaces.Fortran;\n-with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n-with Interfaces.Fortran.LAPACK;       use Interfaces.Fortran.LAPACK;\n-with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n-\n-package body System.Generic_Complex_LAPACK is\n-\n-   Is_Single : constant Boolean :=\n-                 Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n-                  and then Fortran.Real (Real'First) = Fortran.Real'First\n-                  and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n-\n-   Is_Double : constant Boolean :=\n-                 Real'Machine_Mantissa = Double_Precision'Machine_Mantissa\n-                  and then\n-                    Double_Precision (Real'First) = Double_Precision'First\n-                  and then\n-                    Double_Precision (Real'Last) = Double_Precision'Last;\n-\n-   subtype Complex is Complex_Types.Complex;\n-\n-   --  Local subprograms\n-\n-   function To_Double_Precision (X : Real) return Double_Precision;\n-   pragma Inline (To_Double_Precision);\n-\n-   function To_Real (X : Double_Precision) return Real;\n-   pragma Inline (To_Real);\n-\n-   function To_Double_Complex (X : Complex) return Double_Complex;\n-   pragma Inline (To_Double_Complex);\n-\n-   function To_Complex (X : Double_Complex) return Complex;\n-   pragma Inline (To_Complex);\n-\n-   --  Instantiations\n-\n-   function To_Double_Precision is new\n-      Vector_Elementwise_Operation\n-       (X_Scalar      => Real,\n-        Result_Scalar => Double_Precision,\n-        X_Vector      => Real_Vector,\n-        Result_Vector => Double_Precision_Vector,\n-        Operation     => To_Double_Precision);\n-\n-   function To_Real is new\n-      Vector_Elementwise_Operation\n-       (X_Scalar      => Double_Precision,\n-        Result_Scalar => Real,\n-        X_Vector      => Double_Precision_Vector,\n-        Result_Vector => Real_Vector,\n-        Operation     => To_Real);\n-\n-   function To_Double_Complex is new\n-     Matrix_Elementwise_Operation\n-       (X_Scalar      => Complex,\n-        Result_Scalar => Double_Complex,\n-        X_Matrix      => Complex_Matrix,\n-        Result_Matrix => Double_Complex_Matrix,\n-        Operation     => To_Double_Complex);\n-\n-   function To_Complex is new\n-     Matrix_Elementwise_Operation\n-       (X_Scalar      => Double_Complex,\n-        Result_Scalar => Complex,\n-        X_Matrix      => Double_Complex_Matrix,\n-        Result_Matrix => Complex_Matrix,\n-        Operation     => To_Complex);\n-\n-   function To_Double_Precision (X : Real) return Double_Precision is\n-   begin\n-      return Double_Precision (X);\n-   end To_Double_Precision;\n-\n-   function To_Real (X : Double_Precision) return Real is\n-   begin\n-      return Real (X);\n-   end To_Real;\n-\n-   function To_Double_Complex (X : Complex) return Double_Complex is\n-   begin\n-      return (To_Double_Precision (X.Re), To_Double_Precision (X.Im));\n-   end To_Double_Complex;\n-\n-   function To_Complex (X : Double_Complex) return Complex is\n-   begin\n-      return (Real (X.Re), Real (X.Im));\n-   end To_Complex;\n-\n-   -----------\n-   -- getrf --\n-   -----------\n-\n-   procedure getrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Complex_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            type A_Ptr is\n-               access all BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-         begin\n-            cgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv), Info);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            type A_Ptr is\n-               access all Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-         begin\n-            zgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv), Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n-         begin\n-            DP_A := To_Double_Complex (A);\n-            zgetrf (M, N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv), Info);\n-            A := To_Complex (DP_A);\n-         end;\n-      end if;\n-   end getrf;\n-\n-   -----------\n-   -- getri --\n-   -----------\n-\n-   procedure getri\n-     (N      : Natural;\n-      A      : in out Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Complex_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            type A_Ptr is\n-               access all BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n-            type Work_Ptr is\n-               access all BLAS.Complex_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            cgetri (N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            type A_Ptr is\n-               access all Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            type Work_Ptr is\n-               access all Double_Complex_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            zgetri (N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            DP_Work : Double_Complex_Vector (Work'Range);\n-         begin\n-            DP_A := To_Double_Complex (A);\n-            zgetri (N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv),\n-                    DP_Work, L_Work, Info);\n-            A := To_Complex (DP_A);\n-            Work (1) := To_Complex (DP_Work (1));\n-         end;\n-      end if;\n-   end getri;\n-\n-   -----------\n-   -- getrs --\n-   -----------\n-\n-   procedure getrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Complex_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            subtype A_Type is BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n-            type B_Ptr is\n-               access all BLAS.Complex_Matrix (B'Range (1), B'Range (2));\n-            function Conv_A is\n-               new Unchecked_Conversion (Complex_Matrix, A_Type);\n-            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n-         begin\n-            cgetrs (Trans, N, N_Rhs,\n-                    Conv_A (A), Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_B (B'Address).all, Ld_B,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            subtype A_Type is\n-               Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            type B_Ptr is\n-               access all Double_Complex_Matrix (B'Range (1), B'Range (2));\n-            function Conv_A is\n-               new Unchecked_Conversion (Complex_Matrix, A_Type);\n-            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n-         begin\n-            zgetrs (Trans, N, N_Rhs,\n-                    Conv_A (A), Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_B (B'Address).all, Ld_B,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            DP_B : Double_Complex_Matrix (B'Range (1), B'Range (2));\n-         begin\n-            DP_A := To_Double_Complex (A);\n-            DP_B := To_Double_Complex (B);\n-            zgetrs (Trans, N, N_Rhs,\n-                    DP_A, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    DP_B, Ld_B,\n-                    Info);\n-            B := To_Complex (DP_B);\n-         end;\n-      end if;\n-   end getrs;\n-\n-   procedure heevr\n-     (Job_Z    : access constant Character;\n-      Rng      : access constant Character;\n-      Uplo     : access constant Character;\n-      N        : Natural;\n-      A        : in out Complex_Matrix;\n-      Ld_A     : Positive;\n-      Vl, Vu   : Real := 0.0;\n-      Il, Iu   : Integer := 1;\n-      Abs_Tol  : Real := 0.0;\n-      M        : out Integer;\n-      W        : out Real_Vector;\n-      Z        : out Complex_Matrix;\n-      Ld_Z     : Positive;\n-      I_Supp_Z : out Integer_Vector;\n-      Work     : out Complex_Vector;\n-      L_Work   : Integer;\n-      R_Work   : out Real_Vector;\n-      LR_Work  : Integer;\n-      I_Work   : out Integer_Vector;\n-      LI_Work  : Integer;\n-      Info     : access Integer)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            type A_Ptr is\n-               access all BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n-            type W_Ptr is\n-               access all BLAS.Real_Vector (W'Range);\n-            type Z_Ptr is\n-               access all BLAS.Complex_Matrix (Z'Range (1), Z'Range (2));\n-            type Work_Ptr is access all  BLAS.Complex_Vector (Work'Range);\n-            type R_Work_Ptr is access all BLAS.Real_Vector (R_Work'Range);\n-\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_W is new Unchecked_Conversion (Address, W_Ptr);\n-            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-            function Conv_R_Work is\n-               new Unchecked_Conversion (Address, R_Work_Ptr);\n-         begin\n-            cheevr (Job_Z, Rng, Uplo, N,\n-                    Conv_A (A'Address).all, Ld_A,\n-                    Fortran.Real (Vl), Fortran.Real (Vu),\n-                    Il, Iu, Fortran.Real (Abs_Tol), M,\n-                    Conv_W (W'Address).all,\n-                    Conv_Z (Z'Address).all, Ld_Z,\n-                    LAPACK.Integer_Vector (I_Supp_Z),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Conv_R_Work (R_Work'Address).all, LR_Work,\n-                    LAPACK.Integer_Vector (I_Work), LI_Work, Info);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            type A_Ptr is\n-              access all BLAS.Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            type W_Ptr is\n-              access all BLAS.Double_Precision_Vector (W'Range);\n-            type Z_Ptr is\n-              access all BLAS.Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n-            type Work_Ptr is\n-               access all BLAS.Double_Complex_Vector (Work'Range);\n-            type R_Work_Ptr is\n-               access all BLAS.Double_Precision_Vector (R_Work'Range);\n-\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_W is new Unchecked_Conversion (Address, W_Ptr);\n-            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-            function Conv_R_Work is\n-               new Unchecked_Conversion (Address, R_Work_Ptr);\n-         begin\n-            zheevr (Job_Z, Rng, Uplo, N,\n-                    Conv_A (A'Address).all, Ld_A,\n-                    Double_Precision (Vl), Double_Precision (Vu),\n-                    Il, Iu, Double_Precision (Abs_Tol), M,\n-                    Conv_W (W'Address).all,\n-                    Conv_Z (Z'Address).all, Ld_Z,\n-                    LAPACK.Integer_Vector (I_Supp_Z),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Conv_R_Work (R_Work'Address).all, LR_Work,\n-                    LAPACK.Integer_Vector (I_Work), LI_Work, Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n-            DP_W : Double_Precision_Vector (W'Range);\n-            DP_Z : Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n-            DP_Work : Double_Complex_Vector (Work'Range);\n-            DP_R_Work : Double_Precision_Vector (R_Work'Range);\n-\n-         begin\n-            DP_A := To_Double_Complex (A);\n-\n-            zheevr (Job_Z, Rng, Uplo, N,\n-                    DP_A, Ld_A,\n-                    Double_Precision (Vl), Double_Precision (Vu),\n-                    Il, Iu, Double_Precision (Abs_Tol), M,\n-                    DP_W, DP_Z, Ld_Z,\n-                    LAPACK.Integer_Vector (I_Supp_Z),\n-                    DP_Work, L_Work,\n-                    DP_R_Work, LR_Work,\n-                    LAPACK.Integer_Vector (I_Work), LI_Work, Info);\n-\n-            A := To_Complex (DP_A);\n-            W := To_Real (DP_W);\n-            Z := To_Complex (DP_Z);\n-\n-            Work (1) := To_Complex (DP_Work (1));\n-            R_Work (1) := To_Real (DP_R_Work (1));\n-         end;\n-      end if;\n-   end heevr;\n-\n-   -----------\n-   -- steqr --\n-   -----------\n-\n-   procedure steqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Z      : in out Complex_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Real_Vector;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n-            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n-            type Z_Ptr is\n-               access all BLAS.Complex_Matrix (Z'Range (1), Z'Range (2));\n-            type Work_Ptr is\n-               access all BLAS.Real_Vector (Work'Range);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            csteqr (Comp_Z, N,\n-                    Conv_D (D'Address).all,\n-                    Conv_E (E'Address).all,\n-                    Conv_Z (Z'Address).all,\n-                    Ld_Z,\n-                    Conv_Work (Work'Address).all,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            type D_Ptr is access all Double_Precision_Vector (D'Range);\n-            type E_Ptr is access all Double_Precision_Vector (E'Range);\n-            type Z_Ptr is\n-               access all Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n-            type Work_Ptr is\n-               access all Double_Precision_Vector (Work'Range);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            zsteqr (Comp_Z, N,\n-                    Conv_D (D'Address).all,\n-                    Conv_E (E'Address).all,\n-                    Conv_Z (Z'Address).all,\n-                    Ld_Z,\n-                    Conv_Work (Work'Address).all,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_D    : Double_Precision_Vector (D'Range);\n-            DP_E    : Double_Precision_Vector (E'Range);\n-            DP_Z    : Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n-            DP_Work : Double_Precision_Vector (Work'Range);\n-         begin\n-            DP_D := To_Double_Precision (D);\n-            DP_E := To_Double_Precision (E);\n-\n-            if Comp_Z.all = 'V' then\n-               DP_Z := To_Double_Complex (Z);\n-            end if;\n-\n-            zsteqr (Comp_Z, N, DP_D, DP_E, DP_Z, Ld_Z, DP_Work, Info);\n-\n-            D := To_Real (DP_D);\n-            E := To_Real (DP_E);\n-\n-            if Comp_Z.all /= 'N' then\n-               Z := To_Complex (DP_Z);\n-            end if;\n-         end;\n-      end if;\n-   end steqr;\n-\n-end System.Generic_Complex_LAPACK;"}, {"sha": "eb8741ac0463dba970e56378a0f155a87190dbab", "filename": "gcc/ada/s-gecola.ads", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecola.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gecola.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecola.ads?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,131 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---         S Y S T E M . G E N E R I C _ C O M P L E X _ L A P A C K        --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Package comment required ???\n-\n-with Ada.Numerics.Generic_Complex_Types;\n-generic\n-   type Real is digits <>;\n-   type Real_Vector is array (Integer range <>) of Real;\n-\n-   with package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Real);\n-   use Complex_Types;\n-\n-   type Complex_Vector is array (Integer range <>) of Complex;\n-   type Complex_Matrix is array (Integer range <>, Integer range <>)\n-      of Complex;\n-package System.Generic_Complex_LAPACK is\n-   pragma Pure;\n-\n-   type Integer_Vector is array (Integer range <>) of Integer;\n-\n-   Upper : aliased constant Character := 'U';\n-   Lower : aliased constant Character := 'L';\n-\n-   --  LAPACK Computational Routines\n-\n-   --  getrf computes LU factorization of a general m-by-n matrix\n-\n-   procedure getrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Complex_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer);\n-\n-   --  getri computes inverse of an LU-factored square matrix,\n-   --  with multiple right-hand sides\n-\n-   procedure getri\n-     (N      : Natural;\n-      A      : in out Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Complex_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   --  getrs solves a system of linear equations with an LU-factored\n-   --  square matrix, with multiple right-hand sides\n-\n-   procedure getrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Complex_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Complex_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer);\n-\n-   --  heevr computes selected eigenvalues and, optionally,\n-   --  eigenvectors of a Hermitian matrix using the Relatively\n-   --  Robust Representations\n-\n-   procedure heevr\n-     (Job_Z    : access constant Character;\n-      Rng      : access constant Character;\n-      Uplo     : access constant Character;\n-      N        : Natural;\n-      A        : in out Complex_Matrix;\n-      Ld_A     : Positive;\n-      Vl, Vu   : Real := 0.0;\n-      Il, Iu   : Integer := 1;\n-      Abs_Tol  : Real := 0.0;\n-      M        : out Integer;\n-      W        : out Real_Vector;\n-      Z        : out Complex_Matrix;\n-      Ld_Z     : Positive;\n-      I_Supp_Z : out Integer_Vector;\n-      Work     : out Complex_Vector;\n-      L_Work   : Integer;\n-      R_Work   : out Real_Vector;\n-      LR_Work  : Integer;\n-      I_Work   : out Integer_Vector;\n-      LI_Work  : Integer;\n-      Info     : access Integer);\n-\n-   --  steqr computes all eigenvalues and eigenvectors of a symmetric or\n-   --  Hermitian matrix reduced to tridiagonal form (QR algorithm)\n-\n-   procedure steqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Z      : in out Complex_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Real_Vector;\n-      Info   : access Integer);\n-\n-end System.Generic_Complex_LAPACK;"}, {"sha": "fc2f5d7d60453d0fb6d6a631392ac3740a343f05", "filename": "gcc/ada/s-gerebl.adb", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerebl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerebl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerebl.adb?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,311 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---             S Y S T E M . G E N E R I C _ R E A L _ B L A S              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Unchecked_Conversion;        use Ada;\n-with Interfaces;                      use Interfaces;\n-with Interfaces.Fortran;              use Interfaces.Fortran;\n-with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n-with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n-\n-package body System.Generic_Real_BLAS is\n-\n-   Is_Single : constant Boolean :=\n-                 Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n-                  and then Fortran.Real (Real'First) = Fortran.Real'First\n-                  and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n-\n-   Is_Double : constant Boolean :=\n-                 Real'Machine_Mantissa = Double_Precision'Machine_Mantissa\n-                  and then\n-                    Double_Precision (Real'First) = Double_Precision'First\n-                  and then\n-                    Double_Precision (Real'Last) = Double_Precision'Last;\n-\n-   --  Local subprograms\n-\n-   function To_Double_Precision (X : Real) return Double_Precision;\n-   pragma Inline_Always (To_Double_Precision);\n-\n-   function To_Real (X : Double_Precision) return Real;\n-   pragma Inline_Always (To_Real);\n-\n-   --  Instantiations\n-\n-   function To_Double_Precision is new\n-     Vector_Elementwise_Operation\n-       (X_Scalar      => Real,\n-        Result_Scalar => Double_Precision,\n-        X_Vector      => Real_Vector,\n-        Result_Vector => Double_Precision_Vector,\n-        Operation     => To_Double_Precision);\n-\n-   function To_Real is new\n-     Vector_Elementwise_Operation\n-       (X_Scalar      => Double_Precision,\n-        Result_Scalar => Real,\n-        X_Vector      => Double_Precision_Vector,\n-        Result_Vector => Real_Vector,\n-        Operation     => To_Real);\n-\n-   function To_Double_Precision is new\n-     Matrix_Elementwise_Operation\n-       (X_Scalar      => Real,\n-        Result_Scalar => Double_Precision,\n-        X_Matrix      => Real_Matrix,\n-        Result_Matrix => Double_Precision_Matrix,\n-        Operation     => To_Double_Precision);\n-\n-   function To_Real is new\n-     Matrix_Elementwise_Operation\n-       (X_Scalar      => Double_Precision,\n-        Result_Scalar => Real,\n-        X_Matrix      => Double_Precision_Matrix,\n-        Result_Matrix => Real_Matrix,\n-        Operation     => To_Real);\n-\n-   function To_Double_Precision (X : Real) return Double_Precision is\n-   begin\n-      return Double_Precision (X);\n-   end To_Double_Precision;\n-\n-   function To_Real (X : Double_Precision) return Real is\n-   begin\n-      return Real (X);\n-   end To_Real;\n-\n-   ---------\n-   -- dot --\n-   ---------\n-\n-   function dot\n-     (N     : Positive;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Real_Vector;\n-      Inc_Y : Integer := 1) return Real\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            type X_Ptr is access all BLAS.Real_Vector (X'Range);\n-            type Y_Ptr is access all BLAS.Real_Vector (Y'Range);\n-            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n-            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            return Real (sdot (N, Conv_X (X'Address).all, Inc_X,\n-                                  Conv_Y (Y'Address).all, Inc_Y));\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            type X_Ptr is access all BLAS.Double_Precision_Vector (X'Range);\n-            type Y_Ptr is access all BLAS.Double_Precision_Vector (Y'Range);\n-            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n-            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            return Real (ddot (N, Conv_X (X'Address).all, Inc_X,\n-                                  Conv_Y (Y'Address).all, Inc_Y));\n-         end;\n-\n-      else\n-         return Real (ddot (N, To_Double_Precision (X), Inc_X,\n-                               To_Double_Precision (Y), Inc_Y));\n-      end if;\n-   end dot;\n-\n-   ----------\n-   -- gemm --\n-   ----------\n-\n-   procedure gemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Real := 1.0;\n-      A       : Real_Matrix;\n-      Ld_A    : Integer;\n-      B       : Real_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Real := 0.0;\n-      C       : in out Real_Matrix;\n-      Ld_C    : Integer)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            subtype A_Type is BLAS.Real_Matrix (A'Range (1), A'Range (2));\n-            subtype B_Type is BLAS.Real_Matrix (B'Range (1), B'Range (2));\n-            type C_Ptr is\n-              access all BLAS.Real_Matrix (C'Range (1), C'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n-            function Conv_B is new Unchecked_Conversion (Real_Matrix, B_Type);\n-            function Conv_C is new Unchecked_Conversion (Address, C_Ptr);\n-         begin\n-            sgemm (Trans_A, Trans_B, M, N, K, Fortran.Real (Alpha),\n-                   Conv_A (A), Ld_A, Conv_B (B), Ld_B, Fortran.Real (Beta),\n-                   Conv_C (C'Address).all, Ld_C);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            subtype A_Type is\n-               Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            subtype B_Type is\n-               Double_Precision_Matrix (B'Range (1), B'Range (2));\n-            type C_Ptr is\n-              access all Double_Precision_Matrix (C'Range (1), C'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n-            function Conv_B is new Unchecked_Conversion (Real_Matrix, B_Type);\n-            function Conv_C is new Unchecked_Conversion (Address, C_Ptr);\n-         begin\n-            dgemm (Trans_A, Trans_B, M, N, K, Double_Precision (Alpha),\n-                   Conv_A (A), Ld_A, Conv_B (B), Ld_B, Double_Precision (Beta),\n-                   Conv_C (C'Address).all, Ld_C);\n-         end;\n-\n-      else\n-         declare\n-            DP_C : Double_Precision_Matrix (C'Range (1), C'Range (2));\n-         begin\n-            if Beta /= 0.0 then\n-               DP_C := To_Double_Precision (C);\n-            end if;\n-\n-            dgemm (Trans_A, Trans_B, M, N, K, Double_Precision (Alpha),\n-                   To_Double_Precision (A), Ld_A,\n-                   To_Double_Precision (B), Ld_B, Double_Precision (Beta),\n-                   DP_C, Ld_C);\n-\n-            C := To_Real (DP_C);\n-         end;\n-      end if;\n-   end gemm;\n-\n-   ----------\n-   -- gemv --\n-   ----------\n-\n-   procedure gemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Real := 1.0;\n-      A     : Real_Matrix;\n-      Ld_A  : Positive;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1;\n-      Beta  : Real := 0.0;\n-      Y     : in out Real_Vector;\n-      Inc_Y : Integer := 1)\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            subtype A_Type is BLAS.Real_Matrix (A'Range (1), A'Range (2));\n-            subtype X_Type is BLAS.Real_Vector (X'Range);\n-            type Y_Ptr is access all BLAS.Real_Vector (Y'Range);\n-            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n-            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n-            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            sgemv (Trans, M, N, Fortran.Real (Alpha),\n-                   Conv_A (A), Ld_A, Conv_X (X), Inc_X, Fortran.Real (Beta),\n-                   Conv_Y (Y'Address).all, Inc_Y);\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            subtype A_Type is\n-               Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            subtype X_Type is Double_Precision_Vector (X'Range);\n-            type Y_Ptr is access all Double_Precision_Vector (Y'Range);\n-            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n-            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n-            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n-         begin\n-            dgemv (Trans, M, N, Double_Precision (Alpha),\n-                   Conv_A (A), Ld_A, Conv_X (X), Inc_X,\n-                   Double_Precision (Beta),\n-                   Conv_Y (Y'Address).all, Inc_Y);\n-         end;\n-\n-      else\n-         declare\n-            DP_Y : Double_Precision_Vector (Y'Range);\n-         begin\n-            if Beta /= 0.0 then\n-               DP_Y := To_Double_Precision (Y);\n-            end if;\n-\n-            dgemv (Trans, M, N, Double_Precision (Alpha),\n-                   To_Double_Precision (A), Ld_A,\n-                   To_Double_Precision (X), Inc_X, Double_Precision (Beta),\n-                   DP_Y, Inc_Y);\n-\n-            Y := To_Real (DP_Y);\n-         end;\n-      end if;\n-   end gemv;\n-\n-   ----------\n-   -- nrm2 --\n-   ----------\n-\n-   function nrm2\n-     (N     : Natural;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1) return Real\n-   is\n-   begin\n-      if Is_Single then\n-         declare\n-            subtype X_Type is BLAS.Real_Vector (X'Range);\n-            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n-         begin\n-            return Real (snrm2 (N, Conv_X (X), Inc_X));\n-         end;\n-\n-      elsif Is_Double then\n-         declare\n-            subtype X_Type is Double_Precision_Vector (X'Range);\n-            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n-         begin\n-            return Real (dnrm2 (N, Conv_X (X), Inc_X));\n-         end;\n-\n-      else\n-         return Real (dnrm2 (N, To_Double_Precision (X), Inc_X));\n-      end if;\n-   end nrm2;\n-\n-end System.Generic_Real_BLAS;"}, {"sha": "dacbf7bdb132803652920d609234b7b7a886243f", "filename": "gcc/ada/s-gerebl.ads", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerebl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerebl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerebl.ads?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,96 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                         SYSTEM.GENERIC_REAL_BLAS                         --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---            Copyright (C) 2009, Free Software Foundation, Inc.            --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Package comment required ???\n-\n-generic\n-   type Real is digits <>;\n-   type Real_Vector is array (Integer range <>) of Real;\n-   type Real_Matrix is array (Integer range <>, Integer range <>) of Real;\n-package System.Generic_Real_BLAS is\n-   pragma Pure;\n-\n-   --  Although BLAS support is only available for IEEE single and double\n-   --  compatible floating-point types, this unit will accept any type\n-   --  and apply conversions as necessary, with possible loss of\n-   --  precision and range.\n-\n-   No_Trans   : aliased constant Character := 'N';\n-   Trans      : aliased constant Character := 'T';\n-   Conj_Trans : aliased constant Character := 'C';\n-\n-   --  BLAS Level 1 Subprograms and Types\n-\n-   function dot\n-     (N     : Positive;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1;\n-      Y     : Real_Vector;\n-      Inc_Y : Integer := 1) return Real;\n-\n-   function nrm2\n-     (N     : Natural;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1) return Real;\n-\n-   procedure gemv\n-     (Trans : access constant Character;\n-      M     : Natural := 0;\n-      N     : Natural := 0;\n-      Alpha : Real := 1.0;\n-      A     : Real_Matrix;\n-      Ld_A  : Positive;\n-      X     : Real_Vector;\n-      Inc_X : Integer := 1;  -- must be non-zero\n-      Beta  : Real := 0.0;\n-      Y     : in out Real_Vector;\n-      Inc_Y : Integer := 1); -- must be non-zero\n-\n-   --  BLAS Level 3\n-\n-   --  gemm   s, d, c, z  Matrix-matrix product of general matrices\n-\n-   procedure gemm\n-     (Trans_A : access constant Character;\n-      Trans_B : access constant Character;\n-      M       : Positive;\n-      N       : Positive;\n-      K       : Positive;\n-      Alpha   : Real := 1.0;\n-      A       : Real_Matrix;\n-      Ld_A    : Integer;\n-      B       : Real_Matrix;\n-      Ld_B    : Integer;\n-      Beta    : Real := 0.0;\n-      C       : in out Real_Matrix;\n-      Ld_C    : Integer);\n-\n-end System.Generic_Real_BLAS;"}, {"sha": "57d3640ad4dc5c71be9ac4a998dd7a68df74bb78", "filename": "gcc/ada/s-gerela.adb", "status": "removed", "additions": 0, "deletions": 564, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerela.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerela.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerela.adb?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,564 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                        SYSTEM.GENERIC_REAL_LAPACK                        --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---            Copyright (C) 2009, Free Software Foundation, Inc.            --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Unchecked_Conversion;        use Ada;\n-with Interfaces;                      use Interfaces;\n-with Interfaces.Fortran;              use Interfaces.Fortran;\n-with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n-with Interfaces.Fortran.LAPACK;       use Interfaces.Fortran.LAPACK;\n-with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n-\n-package body System.Generic_Real_LAPACK is\n-\n-   Is_Real : constant Boolean :=\n-               Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n-                and then Fortran.Real (Real'First) = Fortran.Real'First\n-                and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n-\n-   Is_Double_Precision : constant Boolean :=\n-                           Real'Machine_Mantissa =\n-                                            Double_Precision'Machine_Mantissa\n-                            and then\n-                              Double_Precision (Real'First) =\n-                                            Double_Precision'First\n-                            and then\n-                              Double_Precision (Real'Last) =\n-                                            Double_Precision'Last;\n-\n-   --  Local subprograms\n-\n-   function To_Double_Precision (X : Real) return Double_Precision;\n-   pragma Inline_Always (To_Double_Precision);\n-\n-   function To_Real (X : Double_Precision) return Real;\n-   pragma Inline_Always (To_Real);\n-\n-   --  Instantiations\n-\n-   function To_Double_Precision is new\n-     Vector_Elementwise_Operation\n-       (X_Scalar      => Real,\n-        Result_Scalar => Double_Precision,\n-        X_Vector      => Real_Vector,\n-        Result_Vector => Double_Precision_Vector,\n-        Operation     => To_Double_Precision);\n-\n-   function To_Real is new\n-     Vector_Elementwise_Operation\n-       (X_Scalar      => Double_Precision,\n-        Result_Scalar => Real,\n-        X_Vector      => Double_Precision_Vector,\n-        Result_Vector => Real_Vector,\n-        Operation     => To_Real);\n-\n-   function To_Double_Precision is new\n-     Matrix_Elementwise_Operation\n-       (X_Scalar      => Real,\n-        Result_Scalar => Double_Precision,\n-        X_Matrix      => Real_Matrix,\n-        Result_Matrix => Double_Precision_Matrix,\n-        Operation     => To_Double_Precision);\n-\n-   function To_Real is new\n-     Matrix_Elementwise_Operation\n-       (X_Scalar      => Double_Precision,\n-        Result_Scalar => Real,\n-        X_Matrix      => Double_Precision_Matrix,\n-        Result_Matrix => Real_Matrix,\n-        Operation     => To_Real);\n-\n-   function To_Double_Precision (X : Real) return Double_Precision is\n-   begin\n-      return Double_Precision (X);\n-   end To_Double_Precision;\n-\n-   function To_Real (X : Double_Precision) return Real is\n-   begin\n-      return Real (X);\n-   end To_Real;\n-\n-   -----------\n-   -- getrf --\n-   -----------\n-\n-   procedure getrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Real_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer)\n-   is\n-   begin\n-      if Is_Real then\n-         declare\n-            type A_Ptr is\n-               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-         begin\n-            sgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv), Info);\n-         end;\n-\n-      elsif Is_Double_Precision then\n-         declare\n-            type A_Ptr is\n-               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-         begin\n-            dgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv), Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n-         begin\n-            DP_A := To_Double_Precision (A);\n-            dgetrf (M, N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv), Info);\n-            A := To_Real (DP_A);\n-         end;\n-      end if;\n-   end getrf;\n-\n-   -----------\n-   -- getri --\n-   -----------\n-\n-   procedure getri\n-     (N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Real then\n-         declare\n-            type A_Ptr is\n-               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n-            type Work_Ptr is\n-               access all BLAS.Real_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            sgetri (N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double_Precision then\n-         declare\n-            type A_Ptr is\n-               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            type Work_Ptr is\n-               access all Double_Precision_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            dgetri (N, Conv_A (A'Address).all, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            DP_Work : Double_Precision_Vector (Work'Range);\n-         begin\n-            DP_A := To_Double_Precision (A);\n-            dgetri (N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv),\n-                    DP_Work, L_Work, Info);\n-            A := To_Real (DP_A);\n-            Work (1) := To_Real (DP_Work (1));\n-         end;\n-      end if;\n-   end getri;\n-\n-   -----------\n-   -- getrs --\n-   -----------\n-\n-   procedure getrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Real_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Real_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Real then\n-         declare\n-            subtype A_Type is BLAS.Real_Matrix (A'Range (1), A'Range (2));\n-            type B_Ptr is\n-               access all BLAS.Real_Matrix (B'Range (1), B'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n-            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n-         begin\n-            sgetrs (Trans, N, N_Rhs,\n-                    Conv_A (A), Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_B (B'Address).all, Ld_B,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double_Precision then\n-         declare\n-            subtype A_Type is\n-               Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            type B_Ptr is\n-               access all Double_Precision_Matrix (B'Range (1), B'Range (2));\n-            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n-            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n-         begin\n-            dgetrs (Trans, N, N_Rhs,\n-                    Conv_A (A), Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    Conv_B (B'Address).all, Ld_B,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            DP_B : Double_Precision_Matrix (B'Range (1), B'Range (2));\n-         begin\n-            DP_A := To_Double_Precision (A);\n-            DP_B := To_Double_Precision (B);\n-            dgetrs (Trans, N, N_Rhs,\n-                    DP_A, Ld_A,\n-                    LAPACK.Integer_Vector (I_Piv),\n-                    DP_B, Ld_B,\n-                    Info);\n-            B := To_Real (DP_B);\n-         end;\n-      end if;\n-   end getrs;\n-\n-   -----------\n-   -- orgtr --\n-   -----------\n-\n-   procedure orgtr\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      Tau    : Real_Vector;\n-      Work   : out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Real then\n-         declare\n-            type A_Ptr is\n-               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n-            subtype Tau_Type is BLAS.Real_Vector (Tau'Range);\n-            type Work_Ptr is\n-               access all BLAS.Real_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_Tau is\n-               new Unchecked_Conversion (Real_Vector, Tau_Type);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            sorgtr (Uplo, N,\n-                    Conv_A (A'Address).all, Ld_A,\n-                    Conv_Tau (Tau),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double_Precision then\n-         declare\n-            type A_Ptr is\n-               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            subtype Tau_Type is Double_Precision_Vector (Tau'Range);\n-            type Work_Ptr is\n-               access all Double_Precision_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_Tau is\n-               new Unchecked_Conversion (Real_Vector, Tau_Type);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            dorgtr (Uplo, N,\n-                    Conv_A (A'Address).all, Ld_A,\n-                    Conv_Tau (Tau),\n-                    Conv_Work (Work'Address).all, L_Work,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            DP_Work : Double_Precision_Vector (Work'Range);\n-            DP_Tau  : Double_Precision_Vector (Tau'Range);\n-         begin\n-            DP_A := To_Double_Precision (A);\n-            DP_Tau := To_Double_Precision (Tau);\n-            dorgtr (Uplo, N, DP_A, Ld_A, DP_Tau, DP_Work, L_Work, Info);\n-            A := To_Real (DP_A);\n-            Work (1) := To_Real (DP_Work (1));\n-         end;\n-      end if;\n-   end orgtr;\n-\n-   -----------\n-   -- steqr --\n-   -----------\n-\n-   procedure steqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Z      : in out Real_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Real_Vector;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Real then\n-         declare\n-            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n-            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n-            type Z_Ptr is\n-               access all BLAS.Real_Matrix (Z'Range (1), Z'Range (2));\n-            type Work_Ptr is\n-               access all BLAS.Real_Vector (Work'Range);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            ssteqr (Comp_Z, N,\n-                    Conv_D (D'Address).all,\n-                    Conv_E (E'Address).all,\n-                    Conv_Z (Z'Address).all,\n-                    Ld_Z,\n-                    Conv_Work (Work'Address).all,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double_Precision then\n-         declare\n-            type D_Ptr is access all Double_Precision_Vector (D'Range);\n-            type E_Ptr is access all Double_Precision_Vector (E'Range);\n-            type Z_Ptr is\n-               access all Double_Precision_Matrix (Z'Range (1), Z'Range (2));\n-            type Work_Ptr is\n-               access all Double_Precision_Vector (Work'Range);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            dsteqr (Comp_Z, N,\n-                    Conv_D (D'Address).all,\n-                    Conv_E (E'Address).all,\n-                    Conv_Z (Z'Address).all,\n-                    Ld_Z,\n-                    Conv_Work (Work'Address).all,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_D    : Double_Precision_Vector (D'Range);\n-            DP_E    : Double_Precision_Vector (E'Range);\n-            DP_Z    : Double_Precision_Matrix (Z'Range (1), Z'Range (2));\n-            DP_Work : Double_Precision_Vector (Work'Range);\n-         begin\n-            DP_D := To_Double_Precision (D);\n-            DP_E := To_Double_Precision (E);\n-\n-            if Comp_Z.all = 'V' then\n-               DP_Z := To_Double_Precision (Z);\n-            end if;\n-\n-            dsteqr (Comp_Z, N, DP_D, DP_E, DP_Z, Ld_Z, DP_Work, Info);\n-\n-            D := To_Real (DP_D);\n-            E := To_Real (DP_E);\n-            Z := To_Real (DP_Z);\n-         end;\n-      end if;\n-   end steqr;\n-\n-   -----------\n-   -- sterf --\n-   -----------\n-\n-   procedure sterf\n-     (N    : Natural;\n-      D    : in out Real_Vector;\n-      E    : in out Real_Vector;\n-      Info : access Integer)\n-   is\n-   begin\n-      if Is_Real then\n-         declare\n-            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n-            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-         begin\n-            ssterf (N, Conv_D (D'Address).all, Conv_E (E'Address).all, Info);\n-         end;\n-\n-      elsif Is_Double_Precision then\n-         declare\n-            type D_Ptr is access all Double_Precision_Vector (D'Range);\n-            type E_Ptr is access all Double_Precision_Vector (E'Range);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-         begin\n-            dsterf (N, Conv_D (D'Address).all, Conv_E (E'Address).all, Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_D    : Double_Precision_Vector (D'Range);\n-            DP_E    : Double_Precision_Vector (E'Range);\n-\n-         begin\n-            DP_D := To_Double_Precision (D);\n-            DP_E := To_Double_Precision (E);\n-\n-            dsterf (N, DP_D, DP_E, Info);\n-\n-            D := To_Real (DP_D);\n-            E := To_Real (DP_E);\n-         end;\n-      end if;\n-   end sterf;\n-\n-   -----------\n-   -- sytrd --\n-   -----------\n-\n-   procedure sytrd\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      D      : out Real_Vector;\n-      E      : out Real_Vector;\n-      Tau    : out Real_Vector;\n-      Work   : out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer)\n-   is\n-   begin\n-      if Is_Real then\n-         declare\n-            type A_Ptr is\n-               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n-            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n-            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n-            type Tau_Ptr is access all BLAS.Real_Vector (Tau'Range);\n-            type Work_Ptr is\n-               access all BLAS.Real_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-            function Conv_Tau is new Unchecked_Conversion (Address, Tau_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            ssytrd (Uplo, N,\n-                    Conv_A (A'Address).all, Ld_A,\n-                    Conv_D (D'Address).all,\n-                    Conv_E (E'Address).all,\n-                    Conv_Tau (Tau'Address).all,\n-                    Conv_Work (Work'Address).all,\n-                    L_Work,\n-                    Info);\n-         end;\n-\n-      elsif Is_Double_Precision then\n-         declare\n-            type A_Ptr is\n-               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            type D_Ptr is access all Double_Precision_Vector (D'Range);\n-            type E_Ptr is access all Double_Precision_Vector (E'Range);\n-            type Tau_Ptr is access all Double_Precision_Vector (Tau'Range);\n-            type Work_Ptr is\n-               access all Double_Precision_Vector (Work'Range);\n-            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n-            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n-            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n-            function Conv_Tau is new Unchecked_Conversion (Address, Tau_Ptr);\n-            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n-         begin\n-            dsytrd (Uplo, N,\n-                    Conv_A (A'Address).all, Ld_A,\n-                    Conv_D (D'Address).all,\n-                    Conv_E (E'Address).all,\n-                    Conv_Tau (Tau'Address).all,\n-                    Conv_Work (Work'Address).all,\n-                    L_Work,\n-                    Info);\n-         end;\n-\n-      else\n-         declare\n-            DP_A    : Double_Precision_Matrix (A'Range (1), A'Range (2));\n-            DP_D    : Double_Precision_Vector (D'Range);\n-            DP_E    : Double_Precision_Vector (E'Range);\n-            DP_Tau  : Double_Precision_Vector (Tau'Range);\n-            DP_Work : Double_Precision_Vector (Work'Range);\n-         begin\n-            DP_A := To_Double_Precision (A);\n-\n-            dsytrd (Uplo, N, DP_A, Ld_A, DP_D, DP_E, DP_Tau,\n-                    DP_Work, L_Work, Info);\n-\n-            if L_Work /= -1 then\n-               A := To_Real (DP_A);\n-               D := To_Real (DP_D);\n-               E := To_Real (DP_E);\n-               Tau := To_Real (DP_Tau);\n-            end if;\n-\n-            Work (1) := To_Real (DP_Work (1));\n-         end;\n-      end if;\n-   end sytrd;\n-\n-end System.Generic_Real_LAPACK;"}, {"sha": "c09ce81d027d1844ddad79a6e2eafb6781790745", "filename": "gcc/ada/s-gerela.ads", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerela.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c6321d455dd13aeb1d5d19615fd10407dd71d/gcc%2Fada%2Fs-gerela.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerela.ads?ref=635c6321d455dd13aeb1d5d19615fd10407dd71d", "patch": "@@ -1,128 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . G E N E R I C _ R E A L _ L A P A C K            --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Package comment required ???\n-\n-generic\n-   type Real is digits <>;\n-   type Real_Vector is array (Integer range <>) of Real;\n-   type Real_Matrix is array (Integer range <>, Integer range <>) of Real;\n-package System.Generic_Real_LAPACK is\n-   pragma Pure;\n-\n-   type Integer_Vector is array (Integer range <>) of Integer;\n-\n-   Upper : aliased constant Character := 'U';\n-   Lower : aliased constant Character := 'L';\n-\n-   --  LAPACK Computational Routines\n-\n-   --  gerfs  Refines the solution of a system of linear equations with\n-   --         a general matrix and estimates its error\n-   --  getrf  Computes LU factorization of a general m-by-n matrix\n-   --  getri  Computes inverse of an LU-factored general matrix\n-   --         square matrix, with multiple right-hand sides\n-   --  getrs  Solves a system of linear equations with an LU-factored\n-   --         square matrix, with multiple right-hand sides\n-   --  orgtr  Generates the Float orthogonal matrix Q determined by sytrd\n-   --  steqr  Computes all eigenvalues and eigenvectors of a symmetric or\n-   --         Hermitian matrix reduced to tridiagonal form (QR algorithm)\n-   --  sterf  Computes all eigenvalues of a Float symmetric\n-   --         tridiagonal matrix using QR algorithm\n-   --  sytrd  Reduces a Float symmetric matrix to tridiagonal form\n-\n-   procedure getrf\n-     (M     : Natural;\n-      N     : Natural;\n-      A     : in out Real_Matrix;\n-      Ld_A  : Positive;\n-      I_Piv : out Integer_Vector;\n-      Info  : access Integer);\n-\n-   procedure getri\n-     (N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      Work   : in out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure getrs\n-     (Trans  : access constant Character;\n-      N      : Natural;\n-      N_Rhs  : Natural;\n-      A      : Real_Matrix;\n-      Ld_A   : Positive;\n-      I_Piv  : Integer_Vector;\n-      B      : in out Real_Matrix;\n-      Ld_B   : Positive;\n-      Info   : access Integer);\n-\n-   procedure orgtr\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      Tau    : Real_Vector;\n-      Work   : out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-   procedure sterf\n-     (N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Info   : access Integer);\n-\n-   procedure steqr\n-     (Comp_Z : access constant Character;\n-      N      : Natural;\n-      D      : in out Real_Vector;\n-      E      : in out Real_Vector;\n-      Z      : in out Real_Matrix;\n-      Ld_Z   : Positive;\n-      Work   : out Real_Vector;\n-      Info   : access Integer);\n-\n-   procedure sytrd\n-     (Uplo   : access constant Character;\n-      N      : Natural;\n-      A      : in out Real_Matrix;\n-      Ld_A   : Positive;\n-      D      : out Real_Vector;\n-      E      : out Real_Vector;\n-      Tau    : out Real_Vector;\n-      Work   : out Real_Vector;\n-      L_Work : Integer;\n-      Info   : access Integer);\n-\n-end System.Generic_Real_LAPACK;"}, {"sha": "70270aba26810022d11ef61e35d0f8b30f77eece", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -10952,7 +10952,8 @@ package body Sem_Prag is\n \n          --  pragma Long_Float (D_Float | G_Float);\n \n-         when Pragma_Long_Float =>\n+         when Pragma_Long_Float => Long_Float : declare\n+         begin\n             GNAT_Pragma;\n             Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (1);\n@@ -10967,22 +10968,42 @@ package body Sem_Prag is\n \n             if Chars (Get_Pragma_Arg (Arg1)) = Name_D_Float then\n                if Opt.Float_Format_Long = 'G' then\n-                  Error_Pragma (\"G_Float previously specified\");\n-               end if;\n+                  Error_Pragma_Arg\n+                    (\"G_Float previously specified\", Arg1);\n+\n+               elsif Current_Sem_Unit /= Main_Unit\n+                 and then Opt.Float_Format_Long /= 'D'\n+               then\n+                  Error_Pragma_Arg\n+                    (\"main unit not compiled with pragma Long_Float (D_Float)\",\n+                     \"\\pragma% must be used consistently for whole partition\",\n+                     Arg1);\n \n-               Opt.Float_Format_Long := 'D';\n+               else\n+                  Opt.Float_Format_Long := 'D';\n+               end if;\n \n             --  G_Float case (this is the default, does not need overriding)\n \n             else\n                if Opt.Float_Format_Long = 'D' then\n                   Error_Pragma (\"D_Float previously specified\");\n-               end if;\n \n-               Opt.Float_Format_Long := 'G';\n+               elsif Current_Sem_Unit /= Main_Unit\n+                 and then Opt.Float_Format_Long /= 'G'\n+               then\n+                  Error_Pragma_Arg\n+                    (\"main unit not compiled with pragma Long_Float (G_Float)\",\n+                     \"\\pragma% must be used consistently for whole partition\",\n+                     Arg1);\n+\n+               else\n+                  Opt.Float_Format_Long := 'G';\n+               end if;\n             end if;\n \n             Set_Standard_Fpt_Formats;\n+         end Long_Float;\n \n          -----------------------\n          -- Machine_Attribute --"}, {"sha": "99b71c00fbf759b1825ae0a274fa0a945fefe5b9", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51cd0ece5f46761fdf91ddc562b8328974dbfc8/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=a51cd0ece5f46761fdf91ddc562b8328974dbfc8", "patch": "@@ -3993,39 +3993,59 @@ package body Sem_Warn is\n                --  Case of assigned value never referenced\n \n                if No (N) then\n+                  declare\n+                     LA : constant Node_Id := Last_Assignment (Ent);\n \n-                  --  Don't give this for OUT and IN OUT formals, since\n-                  --  clearly caller may reference the assigned value. Also\n-                  --  never give such warnings for internal variables.\n+                  begin\n+                     --  Don't give this for OUT and IN OUT formals, since\n+                     --  clearly caller may reference the assigned value. Also\n+                     --  never give such warnings for internal variables.\n \n-                  if Ekind (Ent) = E_Variable\n-                    and then not Is_Internal_Name (Chars (Ent))\n-                  then\n-                     if Referenced_As_Out_Parameter (Ent) then\n-                        Error_Msg_NE\n-                          (\"?& modified by call, but value never referenced\",\n-                           Last_Assignment (Ent), Ent);\n-                     else\n-                        Error_Msg_NE -- CODEFIX\n-                          (\"?useless assignment to&, value never referenced!\",\n-                           Last_Assignment (Ent), Ent);\n+                     if Ekind (Ent) = E_Variable\n+                       and then not Is_Internal_Name (Chars (Ent))\n+                     then\n+                        --  Give appropriate message, distinguishing between\n+                        --  assignment statements and out parameters.\n+\n+                        if Nkind_In (Parent (LA), N_Procedure_Call_Statement,\n+                                                  N_Parameter_Association)\n+                        then\n+                           Error_Msg_NE\n+                             (\"?& modified by call, but value never \"\n+                              & \"referenced\", LA, Ent);\n+\n+                        else\n+                           Error_Msg_NE -- CODEFIX\n+                             (\"?useless assignment to&, value never \"\n+                              & \"referenced!\", LA, Ent);\n+                        end if;\n                      end if;\n-                  end if;\n+                  end;\n \n                --  Case of assigned value overwritten\n \n                else\n-                  Error_Msg_Sloc := Sloc (N);\n+                  declare\n+                     LA : constant Node_Id := Last_Assignment (Ent);\n \n-                  if Referenced_As_Out_Parameter (Ent) then\n-                     Error_Msg_NE\n-                       (\"?& modified by call, but value overwritten #!\",\n-                        Last_Assignment (Ent), Ent);\n-                  else\n-                     Error_Msg_NE -- CODEFIX\n-                       (\"?useless assignment to&, value overwritten #!\",\n-                        Last_Assignment (Ent), Ent);\n-                  end if;\n+                  begin\n+                     Error_Msg_Sloc := Sloc (N);\n+\n+                     --  Give appropriate message, distinguishing between\n+                     --  assignment statements and out parameters.\n+\n+                     if Nkind_In (Parent (LA), N_Procedure_Call_Statement,\n+                                               N_Parameter_Association)\n+                     then\n+                        Error_Msg_NE\n+                          (\"?& modified by call, but value overwritten #!\",\n+                           LA, Ent);\n+                     else\n+                        Error_Msg_NE -- CODEFIX\n+                          (\"?useless assignment to&, value overwritten #!\",\n+                           LA, Ent);\n+                     end if;\n+                  end;\n                end if;\n \n                --  Clear last assignment indication and we are done"}]}