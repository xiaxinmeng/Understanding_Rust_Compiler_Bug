{"sha": "2cec75a1bd9efacb57c9c262af45e32fd712b2dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNlYzc1YTFiZDllZmFjYjU3YzljMjYyYWY0NWUzMmZkNzEyYjJkYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-01-13T19:31:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-01-13T19:31:07Z"}, "message": "genrecog.c (nodes_identical): Expand commentary.\n\n        * genrecog.c (nodes_identical): Expand commentary.\n        (write_switch): Watch out for identical nodes.\n\nFrom-SVN: r38989", "tree": {"sha": "06a6176ca27dc7579e6ac0e20165bd5377d7634a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06a6176ca27dc7579e6ac0e20165bd5377d7634a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cec75a1bd9efacb57c9c262af45e32fd712b2dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cec75a1bd9efacb57c9c262af45e32fd712b2dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cec75a1bd9efacb57c9c262af45e32fd712b2dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cec75a1bd9efacb57c9c262af45e32fd712b2dc/comments", "author": null, "committer": null, "parents": [{"sha": "fabfd8029dc23051d9bc8c914583b2adeaef8a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabfd8029dc23051d9bc8c914583b2adeaef8a3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabfd8029dc23051d9bc8c914583b2adeaef8a3b"}], "stats": {"total": 23, "additions": 20, "deletions": 3}, "files": [{"sha": "e5d71d94b56c2485b987c49316cbfcef3ecd038e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cec75a1bd9efacb57c9c262af45e32fd712b2dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cec75a1bd9efacb57c9c262af45e32fd712b2dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2cec75a1bd9efacb57c9c262af45e32fd712b2dc", "patch": "@@ -1,3 +1,8 @@\n+2001-01-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* genrecog.c (nodes_identical): Expand commentary.\n+\t(write_switch): Watch out for identical nodes.\n+\n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * cppfiles.c (_cpp_fake_include): New function."}, {"sha": "80d680a42922738e84bf2fda221a62e1b91b3ee1", "filename": "gcc/genrecog.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cec75a1bd9efacb57c9c262af45e32fd712b2dc/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cec75a1bd9efacb57c9c262af45e32fd712b2dc/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=2cec75a1bd9efacb57c9c262af45e32fd712b2dc", "patch": "@@ -1297,7 +1297,9 @@ nodes_identical (d1, d2)\n     return 0;\n \n   /* Check that their subnodes are at the same position, as any one set\n-     of sibling decisions must be at the same position.  */\n+     of sibling decisions must be at the same position.  Allowing this\n+     requires complications to find_afterward and when change_state is\n+     invoked.  */\n   if (d1->success.first\n       && d2->success.first\n       && strcmp (d1->success.first->position, d2->success.first->position))\n@@ -1743,7 +1745,8 @@ write_switch (start, depth)\n   if (!p->next\n       || p->tests->next\n       || p->next->tests->type != type\n-      || p->next->tests->next)\n+      || p->next->tests->next\n+      || nodes_identical_1 (p->tests, p->next->tests))\n     return p;\n \n   /* DT_code is special in that we can do interesting things with\n@@ -1866,6 +1869,14 @@ write_switch (start, depth)\n \n       do\n \t{\n+\t  /* Merge trees will not unify identical nodes if their\n+\t     sub-nodes are at different levels.  Thus we must check\n+\t     for duplicate cases.  */\n+\t  struct decision *q;\n+\t  for (q = start; q != p; q = q->next)\n+\t    if (nodes_identical_1 (p->tests, q->tests))\n+\t      goto case_done;\n+\n \t  if (p != start && p->need_label && needs_label == NULL)\n \t    needs_label = p;\n \n@@ -1892,7 +1903,8 @@ write_switch (start, depth)\n \t  p = p->next;\n \t}\n       while (p && p->tests->type == type && !p->tests->next);\n-      \n+\n+    case_done:\n       printf (\"    default:\\n      break;\\n    }\\n\");\n \n       return needs_label != NULL ? needs_label : p;"}]}