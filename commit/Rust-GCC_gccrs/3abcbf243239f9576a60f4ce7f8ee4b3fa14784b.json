{"sha": "3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "node_id": "C_kwDOANBUbNoAKDNhYmNiZjI0MzIzOWY5NTc2YTYwZjRjZTdmOGVlNGIzZmExNDc4NGI", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-01-14T22:41:49Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-01-21T18:11:54Z"}, "message": "c++: ICE with noexcept and canonical types [PR101715]\n\nThis is a \"canonical types differ for identical types\" ICE, which started\nwith r11-4682.  It's a bit tricky to explain.  Consider:\n\n  template <typename T> struct S {\n    S<T> bar() noexcept(T::value);  // #1\n    S<T> foo() noexcept(T::value);  // #2\n  };\n\n  template <typename T> S<T> S<T>::foo() noexcept(T::value) {}  // #3\n\nWe ICE because #3 and #2 have the same type, but their canonical types\ndiffer: TYPE_CANONICAL (#3) == #2 but TYPE_CANONICAL (#2) == #1.\n\nThe member functions #1 and #2 have the same type.  However, since their\nnoexcept-specifier is deferred, when parsing them, we create a variant for\nboth of them, because DEFERRED_PARSE cannot be compared.  In other words,\nbuild_cp_fntype_variant's\n\n  tree v = TYPE_MAIN_VARIANT (type);\n  for (; v; v = TYPE_NEXT_VARIANT (v))\n    if (cp_check_qualified_type (v, type, type_quals, rqual, raises, late))\n      return v;\n\nwill *not* find an existing variant when creating a method_type for #2, so we\nhave to create a new one.\n\nBut then we perform delayed parsing and call fixup_deferred_exception_variants\nfor #1 and #2.  f_d_e_v will replace TYPE_RAISES_EXCEPTIONS with the newly\nparsed noexcept-specifier.  It also sets TYPE_CANONICAL (#2) to #1.  Both\nnoexcepts turned out to be the same, so now we have two equivalent variants in\nthe list!  I.e.,\n\n+-----------------+      +-----------------+      +-----------------+\n|      main       |      |      #2         |      |      #1         |\n| S S::<T379>(S*) |----->| S S::<T37c>(S*) |----->| S S::<T37a>(S*) |----->NULL\n|    -            |      |  noex(T::value) |      |  noex(T::value) |\n+-----------------+      +-----------------+      +-----------------+\n\nThen we get to #3.  As for #1 and #2, grokdeclarator calls build_memfn_type,\nwhich ends up calling build_cp_fntype_variant, which will use the loop\nabove to look for an existing variant.  The first one that matches\ncp_check_qualified_type will be used, so we use #2 rather than #1, and the\nTYPE_CANONICAL mismatch follows.  Hopefully that makes sense.\n\nAs for the fix, I didn't think I could rewrite the method_type #2 with #1\nbecause the type may have escaped via decltype.  So my approach is to\nelide #2 from the list, so when looking for a matching variant, we always\nfind #1 (#2 remains live though, which admittedly sounds sort of dodgy).\n\n\tPR c++/101715\n\ngcc/cp/ChangeLog:\n\n\t* tree.cc (fixup_deferred_exception_variants): Remove duplicate\n\tvariants after parsing the exception specifications.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/noexcept72.C: New test.\n\t* g++.dg/cpp0x/noexcept73.C: New test.", "tree": {"sha": "7aba60097fd78bd038486692388d9c2389626e3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aba60097fd78bd038486692388d9c2389626e3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "087e545747ca9ee977e84326877b0ce1bc4c383a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/087e545747ca9ee977e84326877b0ce1bc4c383a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/087e545747ca9ee977e84326877b0ce1bc4c383a"}], "stats": {"total": 56, "additions": 50, "deletions": 6}, "files": [{"sha": "f88006aec4fb1f3a1018b46a84f892542511a203", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "patch": "@@ -2804,8 +2804,9 @@ fixup_deferred_exception_variants (tree type, tree raises)\n \n   /* Though sucky, this walk will process the canonical variants\n      first.  */\n+  tree prev = NULL_TREE;\n   for (tree variant = TYPE_MAIN_VARIANT (type);\n-       variant; variant = TYPE_NEXT_VARIANT (variant))\n+       variant; prev = variant, variant = TYPE_NEXT_VARIANT (variant))\n     if (TYPE_RAISES_EXCEPTIONS (variant) == original)\n       {\n \tgcc_checking_assert (variant != TYPE_MAIN_VARIANT (type));\n@@ -2815,18 +2816,27 @@ fixup_deferred_exception_variants (tree type, tree raises)\n \t    cp_cv_quals var_quals = TYPE_QUALS (variant);\n \t    cp_ref_qualifier rqual = type_memfn_rqual (variant);\n \n+\t    /* If VARIANT would become a dup (cp_check_qualified_type-wise)\n+\t       of an existing variant in the variant list of TYPE after its\n+\t       exception specification has been parsed, elide it.  Otherwise,\n+\t       build_cp_fntype_variant could use it, leading to \"canonical\n+\t       types differ for identical types.\"  */\n \t    tree v = TYPE_MAIN_VARIANT (type);\n \t    for (; v; v = TYPE_NEXT_VARIANT (v))\n-\t      if (TYPE_CANONICAL (v) == v\n-\t\t  && cp_check_qualified_type (v, variant, var_quals,\n-\t\t\t\t\t      rqual, cr, false))\n-\t\tbreak;\n+\t      if (cp_check_qualified_type (v, variant, var_quals,\n+\t\t\t\t\t   rqual, cr, false))\n+\t\t{\n+\t\t  /* The main variant will not match V, so PREV will never\n+\t\t     be null.  */\n+\t\t  TYPE_NEXT_VARIANT (prev) = TYPE_NEXT_VARIANT (variant);\n+\t\t  break;\n+\t\t}\n \t    TYPE_RAISES_EXCEPTIONS (variant) = raises;\n \n \t    if (!v)\n \t      v = build_cp_fntype_variant (TYPE_CANONICAL (variant),\n \t\t\t\t\t   rqual, cr, false);\n-\t    TYPE_CANONICAL (variant) = v;\n+\t    TYPE_CANONICAL (variant) = TYPE_CANONICAL (v);\n \t  }\n \telse\n \t  TYPE_RAISES_EXCEPTIONS (variant) = raises;"}, {"sha": "f1455b3b46b9b71e0dc08bf6873daf22dafb6d7e", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept72.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept72.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept72.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept72.C?ref=3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/101715\n+// { dg-do compile { target c++11 } }\n+\n+template <typename T> struct S {\n+  S<T> bar() noexcept(T::value);  // #1\n+  S<T> foo() noexcept(T::value);  // #2\n+};\n+\n+template <typename T> S<T> S<T>::foo() noexcept(T::value) {}  // #3\n+\n+template <typename T> struct S2 {\n+  S2<T> bar1() noexcept(T::value);\n+  S2<T> bar2() noexcept(T::value);\n+  S2<T> bar3() noexcept(T::value);\n+  S2<T> bar4() noexcept(T::value);\n+  S2<T> bar5() noexcept(T::value);\n+  S2<T> baz() noexcept(T::value2);\n+  S2<T> foo() noexcept(T::value);\n+};\n+\n+template <typename T> S2<T> S2<T>::foo() noexcept(T::value) {}"}, {"sha": "24524f3592a726def81004b87509d56686db0ff3", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept73.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept73.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abcbf243239f9576a60f4ce7f8ee4b3fa14784b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept73.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept73.C?ref=3abcbf243239f9576a60f4ce7f8ee4b3fa14784b", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/101715\n+// { dg-do compile { target c++11 } }\n+\n+template <typename T> struct S { };\n+\n+template<typename T>\n+struct A\n+{\n+    A& foo(A&&) noexcept((S<T>::value));\n+    A& assign(A&&) noexcept((S<T>::value));\n+};\n+template<typename T>\n+A<T>& A<T>::foo(A&&) noexcept((S<T>::value)) {}"}]}