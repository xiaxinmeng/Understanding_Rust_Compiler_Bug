{"sha": "548c43e724cc6dc360afe75816396c7d5eba38fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ4YzQzZTcyNGNjNmRjMzYwYWZlNzU4MTYzOTZjN2Q1ZWJhMzhmYw==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2015-01-15T19:22:20Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2015-01-15T19:22:20Z"}, "message": "explow.h: Remove duplicate contents.\n\n2015-01-15  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\n\t* explow.h: Remove duplicate contents.\n\t* dojump.h: Likewise.\n\nFrom-SVN: r219680", "tree": {"sha": "8135dde75c3b19fe1d70127856c9af8f4362ac41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8135dde75c3b19fe1d70127856c9af8f4362ac41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/548c43e724cc6dc360afe75816396c7d5eba38fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548c43e724cc6dc360afe75816396c7d5eba38fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/548c43e724cc6dc360afe75816396c7d5eba38fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548c43e724cc6dc360afe75816396c7d5eba38fc/comments", "author": null, "committer": null, "parents": [{"sha": "7c21d0ff8161eef557cbd54d16ded22d8cd51fbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c21d0ff8161eef557cbd54d16ded22d8cd51fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c21d0ff8161eef557cbd54d16ded22d8cd51fbd"}], "stats": {"total": 387, "additions": 5, "deletions": 382}, "files": [{"sha": "d40a3f0864e8bd967833bfd6409f5c9afcf656e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548c43e724cc6dc360afe75816396c7d5eba38fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548c43e724cc6dc360afe75816396c7d5eba38fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=548c43e724cc6dc360afe75816396c7d5eba38fc", "patch": "@@ -1,3 +1,8 @@\n+2015-01-15  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* explow.h: Remove duplicate contents.\n+\t* dojump.h: Likewise.\n+\n 2015-01-15  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (arm_xgene_tune): Add default initializer for instruction"}, {"sha": "74d3f37979c2e4b891c6d5a883e023255d91939d", "filename": "gcc/dojump.h", "status": "modified", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548c43e724cc6dc360afe75816396c7d5eba38fc/gcc%2Fdojump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548c43e724cc6dc360afe75816396c7d5eba38fc/gcc%2Fdojump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.h?ref=548c43e724cc6dc360afe75816396c7d5eba38fc", "patch": "@@ -76,159 +76,3 @@ extern bool split_comparison (enum rtx_code, machine_mode,\n \t\t\t      enum rtx_code *, enum rtx_code *);\n \n #endif /* GCC_DOJUMP_H */\n-/* Export function prototypes from dojump.c.\n-   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_DOJUMP_H\n-#define GCC_DOJUMP_H\n-\n-/* At the start of a function, record that we have no previously-pushed\n-   arguments waiting to be popped.  */\n-extern void init_pending_stack_adjust (void);\n-\n-/* Discard any pending stack adjustment.  */\n-extern void discard_pending_stack_adjust (void);\n-\n-/* When exiting from function, if safe, clear out any pending stack adjust\n-   so the adjustment won't get done.  */\n-extern void clear_pending_stack_adjust (void);\n-\n-/* Pop any previously-pushed arguments that have not been popped yet.  */\n-extern void do_pending_stack_adjust (void);\n-\n-/* Struct for saving/restoring of pending_stack_adjust/stack_pointer_delta\n-   values.  */\n-\n-struct saved_pending_stack_adjust\n-{\n-  /* Saved value of pending_stack_adjust.  */\n-  int x_pending_stack_adjust;\n-\n-  /* Saved value of stack_pointer_delta.  */\n-  int x_stack_pointer_delta;\n-};\n-\n-/* Remember pending_stack_adjust/stack_pointer_delta.\n-   To be used around code that may call do_pending_stack_adjust (),\n-   but the generated code could be discarded e.g. using delete_insns_since.  */\n-\n-extern void save_pending_stack_adjust (saved_pending_stack_adjust *);\n-\n-/* Restore the saved pending_stack_adjust/stack_pointer_delta.  */\n-\n-extern void restore_pending_stack_adjust (saved_pending_stack_adjust *);\n-\n-/* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n-extern void jumpifnot (tree, rtx, int);\n-extern void jumpifnot_1 (enum tree_code, tree, tree, rtx, int);\n-\n-/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n-extern void jumpif (tree, rtx, int);\n-extern void jumpif_1 (enum tree_code, tree, tree, rtx, int);\n-\n-/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n-   the result is zero, or IF_TRUE_LABEL if the result is one.  */\n-extern void do_jump (tree, rtx, rtx, int);\n-extern void do_jump_1 (enum tree_code, tree, tree, rtx, rtx, int);\n-\n-extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n-\t\t\t\t     machine_mode, rtx, rtx, rtx, int);\n-\n-extern bool split_comparison (enum rtx_code, machine_mode,\n-\t\t\t      enum rtx_code *, enum rtx_code *);\n-\n-#endif /* GCC_DOJUMP_H */\n-/* Export function prototypes from dojump.c.\n-   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_DOJUMP_H\n-#define GCC_DOJUMP_H\n-\n-/* At the start of a function, record that we have no previously-pushed\n-   arguments waiting to be popped.  */\n-extern void init_pending_stack_adjust (void);\n-\n-/* Discard any pending stack adjustment.  */\n-extern void discard_pending_stack_adjust (void);\n-\n-/* When exiting from function, if safe, clear out any pending stack adjust\n-   so the adjustment won't get done.  */\n-extern void clear_pending_stack_adjust (void);\n-\n-/* Pop any previously-pushed arguments that have not been popped yet.  */\n-extern void do_pending_stack_adjust (void);\n-\n-/* Struct for saving/restoring of pending_stack_adjust/stack_pointer_delta\n-   values.  */\n-\n-struct saved_pending_stack_adjust\n-{\n-  /* Saved value of pending_stack_adjust.  */\n-  int x_pending_stack_adjust;\n-\n-  /* Saved value of stack_pointer_delta.  */\n-  int x_stack_pointer_delta;\n-};\n-\n-/* Remember pending_stack_adjust/stack_pointer_delta.\n-   To be used around code that may call do_pending_stack_adjust (),\n-   but the generated code could be discarded e.g. using delete_insns_since.  */\n-\n-extern void save_pending_stack_adjust (saved_pending_stack_adjust *);\n-\n-/* Restore the saved pending_stack_adjust/stack_pointer_delta.  */\n-\n-extern void restore_pending_stack_adjust (saved_pending_stack_adjust *);\n-\n-/* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n-extern void jumpifnot (tree, rtx, int);\n-extern void jumpifnot_1 (enum tree_code, tree, tree, rtx, int);\n-\n-/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n-extern void jumpif (tree, rtx, int);\n-extern void jumpif_1 (enum tree_code, tree, tree, rtx, int);\n-\n-/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n-   the result is zero, or IF_TRUE_LABEL if the result is one.  */\n-extern void do_jump (tree, rtx, rtx, int);\n-extern void do_jump_1 (enum tree_code, tree, tree, rtx, rtx, int);\n-\n-extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n-\t\t\t\t     machine_mode, rtx, rtx, rtx, int);\n-\n-extern bool split_comparison (enum rtx_code, machine_mode,\n-\t\t\t      enum rtx_code *, enum rtx_code *);\n-\n-#endif /* GCC_DOJUMP_H */"}, {"sha": "48f18599122f0002a7e5c2f96e927dfb17ecfe86", "filename": "gcc/explow.h", "status": "modified", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548c43e724cc6dc360afe75816396c7d5eba38fc/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548c43e724cc6dc360afe75816396c7d5eba38fc/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=548c43e724cc6dc360afe75816396c7d5eba38fc", "patch": "@@ -111,229 +111,3 @@ extern rtx eliminate_constant_term (rtx, rtx *);\n \tmemory_address_addr_space ((MODE), (RTX), ADDR_SPACE_GENERIC)\n \n #endif /* GCC_EXPLOW_H */\n-/* Export function prototypes from explow.c.\n-   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_EXPLOW_H\n-#define GCC_EXPLOW_H\n-\n-/* Return a memory reference like MEMREF, but which is known to have a\n-   valid address.  */\n-extern rtx validize_mem (rtx);\n-\n-extern rtx use_anchored_address (rtx);\n-\n-/* Copy given rtx to a new temp reg and return that.  */\n-extern rtx copy_to_reg (rtx);\n-\n-/* Like copy_to_reg but always make the reg Pmode.  */\n-extern rtx copy_addr_to_reg (rtx);\n-\n-/* Like copy_to_reg but always make the reg the specified mode MODE.  */\n-extern rtx copy_to_mode_reg (machine_mode, rtx);\n-\n-/* Copy given rtx to given temp reg and return that.  */\n-extern rtx copy_to_suggested_reg (rtx, rtx, machine_mode);\n-\n-/* Copy a value to a register if it isn't already a register.\n-   Args are mode (in case value is a constant) and the value.  */\n-extern rtx force_reg (machine_mode, rtx);\n-\n-/* Return given rtx, copied into a new temp reg if it was in memory.  */\n-extern rtx force_not_mem (rtx);\n-\n-/* Return mode and signedness to use when an argument or result in the\n-   given mode is promoted.  */\n-extern machine_mode promote_function_mode (const_tree, machine_mode, int *,\n-\t\t\t\t\t        const_tree, int);\n-\n-/* Return mode and signedness to use when an object in the given mode\n-   is promoted.  */\n-extern machine_mode promote_mode (const_tree, machine_mode, int *);\n-\n-/* Return mode and signedness to use when object is promoted.  */\n-machine_mode promote_decl_mode (const_tree, int *);\n-\n-/* Remove some bytes from the stack.  An rtx says how many.  */\n-extern void adjust_stack (rtx);\n-\n-/* Add some bytes to the stack.  An rtx says how many.  */\n-extern void anti_adjust_stack (rtx);\n-\n-/* Add some bytes to the stack while probing it.  An rtx says how many. */\n-extern void anti_adjust_stack_and_probe (rtx, bool);\n-\n-/* This enum is used for the following two functions.  */\n-enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n-\n-/* Save the stack pointer at the specified level.  */\n-extern void emit_stack_save (enum save_level, rtx *);\n-\n-/* Restore the stack pointer from a save area of the specified level.  */\n-extern void emit_stack_restore (enum save_level, rtx);\n-\n-/* Invoke emit_stack_save for the nonlocal_goto_save_area.  */\n-extern void update_nonlocal_goto_save_area (void);\n-\n-/* Allocate some space on the stack dynamically and return its address.  */\n-extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned, bool);\n-\n-/* Emit one stack probe at ADDRESS, an address within the stack.  */\n-extern void emit_stack_probe (rtx);\n-\n-/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n-   FIRST is a constant and size is a Pmode RTX.  These are offsets from\n-   the current stack pointer.  STACK_GROWS_DOWNWARD says whether to add\n-   or subtract them from the stack pointer.  */\n-extern void probe_stack_range (HOST_WIDE_INT, rtx);\n-\n-/* Return an rtx that refers to the value returned by a library call\n-   in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_libcall_value (machine_mode, rtx);\n-\n-/* Return an rtx that refers to the value returned by a function\n-   in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_function_value (const_tree, const_tree, const_tree, int);\n-\n-/* Convert arg to a valid memory address for specified machine mode that points\n-   to a specific named address space, by emitting insns to perform arithmetic\n-   if necessary.  */\n-extern rtx memory_address_addr_space (machine_mode, rtx, addr_space_t);\n-\n-extern rtx eliminate_constant_term (rtx, rtx *);\n-\n-/* Like memory_address_addr_space, except assume the memory address points to\n-   the generic named address space.  */\n-#define memory_address(MODE,RTX) \\\n-\tmemory_address_addr_space ((MODE), (RTX), ADDR_SPACE_GENERIC)\n-\n-#endif /* GCC_EXPLOW_H */\n-/* Export function prototypes from explow.c.\n-   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_EXPLOW_H\n-#define GCC_EXPLOW_H\n-\n-/* Return a memory reference like MEMREF, but which is known to have a\n-   valid address.  */\n-extern rtx validize_mem (rtx);\n-\n-extern rtx use_anchored_address (rtx);\n-\n-/* Copy given rtx to a new temp reg and return that.  */\n-extern rtx copy_to_reg (rtx);\n-\n-/* Like copy_to_reg but always make the reg Pmode.  */\n-extern rtx copy_addr_to_reg (rtx);\n-\n-/* Like copy_to_reg but always make the reg the specified mode MODE.  */\n-extern rtx copy_to_mode_reg (machine_mode, rtx);\n-\n-/* Copy given rtx to given temp reg and return that.  */\n-extern rtx copy_to_suggested_reg (rtx, rtx, machine_mode);\n-\n-/* Copy a value to a register if it isn't already a register.\n-   Args are mode (in case value is a constant) and the value.  */\n-extern rtx force_reg (machine_mode, rtx);\n-\n-/* Return given rtx, copied into a new temp reg if it was in memory.  */\n-extern rtx force_not_mem (rtx);\n-\n-/* Return mode and signedness to use when an argument or result in the\n-   given mode is promoted.  */\n-extern machine_mode promote_function_mode (const_tree, machine_mode, int *,\n-\t\t\t\t\t        const_tree, int);\n-\n-/* Return mode and signedness to use when an object in the given mode\n-   is promoted.  */\n-extern machine_mode promote_mode (const_tree, machine_mode, int *);\n-\n-/* Return mode and signedness to use when object is promoted.  */\n-machine_mode promote_decl_mode (const_tree, int *);\n-\n-/* Remove some bytes from the stack.  An rtx says how many.  */\n-extern void adjust_stack (rtx);\n-\n-/* Add some bytes to the stack.  An rtx says how many.  */\n-extern void anti_adjust_stack (rtx);\n-\n-/* Add some bytes to the stack while probing it.  An rtx says how many. */\n-extern void anti_adjust_stack_and_probe (rtx, bool);\n-\n-/* This enum is used for the following two functions.  */\n-enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n-\n-/* Save the stack pointer at the specified level.  */\n-extern void emit_stack_save (enum save_level, rtx *);\n-\n-/* Restore the stack pointer from a save area of the specified level.  */\n-extern void emit_stack_restore (enum save_level, rtx);\n-\n-/* Invoke emit_stack_save for the nonlocal_goto_save_area.  */\n-extern void update_nonlocal_goto_save_area (void);\n-\n-/* Allocate some space on the stack dynamically and return its address.  */\n-extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned, bool);\n-\n-/* Emit one stack probe at ADDRESS, an address within the stack.  */\n-extern void emit_stack_probe (rtx);\n-\n-/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n-   FIRST is a constant and size is a Pmode RTX.  These are offsets from\n-   the current stack pointer.  STACK_GROWS_DOWNWARD says whether to add\n-   or subtract them from the stack pointer.  */\n-extern void probe_stack_range (HOST_WIDE_INT, rtx);\n-\n-/* Return an rtx that refers to the value returned by a library call\n-   in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_libcall_value (machine_mode, rtx);\n-\n-/* Return an rtx that refers to the value returned by a function\n-   in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_function_value (const_tree, const_tree, const_tree, int);\n-\n-/* Convert arg to a valid memory address for specified machine mode that points\n-   to a specific named address space, by emitting insns to perform arithmetic\n-   if necessary.  */\n-extern rtx memory_address_addr_space (machine_mode, rtx, addr_space_t);\n-\n-extern rtx eliminate_constant_term (rtx, rtx *);\n-\n-/* Like memory_address_addr_space, except assume the memory address points to\n-   the generic named address space.  */\n-#define memory_address(MODE,RTX) \\\n-\tmemory_address_addr_space ((MODE), (RTX), ADDR_SPACE_GENERIC)\n-\n-#endif /* GCC_EXPLOW_H */"}]}