{"sha": "a5baf71b0a5bd79923c095cf81218b8194008f60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTViYWY3MWIwYTViZDc5OTIzYzA5NWNmODEyMThiODE5NDAwOGY2MA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-08-02T09:57:59Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-08-02T09:57:59Z"}, "message": "This patch fixes PR96320. See the explanatory comment in the testcase.\n\n2020-08-01  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR target/96320\n\t* interface.c (gfc_check_dummy_characteristics): If a module\n\tprocedure arrives with assumed shape in the interface and\n\tdeferred shape in the procedure itself, update the latter and\n\tcopy the lower bounds.\n\ngcc/testsuite/\n\tPR target/96320\n\t* gfortran.dg/module_procedure_4.f90 : New test.", "tree": {"sha": "b93da317db4de0f951a9c88c99087c8ec9da8301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b93da317db4de0f951a9c88c99087c8ec9da8301"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5baf71b0a5bd79923c095cf81218b8194008f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5baf71b0a5bd79923c095cf81218b8194008f60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5baf71b0a5bd79923c095cf81218b8194008f60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5baf71b0a5bd79923c095cf81218b8194008f60/comments", "author": null, "committer": null, "parents": [{"sha": "6912619fce0dafde2269960c4704e8f88c61b8f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6912619fce0dafde2269960c4704e8f88c61b8f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6912619fce0dafde2269960c4704e8f88c61b8f3"}], "stats": {"total": 82, "additions": 79, "deletions": 3}, "files": [{"sha": "7985fc70fd462691af6637de0382580219ab4c27", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5baf71b0a5bd79923c095cf81218b8194008f60/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5baf71b0a5bd79923c095cf81218b8194008f60/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a5baf71b0a5bd79923c095cf81218b8194008f60", "patch": "@@ -1466,6 +1466,19 @@ gfc_check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n       int i, compval;\n       gfc_expr *shape1, *shape2;\n \n+      /* Sometimes the ambiguity between deferred shape and assumed shape\n+\t does not get resolved in module procedures, where the only explicit\n+\t declaration of the dummy is in the interface.  */\n+      if (s1->ns->proc_name && s1->ns->proc_name->attr.module_procedure\n+\t  && s1->as->type == AS_ASSUMED_SHAPE\n+\t  && s2->as->type == AS_DEFERRED)\n+\t{\n+\t  s2->as->type = AS_ASSUMED_SHAPE;\n+\t  for (i = 0; i < s2->as->rank; i++)\n+\t    if (s1->as->lower[i] != NULL)\n+\t      s2->as->lower[i] = gfc_copy_expr (s1->as->lower[i]);\n+\t}\n+\n       if (s1->as->type != s2->as->type)\n \t{\n \t  snprintf (errmsg, err_len, \"Shape mismatch in argument '%s'\",\n@@ -2617,7 +2630,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       || (actual->rank == 0 && formal->attr.dimension\n \t  && gfc_is_coindexed (actual)))\n     {\n-      if (where \n+      if (where\n \t  && (!formal->attr.artificial || (!formal->maybe_array\n \t\t\t\t\t   && !maybe_dummy_array_arg (actual))))\n \t{\n@@ -2708,7 +2721,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n   if (ref == NULL && actual->expr_type != EXPR_NULL)\n     {\n-      if (where \n+      if (where\n \t  && (!formal->attr.artificial || (!formal->maybe_array\n \t\t\t\t\t   && !maybe_dummy_array_arg (actual))))\n \t{\n@@ -3965,7 +3978,7 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n   if (!gfc_compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental,\n \t\t\t\t  sym->attr.proc == PROC_ST_FUNCTION, where))\n     return false;\n- \n+\n   if (!check_intents (dummy_args, *ap))\n     return false;\n "}, {"sha": "c30bbfe5d50c0c95fa60d51355a57dea3283841a", "filename": "gcc/testsuite/gfortran.dg/module_procedure_4.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5baf71b0a5bd79923c095cf81218b8194008f60/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5baf71b0a5bd79923c095cf81218b8194008f60/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_4.f90?ref=a5baf71b0a5bd79923c095cf81218b8194008f60", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR96320 in which the assumed shape of 'arg' in the\n+! interface for 'bar' was mirrored by the 'arg' in the module procedure\n+! incorrectly have deferred shape.\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+module foobar\n+  type foo\n+  contains\n+    procedure, nopass :: bar1\n+    procedure, nopass :: bar2\n+    procedure, nopass :: bar3\n+  end type\n+\n+  interface\n+\n+    module subroutine bar1(arg)\n+      character(len=*) arg(:)\n+    end subroutine\n+\n+    module subroutine bar2(arg)\n+      character(len=*) arg(3:)\n+    end subroutine\n+\n+    module subroutine bar3(arg)\n+      character(len=*) arg(2)\n+    end subroutine\n+\n+  end interface\n+contains\n+\n+  module procedure bar1\n+    if (lbound(arg, 1) .ne. 1) stop 1\n+    if (arg(3) .ne. 'hijk') stop 2\n+  end procedure\n+\n+! Make sure that the lower bound of an assumed shape array dummy,\n+! if defined, is passed to the module procedure.\n+\n+  module procedure bar2\n+    if (lbound(arg, 1) .ne. 3) stop 3\n+    if (arg(3) .ne. 'abcd') stop 4\n+  end procedure\n+\n+! This makes sure that an dummy with explicit shape has the upper\n+! bound correctly set in the module procedure.\n+\n+  module procedure bar3\n+    if (lbound(arg, 1) .ne. 1) stop 5\n+    if (arg(3) .ne. 'hijk') stop 6       ! { dg-warning \"is out of bounds\" }\n+  end procedure\n+\n+end module\n+\n+  use foobar\n+  character(4) :: list(3) = ['abcd', 'efgh' , 'hijk']\n+  type(foo) :: f\n+  call f%bar1(list)\n+  call f%bar2(list)\n+  call f%bar3(list)\n+end"}]}