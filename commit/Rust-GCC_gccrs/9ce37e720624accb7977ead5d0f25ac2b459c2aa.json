{"sha": "9ce37e720624accb7977ead5d0f25ac2b459c2aa", "node_id": "C_kwDOANBUbNoAKDljZTM3ZTcyMDYyNGFjY2I3OTc3ZWFkNWQwZjI1YWMyYjQ1OWMyYWE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T15:29:11Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:05Z"}, "message": "gccrs: Add helpers mappings canonical path and lang items\n\nThese are various helper classes used in the compiler pipeline.\n\n\tgcc/rust/\n\t* util/rust-canonical-path.h: New.\n\t* util/rust-common.h: New.\n\t* util/rust-hir-map.cc: New.\n\t* util/rust-hir-map.h: New.\n\t* util/rust-identifier.h: New.\n\t* util/rust-lang-item.h: New.\n\t* util/rust-mapping-common.h: New.\n\t* util/rust-stacked-contexts.h: New.", "tree": {"sha": "cd9edcf7004a2d9919a60a1e868002ad6b8825b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd9edcf7004a2d9919a60a1e868002ad6b8825b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ce37e720624accb7977ead5d0f25ac2b459c2aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce37e720624accb7977ead5d0f25ac2b459c2aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce37e720624accb7977ead5d0f25ac2b459c2aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce37e720624accb7977ead5d0f25ac2b459c2aa/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa"}], "stats": {"total": 2181, "additions": 2181, "deletions": 0}, "files": [{"sha": "54cc0390849f6f43b4aeada35526bffcb6a460ac", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,195 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_CANONICAL_PATH\n+#define RUST_CANONICAL_PATH\n+\n+#include \"rust-system.h\"\n+#include \"rust-mapping-common.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// https://doc.rust-lang.org/reference/paths.html#canonical-paths\n+//\n+// struct X - path X\n+// impl X { fn test - path X::test }\n+//\n+// struct X<T> - path X\n+//\n+// impl X<T>   { fn test - path X::test}\n+// impl X<i32> { fn test - path X<i32>::test }\n+// impl X<f32> { fn test - path X<f32>::test }\n+//\n+// pub trait Trait { // ::a::Trait\n+//   fn f(&self); // ::a::Trait::f\n+// }\n+//\n+// impl Trait for Struct {\n+//    fn f(&self) {} // <::a::Struct as ::a::Trait>::f\n+// }\n+class CanonicalPath\n+{\n+public:\n+  CanonicalPath (const CanonicalPath &other) : segs (other.segs) {}\n+\n+  CanonicalPath &operator= (const CanonicalPath &other)\n+  {\n+    segs = other.segs;\n+    return *this;\n+  }\n+\n+  static CanonicalPath new_seg (NodeId id, const std::string &path)\n+  {\n+    rust_assert (!path.empty ());\n+    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)},\n+\t\t\t  UNKNOWN_CREATENUM);\n+  }\n+\n+  static CanonicalPath\n+  trait_impl_projection_seg (NodeId id, const CanonicalPath &trait_seg,\n+\t\t\t     const CanonicalPath &impl_type_seg)\n+  {\n+    return CanonicalPath::new_seg (id, \"<\" + impl_type_seg.get () + \" as \"\n+\t\t\t\t\t + trait_seg.get () + \">\");\n+  }\n+\n+  std::string get () const\n+  {\n+    std::string buf;\n+    for (size_t i = 0; i < segs.size (); i++)\n+      {\n+\tbool have_more = (i + 1) < segs.size ();\n+\tconst std::string &seg = segs.at (i).second;\n+\tbuf += seg + (have_more ? \"::\" : \"\");\n+      }\n+    return buf;\n+  }\n+\n+  static CanonicalPath get_big_self (NodeId id)\n+  {\n+    return CanonicalPath::new_seg (id, \"Self\");\n+  }\n+\n+  static CanonicalPath create_empty ()\n+  {\n+    return CanonicalPath ({}, UNKNOWN_CREATENUM);\n+  }\n+\n+  bool is_empty () const { return segs.size () == 0; }\n+\n+  CanonicalPath append (const CanonicalPath &other) const\n+  {\n+    rust_assert (!other.is_empty ());\n+    if (is_empty ())\n+      return CanonicalPath (other.segs, crate_num);\n+\n+    std::vector<std::pair<NodeId, std::string>> copy (segs);\n+    for (auto &s : other.segs)\n+      copy.push_back (s);\n+\n+    return CanonicalPath (copy, crate_num);\n+  }\n+\n+  // if we have the path A::B::C this will give a callback for each segment\n+  // including the prefix, example:\n+  //\n+  // path:\n+  //   A::B::C\n+  //\n+  // iterate:\n+  //   A\n+  //   A::B\n+  //   A::B::C\n+  void iterate (std::function<bool (const CanonicalPath &)> cb) const\n+  {\n+    std::vector<std::pair<NodeId, std::string>> buf;\n+    for (auto &seg : segs)\n+      {\n+\tbuf.push_back (seg);\n+\tif (!cb (CanonicalPath (buf, crate_num)))\n+\t  return;\n+      }\n+  }\n+\n+  // if we have the path A::B::C this will give a callback for each segment\n+  // example:\n+  //\n+  // path:\n+  //   A::B::C\n+  //\n+  // iterate:\n+  //   A\n+  //      B\n+  //         C\n+  void iterate_segs (std::function<bool (const CanonicalPath &)> cb) const\n+  {\n+    for (auto &seg : segs)\n+      {\n+\tstd::vector<std::pair<NodeId, std::string>> buf;\n+\tbuf.push_back ({seg.first, seg.second});\n+\tif (!cb (CanonicalPath (buf, crate_num)))\n+\t  return;\n+      }\n+  }\n+\n+  size_t size () const { return segs.size (); }\n+\n+  NodeId get_node_id () const\n+  {\n+    rust_assert (!segs.empty ());\n+    return segs.back ().first;\n+  }\n+\n+  const std::pair<NodeId, std::string> &get_seg_at (size_t index) const\n+  {\n+    rust_assert (index < size ());\n+    return segs.at (index);\n+  }\n+\n+  bool is_equal (const CanonicalPath &b) const\n+  {\n+    return get ().compare (b.get ()) == 0;\n+  }\n+\n+  void set_crate_num (CrateNum n) { crate_num = n; }\n+\n+  CrateNum get_crate_num () const\n+  {\n+    rust_assert (crate_num != UNKNOWN_CREATENUM);\n+    return crate_num;\n+  }\n+\n+  bool operator== (const CanonicalPath &b) const { return is_equal (b); }\n+\n+  bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n+\n+private:\n+  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path,\n+\t\t\t  CrateNum crate_num)\n+    : segs (path), crate_num (crate_num)\n+  {}\n+\n+  std::vector<std::pair<NodeId, std::string>> segs;\n+  CrateNum crate_num;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_CANONICAL_PATH"}, {"sha": "a3f6fb07d8d82564719025418b22cabfc992f4eb", "filename": "gcc/rust/util/rust-common.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-common.h?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Common definitions useful throughout the Rust frontend.\n+\n+#ifndef RUST_COMMON\n+#define RUST_COMMON\n+\n+namespace Rust {\n+\n+enum Mutability\n+{\n+  Imm,\n+  Mut\n+};\n+\n+enum Unsafety\n+{\n+  Unsafe,\n+  Normal\n+};\n+\n+enum Polarity\n+{\n+  Positive,\n+  Negative\n+};\n+\n+enum AsyncConstStatus\n+{\n+  NONE,\n+  CONST_FN,\n+  ASYNC_FN\n+};\n+\n+} // namespace Rust\n+\n+#endif // RUST_COMMON"}, {"sha": "8705fdcf3817ca7668a7a49e549202acd303ecfb", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "added", "additions": 980, "deletions": 0, "changes": 980, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,980 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-macro-builtins.h\"\n+#include \"rust-mapping-common.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+NodeMapping\n+NodeMapping::get_error ()\n+{\n+  return NodeMapping (UNKNOWN_CREATENUM, UNKNOWN_NODEID, UNKNOWN_HIRID,\n+\t\t      UNKNOWN_LOCAL_DEFID);\n+}\n+\n+CrateNum\n+NodeMapping::get_crate_num () const\n+{\n+  return crateNum;\n+}\n+\n+NodeId\n+NodeMapping::get_nodeid () const\n+{\n+  return nodeId;\n+}\n+\n+HirId\n+NodeMapping::get_hirid () const\n+{\n+  return hirId;\n+}\n+\n+LocalDefId\n+NodeMapping::get_local_defid () const\n+{\n+  return localDefId;\n+}\n+\n+DefId\n+NodeMapping::get_defid () const\n+{\n+  return get_defid (get_crate_num (), get_local_defid ());\n+}\n+\n+DefId\n+NodeMapping::get_defid (CrateNum crate_num, LocalDefId local_defid)\n+{\n+  return DefId{crate_num, local_defid};\n+}\n+\n+std::string\n+NodeMapping::as_string () const\n+{\n+  std::ostringstream ss;\n+  ss << \"[\"\n+     << \"C: \" << get_crate_num ();\n+  if (get_nodeid () != UNKNOWN_NODEID)\n+    ss << \" Nid: \" << get_nodeid ();\n+\n+  if (get_hirid () != UNKNOWN_HIRID)\n+    ss << \" Hid: \" << get_hirid ();\n+\n+  if (get_local_defid () != UNKNOWN_LOCAL_DEFID)\n+    ss << \" Lid: \" << get_local_defid ();\n+\n+  ss << \"]\";\n+  return ss.str ();\n+}\n+\n+// Mappings Class now\n+static const HirId kDefaultNodeIdBegin = 1;\n+static const HirId kDefaultHirIdBegin = 1;\n+static const HirId kDefaultCrateNumBegin = 0;\n+\n+Mappings::Mappings ()\n+  : crateNumItr (kDefaultCrateNumBegin), currentCrateNum (UNKNOWN_CREATENUM),\n+    hirIdIter (kDefaultHirIdBegin), nodeIdIter (kDefaultNodeIdBegin)\n+{}\n+\n+Mappings::~Mappings () {}\n+\n+Mappings *\n+Mappings::get ()\n+{\n+  static std::unique_ptr<Mappings> instance;\n+  if (!instance)\n+    instance = std::unique_ptr<Mappings> (new Mappings ());\n+\n+  return instance.get ();\n+}\n+\n+CrateNum\n+Mappings::get_next_crate_num (const std::string &name)\n+{\n+  auto id = crateNumItr;\n+  crateNumItr++;\n+  set_crate_name (id, name);\n+  return id;\n+}\n+\n+void\n+Mappings::set_current_crate (CrateNum crateNum)\n+{\n+  currentCrateNum = crateNum;\n+}\n+\n+CrateNum\n+Mappings::get_current_crate () const\n+{\n+  return currentCrateNum;\n+}\n+\n+bool\n+Mappings::get_crate_name (CrateNum crate_num, std::string &name) const\n+{\n+  auto it = crate_names.find (crate_num);\n+  if (it == crate_names.end ())\n+    return false;\n+\n+  name.assign (it->second);\n+  return true;\n+}\n+\n+void\n+Mappings::set_crate_name (CrateNum crate_num, const std::string &name)\n+{\n+  crate_names[crate_num] = name;\n+}\n+\n+std::string\n+Mappings::get_current_crate_name () const\n+{\n+  std::string name;\n+  bool ok = get_crate_name (get_current_crate (), name);\n+  rust_assert (ok);\n+  return name;\n+}\n+\n+bool\n+Mappings::lookup_crate_name (const std::string &crate_name,\n+\t\t\t     CrateNum &resolved_crate_num) const\n+{\n+  for (const auto &it : crate_names)\n+    {\n+      if (it.second.compare (crate_name) == 0)\n+\t{\n+\t  resolved_crate_num = it.first;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+Mappings::crate_num_to_nodeid (const CrateNum &crate_num, NodeId &node_id) const\n+{\n+  auto it = ast_crate_mappings.find (crate_num);\n+  if (it == ast_crate_mappings.end ())\n+    return false;\n+\n+  node_id = it->second->get_node_id ();\n+  return true;\n+}\n+\n+bool\n+Mappings::node_is_crate (NodeId node_id) const\n+{\n+  for (const auto &it : ast_crate_mappings)\n+    {\n+      NodeId crate_node_id = it.second->get_node_id ();\n+      if (crate_node_id == node_id)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+NodeId\n+Mappings::get_next_node_id ()\n+{\n+  auto it = nodeIdIter;\n+  nodeIdIter++;\n+  return it;\n+}\n+\n+HirId\n+Mappings::get_next_hir_id (CrateNum crateNum)\n+{\n+  auto id = hirIdIter;\n+  hirIdIter++;\n+\n+  auto it = hirNodesWithinCrate.find (crateNum);\n+  if (it == hirNodesWithinCrate.end ())\n+    {\n+      hirNodesWithinCrate.insert ({crateNum, {}});\n+    }\n+\n+  hirNodesWithinCrate[crateNum].insert (id);\n+  return id;\n+}\n+\n+LocalDefId\n+Mappings::get_next_localdef_id (CrateNum crateNum)\n+{\n+  auto it = localIdIter.find (crateNum);\n+  if (it == localIdIter.end ())\n+    {\n+      localIdIter.insert ({crateNum, 1});\n+    }\n+\n+  it = localIdIter.find (crateNum);\n+  rust_assert (it != localIdIter.end ());\n+\n+  LocalDefId id = it->second;\n+  localIdIter[crateNum] = id + 1;\n+  return id;\n+}\n+\n+AST::Crate &\n+Mappings::get_ast_crate (CrateNum crateNum)\n+{\n+  auto it = ast_crate_mappings.find (crateNum);\n+  rust_assert (it != ast_crate_mappings.end ());\n+  return *it->second;\n+}\n+\n+AST::Crate &\n+Mappings::get_ast_crate_by_node_id (NodeId id)\n+{\n+  auto i = crate_node_to_crate_num.find (id);\n+  rust_assert (i != crate_node_to_crate_num.end ());\n+\n+  CrateNum crateNum = i->second;\n+  auto it = ast_crate_mappings.find (crateNum);\n+  rust_assert (it != ast_crate_mappings.end ());\n+  return *it->second;\n+}\n+\n+AST::Crate &\n+Mappings::insert_ast_crate (std::unique_ptr<AST::Crate> &&crate,\n+\t\t\t    CrateNum crate_num)\n+{\n+  auto it = ast_crate_mappings.find (crate_num);\n+  rust_assert (it == ast_crate_mappings.end ());\n+\n+  // store it\n+  ast_crate_mappings.insert ({crate_num, crate.release ()});\n+\n+  // return the reference to it\n+  it = ast_crate_mappings.find (crate_num);\n+  rust_assert (it != ast_crate_mappings.end ());\n+  return *it->second;\n+}\n+\n+HIR::Crate &\n+Mappings::get_hir_crate (CrateNum crateNum)\n+{\n+  auto it = hir_crate_mappings.find (crateNum);\n+  rust_assert (it != hir_crate_mappings.end ());\n+  return *it->second;\n+}\n+\n+bool\n+Mappings::is_local_hirid_crate (HirId crateNum)\n+{\n+  for (const auto &it : hir_crate_mappings)\n+    {\n+      const auto &crate = it.second;\n+      if (crate->get_mappings ().get_hirid () == crateNum)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+HIR::Crate &\n+Mappings::insert_hir_crate (std::unique_ptr<HIR::Crate> &&crate)\n+{\n+  CrateNum crateNum = crate->get_mappings ().get_crate_num ();\n+  auto it = hir_crate_mappings.find (crateNum);\n+  rust_assert (it == hir_crate_mappings.end ());\n+\n+  insert_node_to_hir (crate->get_mappings ().get_nodeid (),\n+\t\t      crate->get_mappings ().get_hirid ());\n+  hir_crate_mappings.insert ({crateNum, crate.release ()});\n+\n+  it = hir_crate_mappings.find (crateNum);\n+  rust_assert (it != hir_crate_mappings.end ());\n+  return *it->second;\n+}\n+\n+void\n+Mappings::insert_defid_mapping (DefId id, HIR::Item *item)\n+{\n+  CrateNum crate_num = id.crateNum;\n+  LocalDefId local_def_id = id.localDefId;\n+\n+  rust_assert (lookup_defid (id) == nullptr);\n+  rust_assert (lookup_local_defid (crate_num, local_def_id) == nullptr);\n+\n+  defIdMappings[id] = item;\n+  insert_local_defid_mapping (crate_num, local_def_id, item);\n+}\n+\n+HIR::Item *\n+Mappings::lookup_defid (DefId id)\n+{\n+  auto it = defIdMappings.find (id);\n+  if (it == defIdMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_item (HIR::Item *item)\n+{\n+  auto id = item->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_item (id) == nullptr);\n+\n+  hirItemMappings[id] = item;\n+  insert_node_to_hir (item->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::Item *\n+Mappings::lookup_hir_item (HirId id)\n+{\n+  auto it = hirItemMappings.find (id);\n+  if (it == hirItemMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_trait_item (HIR::TraitItem *item)\n+{\n+  auto id = item->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_trait_item (id) == nullptr);\n+\n+  hirTraitItemMappings[id] = item;\n+  insert_node_to_hir (item->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::TraitItem *\n+Mappings::lookup_hir_trait_item (HirId id)\n+{\n+  auto it = hirTraitItemMappings.find (id);\n+  if (it == hirTraitItemMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_extern_block (HIR::ExternBlock *block)\n+{\n+  auto id = block->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_extern_block (id) == nullptr);\n+\n+  hirExternBlockMappings[id] = block;\n+  insert_node_to_hir (block->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::ExternBlock *\n+Mappings::lookup_hir_extern_block (HirId id)\n+{\n+  auto it = hirExternBlockMappings.find (id);\n+  if (it == hirExternBlockMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_extern_item (HIR::ExternalItem *item, HirId parent_block)\n+{\n+  auto id = item->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_extern_item (id, nullptr) == nullptr);\n+\n+  hirExternItemMappings[id] = {item, parent_block};\n+  insert_node_to_hir (item->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::ExternalItem *\n+Mappings::lookup_hir_extern_item (HirId id, HirId *parent_block)\n+{\n+  auto it = hirExternItemMappings.find (id);\n+  if (it == hirExternItemMappings.end ())\n+    return nullptr;\n+\n+  *parent_block = it->second.second;\n+\n+  return it->second.first;\n+}\n+\n+void\n+Mappings::insert_hir_impl_block (HIR::ImplBlock *item)\n+{\n+  auto id = item->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_impl_block (id) == nullptr);\n+\n+  hirImplBlockMappings[id] = item;\n+  insert_node_to_hir (item->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::ImplBlock *\n+Mappings::lookup_hir_impl_block (HirId id)\n+{\n+  auto it = hirImplBlockMappings.find (id);\n+  if (it == hirImplBlockMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_module (HIR::Module *module)\n+{\n+  auto id = module->get_mappings ().get_hirid ();\n+  rust_assert (lookup_module (id) == nullptr);\n+\n+  hirModuleMappings[id] = module;\n+  insert_node_to_hir (module->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::Module *\n+Mappings::lookup_module (HirId id)\n+{\n+  auto it = hirModuleMappings.find (id);\n+  if (it == hirModuleMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_implitem (HirId parent_impl_id, HIR::ImplItem *item)\n+{\n+  auto id = item->get_impl_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_implitem (id, nullptr) == nullptr);\n+\n+  hirImplItemMappings[id]\n+    = std::pair<HirId, HIR::ImplItem *> (parent_impl_id, item);\n+  insert_node_to_hir (item->get_impl_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::ImplItem *\n+Mappings::lookup_hir_implitem (HirId id, HirId *parent_impl_id)\n+{\n+  auto it = hirImplItemMappings.find (id);\n+  if (it == hirImplItemMappings.end ())\n+    return nullptr;\n+\n+  std::pair<HirId, HIR::ImplItem *> &ref = it->second;\n+  if (parent_impl_id != nullptr)\n+    *parent_impl_id = ref.first;\n+\n+  return ref.second;\n+}\n+\n+void\n+Mappings::insert_hir_expr (HIR::Expr *expr)\n+{\n+  auto id = expr->get_mappings ().get_hirid ();\n+  hirExprMappings[id] = expr;\n+\n+  insert_node_to_hir (expr->get_mappings ().get_nodeid (), id);\n+  insert_location (id, expr->get_locus ());\n+}\n+\n+HIR::Expr *\n+Mappings::lookup_hir_expr (HirId id)\n+{\n+  auto it = hirExprMappings.find (id);\n+  if (it == hirExprMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_path_expr_seg (HIR::PathExprSegment *expr)\n+{\n+  auto id = expr->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_path_expr_seg (id) == nullptr);\n+\n+  hirPathSegMappings[id] = expr;\n+  insert_node_to_hir (expr->get_mappings ().get_nodeid (), id);\n+  insert_location (id, expr->get_locus ());\n+}\n+\n+HIR::PathExprSegment *\n+Mappings::lookup_hir_path_expr_seg (HirId id)\n+{\n+  auto it = hirPathSegMappings.find (id);\n+  if (it == hirPathSegMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_generic_param (HIR::GenericParam *param)\n+{\n+  auto id = param->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_generic_param (id) == nullptr);\n+\n+  hirGenericParamMappings[id] = param;\n+  insert_node_to_hir (param->get_mappings ().get_nodeid (), id);\n+  insert_location (id, param->get_locus ());\n+}\n+\n+HIR::GenericParam *\n+Mappings::lookup_hir_generic_param (HirId id)\n+{\n+  auto it = hirGenericParamMappings.find (id);\n+  if (it == hirGenericParamMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_type (HIR::Type *type)\n+{\n+  auto id = type->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_type (id) == nullptr);\n+\n+  hirTypeMappings[id] = type;\n+  insert_node_to_hir (type->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::Type *\n+Mappings::lookup_hir_type (HirId id)\n+{\n+  auto it = hirTypeMappings.find (id);\n+  if (it == hirTypeMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_stmt (HIR::Stmt *stmt)\n+{\n+  auto id = stmt->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_stmt (id) == nullptr);\n+\n+  hirStmtMappings[id] = stmt;\n+  insert_node_to_hir (stmt->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::Stmt *\n+Mappings::lookup_hir_stmt (HirId id)\n+{\n+  auto it = hirStmtMappings.find (id);\n+  if (it == hirStmtMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_param (HIR::FunctionParam *param)\n+{\n+  auto id = param->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_param (id) == nullptr);\n+\n+  hirParamMappings[id] = param;\n+  insert_node_to_hir (param->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::FunctionParam *\n+Mappings::lookup_hir_param (HirId id)\n+{\n+  auto it = hirParamMappings.find (id);\n+  if (it == hirParamMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_self_param (HIR::SelfParam *param)\n+{\n+  auto id = param->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_self_param (id) == nullptr);\n+\n+  hirSelfParamMappings[id] = param;\n+  insert_node_to_hir (param->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::SelfParam *\n+Mappings::lookup_hir_self_param (HirId id)\n+{\n+  auto it = hirSelfParamMappings.find (id);\n+  if (it == hirSelfParamMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_struct_field (HIR::StructExprField *field)\n+{\n+  auto id = field->get_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_struct_field (id) == nullptr);\n+\n+  hirStructFieldMappings[id] = field;\n+  insert_node_to_hir (field->get_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::StructExprField *\n+Mappings::lookup_hir_struct_field (HirId id)\n+{\n+  auto it = hirStructFieldMappings.find (id);\n+  if (it == hirStructFieldMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_pattern (HIR::Pattern *pattern)\n+{\n+  auto id = pattern->get_pattern_mappings ().get_hirid ();\n+  rust_assert (lookup_hir_pattern (id) == nullptr);\n+\n+  hirPatternMappings[id] = pattern;\n+  insert_node_to_hir (pattern->get_pattern_mappings ().get_nodeid (), id);\n+}\n+\n+HIR::Pattern *\n+Mappings::lookup_hir_pattern (HirId id)\n+{\n+  auto it = hirPatternMappings.find (id);\n+  if (it == hirPatternMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n+\t\t\t\t      HIR::Item *item)\n+{\n+  rust_assert (lookup_local_defid (crateNum, id) == nullptr);\n+  localDefIdMappings[crateNum][id] = item;\n+}\n+\n+HIR::Item *\n+Mappings::lookup_local_defid (CrateNum crateNum, LocalDefId id)\n+{\n+  auto it = localDefIdMappings.find (crateNum);\n+  if (it == localDefIdMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::walk_local_defids_for_crate (CrateNum crateNum,\n+\t\t\t\t       std::function<bool (HIR::Item *)> cb)\n+{\n+  auto it = localDefIdMappings.find (crateNum);\n+  if (it == localDefIdMappings.end ())\n+    return;\n+\n+  for (auto iy = it->second.begin (); iy != it->second.end (); iy++)\n+    {\n+      if (!cb (iy->second))\n+\treturn;\n+    }\n+}\n+\n+void\n+Mappings::insert_node_to_hir (NodeId id, HirId ref)\n+{\n+  nodeIdToHirMappings[id] = ref;\n+  hirIdToNodeMappings[ref] = id;\n+}\n+\n+bool\n+Mappings::lookup_node_to_hir (NodeId id, HirId *ref)\n+{\n+  auto it = nodeIdToHirMappings.find (id);\n+  if (it == nodeIdToHirMappings.end ())\n+    return false;\n+\n+  *ref = it->second;\n+  return true;\n+}\n+\n+bool\n+Mappings::lookup_hir_to_node (HirId id, NodeId *ref)\n+{\n+  auto it = hirIdToNodeMappings.find (id);\n+  if (it == hirIdToNodeMappings.end ())\n+    return false;\n+\n+  *ref = it->second;\n+  return true;\n+}\n+\n+void\n+Mappings::insert_location (HirId id, Location locus)\n+{\n+  locations[id] = locus;\n+}\n+\n+Location\n+Mappings::lookup_location (HirId id)\n+{\n+  auto it = locations.find (id);\n+  if (it == locations.end ())\n+    return Location ();\n+\n+  return it->second;\n+}\n+\n+bool\n+Mappings::resolve_nodeid_to_stmt (NodeId id, HIR::Stmt **stmt)\n+{\n+  auto it = nodeIdToHirMappings.find (id);\n+  if (it == nodeIdToHirMappings.end ())\n+    return false;\n+\n+  HirId resolved = it->second;\n+  auto resolved_stmt = lookup_hir_stmt (resolved);\n+  *stmt = resolved_stmt;\n+  return resolved_stmt != nullptr;\n+}\n+\n+void\n+Mappings::iterate_impl_items (\n+  std::function<bool (HirId, HIR::ImplItem *, HIR::ImplBlock *)> cb)\n+{\n+  for (auto it = hirImplItemMappings.begin (); it != hirImplItemMappings.end ();\n+       it++)\n+    {\n+      auto id = it->first;\n+      auto impl_item = it->second.second;\n+      auto impl\n+\t= lookup_associated_impl (impl_item->get_impl_mappings ().get_hirid ());\n+      if (!cb (id, impl_item, impl))\n+\treturn;\n+    }\n+}\n+\n+void\n+Mappings::iterate_impl_blocks (std::function<bool (HirId, HIR::ImplBlock *)> cb)\n+{\n+  for (auto it = hirImplBlockMappings.begin ();\n+       it != hirImplBlockMappings.end (); it++)\n+    {\n+      HirId id = it->first;\n+      HIR::ImplBlock *impl_block = it->second;\n+      if (!cb (id, impl_block))\n+\treturn;\n+    }\n+}\n+\n+void\n+Mappings::iterate_trait_items (\n+  std::function<bool (HIR::TraitItem *, HIR::Trait *)> cb)\n+{\n+  for (auto it = hirTraitItemMappings.begin ();\n+       it != hirTraitItemMappings.end (); it++)\n+    {\n+      HirId trait_item_id = it->first;\n+      HIR::TraitItem *trait_item = it->second;\n+      HIR::Trait *trait = lookup_trait_item_mapping (trait_item_id);\n+\n+      if (!cb (trait_item, trait))\n+\treturn;\n+    }\n+}\n+\n+void\n+Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n+{\n+  static std::map<std::string, std::function<AST::ASTFragment (\n+\t\t\t\t Location, AST::MacroInvocData &)>>\n+    builtin_macros = {\n+      {\"assert\", MacroBuiltin::assert},\n+      {\"file\", MacroBuiltin::file},\n+      {\"line\", MacroBuiltin::line},\n+      {\"column\", MacroBuiltin::column},\n+      {\"include_bytes\", MacroBuiltin::include_bytes},\n+      {\"include_str\", MacroBuiltin::include_str},\n+      {\"compile_error\", MacroBuiltin::compile_error},\n+      {\"concat\", MacroBuiltin::concat},\n+      {\"env\", MacroBuiltin::env},\n+      {\"cfg\", MacroBuiltin::cfg},\n+      {\"include\", MacroBuiltin::include},\n+    };\n+\n+  auto outer_attrs = macro->get_outer_attrs ();\n+  bool should_be_builtin\n+    = std::any_of (outer_attrs.begin (), outer_attrs.end (),\n+\t\t   [] (AST::Attribute attr) {\n+\t\t     return attr.get_path () == \"rustc_builtin_macro\";\n+\t\t   });\n+  if (should_be_builtin)\n+    {\n+      auto builtin = builtin_macros.find (macro->get_rule_name ());\n+      if (builtin != builtin_macros.end ())\n+\tmacro->set_builtin_transcriber (builtin->second);\n+      else\n+\trust_error_at (macro->get_locus (),\n+\t\t       \"cannot find a built-in macro with name %qs\",\n+\t\t       macro->get_rule_name ().c_str ());\n+    }\n+\n+  auto it = macroMappings.find (macro->get_node_id ());\n+  rust_assert (it == macroMappings.end ());\n+\n+  macroMappings[macro->get_node_id ()] = macro;\n+}\n+\n+bool\n+Mappings::lookup_macro_def (NodeId id, AST::MacroRulesDefinition **def)\n+{\n+  auto it = macroMappings.find (id);\n+  if (it == macroMappings.end ())\n+    return false;\n+\n+  *def = it->second;\n+  return true;\n+}\n+\n+void\n+Mappings::insert_visibility (NodeId id, Privacy::ModuleVisibility visibility)\n+{\n+  visibility_map.insert ({id, visibility});\n+}\n+\n+bool\n+Mappings::lookup_visibility (NodeId id, Privacy::ModuleVisibility &def)\n+{\n+  auto it = visibility_map.find (id);\n+  if (it == visibility_map.end ())\n+    return false;\n+\n+  def = it->second;\n+  return true;\n+}\n+\n+void\n+Mappings::insert_module_child (NodeId module, NodeId child)\n+{\n+  auto it = module_child_map.find (module);\n+  if (it == module_child_map.end ())\n+    module_child_map.insert ({module, {child}});\n+  else\n+    it->second.emplace_back (child);\n+}\n+\n+Optional<std::vector<NodeId> &>\n+Mappings::lookup_module_children (NodeId module)\n+{\n+  auto it = module_child_map.find (module);\n+  if (it == module_child_map.end ())\n+    return Optional<std::vector<NodeId> &>::none ();\n+\n+  return Optional<std::vector<NodeId> &>::some (it->second);\n+}\n+\n+void\n+Mappings::insert_module_child_item (NodeId module,\n+\t\t\t\t    Resolver::CanonicalPath child)\n+{\n+  rust_assert (!child.is_empty ());\n+  rust_assert (child.get_node_id () != UNKNOWN_NODEID);\n+\n+  auto it = module_child_items.find (module);\n+  if (it == module_child_items.end ())\n+    module_child_items.insert ({module, {child}});\n+  else\n+    it->second.emplace_back (child);\n+}\n+\n+Optional<std::vector<Resolver::CanonicalPath> &>\n+Mappings::lookup_module_chidren_items (NodeId module)\n+{\n+  auto it = module_child_items.find (module);\n+  if (it == module_child_items.end ())\n+    return Optional<std::vector<Resolver::CanonicalPath> &>::none ();\n+\n+  return Optional<std::vector<Resolver::CanonicalPath> &>::some (it->second);\n+}\n+\n+Optional<Resolver::CanonicalPath &>\n+Mappings::lookup_module_child (NodeId module, const std::string &item_name)\n+{\n+  Optional<std::vector<Resolver::CanonicalPath> &> children\n+    = lookup_module_chidren_items (module);\n+  if (children.is_none ())\n+    return Optional<Resolver::CanonicalPath &>::none ();\n+\n+  // lookup the children to match the name if we can\n+  for (auto &child : children.get ())\n+    {\n+      const std::string &raw_identifier = child.get ();\n+      bool found = raw_identifier.compare (item_name) == 0;\n+      if (found)\n+\treturn Optional<Resolver::CanonicalPath &>::some (child);\n+    }\n+  return Optional<Resolver::CanonicalPath &>::none ();\n+}\n+\n+void\n+Mappings::insert_child_item_to_parent_module_mapping (NodeId child_item,\n+\t\t\t\t\t\t      NodeId parent_module)\n+{\n+  child_to_parent_module_map.insert ({child_item, parent_module});\n+}\n+\n+Optional<NodeId>\n+Mappings::lookup_parent_module (NodeId child_item)\n+{\n+  auto it = child_to_parent_module_map.find (child_item);\n+  if (it == child_to_parent_module_map.end ())\n+    return Optional<NodeId>::none ();\n+\n+  return Optional<NodeId>::some (it->second);\n+}\n+\n+bool\n+Mappings::node_is_module (NodeId query)\n+{\n+  return module_child_items.find (query) != module_child_items.end ();\n+}\n+\n+void\n+Mappings::insert_ast_item (AST::Item *item)\n+{\n+  auto it = ast_item_mappings.find (item->get_node_id ());\n+  rust_assert (it == ast_item_mappings.end ());\n+\n+  ast_item_mappings[item->get_node_id ()] = item;\n+}\n+\n+bool\n+Mappings::lookup_ast_item (NodeId id, AST::Item **result)\n+{\n+  auto it = ast_item_mappings.find (id);\n+  if (it == ast_item_mappings.end ())\n+    return false;\n+\n+  *result = it->second;\n+  return true;\n+}\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "98fcfe6a6a741e9d768853113019b0530ebc090c", "filename": "gcc/rust/util/rust-hir-map.h", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,356 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_MAP_H\n+#define RUST_HIR_MAP_H\n+\n+#include \"rust-optional.h\"\n+#include \"rust-system.h\"\n+#include \"rust-location.h\"\n+#include \"rust-mapping-common.h\"\n+#include \"rust-canonical-path.h\"\n+#include \"rust-ast-full-decls.h\"\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-lang-item.h\"\n+#include \"rust-privacy-common.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+class NodeMapping\n+{\n+public:\n+  NodeMapping (CrateNum crateNum, NodeId nodeId, HirId hirId,\n+\t       LocalDefId localDefId)\n+    : crateNum (crateNum), nodeId (nodeId), hirId (hirId),\n+      localDefId (localDefId)\n+  {}\n+\n+  static NodeMapping get_error ();\n+\n+  CrateNum get_crate_num () const;\n+  NodeId get_nodeid () const;\n+  HirId get_hirid () const;\n+  LocalDefId get_local_defid () const;\n+  DefId get_defid () const;\n+\n+  static DefId get_defid (CrateNum crate_num, LocalDefId local_defid);\n+\n+  std::string as_string () const;\n+\n+  bool is_equal (const NodeMapping &other) const\n+  {\n+    return get_crate_num () == other.get_crate_num ()\n+\t   && get_nodeid () == other.get_nodeid ()\n+\t   && get_hirid () == other.get_hirid ()\n+\t   && get_local_defid () == other.get_local_defid ();\n+  }\n+\n+private:\n+  CrateNum crateNum;\n+  NodeId nodeId;\n+  HirId hirId;\n+  LocalDefId localDefId;\n+};\n+\n+class Mappings\n+{\n+public:\n+  static Mappings *get ();\n+  ~Mappings ();\n+\n+  CrateNum get_next_crate_num (const std::string &name);\n+  void set_current_crate (CrateNum crateNum);\n+  CrateNum get_current_crate () const;\n+  bool get_crate_name (CrateNum crate_num, std::string &name) const;\n+  void set_crate_name (CrateNum crate_num, const std::string &name);\n+  std::string get_current_crate_name () const;\n+  bool lookup_crate_name (const std::string &crate_name,\n+\t\t\t  CrateNum &resolved_crate_num) const;\n+  bool crate_num_to_nodeid (const CrateNum &crate_num, NodeId &node_id) const;\n+  bool node_is_crate (NodeId node_id) const;\n+\n+  NodeId get_next_node_id ();\n+  HirId get_next_hir_id () { return get_next_hir_id (get_current_crate ()); }\n+  HirId get_next_hir_id (CrateNum crateNum);\n+  LocalDefId get_next_localdef_id ()\n+  {\n+    return get_next_localdef_id (get_current_crate ());\n+  }\n+  LocalDefId get_next_localdef_id (CrateNum crateNum);\n+\n+  AST::Crate &get_ast_crate (CrateNum crateNum);\n+  AST::Crate &get_ast_crate_by_node_id (NodeId id);\n+  AST::Crate &insert_ast_crate (std::unique_ptr<AST::Crate> &&crate,\n+\t\t\t\tCrateNum crate_num);\n+  HIR::Crate &insert_hir_crate (std::unique_ptr<HIR::Crate> &&crate);\n+  HIR::Crate &get_hir_crate (CrateNum crateNum);\n+  bool is_local_hirid_crate (HirId crateNum);\n+\n+  void insert_defid_mapping (DefId id, HIR::Item *item);\n+  HIR::Item *lookup_defid (DefId id);\n+\n+  void insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n+\t\t\t\t   HIR::Item *item);\n+  HIR::Item *lookup_local_defid (CrateNum crateNum, LocalDefId id);\n+\n+  void insert_hir_item (HIR::Item *item);\n+  HIR::Item *lookup_hir_item (HirId id);\n+\n+  void insert_hir_trait_item (HIR::TraitItem *item);\n+  HIR::TraitItem *lookup_hir_trait_item (HirId id);\n+\n+  void insert_hir_extern_block (HIR::ExternBlock *block);\n+  HIR::ExternBlock *lookup_hir_extern_block (HirId id);\n+\n+  void insert_hir_extern_item (HIR::ExternalItem *item, HirId parent_block);\n+  HIR::ExternalItem *lookup_hir_extern_item (HirId id, HirId *parent_block);\n+\n+  void insert_hir_impl_block (HIR::ImplBlock *item);\n+  HIR::ImplBlock *lookup_hir_impl_block (HirId id);\n+\n+  void insert_module (HIR::Module *module);\n+  HIR::Module *lookup_module (HirId id);\n+\n+  void insert_hir_implitem (HirId parent_impl_id, HIR::ImplItem *item);\n+  HIR::ImplItem *lookup_hir_implitem (HirId id, HirId *parent_impl_id);\n+\n+  void insert_hir_expr (HIR::Expr *expr);\n+  HIR::Expr *lookup_hir_expr (HirId id);\n+\n+  void insert_hir_path_expr_seg (HIR::PathExprSegment *expr);\n+  HIR::PathExprSegment *lookup_hir_path_expr_seg (HirId id);\n+\n+  void insert_hir_generic_param (HIR::GenericParam *expr);\n+  HIR::GenericParam *lookup_hir_generic_param (HirId id);\n+\n+  void insert_hir_type (HIR::Type *type);\n+  HIR::Type *lookup_hir_type (HirId id);\n+\n+  void insert_hir_stmt (HIR::Stmt *stmt);\n+  HIR::Stmt *lookup_hir_stmt (HirId id);\n+\n+  void insert_hir_param (HIR::FunctionParam *type);\n+  HIR::FunctionParam *lookup_hir_param (HirId id);\n+\n+  void insert_hir_self_param (HIR::SelfParam *type);\n+  HIR::SelfParam *lookup_hir_self_param (HirId id);\n+\n+  void insert_hir_struct_field (HIR::StructExprField *type);\n+  HIR::StructExprField *lookup_hir_struct_field (HirId id);\n+\n+  void insert_hir_pattern (HIR::Pattern *pattern);\n+  HIR::Pattern *lookup_hir_pattern (HirId id);\n+\n+  void walk_local_defids_for_crate (CrateNum crateNum,\n+\t\t\t\t    std::function<bool (HIR::Item *)> cb);\n+\n+  void insert_node_to_hir (NodeId id, HirId ref);\n+  bool lookup_node_to_hir (NodeId id, HirId *ref);\n+  bool lookup_hir_to_node (HirId id, NodeId *ref);\n+\n+  void insert_location (HirId id, Location locus);\n+  Location lookup_location (HirId id);\n+\n+  bool resolve_nodeid_to_stmt (NodeId id, HIR::Stmt **stmt);\n+\n+  std::set<HirId> &get_hirids_within_crate (CrateNum crate)\n+  {\n+    return hirNodesWithinCrate[crate];\n+  }\n+\n+  void insert_impl_item_mapping (HirId impl_item_id, HIR::ImplBlock *impl)\n+  {\n+    rust_assert (hirImplItemsToImplMappings.find (impl_item_id)\n+\t\t == hirImplItemsToImplMappings.end ());\n+    hirImplItemsToImplMappings[impl_item_id] = impl;\n+  }\n+\n+  HIR::ImplBlock *lookup_associated_impl (HirId impl_item_id)\n+  {\n+    auto lookup = hirImplItemsToImplMappings.find (impl_item_id);\n+    rust_assert (lookup != hirImplItemsToImplMappings.end ());\n+    return lookup->second;\n+  }\n+\n+  void iterate_impl_items (\n+    std::function<bool (HirId, HIR::ImplItem *, HIR::ImplBlock *)> cb);\n+\n+  void iterate_impl_blocks (std::function<bool (HirId, HIR::ImplBlock *)> cb);\n+\n+  void iterate_trait_items (\n+    std::function<bool (HIR::TraitItem *item, HIR::Trait *)> cb);\n+\n+  bool is_impl_item (HirId id)\n+  {\n+    HirId parent_impl_block_id = UNKNOWN_HIRID;\n+    return lookup_hir_implitem (id, &parent_impl_block_id) != nullptr;\n+  }\n+\n+  void insert_trait_item_mapping (HirId trait_item_id, HIR::Trait *trait)\n+  {\n+    rust_assert (hirTraitItemsToTraitMappings.find (trait_item_id)\n+\t\t == hirTraitItemsToTraitMappings.end ());\n+    hirTraitItemsToTraitMappings[trait_item_id] = trait;\n+  }\n+\n+  HIR::Trait *lookup_trait_item_mapping (HirId trait_item_id)\n+  {\n+    auto lookup = hirTraitItemsToTraitMappings.find (trait_item_id);\n+    rust_assert (lookup != hirTraitItemsToTraitMappings.end ());\n+    return lookup->second;\n+  }\n+\n+  void insert_canonical_path (NodeId id, const Resolver::CanonicalPath path)\n+  {\n+    const Resolver::CanonicalPath *p = nullptr;\n+    if (lookup_canonical_path (id, &p))\n+      {\n+\t// if we have already stored a canonical path this is ok so long as\n+\t// this new path is equal or is smaller that the existing one but in\n+\t// that case we ignore it.\n+\tif (p->is_equal (path))\n+\t  return;\n+\telse\n+\t  {\n+\t    rust_assert (p->size () >= path.size ());\n+\t    return;\n+\t  }\n+      }\n+\n+    paths.emplace (id, std::move (path));\n+  }\n+\n+  bool lookup_canonical_path (NodeId id, const Resolver::CanonicalPath **path)\n+  {\n+    auto it = paths.find (id);\n+    if (it == paths.end ())\n+      return false;\n+\n+    *path = &it->second;\n+    return true;\n+  }\n+\n+  void insert_lang_item (RustLangItem::ItemType item_type, DefId id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    rust_assert (it == lang_item_mappings.end ());\n+\n+    lang_item_mappings[item_type] = id;\n+  }\n+\n+  bool lookup_lang_item (RustLangItem::ItemType item_type, DefId *id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    if (it == lang_item_mappings.end ())\n+      return false;\n+\n+    *id = it->second;\n+    return true;\n+  }\n+\n+  void insert_macro_def (AST::MacroRulesDefinition *macro);\n+\n+  bool lookup_macro_def (NodeId id, AST::MacroRulesDefinition **def);\n+\n+  void insert_visibility (NodeId id, Privacy::ModuleVisibility visibility);\n+  bool lookup_visibility (NodeId id, Privacy::ModuleVisibility &def);\n+\n+  void insert_module_child (NodeId module, NodeId child);\n+  Optional<std::vector<NodeId> &> lookup_module_children (NodeId module);\n+\n+  void insert_module_child_item (NodeId module, Resolver::CanonicalPath item);\n+  Optional<std::vector<Resolver::CanonicalPath> &>\n+  lookup_module_chidren_items (NodeId module);\n+  Optional<Resolver::CanonicalPath &>\n+  lookup_module_child (NodeId module, const std::string &item_name);\n+\n+  void insert_child_item_to_parent_module_mapping (NodeId child_item,\n+\t\t\t\t\t\t   NodeId parent_module);\n+  Optional<NodeId> lookup_parent_module (NodeId child_item);\n+  bool node_is_module (NodeId query);\n+\n+  void insert_ast_item (AST::Item *item);\n+  bool lookup_ast_item (NodeId id, AST::Item **result);\n+\n+private:\n+  Mappings ();\n+\n+  CrateNum crateNumItr;\n+  CrateNum currentCrateNum;\n+  HirId hirIdIter;\n+  NodeId nodeIdIter;\n+  std::map<CrateNum, LocalDefId> localIdIter;\n+\n+  std::map<NodeId, CrateNum> crate_node_to_crate_num;\n+  std::map<CrateNum, AST::Crate *> ast_crate_mappings;\n+  std::map<CrateNum, HIR::Crate *> hir_crate_mappings;\n+  std::map<DefId, HIR::Item *> defIdMappings;\n+  std::map<CrateNum, std::map<LocalDefId, HIR::Item *>> localDefIdMappings;\n+\n+  std::map<HirId, HIR::Module *> hirModuleMappings;\n+  std::map<HirId, HIR::Item *> hirItemMappings;\n+  std::map<HirId, HIR::Type *> hirTypeMappings;\n+  std::map<HirId, HIR::Expr *> hirExprMappings;\n+  std::map<HirId, HIR::Stmt *> hirStmtMappings;\n+  std::map<HirId, HIR::FunctionParam *> hirParamMappings;\n+  std::map<HirId, HIR::StructExprField *> hirStructFieldMappings;\n+  std::map<HirId, std::pair<HirId, HIR::ImplItem *>> hirImplItemMappings;\n+  std::map<HirId, HIR::SelfParam *> hirSelfParamMappings;\n+  std::map<HirId, HIR::ImplBlock *> hirImplItemsToImplMappings;\n+  std::map<HirId, HIR::ImplBlock *> hirImplBlockMappings;\n+  std::map<HirId, HIR::TraitItem *> hirTraitItemMappings;\n+  std::map<HirId, HIR::ExternBlock *> hirExternBlockMappings;\n+  std::map<HirId, std::pair<HIR::ExternalItem *, HirId>> hirExternItemMappings;\n+  std::map<HirId, HIR::PathExprSegment *> hirPathSegMappings;\n+  std::map<HirId, HIR::GenericParam *> hirGenericParamMappings;\n+  std::map<HirId, HIR::Trait *> hirTraitItemsToTraitMappings;\n+  std::map<HirId, HIR::Pattern *> hirPatternMappings;\n+  std::map<RustLangItem::ItemType, DefId> lang_item_mappings;\n+  std::map<NodeId, const Resolver::CanonicalPath> paths;\n+  std::map<NodeId, Location> locations;\n+  std::map<NodeId, HirId> nodeIdToHirMappings;\n+  std::map<HirId, NodeId> hirIdToNodeMappings;\n+\n+  // all hirid nodes\n+  std::map<CrateNum, std::set<HirId>> hirNodesWithinCrate;\n+\n+  // macros\n+  std::map<NodeId, AST::MacroRulesDefinition *> macroMappings;\n+\n+  // crate names\n+  std::map<CrateNum, std::string> crate_names;\n+\n+  // Low level visibility map for each DefId\n+  std::map<NodeId, Privacy::ModuleVisibility> visibility_map;\n+\n+  // Module tree maps\n+\n+  // Maps each module's node id to a list of its children\n+  std::map<NodeId, std::vector<NodeId>> module_child_map;\n+  std::map<NodeId, std::vector<Resolver::CanonicalPath>> module_child_items;\n+  std::map<NodeId, NodeId> child_to_parent_module_map;\n+\n+  // AST mappings\n+  std::map<NodeId, AST::Item *> ast_item_mappings;\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust\n+\n+#endif // RUST_HIR_MAP_H"}, {"sha": "0b5cb70b373ca778abdfcefb3fc0f70570e76129", "filename": "gcc/rust/util/rust-identifier.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-identifier.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-identifier.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-identifier.h?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_IDENTIFIER\n+#define RUST_IDENTIFIER\n+\n+#include \"rust-canonical-path.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+\n+struct RustIdent\n+{\n+  Resolver::CanonicalPath path;\n+  Location locus;\n+\n+  RustIdent (const Resolver::CanonicalPath &path, Location locus)\n+    : path (path), locus (locus)\n+  {}\n+\n+  RustIdent (const RustIdent &other) : path (other.path), locus (other.locus) {}\n+\n+  RustIdent &operator= (const RustIdent &other)\n+  {\n+    path = other.path;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+};\n+\n+} // namespace Rust\n+\n+#endif // RUST_IDENTIFIER"}, {"sha": "9d1ee900aeccaf74847c14007af63ba3bd0f3e70", "filename": "gcc/rust/util/rust-lang-item.h", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-lang-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-lang-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-lang-item.h?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,377 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"operator.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+// https://github.com/rust-lang/rust/blob/master/library/core/src/ops/arith.rs\n+class RustLangItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ADD,\n+    SUBTRACT,\n+    MULTIPLY,\n+    DIVIDE,\n+    REMAINDER,\n+    BITAND,\n+    BITOR,\n+    BITXOR,\n+    SHL,\n+    SHR,\n+\n+    NEGATION,\n+    NOT,\n+\n+    ADD_ASSIGN,\n+    SUB_ASSIGN,\n+    MUL_ASSIGN,\n+    DIV_ASSIGN,\n+    REM_ASSIGN,\n+    BITAND_ASSIGN,\n+    BITOR_ASSIGN,\n+    BITXOR_ASSIGN,\n+    SHL_ASSIGN,\n+    SHR_ASSIGN,\n+\n+    DEREF,\n+    DEREF_MUT,\n+\n+    // https://github.com/rust-lang/rust/blob/master/library/core/src/ops/index.rs\n+    INDEX,\n+    INDEX_MUT,\n+\n+    // https://github.com/rust-lang/rust/blob/master/library/core/src/ops/range.rs\n+    RANGE_FULL,\n+    RANGE,\n+    RANGE_FROM,\n+    RANGE_TO,\n+    RANGE_INCLUSIVE,\n+    RANGE_TO_INCLUSIVE,\n+\n+    // https://github.com/rust-lang/rust/blob/master/library/core/src/ptr/const_ptr.rs\n+    CONST_PTR,\n+    MUT_PTR,\n+    CONST_SLICE_PTR,\n+\n+    UNKNOWN,\n+  };\n+\n+  static ItemType Parse (const std::string &item)\n+  {\n+    if (item.compare (\"add\") == 0)\n+      {\n+\treturn ItemType::ADD;\n+      }\n+    else if (item.compare (\"sub\") == 0)\n+      {\n+\treturn ItemType::SUBTRACT;\n+      }\n+    else if (item.compare (\"mul\") == 0)\n+      {\n+\treturn ItemType::MULTIPLY;\n+      }\n+    else if (item.compare (\"div\") == 0)\n+      {\n+\treturn ItemType::DIVIDE;\n+      }\n+    else if (item.compare (\"rem\") == 0)\n+      {\n+\treturn ItemType::REMAINDER;\n+      }\n+    else if (item.compare (\"bitand\") == 0)\n+      {\n+\treturn ItemType::BITAND;\n+      }\n+    else if (item.compare (\"bitor\") == 0)\n+      {\n+\treturn ItemType::BITOR;\n+      }\n+    else if (item.compare (\"bitxor\") == 0)\n+      {\n+\treturn ItemType::BITXOR;\n+      }\n+    else if (item.compare (\"shl\") == 0)\n+      {\n+\treturn ItemType::SHL;\n+      }\n+    else if (item.compare (\"shr\") == 0)\n+      {\n+\treturn ItemType::SHR;\n+      }\n+    else if (item.compare (\"neg\") == 0)\n+      {\n+\treturn ItemType::NEGATION;\n+      }\n+    else if (item.compare (\"not\") == 0)\n+      {\n+\treturn ItemType::NOT;\n+      }\n+    else if (item.compare (\"add_assign\") == 0)\n+      {\n+\treturn ItemType::ADD_ASSIGN;\n+      }\n+    else if (item.compare (\"sub_assign\") == 0)\n+      {\n+\treturn ItemType::SUB_ASSIGN;\n+      }\n+    else if (item.compare (\"mul_assign\") == 0)\n+      {\n+\treturn ItemType::MUL_ASSIGN;\n+      }\n+    else if (item.compare (\"div_assign\") == 0)\n+      {\n+\treturn ItemType::DIV_ASSIGN;\n+      }\n+    else if (item.compare (\"rem_assign\") == 0)\n+      {\n+\treturn ItemType::REM_ASSIGN;\n+      }\n+    else if (item.compare (\"bitand_assign\") == 0)\n+      {\n+\treturn ItemType::BITAND_ASSIGN;\n+      }\n+    else if (item.compare (\"bitor_assign\") == 0)\n+      {\n+\treturn ItemType::BITOR_ASSIGN;\n+      }\n+    else if (item.compare (\"bitxor_assign\") == 0)\n+      {\n+\treturn ItemType::BITXOR_ASSIGN;\n+      }\n+    else if (item.compare (\"shl_assign\") == 0)\n+      {\n+\treturn ItemType::SHL_ASSIGN;\n+      }\n+    else if (item.compare (\"shr_assign\") == 0)\n+      {\n+\treturn ItemType::SHR_ASSIGN;\n+      }\n+    else if (item.compare (\"deref\") == 0)\n+      {\n+\treturn ItemType::DEREF;\n+      }\n+    else if (item.compare (\"deref_mut\") == 0)\n+      {\n+\treturn ItemType::DEREF_MUT;\n+      }\n+    else if (item.compare (\"index\") == 0)\n+      {\n+\treturn ItemType::INDEX;\n+      }\n+    else if (item.compare (\"index_mut\") == 0)\n+      {\n+\treturn ItemType::INDEX_MUT;\n+      }\n+    else if (item.compare (\"RangeFull\") == 0)\n+      {\n+\treturn ItemType::RANGE_FULL;\n+      }\n+    else if (item.compare (\"Range\") == 0)\n+      {\n+\treturn ItemType::RANGE;\n+      }\n+    else if (item.compare (\"RangeFrom\") == 0)\n+      {\n+\treturn ItemType::RANGE_FROM;\n+      }\n+    else if (item.compare (\"RangeTo\") == 0)\n+      {\n+\treturn ItemType::RANGE_TO;\n+      }\n+    else if (item.compare (\"RangeInclusive\") == 0)\n+      {\n+\treturn ItemType::RANGE_INCLUSIVE;\n+      }\n+    else if (item.compare (\"RangeToInclusive\") == 0)\n+      {\n+\treturn ItemType::RANGE_TO_INCLUSIVE;\n+      }\n+    else if (item.compare (\"const_ptr\") == 0)\n+      {\n+\treturn ItemType::CONST_PTR;\n+      }\n+    else if (item.compare (\"mut_ptr\") == 0)\n+      {\n+\treturn ItemType::MUT_PTR;\n+      }\n+    else if (item.compare (\"const_slice_ptr\") == 0)\n+      {\n+\treturn ItemType::CONST_SLICE_PTR;\n+      }\n+\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static std::string ToString (ItemType type)\n+  {\n+    switch (type)\n+      {\n+      case ADD:\n+\treturn \"add\";\n+      case SUBTRACT:\n+\treturn \"sub\";\n+      case MULTIPLY:\n+\treturn \"mul\";\n+      case DIVIDE:\n+\treturn \"div\";\n+      case REMAINDER:\n+\treturn \"rem\";\n+      case BITAND:\n+\treturn \"bitand\";\n+      case BITOR:\n+\treturn \"bitor\";\n+      case BITXOR:\n+\treturn \"bitxor\";\n+      case SHL:\n+\treturn \"shl\";\n+      case SHR:\n+\treturn \"shr\";\n+      case NEGATION:\n+\treturn \"neg\";\n+      case NOT:\n+\treturn \"not\";\n+      case ADD_ASSIGN:\n+\treturn \"add_assign\";\n+      case SUB_ASSIGN:\n+\treturn \"sub_assign\";\n+      case MUL_ASSIGN:\n+\treturn \"mul_assign\";\n+      case DIV_ASSIGN:\n+\treturn \"div_assign\";\n+      case REM_ASSIGN:\n+\treturn \"rem_assign\";\n+      case BITAND_ASSIGN:\n+\treturn \"bitand_assign\";\n+      case BITOR_ASSIGN:\n+\treturn \"bitor_assign\";\n+      case BITXOR_ASSIGN:\n+\treturn \"bitxor_assign\";\n+      case SHL_ASSIGN:\n+\treturn \"shl_assign\";\n+      case SHR_ASSIGN:\n+\treturn \"shr_assign\";\n+      case DEREF:\n+\treturn \"deref\";\n+      case DEREF_MUT:\n+\treturn \"deref_mut\";\n+      case INDEX:\n+\treturn \"index\";\n+      case INDEX_MUT:\n+\treturn \"index_mut\";\n+      case RANGE_FULL:\n+\treturn \"RangeFull\";\n+      case RANGE:\n+\treturn \"Range\";\n+      case RANGE_FROM:\n+\treturn \"RangeFrom\";\n+      case RANGE_TO:\n+\treturn \"RangeTo\";\n+      case RANGE_INCLUSIVE:\n+\treturn \"RangeInclusive\";\n+      case RANGE_TO_INCLUSIVE:\n+\treturn \"RangeToInclusive\";\n+      case CONST_PTR:\n+\treturn \"const_ptr\";\n+      case MUT_PTR:\n+\treturn \"mut_ptr\";\n+      case CONST_SLICE_PTR:\n+\treturn \"const_slice_ptr\";\n+\n+      case UNKNOWN:\n+\treturn \"<UNKNOWN>\";\n+      }\n+    return \"<UNKNOWN>\";\n+  }\n+\n+  static ItemType OperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUBTRACT;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MULTIPLY;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIVIDE;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REMAINDER;\n+      case ArithmeticOrLogicalOperator::BITWISE_AND:\n+\treturn ItemType::BITAND;\n+      case ArithmeticOrLogicalOperator::BITWISE_OR:\n+\treturn ItemType::BITOR;\n+      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+\treturn ItemType::BITXOR;\n+      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+\treturn ItemType::SHL;\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+\treturn ItemType::SHR;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType\n+  CompoundAssignmentOperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD_ASSIGN;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUB_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MUL_ASSIGN;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIV_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REM_ASSIGN;\n+      case ArithmeticOrLogicalOperator::BITWISE_AND:\n+\treturn ItemType::BITAND_ASSIGN;\n+      case ArithmeticOrLogicalOperator::BITWISE_OR:\n+\treturn ItemType::BITOR_ASSIGN;\n+      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+\treturn ItemType::BITXOR_ASSIGN;\n+      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+\treturn ItemType::SHL_ASSIGN;\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+\treturn ItemType::SHR_ASSIGN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType NegationOperatorToLangItem (NegationOperator op)\n+  {\n+    switch (op)\n+      {\n+      case NegationOperator::NEGATE:\n+\treturn ItemType::NEGATION;\n+      case NegationOperator::NOT:\n+\treturn ItemType::NOT;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "c440ae98931f90bff69a22664ece5e074bfaeef3", "filename": "gcc/rust/util/rust-mapping-common.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-mapping-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-mapping-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-mapping-common.h?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MAPPING_COMMON\n+#define RUST_MAPPING_COMMON\n+\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+\n+// refers to a Crate\n+typedef uint32_t CrateNum;\n+// refers to any node in the AST in current Crate\n+typedef uint32_t NodeId;\n+// refers to any node in the HIR for the current crate\n+typedef uint32_t HirId;\n+// refers to any top-level decl in HIR\n+typedef uint32_t LocalDefId;\n+\n+struct DefId\n+{\n+  CrateNum crateNum;\n+  LocalDefId localDefId;\n+\n+  bool operator== (const DefId &other) const\n+  {\n+    return this->crateNum == other.crateNum\n+\t   && this->localDefId == other.localDefId;\n+  }\n+\n+  bool operator!= (const DefId &other) const { return !(*this == other); }\n+\n+  bool operator< (const DefId &other) const\n+  {\n+    return ((uint64_t) this->crateNum << 32 | this->localDefId)\n+\t   < ((uint64_t) other.crateNum << 32 | other.localDefId);\n+  }\n+\n+  std::string as_string () const\n+  {\n+    std::string buf;\n+    buf += std::to_string (crateNum);\n+    buf += \" \"; // or anything else\n+    buf += std::to_string (localDefId);\n+    return buf;\n+  }\n+};\n+\n+#define UNKNOWN_CREATENUM ((uint32_t) (0))\n+#define UNKNOWN_NODEID ((uint32_t) (0))\n+#define UNKNOWN_HIRID ((uint32_t) (0))\n+#define UNKNOWN_LOCAL_DEFID ((uint32_t) (0))\n+#define UNKNOWN_DEFID (DefId{0, 0})\n+\n+} // namespace Rust\n+\n+namespace std {\n+template <> struct hash<Rust::DefId>\n+{\n+  size_t operator() (const Rust::DefId &id) const noexcept\n+  {\n+    // TODO: Check if we can improve performance by having a better hash\n+    // algorithm for `DefId`s\n+    return hash<uint32_t> () (hash<uint32_t> () (id.crateNum)\n+\t\t\t      + hash<uint32_t> () (id.localDefId));\n+  }\n+};\n+} // namespace std\n+\n+#endif // RUST_MAPPING_COMMON"}, {"sha": "c34eb907f06dfcc61e0976345938d54ad497d22a", "filename": "gcc/rust/util/rust-stacked-contexts.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-stacked-contexts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce37e720624accb7977ead5d0f25ac2b459c2aa/gcc%2Frust%2Futil%2Frust-stacked-contexts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-stacked-contexts.h?ref=9ce37e720624accb7977ead5d0f25ac2b459c2aa", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_CONTEXT_STACK_H\n+#define RUST_CONTEXT_STACK_H\n+\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+\n+/**\n+ * Context stack util class. This class is useful for situations where you can\n+ * enter the same kind of context multiple times. For example, when dealing with\n+ * unsafe contexts, you might be tempted to simply keep a boolean value.\n+ *\n+ * ```rust\n+ * let a = 15;\n+ * unsafe { // we set the boolean to true\n+ *     // Now unsafe operations are allowed!\n+ *     let b = *(&a as *const i32);\n+ *     let c = std::mem::transmute<i32, f32>(b); // Urgh!\n+ * } // we set it to false\n+ * ```\n+ *\n+ * However, since the language allows nested unsafe blocks, you may run into\n+ * this situation:\n+ *\n+ * ```rust\n+ * unsafe { // we set the boolean to true\n+ *     unsafe { // we set the boolean to true\n+ *     } // we set it to false\n+ *\n+ *     // Now unsafe operations are forbidden again, the boolean is false\n+ *     let f = std::mem::transmute<i32, f32>(15); // Error!\n+ * } // we set it to false\n+ * ```\n+ */\n+template <typename T> class StackedContexts\n+{\n+public:\n+  /**\n+   * Enter a special context\n+   */\n+  void enter (T value) { stack.emplace_back (value); }\n+\n+  /**\n+   * Exit a special context\n+   */\n+  T exit ()\n+  {\n+    rust_assert (!stack.empty ());\n+\n+    auto last = stack.back ();\n+    stack.pop_back ();\n+\n+    return last;\n+  }\n+\n+  /**\n+   * Are we currently inside of a special context?\n+   */\n+  bool is_in_context () const { return !stack.empty (); }\n+\n+private:\n+  /* Actual data */\n+  std::vector<T> stack;\n+};\n+\n+} // namespace Rust\n+\n+#endif /* !RUST_CONTEXT_STACK_H */"}]}