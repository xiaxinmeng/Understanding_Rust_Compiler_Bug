{"sha": "4790fe99f236c7f1b617722403e682ba2f82485f", "node_id": "C_kwDOANBUbNoAKDQ3OTBmZTk5ZjIzNmM3ZjFiNjE3NzIyNDAzZTY4MmJhMmY4MjQ4NWY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-27T06:23:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-27T06:23:08Z"}, "message": "openmp: Add OpenMP assume, assumes and begin/end assumes support\n\nThe following patch implements OpenMP 5.1\n #pragma omp assume\n #pragma omp assumes\nand\n #pragma omp begin assumes\n #pragma omp end assumes\ndirective support for C and C++.  Currently it doesn't remember\nanything from the assumption clauses for later, so is mainly\nto support the directives and diagnose errors in their use.\nIf the recently posted C++23 [[assume (cond)]]; support makes it\nin, the intent is that this can be easily adjusted at least for\nthe #pragma omp assume directive with holds clause(s) to use\nthe same infrastructure.  Now, C++23 portable assumptions are slightly\ndifferent from OpenMP 5.1 assumptions' holds clause in that C++23\nassumption holds just where it appears, while OpenMP 5.1 assumptions\nhold everywhere in the scope of the directive.  For assumes\ndirective which can appear at file or namespace scope it is the whole\nTU and everything that functions from there call at runtime, for\nbegin assumes/end assumes pair all the functions in between those\ndirectives and everything they call and for assume directive the\nassociated (currently structured) block.  I have no idea how to\nrepresents such holds to be usable for optimizers, except to\nmake\n #pragma omp assume holds (cond)\nblock;\nexpand essentially to\n[[assume (cond)]];\nblock;\nor\n[[assume (cond)]];\nblock;\n[[assume (cond)]];\nfor now.  Except for holds clause, the other assumptions are\nOpenMP related, I'd say we should brainstorm where it would be\nuseful to optimize based on such information (I guess e.g. in target\nregions it easily could) and only when we come up with something\nlike that think about how to propagate the assumptions to the optimizers.\n\n2022-09-27  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/c-family/\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_ASSUME,\n\tPRAGMA_OMP_ASSUMES and PRAGMA_OMP_BEGIN.  Rename\n\tPRAGMA_OMP_END_DECLARE_TARGET to PRAGMA_OMP_END.\n\t* c-pragma.cc (omp_pragmas): Add assumes and begin.\n\tFor end rename PRAGMA_OMP_END_DECLARE_TARGET to PRAGMA_OMP_END.\n\t(omp_pragmas_simd): Add assume.\n\t* c-common.h (c_omp_directives): Declare.\n\t* c-omp.cc (omp_directives): Rename to ...\n\t(c_omp_directives): ... this.  No longer static.  Uncomment\n\tassume, assumes, begin assumes and end assumes entries.\n\tIn end declare target entry rename PRAGMA_OMP_END_DECLARE_TARGET\n\tto PRAGMA_OMP_END.\n\t(c_omp_categorize_directive): Adjust for omp_directives to\n\tc_omp_directives renaming.\ngcc/c/\n\t* c-lang.h (current_omp_begin_assumes): Declare.\n\t* c-parser.cc: Include bitmap.h.\n\t(c_parser_omp_end_declare_target): Rename to ...\n\t(c_parser_omp_end): ... this.  Handle also end assumes.\n\t(c_parser_omp_begin, c_parser_omp_assumption_clauses,\n\tc_parser_omp_assumes, c_parser_omp_assume): New functions.\n\t(c_parser_translation_unit): Also diagnose #pragma omp begin assumes\n\twithout corresponding #pragma omp end assumes.\n\t(c_parser_pragma): Use %s in may only be used at file scope\n\tdiagnostics to decrease number of translatable messages.  Handle\n\tPRAGMA_OMP_BEGIN and PRAGMA_OMP_ASSUMES.  Handle PRAGMA_OMP_END\n\trather than PRAGMA_OMP_END_DECLARE_TARGET and call c_parser_omp_end\n\tfor it rather than c_parser_omp_end_declare_target.\n\t(c_parser_omp_construct): Handle PRAGMA_OMP_ASSUME.\n\t* c-decl.cc (current_omp_begin_assumes): Define.\ngcc/cp/\n\t* cp-tree.h (struct omp_begin_assumes_data): New type.\n\t(struct saved_scope): Add omp_begin_assumes member.\n\t* parser.cc: Include bitmap.h.\n\t(cp_parser_omp_assumption_clauses, cp_parser_omp_assume,\n\tcp_parser_omp_assumes, cp_parser_omp_begin): New functions.\n\t(cp_parser_omp_end_declare_target): Rename to ...\n\t(cp_parser_omp_end): ... this.  Handle also end assumes.\n\t(cp_parser_omp_construct): Handle PRAGMA_OMP_ASSUME.\n\t(cp_parser_pragma): Handle PRAGMA_OMP_ASSUME, PRAGMA_OMP_ASSUMES\n\tand PRAGMA_OMP_BEGIN.  Handle PRAGMA_OMP_END rather than\n\tPRAGMA_OMP_END_DECLARE_TARGET and call cp_parser_omp_end\n\tfor it rather than cp_parser_omp_end_declare_target.\n\t* pt.cc (apply_late_template_attributes): Also temporarily clear\n\tomp_begin_assumes.\n\t* semantics.cc (finish_translation_unit): Also diagnose\n\t#pragma omp begin assumes without corresponding\n\t#pragma omp end assumes.\ngcc/testsuite/\n\t* c-c++-common/gomp/assume-1.c: New test.\n\t* c-c++-common/gomp/assume-2.c: New test.\n\t* c-c++-common/gomp/assume-3.c: New test.\n\t* c-c++-common/gomp/assumes-1.c: New test.\n\t* c-c++-common/gomp/assumes-2.c: New test.\n\t* c-c++-common/gomp/assumes-3.c: New test.\n\t* c-c++-common/gomp/assumes-4.c: New test.\n\t* c-c++-common/gomp/begin-assumes-1.c: New test.\n\t* c-c++-common/gomp/begin-assumes-2.c: New test.\n\t* c-c++-common/gomp/begin-assumes-3.c: New test.\n\t* c-c++-common/gomp/begin-assumes-4.c: New test.\n\t* c-c++-common/gomp/declare-target-6.c: New test.\n\t* g++.dg/gomp/attrs-1.C (bar): Add n1 and n2 arguments, add\n\ttests for assume directive.\n\t* g++.dg/gomp/attrs-2.C (bar): Likewise.\n\t* g++.dg/gomp/attrs-9.C: Add n1 and n2 variables, add tests for\n\tbegin assumes directive.\n\t* g++.dg/gomp/attrs-15.C: New test.\n\t* g++.dg/gomp/attrs-16.C: New test.\n\t* g++.dg/gomp/attrs-17.C: New test.", "tree": {"sha": "2b247f6e88dc3f479497f74215bf1be01f127232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b247f6e88dc3f479497f74215bf1be01f127232"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4790fe99f236c7f1b617722403e682ba2f82485f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4790fe99f236c7f1b617722403e682ba2f82485f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4790fe99f236c7f1b617722403e682ba2f82485f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4790fe99f236c7f1b617722403e682ba2f82485f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b86d5dbe47c477daf739b82c3793a70f8cbd96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b86d5dbe47c477daf739b82c3793a70f8cbd96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b86d5dbe47c477daf739b82c3793a70f8cbd96c"}], "stats": {"total": 1142, "additions": 1075, "deletions": 67}, "files": [{"sha": "50a4691cda6577ee808c1878e935301395d74da7", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -1286,6 +1286,7 @@ struct c_omp_directive {\n   bool simd;\n };\n \n+extern const struct c_omp_directive c_omp_directives[];\n extern const struct c_omp_directive *c_omp_categorize_directive (const char *,\n \t\t\t\t\t\t\t\t const char *,\n \t\t\t\t\t\t\t\t const char *);"}, {"sha": "7a97c40935a268adbae369b88ab0df529a9ece5f", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -3097,21 +3097,21 @@ c_omp_adjust_map_clauses (tree clauses, bool is_target)\n     }\n }\n \n-static const struct c_omp_directive omp_directives[] = {\n+const struct c_omp_directive c_omp_directives[] = {\n   /* Keep this alphabetically sorted by the first word.  Non-null second/third\n      if any should precede null ones.  */\n   { \"allocate\", nullptr, nullptr, PRAGMA_OMP_ALLOCATE,\n     C_OMP_DIR_DECLARATIVE, false },\n-  /* { \"assume\", nullptr, nullptr, PRAGMA_OMP_ASSUME,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n-  /* { \"assumes\", nullptr, nullptr, PRAGMA_OMP_ASSUMES,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n+  { \"assume\", nullptr, nullptr, PRAGMA_OMP_ASSUME,\n+    C_OMP_DIR_INFORMATIONAL, false },\n+  { \"assumes\", nullptr, nullptr, PRAGMA_OMP_ASSUMES,\n+    C_OMP_DIR_INFORMATIONAL, false },\n   { \"atomic\", nullptr, nullptr, PRAGMA_OMP_ATOMIC,\n     C_OMP_DIR_CONSTRUCT, false },\n   { \"barrier\", nullptr, nullptr, PRAGMA_OMP_BARRIER,\n     C_OMP_DIR_STANDALONE, false },\n-  /* { \"begin\", \"assumes\", nullptr, PRAGMA_OMP_BEGIN,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n+  { \"begin\", \"assumes\", nullptr, PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_INFORMATIONAL, false },\n   /* { \"begin\", \"declare\", \"target\", PRAGMA_OMP_BEGIN,\n     C_OMP_DIR_DECLARATIVE, false }, */\n   /* { \"begin\", \"declare\", \"variant\", PRAGMA_OMP_BEGIN,\n@@ -3140,9 +3140,9 @@ static const struct c_omp_directive omp_directives[] = {\n     C_OMP_DIR_CONSTRUCT, false },  */\n   { \"distribute\", nullptr, nullptr, PRAGMA_OMP_DISTRIBUTE,\n     C_OMP_DIR_CONSTRUCT, true },\n-  /* { \"end\", \"assumes\", nullptr, PRAGMA_OMP_END,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n-  { \"end\", \"declare\", \"target\", PRAGMA_OMP_END_DECLARE_TARGET,\n+  { \"end\", \"assumes\", nullptr, PRAGMA_OMP_END,\n+    C_OMP_DIR_INFORMATIONAL, false },\n+  { \"end\", \"declare\", \"target\", PRAGMA_OMP_END,\n     C_OMP_DIR_DECLARATIVE, false },\n   /* { \"end\", \"declare\", \"variant\", PRAGMA_OMP_END,\n     C_OMP_DIR_DECLARATIVE, false }, */\n@@ -3224,26 +3224,26 @@ const struct c_omp_directive *\n c_omp_categorize_directive (const char *first, const char *second,\n \t\t\t    const char *third)\n {\n-  const size_t n_omp_directives = ARRAY_SIZE (omp_directives);\n+  const size_t n_omp_directives = ARRAY_SIZE (c_omp_directives);\n   for (size_t i = 0; i < n_omp_directives; i++)\n     {\n-      if ((unsigned char) omp_directives[i].first[0]\n+      if ((unsigned char) c_omp_directives[i].first[0]\n \t  < (unsigned char) first[0])\n \tcontinue;\n-      if ((unsigned char) omp_directives[i].first[0]\n+      if ((unsigned char) c_omp_directives[i].first[0]\n \t  > (unsigned char) first[0])\n \tbreak;\n-      if (strcmp (omp_directives[i].first, first))\n+      if (strcmp (c_omp_directives[i].first, first))\n \tcontinue;\n-      if (!omp_directives[i].second)\n-\treturn &omp_directives[i];\n-      if (!second || strcmp (omp_directives[i].second, second))\n+      if (!c_omp_directives[i].second)\n+\treturn &c_omp_directives[i];\n+      if (!second || strcmp (c_omp_directives[i].second, second))\n \tcontinue;\n-      if (!omp_directives[i].third)\n-\treturn &omp_directives[i];\n-      if (!third || strcmp (omp_directives[i].third, third))\n+      if (!c_omp_directives[i].third)\n+\treturn &c_omp_directives[i];\n+      if (!third || strcmp (c_omp_directives[i].third, third))\n \tcontinue;\n-      return &omp_directives[i];\n+      return &c_omp_directives[i];\n     }\n   return NULL;\n }"}, {"sha": "b5a4b3c970f21ebcc001b617db26df8866592505", "filename": "gcc/c-family/c-pragma.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-pragma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-pragma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.cc?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -1546,14 +1546,16 @@ static const struct omp_pragma_def oacc_pragmas[] = {\n };\n static const struct omp_pragma_def omp_pragmas[] = {\n   { \"allocate\", PRAGMA_OMP_ALLOCATE },\n+  { \"assumes\", PRAGMA_OMP_ASSUMES },\n   { \"atomic\", PRAGMA_OMP_ATOMIC },\n   { \"barrier\", PRAGMA_OMP_BARRIER },\n+  { \"begin\", PRAGMA_OMP_BEGIN },\n   { \"cancel\", PRAGMA_OMP_CANCEL },\n   { \"cancellation\", PRAGMA_OMP_CANCELLATION_POINT },\n   { \"critical\", PRAGMA_OMP_CRITICAL },\n   { \"depobj\", PRAGMA_OMP_DEPOBJ },\n   { \"error\", PRAGMA_OMP_ERROR },\n-  { \"end\", PRAGMA_OMP_END_DECLARE_TARGET },\n+  { \"end\", PRAGMA_OMP_END },\n   { \"flush\", PRAGMA_OMP_FLUSH },\n   { \"nothing\", PRAGMA_OMP_NOTHING },\n   { \"requires\", PRAGMA_OMP_REQUIRES },\n@@ -1568,6 +1570,7 @@ static const struct omp_pragma_def omp_pragmas[] = {\n   { \"threadprivate\", PRAGMA_OMP_THREADPRIVATE }\n };\n static const struct omp_pragma_def omp_pragmas_simd[] = {\n+  { \"assume\", PRAGMA_OMP_ASSUME },\n   { \"declare\", PRAGMA_OMP_DECLARE },\n   { \"distribute\", PRAGMA_OMP_DISTRIBUTE },\n   { \"for\", PRAGMA_OMP_FOR },"}, {"sha": "10a4053d8fee73175135c4899ab86afc5a5197bd", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -45,16 +45,19 @@ enum pragma_kind {\n   /* PRAGMA_OMP__START_ should be equal to the first PRAGMA_OMP_* code.  */\n   PRAGMA_OMP_ALLOCATE,\n   PRAGMA_OMP__START_ = PRAGMA_OMP_ALLOCATE,\n+  PRAGMA_OMP_ASSUME,\n+  PRAGMA_OMP_ASSUMES,\n   PRAGMA_OMP_ATOMIC,\n   PRAGMA_OMP_BARRIER,\n+  PRAGMA_OMP_BEGIN,\n   PRAGMA_OMP_CANCEL,\n   PRAGMA_OMP_CANCELLATION_POINT,\n   PRAGMA_OMP_CRITICAL,\n   PRAGMA_OMP_DECLARE,\n   PRAGMA_OMP_DEPOBJ,\n   PRAGMA_OMP_DISTRIBUTE,\n   PRAGMA_OMP_ERROR,\n-  PRAGMA_OMP_END_DECLARE_TARGET,\n+  PRAGMA_OMP_END,\n   PRAGMA_OMP_FLUSH,\n   PRAGMA_OMP_FOR,\n   PRAGMA_OMP_LOOP,"}, {"sha": "740982eae311ba2ba87374e297b601eab9da87ca", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -156,6 +156,10 @@ static bool undef_nested_function;\n /* If non-zero, implicit \"omp declare target\" attribute is added into the\n    attribute lists.  */\n int current_omp_declare_target_attribute;\n+\n+/* If non-zero, we are inside of\n+   #pragma omp begin assumes ... #pragma omp end assumes region.  */\n+int current_omp_begin_assumes;\n \f\n /* Each c_binding structure describes one binding of an identifier to\n    a decl.  All the decls in a scope - irrespective of namespace - are"}, {"sha": "861abe8377a6ce0702b9086e0837a1ab73852690", "filename": "gcc/c/c-lang.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc%2Fc-lang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc%2Fc-lang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-lang.h?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -63,5 +63,8 @@ struct GTY(()) language_function {\n /* If non-zero, implicit \"omp declare target\" attribute is added into the\n    attribute lists.  */\n extern GTY(()) int current_omp_declare_target_attribute;\n+/* Similarly whether we are in between #pragma omp begin assumes and\n+   #pragma omp end assumes (and how many times when nested).  */\n+extern GTY(()) int current_omp_begin_assumes;\n \n #endif /* ! GCC_C_LANG_H */"}, {"sha": "f2498dc1c37fc584e26742a2d97391301d49a739", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 291, "deletions": 17, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -71,6 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"memmodel.h\"\n #include \"c-family/known-headers.h\"\n+#include \"bitmap.h\"\n \n /* We need to walk over decls with incomplete struct/union/enum types\n    after parsing the whole translation unit.\n@@ -1594,10 +1595,13 @@ enum pragma_context { pragma_external, pragma_struct, pragma_param,\n static bool c_parser_pragma (c_parser *, enum pragma_context, bool *);\n static bool c_parser_omp_cancellation_point (c_parser *, enum pragma_context);\n static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);\n-static void c_parser_omp_end_declare_target (c_parser *);\n+static void c_parser_omp_begin (c_parser *);\n+static void c_parser_omp_end (c_parser *);\n static bool c_parser_omp_declare (c_parser *, enum pragma_context);\n static void c_parser_omp_requires (c_parser *);\n static bool c_parser_omp_error (c_parser *, enum pragma_context);\n+static void c_parser_omp_assumption_clauses (c_parser *, bool);\n+static void c_parser_omp_assumes (c_parser *);\n static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);\n static void c_parser_oacc_routine (c_parser *, enum pragma_context);\n \n@@ -1678,6 +1682,13 @@ c_parser_translation_unit (c_parser *parser)\n \t       \"%<#pragma omp end declare target%>\");\n       current_omp_declare_target_attribute = 0;\n     }\n+  if (current_omp_begin_assumes)\n+    {\n+      if (!errorcount)\n+\terror (\"%<#pragma omp begin assumes%> without corresponding \"\n+\t       \"%<#pragma omp end assumes%>\");\n+      current_omp_begin_assumes = 0;\n+    }\n }\n \n /* Parse an external declaration (C90 6.7, C99 6.9, C11 6.9).\n@@ -12594,8 +12605,12 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n     case PRAGMA_OMP_TARGET:\n       return c_parser_omp_target (parser, context, if_p);\n \n-    case PRAGMA_OMP_END_DECLARE_TARGET:\n-      c_parser_omp_end_declare_target (parser);\n+    case PRAGMA_OMP_BEGIN:\n+      c_parser_omp_begin (parser);\n+      return false;\n+\n+    case PRAGMA_OMP_END:\n+      c_parser_omp_end (parser);\n       return false;\n \n     case PRAGMA_OMP_SCAN:\n@@ -12619,13 +12634,26 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       if (context != pragma_external)\n \t{\n \t  error_at (c_parser_peek_token (parser)->location,\n-\t\t    \"%<#pragma omp requires%> may only be used at file scope\");\n+\t\t    \"%<#pragma %s%> may only be used at file scope\",\n+\t\t    \"omp requires\");\n \t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n \t  return false;\n \t}\n       c_parser_omp_requires (parser);\n       return false;\n \n+    case PRAGMA_OMP_ASSUMES:\n+      if (context != pragma_external)\n+\t{\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"%<#pragma %s%> may only be used at file scope\",\n+\t\t    \"omp assumes\");\n+\t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+\t  return false;\n+\t}\n+      c_parser_omp_assumes (parser);\n+      return false;\n+\n     case PRAGMA_OMP_NOTHING:\n       c_parser_omp_nothing (parser);\n       return false;\n@@ -22405,14 +22433,44 @@ c_parser_omp_declare_target (c_parser *parser)\n \t\t\"directive with only %<device_type%> clauses ignored\");\n }\n \n+/* OpenMP 5.1\n+   #pragma omp begin assumes clauses[optseq] new-line  */\n+\n+static void\n+c_parser_omp_begin (c_parser *parser)\n+{\n+  const char *p = \"\";\n+  c_parser_consume_pragma (parser);\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"assumes\") == 0)\n+    {\n+      c_parser_consume_token (parser);\n+      c_parser_omp_assumption_clauses (parser, false);\n+      current_omp_begin_assumes++;\n+    }\n+  else\n+    {\n+      c_parser_error (parser, \"expected %<assumes%>\");\n+      c_parser_skip_to_pragma_eol (parser);\n+    }\n+}\n+\n+/* OpenMP 4.0\n+   #pragma omp end declare target\n+\n+   OpenMP 5.1\n+   #pragma omp end assumes  */\n+\n static void\n-c_parser_omp_end_declare_target (c_parser *parser)\n+c_parser_omp_end (c_parser *parser)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n+  const char *p = \"\";\n   c_parser_consume_pragma (parser);\n-  if (c_parser_next_token_is (parser, CPP_NAME)\n-      && strcmp (IDENTIFIER_POINTER (c_parser_peek_token (parser)->value),\n-\t\t \"declare\") == 0)\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"declare\") == 0)\n     {\n       c_parser_consume_token (parser);\n       if (c_parser_next_token_is (parser, CPP_NAME)\n@@ -22425,22 +22483,30 @@ c_parser_omp_end_declare_target (c_parser *parser)\n \t  c_parser_skip_to_pragma_eol (parser);\n \t  return;\n \t}\n+      c_parser_skip_to_pragma_eol (parser);\n+      if (!current_omp_declare_target_attribute)\n+\terror_at (loc, \"%<#pragma omp end declare target%> without \"\n+\t\t       \"corresponding %<#pragma omp declare target%>\");\n+      else\n+\tcurrent_omp_declare_target_attribute--;\n     }\n-  else\n+  else if (strcmp (p, \"assumes\") == 0)\n     {\n-      c_parser_error (parser, \"expected %<declare%>\");\n+      c_parser_consume_token (parser);\n       c_parser_skip_to_pragma_eol (parser);\n-      return;\n+      if (!current_omp_begin_assumes)\n+\terror_at (loc, \"%<#pragma omp end assumes%> without \"\n+\t\t       \"corresponding %<#pragma omp begin assumes%>\");\n+      else\n+\tcurrent_omp_begin_assumes--;\n     }\n-  c_parser_skip_to_pragma_eol (parser);\n-  if (!current_omp_declare_target_attribute)\n-    error_at (loc, \"%<#pragma omp end declare target%> without corresponding \"\n-\t\t   \"%<#pragma omp declare target%>\");\n   else\n-    current_omp_declare_target_attribute--;\n+    {\n+      c_parser_error (parser, \"expected %<declare%> or %<assumes%>\");\n+      c_parser_skip_to_pragma_eol (parser);\n+    }\n }\n \n-\n /* OpenMP 4.0\n    #pragma omp declare reduction (reduction-id : typename-list : expression) \\\n       initializer-clause[opt] new-line\n@@ -23299,6 +23365,211 @@ c_parser_omp_error (c_parser *parser, enum pragma_context context)\n   return false;\n }\n \n+/* Assumption clauses:\n+   OpenMP 5.1\n+   absent (directive-name-list)\n+   contains (directive-name-list)\n+   holds (expression)\n+   no_openmp\n+   no_openmp_routines\n+   no_parallelism  */\n+\n+static void\n+c_parser_omp_assumption_clauses (c_parser *parser, bool is_assume)\n+{\n+  bool first = true;\n+  bool no_openmp = false;\n+  bool no_openmp_routines = false;\n+  bool no_parallelism = false;\n+  bitmap_head absent_head, contains_head;\n+\n+  bitmap_obstack_initialize (NULL);\n+  bitmap_initialize (&absent_head, &bitmap_default_obstack);\n+  bitmap_initialize (&contains_head, &bitmap_default_obstack);\n+\n+  if (c_parser_next_token_is (parser, CPP_PRAGMA_EOL))\n+    error_at (c_parser_peek_token (parser)->location,\n+\t      \"expected at least one assumption clause\");\n+\n+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    {\n+      if (!first\n+\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\tc_parser_consume_token (parser);\n+\n+      first = false;\n+\n+      if (!c_parser_next_token_is (parser, CPP_NAME))\n+\tbreak;\n+\n+      const char *p\n+\t= IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      location_t cloc = c_parser_peek_token (parser)->location;\n+\n+      if (!strcmp (p, \"no_openmp\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  if (no_openmp)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp\");\n+\t  no_openmp = true;\n+\t}\n+      else if (!strcmp (p, \"no_openmp_routines\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  if (no_openmp_routines)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp_routines\");\n+\t  no_openmp_routines = true;\n+\t}\n+      else if (!strcmp (p, \"no_parallelism\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  if (no_parallelism)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_parallelism\");\n+\t  no_parallelism = true;\n+\t}\n+      else if (!strcmp (p, \"holds\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      location_t eloc = c_parser_peek_token (parser)->location;\n+\t      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t      tree t = convert_lvalue_to_rvalue (eloc, expr, true, true).value;\n+\t      t = c_objc_common_truthvalue_conversion (eloc, t);\n+\t      t = c_fully_fold (t, false, NULL);\n+\t      if (is_assume)\n+\t\t{\n+\t\t  /* FIXME: Emit .ASSUME (t) call here.  */\n+\t\t  (void) t;\n+\t\t}\n+\t      parens.skip_until_found_close (parser);\n+\t    }\n+\t}\n+      else if (!strcmp (p, \"absent\") || !strcmp (p, \"contains\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  const char *directive[3] = {};\n+\t\t  int i;\n+\t\t  location_t dloc = c_parser_peek_token (parser)->location;\n+\t\t  for (i = 0; i < 3; i++)\n+\t\t    {\n+\t\t      tree id;\n+\t\t      if (c_parser_peek_nth_token (parser, i + 1)->type\n+\t\t\t  == CPP_NAME)\n+\t\t\tid = c_parser_peek_nth_token (parser, i + 1)->value;\n+\t\t      else if (c_parser_peek_nth_token (parser, i + 1)->keyword\n+\t\t\t       != RID_MAX)\n+\t\t\t{\n+\t\t\t  enum rid rid\n+\t\t\t    = c_parser_peek_nth_token (parser, i + 1)->keyword;\n+\t\t\t  id = ridpointers[rid];\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n+\t\t      directive[i] = IDENTIFIER_POINTER (id);\n+\t\t    }\n+\t\t  if (i == 0)\n+\t\t    error_at (dloc, \"expected directive name\");\n+\t\t  else\n+\t\t    {\n+\t\t      const struct c_omp_directive *dir\n+\t\t\t= c_omp_categorize_directive (directive[0],\n+\t\t\t\t\t\t      directive[1],\n+\t\t\t\t\t\t      directive[2]);\n+\t\t      if (dir == NULL\n+\t\t\t  || dir->kind == C_OMP_DIR_DECLARATIVE\n+\t\t\t  || dir->kind == C_OMP_DIR_INFORMATIONAL\n+\t\t\t  || dir->id == PRAGMA_OMP_END\n+\t\t\t  || (!dir->second && directive[1])\n+\t\t\t  || (!dir->third && directive[2]))\n+\t\t\terror_at (dloc, \"unknown OpenMP directive name in \"\n+\t\t\t\t\t\"%qs clause argument\", p);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  int id = dir - c_omp_directives;\n+\t\t\t  if (bitmap_bit_p (p[0] == 'a' ? &contains_head\n+\t\t\t\t\t\t\t: &absent_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned in both %<absent%> and \"\n+\t\t\t\t\t    \"%<contains%> clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\");\n+\t\t\t  else if (!bitmap_set_bit (p[0] == 'a'\n+\t\t\t\t\t\t    ? &absent_head\n+\t\t\t\t\t\t    : &contains_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned multiple times in %qs \"\n+\t\t\t\t\t    \"clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\", p);\n+\t\t\t}\n+\t\t      for (; i; --i)\n+\t\t\tc_parser_consume_token (parser);\n+\t\t    }\n+\t\t  if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t    c_parser_consume_token (parser);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      parens.skip_until_found_close (parser);\n+\t    }\n+\t}\n+      else if (startswith (p, \"ext_\"))\n+\t{\n+\t  warning_at (cloc, 0, \"unknown assumption clause %qs\", p);\n+\t  c_parser_consume_token (parser);\n+\t  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+\t    {\n+\t      matching_parens parens;\n+\t      parens.consume_open (parser);\n+\t      c_parser_balanced_token_sequence (parser);\n+\t      parens.require_close (parser);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  error_at (cloc, \"expected assumption clause\");\n+\t  break;\n+\t}\n+    }\n+  c_parser_skip_to_pragma_eol (parser);\n+}\n+\n+/* OpenMP 5.1\n+   #pragma omp assume clauses[optseq] new-line  */\n+\n+static void\n+c_parser_omp_assume (c_parser *parser, bool *if_p)\n+{\n+  c_parser_omp_assumption_clauses (parser, true);\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n+}\n+\n+/* OpenMP 5.1\n+   #pragma omp assumes clauses[optseq] new-line  */\n+\n+static void\n+c_parser_omp_assumes (c_parser *parser)\n+{\n+  c_parser_consume_pragma (parser);\n+  c_parser_omp_assumption_clauses (parser, false);\n+}\n+\n /* Main entry point to parsing most OpenMP pragmas.  */\n \n static void\n@@ -23404,6 +23675,9 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_teams (loc, parser, p_name, mask, NULL, if_p);\n       break;\n+    case PRAGMA_OMP_ASSUME:\n+      c_parser_omp_assume (parser, if_p);\n+      return;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "51fd0cf8ba9215a097884989369bad292e5f1750", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -1834,6 +1834,10 @@ struct GTY(()) omp_declare_target_attr {\n   bool attr_syntax;\n };\n \n+struct GTY(()) omp_begin_assumes_data {\n+  bool attr_syntax;\n+};\n+\n /* Global state.  */\n \n struct GTY(()) saved_scope {\n@@ -1881,6 +1885,7 @@ struct GTY(()) saved_scope {\n \n   hash_map<tree, tree> *GTY((skip)) x_local_specializations;\n   vec<omp_declare_target_attr, va_gc> *omp_declare_target_attribute;\n+  vec<omp_begin_assumes_data, va_gc> *omp_begin_assumes;\n \n   struct saved_scope *prev;\n };"}, {"sha": "4bd3ca1ac198e43da2061399c5ada1ee893f55eb", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 315, "deletions": 25, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-name-hint.h\"\n #include \"memmodel.h\"\n #include \"c-family/known-headers.h\"\n+#include \"bitmap.h\"\n \n \f\n /* The lexer.  */\n@@ -46061,6 +46062,218 @@ cp_parser_omp_context_selector_specification (cp_parser *parser,\n   return nreverse (ret);\n }\n \n+/* Assumption clauses:\n+   OpenMP 5.1\n+   absent (directive-name-list)\n+   contains (directive-name-list)\n+   holds (expression)\n+   no_openmp\n+   no_openmp_routines\n+   no_parallelism  */\n+\n+static void\n+cp_parser_omp_assumption_clauses (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\t\t  bool is_assume)\n+{\n+  bool first = true;\n+  bool no_openmp = false;\n+  bool no_openmp_routines = false;\n+  bool no_parallelism = false;\n+  bitmap_head absent_head, contains_head;\n+\n+  bitmap_obstack_initialize (NULL);\n+  bitmap_initialize (&absent_head, &bitmap_default_obstack);\n+  bitmap_initialize (&contains_head, &bitmap_default_obstack);\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA_EOL))\n+    error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t      \"expected at least one assumption clause\");\n+\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n+    {\n+      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+      if ((!first || parser->lexer->in_omp_attribute_pragma)\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      first = false;\n+\n+      if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\tbreak;\n+\n+      const char *p\n+\t= IDENTIFIER_POINTER (cp_lexer_peek_token (parser->lexer)->u.value);\n+      location_t cloc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+      if (!strcmp (p, \"no_openmp\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (no_openmp)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp\");\n+\t  no_openmp = true;\n+\t}\n+      else if (!strcmp (p, \"no_openmp_routines\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (no_openmp_routines)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp_routines\");\n+\t  no_openmp_routines = true;\n+\t}\n+      else if (!strcmp (p, \"no_parallelism\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (no_parallelism)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_parallelism\");\n+\t  no_parallelism = true;\n+\t}\n+      else if (!strcmp (p, \"holds\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      tree t = cp_parser_assignment_expression (parser);\n+\t      if (!type_dependent_expression_p (t))\n+\t\tt = contextual_conv_bool (t, tf_warning_or_error);\n+\t      if (is_assume)\n+\t\t{\n+\t\t  /* FIXME: Emit .ASSUME (t) call here.  */\n+\t\t  (void) t;\n+\t\t}\n+\t      if (!parens.require_close (parser))\n+\t\tcp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t       /*recovering=*/true,\n+\t\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t\t       /*consume_paren=*/true);\n+\t    }\n+\t}\n+      else if (!strcmp (p, \"absent\") || !strcmp (p, \"contains\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  const char *directive[3] = {};\n+\t\t  int i;\n+\t\t  location_t dloc\n+\t\t    = cp_lexer_peek_token (parser->lexer)->location;\n+\t\t  for (i = 0; i < 3; i++)\n+\t\t    {\n+\t\t      tree id;\n+\t\t      if (cp_lexer_nth_token_is (parser->lexer, i + 1, CPP_NAME))\n+\t\t\tid = cp_lexer_peek_nth_token (parser->lexer,\n+\t\t\t\t\t\t      i + 1)->u.value;\n+\t\t      else if (cp_lexer_nth_token_is (parser->lexer, i + 1,\n+\t\t\t\t\t\t      CPP_KEYWORD))\n+\t\t\t{\n+\t\t\t  enum rid rid\n+\t\t\t    = cp_lexer_peek_nth_token (parser->lexer,\n+\t\t\t\t\t\t       i + 1)->keyword;\n+\t\t\t  id = ridpointers[rid];\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n+\t\t      directive[i] = IDENTIFIER_POINTER (id);\n+\t\t    }\n+\t\t  if (i == 0)\n+\t\t    error_at (dloc, \"expected directive name\");\n+\t\t  else\n+\t\t    {\n+\t\t      const struct c_omp_directive *dir\n+\t\t\t= c_omp_categorize_directive (directive[0],\n+\t\t\t\t\t\t      directive[1],\n+\t\t\t\t\t\t      directive[2]);\n+\t\t      if (dir == NULL\n+\t\t\t  || dir->kind == C_OMP_DIR_DECLARATIVE\n+\t\t\t  || dir->kind == C_OMP_DIR_INFORMATIONAL\n+\t\t\t  || dir->id == PRAGMA_OMP_END\n+\t\t\t  || (!dir->second && directive[1])\n+\t\t\t  || (!dir->third && directive[2]))\n+\t\t\terror_at (dloc, \"unknown OpenMP directive name in \"\n+\t\t\t\t\t\"%qs clause argument\", p);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  int id = dir - c_omp_directives;\n+\t\t\t  if (bitmap_bit_p (p[0] == 'a' ? &contains_head\n+\t\t\t\t\t\t\t: &absent_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned in both %<absent%> and \"\n+\t\t\t\t\t    \"%<contains%> clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\");\n+\t\t\t  else if (!bitmap_set_bit (p[0] == 'a'\n+\t\t\t\t\t\t    ? &absent_head\n+\t\t\t\t\t\t    : &contains_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned multiple times in %qs \"\n+\t\t\t\t\t    \"clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\", p);\n+\t\t\t}\n+\t\t      for (; i; --i)\n+\t\t\tcp_lexer_consume_token (parser->lexer);\n+\t\t    }\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      if (!parens.require_close (parser))\n+\t\tcp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t       /*recovering=*/true,\n+\t\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t\t       /*consume_paren=*/true);\n+\t    }\n+\t}\n+      else if (startswith (p, \"ext_\"))\n+\t{\n+\t  warning_at (cloc, 0, \"unknown assumption clause %qs\", p);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+\t    for (size_t n = cp_parser_skip_balanced_tokens (parser, 1) - 1;\n+\t\t n; --n)\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t}\n+      else\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  error_at (cloc, \"expected assumption clause\");\n+\t  break;\n+\t}\n+    }\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+}\n+\n+/* OpenMP 5.1\n+   # pragma omp assume clauses[optseq] new-line  */\n+\n+static void\n+cp_parser_omp_assume (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n+{\n+  cp_parser_omp_assumption_clauses (parser, pragma_tok, true);\n+  add_stmt (cp_parser_omp_structured_block (parser, if_p));\n+}\n+\n+/* OpenMP 5.1\n+   # pragma omp assumes clauses[optseq] new-line  */\n+\n+static bool\n+cp_parser_omp_assumes (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_omp_assumption_clauses (parser, pragma_tok, false);\n+  return false;\n+}\n+\n /* Finalize #pragma omp declare variant after a fndecl has been parsed, and put\n    that into \"omp declare variant base\" attribute.  */\n \n@@ -46510,8 +46723,41 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n \t\t\"directive with only %<device_type%> clauses ignored\");\n }\n \n+/* OpenMP 5.1\n+   #pragma omp begin assumes clauses[optseq] new-line  */\n+\n+static void\n+cp_parser_omp_begin (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  const char *p = \"\";\n+  bool in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      p = IDENTIFIER_POINTER (id);\n+    }\n+  if (strcmp (p, \"assumes\") == 0)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_omp_assumption_clauses (parser, pragma_tok, false);\n+      struct omp_begin_assumes_data a = { in_omp_attribute_pragma };\n+      vec_safe_push (scope_chain->omp_begin_assumes, a);\n+    }\n+  else\n+    {\n+      cp_parser_error (parser, \"expected %<assumes%>\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+    }\n+}\n+\n+/* OpenMP 4.0:\n+   # pragma omp end declare target new-line\n+\n+   OpenMP 5.1:\n+   # pragma omp end assumes new-line  */\n+\n static void\n-cp_parser_omp_end_declare_target (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_end (cp_parser *parser, cp_token *pragma_tok)\n {\n   const char *p = \"\";\n   bool in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n@@ -46537,33 +46783,58 @@ cp_parser_omp_end_declare_target (cp_parser *parser, cp_token *pragma_tok)\n \t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n \t  return;\n \t}\n+      cp_parser_require_pragma_eol (parser, pragma_tok);\n+      if (!vec_safe_length (scope_chain->omp_declare_target_attribute))\n+\terror_at (pragma_tok->location,\n+\t\t  \"%<#pragma omp end declare target%> without corresponding \"\n+\t\t  \"%<#pragma omp declare target%>\");\n+      else\n+\t{\n+\t  omp_declare_target_attr\n+\t    a = scope_chain->omp_declare_target_attribute->pop ();\n+\t  if (a.attr_syntax != in_omp_attribute_pragma)\n+\t    {\n+\t      if (a.attr_syntax)\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<declare target%> in attribute syntax terminated \"\n+\t\t\t  \"with %<end declare target%> in pragma syntax\");\n+\t      else\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<declare target%> in pragma syntax terminated \"\n+\t\t\t  \"with %<end declare target%> in attribute syntax\");\n+\t    }\n+\t}\n     }\n-  else\n+  else if (strcmp (p, \"assumes\") == 0)\n     {\n-      cp_parser_error (parser, \"expected %<declare%>\");\n-      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return;\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_require_pragma_eol (parser, pragma_tok);\n+      if (!vec_safe_length (scope_chain->omp_begin_assumes))\n+\terror_at (pragma_tok->location,\n+\t\t  \"%<#pragma omp end assumes%> without corresponding \"\n+\t\t  \"%<#pragma omp begin assumes%>\");\n+      else\n+\t{\n+\t  omp_begin_assumes_data\n+\t    a = scope_chain->omp_begin_assumes->pop ();\n+\t  if (a.attr_syntax != in_omp_attribute_pragma)\n+\t    {\n+\t      if (a.attr_syntax)\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<begin assumes%> in attribute syntax terminated \"\n+\t\t\t  \"with %<end assumes%> in pragma syntax\");\n+\t      else\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<begin assumes%> in pragma syntax terminated \"\n+\t\t\t  \"with %<end assumes%> in attribute syntax\");\n+\t    }\n+\t}\n     }\n-  cp_parser_require_pragma_eol (parser, pragma_tok);\n-  if (!vec_safe_length (scope_chain->omp_declare_target_attribute))\n-    error_at (pragma_tok->location,\n-\t      \"%<#pragma omp end declare target%> without corresponding \"\n-\t      \"%<#pragma omp declare target%>\");\n   else\n     {\n-      omp_declare_target_attr\n-\ta = scope_chain->omp_declare_target_attribute->pop ();\n-      if (a.attr_syntax != in_omp_attribute_pragma)\n-\t{\n-\t  if (a.attr_syntax)\n-\t    error_at (pragma_tok->location,\n-\t\t      \"%<declare target%> in attribute syntax terminated \"\n-\t\t      \"with %<end declare target%> in pragma syntax\");\n-\t  else\n-\t    error_at (pragma_tok->location,\n-\t\t      \"%<declare target%> in pragma syntax terminated \"\n-\t\t      \"with %<end declare target%> in attribute syntax\");\n-\t}\n+      cp_parser_error (parser, \"expected %<declare%> or %<assumes%>\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return;\n     }\n }\n \n@@ -47846,6 +48117,9 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n       stmt = cp_parser_omp_teams (parser, pragma_tok, p_name, mask, NULL,\n \t\t\t\t  if_p);\n       break;\n+    case PRAGMA_OMP_ASSUME:\n+      cp_parser_omp_assume (parser, pragma_tok, if_p);\n+      return;\n     default:\n       gcc_unreachable ();\n     }\n@@ -48449,6 +48723,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n     case PRAGMA_OACC_LOOP:\n     case PRAGMA_OACC_PARALLEL:\n     case PRAGMA_OACC_SERIAL:\n+    case PRAGMA_OMP_ASSUME:\n     case PRAGMA_OMP_ATOMIC:\n     case PRAGMA_OMP_CRITICAL:\n     case PRAGMA_OMP_DISTRIBUTE:\n@@ -48483,6 +48758,17 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t}\n       return cp_parser_omp_requires (parser, pragma_tok);\n \n+    case PRAGMA_OMP_ASSUMES:\n+      if (context != pragma_external)\n+\t{\n+\t  error_at (pragma_tok->location,\n+\t\t    \"%<#pragma omp assumes%> may only be used at file or \"\n+\t\t    \"namespace scope\");\n+\t  ret = true;\n+\t  break;\n+\t}\n+      return cp_parser_omp_assumes (parser, pragma_tok);\n+\n     case PRAGMA_OMP_NOTHING:\n       cp_parser_omp_nothing (parser, pragma_tok);\n       return false;\n@@ -48506,8 +48792,12 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n       pop_omp_privatization_clauses (stmt);\n       return ret;\n \n-    case PRAGMA_OMP_END_DECLARE_TARGET:\n-      cp_parser_omp_end_declare_target (parser, pragma_tok);\n+    case PRAGMA_OMP_BEGIN:\n+      cp_parser_omp_begin (parser, pragma_tok);\n+      return false;\n+\n+    case PRAGMA_OMP_END:\n+      cp_parser_omp_end (parser, pragma_tok);\n       return false;\n \n     case PRAGMA_OMP_SCAN:"}, {"sha": "1c1e5735743b23406e86e8526a2d82944b2cb3b8", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -11945,6 +11945,7 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n   auto o3 = make_temp_override (current_target_pragma, NULL_TREE);\n   auto o4 = make_temp_override (scope_chain->omp_declare_target_attribute,\n \t\t\t\tNULL);\n+  auto o5 = make_temp_override (scope_chain->omp_begin_assumes, NULL);\n \n   cplus_decl_attributes (decl_p, late_attrs, attr_flags);\n "}, {"sha": "e8cd50558d6fcb3a3bb37dd950697056947c9398", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -3363,6 +3363,13 @@ finish_translation_unit (void)\n \t       \"%<#pragma omp end declare target%>\");\n       vec_safe_truncate (scope_chain->omp_declare_target_attribute, 0);\n     }\n+  if (vec_safe_length (scope_chain->omp_begin_assumes))\n+    {\n+      if (!errorcount)\n+\terror (\"%<#pragma omp begin assumes%> without corresponding \"\n+\t       \"%<#pragma omp end assumes%>\");\n+      vec_safe_truncate (scope_chain->omp_begin_assumes, 0);\n+    }\n }\n \n /* Finish a template type parameter, specified as AGGR IDENTIFIER."}, {"sha": "05c64a803da286d9a6de2bab152dc7e341678de4", "filename": "gcc/testsuite/c-c++-common/gomp/assume-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-1.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,29 @@\n+void\n+foo (int i, int *a)\n+{\n+  #pragma omp assume no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U)\n+  ;\n+  #pragma omp assume no_openmp_routines, contains (simd)\n+  {\n+    #pragma omp simd\n+    for (int j = 0; j < i; j++)\n+      a[j] = j;\n+  }\n+  #pragma omp assume no_parallelism, contains (error)\n+  {\n+    if (i >= 32)\n+      {\n+\t#pragma omp error at (execution) message (\"Should not happen\")\n+      }\n+  }\n+  #pragma omp assume absent (for)\n+  ;\n+  #pragma omp assume absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj)\n+  ;\n+  #pragma omp assume absent (distribute, flush, loop, masked, master, nothing, ordered)\n+  ;\n+  #pragma omp assume absent (parallel, scan, scope, section, sections, simd, single, task)\n+  ;\n+  #pragma omp assume absent (taskgroup, taskloop, taskwait, taskyield)\n+  ;\n+}"}, {"sha": "47396055aef1df84e75397a595d023a734958b63", "filename": "gcc/testsuite/c-c++-common/gomp/assume-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-2.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,46 @@\n+void\n+foo (int i, int *a)\n+{\n+  #pragma omp assume no_openmp no_openmp\t\t\t/* { dg-error \"too many 'no_openmp' clauses\" } */\n+  ;\n+  #pragma omp assume no_openmp_routines, no_openmp_routines\t/* { dg-error \"too many 'no_openmp_routines' clauses\" } */\n+  ;\n+  #pragma omp assume no_parallelism, no_parallelism\t\t/* { dg-error \"too many 'no_parallelism' clauses\" } */\n+  ;\n+  #pragma omp assume absent (target, target)\t\t\t/* { dg-error \"'target' directive mentioned multiple times in 'absent' clauses\" } */\n+  ;\n+  #pragma omp assume absent (target, teams) absent (teams, parallel)\t/* { dg-error \"'teams' directive mentioned multiple times in 'absent' clauses\" } */\n+  ;\n+  #pragma omp assume contains (cancellation point, cancellation point)\t/* { dg-error \"'cancellation point' directive mentioned multiple times in 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume contains (target enter data, target exit data) contains (target exit data, parallel)\t/* { dg-error \"target exit data' directive mentioned multiple times in 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume absent (target enter data, target exit data) contains (target exit data, parallel)\t\t/* { dg-error \"'target exit data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume contains (target enter data, target exit data) absent (target enter data, parallel)\t/* { dg-error \"'target enter data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume contains (declare target)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (parallel for simd)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (target parallel)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (assume)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (assumes)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (begin assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (end assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (foo)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (target enter something)\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume foobar\t\t\t\t\t/* { dg-error \"expected assumption clause\" } */\n+  ;\n+  #pragma omp assume ext_GCC_foobarbaz, ext_GCC_baz (1, 12, 1 < 17), no_parallelism\t/* { dg-warning \"unknown assumption clause 'ext_GCC_foobarbaz'\" } */\n+  ;\t\t\t\t\t\t\t\t/* { dg-warning \"unknown assumption clause 'ext_GCC_baz'\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp assume\t\t\t\t\t\t/* { dg-error \"expected at least one assumption clause\" } */\n+  ;\n+}"}, {"sha": "ce38359552da19ff57b248b823009fb5fea339ae", "filename": "gcc/testsuite/c-c++-common/gomp/assume-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-3.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-openmp -fopenmp-simd\" } */\n+\n+int i, j;\n+\n+int\n+foo (void)\n+{\n+  j = 1;\n+  return 1;\n+}\n+\n+int\n+main ()\n+{\n+  #pragma omp assume holds (i < 42)\n+  ;\n+  #pragma omp assume holds (++i == 1)\n+  ;\n+  if (i != 0)\n+    __builtin_abort ();\n+  #pragma omp assume holds (foo () == 1)\n+  ;\n+  if (j != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "8b3fb378bfbfd6589c1edf7c63713f592bf86de7", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-1.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,26 @@\n+int i;\n+\n+#pragma omp assumes no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U)\n+void\n+bar (void)\n+{\n+}\n+\n+#pragma omp assumes no_openmp_routines\n+\n+#pragma omp assumes no_parallelism\n+\n+#pragma omp assumes absent (for)\n+void\n+fred (void)\n+{\n+}\n+\n+#pragma omp assumes absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj) \\\n+\t\t    absent (distribute, flush, loop, masked, master, nothing, ordered) \\\n+\t\t    absent (parallel, scan, scope, section, sections, simd, single, task) \\\n+\t\t    absent (taskgroup, taskloop, taskwait, taskyield)\n+void\n+foo (void)\n+{\n+}"}, {"sha": "924f323d68f702d5ceb2227a751906c8ed28efc3", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-2.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,23 @@\n+#pragma omp assumes no_openmp no_openmp\t\t\t\t/* { dg-error \"too many 'no_openmp' clauses\" } */\n+#pragma omp assumes no_openmp_routines, no_openmp_routines\t/* { dg-error \"too many 'no_openmp_routines' clauses\" } */\n+#pragma omp assumes no_parallelism, no_parallelism\t\t/* { dg-error \"too many 'no_parallelism' clauses\" } */\n+#pragma omp assumes absent (target, target)\t\t\t/* { dg-error \"'target' directive mentioned multiple times in 'absent' clauses\" } */\n+#pragma omp assumes absent (target, teams) absent (teams, parallel)\t/* { dg-error \"'teams' directive mentioned multiple times in 'absent' clauses\" } */\n+#pragma omp assumes contains (cancellation point, cancellation point)\t/* { dg-error \"'cancellation point' directive mentioned multiple times in 'contains' clauses\" } */\n+#pragma omp assumes contains (target enter data, target exit data) contains (target exit data, parallel)\t/* { dg-error \"target exit data' directive mentioned multiple times in 'contains' clauses\" } */\n+#pragma omp assumes absent (target enter data, target exit data) contains (target exit data, parallel)\t\t/* { dg-error \"'target exit data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+#pragma omp assumes contains (target enter data, target exit data) absent (target enter data, parallel)\t/* { dg-error \"'target enter data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+#pragma omp assumes contains (declare target)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes absent (parallel for simd)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes contains (target parallel)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes absent (assume)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes absent (assumes)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes contains (begin assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes contains (end assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes contains (foo)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes absent (target enter something)\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes foobar\t\t\t\t\t/* { dg-error \"expected assumption clause\" } */\n+#pragma omp assumes ext_GCC_foobarbaz, ext_GCC_baz (1, 12, 1 < 17), no_parallelism\t/* { dg-warning \"unknown assumption clause 'ext_GCC_foobarbaz'\" } */\n+\t\t\t\t\t\t\t\t/* { dg-warning \"unknown assumption clause 'ext_GCC_baz'\" \"\" { target *-*-* } .-1 } */\n+#pragma omp assumes\t\t\t\t\t\t/* { dg-error \"expected at least one assumption clause\" } */\n+int i;"}, {"sha": "0bfadace4b39bab2e630386c6be98bae5a7c677a", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-3.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,15 @@\n+#pragma omp assumes contains (simd)\n+#pragma omp assumes contains (error)\n+#pragma omp assumes contains (simd)\n+\n+void\n+foo (int i, int *a)\n+{\n+  #pragma omp simd\n+  for (int j = 0; j < i; j++)\n+    a[j] = j;\n+  if (i >= 32)\n+    {\n+      #pragma omp error at (execution) message (\"Should not happen\")\n+    }\n+}"}, {"sha": "6e77adb2fe86d1c821a6fb7fad1e099276ade0cb", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-4.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-4.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,6 @@\n+void\n+foo (void)\n+{\n+  #pragma omp assumes no_openmp\t\t/* { dg-error \"'#pragma omp assumes' may only be used at file scope\" \"\" { target c } } */\n+  ;\t\t\t\t\t/* { dg-error \"'#pragma omp assumes' may only be used at file or namespace scope\" \"\" { target c++ } .-1 } */\n+}"}, {"sha": "c3332b12755e24115ecd9c7d5e30b6ee4b2fa9c5", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-1.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,46 @@\n+int i;\n+\n+#pragma omp begin assumes no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U)\n+void\n+bar (void)\n+{\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes no_openmp_routines, contains (simd)\n+void\n+baz (int *a)\n+{\n+  #pragma omp simd\n+  for (int j = 0; j < i; j++)\n+    a[j] = j;\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes no_parallelism, contains (error)\n+void\n+qux (void)\n+{\n+  if (i >= 32)\n+    {\n+      #pragma omp error at (execution) message (\"Should not happen\")\n+    }\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes absent (for)\n+void\n+fred (void)\n+{\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj) \\\n+\t\t\t  absent (distribute, flush, loop, masked, master, nothing, ordered) \\\n+\t\t\t  absent (parallel, scan, scope, section, sections, simd, single, task) \\\n+\t\t\t  absent (taskgroup, taskloop, taskwait, taskyield)\n+void\n+foo (void)\n+{\n+}\n+#pragma omp end assumes"}, {"sha": "15dae6419338bdefdda5ddf134f2628c833ed70f", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-2.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-2.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,63 @@\n+#pragma omp begin assumes no_openmp no_openmp\t\t\t/* { dg-error \"too many 'no_openmp' clauses\" } */\n+void f1 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes no_openmp_routines, no_openmp_routines\t/* { dg-error \"too many 'no_openmp_routines' clauses\" } */\n+void f2 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes no_parallelism, no_parallelism\t\t/* { dg-error \"too many 'no_parallelism' clauses\" } */\n+void f3 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target, target)\t\t\t/* { dg-error \"'target' directive mentioned multiple times in 'absent' clauses\" } */\n+void f4 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target, teams) absent (teams, parallel)\t/* { dg-error \"'teams' directive mentioned multiple times in 'absent' clauses\" } */\n+void f5 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (cancellation point, cancellation point)\t/* { dg-error \"'cancellation point' directive mentioned multiple times in 'contains' clauses\" } */\n+void f6 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (target enter data, target exit data) contains (target exit data, parallel)\t/* { dg-error \"target exit data' directive mentioned multiple times in 'contains' clauses\" } */\n+void f7 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target enter data, target exit data) contains (target exit data, parallel)\t\t/* { dg-error \"'target exit data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+void f8 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (target enter data, target exit data) absent (target enter data, parallel)\t/* { dg-error \"'target enter data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+void f9 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (declare target)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f10 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (parallel for simd)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f11 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (target parallel)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f12 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (assume)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f13 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (assumes)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f14 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (begin assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f15 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (end assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f16 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (foo)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f17 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target enter something)\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f18 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes foobar\t\t\t\t\t/* { dg-error \"expected assumption clause\" } */\n+void f19 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes ext_GCC_foobarbaz, ext_GCC_baz (1, 12, 1 < 17), no_parallelism\t/* { dg-warning \"unknown assumption clause 'ext_GCC_foobarbaz'\" } */\n+void f20 (void) {}\t\t\t\t\t\t\t\t/* { dg-warning \"unknown assumption clause 'ext_GCC_baz'\" \"\" { target *-*-* } .-1 } */\n+#pragma omp end assumes\n+#pragma omp begin assumes\t\t\t\t\t\t/* { dg-error \"expected at least one assumption clause\" } */\n+void f21 (void) {}\n+#pragma omp end assumes"}, {"sha": "202d5c7741b5e3eca95c972643c8a58a47f038ca", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-3.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-3.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,2 @@\n+#pragma omp begin assumes no_openmp_routines\n+void foo (void);\t/* { dg-error \"'#pragma omp begin assumes' without corresponding '#pragma omp end assumes'\" } */"}, {"sha": "eea6f908d051ac3b0ffacbe219643818e3058100", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-4.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-4.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,2 @@\n+#pragma omp end assumes\t/* { dg-error \"'#pragma omp end assumes' without corresponding '#pragma omp begin assumes'\" } */\n+void foo (void);"}, {"sha": "586eb50f8016f1cf810ba21d2508f2988b19876f", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-6.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,2 @@\n+#pragma omp end declare target\t/* { dg-error \"'#pragma omp end declare target' without corresponding '#pragma omp declare target'\" } */\n+void foo (void);"}, {"sha": "dd33b07361483e8f0bd702df125c61e3a3d1c1d1", "filename": "gcc/testsuite/g++.dg/gomp/attrs-1.C", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -123,7 +123,7 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n void\n bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n      int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm,\n-     const char *msg)\n+     const char *msg, int n1, int n2)\n {\n   [[omp::directive (nothing)]];\n   [[omp::directive (error at (execution) severity (warning) message (msg))]];\n@@ -612,6 +612,19 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n     ;\n   [[omp::directive (parallel)]]\n   switch (0) { case 1: break; default: break; }\n+  [[omp::directive (assume no_openmp no_openmp_routines no_parallelism\n+\t\t\t   absent (atomic, barrier, cancel, cancellation point)\n+\t\t\t   absent (critical, depobj)\n+\t\t\t   absent (distribute, flush, loop, masked, master, nothing, ordered)\n+\t\t\t   absent (parallel, scan, scope, section, sections, simd, single, task)\n+\t\t\t   absent (taskgroup, taskloop, taskwait, taskyield)\n+\t\t\t   absent (target, teams, for, error) holds (n1 < n2))]]\n+  if (0)\n+    ;\n+  [[omp::sequence (omp::directive (assume contains (simd)),\n+\t\t   omp::directive (for simd))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n }\n \n void corge1 ();"}, {"sha": "d0598f47dff3d1604dde296e29f6861ae07432d7", "filename": "gcc/testsuite/g++.dg/gomp/attrs-15.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-15.C?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile { target c++11 } }\n+\n+#pragma omp begin assumes absent (target)\n+#pragma omp begin assumes absent (target)\n+[[omp::directive (begin assumes absent (target))]];\n+int a;\n+[[omp::directive (end assumes)]];\n+#pragma omp end assumes\n+#pragma omp end assumes\n+[[omp::directive (begin assumes absent (target))]];\n+int b;\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+int c;\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }\n+#pragma omp begin assumes absent (target)\n+[[omp::directive (begin assumes absent (target))]];\n+int d;\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+int e;\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }\n+#pragma omp end assumes\n+[[omp::directive (begin assumes absent (target))]];\n+[[omp::directive (begin assumes absent (target))]];\n+int f;\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+int g;\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }\n+[[omp::directive (end assumes)]];\n+[[omp::directive (begin assumes absent (target))]];\n+#pragma omp begin assumes absent (target)\n+int h;\n+#pragma omp end assumes\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+[[omp::directive (begin assumes absent (target))]];\n+int i;\n+[[omp::directive (end assumes)]];\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }"}, {"sha": "5c1dcc587c56f4ac64df858b34cf4f94f199c2f8", "filename": "gcc/testsuite/g++.dg/gomp/attrs-16.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-16.C?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++11 } }\n+\n+int i;\n+\n+[[omp::directive (assumes no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U))]];\n+void\n+bar (void)\n+{\n+}\n+\n+[[omp::directive (assumes no_openmp_routines)]];\n+[[omp::directive (assumes no_parallelism)]];\n+[[omp::directive (assumes absent (for))]];\n+void\n+fred (void)\n+{\n+}\n+\n+[[omp::directive (assumes absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj)\n+\t\t    absent (distribute, flush, loop, masked, master, nothing, ordered)\n+\t\t    absent (parallel, scan, scope, section, sections, simd, single, task)\n+\t\t    absent (taskgroup, taskloop, taskwait, taskyield))]];\n+void\n+foo (void)\n+{\n+}"}, {"sha": "fe36146792431e38cb0feeb9818fd6c971047b74", "filename": "gcc/testsuite/g++.dg/gomp/attrs-17.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-17.C?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+\n+[[omp::directive (assumes contains (simd))]];\n+[[omp::directive (assumes contains (error))]];\n+[[omp::directive (assumes, contains (simd))]];\n+\n+void\n+foo (int i, int *a)\n+{\n+  [[omp::directive (simd)]]\n+  for (int j = 0; j < i; j++)\n+    a[j] = j;\n+  if (i >= 32)\n+    {\n+      [[omp::directive (error at (execution) message (\"Should not happen\"))]];\n+    }\n+}"}, {"sha": "7258d38c5a35a2244031d87f70ec351f80d27d9d", "filename": "gcc/testsuite/g++.dg/gomp/attrs-2.C", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -123,7 +123,7 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n void\n bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n      int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm,\n-     const char *msg)\n+     const char *msg, int n1, int n2)\n {\n   [[omp::directive (nothing)]];\n   [[omp::directive (error, at (execution), severity (warning), message (msg))]];\n@@ -604,6 +604,19 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n   extern int t2;\n   [[omp::directive (declare reduction (dr: int: omp_out += omp_in),initializer (omp_priv = 0))]]\n   ;\n+  [[omp::directive (assume, no_openmp, no_openmp_routines, no_parallelism,\n+\t\t\t    absent (atomic, barrier, cancel, cancellation point),\n+\t\t\t    absent (critical, depobj),\n+\t\t\t    absent (distribute, flush, loop, masked, master, nothing, ordered),\n+\t\t\t    absent (parallel, scan, scope, section, sections, simd, single, task),\n+\t\t\t    absent (taskgroup, taskloop, taskwait, taskyield),\n+\t\t\t    absent (target, teams, for, error), holds (n1 < n2))]]\n+  if (0)\n+    ;\n+  [[omp::sequence (omp::directive (assume, contains (simd)),\n+\t\t   omp::directive (for simd))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n }\n \n void corge1 ();"}, {"sha": "fa02299bcafd902bc7927a8b4eff1b0bf47ad8fc", "filename": "gcc/testsuite/g++.dg/gomp/attrs-9.C", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4790fe99f236c7f1b617722403e682ba2f82485f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C?ref=4790fe99f236c7f1b617722403e682ba2f82485f", "patch": "@@ -1,5 +1,6 @@\n // { dg-do compile { target c++11 } }\n \n+int n1 = 0, n2 = 42;\n [[omp::sequence (directive (requires, atomic_default_mem_order (seq_cst)))]];\n [[omp::directive (declare reduction (plus: int: omp_out += omp_in) initializer (omp_priv = 0))]];\n int a;\n@@ -14,3 +15,22 @@ int d;\n [[omp::directive (end declare target)]];\n [[omp::directive (end declare target)]];\n [[omp::directive (nothing)]];\n+[[omp::directive (begin assumes no_openmp no_openmp_routines no_parallelism\n+\t\t\t\tabsent (atomic, barrier, cancel, cancellation point)\n+\t\t\t\tabsent (critical, depobj)\n+\t\t\t\tabsent (distribute, flush, loop, masked, master, nothing, ordered)\n+\t\t\t\tabsent (parallel, scan, scope, section, sections, simd, single, task)\n+\t\t\t\tabsent (taskgroup, taskloop, taskwait, taskyield)\n+\t\t\t\tabsent (target, teams, for, error) holds (n1 < n2))]];\n+void foo (void) {}\n+[[omp::directive (end assumes)]];\n+[[omp::directive (begin assumes, no_openmp, no_openmp_routines, no_parallelism,\n+\t\t\t\t absent (atomic, barrier, cancel, cancellation point),\n+\t\t\t\t absent (critical, depobj),\n+\t\t\t\t absent (distribute, flush, loop, masked, master, nothing, ordered),\n+\t\t\t\t absent (parallel, scan, scope, section, sections, simd, single, task),\n+\t\t\t\t absent (taskgroup, taskloop, taskwait, taskyield),\n+\t\t\t\t absent (target, teams, for, error), holds (n1 < n2))]];\n+[[omp::directive (begin assumes no_openmp)]];\n+void bar (void) {}\n+[[omp::sequence (omp::directive (end assumes), omp::directive (end assumes))]];"}]}