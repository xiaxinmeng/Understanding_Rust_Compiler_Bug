{"sha": "be0cc7e21cee56062492d6e11014b827ab39c342", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUwY2M3ZTIxY2VlNTYwNjI0OTJkNmUxMTAxNGI4MjdhYjM5YzM0Mg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-07-14T06:21:59Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-07-14T06:21:59Z"}, "message": "[multiple changes]\n\n2005-07-12 Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR libfortran/16435\n\t* transfer.c (formatted_transfer): Correct the problems\n\twith X- and T-editting that caused TLs followed by TRs\n\tto overwrite data, which caused NIST FM908.FOR to fail\n\ton many tests.\n\t(data_transfer_init): Zero X- and T-editting counters at\n\tthe start of formatted IO.\n\t* write.c (write_x): Write specified number of skips with\n\tspecified number of spaces at the end.\n\n2005-07-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR libfortran/16435\n\t* gfortran.dg/tl_editting.f90: New.\n\t* gfortran.dg/g77/f77-edit-x-out.f: Remove XFAIL.\n\nFrom-SVN: r102008", "tree": {"sha": "3a6abdf272c0e410094c15917247aec5ab5c7909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a6abdf272c0e410094c15917247aec5ab5c7909"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be0cc7e21cee56062492d6e11014b827ab39c342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be0cc7e21cee56062492d6e11014b827ab39c342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be0cc7e21cee56062492d6e11014b827ab39c342", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be0cc7e21cee56062492d6e11014b827ab39c342/comments", "author": null, "committer": null, "parents": [{"sha": "93e261acea9db4975e505d7cbdf42572d3c8557d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e261acea9db4975e505d7cbdf42572d3c8557d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93e261acea9db4975e505d7cbdf42572d3c8557d"}], "stats": {"total": 313, "additions": 195, "deletions": 118}, "files": [{"sha": "b3585c7d75ba695bfb21c6a15f89cb69c4319068", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0cc7e21cee56062492d6e11014b827ab39c342/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0cc7e21cee56062492d6e11014b827ab39c342/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be0cc7e21cee56062492d6e11014b827ab39c342", "patch": "@@ -1,3 +1,9 @@\n+2005-07-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR libfortran/16435\n+\t* gfortran.dg/tl_editting.f90: New.\n+\t* gfortran.dg/g77/f77-edit-x-out.f: Remove XFAIL.\n+\n 2005-07-14  Steven G. Kargl  <kargls@comcast.net>\n \n \t* gfortran.dg/char_array_constructor.f90: New test."}, {"sha": "9d196331dd16901abb507b8b634067e6639e1241", "filename": "gcc/testsuite/gfortran.dg/g77/f77-edit-x-out.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0cc7e21cee56062492d6e11014b827ab39c342/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ff77-edit-x-out.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0cc7e21cee56062492d6e11014b827ab39c342/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ff77-edit-x-out.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ff77-edit-x-out.f?ref=be0cc7e21cee56062492d6e11014b827ab39c342", "patch": "@@ -8,5 +8,5 @@\n       write(*,'(I1,1X,I1,2X,I1)') 1,2,3    ! { dg-output \"1 2  3(\\n|\\r\\n|\\r)\" }\n C Section 13.5.3 explains why there are no trailing blanks\n       write(*,'(I1,1X,I1,2X,I1,3X)') 1,2,3 ! { dg-output \"1 2  3(\\n|\\r\\n|\\r)\" }\n-C { dg-output \"\\$\" {xfail *-*-*} } gfortran PR 16435\n+C { dg-output \"\\$\" }\n       end"}, {"sha": "3a313cd2b591f1afe158f517b53af5ce39c9ed97", "filename": "gcc/testsuite/gfortran.dg/tl_editing.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0cc7e21cee56062492d6e11014b827ab39c342/gcc%2Ftestsuite%2Fgfortran.dg%2Ftl_editing.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0cc7e21cee56062492d6e11014b827ab39c342/gcc%2Ftestsuite%2Fgfortran.dg%2Ftl_editing.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftl_editing.f90?ref=be0cc7e21cee56062492d6e11014b827ab39c342", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }     \n+! Test of fix to bug triggered by NIST fm908.for.\n+! Left tabbing, followed by X or T-tabbing to the right would\n+! cause spaces to be overwritten on output data.\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+  program tl_editting\n+    character*10           ::  line\n+    character*10           ::  aline = \"abcdefxyij\"\n+    character*2            ::  bline = \"gh\"\n+    character*10           ::  cline = \"abcdefghij\"\n+    write (line, '(a10,tl6,2x,a2)') aline, bline\n+    if (line.ne.cline) call abort ()\n+  end program tl_editting\n\\ No newline at end of file"}, {"sha": "48788f197cb97ebe19dedc1d5c598cf842fc7473", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=be0cc7e21cee56062492d6e11014b827ab39c342", "patch": "@@ -1,3 +1,15 @@\n+2005-07-12 Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR libfortran/16435\n+\t* transfer.c (formatted_transfer): Correct the problems\n+\twith X- and T-editting that caused TLs followed by TRs\n+\tto overwrite data, which caused NIST FM908.FOR to fail\n+\ton many tests.\n+\t(data_transfer_init): Zero X- and T-editting counters at\n+\tthe start of formatted IO.\n+\t* write.c (write_x): Write specified number of skips with\n+\tspecified number of spaces at the end.\n+\n 2005-07-13 Paul Thomas  <pault@gcc.gnu.org>\n \n \t* io/read.c (read_complex): Prevent X formatting during reads"}, {"sha": "37bdb3ebdfac9ef90abaa91a100f5ddaabc83c8d", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=be0cc7e21cee56062492d6e11014b827ab39c342", "patch": "@@ -638,7 +638,7 @@ internal_proto(write_l);\n extern void write_o (fnode *, const char *, int);\n internal_proto(write_o);\n \n-extern void write_x (fnode *);\n+extern void write_x (int, int);\n internal_proto(write_x);\n \n extern void write_z (fnode *, const char *, int);"}, {"sha": "161e5cca40209c6ed16b77447963a1e9d81e2a84", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 158, "deletions": 113, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=be0cc7e21cee56062492d6e11014b827ab39c342", "patch": "@@ -82,6 +82,13 @@ gfc_unit *current_unit = NULL;\n static int sf_seen_eor = 0;\n static int eor_condition = 0;\n \n+/* Maximum righthand column written to.  */\n+static int max_pos;\n+/* Number of skips + spaces to be done for T and X-editing.  */\n+static int skips;\n+/* Number of spaces to be done for T and X-editing.  */\n+static int pending_spaces;\n+\n char scratch[SCRATCH_SIZE];\n static char *line_buffer = NULL;\n \n@@ -166,11 +173,11 @@ read_sf (int *length)\n   do\n     {\n       if (is_internal_unit())\n-        {\n+\t{\n \t  /* readlen may be modified inside salloc_r if\n \t     is_internal_unit() is true.  */\n-          readlen = 1;\n-        }\n+\t  readlen = 1;\n+\t}\n \n       q = salloc_r (current_unit->s, &readlen);\n       if (q == NULL)\n@@ -204,7 +211,7 @@ read_sf (int *length)\n \n \t  current_unit->bytes_left = 0;\n \t  *length = n;\n-          sf_seen_eor = 1;\n+\t  sf_seen_eor = 1;\n \t  break;\n \t}\n \n@@ -437,8 +444,9 @@ require_type (bt expected, bt actual, fnode * f)\n static void\n formatted_transfer (bt type, void *p, int len)\n {\n-  int pos ,m ;\n+  int pos;\n   fnode *f;\n+  format_token t;\n   int n;\n   int consume_data_flag;\n \n@@ -456,22 +464,36 @@ formatted_transfer (bt type, void *p, int len)\n   for (;;)\n     {\n       /* If reversion has occurred and there is another real data item,\n-         then we have to move to the next record.  */\n+\t then we have to move to the next record.  */\n       if (g.reversion_flag && n > 0)\n-        {\n-          g.reversion_flag = 0;\n-          next_record (0);\n-        }\n+\t{\n+\t  g.reversion_flag = 0;\n+\t  next_record (0);\n+\t}\n \n       consume_data_flag = 1 ;\n       if (ioparm.library_return != LIBRARY_OK)\n \tbreak;\n \n       f = next_format ();\n       if (f == NULL)\n-\treturn;\t\t/* No data descriptors left (already raised).  */\n+\treturn;\t      /* No data descriptors left (already raised).  */\n+\n+      /* Now discharge T, TR and X movements to the right.  This is delayed\n+\t until a data producing format to supress trailing spaces.  */\n+      t = f->format;\n+      if (g.mode == WRITING && skips > 0\n+\t&&    (t == FMT_I || t == FMT_B || t == FMT_O || t == FMT_Z\n+\t    || t == FMT_F || t == FMT_E || t == FMT_EN || t == FMT_ES\n+\t    || t == FMT_G || t == FMT_L || t == FMT_A || t == FMT_D\n+\t    || t == FMT_STRING))\n+\t{\n+\t  write_x (skips, pending_spaces);\n+\t  max_pos = current_unit->recl - current_unit->bytes_left;\n+\t  skips = pending_spaces = 0;\n+\t}\n \n-      switch (f->format)\n+      switch (t)\n \t{\n \tcase FMT_I:\n \t  if (n == 0)\n@@ -651,7 +673,7 @@ formatted_transfer (bt type, void *p, int len)\n \t  break;\n \n \tcase FMT_STRING:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  if (g.mode == READING)\n \t    {\n \t      format_error (f, \"Constant string in input format\");\n@@ -660,90 +682,100 @@ formatted_transfer (bt type, void *p, int len)\n \t  write_constant_string (f);\n \t  break;\n \n-\t  /* Format codes that don't transfer data.  */\n+\t/* Format codes that don't transfer data.  */\n \tcase FMT_X:\n \tcase FMT_TR:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n+\n+\t  pos = current_unit->recl - current_unit->bytes_left + f->u.n;\n+\t  skips = f->u.n;\n+\t  pending_spaces = pos - max_pos;\n+\n+\t  /* Writes occur just before the switch on f->format, above, so that\n+\t     trailing blanks are suppressed.  */\n \t  if (g.mode == READING)\n \t    read_x (f);\n-\t  else\n-\t    write_x (f);\n \n \t  break;\n \n-        case FMT_TL:\n-        case FMT_T:\n-           if (f->format == FMT_TL)\n-             pos = current_unit->recl - current_unit->bytes_left - f->u.n;\n-           else /* FMT_T */\n-             {\n-               consume_data_flag = 0;\n-               pos = f->u.n - 1;\n-             }\n-\n-           if (pos < 0 || pos >= current_unit->recl )\n-             {\n-               generate_error (ERROR_EOR, \"T or TL edit position error\");\n-               break ;\n-             }\n-            m = pos - (current_unit->recl - current_unit->bytes_left);\n-\n-            if (m == 0)\n-               break;\n-\n-            if (m > 0)\n-             {\n-               f->u.n = m;\n-               if (g.mode == READING)\n-                 read_x (f);\n-               else\n-                 write_x (f);\n-             }\n-            if (m < 0)\n-             {\n-               move_pos_offset (current_unit->s,m);\n-\t       current_unit->bytes_left -= m;\n-             }\n+\tcase FMT_TL:\n+\tcase FMT_T:\n+\t  if (f->format == FMT_TL)\n+\t    pos = current_unit->recl - current_unit->bytes_left - f->u.n;\n+\t  else /* FMT_T */\n+\t    {\n+\t      consume_data_flag = 0;\n+\t      pos = f->u.n - 1;\n+\t    }\n+\n+\t  /* Standard 10.6.1.1: excessive left tabbing is reset to the\n+\t     left tab limit.  We do not check if the position has gone\n+\t     beyond the end of record because a subsequent tab could\n+\t     bring us back again.  */\n+\t  pos = pos < 0 ? 0 : pos;\n+\n+\t  skips = skips + pos - (current_unit->recl - current_unit->bytes_left);\n+\t  pending_spaces =  pending_spaces + pos - max_pos;\n+\n+\t  if (skips == 0)\n+\t    break;\n+\n+\t  /* Writes occur just before the switch on f->format, above, so that\n+\t     trailing blanks are suppressed.  */\n+\t  if (skips > 0)\n+\t    {\n+\t      if (g.mode == READING)\n+\t\t{\n+\t\t  f->u.n = skips;\n+\t\t  read_x (f);\n+\t\t}\n+\t    }\n+\t  if (skips < 0)\n+\t    {\n+\t      move_pos_offset (current_unit->s, skips);\n+\t      current_unit->bytes_left -= skips;\n+\t      skips = pending_spaces = 0;\n+\t    }\n \n \t  break;\n \n \tcase FMT_S:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  g.sign_status = SIGN_S;\n \t  break;\n \n \tcase FMT_SS:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  g.sign_status = SIGN_SS;\n \t  break;\n \n \tcase FMT_SP:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  g.sign_status = SIGN_SP;\n \t  break;\n \n \tcase FMT_BN:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  g.blank_status = BLANK_NULL;\n \t  break;\n \n \tcase FMT_BZ:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  g.blank_status = BLANK_ZERO;\n \t  break;\n \n \tcase FMT_P:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  g.scale_factor = f->u.k;\n \t  break;\n \n \tcase FMT_DOLLAR:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  g.seen_dollar = 1;\n \t  break;\n \n \tcase FMT_SLASH:\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  next_record (0);\n \t  break;\n \n@@ -752,7 +784,7 @@ formatted_transfer (bt type, void *p, int len)\n \t     particular preventing another / descriptor from being\n \t     processed) unless there is another data item to be\n \t     transferred.  */\n-          consume_data_flag = 0 ;\n+\t  consume_data_flag = 0 ;\n \t  if (n == 0)\n \t    return;\n \t  break;\n@@ -776,8 +808,15 @@ formatted_transfer (bt type, void *p, int len)\n       if ((consume_data_flag > 0) && (n > 0))\n       {\n \tn--;\n-        p = ((char *) p) + len;\n+\tp = ((char *) p) + len;\n       }\n+\n+      if (g.mode == READING)\n+\tskips = 0;\n+\n+      pos = current_unit->recl - current_unit->bytes_left;\n+      max_pos = (max_pos > pos) ? max_pos : pos;\n+\n     }\n \n   return;\n@@ -977,7 +1016,7 @@ data_transfer_init (int read_flag)\n     {\n       current_unit->recl = file_length(current_unit->s);\n       if (g.mode==WRITING)\n-        empty_internal_buffer (current_unit->s);\n+\tempty_internal_buffer (current_unit->s);\n     }\n \n   /* Check the action.  */\n@@ -1007,14 +1046,14 @@ data_transfer_init (int read_flag)\n \n   if (ioparm.namelist_name != NULL && ionml != NULL)\n      {\n-        if(ioparm.format != NULL)\n-           generate_error (ERROR_OPTION_CONFLICT,\n-                    \"A format cannot be specified with a namelist\");\n+\tif(ioparm.format != NULL)\n+\t   generate_error (ERROR_OPTION_CONFLICT,\n+\t\t    \"A format cannot be specified with a namelist\");\n      }\n   else if (current_unit->flags.form == FORM_FORMATTED &&\n-           ioparm.format == NULL && !ioparm.list_format)\n+\t   ioparm.format == NULL && !ioparm.list_format)\n     generate_error (ERROR_OPTION_CONFLICT,\n-                    \"Missing format for FORMATTED data transfer\");\n+\t\t    \"Missing format for FORMATTED data transfer\");\n \n \n   if (is_internal_unit () && current_unit->flags.form == FORM_UNFORMATTED)\n@@ -1108,11 +1147,11 @@ data_transfer_init (int read_flag)\n       /* Check to see if we might be reading what we wrote before  */\n \n       if (g.mode == READING && current_unit->mode  == WRITING)\n-         flush(current_unit->s);\n+\t flush(current_unit->s);\n \n       /* Position the file.  */\n       if (sseek (current_unit->s,\n-               (ioparm.rec - 1) * current_unit->recl) == FAILURE)\n+\t       (ioparm.rec - 1) * current_unit->recl) == FAILURE)\n \tgenerate_error (ERROR_OS, NULL);\n     }\n \n@@ -1121,7 +1160,7 @@ data_transfer_init (int read_flag)\n   if (g.mode == WRITING\n       && current_unit->flags.access == ACCESS_SEQUENTIAL\n       && current_unit->current_record == 0)\n-        struncate(current_unit->s);\n+\tstruncate(current_unit->s);\n \n   current_unit->mode = g.mode;\n \n@@ -1147,10 +1186,10 @@ data_transfer_init (int read_flag)\n       else\n \t{\n \t  if (ioparm.list_format)\n-            {\n-               transfer = list_formatted_read;\n-               init_at_eol();\n-            }\n+\t    {\n+\t       transfer = list_formatted_read;\n+\t       init_at_eol();\n+\t    }\n \t  else\n \t    transfer = formatted_transfer;\n \t}\n@@ -1185,6 +1224,10 @@ data_transfer_init (int read_flag)\n \tcurrent_unit->read_bad = 1;\n     }\n \n+  /* Reset counters for T and X-editing.  */\n+  if (current_unit->flags.form == FORM_FORMATTED)\n+    max_pos = skips = pending_spaces = 0;\n+\n   /* Start the data transfer if we are doing a formatted transfer.  */\n   if (current_unit->flags.form == FORM_FORMATTED && !ioparm.list_format\n       && ioparm.namelist_name == NULL && ionml == NULL)\n@@ -1256,27 +1299,27 @@ next_record_r (void)\n \t}\n \n       do\n-        {\n-          p = salloc_r (current_unit->s, &length);\n-\n-          /* In case of internal file, there may not be any '\\n'.  */\n-          if (is_internal_unit() && p == NULL)\n-            {\n-               break;\n-            }\n-\n-          if (p == NULL)\n-            {\n-              generate_error (ERROR_OS, NULL);\n-              break;\n-            }\n-\n-          if (length == 0)\n-            {\n-              current_unit->endfile = AT_ENDFILE;\n-              break;\n-            }\n-        }\n+\t{\n+\t  p = salloc_r (current_unit->s, &length);\n+\n+\t  /* In case of internal file, there may not be any '\\n'.  */\n+\t  if (is_internal_unit() && p == NULL)\n+\t    {\n+\t       break;\n+\t    }\n+\n+\t  if (p == NULL)\n+\t    {\n+\t      generate_error (ERROR_OS, NULL);\n+\t      break;\n+\t    }\n+\n+\t  if (length == 0)\n+\t    {\n+\t      current_unit->endfile = AT_ENDFILE;\n+\t      break;\n+\t    }\n+\t}\n       while (*p != '\\n');\n \n       break;\n@@ -1315,7 +1358,7 @@ next_record_w (void)\n \n     case UNFORMATTED_DIRECT:\n       if (sfree (current_unit->s) == FAILURE)\n-        goto io_error;\n+\tgoto io_error;\n       break;\n \n     case UNFORMATTED_SEQUENTIAL:\n@@ -1357,12 +1400,12 @@ next_record_w (void)\n       p = salloc_w (current_unit->s, &length);\n \n       if (!is_internal_unit())\n-        {\n-          if (p)\n-            *p = '\\n'; /* No CR for internal writes.  */\n-          else\n-            goto io_error;\n-        }\n+\t{\n+\t  if (p)\n+\t    *p = '\\n'; /* No CR for internal writes.  */\n+\t  else\n+\t    goto io_error;\n+\t}\n \n       if (sfree (current_unit->s) == FAILURE)\n \tgoto io_error;\n@@ -1432,9 +1475,9 @@ finalize_transfer (void)\n   if ((ionml != NULL) && (ioparm.namelist_name != NULL))\n     {\n        if (ioparm.namelist_read_mode)\n-         namelist_read();\n+\t namelist_read();\n        else\n-         namelist_write();\n+\t namelist_write();\n     }\n \n   transfer = NULL;\n@@ -1537,6 +1580,7 @@ export_proto(st_read);\n void\n st_read (void)\n {\n+\n   library_start ();\n \n   data_transfer_init (1);\n@@ -1553,11 +1597,11 @@ st_read (void)\n \tbreak;\n \n       case AT_ENDFILE:\n-        if (!is_internal_unit())\n-          {\n-            generate_error (ERROR_END, NULL);\n-            current_unit->endfile = AFTER_ENDFILE;\n-          }\n+\tif (!is_internal_unit())\n+\t  {\n+\t    generate_error (ERROR_END, NULL);\n+\t    current_unit->endfile = AFTER_ENDFILE;\n+\t  }\n \tbreak;\n \n       case AFTER_ENDFILE:\n@@ -1582,6 +1626,7 @@ export_proto(st_write);\n void\n st_write (void)\n {\n+\n   library_start ();\n   data_transfer_init (0);\n }\n@@ -1608,11 +1653,11 @@ st_write_done (void)\n \n       case NO_ENDFILE:\n \tif (current_unit->current_record > current_unit->last_record)\n-          {\n-            /* Get rid of whatever is after this record.  */\n-            if (struncate (current_unit->s) == FAILURE)\n-              generate_error (ERROR_OS, NULL);\n-          }\n+\t  {\n+\t    /* Get rid of whatever is after this record.  */\n+\t    if (struncate (current_unit->s) == FAILURE)\n+\t      generate_error (ERROR_OS, NULL);\n+\t  }\n \n \tcurrent_unit->endfile = AT_ENDFILE;\n \tbreak;"}, {"sha": "c7abf2bbd7d8abace4c59b6fa45928eb26fa477d", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0cc7e21cee56062492d6e11014b827ab39c342/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=be0cc7e21cee56062492d6e11014b827ab39c342", "patch": "@@ -1110,15 +1110,16 @@ write_es (fnode *f, const char *p, int len)\n /* Take care of the X/TR descriptor.  */\n \n void\n-write_x (fnode * f)\n+write_x (int len, int nspaces)\n {\n   char *p;\n \n-  p = write_block (f->u.n);\n+  p = write_block (len);\n   if (p == NULL)\n     return;\n \n-  memset (p, ' ', f->u.n);\n+  if (nspaces > 0)\n+    memset (&p[len - nspaces], ' ', nspaces);\n }\n \n "}]}