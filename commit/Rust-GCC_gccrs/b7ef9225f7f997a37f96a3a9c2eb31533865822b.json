{"sha": "b7ef9225f7f997a37f96a3a9c2eb31533865822b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdlZjkyMjVmN2Y5OTdhMzdmOTZhM2E5YzJlYjMxNTMzODY1ODIyYg==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2018-04-02T22:37:21Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2018-04-02T22:37:21Z"}, "message": "RISC-V: Fix for combine bug with shift and AND operations.\n\n\tPR rtl-optimization/84660\n\tgcc/\n\t* config/riscv/riscv.h (SHIFT_COUNT_TRUNCATED): Set to zero.\n\t* config/riscv/riscv.md (<optab>si3): Use QImode shift count.\n\t(<optab>di3, <optab>si3_extend): Likewise.\n\t(<optab>si3_mask, <optab>si3_mask_1): New.\n\t(<optab>di3_mask, <optab>di3_mask_1): New.\n\t(<optab>si3_extend_mask, <optab>si3_extend_mask_1): New.\n\t(lshrsi3_zero_extend_1): Use VOIDmode shift count.\n\t* config/riscv/sync.md (atomic_test_and_set): Emit QImode shift count.\n\tgcc/testsuite/\n\t* gcc.target/riscv/pr84660.c: New.\n\t* gcc.target/riscv/shift-and-1.c: New.\n\t* gcc.target/riscv/shift-and-2.c: New.\n\nFrom-SVN: r259019", "tree": {"sha": "2b4c1d1ef35215676c1927b0b1a197e2a919dce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4c1d1ef35215676c1927b0b1a197e2a919dce6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7ef9225f7f997a37f96a3a9c2eb31533865822b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7ef9225f7f997a37f96a3a9c2eb31533865822b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7ef9225f7f997a37f96a3a9c2eb31533865822b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7ef9225f7f997a37f96a3a9c2eb31533865822b/comments", "author": null, "committer": null, "parents": [{"sha": "82a926bf06e8b7989ee189ef2b3bf7a6c055d6b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a926bf06e8b7989ee189ef2b3bf7a6c055d6b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82a926bf06e8b7989ee189ef2b3bf7a6c055d6b8"}], "stats": {"total": 230, "additions": 223, "deletions": 7}, "files": [{"sha": "293df9a98783fb2daedaff8183f2fe1134b76156", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -1,3 +1,14 @@\n+2018-04-02  Jim Wilson  <jimw@sifive.com>\n+\n+\t* config/riscv/riscv.h (SHIFT_COUNT_TRUNCATED): Set to zero.\n+\t* config/riscv/riscv.md (<optab>si3): Use QImode shift count.\n+\t(<optab>di3, <optab>si3_extend): Likewise.\n+\t(<optab>si3_mask, <optab>si3_mask_1): New.\n+\t(<optab>di3_mask, <optab>di3_mask_1): New.\n+\t(<optab>si3_extend_mask, <optab>si3_extend_mask_1): New.\n+\t(lshrsi3_zero_extend_1): Use VOIDmode shift count.\n+\t* config/riscv/sync.md (atomic_test_and_set): Emit QImode shift count.\n+\n 2018-04-02  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/cpp.texi (Variadic Macros): Fix line continuation in an"}, {"sha": "62279ff2cdef9dc32863a3fd311cae7c78dbd79f", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -636,7 +636,9 @@ typedef struct {\n    and maybe make use of that.  */\n #define SLOW_BYTE_ACCESS 1\n \n-#define SHIFT_COUNT_TRUNCATED 1\n+/* Using SHIFT_COUNT_TRUNCATED is discouraged, so we handle this with patterns\n+   in the md file instead.  */\n+#define SHIFT_COUNT_TRUNCATED 0\n \n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction"}, {"sha": "9d222731a069a1f6459c61b4297d7a179e0818a9", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -1483,11 +1483,16 @@\n ;;\n ;;  ....................\n \n+;; Use a QImode shift count, to avoid generating sign or zero extend\n+;; instructions for shift counts, and to avoid dropping subregs.\n+;; expand_shift_1 can do this automatically when SHIFT_COUNT_TRUNCATED is\n+;; defined, but use of that is discouraged.\n+\n (define_insn \"<optab>si3\"\n   [(set (match_operand:SI     0 \"register_operand\" \"= r\")\n \t(any_shift:SI\n \t    (match_operand:SI 1 \"register_operand\" \"  r\")\n-\t    (match_operand:SI 2 \"arith_operand\"    \" rI\")))]\n+\t    (match_operand:QI 2 \"arith_operand\"    \" rI\")))]\n   \"\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1499,11 +1504,50 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"<optab>si3_mask\"\n+  [(set (match_operand:SI     0 \"register_operand\" \"= r\")\n+\t(any_shift:SI\n+\t    (match_operand:SI 1 \"register_operand\" \"  r\")\n+\t    (subreg:QI\n+\t     (and:SI\n+\t      (match_operand:SI 2 \"register_operand\"  \"r\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))]\n+  \"(INTVAL (operands[3]) & (GET_MODE_BITSIZE (SImode)-1))\n+   == GET_MODE_BITSIZE (SImode)-1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(any_shift:SI (match_dup 1)\n+\t\t      (match_dup 2)))]\n+  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"<optab>si3_mask_1\"\n+  [(set (match_operand:SI     0 \"register_operand\" \"= r\")\n+\t(any_shift:SI\n+\t    (match_operand:SI 1 \"register_operand\" \"  r\")\n+\t    (subreg:QI\n+\t     (and:DI\n+\t      (match_operand:DI 2 \"register_operand\"  \"r\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))]\n+  \"TARGET_64BIT\n+   && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (SImode)-1))\n+       == GET_MODE_BITSIZE (SImode)-1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(any_shift:SI (match_dup 1)\n+\t\t      (match_dup 2)))]\n+  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"<optab>di3\"\n   [(set (match_operand:DI 0 \"register_operand\"     \"= r\")\n \t(any_shift:DI\n \t    (match_operand:DI 1 \"register_operand\" \"  r\")\n-\t    (match_operand:DI 2 \"arith_operand\"    \" rI\")))]\n+\t    (match_operand:QI 2 \"arith_operand\"    \" rI\")))]\n   \"TARGET_64BIT\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1515,11 +1559,51 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_insn_and_split \"<optab>di3_mask\"\n+  [(set (match_operand:DI     0 \"register_operand\" \"= r\")\n+\t(any_shift:DI\n+\t    (match_operand:DI 1 \"register_operand\" \"  r\")\n+\t    (subreg:QI\n+\t     (and:SI\n+\t      (match_operand:SI 2 \"register_operand\"  \"r\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))]\n+  \"TARGET_64BIT\n+   && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (DImode)-1))\n+       == GET_MODE_BITSIZE (DImode)-1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(any_shift:DI (match_dup 1)\n+\t\t      (match_dup 2)))]\n+  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn_and_split \"<optab>di3_mask_1\"\n+  [(set (match_operand:DI     0 \"register_operand\" \"= r\")\n+\t(any_shift:DI\n+\t    (match_operand:DI 1 \"register_operand\" \"  r\")\n+\t    (subreg:QI\n+\t     (and:DI\n+\t      (match_operand:DI 2 \"register_operand\"  \"r\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))]\n+  \"TARGET_64BIT\n+   && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (DImode)-1))\n+       == GET_MODE_BITSIZE (DImode)-1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(any_shift:DI (match_dup 1)\n+\t\t      (match_dup 2)))]\n+  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"*<optab>si3_extend\"\n   [(set (match_operand:DI                   0 \"register_operand\" \"= r\")\n \t(sign_extend:DI\n \t    (any_shift:SI (match_operand:SI 1 \"register_operand\" \"  r\")\n-\t\t\t  (match_operand:SI 2 \"arith_operand\"    \" rI\"))))]\n+\t\t\t  (match_operand:QI 2 \"arith_operand\"    \" rI\"))))]\n   \"TARGET_64BIT\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1530,13 +1614,57 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"*<optab>si3_extend_mask\"\n+  [(set (match_operand:DI                   0 \"register_operand\" \"= r\")\n+\t(sign_extend:DI\n+\t    (any_shift:SI\n+\t     (match_operand:SI 1 \"register_operand\" \"  r\")\n+\t     (subreg:QI\n+\t      (and:SI\n+\t       (match_operand:SI 2 \"register_operand\" \" r\")\n+\t       (match_operand 3 \"const_int_operand\")) 0))))]\n+  \"TARGET_64BIT\n+   && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (SImode)-1))\n+       == GET_MODE_BITSIZE (SImode)-1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(sign_extend:DI\n+\t (any_shift:SI (match_dup 1)\n+\t\t       (match_dup 2))))]\n+  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*<optab>si3_extend_mask_1\"\n+  [(set (match_operand:DI                   0 \"register_operand\" \"= r\")\n+\t(sign_extend:DI\n+\t    (any_shift:SI\n+\t     (match_operand:SI 1 \"register_operand\" \"  r\")\n+\t     (subreg:QI\n+\t      (and:DI\n+\t       (match_operand:DI 2 \"register_operand\" \" r\")\n+\t       (match_operand 3 \"const_int_operand\")) 0))))]\n+  \"TARGET_64BIT\n+   && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (SImode)-1))\n+       == GET_MODE_BITSIZE (SImode)-1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(sign_extend:DI\n+\t (any_shift:SI (match_dup 1)\n+\t\t       (match_dup 2))))]\n+  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")])\n+\n ;; Non-canonical, but can be formed by ree when combine is not successful at\n ;; producing one of the two canonical patterns below.\n (define_insn \"*lshrsi3_zero_extend_1\"\n   [(set (match_operand:DI                   0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n \t (lshiftrt:SI (match_operand:SI     1 \"register_operand\" \" r\")\n-\t\t      (match_operand:SI     2 \"const_int_operand\"))))]\n+\t\t      (match_operand        2 \"const_int_operand\"))))]\n   \"TARGET_64BIT && (INTVAL (operands[2]) & 0x1f) > 0\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);"}, {"sha": "8e8c37702aab69b8fd75eb8d512140f0674a11f8", "filename": "gcc/config/riscv/sync.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Fconfig%2Friscv%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Fconfig%2Friscv%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fsync.md?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -182,13 +182,14 @@\n   emit_move_insn (shmt, gen_rtx_ASHIFT (SImode, offset, GEN_INT (3)));\n \n   rtx word = gen_reg_rtx (SImode);\n-  emit_move_insn (word, gen_rtx_ASHIFT (SImode, tmp, shmt));\n+  emit_move_insn (word, gen_rtx_ASHIFT (SImode, tmp,\n+\t\t\t\t\tgen_lowpart (QImode, shmt)));\n \n   tmp = gen_reg_rtx (SImode);\n   emit_insn (gen_atomic_fetch_orsi (tmp, aligned_mem, word, model));\n \n   emit_move_insn (gen_lowpart (SImode, result),\n \t\t  gen_rtx_LSHIFTRT (SImode, tmp,\n-\t\t\t\t    gen_lowpart (SImode, shmt)));\n+\t\t\t\t    gen_lowpart (QImode, shmt)));\n   DONE;\n })"}, {"sha": "9dd9cdc542b8c983a8407b456cbbfbd3fab94a6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -1,3 +1,9 @@\n+2018-04-02  Jim Wilson  <jimw@sifive.com>\n+\n+\t* gcc.target/riscv/pr84660.c: New.\n+\t* gcc.target/riscv/shift-and-1.c: New.\n+\t* gcc.target/riscv/shift-and-2.c: New.\n+\n 2018-04-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/85102"}, {"sha": "a87fa0a914dcf18e46385ae21735a21a12688e27", "filename": "gcc/testsuite/gcc.target/riscv/pr84660.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fpr84660.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fpr84660.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fpr84660.c?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+unsigned int __attribute__ ((noinline, noclone))\n+foo(unsigned int i) {\n+\n+  return 0xFFFF & (0xd066 << (((i & 0x1) ^ 0x2f) & 0xf));\n+}\n+\n+int main() {\n+  if (foo (1) != 0x8000)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "d1f3a05db2c4c1d91e1d17469f09f5e40c80140b", "filename": "gcc/testsuite/gcc.target/riscv/shift-and-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshift-and-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshift-and-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshift-and-1.c?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc -mabi=ilp32 -O\" } */\n+\n+/* Test for <optab>si3_mask.  */\n+int\n+sub1 (int i, int j)\n+{\n+  return i << (j & 0x1f);\n+}\n+/* { dg-final { scan-assembler-not \"andi\" } } */"}, {"sha": "2c98e50101bcb7bd7285b8eab88bc106ad0dbaf8", "filename": "gcc/testsuite/gcc.target/riscv/shift-and-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshift-and-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ef9225f7f997a37f96a3a9c2eb31533865822b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshift-and-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshift-and-2.c?ref=b7ef9225f7f997a37f96a3a9c2eb31533865822b", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile { target { riscv64*-*-* } } } */\n+/* { dg-options \"-march=rv64gc -mabi=lp64 -O\" } */\n+\n+/* Test for <optab>si3_mask_1.  */\n+extern int k;\n+void\n+sub2 (int i, long j)\n+{\n+  k = i << (j & 0x1f);\n+}\n+\n+/* Test for <optab>si3_extend_mask.  */\n+unsigned long\n+sub3 (int mask)\n+{\n+  return 1 << (mask & 0xff);\n+}\n+\n+/* Test for <optab>si3_extend_mask_1.  */\n+int\n+sub4 (int i, int j)\n+{\n+  return i << (j & 0x1f);\n+}\n+\n+/* Test for <optab>di3_mask.  */\n+long\n+sub5 (long i, int j)\n+{\n+  char k = j & 0x3f;\n+  return i << k;\n+}\n+\n+/* Test for <optab>di3_mask_1.  */\n+long\n+sub6 (long i, long j)\n+{\n+  return i << (j & 0x3f);\n+}\n+/* { dg-final { scan-assembler-not \"andi\" } } */\n+/* { dg-final { scan-assembler-not \"sext.w\" } } */"}]}