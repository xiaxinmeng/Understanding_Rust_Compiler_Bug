{"sha": "884d914111228eed977d794f38e4cc88bf132a58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg0ZDkxNDExMTIyOGVlZDk3N2Q3OTRmMzhlNGNjODhiZjEzMmE1OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-11T21:06:41Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-18T14:03:50Z"}, "message": "analyzer: make summarized dumps more comprehensive\n\nThe previous implementation of summarized dumps within\nregion_model::dump_to_pp showed only the \"top-level\" keys within the\ncurrent frame and for globals, and thus didn't e.g. show the values\nof fields of structs, or elements of arrays.\n\nThis patch rewrites it to gather a vec of representative path_vars\nfor all regions, using this to generate the dump, so that all expressible\nlvalues ought to make it to the summarized dump.\n\ngcc/analyzer/ChangeLog:\n\t* region-model.cc: Include \"stor-layout.h\".\n\t(region_model::dump_to_pp): Rather than calling\n\tdump_summary_of_map on each of the current frame and the globals,\n\tinstead get a vec of representative path_vars for all regions,\n\tand then dump a summary of all of them.\n\t(region_model::dump_summary_of_map): Delete, rewriting into...\n\t(region_model::dump_summary_of_rep_path_vars): ...this new\n\tfunction, working on a vec of path_vars.\n\t(region_model::set_value): New overload.\n\t(region_model::get_representative_path_var): Rename\n\t\"parent_region\" local to \"parent_reg\" and consolidate with other\n\tlocal.  Guard test for grandparent being stack on parent_reg being\n\tnon-NULL.  Move handling for parent being an array_region to\n\twithin guard for parent_reg being non-NULL.\n\t(selftest::make_test_compound_type): New function.\n\t(selftest::test_dump_2): New selftest.\n\t(selftest::test_dump_3): New selftest.\n\t(selftest::test_stack_frames): Update expected output from\n\tsimplified dump to show \"a\" and \"b\" from parent frame and \"y\" in\n\tchild frame.\n\t(selftest::analyzer_region_model_cc_tests): Call test_dump_2 and\n\ttest_dump_3.\n\t* region-model.h (region_model::set_value): New overload decl.\n\t(region_model::dump_summary_of_map): Delete.\n\t(region_model::dump_summary_of_rep_path_vars): New.", "tree": {"sha": "4eb0af06c37a348b7fbbb8cf2b901f9e9d970997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4eb0af06c37a348b7fbbb8cf2b901f9e9d970997"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/884d914111228eed977d794f38e4cc88bf132a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884d914111228eed977d794f38e4cc88bf132a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884d914111228eed977d794f38e4cc88bf132a58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884d914111228eed977d794f38e4cc88bf132a58/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f665beeba625490bd96a593d23e00726d969cf98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f665beeba625490bd96a593d23e00726d969cf98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f665beeba625490bd96a593d23e00726d969cf98"}], "stats": {"total": 295, "additions": 227, "deletions": 68}, "files": [{"sha": "0219cb3de756599ca0d898a72d845e9daa0b2d7a", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d914111228eed977d794f38e4cc88bf132a58/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d914111228eed977d794f38e4cc88bf132a58/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=884d914111228eed977d794f38e4cc88bf132a58", "patch": "@@ -1,3 +1,31 @@\n+2020-03-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* region-model.cc: Include \"stor-layout.h\".\n+\t(region_model::dump_to_pp): Rather than calling\n+\tdump_summary_of_map on each of the current frame and the globals,\n+\tinstead get a vec of representative path_vars for all regions,\n+\tand then dump a summary of all of them.\n+\t(region_model::dump_summary_of_map): Delete, rewriting into...\n+\t(region_model::dump_summary_of_rep_path_vars): ...this new\n+\tfunction, working on a vec of path_vars.\n+\t(region_model::set_value): New overload.\n+\t(region_model::get_representative_path_var): Rename\n+\t\"parent_region\" local to \"parent_reg\" and consolidate with other\n+\tlocal.  Guard test for grandparent being stack on parent_reg being\n+\tnon-NULL.  Move handling for parent being an array_region to\n+\twithin guard for parent_reg being non-NULL.\n+\t(selftest::make_test_compound_type): New function.\n+\t(selftest::test_dump_2): New selftest.\n+\t(selftest::test_dump_3): New selftest.\n+\t(selftest::test_stack_frames): Update expected output from\n+\tsimplified dump to show \"a\" and \"b\" from parent frame and \"y\" in\n+\tchild frame.\n+\t(selftest::analyzer_region_model_cc_tests): Call test_dump_2 and\n+\ttest_dump_3.\n+\t* region-model.h (region_model::set_value): New overload decl.\n+\t(region_model::dump_summary_of_map): Delete.\n+\t(region_model::dump_summary_of_rep_path_vars): New.\n+\n 2020-03-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* region-model.h (class noop_region_model_context): New subclass"}, {"sha": "a71d3de7b12289c6a61cb62adc3678ac6d97ba77", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 195, "deletions": 66, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d914111228eed977d794f38e4cc88bf132a58/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d914111228eed977d794f38e4cc88bf132a58/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=884d914111228eed977d794f38e4cc88bf132a58", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/analyzer-selftests.h\"\n+#include \"stor-layout.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -3538,7 +3539,7 @@ region_model::dump_dot (const char *path) const\n /* Dump a multiline representation of this model to PP, showing the\n    region hierarchy, the svalues, and any constraints.\n \n-   If SUMMARIZE is true, show only the most pertient information,\n+   If SUMMARIZE is true, show only the most pertinent information,\n    in a form that attempts to be less verbose.\n    Otherwise, show all information.  */\n \n@@ -3547,18 +3548,23 @@ region_model::dump_to_pp (pretty_printer *pp, bool summarize) const\n {\n   if (summarize)\n     {\n-      bool is_first = true;\n-      region_id frame_id = get_current_frame_id ();\n-      frame_region *frame = get_region <frame_region> (frame_id);\n-      if (frame)\n-\tdump_summary_of_map (pp, frame, &is_first);\n-\n-      region_id globals_id = get_globals_region_id ();\n-      map_region *globals = get_region <map_region> (globals_id);\n-      if (globals)\n-\tdump_summary_of_map (pp, globals, &is_first);\n+      auto_vec<path_var> rep_path_vars;\n \n       unsigned i;\n+      region *reg;\n+      FOR_EACH_VEC_ELT (m_regions, i, reg)\n+\t{\n+\t  region_id rid = region_id::from_int (i);\n+\t  path_var pv = get_representative_path_var (rid);\n+\t  if (pv.m_tree)\n+\t    rep_path_vars.safe_push (pv);\n+\t}\n+      bool is_first = true;\n+\n+      /* Work with a copy in case the get_lvalue calls change anything\n+\t (they shouldn't).  */\n+      region_model copy (*this);\n+      copy.dump_summary_of_rep_path_vars (pp, &rep_path_vars, &is_first);\n \n       equiv_class *ec;\n       FOR_EACH_VEC_ELT (m_constraints->m_equiv_classes, i, ec)\n@@ -3680,37 +3686,28 @@ dump_vec_of_tree (pretty_printer *pp,\n   pp_printf (pp, \"}: %s\", label);\n }\n \n-/* Dump *MAP_REGION to PP in compact form, updating *IS_FIRST.\n-   Subroutine of region_model::dump_to_pp for use on stack frames and for\n-   the \"globals\" region.  */\n+/* Dump all *REP_PATH_VARS to PP in compact form, updating *IS_FIRST.\n+   Subroutine of region_model::dump_to_pp.  */\n \n void\n-region_model::dump_summary_of_map (pretty_printer *pp,\n-\t\t\t\t   map_region *map_region,\n-\t\t\t\t   bool *is_first) const\n-{\n-  /* Get the keys, sorted by tree_cmp.  In particular, this ought\n-     to alphabetize any decls.  */\n-  auto_vec<tree> keys (map_region->elements ());\n-  for (map_region::iterator_t iter = map_region->begin ();\n-       iter != map_region->end ();\n-       ++iter)\n-    {\n-      tree key_a = (*iter).first;\n-      keys.quick_push (key_a);\n-    }\n-  keys.qsort (tree_cmp);\n-\n+region_model::dump_summary_of_rep_path_vars (pretty_printer *pp,\n+\t\t\t\t\t     auto_vec<path_var> *rep_path_vars,\n+\t\t\t\t\t     bool *is_first)\n+{\n   /* Print pointers, constants, and poisoned values that aren't \"uninit\";\n      gather keys for unknown and uninit values.  */\n   unsigned i;\n-  tree key;\n-  auto_vec<tree> unknown_keys;\n-  auto_vec<tree> uninit_keys;\n-  FOR_EACH_VEC_ELT (keys, i, key)\n+  path_var *pv;\n+  auto_vec<tree> unknown_trees;\n+  auto_vec<tree> uninit_trees;\n+  FOR_EACH_VEC_ELT (*rep_path_vars, i, pv)\n     {\n-      region_id child_rid = *map_region->get (key);\n-\n+      if (TREE_CODE (pv->m_tree) == STRING_CST)\n+\tcontinue;\n+      tentative_region_model_context ctxt;\n+      region_id child_rid = get_lvalue (*pv, &ctxt);\n+      if (ctxt.had_errors_p ())\n+\tcontinue;\n       region *child_region = get_region (child_rid);\n       if (!child_region)\n \tcontinue;\n@@ -3729,7 +3726,7 @@ region_model::dump_summary_of_map (pretty_printer *pp,\n \t    gcc_assert (!pointee_rid.null_p ());\n \t    tree pointee = get_representative_path_var (pointee_rid).m_tree;\n \t    dump_separator (pp, is_first);\n-\t    dump_tree (pp, key);\n+\t    dump_tree (pp, pv->m_tree);\n \t    pp_string (pp, \": \");\n \t    pp_character (pp, '&');\n \t    if (pointee)\n@@ -3740,23 +3737,23 @@ region_model::dump_summary_of_map (pretty_printer *pp,\n \t  break;\n \tcase SK_CONSTANT:\n \t  dump_separator (pp, is_first);\n-\t  dump_tree (pp, key);\n+\t  dump_tree (pp, pv->m_tree);\n \t  pp_string (pp, \": \");\n \t  dump_tree (pp, sval->dyn_cast_constant_svalue ()->get_constant ());\n \t  break;\n \tcase SK_UNKNOWN:\n-\t  unknown_keys.safe_push (key);\n+\t  unknown_trees.safe_push (pv->m_tree);\n \t  break;\n \tcase SK_POISONED:\n \t  {\n \t    poisoned_svalue *poisoned_sval = as_a <poisoned_svalue *> (sval);\n \t    enum poison_kind pkind = poisoned_sval->get_poison_kind ();\n \t    if (pkind == POISON_KIND_UNINIT)\n-\t      uninit_keys.safe_push (key);\n+\t      uninit_trees.safe_push (pv->m_tree);\n \t    else\n \t      {\n \t\tdump_separator (pp, is_first);\n-\t\tdump_tree (pp, key);\n+\t\tdump_tree (pp, pv->m_tree);\n \t\tpp_printf (pp, \": %s\", poison_kind_to_str (pkind));\n \t      }\n \t  }\n@@ -3770,8 +3767,8 @@ region_model::dump_summary_of_map (pretty_printer *pp,\n     }\n \n   /* Print unknown and uninitialized values in consolidated form.  */\n-  dump_vec_of_tree (pp, is_first, unknown_keys, \"unknown\");\n-  dump_vec_of_tree (pp, is_first, uninit_keys, \"uninit\");\n+  dump_vec_of_tree (pp, is_first, unknown_trees, \"unknown\");\n+  dump_vec_of_tree (pp, is_first, uninit_trees, \"uninit\");\n }\n \n /* Assert that this object is valid.  */\n@@ -5355,6 +5352,19 @@ region_model::set_value (region_id lhs_rid, svalue_id rhs_sid,\n   get_region (lhs_rid)->set_value (*this, lhs_rid, rhs_sid, ctxt);\n }\n \n+/* Set the value of the region given by LHS to the value given\n+   by RHS.  */\n+\n+void\n+region_model::set_value (tree lhs, tree rhs, region_model_context *ctxt)\n+{\n+  region_id lhs_rid = get_lvalue (lhs, ctxt);\n+  svalue_id rhs_sid = get_rvalue (rhs, ctxt);\n+  gcc_assert (!lhs_rid.null_p ());\n+  gcc_assert (!rhs_sid.null_p ());\n+  set_value (lhs_rid, rhs_sid, ctxt);\n+}\n+\n /* Determine what is known about the condition \"LHS_SID OP RHS_SID\" within\n    this model.  */\n \n@@ -5735,12 +5745,12 @@ path_var\n region_model::get_representative_path_var (region_id rid) const\n {\n   region *reg = get_region (rid);\n-  region *parent_region = get_region (reg->get_parent ());\n+  region *parent_reg = get_region (reg->get_parent ());\n   region_id stack_rid = get_stack_region_id ();\n   if (!stack_rid.null_p ())\n-    if (parent_region->get_parent () == stack_rid)\n+    if (parent_reg && parent_reg->get_parent () == stack_rid)\n       {\n-\tframe_region *parent_frame = (frame_region *)parent_region;\n+\tframe_region *parent_frame = (frame_region *)parent_reg;\n \ttree t = parent_frame->get_tree_for_child_region (rid);\n \treturn path_var (t, parent_frame->get_depth ());\n     }\n@@ -5753,7 +5763,6 @@ region_model::get_representative_path_var (region_id rid) const\n \n   /* Handle e.g. fields of a local by recursing.  */\n   region_id parent_rid = reg->get_parent ();\n-  region *parent_reg = get_region (parent_rid);\n   if (parent_reg)\n     {\n       if (reg->is_view_p ())\n@@ -5782,25 +5791,25 @@ region_model::get_representative_path_var (region_id rid) const\n \t\t\t\t parent_pv.m_stack_depth);\n \t    }\n \t}\n-    }\n \n-  /* Handle elements within an array.  */\n-  if (array_region *array_reg = parent_region->dyn_cast_array_region ())\n-    {\n-      array_region::key_t key;\n-      if (array_reg->get_key_for_child_region (rid, &key))\n-\t{\n-\t  path_var parent_pv = get_representative_path_var (parent_rid);\n-\t  if (parent_pv.m_tree && reg->get_type ())\n-\t    {\n-\t      tree index = array_reg->constant_from_key (key);\n-\t      return path_var (build4 (ARRAY_REF,\n-\t\t\t\t       reg->get_type (),\n-\t\t\t\t       parent_pv.m_tree, index,\n-\t\t\t\t       NULL_TREE, NULL_TREE),\n-\t\t\t       parent_pv.m_stack_depth);\n-\t    }\n-\t}\n+      /* Handle elements within an array.  */\n+      if (array_region *array_reg = parent_reg->dyn_cast_array_region ())\n+      {\n+\tarray_region::key_t key;\n+\tif (array_reg->get_key_for_child_region (rid, &key))\n+\t  {\n+\t    path_var parent_pv = get_representative_path_var (parent_rid);\n+\t    if (parent_pv.m_tree && reg->get_type ())\n+\t      {\n+\t\ttree index = array_reg->constant_from_key (key);\n+\t\treturn path_var (build4 (ARRAY_REF,\n+\t\t\t\t\t reg->get_type (),\n+\t\t\t\t\t parent_pv.m_tree, index,\n+\t\t\t\t\t NULL_TREE, NULL_TREE),\n+\t\t\t\t parent_pv.m_stack_depth);\n+\t      }\n+\t  }\n+      }\n     }\n \n   /* Handle string literals.  */\n@@ -7400,6 +7409,124 @@ test_dump ()\n   ASSERT_DUMP_EQ (model, true, \"\");\n }\n \n+/* Helper function for selftests.  Create a struct or union type named NAME,\n+   with the fields given by the FIELD_DECLS in FIELDS.\n+   If IS_STRUCT is true create a RECORD_TYPE (aka a struct), otherwise\n+   create a UNION_TYPE.  */\n+\n+static tree\n+make_test_compound_type (const char *name, bool is_struct,\n+\t\t\t const auto_vec<tree> *fields)\n+{\n+  tree t = make_node (is_struct ? RECORD_TYPE : UNION_TYPE);\n+  TYPE_NAME (t) = get_identifier (name);\n+  TYPE_SIZE (t) = 0;\n+\n+  tree fieldlist = NULL;\n+  int i;\n+  tree field;\n+  FOR_EACH_VEC_ELT (*fields, i, field)\n+    {\n+      gcc_assert (TREE_CODE (field) == FIELD_DECL);\n+      DECL_CONTEXT (field) = t;\n+      fieldlist = chainon (field, fieldlist);\n+    }\n+  fieldlist = nreverse (fieldlist);\n+  TYPE_FIELDS (t) = fieldlist;\n+\n+  layout_type (t);\n+  return t;\n+}\n+\n+/* Verify that dumps can show struct fields.  */\n+\n+static void\n+test_dump_2 ()\n+{\n+  auto_vec<tree> fields;\n+  tree x_field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t     get_identifier (\"x\"), integer_type_node);\n+  fields.safe_push (x_field);\n+  tree y_field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t     get_identifier (\"y\"), integer_type_node);\n+  fields.safe_push (y_field);\n+  tree coord_type = make_test_compound_type (\"coord\", true, &fields);\n+\n+  tree c = build_global_decl (\"c\", coord_type);\n+  tree c_x = build3 (COMPONENT_REF, TREE_TYPE (x_field),\n+\t\t     c, x_field, NULL_TREE);\n+  tree c_y = build3 (COMPONENT_REF, TREE_TYPE (y_field),\n+\t\t     c, y_field, NULL_TREE);\n+\n+  tree int_17 = build_int_cst (integer_type_node, 17);\n+  tree int_m3 = build_int_cst (integer_type_node, -3);\n+\n+  region_model model;\n+  model.set_value (c_x, int_17, NULL);\n+  model.set_value (c_y, int_m3, NULL);\n+\n+  /* Simplified dump.  */\n+  ASSERT_DUMP_EQ (model, true, \"c.x: 17, c.y: -3\");\n+\n+  /* Full dump.  */\n+  ASSERT_DUMP_EQ\n+    (model, false,\n+     \"r0: {kind: `root', parent: null, sval: null}\\n\"\n+     \"`-globals: r1: {kind: `globals', parent: r0, sval: null, map: {`c': r2}}\\n\"\n+     \"  `-`c': r2: {kind: `struct', parent: r1, sval: null, type: `struct coord', map: {`x': r3, `y': r4}}\\n\"\n+     \"    |: type: `struct coord'\\n\"\n+     \"    |-`x': r3: {kind: `primitive', parent: r2, sval: sv0, type: `int'}\\n\"\n+     \"    |  |: sval: sv0: {type: `int', `17'}\\n\"\n+     \"    |  |: type: `int'\\n\"\n+     \"    `-`y': r4: {kind: `primitive', parent: r2, sval: sv1, type: `int'}\\n\"\n+     \"      |: sval: sv1: {type: `int', `-3'}\\n\"\n+     \"      |: type: `int'\\n\"\n+     \"svalues:\\n\"\n+     \"  sv0: {type: `int', `17'}\\n\"\n+     \"  sv1: {type: `int', `-3'}\\n\"\n+     \"constraint manager:\\n\"\n+     \"  equiv classes:\\n\"\n+     \"  constraints:\\n\");\n+}\n+\n+/* Verify that dumps can show array elements.  */\n+\n+static void\n+test_dump_3 ()\n+{\n+  tree tlen = size_int (10);\n+  tree arr_type = build_array_type (char_type_node, build_index_type (tlen));\n+\n+  tree a = build_global_decl (\"a\", arr_type);\n+\n+  region_model model;\n+  tree int_0 = build_int_cst (integer_type_node, 0);\n+  tree a_0 = build4 (ARRAY_REF, char_type_node,\n+\t\t     a, int_0, NULL_TREE, NULL_TREE);\n+  tree char_A = build_int_cst (char_type_node, 'A');\n+  model.set_value (a_0, char_A, NULL);\n+\n+  /* Simplified dump.  */\n+  ASSERT_DUMP_EQ (model, true, \"a[0]: 65\");\n+\n+  /* Full dump.  */\n+  ASSERT_DUMP_EQ\n+    (model, false,\n+     \"r0: {kind: `root', parent: null, sval: null}\\n\"\n+     \"`-globals: r1: {kind: `globals', parent: r0, sval: null, map: {`a': r2}}\\n\"\n+     \"  `-`a': r2: {kind: `array', parent: r1, sval: null, type: `char[11]', array: {[0]: r3}}\\n\"\n+     \"    |: type: `char[11]'\\n\"\n+     \"    `-[0]: r3: {kind: `primitive', parent: r2, sval: sv1, type: `char'}\\n\"\n+     \"      |: sval: sv1: {type: `char', `65'}\\n\"\n+     \"      |: type: `char'\\n\"\n+     \"svalues:\\n\"\n+     \"  sv0: {type: `int', `0'}\\n\"\n+     \"  sv1: {type: `char', `65'}\\n\"\n+     \"constraint manager:\\n\"\n+     \"  equiv classes:\\n\"\n+     \"  constraints:\\n\");\n+}\n+\n /* Verify that region_model::get_representative_tree works as expected.  */\n \n static void\n@@ -7834,7 +7961,7 @@ test_stack_frames ()\n #endif\n \n   ASSERT_DUMP_EQ (model, true,\n-\t\t  \"x: 0, {y}: unknown, p: &x, q: &p, b < 10, y != 5\");\n+\t\t  \"a: 42, x: 0, p: &x, q: &p, {b, y}: unknown, b < 10, y != 5\");\n \n   /* Pop the \"child_fn\" frame from the stack.  */\n   purge_stats purged;\n@@ -8475,6 +8602,8 @@ analyzer_region_model_cc_tests ()\n {\n   test_tree_cmp_on_constants ();\n   test_dump ();\n+  test_dump_2 ();\n+  test_dump_3 ();\n   test_get_representative_tree ();\n   test_unique_constants ();\n   test_svalue_equality ();"}, {"sha": "65e66005c93ba8edb774591a98a3f3612433b632", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d914111228eed977d794f38e4cc88bf132a58/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d914111228eed977d794f38e4cc88bf132a58/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=884d914111228eed977d794f38e4cc88bf132a58", "patch": "@@ -1771,6 +1771,7 @@ class region_model\n \n   void set_value (region_id lhs_rid, svalue_id rhs_sid,\n \t\t  region_model_context *ctxt);\n+  void set_value (tree lhs, tree rhs, region_model_context *ctxt);\n   svalue_id set_to_new_unknown_value (region_id dst_rid, tree type,\n \t\t\t\t      region_model_context *ctxt);\n \n@@ -1884,8 +1885,9 @@ class region_model\n   void poison_any_pointers_to_bad_regions (const region_id_set &bad_regions,\n \t\t\t\t\t   enum poison_kind pkind);\n \n-  void dump_summary_of_map (pretty_printer *pp, map_region *map_region,\n-\t\t\t    bool *is_first) const;\n+  void dump_summary_of_rep_path_vars (pretty_printer *pp,\n+\t\t\t\t      auto_vec<path_var> *rep_path_vars,\n+\t\t\t\t      bool *is_first);\n \n   auto_delete_vec<svalue> m_svalues;\n   auto_delete_vec<region> m_regions;"}]}