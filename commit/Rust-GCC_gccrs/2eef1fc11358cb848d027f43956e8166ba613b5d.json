{"sha": "2eef1fc11358cb848d027f43956e8166ba613b5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVlZjFmYzExMzU4Y2I4NDhkMDI3ZjQzOTU2ZTgxNjZiYTYxM2I1ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-10-13T12:15:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-10-13T12:15:38Z"}, "message": "re PR target/77826 (ICE in decompose, at wide-int.h:928 w/ -m64 -O2 and above)\n\n2016-10-13  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/77826\n\t* genmatch.c (struct capture): Add value_match member.\n\t(commutate): Preserve value_match.\n\t(lower_opt_convert): Likewise.\n\t(lower_cond): Likewise.\n\t(replace_id): Likewise.\n\t(struct dt_operand): Add value_match member.\n\t(decision_tree::cmp_node): Compare it.\n\t(decision_tree::insert_operand): Honor it when finding and\n\twhen appending a DT_MATCH.\n\t(dt_operand::gen_match_op): Generate a type check after\n\toperand_equal_p if ! value_match for both GENERIC and GIMPLE.\n\t(parser::get_internal_capture_id): New helper.\n\t(parser::finish_match_operand): New function lowering @@<id>.\n\t(parser::parse_capture): Parse @@<id> as value-match.\n\t(parser::parse_expr): Use get_internal_capture_id.\n\t(parser::parse_simplify): Call finish_match_operand.\n\t(walk_captures): New helper.\n\t* match.pd (X - (X / Y) * Y -> X % Y): Use value-matching instead\n\tof operand_equal_p.\n\t((X /[ex] A) * A -> X): Likewise.\n\t((X | Y) ^ X -> Y & ~ X): Handle constants properly by using\n\tconvert[12] and value-matching.\n\t((A | B) & (A | C) ->  A | (B & C)): Likewise.\n\t((X | Y) | Y -> X | Y): Likewise.\n\t((X ^ Y) ^ Y -> X): Likewise.\n\t(A - (A & B) -> ~B & A): Likewise.\n\t((T)(P + A) - (T)P -> (T) A): Likewise.\n\t((T)P - (T)(P + A) -> -(T) A): Likewise.\n\t((T)(P + A) - (T)(P + B) -> (T)A - (T)B): Likewise.\n\t* doc/match-and-simplify.texi: Amend capture section.\n\nFrom-SVN: r241108", "tree": {"sha": "4e342da03c96b1fb71b0d0f890e31cad31ce87e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e342da03c96b1fb71b0d0f890e31cad31ce87e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eef1fc11358cb848d027f43956e8166ba613b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eef1fc11358cb848d027f43956e8166ba613b5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eef1fc11358cb848d027f43956e8166ba613b5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eef1fc11358cb848d027f43956e8166ba613b5d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a946a5c38d46ae99653649aafadf8f020defaa5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a946a5c38d46ae99653649aafadf8f020defaa5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a946a5c38d46ae99653649aafadf8f020defaa5d"}], "stats": {"total": 220, "additions": 176, "deletions": 44}, "files": [{"sha": "756d77f66c53d09f150e728c55b4cb41ddba103b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2eef1fc11358cb848d027f43956e8166ba613b5d", "patch": "@@ -1,3 +1,37 @@\n+2016-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/77826\n+\t* genmatch.c (struct capture): Add value_match member.\n+\t(commutate): Preserve value_match.\n+\t(lower_opt_convert): Likewise.\n+\t(lower_cond): Likewise.\n+\t(replace_id): Likewise.\n+\t(struct dt_operand): Add value_match member.\n+\t(decision_tree::cmp_node): Compare it.\n+\t(decision_tree::insert_operand): Honor it when finding and\n+\twhen appending a DT_MATCH.\n+\t(dt_operand::gen_match_op): Generate a type check after\n+\toperand_equal_p if ! value_match for both GENERIC and GIMPLE.\n+\t(parser::get_internal_capture_id): New helper.\n+\t(parser::finish_match_operand): New function lowering @@<id>.\n+\t(parser::parse_capture): Parse @@<id> as value-match.\n+\t(parser::parse_expr): Use get_internal_capture_id.\n+\t(parser::parse_simplify): Call finish_match_operand.\n+\t(walk_captures): New helper.\n+\t* match.pd (X - (X / Y) * Y -> X % Y): Use value-matching instead\n+\tof operand_equal_p.\n+\t((X /[ex] A) * A -> X): Likewise.\n+\t((X | Y) ^ X -> Y & ~ X): Handle constants properly by using\n+\tconvert[12] and value-matching.\n+\t((A | B) & (A | C) ->  A | (B & C)): Likewise.\n+\t((X | Y) | Y -> X | Y): Likewise.\n+\t((X ^ Y) ^ Y -> X): Likewise.\n+\t(A - (A & B) -> ~B & A): Likewise.\n+\t((T)(P + A) - (T)P -> (T) A): Likewise.\n+\t((T)P - (T)(P + A) -> -(T) A): Likewise.\n+\t((T)(P + A) - (T)(P + B) -> (T)A - (T)B): Likewise.\n+\t* doc/match-and-simplify.texi: Amend capture section.\n+\n 2016-10-13  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.md (umul_600): Remove predicated variant."}, {"sha": "aaa367b5226f8e5ba561d85aaabfd9db0a3619d9", "filename": "gcc/doc/match-and-simplify.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2Fdoc%2Fmatch-and-simplify.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2Fdoc%2Fmatch-and-simplify.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmatch-and-simplify.texi?ref=2eef1fc11358cb848d027f43956e8166ba613b5d", "patch": "@@ -110,7 +110,11 @@ are @code{@@} followed by a number or an identifier.\n @end smallexample\n \n In this example @code{@@0} is mentioned twice which constrains the matched\n-expression to have two equal operands.  This example also introduces\n+expression to have two equal operands.  Usually matches are constraint\n+to equal types.  If operands may be constants and conversions are involved\n+matching by value might be preferred in which case use @code{@@@@0} to\n+denote a by value match and the specific operand you want to refer to\n+in the result part.  This example also introduces\n operands written in C code.  These can be used in the expression\n replacements and are supposed to evaluate to a tree node which has to\n be a valid GIMPLE operand (so you cannot generate expressions in C code)."}, {"sha": "fc4f5987fc44faf6f7d991d03b95c12fc1bab147", "filename": "gcc/genmatch.c", "status": "modified", "additions": 125, "deletions": 25, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=2eef1fc11358cb848d027f43956e8166ba613b5d", "patch": "@@ -693,10 +693,15 @@ struct c_expr : public operand\n \n struct capture : public operand\n {\n-  capture (source_location loc, unsigned where_, operand *what_)\n-      : operand (OP_CAPTURE, loc), where (where_), what (what_) {}\n+  capture (source_location loc, unsigned where_, operand *what_, bool value_)\n+      : operand (OP_CAPTURE, loc), where (where_), value_match (value_),\n+        what (what_) {}\n   /* Identifier index for the value.  */\n   unsigned where;\n+  /* Whether in a match of two operands the compare should be for\n+     equal values rather than equal atoms (boils down to a type\n+     check or not).  */\n+  bool value_match;\n   /* The captured value.  */\n   operand *what;\n   virtual void gen_transform (FILE *f, int, const char *, bool, int,\n@@ -895,7 +900,8 @@ commutate (operand *op, vec<vec<user_id *> > &for_vec)\n       vec<operand *> v = commutate (c->what, for_vec);\n       for (unsigned i = 0; i < v.length (); ++i)\n \t{\n-\t  capture *nc = new capture (c->location, c->where, v[i]);\n+\t  capture *nc = new capture (c->location, c->where, v[i],\n+\t\t\t\t     c->value_match);\n \t  ret.safe_push (nc);\n \t}\n       return ret;\n@@ -1013,7 +1019,8 @@ lower_opt_convert (operand *o, enum tree_code oper,\n     {\n       if (c->what)\n \treturn new capture (c->location, c->where,\n-\t\t\t    lower_opt_convert (c->what, oper, to_oper, strip));\n+\t\t\t    lower_opt_convert (c->what, oper, to_oper, strip),\n+\t\t\t    c->value_match);\n       else\n \treturn c;\n     }\n@@ -1146,7 +1153,8 @@ lower_cond (operand *o)\n \t  lop = lower_cond (c->what);\n \n \t  for (unsigned i = 0; i < lop.length (); ++i)\n-\t    ro.safe_push (new capture (c->location, c->where, lop[i]));\n+\t    ro.safe_push (new capture (c->location, c->where, lop[i],\n+\t\t\t\t       c->value_match));\n \t  return ro;\n \t}\n     }\n@@ -1196,7 +1204,8 @@ lower_cond (operand *o)\n \t      for (unsigned j = 0; j < ocmp->ops.length (); ++j)\n \t\tcmp->append_op (ocmp->ops[j]);\n \t      cmp->is_generic = true;\n-\t      ne->ops[0] = new capture (c->location, c->where, cmp);\n+\t      ne->ops[0] = new capture (c->location, c->where, cmp,\n+\t\t\t\t\tc->value_match);\n \t    }\n \t  else\n \t    {\n@@ -1275,7 +1284,7 @@ replace_id (operand *o, user_id *id, id_base *with)\n       if (!c->what)\n \treturn c;\n       return new capture (c->location, c->where,\n-\t\t\t  replace_id (c->what, id, with));\n+\t\t\t  replace_id (c->what, id, with), c->value_match);\n     }\n   else if (expr *e = dyn_cast<expr *> (o))\n     {\n@@ -1554,11 +1563,12 @@ struct dt_operand : public dt_node\n   dt_operand *match_dop;\n   dt_operand *parent;\n   unsigned pos;\n+  bool value_match;\n \n   dt_operand (enum dt_type type, operand *op_, dt_operand *match_dop_,\n \t      dt_operand *parent_ = 0, unsigned pos_ = 0)\n       : dt_node (type), op (op_), match_dop (match_dop_),\n-      parent (parent_), pos (pos_) {}\n+      parent (parent_), pos (pos_), value_match (false) {}\n \n   void gen (FILE *, int, bool);\n   unsigned gen_predicate (FILE *, int, const char *, bool);\n@@ -1670,8 +1680,10 @@ decision_tree::cmp_node (dt_node *n1, dt_node *n2)\n     return cmp_operand ((as_a<dt_operand *> (n1))->op,\n \t\t\t(as_a<dt_operand *> (n2))->op);\n   else if (n1->type == dt_node::DT_MATCH)\n-    return ((as_a<dt_operand *> (n1))->match_dop\n-\t    == (as_a<dt_operand *> (n2))->match_dop);\n+    return (((as_a<dt_operand *> (n1))->match_dop\n+\t     == (as_a<dt_operand *> (n2))->match_dop)\n+\t    && ((as_a<dt_operand *> (n1))->value_match\n+\t\t== (as_a<dt_operand *> (n2))->value_match));\n   return false;\n }\n \n@@ -1841,6 +1853,7 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n \t      if (elm == 0)\n \t\t{\n \t\t  dt_operand temp (dt_node::DT_MATCH, 0, match_op);\n+\t\t  temp.value_match = c->value_match;\n \t\t  elm = decision_tree::find_node (p->kids, &temp);\n \t\t}\n \t    }\n@@ -1860,6 +1873,7 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n       else\n \t{\n \t  p = p->append_match_op (indexes[capt_index], parent, pos);\n+\t  as_a <dt_operand *>(p)->value_match = c->value_match;\n \t  if (c->what)\n \t    return insert_operand (p, c->what, indexes, 0, p);\n \t  else\n@@ -2591,18 +2605,18 @@ dt_operand::gen_predicate (FILE *f, int indent, const char *opname, bool gimple)\n    a capture-match.  */\n \n unsigned\n-dt_operand::gen_match_op (FILE *f, int indent, const char *opname, bool gimple)\n+dt_operand::gen_match_op (FILE *f, int indent, const char *opname, bool)\n {\n   char match_opname[20];\n   match_dop->get_name (match_opname);\n-  if (gimple)\n+  if (value_match)\n+    fprintf_indent (f, indent, \"if (%s == %s || operand_equal_p (%s, %s, 0))\\n\",\n+\t\t    opname, match_opname, opname, match_opname);\n+  else\n     fprintf_indent (f, indent, \"if (%s == %s || (operand_equal_p (%s, %s, 0) \"\n \t\t    \"&& types_match (%s, %s)))\\n\",\n \t\t    opname, match_opname, opname, match_opname,\n \t\t    opname, match_opname);\n-  else\n-    fprintf_indent (f, indent, \"if (%s == %s || operand_equal_p (%s, %s, 0))\\n\",\n-\t\t    opname, match_opname, opname, match_opname);\n   fprintf_indent (f, indent + 2, \"{\\n\");\n   return 1;\n }\n@@ -3731,6 +3745,8 @@ class parser\n   const cpp_token *eat_ident (const char *);\n   const char *get_number ();\n \n+  unsigned get_internal_capture_id ();\n+\n   id_base *parse_operation ();\n   operand *parse_capture (operand *, bool);\n   operand *parse_expr ();\n@@ -3750,6 +3766,8 @@ class parser\n   void parse_predicates (source_location);\n   void parse_operator_list (source_location);\n \n+  void finish_match_operand (operand *);\n+\n   cpp_reader *r;\n   vec<c_expr *> active_ifs;\n   vec<vec<user_id *> > active_fors;\n@@ -3886,6 +3904,21 @@ parser::get_number ()\n   return (const char *)token->val.str.text;\n }\n \n+/* Return a capture ID that can be used internally.  */\n+\n+unsigned\n+parser::get_internal_capture_id ()\n+{\n+  unsigned newid = capture_ids->elements ();\n+  /* Big enough for a 32-bit UINT_MAX plus prefix.  */\n+  char id[13];\n+  bool existed;\n+  sprintf (id, \"__%u\", newid);\n+  capture_ids->get_or_insert (xstrdup (id), &existed);\n+  if (existed)\n+    fatal (\"reserved capture id '%s' already used\", id);\n+  return newid;\n+}\n \n /* Record an operator-list use for transparent for handling.  */\n \n@@ -3967,6 +4000,16 @@ parser::parse_capture (operand *op, bool require_existing)\n   source_location src_loc = eat_token (CPP_ATSIGN)->src_loc;\n   const cpp_token *token = peek ();\n   const char *id = NULL;\n+  bool value_match = false;\n+  /* For matches parse @@ as a value-match denoting the prevailing operand.  */\n+  if (token->type == CPP_ATSIGN\n+      && ! (token->flags & PREV_WHITE)\n+      && parsing_match_operand)\n+    {\n+      eat_token (CPP_ATSIGN);\n+      token = peek ();\n+      value_match = true;\n+    }\n   if (token->type == CPP_NUMBER)\n     id = get_number ();\n   else if (token->type == CPP_NAME)\n@@ -3982,7 +4025,7 @@ parser::parse_capture (operand *op, bool require_existing)\n \tfatal_at (src_loc, \"unknown capture id\");\n       num = next_id;\n     }\n-  return new capture (src_loc, num, op);\n+  return new capture (src_loc, num, op, value_match);\n }\n \n /* Parse an expression\n@@ -4062,15 +4105,8 @@ parser::parse_expr ()\n     op = parse_capture (e, false);\n   else if (force_capture)\n     {\n-      unsigned num = capture_ids->elements ();\n-      /* Big enough for a 32-bit UINT_MAX plus prefix.  */\n-      char id[13];\n-      bool existed;\n-      sprintf (id, \"__%u\", num);\n-      capture_ids->get_or_insert (xstrdup (id), &existed);\n-      if (existed)\n-\tfatal_at (token, \"reserved capture id '%s' already used\", id);\n-      op = new capture (token->src_loc, num, e);\n+      unsigned num = get_internal_capture_id ();\n+      op = new capture (token->src_loc, num, e, false);\n     }\n   else\n     op = e;\n@@ -4384,6 +4420,7 @@ parser::parse_simplify (simplify::simplify_kind kind,\n   const cpp_token *loc = peek ();\n   parsing_match_operand = true;\n   struct operand *match = parse_op ();\n+  finish_match_operand (match);\n   parsing_match_operand = false;\n   if (match->type == operand::OP_CAPTURE && !matcher)\n     fatal_at (loc, \"outermost expression cannot be captured\");\n@@ -4724,6 +4761,69 @@ parser::parse_pattern ()\n   eat_token (CPP_CLOSE_PAREN);\n }\n \n+/* Helper for finish_match_operand, collecting captures of OP in CPTS\n+   recursively.  */\n+\n+static void\n+walk_captures (operand *op, vec<vec<capture *> > cpts)\n+{\n+  if (! op)\n+    return;\n+\n+  if (capture *c = dyn_cast <capture *> (op))\n+    {\n+      cpts[c->where].safe_push (c);\n+      walk_captures (c->what, cpts);\n+    }\n+  else if (expr *e = dyn_cast <expr *> (op))\n+    for (unsigned i = 0; i < e->ops.length (); ++i)\n+      walk_captures (e->ops[i], cpts);\n+}\n+\n+/* Finish up OP which is a match operand.  */\n+\n+void\n+parser::finish_match_operand (operand *op)\n+{\n+  /* Look for matching captures, diagnose mis-uses of @@ and apply\n+     early lowering and distribution of value_match.  */\n+  auto_vec<vec<capture *> > cpts;\n+  cpts.safe_grow_cleared (capture_ids->elements ());\n+  walk_captures (op, cpts);\n+  for (unsigned i = 0; i < cpts.length (); ++i)\n+    {\n+      capture *value_match = NULL;\n+      for (unsigned j = 0; j < cpts[i].length (); ++j)\n+\t{\n+\t  if (cpts[i][j]->value_match)\n+\t    {\n+\t      if (value_match)\n+\t\tfatal_at (cpts[i][j]->location, \"duplicate @@\");\n+\t      value_match = cpts[i][j];\n+\t    }\n+\t}\n+      if (cpts[i].length () == 1 && value_match)\n+\tfatal_at (value_match->location, \"@@ without a matching capture\");\n+      if (value_match)\n+\t{\n+\t  /* Duplicate prevailing capture with the existing ID, create\n+\t     a fake ID and rewrite all captures to use it.  This turns\n+\t     @@1 into @__<newid>@1 and @1 into @__<newid>.  */\n+\t  value_match->what = new capture (value_match->location,\n+\t\t\t\t\t   value_match->where,\n+\t\t\t\t\t   value_match->what, false);\n+\t  /* Create a fake ID and rewrite all captures to use it.  */\n+\t  unsigned newid = get_internal_capture_id ();\n+\t  for (unsigned j = 0; j < cpts[i].length (); ++j)\n+\t    {\n+\t      cpts[i][j]->where = newid;\n+\t      cpts[i][j]->value_match = true;\n+\t    }\n+\t}\n+      cpts[i].release ();\n+    }\n+}\n+\n /* Main entry of the parser.  Repeatedly parse outer control structures.  */\n \n parser::parser (cpp_reader *r_)"}, {"sha": "e4ff0e70588021e933b99bf1a5b2d2c847038777", "filename": "gcc/match.pd", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eef1fc11358cb848d027f43956e8166ba613b5d/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=2eef1fc11358cb848d027f43956e8166ba613b5d", "patch": "@@ -334,11 +334,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* X - (X / Y) * Y is the same as X % Y.  */\n (simplify\n- (minus (convert1? @2) (convert2? (mult:c (trunc_div @0 @1) @1)))\n- /* We cannot use matching captures here, since in the case of\n-    constants we really want the type of @0, not @2.  */\n- (if (operand_equal_p (@0, @2, 0)\n-      && (INTEGRAL_TYPE_P (type) || VECTOR_INTEGER_TYPE_P (type)))\n+ (minus (convert1? @0) (convert2? (mult:c (trunc_div @@0 @@1) @1)))\n+ (if (INTEGRAL_TYPE_P (type) || VECTOR_INTEGER_TYPE_P (type))\n   (convert (trunc_mod @0 @1))))\n \n /* Optimize TRUNC_MOD_EXPR by a power of two into a BIT_AND_EXPR,\n@@ -714,7 +711,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* (X | Y) ^ X -> Y & ~ X*/\n (simplify\n- (bit_xor:c (convert? (bit_ior:c @0 @1)) (convert? @0))\n+ (bit_xor:c (convert1? (bit_ior:c @@0 @1)) (convert2? @0))\n  (if (tree_nop_conversion_p (type, TREE_TYPE (@0)))\n   (convert (bit_and @1 (bit_not @0)))))\n \n@@ -747,7 +744,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (for op (bit_and bit_ior bit_xor)\n      rop (bit_ior bit_and bit_and)\n  (simplify\n-  (op (convert? (rop:c @0 @1)) (convert? (rop:c @0 @2)))\n+  (op (convert? (rop:c @@0 @1)) (convert? (rop:c @0 @2)))\n   (if (tree_nop_conversion_p (type, TREE_TYPE (@1))\n        && tree_nop_conversion_p (type, TREE_TYPE (@2)))\n    (rop (convert @0) (op (convert @1) (convert @2))))))\n@@ -757,11 +754,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (X | Y) | Y -> X | Y  */\n (for op (bit_and bit_ior)\n  (simplify\n-  (op:c (convert?@2 (op:c @0 @1)) (convert? @1))\n+  (op:c (convert1?@2 (op:c @0 @@1)) (convert2? @1))\n   @2))\n /* (X ^ Y) ^ Y -> X  */\n (simplify\n- (bit_xor:c (convert? (bit_xor:c @0 @1)) (convert? @1))\n+ (bit_xor:c (convert1? (bit_xor:c @0 @@1)) (convert2? @1))\n  (convert @0))\n /* (X & Y) & (X & Z) -> (X & Y) & Z\n    (X | Y) | (X | Z) -> (X | Y) | Z  */\n@@ -991,7 +988,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* Fold A - (A & B) into ~B & A.  */\n (simplify\n- (minus (convert? @0) (convert?:s (bit_and:cs @0 @1)))\n+ (minus (convert1? @0) (convert2?:s (bit_and:cs @@0 @1)))\n  (if (tree_nop_conversion_p (type, TREE_TYPE (@0))\n       && tree_nop_conversion_p (type, TREE_TYPE (@1)))\n   (convert (bit_and (bit_not @1) @0))))\n@@ -1206,7 +1203,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   /* (T)(P + A) - (T)P -> (T) A */\n   (for add (plus pointer_plus)\n    (simplify\n-    (minus (convert (add @0 @1))\n+    (minus (convert (add @@0 @1))\n      (convert @0))\n     (if (element_precision (type) <= element_precision (TREE_TYPE (@1))\n \t /* For integer types, if A has a smaller type\n@@ -1231,7 +1228,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (for add (plus pointer_plus)\n    (simplify\n     (minus (convert @0)\n-     (convert (add @0 @1)))\n+     (convert (add @@0 @1)))\n     (if (element_precision (type) <= element_precision (TREE_TYPE (@1))\n \t /* For integer types, if A has a smaller type\n \t    than T the result depends on the possible\n@@ -1254,7 +1251,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   /* (T)(P + A) - (T)(P + B) -> (T)A - (T)B */\n   (for add (plus pointer_plus)\n    (simplify\n-    (minus (convert (add @0 @1))\n+    (minus (convert (add @@0 @1))\n      (convert (add @0 @2)))\n     (if (element_precision (type) <= element_precision (TREE_TYPE (@1))\n \t /* For integer types, if A has a smaller type\n@@ -1781,11 +1778,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* (X /[ex] A) * A -> X.  */\n (simplify\n-  (mult (convert1? (exact_div @0 @1)) (convert2? @2))\n-  /* We cannot use matching captures here, since in the case of\n-     constants we don't see the second conversion.  */\n-  (if (operand_equal_p (@1, @2, 0))\n-   (convert @0)))\n+  (mult (convert1? (exact_div @0 @@1)) (convert2? @1))\n+  (convert @0))\n \n /* Canonicalization of binary operations.  */\n "}]}