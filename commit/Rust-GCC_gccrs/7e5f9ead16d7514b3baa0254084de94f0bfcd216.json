{"sha": "7e5f9ead16d7514b3baa0254084de94f0bfcd216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U1ZjllYWQxNmQ3NTE0YjNiYWEwMjU0MDg0ZGU5NGYwYmZjZDIxNg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-23T11:40:10Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-23T11:40:10Z"}, "message": "Simplify (truncate:QI (subreg:SI (reg:QI x))) to (reg:QI x)\n\nWhilst working on a backend patch, I noticed that the middle-end's\nRTL optimizers weren't simplifying a truncation of a paradoxical\nsubreg extension, though it does transform closely related (more\ncomplex) expressions.  The main (first) part of this patch\nimplements this simplification, reusing much of the logic already\nin place.\n\nI briefly considered suggesting that it's difficult to provide a new\ntestcase for this change, but then realized the reviewer's response\nwould be that this type of transformation should be self-tested\nin simplify-rtx, so this patch adds a bunch of tests that integer\nextensions and truncations are simplified as expected.  No good\ndeed goes unpunished and I was equally surprised to see that we\ndon't currently simplify/check/defend (zero_extend:SI (reg:SI)),\ni.e. useless no-op extensions to the same mode.  So I've added\nsome logic to simplify (or more accurately prevent us generating\ndubious RTL for) those.\n\n2021-08-23  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* simplify-rtx.c (simplify_truncation): Generalize simplification\n\tof (truncate:A (subreg:B X)).\n\t(simplify_unary_operation_1) [FLOAT_TRUNCATE, FLOAT_EXTEND,\n\tSIGN_EXTEND, ZERO_EXTEND]: Handle cases where the operand\n\talready has the desired machine mode.\n\t(test_scalar_int_ops): Add tests that useless extensions and\n\ttruncations are optimized away.\n\t(test_scalar_int_ext_ops): New self-test function to confirm\n\tthat truncations of extensions are correctly simplified.\n\t(test_scalar_int_ext_ops2): New self-test function to check\n\ttruncations of truncations, extensions of extensions, and\n\ttruncations of extensions.\n\t(test_scalar_ops): Call the above two functions with a\n\trepresentative sampling of integer machine modes.", "tree": {"sha": "86de623cb72f1e98762052e77958157c565583bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86de623cb72f1e98762052e77958157c565583bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e5f9ead16d7514b3baa0254084de94f0bfcd216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5f9ead16d7514b3baa0254084de94f0bfcd216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e5f9ead16d7514b3baa0254084de94f0bfcd216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5f9ead16d7514b3baa0254084de94f0bfcd216/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d244020246cb155e4de62ca3b302b920a1f513f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d244020246cb155e4de62ca3b302b920a1f513f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d244020246cb155e4de62ca3b302b920a1f513f"}], "stats": {"total": 160, "additions": 149, "deletions": 11}, "files": [{"sha": "f3df6140766febcf423aaef351a0e6db198f4d58", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 149, "deletions": 11, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5f9ead16d7514b3baa0254084de94f0bfcd216/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5f9ead16d7514b3baa0254084de94f0bfcd216/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=7e5f9ead16d7514b3baa0254084de94f0bfcd216", "patch": "@@ -813,23 +813,49 @@ simplify_context::simplify_truncation (machine_mode mode, rtx op,\n     return simplify_gen_unary (GET_CODE (op), mode,\n \t\t\t       XEXP (XEXP (op, 0), 0), mode);\n \n-  /* (truncate:A (subreg:B (truncate:C X) 0)) is\n-     (truncate:A X).  */\n+  /* Simplifications of (truncate:A (subreg:B X 0)).  */\n   if (GET_CODE (op) == SUBREG\n       && is_a <scalar_int_mode> (mode, &int_mode)\n       && SCALAR_INT_MODE_P (op_mode)\n       && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (op)), &subreg_mode)\n-      && GET_CODE (SUBREG_REG (op)) == TRUNCATE\n       && subreg_lowpart_p (op))\n     {\n-      rtx inner = XEXP (SUBREG_REG (op), 0);\n-      if (GET_MODE_PRECISION (int_mode) <= GET_MODE_PRECISION (subreg_mode))\n-\treturn simplify_gen_unary (TRUNCATE, int_mode, inner,\n-\t\t\t\t   GET_MODE (inner));\n-      else\n-\t/* If subreg above is paradoxical and C is narrower\n-\t   than A, return (subreg:A (truncate:C X) 0).  */\n-\treturn simplify_gen_subreg (int_mode, SUBREG_REG (op), subreg_mode, 0);\n+      /* (truncate:A (subreg:B (truncate:C X) 0)) is (truncate:A X).  */\n+      if (GET_CODE (SUBREG_REG (op)) == TRUNCATE)\n+\t{\n+\t  rtx inner = XEXP (SUBREG_REG (op), 0);\n+\t  if (GET_MODE_PRECISION (int_mode)\n+\t      <= GET_MODE_PRECISION (subreg_mode))\n+\t    return simplify_gen_unary (TRUNCATE, int_mode, inner,\n+\t\t\t\t       GET_MODE (inner));\n+\t  else\n+\t    /* If subreg above is paradoxical and C is narrower\n+\t       than A, return (subreg:A (truncate:C X) 0).  */\n+\t    return simplify_gen_subreg (int_mode, SUBREG_REG (op),\n+\t\t\t\t\tsubreg_mode, 0);\n+\t}\n+\n+      /* Simplifications of (truncate:A (subreg:B X:C 0)) with\n+\t paradoxical subregs (B is wider than C).  */\n+      if (is_a <scalar_int_mode> (op_mode, &int_op_mode))\n+\t{\n+\t  unsigned int int_op_prec = GET_MODE_PRECISION (int_op_mode);\n+\t  unsigned int subreg_prec = GET_MODE_PRECISION (subreg_mode);\n+\t  if (int_op_prec > subreg_mode)\n+\t    {\n+\t      if (int_mode == subreg_mode)\n+\t\treturn SUBREG_REG (op);\n+\t      if (GET_MODE_PRECISION (int_mode) < subreg_prec)\n+\t\treturn simplify_gen_unary (TRUNCATE, int_mode,\n+\t\t\t\t\t   SUBREG_REG (op), subreg_mode);\n+\t    }\n+\t  /* Simplification of (truncate:A (subreg:B X:C 0)) where\n+ \t     A is narrower than B and B is narrower than C.  */\n+\t  else if (int_op_prec < subreg_mode\n+\t\t   && GET_MODE_PRECISION (int_mode) < int_op_prec)\n+\t    return simplify_gen_unary (TRUNCATE, int_mode,\n+\t\t\t\t       SUBREG_REG (op), subreg_mode);\n+\t}\n     }\n \n   /* (truncate:A (truncate:B X)) is (truncate:A X).  */\n@@ -1245,6 +1271,10 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n       break;\n \n     case FLOAT_TRUNCATE:\n+      /* Check for useless truncation.  */\n+      if (GET_MODE (op) == mode)\n+\treturn op;\n+\n       if (DECIMAL_FLOAT_MODE_P (mode))\n \tbreak;\n \n@@ -1297,6 +1327,10 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n       break;\n \n     case FLOAT_EXTEND:\n+      /* Check for useless extension.  */\n+      if (GET_MODE (op) == mode)\n+\treturn op;\n+\n       if (DECIMAL_FLOAT_MODE_P (mode))\n \tbreak;\n \n@@ -1410,6 +1444,10 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n       break;\n \n     case SIGN_EXTEND:\n+      /* Check for useless extension.  */\n+      if (GET_MODE (op) == mode)\n+\treturn op;\n+\n       /* (sign_extend (truncate (minus (label_ref L1) (label_ref L2))))\n \t becomes just the MINUS if its mode is MODE.  This allows\n \t folding switch statements on machines using casesi (such as\n@@ -1580,6 +1618,10 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n       break;\n \n     case ZERO_EXTEND:\n+      /* Check for useless extension.  */\n+      if (GET_MODE (op) == mode)\n+\treturn op;\n+\n       /* Check for a zero extension of a subreg of a promoted\n \t variable, where the promotion is zero-extended, and the\n \t target mode is the same as the variable's promotion.  */\n@@ -7563,8 +7605,92 @@ test_scalar_int_ops (machine_mode mode)\n \t\t simplify_gen_binary (IOR, mode, and_op0_6, and_op1_6));\n   ASSERT_RTX_EQ (simplify_gen_binary (AND, mode, and_op0_op1, six),\n \t\t simplify_gen_binary (AND, mode, and_op0_6, and_op1_6));\n+\n+  /* Test useless extensions are eliminated.  */\n+  ASSERT_RTX_EQ (op0, simplify_gen_unary (TRUNCATE, mode, op0, mode));\n+  ASSERT_RTX_EQ (op0, simplify_gen_unary (ZERO_EXTEND, mode, op0, mode));\n+  ASSERT_RTX_EQ (op0, simplify_gen_unary (SIGN_EXTEND, mode, op0, mode));\n+  ASSERT_RTX_EQ (op0, lowpart_subreg (mode, op0, mode));\n+}\n+\n+/* Verify some simplifications of integer extension/truncation.\n+   Machine mode BMODE is the guaranteed wider than SMODE.  */\n+\n+static void\n+test_scalar_int_ext_ops (machine_mode bmode, machine_mode smode)\n+{\n+  rtx sreg = make_test_reg (smode);\n+\n+  /* Check truncation of extension.  */\n+  ASSERT_RTX_EQ (simplify_gen_unary (TRUNCATE, smode,\n+\t\t\t\t     simplify_gen_unary (ZERO_EXTEND, bmode,\n+\t\t\t\t\t\t\t sreg, smode),\n+\t\t\t\t     bmode),\n+\t\t sreg);\n+  ASSERT_RTX_EQ (simplify_gen_unary (TRUNCATE, smode,\n+\t\t\t\t     simplify_gen_unary (SIGN_EXTEND, bmode,\n+\t\t\t\t\t\t\t sreg, smode),\n+\t\t\t\t     bmode),\n+\t\t sreg);\n+  ASSERT_RTX_EQ (simplify_gen_unary (TRUNCATE, smode,\n+\t\t\t\t     lowpart_subreg (bmode, sreg, smode),\n+\t\t\t\t     bmode),\n+\t\t sreg);\n }\n \n+/* Verify more simplifications of integer extension/truncation.\n+   BMODE is wider than MMODE which is wider than SMODE.  */\n+\n+static void\n+test_scalar_int_ext_ops2 (machine_mode bmode, machine_mode mmode,\n+\t\t\t  machine_mode smode)\n+{\n+  rtx breg = make_test_reg (bmode);\n+  rtx mreg = make_test_reg (mmode);\n+  rtx sreg = make_test_reg (smode);\n+\n+  /* Check truncate of truncate.  */\n+  ASSERT_RTX_EQ (simplify_gen_unary (TRUNCATE, smode,\n+\t\t\t\t     simplify_gen_unary (TRUNCATE, mmode,\n+\t\t\t\t\t\t\t breg, bmode),\n+\t\t\t\t     mmode),\n+\t\t simplify_gen_unary (TRUNCATE, smode, breg, bmode));\n+\n+  /* Check extension of extension.  */\n+  ASSERT_RTX_EQ (simplify_gen_unary (ZERO_EXTEND, bmode,\n+\t\t\t\t     simplify_gen_unary (ZERO_EXTEND, mmode,\n+\t\t\t\t\t\t\t sreg, smode),\n+\t\t\t\t     mmode),\n+\t\t simplify_gen_unary (ZERO_EXTEND, bmode, sreg, smode));\n+  ASSERT_RTX_EQ (simplify_gen_unary (SIGN_EXTEND, bmode,\n+\t\t\t\t     simplify_gen_unary (SIGN_EXTEND, mmode,\n+\t\t\t\t\t\t\t sreg, smode),\n+\t\t\t\t     mmode),\n+\t\t simplify_gen_unary (SIGN_EXTEND, bmode, sreg, smode));\n+  ASSERT_RTX_EQ (simplify_gen_unary (SIGN_EXTEND, bmode,\n+\t\t\t\t     simplify_gen_unary (ZERO_EXTEND, mmode,\n+\t\t\t\t\t\t\t sreg, smode),\n+\t\t\t\t     mmode),\n+\t\t simplify_gen_unary (ZERO_EXTEND, bmode, sreg, smode));\n+\n+  /* Check truncation of extension.  */\n+  ASSERT_RTX_EQ (simplify_gen_unary (TRUNCATE, smode,\n+\t\t\t\t     simplify_gen_unary (ZERO_EXTEND, bmode,\n+\t\t\t\t\t\t\t mreg, mmode),\n+\t\t\t\t     bmode),\n+\t\t simplify_gen_unary (TRUNCATE, smode, mreg, mmode));\n+  ASSERT_RTX_EQ (simplify_gen_unary (TRUNCATE, smode,\n+\t\t\t\t     simplify_gen_unary (SIGN_EXTEND, bmode,\n+\t\t\t\t\t\t\t mreg, mmode),\n+\t\t\t\t     bmode),\n+\t\t simplify_gen_unary (TRUNCATE, smode, mreg, mmode));\n+  ASSERT_RTX_EQ (simplify_gen_unary (TRUNCATE, smode,\n+\t\t\t\t     lowpart_subreg (bmode, mreg, mmode),\n+\t\t\t\t     bmode),\n+\t\t simplify_gen_unary (TRUNCATE, smode, mreg, mmode));\n+}  \n+\n+\n /* Verify some simplifications involving scalar expressions.  */\n \n static void\n@@ -7576,6 +7702,18 @@ test_scalar_ops ()\n       if (SCALAR_INT_MODE_P (mode) && mode != BImode)\n \ttest_scalar_int_ops (mode);\n     }\n+\n+  test_scalar_int_ext_ops (HImode, QImode);\n+  test_scalar_int_ext_ops (SImode, QImode);\n+  test_scalar_int_ext_ops (SImode, HImode);\n+  test_scalar_int_ext_ops (DImode, QImode);\n+  test_scalar_int_ext_ops (DImode, HImode);\n+  test_scalar_int_ext_ops (DImode, SImode);\n+\n+  test_scalar_int_ext_ops2 (SImode, HImode, QImode);\n+  test_scalar_int_ext_ops2 (DImode, HImode, QImode);\n+  test_scalar_int_ext_ops2 (DImode, SImode, QImode);\n+  test_scalar_int_ext_ops2 (DImode, SImode, HImode);\n }\n \n /* Test vector simplifications involving VEC_DUPLICATE in which the"}]}