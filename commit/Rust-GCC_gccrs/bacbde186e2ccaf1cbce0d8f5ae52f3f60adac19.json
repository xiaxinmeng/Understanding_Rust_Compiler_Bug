{"sha": "bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFjYmRlMTg2ZTJjY2FmMWNiY2UwZDhmNWFlNTJmM2Y2MGFkYWMxOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-14T20:56:14Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-14T20:56:14Z"}, "message": "(output_prolog): Don't call __eabi here, let compiler call it after the arguments to main are saved.\n\n(output_prolog): Don't call __eabi here, let compiler call it after the\narguments to main are saved.\n(output_{prolog,epilog}): Don't use functions under V.4 to save and restore\nfloating point registers.\n\nFrom-SVN: r9951", "tree": {"sha": "245c22b52e6ed57367efc417b7e4609f73515182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/245c22b52e6ed57367efc417b7e4609f73515182"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19/comments", "author": null, "committer": null, "parents": [{"sha": "4cd44f166e52a8e88db9622f0ed1eb4ad9ca2562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd44f166e52a8e88db9622f0ed1eb4ad9ca2562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd44f166e52a8e88db9622f0ed1eb4ad9ca2562"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "8e725f8358bc5260d22934c61e9937b1c256f386", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bacbde186e2ccaf1cbce0d8f5ae52f3f60adac19", "patch": "@@ -1868,28 +1868,17 @@ output_prolog (file, size)\n   int total_size = (basic_size + size + current_function_outgoing_args_size);\n   char buf[256];\n \n-  /* If this is eabi, call __eabi with main, but do so before the minimal TOC\n-     is setup, so we can't use the normal mechanism.  */\n-#if defined(USING_SVR4_H) && defined(NAME__MAIN) && !defined(INVOKE__main)\n-  int main_p = 0;\n-\n-  if (IDENTIFIER_LENGTH (DECL_NAME (current_function_decl)) == 4\n-      && !strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)), \"main\"))\n-    {\n-      main_p = 1;\n-      regs_ever_live[65] = 1;\n-    }\n-#endif\n-\n   /* Round size to multiple of 8 bytes.  */\n   total_size = (total_size + 7) & ~7;\n \n   /* Write .extern for any function we will call to save and restore fp\n      values.  */\n+#ifndef USING_SVR4_H\n   if (first_fp_reg < 62)\n     fprintf (file, \"\\t.extern %s%d%s\\n\\t.extern %s%d%s\\n\",\n \t     SAVE_FP_PREFIX, first_fp_reg - 32, SAVE_FP_SUFFIX,\n \t     RESTORE_FP_PREFIX, first_fp_reg - 32, RESTORE_FP_SUFFIX);\n+#endif\n \n   /* Write .extern for truncation routines, if needed.  */\n   if (rs6000_trunc_used && ! trunc_defined)\n@@ -1918,9 +1907,14 @@ output_prolog (file, size)\n \n   /* If we have to call a function to save fpr's, or if we are doing profiling,\n      then we will be using LR.  */\n-  if (first_fp_reg < 62 || profile_flag)\n+  if (profile_flag)\n     regs_ever_live[65] = 1;\n \n+#ifndef USING_SVR4_H\n+  if (first_fp_reg < 62)\n+    regs_ever_live[65] = 1;\n+#endif\n+\n   /* If we use the link register, get it into r0.  */\n   if (regs_ever_live[65])\n     asm_fprintf (file, \"\\tmflr 0\\n\");\n@@ -1937,7 +1931,19 @@ output_prolog (file, size)\n   else if (first_fp_reg == 63)\n     asm_fprintf (file, \"\\tstfd 31,-8(1)\\n\");\n   else if (first_fp_reg != 64)\n-    asm_fprintf (file, \"\\tbl %s%d%s\\n\", SAVE_FP_PREFIX, first_fp_reg - 32, SAVE_FP_SUFFIX);\n+    {\n+#ifndef USING_SVR4_H\n+      asm_fprintf (file, \"\\tbl %s%d%s\\n\", SAVE_FP_PREFIX, first_fp_reg - 32, SAVE_FP_SUFFIX);\n+#else\n+      int regno, loc;\n+\n+      for (regno = first_fp_reg,\n+\t   loc = - (64 - first_fp_reg) * 8;\n+\t   regno < 64;\n+\t   regno++, loc += 8)\n+\tasm_fprintf (file, \"\\tstfd %d,%d(1)\\n\", regno - 32, loc);\n+#endif\n+    }\n \n   /* Now save gpr's.  */\n   if (! TARGET_MULTIPLE || first_reg == 31)\n@@ -1984,12 +1990,6 @@ output_prolog (file, size)\n   if (frame_pointer_needed)\n     asm_fprintf (file, \"\\tmr 31,1\\n\");\n \n-  /* If this is eabi, call __eabi before loading up the minimal TOC */\n-#if defined(USING_SVR4_H) && defined(NAME__MAIN) && !defined(INVOKE__main)\n-  if (main_p)\n-    fprintf (file, \"\\tbl %s\\n\", NAME__MAIN);\n-#endif\n-\n   /* If TARGET_MINIMAL_TOC, and the constant pool is needed, then load the\n      TOC_TABLE address into register 30.  */\n   if (TARGET_MINIMAL_TOC && get_pool_size () != 0)\n@@ -2122,7 +2122,21 @@ output_epilog (file, size)\n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n       if (first_fp_reg < 62)\n-\tasm_fprintf (file, \"\\tb %s%d%s\\n\", RESTORE_FP_PREFIX, first_fp_reg - 32, RESTORE_FP_SUFFIX);\n+\t{\n+#ifndef USING_SVR4_H\n+\t  asm_fprintf (file, \"\\tb %s%d%s\\n\", RESTORE_FP_PREFIX, first_fp_reg - 32, RESTORE_FP_SUFFIX);\n+#else\n+\t  int regno, loc;\n+\n+\t  for (regno = first_fp_reg,\n+\t       loc = - (64 - first_fp_reg) * 8;\n+\t       regno < 64;\n+\t       regno++, loc += 8)\n+\t    asm_fprintf (file, \"\\tlfd %d,%d(1)\\n\", regno - 32, loc);\n+\n+\t  asm_fprintf (file, \"\\t{br|blr}\\n\");\n+#endif\n+\t}\n       else\n \tasm_fprintf (file, \"\\t{br|blr}\\n\");\n     }"}]}