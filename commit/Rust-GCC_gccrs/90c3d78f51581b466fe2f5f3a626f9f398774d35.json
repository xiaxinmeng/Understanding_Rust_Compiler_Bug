{"sha": "90c3d78f51581b466fe2f5f3a626f9f398774d35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjM2Q3OGY1MTU4MWI0NjZmZTJmNWYzYTYyNmY5ZjM5ODc3NGQzNQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2019-01-10T03:27:13Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2019-01-10T03:27:13Z"}, "message": "target-supports.exp (check_effective_target_arm_v8_3a_complex_neon_ok_nocache, [...]): New.\n\ngcc/testsuite/ChangeLog:\n\n2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n\n\t* lib/target-supports.exp\n\t(check_effective_target_arm_v8_3a_complex_neon_ok_nocache,\n\tcheck_effective_target_arm_v8_3a_complex_neon_ok,\n\tadd_options_for_arm_v8_3a_complex_neon,\n\tcheck_effective_target_arm_v8_3a_complex_neon_hw,\n\tcheck_effective_target_vect_complex_rot_N): New.\n\nFrom-SVN: r267794", "tree": {"sha": "45060094c8e319e84b9c20b5ed91336790243c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45060094c8e319e84b9c20b5ed91336790243c26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90c3d78f51581b466fe2f5f3a626f9f398774d35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c3d78f51581b466fe2f5f3a626f9f398774d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90c3d78f51581b466fe2f5f3a626f9f398774d35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c3d78f51581b466fe2f5f3a626f9f398774d35/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c94b8dad232c35a3d713c5df782e90ee560985f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c94b8dad232c35a3d713c5df782e90ee560985f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c94b8dad232c35a3d713c5df782e90ee560985f"}], "stats": {"total": 117, "additions": 117, "deletions": 0}, "files": [{"sha": "ef7d0f87b8764680f931e48026a46956ef437c0f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c3d78f51581b466fe2f5f3a626f9f398774d35/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c3d78f51581b466fe2f5f3a626f9f398774d35/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90c3d78f51581b466fe2f5f3a626f9f398774d35", "patch": "@@ -1,3 +1,12 @@\n+2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_arm_v8_3a_complex_neon_ok_nocache,\n+\tcheck_effective_target_arm_v8_3a_complex_neon_ok,\n+\tadd_options_for_arm_v8_3a_complex_neon,\n+\tcheck_effective_target_arm_v8_3a_complex_neon_hw,\n+\tcheck_effective_target_vect_complex_rot_N): New.\n+\n 2019-01-09  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/88376"}, {"sha": "88fbc8d7fe4c430ea273783ec83a1f9e102e1f40", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c3d78f51581b466fe2f5f3a626f9f398774d35/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c3d78f51581b466fe2f5f3a626f9f398774d35/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=90c3d78f51581b466fe2f5f3a626f9f398774d35", "patch": "@@ -9064,3 +9064,111 @@ proc check_effective_target_inf { } {\n         const double pinf = __builtin_inf ();\n     }]\n }\n+\n+# Return 1 if the target supports ARMv8.3 Adv.SIMD Complex instructions\n+# instructions, 0 otherwise.  The test is valid for ARM and for AArch64.\n+# Record the command line options needed.\n+\n+proc check_effective_target_arm_v8_3a_complex_neon_ok_nocache { } {\n+    global et_arm_v8_3a_complex_neon_flags\n+    set et_arm_v8_3a_complex_neon_flags \"\"\n+\n+    if { ![istarget arm*-*-*] && ![istarget aarch64*-*-*] } {\n+        return 0;\n+    }\n+\n+    # Iterate through sets of options to find the compiler flags that\n+    # need to be added to the -march option.\n+    foreach flags {\"\" \"-mfloat-abi=softfp -mfpu=auto\" \"-mfloat-abi=hard -mfpu=auto\"} {\n+        if { [check_no_compiler_messages_nocache \\\n+                  arm_v8_3a_complex_neon_ok object {\n+            #if !defined (__ARM_FEATURE_COMPLEX)\n+            #error \"__ARM_FEATURE_COMPLEX not defined\"\n+            #endif\n+        } \"$flags -march=armv8.3-a\"] } {\n+            set et_arm_v8_3a_complex_neon_flags \"$flags -march=armv8.3-a\"\n+            return 1\n+        }\n+    }\n+\n+    return 0;\n+}\n+\n+proc check_effective_target_arm_v8_3a_complex_neon_ok { } {\n+    return [check_cached_effective_target arm_v8_3a_complex_neon_ok \\\n+                check_effective_target_arm_v8_3a_complex_neon_ok_nocache]\n+}\n+\n+proc add_options_for_arm_v8_3a_complex_neon { flags } {\n+    if { ! [check_effective_target_arm_v8_3a_complex_neon_ok] } {\n+        return \"$flags\"\n+    }\n+    global et_arm_v8_3a_complex_neon_flags\n+    return \"$flags $et_arm_v8_3a_complex_neon_flags\"\n+}\n+\n+# Return 1 if the target supports executing AdvSIMD instructions from ARMv8.3\n+# with the complex instruction extension, 0 otherwise.  The test is valid for\n+# ARM and for AArch64.\n+\n+proc check_effective_target_arm_v8_3a_complex_neon_hw { } {\n+    if { ![check_effective_target_arm_v8_3a_complex_neon_ok] } {\n+        return 0;\n+    }\n+    return [check_runtime arm_v8_3a_complex_neon_hw_available {\n+        #include \"arm_neon.h\"\n+        int\n+        main (void)\n+        {\n+\n+          float32x2_t results = {-4.0,5.0};\n+          float32x2_t a = {1.0,3.0};\n+          float32x2_t b = {2.0,5.0};\n+\n+          #ifdef __ARM_ARCH_ISA_A64\n+          asm (\"fcadd %0.2s, %1.2s, %2.2s, #90\"\n+               : \"=w\"(results)\n+               : \"w\"(a), \"w\"(b)\n+               : /* No clobbers.  */);\n+\n+          #else\n+          asm (\"vcadd.f32 %P0, %P1, %P2, #90\"\n+               : \"=w\"(results)\n+               : \"w\"(a), \"w\"(b)\n+               : /* No clobbers.  */);\n+          #endif\n+\n+          return (results[0] == 8 && results[1] == 24) ? 1 : 0;\n+        }\n+    } [add_options_for_arm_v8_3a_complex_neon \"\"]]\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# complex addition with rotate of half and single float modes, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+foreach N {hf sf} {\n+    eval [string map [list N $N] {\n+        proc check_effective_target_vect_complex_rot_N { } {\n+            return [check_cached_effective_target_indexed vect_complex_rot_N {\n+            expr { [istarget aarch64*-*-*]\n+                    || [istarget arm*-*-*] }}]\n+        }\n+    }]\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# complex addition with rotate of double float modes, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+foreach N {df} {\n+    eval [string map [list N $N] {\n+        proc check_effective_target_vect_complex_rot_N { } {\n+            return [check_cached_effective_target_indexed vect_complex_rot_N {\n+            expr { [istarget aarch64*-*-*] }}]\n+        }\n+    }]\n+}\n+"}]}