{"sha": "a94ce33311d4bbc1f98d6f55beb133616347c682", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0Y2UzMzMxMWQ0YmJjMWY5OGQ2ZjU1YmViMTMzNjE2MzQ3YzY4Mg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1997-08-19T16:04:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-19T16:04:22Z"}, "message": "reload.c (find_reloads): Add code to convert RELOAD_FOR_OPADDR_ADDR reloads to...\n\n        * reload.c (find_reloads): Add code to convert RELOAD_FOR_OPADDR_ADDR\n        reloads to RELOAD_FOR_OPERAND_ADDRESS reloads.\n        * reload1.c: Undo bugfix from Aug 11.\nBack out \"simple\" patch for PA reload bug and install the one accepted\nby the FSF.\n\nFrom-SVN: r14847", "tree": {"sha": "25b3a60e6623c4cd6da8ad483c50546a449f0d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25b3a60e6623c4cd6da8ad483c50546a449f0d52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a94ce33311d4bbc1f98d6f55beb133616347c682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94ce33311d4bbc1f98d6f55beb133616347c682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94ce33311d4bbc1f98d6f55beb133616347c682", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94ce33311d4bbc1f98d6f55beb133616347c682/comments", "author": null, "committer": null, "parents": [{"sha": "e9576d2c229b3caea1c0c7fb0bd56eb1dd8537ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9576d2c229b3caea1c0c7fb0bd56eb1dd8537ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9576d2c229b3caea1c0c7fb0bd56eb1dd8537ee"}], "stats": {"total": 67, "additions": 50, "deletions": 17}, "files": [{"sha": "aef412e73c42322f7044f586e1ed097dbba959c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94ce33311d4bbc1f98d6f55beb133616347c682/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94ce33311d4bbc1f98d6f55beb133616347c682/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a94ce33311d4bbc1f98d6f55beb133616347c682", "patch": "@@ -1,3 +1,9 @@\n+Mon Aug 18 21:49:02 1997  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* reload.c (find_reloads): Add code to convert RELOAD_FOR_OPADDR_ADDR\n+\treloads to RELOAD_FOR_OPERAND_ADDRESS reloads.\n+\t* reload1.c: Undo bugfix from Aug 11.\n+\n Tue Aug 19 09:34:57 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (EXPECT, RUNTEST, RUNTESTFLAGS): Define."}, {"sha": "efd4aca2e94be3f3d51e3ac01adc545ef7f9554c", "filename": "gcc/reload.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94ce33311d4bbc1f98d6f55beb133616347c682/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94ce33311d4bbc1f98d6f55beb133616347c682/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a94ce33311d4bbc1f98d6f55beb133616347c682", "patch": "@@ -3871,6 +3871,35 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \treload_opnum[i] = goal_alternative_matches[reload_opnum[i]];\n     }\n \n+  /* Scan all the reloads, and check for RELOAD_FOR_OPERAND_ADDRESS reloads.\n+     If we have more than one, then convert all RELOAD_FOR_OPADDR_ADDR\n+     reloads to RELOAD_FOR_OPERAND_ADDRESS reloads.\n+\n+     choose_reload_regs assumes that RELOAD_FOR_OPADDR_ADDR reloads never\n+     conflict with RELOAD_FOR_OPERAND_ADDRESS reloads.  This is true for a\n+     single pair of RELOAD_FOR_OPADDR_ADDR/RELOAD_FOR_OPERAND_ADDRESS reloads.\n+     However, if there is more than one RELOAD_FOR_OPERAND_ADDRESS reload,\n+     then a RELOAD_FOR_OPADDR_ADDR reload conflicts with all\n+     RELOAD_FOR_OPERAND_ADDRESS reloads other than the one that uses it.\n+     This is complicated by the fact that a single operand can have more\n+     than one RELOAD_FOR_OPERAND_ADDRESS reload.  It is very difficult to fix\n+     choose_reload_regs without affecting code quality, and cases that\n+     actually fail are extremely rare, so it turns out to be better to fix\n+     the problem here by not generating cases that choose_reload_regs will\n+     fail for.  */\n+   \n+  {\n+    int op_addr_reloads = 0;\n+    for (i = 0; i < n_reloads; i++)\n+      if (reload_when_needed[i] == RELOAD_FOR_OPERAND_ADDRESS)\n+\top_addr_reloads++;\n+\n+    if (op_addr_reloads > 1)\n+      for (i = 0; i < n_reloads; i++)\n+\tif (reload_when_needed[i] == RELOAD_FOR_OPADDR_ADDR)\n+\t  reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+  }\n+\n   /* See if we have any reloads that are now allowed to be merged\n      because we've changed when the reload is needed to\n      RELOAD_FOR_OPERAND_ADDRESS or RELOAD_FOR_OTHER_ADDRESS.  Only"}, {"sha": "a3361abbfadfabb55e8f9ee1c43e714ea4a46674", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94ce33311d4bbc1f98d6f55beb133616347c682/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94ce33311d4bbc1f98d6f55beb133616347c682/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a94ce33311d4bbc1f98d6f55beb133616347c682", "patch": "@@ -1341,8 +1341,8 @@ reload (first, global, dumpfile)\n \t\t\t don't conflict with things needed to reload inputs or\n \t\t\t outputs.  */\n \n-\t\t      in_max = MAX ((insn_needs.op_addr.regs[j][i]\n-\t\t\t\t     + insn_needs.op_addr_reload.regs[j][i]),\n+\t\t      in_max = MAX (MAX (insn_needs.op_addr.regs[j][i],\n+\t\t\t\t\t insn_needs.op_addr_reload.regs[j][i]),\n \t\t\t\t    in_max);\n \n \t\t      out_max = MAX (out_max, insn_needs.insn.regs[j][i]);\n@@ -1374,8 +1374,8 @@ reload (first, global, dumpfile)\n \t\t\t= MAX (out_max, insn_needs.out_addr_addr[j].groups[i]);\n \t\t    }\n \n-\t\t  in_max = MAX ((insn_needs.op_addr.groups[i]\n-\t\t\t\t + insn_needs.op_addr_reload.groups[i]),\n+\t\t  in_max = MAX (MAX (insn_needs.op_addr.groups[i],\n+\t\t\t\t     insn_needs.op_addr_reload.groups[i]),\n \t\t\t\tin_max);\n \t\t  out_max = MAX (out_max, insn_needs.insn.groups[i]);\n \n@@ -4605,22 +4605,15 @@ reload_reg_free_p (regno, opnum, type)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n \t  return 0;\n \n-      /* ??? A OPADDR_ADDR reload does not conflict with the OPERAND_ADDRESS\n-\t reload that uses it.  However, the same operand can have multiple\n-\t OPERAND_ADDRESS reloads, and a OPADDR_ADDR reload does conflict with\n-\t other OPERAND_ADDRESS reloads for the same operand, hence we must\n-\t say that OPADDR_ADDR and OPERAND_ADDRESS reloads always conflict.  */\n       return (! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno)\n \t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n \n     case RELOAD_FOR_OPADDR_ADDR:\n       for (i = 0; i < reload_n_operands; i++)\n         if (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n           return 0;\n \n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n+      return (!TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno));\n \n     case RELOAD_FOR_OUTPUT:\n       /* This cannot share a register with RELOAD_FOR_INSN reloads, other\n@@ -4737,6 +4730,12 @@ reload_reg_free_before_p (regno, opnum, type)\n       return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n+      /* Earlier reloads include RELOAD_FOR_OPADDR_ADDR reloads.  */\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno))\n+\treturn 0;\n+\n+      /* ... fall through ...  */\n+\n     case RELOAD_FOR_OPADDR_ADDR:\n     case RELOAD_FOR_INSN:\n       /* These can't conflict with inputs, or each other, so all we have to\n@@ -4880,7 +4879,8 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno));\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n+\t      && !TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno));\n \n     case RELOAD_FOR_INSN:\n       /* These conflict with other outputs with RELOAD_OTHER.  So\n@@ -4955,13 +4955,11 @@ reloads_conflict (r1, r2)\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n       return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_INSN\n-\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS\n-\t      || r2_type == RELOAD_FOR_OPADDR_ADDR);\n+\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n \n     case RELOAD_FOR_OPADDR_ADDR:\n       return (r2_type == RELOAD_FOR_INPUT \n-\t      || r2_type == RELOAD_FOR_OPADDR_ADDR\n-\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n+\t      || r2_type == RELOAD_FOR_OPADDR_ADDR);\n \n     case RELOAD_FOR_OUTPUT:\n       return (r2_type == RELOAD_FOR_INSN || r2_type == RELOAD_FOR_OUTPUT"}]}