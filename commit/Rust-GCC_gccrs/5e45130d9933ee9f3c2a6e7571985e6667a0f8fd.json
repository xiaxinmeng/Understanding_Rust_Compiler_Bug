{"sha": "5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU0NTEzMGQ5OTMzZWU5ZjNjMmE2ZTc1NzE5ODVlNjY2N2EwZjhmZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-24T20:09:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-24T20:09:32Z"}, "message": "invoke.texi (-fipa-cp-clone): New option.\n\n\n\t* doc/invoke.texi (-fipa-cp-clone): New option.\n\t(-fipa-cp): Update docs.\n\t(--param ipcp-unit-growth):New.\n\t* ipa-cp.c: Include fibheap.h, params.h\n\t(ipcp_initialize_node_lattices): When not cloning, all externally\n\tvisible functions are bottom.\n\t(ipcp_need_redirect_p): Accept clones.\n\t(ipcp_insert_stage): Use cost driven heuristics.\n\t(max_count, dead_nodes): New static vars.\n\t(ipcp_need_original_clone_p, ipcp_estimate_cloning_cost,\n\tipcp_const_param_count): New functions.\n\t* common.opt (ipa-cp-clone): New command line option.\n\t* params.def (ipcp-unit-growth): New.\n\n\t* gcc.dg/ipa/ipacost-1.c: New testcase.\n\t* gcc.dg/ipa/ipacost-2.c: New testcase.\n\t* gcc.dg/ipa/ipa-7.c: Update template.\n\nFrom-SVN: r139543", "tree": {"sha": "15e8f39fcea6710eaf6421db403e5763c55d3734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e8f39fcea6710eaf6421db403e5763c55d3734"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/comments", "author": null, "committer": null, "parents": [{"sha": "657c0925049e8902484474e0a1b53dfe34863858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/657c0925049e8902484474e0a1b53dfe34863858", "html_url": "https://github.com/Rust-GCC/gccrs/commit/657c0925049e8902484474e0a1b53dfe34863858"}], "stats": {"total": 262, "additions": 237, "deletions": 25}, "files": [{"sha": "8aaece17699219c1dad7a1bb8a32c117660d8ea6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "patch": "@@ -1,3 +1,19 @@\n+2008-08-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* doc/invoke.texi (-fipa-cp-clone): New option.\n+\t(-fipa-cp): Update docs.\n+\t(--param ipcp-unit-growth):New.\n+\t* ipa-cp.c: Include fibheap.h, params.h\n+\t(ipcp_initialize_node_lattices): When not cloning, all externally\n+\tvisible functions are bottom.\n+\t(ipcp_need_redirect_p): Accept clones.\n+\t(ipcp_insert_stage): Use cost driven heuristics.\n+\t(max_count, dead_nodes): New static vars.\n+\t(ipcp_need_original_clone_p, ipcp_estimate_cloning_cost,\n+\tipcp_const_param_count): New functions.\n+\t* common.opt (ipa-cp-clone): New command line option.\n+\t* params.def (ipcp-unit-growth): New.\n+\n 2008-08-24  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-inline.c (tree_function_versioning): Look harder"}, {"sha": "523f71206c7fc964d403d550673d84f2d1ad8c3b", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "patch": "@@ -623,6 +623,10 @@ fipa-cp\n Common Report Var(flag_ipa_cp) Optimization\n Perform Interprocedural constant propagation\n \n+fipa-cp-clone\n+Common Report Var(flag_ipa_cp_clone) Optimization\n+Perform cloning to make Interprocedural constant propagation stronger\n+\n fipa-pure-const\n Common Report Var(flag_ipa_pure_const) Init(0) Optimization\n Discover pure and const functions"}, {"sha": "e34802a356e63632140b1435338c1184059c8ee7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "patch": "@@ -330,7 +330,7 @@ Objective-C and Objective-C++ Dialects}.\n -ffunction-sections -fgcse -fgcse-after-reload -fgcse-las -fgcse-lm @gol\n -fgcse-sm -fif-conversion -fif-conversion2 -findirect-inlining @gol\n -finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n--finline-small-functions -fipa-cp -fipa-marix-reorg -fipa-pta @gol \n+-finline-small-functions -fipa-cp -fipa-cp-clone -fipa-marix-reorg -fipa-pta @gol \n -fipa-pure-const -fipa-reference -fipa-struct-reorg @gol\n -fipa-type-escape -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n -fmerge-all-constants -fmerge-constants -fmodulo-sched @gol\n@@ -5854,9 +5854,16 @@ Perform interprocedural constant propagation.\n This optimization analyzes the program to determine when values passed\n to functions are constants and then optimizes accordingly.  \n This optimization can substantially increase performance\n-if the application has constants passed to functions, but\n-because this optimization can create multiple copies of functions,\n-it may significantly increase code size.\n+if the application has constants passed to functions.\n+\n+@item -fipa-cp-clone\n+@opindex fipa-cp-clone\n+Perform function cloning to make interprocedural constant propagation stronger.\n+When enabled, interprocedural constant propagation will perform function cloning\n+when externally visible function can be called with constant arguments.\n+Because this optimization can create multiple copies of functions,\n+it may significantly increase code size\n+(see @option{--param ipcp-unit-growth=@var{value}}).\n \n @item -fipa-matrix-reorg\n @opindex fipa-matrix-reorg\n@@ -6953,6 +6960,11 @@ Specifies maximal overall growth of the compilation unit caused by inlining.\n The default value is 30 which limits unit growth to 1.3 times the original\n size.\n \n+@item ipcp-unit-growth\n+Specifies maximal overall growth of the compilation unit caused by\n+interprocedural constant propagation.  The default value is 10 which limits\n+unit growth to 1.1 times the original size.\n+\n @item large-stack-frame\n The limit specifying large stack frames.  While inlining the algorithm is trying\n to not grow past this limit too much.  Default value is 256 bytes."}, {"sha": "b0ed074e3a942dec582ab7c6f09e157d68bd7945", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 190, "deletions": 20, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "patch": "@@ -132,6 +132,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"tree-dump.h\"\n #include \"tree-inline.h\"\n+#include \"fibheap.h\"\n+#include \"params.h\"\n \n /* Get the original node field of ipa_node_params associated with node NODE.  */\n static inline struct cgraph_node *\n@@ -375,8 +377,15 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n \n   info->ipcp_lattices = XCNEWVEC (struct ipcp_lattice,\n \t\t\t\t  ipa_get_param_count (info));\n-  for (i = 0; i < ipa_get_param_count (info) ; i++)\n-    ipcp_get_ith_lattice (info, i)->type = IPA_TOP;\n+  \n+  /* When cloning is allowed, we can assume that externally visible functions\n+     are not called.  We will compensate this by cloning later.  */\n+  if (flag_ipa_cp_clone || !node->needed)\n+    for (i = 0; i < ipa_get_param_count (info) ; i++)\n+      ipcp_get_ith_lattice (info, i)->type = IPA_TOP;\n+  else\n+    for (i = 0; i < ipa_get_param_count (info) ; i++)\n+      ipcp_get_ith_lattice (info, i)->type = IPA_BOTTOM;\n }\n \n /* build INTEGER_CST tree with type TREE_TYPE and value according to LAT.\n@@ -755,8 +764,14 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n   struct ipa_node_params *orig_callee_info;\n   int i, count;\n   struct ipa_jump_func *jump_func;\n+  struct cgraph_node *node = cs->callee, *orig;\n+\n+  if ((orig = ipcp_get_orig_node (node)) != NULL)\n+    node = orig;\n+  if (ipcp_get_orig_node (cs->caller))\n+    return false;\n \n-  orig_callee_info = IPA_NODE_REF (ipcp_get_orig_node (cs->callee));\n+  orig_callee_info = IPA_NODE_REF (node);\n   count = ipa_get_param_count (orig_callee_info);\n   for (i = 0; i < count; i++)\n     {\n@@ -852,23 +867,124 @@ ipcp_update_profiling (void)\n     }\n }\n \n+/* Maximal count found in program.  */\n+static gcov_type max_count;\n+bitmap dead_nodes;\n+\n+/* Return true if original clone needs to be preserved.  */\n+static bool\n+ipcp_need_original_clone_p (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+\n+  if (node->needed)\n+    return true;\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (!bitmap_bit_p (dead_nodes, e->caller->uid)\n+        && ipcp_need_redirect_p (e))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Estimate cost of cloning NODE.  */\n+static long\n+ipcp_estimate_cloning_cost (struct cgraph_node *node)\n+{\n+  int freq_sum = 1;\n+  gcov_type count_sum = 1;\n+  struct cgraph_edge *e;\n+  int cost;\n+\n+  /* When we don't need original clone; we should always propagate.  */\n+  if (!ipcp_need_original_clone_p (node))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function %s can be fully propagated\\n\",\n+\t\t cgraph_node_name (node));\n+      return 0;\n+    }\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (!bitmap_bit_p (dead_nodes, e->caller->uid)\n+        && !ipcp_need_redirect_p (e))\n+      {\n+\tcount_sum += e->count;\n+\tfreq_sum += e->frequency + 1;\n+      }\n+\n+  cost = node->local.inline_summary.self_insns * 1000;\n+  if (max_count)\n+    cost /= count_sum * 1000 / max_count + 1;\n+  else\n+    cost /= freq_sum * 1000 / REG_BR_PROB_BASE + 1;\n+  if (dump_file)\n+    fprintf (dump_file, \"Cost of versioning %s is %i, (size: %i, freq: %i)\\n\",\n+             cgraph_node_name (node), cost, node->local.inline_summary.self_insns,\n+\t     freq_sum);\n+  return cost + 1;\n+}\n+\n+/* Return number of live constant parameters.  */\n+static int\n+ipcp_const_param_count (struct cgraph_node *node)\n+{\n+  int const_param = 0;\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  int count = ipa_get_param_count (info);\n+  int i;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+      tree parm_tree = ipa_get_ith_param (info, i);\n+      if (ipcp_lat_is_insertable (lat)\n+\t  /* Do not count obviously unused arguments.  */\n+\t  && (!is_gimple_reg (parm_tree)\n+\t      || gimple_default_def (DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t\t     parm_tree)))\n+\tconst_param++;\n+    }\n+  return const_param;\n+}\n+\n /* Propagate the constant parameters found by ipcp_iterate_stage()\n    to the function's code.  */\n static void\n ipcp_insert_stage (void)\n {\n   struct cgraph_node *node, *node1 = NULL;\n-  int i, const_param;\n+  int i;\n   VEC (cgraph_edge_p, heap) * redirect_callers;\n   varray_type replace_trees;\n   struct cgraph_edge *cs;\n   int node_callers, count;\n   tree parm_tree;\n   struct ipa_replace_map *replace_param;\n+  fibheap_t heap;\n+  long overall_insns = 0, new_insns = 0;\n+  long max_new_insns;\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n \n+  dead_nodes = BITMAP_ALLOC (NULL);\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed)\n+      {\n+\tif (node->count > max_count)\n+\t  max_count = node->count;\n+\toverall_insns += node->local.inline_summary.self_insns;\n+      }\n+\n+  max_new_insns = overall_insns;\n+  if (max_new_insns < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n+    max_new_insns = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n+  max_new_insns = max_new_insns * PARAM_VALUE (PARAM_IPCP_UNIT_GROWTH) / 100 + 1;\n+\n+  /* First collect all functions we proved to have constant arguments to heap.  */\n+  heap = fibheap_new ();\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       struct ipa_node_params *info;\n@@ -878,39 +994,72 @@ ipcp_insert_stage (void)\n       info = IPA_NODE_REF (node);\n       if (ipa_is_called_with_var_arguments (info))\n \tcontinue;\n-      const_param = 0;\n+      if (ipcp_const_param_count (node))\n+\tnode->aux = fibheap_insert (heap, ipcp_estimate_cloning_cost (node), node);\n+     }\n+\n+  /* Now clone in priority order until code size growth limits are met or\n+     heap is emptied.  */\n+  while (!fibheap_empty (heap))\n+    {\n+      struct ipa_node_params *info;\n+      int growth = 0;\n+\n+      node = (struct cgraph_node *)fibheap_extract_min (heap);\n+      node->aux = NULL;\n+      if (dump_file)\n+\tfprintf (dump_file, \"considering function %s\\n\",\n+\t\t cgraph_node_name (node));\n+\n+      if (ipcp_need_original_clone_p (node))\n+        growth = node->local.inline_summary.self_insns;\n+      else\n+\tbitmap_set_bit (dead_nodes, node->uid);\n+\n+      if (new_insns + growth > max_new_insns)\n+\tbreak;\n+      if (growth\n+          && (optimize_size\n+\t      || (DECL_STRUCT_FUNCTION (node->decl)\n+\t          ->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not versioning, cold code would grow\");\n+\t  continue;\n+\t}\n+\n+      new_insns += growth;\n+\n+      info = IPA_NODE_REF (node);\n       count = ipa_get_param_count (info);\n+\n+      VARRAY_GENERIC_PTR_INIT (replace_trees, ipcp_const_param_count (node),\n+\t\t\t\t\"replace_trees\");\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t  tree parm_tree = ipa_get_ith_param (info, i);\n-\t  if (ipcp_lat_is_insertable (lat)\n+\t  parm_tree = ipa_get_ith_param (info, i);\n+\n+\t  if (lat->type == IPA_CONST_VALUE\n \t      /* Do not count obviously unused arguments.  */\n \t      && (!is_gimple_reg (parm_tree)\n-\t\t  || gimple_default_def (DECL_STRUCT_FUNCTION (node->decl), parm_tree)))\n-\t    const_param++;\n-\t}\n-      if (const_param == 0)\n-\tcontinue;\n-      VARRAY_GENERIC_PTR_INIT (replace_trees, const_param, \"replace_trees\");\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t  if (lat->type == IPA_CONST_VALUE)\n+\t\t  || gimple_default_def (DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t\t\t parm_tree)))\n \t    {\n-\t      parm_tree = ipa_get_ith_param (info, i);\n \t      replace_param =\n \t\tipcp_create_replace_map (parm_tree, lat);\n \t      VARRAY_PUSH_GENERIC_PTR (replace_trees, replace_param);\n \t    }\n \t}\n+\n       /* Compute how many callers node has.  */\n       node_callers = 0;\n       for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n \tnode_callers++;\n       redirect_callers = VEC_alloc (cgraph_edge_p, heap, node_callers);\n       for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n \tVEC_quick_push (cgraph_edge_p, redirect_callers, cs);\n+\n       /* Redirecting all the callers of the node to the\n          new versioned node.  */\n       node1 =\n@@ -920,15 +1069,36 @@ ipcp_insert_stage (void)\n       if (node1 == NULL)\n \tcontinue;\n       if (dump_file)\n-\tfprintf (dump_file, \"versioned function %s\\n\",\n-\t\t cgraph_node_name (node));\n+\tfprintf (dump_file, \"versioned function %s with growth %i, overall %i\\n\",\n+\t\t cgraph_node_name (node), (int)growth, (int)new_insns);\n       ipcp_init_cloned_node (node, node1);\n+\n       /* We've possibly introduced direct calls.  */\n       ipcp_update_cloned_node (node1);\n \n       if (dump_file)\n \tdump_function_to_file (node1->decl, dump_file, dump_flags);\n+\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+        if (cs->callee->aux)\n+\t  {\n+\t    fibheap_delete_node (heap, (fibnode_t) cs->callee->aux);\n+\t    cs->callee->aux = fibheap_insert (heap,\n+\t    \t\t\t\t      ipcp_estimate_cloning_cost (cs->callee),\n+\t\t\t\t\t      cs->callee);\n+\t  }\n+    }\n+\n+  while (!fibheap_empty (heap))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"skipping function %s\\n\",\n+\t\t cgraph_node_name (node));\n+      node = (struct cgraph_node *) fibheap_extract_min (heap);\n+      node->aux = NULL;\n     }\n+  fibheap_delete (heap);\n+  BITMAP_FREE (dead_nodes);\n   ipcp_update_callgraph ();\n   ipcp_update_profiling ();\n }"}, {"sha": "8dd1cf48eb50e432bf9c65238d2a70fe4c1a3d8f", "filename": "gcc/params.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "patch": "@@ -193,6 +193,10 @@ DEFPARAM(PARAM_INLINE_UNIT_GROWTH,\n \t \"inline-unit-growth\",\n \t \"how much can given compilation unit grow because of the inlining (in percent)\",\n \t 30, 0, 0)\n+DEFPARAM(PARAM_IPCP_UNIT_GROWTH,\n+\t \"ipcp-unit-growth\",\n+\t \"how much can given compilation unit grow because of the interprocedural constant propagation (in percent)\",\n+\t 10, 0, 0)\n DEFPARAM(PARAM_INLINE_CALL_COST,\n \t \"inline-call-cost\",\n \t \"expense of call operation relative to ordinary arithmetic operations\","}, {"sha": "7c63b60d1185677bd98346652bd4971bedc39a17", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "patch": "@@ -1,3 +1,9 @@\n+2008-08-24  Jan Hubicka <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/ipacost-1.c: New testcase.\n+\t* gcc.dg/ipa/ipacost-2.c: New testcase.\n+\t* gcc.dg/ipa/ipa-7.c: Update template.\n+\n 2008-08-24  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/37201"}, {"sha": "0005057047db154087de8e4ae968228913b39fb4", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e45130d9933ee9f3c2a6e7571985e6667a0f8fd/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-7.c?ref=5e45130d9933ee9f3c2a6e7571985e6667a0f8fd", "patch": "@@ -25,7 +25,7 @@ int main ()\n \n \n /* { dg-final { scan-ipa-dump-times \"versioned function\" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"propagating const\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"replacing param with const\" 1 \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */\n \n "}]}