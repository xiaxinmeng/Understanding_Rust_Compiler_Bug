{"sha": "a56e2f69fede451499cfcbb58bab7687e4b1643a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2ZTJmNjlmZWRlNDUxNDk5Y2ZjYmI1OGJhYjc2ODdlNGIxNjQzYQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-04-18T05:17:26Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-04-18T05:17:26Z"}, "message": "[PR c++/80290] recycle tinst garbage sooner\n\ntinst_level objects are created during template instantiation, and\nthey're most often quite short-lived, but since there's no intervening\ngarbage collection, they accumulate throughout the pass while most by\nfar could be recycled after a short while.  The original testcase in\nPR80290, for example, creates almost 55 million tinst_level objects,\nall but 10 thousand of them without intervening GC, but we don't need\nmore than 284 of them live at a time.\n\nFurthermore, in many cases, TREE_LIST objects are created to stand for\nthe decl in tinst_level.  In most cases, those can be recycled as soon\nas the tinst_level object is recycled; in some relatively common\ncases, they are modified and reused in up to 3 tinst_level objects.\nIn the same testcase, TREE_LISTs are used in all but 3 thousand of the\ntinst_level objects, and we don't need more than 89 tinst_level\nobjects with TREE_LISTs live at a time.  Furthermore, all but 2\nthousand of those are created without intervening GC.\n\nThis patch arranges for tinst_level objects to be refcounted (I've\nseen as many as 20 live references to a single tinst_level object in\nmy testing), and for pending_template, tinst_level and TREE_LIST\nobjects that can be recycled to be added to freelists; that's much\nfaster than ggc_free()ing them and reallocating them shortly\nthereafter.  In fact, the introduction of such freelists is what makes\nthis entire patch lighter-weight, when it comes to memory use, and\nfaster.  With refcounting alone, the total memory footprint was still\nabout the same, and we spent more time.\n\nIn order to further reduce memory use, I've arranged for us to create\nTREE_LISTs lazily, only at points that really need them (when printing\nerror messages).  This grows tinst_level by an additional pointer, but\nsince a TREE_LIST holds a lot more than an extra pointer, and\ntinst_levels with TREE_LISTs used to be allocated tens of thousands of\ntimes more often than plain decl ones, we still save memory overall.\n\nI was still not quite happy about growing memory use in cases that\nused template classes but not template overload resolution, so I\nchanged the type of the errors field to unsigned short, from int.\nWith that change, in_system_header_p and refcount move into the same\nword or half-word that used to hold errors, releasing a full word,\nbringing tinst_level back to its original size, now without any\npadding.\n\nThe errors field is only used to test whether we've had any errors\nsince the expansion of some template, to skip the expansion of further\ntemplates.  If we get 2^16 errors or more, it is probably reasonable\nto refrain from expanding further templates, even if we would expand\nthem before this change.\n\nWith these changes, compile time for the original testcase at -O0,\nwith default checking enabled, is cut down by some 3.7%, total GCable\nmemory allocation is cut down by almost 20%, and total memory use (as\nreported by GNU time as maxresident) is cut down by slightly over 15%.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/80290\n\t* cp-tree.h (struct tinst_level): Split decl into tldcl and\n\ttargs.  Add private split_list_p, tree_list_p, and not_list_p\n\tinline const predicates; to_list private member function\n\tdeclaration; free public member function declaration; list_p,\n\tget_node and maybe_get_node accessors, and refcount data\n\tmember.  Narrow errors to unsigned short.\n\t* error.c (print_instantiation_full_context): Use new\n\taccessors.\n\t(print_instantiation_partial_context_line): Likewise.  Drop\n\tconst from tinst_level-typed parameter.\n\t* mangle.c (mangle_decl_string): Likewise.\n\t* pt.c (freelist): New template class.\n\t(tree_list_freelist_head): New var.\n\t(tree_list_freelist): New fn, along with specializations.\n\t(tinst_level_freelist_head): New var.\n\t(pending_template_freelist_head): Likewise.\n\t(tinst_level_freelist, pending_template_freelist): New fns.\n\t(tinst_level::to_list, tinst_level::free): Define.\n\t(inc_refcount_use, dec_refcount_use): New fns for tinst_level.\n\t(set_refcount_ptr): New template fn.\n\t(add_pending_template): Adjust for refcounting, freelists and\n\tnew accessors.\n\t(neglectable_inst_p): Take a NULL d as a non-DECL.\n\t(limit_bad_template_recursion): Use new accessors.\n\t(push_tinst_level): New overload to create the list.\n\t(push_tinst_level_loc): Make it static, split decl into two\n\targs, adjust tests and initialization to cope with split\n\tlists, use freelist, adjust for refcounting.\n\t(push_tinst_level_loc): New wrapper with the old interface.\n\t(pop_tinst_level): Adjust for refcounting.\n\t(record_last_problematic_instantiation): Likewise.\n\t(reopen_tinst_level): Likewise.  Use new accessors.\n\t(instantiate_alias_template): Adjust for split list.\n\t(fn_type_unification): Likewise.\n\t(get_partial_spec_bindings): Likewise.\n\t(instantiate_pending_templates): Use new accessors.  Adjust\n\tfor refcount.  Release pending_template to freelist.\n\t(instantiating_current_function_p): Use new accessors.\n\nFrom-SVN: r259457", "tree": {"sha": "8350fc400a1d7b2712735fcf9bcbd4bd6572fe22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8350fc400a1d7b2712735fcf9bcbd4bd6572fe22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a56e2f69fede451499cfcbb58bab7687e4b1643a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56e2f69fede451499cfcbb58bab7687e4b1643a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56e2f69fede451499cfcbb58bab7687e4b1643a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56e2f69fede451499cfcbb58bab7687e4b1643a/comments", "author": null, "committer": null, "parents": [{"sha": "e66e5d5f11876a73295712e038ba8c8d1c660499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66e5d5f11876a73295712e038ba8c8d1c660499", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66e5d5f11876a73295712e038ba8c8d1c660499"}], "stats": {"total": 524, "additions": 444, "deletions": 80}, "files": [{"sha": "ff6f4121723ab26dab44b033cd6d0422cefa140f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a56e2f69fede451499cfcbb58bab7687e4b1643a", "patch": "@@ -1,3 +1,45 @@\n+2018-04-18  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/80290\n+\t* cp-tree.h (struct tinst_level): Split decl into tldcl and\n+\ttargs.  Add private split_list_p, tree_list_p, and not_list_p\n+\tinline const predicates; to_list private member function\n+\tdeclaration; free public member function declaration; list_p,\n+\tget_node and maybe_get_node accessors, and refcount data\n+\tmember.  Narrow errors to unsigned short.\n+\t* error.c (print_instantiation_full_context): Use new\n+\taccessors.\n+\t(print_instantiation_partial_context_line): Likewise.  Drop\n+\tconst from tinst_level-typed parameter.\n+\t* mangle.c (mangle_decl_string): Likewise.\n+\t* pt.c (freelist): New template class.\n+\t(tree_list_freelist_head): New var.\n+\t(tree_list_freelist): New fn, along with specializations.\n+\t(tinst_level_freelist_head): New var.\n+\t(pending_template_freelist_head): Likewise.\n+\t(tinst_level_freelist, pending_template_freelist): New fns.\n+\t(tinst_level::to_list, tinst_level::free): Define.\n+\t(inc_refcount_use, dec_refcount_use): New fns for tinst_level.\n+\t(set_refcount_ptr): New template fn.\n+\t(add_pending_template): Adjust for refcounting, freelists and\n+\tnew accessors.\n+\t(neglectable_inst_p): Take a NULL d as a non-DECL.\n+\t(limit_bad_template_recursion): Use new accessors.\n+\t(push_tinst_level): New overload to create the list.\n+\t(push_tinst_level_loc): Make it static, split decl into two\n+\targs, adjust tests and initialization to cope with split\n+\tlists, use freelist, adjust for refcounting.\n+\t(push_tinst_level_loc): New wrapper with the old interface.\n+\t(pop_tinst_level): Adjust for refcounting.\n+\t(record_last_problematic_instantiation): Likewise.\n+\t(reopen_tinst_level): Likewise.  Use new accessors.\n+\t(instantiate_alias_template): Adjust for split list.\n+\t(fn_type_unification): Likewise.\n+\t(get_partial_spec_bindings): Likewise.\n+\t(instantiate_pending_templates): Use new accessors.  Adjust\n+\tfor refcount.  Release pending_template to freelist.\n+\t(instantiating_current_function_p): Use new accessors.\n+\n 2018-04-16  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR c++/85039"}, {"sha": "7031c79b35dbf22a11fa8a2c9db571fafabf1136", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a56e2f69fede451499cfcbb58bab7687e4b1643a", "patch": "@@ -5870,19 +5870,71 @@ struct GTY((chain_next (\"%h.next\"))) tinst_level {\n   /* The immediately deeper level in the chain.  */\n   struct tinst_level *next;\n \n-  /* The original node.  Can be either a DECL (for a function or static\n-     data member) or a TYPE (for a class), depending on what we were\n-     asked to instantiate.  */\n-  tree decl;\n+  /* The original node.  TLDCL can be a DECL (for a function or static\n+     data member), a TYPE (for a class), depending on what we were\n+     asked to instantiate, or a TREE_LIST with the template as PURPOSE\n+     and the template args as VALUE, if we are substituting for\n+     overload resolution.  In all these cases, TARGS is NULL.\n+     However, to avoid creating TREE_LIST objects for substitutions if\n+     we can help, we store PURPOSE and VALUE in TLDCL and TARGS,\n+     respectively.  So TLDCL stands for TREE_LIST or DECL (the\n+     template is a DECL too), whereas TARGS stands for the template\n+     arguments.  */\n+  tree tldcl, targs;\n+\n+ private:\n+  /* Return TRUE iff the original node is a split list.  */\n+  bool split_list_p () const { return targs; }\n+\n+  /* Return TRUE iff the original node is a TREE_LIST object.  */\n+  bool tree_list_p () const\n+  {\n+    return !split_list_p () && TREE_CODE (tldcl) == TREE_LIST;\n+  }\n+\n+  /* Return TRUE iff the original node is not a list, split or not.  */\n+  bool not_list_p () const\n+  {\n+    return !split_list_p () && !tree_list_p ();\n+  }\n+\n+  /* Convert (in place) the original node from a split list to a\n+     TREE_LIST.  */\n+  tree to_list ();\n+\n+ public:\n+  /* Release storage for OBJ and node, if it's a TREE_LIST.  */\n+  static void free(tinst_level *obj);\n+\n+  /* Return TRUE iff the original node is a list, split or not.  */\n+  bool list_p () const { return !not_list_p (); }\n+\n+  /* Return the original node; if it's a split list, make it a\n+     TREE_LIST first, so that it can be returned as a single tree\n+     object.  */\n+  tree get_node () {\n+    if (!split_list_p ()) return tldcl;\n+    else return to_list ();\n+  }\n+\n+  /* Return the original node if it's a DECL or a TREE_LIST, but do\n+     NOT convert a split list to a TREE_LIST: return NULL instead.  */\n+  tree maybe_get_node () const {\n+    if (!split_list_p ()) return tldcl;\n+    else return NULL_TREE;\n+  }\n \n   /* The location where the template is instantiated.  */\n   location_t locus;\n \n   /* errorcount+sorrycount when we pushed this level.  */\n-  int errors;\n+  unsigned short errors;\n \n   /* True if the location is in a system header.  */\n   bool in_system_header_p;\n+\n+  /* Count references to this object.  */\n+  unsigned char refcount;\n };\n \n bool decl_spec_seq_has_spec_p (const cp_decl_specifier_seq *, cp_decl_spec);"}, {"sha": "95b8b84f34abe65777e3ead3f6e2f5075e872689", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a56e2f69fede451499cfcbb58bab7687e4b1643a", "patch": "@@ -3457,11 +3457,11 @@ print_instantiation_full_context (diagnostic_context *context)\n   if (p)\n     {\n       pp_verbatim (context->printer,\n-\t\t   TREE_CODE (p->decl) == TREE_LIST\n+\t\t   p->list_p ()\n \t\t   ? _(\"%s: In substitution of %qS:\\n\")\n \t\t   : _(\"%s: In instantiation of %q#D:\\n\"),\n \t\t   LOCATION_FILE (location),\n-\t\t   p->decl);\n+\t\t   p->get_node ());\n \n       location = p->locus;\n       p = p->next;\n@@ -3475,7 +3475,7 @@ print_instantiation_full_context (diagnostic_context *context)\n \n static void\n print_instantiation_partial_context_line (diagnostic_context *context,\n-\t\t\t\t\t  const struct tinst_level *t,\n+\t\t\t\t\t  struct tinst_level *t,\n \t\t\t\t\t  location_t loc, bool recursive_p)\n {\n   if (loc == UNKNOWN_LOCATION)\n@@ -3492,18 +3492,18 @@ print_instantiation_partial_context_line (diagnostic_context *context,\n \n   if (t != NULL)\n     {\n-      if (TREE_CODE (t->decl) == TREE_LIST)\n+      if (t->list_p ())\n \tpp_verbatim (context->printer,\n \t\t     recursive_p\n \t\t     ? _(\"recursively required by substitution of %qS\\n\")\n \t\t     : _(\"required by substitution of %qS\\n\"),\n-\t\t     t->decl);\n+\t\t     t->get_node ());\n       else\n \tpp_verbatim (context->printer,\n \t\t     recursive_p\n \t\t     ? _(\"recursively required from %q#D\\n\")\n \t\t     : _(\"required from %q#D\\n\"),\n-\t\t     t->decl);\n+\t\t     t->get_node ());\n     }\n   else\n     {"}, {"sha": "2f65709d7d8c05342febf8e2ce515ead81f7990c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=a56e2f69fede451499cfcbb58bab7687e4b1643a", "patch": "@@ -3777,7 +3777,7 @@ mangle_decl_string (const tree decl)\n   if (DECL_LANG_SPECIFIC (decl) && DECL_USE_TEMPLATE (decl))\n     {\n       struct tinst_level *tl = current_instantiation ();\n-      if ((!tl || tl->decl != decl)\n+      if ((!tl || tl->maybe_get_node () != decl)\n \t  && push_tinst_level (decl))\n \t{\n \t  template_p = true;"}, {"sha": "79563dfa5334b128c412e09180caf4089f2eb497", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 338, "deletions": 68, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56e2f69fede451499cfcbb58bab7687e4b1643a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a56e2f69fede451499cfcbb58bab7687e4b1643a", "patch": "@@ -50,7 +50,8 @@ typedef int (*tree_fn_t) (tree, void*);\n /* The PENDING_TEMPLATES is a TREE_LIST of templates whose\n    instantiations have been deferred, either because their definitions\n    were not yet available, or because we were putting off doing the work.  */\n-struct GTY ((chain_next (\"%h.next\"))) pending_template {\n+struct GTY ((chain_next (\"%h.next\"))) pending_template\n+{\n   struct pending_template *next;\n   struct tinst_level *tinst;\n };\n@@ -8731,6 +8732,269 @@ comp_template_args_porder (tree oargs, tree nargs)\n   return comp_template_args (oargs, nargs, NULL, NULL, true);\n }\n \n+/* Implement a freelist interface for objects of type T.\n+\n+   Head is a separate object, rather than a regular member, so that we\n+   can define it as a GTY deletable pointer, which is highly\n+   desirable.  A data member could be declared that way, but then the\n+   containing object would implicitly get GTY((user)), which would\n+   prevent us from instantiating freelists as global objects.\n+   Although this way we can create freelist global objects, they're\n+   such thin wrappers that instantiating temporaries at every use\n+   loses nothing and saves permanent storage for the freelist object.\n+\n+   Member functions next, anew, poison and reinit have default\n+   implementations that work for most of the types we're interested\n+   in, but if they don't work for some type, they should be explicitly\n+   specialized.  See the comments before them for requirements, and\n+   the example specializations for the tree_list_freelist.  */\n+template <typename T>\n+class freelist\n+{\n+  /* Return the next object in a chain.  We could just do type\n+     punning, but if we access the object with its underlying type, we\n+     avoid strict-aliasing trouble.  This needs only work between\n+     poison and reinit.  */\n+  static T *&next (T *obj) { return obj->next; }\n+\n+  /* Return a newly allocated, uninitialized or minimally-initialized\n+     object of type T.  Any initialization performed by anew should\n+     either remain across the life of the object and the execution of\n+     poison, or be redone by reinit.  */\n+  static T *anew () { return ggc_alloc<T> (); }\n+\n+  /* Optionally scribble all over the bits holding the object, so that\n+     they become (mostly?) uninitialized memory.  This is called while\n+     preparing to make the object part of the free list.  */\n+  static void poison (T *obj) {\n+    T *p ATTRIBUTE_UNUSED = obj;\n+    T **q ATTRIBUTE_UNUSED = &next (obj);\n+\n+#ifdef ENABLE_GC_CHECKING\n+    /* Poison the data, to indicate the data is garbage.  */\n+    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (p, sizeof (*p)));\n+    memset (p, 0xa5, sizeof (*p));\n+#endif\n+    /* Let valgrind know the object is free.  */\n+    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (p, sizeof (*p)));\n+\n+    /* Let valgrind know the next portion of the object is available,\n+       but uninitialized.  */\n+    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (q, sizeof (*q)));\n+  }\n+\n+  /* Bring an object that underwent at least one lifecycle after anew\n+     and before the most recent free and poison, back to a usable\n+     state, reinitializing whatever is needed for it to be\n+     functionally equivalent to an object just allocated and returned\n+     by anew.  This may poison or clear the next field, used by\n+     freelist housekeeping after poison was called.  */\n+  static void reinit (T *obj) {\n+    T **q ATTRIBUTE_UNUSED = &next (obj);\n+\n+#ifdef ENABLE_GC_CHECKING\n+    memset (q, 0xa5, sizeof (*q));\n+#endif\n+    /* Let valgrind know the entire object is available, but\n+       uninitialized.  */\n+    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (obj, sizeof (*obj)));\n+  }\n+\n+  /* Reference a GTY-deletable pointer that points to the first object\n+     in the free list proper.  */\n+  T *&head;\n+public:\n+  /* Construct a freelist object chaining objects off of HEAD.  */\n+  freelist (T *&head) : head(head) {}\n+\n+  /* Add OBJ to the free object list.  The former head becomes OBJ's\n+     successor.  */\n+  void free (T *obj)\n+  {\n+    poison (obj);\n+    next (obj) = head;\n+    head = obj;\n+  }\n+\n+  /* Take an object from the free list, if one is available, or\n+     allocate a new one.  Objects taken from the free list should be\n+     regarded as filled with garbage, except for bits that are\n+     configured to be preserved across free and alloc.  */\n+  T *alloc ()\n+  {\n+    if (head)\n+      {\n+\tT *obj = head;\n+\thead = next (head);\n+\treinit (obj);\n+\treturn obj;\n+      }\n+    else\n+      return anew ();\n+  }\n+};\n+\n+/* Explicitly specialize the interfaces for freelist<tree_node>: we\n+   want to allocate a TREE_LIST using the usual interface, and ensure\n+   TREE_CHAIN remains functional.  Alas, we have to duplicate a bit of\n+   build_tree_list logic in reinit, so this could go out of sync.  */\n+template <>\n+inline tree &\n+freelist<tree_node>::next (tree obj)\n+{\n+  return TREE_CHAIN (obj);\n+}\n+template <>\n+inline tree\n+freelist<tree_node>::anew ()\n+{\n+  return build_tree_list (NULL, NULL);\n+}\n+template <>\n+inline void\n+freelist<tree_node>::poison (tree obj ATTRIBUTE_UNUSED)\n+{\n+  int size ATTRIBUTE_UNUSED = sizeof (tree_list);\n+  tree p ATTRIBUTE_UNUSED = obj;\n+  tree_base *b ATTRIBUTE_UNUSED = &obj->base;\n+  tree *q ATTRIBUTE_UNUSED = &next (obj);\n+\n+#ifdef ENABLE_GC_CHECKING\n+  gcc_checking_assert (TREE_CODE (obj) == TREE_LIST);\n+\n+  /* Poison the data, to indicate the data is garbage.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (p, size));\n+  memset (p, 0xa5, size);\n+#endif\n+  /* Let valgrind know the object is free.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (p, size));\n+  /* But we still want to use the TREE_CODE and TREE_CHAIN parts.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (b, sizeof (*b)));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (q, sizeof (*q)));\n+\n+#ifdef ENABLE_GC_CHECKING\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (b, sizeof (*b)));\n+  /* Keep TREE_CHAIN functional.  */\n+  TREE_SET_CODE (obj, TREE_LIST);\n+#else\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (b, sizeof (*b)));\n+#endif\n+}\n+template <>\n+inline void\n+freelist<tree_node>::reinit (tree obj ATTRIBUTE_UNUSED)\n+{\n+  tree_base *b ATTRIBUTE_UNUSED = &obj->base;\n+\n+#ifdef ENABLE_GC_CHECKING\n+  gcc_checking_assert (TREE_CODE (obj) == TREE_LIST);\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (obj, sizeof (tree_list)));\n+  memset (obj, 0, sizeof (tree_list));\n+#endif\n+\n+  /* Let valgrind know the entire object is available, but\n+     uninitialized.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (obj, sizeof (tree_list)));\n+\n+#ifdef ENABLE_GC_CHECKING\n+  TREE_SET_CODE (obj, TREE_LIST);\n+#else\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (b, sizeof (*b)));\n+#endif\n+}\n+\n+/* Point to the first object in the TREE_LIST freelist.  */\n+static GTY((deletable)) tree tree_list_freelist_head;\n+/* Return the/an actual TREE_LIST freelist.  */\n+static inline freelist<tree_node>\n+tree_list_freelist ()\n+{\n+  return tree_list_freelist_head;\n+}\n+\n+/* Point to the first object in the tinst_level freelist.  */\n+static GTY((deletable)) tinst_level *tinst_level_freelist_head;\n+/* Return the/an actual tinst_level freelist.  */\n+static inline freelist<tinst_level>\n+tinst_level_freelist ()\n+{\n+  return tinst_level_freelist_head;\n+}\n+\n+/* Point to the first object in the pending_template freelist.  */\n+static GTY((deletable)) pending_template *pending_template_freelist_head;\n+/* Return the/an actual pending_template freelist.  */\n+static inline freelist<pending_template>\n+pending_template_freelist ()\n+{\n+  return pending_template_freelist_head;\n+}\n+\n+/* Build the TREE_LIST object out of a split list, store it\n+   permanently, and return it.  */\n+tree\n+tinst_level::to_list ()\n+{\n+  gcc_assert (split_list_p ());\n+  tree ret = tree_list_freelist ().alloc ();\n+  TREE_PURPOSE (ret) = tldcl;\n+  TREE_VALUE (ret) = targs;\n+  tldcl = ret;\n+  targs = NULL;\n+  gcc_assert (tree_list_p ());\n+  return ret;\n+}\n+\n+/* Increment OBJ's refcount.  */\n+static tinst_level *\n+inc_refcount_use (tinst_level *obj)\n+{\n+  if (obj)\n+    {\n+      ++obj->refcount;\n+      gcc_assert (obj->refcount != 0);\n+    }\n+  return obj;\n+}\n+\n+/* Release storage for OBJ and node, if it's a TREE_LIST.  */\n+void\n+tinst_level::free (tinst_level *obj)\n+{\n+  if (obj->tree_list_p ())\n+    tree_list_freelist ().free (obj->get_node ());\n+  tinst_level_freelist ().free (obj);\n+}\n+\n+/* Decrement OBJ's refcount.  If it reaches zero, release OBJ's DECL\n+   and OBJ, and start over with the tinst_level object that used to be\n+   referenced by OBJ's NEXT.  */\n+static void\n+dec_refcount_use (tinst_level *obj)\n+{\n+  while (obj && !--obj->refcount)\n+    {\n+      gcc_assert (obj->refcount+1 != 0);\n+      tinst_level *next = obj->next;\n+      tinst_level::free (obj);\n+      obj = next;\n+    }\n+}\n+\n+/* Modify PTR so that it points to OBJ, adjusting the refcounts of OBJ\n+   and of the former PTR.  Omitting the second argument is equivalent\n+   to passing (T*)NULL; this is allowed because passing the\n+   zero-valued integral constant NULL confuses type deduction and/or\n+   overload resolution.  */\n+template <typename T>\n+static void\n+set_refcount_ptr (T *& ptr, T *obj = NULL)\n+{\n+  T *save = ptr;\n+  ptr = inc_refcount_use (obj);\n+  dec_refcount_use (save);\n+}\n+\n static void\n add_pending_template (tree d)\n {\n@@ -8746,14 +9010,17 @@ add_pending_template (tree d)\n   /* We are called both from instantiate_decl, where we've already had a\n      tinst_level pushed, and instantiate_template, where we haven't.\n      Compensate.  */\n-  level = !current_tinst_level || current_tinst_level->decl != d;\n+  gcc_assert (TREE_CODE (d) != TREE_LIST);\n+  level = !current_tinst_level\n+    || current_tinst_level->maybe_get_node () != d;\n \n   if (level)\n     push_tinst_level (d);\n \n-  pt = ggc_alloc<pending_template> ();\n+  pt = pending_template_freelist ().alloc ();\n   pt->next = NULL;\n-  pt->tinst = current_tinst_level;\n+  pt->tinst = NULL;\n+  set_refcount_ptr (pt->tinst, current_tinst_level);\n   if (last_pending_template)\n     last_pending_template->next = pt;\n   else\n@@ -9810,7 +10077,7 @@ uses_outer_template_parms (tree decl)\n static inline bool\n neglectable_inst_p (tree d)\n {\n-  return (DECL_P (d)\n+  return (d && DECL_P (d)\n \t  && !undeduced_auto_decl (d)\n \t  && !(TREE_CODE (d) == FUNCTION_DECL ? DECL_DECLARED_CONSTEXPR_P (d)\n \t       : decl_maybe_constant_var_p (d)));\n@@ -9828,7 +10095,7 @@ limit_bad_template_recursion (tree decl)\n     return false;\n \n   for (; lev; lev = lev->next)\n-    if (neglectable_inst_p (lev->decl))\n+    if (neglectable_inst_p (lev->maybe_get_node ()))\n       break;\n \n   return (lev && errs > lev->errors);\n@@ -9840,20 +10107,11 @@ int depth_reached;\n \n static GTY(()) struct tinst_level *last_error_tinst_level;\n \n-/* We're starting to instantiate D; record the template instantiation context\n-   for diagnostics and to restore it later.  */\n-\n-bool\n-push_tinst_level (tree d)\n-{\n-  return push_tinst_level_loc (d, input_location);\n-}\n-\n /* We're starting to instantiate D; record the template instantiation context\n    at LOC for diagnostics and to restore it later.  */\n \n-bool\n-push_tinst_level_loc (tree d, location_t loc)\n+static bool\n+push_tinst_level_loc (tree tldcl, tree targs, location_t loc)\n {\n   struct tinst_level *new_level;\n \n@@ -9871,23 +10129,26 @@ push_tinst_level_loc (tree d, location_t loc)\n   /* If the current instantiation caused problems, don't let it instantiate\n      anything else.  Do allow deduction substitution and decls usable in\n      constant expressions.  */\n-  if (limit_bad_template_recursion (d))\n+  if (!targs && limit_bad_template_recursion (tldcl))\n     return false;\n \n   /* When not -quiet, dump template instantiations other than functions, since\n      announce_function will take care of those.  */\n-  if (!quiet_flag\n-      && TREE_CODE (d) != TREE_LIST\n-      && TREE_CODE (d) != FUNCTION_DECL)\n-    fprintf (stderr, \" %s\", decl_as_string (d, TFF_DECL_SPECIFIERS));\n-\n-  new_level = ggc_alloc<tinst_level> ();\n-  new_level->decl = d;\n+  if (!quiet_flag && !targs\n+      && TREE_CODE (tldcl) != TREE_LIST\n+      && TREE_CODE (tldcl) != FUNCTION_DECL)\n+    fprintf (stderr, \" %s\", decl_as_string (tldcl, TFF_DECL_SPECIFIERS));\n+\n+  new_level = tinst_level_freelist ().alloc ();\n+  new_level->tldcl = tldcl;\n+  new_level->targs = targs;\n   new_level->locus = loc;\n   new_level->errors = errorcount+sorrycount;\n   new_level->in_system_header_p = in_system_header_at (input_location);\n-  new_level->next = current_tinst_level;\n-  current_tinst_level = new_level;\n+  new_level->next = NULL;\n+  new_level->refcount = 0;\n+  set_refcount_ptr (new_level->next, current_tinst_level);\n+  set_refcount_ptr (current_tinst_level, new_level);\n \n   ++tinst_depth;\n   if (GATHER_STATISTICS && (tinst_depth > depth_reached))\n@@ -9896,6 +10157,34 @@ push_tinst_level_loc (tree d, location_t loc)\n   return true;\n }\n \n+/* We're starting substitution of TMPL<ARGS>; record the template\n+   substitution context for diagnostics and to restore it later.  */\n+\n+static bool\n+push_tinst_level (tree tmpl, tree args)\n+{\n+  return push_tinst_level_loc (tmpl, args, input_location);\n+}\n+\n+/* We're starting to instantiate D; record INPUT_LOCATION and the\n+   template instantiation context for diagnostics and to restore it\n+   later.  */\n+\n+bool\n+push_tinst_level (tree d)\n+{\n+  return push_tinst_level_loc (d, input_location);\n+}\n+\n+/* Likewise, but record LOC as the program location.  */\n+\n+bool\n+push_tinst_level_loc (tree d, location_t loc)\n+{\n+  gcc_assert (TREE_CODE (d) != TREE_LIST);\n+  return push_tinst_level_loc (d, NULL, loc);\n+}\n+\n /* We're done instantiating this template; return to the instantiation\n    context.  */\n \n@@ -9905,7 +10194,7 @@ pop_tinst_level (void)\n   /* Restore the filename and line number stashed away when we started\n      this instantiation.  */\n   input_location = current_tinst_level->locus;\n-  current_tinst_level = current_tinst_level->next;\n+  set_refcount_ptr (current_tinst_level, current_tinst_level->next);\n   --tinst_depth;\n }\n \n@@ -9922,11 +10211,11 @@ reopen_tinst_level (struct tinst_level *level)\n   for (t = level; t; t = t->next)\n     ++tinst_depth;\n \n-  current_tinst_level = level;\n+  set_refcount_ptr (current_tinst_level, level);\n   pop_tinst_level ();\n   if (current_tinst_level)\n     current_tinst_level->errors = errorcount+sorrycount;\n-  return level->decl;\n+  return level->maybe_get_node ();\n }\n \n /* Returns the TINST_LEVEL which gives the original instantiation\n@@ -18983,16 +19272,10 @@ instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n static tree\n instantiate_alias_template (tree tmpl, tree args, tsubst_flags_t complain)\n {\n-  struct pending_template *old_last_pend = last_pending_template;\n-  struct tinst_level *old_error_tinst = last_error_tinst_level;\n   if (tmpl == error_mark_node || args == error_mark_node)\n     return error_mark_node;\n-  tree tinst = build_tree_list (tmpl, args);\n-  if (!push_tinst_level (tinst))\n-    {\n-      ggc_free (tinst);\n-      return error_mark_node;\n-    }\n+  if (!push_tinst_level (tmpl, args))\n+    return error_mark_node;\n \n   args =\n     coerce_innermost_template_parms (DECL_TEMPLATE_PARMS (tmpl),\n@@ -19002,11 +19285,6 @@ instantiate_alias_template (tree tmpl, tree args, tsubst_flags_t complain)\n \n   tree r = instantiate_template (tmpl, args, complain);\n   pop_tinst_level ();\n-  /* We can't free this if a pending_template entry or last_error_tinst_level\n-     is pointing at it.  */\n-  if (last_pending_template == old_last_pend\n-      && last_error_tinst_level == old_error_tinst)\n-    ggc_free (tinst);\n \n   return r;\n }\n@@ -19096,15 +19374,12 @@ fn_type_unification (tree fn,\n   tsubst_flags_t complain = (explain_p ? tf_warning_or_error : tf_none);\n   bool ok;\n   static int deduction_depth;\n-  struct pending_template *old_last_pend = last_pending_template;\n-  struct tinst_level *old_error_tinst = last_error_tinst_level;\n \n   tree orig_fn = fn;\n   if (flag_new_inheriting_ctors)\n     fn = strip_inheriting_ctors (fn);\n \n   tree tparms = DECL_INNERMOST_TEMPLATE_PARMS (fn);\n-  tree tinst;\n   tree r = error_mark_node;\n \n   tree full_targs = targs;\n@@ -19130,7 +19405,6 @@ fn_type_unification (tree fn,\n      This is, of course, not reentrant.  */\n   if (excessive_deduction_depth)\n     return error_mark_node;\n-  tinst = build_tree_list (fn, NULL_TREE);\n   ++deduction_depth;\n \n   gcc_assert (TREE_CODE (fn) == TEMPLATE_DECL);\n@@ -19223,8 +19497,7 @@ fn_type_unification (tree fn,\n             }\n         }\n \n-      TREE_VALUE (tinst) = explicit_targs;\n-      if (!push_tinst_level (tinst))\n+      if (!push_tinst_level (fn, explicit_targs))\n \t{\n \t  excessive_deduction_depth = true;\n \t  goto fail;\n@@ -19279,12 +19552,11 @@ fn_type_unification (tree fn,\n      callers must be ready to deal with unification failures in any\n      event.  */\n \n-  TREE_VALUE (tinst) = targs;\n   /* If we aren't explaining yet, push tinst context so we can see where\n      any errors (e.g. from class instantiations triggered by instantiation\n      of default template arguments) come from.  If we are explaining, this\n      context is redundant.  */\n-  if (!explain_p && !push_tinst_level (tinst))\n+  if (!explain_p && !push_tinst_level (fn, targs))\n     {\n       excessive_deduction_depth = true;\n       goto fail;\n@@ -19340,8 +19612,7 @@ fn_type_unification (tree fn,\n      the corresponding deduced argument values.  If the\n      substitution results in an invalid type, as described above,\n      type deduction fails.  */\n-  TREE_VALUE (tinst) = targs;\n-  if (!push_tinst_level (tinst))\n+  if (!push_tinst_level (fn, targs))\n     {\n       excessive_deduction_depth = true;\n       goto fail;\n@@ -19407,12 +19678,6 @@ fn_type_unification (tree fn,\n \texcessive_deduction_depth = false;\n     }\n \n-  /* We can't free this if a pending_template entry or last_error_tinst_level\n-     is pointing at it.  */\n-  if (last_pending_template == old_last_pend\n-      && last_error_tinst_level == old_error_tinst)\n-    ggc_free (tinst);\n-\n   return r;\n }\n \n@@ -22382,8 +22647,7 @@ get_partial_spec_bindings (tree tmpl, tree spec_tmpl, tree args)\n \treturn NULL_TREE;\n       }\n \n-  tree tinst = build_tree_list (spec_tmpl, deduced_args);\n-  if (!push_tinst_level (tinst))\n+  if (!push_tinst_level (spec_tmpl, deduced_args))\n     {\n       excessive_deduction_depth = true;\n       return NULL_TREE;\n@@ -23764,7 +24028,7 @@ instantiate_pending_templates (int retries)\n      to avoid infinite loop.  */\n   if (pending_templates && retries >= max_tinst_depth)\n     {\n-      tree decl = pending_templates->tinst->decl;\n+      tree decl = pending_templates->tinst->maybe_get_node ();\n \n       fatal_error (input_location,\n \t\t   \"template instantiation depth exceeds maximum of %d\"\n@@ -23827,16 +24091,21 @@ instantiate_pending_templates (int retries)\n \t    }\n \n \t  if (complete)\n-\t    /* If INSTANTIATION has been instantiated, then we don't\n-\t       need to consider it again in the future.  */\n-\t    *t = (*t)->next;\n+\t    {\n+\t      /* If INSTANTIATION has been instantiated, then we don't\n+\t\t need to consider it again in the future.  */\n+\t      struct pending_template *drop = *t;\n+\t      *t = (*t)->next;\n+\t      set_refcount_ptr (drop->tinst);\n+\t      pending_template_freelist ().free (drop);\n+\t    }\n \t  else\n \t    {\n \t      last = *t;\n \t      t = &(*t)->next;\n \t    }\n \t  tinst_depth = 0;\n-\t  current_tinst_level = NULL;\n+\t  set_refcount_ptr (current_tinst_level);\n \t}\n       last_pending_template = last;\n     }\n@@ -24084,7 +24353,7 @@ problematic_instantiation_changed (void)\n void\n record_last_problematic_instantiation (void)\n {\n-  last_error_tinst_level = current_tinst_level;\n+  set_refcount_ptr (last_error_tinst_level, current_tinst_level);\n }\n \n struct tinst_level *\n@@ -24100,7 +24369,8 @@ bool\n instantiating_current_function_p (void)\n {\n   return (current_instantiation ()\n-\t  && current_instantiation ()->decl == current_function_decl);\n+\t  && (current_instantiation ()->maybe_get_node ()\n+\t      == current_function_decl));\n }\n \n /* [temp.param] Check that template non-type parm TYPE is of an allowable"}]}