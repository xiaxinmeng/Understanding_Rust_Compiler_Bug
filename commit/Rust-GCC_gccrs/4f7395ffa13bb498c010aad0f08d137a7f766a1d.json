{"sha": "4f7395ffa13bb498c010aad0f08d137a7f766a1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY3Mzk1ZmZhMTNiYjQ5OGMwMTBhYWQwZjA4ZDEzN2E3Zjc2NmExZA==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2013-08-23T16:43:15Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2013-08-23T16:43:15Z"}, "message": "re PR fortran/57843 ([OOP] Type-bound assignment is resolved to non-polymorphic procedure call)\n\n2013-08-23  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/57843\n\t* interface.c (gfc_extend_assign): Look for type-bound assignment\n\tprocedures before non-typebound.\n\n\n2013-08-23  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/57843\n\t* gfortran.dg/typebound_assignment_7.f90: New.\n\nFrom-SVN: r201946", "tree": {"sha": "b5bdf33b142993fad36639f8c2878604acab85c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5bdf33b142993fad36639f8c2878604acab85c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f7395ffa13bb498c010aad0f08d137a7f766a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7395ffa13bb498c010aad0f08d137a7f766a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f7395ffa13bb498c010aad0f08d137a7f766a1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7395ffa13bb498c010aad0f08d137a7f766a1d/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf66452262a257dc3591df9b762f2b2b9162067f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf66452262a257dc3591df9b762f2b2b9162067f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf66452262a257dc3591df9b762f2b2b9162067f"}], "stats": {"total": 163, "additions": 115, "deletions": 48}, "files": [{"sha": "35f970ead81c4d8156eea8107e46dfc578e35e26", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4f7395ffa13bb498c010aad0f08d137a7f766a1d", "patch": "@@ -1,3 +1,9 @@\n+2013-08-23  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/57843\n+\t* interface.c (gfc_extend_assign): Look for type-bound assignment\n+\tprocedures before non-typebound.\n+\n 2013-08-23  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.c (gfc_conv_section_startstride): Move &loop->pre access"}, {"sha": "aa88b3c3fa67ff7692793e04b395ffef4b9e53c8", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=4f7395ffa13bb498c010aad0f08d137a7f766a1d", "patch": "@@ -3754,20 +3754,18 @@ gfc_extend_expr (gfc_expr *e)\n }\n \n \n-/* Tries to replace an assignment code node with a subroutine call to\n-   the subroutine associated with the assignment operator.  Return\n-   true if the node was replaced.  On false, no error is\n-   generated.  */\n+/* Tries to replace an assignment code node with a subroutine call to the\n+   subroutine associated with the assignment operator. Return true if the node\n+   was replaced. On false, no error is generated.  */\n \n bool\n gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n {\n   gfc_actual_arglist *actual;\n-  gfc_expr *lhs, *rhs;\n-  gfc_symbol *sym;\n-  const char *gname;\n-\n-  gname = NULL;\n+  gfc_expr *lhs, *rhs, *tb_base;\n+  gfc_symbol *sym = NULL;\n+  const char *gname = NULL;\n+  gfc_typebound_proc* tbo;\n \n   lhs = c->expr1;\n   rhs = c->expr2;\n@@ -3785,56 +3783,48 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n   actual->next = gfc_get_actual_arglist ();\n   actual->next->expr = rhs;\n \n-  sym = NULL;\n+  /* TODO: Ambiguity-check, see above for gfc_extend_expr.  */\n+\n+  /* See if we find a matching type-bound assignment.  */\n+  tbo = matching_typebound_op (&tb_base, actual, INTRINSIC_ASSIGN,\n+\t\t\t       NULL, &gname);\n+\n+  if (tbo)\n+    {\n+      /* Success: Replace the expression with a type-bound call.  */\n+      gcc_assert (tb_base);\n+      c->expr1 = gfc_get_expr ();\n+      build_compcall_for_operator (c->expr1, actual, tb_base, tbo, gname);\n+      c->expr1->value.compcall.assign = 1;\n+      c->expr1->where = c->loc;\n+      c->expr2 = NULL;\n+      c->op = EXEC_COMPCALL;\n+      return true;\n+    }\n \n+  /* See if we find an 'ordinary' (non-typebound) assignment procedure.  */\n   for (; ns; ns = ns->parent)\n     {\n       sym = gfc_search_interface (ns->op[INTRINSIC_ASSIGN], 1, &actual);\n       if (sym != NULL)\n \tbreak;\n     }\n \n-  /* TODO: Ambiguity-check, see above for gfc_extend_expr.  */\n-\n-  if (sym == NULL)\n+  if (sym)\n     {\n-      gfc_typebound_proc* tbo;\n-      gfc_expr* tb_base;\n-\n-      /* See if we find a matching type-bound assignment.  */\n-      tbo = matching_typebound_op (&tb_base, actual,\n-\t\t\t\t   INTRINSIC_ASSIGN, NULL, &gname);\n-\n-      /* If there is one, replace the expression with a call to it and\n-\t succeed.  */\n-      if (tbo)\n-\t{\n-\t  gcc_assert (tb_base);\n-\t  c->expr1 = gfc_get_expr ();\n-\t  build_compcall_for_operator (c->expr1, actual, tb_base, tbo, gname);\n-\t  c->expr1->value.compcall.assign = 1;\n-\t  c->expr1->where = c->loc;\n-\t  c->expr2 = NULL;\n-\t  c->op = EXEC_COMPCALL;\n-\n-\t  /* c is resolved from the caller, so no need to do it here.  */\n-\n-\t  return true;\n-\t}\n-\n-      free (actual->next);\n-      free (actual);\n-      return false;\n+      /* Success: Replace the assignment with the call.  */\n+      c->op = EXEC_ASSIGN_CALL;\n+      c->symtree = gfc_find_sym_in_symtree (sym);\n+      c->expr1 = NULL;\n+      c->expr2 = NULL;\n+      c->ext.actual = actual;\n+      return true;\n     }\n \n-  /* Replace the assignment with the call.  */\n-  c->op = EXEC_ASSIGN_CALL;\n-  c->symtree = gfc_find_sym_in_symtree (sym);\n-  c->expr1 = NULL;\n-  c->expr2 = NULL;\n-  c->ext.actual = actual;\n-\n-  return true;\n+  /* Failure: No assignment procedure found.  */\n+  free (actual->next);\n+  free (actual);\n+  return false;\n }\n \n "}, {"sha": "5d9c3bb70c8eea8b8c71029a548829b7fd502f3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f7395ffa13bb498c010aad0f08d137a7f766a1d", "patch": "@@ -1,3 +1,8 @@\n+2013-08-23  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/57843\n+\t* gfortran.dg/typebound_assignment_7.f90: New.\n+\n 2013-08-23  Jan Hubicka  <jh@suse.cz>\n \n \t* g++.dg/ipa/devirt-13.C: New testcase."}, {"sha": "2c5b837d67022b36b52ca68d0e2c19ceea5913b8", "filename": "gcc/testsuite/gfortran.dg/typebound_assignment_7.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_assignment_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f7395ffa13bb498c010aad0f08d137a7f766a1d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_assignment_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_assignment_7.f90?ref=4f7395ffa13bb498c010aad0f08d137a7f766a1d", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+!\n+! PR 57843: [OOP] Type-bound assignment is resolved to non-polymorphic procedure call\n+!\n+! Contributed by John <jwmwalrus@gmail.com>\n+\n+module mod1\n+  implicit none\n+  type :: itemType\n+  contains\n+    procedure :: the_assignment => assign_itemType\n+    generic :: assignment(=) => the_assignment\n+  end type\n+contains\n+  subroutine assign_itemType(left, right)\n+    class(itemType), intent(OUT) :: left\n+    class(itemType), intent(IN) :: right\n+  end subroutine\n+end module\n+\n+module mod2\n+  use mod1\n+  implicit none\n+  type, extends(itemType) :: myItem\n+    character(3) :: name = ''\n+  contains\n+    procedure :: the_assignment => assign_myItem\n+  end type\n+contains\n+  subroutine assign_myItem(left, right)\n+    class(myItem), intent(OUT) :: left\n+    class(itemType), intent(IN) :: right\n+    select type (right)\n+    type is (myItem)\n+      left%name = right%name\n+    end select\n+  end subroutine\n+end module\n+\n+\n+program test_assign\n+\n+  use mod2\n+  implicit none\n+\n+  class(itemType), allocatable :: item1, item2\n+\n+  allocate (myItem :: item1)\n+  select type (item1)\n+    type is (myItem)\n+      item1%name = 'abc'\n+  end select\n+\n+  allocate (myItem :: item2)\n+  item2 = item1\n+\n+  select type (item2)\n+    type is (myItem)\n+      if (item2%name /= 'abc') call abort()\n+    class default\n+      call abort()\n+  end select\n+\n+end\n+\n+! { dg-final { cleanup-modules \"mod1 mod2\" } }"}]}