{"sha": "561cf7b130aa8c70031ace121a516f7d92e8d8b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxY2Y3YjEzMGFhOGM3MDAzMWFjZTEyMWE1MTZmN2Q5MmU4ZDhiMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-04-27T19:24:06Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-04-27T19:24:06Z"}, "message": "Fix for x86 FP problem.\n\n\t* reg-stack.c: Revert last patch (Apr 20).\n\t(convert_regs): Set insn to PREV_INSN (next) after do while loop.\n\nFrom-SVN: r19437", "tree": {"sha": "f41ad05ed868a3d611a9bf1858631bbe1ddaf955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f41ad05ed868a3d611a9bf1858631bbe1ddaf955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561cf7b130aa8c70031ace121a516f7d92e8d8b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561cf7b130aa8c70031ace121a516f7d92e8d8b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561cf7b130aa8c70031ace121a516f7d92e8d8b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561cf7b130aa8c70031ace121a516f7d92e8d8b2/comments", "author": null, "committer": null, "parents": [{"sha": "1688d6d2c75c0a3b02144fa4479377da2c6818c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1688d6d2c75c0a3b02144fa4479377da2c6818c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1688d6d2c75c0a3b02144fa4479377da2c6818c7"}], "stats": {"total": 51, "additions": 28, "deletions": 23}, "files": [{"sha": "05f05ab7e4cfffe56f87ec10ef3943bbdaec3612", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561cf7b130aa8c70031ace121a516f7d92e8d8b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561cf7b130aa8c70031ace121a516f7d92e8d8b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=561cf7b130aa8c70031ace121a516f7d92e8d8b2", "patch": "@@ -1,5 +1,8 @@\n Mon Apr 27 18:36:28 1998  Jim Wilson  <wilson@cygnus.com>\n \n+\t* reg-stack.c: Revert last patch (Apr 20).\n+\t(convert_regs): Set insn to PREV_INSN (next) after do while loop.\n+\n \t* m68k/lb1sf68.asm (Laddsf$3): Fix typos in mcf5200 exg code.\n \n \t* loop.c (check_dbra_loop): New locals jump, first_compare, and"}, {"sha": "255cb38524b18dd9bbe69572dfc5394836c5bd3b", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561cf7b130aa8c70031ace121a516f7d92e8d8b2/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561cf7b130aa8c70031ace121a516f7d92e8d8b2/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=561cf7b130aa8c70031ace121a516f7d92e8d8b2", "patch": "@@ -262,9 +262,9 @@ static void move_for_stack_reg\t\tPROTO((rtx, stack, rtx));\n static void swap_rtx_condition\t\tPROTO((rtx));\n static void compare_for_stack_reg\tPROTO((rtx, stack, rtx));\n static void subst_stack_regs_pat\tPROTO((rtx, stack, rtx));\n-static rtx subst_asm_stack_regs\t\tPROTO((rtx, stack, rtx *, rtx **,\n+static void subst_asm_stack_regs\tPROTO((rtx, stack, rtx *, rtx **,\n \t\t\t\t\t       char **, int, int));\n-static rtx subst_stack_regs\t\tPROTO((rtx, stack));\n+static void subst_stack_regs\t\tPROTO((rtx, stack));\n static void change_stack\t\tPROTO((rtx, stack, stack, rtx (*) ()));\n \n static void goto_block_pat\t\tPROTO((rtx, stack, rtx));\n@@ -2411,11 +2411,9 @@ subst_stack_regs_pat (insn, regstack, pat)\n    stack-like regs in asm statements.  These rules are enforced by\n    record_asm_stack_regs; see comments there for details.  Any\n    asm_operands left in the RTL at this point may be assume to meet the\n-   requirements, since record_asm_stack_regs removes any problem asm.\n+   requirements, since record_asm_stack_regs removes any problem asm.  */\n \n-   It returns the last new insn generated by this function. */\n-\n-static rtx\n+static void\n subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t\t      n_inputs, n_outputs)\n      rtx insn;\n@@ -2694,18 +2692,14 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t      break;\n \t    }\n       }\n-\n-  return insn;\n }\n \f\n /* Substitute stack hard reg numbers for stack virtual registers in\n    INSN.  Non-stack register numbers are not changed.  REGSTACK is the\n    current stack content.  Insns may be emitted as needed to arrange the\n-   stack for the 387 based on the contents of the insn.\n-\n-   It returns the last new insn generated by this function. */\n+   stack for the 387 based on the contents of the insn.  */\n \n-static rtx\n+static void\n subst_stack_regs (insn, regstack)\n      rtx insn;\n      stack regstack;\n@@ -2761,9 +2755,9 @@ subst_stack_regs (insn, regstack)\n \t  decode_asm_operands (body, operands, operands_loc,\n \t\t\t       constraints, NULL_PTR);\n \t  get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n-\t  return subst_asm_stack_regs (insn, regstack, operands,\n-\t\t\t\t       operands_loc, constraints,\n-\t\t\t\t       n_inputs, n_outputs);\n+\t  subst_asm_stack_regs (insn, regstack, operands, operands_loc,\n+\t\t\t\tconstraints, n_inputs, n_outputs);\n+\t  return;\n \t}\n \n       if (GET_CODE (PATTERN (insn)) == PARALLEL)\n@@ -2781,7 +2775,7 @@ subst_stack_regs (insn, regstack)\n      REG_UNUSED will already have been dealt with, so just return.  */\n \n   if (GET_CODE (insn) == NOTE)\n-    return insn;\n+    return;\n \n   /* If there is a REG_UNUSED note on a stack register on this insn,\n      the indicated reg must be popped.  The REG_UNUSED note is removed,\n@@ -2797,8 +2791,6 @@ subst_stack_regs (insn, regstack)\n       }\n     else\n       note_link = &XEXP (note, 1);\n-\n-  return insn;\n }\n \f\n /* Change the organization of the stack so that it fits a new basic\n@@ -3039,7 +3031,7 @@ static void\n convert_regs ()\n {\n   register int block, reg;\n-  register rtx insn, next, new;\n+  register rtx insn, next;\n   struct stack_def regstack;\n \n   for (block = 0; block < blocks; block++)\n@@ -3065,18 +3057,28 @@ convert_regs ()\n       do\n \t{\n \t  insn = next;\n-\t  new = insn;\n \t  next = NEXT_INSN (insn);\n \n \t  /* Don't bother processing unless there is a stack reg\n \t     mentioned or if it's a CALL_INSN (register passing of\n \t     floating point values).  */\n \n \t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n-\t    /* We may have generated some new instructions here. */\n-\t    new = subst_stack_regs (insn, &regstack);\n+\t    subst_stack_regs (insn, &regstack);\n \n \t} while (insn != block_end[block]);\n+      \n+      /* For all further actions, INSN needs to be the last insn in\n+         this basic block.  If subst_stack_regs inserted additional\n+         instructions after INSN, it is no longer the last one at\n+         this point.  */\n+      next = PREV_INSN (next);\n+\n+      /* If subst_stack_regs inserted something after a JUMP_INSN, that\n+         is almost certainly a bug.  */\n+      if (GET_CODE (insn) == JUMP_INSN && insn != next)\n+\tabort ();\n+      insn = next;\n \n       /* Something failed if the stack life doesn't match.  */\n \n@@ -3097,7 +3099,7 @@ convert_regs ()\n       /* Likewise handle the case where we fall into the next block.  */\n \n       if ((block < blocks - 1) && block_drops_in[block+1])\n-\tchange_stack (new, &regstack, &block_stack_in[block+1],\n+\tchange_stack (insn, &regstack, &block_stack_in[block+1],\n \t\t      emit_insn_after);\n     }\n "}]}