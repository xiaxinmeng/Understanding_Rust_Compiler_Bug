{"sha": "35f2c098c81118020b1d288cd739108c8747a520", "node_id": "C_kwDOANBUbNoAKDM1ZjJjMDk4YzgxMTE4MDIwYjFkMjg4Y2Q3MzkxMDhjODc0N2E1MjA", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-01T09:16:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-01T09:16:57Z"}, "message": "simplify-rtx: Punt on simplify_associative_operation with large operands [PR102356]\n\nSeems simplify_associate_operation is quadratic, which isn't a big deal\nfor use during combine and other similar RTL passes, because those never\ntry to combine expressions from more than a few instructions and because\nthose instructions need to be recognized the machine description also bounds\nhow many expressions can appear in there.\nvar-tracking has depth limits only for some cases and unlimited depth\nfor the vt_expand_loc though:\n /* This is the value used during expansion of locations.  We want it\n    to be unbounded, so that variables expanded deep in a recursion\n    nest are fully evaluated, so that their values are cached\n    correctly.  We avoid recursion cycles through other means, and we\n    don't unshare RTL, so excess complexity is not a problem.  */\n #define EXPR_DEPTH (INT_MAX)\n /* We use this to keep too-complex expressions from being emitted as\n    location notes, and then to debug information.  Users can trade\n    compile time for ridiculously complex expressions, although they're\n    seldom useful, and they may often have to be discarded as not\n    representable anyway.  */\n #define EXPR_USE_DEPTH (param_max_vartrack_expr_depth)\n\nIMO for very large expressions it isn't worth trying to reassociate though,\nin fact e.g. for the new testcase below keeping it as is has bigger chance\nof generating smaller debug info which the dwarf2out.c part of the change\ntries to achieve - if a binary operation has the same operands, we can\nuse DW_OP_dup and not bother computing the possibly large operand again.\n\nThe patch fixes it by adding a counter to simplify_context and counting\nhow many times simplify_associative_operation has been called during\na single outermost simplify_* call, and once it reaches some maximum\n(currently 64), it stops reassociating.\n\nAnother possibility to deal with the power expressions in debug info\nwould be to introduce some new RTL operation for the pow{,i} (x, n)\ncase, allow that solely in debug insns and expand those into DWARF\nusing a loop.  But that seems like quite a lot of work for something rarely\nused (especially when powi for larger n is only useful for 0 and 1 inputs\nbecause anything else overflows).\n\n2021-12-01  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/102356\n\t* rtl.h (simplify_context): Add assoc_count member and\n\tmax_assoc_count static member.\n\t* simplify-rtx.c (simplify_associative_operation): Don't reassociate\n\tmore than max_assoc_count times within one outermost simplify_* call.\n\t* dwarf2out.c (mem_loc_descriptor): Optimize binary operation\n\twith both operands the same using DW_OP_dup.\n\n\t* gcc.dg/pr102356.c: New test.", "tree": {"sha": "c056e49381ca148016b4c5d8f68f05c344d630f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c056e49381ca148016b4c5d8f68f05c344d630f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35f2c098c81118020b1d288cd739108c8747a520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35f2c098c81118020b1d288cd739108c8747a520", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35f2c098c81118020b1d288cd739108c8747a520", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35f2c098c81118020b1d288cd739108c8747a520/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac5fd364f0978c62ae759e7b36ce6b912a27546c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5fd364f0978c62ae759e7b36ce6b912a27546c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac5fd364f0978c62ae759e7b36ce6b912a27546c"}], "stats": {"total": 60, "additions": 60, "deletions": 0}, "files": [{"sha": "e36ef56a9829b76e5e1ab529845f508f2d6bd984", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=35f2c098c81118020b1d288cd739108c8747a520", "patch": "@@ -16363,6 +16363,15 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n     do_binop:\n       op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      if (XEXP (rtl, 0) == XEXP (rtl, 1))\n+\t{\n+\t  if (op0 == 0)\n+\t    break;\n+\t  mem_loc_result = op0;\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_dup, 0, 0));\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+\t  break;\n+\t}\n       op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n "}, {"sha": "cf801be62c6b345de63ea497d607dddb36829f71", "filename": "gcc/rtl.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=35f2c098c81118020b1d288cd739108c8747a520", "patch": "@@ -3433,6 +3433,14 @@ class simplify_context\n      inside a MEM than outside.  */\n   unsigned int mem_depth = 0;\n \n+  /* Tracks number of simplify_associative_operation calls performed during\n+     outermost simplify* call.  */\n+  unsigned int assoc_count = 0;\n+\n+  /* Limit for the above number, return NULL from\n+     simplify_associative_operation after we reach that assoc_count.  */\n+  static const unsigned int max_assoc_count = 64;\n+\n private:\n   rtx simplify_truncation (machine_mode, rtx, machine_mode);\n   rtx simplify_byte_swapping_operation (rtx_code, machine_mode, rtx, rtx);"}, {"sha": "4fabd73382be3b3093bcabaf34747d6e59788297", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=35f2c098c81118020b1d288cd739108c8747a520", "patch": "@@ -2263,6 +2263,16 @@ simplify_context::simplify_associative_operation (rtx_code code,\n {\n   rtx tem;\n \n+  /* Normally expressions simplified by simplify-rtx.c are combined\n+     at most from a few machine instructions and therefore the\n+     expressions should be fairly small.  During var-tracking\n+     we can see arbitrarily large expressions though and reassociating\n+     those can be quadratic, so punt after encountering max_assoc_count\n+     simplify_associative_operation calls during outermost simplify_*\n+     call.  */\n+  if (++assoc_count >= max_assoc_count)\n+    return NULL_RTX;\n+\n   /* Linearize the operator to the left.  */\n   if (GET_CODE (op1) == code)\n     {"}, {"sha": "6fce77043cc2b31bfda26bcbf554f6bb849b17e2", "filename": "gcc/testsuite/gcc.dg/pr102356.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102356.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35f2c098c81118020b1d288cd739108c8747a520/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102356.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102356.c?ref=35f2c098c81118020b1d288cd739108c8747a520", "patch": "@@ -0,0 +1,33 @@\n+/* PR rtl-optimization/102356 */\n+/* { dg-do compile { target int32plus } } */\n+/* { dg-options \"-O3 -g\" } */\n+\n+signed char a = 0;\n+unsigned char b = 9;\n+unsigned long long c = 0xF1FBFC17225F7A57ULL;\n+int d = 0x3A6667C6;\n+\n+unsigned char\n+foo (unsigned int x)\n+{\n+  unsigned int *e = &x;\n+  if ((c /= ((0 * (*e *= b)) <= 0)))\n+    ;\n+  for (d = 9; d > 2; d -= 2)\n+    {\n+      c = -2;\n+      do\n+\tif ((*e *= *e))\n+\t  {\n+\t    a = 4;\n+\t    do\n+\t      {\n+\t\ta -= 3;\n+\t\tif ((*e *= *e))\n+\t\t  b = 9;\n+\t      }\n+\t    while (a > 2);\n+\t  }\n+      while (c++);\n+    }\n+}"}]}