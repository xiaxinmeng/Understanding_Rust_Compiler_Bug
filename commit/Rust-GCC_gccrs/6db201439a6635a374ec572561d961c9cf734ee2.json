{"sha": "6db201439a6635a374ec572561d961c9cf734ee2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRiMjAxNDM5YTY2MzVhMzc0ZWM1NzI1NjFkOTYxYzljZjczNGVlMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-03-04T00:45:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-04T00:45:24Z"}, "message": "decl2.c (key_method): Break out from...\n\n        * decl2.c (key_method): Break out from...\n        (import_export_vtable, import_export_class): ...here.\n\n        * decl.c (finish_function): Don't mess with flag_keep_inline_functions.\n        * decl2.c (finish_vtable_vardecl): Don't check decl_function_context.\n\n        * search.c (note_debug_info_needed, dfs_debug_mark,\n        dfs_debug_unmarkedp): Uncomment.  Adjust for new scheme.\n        * decl2.c (finish_vtable_vardecl): Call note_debug_info_needed.\n\nFrom-SVN: r32319", "tree": {"sha": "5ce9ac0c720473894250630fd62d659f1ffa7372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ce9ac0c720473894250630fd62d659f1ffa7372"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6db201439a6635a374ec572561d961c9cf734ee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db201439a6635a374ec572561d961c9cf734ee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6db201439a6635a374ec572561d961c9cf734ee2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db201439a6635a374ec572561d961c9cf734ee2/comments", "author": null, "committer": null, "parents": [{"sha": "49634cde481046798cf98c775317df99a5cade05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49634cde481046798cf98c775317df99a5cade05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49634cde481046798cf98c775317df99a5cade05"}], "stats": {"total": 208, "additions": 91, "deletions": 117}, "files": [{"sha": "b97b555da616f01a81787063c8d629c73df07b99", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6db201439a6635a374ec572561d961c9cf734ee2", "patch": "@@ -1,3 +1,15 @@\n+2000-03-03  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* decl2.c (key_method): Break out from...\n+\t(import_export_vtable, import_export_class): ...here.\n+\n+\t* decl.c (finish_function): Don't mess with flag_keep_inline_functions.\n+\t* decl2.c (finish_vtable_vardecl): Don't check decl_function_context.\n+\n+\t* search.c (note_debug_info_needed, dfs_debug_mark, \n+\tdfs_debug_unmarkedp): Uncomment.  Adjust for new scheme.\n+\t* decl2.c (finish_vtable_vardecl): Call note_debug_info_needed.\n+\n 2000-03-03  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (cp_finish_decl): Remove obsolete obstack comments, fix"}, {"sha": "c3d070da6f34a9b756934bab1f739aba46f18352", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6db201439a6635a374ec572561d961c9cf734ee2", "patch": "@@ -13883,21 +13883,10 @@ finish_function (lineno, flags)\n     {\n       int returns_null;\n       int returns_value;\n-      int saved_flag_keep_inline_functions =\n-\tflag_keep_inline_functions;\n \n       /* So we can tell if jump_optimize sets it to 1.  */\n       can_reach_end = 0;\n \n-      if (DECL_CONTEXT (fndecl) != NULL_TREE\n-\t  && decl_function_context (fndecl))\n-\t/* Trick rest_of_compilation into not deferring output of this\n-\t   function, even if it is inline, since the rtl_obstack for\n-\t   this function is the function_obstack of the enclosing\n-\t   function and will be deallocated when the enclosing\n-\t   function is gone.  See save_tree_status.  */\n-\tflag_keep_inline_functions = 1;\n-\n       /* Before we call rest_of_compilation (which will pop the\n \t CURRENT_FUNCTION), we must save these values.  */\n       returns_null = current_function_returns_null;\n@@ -13934,8 +13923,6 @@ finish_function (lineno, flags)\n       if (function_depth > 1)\n \tggc_pop_context ();\n \n-      flag_keep_inline_functions = saved_flag_keep_inline_functions;\n-\n       if (DECL_SAVED_INSNS (fndecl) && ! TREE_ASM_WRITTEN (fndecl))\n \t{\n \t  /* Set DECL_EXTERNAL so that assemble_external will be called as"}, {"sha": "8e66bb6bc3c89b8495cb3e57cc67032670203fc1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6db201439a6635a374ec572561d961c9cf734ee2", "patch": "@@ -92,6 +92,7 @@ static int generate_ctor_and_dtor_functions_for_priority\n static tree prune_vars_needing_no_initialization PARAMS ((tree));\n static void write_out_vars PARAMS ((tree));\n static void import_export_class\tPARAMS ((tree));\n+static tree key_method PARAMS ((tree));\n \n extern int current_class_depth;\n \n@@ -2378,6 +2379,29 @@ maybe_make_one_only (decl)\n     DECL_COMDAT (decl) = 1;\n }\n \n+/* Returns the virtual function with which the vtable for TYPE is\n+   emitted, or NULL_TREE if that heuristic is not applicable to TYPE.  */\n+\n+static tree\n+key_method (type)\n+     tree type;\n+{\n+  tree method;\n+\n+  if (TYPE_FOR_JAVA (type)\n+      || CLASSTYPE_INTERFACE_KNOWN (type))\n+    return NULL_TREE;\n+\n+  for (method = TYPE_METHODS (type); method != NULL_TREE;\n+       method = TREE_CHAIN (method))\n+    if (DECL_VINDEX (method) != NULL_TREE\n+\t&& ! DECL_THIS_INLINE (method)\n+\t&& ! DECL_PURE_VIRTUAL_P (method))\n+      return method;\n+\n+  return NULL_TREE;\n+}\n+\n /* Set TREE_PUBLIC and/or DECL_EXTERN on the vtable DECL,\n    based on TYPE and other static flags.\n \n@@ -2409,21 +2433,8 @@ import_export_vtable (decl, type, final)\n       /* We can only wait to decide if we have real non-inline virtual\n \t functions in our class, or if we come from a template.  */\n \n-      int found = CLASSTYPE_TEMPLATE_INSTANTIATION (type);\n-\n-      if (! found && ! final)\n-\t{\n-\t  tree method;\n-\t  for (method = TYPE_METHODS (type); method != NULL_TREE;\n-\t       method = TREE_CHAIN (method))\n-\t    if (DECL_VINDEX (method) != NULL_TREE\n-\t\t&& ! DECL_THIS_INLINE (method)\n-\t\t&& ! DECL_PURE_VIRTUAL_P (method))\n-\t      {\n-\t\tfound = 1;\n-\t\tbreak;\n-\t      }\n-\t}\n+      int found = (CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n+\t\t   || key_method (type));\n \n       if (final || ! found)\n \t{\n@@ -2482,23 +2493,14 @@ import_export_class (ctype)\n     import_export = -1;\n \n   /* Base our import/export status on that of the first non-inline,\n-     non-abstract virtual function, if any.  */\n+     non-pure virtual function, if any.  */\n   if (import_export == 0\n       && TYPE_POLYMORPHIC_P (ctype)\n       && ! CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n     {\n-      tree method;\n-      for (method = TYPE_METHODS (ctype); method != NULL_TREE;\n-\t   method = TREE_CHAIN (method))\n-\t{\n-\t  if (DECL_VINDEX (method) != NULL_TREE\n-\t      && !DECL_THIS_INLINE (method)\n-\t      && !DECL_PURE_VIRTUAL_P (method))\n-\t    {\n-\t      import_export = (DECL_REALLY_EXTERN (method) ? -1 : 1);\n-\t      break;\n-\t    }\n-\t}\n+      tree method = key_method (ctype);\n+      if (method)\n+\timport_export = (DECL_REALLY_EXTERN (method) ? -1 : 1);\n     }\n \n #ifdef MULTIPLE_SYMBOL_SPACES\n@@ -2552,8 +2554,7 @@ finish_vtable_vardecl (t, data)\n   import_export_vtable (vars, ctype, 1);\n \n   if (! DECL_EXTERNAL (vars)\n-      && (DECL_NEEDED_P (vars)\n-\t  || (decl_function_context (vars) && TREE_USED (vars)))\n+      && DECL_NEEDED_P (vars)\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n       if (TREE_TYPE (vars) == void_type_node)\n@@ -2607,17 +2608,16 @@ finish_vtable_vardecl (t, data)\n \n       /* Since we're writing out the vtable here, also write the debug \n \t info.  */\n-      if (TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (ctype)))\n-\t{\n-\t  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (ctype)) = 0;\n-\t  rest_of_type_compilation (ctype, toplevel_bindings_p ());\n-\t}\n+      note_debug_info_needed (ctype);\n \n       return 1;\n     }\n-  else if (!DECL_NEEDED_P (vars))\n-    /* We don't know what to do with this one yet.  */\n-    return 0;\n+\n+  /* If the references to this class' vtables were optimized away, still\n+     emit the appropriate debugging information.  See dfs_debug_mark.  */\n+  if (DECL_COMDAT (vars)\n+      && CLASSTYPE_DEBUG_REQUESTED (ctype))\n+    note_debug_info_needed (ctype);\n \n   return 0;\n }"}, {"sha": "9f8f5de3062243940748daa85d2fea722b12cb53", "filename": "gcc/cp/search.c", "status": "modified", "additions": 41, "deletions": 66, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db201439a6635a374ec572561d961c9cf734ee2/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6db201439a6635a374ec572561d961c9cf734ee2", "patch": "@@ -2571,15 +2571,6 @@ unmarked_pushdecls_p (binfo, data)\n #if 0\n static int dfs_search_slot_nonempty_p (binfo) tree binfo;\n { return CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) != 0; }\n-\n-static tree \n-dfs_debug_unmarkedp (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{ \n-  return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n-\t  ? binfo : NULL_TREE);\n-}\n #endif\n \n /* The worker functions for `dfs_walk'.  These do not need to\n@@ -2639,36 +2630,6 @@ dfs_unmark_new_vtable (binfo) tree binfo;\n static void\n dfs_clear_search_slot (binfo) tree binfo;\n { CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) = 0; }\n-\n-/* Keep this code around in case we later want to control debug info\n-   based on whether a type is \"used\".  Currently, we only suppress debug\n-   info if we can emit it with the vtable.  jason 1999-11-11) */\n-static tree\n-dfs_debug_mark (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  tree t = BINFO_TYPE (binfo);\n-\n-  CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n-\n-  /* If interface info is known, either we've already emitted the debug\n-     info or we don't need to.  */\n-  if (CLASSTYPE_INTERFACE_KNOWN (t))\n-    return NULL_TREE;\n-\n-  /* If the class has virtual functions, we'll emit the debug info\n-     with the vtable.  */\n-  if (TYPE_POLYMORPHIC_P (t))\n-    return NULL_TREE;\n-\n-  /* We cannot rely on some alien method to solve our problems,\n-     so we must write out the debug info ourselves.  */\n-  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n-  rest_of_type_compilation (t, toplevel_bindings_p ());\n-\n-  return NULL_TREE;\n-}\n #endif\n \f\n struct vbase_info \n@@ -3254,44 +3215,58 @@ maybe_suppress_debug_info (t)\n   /* Otherwise, just emit the debug info normally.  */\n }\n \n-#if 0\n-/* Keep this code around in case we later want to control debug info\n-   based on whether a type is \"used\".  Currently, we only suppress debug\n-   info if we can emit it with the vtable.  jason 1999-11-11) */\n+/* Note that we want debugging information for a base class of a class\n+   whose vtable is being emitted.  Normally, this would happen because\n+   calling the constructor for a derived class implies calling the\n+   constructors for all bases, which involve initializing the\n+   appropriate vptr with the vtable for the base class; but in the\n+   presence of optimization, this initialization may be optimized\n+   away, so we tell finish_vtable_vardecl that we want the debugging\n+   information anyway.  */\n+\n+static tree\n+dfs_debug_mark (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree t = BINFO_TYPE (binfo);\n+\n+  CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns BINFO if we haven't already noted that we want debugging\n+   info for this base class.  */\n+\n+static tree \n+dfs_debug_unmarkedp (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n+\t  ? binfo : NULL_TREE);\n+}\n \n-/* If we want debug info for a type TYPE, make sure all its base types\n-   are also marked as being potentially interesting.  This avoids\n-   the problem of not writing any debug info for intermediate basetypes\n-   that have abstract virtual functions.  Also mark member types.  */\n+/* Write out the debugging information for TYPE, whose vtable is being\n+   emitted.  Also walk through our bases and note that we want to\n+   write out information for them.  This avoids the problem of not\n+   writing any debug info for intermediate basetypes whose\n+   constructors, and thus the references to their vtables, and thus\n+   the vtables themselves, were optimized away.  */\n \n void\n note_debug_info_needed (type)\n      tree type;\n {\n-  tree field;\n-\n-  if (current_template_parms)\n-    return;\n-    \n-  if (TYPE_BEING_DEFINED (type))\n-    /* We can't go looking for the base types and fields just yet.  */\n+  if (! TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (type)))\n     return;\n \n-  /* See the comment in maybe_suppress_debug_info.  */\n-  if (write_symbols == DWARF_DEBUG || write_symbols == NO_DEBUG)\n-    return;\n+  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (type)) = 0;\n+  rest_of_type_compilation (type, toplevel_bindings_p ());\n \n   dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp, 0);\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-    {\n-      tree ttype;\n-      if (TREE_CODE (field) == FIELD_DECL\n-\t  && IS_AGGR_TYPE (ttype = target_type (TREE_TYPE (field)))\n-\t  && dfs_debug_unmarkedp (TYPE_BINFO (ttype), 0))\n-\tnote_debug_info_needed (ttype);\n-    }\n }\n-#endif\n \f\n /* Subroutines of push_class_decls ().  */\n "}]}