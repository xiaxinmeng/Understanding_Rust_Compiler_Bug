{"sha": "4b79993fd512c13fc94cfe8aad2f8387a7f614a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI3OTk5M2ZkNTEyYzEzZmM5NGNmZThhYWQyZjgzODdhN2Y2MTRhMQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-10-25T00:33:56Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-10-25T00:33:56Z"}, "message": "cccp.c (progname, [...]): Constify a char*.\n\n        * cccp.c (progname, file_buf, default_include, include_file,\n        macrodef, definition, hashval, wchar_type, user_label_prefix,\n        directive, out_fname, if_stack, safe_write, index0, get_lintcmd,\n        expand_to_temp_buffer, is_system_include, base_name,\n        absolute_filename, read_name_map, open_include_file,\n        record_control_macro, check_precompiled, check_preconditions,\n        pcfinclude, pass_thru_directive, create_definition,\n        check_macro_name, comp_def_part, collect_expansion,\n        check_assertion, read_token_list, assertion_install,\n        assertion_lookup, eval_if_expression, conditional_skip,\n        validate_else, skip_quoted_string, quote_string, macarg1,\n        error_from_errno, install, lookup, hashf, dump_defn_1,\n        perror_with_name, pfatal_with_name, main, trigraph_pcp,\n        check_white_space, rescan, handle_directive, monthnames,\n        special_symbol, do_include, remap_include_file, write_output,\n        arglist, do_assert, do_unassert, do_line, do_error, do_once,\n        do_ident, do_sccs, do_xifdef, skip_if_group,\n        output_line_directive, macroexpand, macarg, change_newlines,\n        initialize_builtins, make_definition): Constify a char*.\n\n        * pcp.h (stringdef): Likewise.\n\nFrom-SVN: r30150", "tree": {"sha": "9058ab393570b63b3b68fcf36fb0c6b6087f2ab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9058ab393570b63b3b68fcf36fb0c6b6087f2ab2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b79993fd512c13fc94cfe8aad2f8387a7f614a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b79993fd512c13fc94cfe8aad2f8387a7f614a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b79993fd512c13fc94cfe8aad2f8387a7f614a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b79993fd512c13fc94cfe8aad2f8387a7f614a1/comments", "author": null, "committer": null, "parents": [{"sha": "65c8a03d5ceb266752a24fff8f897d8d488b3f21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65c8a03d5ceb266752a24fff8f897d8d488b3f21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65c8a03d5ceb266752a24fff8f897d8d488b3f21"}], "stats": {"total": 558, "additions": 312, "deletions": 246}, "files": [{"sha": "e6ec38f9024a6dd9520ee3d210308f90449b1fad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b79993fd512c13fc94cfe8aad2f8387a7f614a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b79993fd512c13fc94cfe8aad2f8387a7f614a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b79993fd512c13fc94cfe8aad2f8387a7f614a1", "patch": "@@ -1,3 +1,27 @@\n+Sun Oct 24 20:29:59 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cccp.c (progname, file_buf, default_include, include_file,\n+\tmacrodef, definition, hashval, wchar_type, user_label_prefix,\n+\tdirective, out_fname, if_stack, safe_write, index0, get_lintcmd,\n+\texpand_to_temp_buffer, is_system_include, base_name,\n+\tabsolute_filename, read_name_map, open_include_file,\n+\trecord_control_macro, check_precompiled, check_preconditions,\n+\tpcfinclude, pass_thru_directive, create_definition,\n+\tcheck_macro_name, comp_def_part, collect_expansion,\n+\tcheck_assertion, read_token_list, assertion_install,\n+\tassertion_lookup, eval_if_expression, conditional_skip,\n+\tvalidate_else, skip_quoted_string, quote_string, macarg1,\n+\terror_from_errno, install, lookup, hashf, dump_defn_1,\n+\tperror_with_name, pfatal_with_name, main, trigraph_pcp,\n+\tcheck_white_space, rescan, handle_directive, monthnames,\n+\tspecial_symbol, do_include, remap_include_file, write_output,\n+\targlist, do_assert, do_unassert, do_line, do_error, do_once,\n+\tdo_ident, do_sccs, do_xifdef, skip_if_group,\n+\toutput_line_directive, macroexpand, macarg, change_newlines,\n+\tinitialize_builtins, make_definition): Constify a char*.\n+\n+\t* pcp.h (stringdef): Likewise.\n+\n Sun Oct 24 13:29:28 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* unroll.c (copy_loop_body): Examine SET_DEST of single_set"}, {"sha": "2a56b232190cd5207064c4b9d26ad956b7b60b55", "filename": "gcc/cccp.c", "status": "modified", "additions": 287, "deletions": 245, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b79993fd512c13fc94cfe8aad2f8387a7f614a1/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b79993fd512c13fc94cfe8aad2f8387a7f614a1/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=4b79993fd512c13fc94cfe8aad2f8387a7f614a1", "patch": "@@ -110,7 +110,7 @@ HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n \f\n /* Name under which this program was invoked.  */\n \n-static char *progname;\n+static const char *progname;\n \n /* Nonzero means use extra default include directories for C++.  */\n \n@@ -300,9 +300,9 @@ static int multiline_string_line = 0;\n    and for expanding macro arguments.  */\n #define INPUT_STACK_MAX 400\n static struct file_buf {\n-  char *fname;\n+  const char *fname;\n   /* Filename specified with #line directive.  */\n-  char *nominal_fname;\n+  const char *nominal_fname;\n   /* The length of nominal_fname, which may contain embedded NULs.  */\n   size_t nominal_fname_len;\n   /* Include file description.  */\n@@ -383,8 +383,8 @@ struct file_name_list\n /* -I directories are added to the end, then the defaults are added.  */\n /* The */\n static struct default_include {\n-  char *fname;\t\t\t/* The name of the directory.  */\n-  char *component;\t\t/* The component containing the directory */\n+  const char *fname;\t\t/* The name of the directory.  */\n+  const char *component;\t/* The component containing the directory */\n   int cplusplus;\t\t/* Only look here if we're compiling C++.  */\n   int cxx_aware;\t\t/* Includes in this directory don't need to\n \t\t\t\t   be wrapped in extern \"C\" when compiling\n@@ -472,7 +472,7 @@ struct include_file {\n      was seen in this include file, or #import was applied to the file.\n      Otherwise, if it is nonzero, it is a macro name.\n      Don't include the file again if that macro is defined.  */\n-  U_CHAR *control_macro;\n+  const U_CHAR *control_macro;\n   /* Nonzero if the dependency on this include file has been output.  */\n   int deps_output;\n   struct stat st;\n@@ -499,7 +499,7 @@ typedef struct macrodef MACRODEF;\n struct macrodef\n {\n   struct definition *defn;\n-  U_CHAR *symnam;\n+  const U_CHAR *symnam;\n   int symlen;\n };\n \f\n@@ -542,7 +542,7 @@ struct definition {\n \t\t\t\t/* came from the command line */\n   U_CHAR *expansion;\n   int line;\t\t\t/* Line number of definition */\n-  char *file;\t\t\t/* File of definition */\n+  const char *file;\t\t/* File of definition */\n   size_t file_len;\t\t/* Length of file (which can contain NULs) */\n   char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n   struct reflist {\n@@ -569,7 +569,7 @@ struct definition {\n /* different kinds of things that can appear in the value field\n    of a hash node.  Actually, this may be useless now.  */\n union hashval {\n-  char *cpval;\n+  const char *cpval;\n   DEFINITION *defn;\n   KEYDEF *keydef;\n };\n@@ -694,15 +694,15 @@ static HASHNODE *hashtab[HASHSIZE];\n #ifndef WCHAR_TYPE\n #define WCHAR_TYPE \"int\"\n #endif\n-char * wchar_type = WCHAR_TYPE;\n+static const char * wchar_type = WCHAR_TYPE;\n #undef WCHAR_TYPE\n \n /* The string value for __USER_LABEL_PREFIX__ */\n \n #ifndef USER_LABEL_PREFIX\n #define USER_LABEL_PREFIX \"\"\n #endif\n-char * user_label_prefix = USER_LABEL_PREFIX;\n+static const char * user_label_prefix = USER_LABEL_PREFIX;\n #undef USER_LABEL_PREFIX\n \n /* The string value for __REGISTER_PREFIX__ */\n@@ -763,7 +763,7 @@ static int assertions_flag;\n struct directive {\n   int length;\t\t\t/* Length of name */\n   int (*func) DO_PROTO;\t/* Function to handle directive */\n-  char *name;\t\t\t/* Name of directive */\n+  const char *name;\t\t/* Name of directive */\n   enum node_type type;\t\t/* Code which describes which directive.  */\n };\n \n@@ -838,7 +838,7 @@ U_CHAR is_space[256];\n static int errors = 0;\t\t\t/* Error counter for exit code */\n \n /* Name of output file, for error messages.  */\n-static char *out_fname;\n+static const char *out_fname;\n \n /* Nonzero to ignore \\ in string constants.  Use to treat #line 1 \"A:\\file.h\n    as a non-form feed.  If you want it to be a form feed, you must use\n@@ -850,12 +850,12 @@ static int ignore_escape_flag = 1;\n \n struct if_stack {\n   struct if_stack *next;\t/* for chaining to the next stack frame */\n-  char *fname;\t\t/* copied from input when frame is made */\n+  const char *fname;\t\t/* copied from input when frame is made */\n   size_t fname_len;\t\t/* similarly */\n   int lineno;\t\t\t/* similarly */\n   int if_succeeded;\t\t/* true if a leg of this if-group\n \t\t\t\t    has been passed through rescan */\n-  U_CHAR *control_macro;\t/* For #ifndef at start of file,\n+  const U_CHAR *control_macro;\t/* For #ifndef at start of file,\n \t\t\t\t   this is the macro name tested.  */\n   enum node_type type;\t\t/* type of last directive seen in this group */\n };\n@@ -879,80 +879,91 @@ static int deps_column;\n static int ignore_srcdir;\n \f\n static int safe_read PROTO((int, char *, int));\n-static void safe_write PROTO((int, char *, int));\n+static void safe_write PROTO((int, const char *, int));\n \n int main PROTO((int, char **));\n \n static void path_include PROTO((char *));\n \n-static U_CHAR *index0 PROTO((U_CHAR *, int, size_t));\n+static const U_CHAR *index0 PROTO((const U_CHAR *, int, size_t));\n \n static void trigraph_pcp PROTO((FILE_BUF *));\n static void check_white_space PROTO((FILE_BUF *));\n \n static void newline_fix PROTO((U_CHAR *));\n static void name_newline_fix PROTO((U_CHAR *));\n \n-static char *get_lintcmd PROTO((U_CHAR *, U_CHAR *, U_CHAR **, int *, int *));\n+static const char *get_lintcmd PROTO((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t      const U_CHAR **, int *, int *));\n \n static void rescan PROTO((FILE_BUF *, int));\n \n-static FILE_BUF expand_to_temp_buffer PROTO((U_CHAR *, U_CHAR *, int, int));\n+static FILE_BUF expand_to_temp_buffer PROTO((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t     int, int));\n \n static int handle_directive PROTO((FILE_BUF *, FILE_BUF *));\n \n static struct tm *timestamp PROTO((void));\n static void special_symbol PROTO((HASHNODE *, FILE_BUF *));\n \n-static int is_system_include PROTO((char *));\n-static char *base_name PROTO((char *));\n-static int absolute_filename PROTO((char *));\n+static int is_system_include PROTO((const char *));\n+static char *base_name PROTO((const char *));\n+static int absolute_filename PROTO((const char *));\n static size_t simplify_filename PROTO((char *));\n \n static char *read_filename_string PROTO((int, FILE *));\n-static struct file_name_map *read_name_map PROTO((char *));\n-static int open_include_file PROTO((char *, struct file_name_list *, U_CHAR *, struct include_file **));\n+static struct file_name_map *read_name_map PROTO((const char *));\n+static int open_include_file PROTO((char *, struct file_name_list *,\n+\t\t\t\t    const U_CHAR *, struct include_file **));\n static char *remap_include_file PROTO((char *, struct file_name_list *));\n static int lookup_ino_include PROTO((struct include_file *));\n \n static void finclude PROTO((int, struct include_file *, FILE_BUF *, int, struct file_name_list *));\n-static void record_control_macro PROTO((struct include_file *, U_CHAR *));\n+static void record_control_macro PROTO((struct include_file *, const U_CHAR *));\n \n-static char *check_precompiled PROTO((int, struct stat *, char *, char **));\n-static int check_preconditions PROTO((char *));\n-static void pcfinclude PROTO((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static char *check_precompiled PROTO((int, struct stat *, const char *,\n+\t\t\t\t      const char **));\n+static int check_preconditions PROTO((const char *));\n+static void pcfinclude PROTO((U_CHAR *, const U_CHAR *, FILE_BUF *));\n static void pcstring_used PROTO((HASHNODE *));\n static void write_output PROTO((void));\n-static void pass_thru_directive PROTO((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void pass_thru_directive PROTO((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t       FILE_BUF *, struct directive *));\n \n-static MACRODEF create_definition PROTO((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static MACRODEF create_definition PROTO((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t FILE_BUF *));\n \n-static int check_macro_name PROTO((U_CHAR *, int));\n+static int check_macro_name PROTO((const U_CHAR *, int));\n static int compare_defs PROTO((DEFINITION *, DEFINITION *));\n-static int comp_def_part PROTO((int, U_CHAR *, int, U_CHAR *, int, int));\n+static int comp_def_part PROTO((int, const U_CHAR *, int, const U_CHAR *,\n+\t\t\t\tint, int));\n \n-static DEFINITION *collect_expansion  PROTO((U_CHAR *, U_CHAR *, int, struct arglist *));\n+static DEFINITION *collect_expansion  PROTO((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t     int, struct arglist *));\n \n-int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n+int check_assertion PROTO((const U_CHAR *, int, int, struct arglist *));\n static int compare_token_lists PROTO((struct arglist *, struct arglist *));\n \n-static struct arglist *read_token_list PROTO((U_CHAR **, U_CHAR *, int *));\n+static struct arglist *read_token_list PROTO((const U_CHAR **, const U_CHAR *,\n+\t\t\t\t\t      int *));\n static void free_token_list PROTO((struct arglist *));\n \n-static ASSERTION_HASHNODE *assertion_install PROTO((U_CHAR *, int, int));\n-static ASSERTION_HASHNODE *assertion_lookup PROTO((U_CHAR *, int, int));\n+static ASSERTION_HASHNODE *assertion_install PROTO((const U_CHAR *, int, int));\n+static ASSERTION_HASHNODE *assertion_lookup PROTO((const U_CHAR *, int, int));\n static void delete_assertion PROTO((ASSERTION_HASHNODE *));\n \n static void do_once PROTO((void));\n \n-static HOST_WIDEST_INT eval_if_expression PROTO((U_CHAR *, int));\n-static void conditional_skip PROTO((FILE_BUF *, int, enum node_type, U_CHAR *, FILE_BUF *));\n+static HOST_WIDEST_INT eval_if_expression PROTO((const U_CHAR *, int));\n+static void conditional_skip PROTO((FILE_BUF *, int, enum node_type,\n+\t\t\t\t    const U_CHAR *, FILE_BUF *));\n static void skip_if_group PROTO((FILE_BUF *, int, FILE_BUF *));\n-static void validate_else PROTO((U_CHAR *, U_CHAR *));\n+static void validate_else PROTO((const U_CHAR *, const U_CHAR *));\n \n static U_CHAR *skip_to_end_of_comment PROTO((FILE_BUF *, int *, int));\n-static U_CHAR *skip_quoted_string PROTO((U_CHAR *, U_CHAR *, int, int *, int *, int *));\n-static char *quote_string PROTO((char *, char *, size_t));\n+static U_CHAR *skip_quoted_string PROTO((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t int, int *, int *, int *));\n+static char *quote_string PROTO((char *, const char *, size_t));\n static U_CHAR *skip_paren_group PROTO((FILE_BUF *));\n \n /* Last arg to output_line_directive.  */\n@@ -964,7 +975,7 @@ static void macroexpand PROTO((HASHNODE *, FILE_BUF *));\n struct argdata;\n static int macarg PROTO((struct argdata *, int));\n \n-static U_CHAR *macarg1 PROTO((U_CHAR *, U_CHAR *, struct hashnode *, int *, int *, int *, int));\n+static U_CHAR *macarg1 PROTO((U_CHAR *, const U_CHAR *, struct hashnode *, int *, int *, int *, int));\n \n static int discard_comments PROTO((U_CHAR *, int, int));\n \n@@ -974,7 +985,7 @@ static void notice PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n static void vnotice PROTO((const char *, va_list));\n void error PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n void verror PROTO((const char *, va_list));\n-static void error_from_errno PROTO((char *));\n+static void error_from_errno PROTO((const char *));\n void warning PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n static void vwarning PROTO((const char *, va_list));\n static void error_with_line PVPROTO((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n@@ -991,14 +1002,15 @@ static void print_containing_files PROTO((void));\n static int line_for_error PROTO((int));\n static int grow_outbuf PROTO((FILE_BUF *, int));\n \n-static HASHNODE *install PROTO((U_CHAR *, int, enum node_type, char *, int));\n-HASHNODE *lookup PROTO((U_CHAR *, int, int));\n+static HASHNODE *install PROTO((const U_CHAR *, int, enum node_type,\n+\t\t\t\tconst char *, int));\n+HASHNODE *lookup PROTO((const U_CHAR *, int, int));\n static void delete_macro PROTO((HASHNODE *));\n-static int hashf PROTO((U_CHAR *, int, int));\n+static int hashf PROTO((const U_CHAR *, int, int));\n \n static void dump_single_macro PROTO((HASHNODE *, FILE *));\n static void dump_all_macros PROTO((void));\n-static void dump_defn_1 PROTO((U_CHAR *, int, int, FILE *));\n+static void dump_defn_1 PROTO((const U_CHAR *, int, int, FILE *));\n static void dump_arg_n PROTO((DEFINITION *, int, FILE *));\n \n static void initialize_char_syntax PROTO((void));\n@@ -1017,8 +1029,8 @@ static void deps_output PROTO((const char *, int));\n \n void fatal PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n void fancy_abort PROTO((void)) ATTRIBUTE_NORETURN;\n-static void perror_with_name PROTO((char *));\n-static void pfatal_with_name PROTO((char *)) ATTRIBUTE_NORETURN;\n+static void perror_with_name PROTO((const char *));\n+static void pfatal_with_name PROTO((const char *)) ATTRIBUTE_NORETURN;\n static void pipe_closed PROTO((int)) ATTRIBUTE_NORETURN;\n \n static void memory_full PROTO((void)) ATTRIBUTE_NORETURN;\n@@ -1069,7 +1081,7 @@ safe_read (desc, ptr, len)\n static void\n safe_write (desc, ptr, len)\n      int desc;\n-     char *ptr;\n+     const char *ptr;\n      int len;\n {\n   int wcount, written;\n@@ -1171,7 +1183,7 @@ main (argc, argv)\n      char **argv;\n {\n   struct stat st;\n-  char *in_fname;\n+  const char *in_fname;\n   char *cp;\n   int f, i;\n   FILE_BUF *fp;\n@@ -1185,7 +1197,7 @@ main (argc, argv)\n   /* Record the option used with each element of pend_assertions.\n      This is preparation for supporting more than one option for making\n      an assertion.  */\n-  char **pend_assertion_options;\n+  const char **pend_assertion_options;\n   int no_standard_includes = 0;\n   int no_standard_cplusplus_includes = 0;\n   int missing_newline = 0;\n@@ -1199,7 +1211,7 @@ main (argc, argv)\n      This is 0 if deps are being written to stdout.  */\n   char *deps_file = 0;\n   /* Fopen file mode to open deps_file with.  */\n-  char *deps_mode = \"a\";\n+  const char *deps_mode = \"a\";\n   /* Stream on which to print the dependency information.  */\n   FILE *deps_stream = 0;\n   /* Target-name to write with the dependency information.  */\n@@ -1234,7 +1246,8 @@ main (argc, argv)\n   {\n     /* Remove extension from PROGNAME.  */\n     char *p;\n-    char *s = progname = xstrdup (progname);\n+    char *s = xstrdup (progname);\n+    progname = s;\n \n     if ((p = rindex (s, ';')) != 0) *p = '\\0';\t/* strip version number */\n     if ((p = rindex (s, '.')) != 0\t\t/* strip type iff \".exe\" */\n@@ -1254,7 +1267,7 @@ main (argc, argv)\n   pend_undefs = (char **) xmalloc (argc * sizeof (char *));\n   pend_assertions = (char **) xmalloc (argc * sizeof (char *));\n   pend_includes = (char **) xmalloc (argc * sizeof (char *));\n-  pend_assertion_options = (char **) xmalloc (argc * sizeof (char *));\n+  pend_assertion_options = (const char **) xmalloc (argc * sizeof (char *));\n \n   in_fname = NULL;\n   out_fname = NULL;\n@@ -1826,8 +1839,8 @@ main (argc, argv)\n \t}\n       }\n       /* Put the usual defaults back in at the end.  */\n-      bcopy ((char *) include_defaults_array,\n-\t     (char *) &include_defaults[num_dirs],\n+      bcopy ((const PTR) include_defaults_array,\n+\t     (PTR) &include_defaults[num_dirs],\n \t     sizeof (include_defaults_array));\n     }\n   }\n@@ -2216,17 +2229,17 @@ path_include (path)\n    If we knew we could use memchr, we could just invoke memchr (S, C, N),\n    but unfortunately memchr isn't autoconfigured yet.  */\n \n-static U_CHAR *\n+static const U_CHAR *\n index0 (s, c, n)\n-     U_CHAR *s;\n+     const U_CHAR *s;\n      int c;\n      size_t n;\n {\n-  char *p = (char *) s;\n+  const char *p = (const char *) s;\n   for (;;) {\n-    char *q = index (p, c);\n+    const char *q = index (p, c);\n     if (q)\n-      return (U_CHAR *) q;\n+      return q;\n     else {\n       size_t l = strlen (p);\n       if (l == n)\n@@ -2251,10 +2264,11 @@ static void\n trigraph_pcp (buf)\n      FILE_BUF *buf;\n {\n-  register U_CHAR c, *fptr, *bptr, *sptr, *lptr;\n+  register U_CHAR c, *bptr;\n+  register const U_CHAR *fptr, *sptr, *lptr;\n   int len;\n \n-  fptr = bptr = sptr = buf->buf;\n+  fptr = sptr = bptr = buf->buf;\n   lptr = fptr + buf->length;\n   while ((sptr = index0 (sptr, '?', (size_t) (lptr - sptr))) != NULL) {\n     if (*++sptr != '?')\n@@ -2298,15 +2312,15 @@ trigraph_pcp (buf)\n     /* BSD doc says bcopy () works right for overlapping strings.  In ANSI\n        C, this will be memmove ().  */\n     if (bptr != fptr && len > 0)\n-      bcopy ((char *) fptr, (char *) bptr, len);\n+      bcopy ((const PTR) fptr, (PTR) bptr, len);\n \n     bptr += len;\n     *bptr++ = c;\n     fptr = ++sptr;\n   }\n   len = buf->length - (fptr - buf->buf);\n   if (bptr != fptr && len > 0)\n-    bcopy ((char *) fptr, (char *) bptr, len);\n+    bcopy ((const PTR) fptr, (PTR) bptr, len);\n   buf->length -= fptr - bptr;\n   buf->buf[buf->length] = '\\0';\n   if (warn_trigraphs && fptr != bptr)\n@@ -2320,17 +2334,17 @@ static void\n check_white_space (buf)\n      FILE_BUF *buf;\n {\n-  register U_CHAR *sptr = buf->buf;\n-  register U_CHAR *lptr = sptr + buf->length;\n-  register U_CHAR *nptr;\n+  register const U_CHAR *sptr = buf->buf;\n+  register const U_CHAR *lptr = sptr + buf->length;\n+  register const U_CHAR *nptr;\n   int line = 0;\n \n   nptr = sptr = buf->buf;\n   lptr = sptr + buf->length;\n   for (nptr = sptr;\n        (nptr = index0 (nptr, '\\n', (size_t) (lptr - nptr))) != NULL;\n        nptr ++) {\n-    register U_CHAR *p = nptr;\n+    register const U_CHAR *p = nptr;\n     line++;\n     for (p = nptr; sptr < p; p--) {\n       if (! is_hor_space[p[-1]]) {\n@@ -2430,15 +2444,15 @@ name_newline_fix (bp)\n    arglen long.  Note that we don't parse that arg since it will just\n    be printed out again.  */\n \n-static char *\n+static const char *\n get_lintcmd (ibp, limit, argstart, arglen, cmdlen)\n-     register U_CHAR *ibp;\n-     register U_CHAR *limit;\n-     U_CHAR **argstart;\t\t/* point to command arg */\n+     register const U_CHAR *ibp;\n+     register const U_CHAR *limit;\n+     const U_CHAR **argstart;\t/* point to command arg */\n      int *arglen, *cmdlen;\t/* how long they are */\n {\n   HOST_WIDEST_INT linsize;\n-  register U_CHAR *numptr;\t/* temp for arg parsing */\n+  register const U_CHAR *numptr;\t/* temp for arg parsing */\n \n   *arglen = 0;\n \n@@ -2640,7 +2654,7 @@ do { ip = &instack[indepth];\t\t\\\n \tif (*ibp == '(') {\n \t  ip->bufp = ibp;\n \t  skip_paren_group (ip);\n-\t  bcopy ((char *) ibp, (char *) obp, ip->bufp - ibp);\n+\t  bcopy ((const PTR) ibp, (PTR) obp, ip->bufp - ibp);\n \t  obp += ip->bufp - ibp;\n \t  ibp = ip->bufp;\n \t}\n@@ -2918,7 +2932,7 @@ do { ip = &instack[indepth];\t\t\\\n \t    if (*ibp == '\\n')\n \t      {\n \t\tif (put_out_comments) {\n-\t\t  bcopy ((char *) before_bp, (char *) obp, ibp - before_bp);\n+\t\t  bcopy ((const PTR) before_bp, (PTR) obp, ibp - before_bp);\n \t\t  obp += ibp - before_bp;\n \t\t}\n \t\tbreak;\n@@ -2961,9 +2975,10 @@ do { ip = &instack[indepth];\t\t\\\n \n       /* If this cpp is for lint, we peek inside the comments: */\n       if (for_lint) {\n-\tU_CHAR *argbp;\n+\tconst U_CHAR *argbp;\n \tint cmdlen, arglen;\n-\tchar *lintcmd = get_lintcmd (ibp, limit, &argbp, &arglen, &cmdlen);\n+\tconst char *lintcmd =\n+\t  get_lintcmd (ibp, limit, &argbp, &arglen, &cmdlen);\n \n \tif (lintcmd != NULL) {\n \t  op->bufp = obp;\n@@ -3052,7 +3067,7 @@ do { ip = &instack[indepth];\t\t\\\n \n \tibp++;\n \tif (put_out_comments) {\n-\t  bcopy ((char *) before_bp, (char *) obp, ibp - before_bp);\n+\t  bcopy ((const PTR) before_bp, (PTR) obp, ibp - before_bp);\n \t  obp += ibp - before_bp;\n \t}\n       }\n@@ -3547,7 +3562,7 @@ do { ip = &instack[indepth];\t\t\\\n  ending:\n   if (if_stack != ip->if_stack)\n     {\n-      char *str;\n+      const char *str;\n \n       switch (if_stack->type)\n \t{\n@@ -3587,7 +3602,8 @@ do { ip = &instack[indepth];\t\t\\\n  */\n static FILE_BUF\n expand_to_temp_buffer (buf, limit, output_marks, assertions)\n-     U_CHAR *buf, *limit;\n+     const U_CHAR *buf;\n+     const U_CHAR *limit;\n      int output_marks, assertions;\n {\n   register FILE_BUF *ip;\n@@ -3606,7 +3622,7 @@ expand_to_temp_buffer (buf, limit, output_marks, assertions)\n \n   buf1 = (U_CHAR *) alloca (length + 1);\n   {\n-    register U_CHAR *p1 = buf;\n+    register const U_CHAR *p1 = buf;\n     register U_CHAR *p2 = buf1;\n \n     while (p1 != limit)\n@@ -3800,7 +3816,7 @@ handle_directive (ip, op)\n       keep_comments = traditional && kt->type == T_DEFINE;\n       /* #import is defined only in Objective C, or when on the NeXT.  */\n       if (kt->type == T_IMPORT\n-\t  && !(objc || lookup ((U_CHAR *) \"__NeXT__\", -1, -1)))\n+\t  && !(objc || lookup ((const U_CHAR *) \"__NeXT__\", -1, -1)))\n \tbreak;\n \n       /* Find the end of this directive (first newline not backslashed\n@@ -4005,7 +4021,7 @@ handle_directive (ip, op)\n \t    {\n \t      int backslash_newlines_p;\n \n-\t      register U_CHAR *bp1\n+\t      register const U_CHAR *bp1\n \t\t= skip_quoted_string (xp - 1, bp, ip->lineno,\n \t\t\t\t      NULL_PTR, &backslash_newlines_p, \n \t\t\t\t      NULL_PTR);\n@@ -4133,9 +4149,10 @@ timestamp ()\n   return &tmbuf;\n }\n \n-static char *monthnames[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n-\t\t\t     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n-\t\t\t    };\n+static const  char * const monthnames[] = {\n+  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n+  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n+};\n \n /*\n  * expand things like __FILE__.  Place the expansion into the output\n@@ -4147,7 +4164,7 @@ special_symbol (hp, op)\n      HASHNODE *hp;\n      FILE_BUF *op;\n {\n-  char *buf;\n+  const char *buf;\n   int i, len;\n   int true_indepth;\n   FILE_BUF *ip = NULL;\n@@ -4175,13 +4192,14 @@ special_symbol (hp, op)\n   case T_BASE_FILE:\n     {\n       FILE_BUF *p = hp->type == T_FILE ? ip : &instack[0];\n-      char *string = p->nominal_fname;\n+      const char *string = p->nominal_fname;\n \n       if (string)\n \t{\n \t  size_t string_len = p->nominal_fname_len;\n-\t  buf = (char *) alloca (3 + 4 * string_len);\n-\t  quote_string (buf, string, string_len);\n+\t  char *newbuf = (char *) alloca (3 + 4 * string_len);\n+\t  quote_string (newbuf, string, string_len);\n+\t  buf = newbuf;\n \t}\n       else\n \tbuf = \"\\\"\\\"\";\n@@ -4190,18 +4208,24 @@ special_symbol (hp, op)\n     }\n \n   case T_INCLUDE_LEVEL:\n-    true_indepth = 0;\n-    for (i = indepth; i >= 0; i--)\n-      if (instack[i].fname != NULL)\n-        true_indepth++;\n-\n-    buf = (char *) alloca (8);\t/* Eight bytes ought to be more than enough */\n-    sprintf (buf, \"%d\", true_indepth - 1);\n+    {\n+      /* Eight bytes ought to be more than enough */\n+      char *newbuf =  (char *) alloca (8);\n+      true_indepth = 0;\n+      for (i = indepth; i >= 0; i--)\n+\tif (instack[i].fname != NULL)\n+\t  true_indepth++;\n+      sprintf (newbuf, \"%d\", true_indepth - 1);\n+      buf = newbuf;\n+    }\n     break;\n \n   case T_VERSION:\n-    buf = (char *) alloca (3 + strlen (version_string));\n-    sprintf (buf, \"\\\"%s\\\"\", version_string);\n+    {\n+      char *newbuf = (char *) alloca (3 + strlen (version_string));\n+      sprintf (newbuf, \"\\\"%s\\\"\", version_string);\n+      buf = newbuf;\n+    }\n     break;\n \n #ifndef NO_BUILTIN_SIZE_TYPE\n@@ -4246,20 +4270,26 @@ special_symbol (hp, op)\n     break;\n \n   case T_SPECLINE:\n-    buf = (char *) alloca (10);\n-    sprintf (buf, \"%d\", ip->lineno);\n+    {\n+      char *newbuf = (char *) alloca (10);\n+      sprintf (newbuf, \"%d\", ip->lineno);\n+      buf = newbuf;\n+    }\n     break;\n \n   case T_DATE:\n   case T_TIME:\n-    buf = (char *) alloca (20);\n-    timebuf = timestamp ();\n-    if (hp->type == T_DATE)\n-      sprintf (buf, \"\\\"%s %2d %4d\\\"\", monthnames[timebuf->tm_mon],\n-\t      timebuf->tm_mday, timebuf->tm_year + 1900);\n-    else\n-      sprintf (buf, \"\\\"%02d:%02d:%02d\\\"\", timebuf->tm_hour, timebuf->tm_min,\n-\t      timebuf->tm_sec);\n+    {\n+      char *newbuf = (char *) alloca (20);\n+      timebuf = timestamp ();\n+      if (hp->type == T_DATE)\n+\tsprintf (newbuf, \"\\\"%s %2d %4d\\\"\", monthnames[timebuf->tm_mon],\n+\t\t timebuf->tm_mday, timebuf->tm_year + 1900);\n+      else\n+\tsprintf (newbuf, \"\\\"%02d:%02d:%02d\\\"\", timebuf->tm_hour,\n+\t\t timebuf->tm_min, timebuf->tm_sec);\n+      buf = newbuf;\n+    }\n     break;\n \n   case T_SPEC_DEFINED:\n@@ -4342,7 +4372,8 @@ do_include (buf, limit, op, keyword)\n      FILE_BUF *op;\n      struct directive *keyword;\n {\n-  U_CHAR *importing = keyword->type == T_IMPORT ? (U_CHAR *) \"\" : (U_CHAR *) 0;\n+  const U_CHAR *importing =\n+    keyword->type == T_IMPORT ? (const U_CHAR *) \"\" : (const U_CHAR *) 0;\n   int skip_dirs = (keyword->type == T_INCLUDE_NEXT);\n   static int import_warning = 0;\n   char *fname;\t\t/* Dynamically allocated fname buffer */\n@@ -4367,7 +4398,7 @@ do_include (buf, limit, op, keyword)\n #endif\n   int pcf = -1;\n   char *pcfbuf;\n-  char *pcfbuflimit;\n+  const char *pcfbuflimit;\n   int pcfnum;\n \n   if (pedantic && !instack[indepth].system_header_p)\n@@ -4441,15 +4472,15 @@ when it is equipped with such a conditional.\\n\");\n       for (fp = &instack[indepth]; fp >= instack; fp--)\n \t{\n \t  int n;\n-\t  char *nam;\n \n-\t  if ((nam = fp->nominal_fname) != NULL) {\n+\t  if ((fp->nominal_fname) != NULL) {\n+\t    char *nam;\n \t    /* Found a named file.  Figure out dir of the file,\n \t       and put it in front of the search list.  */\n \t    dsp = ((struct file_name_list *)\n \t\t   alloca (sizeof (struct file_name_list)\n \t\t\t   + fp->nominal_fname_len));\n-\t    strcpy (dsp->fname, nam);\n+\t    strcpy (dsp->fname, fp->nominal_fname);\n \t    simplify_filename (dsp->fname);\n \t    nam = base_name (dsp->fname);\n \t    *nam = 0;\n@@ -4519,10 +4550,9 @@ when it is equipped with such a conditional.\\n\");\n       /* Expand buffer and then remove any newline markers.\n \t We can't just tell expand_to_temp_buffer to omit the markers,\n \t since it would put extra spaces in include file names.  */\n-      FILE_BUF trybuf;\n       U_CHAR *src;\n       int errors_before_expansion = errors;\n-      trybuf = expand_to_temp_buffer (buf, limit, 1, 0);\n+      FILE_BUF trybuf = expand_to_temp_buffer (buf, limit, 1, 0);\n       if (errors != errors_before_expansion) {\n \tfree (trybuf.buf);\n \tgoto invalid_include_file_name;\n@@ -4540,7 +4570,7 @@ when it is equipped with such a conditional.\\n\");\n \t  case '\\'':\n \t  case '\\\"':\n \t    {\n-\t      U_CHAR *src1 = skip_quoted_string (src - 1, trybuf.bufp, 0,\n+\t      const U_CHAR *src1 = skip_quoted_string (src - 1, trybuf.bufp, 0,\n \t\t\t\t\t\t NULL_PTR, NULL_PTR, NULL_PTR);\n \t      while (src != src1)\n \t\t*limit++ = *src++;\n@@ -4788,7 +4818,7 @@ when it is equipped with such a conditional.\\n\");\n \n static int\n is_system_include (filename)\n-    register char *filename;\n+    register const char *filename;\n {\n   struct file_name_list *searchptr;\n \n@@ -4803,10 +4833,10 @@ is_system_include (filename)\n \n static char *\n base_name (fname)\n-     char *fname;\n+     const char *fname;\n {\n-  char *s = fname;\n-  char *p;\n+  const char *s = fname;\n+  const char *p;\n #if defined (__MSDOS__) || defined (_WIN32)\n   if (ISALPHA (s[0]) && s[1] == ':') s += 2;\n #endif\n@@ -4815,20 +4845,20 @@ base_name (fname)\n   if ((p = rindex (s, ']'))) s = p + 1;\t/* Skip directory.  */\n   if ((p = rindex (s, '>'))) s = p + 1;\t/* Skip alternate (int'n'l) dir.  */\n   if (s != fname)\n-    return s;\n+    return (char *) s;\n #endif\n   if ((p = rindex (s, '/'))) s = p + 1;\n #ifdef DIR_SEPARATOR\n   if ((p = rindex (s, DIR_SEPARATOR))) s = p + 1;\n #endif\n-  return s;\n+  return (char *) s;\n }\n \n /* Yield nonzero if FILENAME is absolute (i.e. not relative).  */\n \n static int\n absolute_filename (filename)\n-     char *filename;\n+     const char *filename;\n {\n #if defined (__MSDOS__) \\\n   || (defined (_WIN32) && !defined (__CYGWIN__) && !defined (_UWIN))\n@@ -4993,7 +5023,7 @@ read_filename_string (ch, f)\n \n static struct file_name_map *\n read_name_map (dirname)\n-     char *dirname;\n+     const char *dirname;\n {\n   /* This structure holds a linked list of file name maps, one per\n      directory.  */\n@@ -5091,7 +5121,7 @@ static int\n open_include_file (filename, searchptr, importing, pinc)\n      char *filename;\n      struct file_name_list *searchptr;\n-     U_CHAR *importing;\n+     const U_CHAR *importing;\n      struct include_file **pinc;\n {\n   char *fname = remap ? remap_include_file (filename, searchptr) : filename;\n@@ -5171,7 +5201,7 @@ remap_include_file (filename, searchptr)\n      struct file_name_list *searchptr;\n {\n   register struct file_name_map *map;\n-  register char *from;\n+  register const char *from;\n \n   if (searchptr)\n     {\n@@ -5360,7 +5390,7 @@ finclude (f, inc, op, system_header_p, dirptr)\n static void\n record_control_macro (inc, macro_name)\n      struct include_file *inc;\n-     U_CHAR *macro_name;\n+     const U_CHAR *macro_name;\n {\n   if (!inc->control_macro || inc->control_macro[0])\n     inc->control_macro = macro_name;\n@@ -5382,8 +5412,8 @@ static char *\n check_precompiled (pcf, st, fname, limit)\n      int pcf;\n      struct stat *st;\n-     char *fname ATTRIBUTE_UNUSED;\n-     char **limit;\n+     const char *fname ATTRIBUTE_UNUSED;\n+     const char **limit;\n {\n   int length = 0;\n   char *buf;\n@@ -5436,10 +5466,10 @@ check_precompiled (pcf, st, fname, limit)\n \n static int \n check_preconditions (prec)\n-     char *prec;\n+     const char *prec;\n {\n   MACRODEF mdef;\n-  char *lineend;\n+  const char *lineend;\n   \n   while (*prec) {\n     lineend = index (prec, '\\n');\n@@ -5452,7 +5482,8 @@ check_preconditions (prec)\n       HASHNODE *hp;\n       \n       prec += 6;\n-      mdef = create_definition ((U_CHAR *) prec, (U_CHAR *) lineend, NULL_PTR);\n+      mdef = create_definition ((const U_CHAR *) prec,\n+\t\t\t\t(const U_CHAR *) lineend, NULL_PTR);\n \n       if (mdef.defn == 0)\n \tabort ();\n@@ -5466,7 +5497,7 @@ check_preconditions (prec)\n \t\t  || mdef.defn->expansion[1] != ' ')))\n \treturn 0;\n     } else if (!strncmp (prec, \"undef\", 5)) {\n-      char *name;\n+      const char *name;\n       int len;\n       \n       prec += 5;\n@@ -5477,7 +5508,7 @@ check_preconditions (prec)\n \tprec++;\n       len = prec - name;\n       \n-      if (lookup ((U_CHAR *) name, len, -1))\n+      if (lookup ((const U_CHAR *) name, len, -1))\n \treturn 0;\n     } else {\n       error (\"Bad format encountered while reading precompiled file\");\n@@ -5496,7 +5527,8 @@ check_preconditions (prec)\n \n static void\n pcfinclude (buf, name, op)\n-     U_CHAR *buf, *name;\n+     U_CHAR *buf;\n+     const U_CHAR *name;\n      FILE_BUF *op;\n {\n   FILE_BUF tmpbuf;\n@@ -5644,14 +5676,14 @@ write_output ()\n     if (next_string\n \t&& cur_buf_loc - outbuf.buf == next_string->output_mark) {\n       if (next_string->writeflag) {\n-\tlen = 4 * strlen ((char *) next_string->filename) + 32;\n+\tlen = 4 * strlen ((const char *) next_string->filename) + 32;\n \twhile (len > line_directive_len)\n \t  line_directive = xrealloc (line_directive, \n \t\t\t\t     line_directive_len *= 2);\n \tsprintf (line_directive, \"\\n# %d \", next_string->lineno);\n \tstrcpy (quote_string (line_directive + strlen (line_directive),\n-\t\t\t      (char *) next_string->filename,\n-\t\t\t      strlen ((char *) next_string->filename)),\n+\t\t\t      (const char *) next_string->filename,\n+\t\t\t      strlen ((const char *) next_string->filename)),\n \t\t\"\\n\");\n \tsafe_write (fileno (stdout), line_directive, strlen (line_directive));\n \tsafe_write (fileno (stdout),\n@@ -5679,7 +5711,8 @@ write_output ()\n \n static void\n pass_thru_directive (buf, limit, op, keyword)\n-     U_CHAR *buf, *limit;\n+     const U_CHAR *buf;\n+     const U_CHAR *limit;\n      FILE_BUF *op;\n      struct directive *keyword;\n {\n@@ -5691,7 +5724,7 @@ pass_thru_directive (buf, limit, op, keyword)\n   op->bufp += keyword_length;\n   if (limit != buf && buf[0] != ' ')\n     *op->bufp++ = ' ';\n-  bcopy ((char *) buf, (char *) op->bufp, limit - buf);\n+  bcopy ((const PTR) buf, (PTR) op->bufp, limit - buf);\n   op->bufp += (limit - buf);\n #if 0\n   *op->bufp++ = '\\n';\n@@ -5714,7 +5747,7 @@ pass_thru_directive (buf, limit, op, keyword)\n \n struct arglist {\n   struct arglist *next;\n-  U_CHAR *name;\n+  const U_CHAR *name;\n   int length;\n   int argno;\n   char rest_args;\n@@ -5725,14 +5758,14 @@ struct arglist {\n \n static MACRODEF\n create_definition (buf, limit, op)\n-     U_CHAR *buf, *limit;\n+     const U_CHAR *buf, *limit;\n      FILE_BUF *op;\n {\n-  U_CHAR *bp;\t\t\t/* temp ptr into input buffer */\n-  U_CHAR *symname;\t\t/* remember where symbol name starts */\n+  const U_CHAR *bp;\t\t/* temp ptr into input buffer */\n+  const U_CHAR *symname;\t/* remember where symbol name starts */\n   int sym_length;\t\t/* and how long it is */\n   int line = instack[indepth].lineno;\n-  char *file = instack[indepth].nominal_fname;\n+  const char *file = instack[indepth].nominal_fname;\n   size_t file_len = instack[indepth].nominal_fname_len;\n   int rest_args = 0;\n \n@@ -6018,10 +6051,10 @@ do_define (buf, limit, op, keyword)\n \n static int\n check_macro_name (symname, assertion)\n-     U_CHAR *symname;\n+     const U_CHAR *symname;\n      int assertion;\n {\n-  U_CHAR *p;\n+  const U_CHAR *p;\n   int sym_length;\n \n   for (p = symname; is_idchar[*p]; p++)\n@@ -6088,12 +6121,12 @@ compare_defs (d1, d2)\n static int\n comp_def_part (first, beg1, len1, beg2, len2, last)\n      int first;\n-     U_CHAR *beg1, *beg2;\n+     const U_CHAR *beg1, *beg2;\n      int len1, len2;\n      int last;\n {\n-  register U_CHAR *end1 = beg1 + len1;\n-  register U_CHAR *end2 = beg2 + len2;\n+  register const U_CHAR *end1 = beg1 + len1;\n+  register const U_CHAR *end2 = beg2 + len2;\n   if (first) {\n     while (beg1 != end1 && is_space[*beg1]) beg1++;\n     while (beg2 != end2 && is_space[*beg2]) beg2++;\n@@ -6130,17 +6163,20 @@ have already been deleted from the argument.  */\n \n static DEFINITION *\n collect_expansion (buf, end, nargs, arglist)\n-     U_CHAR *buf, *end;\n+     const U_CHAR *buf;\n+     const U_CHAR *end;\n      int nargs;\n      struct arglist *arglist;\n {\n   DEFINITION *defn;\n-  register U_CHAR *p, *limit, *lastp, *exp_p;\n+  register const U_CHAR *p;\n+  register const U_CHAR *limit;\n+  register U_CHAR *lastp, *exp_p;\n   struct reflist *endpat = NULL;\n   /* Pointer to first nonspace after last ## seen.  */\n-  U_CHAR *concat = 0;\n+  const U_CHAR *concat = 0;\n   /* Pointer to first nonspace after last single-# seen.  */\n-  U_CHAR *stringify = 0;\n+  const U_CHAR *stringify = 0;\n   /* How those tokens were spelled.  */\n   enum sharp_token_type concat_sharp_token_type = NO_SHARP_TOKEN;\n   enum sharp_token_type stringify_sharp_token_type = NO_SHARP_TOKEN;\n@@ -6208,7 +6244,7 @@ collect_expansion (buf, end, nargs, arglist)\n       case '%':\n \tif (!expected_delimiter && *p == ':') {\n \t  /* %: is not a digraph if preceded by an odd number of '<'s.  */\n-\t  U_CHAR *p0 = p - 1;\n+\t  const U_CHAR *p0 = p - 1;\n \t  while (buf < p0 && p0[-1] == '<')\n \t    p0--;\n \t  if ((p - p0) & 1) {\n@@ -6334,7 +6370,7 @@ collect_expansion (buf, end, nargs, arglist)\n \n     /* Handle the start of a symbol.  */\n     if (is_idchar[c] && nargs > 0) {\n-      U_CHAR *id_beg = p - 1;\n+      const U_CHAR *id_beg = p - 1;\n       int id_len;\n \n       --exp_p;\n@@ -6390,7 +6426,7 @@ collect_expansion (buf, end, nargs, arglist)\n \t    tpat->argno = arg->argno;\n \t    tpat->nchars = exp_p - lastp;\n \t    {\n-\t      register U_CHAR *p1 = p;\n+\t      register const U_CHAR *p1 = p;\n \t      SKIP_WHITE_SPACE (p1);\n \t      if (p1[0]=='#'\n \t          ? p1[1]=='#'\n@@ -6406,7 +6442,7 @@ collect_expansion (buf, end, nargs, arglist)\n \n       /* If this was not a macro arg, copy it into the expansion.  */\n       if (! skipped_arg) {\n-\tregister U_CHAR *lim1 = p;\n+\tregister const U_CHAR *lim1 = p;\n \tp = id_beg;\n \twhile (p != lim1)\n \t  *exp_p++ = *p++;\n@@ -6447,8 +6483,8 @@ do_assert (buf, limit, op, keyword)\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  U_CHAR *bp;\t\t\t/* temp ptr into input buffer */\n-  U_CHAR *symname;\t\t/* remember where symbol name starts */\n+  const U_CHAR *bp;\t\t/* temp ptr into input buffer */\n+  const U_CHAR *symname;\t/* remember where symbol name starts */\n   int sym_length;\t\t/* and how long it is */\n   struct arglist *tokens = NULL;\n \n@@ -6524,8 +6560,8 @@ do_unassert (buf, limit, op, keyword)\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  U_CHAR *bp;\t\t\t/* temp ptr into input buffer */\n-  U_CHAR *symname;\t\t/* remember where symbol name starts */\n+  const U_CHAR *bp;\t\t/* temp ptr into input buffer */\n+  const U_CHAR *symname;\t/* remember where symbol name starts */\n   int sym_length;\t\t/* and how long it is */\n \n   struct arglist *tokens = NULL;\n@@ -6620,7 +6656,7 @@ do_unassert (buf, limit, op, keyword)\n \n int\n check_assertion (name, sym_length, tokens_specified, tokens)\n-     U_CHAR *name;\n+     const U_CHAR *name;\n      int sym_length;\n      int tokens_specified;\n      struct arglist *tokens;\n@@ -6686,21 +6722,22 @@ compare_token_lists (l1, l2)\n \n static struct arglist *\n read_token_list (bpp, limit, error_flag)\n-     U_CHAR **bpp;\n-     U_CHAR *limit;\n+     const U_CHAR **bpp;\n+     const U_CHAR *limit;\n      int *error_flag;\n {\n   struct arglist *token_ptrs = 0;\n-  U_CHAR *bp = *bpp;\n+  const U_CHAR *bp = *bpp;\n   int depth = 1;\n \n   *error_flag = 0;\n \n   /* Loop over the assertion value tokens.  */\n   while (depth > 0) {\n     struct arglist *temp;\n+    U_CHAR *temp2;\n     int eofp = 0;\n-    U_CHAR *beg = bp;\n+    const U_CHAR *beg = bp;\n \n     /* Find the end of the token.  */\n     if (*bp == '(') {\n@@ -6719,9 +6756,10 @@ read_token_list (bpp, limit, error_flag)\n \tbp++;\n \n     temp = (struct arglist *) xmalloc (sizeof (struct arglist));\n-    temp->name = (U_CHAR *) xmalloc (bp - beg + 1);\n-    bcopy ((char *) beg, (char *) temp->name, bp - beg);\n-    temp->name[bp - beg] = 0;\n+    temp2 = (U_CHAR *) xmalloc (bp - beg + 1);\n+    bcopy ((const PTR) beg, (PTR) temp2, bp - beg);\n+    temp2[bp - beg] = 0;\n+    temp->name = temp2;\n     temp->next = token_ptrs;\n     token_ptrs = temp;\n     temp->length = bp - beg;\n@@ -6755,7 +6793,7 @@ free_token_list (tokens)\n {\n   while (tokens) {\n     struct arglist *next = tokens->next;\n-    free (tokens->name);\n+    free ((PTR) tokens->name);\n     free (tokens);\n     tokens = next;\n   }\n@@ -6771,13 +6809,14 @@ free_token_list (tokens)\n \n static ASSERTION_HASHNODE *\n assertion_install (name, len, hash)\n-     U_CHAR *name;\n+     const U_CHAR *name;\n      int len;\n      int hash;\n {\n   register ASSERTION_HASHNODE *hp;\n   register int i, bucket;\n-  register U_CHAR *p, *q;\n+  register U_CHAR *p;\n+  register const U_CHAR *q;\n \n   i = sizeof (ASSERTION_HASHNODE) + len + 1;\n   hp = (ASSERTION_HASHNODE *) xmalloc (i);\n@@ -6810,7 +6849,7 @@ assertion_install (name, len, hash)\n \n static ASSERTION_HASHNODE *\n assertion_lookup (name, len, hash)\n-     U_CHAR *name;\n+     const U_CHAR *name;\n      int len;\n      int hash;\n {\n@@ -6980,7 +7019,7 @@ do_line (buf, limit, op, keyword)\n \n       ip->nominal_fname = hp->value.cpval = ((char *) hp) + sizeof (HASHNODE);\n       ip->nominal_fname_len = hp->length = fname_length;\n-      bcopy (fname, hp->value.cpval, fname_length + 1);\n+      bcopy (fname, ((char *) hp) + sizeof (HASHNODE), fname_length + 1);\n     }\n   } else if (*bp) {\n     error (\"invalid format `#line' directive\");\n@@ -7049,7 +7088,7 @@ do_error (buf, limit, op, keyword)\n {\n   int length = limit - buf;\n   U_CHAR *copy = (U_CHAR *) alloca (length + 1);\n-  bcopy ((char *) buf, (char *) copy, length);\n+  bcopy ((const PTR) buf, (PTR) copy, length);\n   copy[length] = 0;\n   SKIP_WHITE_SPACE (copy);\n \n@@ -7080,7 +7119,7 @@ do_once ()\n \n   for (i = indepth; i >= 0; i--)\n     if (instack[i].inc) {\n-      record_control_macro (instack[i].inc, (U_CHAR *) \"\");\n+      record_control_macro (instack[i].inc, (const U_CHAR *) \"\");\n       break;\n     }\n }\n@@ -7108,7 +7147,7 @@ do_ident (buf, limit, op, keyword)\n   check_expand (op, 7 + len);\n   bcopy (\"#ident \", (char *) op->bufp, 7);\n   op->bufp += 7;\n-  bcopy ((char *) buf, (char *) op->bufp, len);\n+  bcopy ((const PTR) buf, (PTR) op->bufp, len);\n   op->bufp += len;\n \n   free (buf);\n@@ -7215,7 +7254,8 @@ do_pragma ()\n \n static int\n do_sccs (buf, limit, op, keyword)\n-     U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n+     U_CHAR *buf ATTRIBUTE_UNUSED;\n+     U_CHAR *limit ATTRIBUTE_UNUSED;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n {\n@@ -7301,14 +7341,14 @@ do_elif (buf, limit, op, keyword)\n \n static HOST_WIDEST_INT\n eval_if_expression (buf, length)\n-     U_CHAR *buf;\n+     const U_CHAR *buf;\n      int length;\n {\n   FILE_BUF temp_obuf;\n   HASHNODE *save_defined;\n   HOST_WIDEST_INT value;\n \n-  save_defined = install ((U_CHAR *) \"defined\", -1, T_SPEC_DEFINED,\n+  save_defined = install ((const U_CHAR *) \"defined\", -1, T_SPEC_DEFINED,\n \t\t\t  NULL_PTR, -1);\n   pcp_inside_if = 1;\n   temp_obuf = expand_to_temp_buffer (buf, buf + length, 0, 1);\n@@ -7414,7 +7454,7 @@ do_xifdef (buf, limit, op, keyword)\n     skip = (hp == NULL) ^ (keyword->type == T_IFNDEF);\n     if (start_of_file && !skip) {\n       control_macro = (U_CHAR *) xmalloc (end - buf + 1);\n-      bcopy ((char *) buf, (char *) control_macro, end - buf);\n+      bcopy ((const PTR) buf, (PTR) control_macro, end - buf);\n       control_macro[end - buf] = 0;\n     }\n   }\n@@ -7433,7 +7473,7 @@ conditional_skip (ip, skip, type, control_macro, op)\n      FILE_BUF *ip;\n      int skip;\n      enum node_type type;\n-     U_CHAR *control_macro;\n+     const U_CHAR *control_macro;\n      FILE_BUF *op;\n {\n   IF_STACK_FRAME *temp;\n@@ -7480,7 +7520,7 @@ skip_if_group (ip, any, op)\n   int skipping_include_directive = 0;\n \n   if (output_conditionals && op != 0) {\n-    char *ptr = \"#failed\\n\";\n+    static const char * const ptr = \"#failed\\n\";\n     int len = strlen (ptr);\n \n     if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n@@ -7805,7 +7845,7 @@ skip_if_group (ip, any, op)\n \n  done:\n   if (output_conditionals && op != 0) {\n-    char *ptr = \"#endfailed\\n\";\n+    static const char * const ptr = \"#endfailed\\n\";\n     int len = strlen (ptr);\n \n     if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n@@ -7814,7 +7854,7 @@ skip_if_group (ip, any, op)\n \top->lineno++;\n       }\n     check_expand (op, beg_of_line - beg_of_group);\n-    bcopy ((char *) beg_of_group, (char *) op->bufp,\n+    bcopy ((const PTR) beg_of_group, (PTR) op->bufp,\n \t   beg_of_line - beg_of_group);\n     op->bufp += beg_of_line - beg_of_group;\n     op->lineno += ip->lineno - beg_lineno;\n@@ -7943,8 +7983,8 @@ do_endif (buf, limit, op, keyword)\n \n static void\n validate_else (p, limit)\n-     register U_CHAR *p;\n-     register U_CHAR *limit;\n+     register const U_CHAR *p;\n+     register const U_CHAR *limit;\n {\n   /* Advance P over whitespace and comments.  */\n   while (1) {\n@@ -8133,8 +8173,8 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n \n static U_CHAR *\n skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p, eofp)\n-     register U_CHAR *bp;\n-     register U_CHAR *limit;\n+     register const U_CHAR *bp;\n+     register const U_CHAR *limit;\n      int start_line;\n      int *count_newlines;\n      int *backslash_newlines_p;\n@@ -8211,7 +8251,7 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n     }\n #endif\n   }\n-  return bp;\n+  return (U_CHAR *) bp;\n }\n \n /* Place into DST a quoted string representing the string SRC.\n@@ -8220,11 +8260,12 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n \n static char *\n quote_string (dst, src, srclen)\n-     char *dst, *src;\n+     char *dst;\n+     const char *src;\n      size_t srclen;\n {\n   U_CHAR c;\n-  char *srclim = src + srclen;\n+  const char *srclim = src + srclen;\n \n   *dst++ = '\\\"';\n   while (src != srclim)\n@@ -8373,7 +8414,7 @@ output_line_directive (ip, op, conditional, file_change)\n   check_expand (op, len + 1);\n   if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n     *op->bufp++ = '\\n';\n-  bcopy ((char *) line_directive_buf, (char *) op->bufp, len);\n+  bcopy ((const PTR) line_directive_buf, (PTR) op->bufp, len);\n   op->bufp += len;\n   op->lineno = ip->lineno;\n }\n@@ -8480,8 +8521,8 @@ macroexpand (hp, op)\n \n     /* If we got one arg but it was just whitespace, call that 0 args.  */\n     if (i == 1) {\n-      register U_CHAR *bp = args[0].raw;\n-      register U_CHAR *lim = bp + args[0].raw_length;\n+      register const U_CHAR *bp = args[0].raw;\n+      register const U_CHAR *lim = bp + args[0].raw_length;\n       /* cpp.texi says for foo ( ) we provide one argument.\n \t However, if foo wants just 0 arguments, treat this as 0.  */\n       if (nargs == 0)\n@@ -8695,8 +8736,8 @@ macroexpand (hp, op)\n \t  if (!traditional)\n \t    xbuf[totlen++] = '\\\"'; /* insert ending quote */\n \t} else if (ap->raw_before != 0 || ap->raw_after != 0 || traditional) {\n-\t  U_CHAR *p1 = arg->raw;\n-\t  U_CHAR *l1 = p1 + arg->raw_length;\n+\t  const U_CHAR *p1 = arg->raw;\n+\t  const U_CHAR *l1 = p1 + arg->raw_length;\n \t  if (ap->raw_before != 0) {\n \t    while (p1 != l1 && is_space[*p1]) p1++;\n \t    while (p1 != l1 && is_idchar[*p1])\n@@ -8718,7 +8759,7 @@ macroexpand (hp, op)\n \t    while (p1 != l1) {\n \t      if (is_space[l1[-1]]) l1--;\n \t      else if (l1[-1] == '-') {\n-\t\tU_CHAR *p2 = l1 - 1;\n+\t\tconst U_CHAR *p2 = l1 - 1;\n \t\t/* If a `-' is preceded by an odd number of newlines then it\n \t\t   and the last newline are a no-reexpansion marker.  */\n \t\twhile (p2 != p1 && p2[-1] == '\\n') p2--;\n@@ -8731,7 +8772,7 @@ macroexpand (hp, op)\n \t    }\n \t  }\n \n-\t  bcopy ((char *) p1, (char *) (xbuf + totlen), l1 - p1);\n+\t  bcopy ((const PTR) p1, (PTR) (xbuf + totlen), l1 - p1);\n \t  totlen += l1 - p1;\n \t  if (!traditional && ap->raw_after == 0) {\n \t    /* Ordinary expanded use of the argument.\n@@ -8746,7 +8787,7 @@ macroexpand (hp, op)\n \t    xbuf[totlen++] = '\\n';\n \t    xbuf[totlen++] = ' ';\n \t  }\n-\t  bcopy ((char *) arg->expanded, (char *) (xbuf + totlen),\n+\t  bcopy ((const PTR) arg->expanded, (PTR) (xbuf + totlen),\n \t\t arg->expand_length);\n \t  totlen += arg->expand_length;\n \t  if (!traditional) {\n@@ -8867,7 +8908,7 @@ macarg (argptr, rest_args)\n     U_CHAR *buffer = (U_CHAR *) xmalloc (bufsize + extra + 1);\n     int final_start = 0;\n \n-    bcopy ((char *) ip->bufp, (char *) buffer, bufsize);\n+    bcopy ((const PTR) ip->bufp, (PTR) buffer, bufsize);\n     ip->bufp = bp;\n \n     while (bp == ip->buf + ip->length) {\n@@ -8887,7 +8928,7 @@ macarg (argptr, rest_args)\n       bufsize += bp - ip->bufp;\n       extra += ip->lineno - lineno0;\n       buffer = (U_CHAR *) xrealloc (buffer, bufsize + extra + 1);\n-      bcopy ((char *) ip->bufp, (char *) (buffer + bufsize - (bp - ip->bufp)),\n+      bcopy ((const PTR) ip->bufp, (PTR) (buffer + bufsize - (bp - ip->bufp)),\n \t     bp - ip->bufp);\n       ip->bufp = bp;\n     }\n@@ -8919,7 +8960,7 @@ macarg (argptr, rest_args)\n      All this info goes into *ARGPTR.  */\n \n   if (argptr != 0) {\n-    register U_CHAR *buf, *lim;\n+    register const U_CHAR *buf, *lim;\n     register int totlen;\n \n     buf = argptr->raw;\n@@ -8966,7 +9007,7 @@ macarg (argptr, rest_args)\n static U_CHAR *\n macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n      U_CHAR *start;\n-     register U_CHAR *limit;\n+     register const U_CHAR *limit;\n      struct hashnode *macro;\n      int *depthptr, *newlines, *comments;\n      int rest_args;\n@@ -9263,7 +9304,7 @@ change_newlines (arg)\n   int length = arg->expand_length;\n   register U_CHAR *ibp;\n   register U_CHAR *obp;\n-  register U_CHAR *limit;\n+  register const U_CHAR *limit;\n   register int c;\n \n   ibp = start;\n@@ -9408,7 +9449,7 @@ verror (msgid, args)\n \n static void\n error_from_errno (name)\n-     char *name;\n+     const char *name;\n {\n   int e = errno;\n   int i;\n@@ -9817,21 +9858,22 @@ grow_outbuf (obuf, needed)\n \n static HASHNODE *\n install (name, len, type, value, hash)\n-     U_CHAR *name;\n+     const U_CHAR *name;\n      int len;\n      enum node_type type;\n-     char *value;\n+     const char *value;\n      int hash;\n {\n   register HASHNODE *hp;\n   register int i, bucket;\n-  register U_CHAR *p, *q;\n+  register U_CHAR *p;\n+  register const U_CHAR *q;\n \n   if (len < 0) {\n-    p = name;\n-    while (is_idchar[*p])\n-      p++;\n-    len = p - name;\n+    q = name;\n+    while (is_idchar[*q])\n+      q++;\n+    len = q - name;\n   }\n \n   if (hash < 0)\n@@ -9871,11 +9913,11 @@ install (name, len, type, value, hash)\n \n HASHNODE *\n lookup (name, len, hash)\n-     U_CHAR *name;\n+     const U_CHAR *name;\n      int len;\n      int hash;\n {\n-  register U_CHAR *bp;\n+  register const U_CHAR *bp;\n   register HASHNODE *bucket;\n \n   if (len < 0) {\n@@ -9946,7 +9988,7 @@ delete_macro (hp)\n \n static int\n hashf (name, len, hashsize)\n-     register U_CHAR *name;\n+     register const U_CHAR *name;\n      register int len;\n      int hashsize;\n {\n@@ -10070,21 +10112,21 @@ dump_all_macros ()\n \n static void\n dump_defn_1 (base, start, length, of)\n-     U_CHAR *base;\n+     const U_CHAR *base;\n      int start;\n      int length;\n      FILE *of;\n {\n-  U_CHAR *p = base + start;\n-  U_CHAR *limit = base + start + length;\n+  const U_CHAR *p = base + start;\n+  const U_CHAR *limit = base + start + length;\n \n   if (traditional)\n     fwrite (p, sizeof (*p), length, of);\n   else {\n     while (p < limit) {\n       if (*p == '\\\"' || *p =='\\'') {\n-\tU_CHAR *p1 = skip_quoted_string (p, limit, 0, NULL_PTR,\n-\t\t\t\t\t NULL_PTR, NULL_PTR);\n+\tconst U_CHAR *p1 = skip_quoted_string (p, limit, 0, NULL_PTR,\n+\t\t\t\t\t       NULL_PTR, NULL_PTR);\n \tfwrite (p, sizeof (*p), p1 - p, of);\n \tp = p1;\n       } else {\n@@ -10167,34 +10209,34 @@ initialize_builtins (inp, outp)\n      FILE_BUF *inp;\n      FILE_BUF *outp;\n {\n-  install ((U_CHAR *) \"__LINE__\", -1, T_SPECLINE, NULL_PTR, -1);\n-  install ((U_CHAR *) \"__DATE__\", -1, T_DATE, NULL_PTR, -1);\n-  install ((U_CHAR *) \"__FILE__\", -1, T_FILE, NULL_PTR, -1);\n-  install ((U_CHAR *) \"__BASE_FILE__\", -1, T_BASE_FILE, NULL_PTR, -1);\n-  install ((U_CHAR *) \"__INCLUDE_LEVEL__\", -1, T_INCLUDE_LEVEL, NULL_PTR, -1);\n-  install ((U_CHAR *) \"__VERSION__\", -1, T_VERSION, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__LINE__\", -1, T_SPECLINE, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__DATE__\", -1, T_DATE, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__FILE__\", -1, T_FILE, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__BASE_FILE__\", -1, T_BASE_FILE, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__INCLUDE_LEVEL__\", -1, T_INCLUDE_LEVEL, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__VERSION__\", -1, T_VERSION, NULL_PTR, -1);\n #ifndef NO_BUILTIN_SIZE_TYPE\n-  install ((U_CHAR *) \"__SIZE_TYPE__\", -1, T_SIZE_TYPE, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__SIZE_TYPE__\", -1, T_SIZE_TYPE, NULL_PTR, -1);\n #endif\n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n-  install ((U_CHAR *) \"__PTRDIFF_TYPE__ \", -1, T_PTRDIFF_TYPE, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__PTRDIFF_TYPE__ \", -1, T_PTRDIFF_TYPE, NULL_PTR, -1);\n #endif\n-  install ((U_CHAR *) \"__WCHAR_TYPE__\", -1, T_WCHAR_TYPE, NULL_PTR, -1);\n-  install ((U_CHAR *) \"__USER_LABEL_PREFIX__\", -1, T_USER_LABEL_PREFIX_TYPE,\n+  install ((const U_CHAR *) \"__WCHAR_TYPE__\", -1, T_WCHAR_TYPE, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__USER_LABEL_PREFIX__\", -1, T_USER_LABEL_PREFIX_TYPE,\n \t   NULL_PTR, -1);\n-  install ((U_CHAR *) \"__REGISTER_PREFIX__\", -1, T_REGISTER_PREFIX_TYPE,\n+  install ((const U_CHAR *) \"__REGISTER_PREFIX__\", -1, T_REGISTER_PREFIX_TYPE,\n \t   NULL_PTR, -1);\n-  install ((U_CHAR *) \"__IMMEDIATE_PREFIX__\", -1, T_IMMEDIATE_PREFIX_TYPE,\n+  install ((const U_CHAR *) \"__IMMEDIATE_PREFIX__\", -1, T_IMMEDIATE_PREFIX_TYPE,\n \t   NULL_PTR, -1);\n-  install ((U_CHAR *) \"__TIME__\", -1, T_TIME, NULL_PTR, -1);\n+  install ((const U_CHAR *) \"__TIME__\", -1, T_TIME, NULL_PTR, -1);\n   if (!traditional) {\n-    install ((U_CHAR *) \"__STDC__\", -1, T_CONST, \"1\", -1);\n-    install ((U_CHAR *) \"__STDC_VERSION__\", -1, T_CONST, \"199409L\", -1);\n+    install ((const U_CHAR *) \"__STDC__\", -1, T_CONST, \"1\", -1);\n+    install ((const U_CHAR *) \"__STDC_VERSION__\", -1, T_CONST, \"199409L\", -1);\n   }\n /*  This is supplied using a -D by the compiler driver\n     so that it is present only when truly compiling with GNU C.  */\n /*  install ((U_CHAR *) \"__GNUC__\", -1, T_CONST, \"2\", -1);  */\n-  install ((U_CHAR *) \"__HAVE_BUILTIN_SETJMP__\", -1, T_CONST, \"1\", -1);\n+  install ((const U_CHAR *) \"__HAVE_BUILTIN_SETJMP__\", -1, T_CONST, \"1\", -1);\n \n   if (debug_output)\n     {\n@@ -10311,7 +10353,7 @@ make_definition (str)\n     while (*p) {\n       if (*p == '\\\"' || *p == '\\'') {\n \tint unterminated = 0;\n-\tU_CHAR *p1 = skip_quoted_string (p, p + strlen ((char *) p), 0,\n+\tconst U_CHAR *p1 = skip_quoted_string (p, p + strlen ((char *) p), 0,\n \t\t\t\t\t NULL_PTR, NULL_PTR, &unterminated);\n \tif (unterminated)\n \t  return;\n@@ -10719,15 +10761,15 @@ fancy_abort ()\n \n static void\n perror_with_name (name)\n-     char *name;\n+     const char *name;\n {\n   fprintf (stderr, \"%s: %s: %s\\n\", progname, name, xstrerror (errno));\n   errors++;\n }\n \n static void\n pfatal_with_name (name)\n-     char *name;\n+     const char *name;\n {\n   perror_with_name (name);\n #ifdef VMS"}, {"sha": "4065c95de9e21eae0fd1a8fb29476f0616b0ae20", "filename": "gcc/pcp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b79993fd512c13fc94cfe8aad2f8387a7f614a1/gcc%2Fpcp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b79993fd512c13fc94cfe8aad2f8387a7f614a1/gcc%2Fpcp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpcp.h?ref=4b79993fd512c13fc94cfe8aad2f8387a7f614a1", "patch": "@@ -28,7 +28,7 @@ struct stringdef\n   int len;\t\t\t/* Its length */\n   int writeflag;\t\t/* Whether we write this */\n   int lineno;\t\t\t/* Linenumber of source file */\n-  U_CHAR *filename;\t\t/* Name of source file */\n+  const U_CHAR *filename;\t/* Name of source file */\n   STRINGDEF *chain;\t\t/* Global list of strings in natural order */\n   int output_mark;\t\t/* Where in the output this goes */\n };"}]}