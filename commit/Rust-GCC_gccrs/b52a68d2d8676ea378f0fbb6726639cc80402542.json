{"sha": "b52a68d2d8676ea378f0fbb6726639cc80402542", "node_id": "C_kwDOANBUbNoAKGI1MmE2OGQyZDg2NzZlYTM3OGYwZmJiNjcyNjYzOWNjODA0MDI1NDI", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-15T19:17:26Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-16T21:04:58Z"}, "message": "Replace Bexpression with GCC tree", "tree": {"sha": "fa70c52eb6f879864fa76908a2cf670b50d88e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa70c52eb6f879864fa76908a2cf670b50d88e48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52a68d2d8676ea378f0fbb6726639cc80402542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52a68d2d8676ea378f0fbb6726639cc80402542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52a68d2d8676ea378f0fbb6726639cc80402542", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52a68d2d8676ea378f0fbb6726639cc80402542/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a751f354a91a8459b877c60a5e5d78203aeb3ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a751f354a91a8459b877c60a5e5d78203aeb3ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a751f354a91a8459b877c60a5e5d78203aeb3ce"}], "stats": {"total": 1046, "additions": 455, "deletions": 591}, "files": [{"sha": "56504515b5c0a0c1207553ddba8fd803b49a685f", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -200,16 +200,14 @@ class HIRCompileBase : public HIR::HIRVisitor\n   bool compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \t\t\t\t std::vector<Bvariable *> &locals);\n \n-  Bexpression *coercion_site (Bexpression *compiled_ref, TyTy::BaseType *actual,\n-\t\t\t      TyTy::BaseType *expected, Location locus);\n+  tree coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n+\t\t      TyTy::BaseType *expected, Location locus);\n \n-  Bexpression *coerce_to_dyn_object (Bexpression *compiled_ref,\n-\t\t\t\t     const TyTy::BaseType *actual,\n-\t\t\t\t     const TyTy::BaseType *expected,\n-\t\t\t\t     const TyTy::DynamicObjectType *ty,\n-\t\t\t\t     Location locus);\n+  tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,\n+\t\t\t     const TyTy::BaseType *expected,\n+\t\t\t     const TyTy::DynamicObjectType *ty, Location locus);\n \n-  Bexpression *compute_address_for_trait_item (\n+  tree compute_address_for_trait_item (\n     const Resolver::TraitItemReference *ref,\n     const TyTy::TypeBoundPredicate *predicate,\n     std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>"}, {"sha": "35ea01286cb480d8f690bf4a60b530fe026c37d8", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -210,12 +210,9 @@ class Context\n     return true;\n   }\n \n-  void insert_const_decl (HirId id, ::Bexpression *expr)\n-  {\n-    compiled_consts[id] = expr;\n-  }\n+  void insert_const_decl (HirId id, ::tree expr) { compiled_consts[id] = expr; }\n \n-  bool lookup_const_decl (HirId id, ::Bexpression **expr)\n+  bool lookup_const_decl (HirId id, ::tree *expr)\n   {\n     auto it = compiled_consts.find (id);\n     if (it == compiled_consts.end ())\n@@ -249,7 +246,7 @@ class Context\n \n   void push_type (::tree t) { type_decls.push_back (t); }\n   void push_var (::Bvariable *v) { var_decls.push_back (v); }\n-  void push_const (::Bexpression *c) { const_decls.push_back (c); }\n+  void push_const (::tree c) { const_decls.push_back (c); }\n   void push_function (::Bfunction *f) { func_decls.push_back (f); }\n \n   void write_to_backend ()\n@@ -322,9 +319,9 @@ class Context\n   // state\n   std::vector<fncontext> fn_stack;\n   std::map<HirId, ::Bvariable *> compiled_var_decls;\n-  std::map<HirId, ::tree > compiled_type_map;\n+  std::map<HirId, tree> compiled_type_map;\n   std::map<HirId, ::Bfunction *> compiled_fn_map;\n-  std::map<HirId, ::Bexpression *> compiled_consts;\n+  std::map<HirId, tree> compiled_consts;\n   std::map<HirId, ::Blabel *> compiled_labels;\n   std::vector<::std::vector<Bstatement *>> statements;\n   std::vector<::Bblock *> scope_stack;\n@@ -337,7 +334,7 @@ class Context\n   // To GCC middle-end\n   std::vector<tree> type_decls;\n   std::vector<::Bvariable *> var_decls;\n-  std::vector<::Bexpression *> const_decls;\n+  std::vector<tree> const_decls;\n   std::vector<::Bfunction *> func_decls;\n };\n "}, {"sha": "d475ec460230d7f5f8c19e1dff24ffd057981640", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -117,11 +117,10 @@ CompileExpr::visit (HIR::NegationExpr &expr)\n     = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n }\n \n-Bexpression *\n+tree\n CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\tTyTy::BaseType *receiver,\n-\t\t\t\t\tTyTy::FnType *fntype,\n-\t\t\t\t\tBexpression *receiver_ref,\n+\t\t\t\t\tTyTy::FnType *fntype, tree receiver_ref,\n \t\t\t\t\tstd::vector<HIR::Expr *> &arguments,\n \t\t\t\t\tLocation expr_locus)\n {\n@@ -153,26 +152,26 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n       tree indrect_compiled_tyty\n \t= TyTyResolveCompile::compile (ctx, indirect_ty);\n \n-      Bexpression *indirect\n+      tree indirect\n \t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n \t\t\t\t\t\t    receiver_ref, true,\n \t\t\t\t\t\t    expr_locus);\n       receiver_ref = indirect;\n     }\n \n   // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n-  Bexpression *self_argument\n+  tree self_argument\n     = ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n \t\t\t\t\t\t    expr_locus);\n \n   // access the vtable for the fn\n-  Bexpression *fn_vtable_access\n+  tree fn_vtable_access\n     = ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n \t\t\t\t\t\t    expr_locus);\n \n   // cast it to the correct fntype\n   tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n-  Bexpression *fn_convert_expr\n+  tree fn_convert_expr\n     = ctx->get_backend ()->convert_expression (expected_fntype,\n \t\t\t\t\t       fn_vtable_access, expr_locus);\n \n@@ -187,22 +186,22 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\t       &ret_var_stmt);\n   ctx->add_statement (ret_var_stmt);\n \n-  std::vector<Bexpression *> args;\n+  std::vector<tree> args;\n   args.push_back (self_argument);\n   for (auto &argument : arguments)\n     {\n-      Bexpression *compiled_expr = CompileExpr::Compile (argument, ctx);\n+      tree compiled_expr = CompileExpr::Compile (argument, ctx);\n       args.push_back (compiled_expr);\n     }\n \n-  Bexpression *fn_expr\n+  tree fn_expr\n     = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n \n   return ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n \t\t\t\t\t       nullptr, expr_locus);\n }\n \n-Bexpression *\n+tree\n CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \t\t\t\t     TyTy::BaseType *receiver,\n \t\t\t\t     HIR::PathIdentSegment &segment,\n@@ -294,10 +293,10 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n     }\n }\n \n-Bexpression *\n+tree\n CompileExpr::resolve_operator_overload (\n   Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExpr &expr,\n-  Bexpression *lhs, Bexpression *rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n+  tree lhs, tree rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n {\n   TyTy::FnType *fntype;\n   bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n@@ -346,7 +345,7 @@ CompileExpr::resolve_operator_overload (\n   // lookup compiled functions since it may have already been compiled\n   HIR::PathIdentSegment segment_name (\n     Analysis::RustLangItem::ToString (lang_item_type));\n-  Bexpression *fn_expr\n+  tree fn_expr\n     = resolve_method_address (fntype, ref, receiver, segment_name,\n \t\t\t      expr.get_mappings (), expr.get_locus ());\n \n@@ -357,7 +356,7 @@ CompileExpr::resolve_operator_overload (\n   rust_assert (ok);\n \n   // FIXME refactor this out\n-  Bexpression *self = lhs;\n+  tree self = lhs;\n   for (auto &adjustment : *adjustments)\n     {\n       switch (adjustment.get_type ())\n@@ -380,7 +379,7 @@ CompileExpr::resolve_operator_overload (\n \t}\n     }\n \n-  std::vector<Bexpression *> args;\n+  std::vector<tree> args;\n   args.push_back (self); // adjusted self\n   if (rhs != nullptr)\t // can be null for negation_expr (unary ones)\n     args.push_back (rhs);"}, {"sha": "2f6395c4eeab838aee178e26c70f5aa5cedaa414", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -33,7 +33,7 @@ class CompileExpr : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  static tree Compile (HIR::Expr *expr, Context *ctx)\n   {\n     CompileExpr compiler (ctx);\n     expr->accept_vis (compiler);\n@@ -45,7 +45,7 @@ class CompileExpr : public HIRCompileBase\n     HIR::Expr *tuple_expr = expr.get_tuple_expr ().get ();\n     TupleIndex index = expr.get_tuple_index ();\n \n-    Bexpression *receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n+    tree receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n \n     TyTy::BaseType *tuple_expr_ty = nullptr;\n     bool ok = ctx->get_tyctx ()->lookup_type (\n@@ -60,7 +60,7 @@ class CompileExpr : public HIRCompileBase\n \tTyTy::BaseType *tuple_type = r->get_base ();\n \ttree tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n \n-\tBexpression *indirect\n+\ttree indirect\n \t  = ctx->get_backend ()->indirect_expression (tuple_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());\n \treceiver_ref = indirect;\n@@ -92,7 +92,7 @@ class CompileExpr : public HIRCompileBase\n     rust_assert (tuple_type != nullptr);\n \n     // this assumes all fields are in order from type resolution\n-    std::vector<Bexpression *> vals;\n+    std::vector<tree> vals;\n     for (auto &elem : expr.get_tuple_elems ())\n       {\n \tauto e = CompileExpr::Compile (elem.get (), ctx);\n@@ -108,10 +108,10 @@ class CompileExpr : public HIRCompileBase\n   {\n     auto fncontext = ctx->peek_fn ();\n \n-    std::vector<Bexpression *> retstmts;\n+    std::vector<tree> retstmts;\n     if (expr.has_return_expr ())\n       {\n-\tBexpression *compiled_expr\n+\ttree compiled_expr\n \t  = CompileExpr::Compile (expr.return_expr.get (), ctx);\n \trust_assert (compiled_expr != nullptr);\n \n@@ -330,21 +330,19 @@ class CompileExpr : public HIRCompileBase\n \t  auto array_tyty = static_cast<TyTy::ArrayType *> (base_tyty);\n \n \t  std::string value_str = expr.get_literal ()->as_string ();\n-\t  std::vector<Bexpression *> vals;\n+\t  std::vector<tree> vals;\n \t  std::vector<unsigned long> indexes;\n \t  for (size_t i = 0; i < value_str.size (); i++)\n \t    {\n \t      char b = value_str.at (i);\n-\t      Bexpression *bb\n-\t\t= ctx->get_backend ()->char_constant_expression (b);\n+\t      tree bb = ctx->get_backend ()->char_constant_expression (b);\n \t      vals.push_back (bb);\n \t      indexes.push_back (i);\n \t    }\n \n \t  tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n-\t  Bexpression *constructed\n-\t    = ctx->get_backend ()->array_constructor_expression (\n-\t      array_type, indexes, vals, expr.get_locus ());\n+\t  tree constructed = ctx->get_backend ()->array_constructor_expression (\n+\t    array_type, indexes, vals, expr.get_locus ());\n \n \t  translated\n \t    = ctx->get_backend ()->address_expression (constructed,\n@@ -392,8 +390,8 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::ArrayIndexExpr &expr) override\n   {\n-    Bexpression *array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n-    Bexpression *index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n+    tree array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n+    tree index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n     translated\n       = ctx->get_backend ()->array_index_expression (array, index,\n \t\t\t\t\t\t     expr.get_locus ());\n@@ -432,14 +430,14 @@ class CompileExpr : public HIRCompileBase\n   {\n     for (auto &elem : elems.get_values ())\n       {\n-\tBexpression *translated_expr = CompileExpr::Compile (elem.get (), ctx);\n+\ttree translated_expr = CompileExpr::Compile (elem.get (), ctx);\n \tconstructor.push_back (translated_expr);\n       }\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems) override\n   {\n-    Bexpression *translated_expr\n+    tree translated_expr\n       = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n \n     size_t capacity;\n@@ -645,10 +643,10 @@ class CompileExpr : public HIRCompileBase\n \n     // this assumes all fields are in order from type resolution and if a base\n     // struct was specified those fields are filed via accesors\n-    std::vector<Bexpression *> vals;\n+    std::vector<tree> vals;\n     for (auto &field : struct_expr.get_fields ())\n       {\n-\tBexpression *expr = CompileStructExprField::Compile (field.get (), ctx);\n+\ttree expr = CompileStructExprField::Compile (field.get (), ctx);\n \tvals.push_back (expr);\n       }\n \n@@ -665,7 +663,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::FieldAccessExpr &expr) override\n   {\n-    Bexpression *receiver_ref\n+    tree receiver_ref\n       = CompileExpr::Compile (expr.get_receiver_expr ().get (), ctx);\n \n     // resolve the receiver back to ADT type\n@@ -706,7 +704,7 @@ class CompileExpr : public HIRCompileBase\n \trust_assert (ok);\n \n \ttree adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n-\tBexpression *indirect\n+\ttree indirect\n \t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());\n \treceiver_ref = indirect;\n@@ -777,7 +775,7 @@ class CompileExpr : public HIRCompileBase\n \n     Bblock *code_block\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    Bexpression *loop_expr\n+    tree loop_expr\n       = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n     Bstatement *loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n@@ -826,9 +824,9 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (loop_begin_label_decl);\n     ctx->push_loop_begin_label (loop_begin_label);\n \n-    Bexpression *condition\n+    tree condition\n       = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n-    Bexpression *exit_expr\n+    tree exit_expr\n       = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n     Bstatement *break_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n@@ -843,7 +841,7 @@ class CompileExpr : public HIRCompileBase\n     ctx->pop_loop_begin_label ();\n     ctx->pop_block ();\n \n-    Bexpression *loop_expr\n+    tree loop_expr\n       = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n     Bstatement *loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n@@ -855,11 +853,11 @@ class CompileExpr : public HIRCompileBase\n     fncontext fnctx = ctx->peek_fn ();\n     if (expr.has_break_expr ())\n       {\n-\tBexpression *compiled_expr\n+\ttree compiled_expr\n \t  = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n \tBvariable *loop_result_holder = ctx->peek_loop_context ();\n-\tBexpression *result_reference = ctx->get_backend ()->var_expression (\n+\ttree result_reference = ctx->get_backend ()->var_expression (\n \t  loop_result_holder, expr.get_expr ()->get_locus ());\n \n \tBstatement *assignment = ctx->get_backend ()->assignment_statement (\n@@ -904,7 +902,7 @@ class CompileExpr : public HIRCompileBase\n       }\n     else\n       {\n-\tBexpression *exit_expr = ctx->get_backend ()->exit_expression (\n+\ttree exit_expr = ctx->get_backend ()->exit_expression (\n \t  ctx->get_backend ()->boolean_constant_expression (true),\n \t  expr.get_locus ());\n \tBstatement *break_stmt\n@@ -954,17 +952,15 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::BorrowExpr &expr) override\n   {\n-    Bexpression *main_expr\n-      = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n     translated\n       = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override\n   {\n-    Bexpression *main_expr\n-      = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n     TyTy::BaseType *tyty = nullptr;\n     if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n@@ -984,33 +980,31 @@ class CompileExpr : public HIRCompileBase\n   }\n \n protected:\n-  Bexpression *compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n-\t\t\t\t\t  TyTy::BaseType *receiver,\n-\t\t\t\t\t  TyTy::FnType *fntype,\n-\t\t\t\t\t  Bexpression *receiver_ref,\n-\t\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n-\t\t\t\t\t  Location expr_locus);\n-\n-  Bexpression *resolve_method_address (TyTy::FnType *fntype, HirId ref,\n-\t\t\t\t       TyTy::BaseType *receiver,\n-\t\t\t\t       HIR::PathIdentSegment &segment,\n-\t\t\t\t       Analysis::NodeMapping expr_mappings,\n-\t\t\t\t       Location expr_locus);\n-\n-  Bexpression *\n+  tree compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t  TyTy::BaseType *receiver,\n+\t\t\t\t  TyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n+\t\t\t\t  Location expr_locus);\n+\n+  tree resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t       TyTy::BaseType *receiver,\n+\t\t\t       HIR::PathIdentSegment &segment,\n+\t\t\t       Analysis::NodeMapping expr_mappings,\n+\t\t\t       Location expr_locus);\n+\n+  tree\n   resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n-\t\t\t     HIR::OperatorExpr &expr, Bexpression *lhs,\n-\t\t\t     Bexpression *rhs, HIR::Expr *lhs_expr,\n-\t\t\t     HIR::Expr *rhs_expr);\n+\t\t\t     HIR::OperatorExpr &expr, tree lhs, tree rhs,\n+\t\t\t     HIR::Expr *lhs_expr, HIR::Expr *rhs_expr);\n \n private:\n   CompileExpr (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)\n   {}\n \n-  Bexpression *translated;\n-  Bexpression *capacity_expr;\n-  std::vector<Bexpression *> constructor;\n+  tree translated;\n+  tree capacity_expr;\n+  std::vector<tree> constructor;\n };\n \n } // namespace Compile"}, {"sha": "65f3d2cc57834556210d66fb271aaf12f264ca5b", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -34,11 +34,11 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (const TyTy::BaseType *self, HIR::ImplItem *item,\n-\t\t\t       Context *ctx, bool compile_fns,\n-\t\t\t       TyTy::BaseType *concrete = nullptr,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree Compile (const TyTy::BaseType *self, HIR::ImplItem *item,\n+\t\t       Context *ctx, bool compile_fns,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileInherentImplItem compiler (self, ctx, compile_fns, concrete,\n \t\t\t\t      ref_locus);\n@@ -61,7 +61,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     rust_assert (ok);\n \n     tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -70,7 +70,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+    tree const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_identifier (), value, constant.get_locus ());\n \n     ctx->push_const (const_expr);\n@@ -319,7 +319,7 @@ class CompileInherentImplItem : public HIRCompileBase\n   const TyTy::BaseType *self;\n   bool compile_fns;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n \n@@ -328,10 +328,10 @@ class CompileTraitItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n-\t\t\t       Context *ctx, TyTy::BaseType *concrete,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n+\t\t       Context *ctx, TyTy::BaseType *concrete,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileTraitItem compiler (self, ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n@@ -350,8 +350,7 @@ class CompileTraitItem : public HIRCompileBase\n     TyTy::BaseType *resolved_type = concrete;\n \n     tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value\n-      = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n+    tree value = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     bool ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -360,7 +359,7 @@ class CompileTraitItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+    tree const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_name (), value, constant.get_locus ());\n \n     ctx->push_const (const_expr);\n@@ -578,7 +577,7 @@ class CompileTraitItem : public HIRCompileBase\n \n   const TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n "}, {"sha": "95de611277b654958e20489204874be72a225754", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -37,11 +37,10 @@ class CompileItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *compile (HIR::Item *item, Context *ctx,\n-\t\t\t       bool compile_fns = true,\n-\t\t\t       TyTy::BaseType *concrete = nullptr,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree compile (HIR::Item *item, Context *ctx, bool compile_fns = true,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileItem compiler (ctx, compile_fns, concrete, ref_locus);\n     item->accept_vis (compiler);\n@@ -62,7 +61,7 @@ class CompileItem : public HIRCompileBase\n     rust_assert (ok);\n \n     tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (var.get_expr (), ctx);\n+    tree value = CompileExpr::Compile (var.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -98,7 +97,7 @@ class CompileItem : public HIRCompileBase\n     rust_assert (ok);\n \n     tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -107,7 +106,7 @@ class CompileItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr\n+    tree const_expr\n       = ctx->get_backend ()->named_constant_expression (type, ident, value,\n \t\t\t\t\t\t\tconstant.get_locus ());\n \n@@ -347,7 +346,7 @@ class CompileItem : public HIRCompileBase\n \n   bool compile_fns;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n "}, {"sha": "81ffad8d147cee103cf6defb0db16c76672ca7e4", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -40,7 +40,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t      expr.get_mappings (), expr.get_locus (), false);\n }\n \n-Bexpression *\n+tree\n ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t const Analysis::NodeMapping &mappings,\n \t\t\t Location expr_locus, bool is_qualified_path)\n@@ -76,7 +76,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n     }\n \n   // might be a constant\n-  Bexpression *constant_expr;\n+  tree constant_expr;\n   if (ctx->lookup_const_decl (ref, &constant_expr))\n     return constant_expr;\n \n@@ -104,7 +104,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\tis_qualified_path);\n }\n \n-Bexpression *\n+tree\n ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t\t\t       const HIR::PathIdentSegment &final_segment,\n \t\t\t       const Analysis::NodeMapping &mappings,"}, {"sha": "56f82d1e6bca9a81aa43b2fec678f07ceab09b31", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -30,15 +30,14 @@ class ResolvePathRef : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::QualifiedPathInExpression &expr,\n-\t\t\t       Context *ctx)\n+  static tree Compile (HIR::QualifiedPathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n     expr.accept_vis (resolver);\n     return resolver.resolved;\n   }\n \n-  static Bexpression *Compile (HIR::PathInExpression &expr, Context *ctx)\n+  static tree Compile (HIR::PathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n     expr.accept_vis (resolver);\n@@ -54,16 +53,16 @@ class ResolvePathRef : public HIRCompileBase\n     : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *resolve (const HIR::PathIdentSegment &final_segment,\n-\t\t\tconst Analysis::NodeMapping &mappings, Location locus,\n-\t\t\tbool is_qualified_path);\n+  tree resolve (const HIR::PathIdentSegment &final_segment,\n+\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\tbool is_qualified_path);\n \n-  Bexpression *query_compile (HirId ref, TyTy::BaseType *lookup,\n-\t\t\t      const HIR::PathIdentSegment &final_segment,\n-\t\t\t      const Analysis::NodeMapping &mappings,\n-\t\t\t      Location expr_locus, bool is_qualified_path);\n+  tree query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t      const HIR::PathIdentSegment &final_segment,\n+\t\t      const Analysis::NodeMapping &mappings,\n+\t\t      Location expr_locus, bool is_qualified_path);\n \n-  Bexpression *resolved;\n+  tree resolved;\n };\n \n } // namespace Compile"}, {"sha": "604d9a53fe39333381c014ccaeb8c8c4124179e2", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -31,7 +31,7 @@ class CompileStmt : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::Stmt *stmt, Context *ctx)\n+  static tree Compile (HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileStmt compiler (ctx);\n     stmt->accept_vis (compiler);\n@@ -57,7 +57,7 @@ class CompileStmt : public HIRCompileBase\n     rust_assert (ok);\n \n     tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -66,7 +66,7 @@ class CompileStmt : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr\n+    tree const_expr\n       = ctx->get_backend ()->named_constant_expression (type, ident, value,\n \t\t\t\t\t\t\tconstant.get_locus ());\n \n@@ -101,7 +101,7 @@ class CompileStmt : public HIRCompileBase\n \treturn;\n       }\n \n-    Bexpression *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    tree init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n     // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n     // on failure and make this an assertion\n     if (init == nullptr)\n@@ -132,7 +132,7 @@ class CompileStmt : public HIRCompileBase\n private:\n   CompileStmt (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n \n-  Bexpression *translated;\n+  tree translated;\n };\n \n } // namespace Compile"}, {"sha": "6754e8c4242504b2763eda2b7b9c3e1722d52db1", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -30,7 +30,7 @@ class CompileStructExprField : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::StructExprField *field, Context *ctx)\n+  static tree Compile (HIR::StructExprField *field, Context *ctx)\n   {\n     CompileStructExprField compiler (ctx);\n     field->accept_vis (compiler);\n@@ -49,7 +49,7 @@ class CompileStructExprField : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr)\n   {}\n \n-  Bexpression *translated;\n+  tree translated;\n };\n \n } // namespace Compile"}, {"sha": "3531930478dac4da596a5e5ba8c139aee3819b1d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -80,7 +80,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n-      std::vector<Bexpression *> vals;\n+      std::vector<tree> vals;\n       for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n \t  auto &argument = expr.get_arguments ().at (i);\n@@ -150,7 +150,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t  required_num_args = fn->num_params ();\n \t}\n \n-      std::vector<Bexpression *> args;\n+      std::vector<tree> args;\n       for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n \t  auto &argument = expr.get_arguments ().at (i);\n@@ -195,7 +195,7 @@ void\n CompileExpr::visit (HIR::MethodCallExpr &expr)\n {\n   // method receiver\n-  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n \n   // lookup the resolved name\n   NodeId resolved_node_id = UNKNOWN_NODEID;\n@@ -254,7 +254,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n   // lookup compiled functions since it may have already been compiled\n   HIR::PathExprSegment method_name = expr.get_method_name ();\n   HIR::PathIdentSegment segment_name = method_name.get_segment ();\n-  Bexpression *fn_expr\n+  tree fn_expr\n     = resolve_method_address (fntype, ref, receiver, segment_name,\n \t\t\t      expr.get_mappings (), expr.get_locus ());\n \n@@ -284,7 +284,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t}\n     }\n \n-  std::vector<Bexpression *> args;\n+  std::vector<tree> args;\n   args.push_back (self); // adjusted self\n \n   // normal args\n@@ -360,7 +360,7 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n     {\n       // the previous passes will ensure this is a valid return or\n       // a valid trailing expression\n-      Bexpression *compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n+      tree compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n \t  if (result == nullptr)\n@@ -372,9 +372,8 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n \t    }\n \t  else\n \t    {\n-\t      Bexpression *result_reference\n-\t\t= ctx->get_backend ()->var_expression (\n-\t\t  result, expr.get_final_expr ()->get_locus ());\n+\t      tree result_reference = ctx->get_backend ()->var_expression (\n+\t\tresult, expr.get_final_expr ()->get_locus ());\n \n \t      Bstatement *assignment\n \t\t= ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n@@ -395,8 +394,7 @@ CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n   Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n   Bblock *then_block\n     = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n@@ -410,8 +408,7 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n   Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n   Bblock *then_block\n     = CompileBlock::compile (expr.get_if_block (), ctx, result);\n   Bblock *else_block\n@@ -427,8 +424,7 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n   Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n   Bblock *then_block\n     = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n@@ -500,14 +496,14 @@ HIRCompileBase::compile_function_body (\n     {\n       // the previous passes will ensure this is a valid return\n       // or a valid trailing expression\n-      Bexpression *compiled_expr\n+      tree compiled_expr\n \t= CompileExpr::Compile (function_body->expr.get (), ctx);\n \n       if (compiled_expr != nullptr)\n \t{\n \t  if (has_return_type)\n \t    {\n-\t      std::vector<Bexpression *> retstmts;\n+\t      std::vector<tree> retstmts;\n \t      retstmts.push_back (compiled_expr);\n \n \t      auto ret = ctx->get_backend ()->return_statement (\n@@ -561,10 +557,9 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n   return true;\n }\n \n-Bexpression *\n-HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n-\t\t\t       TyTy::BaseType *actual, TyTy::BaseType *expected,\n-\t\t\t       Location locus)\n+tree\n+HIRCompileBase::coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n+\t\t\t       TyTy::BaseType *expected, Location locus)\n {\n   auto root_actual_kind = actual->get_root ()->get_kind ();\n   auto root_expected_kind = expected->get_root ()->get_kind ();\n@@ -580,8 +575,8 @@ HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n   return compiled_ref;\n }\n \n-Bexpression *\n-HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n+tree\n+HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \t\t\t\t      const TyTy::BaseType *actual,\n \t\t\t\t      const TyTy::BaseType *expected,\n \t\t\t\t      const TyTy::DynamicObjectType *ty,\n@@ -597,7 +592,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n     probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (root);\n \n-  std::vector<Bexpression *> vals;\n+  std::vector<tree> vals;\n   vals.push_back (compiled_ref);\n   for (auto &bound : ty->get_object_items ())\n     {\n@@ -610,7 +605,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n       vals.push_back (address);\n     }\n \n-  Bexpression *constructed_trait_object\n+  tree constructed_trait_object\n     = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n \t\t\t\t\t\t   locus);\n \n@@ -659,7 +654,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   return resulting_dyn_object_ref;\n }\n \n-Bexpression *\n+tree\n HIRCompileBase::compute_address_for_trait_item (\n   const Resolver::TraitItemReference *ref,\n   const TyTy::TypeBoundPredicate *predicate,"}, {"sha": "49b9eeaf451665aa009bcff9485a7c05de67c4d3", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 75, "deletions": 98, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -41,9 +41,6 @@ saw_errors (void);\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n \n-// The backend represention of an expression.\n-class Bexpression;\n-\n // The backend representation of a statement.\n class Bstatement;\n \n@@ -87,17 +84,16 @@ class Backend\n \n   // debug\n   virtual void debug (tree) = 0;\n-  virtual void debug (Bexpression *) = 0;\n   virtual void debug (Bstatement *) = 0;\n   virtual void debug (Bfunction *) = 0;\n   virtual void debug (Bblock *) = 0;\n   virtual void debug (Bvariable *) = 0;\n   virtual void debug (Blabel *) = 0;\n \n   // const folder helpers\n-  virtual bool const_size_cast (Bexpression *, size_t *) = 0;\n-  virtual std::string const_size_val_to_string (Bexpression *) = 0;\n-  virtual bool const_values_equal (Bexpression *, Bexpression *) = 0;\n+  virtual bool const_size_cast (tree, size_t *) = 0;\n+  virtual std::string const_size_val_to_string (tree) = 0;\n+  virtual bool const_values_equal (tree, tree) = 0;\n \n   static Rust::ABI get_abi_from_string (const std::string &abi, Location locus)\n   {\n@@ -226,7 +222,7 @@ class Backend\n   virtual tree union_type (const std::vector<typed_identifier> &fields) = 0;\n \n   // Get an array type.\n-  virtual tree array_type (tree element_type, Bexpression *length) = 0;\n+  virtual tree array_type (tree element_type, tree length) = 0;\n \n   // Return a named version of a type.  The location is the location\n   // of the type definition.  This will not be called for a type\n@@ -255,165 +251,148 @@ class Backend\n   // Return an expression for a zero value of the given type.  This is\n   // used for cases such as local variable initialization and\n   // converting nil to other types.\n-  virtual Bexpression *zero_expression (tree) = 0;\n+  virtual tree zero_expression (tree) = 0;\n \n   // Create an error expression. This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bexpression *error_expression () = 0;\n+  virtual tree error_expression () = 0;\n \n   // return whether this is error_mark_node\n-  virtual bool is_error_expression (Bexpression *) = 0;\n+  virtual bool is_error_expression (tree) = 0;\n \n   // Create a nil pointer expression.\n-  virtual Bexpression *nil_pointer_expression () = 0;\n+  virtual tree nil_pointer_expression () = 0;\n \n-  virtual Bexpression *unit_expression () = 0;\n+  virtual tree unit_expression () = 0;\n \n   // Create a reference to a variable.\n-  virtual Bexpression *var_expression (Bvariable *var, Location) = 0;\n+  virtual tree var_expression (Bvariable *var, Location) = 0;\n \n   // Create an expression that indirects through the pointer expression EXPR\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n   // is known to point to a valid memory location.  BTYPE is the expected type\n   // of the indirected EXPR.\n-  virtual Bexpression *indirect_expression (tree btype, Bexpression *expr,\n-\t\t\t\t\t    bool known_valid, Location)\n+  virtual tree indirect_expression (tree btype, tree expr, bool known_valid,\n+\t\t\t\t    Location)\n     = 0;\n \n   // Return an expression that declares a constant named NAME with the\n   // constant value VAL in BTYPE.\n-  virtual Bexpression *named_constant_expression (tree btype,\n-\t\t\t\t\t\t  const std::string &name,\n-\t\t\t\t\t\t  Bexpression *val, Location)\n+  virtual tree named_constant_expression (tree btype, const std::string &name,\n+\t\t\t\t\t  tree val, Location)\n     = 0;\n \n   // Return an expression for the multi-precision integer VAL in BTYPE.\n-  virtual Bexpression *integer_constant_expression (tree btype, mpz_t val) = 0;\n+  virtual tree integer_constant_expression (tree btype, mpz_t val) = 0;\n \n   // Return an expression for the floating point value VAL in BTYPE.\n-  virtual Bexpression *float_constant_expression (tree btype, mpfr_t val) = 0;\n+  virtual tree float_constant_expression (tree btype, mpfr_t val) = 0;\n \n   // Return an expression for the complex value VAL in BTYPE.\n-  virtual Bexpression *complex_constant_expression (tree btype, mpc_t val) = 0;\n+  virtual tree complex_constant_expression (tree btype, mpc_t val) = 0;\n \n   // Return an expression for the string value VAL.\n-  virtual Bexpression *string_constant_expression (const std::string &val) = 0;\n+  virtual tree string_constant_expression (const std::string &val) = 0;\n \n   // Get a char literal\n-  virtual Bexpression *char_constant_expression (char c) = 0;\n+  virtual tree char_constant_expression (char c) = 0;\n \n   // Get a char literal\n-  virtual Bexpression *wchar_constant_expression (wchar_t c) = 0;\n+  virtual tree wchar_constant_expression (wchar_t c) = 0;\n \n   // Return an expression for the boolean value VAL.\n-  virtual Bexpression *boolean_constant_expression (bool val) = 0;\n+  virtual tree boolean_constant_expression (bool val) = 0;\n \n   // Return an expression for the real part of BCOMPLEX.\n-  virtual Bexpression *real_part_expression (Bexpression *bcomplex, Location)\n-    = 0;\n+  virtual tree real_part_expression (tree bcomplex, Location) = 0;\n \n   // Return an expression for the imaginary part of BCOMPLEX.\n-  virtual Bexpression *imag_part_expression (Bexpression *bcomplex, Location)\n-    = 0;\n+  virtual tree imag_part_expression (tree bcomplex, Location) = 0;\n \n   // Return an expression for the complex number (BREAL, BIMAG).\n-  virtual Bexpression *complex_expression (Bexpression *breal,\n-\t\t\t\t\t   Bexpression *bimag, Location)\n-    = 0;\n+  virtual tree complex_expression (tree breal, tree bimag, Location) = 0;\n \n   // Return an expression that converts EXPR to TYPE.\n-  virtual Bexpression *convert_expression (tree type, Bexpression *expr,\n-\t\t\t\t\t   Location)\n-    = 0;\n+  virtual tree convert_expression (tree type, tree expr, Location) = 0;\n \n   // Create an expression for the address of a function.  This is used to\n   // get the address of the code for a function.\n-  virtual Bexpression *function_code_expression (Bfunction *, Location) = 0;\n+  virtual tree function_code_expression (Bfunction *, Location) = 0;\n \n   // Create an expression that takes the address of an expression.\n-  virtual Bexpression *address_expression (Bexpression *, Location) = 0;\n+  virtual tree address_expression (tree, Location) = 0;\n \n   // Return an expression for the field at INDEX in BSTRUCT.\n-  virtual Bexpression *struct_field_expression (Bexpression *bstruct,\n-\t\t\t\t\t\tsize_t index, Location)\n+  virtual tree struct_field_expression (tree bstruct, size_t index, Location)\n     = 0;\n \n   // Create an expression that executes BSTAT before BEXPR.\n-  virtual Bexpression *compound_expression (Bstatement *bstat,\n-\t\t\t\t\t    Bexpression *bexpr, Location)\n+  virtual tree compound_expression (Bstatement *bstat, tree bexpr, Location)\n     = 0;\n \n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n   // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n-  virtual Bexpression *conditional_expression (Bfunction *function, tree btype,\n-\t\t\t\t\t       Bexpression *condition,\n-\t\t\t\t\t       Bexpression *then_expr,\n-\t\t\t\t\t       Bexpression *else_expr, Location)\n+  virtual tree conditional_expression (Bfunction *function, tree btype,\n+\t\t\t\t       tree condition, tree then_expr,\n+\t\t\t\t       tree else_expr, Location)\n     = 0;\n \n   // Return an expression for the negation operation OP EXPR.\n   // Supported values of OP are enumerated in NegationOperator.\n-  virtual Bexpression *negation_expression (NegationOperator op,\n-\t\t\t\t\t    Bexpression *expr, Location)\n+  virtual tree negation_expression (NegationOperator op, tree expr, Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n-  virtual Bexpression *\n-  arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t    Bexpression *left, Bexpression *right,\n-\t\t\t\t    Location)\n+  virtual tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t\t tree left, tree right,\n+\t\t\t\t\t\t Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ComparisonOperator.\n-  virtual Bexpression *comparison_expression (ComparisonOperator op,\n-\t\t\t\t\t      Bexpression *left,\n-\t\t\t\t\t      Bexpression *right, Location)\n+  virtual tree comparison_expression (ComparisonOperator op, tree left,\n+\t\t\t\t      tree right, Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in LazyBooleanOperator.\n-  virtual Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n-\t\t\t\t\t\tBexpression *left,\n-\t\t\t\t\t\tBexpression *right, Location)\n+  virtual tree lazy_boolean_expression (LazyBooleanOperator op, tree left,\n+\t\t\t\t\ttree right, Location)\n     = 0;\n \n   // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n   // backend representation a of struct.  VALS must be in the same order as the\n   // corresponding fields in BTYPE.\n-  virtual Bexpression *\n-  constructor_expression (tree btype, const std::vector<Bexpression *> &vals,\n-\t\t\t  int, Location)\n+  virtual tree constructor_expression (tree btype,\n+\t\t\t\t       const std::vector<tree> &vals, int,\n+\t\t\t\t       Location)\n     = 0;\n \n   // Return an expression that constructs an array of BTYPE with INDEXES and\n   // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n   // in INDEXES must be in the same order as the corresponding value in VALS.\n-  virtual Bexpression *array_constructor_expression (\n-    tree btype, const std::vector<unsigned long> &indexes,\n-    const std::vector<Bexpression *> &vals, Location)\n+  virtual tree\n+  array_constructor_expression (tree btype,\n+\t\t\t\tconst std::vector<unsigned long> &indexes,\n+\t\t\t\tconst std::vector<tree> &vals, Location)\n     = 0;\n \n   // Return an expression for the address of BASE[INDEX].\n   // BASE has a pointer type.  This is used for slice indexing.\n-  virtual Bexpression *pointer_offset_expression (Bexpression *base,\n-\t\t\t\t\t\t  Bexpression *index, Location)\n-    = 0;\n+  virtual tree pointer_offset_expression (tree base, tree index, Location) = 0;\n \n   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n   // fixed-length array, not a slice.\n-  virtual Bexpression *array_index_expression (Bexpression *array,\n-\t\t\t\t\t       Bexpression *index, Location)\n-    = 0;\n+  virtual tree array_index_expression (tree array, tree index, Location) = 0;\n \n   // Create an expression for a call to FN with ARGS, taking place within\n   // caller CALLER.\n-  virtual Bexpression *call_expression (Bfunction *caller, Bexpression *fn,\n-\t\t\t\t\tconst std::vector<Bexpression *> &args,\n-\t\t\t\t\tBexpression *static_chain, Location)\n+  virtual tree call_expression (Bfunction *caller, tree fn,\n+\t\t\t\tconst std::vector<tree> &args,\n+\t\t\t\ttree static_chain, Location)\n     = 0;\n \n   // Statements.\n@@ -424,37 +403,36 @@ class Backend\n   virtual Bstatement *error_statement () = 0;\n \n   // Create an expression statement within the specified function.\n-  virtual Bstatement *expression_statement (Bfunction *, Bexpression *) = 0;\n+  virtual Bstatement *expression_statement (Bfunction *, tree) = 0;\n \n   // Create a variable initialization statement in the specified\n   // function.  This initializes a local variable at the point in the\n   // program flow where it is declared.\n-  virtual Bstatement *init_statement (Bfunction *, Bvariable *var,\n-\t\t\t\t      Bexpression *init)\n+  virtual Bstatement *init_statement (Bfunction *, Bvariable *var, tree init)\n     = 0;\n \n   // Create an assignment statement within the specified function.\n-  virtual Bstatement *assignment_statement (Bfunction *, Bexpression *lhs,\n-\t\t\t\t\t    Bexpression *rhs, Location)\n+  virtual Bstatement *assignment_statement (Bfunction *, tree lhs, tree rhs,\n+\t\t\t\t\t    Location)\n     = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return.\n-  virtual Bstatement *\n-  return_statement (Bfunction *, const std::vector<Bexpression *> &, Location)\n+  virtual Bstatement *return_statement (Bfunction *, const std::vector<tree> &,\n+\t\t\t\t\tLocation)\n     = 0;\n \n   // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n-  virtual Bstatement *if_statement (Bfunction *, Bexpression *condition,\n+  virtual Bstatement *if_statement (Bfunction *, tree condition,\n \t\t\t\t    Bblock *then_block, Bblock *else_block,\n \t\t\t\t    Location)\n     = 0;\n \n   // infinite loop expressions\n-  virtual Bexpression *loop_expression (Bblock *body, Location) = 0;\n+  virtual tree loop_expression (Bblock *body, Location) = 0;\n \n   // exit expressions\n-  virtual Bexpression *exit_expression (Bexpression *condition, Location) = 0;\n+  virtual tree exit_expression (tree condition, Location) = 0;\n \n   // Create a switch statement where the case values are constants.\n   // CASES and STATEMENTS must have the same number of entries.  If\n@@ -464,8 +442,8 @@ class Backend\n   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n   // which need not be last.  FUNCTION is the current function.\n   virtual Bstatement *\n-  switch_statement (Bfunction *function, Bexpression *value,\n-\t\t    const std::vector<std::vector<Bexpression *> > &cases,\n+  switch_statement (Bfunction *function, tree value,\n+\t\t    const std::vector<std::vector<tree> > &cases,\n \t\t    const std::vector<Bstatement *> &statements, Location)\n     = 0;\n \n@@ -543,7 +521,7 @@ class Backend\n   // global_variable_set_init to set the initial value.  If this is\n   // not called, the backend should initialize a global variable to 0.\n   // The init function may then assign a value to it.\n-  virtual void global_variable_set_init (Bvariable *, Bexpression *) = 0;\n+  virtual void global_variable_set_init (Bvariable *, tree) = 0;\n \n   // Create a local variable.  The frontend will create the local\n   // variables first, and then create the block which contains them.\n@@ -587,10 +565,10 @@ class Backend\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n-  virtual Bvariable *\n-  temporary_variable (Bfunction *, Bblock *, tree, Bexpression *init,\n-\t\t      bool address_is_taken, Location location,\n-\t\t      Bstatement **pstatement)\n+  virtual Bvariable *temporary_variable (Bfunction *, Bblock *, tree, tree init,\n+\t\t\t\t\t bool address_is_taken,\n+\t\t\t\t\t Location location,\n+\t\t\t\t\t Bstatement **pstatement)\n     = 0;\n \n   // Create an implicit variable that is compiler-defined.  This is\n@@ -638,7 +616,7 @@ class Backend\n   virtual void implicit_variable_set_init (Bvariable *, const std::string &name,\n \t\t\t\t\t   tree type, bool is_hidden,\n \t\t\t\t\t   bool is_constant, bool is_common,\n-\t\t\t\t\t   Bexpression *init)\n+\t\t\t\t\t   tree init)\n     = 0;\n \n   // Create a reference to a named implicit variable defined in some\n@@ -693,8 +671,7 @@ class Backend\n   // immutable_struct.\n   virtual void immutable_struct_set_init (Bvariable *, const std::string &name,\n \t\t\t\t\t  bool is_hidden, bool is_common,\n-\t\t\t\t\t  tree type, Location,\n-\t\t\t\t\t  Bexpression *initializer)\n+\t\t\t\t\t  tree type, Location, tree initializer)\n     = 0;\n \n   // Create a reference to a named immutable initialized data\n@@ -725,7 +702,7 @@ class Backend\n   // Create an expression for the address of a label.  This is used to\n   // get the return address of a deferred function which may call\n   // recover.\n-  virtual Bexpression *label_address (Blabel *, Location) = 0;\n+  virtual tree label_address (Blabel *, Location) = 0;\n \n   // Functions.\n \n@@ -782,9 +759,9 @@ class Backend\n   // be a statement that looks like this in C++:\n   //   finish:\n   //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n-  virtual Bstatement *\n-  function_defer_statement (Bfunction *function, Bexpression *undefer,\n-\t\t\t    Bexpression *check_defer, Location)\n+  virtual Bstatement *function_defer_statement (Bfunction *function,\n+\t\t\t\t\t\ttree undefer, tree check_defer,\n+\t\t\t\t\t\tLocation)\n     = 0;\n \n   // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n@@ -812,7 +789,7 @@ class Backend\n   // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n   virtual void\n   write_global_definitions (const std::vector<tree> &type_decls,\n-\t\t\t    const std::vector<Bexpression *> &constant_decls,\n+\t\t\t    const std::vector<tree> &constant_decls,\n \t\t\t    const std::vector<Bfunction *> &function_decls,\n \t\t\t    const std::vector<Bvariable *> &variable_decls)\n     = 0;"}, {"sha": "ef7b0b72fd52921bde3da58e4e1c92a6ff4c2eb5", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 218, "deletions": 310, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -70,12 +70,6 @@ class Gcc_tree\n \n // In gcc, types, expressions, and statements are all trees.\n \n-class Bexpression : public Gcc_tree\n-{\n-public:\n-  Bexpression (tree t) : Gcc_tree (t) {}\n-};\n-\n class Bstatement : public Gcc_tree\n {\n public:\n@@ -155,7 +149,6 @@ class Gcc_backend : public Backend\n   Gcc_backend ();\n \n   void debug (tree t) { debug_tree (t); };\n-  void debug (Bexpression *t) { debug_tree (t->get_tree ()); };\n   void debug (Bstatement *t) { debug_tree (t->get_tree ()); };\n   void debug (Bfunction *t) { debug_tree (t->get_tree ()); };\n   void debug (Bblock *t) { debug_tree (t->get_tree ()); };\n@@ -184,14 +177,14 @@ class Gcc_backend : public Backend\n \n   tree char_type () { return char_type_node; }\n \n-  bool const_size_cast (Bexpression *expr, size_t *result)\n+  bool const_size_cast (tree expr, size_t *result)\n   {\n-    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+    rust_assert (TREE_CONSTANT (expr));\n \n     unsigned char buf[sizeof (size_t) + 1];\n     memset (buf, 0, sizeof (buf));\n \n-    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n     if (ret <= 0)\n       return false;\n \n@@ -200,23 +193,23 @@ class Gcc_backend : public Backend\n     return true;\n   }\n \n-  std::string const_size_val_to_string (Bexpression *expr)\n+  std::string const_size_val_to_string (tree expr)\n   {\n-    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+    rust_assert (TREE_CONSTANT (expr));\n \n     unsigned char buf[sizeof (size_t) + 1];\n     memset (buf, 0, sizeof (buf));\n \n-    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n     rust_assert (ret > 0);\n \n     size_t *ptr = (size_t *) buf;\n     return std::to_string (*ptr);\n   }\n \n-  bool const_values_equal (Bexpression *a, Bexpression *b)\n+  bool const_values_equal (tree a, tree b)\n   {\n-    return operand_equal_p (a->get_tree (), b->get_tree (), OEP_ONLY_CONST | OEP_PURE_SAME);\n+    return operand_equal_p (a, b, OEP_ONLY_CONST | OEP_PURE_SAME);\n     // printf (\"comparing!\\n\");\n     // debug_tree (a->get_tree ());\n     // debug_tree (b->get_tree ());\n@@ -266,7 +259,7 @@ class Gcc_backend : public Backend\n \n   tree union_type (const std::vector<typed_identifier> &);\n \n-  tree array_type (tree, Bexpression *);\n+  tree array_type (tree, tree);\n \n   tree named_type (const std::string &, tree, Location);\n \n@@ -280,102 +273,78 @@ class Gcc_backend : public Backend\n \n   // Expressions.\n \n-  Bexpression *zero_expression (tree);\n+  tree zero_expression (tree);\n \n-  Bexpression *error_expression ()\n-  {\n-    return this->make_expression (error_mark_node);\n-  }\n+  tree error_expression () { return error_mark_node; }\n \n-  bool is_error_expression (Bexpression *expr)\n-  {\n-    return expr->get_tree () == error_mark_node;\n-  }\n+  bool is_error_expression (tree expr) { return expr == error_mark_node; }\n \n-  Bexpression *nil_pointer_expression ()\n-  {\n-    return this->make_expression (null_pointer_node);\n-  }\n+  tree nil_pointer_expression () { return null_pointer_node; }\n \n-  Bexpression *unit_expression ()\n-  {\n-    return this->make_expression (integer_zero_node);\n-  }\n+  tree unit_expression () { return integer_zero_node; }\n \n-  Bexpression *var_expression (Bvariable *var, Location);\n+  tree var_expression (Bvariable *var, Location);\n \n-  Bexpression *indirect_expression (tree, Bexpression *expr,\n-\t\t\t\t    bool known_valid, Location);\n+  tree indirect_expression (tree, tree expr, bool known_valid, Location);\n \n-  Bexpression *named_constant_expression (tree type, const std::string &name,\n-\t\t\t\t\t  Bexpression *val, Location);\n+  tree named_constant_expression (tree type, const std::string &name, tree val,\n+\t\t\t\t  Location);\n \n-  Bexpression *integer_constant_expression (tree type, mpz_t val);\n+  tree integer_constant_expression (tree type, mpz_t val);\n \n-  Bexpression *float_constant_expression (tree type, mpfr_t val);\n+  tree float_constant_expression (tree type, mpfr_t val);\n \n-  Bexpression *complex_constant_expression (tree type, mpc_t val);\n+  tree complex_constant_expression (tree type, mpc_t val);\n \n-  Bexpression *string_constant_expression (const std::string &val);\n+  tree string_constant_expression (const std::string &val);\n \n-  Bexpression *wchar_constant_expression (wchar_t c);\n+  tree wchar_constant_expression (wchar_t c);\n \n-  Bexpression *char_constant_expression (char c);\n+  tree char_constant_expression (char c);\n \n-  Bexpression *boolean_constant_expression (bool val);\n+  tree boolean_constant_expression (bool val);\n \n-  Bexpression *real_part_expression (Bexpression *bcomplex, Location);\n+  tree real_part_expression (tree bcomplex, Location);\n \n-  Bexpression *imag_part_expression (Bexpression *bcomplex, Location);\n+  tree imag_part_expression (tree bcomplex, Location);\n \n-  Bexpression *complex_expression (Bexpression *breal, Bexpression *bimag,\n-\t\t\t\t   Location);\n+  tree complex_expression (tree breal, tree bimag, Location);\n \n-  Bexpression *convert_expression (tree type, Bexpression *expr, Location);\n+  tree convert_expression (tree type, tree expr, Location);\n \n-  Bexpression *function_code_expression (Bfunction *, Location);\n+  tree function_code_expression (Bfunction *, Location);\n \n-  Bexpression *address_expression (Bexpression *, Location);\n+  tree address_expression (tree, Location);\n \n-  Bexpression *struct_field_expression (Bexpression *, size_t, Location);\n+  tree struct_field_expression (tree, size_t, Location);\n \n-  Bexpression *compound_expression (Bstatement *, Bexpression *, Location);\n+  tree compound_expression (Bstatement *, tree, Location);\n \n-  Bexpression *conditional_expression (Bfunction *, tree, Bexpression *,\n-\t\t\t\t       Bexpression *, Bexpression *, Location);\n+  tree conditional_expression (Bfunction *, tree, tree, tree, tree, Location);\n \n-  Bexpression *negation_expression (NegationOperator op, Bexpression *expr,\n-\t\t\t\t    Location);\n+  tree negation_expression (NegationOperator op, tree expr, Location);\n \n-  Bexpression *arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t\t Bexpression *left,\n-\t\t\t\t\t\t Bexpression *right, Location);\n+  tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t tree left, tree right, Location);\n \n-  Bexpression *comparison_expression (ComparisonOperator op, Bexpression *left,\n-\t\t\t\t      Bexpression *right, Location);\n+  tree comparison_expression (ComparisonOperator op, tree left, tree right,\n+\t\t\t      Location);\n \n-  Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n-\t\t\t\t\tBexpression *left, Bexpression *right,\n-\t\t\t\t\tLocation);\n+  tree lazy_boolean_expression (LazyBooleanOperator op, tree left, tree right,\n+\t\t\t\tLocation);\n \n-  Bexpression *constructor_expression (tree,\n-\t\t\t\t       const std::vector<Bexpression *> &, int,\n-\t\t\t\t       Location);\n+  tree constructor_expression (tree, const std::vector<tree> &, int, Location);\n \n-  Bexpression *array_constructor_expression (tree,\n-\t\t\t\t\t     const std::vector<unsigned long> &,\n-\t\t\t\t\t     const std::vector<Bexpression *> &,\n-\t\t\t\t\t     Location);\n+  tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n+\t\t\t\t     const std::vector<tree> &, Location);\n \n-  Bexpression *pointer_offset_expression (Bexpression *base,\n-\t\t\t\t\t  Bexpression *offset, Location);\n+  tree pointer_offset_expression (tree base, tree offset, Location);\n \n-  Bexpression *array_index_expression (Bexpression *array, Bexpression *index,\n-\t\t\t\t       Location);\n+  tree array_index_expression (tree array, tree index, Location);\n \n-  Bexpression *call_expression (Bfunction *caller, Bexpression *fn,\n-\t\t\t\tconst std::vector<Bexpression *> &args,\n-\t\t\t\tBexpression *static_chain, Location);\n+  tree call_expression (Bfunction *caller, tree fn,\n+\t\t\tconst std::vector<tree> &args, tree static_chain,\n+\t\t\tLocation);\n \n   // Statements.\n \n@@ -384,23 +353,22 @@ class Gcc_backend : public Backend\n     return this->make_statement (error_mark_node);\n   }\n \n-  Bstatement *expression_statement (Bfunction *, Bexpression *);\n+  Bstatement *expression_statement (Bfunction *, tree);\n \n-  Bstatement *init_statement (Bfunction *, Bvariable *var, Bexpression *init);\n+  Bstatement *init_statement (Bfunction *, Bvariable *var, tree init);\n \n-  Bstatement *assignment_statement (Bfunction *, Bexpression *lhs,\n-\t\t\t\t    Bexpression *rhs, Location);\n+  Bstatement *assignment_statement (Bfunction *, tree lhs, tree rhs, Location);\n \n-  Bstatement *return_statement (Bfunction *, const std::vector<Bexpression *> &,\n+  Bstatement *return_statement (Bfunction *, const std::vector<tree> &,\n \t\t\t\tLocation);\n \n-  Bstatement *if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t    Bblock *then_block, Bblock *else_block, Location);\n+  Bstatement *if_statement (Bfunction *, tree condition, Bblock *then_block,\n+\t\t\t    Bblock *else_block, Location);\n \n-  Bstatement *\n-  switch_statement (Bfunction *function, Bexpression *value,\n-\t\t    const std::vector<std::vector<Bexpression *> > &cases,\n-\t\t    const std::vector<Bstatement *> &statements, Location);\n+  Bstatement *switch_statement (Bfunction *function, tree value,\n+\t\t\t\tconst std::vector<std::vector<tree>> &cases,\n+\t\t\t\tconst std::vector<Bstatement *> &statements,\n+\t\t\t\tLocation);\n \n   Bstatement *compound_statement (Bstatement *, Bstatement *);\n \n@@ -410,9 +378,9 @@ class Gcc_backend : public Backend\n \t\t\t\t\t   Bstatement *except_stmt,\n \t\t\t\t\t   Bstatement *finally_stmt, Location);\n \n-  Bexpression *loop_expression (Bblock *body, Location);\n+  tree loop_expression (Bblock *body, Location);\n \n-  Bexpression *exit_expression (Bexpression *condition, Location);\n+  tree exit_expression (tree condition, Location);\n \n   // Blocks.\n \n@@ -432,7 +400,7 @@ class Gcc_backend : public Backend\n \t\t\t      bool is_external, bool is_hidden,\n \t\t\t      bool in_unique_section, Location location);\n \n-  void global_variable_set_init (Bvariable *, Bexpression *);\n+  void global_variable_set_init (Bvariable *, tree);\n \n   Bvariable *local_variable (Bfunction *, const std::string &, tree,\n \t\t\t     Bvariable *, bool, Location);\n@@ -443,14 +411,14 @@ class Gcc_backend : public Backend\n   Bvariable *static_chain_variable (Bfunction *, const std::string &, tree,\n \t\t\t\t    Location);\n \n-  Bvariable *temporary_variable (Bfunction *, Bblock *, tree, Bexpression *,\n-\t\t\t\t bool, Location, Bstatement **);\n+  Bvariable *temporary_variable (Bfunction *, Bblock *, tree, tree, bool,\n+\t\t\t\t Location, Bstatement **);\n \n   Bvariable *implicit_variable (const std::string &, const std::string &,\n \t\t\t\ttree, bool, bool, bool, int64_t);\n \n-  void implicit_variable_set_init (Bvariable *, const std::string &, tree,\n-\t\t\t\t   bool, bool, bool, Bexpression *);\n+  void implicit_variable_set_init (Bvariable *, const std::string &, tree, bool,\n+\t\t\t\t   bool, bool, tree);\n \n   Bvariable *implicit_variable_reference (const std::string &,\n \t\t\t\t\t  const std::string &, tree);\n@@ -459,7 +427,7 @@ class Gcc_backend : public Backend\n \t\t\t       bool, tree, Location);\n \n   void immutable_struct_set_init (Bvariable *, const std::string &, bool, bool,\n-\t\t\t\t  tree, Location, Bexpression *);\n+\t\t\t\t  tree, Location, tree);\n \n   Bvariable *immutable_struct_reference (const std::string &,\n \t\t\t\t\t const std::string &, tree,\n@@ -473,7 +441,7 @@ class Gcc_backend : public Backend\n \n   Bstatement *goto_statement (Blabel *, Location);\n \n-  Bexpression *label_address (Blabel *, Location);\n+  tree label_address (Blabel *, Location);\n \n   // Functions.\n \n@@ -483,9 +451,8 @@ class Gcc_backend : public Backend\n \t\t       const std::string &asm_name, unsigned int flags,\n \t\t       Location);\n \n-  Bstatement *function_defer_statement (Bfunction *function,\n-\t\t\t\t\tBexpression *undefer,\n-\t\t\t\t\tBexpression *defer, Location);\n+  Bstatement *function_defer_statement (Bfunction *function, tree undefer,\n+\t\t\t\t\ttree defer, Location);\n \n   bool function_set_parameters (Bfunction *function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n@@ -497,15 +464,13 @@ class Gcc_backend : public Backend\n   Bfunction *lookup_builtin_by_rust_name (const std::string &);\n \n   void write_global_definitions (const std::vector<tree> &,\n-\t\t\t\t const std::vector<Bexpression *> &,\n+\t\t\t\t const std::vector<tree> &,\n \t\t\t\t const std::vector<Bfunction *> &,\n \t\t\t\t const std::vector<Bvariable *> &);\n \n   void write_export_data (const char *bytes, unsigned int size);\n \n private:\n-  // Make a Bexpression from a tree.\n-  Bexpression *make_expression (tree t) { return new Bexpression (t); }\n \n   // Make a Bstatement from a tree.\n   Bstatement *make_statement (tree t) { return new Bstatement (t); }\n@@ -514,7 +479,7 @@ class Gcc_backend : public Backend\n \n   tree fill_in_fields (tree, const std::vector<typed_identifier> &);\n \n-  tree fill_in_array (tree, tree, Bexpression *);\n+  tree fill_in_array (tree, tree, tree);\n \n   tree non_zero_size_type (tree);\n \n@@ -1144,18 +1109,16 @@ Gcc_backend::fill_in_fields (tree fill,\n // Make an array type.\n \n tree\n-Gcc_backend::array_type (tree element_type, Bexpression *length)\n+Gcc_backend::array_type (tree element_type, tree length)\n {\n   return this->fill_in_array (make_node (ARRAY_TYPE), element_type, length);\n }\n \n // Fill in an array type.\n \n tree\n-Gcc_backend::fill_in_array (tree fill, tree element_type,\n-\t\t\t    Bexpression *length)\n+Gcc_backend::fill_in_array (tree fill, tree element_type, tree length_tree)\n {\n-  tree length_tree = length->get_tree ();\n   if (element_type == error_mark_node || length_tree == error_mark_node)\n     return this->error_type ();\n \n@@ -1275,35 +1238,34 @@ Gcc_backend::type_field_offset (tree struct_tree, size_t index)\n \n // Return the zero value for a type.\n \n-Bexpression *\n+tree\n Gcc_backend::zero_expression (tree t)\n {\n   tree ret;\n   if (t == error_mark_node)\n     ret = error_mark_node;\n   else\n     ret = build_zero_cst (t);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that references a variable.\n \n-Bexpression *\n+tree\n Gcc_backend::var_expression (Bvariable *var, Location location)\n {\n   tree ret = var->get_tree (location);\n   if (ret == error_mark_node)\n     return this->error_expression ();\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that indirectly references an expression.\n \n-Bexpression *\n-Gcc_backend::indirect_expression (tree type_tree, Bexpression *expr,\n+tree\n+Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n \t\t\t\t  bool known_valid, Location location)\n {\n-  tree expr_tree = expr->get_tree ();\n   if (expr_tree == error_mark_node || type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1317,17 +1279,16 @@ Gcc_backend::indirect_expression (tree type_tree, Bexpression *expr,\n   tree ret = build_fold_indirect_ref_loc (location.gcc_location (), expr_tree);\n   if (known_valid)\n     TREE_THIS_NOTRAP (ret) = 1;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that declares a constant named NAME with the\n // constant value VAL in BTYPE.\n \n-Bexpression *\n+tree\n Gcc_backend::named_constant_expression (tree type_tree, const std::string &name,\n-\t\t\t\t\tBexpression *val, Location location)\n+\t\t\t\t\ttree const_val, Location location)\n {\n-  tree const_val = val->get_tree ();\n   if (type_tree == error_mark_node || const_val == error_mark_node)\n     return this->error_expression ();\n \n@@ -1339,24 +1300,24 @@ Gcc_backend::named_constant_expression (tree type_tree, const std::string &name,\n   TREE_READONLY (decl) = 1;\n \n   rust_preserve_from_gc (decl);\n-  return this->make_expression (decl);\n+  return decl;\n }\n \n // Return a typed value as a constant integer.\n \n-Bexpression *\n+tree\n Gcc_backend::integer_constant_expression (tree t, mpz_t val)\n {\n   if (t == error_mark_node)\n     return this->error_expression ();\n \n   tree ret = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return a typed value as a constant floating-point number.\n \n-Bexpression *\n+tree\n Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n {\n   tree ret;\n@@ -1368,12 +1329,12 @@ Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n   REAL_VALUE_TYPE r2;\n   real_convert (&r2, TYPE_MODE (t), &r1);\n   ret = build_real (t, r2);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return a typed real and imaginary value as a constant complex number.\n \n-Bexpression *\n+tree\n Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n {\n   tree ret;\n@@ -1392,12 +1353,12 @@ Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n \n   ret = build_complex (t, build_real (TREE_TYPE (t), r2),\n \t\t       build_real (TREE_TYPE (t), r4));\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Make a constant string expression.\n \n-Bexpression *\n+tree\n Gcc_backend::string_constant_expression (const std::string &val)\n {\n   tree index_type = build_index_type (size_int (val.length ()));\n@@ -1407,70 +1368,63 @@ Gcc_backend::string_constant_expression (const std::string &val)\n   tree string_val = build_string (val.length (), val.data ());\n   TREE_TYPE (string_val) = string_type;\n \n-  return this->make_expression (string_val);\n+  return string_val;\n }\n \n-Bexpression *\n+tree\n Gcc_backend::wchar_constant_expression (wchar_t c)\n {\n-  tree ret = build_int_cst (this->wchar_type (), c);\n-  return this->make_expression (ret);\n+  return build_int_cst (this->wchar_type (), c);\n }\n \n-Bexpression *\n+tree\n Gcc_backend::char_constant_expression (char c)\n {\n-  tree ret = build_int_cst (this->char_type (), c);\n-  return this->make_expression (ret);\n+  return build_int_cst (this->char_type (), c);\n }\n \n // Make a constant boolean expression.\n \n-Bexpression *\n+tree\n Gcc_backend::boolean_constant_expression (bool val)\n {\n-  tree bool_cst = val ? boolean_true_node : boolean_false_node;\n-  return this->make_expression (bool_cst);\n+  return val ? boolean_true_node : boolean_false_node;\n }\n \n // Return the real part of a complex expression.\n \n-Bexpression *\n-Gcc_backend::real_part_expression (Bexpression *bcomplex, Location location)\n+tree\n+Gcc_backend::real_part_expression (tree complex_tree, Location location)\n {\n-  tree complex_tree = bcomplex->get_tree ();\n   if (complex_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), REALPART_EXPR,\n \t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return the imaginary part of a complex expression.\n \n-Bexpression *\n-Gcc_backend::imag_part_expression (Bexpression *bcomplex, Location location)\n+tree\n+Gcc_backend::imag_part_expression (tree complex_tree, Location location)\n {\n-  tree complex_tree = bcomplex->get_tree ();\n   if (complex_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), IMAGPART_EXPR,\n \t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Make a complex expression given its real and imaginary parts.\n \n-Bexpression *\n-Gcc_backend::complex_expression (Bexpression *breal, Bexpression *bimag,\n+tree\n+Gcc_backend::complex_expression (tree real_tree, tree imag_tree,\n \t\t\t\t Location location)\n {\n-  tree real_tree = breal->get_tree ();\n-  tree imag_tree = bimag->get_tree ();\n   if (real_tree == error_mark_node || imag_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (real_tree))\n@@ -1479,16 +1433,15 @@ Gcc_backend::complex_expression (Bexpression *breal, Bexpression *bimag,\n   tree ret = fold_build2_loc (location.gcc_location (), COMPLEX_EXPR,\n \t\t\t      build_complex_type (TREE_TYPE (real_tree)),\n \t\t\t      real_tree, imag_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that converts an expression to a different type.\n \n-Bexpression *\n-Gcc_backend::convert_expression (tree type_tree, Bexpression *expr,\n+tree\n+Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n \t\t\t\t Location location)\n {\n-  tree expr_tree = expr->get_tree ();\n   if (type_tree == error_mark_node || expr_tree == error_mark_node\n       || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n@@ -1515,42 +1468,39 @@ Gcc_backend::convert_expression (tree type_tree, Bexpression *expr,\n   else\n     ret = fold_convert_loc (location.gcc_location (), type_tree, expr_tree);\n \n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Get the address of a function.\n \n-Bexpression *\n+tree\n Gcc_backend::function_code_expression (Bfunction *bfunc, Location location)\n {\n   tree func = bfunc->get_tree ();\n   if (func == error_mark_node)\n     return this->error_expression ();\n \n   tree ret = build_fold_addr_expr_loc (location.gcc_location (), func);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Get the address of an expression.\n \n-Bexpression *\n-Gcc_backend::address_expression (Bexpression *bexpr, Location location)\n+tree\n+Gcc_backend::address_expression (tree expr, Location location)\n {\n-  tree expr = bexpr->get_tree ();\n   if (expr == error_mark_node)\n     return this->error_expression ();\n \n-  tree ret = build_fold_addr_expr_loc (location.gcc_location (), expr);\n-  return this->make_expression (ret);\n+  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n }\n \n // Return an expression for the field at INDEX in BSTRUCT.\n \n-Bexpression *\n-Gcc_backend::struct_field_expression (Bexpression *bstruct, size_t index,\n+tree\n+Gcc_backend::struct_field_expression (tree struct_tree, size_t index,\n \t\t\t\t      Location location)\n {\n-  tree struct_tree = bstruct->get_tree ();\n   if (struct_tree == error_mark_node\n       || TREE_TYPE (struct_tree) == error_mark_node)\n     return this->error_expression ();\n@@ -1574,42 +1524,37 @@ Gcc_backend::struct_field_expression (Bexpression *bstruct, size_t index,\n \t\t\t      TREE_TYPE (field), struct_tree, field, NULL_TREE);\n   if (TREE_CONSTANT (struct_tree))\n     TREE_CONSTANT (ret) = 1;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that executes BSTAT before BEXPR.\n \n-Bexpression *\n-Gcc_backend::compound_expression (Bstatement *bstat, Bexpression *bexpr,\n+tree\n+Gcc_backend::compound_expression (Bstatement *bstat, tree expr,\n \t\t\t\t  Location location)\n {\n   tree stat = bstat->get_tree ();\n-  tree expr = bexpr->get_tree ();\n   if (stat == error_mark_node || expr == error_mark_node)\n     return this->error_expression ();\n   tree ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t      TREE_TYPE (expr), stat, expr);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that executes THEN_EXPR if CONDITION is true, or\n // ELSE_EXPR otherwise.\n \n-Bexpression *\n+tree\n Gcc_backend::conditional_expression (Bfunction *, tree type_tree,\n-\t\t\t\t     Bexpression *condition,\n-\t\t\t\t     Bexpression *then_expr,\n-\t\t\t\t     Bexpression *else_expr, Location location)\n-{\n-  tree cond_tree = condition->get_tree ();\n-  tree then_tree = then_expr->get_tree ();\n-  tree else_tree = else_expr == NULL ? NULL_TREE : else_expr->get_tree ();\n-  if (type_tree == error_mark_node || cond_tree == error_mark_node\n-      || then_tree == error_mark_node || else_tree == error_mark_node)\n+\t\t\t\t     tree cond_expr, tree then_expr,\n+\t\t\t\t     tree else_expr, Location location)\n+{\n+  if (type_tree == error_mark_node || cond_expr == error_mark_node\n+      || then_expr == error_mark_node || else_expr == error_mark_node)\n     return this->error_expression ();\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, type_tree,\n-\t\t\t cond_tree, then_tree, else_tree);\n-  return this->make_expression (ret);\n+\t\t\t cond_expr, then_expr, else_expr);\n+  return ret;\n }\n \n /* Helper function that converts rust operators to equivalent GCC tree_code.\n@@ -1711,13 +1656,12 @@ is_floating_point (tree t)\n }\n \n // Return an expression for the negation operation OP EXPR.\n-Bexpression *\n-Gcc_backend::negation_expression (NegationOperator op, Bexpression *expr,\n+tree\n+Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n \t\t\t\t  Location location)\n {\n   /* Check if the expression is an error, in which case we return an error\n      expression. */\n-  auto expr_tree = expr->get_tree ();\n   if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n \n@@ -1746,20 +1690,17 @@ Gcc_backend::negation_expression (NegationOperator op, Bexpression *expr,\n \t\t\t\t   tree_type, expr_tree);\n   if (floating_point && extended_type != NULL_TREE)\n     new_tree = convert (original_type, expr_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the arithmetic or logical operation LEFT OP RIGHT.\n-Bexpression *\n+tree\n Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t       Bexpression *left,\n-\t\t\t\t\t       Bexpression *right,\n+\t\t\t\t\t       tree left_tree, tree right_tree,\n \t\t\t\t\t       Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1792,18 +1733,16 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n \t\t\t\t   tree_type, left_tree, right_tree);\n   if (floating_point && extended_type != NULL_TREE)\n     new_tree = convert (original_type, new_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the comparison operation LEFT OP RIGHT.\n-Bexpression *\n-Gcc_backend::comparison_expression (ComparisonOperator op, Bexpression *left,\n-\t\t\t\t    Bexpression *right, Location location)\n+tree\n+Gcc_backend::comparison_expression (ComparisonOperator op, tree left_tree,\n+\t\t\t\t    tree right_tree, Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1814,18 +1753,16 @@ Gcc_backend::comparison_expression (ComparisonOperator op, Bexpression *left,\n   /* Construct a new tree and build an expression from it. */\n   auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n \t\t\t\t   tree_type, left_tree, right_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the lazy boolean operation LEFT OP RIGHT.\n-Bexpression *\n-Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n-\t\t\t\t      Bexpression *right, Location location)\n+tree\n+Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, tree left_tree,\n+\t\t\t\t      tree right_tree, Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1837,14 +1774,14 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n   /* Construct a new tree and build an expression from it. */\n   auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n \t\t\t\t   tree_type, left_tree, right_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression that constructs BTYPE with VALS.\n \n-Bexpression *\n+tree\n Gcc_backend::constructor_expression (tree type_tree,\n-\t\t\t\t     const std::vector<Bexpression *> &vals,\n+\t\t\t\t     const std::vector<tree> &vals,\n \t\t\t\t     int union_index, Location location)\n {\n   if (type_tree == error_mark_node)\n@@ -1859,7 +1796,7 @@ Gcc_backend::constructor_expression (tree type_tree,\n   if (union_index != -1)\n     {\n       gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n-      tree val = vals.front ()->get_tree ();\n+      tree val = vals.front ();\n       for (int i = 0; i < union_index; i++)\n \t{\n \t  gcc_assert (field != NULL_TREE);\n@@ -1891,11 +1828,11 @@ Gcc_backend::constructor_expression (tree type_tree,\n   else\n     {\n       gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); ++p, field = DECL_CHAIN (field))\n \t{\n \t  gcc_assert (field != NULL_TREE);\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t      || TREE_TYPE (val) == error_mark_node)\n \t    return this->error_expression ();\n@@ -1926,13 +1863,13 @@ Gcc_backend::constructor_expression (tree type_tree,\n   if (sink != NULL_TREE)\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n \t\t\t   sink, ret);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n-Bexpression *\n+tree\n Gcc_backend::array_constructor_expression (\n   tree type_tree, const std::vector<unsigned long> &indexes,\n-  const std::vector<Bexpression *> &vals, Location location)\n+  const std::vector<tree> &vals, Location location)\n {\n   if (type_tree == error_mark_node)\n     return this->error_expression ();\n@@ -1949,7 +1886,7 @@ Gcc_backend::array_constructor_expression (\n   for (size_t i = 0; i < vals.size (); ++i)\n     {\n       tree index = size_int (indexes[i]);\n-      tree val = (vals[i])->get_tree ();\n+      tree val = vals[i];\n \n       if (index == error_mark_node || val == error_mark_node)\n \treturn this->error_expression ();\n@@ -1979,17 +1916,15 @@ Gcc_backend::array_constructor_expression (\n   if (sink != NULL_TREE)\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n \t\t\t   sink, ret);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression for the address of BASE[INDEX].\n \n-Bexpression *\n-Gcc_backend::pointer_offset_expression (Bexpression *base, Bexpression *index,\n+tree\n+Gcc_backend::pointer_offset_expression (tree base_tree, tree index_tree,\n \t\t\t\t\tLocation location)\n {\n-  tree base_tree = base->get_tree ();\n-  tree index_tree = index->get_tree ();\n   tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n   if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n       || index_tree == error_mark_node || element_type_tree == error_mark_node)\n@@ -2002,17 +1937,15 @@ Gcc_backend::pointer_offset_expression (Bexpression *base, Bexpression *index,\n \t\t\t\t index_tree, element_size);\n   tree ptr = fold_build2_loc (location.gcc_location (), POINTER_PLUS_EXPR,\n \t\t\t      TREE_TYPE (base_tree), base_tree, offset);\n-  return this->make_expression (ptr);\n+  return ptr;\n }\n \n // Return an expression representing ARRAY[INDEX]\n \n-Bexpression *\n-Gcc_backend::array_index_expression (Bexpression *array, Bexpression *index,\n+tree\n+Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n \t\t\t\t     Location location)\n {\n-  tree array_tree = array->get_tree ();\n-  tree index_tree = index->get_tree ();\n   if (array_tree == error_mark_node || TREE_TYPE (array_tree) == error_mark_node\n       || index_tree == error_mark_node)\n     return this->error_expression ();\n@@ -2029,17 +1962,15 @@ Gcc_backend::array_index_expression (Bexpression *array, Bexpression *index,\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t   void_type_node, array_tree, index_tree);\n \n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Create an expression for a call to FN_EXPR with FN_ARGS.\n-Bexpression *\n+tree\n Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n-\t\t\t      Bexpression *fn_expr,\n-\t\t\t      const std::vector<Bexpression *> &fn_args,\n-\t\t\t      Bexpression *chain_expr, Location location)\n+\t\t\t      tree fn, const std::vector<tree> &fn_args,\n+\t\t\t      tree chain_expr, Location location)\n {\n-  tree fn = fn_expr->get_tree ();\n   if (fn == error_mark_node || TREE_TYPE (fn) == error_mark_node)\n     return this->error_expression ();\n \n@@ -2050,7 +1981,7 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n   tree *args = nargs == 0 ? NULL : new tree[nargs];\n   for (size_t i = 0; i < nargs; ++i)\n     {\n-      args[i] = fn_args.at (i)->get_tree ();\n+      args[i] = fn_args.at (i);\n       if (args[i] == error_mark_node)\n \treturn this->error_expression ();\n     }\n@@ -2096,7 +2027,7 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n \t\t\t    fn, nargs, args);\n \n   if (chain_expr)\n-    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr->get_tree ();\n+    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr;\n \n   if (excess_type != NULL_TREE)\n     {\n@@ -2106,24 +2037,23 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n     }\n \n   delete[] args;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression as a statement.\n \n Bstatement *\n-Gcc_backend::expression_statement (Bfunction *, Bexpression *expr)\n+Gcc_backend::expression_statement (Bfunction *, tree expr)\n {\n-  return this->make_statement (expr->get_tree ());\n+  return this->make_statement (expr);\n }\n \n // Variable initialization.\n \n Bstatement *\n-Gcc_backend::init_statement (Bfunction *, Bvariable *var, Bexpression *init)\n+Gcc_backend::init_statement (Bfunction *, Bvariable *var, tree init_tree)\n {\n   tree var_tree = var->get_decl ();\n-  tree init_tree = init->get_tree ();\n   if (var_tree == error_mark_node || init_tree == error_mark_node)\n     return this->error_statement ();\n   gcc_assert (TREE_CODE (var_tree) == VAR_DECL);\n@@ -2153,12 +2083,10 @@ Gcc_backend::init_statement (Bfunction *, Bvariable *var, Bexpression *init)\n // Assignment.\n \n Bstatement *\n-Gcc_backend::assignment_statement (Bfunction *bfn, Bexpression *lhs,\n-\t\t\t\t   Bexpression *rhs, Location location)\n+Gcc_backend::assignment_statement (Bfunction *bfn, tree lhs, tree rhs,\n+\t\t\t\t   Location location)\n {\n-  tree lhs_tree = lhs->get_tree ();\n-  tree rhs_tree = rhs->get_tree ();\n-  if (lhs_tree == error_mark_node || rhs_tree == error_mark_node)\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n     return this->error_statement ();\n \n   // To avoid problems with GNU ld, we don't make zero-sized\n@@ -2167,26 +2095,25 @@ Gcc_backend::assignment_statement (Bfunction *bfn, Bexpression *lhs,\n   // expression; avoid crashes here by avoiding assignments of\n   // zero-sized expressions.  Such assignments don't really mean\n   // anything anyhow.\n-  if (TREE_TYPE (lhs_tree) == void_type_node\n-      || int_size_in_bytes (TREE_TYPE (lhs_tree)) == 0\n-      || TREE_TYPE (rhs_tree) == void_type_node\n-      || int_size_in_bytes (TREE_TYPE (rhs_tree)) == 0)\n+  if (TREE_TYPE (lhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (lhs)) == 0\n+      || TREE_TYPE (rhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (rhs)) == 0)\n     return this->compound_statement (this->expression_statement (bfn, lhs),\n \t\t\t\t     this->expression_statement (bfn, rhs));\n \n-  rhs_tree = this->convert_tree (TREE_TYPE (lhs_tree), rhs_tree, location);\n+  rhs = this->convert_tree (TREE_TYPE (lhs), rhs, location);\n \n   return this->make_statement (fold_build2_loc (location.gcc_location (),\n \t\t\t\t\t\tMODIFY_EXPR, void_type_node,\n-\t\t\t\t\t\tlhs_tree, rhs_tree));\n+\t\t\t\t\t\tlhs, rhs));\n }\n \n // Return.\n \n Bstatement *\n Gcc_backend::return_statement (Bfunction *bfunction,\n-\t\t\t       const std::vector<Bexpression *> &vals,\n-\t\t\t       Location location)\n+\t\t\t       const std::vector<tree> &vals, Location location)\n {\n   tree fntree = bfunction->get_tree ();\n   if (fntree == error_mark_node)\n@@ -2202,10 +2129,10 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n   if (res_type == void_type_node || int_size_in_bytes (res_type) == 0)\n     {\n       tree stmt_list = NULL_TREE;\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); p++)\n \t{\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (val == error_mark_node)\n \t    return this->error_statement ();\n \t  append_to_statement_list (val, &stmt_list);\n@@ -2222,12 +2149,11 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n \t\t\t   void_type_node, NULL_TREE);\n   else if (vals.size () == 1)\n     {\n-      tree val = vals.front ()->get_tree ();\n+      tree val = vals.front ();\n       if (val == error_mark_node)\n \treturn this->error_statement ();\n-      tree set\n-\t= fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t   void_type_node, result, vals.front ()->get_tree ());\n+      tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n+\t\t\t\t  void_type_node, result, vals.front ());\n       ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n \t\t\t     void_type_node, set);\n     }\n@@ -2248,18 +2174,18 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n       pop_cfun ();\n \n       tree field = TYPE_FIELDS (rettype);\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); p++, field = DECL_CHAIN (field))\n \t{\n \t  gcc_assert (field != NULL_TREE);\n \t  tree ref\n \t    = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n \t\t\t       TREE_TYPE (field), rettmp, field, NULL_TREE);\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (val == error_mark_node)\n \t    return this->error_statement ();\n \t  tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t\t      void_type_node, ref, (*p)->get_tree ());\n+\t\t\t\t      void_type_node, ref, (*p));\n \t  append_to_statement_list (set, &stmt_list);\n \t}\n       gcc_assert (field == NULL_TREE);\n@@ -2308,11 +2234,9 @@ Gcc_backend::exception_handler_statement (Bstatement *bstat,\n // If.\n \n Bstatement *\n-Gcc_backend::if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t   Bblock *then_block, Bblock *else_block,\n-\t\t\t   Location location)\n+Gcc_backend::if_statement (Bfunction *, tree cond_tree, Bblock *then_block,\n+\t\t\t   Bblock *else_block, Location location)\n {\n-  tree cond_tree = condition->get_tree ();\n   tree then_tree = then_block->get_tree ();\n   tree else_tree = else_block == NULL ? NULL_TREE : else_block->get_tree ();\n   if (cond_tree == error_mark_node || then_tree == error_mark_node\n@@ -2325,30 +2249,27 @@ Gcc_backend::if_statement (Bfunction *, Bexpression *condition,\n \n // Loops\n \n-Bexpression *\n+tree\n Gcc_backend::loop_expression (Bblock *body, Location locus)\n {\n-  tree loop_expr_tree = fold_build1_loc (locus.gcc_location (), LOOP_EXPR,\n-\t\t\t\t\t void_type_node, body->get_tree ());\n-  return this->make_expression (loop_expr_tree);\n+  return fold_build1_loc (locus.gcc_location (), LOOP_EXPR, void_type_node,\n+\t\t\t  body->get_tree ());\n }\n \n-Bexpression *\n-Gcc_backend::exit_expression (Bexpression *condition, Location locus)\n+tree\n+Gcc_backend::exit_expression (tree cond_tree, Location locus)\n {\n-  tree cond_tree = condition->get_tree ();\n-  tree exit_expr_tree = fold_build1_loc (locus.gcc_location (), EXIT_EXPR,\n-\t\t\t\t\t void_type_node, cond_tree);\n-  return this->make_expression (exit_expr_tree);\n+  return fold_build1_loc (locus.gcc_location (), EXIT_EXPR, void_type_node,\n+\t\t\t  cond_tree);\n }\n \n // Switch.\n \n Bstatement *\n-Gcc_backend::switch_statement (\n-  Bfunction *function, Bexpression *value,\n-  const std::vector<std::vector<Bexpression *> > &cases,\n-  const std::vector<Bstatement *> &statements, Location switch_location)\n+Gcc_backend::switch_statement (Bfunction *function, tree value,\n+\t\t\t       const std::vector<std::vector<tree>> &cases,\n+\t\t\t       const std::vector<Bstatement *> &statements,\n+\t\t\t       Location switch_location)\n {\n   gcc_assert (cases.size () == statements.size ());\n \n@@ -2359,7 +2280,7 @@ Gcc_backend::switch_statement (\n     push_cfun (DECL_STRUCT_FUNCTION (decl));\n \n   tree stmt_list = NULL_TREE;\n-  std::vector<std::vector<Bexpression *> >::const_iterator pc = cases.begin ();\n+  std::vector<std::vector<tree>>::const_iterator pc = cases.begin ();\n   for (std::vector<Bstatement *>::const_iterator ps = statements.begin ();\n        ps != statements.end (); ++ps, ++pc)\n     {\n@@ -2373,15 +2294,15 @@ Gcc_backend::switch_statement (\n \t}\n       else\n \t{\n-\t  for (std::vector<Bexpression *>::const_iterator pcv = pc->begin ();\n+\t  for (std::vector<tree>::const_iterator pcv = pc->begin ();\n \t       pcv != pc->end (); ++pcv)\n \t    {\n-\t      tree t = (*pcv)->get_tree ();\n+\t      tree t = (*pcv);\n \t      if (t == error_mark_node)\n \t\treturn this->error_statement ();\n \t      location_t loc = EXPR_LOCATION (t);\n \t      tree label = create_artificial_label (loc);\n-\t      tree c = build_case_label ((*pcv)->get_tree (), NULL_TREE, label);\n+\t      tree c = build_case_label ((*pcv), NULL_TREE, label);\n \t      append_to_statement_list (c, &stmt_list);\n \t    }\n \t}\n@@ -2396,7 +2317,7 @@ Gcc_backend::switch_statement (\n     }\n   pop_cfun ();\n \n-  tree tv = value->get_tree ();\n+  tree tv = value;\n   if (tv == error_mark_node)\n     return this->error_statement ();\n   tree t = build2_loc (switch_location.gcc_location (), SWITCH_EXPR, NULL_TREE,\n@@ -2680,9 +2601,8 @@ Gcc_backend::global_variable (const std::string &var_name,\n // Set the initial value of a global variable.\n \n void\n-Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n+Gcc_backend::global_variable_set_init (Bvariable *var, tree expr_tree)\n {\n-  tree expr_tree = expr->get_tree ();\n   if (expr_tree == error_mark_node)\n     return;\n   gcc_assert (TREE_CONSTANT (expr_tree));\n@@ -2784,13 +2704,12 @@ Gcc_backend::static_chain_variable (Bfunction *function,\n \n Bvariable *\n Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n-\t\t\t\t tree type_tree, Bexpression *binit,\n+\t\t\t\t tree type_tree, tree init_tree,\n \t\t\t\t bool is_address_taken, Location location,\n \t\t\t\t Bstatement **pstatement)\n {\n   gcc_assert (function != NULL);\n   tree decl = function->get_tree ();\n-  tree init_tree = binit == NULL ? NULL_TREE : binit->get_tree ();\n   if (type_tree == error_mark_node || init_tree == error_mark_node\n       || decl == error_mark_node)\n     {\n@@ -2845,9 +2764,8 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n   if (init_tree != NULL_TREE\n       && (this->type_size (type_tree) == 0\n \t  || TREE_TYPE (init_tree) == void_type_node))\n-    *pstatement\n-      = this->compound_statement (this->expression_statement (function, binit),\n-\t\t\t\t  *pstatement);\n+    *pstatement = this->compound_statement (\n+      this->expression_statement (function, init_tree), *pstatement);\n \n   return new Bvariable (var);\n }\n@@ -2912,14 +2830,9 @@ Gcc_backend::implicit_variable (const std::string &name,\n void\n Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n \t\t\t\t\t tree, bool, bool, bool is_common,\n-\t\t\t\t\t Bexpression *init)\n+\t\t\t\t\t tree init_tree)\n {\n   tree decl = var->get_decl ();\n-  tree init_tree;\n-  if (init == NULL)\n-    init_tree = NULL_TREE;\n-  else\n-    init_tree = init->get_tree ();\n   if (decl == error_mark_node || init_tree == error_mark_node)\n     return;\n \n@@ -3012,10 +2925,9 @@ Gcc_backend::immutable_struct (const std::string &name,\n void\n Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n \t\t\t\t\tbool, bool is_common, tree, Location,\n-\t\t\t\t\tBexpression *initializer)\n+\t\t\t\t\ttree init_tree)\n {\n   tree decl = var->get_decl ();\n-  tree init_tree = initializer->get_tree ();\n   if (decl == error_mark_node || init_tree == error_mark_node)\n     return;\n \n@@ -3114,7 +3026,7 @@ Gcc_backend::goto_statement (Blabel *label, Location location)\n \n // Get the address of a label.\n \n-Bexpression *\n+tree\n Gcc_backend::label_address (Blabel *label, Location location)\n {\n   tree lab = label->get_tree ();\n@@ -3124,7 +3036,7 @@ Gcc_backend::label_address (Blabel *label, Location location)\n     = fold_convert_loc (location.gcc_location (), ptr_type_node,\n \t\t\tbuild_fold_addr_expr_loc (location.gcc_location (),\n \t\t\t\t\t\t  lab));\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Declare or define a new function.\n@@ -3186,12 +3098,9 @@ Gcc_backend::function (tree functype, const std::string &name,\n //     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n \n Bstatement *\n-Gcc_backend::function_defer_statement (Bfunction *function,\n-\t\t\t\t       Bexpression *undefer, Bexpression *defer,\n-\t\t\t\t       Location location)\n+Gcc_backend::function_defer_statement (Bfunction *function, tree undefer_tree,\n+\t\t\t\t       tree defer_tree, Location location)\n {\n-  tree undefer_tree = undefer->get_tree ();\n-  tree defer_tree = defer->get_tree ();\n   tree fntree = function->get_tree ();\n \n   if (undefer_tree == error_mark_node || defer_tree == error_mark_node\n@@ -3286,8 +3195,7 @@ Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n \n void\n Gcc_backend::write_global_definitions (\n-  const std::vector<tree> &type_decls,\n-  const std::vector<Bexpression *> &constant_decls,\n+  const std::vector<tree> &type_decls, const std::vector<tree> &constant_decls,\n   const std::vector<Bfunction *> &function_decls,\n   const std::vector<Bvariable *> &variable_decls)\n {\n@@ -3322,12 +3230,12 @@ Gcc_backend::write_global_definitions (\n \t  ++i;\n \t}\n     }\n-  for (std::vector<Bexpression *>::const_iterator p = constant_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = constant_decls.begin ();\n        p != constant_decls.end (); ++p)\n     {\n-      if ((*p)->get_tree () != error_mark_node)\n+      if ((*p) != error_mark_node)\n \t{\n-\t  defs[i] = (*p)->get_tree ();\n+\t  defs[i] = (*p);\n \t  rust_preserve_from_gc (defs[i]);\n \t  ++i;\n \t}"}, {"sha": "a3f5a16118ef870796afdea1c4c0a8227f100f23", "filename": "gcc/rust/typecheck/rust-hir-const-fold-ctx.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -36,15 +36,15 @@ class Context\n \n   ::Backend *get_backend () { return backend; }\n \n-  bool lookup_const (HirId id, Bexpression **expr);\n+  bool lookup_const (HirId id, tree *expr);\n \n-  void insert_const (HirId, Bexpression *expr);\n+  void insert_const (HirId, tree expr);\n \n private:\n   Context (::Backend *backend);\n \n   ::Backend *backend;\n-  std::map<HirId, Bexpression *> ctx;\n+  std::map<HirId, tree> ctx;\n };\n \n } // namespace ConstFold"}, {"sha": "6acedd19b0fc015f13590094af7d7b6ba23eb258", "filename": "gcc/rust/typecheck/rust-hir-const-fold.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -41,7 +41,7 @@ Context::get ()\n }\n \n bool\n-Context::lookup_const (HirId id, Bexpression **expr)\n+Context::lookup_const (HirId id, tree *expr)\n {\n   auto it = ctx.find (id);\n   if (it == ctx.end ())\n@@ -52,7 +52,7 @@ Context::lookup_const (HirId id, Bexpression **expr)\n }\n \n void\n-Context::insert_const (HirId id, Bexpression *expr)\n+Context::insert_const (HirId id, tree expr)\n {\n   rust_assert (ctx.find (id) == ctx.end ());\n   ctx[id] = expr;\n@@ -75,7 +75,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n {\n   unsigned long index = 0;\n   std::vector<unsigned long> indices;\n-  std::vector<Bexpression *> values;\n+  std::vector<tree> values;\n \n   TyTy::BaseType *tyty = nullptr;\n   if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -102,7 +102,7 @@ void\n ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n {\n   std::vector<unsigned long> indices;\n-  std::vector<Bexpression *> values;\n+  std::vector<tree> values;\n \n   TyTy::BaseType *tyty = nullptr;\n   if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -113,11 +113,11 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n     }\n \n   tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n-  Bexpression *elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n+  tree elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n \n   // num copies expr was already folded in rust-hir-type-check-expr; lookup the\n   // earlier result\n-  Bexpression *num_copies_expr = ctx->get_backend ()->error_expression ();\n+  tree num_copies_expr = ctx->get_backend ()->error_expression ();\n   ctx->lookup_const (elems.get_num_copies_expr ()->get_mappings ().get_hirid (),\n \t\t     &num_copies_expr);\n "}, {"sha": "c965e25017c183ff334b08b3e08a74f706fe92b7", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -237,7 +237,7 @@ class ConstFoldItem : public ConstFoldBase\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::Item &item)\n+  static tree fold (HIR::Item &item)\n   {\n     ConstFoldItem folder;\n     item.accept_vis (folder);\n@@ -258,15 +258,15 @@ class ConstFoldItem : public ConstFoldBase\n     : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n };\n \n class ConstFoldArrayElems : public ConstFoldBase\n {\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::ArrayExpr &expr)\n+  static tree fold (HIR::ArrayExpr &expr)\n   {\n     ConstFoldArrayElems folder (expr);\n     HIR::ArrayElems *elems = expr.get_internal_elements ();\n@@ -283,7 +283,7 @@ class ConstFoldArrayElems : public ConstFoldBase\n       expr (expr)\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n   HIR::ArrayExpr &expr;\n };\n \n@@ -292,7 +292,7 @@ class ConstFoldExpr : public ConstFoldBase\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::Expr *expr)\n+  static tree fold (HIR::Expr *expr)\n   {\n     ConstFoldExpr folder;\n     expr->accept_vis (folder);\n@@ -453,24 +453,24 @@ class ConstFoldExpr : public ConstFoldBase\n \n   void visit (HIR::ArrayIndexExpr &expr) override\n   {\n-    Bexpression *array = ConstFoldExpr::fold (expr.get_array_expr ());\n-    Bexpression *index = ConstFoldExpr::fold (expr.get_index_expr ());\n+    tree array = ConstFoldExpr::fold (expr.get_array_expr ());\n+    tree index = ConstFoldExpr::fold (expr.get_index_expr ());\n \n     folded = ctx->get_backend ()->array_index_expression (array, index,\n \t\t\t\t\t\t\t  expr.get_locus ());\n   }\n \n   void visit (HIR::BorrowExpr &expr) override\n   {\n-    Bexpression *main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n+    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n \n     folded\n       = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override\n   {\n-    Bexpression *main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n+    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n \n     TyTy::BaseType *tyty = nullptr;\n     if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -497,7 +497,7 @@ class ConstFoldExpr : public ConstFoldBase\n     : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n };\n \n } // namespace ConstFold"}, {"sha": "daef15ba8ed7f5858fd79aca3ee2416b3182e7b0", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -687,7 +687,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t\t\t\t  UNKNOWN_LOCAL_DEFID);\n \n \t  /* Capacity is the size of the string (number of chars).\n-\t     It is a constant, but for fold it to get a Bexpression.  */\n+\t     It is a constant, but for fold it to get a tree.  */\n \t  std::string capacity_str\n \t    = std::to_string (expr.get_literal ()->as_string ().size ());\n \t  HIR::LiteralExpr literal_capacity (capacity_mapping, capacity_str,\n@@ -700,8 +700,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t\tnew TyTy::USizeType (\n \t\t\t\t  capacity_mapping.get_hirid ()));\n \n-\t  Bexpression *capacity\n-\t    = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n+\t  tree capacity = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n \n \t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n \t\t\t\t\t       mappings->get_next_hir_id (\n@@ -1491,7 +1490,7 @@ class TypeCheckExpr : public TypeCheckBase\n   /* The return value of visit(ArrayElemsValues&) and visit(ArrayElemsCopied&)\n      Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n-  Bexpression *folded_array_capacity;\n+  tree folded_array_capacity;\n   Location root_array_expr_locus;\n \n   bool inside_loop;"}, {"sha": "915aad9909bc702ce41e8ebb3ad62b90041ec971", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a68d2d8676ea378f0fbb6726639cc80402542/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=b52a68d2d8676ea378f0fbb6726639cc80402542", "patch": "@@ -1588,13 +1588,13 @@ class ClosureType : public BaseType, public SubstitutionRef\n class ArrayType : public BaseType\n {\n public:\n-  ArrayType (HirId ref, Bexpression *capacity, TyVar base,\n+  ArrayType (HirId ref, tree capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, Bexpression *capacity, TyVar base,\n+  ArrayType (HirId ref, HirId ty_ref, tree capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n@@ -1615,7 +1615,7 @@ class ArrayType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  Bexpression *get_capacity () const { return capacity; }\n+  tree get_capacity () const { return capacity; }\n   std::string capacity_string () const;\n \n   BaseType *get_element_type () const;\n@@ -1628,7 +1628,7 @@ class ArrayType : public BaseType\n   }\n \n private:\n-  Bexpression *capacity;\n+  tree capacity;\n   TyVar element_type;\n };\n "}]}