{"sha": "6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyMWYzYjUyZWM0YjFjOTFhNjM2YTZhOGE3M2QwZmJhNjhmYzUwZQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2017-05-18T23:38:04Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2017-05-18T23:38:04Z"}, "message": "rs6000: Separate shrink-wrapping for FPRs\n\nThis patch implements separate shrink-wrapping for the non-volatile\nfloating point registers (FPR14..FPR31).  It is pretty much exactly\nanalogous to the code for GPRs.\n\n\n\t* config/rs6000/rs6000.c (struct machine_function): Add field\n\tfpr_is_wrapped_separately.\n\t(rs6000_get_separate_components): Use 64 components.  Handle the\n\tnew FPR components.\n\t(rs6000_components_for_bb): Handle the FPR components.\n\t(rs6000_emit_prologue_components): Handle the FPR components.\n\t(rs6000_emit_epilogue_components): Handle the FPR components.\n\t(rs6000_set_handled_components): Handle the FPR components.\n\t(rs6000_emit_prologue): Don't output prologue code for those FPRs\n\tthat are already separately shrink-wrapped.\n\t(rs6000_emit_epilogue): Don't output epilogue code for those FPRs\n\tthat are already separately shrink-wrapped.\n\nFrom-SVN: r248256", "tree": {"sha": "246db0228a686d016aa85e8da3f3425bf10a8a37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/246db0228a686d016aa85e8da3f3425bf10a8a37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "afbc9ecbf6c38730ac304a77e8f397f2509780f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbc9ecbf6c38730ac304a77e8f397f2509780f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afbc9ecbf6c38730ac304a77e8f397f2509780f6"}], "stats": {"total": 177, "additions": 146, "deletions": 31}, "files": [{"sha": "23f9b69074bdf00b01bcc5d82ed13dc374a3f2d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e", "patch": "@@ -1,3 +1,18 @@\n+2017-05-18  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.c (struct machine_function): Add field\n+\tfpr_is_wrapped_separately.\n+\t(rs6000_get_separate_components): Use 64 components.  Handle the\n+\tnew FPR components.\n+\t(rs6000_components_for_bb): Handle the FPR components.\n+\t(rs6000_emit_prologue_components): Handle the FPR components.\n+\t(rs6000_emit_epilogue_components): Handle the FPR components.\n+\t(rs6000_set_handled_components): Handle the FPR components.\n+\t(rs6000_emit_prologue): Don't output prologue code for those FPRs\n+\tthat are already separately shrink-wrapped.\n+\t(rs6000_emit_epilogue): Don't output epilogue code for those FPRs\n+\tthat are already separately shrink-wrapped.\n+\n 2017-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/80510"}, {"sha": "d4906cc894e06dbad1348e87224bf7e61fa6e4cd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 131, "deletions": 31, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6e21f3b52ec4b1c91a636a6a8a73d0fba68fc50e", "patch": "@@ -159,6 +159,7 @@ typedef struct GTY(()) machine_function\n   /* The components already handled by separate shrink-wrapping, which should\n      not be considered by the prologue and epilogue.  */\n   bool gpr_is_wrapped_separately[32];\n+  bool fpr_is_wrapped_separately[32];\n   bool lr_is_wrapped_separately;\n } machine_function;\n \n@@ -29221,17 +29222,25 @@ rs6000_get_separate_components (void)\n   if (TARGET_SPE_ABI)\n     return NULL;\n \n-  sbitmap components = sbitmap_alloc (32);\n-  bitmap_clear (components);\n-\n   gcc_assert (!(info->savres_strategy & SAVE_MULTIPLE)\n \t      && !(info->savres_strategy & REST_MULTIPLE));\n \n+  /* Component 0 is the save/restore of LR (done via GPR0).\n+     Components 13..31 are the save/restore of GPR13..GPR31.\n+     Components 46..63 are the save/restore of FPR14..FPR31.  */\n+\n+  int n_components = 64;\n+\n+  sbitmap components = sbitmap_alloc (n_components);\n+  bitmap_clear (components);\n+\n+  int reg_size = TARGET_32BIT ? 4 : 8;\n+  int fp_reg_size = 8;\n+\n   /* The GPRs we need saved to the frame.  */\n   if ((info->savres_strategy & SAVE_INLINE_GPRS)\n       && (info->savres_strategy & REST_INLINE_GPRS))\n     {\n-      int reg_size = TARGET_32BIT ? 4 : 8;\n       int offset = info->gp_save_offset;\n       if (info->push_p)\n \toffset += info->total_size;\n@@ -29256,6 +29265,23 @@ rs6000_get_separate_components (void)\n       || (flag_pic && DEFAULT_ABI == ABI_DARWIN))\n     bitmap_clear_bit (components, RS6000_PIC_OFFSET_TABLE_REGNUM);\n \n+  /* The FPRs we need saved to the frame.  */\n+  if ((info->savres_strategy & SAVE_INLINE_FPRS)\n+      && (info->savres_strategy & REST_INLINE_FPRS))\n+    {\n+      int offset = info->fp_save_offset;\n+      if (info->push_p)\n+\toffset += info->total_size;\n+\n+      for (unsigned regno = info->first_fp_reg_save; regno < 64; regno++)\n+\t{\n+\t  if (IN_RANGE (offset, -0x8000, 0x7fff) && save_reg_p (regno))\n+\t    bitmap_set_bit (components, regno);\n+\n+\t  offset += fp_reg_size;\n+\t}\n+    }\n+\n   /* Optimize LR save and restore if we can.  This is component 0.  Any\n      out-of-line register save/restore routines need LR.  */\n   if (info->lr_save_p\n@@ -29290,14 +29316,23 @@ rs6000_components_for_bb (basic_block bb)\n   sbitmap components = sbitmap_alloc (32);\n   bitmap_clear (components);\n \n-  /* GPRs are used in a bb if they are in the IN, GEN, or KILL sets.  */\n+  /* A register is used in a bb if it is in the IN, GEN, or KILL sets.  */\n+\n+  /* GPRs.  */\n   for (unsigned regno = info->first_gp_reg_save; regno < 32; regno++)\n     if (bitmap_bit_p (in, regno)\n \t|| bitmap_bit_p (gen, regno)\n \t|| bitmap_bit_p (kill, regno))\n       bitmap_set_bit (components, regno);\n \n-  /* LR needs to be saved around a bb if it is killed in that bb.  */\n+  /* FPRs.  */\n+  for (unsigned regno = info->first_fp_reg_save; regno < 64; regno++)\n+    if (bitmap_bit_p (in, regno)\n+\t|| bitmap_bit_p (gen, regno)\n+\t|| bitmap_bit_p (kill, regno))\n+      bitmap_set_bit (components, regno);\n+\n+  /* The link register.  */\n   if (bitmap_bit_p (in, LR_REGNO)\n       || bitmap_bit_p (gen, LR_REGNO)\n       || bitmap_bit_p (kill, LR_REGNO))\n@@ -29331,13 +29366,18 @@ rs6000_emit_prologue_components (sbitmap components)\n   rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed\n \t\t\t     ? HARD_FRAME_POINTER_REGNUM\n \t\t\t     : STACK_POINTER_REGNUM);\n+\n+  machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n+  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n+\t\t\t     ? DFmode : SFmode;\n+  int fp_reg_size = 8;\n \n   /* Prologue for LR.  */\n   if (bitmap_bit_p (components, 0))\n     {\n-      rtx reg = gen_rtx_REG (Pmode, 0);\n-      rtx_insn *insn = emit_move_insn (reg, gen_rtx_REG (Pmode, LR_REGNO));\n+      rtx reg = gen_rtx_REG (reg_mode, 0);\n+      rtx_insn *insn = emit_move_insn (reg, gen_rtx_REG (reg_mode, LR_REGNO));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       add_reg_note (insn, REG_CFA_REGISTER, NULL);\n \n@@ -29347,7 +29387,7 @@ rs6000_emit_prologue_components (sbitmap components)\n \n       insn = emit_insn (gen_frame_store (reg, ptr_reg, offset));\n       RTX_FRAME_RELATED_P (insn) = 1;\n-      rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n+      rtx lr = gen_rtx_REG (reg_mode, LR_REGNO);\n       rtx mem = copy_rtx (SET_DEST (single_set (insn)));\n       add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (mem, lr));\n     }\n@@ -29361,7 +29401,7 @@ rs6000_emit_prologue_components (sbitmap components)\n     {\n       if (bitmap_bit_p (components, i))\n \t{\n-\t  rtx reg = gen_rtx_REG (Pmode, i);\n+\t  rtx reg = gen_rtx_REG (reg_mode, i);\n \t  rtx_insn *insn = emit_insn (gen_frame_store (reg, ptr_reg, offset));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  rtx set = copy_rtx (single_set (insn));\n@@ -29370,6 +29410,25 @@ rs6000_emit_prologue_components (sbitmap components)\n \n       offset += reg_size;\n     }\n+\n+  /* Prologue for the FPRs.  */\n+  offset = info->fp_save_offset;\n+  if (info->push_p)\n+    offset += info->total_size;\n+\n+  for (int i = info->first_fp_reg_save; i < 64; i++)\n+    {\n+      if (bitmap_bit_p (components, i))\n+\t{\n+\t  rtx reg = gen_rtx_REG (fp_reg_mode, i);\n+\t  rtx_insn *insn = emit_insn (gen_frame_store (reg, ptr_reg, offset));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  rtx set = copy_rtx (single_set (insn));\n+\t  add_reg_note (insn, REG_CFA_OFFSET, set);\n+\t}\n+\n+      offset += fp_reg_size;\n+    }\n }\n \n /* Implement TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS.  */\n@@ -29380,18 +29439,42 @@ rs6000_emit_epilogue_components (sbitmap components)\n   rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed\n \t\t\t     ? HARD_FRAME_POINTER_REGNUM\n \t\t\t     : STACK_POINTER_REGNUM);\n+\n+  machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n \n+  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n+\t\t\t     ? DFmode : SFmode;\n+  int fp_reg_size = 8;\n+\n+  /* Epilogue for the FPRs.  */\n+  int offset = info->fp_save_offset;\n+  if (info->push_p)\n+    offset += info->total_size;\n+\n+  for (int i = info->first_fp_reg_save; i < 64; i++)\n+    {\n+      if (bitmap_bit_p (components, i))\n+\t{\n+\t  rtx reg = gen_rtx_REG (fp_reg_mode, i);\n+\t  rtx_insn *insn = emit_insn (gen_frame_load (reg, ptr_reg, offset));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t}\n+\n+      offset += fp_reg_size;\n+    }\n+\n   /* Epilogue for the GPRs.  */\n-  int offset = info->gp_save_offset;\n+  offset = info->gp_save_offset;\n   if (info->push_p)\n     offset += info->total_size;\n \n   for (int i = info->first_gp_reg_save; i < 32; i++)\n     {\n       if (bitmap_bit_p (components, i))\n \t{\n-\t  rtx reg = gen_rtx_REG (Pmode, i);\n+\t  rtx reg = gen_rtx_REG (reg_mode, i);\n \t  rtx_insn *insn = emit_insn (gen_frame_load (reg, ptr_reg, offset));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n@@ -29407,7 +29490,7 @@ rs6000_emit_epilogue_components (sbitmap components)\n       if (info->push_p)\n \toffset += info->total_size;\n \n-      rtx reg = gen_rtx_REG (Pmode, 0);\n+      rtx reg = gen_rtx_REG (reg_mode, 0);\n       rtx_insn *insn = emit_insn (gen_frame_load (reg, ptr_reg, offset));\n \n       rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n@@ -29427,6 +29510,10 @@ rs6000_set_handled_components (sbitmap components)\n     if (bitmap_bit_p (components, i))\n       cfun->machine->gpr_is_wrapped_separately[i] = true;\n \n+  for (int i = info->first_fp_reg_save; i < 64; i++)\n+    if (bitmap_bit_p (components, i))\n+      cfun->machine->fpr_is_wrapped_separately[i - 32] = true;\n+\n   if (bitmap_bit_p (components, 0))\n     cfun->machine->lr_is_wrapped_separately = true;\n }\n@@ -29439,6 +29526,9 @@ rs6000_emit_prologue (void)\n   rs6000_stack_t *info = rs6000_stack_info ();\n   machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n+  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n+\t\t\t     ? DFmode : SFmode;\n+  int fp_reg_size = 8;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n   rtx frame_reg_rtx = sp_reg_rtx;\n   unsigned int cr_save_regno;\n@@ -29736,15 +29826,16 @@ rs6000_emit_prologue (void)\n      it ourselves.  Otherwise, call function.  */\n   if (!WORLD_SAVE_P (info) && (strategy & SAVE_INLINE_FPRS))\n     {\n-      int i;\n-      for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-\tif (save_reg_p (info->first_fp_reg_save + i))\n-\t  emit_frame_save (frame_reg_rtx,\n-\t\t\t   (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t    ? DFmode : SFmode),\n-\t\t\t   info->first_fp_reg_save + i,\n-\t\t\t   info->fp_save_offset + frame_off + 8 * i,\n-\t\t\t   sp_off - frame_off);\n+      int offset = info->fp_save_offset + frame_off;\n+      for (int i = info->first_fp_reg_save; i < 64; i++)\n+\t{\n+\t  if (save_reg_p (i)\n+\t      && !cfun->machine->fpr_is_wrapped_separately[i - 32])\n+\t    emit_frame_save (frame_reg_rtx, fp_reg_mode, i, offset,\n+\t\t\t     sp_off - frame_off);\n+\n+\t  offset += fp_reg_size;\n+\t}\n     }\n   else if (!WORLD_SAVE_P (info) && info->first_fp_reg_save != 64)\n     {\n@@ -30818,6 +30909,9 @@ rs6000_emit_epilogue (int sibcall)\n   rtx cr_save_reg = NULL_RTX;\n   machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n+  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n+\t\t\t     ? DFmode : SFmode;\n+  int fp_reg_size = 8;\n   int i;\n   bool exit_func;\n   unsigned ptr_regno;\n@@ -31564,17 +31658,23 @@ rs6000_emit_epilogue (int sibcall)\n \n   /* Restore fpr's if we need to do it without calling a function.  */\n   if (restoring_FPRs_inline)\n-    for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-      if (save_reg_p (info->first_fp_reg_save + i))\n+    {\n+      int offset = info->fp_save_offset + frame_off;\n+      for (i = info->first_fp_reg_save; i < 64; i++)\n \t{\n-\t  rtx reg = gen_rtx_REG ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t\t  ? DFmode : SFmode),\n-\t\t\t\t info->first_fp_reg_save + i);\n-\t  emit_insn (gen_frame_load (reg, frame_reg_rtx,\n-\t\t\t\t     info->fp_save_offset + frame_off + 8 * i));\n-\t  if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n+\t  if (save_reg_p (i)\n+\t      && !cfun->machine->fpr_is_wrapped_separately[i - 32])\n+\t    {\n+\t      rtx reg = gen_rtx_REG (fp_reg_mode, i);\n+\t      emit_insn (gen_frame_load (reg, frame_reg_rtx, offset));\n+\t      if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n+\t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n+\t\t\t\t\t       cfa_restores);\n+\t    }\n+\n+\t  offset += fp_reg_size;\n \t}\n+    }\n \n   /* If we saved cr, restore it here.  Just those that were used.  */\n   if (info->cr_save_p)"}]}