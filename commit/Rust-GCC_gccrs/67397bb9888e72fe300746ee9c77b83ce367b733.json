{"sha": "67397bb9888e72fe300746ee9c77b83ce367b733", "node_id": "C_kwDOANBUbNoAKDY3Mzk3YmI5ODg4ZTcyZmUzMDA3NDZlZTljNzdiODNjZTM2N2I3MzM", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2021-09-04T17:11:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-25T15:07:19Z"}, "message": "[Ada] Ada 2022: Class-wide types and formal abstract subprograms\n\ngcc/ada/\n\n\t* sem_ch8.adb (Build_Class_Wide_Wrapper): Previous version split\n\tin two subprograms to factorize its functionality:\n\tFind_Suitable_Candidate, and Build_Class_Wide_Wrapper. These\n\troutines are also placed in the new subprogram\n\tHandle_Instance_With_Class_Wide_Type.\n\t(Handle_Instance_With_Class_Wide_Type): New subprogram that\n\tencapsulates all the code that handles instantiations with\n\tclass-wide types.\n\t(Analyze_Subprogram_Renaming): Adjust code to invoke the new\n\tnested subprogram Handle_Instance_With_Class_Wide_Type; adjust\n\tdocumentation.", "tree": {"sha": "ddcc5b047f41927b49cbf97520203812f02d6827", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddcc5b047f41927b49cbf97520203812f02d6827"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67397bb9888e72fe300746ee9c77b83ce367b733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67397bb9888e72fe300746ee9c77b83ce367b733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67397bb9888e72fe300746ee9c77b83ce367b733", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67397bb9888e72fe300746ee9c77b83ce367b733/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19e7eae5b917d782d20d59f3cbe3c344a06aafb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e7eae5b917d782d20d59f3cbe3c344a06aafb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19e7eae5b917d782d20d59f3cbe3c344a06aafb7"}], "stats": {"total": 1377, "additions": 784, "deletions": 593}, "files": [{"sha": "1513cd5579c5fa27f8f419771143a521621e4e6b", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 784, "deletions": 593, "changes": 1377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67397bb9888e72fe300746ee9c77b83ce367b733/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67397bb9888e72fe300746ee9c77b83ce367b733/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=67397bb9888e72fe300746ee9c77b83ce367b733", "patch": "@@ -2109,42 +2109,6 @@ package body Sem_Ch8 is\n       Old_S       : Entity_Id := Empty;\n       Rename_Spec : Entity_Id;\n \n-      procedure Build_Class_Wide_Wrapper\n-        (Ren_Id  : out Entity_Id;\n-         Wrap_Id : out Entity_Id);\n-      --  Ada 2012 (AI05-0071): A generic/instance scenario involving a formal\n-      --  type with unknown discriminants and a generic primitive operation of\n-      --  the said type with a box require special processing when the actual\n-      --  is a class-wide type:\n-      --\n-      --    generic\n-      --       type Formal_Typ (<>) is private;\n-      --       with procedure Prim_Op (Param : Formal_Typ) is <>;\n-      --    package Gen is ...\n-      --\n-      --    package Inst is new Gen (Actual_Typ'Class);\n-      --\n-      --  In this case the general renaming mechanism used in the prologue of\n-      --  an instance no longer applies:\n-      --\n-      --    procedure Prim_Op (Param : Formal_Typ) renames Prim_Op;\n-      --\n-      --  The above is replaced the following wrapper/renaming combination:\n-      --\n-      --    procedure Wrapper (Param : Formal_Typ) is  --  wrapper\n-      --    begin\n-      --       Prim_Op (Param);                        --  primitive\n-      --    end Wrapper;\n-      --\n-      --    procedure Prim_Op (Param : Formal_Typ) renames Wrapper;\n-      --\n-      --  This transformation applies only if there is no explicit visible\n-      --  class-wide operation at the point of the instantiation. Ren_Id is\n-      --  the entity of the renaming declaration. When the transformation\n-      --  applies, Wrap_Id is the entity of the generated class-wide wrapper\n-      --  (or Any_Id). Otherwise, Wrap_Id is the entity of the class-wide\n-      --  operation.\n-\n       procedure Check_Null_Exclusion\n         (Ren : Entity_Id;\n          Sub : Entity_Id);\n@@ -2170,9 +2134,21 @@ package body Sem_Ch8 is\n       --  incomplete untagged formal (RM 13.14(10.2/3)).\n \n       function Has_Class_Wide_Actual return Boolean;\n-      --  Ada 2012 (AI05-071, AI05-0131): True if N is the renaming for a\n-      --  defaulted formal subprogram where the actual for the controlling\n-      --  formal type is class-wide.\n+      --  Ada 2012 (AI05-071, AI05-0131) and Ada 2022 (AI12-0165): True if N is\n+      --  the renaming for a defaulted formal subprogram where the actual for\n+      --  the controlling formal type is class-wide.\n+\n+      procedure Handle_Instance_With_Class_Wide_Type\n+        (Inst_Node    : Node_Id;\n+         Ren_Id       : Entity_Id;\n+         Wrapped_Prim : out Entity_Id;\n+         Wrap_Id      : out Entity_Id);\n+      --  Ada 2012 (AI05-0071), Ada 2022 (AI12-0165): when the actual type\n+      --  of an instantiation is a class-wide type T'Class we may need to\n+      --  wrap a primitive operation of T; this routine looks for a suitable\n+      --  primitive to be wrapped and (if the wrapper is required) returns the\n+      --  Id of the wrapped primitive and the Id of the built wrapper. Ren_Id\n+      --  is the defining entity for the renamed subprogram specification.\n \n       function Original_Subprogram (Subp : Entity_Id) return Entity_Id;\n       --  Find renamed entity when the declaration is a renaming_as_body and\n@@ -2181,550 +2157,6 @@ package body Sem_Ch8 is\n       --  before the subprogram it completes is frozen, and renaming indirectly\n       --  renames the subprogram itself.(Defect Report 8652/0027).\n \n-      ------------------------------\n-      -- Build_Class_Wide_Wrapper --\n-      ------------------------------\n-\n-      procedure Build_Class_Wide_Wrapper\n-        (Ren_Id  : out Entity_Id;\n-         Wrap_Id : out Entity_Id)\n-      is\n-         Loc : constant Source_Ptr := Sloc (N);\n-\n-         function Build_Call\n-           (Subp_Id : Entity_Id;\n-            Params  : List_Id) return Node_Id;\n-         --  Create a dispatching call to invoke routine Subp_Id with actuals\n-         --  built from the parameter specifications of list Params.\n-\n-         function Build_Expr_Fun_Call\n-           (Subp_Id : Entity_Id;\n-            Params  : List_Id) return Node_Id;\n-         --  Create a dispatching call to invoke function Subp_Id with actuals\n-         --  built from the parameter specifications of list Params. Return\n-         --  directly the call, so that it can be used inside an expression\n-         --  function. This is a specificity of the GNATprove mode.\n-\n-         function Build_Spec (Subp_Id : Entity_Id) return Node_Id;\n-         --  Create a subprogram specification based on the subprogram profile\n-         --  of Subp_Id.\n-\n-         function Find_Primitive (Typ : Entity_Id) return Entity_Id;\n-         --  Find a primitive subprogram of type Typ which matches the profile\n-         --  of the renaming declaration.\n-\n-         procedure Interpretation_Error (Subp_Id : Entity_Id);\n-         --  Emit a continuation error message suggesting subprogram Subp_Id as\n-         --  a possible interpretation.\n-\n-         function Is_Intrinsic_Equality (Subp_Id : Entity_Id) return Boolean;\n-         --  Determine whether subprogram Subp_Id denotes the intrinsic \"=\"\n-         --  operator.\n-\n-         function Is_Suitable_Candidate (Subp_Id : Entity_Id) return Boolean;\n-         --  Determine whether subprogram Subp_Id is a suitable candidate for\n-         --  the role of a wrapped subprogram.\n-\n-         ----------------\n-         -- Build_Call --\n-         ----------------\n-\n-         function Build_Call\n-           (Subp_Id : Entity_Id;\n-            Params  : List_Id) return Node_Id\n-         is\n-            Actuals  : constant List_Id := New_List;\n-            Call_Ref : constant Node_Id := New_Occurrence_Of (Subp_Id, Loc);\n-            Formal   : Node_Id;\n-\n-         begin\n-            --  Build the actual parameters of the call\n-\n-            Formal := First (Params);\n-            while Present (Formal) loop\n-               Append_To (Actuals,\n-                 Make_Identifier (Loc, Chars (Defining_Identifier (Formal))));\n-               Next (Formal);\n-            end loop;\n-\n-            --  Generate:\n-            --    return Subp_Id (Actuals);\n-\n-            if Ekind (Subp_Id) in E_Function | E_Operator then\n-               return\n-                 Make_Simple_Return_Statement (Loc,\n-                   Expression =>\n-                     Make_Function_Call (Loc,\n-                       Name                   => Call_Ref,\n-                       Parameter_Associations => Actuals));\n-\n-            --  Generate:\n-            --    Subp_Id (Actuals);\n-\n-            else\n-               return\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name                   => Call_Ref,\n-                   Parameter_Associations => Actuals);\n-            end if;\n-         end Build_Call;\n-\n-         -------------------------\n-         -- Build_Expr_Fun_Call --\n-         -------------------------\n-\n-         function Build_Expr_Fun_Call\n-           (Subp_Id : Entity_Id;\n-            Params  : List_Id) return Node_Id\n-         is\n-            Actuals  : constant List_Id := New_List;\n-            Call_Ref : constant Node_Id := New_Occurrence_Of (Subp_Id, Loc);\n-            Formal   : Node_Id;\n-\n-         begin\n-            pragma Assert (Ekind (Subp_Id) in E_Function | E_Operator);\n-\n-            --  Build the actual parameters of the call\n-\n-            Formal := First (Params);\n-            while Present (Formal) loop\n-               Append_To (Actuals,\n-                 Make_Identifier (Loc, Chars (Defining_Identifier (Formal))));\n-               Next (Formal);\n-            end loop;\n-\n-            --  Generate:\n-            --    Subp_Id (Actuals);\n-\n-            return\n-              Make_Function_Call (Loc,\n-                Name                   => Call_Ref,\n-                Parameter_Associations => Actuals);\n-         end Build_Expr_Fun_Call;\n-\n-         ----------------\n-         -- Build_Spec --\n-         ----------------\n-\n-         function Build_Spec (Subp_Id : Entity_Id) return Node_Id is\n-            Params  : constant List_Id   := Copy_Parameter_List (Subp_Id);\n-            Spec_Id : constant Entity_Id :=\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => New_External_Name (Chars (Subp_Id), 'R'));\n-\n-         begin\n-            if Ekind (Formal_Spec) = E_Procedure then\n-               return\n-                 Make_Procedure_Specification (Loc,\n-                   Defining_Unit_Name       => Spec_Id,\n-                   Parameter_Specifications => Params);\n-            else\n-               return\n-                 Make_Function_Specification (Loc,\n-                   Defining_Unit_Name       => Spec_Id,\n-                   Parameter_Specifications => Params,\n-                   Result_Definition =>\n-                     New_Copy_Tree (Result_Definition (Spec)));\n-            end if;\n-         end Build_Spec;\n-\n-         --------------------\n-         -- Find_Primitive --\n-         --------------------\n-\n-         function Find_Primitive (Typ : Entity_Id) return Entity_Id is\n-            procedure Replace_Parameter_Types (Spec : Node_Id);\n-            --  Given a specification Spec, replace all class-wide parameter\n-            --  types with reference to type Typ.\n-\n-            -----------------------------\n-            -- Replace_Parameter_Types --\n-            -----------------------------\n-\n-            procedure Replace_Parameter_Types (Spec : Node_Id) is\n-               Formal     : Node_Id;\n-               Formal_Id  : Entity_Id;\n-               Formal_Typ : Node_Id;\n-\n-            begin\n-               Formal := First (Parameter_Specifications (Spec));\n-               while Present (Formal) loop\n-                  Formal_Id  := Defining_Identifier (Formal);\n-                  Formal_Typ := Parameter_Type (Formal);\n-\n-                  --  Create a new entity for each class-wide formal to prevent\n-                  --  aliasing with the original renaming. Replace the type of\n-                  --  such a parameter with the candidate type.\n-\n-                  if Nkind (Formal_Typ) = N_Identifier\n-                    and then Is_Class_Wide_Type (Etype (Formal_Typ))\n-                  then\n-                     Set_Defining_Identifier (Formal,\n-                       Make_Defining_Identifier (Loc, Chars (Formal_Id)));\n-\n-                     Set_Parameter_Type (Formal, New_Occurrence_Of (Typ, Loc));\n-                  end if;\n-\n-                  Next (Formal);\n-               end loop;\n-            end Replace_Parameter_Types;\n-\n-            --  Local variables\n-\n-            Alt_Ren  : constant Node_Id := New_Copy_Tree (N);\n-            Alt_Nam  : constant Node_Id := Name (Alt_Ren);\n-            Alt_Spec : constant Node_Id := Specification (Alt_Ren);\n-            Subp_Id  : Entity_Id;\n-\n-         --  Start of processing for Find_Primitive\n-\n-         begin\n-            --  Each attempt to find a suitable primitive of a particular type\n-            --  operates on its own copy of the original renaming. As a result\n-            --  the original renaming is kept decoration and side-effect free.\n-\n-            --  Inherit the overloaded status of the renamed subprogram name\n-\n-            if Is_Overloaded (Nam) then\n-               Set_Is_Overloaded (Alt_Nam);\n-               Save_Interps (Nam, Alt_Nam);\n-            end if;\n-\n-            --  The copied renaming is hidden from visibility to prevent the\n-            --  pollution of the enclosing context.\n-\n-            Set_Defining_Unit_Name (Alt_Spec, Make_Temporary (Loc, 'R'));\n-\n-            --  The types of all class-wide parameters must be changed to the\n-            --  candidate type.\n-\n-            Replace_Parameter_Types (Alt_Spec);\n-\n-            --  Try to find a suitable primitive which matches the altered\n-            --  profile of the renaming specification.\n-\n-            Subp_Id :=\n-              Find_Renamed_Entity\n-                (N         => Alt_Ren,\n-                 Nam       => Name (Alt_Ren),\n-                 New_S     => Analyze_Subprogram_Specification (Alt_Spec),\n-                 Is_Actual => Is_Actual);\n-\n-            --  Do not return Any_Id if the resolion of the altered profile\n-            --  failed as this complicates further checks on the caller side,\n-            --  return Empty instead.\n-\n-            if Subp_Id = Any_Id then\n-               return Empty;\n-            else\n-               return Subp_Id;\n-            end if;\n-         end Find_Primitive;\n-\n-         --------------------------\n-         -- Interpretation_Error --\n-         --------------------------\n-\n-         procedure Interpretation_Error (Subp_Id : Entity_Id) is\n-         begin\n-            Error_Msg_Sloc := Sloc (Subp_Id);\n-\n-            if Is_Internal (Subp_Id) then\n-               Error_Msg_NE\n-                 (\"\\\\possible interpretation: predefined & #\",\n-                  Spec, Formal_Spec);\n-            else\n-               Error_Msg_NE\n-                 (\"\\\\possible interpretation: & defined #\", Spec, Formal_Spec);\n-            end if;\n-         end Interpretation_Error;\n-\n-         ---------------------------\n-         -- Is_Intrinsic_Equality --\n-         ---------------------------\n-\n-         function Is_Intrinsic_Equality (Subp_Id : Entity_Id) return Boolean is\n-         begin\n-            return\n-              Ekind (Subp_Id) = E_Operator\n-                and then Chars (Subp_Id) = Name_Op_Eq\n-                and then Is_Intrinsic_Subprogram (Subp_Id);\n-         end Is_Intrinsic_Equality;\n-\n-         ---------------------------\n-         -- Is_Suitable_Candidate --\n-         ---------------------------\n-\n-         function Is_Suitable_Candidate (Subp_Id : Entity_Id) return Boolean is\n-         begin\n-            if No (Subp_Id) then\n-               return False;\n-\n-            --  An intrinsic subprogram is never a good candidate. This is an\n-            --  indication of a missing primitive, either defined directly or\n-            --  inherited from a parent tagged type.\n-\n-            elsif Is_Intrinsic_Subprogram (Subp_Id) then\n-               return False;\n-\n-            else\n-               return True;\n-            end if;\n-         end Is_Suitable_Candidate;\n-\n-         --  Local variables\n-\n-         Actual_Typ : Entity_Id := Empty;\n-         --  The actual class-wide type for Formal_Typ\n-\n-         CW_Prim_OK : Boolean;\n-         CW_Prim_Op : Entity_Id;\n-         --  The class-wide subprogram (if available) which corresponds to the\n-         --  renamed generic formal subprogram.\n-\n-         Formal_Typ : Entity_Id := Empty;\n-         --  The generic formal type with unknown discriminants\n-\n-         Root_Prim_OK : Boolean;\n-         Root_Prim_Op : Entity_Id;\n-         --  The root type primitive (if available) which corresponds to the\n-         --  renamed generic formal subprogram.\n-\n-         Root_Typ : Entity_Id := Empty;\n-         --  The root type of Actual_Typ\n-\n-         Body_Decl : Node_Id;\n-         Formal    : Node_Id;\n-         Prim_Op   : Entity_Id;\n-         Spec_Decl : Node_Id;\n-         New_Spec  : Node_Id;\n-\n-      --  Start of processing for Build_Class_Wide_Wrapper\n-\n-      begin\n-         --  Analyze the specification of the renaming in case the generation\n-         --  of the class-wide wrapper fails.\n-\n-         Ren_Id  := Analyze_Subprogram_Specification (Spec);\n-         Wrap_Id := Any_Id;\n-\n-         --  Do not attempt to build a wrapper if the renaming is in error\n-\n-         if Error_Posted (Nam) then\n-            return;\n-         end if;\n-\n-         --  Analyze the renamed name, but do not resolve it. The resolution is\n-         --  completed once a suitable subprogram is found.\n-\n-         Analyze (Nam);\n-\n-         --  When the renamed name denotes the intrinsic operator equals, the\n-         --  name must be treated as overloaded. This allows for a potential\n-         --  match against the root type's predefined equality function.\n-\n-         if Is_Intrinsic_Equality (Entity (Nam)) then\n-            Set_Is_Overloaded (Nam);\n-            Collect_Interps   (Nam);\n-         end if;\n-\n-         --  Step 1: Find the generic formal type with unknown discriminants\n-         --  and its corresponding class-wide actual type from the renamed\n-         --  generic formal subprogram.\n-\n-         Formal := First_Formal (Formal_Spec);\n-         while Present (Formal) loop\n-            if Has_Unknown_Discriminants (Etype (Formal))\n-              and then not Is_Class_Wide_Type (Etype (Formal))\n-              and then Is_Class_Wide_Type (Get_Instance_Of (Etype (Formal)))\n-            then\n-               Formal_Typ := Etype (Formal);\n-               Actual_Typ := Base_Type (Get_Instance_Of (Formal_Typ));\n-               Root_Typ   := Root_Type (Actual_Typ);\n-               exit;\n-            end if;\n-\n-            Next_Formal (Formal);\n-         end loop;\n-\n-         --  The specification of the generic formal subprogram should always\n-         --  contain a formal type with unknown discriminants whose actual is\n-         --  a class-wide type, otherwise this indicates a failure in routine\n-         --  Has_Class_Wide_Actual.\n-\n-         pragma Assert (Present (Formal_Typ));\n-\n-         --  Step 2: Find the proper class-wide subprogram or primitive which\n-         --  corresponds to the renamed generic formal subprogram.\n-\n-         CW_Prim_Op   := Find_Primitive (Actual_Typ);\n-         CW_Prim_OK   := Is_Suitable_Candidate (CW_Prim_Op);\n-         Root_Prim_Op := Find_Primitive (Root_Typ);\n-         Root_Prim_OK := Is_Suitable_Candidate (Root_Prim_Op);\n-\n-         --  The class-wide actual type has two subprograms which correspond to\n-         --  the renamed generic formal subprogram:\n-\n-         --    with procedure Prim_Op (Param : Formal_Typ);\n-\n-         --    procedure Prim_Op (Param : Actual_Typ);  --  may be inherited\n-         --    procedure Prim_Op (Param : Actual_Typ'Class);\n-\n-         --  Even though the declaration of the two subprograms is legal, a\n-         --  call to either one is ambiguous and therefore illegal.\n-\n-         if CW_Prim_OK and Root_Prim_OK then\n-\n-            --  A user-defined primitive has precedence over a predefined one\n-\n-            if Is_Internal (CW_Prim_Op)\n-              and then not Is_Internal (Root_Prim_Op)\n-            then\n-               Prim_Op := Root_Prim_Op;\n-\n-            elsif Is_Internal (Root_Prim_Op)\n-              and then not Is_Internal (CW_Prim_Op)\n-            then\n-               Prim_Op := CW_Prim_Op;\n-\n-            elsif CW_Prim_Op = Root_Prim_Op then\n-               Prim_Op := Root_Prim_Op;\n-\n-            --  The two subprograms are legal but the class-wide subprogram is\n-            --  a class-wide wrapper built for a previous instantiation; the\n-            --  wrapper has precedence.\n-\n-            elsif Present (Alias (CW_Prim_Op))\n-              and then Is_Class_Wide_Wrapper (Ultimate_Alias (CW_Prim_Op))\n-            then\n-               Prim_Op := CW_Prim_Op;\n-\n-            --  Otherwise both candidate subprograms are user-defined and\n-            --  ambiguous.\n-\n-            else\n-               Error_Msg_NE\n-                 (\"ambiguous actual for generic subprogram &\",\n-                  Spec, Formal_Spec);\n-               Interpretation_Error (Root_Prim_Op);\n-               Interpretation_Error (CW_Prim_Op);\n-               return;\n-            end if;\n-\n-         elsif CW_Prim_OK and not Root_Prim_OK then\n-            Prim_Op := CW_Prim_Op;\n-\n-         elsif not CW_Prim_OK and Root_Prim_OK then\n-            Prim_Op := Root_Prim_Op;\n-\n-         --  An intrinsic equality may act as a suitable candidate in the case\n-         --  of a null type extension where the parent's equality is hidden. A\n-         --  call to an intrinsic equality is expanded as dispatching.\n-\n-         elsif Present (Root_Prim_Op)\n-           and then Is_Intrinsic_Equality (Root_Prim_Op)\n-         then\n-            Prim_Op := Root_Prim_Op;\n-\n-         --  Otherwise there are no candidate subprograms. Let the caller\n-         --  diagnose the error.\n-\n-         else\n-            return;\n-         end if;\n-\n-         --  At this point resolution has taken place and the name is no longer\n-         --  overloaded. Mark the primitive as referenced.\n-\n-         Set_Is_Overloaded (Name (N), False);\n-         Set_Referenced    (Prim_Op);\n-\n-         --  Do not generate a wrapper when the only candidate is a class-wide\n-         --  subprogram. Instead modify the renaming to directly map the actual\n-         --  to the generic formal.\n-\n-         if CW_Prim_OK and then Prim_Op = CW_Prim_Op then\n-            Wrap_Id := Prim_Op;\n-            Rewrite (Nam, New_Occurrence_Of (Prim_Op, Loc));\n-            return;\n-         end if;\n-\n-         --  Step 3: Create the declaration and the body of the wrapper, insert\n-         --  all the pieces into the tree.\n-\n-         --  In GNATprove mode, create a function wrapper in the form of an\n-         --  expression function, so that an implicit postcondition relating\n-         --  the result of calling the wrapper function and the result of the\n-         --  dispatching call to the wrapped function is known during proof.\n-\n-         if GNATprove_Mode\n-           and then Ekind (Ren_Id) in E_Function | E_Operator\n-         then\n-            New_Spec := Build_Spec (Ren_Id);\n-            Body_Decl :=\n-              Make_Expression_Function (Loc,\n-                Specification => New_Spec,\n-                Expression    =>\n-                  Build_Expr_Fun_Call\n-                    (Subp_Id => Prim_Op,\n-                     Params  => Parameter_Specifications (New_Spec)));\n-\n-            Wrap_Id := Defining_Entity (Body_Decl);\n-\n-         --  Otherwise, create separate spec and body for the subprogram\n-\n-         else\n-            Spec_Decl :=\n-              Make_Subprogram_Declaration (Loc,\n-                Specification => Build_Spec (Ren_Id));\n-            Insert_Before_And_Analyze (N, Spec_Decl);\n-\n-            Wrap_Id := Defining_Entity (Spec_Decl);\n-\n-            Body_Decl :=\n-              Make_Subprogram_Body (Loc,\n-                Specification              => Build_Spec (Ren_Id),\n-                Declarations               => New_List,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => New_List (\n-                      Build_Call\n-                        (Subp_Id => Prim_Op,\n-                         Params  =>\n-                           Parameter_Specifications\n-                             (Specification (Spec_Decl))))));\n-\n-            Set_Corresponding_Body (Spec_Decl, Defining_Entity (Body_Decl));\n-         end if;\n-\n-         Set_Is_Class_Wide_Wrapper (Wrap_Id);\n-\n-         --  If the operator carries an Eliminated pragma, indicate that the\n-         --  wrapper is also to be eliminated, to prevent spurious error when\n-         --  using gnatelim on programs that include box-initialization of\n-         --  equality operators.\n-\n-         Set_Is_Eliminated (Wrap_Id, Is_Eliminated (Prim_Op));\n-\n-         --  In GNATprove mode, insert the body in the tree for analysis\n-\n-         if GNATprove_Mode then\n-            Insert_Before_And_Analyze (N, Body_Decl);\n-         end if;\n-\n-         --  The generated body does not freeze and must be analyzed when the\n-         --  class-wide wrapper is frozen. The body is only needed if expansion\n-         --  is enabled.\n-\n-         if Expander_Active then\n-            Append_Freeze_Action (Wrap_Id, Body_Decl);\n-         end if;\n-\n-         --  Step 4: The subprogram renaming aliases the wrapper\n-\n-         Rewrite (Nam, New_Occurrence_Of (Wrap_Id, Loc));\n-      end Build_Class_Wide_Wrapper;\n-\n       --------------------------\n       -- Check_Null_Exclusion --\n       --------------------------\n@@ -2919,6 +2351,703 @@ package body Sem_Ch8 is\n          return False;\n       end Has_Class_Wide_Actual;\n \n+      ------------------------------------------\n+      -- Handle_Instance_With_Class_Wide_Type --\n+      ------------------------------------------\n+\n+      procedure Handle_Instance_With_Class_Wide_Type\n+        (Inst_Node    : Node_Id;\n+         Ren_Id       : Entity_Id;\n+         Wrapped_Prim : out Entity_Id;\n+         Wrap_Id      : out Entity_Id)\n+      is\n+         procedure Build_Class_Wide_Wrapper\n+           (Ren_Id  : Entity_Id;\n+            Prim_Op : Entity_Id;\n+            Wrap_Id : out Entity_Id);\n+         --  Build a wrapper for the renaming Ren_Id of subprogram Prim_Op.\n+\n+         procedure Find_Suitable_Candidate\n+           (Prim_Op    : out Entity_Id;\n+            Is_CW_Prim : out Boolean);\n+         --  Look for a suitable primitive to be wrapped (Prim_Op); Is_CW_Prim\n+         --  indicates that the found candidate is a class-wide primitive (to\n+         --  help the caller decide if the wrapper is required).\n+\n+         ------------------------------\n+         -- Build_Class_Wide_Wrapper --\n+         ------------------------------\n+\n+         procedure Build_Class_Wide_Wrapper\n+           (Ren_Id  : Entity_Id;\n+            Prim_Op : Entity_Id;\n+            Wrap_Id : out Entity_Id)\n+         is\n+            Loc : constant Source_Ptr := Sloc (N);\n+\n+            function Build_Call\n+              (Subp_Id : Entity_Id;\n+               Params  : List_Id) return Node_Id;\n+            --  Create a dispatching call to invoke routine Subp_Id with\n+            --  actuals built from the parameter specifications of list Params.\n+\n+            function Build_Expr_Fun_Call\n+              (Subp_Id : Entity_Id;\n+               Params  : List_Id) return Node_Id;\n+            --  Create a dispatching call to invoke function Subp_Id with\n+            --  actuals built from the parameter specifications of list Params.\n+            --  Directly return the call, so that it can be used inside an\n+            --  expression function. This is a requirement of GNATprove mode.\n+\n+            function Build_Spec (Subp_Id : Entity_Id) return Node_Id;\n+            --  Create a subprogram specification based on the subprogram\n+            --  profile of Subp_Id.\n+\n+            ----------------\n+            -- Build_Call --\n+            ----------------\n+\n+            function Build_Call\n+              (Subp_Id : Entity_Id;\n+               Params  : List_Id) return Node_Id\n+            is\n+               Actuals  : constant List_Id := New_List;\n+               Call_Ref : constant Node_Id := New_Occurrence_Of (Subp_Id, Loc);\n+               Formal   : Node_Id;\n+\n+            begin\n+               --  Build the actual parameters of the call\n+\n+               Formal := First (Params);\n+               while Present (Formal) loop\n+                  Append_To (Actuals,\n+                    Make_Identifier (Loc,\n+                      Chars (Defining_Identifier (Formal))));\n+                  Next (Formal);\n+               end loop;\n+\n+               --  Generate:\n+               --    return Subp_Id (Actuals);\n+\n+               if Ekind (Subp_Id) in E_Function | E_Operator then\n+                  return\n+                    Make_Simple_Return_Statement (Loc,\n+                      Expression =>\n+                        Make_Function_Call (Loc,\n+                          Name                   => Call_Ref,\n+                          Parameter_Associations => Actuals));\n+\n+               --  Generate:\n+               --    Subp_Id (Actuals);\n+\n+               else\n+                  return\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name                   => Call_Ref,\n+                      Parameter_Associations => Actuals);\n+               end if;\n+            end Build_Call;\n+\n+            -------------------------\n+            -- Build_Expr_Fun_Call --\n+            -------------------------\n+\n+            function Build_Expr_Fun_Call\n+              (Subp_Id : Entity_Id;\n+               Params  : List_Id) return Node_Id\n+            is\n+               Actuals  : constant List_Id := New_List;\n+               Call_Ref : constant Node_Id := New_Occurrence_Of (Subp_Id, Loc);\n+               Formal   : Node_Id;\n+\n+            begin\n+               pragma Assert (Ekind (Subp_Id) in E_Function | E_Operator);\n+\n+               --  Build the actual parameters of the call\n+\n+               Formal := First (Params);\n+               while Present (Formal) loop\n+                  Append_To (Actuals,\n+                    Make_Identifier (Loc,\n+                      Chars (Defining_Identifier (Formal))));\n+                  Next (Formal);\n+               end loop;\n+\n+               --  Generate:\n+               --    Subp_Id (Actuals);\n+\n+               return\n+                 Make_Function_Call (Loc,\n+                   Name                   => Call_Ref,\n+                   Parameter_Associations => Actuals);\n+            end Build_Expr_Fun_Call;\n+\n+            ----------------\n+            -- Build_Spec --\n+            ----------------\n+\n+            function Build_Spec (Subp_Id : Entity_Id) return Node_Id is\n+               Params  : constant List_Id   := Copy_Parameter_List (Subp_Id);\n+               Spec_Id : constant Entity_Id :=\n+                           Make_Defining_Identifier (Loc,\n+                             New_External_Name (Chars (Subp_Id), 'R'));\n+\n+            begin\n+               if Ekind (Formal_Spec) = E_Procedure then\n+                  return\n+                    Make_Procedure_Specification (Loc,\n+                      Defining_Unit_Name       => Spec_Id,\n+                      Parameter_Specifications => Params);\n+               else\n+                  return\n+                    Make_Function_Specification (Loc,\n+                      Defining_Unit_Name       => Spec_Id,\n+                      Parameter_Specifications => Params,\n+                      Result_Definition =>\n+                        New_Copy_Tree (Result_Definition (Spec)));\n+               end if;\n+            end Build_Spec;\n+\n+            --  Local variables\n+\n+            Body_Decl : Node_Id;\n+            Spec_Decl : Node_Id;\n+            New_Spec  : Node_Id;\n+\n+         --  Start of processing for Build_Class_Wide_Wrapper\n+\n+         begin\n+            pragma Assert (not Error_Posted (Nam));\n+\n+            --  Step 1: Create the declaration and the body of the wrapper,\n+            --  insert all the pieces into the tree.\n+\n+            --  In GNATprove mode, create a function wrapper in the form of an\n+            --  expression function, so that an implicit postcondition relating\n+            --  the result of calling the wrapper function and the result of\n+            --  the dispatching call to the wrapped function is known during\n+            --  proof.\n+\n+            if GNATprove_Mode\n+              and then Ekind (Ren_Id) in E_Function | E_Operator\n+            then\n+               New_Spec := Build_Spec (Ren_Id);\n+               Body_Decl :=\n+                 Make_Expression_Function (Loc,\n+                   Specification => New_Spec,\n+                   Expression    =>\n+                     Build_Expr_Fun_Call\n+                       (Subp_Id => Prim_Op,\n+                        Params  => Parameter_Specifications (New_Spec)));\n+\n+               Wrap_Id := Defining_Entity (Body_Decl);\n+\n+            --  Otherwise, create separate spec and body for the subprogram\n+\n+            else\n+               Spec_Decl :=\n+                 Make_Subprogram_Declaration (Loc,\n+                   Specification => Build_Spec (Ren_Id));\n+               Insert_Before_And_Analyze (N, Spec_Decl);\n+\n+               Wrap_Id := Defining_Entity (Spec_Decl);\n+\n+               Body_Decl :=\n+                 Make_Subprogram_Body (Loc,\n+                   Specification              => Build_Spec (Ren_Id),\n+                   Declarations               => New_List,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (\n+                         Build_Call\n+                           (Subp_Id => Prim_Op,\n+                            Params  =>\n+                              Parameter_Specifications\n+                                (Specification (Spec_Decl))))));\n+\n+               Set_Corresponding_Body (Spec_Decl, Defining_Entity (Body_Decl));\n+            end if;\n+\n+            Set_Is_Class_Wide_Wrapper (Wrap_Id);\n+\n+            --  If the operator carries an Eliminated pragma, indicate that\n+            --  the wrapper is also to be eliminated, to prevent spurious\n+            --  errors when using gnatelim on programs that include box-\n+            --  defaulted initialization of equality operators.\n+\n+            Set_Is_Eliminated (Wrap_Id, Is_Eliminated (Prim_Op));\n+\n+            --  In GNATprove mode, insert the body in the tree for analysis\n+\n+            if GNATprove_Mode then\n+               Insert_Before_And_Analyze (N, Body_Decl);\n+            end if;\n+\n+            --  The generated body does not freeze and must be analyzed when\n+            --  the class-wide wrapper is frozen. The body is only needed if\n+            --  expansion is enabled.\n+\n+            if Expander_Active then\n+               Append_Freeze_Action (Wrap_Id, Body_Decl);\n+            end if;\n+\n+            --  Step 2: The subprogram renaming aliases the wrapper\n+\n+            Rewrite (Name (N), New_Occurrence_Of (Wrap_Id, Loc));\n+         end Build_Class_Wide_Wrapper;\n+\n+         -----------------------------\n+         -- Find_Suitable_Candidate --\n+         -----------------------------\n+\n+         procedure Find_Suitable_Candidate\n+           (Prim_Op    : out Entity_Id;\n+            Is_CW_Prim : out Boolean)\n+         is\n+            Loc : constant Source_Ptr := Sloc (N);\n+\n+            function Find_Primitive (Typ : Entity_Id) return Entity_Id;\n+            --  Find a primitive subprogram of type Typ which matches the\n+            --  profile of the renaming declaration.\n+\n+            procedure Interpretation_Error (Subp_Id : Entity_Id);\n+            --  Emit a continuation error message suggesting subprogram Subp_Id\n+            --  as a possible interpretation.\n+\n+            function Is_Intrinsic_Equality\n+              (Subp_Id : Entity_Id) return Boolean;\n+            --  Determine whether subprogram Subp_Id denotes the intrinsic \"=\"\n+            --  operator.\n+\n+            function Is_Suitable_Candidate\n+              (Subp_Id : Entity_Id) return Boolean;\n+            --  Determine whether subprogram Subp_Id is a suitable candidate\n+            --  for the role of a wrapped subprogram.\n+\n+            --------------------\n+            -- Find_Primitive --\n+            --------------------\n+\n+            function Find_Primitive (Typ : Entity_Id) return Entity_Id is\n+               procedure Replace_Parameter_Types (Spec : Node_Id);\n+               --  Given a specification Spec, replace all class-wide parameter\n+               --  types with reference to type Typ.\n+\n+               -----------------------------\n+               -- Replace_Parameter_Types --\n+               -----------------------------\n+\n+               procedure Replace_Parameter_Types (Spec : Node_Id) is\n+                  Formal     : Node_Id;\n+                  Formal_Id  : Entity_Id;\n+                  Formal_Typ : Node_Id;\n+\n+               begin\n+                  Formal := First (Parameter_Specifications (Spec));\n+                  while Present (Formal) loop\n+                     Formal_Id  := Defining_Identifier (Formal);\n+                     Formal_Typ := Parameter_Type (Formal);\n+\n+                     --  Create a new entity for each class-wide formal to\n+                     --  prevent aliasing with the original renaming. Replace\n+                     --  the type of such a parameter with the candidate type.\n+\n+                     if Nkind (Formal_Typ) = N_Identifier\n+                       and then Is_Class_Wide_Type (Etype (Formal_Typ))\n+                     then\n+                        Set_Defining_Identifier (Formal,\n+                          Make_Defining_Identifier (Loc, Chars (Formal_Id)));\n+\n+                        Set_Parameter_Type (Formal,\n+                          New_Occurrence_Of (Typ, Loc));\n+                     end if;\n+\n+                     Next (Formal);\n+                  end loop;\n+               end Replace_Parameter_Types;\n+\n+               --  Local variables\n+\n+               Alt_Ren  : constant Node_Id := New_Copy_Tree (N);\n+               Alt_Nam  : constant Node_Id := Name (Alt_Ren);\n+               Alt_Spec : constant Node_Id := Specification (Alt_Ren);\n+               Subp_Id  : Entity_Id;\n+\n+            --  Start of processing for Find_Primitive\n+\n+            begin\n+               --  Each attempt to find a suitable primitive of a particular\n+               --  type operates on its own copy of the original renaming.\n+               --  As a result the original renaming is kept decoration and\n+               --  side-effect free.\n+\n+               --  Inherit the overloaded status of the renamed subprogram name\n+\n+               if Is_Overloaded (Nam) then\n+                  Set_Is_Overloaded (Alt_Nam);\n+                  Save_Interps (Nam, Alt_Nam);\n+               end if;\n+\n+               --  The copied renaming is hidden from visibility to prevent the\n+               --  pollution of the enclosing context.\n+\n+               Set_Defining_Unit_Name (Alt_Spec, Make_Temporary (Loc, 'R'));\n+\n+               --  The types of all class-wide parameters must be changed to\n+               --  the candidate type.\n+\n+               Replace_Parameter_Types (Alt_Spec);\n+\n+               --  Try to find a suitable primitive that matches the altered\n+               --  profile of the renaming specification.\n+\n+               Subp_Id :=\n+                 Find_Renamed_Entity\n+                   (N         => Alt_Ren,\n+                    Nam       => Name (Alt_Ren),\n+                    New_S     => Analyze_Subprogram_Specification (Alt_Spec),\n+                    Is_Actual => Is_Actual);\n+\n+               --  Do not return Any_Id if the resolution of the altered\n+               --  profile failed as this complicates further checks on\n+               --  the caller side; return Empty instead.\n+\n+               if Subp_Id = Any_Id then\n+                  return Empty;\n+               else\n+                  return Subp_Id;\n+               end if;\n+            end Find_Primitive;\n+\n+            --------------------------\n+            -- Interpretation_Error --\n+            --------------------------\n+\n+            procedure Interpretation_Error (Subp_Id : Entity_Id) is\n+            begin\n+               Error_Msg_Sloc := Sloc (Subp_Id);\n+\n+               if Is_Internal (Subp_Id) then\n+                  Error_Msg_NE\n+                    (\"\\\\possible interpretation: predefined & #\",\n+                     Spec, Formal_Spec);\n+               else\n+                  Error_Msg_NE\n+                    (\"\\\\possible interpretation: & defined #\",\n+                     Spec, Formal_Spec);\n+               end if;\n+            end Interpretation_Error;\n+\n+            ---------------------------\n+            -- Is_Intrinsic_Equality --\n+            ---------------------------\n+\n+            function Is_Intrinsic_Equality (Subp_Id : Entity_Id) return Boolean\n+            is\n+            begin\n+               return\n+                 Ekind (Subp_Id) = E_Operator\n+                   and then Chars (Subp_Id) = Name_Op_Eq\n+                   and then Is_Intrinsic_Subprogram (Subp_Id);\n+            end Is_Intrinsic_Equality;\n+\n+            ---------------------------\n+            -- Is_Suitable_Candidate --\n+            ---------------------------\n+\n+            function Is_Suitable_Candidate (Subp_Id : Entity_Id) return Boolean\n+            is\n+            begin\n+               if No (Subp_Id) then\n+                  return False;\n+\n+               --  An intrinsic subprogram is never a good candidate. This\n+               --  is an indication of a missing primitive, either defined\n+               --  directly or inherited from a parent tagged type.\n+\n+               elsif Is_Intrinsic_Subprogram (Subp_Id) then\n+                  return False;\n+\n+               else\n+                  return True;\n+               end if;\n+            end Is_Suitable_Candidate;\n+\n+            --  Local variables\n+\n+            Actual_Typ : Entity_Id := Empty;\n+            --  The actual class-wide type for Formal_Typ\n+\n+            CW_Prim_OK : Boolean;\n+            CW_Prim_Op : Entity_Id;\n+            --  The class-wide subprogram (if available) that corresponds to\n+            --  the renamed generic formal subprogram.\n+\n+            Formal_Typ : Entity_Id := Empty;\n+            --  The generic formal type with unknown discriminants\n+\n+            Root_Prim_OK : Boolean;\n+            Root_Prim_Op : Entity_Id;\n+            --  The root type primitive (if available) that corresponds to the\n+            --  renamed generic formal subprogram.\n+\n+            Root_Typ : Entity_Id := Empty;\n+            --  The root type of Actual_Typ\n+\n+            Formal   : Node_Id;\n+\n+         --  Start of processing for Find_Suitable_Candidate\n+\n+         begin\n+            pragma Assert (not Error_Posted (Nam));\n+\n+            Prim_Op    := Empty;\n+            Is_CW_Prim := False;\n+\n+            --  Analyze the renamed name, but do not resolve it. The resolution\n+            --  is completed once a suitable subprogram is found.\n+\n+            Analyze (Nam);\n+\n+            --  When the renamed name denotes the intrinsic operator equals,\n+            --  the name must be treated as overloaded. This allows for a\n+            --  potential match against the root type's predefined equality\n+            --  function.\n+\n+            if Is_Intrinsic_Equality (Entity (Nam)) then\n+               Set_Is_Overloaded (Nam);\n+               Collect_Interps   (Nam);\n+            end if;\n+\n+            --  Step 1: Find the generic formal type and its corresponding\n+            --  class-wide actual type from the renamed generic formal\n+            --  subprogram.\n+\n+            Formal := First_Formal (Formal_Spec);\n+            while Present (Formal) loop\n+               if Has_Unknown_Discriminants (Etype (Formal))\n+                 and then not Is_Class_Wide_Type (Etype (Formal))\n+                 and then Is_Class_Wide_Type (Get_Instance_Of (Etype (Formal)))\n+               then\n+                  Formal_Typ := Etype (Formal);\n+                  Actual_Typ := Base_Type (Get_Instance_Of (Formal_Typ));\n+                  Root_Typ   := Root_Type (Actual_Typ);\n+                  exit;\n+               end if;\n+\n+               Next_Formal (Formal);\n+            end loop;\n+\n+            --  The specification of the generic formal subprogram should\n+            --  always contain a formal type with unknown discriminants whose\n+            --  actual is a class-wide type; otherwise this indicates a failure\n+            --  in function Has_Class_Wide_Actual.\n+\n+            pragma Assert (Present (Formal_Typ));\n+\n+            --  Step 2: Find the proper class-wide subprogram or primitive\n+            --  that corresponds to the renamed generic formal subprogram.\n+\n+            CW_Prim_Op   := Find_Primitive (Actual_Typ);\n+            CW_Prim_OK   := Is_Suitable_Candidate (CW_Prim_Op);\n+            Root_Prim_Op := Find_Primitive (Root_Typ);\n+            Root_Prim_OK := Is_Suitable_Candidate (Root_Prim_Op);\n+\n+            --  The class-wide actual type has two subprograms that correspond\n+            --  to the renamed generic formal subprogram:\n+\n+            --    with procedure Prim_Op (Param : Formal_Typ);\n+\n+            --    procedure Prim_Op (Param : Actual_Typ);  --  may be inherited\n+            --    procedure Prim_Op (Param : Actual_Typ'Class);\n+\n+            --  Even though the declaration of the two subprograms is legal, a\n+            --  call to either one is ambiguous and therefore illegal.\n+\n+            if CW_Prim_OK and Root_Prim_OK then\n+\n+               --  A user-defined primitive has precedence over a predefined\n+               --  one.\n+\n+               if Is_Internal (CW_Prim_Op)\n+                 and then not Is_Internal (Root_Prim_Op)\n+               then\n+                  Prim_Op := Root_Prim_Op;\n+\n+               elsif Is_Internal (Root_Prim_Op)\n+                 and then not Is_Internal (CW_Prim_Op)\n+               then\n+                  Prim_Op := CW_Prim_Op;\n+                  Is_CW_Prim := True;\n+\n+               elsif CW_Prim_Op = Root_Prim_Op then\n+                  Prim_Op := Root_Prim_Op;\n+\n+               --  The two subprograms are legal but the class-wide subprogram\n+               --  is a class-wide wrapper built for a previous instantiation;\n+               --  the wrapper has precedence.\n+\n+               elsif Present (Alias (CW_Prim_Op))\n+                 and then Is_Class_Wide_Wrapper (Ultimate_Alias (CW_Prim_Op))\n+               then\n+                  Prim_Op := CW_Prim_Op;\n+                  Is_CW_Prim := True;\n+\n+               --  Otherwise both candidate subprograms are user-defined and\n+               --  ambiguous.\n+\n+               else\n+                  Error_Msg_NE\n+                    (\"ambiguous actual for generic subprogram &\",\n+                     Spec, Formal_Spec);\n+                  Interpretation_Error (Root_Prim_Op);\n+                  Interpretation_Error (CW_Prim_Op);\n+                  return;\n+               end if;\n+\n+            elsif CW_Prim_OK and not Root_Prim_OK then\n+               Prim_Op := CW_Prim_Op;\n+               Is_CW_Prim := True;\n+\n+            elsif not CW_Prim_OK and Root_Prim_OK then\n+               Prim_Op := Root_Prim_Op;\n+\n+            --  An intrinsic equality may act as a suitable candidate in the\n+            --  case of a null type extension where the parent's equality\n+            --  is hidden. A call to an intrinsic equality is expanded as\n+            --  dispatching.\n+\n+            elsif Present (Root_Prim_Op)\n+              and then Is_Intrinsic_Equality (Root_Prim_Op)\n+            then\n+               Prim_Op := Root_Prim_Op;\n+\n+            --  Otherwise there are no candidate subprograms. Let the caller\n+            --  diagnose the error.\n+\n+            else\n+               return;\n+            end if;\n+\n+            --  At this point resolution has taken place and the name is no\n+            --  longer overloaded. Mark the primitive as referenced.\n+\n+            Set_Is_Overloaded (Name (N), False);\n+            Set_Referenced    (Prim_Op);\n+         end Find_Suitable_Candidate;\n+\n+         --  Local variables\n+\n+         Is_CW_Prim : Boolean;\n+\n+      --  Start of processing for Handle_Instance_With_Class_Wide_Type\n+\n+      begin\n+         Wrapped_Prim := Empty;\n+         Wrap_Id := Empty;\n+\n+         --  Ada 2012 (AI05-0071): A generic/instance scenario involving a\n+         --  formal type with unknown discriminants and a generic primitive\n+         --  operation of the said type with a box require special processing\n+         --  when the actual is a class-wide type:\n+         --\n+         --    generic\n+         --       type Formal_Typ (<>) is private;\n+         --       with procedure Prim_Op (Param : Formal_Typ) is <>;\n+         --    package Gen is ...\n+         --\n+         --    package Inst is new Gen (Actual_Typ'Class);\n+         --\n+         --  In this case the general renaming mechanism used in the prologue\n+         --  of an instance no longer applies:\n+         --\n+         --    procedure Prim_Op (Param : Formal_Typ) renames Prim_Op;\n+         --\n+         --  The above is replaced the following wrapper/renaming combination:\n+         --\n+         --    procedure Wrapper (Param : Formal_Typ) is  --  wrapper\n+         --    begin\n+         --       Prim_Op (Param);                        --  primitive\n+         --    end Wrapper;\n+         --\n+         --    procedure Prim_Op (Param : Formal_Typ) renames Wrapper;\n+         --\n+         --  This transformation applies only if there is no explicit visible\n+         --  class-wide operation at the point of the instantiation. Ren_Id is\n+         --  the entity of the renaming declaration. When the transformation\n+         --  applies, Wrapped_Prim is the entity of the wrapped primitive.\n+\n+         if Box_Present (Inst_Node) then\n+            Find_Suitable_Candidate\n+              (Prim_Op    => Wrapped_Prim,\n+               Is_CW_Prim => Is_CW_Prim);\n+\n+            if Present (Wrapped_Prim) then\n+               if not Is_CW_Prim then\n+                  Build_Class_Wide_Wrapper (Ren_Id, Wrapped_Prim, Wrap_Id);\n+\n+               --  Small optimization: When the candidate is a class-wide\n+               --  subprogram we don't build the wrapper; we modify the\n+               --  renaming declaration to directly map the actual to the\n+               --  generic formal and discard the candidate.\n+\n+               else\n+                  Rewrite (Nam, New_Occurrence_Of (Wrapped_Prim, Sloc (N)));\n+                  Wrapped_Prim := Empty;\n+               end if;\n+            end if;\n+\n+         --  Ada 2022 (AI12-0165, RM 12.6(8.5/3)): The actual subprogram for a\n+         --  formal_abstract_subprogram_declaration shall be:\n+         --   a) a dispatching operation of the controlling type; or\n+         --   b) if the controlling type is a formal type, and the actual\n+         --      type corresponding to that formal type is a specific type T,\n+         --      a dispatching operation of type T; or\n+         --   c) if the controlling type is a formal type, and the actual\n+         --      type is a class-wide type T'Class, an implicitly declared\n+         --      subprogram corresponding to a primitive operation of type T.\n+\n+         elsif Nkind (Inst_Node) = N_Formal_Abstract_Subprogram_Declaration\n+           and then Is_Entity_Name (Nam)\n+         then\n+            Find_Suitable_Candidate\n+              (Prim_Op    => Wrapped_Prim,\n+               Is_CW_Prim => Is_CW_Prim);\n+\n+            if Present (Wrapped_Prim) then\n+\n+               --  Cases (a) and (b); see previous description.\n+\n+               if not Is_CW_Prim then\n+                  Build_Class_Wide_Wrapper (Ren_Id, Wrapped_Prim, Wrap_Id);\n+\n+               --  Case (c); see previous description.\n+\n+               --  Implicit operations of T'Class for subtype declarations\n+               --  are built by Derive_Subprogram, and their Alias attribute\n+               --  references the primitive operation of T.\n+\n+               elsif not Comes_From_Source (Wrapped_Prim)\n+                 and then Nkind (Parent (Wrapped_Prim)) = N_Subtype_Declaration\n+                 and then Present (Alias (Wrapped_Prim))\n+               then\n+                  --  We don't need to build the wrapper; we modify the\n+                  --  renaming declaration to directly map the actual to\n+                  --  the generic formal and discard the candidate.\n+\n+                  Rewrite (Nam,\n+                    New_Occurrence_Of (Alias (Wrapped_Prim), Sloc (N)));\n+                  Wrapped_Prim := Empty;\n+\n+               --  Legality rules do not apply; discard the candidate.\n+\n+               else\n+                  Wrapped_Prim := Empty;\n+               end if;\n+            end if;\n+         end if;\n+      end Handle_Instance_With_Class_Wide_Type;\n+\n       -------------------------\n       -- Original_Subprogram --\n       -------------------------\n@@ -2965,12 +3094,13 @@ package body Sem_Ch8 is\n       --  Local variables\n \n       CW_Actual : constant Boolean := Has_Class_Wide_Actual;\n-      --  Ada 2012 (AI05-071, AI05-0131): True if the renaming is for a\n-      --  defaulted formal subprogram when the actual for a related formal\n-      --  type is class-wide.\n+      --  Ada 2012 (AI05-071, AI05-0131) and Ada 2022 (AI12-0165): True if the\n+      --  renaming is for a defaulted formal subprogram when the actual for a\n+      --  related formal type is class-wide.\n \n-      Inst_Node : Node_Id := Empty;\n-      New_S     : Entity_Id;\n+      Inst_Node    : Node_Id   := Empty;\n+      New_S        : Entity_Id;\n+      Wrapped_Prim : Entity_Id := Empty;\n \n    --  Start of processing for Analyze_Subprogram_Renaming\n \n@@ -3101,11 +3231,64 @@ package body Sem_Ch8 is\n       if Is_Actual then\n          Inst_Node := Unit_Declaration_Node (Formal_Spec);\n \n-         --  Check whether the renaming is for a defaulted actual subprogram\n-         --  with a class-wide actual.\n+         --  Ada 2012 (AI05-0071) and Ada 2022 (AI12-0165): when the actual\n+         --  type is a class-wide type T'Class we may need to wrap a primitive\n+         --  operation of T. Search for the wrapped primitive and (if required)\n+         --  build a wrapper whose body consists of a dispatching call to the\n+         --  wrapped primitive of T, with its formal parameters as the actual\n+         --  parameters.\n+\n+         if CW_Actual and then\n+\n+         --  Ada 2012 (AI05-0071): Check whether the renaming is for a\n+         --  defaulted actual subprogram with a class-wide actual.\n+\n+            (Box_Present (Inst_Node)\n+\n+                or else\n+\n+         --  Ada 2022 (AI12-0165): Check whether the renaming is for a formal\n+         --  abstract subprogram declaration with a class-wide actual.\n+\n+             (Nkind (Inst_Node) = N_Formal_Abstract_Subprogram_Declaration\n+               and then Is_Entity_Name (Nam)))\n+         then\n+            New_S := Analyze_Subprogram_Specification (Spec);\n+\n+            --  Do not attempt to build the wrapper if the renaming is in error\n+\n+            if not Error_Posted (Nam) then\n+               Handle_Instance_With_Class_Wide_Type\n+                 (Inst_Node    => Inst_Node,\n+                  Ren_Id       => New_S,\n+                  Wrapped_Prim => Wrapped_Prim,\n+                  Wrap_Id      => Old_S);\n+\n+               --  If several candidates were found, then we reported the\n+               --  ambiguity; stop processing the renaming declaration to\n+               --  avoid reporting further (spurious) errors.\n+\n+               if Error_Posted (Spec) then\n+                  return;\n+               end if;\n+\n+            end if;\n+         end if;\n+\n+         if Present (Wrapped_Prim) then\n+\n+            --  When the wrapper is built, the subprogram renaming aliases\n+            --  the wrapper.\n \n-         if CW_Actual and then Box_Present (Inst_Node) then\n-            Build_Class_Wide_Wrapper (New_S, Old_S);\n+            Analyze (Nam);\n+\n+            pragma Assert (Old_S = Entity (Nam)\n+              and then Is_Class_Wide_Wrapper (Old_S));\n+\n+            --  The subprogram renaming declaration may become Ghost if it\n+            --  renames a wrapper of a Ghost entity.\n+\n+            Mark_Ghost_Renaming (N, Wrapped_Prim);\n \n          elsif Is_Entity_Name (Nam)\n            and then Present (Entity (Nam))\n@@ -3685,7 +3868,15 @@ package body Sem_Ch8 is\n             --  indicate that the renaming is an abstract dispatching operation\n             --  with a controlling type.\n \n-            if Is_Actual and then Is_Abstract_Subprogram (Formal_Spec) then\n+            --  Skip this decoration when the renaming corresponds to an\n+            --  association with class-wide wrapper (see above) because such\n+            --  wrapper is neither abstract nor a dispatching operation (its\n+            --  body has the dispatching call to the wrapped primitive).\n+\n+            if Is_Actual\n+              and then Is_Abstract_Subprogram (Formal_Spec)\n+              and then No (Wrapped_Prim)\n+            then\n \n                --  Mark the renaming as abstract here, so Find_Dispatching_Type\n                --  see it as corresponding to a generic association for a"}]}