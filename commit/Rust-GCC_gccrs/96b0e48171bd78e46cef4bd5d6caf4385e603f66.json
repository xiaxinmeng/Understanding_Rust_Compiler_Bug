{"sha": "96b0e48171bd78e46cef4bd5d6caf4385e603f66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZiMGU0ODE3MWJkNzhlNDZjZWY0YmQ1ZDZjYWY0Mzg1ZTYwM2Y2Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-08T21:57:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-08T21:57:16Z"}, "message": "(cse_gen_binary, simplify_plus_minus): New functions.\n\n(find_best_addr): Use cse_gen_binary.\n(simplify_binary_operation, fold_rtx): Likewise.\nRemove most special-cases for PLUS and MINUS and call\nsimplify_plus_minus instead.\nClean up some tests for FP.\n\nFrom-SVN: r3680", "tree": {"sha": "3384f415bde1d831e03cccf58222f8e9ff17a589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3384f415bde1d831e03cccf58222f8e9ff17a589"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96b0e48171bd78e46cef4bd5d6caf4385e603f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96b0e48171bd78e46cef4bd5d6caf4385e603f66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96b0e48171bd78e46cef4bd5d6caf4385e603f66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96b0e48171bd78e46cef4bd5d6caf4385e603f66/comments", "author": null, "committer": null, "parents": [{"sha": "0f15260aeac66189c812a3185f35015808da571d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f15260aeac66189c812a3185f35015808da571d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f15260aeac66189c812a3185f35015808da571d"}], "stats": {"total": 464, "additions": 249, "deletions": 215}, "files": [{"sha": "e2bb7ae1456c6662bd6c87da468001f2c7d066ca", "filename": "gcc/cse.c", "status": "modified", "additions": 249, "deletions": 215, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b0e48171bd78e46cef4bd5d6caf4385e603f66/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b0e48171bd78e46cef4bd5d6caf4385e603f66/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=96b0e48171bd78e46cef4bd5d6caf4385e603f66", "patch": "@@ -612,6 +612,10 @@ static void find_best_addr\tPROTO((rtx, rtx *));\n static enum rtx_code find_comparison_args PROTO((enum rtx_code, rtx *, rtx *,\n \t\t\t\t\t\t enum machine_mode *,\n \t\t\t\t\t\t enum machine_mode *));\n+static rtx cse_gen_binary\tPROTO((enum rtx_code, enum machine_mode,\n+\t\t\t\t       rtx, rtx));\n+static rtx simplify_plus_minus\tPROTO((enum rtx_code, enum machine_mode,\n+\t\t\t\t       rtx, rtx));\n static rtx fold_rtx\t\tPROTO((rtx, rtx));\n static rtx equiv_constant\tPROTO((rtx));\n static void record_jump_equiv\tPROTO((rtx, int));\n@@ -2649,11 +2653,7 @@ find_best_addr (insn, loc)\n \t\t&& (GET_CODE (p->exp) == REG\n \t\t    || exp_equiv_p (p->exp, p->exp, 1, 0)))\n \t      {\n-\t\trtx new = simplify_binary_operation (GET_CODE (*loc), Pmode,\n-\t\t\t\t\t\t     p->exp, c);\n-\n-\t\tif (new == 0)\n-\t\t  new = gen_rtx (GET_CODE (*loc), Pmode, p->exp, c);\n+\t\trtx new = cse_gen_binary (GET_CODE (*loc), Pmode, p->exp, c);\n \n \t\tif ((ADDRESS_COST (new) < best_addr_cost\n \t\t    || (ADDRESS_COST (new) == best_addr_cost\n@@ -3248,6 +3248,7 @@ simplify_binary_operation (code, mode, op0, op1)\n   register HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n   HOST_WIDE_INT val;\n   int width = GET_MODE_BITSIZE (mode);\n+  rtx tem;\n \n   /* Relational operations don't work here.  We must know the mode\n      of the operands in order to do the comparison correctly.\n@@ -3448,85 +3449,33 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  if (op1 == CONST0_RTX (mode))\n \t    return op0;\n \n-\t  /* Strip off any surrounding CONSTs.  They don't matter in any of \n-\t     the cases below.  */\n-\t  if (GET_CODE (op0) == CONST)\n-\t    op0 = XEXP (op0, 0);\n-\t  if (GET_CODE (op1) == CONST)\n-\t    op1 = XEXP (op1, 0);\n-\n \t  /* ((-a) + b) -> (b - a) and similarly for (a + (-b)) */\n \t  if (GET_CODE (op0) == NEG)\n-\t    {\n-\t      rtx tem = simplify_binary_operation (MINUS, mode,\n-\t\t\t\t\t\t   op1, XEXP (op0, 0));\n-\t      return tem ? tem : gen_rtx (MINUS, mode, op1, XEXP (op0, 0));\n-\t    }\n+\t    return cse_gen_binary (MINUS, mode, op1, XEXP (op0, 0));\n \t  else if (GET_CODE (op1) == NEG)\n-\t    {\n-\t      rtx tem = simplify_binary_operation (MINUS, mode,\n-\t\t\t\t\t\t   op0, XEXP (op1, 0));\n-\t      return tem ? tem : gen_rtx (MINUS, mode, op0, XEXP (op1, 0));\n-\t    }\n-\n-\t  /* Don't use the associative law for floating point.\n-\t     The inaccuracy makes it nonassociative,\n-\t     and subtle programs can break if operations are associated.  */\n-\t  if (GET_MODE_CLASS (mode) != MODE_INT)\n-\t    break;\n-\n-\t  /* (a - b) + b -> a, similarly a + (b - a) -> a */\n-\t  if (GET_CODE (op0) == MINUS\n-\t      && rtx_equal_p (XEXP (op0, 1), op1) && ! side_effects_p (op1))\n-\t    return XEXP (op0, 0);\n+\t    return cse_gen_binary (MINUS, mode, op0, XEXP (op1, 0));\n \n-\t  if (GET_CODE (op1) == MINUS\n-\t      && rtx_equal_p (XEXP (op1, 1), op0) && ! side_effects_p (op0))\n-\t    return XEXP (op1, 0);\n+\t  /* Handle both-operands-constant cases.  We can only add\n+\t     CONST_INTs to constants since the sum of relocatable symbols\n+\t     can't be handled by most assemblers.  */\n \n-\t  /* (c1 - a) + c2 becomes (c1 + c2) - a.  */\n-\t  if (GET_CODE (op1) == CONST_INT && GET_CODE (op0) == MINUS\n-\t      && GET_CODE (XEXP (op0, 0)) == CONST_INT)\n-\t    {\n-\t      rtx tem = simplify_binary_operation (PLUS, mode, op1,\n-\t\t\t\t\t\t   XEXP (op0, 0));\n+\t  if (CONSTANT_P (op0) && GET_CODE (op1) == CONST_INT)\n+\t    return plus_constant (op0, INTVAL (op1));\n+\t  else if (CONSTANT_P (op1) && GET_CODE (op0) == CONST_INT)\n+\t    return plus_constant (op1, INTVAL (op0));\n \n-\t      return tem ? gen_rtx (MINUS, mode, tem, XEXP (op0, 1)) : 0;\n-\t    }\n+\t  /* If one of the operands is a PLUS or a MINUS, see if we can\n+\t     simplify this by the associative law. \n+\t     Don't use the associative law for floating point.\n+\t     The inaccuracy makes it nonassociative,\n+\t     and subtle programs can break if operations are associated.  */\n \n-\t  /* Handle both-operands-constant cases.  */\n-\t  if (CONSTANT_P (op0) && CONSTANT_P (op1)\n-\t      && GET_CODE (op0) != CONST_DOUBLE\n-\t      && GET_CODE (op1) != CONST_DOUBLE\n-\t      && GET_MODE_CLASS (mode) == MODE_INT)\n-\t    {\n-\t      if (GET_CODE (op1) == CONST_INT)\n-\t\treturn plus_constant (op0, INTVAL (op1));\n-\t      else if (GET_CODE (op0) == CONST_INT)\n-\t\treturn plus_constant (op1, INTVAL (op0));\n-\t      else\n-\t\tbreak;\n-#if 0 /* No good, because this can produce the sum of two relocatable\n-\t symbols, in an assembler instruction.  Most UNIX assemblers can't\n-\t handle that.  */\n-\t      else\n-\t\treturn gen_rtx (CONST, mode,\n-\t\t\t\tgen_rtx (PLUS, mode,\n-\t\t\t\t\t GET_CODE (op0) == CONST\n-\t\t\t\t\t ? XEXP (op0, 0) : op0,\n-\t\t\t\t\t GET_CODE (op1) == CONST\n-\t\t\t\t\t ? XEXP (op1, 0) : op1));\n-#endif\n-\t    }\n-\t  else if (GET_CODE (op1) == CONST_INT\n-\t\t   && GET_CODE (op0) == PLUS\n-\t\t   && (CONSTANT_P (XEXP (op0, 0))\n-\t\t       || CONSTANT_P (XEXP (op0, 1))))\n-\t    /* constant + (variable + constant)\n-\t       can result if an index register is made constant.\n-\t       We simplify this by adding the constants.\n-\t       If we did not, it would become an invalid address.  */\n-\t    return plus_constant (op0, INTVAL (op1));\n+\t  if ((GET_MODE_CLASS (mode) == MODE_INT\n+\t       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+\t      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n+\t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS)\n+\t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n+\t    return tem;\n \t  break;\n \n \tcase COMPARE:\n@@ -3550,159 +3499,45 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* None of these optimizations can be done for IEEE\n \t     floating point.  */\n \t  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t      && GET_MODE_CLASS (mode) != MODE_INT)\n+\t      && GET_MODE_CLASS (mode) != MODE_INT\n+\t      && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n \t    break;\n \n \t  /* We can't assume x-x is 0 even with non-IEEE floating point.  */\n \t  if (rtx_equal_p (op0, op1)\n \t      && ! side_effects_p (op0)\n-\t      && GET_MODE_CLASS (mode) != MODE_FLOAT)\n+\t      && GET_MODE_CLASS (mode) != MODE_FLOAT\n+\t      && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n \t    return const0_rtx;\n \n \t  /* Change subtraction from zero into negation.  */\n \t  if (op0 == CONST0_RTX (mode))\n \t    return gen_rtx (NEG, mode, op1);\n \n+\t  /* (-1 - a) is ~a.  */\n+\t  if (op0 == constm1_rtx)\n+\t    return gen_rtx (NOT, mode, op1);\n+\n \t  /* Subtracting 0 has no effect.  */\n \t  if (op1 == CONST0_RTX (mode))\n \t    return op0;\n \n-\t  /* Strip off any surrounding CONSTs.  They don't matter in any of \n-\t     the cases below.  */\n-\t  if (GET_CODE (op0) == CONST)\n-\t    op0 = XEXP (op0, 0);\n-\t  if (GET_CODE (op1) == CONST)\n-\t    op1 = XEXP (op1, 0);\n-\n \t  /* (a - (-b)) -> (a + b).  */\n \t  if (GET_CODE (op1) == NEG)\n-\t    {\n-\t      rtx tem = simplify_binary_operation (PLUS, mode,\n-\t\t\t\t\t\t   op0, XEXP (op1, 0));\n-\t      return tem ? tem : gen_rtx (PLUS, mode, op0, XEXP (op1, 0));\n-\t    }\n+\t    return cse_gen_binary (PLUS, mode, op0, XEXP (op1, 0));\n \n-\t  /* Don't use the associative law for floating point.\n+\t  /* If one of the operands is a PLUS or a MINUS, see if we can\n+\t     simplify this by the associative law. \n+\t     Don't use the associative law for floating point.\n \t     The inaccuracy makes it nonassociative,\n \t     and subtle programs can break if operations are associated.  */\n-\t  if (GET_MODE_CLASS (mode) != MODE_INT)\n-\t    break;\n \n-\t  /* (a + b) - a -> b, and (b - (a + b))  -> -a  */\n-\t  if (GET_CODE (op0) == PLUS\n-\t      && rtx_equal_p (XEXP (op0, 0), op1)\n-\t      && ! side_effects_p (op1))\n-\t    return XEXP (op0, 1);\n-\t  else if (GET_CODE (op0) == PLUS\n-\t\t   && rtx_equal_p (XEXP (op0, 1), op1)\n-\t\t   && ! side_effects_p (op1))\n-\t    return XEXP (op0, 0);\n-\n-\t  if (GET_CODE (op1) == PLUS\n-\t      && rtx_equal_p (XEXP (op1, 0), op0)\n-\t      && ! side_effects_p (op0))\n-\t    {\n-\t      rtx tem = simplify_unary_operation (NEG, mode, XEXP (op1, 1),\n-\t\t\t\t\t\t  mode);\n-\n-\t      return tem ? tem : gen_rtx (NEG, mode, XEXP (op1, 1));\n-\t    }\n-\t  else if (GET_CODE (op1) == PLUS\n-\t\t   && rtx_equal_p (XEXP (op1, 1), op0)\n-\t\t   && ! side_effects_p (op0))\n-\t    {\n-\t      rtx tem = simplify_unary_operation (NEG, mode, XEXP (op1, 0),\n-\t\t\t\t\t\t  mode);\n-\n-\t      return tem ? tem : gen_rtx (NEG, mode, XEXP (op1, 0));\n-\t    }\n-\n-\t  /* a - (a - b) -> b */\n-\t  if (GET_CODE (op1) == MINUS && rtx_equal_p (op0, XEXP (op1, 0))\n-\t      && ! side_effects_p (op0))\n-\t    return XEXP (op1, 1);\n-\n-\t  /* (a +/- b) - (a +/- c) can be simplified.  Do variants of\n-\t     this involving commutativity.  The most common case is\n-\t     (a + C1) - (a + C2), but it's not hard to do all the cases.  */\n-\t  if ((GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS)\n-\t      && (GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS))\n-\t    {\n-\t      rtx lhs0 = XEXP (op0, 0), lhs1 = XEXP (op0, 1);\n-\t      rtx rhs0 = XEXP (op1, 0), rhs1 = XEXP (op1, 1);\n-\t      int lhs_neg = GET_CODE (op0) == MINUS;\n-\t      int rhs_neg = GET_CODE (op1) == MINUS;\n-\t      rtx lhs = 0, rhs = 0;\n-\n-\t      /* Set LHS and RHS to the two different terms.  */\n-\t      if (rtx_equal_p (lhs0, rhs0) && ! side_effects_p (lhs0))\n-\t\tlhs = lhs1, rhs = rhs1;\n-\t      else if (! rhs_neg && rtx_equal_p (lhs0, rhs1)\n-\t\t       && ! side_effects_p (lhs0))\n-\t\tlhs = lhs1, rhs = rhs0;\n-\t      else if (! lhs_neg && rtx_equal_p (lhs1, rhs0)\n-\t\t       && ! side_effects_p (lhs1))\n-\t\tlhs = lhs0, rhs = rhs1;\n-\t      else if (! lhs_neg && ! rhs_neg && rtx_equal_p (lhs1, rhs1)\n-\t\t       && ! side_effects_p (lhs1))\n-\t\tlhs = lhs0, rhs = rhs0;\n-\n-\t      /* The RHS is the operand of a MINUS, so its negation\n-\t\t status should be complemented.  */\n-\t      rhs_neg = ! rhs_neg;\n-\n-\t      /* If we found two values equal, form the sum or difference\n-\t\t of the remaining two terms.   */\n-\t      if (lhs)\n-\t\t{\n-\t\t  rtx tem = simplify_binary_operation (lhs_neg == rhs_neg\n-\t\t\t\t\t\t       ? PLUS : MINUS,\n-\t\t\t\t\t\t       mode,\n-\t\t\t\t\t\t       lhs_neg ? rhs : lhs,\n-\t\t\t\t\t\t       lhs_neg ? lhs : rhs);\n-\t\t  if (tem == 0)\n-\t\t    tem = gen_rtx (lhs_neg == rhs_neg\n-\t\t\t\t   ? PLUS : MINUS,\n-\t\t\t\t   mode, lhs_neg ? rhs : lhs,\n-\t\t\t\t   lhs_neg ? lhs : rhs);\n-\n-\t\t  /* If both sides negated, negate result.  */\n-\t\t  if (lhs_neg && rhs_neg)\n-\t\t    {\n-\t\t      rtx tem1\n-\t\t\t= simplify_unary_operation (NEG, mode, tem, mode);\n-\t\t      if (tem1 == 0)\n-\t\t\ttem1 = gen_rtx (NEG, mode, tem);\n-\t\t      tem = tem1;\n-\t\t    }\n-\n-\t\t  return tem;\n-\t\t}\n-\n-\t      return 0;\n-\t    }\n-\n-\t  /* c1 - (a + c2) becomes (c1 - c2) - a.  */\n-\t  if (GET_CODE (op0) == CONST_INT && GET_CODE (op1) == PLUS\n-\t      && GET_CODE (XEXP (op1, 1)) == CONST_INT)\n-\t    {\n-\t      rtx tem = simplify_binary_operation (MINUS, mode, op0,\n-\t\t\t\t\t\t   XEXP (op1, 1));\n-\n-\t      return tem ? gen_rtx (MINUS, mode, tem, XEXP (op1, 0)) : 0;\n-\t    }\n-\n-\t  /* c1 - (c2 - a) becomes (c1 - c2) + a.  */\n-\t  if (GET_CODE (op0) == CONST_INT && GET_CODE (op1) == MINUS\n-\t      && GET_CODE (XEXP (op1, 0)) == CONST_INT)\n-\t    {\n-\t      rtx tem = simplify_binary_operation (MINUS, mode, op0,\n-\t\t\t\t\t\t   XEXP (op1, 0));\n-\n-\t      return (tem && GET_CODE (tem) == CONST_INT\n-\t\t      ? plus_constant (XEXP (op1, 1), INTVAL (tem))\n-\t\t      : 0);\n-\t    }\n+\t  if ((GET_MODE_CLASS (mode) == MODE_INT\n+\t       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+\t      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n+\t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS)\n+\t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n+\t    return tem;\n \n \t  /* Don't let a relocatable value get a negative coeff.  */\n \t  if (GET_CODE (op1) == CONST_INT)\n@@ -3712,7 +3547,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \tcase MULT:\n \t  if (op1 == constm1_rtx)\n \t    {\n-\t      rtx tem = simplify_unary_operation (NEG, mode, op0, mode);\n+\t      tem = simplify_unary_operation (NEG, mode, op0, mode);\n \n \t      return tem ? tem : gen_rtx (NEG, mode, op0);\n \t    }\n@@ -4092,6 +3927,209 @@ simplify_binary_operation (code, mode, op0, op1)\n   return GEN_INT (val);\n }\n \f\n+/* Simplify a PLUS or MINUS, at least one of whose operands may be another\n+   PLUS or MINUS.\n+\n+   Rather than test for specific case, we do this by a brute-force method\n+   and do all possible simplifications until no more changes occur.  Then\n+   we rebuild the operation.  */\n+\n+static rtx\n+simplify_plus_minus (code, mode, op0, op1)\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+     rtx op0, op1;\n+{\n+  rtx ops[8];\n+  int negs[8];\n+  rtx result, tem;\n+  int n_ops = 2;\n+  int i, j;\n+  int first = 1, negate = 0, changed;\n+\n+  bzero (ops, sizeof ops);\n+  \n+  /* Set up the two operands and then expand them until nothing has been\n+     changed.  If we run out of room in our array, give up; this should\n+     almost never happen.  */\n+\n+  ops[0] = op0, ops[1] = op1, negs[0] = 0, negs[1] = (code == MINUS);\n+\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+\n+      for (i = 0; i < n_ops; i++)\n+\tswitch (GET_CODE (ops[i]))\n+\t  {\n+\t  case PLUS:\n+\t  case MINUS:\n+\t    if (n_ops == 7)\n+\t      return 0;\n+\n+\t    ops[n_ops] = XEXP (ops[i], 1);\n+\t    negs[n_ops++] = GET_CODE (ops[i]) == MINUS ? !negs[i] : negs[i];\n+\t    ops[i] = XEXP (ops[i], 0);\n+\t    changed = 1;\n+\t    break;\n+\n+\t  case NEG:\n+\t    ops[i] = XEXP (ops[i], 0);\n+\t    negs[i] = ! negs[i];\n+\t    changed = 1;\n+\t    break;\n+\n+\t  case CONST:\n+\t    ops[i] = XEXP (ops[i], 0);\n+\t    changed = 1;\n+\t    break;\n+\n+\t  case NOT:\n+\t    /* ~a -> (-a - 1) */\n+\t    if (n_ops != 7)\n+\t      {\n+\t\tops[n_ops] = constm1_rtx;\n+\t\tnegs[n_ops++] = ! negs[i];\n+\t\tops[i] = XEXP (ops[i], 0);\n+\t\tnegs[i] = ! negs[i];\n+\t\tchanged = 1;\n+\t      }\n+\t    break;\n+\n+\t  case CONST_INT:\n+\t    if (negs[i])\n+\t      ops[i] = GEN_INT (- INTVAL (ops[i])), negs[i] = 0, changed = 1;\n+\t    break;\n+\t  }\n+    }\n+\n+  /* If we only have two operands, we can't do anything.  */\n+  if (n_ops <= 2)\n+    return 0;\n+\n+  /* Now simplify each pair of operands until nothing changes.  The first\n+     time through just simplify constants against each other.  */\n+\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = first;\n+\n+      for (i = 0; i < n_ops - 1; i++)\n+\tfor (j = i + 1; j < n_ops; j++)\n+\t  if (ops[i] != 0 && ops[j] != 0\n+\t      && (! first || (CONSTANT_P (ops[i]) && CONSTANT_P (ops[j]))))\n+\t    {\n+\t      rtx lhs = ops[i], rhs = ops[j];\n+\t      enum rtx_code ncode = PLUS;\n+\n+\t      if (negs[i] && ! negs[j])\n+\t\tlhs = ops[j], rhs = ops[i], ncode = MINUS;\n+\t      else if (! negs[i] && negs[j])\n+\t\tncode = MINUS;\n+\n+\t      tem = simplify_binary_operation (ncode, mode, lhs, rhs);\n+\t      if (tem)\n+\t\t{\n+\t\t  ops[i] = tem, ops[j] = 0;\n+\t\t  negs[i] = negs[i] && negs[j];\n+\t\t  if (GET_CODE (tem) == NEG)\n+\t\t    ops[i] = XEXP (tem, 0), negs[i] = ! negs[i];\n+\n+\t\t  if (GET_CODE (ops[i]) == CONST_INT && negs[i])\n+\t\t    ops[i] = GEN_INT (- INTVAL (ops[i])), negs[i] = 0;\n+\t\t  changed = 1;\n+\t\t}\n+\t    }\n+\n+      first = 0;\n+    }\n+\n+  /* Pack all the operands to the lower-numbered entries and give up if\n+     we didn't reduce the number of operands we had.  */\n+  for (i = 0, j = 0; j < n_ops; j++)\n+    if (ops[j] != 0)\n+      ops[i] = ops[j], negs[i++] = negs[j];\n+\n+  if (i >= n_ops)\n+    return 0;\n+\n+  n_ops = i;\n+\n+  /* If we have a CONST_INT, put it last.  */\n+  for (i = 0; i < n_ops - 1; i++)\n+    if (GET_CODE (ops[i]) == CONST_INT)\n+      {\n+\ttem = ops[n_ops - 1], ops[n_ops - 1] = ops[i] , ops[i] = tem;\n+\tj = negs[n_ops - 1], negs[n_ops - 1] = negs[i], negs[i] = j;\n+      }\n+\n+  /* Put a non-negated operand first.  If there aren't any, make all\n+     operands positive and negate the whole thing later.  */\n+  for (i = 0; i < n_ops && negs[i]; i++)\n+    ;\n+\n+  if (i == n_ops)\n+    {\n+      for (i = 0; i < n_ops; i++)\n+\tnegs[i] = 0;\n+      negate = 1;\n+    }\n+  else if (i != 0)\n+    {\n+      tem = ops[0], ops[0] = ops[i], ops[i] = tem;\n+      j = negs[0], negs[0] = negs[i], negs[i] = j;\n+    }\n+\n+  /* Now make the result by performing the requested operations.  */\n+  result = ops[0];\n+  for (i = 1; i < n_ops; i++)\n+    result = cse_gen_binary (negs[i] ? MINUS : PLUS, mode, result, ops[i]);\n+\n+  return negate ? gen_rtx (NEG, mode, result) : result;\n+}\n+\f\n+/* Make a binary operation by properly ordering the operands and \n+   seeing if the expression folds.  */\n+\n+static rtx\n+cse_gen_binary (code, mode, op0, op1)\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+     rtx op0, op1;\n+{\n+  rtx tem;\n+\n+  /* Put complex operands first and constants second if commutative.  */\n+  if (GET_RTX_CLASS (code) == 'c'\n+      && ((CONSTANT_P (op0) && GET_CODE (op1) != CONST_INT)\n+\t  || (GET_RTX_CLASS (GET_CODE (op0)) == 'o'\n+\t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')\n+\t  || (GET_CODE (op0) == SUBREG\n+\t      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op0))) == 'o'\n+\t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')))\n+    tem = op0, op0 = op1, op1 = tem;\n+\n+  /* If this simplifies, do it.  */\n+  tem = simplify_binary_operation (code, mode, op0, op1);\n+\n+  if (tem)\n+    return tem;\n+\n+  /* Handle addition and subtraction of CONST_INT specially.  Otherwise,\n+     just form the operation.  */\n+\n+  if (code == PLUS && GET_CODE (op1) == CONST_INT\n+      && GET_MODE (op0) != VOIDmode)\n+    return plus_constant (op0, INTVAL (op1));\n+  else if (code == MINUS && GET_CODE (op1) == CONST_INT\n+\t   && GET_MODE (op0) != VOIDmode)\n+    return plus_constant (op0, - INTVAL (op1));\n+  else\n+    return gen_rtx (code, mode, op0, op1);\n+}\n+\f\n /* Like simplify_binary_operation except used for relational operators.\n    MODE is the mode of the operands, not that of the result.  */\n \n@@ -5241,11 +5279,7 @@ fold_rtx (x, insn)\n \t      if (! reg_mentioned_p (folded_arg0, y))\n \t\ty = fold_rtx (y, insn);\n \n-\t      new = simplify_binary_operation (code, mode, y, new_const);\n-\t      if (new)\n-\t\treturn new;\n-\n-\t      return gen_rtx (code, mode, y, new_const);\n+\t      return cse_gen_binary (code, mode, y, new_const);\n \t    }\n \t}\n "}]}