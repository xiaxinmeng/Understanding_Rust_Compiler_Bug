{"sha": "486024b158a3445f48aea91fb136dde3a174d219", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg2MDI0YjE1OGEzNDQ1ZjQ4YWVhOTFmYjEzNmRkZTNhMTc0ZDIxOQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2009-10-29T19:20:18Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2009-10-29T19:20:18Z"}, "message": "re PR libfortran/41711 ([F08] BOZ edit-descr does not support reading large kind reals)\n\n2009-10-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/41711\n\t* libgfortran.h: Define larger sizes for BOZ conversion\tbuffers.\n\t* io/write.c (extract_uint): Include case where size is 10 if integer\n\tis large enough. (write_int): Rename to\twrite_boz. (write_boz): Factor\n\tout extract_uint and delete the\tconversion function.\n\t(btoa_big): New binary conversion function.\n\t(otoa_big): New octal conversion function.\n\t(ztoa_big): New\thexidecimal conversion function.\n\t(write_b): Modify to use new function.\n\t(write_o): Likewise.\n\t(write_z): Likewise.\n\nFrom-SVN: r153724", "tree": {"sha": "718741e2774c24e63f25ead67c2ea5159ae6a55b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/718741e2774c24e63f25ead67c2ea5159ae6a55b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/486024b158a3445f48aea91fb136dde3a174d219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486024b158a3445f48aea91fb136dde3a174d219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/486024b158a3445f48aea91fb136dde3a174d219", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486024b158a3445f48aea91fb136dde3a174d219/comments", "author": null, "committer": null, "parents": [{"sha": "2d02c187d18a9195605fa426e4125b6e51b04462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d02c187d18a9195605fa426e4125b6e51b04462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d02c187d18a9195605fa426e4125b6e51b04462"}], "stats": {"total": 291, "additions": 272, "deletions": 19}, "files": [{"sha": "a47fc242f4d7ec31174eddd2daeb57bc454cefb8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486024b158a3445f48aea91fb136dde3a174d219/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486024b158a3445f48aea91fb136dde3a174d219/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=486024b158a3445f48aea91fb136dde3a174d219", "patch": "@@ -1,3 +1,17 @@\n+2009-10-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/41711\n+\t* libgfortran.h: Define larger sizes for BOZ conversion\tbuffers.\n+\t* io/write.c (extract_uint): Include case where size is 10 if integer\n+\tis large enough. (write_int): Rename to\twrite_boz. (write_boz): Factor\n+\tout extract_uint and delete the\tconversion function.\n+\t(btoa_big): New binary conversion function.\n+\t(otoa_big): New octal conversion function.\n+\t(ztoa_big): New\thexidecimal conversion function.\n+\t(write_b): Modify to use new function.\n+\t(write_o): Likewise.\n+\t(write_z): Likewise.\n+\n 2009-10-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/41683"}, {"sha": "8a1c20abee3fa2d7e43811978841c6a4cd78a78f", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 247, "deletions": 16, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486024b158a3445f48aea91fb136dde3a174d219/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486024b158a3445f48aea91fb136dde3a174d219/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=486024b158a3445f48aea91fb136dde3a174d219", "patch": "@@ -446,9 +446,10 @@ extract_uint (const void *p, int len)\n       }\n       break;\n #ifdef HAVE_GFC_INTEGER_16\n+    case 10:\n     case 16:\n       {\n-\tGFC_INTEGER_16 tmp;\n+\tGFC_INTEGER_16 tmp = 0;\n \tmemcpy ((void *) &tmp, p, len);\n \ti = (GFC_UINTEGER_16) tmp;\n       }\n@@ -482,20 +483,14 @@ write_l (st_parameter_dt *dtp, const fnode *f, char *source, int len)\n \n \n static void\n-write_int (st_parameter_dt *dtp, const fnode *f, const char *source, int len,\n-           const char *(*conv) (GFC_UINTEGER_LARGEST, char *, size_t))\n+write_boz (st_parameter_dt *dtp, const fnode *f, const char *q, int n)\n {\n-  GFC_UINTEGER_LARGEST n = 0;\n   int w, m, digits, nzero, nblank;\n   char *p;\n-  const char *q;\n-  char itoa_buf[GFC_BTOA_BUF_SIZE];\n \n   w = f->u.integer.w;\n   m = f->u.integer.m;\n \n-  n = extract_uint (source, len);\n-\n   /* Special case:  */\n \n   if (m == 0 && n == 0)\n@@ -511,7 +506,6 @@ write_int (st_parameter_dt *dtp, const fnode *f, const char *source, int len,\n       goto done;\n     }\n \n-  q = conv (n, itoa_buf, sizeof (itoa_buf));\n   digits = strlen (q);\n \n   /* Select a width if none was specified.  The idea here is to always\n@@ -538,7 +532,6 @@ write_int (st_parameter_dt *dtp, const fnode *f, const char *source, int len,\n       goto done;\n     }\n \n-\n   if (!dtp->u.p.no_leading_blank)\n     {\n       memset (p, ' ', nblank);\n@@ -706,6 +699,202 @@ btoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n   return p;\n }\n \n+/* The following three functions, btoa_big, otoa_big, and ztoa_big, are needed\n+   to convert large reals with kind sizes that exceed the largest integer type\n+   available on certain platforms.  In these cases, byte by byte conversion is\n+   performed. Endianess is taken into account.  */\n+\n+/* Conversion to binary.  */\n+\n+static const char *\n+btoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n+{\n+  char *q;\n+  int i, j;\n+  \n+  q = buffer;\n+  if (big_endian)\n+    {\n+      const char *p = s;\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  char c = *p;\n+\n+\t  /* Test for zero. Needed by write_boz later.  */\n+\t  if (*p != 0)\n+\t    *n = 1;\n+\n+\t  for (j = 0; j < 8; j++)\n+\t    {\n+\t      *q++ = (c & 128) ? '1' : '0';\n+\t      c <<= 1;\n+\t    }\n+\t  p++;\n+\t}\n+    }\n+  else\n+    {\n+      const char *p = s + len - 1;\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  char c = *p;\n+\n+\t  /* Test for zero. Needed by write_boz later.  */\n+\t  if (*p != 0)\n+\t    *n = 1;\n+\n+\t  for (j = 0; j < 8; j++)\n+\t    {\n+\t      *q++ = (c & 128) ? '1' : '0';\n+\t      c <<= 1;\n+\t    }\n+\t  p--;\n+\t}\n+    }\n+\n+  *q = '\\0';\n+\n+  if (*n == 0)\n+    return \"0\";\n+\n+  /* Move past any leading zeros.  */  \n+  while (*buffer == '0')\n+    buffer++;\n+\n+  return buffer;\n+\n+}\n+\n+/* Conversion to octal.  */\n+\n+static const char *\n+otoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n+{\n+  char *q;\n+  int i, j, k;\n+  uint8_t octet;\n+\n+  q = buffer + GFC_OTOA_BUF_SIZE - 1;\n+  *q = '\\0';\n+  i = k = octet = 0;\n+\n+  if (big_endian)\n+    {\n+      const char *p = s + len - 1;\n+      char c = *p;\n+      while (i < len)\n+\t{\n+\t  /* Test for zero. Needed by write_boz later.  */\n+\t  if (*p != 0)\n+\t    *n = 1;\n+\n+\t  for (j = 0; j < 3 && i < len; j++)\n+\t    {\n+\t      octet |= (c & 1) << j;\n+\t      c >>= 1;\n+\t      if (++k > 7)\n+\t        {\n+\t\t  i++;\n+\t\t  k = 0;\n+\t\t  c = *--p;\n+\t\t}\n+\t    }\n+\t  *--q = '0' + octet;\n+\t  octet = 0;\n+\t}\n+    }\n+  else\n+    {\n+      const char *p = s;\n+      char c = *p;\n+      while (i < len)\n+\t{\n+\t  /* Test for zero. Needed by write_boz later.  */\n+\t  if (*p != 0)\n+\t    *n = 1;\n+\n+\t  for (j = 0; j < 3 && i < len; j++)\n+\t    {\n+\t      octet |= (c & 1) << j;\n+\t      c >>= 1;\n+\t      if (++k > 7)\n+\t        {\n+\t\t  i++;\n+\t\t  k = 0;\n+\t\t  c = *++p;\n+\t\t}\n+\t    }\n+\t  *--q = '0' + octet;\n+\t  octet = 0;\n+\t}\n+    }\n+\n+  if (*n == 0)\n+    return \"0\";\n+\n+  /* Move past any leading zeros.  */  \n+  while (*q == '0')\n+    q++;\n+\n+  return q;\n+}\n+\n+/* Conversion to hexidecimal.  */\n+\n+static const char *\n+ztoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n+{\n+  static char a[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n+    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n+\n+  char *q;\n+  uint8_t h, l;\n+  int i;\n+  \n+  q = buffer;\n+  \n+  if (big_endian)\n+    {\n+      const char *p = s;\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  /* Test for zero. Needed by write_boz later.  */\n+\t  if (*p != 0)\n+\t    *n = 1;\n+\n+\t  h = (*p >> 4) & 0x0F;\n+\t  l = *p++ & 0x0F;\n+\t  *q++ = a[h];\n+\t  *q++ = a[l];\n+\t}\n+    }\n+  else\n+    {\n+      const char *p = s + len - 1;\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  /* Test for zero. Needed by write_boz later.  */\n+\t  if (*p != 0)\n+\t    *n = 1;\n+\n+\t  h = (*p >> 4) & 0x0F;\n+\t  l = *p-- & 0x0F;\n+\t  *q++ = a[h];\n+\t  *q++ = a[l];\n+\t}\n+    }\n+\n+  *q = '\\0';\n+  \n+  if (*n == 0)\n+    return \"0\";\n+    \n+  /* Move past any leading zeros.  */  \n+  while (*buffer == '0')\n+    buffer++;\n+\n+  return buffer;\n+}\n \n /* gfc_itoa()-- Integer to decimal conversion.\n    The itoa function is a widespread non-standard extension to standard\n@@ -757,22 +946,64 @@ write_i (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n \n \n void\n-write_b (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+write_b (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n-  write_int (dtp, f, p, len, btoa);\n+  const char *p;\n+  char itoa_buf[GFC_BTOA_BUF_SIZE];\n+  GFC_UINTEGER_LARGEST n = 0;\n+\n+  if (len > (int) sizeof (GFC_UINTEGER_LARGEST))\n+    {\n+      p = btoa_big (source, itoa_buf, len, &n);\n+      write_boz (dtp, f, p, n);\n+    }\n+  else\n+    {\n+      n = extract_uint (source, len);\n+      p = btoa (n, itoa_buf, sizeof (itoa_buf));\n+      write_boz (dtp, f, p, n);\n+    }\n }\n \n \n void\n-write_o (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+write_o (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n-  write_int (dtp, f, p, len, otoa);\n+  const char *p;\n+  char itoa_buf[GFC_OTOA_BUF_SIZE];\n+  GFC_UINTEGER_LARGEST n = 0;\n+  \n+  if (len > (int) sizeof (GFC_UINTEGER_LARGEST))\n+    {\n+      p = otoa_big (source, itoa_buf, len, &n);\n+      write_boz (dtp, f, p, n);\n+    }\n+  else\n+    {\n+      n = extract_uint (source, len);\n+      p = otoa (n, itoa_buf, sizeof (itoa_buf));\n+      write_boz (dtp, f, p, n);\n+    }\n }\n \n void\n-write_z (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+write_z (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n-  write_int (dtp, f, p, len, gfc_xtoa);\n+  const char *p;\n+  char itoa_buf[GFC_XTOA_BUF_SIZE];\n+  GFC_UINTEGER_LARGEST n = 0;\n+\n+  if (len > (int) sizeof (GFC_UINTEGER_LARGEST))\n+    {\n+      p = ztoa_big (source, itoa_buf, len, &n);\n+      write_boz (dtp, f, p, n);\n+    }\n+  else\n+    {\n+      n = extract_uint (source, len);\n+      p = gfc_xtoa (n, itoa_buf, sizeof (itoa_buf));\n+      write_boz (dtp, f, p, n);\n+    }\n }\n \n "}, {"sha": "bba95f7c7813263093cb294abb440728d487f7bd", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486024b158a3445f48aea91fb136dde3a174d219/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486024b158a3445f48aea91fb136dde3a174d219/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=486024b158a3445f48aea91fb136dde3a174d219", "patch": "@@ -672,10 +672,18 @@ internal_proto(show_backtrace);\n \n /* error.c */\n \n+#if defined(HAVE_GFC_REAL_16)\n+#define GFC_LARGEST_BUF (sizeof (GFC_REAL_16))\n+#elif defined(HAVE_GFC_REAL_10)\n+#define GFC_LARGEST_BUF (sizeof (GFC_REAL_10))\n+#else\n+#define GFC_LARGEST_BUF (sizeof (GFC_INTEGER_LARGEST))\n+#endif\n+\n #define GFC_ITOA_BUF_SIZE (sizeof (GFC_INTEGER_LARGEST) * 3 + 2)\n-#define GFC_XTOA_BUF_SIZE (sizeof (GFC_UINTEGER_LARGEST) * 2 + 1)\n-#define GFC_OTOA_BUF_SIZE (sizeof (GFC_INTEGER_LARGEST) * 3 + 1)\n-#define GFC_BTOA_BUF_SIZE (sizeof (GFC_INTEGER_LARGEST) * 8 + 1)\n+#define GFC_XTOA_BUF_SIZE (GFC_LARGEST_BUF * 2 + 1)\n+#define GFC_OTOA_BUF_SIZE (GFC_LARGEST_BUF * 3 + 1)\n+#define GFC_BTOA_BUF_SIZE (GFC_LARGEST_BUF * 8 + 1)\n \n extern void sys_exit (int) __attribute__ ((noreturn));\n internal_proto(sys_exit);"}]}