{"sha": "380ff34aabf91a8785fa7428177979fb85fe7e98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgwZmYzNGFhYmY5MWE4Nzg1ZmE3NDI4MTc3OTc5ZmI4NWZlN2U5OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:27:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:27:13Z"}, "message": "(const_binop): Rework to only make constants in one place; always use size_int if small enough and of sizetype.\n\n(const_binop): Rework to only make constants in\none place; always use size_int if small enough and of sizetype.\n(size_int): Call force_fit_type.\n(fold): Avoid ever changing type of input tree.\n\nFrom-SVN: r13377", "tree": {"sha": "a7084ba334e8eff28d6cabcedae522961be01fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7084ba334e8eff28d6cabcedae522961be01fa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/380ff34aabf91a8785fa7428177979fb85fe7e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/380ff34aabf91a8785fa7428177979fb85fe7e98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/380ff34aabf91a8785fa7428177979fb85fe7e98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/380ff34aabf91a8785fa7428177979fb85fe7e98/comments", "author": null, "committer": null, "parents": [{"sha": "f7fa6ef9c7e369c662149c43e18a63eee4dd63cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fa6ef9c7e369c662149c43e18a63eee4dd63cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7fa6ef9c7e369c662149c43e18a63eee4dd63cb"}], "stats": {"total": 130, "additions": 62, "deletions": 68}, "files": [{"sha": "b3c2547dce3a358de6654a8fadc759becbf04904", "filename": "gcc/fold-const.c", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/380ff34aabf91a8785fa7428177979fb85fe7e98/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/380ff34aabf91a8785fa7428177979fb85fe7e98/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=380ff34aabf91a8785fa7428177979fb85fe7e98", "patch": "@@ -1,5 +1,5 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n-   Copyright (C) 1987, 88, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1072,23 +1072,24 @@ const_binop (code, arg1, arg2, notrunc)\n       register tree t;\n       int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n       int overflow = 0;\n+      int no_overflow = 0;\n \n       switch (code)\n \t{\n \tcase BIT_IOR_EXPR:\n-\t  t = build_int_2 (int1l | int2l, int1h | int2h);\n+\t  low = int1l | int2l, hi = int1h | int2h;\n \t  break;\n \n \tcase BIT_XOR_EXPR:\n-\t  t = build_int_2 (int1l ^ int2l, int1h ^ int2h);\n+\t  low = int1l ^ int2l, hi = int1h ^ int2h;\n \t  break;\n \n \tcase BIT_AND_EXPR:\n-\t  t = build_int_2 (int1l & int2l, int1h & int2h);\n+\t  low = int1l & int2l, hi = int1h & int2h;\n \t  break;\n \n \tcase BIT_ANDTC_EXPR:\n-\t  t = build_int_2 (int1l & ~int2l, int1h & ~int2h);\n+\t  low = int1l & ~int2l, hi = int1h & ~int2h;\n \t  break;\n \n \tcase RSHIFT_EXPR:\n@@ -1101,109 +1102,85 @@ const_binop (code, arg1, arg2, notrunc)\n \t\t\t TYPE_PRECISION (TREE_TYPE (arg1)),\n \t\t\t &low, &hi,\n \t\t\t !uns);\n-\t  t = build_int_2 (low, hi);\n-\t  TREE_TYPE (t) = TREE_TYPE (arg1);\n-\t  if (!notrunc)\n-\t    force_fit_type (t, 0);\n-\t  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2);\n-\t  TREE_CONSTANT_OVERFLOW (t)\n-\t    = TREE_CONSTANT_OVERFLOW (arg1) | TREE_CONSTANT_OVERFLOW (arg2);\n-\t  return t;\n+\t  no_overflow = 1;\n+\t  break;\n \n \tcase RROTATE_EXPR:\n \t  int2l = - int2l;\n \tcase LROTATE_EXPR:\n \t  lrotate_double (int1l, int1h, int2l,\n \t\t\t  TYPE_PRECISION (TREE_TYPE (arg1)),\n \t\t\t  &low, &hi);\n-\t  t = build_int_2 (low, hi);\n \t  break;\n \n \tcase PLUS_EXPR:\n-\t  if (int1h == 0)\n-\t    {\n-\t      int2l += int1l;\n-\t      if ((unsigned HOST_WIDE_INT) int2l < int1l)\n-\t\t{\n-\t\t  hi = int2h++;\n-\t\t  overflow = int2h < hi;\n-\t\t}\n-\t      t = build_int_2 (int2l, int2h);\n-\t      break;\n-\t    }\n-\t  if (int2h == 0)\n-\t    {\n-\t      int1l += int2l;\n-\t      if ((unsigned HOST_WIDE_INT) int1l < int2l)\n-\t\t{\n-\t\t  hi = int1h++;\n-\t\t  overflow = int1h < hi;\n-\t\t}\n-\t      t = build_int_2 (int1l, int1h);\n-\t      break;\n-\t    }\n \t  overflow = add_double (int1l, int1h, int2l, int2h, &low, &hi);\n-\t  t = build_int_2 (low, hi);\n \t  break;\n \n \tcase MINUS_EXPR:\n-\t  if (int2h == 0 && int2l == 0)\n-\t    {\n-\t      t = build_int_2 (int1l, int1h);\n-\t      break;\n-\t    }\n \t  neg_double (int2l, int2h, &low, &hi);\n \t  add_double (int1l, int1h, low, hi, &low, &hi);\n \t  overflow = overflow_sum_sign (hi, int2h, int1h);\n-\t  t = build_int_2 (low, hi);\n \t  break;\n \n \tcase MULT_EXPR:\n \t  overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n-\t  t = build_int_2 (low, hi);\n \t  break;\n \n \tcase TRUNC_DIV_EXPR:\n \tcase FLOOR_DIV_EXPR: case CEIL_DIV_EXPR:\n \tcase EXACT_DIV_EXPR:\n-\t  /* This is a shortcut for a common special case.\n-\t     It reduces the number of tree nodes generated\n-\t     and saves time.  */\n+\t  /* This is a shortcut for a common special case.  */\n \t  if (int2h == 0 && int2l > 0\n-\t      && TREE_TYPE (arg1) == sizetype\n \t      && ! TREE_CONSTANT_OVERFLOW (arg1)\n \t      && ! TREE_CONSTANT_OVERFLOW (arg2)\n \t      && int1h == 0 && int1l >= 0)\n \t    {\n \t      if (code == CEIL_DIV_EXPR)\n-\t\tint1l += int2l-1;\n-\t      return size_int (int1l / int2l);\n+\t\tint1l += int2l - 1;\n+\t      low = int1l / int2l, hi = 0;\n+\t      break;\n \t    }\n+\n+\t  /* ... fall through ... */\n+\n \tcase ROUND_DIV_EXPR: \n \t  if (int2h == 0 && int2l == 1)\n \t    {\n-\t      t = build_int_2 (int1l, int1h);\n+\t      low = int1l, hi = int1h;\n \t      break;\n \t    }\n-\t  if (int1l == int2l && int1h == int2h)\n+\t  if (int1l == int2l && int1h == int2h\n+\t      && ! (int1l == 0 && int1h == 0))\n \t    {\n-\t      if ((int1l | int1h) == 0)\n-\t\tabort ();\n-\t      t = build_int_2 (1, 0);\n+\t      low = 1, hi = 0;\n \t      break;\n \t    }\n \t  overflow = div_and_round_double (code, uns,\n \t\t\t\t\t   int1l, int1h, int2l, int2h,\n \t\t\t\t\t   &low, &hi, &garbagel, &garbageh);\n-\t  t = build_int_2 (low, hi);\n \t  break;\n \n-\tcase TRUNC_MOD_EXPR: case ROUND_MOD_EXPR: \n+\tcase TRUNC_MOD_EXPR:\n \tcase FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n+\t  /* This is a shortcut for a common special case.  */\n+\t  if (int2h == 0 && int2l > 0\n+\t      && ! TREE_CONSTANT_OVERFLOW (arg1)\n+\t      && ! TREE_CONSTANT_OVERFLOW (arg2)\n+\t      && int1h == 0 && int1l >= 0)\n+\t    {\n+\t      if (code == CEIL_MOD_EXPR)\n+\t\tint1l += int2l - 1;\n+\t      low = int1l % int2l, hi = 0;\n+\t      break;\n+\t    }\n+\n+\t  /* ... fall through ... */\n+\n+\tcase ROUND_MOD_EXPR: \n \t  overflow = div_and_round_double (code, uns,\n \t\t\t\t\t   int1l, int1h, int2l, int2h,\n \t\t\t\t\t   &garbagel, &garbageh, &low, &hi);\n-\t  t = build_int_2 (low, hi);\n \t  break;\n \n \tcase MIN_EXPR:\n@@ -1225,18 +1202,29 @@ const_binop (code, arg1, arg2, notrunc)\n \t\t\t     < (unsigned HOST_WIDE_INT) int2l)));\n \t    }\n \t  if (low == (code == MIN_EXPR))\n-\t    t = build_int_2 (int1l, int1h);\n+\t    low = int1l, hi = int1h;\n \t  else\n-\t    t = build_int_2 (int2l, int2h);\n+\t    low = int2l, hi = int2h;\n \t  break;\n \n \tdefault:\n \t  abort ();\n \t}\n     got_it:\n-      TREE_TYPE (t) = TREE_TYPE (arg1);\n+      if (TREE_TYPE (arg1) == sizetype && hi == 0\n+\t  && low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype))\n+\t  && ! overflow\n+\t  && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n+\tt = size_int (low);\n+      else\n+\t{\n+\t  t = build_int_2 (low, hi);\n+\t  TREE_TYPE (t) = TREE_TYPE (arg1);\n+\t}\n+\n       TREE_OVERFLOW (t)\n-\t= ((notrunc ? !uns && overflow : force_fit_type (t, overflow && !uns))\n+\t= ((notrunc ? !uns && overflow\n+\t    : force_fit_type (t, overflow && !uns) && ! no_overflow)\n \t   | TREE_OVERFLOW (arg1)\n \t   | TREE_OVERFLOW (arg2));\n       TREE_CONSTANT_OVERFLOW (t) = (TREE_OVERFLOW (t)\n@@ -1430,6 +1418,7 @@ size_int (number)\n     {\n       t = build_int_2 (number, 0);\n       TREE_TYPE (t) = sizetype;\n+      TREE_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (t) = force_fit_type (t, 0);\n     }\n   return t;\n }\n@@ -4018,7 +4007,6 @@ fold (expr)\n \t    }\n \t  else if (TREE_CODE (arg0) == REAL_CST)\n \t    t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n-\t  TREE_TYPE (t) = type;\n \t}\n       else if (TREE_CODE (arg0) == NEGATE_EXPR)\n \treturn TREE_OPERAND (arg0, 0);\n@@ -4057,7 +4045,6 @@ fold (expr)\n \t\tt = build_real (type,\n \t\t\t\tREAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n \t    }\n-\t  TREE_TYPE (t) = type;\n \t}\n       else if (TREE_CODE (arg0) == ABS_EXPR || TREE_CODE (arg0) == NEGATE_EXPR)\n \treturn build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0));\n@@ -4090,9 +4077,8 @@ fold (expr)\n     case BIT_NOT_EXPR:\n       if (wins)\n \t{\n-\t  if (TREE_CODE (arg0) == INTEGER_CST)\n-\t    t = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n-\t\t\t     ~ TREE_INT_CST_HIGH (arg0));\n+\t  t = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n+\t\t\t   ~ TREE_INT_CST_HIGH (arg0));\n \t  TREE_TYPE (t) = type;\n \t  force_fit_type (t, 0);\n \t  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg0);\n@@ -4259,7 +4245,9 @@ fold (expr)\n \t{\n \t  /* The return value should always have\n \t     the same type as the original expression.  */\n-\t  TREE_TYPE (t1) = TREE_TYPE (t);\n+\t  if (TREE_TYPE (t1) != TREE_TYPE (t))\n+\t    t1 = convert (TREE_TYPE (t), t1);\n+\n \t  return t1;\n \t}\n       return t;\n@@ -5091,6 +5079,9 @@ fold (expr)\n \t    case LE_EXPR:\n \t      if (INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n \t\t{\n+\t\t  if (type == integer_type_node)\n+\t\t    return integer_one_node;\n+\n \t\t  t = build_int_2 (1, 0);\n \t\t  TREE_TYPE (t) = type;\n \t\t  return t;\n@@ -5106,6 +5097,9 @@ fold (expr)\n \t      /* ... fall through ...  */\n \t    case GT_EXPR:\n \t    case LT_EXPR:\n+\t      if (type == integer_type_node)\n+\t\treturn integer_zero_node;\n+\n \t      t = build_int_2 (0, 0);\n \t      TREE_TYPE (t) = type;\n \t      return t;"}]}