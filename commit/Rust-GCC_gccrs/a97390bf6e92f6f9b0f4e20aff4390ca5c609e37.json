{"sha": "a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk3MzkwYmY2ZTkyZjZmOWIwZjRlMjBhZmY0MzkwY2E1YzYwOWUzNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:21:04Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:21:04Z"}, "message": "[77/77] Add a complex_mode class\n\nThis patch adds another machine_mode wrapper for modes that are\nknown to be COMPLEX_MODE_P.  There aren't yet many places that make\nuse of it, but that might change in future.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* coretypes.h (complex_mode): New type.\n\t* gdbhooks.py (build_pretty_printer): Handle it.\n\t* machmode.h (complex_mode): New class.\n\t(complex_mode::includes_p): New function.\n\t(is_complex_int_mode): Likewise.\n\t(is_complex_float_mode): Likewise.\n\t* genmodes.c (get_mode_class): Handle complex mode classes.\n\t* function.c (expand_function_end): Use is_complex_int_mode.\n\ngcc/go/\n\t* go-lang.c (go_langhook_type_for_mode): Use is_complex_float_mode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251527", "tree": {"sha": "887cbbdf7eab9b228fc8dbc63e7d4c06f9b255eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/887cbbdf7eab9b228fc8dbc63e7d4c06f9b255eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/comments", "author": null, "committer": null, "parents": [{"sha": "382615c64cad28fb4aa0566b25b3f1921b3d6a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382615c64cad28fb4aa0566b25b3f1921b3d6a3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/382615c64cad28fb4aa0566b25b3f1921b3d6a3d"}], "stats": {"total": 95, "additions": 88, "deletions": 7}, "files": [{"sha": "9d89d47c55de0b37f10623e92ddae6edb42f0dcf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -1,3 +1,16 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* coretypes.h (complex_mode): New type.\n+\t* gdbhooks.py (build_pretty_printer): Handle it.\n+\t* machmode.h (complex_mode): New class.\n+\t(complex_mode::includes_p): New function.\n+\t(is_complex_int_mode): Likewise.\n+\t(is_complex_float_mode): Likewise.\n+\t* genmodes.c (get_mode_class): Handle complex mode classes.\n+\t* function.c (expand_function_end): Use is_complex_int_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "21ea8d97a0d5b318ea1bcb40edda891e27387479", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -58,6 +58,7 @@ typedef const struct rtx_def *const_rtx;\n class scalar_mode;\n class scalar_int_mode;\n class scalar_float_mode;\n+class complex_mode;\n template<typename> class opt_mode;\n typedef opt_mode<scalar_mode> opt_scalar_mode;\n typedef opt_mode<scalar_int_mode> opt_scalar_int_mode;\n@@ -323,6 +324,7 @@ union _dont_use_tree_here_;\n typedef struct scalar_mode scalar_mode;\n typedef struct scalar_int_mode scalar_int_mode;\n typedef struct scalar_float_mode scalar_float_mode;\n+typedef struct complex_mode complex_mode;\n \n #endif\n "}, {"sha": "4c77e19973e1e5e3666c5718f6efcc128ddf1fe9", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -5491,6 +5491,7 @@ expand_function_end (void)\n \t  : DECL_REGISTER (decl_result))\n \t{\n \t  rtx real_decl_rtl = crtl->return_rtx;\n+\t  complex_mode cmode;\n \n \t  /* This should be set in assign_parms.  */\n \t  gcc_assert (REG_FUNCTION_VALUE_P (real_decl_rtl));\n@@ -5531,8 +5532,8 @@ expand_function_end (void)\n \t     need to generate some non-trivial bitfield insertions.  Do that\n \t     on a pseudo and not the hard register.  */\n \t  else if (GET_CODE (decl_rtl) == CONCAT\n-\t\t   && GET_MODE_CLASS (GET_MODE (decl_rtl)) == MODE_COMPLEX_INT\n-\t\t   && GET_MODE_BITSIZE (GET_MODE (decl_rtl)) <= BITS_PER_WORD)\n+\t\t   && is_complex_int_mode (GET_MODE (decl_rtl), &cmode)\n+\t\t   && GET_MODE_BITSIZE (cmode) <= BITS_PER_WORD)\n \t    {\n \t      int old_generating_concat_p;\n \t      rtx tmp;"}, {"sha": "1b3f95361b6f415c4ba2646a321fc35178ccbfbb", "filename": "gcc/gdbhooks.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -551,7 +551,8 @@ def build_pretty_printer():\n     pp.add_printer_for_types(['scalar_int_mode_pod',\n                               'scalar_mode_pod'],\n                              'pod_mode', MachineModePrinter)\n-    for mode in 'scalar_mode', 'scalar_int_mode', 'scalar_float_mode':\n+    for mode in ('scalar_mode', 'scalar_int_mode', 'scalar_float_mode',\n+                 'complex_mode'):\n         pp.add_printer_for_types([mode], mode, MachineModePrinter)\n \n     return pp"}, {"sha": "97ed949c255aa87cd0550973781d45db87cc078d", "filename": "gcc/genmodes.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -1152,6 +1152,10 @@ get_mode_class (struct mode_data *mode)\n     case MODE_DECIMAL_FLOAT:\n       return \"scalar_float_mode\";\n \n+    case MODE_COMPLEX_INT:\n+    case MODE_COMPLEX_FLOAT:\n+      return \"complex_mode\";\n+\n     default:\n       return NULL;\n     }"}, {"sha": "83138d35c281b94cedeebbe0ba64d46706c40054", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -1,3 +1,9 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* go-lang.c (go_langhook_type_for_mode): Use is_complex_float_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "81eeb5c9cdcea54709470635463d843a3c0ce400", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -384,7 +384,7 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n \n   scalar_int_mode imode;\n   scalar_float_mode fmode;\n-  enum mode_class mc = GET_MODE_CLASS (mode);\n+  complex_mode cmode;\n   if (is_int_mode (mode, &imode))\n     return go_langhook_type_for_size (GET_MODE_BITSIZE (imode), unsignedp);\n   else if (is_float_mode (mode, &fmode))\n@@ -402,9 +402,9 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n \t    return long_double_type_node;\n \t}\n     }\n-  else if (mc == MODE_COMPLEX_FLOAT)\n+  else if (is_complex_float_mode (mode, &cmode))\n     {\n-      switch (GET_MODE_BITSIZE (mode))\n+      switch (GET_MODE_BITSIZE (cmode))\n \t{\n \tcase 64:\n \t  return complex_float_type_node;\n@@ -413,7 +413,7 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n \tdefault:\n \t  // We have to check for long double in order to support\n \t  // i386 excess precision.\n-\t  if (mode == TYPE_MODE(complex_long_double_type_node))\n+\t  if (cmode == TYPE_MODE(complex_long_double_type_node))\n \t    return complex_long_double_type_node;\n \t}\n     }"}, {"sha": "b331f07b4fd8fb73c727901895c6d49f0e798d29", "filename": "gcc/machmode.h", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97390bf6e92f6f9b0f4e20aff4390ca5c609e37/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=a97390bf6e92f6f9b0f4e20aff4390ca5c609e37", "patch": "@@ -450,6 +450,30 @@ scalar_mode::includes_p (machine_mode m)\n     }\n }\n \n+/* Represents a machine mode that is known to be a COMPLEX_MODE_P.  */\n+class complex_mode\n+{\n+public:\n+  typedef mode_traits<complex_mode>::from_int from_int;\n+\n+  ALWAYS_INLINE complex_mode () {}\n+  ALWAYS_INLINE complex_mode (from_int m) : m_mode (machine_mode (m)) {}\n+  ALWAYS_INLINE operator machine_mode () const { return m_mode; }\n+\n+  static bool includes_p (machine_mode);\n+\n+protected:\n+  machine_mode m_mode;\n+};\n+\n+/* Return true if M is a complex_mode.  */\n+\n+inline bool\n+complex_mode::includes_p (machine_mode m)\n+{\n+  return COMPLEX_MODE_P (m);\n+}\n+\n /* Return the base GET_MODE_SIZE value for MODE.  */\n \n ALWAYS_INLINE unsigned short\n@@ -771,6 +795,36 @@ is_float_mode (machine_mode mode, T *float_mode)\n   return false;\n }\n \n+/* Return true if MODE has class MODE_COMPLEX_INT, storing it as\n+   a complex_mode in *CMODE if so.  */\n+\n+template<typename T>\n+inline bool\n+is_complex_int_mode (machine_mode mode, T *cmode)\n+{\n+  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT)\n+    {\n+      *cmode = complex_mode (complex_mode::from_int (mode));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if MODE has class MODE_COMPLEX_FLOAT, storing it as\n+   a complex_mode in *CMODE if so.  */\n+\n+template<typename T>\n+inline bool\n+is_complex_float_mode (machine_mode mode, T *cmode)\n+{\n+  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+    {\n+      *cmode = complex_mode (complex_mode::from_int (mode));\n+      return true;\n+    }\n+  return false;\n+}\n+\n namespace mode_iterator\n {\n   /* Start mode iterator *ITER at the first mode in class MCLASS, if any.  */"}]}