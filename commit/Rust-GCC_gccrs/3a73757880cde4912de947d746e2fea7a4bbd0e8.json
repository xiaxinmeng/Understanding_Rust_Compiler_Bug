{"sha": "3a73757880cde4912de947d746e2fea7a4bbd0e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E3Mzc1Nzg4MGNkZTQ5MTJkZTk0N2Q3NDZlMmZlYTdhNGJiZDBlOA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-10-29T05:06:10Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-10-29T05:06:10Z"}, "message": "AbstractCollection.java (addAll): Use size() instead of hasNext() in iterator loop.\n\n2000-10-29  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* java/util/AbstractCollection.java (addAll): Use size() instead of\n\thasNext() in iterator loop.\n\t(clear): Ditto.\n\t(contains): Ditto. Simplify loop.\n\t(containsAll): Ditto.\n\t(remove): Ditto.\n\t(removeAll): Ditto.\n\t(retainAll): Ditto.\n\t(toArray): Ditto.\n\t(toString): Ditto. Use string concatenation operators, not\n\tStringBuffer.\n\t* java/util/AbstractList.java (addAll): Use size() instead of\n\thasNext() in iterator loop.\n\t(equals): Ditto.\n\t(hashCode): Ditto.\n\t(indexOf): Ditto. Don't take null check outside of the loop.\n\t(iterator): Return an AbstractListItr instead of anonymous class.\n\t(lastIndexOf): Use a for loop bounded by size() instead of\n\thasPrevious() in iterator loop.\n\t(listIterator): Return an AbstractListItr.\n\t(removeRange): Remove bounds checking code and docs.\n\t(AbstractListItr): New inner class. Code moved here from\n\tlistIterator().\n\t(SubList.iterator): Removed. Use default implementation from\n\tAbstractList instead.\n\t(SubList.listIterator): As above.\n\t* java/util/AbstractMap.java (clear): Use a for loop bounded by size()\n\tinstead of hasNext() in iterator loop.\n\t(containsValue): Ditto.\n\t(equals): Ditto.\n\t(get): Ditto.\n\t(put): Ditto.\n\t(putAll): Ditto.\n\t(remove): Ditto.\n\t(toString): Ditto. Use string concatenation operators, not\n\tStringBuffer.\n\t* java/util/AbstractSequentialList.java (addAll): Use a for loop\n\tbounded by size() instead of hasNext() in iterator loop.\n\t* java/util/AbstractSet.java (hashCode): Don't catch exception as\n\tpart of normal execution flow. Do an explicit null check instead.\n\t* java/util/ArrayList.java (_iSize): Rename to `size'.\n\t(_arData): Rename to `data'.\n\t(get): Check lower bounds also. Simplify IndexOutOfBoundsException\n\tmessage.\n\t(remove): Ditto.\n\t(removeRange): Make protected. Don't check bounds.\n\t(add): Check lower bounds also. Simplify IndexOutOfBoundsException\n\tmessage.\n\t(addAll (Collection)): Use a size-bounded for loop instead of hasNext()\n\tcheck.\n\t(addAll (int, Collection)): Check lower bounds. Simplify exception\n\tstring.\n\t(clone): Clone the data array too.\n\t(indexOf): Inline doesEqual().\n\t(lastIndexOf): Ditto.\n\t(clear): Don't set array data to null.\n\t(set): Check lower bounds. Simplify exception string.\n\t(toArray): Correct comment.\n\t(trimToSize): Don't update modCount, this is not a structural change.\n\tAdd comment.\n\n\t* java/util/BitSet.java: Merged with classpath, new JDK 1.2 methods\n\timplemented.\n\t(toString): Declare `bit' as long, not int.\n\t(data): Made package-private, not private.\n\nFrom-SVN: r37116", "tree": {"sha": "1880d4664e9f2de91bfd16e2e6c1c7c37344d891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1880d4664e9f2de91bfd16e2e6c1c7c37344d891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a73757880cde4912de947d746e2fea7a4bbd0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a73757880cde4912de947d746e2fea7a4bbd0e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a73757880cde4912de947d746e2fea7a4bbd0e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a73757880cde4912de947d746e2fea7a4bbd0e8/comments", "author": null, "committer": null, "parents": [{"sha": "e2d79607346564139f9c2ba3e5a42ece5aab6149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d79607346564139f9c2ba3e5a42ece5aab6149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2d79607346564139f9c2ba3e5a42ece5aab6149"}], "stats": {"total": 1870, "additions": 979, "deletions": 891}, "files": [{"sha": "3a58979fe30899ae747e7192ba6b263bdfcaaf80", "filename": "libjava/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -1,3 +1,71 @@\n+2000-10-29  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/util/AbstractCollection.java (addAll): Use size() instead of\n+\thasNext() in iterator loop.\n+\t(clear): Ditto.\n+\t(contains): Ditto. Simplify loop.\n+\t(containsAll): Ditto.\n+\t(remove): Ditto.\n+\t(removeAll): Ditto.\n+\t(retainAll): Ditto.\n+\t(toArray): Ditto.\n+\t(toString): Ditto. Use string concatenation operators, not\n+\tStringBuffer.\n+\t* java/util/AbstractList.java (addAll): Use size() instead of\n+\thasNext() in iterator loop.\n+\t(equals): Ditto.\n+\t(hashCode): Ditto.\n+\t(indexOf): Ditto. Don't take null check outside of the loop.\n+\t(iterator): Return an AbstractListItr instead of anonymous class.\n+\t(lastIndexOf): Use a for loop bounded by size() instead of \n+\thasPrevious() in iterator loop.\n+\t(listIterator): Return an AbstractListItr.\n+\t(removeRange): Remove bounds checking code and docs.\n+\t(AbstractListItr): New inner class. Code moved here from \n+\tlistIterator().\n+\t(SubList.iterator): Removed. Use default implementation from \n+\tAbstractList instead.\n+\t(SubList.listIterator): As above.\n+\t* java/util/AbstractMap.java (clear): Use a for loop bounded by size() \n+\tinstead of hasNext() in iterator loop.\n+\t(containsValue): Ditto.\n+\t(equals): Ditto.\n+\t(get): Ditto.\n+\t(put): Ditto.\n+\t(putAll): Ditto.\n+\t(remove): Ditto.\n+\t(toString): Ditto. Use string concatenation operators, not\n+\tStringBuffer.\n+\t* java/util/AbstractSequentialList.java (addAll): Use a for loop \n+\tbounded by size() instead of hasNext() in iterator loop.\n+\t* java/util/AbstractSet.java (hashCode): Don't catch exception as\n+\tpart of normal execution flow. Do an explicit null check instead.\n+\t* java/util/ArrayList.java (_iSize): Rename to `size'.\n+\t(_arData): Rename to `data'.\n+\t(get): Check lower bounds also. Simplify IndexOutOfBoundsException\n+\tmessage.\n+\t(remove): Ditto.\n+\t(removeRange): Make protected. Don't check bounds.\n+\t(add): Check lower bounds also. Simplify IndexOutOfBoundsException\n+\tmessage.\n+\t(addAll (Collection)): Use a size-bounded for loop instead of hasNext() \n+\tcheck.\n+\t(addAll (int, Collection)): Check lower bounds. Simplify exception\n+\tstring.\n+\t(clone): Clone the data array too.\n+\t(indexOf): Inline doesEqual().\n+\t(lastIndexOf): Ditto.\n+\t(clear): Don't set array data to null.\n+\t(set): Check lower bounds. Simplify exception string.\n+\t(toArray): Correct comment.\n+\t(trimToSize): Don't update modCount, this is not a structural change.\n+\tAdd comment.\n+\t\n+\t* java/util/BitSet.java: Merged with classpath, new JDK 1.2 methods\n+\timplemented.\n+\t(toString): Declare `bit' as long, not int.\n+\t(data): Made package-private, not private.\t\n+\n 2000-10-27  Warren Levy  <warrenl@cygnus.com>\n \n \t* java/util/natGregorianCalendar.cc (computeFields): Set the isSet__"}, {"sha": "d75aff97339333f7f40c022aee13100a66a9cb25", "filename": "libjava/java/util/AbstractCollection.java", "status": "modified", "additions": 115, "deletions": 109, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractCollection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractCollection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractCollection.java?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -1,13 +1,13 @@\n /* AbstractCollection.java -- Abstract implementation of most of Collection\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -43,8 +43,8 @@\n  * precise implementation used by AbstractCollection is documented, so that\n  * subclasses can tell which methods could be implemented more efficiently.\n  */\n-public abstract class AbstractCollection implements Collection {\n-\n+public abstract class AbstractCollection implements Collection\n+{\n   /**\n    * Return an Iterator over this collection. The iterator must provide the\n    * hasNext and next methods and should in addition provide remove if the\n@@ -67,7 +67,8 @@ public abstract class AbstractCollection implements Collection {\n    * @exception UnsupportedOperationException if the add operation is not\n    *   supported on this collection\n    */\n-  public boolean add(Object o) {\n+  public boolean add(Object o)\n+  {\n     throw new java.lang.UnsupportedOperationException();\n   }\n \n@@ -82,12 +83,15 @@ public boolean add(Object o) {\n    * @exception UnsupportedOperationException if the add operation is not\n    *   supported on this collection\n    */\n-  public boolean addAll(Collection c) {\n-    Iterator i = c.iterator();\n+  public boolean addAll(Collection c)\n+  {\n+    Iterator itr = c.iterator();\n+    int size = c.size();\n     boolean modified = false;\n-    while (i.hasNext()) {\n-      modified |= add(i.next());\n-    }\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tmodified |= add(itr.next());\n+      }\n     return modified;\n   }\n \n@@ -101,12 +105,15 @@ public boolean addAll(Collection c) {\n    * @exception UnsupportedOperationException if the Iterator returned by\n    *   iterator does not provide an implementation of remove\n    */\n-  public void clear() {\n-    Iterator i = iterator();\n-    while (i.hasNext()) {\n-      i.next();\n-      i.remove();\n-    }\n+  public void clear()\n+  {\n+    Iterator itr = iterator();\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\titr.next();\n+\titr.remove();\n+      }\n   }\n \n   /**\n@@ -120,25 +127,15 @@ public void clear() {\n    * @param o the object to remove from this collection\n    * @return true if this collection contains an object equal to o\n    */\n-  public boolean contains(Object o) {\n-    Iterator i = iterator();\n-\n-    // This looks crazily inefficient, but it takes the test o==null outside\n-    // the loop, saving time, and also saves needing to store the result of\n-    // i.next() each time.\n-    if (o == null) {\n-      while (i.hasNext()) {\n-        if (i.next() == null) {\n-          return true;\n-        }\n-      }\n-    } else {\n-      while (i.hasNext()) {\n-        if (o.equals(i.next())) {\n-          return true;\n-        }\n+  public boolean contains(Object o)\n+  {\n+    Iterator itr = iterator();\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tif (o == null ? itr.next() == null : o.equals(itr.next()))\n+\t  return true;\n       }\n-    }\n     return false;\n   }\n \n@@ -152,13 +149,15 @@ public boolean contains(Object o) {\n    * @return true if this collection contains all the elements in the given\n    *   collection\n    */\n-  public boolean containsAll(Collection c) {\n-    Iterator i = c.iterator();\n-    while (i.hasNext()) {\n-      if (!contains(i.next())) {\n-        return false;\n+  public boolean containsAll(Collection c)\n+  {\n+    Iterator itr = c.iterator();\n+    int size = c.size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tif (!contains(itr.next()))\n+\t  return false;\n       }\n-    }\n     return true;\n   }\n \n@@ -168,7 +167,8 @@ public boolean containsAll(Collection c) {\n    *\n    * @return true if this collection is empty.\n    */\n-  public boolean isEmpty() {\n+  public boolean isEmpty()\n+  {\n     return size() == 0;\n   }\n \n@@ -189,27 +189,18 @@ public boolean isEmpty() {\n    * @exception UnsupportedOperationException if this collection's Iterator\n    *   does not support the remove method\n    */\n-  public boolean remove(Object o) {\n-    Iterator i = iterator();\n-\n-    // This looks crazily inefficient, but it takes the test o==null outside\n-    // the loop, saving time, and also saves needing to store the result of\n-    // i.next() each time.\n-    if (o == null) {\n-      while (i.hasNext()) {\n-        if (i.next() == null) {\n-          i.remove();\n-\t  return true;\n-        }\n+  public boolean remove(Object o)\n+  {\n+    Iterator itr = iterator();\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tif (o == null ? itr.next() == null : o.equals(itr.next()))\n+\t  {\n+\t    itr.remove();\n+\t    return true;\n+\t  }\n       }\n-    } else {\n-      while (i.hasNext()) {\n-        if (o.equals(i.next())) {\n-          i.remove();\n-          return true;\n-        }\n-      }\n-    }\n     return false;\n   }\n \n@@ -226,16 +217,20 @@ public boolean remove(Object o) {\n    * @exception UnsupportedOperationException if this collection's Iterator\n    *   does not support the remove method\n    */\n-  public boolean removeAll(Collection c) {\n-    Iterator i = iterator();\n-    boolean changed = false;\n-    while (i.hasNext()) {\n-      if (c.contains(i.next())) {\n-        i.remove();\n-        changed = true;\n+  public boolean removeAll(Collection c)\n+  {\n+    Iterator itr = iterator();\n+    int size = size();\n+    boolean modified = false;\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tif (c.contains(itr.next()))\n+\t  {\n+\t    itr.remove();\n+\t    modified = true;\n+\t  }\n       }\n-    }\n-    return changed;\n+    return modified;\n   }\n \n   /**\n@@ -251,16 +246,20 @@ public boolean removeAll(Collection c) {\n    * @exception UnsupportedOperationException if this collection's Iterator\n    *   does not support the remove method\n    */\n-  public boolean retainAll(Collection c) {\n-    Iterator i = iterator();\n-    boolean changed = false;\n-    while (i.hasNext()) {\n-      if (!c.contains(i.next())) {\n-        i.remove();\n-        changed = true;\n+  public boolean retainAll(Collection c)\n+  {\n+    Iterator itr = iterator();\n+    int size = size();\n+    boolean modified = false;\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tif (!c.contains(itr.next()))\n+\t  {\n+\t    itr.remove();\n+\t    modified = true;\n+\t  }\n       }\n-    }\n-    return changed;\n+    return modified;\n   }\n \n   /**\n@@ -271,12 +270,14 @@ public boolean retainAll(Collection c) {\n    *\n    * @return an array containing the elements of this collection\n    */\n-  public Object[] toArray() {\n-    Object[] a = new Object[size()];\n-    Iterator i = iterator();\n-    for (int pos = 0; pos < a.length; pos++) {\n-      a[pos] = i.next();\n-    }\n+  public Object[] toArray()\n+  {\n+    Iterator itr = iterator();\n+    Object[]a = new Object[size()];\n+    for (int pos = 0; pos < a.length; pos++)\n+      {\n+\ta[pos] = itr.next();\n+      }\n     return a;\n   }\n \n@@ -298,18 +299,23 @@ public Object[] toArray() {\n    * @exception ClassCastException if the type of the array precludes holding\n    *   one of the elements of the Collection\n    */\n-  public Object[] toArray(Object[] a) {\n-    final int n = size();\n-    if (a.length < n) {\n-      a = (Object[])Array.newInstance(a.getClass().getComponentType(), n);\n-    }\n-    Iterator i = iterator();\n-    for (int pos = 0; pos < n; pos++) {\n-      a[pos] = i.next();\n-    }\n-    if (a.length > n) {\n-      a[n] = null;\n-    }\n+  public Object[] toArray(Object[]a)\n+  {\n+    int size = size();\n+    if (a.length < size)\n+      {\n+\ta = (Object[])Array.newInstance(a.getClass().getComponentType(),\n+\t\t\t\t\tsize);\n+      }\n+    Iterator itr = iterator();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\ta[pos] = itr.next();\n+      }\n+    if (a.length > size)\n+      {\n+\ta[size] = null;\n+      }\n     return a;\n   }\n \n@@ -322,18 +328,18 @@ public Object[] toArray(Object[] a) {\n    *\n    * @return a String representation of the Collection\n    */\n-  public String toString() {\n-    StringBuffer s = new StringBuffer();\n-    s.append('[');\n-    Iterator i = iterator();\n-    boolean more = i.hasNext();\n-    while(more) {\n-      s.append(i.next());\n-      if (more = i.hasNext()) {\n-        s.append(\", \");\n+  public String toString()\n+  {\n+    Iterator itr = iterator();\n+    int size = size();\n+    String r = \"[\";\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tr += itr.next();\n+\tif (pos < size - 1)\n+\t  r += \", \";\n       }\n-    }\n-    s.append(']');\n-    return s.toString();\n+    r += \"]\";\n+    return r;\n   }\n }"}, {"sha": "89d9a1e1e1bacbc90ba2cb90a660b08396d399e5", "filename": "libjava/java/util/AbstractList.java", "status": "modified", "additions": 220, "deletions": 343, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractList.java?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -44,8 +44,8 @@\n  * AbstractList is documented, so that subclasses can tell which methods could\n  * be implemented more efficiently.\n  */\n-public abstract class AbstractList extends AbstractCollection implements List {\n-\n+public abstract class AbstractList extends AbstractCollection implements List\n+{\n   /**\n    * A count of the number of structural modifications that have been made to\n    * the list (that is, insertions and removals).\n@@ -54,238 +54,112 @@ public abstract class AbstractList extends AbstractCollection implements List {\n \n   public abstract Object get(int index);\n \n-  public void add(int index, Object o) {\n+  public void add(int index, Object o)\n+  {\n     throw new UnsupportedOperationException();\n   }\n \n-  public boolean add(Object o) {\n+  public boolean add(Object o)\n+  {\n     add(size(), o);\n     return true;\n   }\n \n-  public boolean addAll(int index, Collection c) {\n-    Iterator i = c.iterator();\n-    if (i.hasNext()) {\n-      do {\n-        add(index++, i.next());\n-      } while (i.hasNext());\n-      return true;\n-    } else {\n-      return false;\n-    }\n+  public boolean addAll(int index, Collection c)\n+  {\n+    Iterator itr = c.iterator();\n+    int size = c.size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tadd(index++, itr.next());\n+      }\n+    return (size > 0);\n   }\n \n-  public void clear() {\n+  public void clear()\n+  {\n     removeRange(0, size());\n   }\n \n-  public boolean equals(Object o) {\n-    if (o == this) {\n+  public boolean equals(Object o)\n+  {\n+    if (o == this)\n       return true;\n-    } else if (!(o instanceof List)) {\n+    if (!(o instanceof List))\n       return false;\n-    } else {\n-      Iterator i1 = iterator();\n-      Iterator i2 = ((List)o).iterator();\n-      while (i1.hasNext()) {\n-        if (!i2.hasNext()) {\n-          return false;\n-        } else {\n-          Object e = i1.next();\n-          if (e == null ? i2.next() != null : !e.equals(i2.next())) {\n-            return false;\n-          }\n-        }\n-      }\n-      if (i2.hasNext()) {\n-        return false;\n-      } else {\n-        return true;\n+    int size = size();\n+    if (size != ((List) o).size())\n+      return false;\n+\n+    Iterator itr1 = iterator();\n+    Iterator itr2 = ((List) o).iterator();\n+\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tObject e = itr1.next();\n+\tif (e == null ? itr2.next() != null : !e.equals(itr2.next()))\n+\t  return false;\n       }\n-    }\n+    return true;\n   }\n \n-  public int hashCode() {\n+  public int hashCode()\n+  {\n     int hashCode = 1;\n-    Iterator i = iterator();\n-    while (i.hasNext()) {\n-      Object obj = i.next();\n-      hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n-    }\n+    Iterator itr = iterator();\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tObject obj = itr.next();\n+\thashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+      }\n     return hashCode;\n   }\n \n-  public int indexOf(Object o) {\n-    int index = 0;\n-    ListIterator i = listIterator();\n-    if (o == null) {\n-      while (i.hasNext()) {\n-        if (i.next() == null) {\n-          return index;\n-        }\n-        index++;\n-      }\n-    } else {\n-      while (i.hasNext()) {\n-        if (o.equals(i.next())) {\n-          return index;\n-        }\n-        index++;\n+  public int indexOf(Object o)\n+  {\n+    ListIterator itr = listIterator(0);\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tif (o == null ? itr.next() == null : o.equals(itr.next()))\n+\t  return pos;\n       }\n-    }\n     return -1;\n   }\n \n-  public Iterator iterator() {\n-    return new Iterator() {\n-      private int knownMod = modCount;\n-      private int position = 0;\n-      boolean removed = true;\n-\n-      private void checkMod() {\n-        if (knownMod != modCount) {\n-          throw new ConcurrentModificationException();\n-        }\n-      }\n-\n-      public boolean hasNext() {\n-        checkMod();\n-        return position < size();\n-      }\n-\n-      public Object next() {\n-        checkMod();\n-        removed = false;\n-        try {\n-          return get(position++);\n-        } catch (IndexOutOfBoundsException e) {\n-          throw new NoSuchElementException();\n-        }\n-      }\n-\n-      public void remove() {\n-        checkMod();\n-        if (removed) {\n-          throw new IllegalStateException();\n-        }\n-        AbstractList.this.remove(--position);\n-        knownMod = modCount;\n-        removed = true;\n-      }\n-    };\n+  public Iterator iterator()\n+  {\n+    return new AbstractListItr(0);\n   }\n \n-  public int lastIndexOf(Object o) {\n-    int index = size();\n-    ListIterator i = listIterator(index);\n-    if (o == null) {\n-      while (i.hasPrevious()) {\n-        index--;\n-        if (i.previous() == null) {\n-          return index;\n-        }\n-      }\n-    } else {\n-      while (i.hasPrevious()) {\n-        index--;\n-        if (o.equals(i.previous())) {\n-          return index;\n-        }\n+  public int lastIndexOf(Object o)\n+  {\n+    int size = size();\n+    ListIterator itr = listIterator(size);\n+    for (int pos = size; pos > 0; pos--)\n+      {\n+\tif (o == null ? itr.previous() == null : o.equals(itr.previous()))\n+\t  return pos - 1;\n       }\n-    }\n     return -1;\n   }\n \n-  public ListIterator listIterator() {\n-    return listIterator(0);\n+  public ListIterator listIterator()\n+  {\n+    return new AbstractListItr(0);\n   }\n \n-  public ListIterator listIterator(final int index) {\n-\n-    if (index < 0 || index > size()) {\n+  public ListIterator listIterator(int index)\n+  {\n+    if (index < 0 || index > size())\n       throw new IndexOutOfBoundsException();\n-    }\n-\n-    return new ListIterator() {\n-      private int knownMod = modCount;\n-      private int position = index;\n-      private int lastReturned = -1;\n \n-      private void checkMod() {\n-        if (knownMod != modCount) {\n-          throw new ConcurrentModificationException();\n-        }\n-      }\n-\n-      public boolean hasNext() {\n-        checkMod();\n-        return position < size();\n-      }\n-\n-      public boolean hasPrevious() {\n-        checkMod();\n-        return position > 0;\n-      }\n-\n-      public Object next() {\n-        checkMod();\n-        if (hasNext()) {\n-          lastReturned = position++;\n-          return get(lastReturned);\n-        } else {\n-          throw new NoSuchElementException();\n-        }\n-      }\n-\n-      public Object previous() {\n-        checkMod();\n-        if (hasPrevious()) {\n-          lastReturned = --position;\n-          return get(lastReturned);\n-        } else {\n-          throw new NoSuchElementException();\n-        }\n-      }\n-\n-      public int nextIndex() {\n-        checkMod();\n-        return position;\n-      }\n-\n-      public int previousIndex() {\n-        checkMod();\n-        return position - 1;\n-      }\n-\n-      public void remove() {\n-        checkMod();\n-        if (lastReturned < 0) {\n-          throw new IllegalStateException();\n-        }\n-        AbstractList.this.remove(lastReturned);\n-        knownMod = modCount;\n-        position = lastReturned;\n-        lastReturned = -1;\n-      }\n-\n-      public void set(Object o) {\n-        checkMod();\n-        if (lastReturned < 0) {\n-          throw new IllegalStateException();\n-        }\n-        AbstractList.this.set(lastReturned, o);\n-      }\n-\n-      public void add(Object o) {\n-        checkMod();\n-        AbstractList.this.add(position++, o);\n-        lastReturned = -1;\n-        knownMod = modCount;\n-      }\n-    };\n+    return new AbstractListItr(index);\n   }\n \n-  public Object remove(int index) {\n+  public Object remove(int index)\n+  {\n     throw new UnsupportedOperationException();\n   }\n \n@@ -303,59 +177,145 @@ public Object remove(int index) {\n    *\n    * @param fromIndex the index, inclusive, to remove from.\n    * @param toIndex the index, exclusive, to remove to.\n-   * @exception UnsupportedOperationException if this list does not support\n-   *   the removeRange operation.\n-   * @exception IndexOutOfBoundsException if fromIndex > toIndex || fromIndex <\n-   *   0 || toIndex > size().\n    */\n-  protected void removeRange(int fromIndex, int toIndex) {\n-    if (fromIndex > toIndex) {\n-      throw new IllegalArgumentException();\n-    } else if (fromIndex < 0 || toIndex > size()) {\n-      throw new IndexOutOfBoundsException();\n-    } else {\n-      ListIterator i = listIterator(fromIndex);\n-      for (int index = fromIndex; index < toIndex; index++) {\n-        i.next();\n-        i.remove();\n+  protected void removeRange(int fromIndex, int toIndex)\n+  {\n+    ListIterator itr = listIterator(fromIndex);\n+    for (int index = fromIndex; index < toIndex; index++)\n+      {\n+\titr.next();\n+\titr.remove();\n       }\n-    }\n   }\n \n-  public Object set(int index, Object o) {\n+  public Object set(int index, Object o)\n+  {\n     throw new UnsupportedOperationException();\n   }\n \n-  public List subList(final int fromIndex, final int toIndex) {\n+  public List subList(final int fromIndex, final int toIndex)\n+  {\n     if (fromIndex > toIndex)\n       throw new IllegalArgumentException();\n     if (fromIndex < 0 || toIndex > size())\n       throw new IndexOutOfBoundsException();\n+\n     return new SubList(this, fromIndex, toIndex);\n   }\n \n-  static class SubList extends AbstractList {\n+  class AbstractListItr implements ListIterator\n+  {\n+    private int knownMod = modCount;\n+    private int position;\n+    private int lastReturned = -1;\n \n+    AbstractListItr(int start_pos)\n+    {\n+      this.position = start_pos;\n+    }\n+\n+    private void checkMod()\n+    {\n+      if (knownMod != modCount)\n+\tthrow new ConcurrentModificationException();\n+    }\n+\n+    public boolean hasNext()\n+    {\n+      checkMod();\n+      return position < size();\n+    }\n+\n+    public boolean hasPrevious()\n+    {\n+      checkMod();\n+      return position > 0;\n+    }\n+\n+    public Object next()\n+    {\n+      checkMod();\n+      if (position < size())\n+\t{\n+\t  lastReturned = position++;\n+\t  return get(lastReturned);\n+\t}\n+      else\n+\t{\n+\t  throw new NoSuchElementException();\n+\t}\n+    }\n+\n+    public Object previous()\n+    {\n+      checkMod();\n+      if (position > 0)\n+\t{\n+\t  lastReturned = --position;\n+\t  return get(lastReturned);\n+\t}\n+      else\n+\t{\n+\t  throw new NoSuchElementException();\n+\t}\n+    }\n+\n+    public int nextIndex()\n+    {\n+      checkMod();\n+      return position;\n+    }\n+\n+    public int previousIndex()\n+    {\n+      checkMod();\n+      return position - 1;\n+    }\n+\n+    public void remove()\n+    {\n+      checkMod();\n+      if (lastReturned < 0)\n+\t{\n+\t  throw new IllegalStateException();\n+\t}\n+      AbstractList.this.remove(lastReturned);\n+      knownMod = modCount;\n+      position = lastReturned;\n+      lastReturned = -1;\n+    }\n+\n+    public void set(Object o)\n+    {\n+      checkMod();\n+      if (lastReturned < 0)\n+\tthrow new IllegalStateException();\n+      AbstractList.this.set(lastReturned, o);\n+    }\n+\n+    public void add(Object o)\n+    {\n+      checkMod();\n+      AbstractList.this.add(position++, o);\n+      lastReturned = -1;\n+      knownMod = modCount;\n+    }\n+  }\t\t\t\t// AbstractList.Iterator\n+\n+  static class SubList extends AbstractList\n+  {\n     private AbstractList backingList;\n     private int offset;\n     private int size;\n \n-    public SubList(AbstractList backing, int fromIndex, int toIndex) {\n+    public SubList(AbstractList backing, int fromIndex, int toIndex)\n+    {\n       backingList = backing;\n       upMod();\n       offset = fromIndex;\n       size = toIndex - fromIndex;\n     }\n \n-    // Note that within this class two fields called modCount are inherited -\n-    // one from the superclass, and one from the outer class. \n-    // The code uses both these two fields and *no other* to provide fail-fast\n-    // behaviour. For correct operation, the two fields should contain equal\n-    // values. Therefore, if this.modCount != backingList.modCount, there\n-    // has been a concurrent modification. This is all achieved purely by using\n-    // the modCount field, precisely according to the docs of AbstractList.\n-    // See the methods upMod and checkMod.\n-\n     /**\n      * This method checks the two modCount fields to ensure that there has\n      * not been a concurrent modification. It throws an exception if there\n@@ -365,167 +325,82 @@ public SubList(AbstractList backing, int fromIndex, int toIndex) {\n      * @exception ConcurrentModificationException if there has been a\n      *   concurrent modification.\n      */\n-    private void checkMod() {\n-      if (this.modCount != backingList.modCount) {\n+    private void checkMod()\n+    {\n+      if (this.modCount != backingList.modCount)\n \tthrow new ConcurrentModificationException();\n-      }\n     }\n-    \n+\n     /**\n      * This method is called after every method that causes a structural\n      * modification to the backing list. It updates the local modCount field\n      * to match that of the backing list.\n      * Note that since this method is private, it will be inlined.\n      */\n-    private void upMod() {\n+    private void upMod()\n+    {\n       this.modCount = backingList.modCount;\n     }\n-    \n+\n     /**\n      * This method checks that a value is between 0 and size (inclusive). If\n      * it is not, an exception is thrown.\n      * Note that since this method is private, it will be inlined.\n      *\n      * @exception IndexOutOfBoundsException if the value is out of range.\n      */\n-    private void checkBoundsInclusive(int index) {\n-      if (index < 0 || index > size) {\n+    private void checkBoundsInclusive(int index)\n+    {\n+      if (index < 0 || index > size)\n \tthrow new IndexOutOfBoundsException();\n-      }\n     }\n-    \n+\n     /**\n      * This method checks that a value is between 0 (inclusive) and size\n      * (exclusive). If it is not, an exception is thrown.\n      * Note that since this method is private, it will be inlined.\n      *\n      * @exception IndexOutOfBoundsException if the value is out of range.\n      */\n-    private void checkBoundsExclusive(int index) {\n-      if (index < 0 || index >= size) {\n+    private void checkBoundsExclusive(int index)\n+    {\n+      if (index < 0 || index >= size)\n \tthrow new IndexOutOfBoundsException();\n-      }\n     }\n-    \n-    public int size() {\n+\n+    public int size()\n+    {\n       checkMod();\n       return size;\n     }\n-    \n-    public Iterator iterator() {\n-      return listIterator();\n-    }\n-    \n-    public ListIterator listIterator(final int index) {\n-      \n-      checkMod();\n-      checkBoundsInclusive(index);\n-      \n-      return new ListIterator() {\n-\tListIterator i = backingList.listIterator(index + offset);\n-\tint position = index;\n-\t\n-\tpublic boolean hasNext() {\n-\t  checkMod();\n-\t  return position < size;\n-\t}\n-\t\n-\tpublic boolean hasPrevious() {\n-\t  checkMod();\n-\t  return position > 0;\n-\t}\n-\t\n-\tpublic Object next() {\n-\t  if (position < size) {\n-\t    Object o = i.next();\n-\t    position++;\n-\t    return o;\n-\t  } else {\n-\t    throw new NoSuchElementException();\n-\t  }\n-\t}\n-\t\n-\tpublic Object previous() {\n-\t  if (position > 0) {\n-\t    Object o = i.previous();\n-\t    position--;\n-\t    return o;\n-\t  } else {\n-\t    throw new NoSuchElementException();\n-\t  }\n-\t}\n-\t\n-\tpublic int nextIndex() {\n-\t  return offset + i.nextIndex();\n-\t}\n-\t\n-\tpublic int previousIndex() {\n-\t  return offset + i.previousIndex();\n-\t}\n-\n-\tpublic void remove() {\n-\t  i.remove();\n-\t  upMod();\n-\t  size--;\n-\t  position = nextIndex();\n-\t}\n-\t\n-\tpublic void set(Object o) {\n-\t  i.set(o);\n-\t}\n-\t\n-\tpublic void add(Object o) {\n-\t  i.add(o);\n-\t  upMod();\n-\t  size++;\n-\t  position++;\n-\t}\n \n-\t// Here is the reason why the various modCount fields are mostly\n-\t// ignored in this wrapper listIterator.\n-\t// IF the backing listIterator is failfast, then the following holds:\n-\t//   Using any other method on this list will call a corresponding\n-\t//   method on the backing list *after* the backing listIterator\n-\t//   is created, which will in turn cause a ConcurrentModException\n-\t//   when this listIterator comes to use the backing one. So it is\n-\t//   implicitly failfast.\n-\t// If the backing listIterator is NOT failfast, then the whole of\n-\t//   this list isn't failfast, because the modCount field of the\n-\t//   backing list is not valid. It would still be *possible* to\n-\t//   make the iterator failfast wrt modifications of the sublist\n-\t//   only, but somewhat pointless when the list can be changed under\n-\t//   us.\n-\t// Either way, no explicit handling of modCount is needed.\n-\t// However upMod() must be called in add and remove, and size\n-\t// must also be updated in these two methods, since they do not go\n-\t// through the corresponding methods of the subList.\n-\n-      };\n-    }\n-\n-    public Object set(int index, Object o) {\n+    public Object set(int index, Object o)\n+    {\n       checkMod();\n       checkBoundsExclusive(index);\n       o = backingList.set(index + offset, o);\n       upMod();\n       return o;\n     }\n-    \n-    public Object get(int index) {\n+\n+    public Object get(int index)\n+    {\n       checkMod();\n       checkBoundsExclusive(index);\n       return backingList.get(index + offset);\n     }\n \n-    public void add(int index, Object o) {\n+    public void add(int index, Object o)\n+    {\n       checkMod();\n       checkBoundsInclusive(index);\n       backingList.add(index + offset, o);\n       upMod();\n       size++;\n     }\n-    \n-    public Object remove(int index) {\n+\n+    public Object remove(int index)\n+    {\n       checkMod();\n       checkBoundsExclusive(index);\n       Object o = backingList.remove(index + offset);\n@@ -534,18 +409,20 @@ public Object remove(int index) {\n       return o;\n     }\n \n-    public void removeRange(int fromIndex, int toIndex) {\n+    public void removeRange(int fromIndex, int toIndex)\n+    {\n       checkMod();\n       checkBoundsExclusive(fromIndex);\n       checkBoundsInclusive(toIndex);\n-      \n+\n       // this call will catch the toIndex < fromIndex condition\n       backingList.removeRange(offset + fromIndex, offset + toIndex);\n       upMod();\n       size -= toIndex - fromIndex;\n     }\n-    \n-    public boolean addAll(int index, Collection c) {\n+\n+    public boolean addAll(int index, Collection c)\n+    {\n       checkMod();\n       checkBoundsInclusive(index);\n       int s = backingList.size();\n@@ -554,5 +431,5 @@ public boolean addAll(int index, Collection c) {\n       size += backingList.size() - s;\n       return result;\n     }\n-  }\n+  }\t\t\t\t// AbstractList.SubList\n }"}, {"sha": "c4f9df0fc9faa009a35de8f9d2a233ae1358f7eb", "filename": "libjava/java/util/AbstractMap.java", "status": "modified", "additions": 131, "deletions": 132, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractMap.java?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -31,100 +31,103 @@\n \n package java.util;\n \n-public abstract class AbstractMap implements Map {\n-  \n+public abstract class AbstractMap implements Map\n+{\n+  /**\n+   * Remove all entries from this Map. This default implementation calls\n+   * entrySet().clear().\n+   *\n+   * @throws UnsupportedOperationException\n+   * @specnote The JCL book claims that this implementation always throws \n+   *           UnsupportedOperationException, while the online docs claim it\n+   *           calls entrySet().clear(). We take the later to be correct.\n+   */\n   public void clear()\n   {\n     entrySet().clear();\n   }\n \n-  public boolean containsKey( Object key )\n+  public boolean containsKey(Object key)\n   {\n     Object k;\n-    Iterator entries = entrySet().iterator();\n-  \n-    while( entries.hasNext() )\n-    {\n-      k = ((Map.Entry)entries.next()).getKey();\n-      if( key == null ? k == null : key.equals( k ) )\n-\treturn true;\n-    }\n-\n+    Set es = entrySet();\n+    Iterator entries = es.iterator();\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tk = ((Map.Entry) entries.next()).getKey();\n+\tif (key == null ? k == null : key.equals(k))\n+\t  return true;\n+      }\n     return false;\n   }\n \n-  public boolean containsValue( Object value )\n+  public boolean containsValue(Object value)\n   {\n     Object v;\n-    Iterator entries = entrySet().iterator();\n-  \n-    while( entries.hasNext() )\n-    {\n-      v = ((Map.Entry)entries.next()).getValue();\n-      if( value == null ? v == null : value.equals( v ) )\n-\treturn true;\n-    }\n-\n-    return false; \n+    Set es = entrySet();\n+    Iterator entries = es.iterator();\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tv = ((Map.Entry) entries.next()).getValue();\n+\tif (value == null ? v == null : value.equals(v))\n+\t  return true;\n+      }\n+    return false;\n   }\n \n   public abstract Set entrySet();\n \n-  public boolean equals( Object o )\n+  public boolean equals(Object o)\n   {\n-    if( this == o )\n+    if (o == this)\n       return true;\n-    \n-    if( o == null || !( o instanceof Map ) )\n+    if (!(o instanceof Map))\n       return false;\n-    \n-    Map m = (Map)o;\n-    if( m.size() != size() )\n+\n+    Map m = (Map) o;\n+    Set s = m.entrySet();\n+    Iterator itr = entrySet().iterator();\n+    int size = size();\n+\n+    if (m.size() != size)\n       return false;\n-    \n-    Object key, value1, value2;\n-    Map.Entry entry;\n-    Iterator entries = entrySet().iterator();\n-    while( entries.hasNext() )\n-    {\n-      entry = (Map.Entry)entries.next();\n-      key = entry.getKey();\n-      value1 = entry.getValue();\n-      value2 = m.get( key );\n-      \n-      if( !( ( value1 == null && value2 == null )\n-\t     || value1.equals( value2 ) ) )\n-\treturn false;\n-    }\n-\n-    return true;    \n+\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tif (!s.contains(itr.next()))\n+\t  return false;\n+      }\n+    return true;\n   }\n \n-  public Object get( Object key )\n+  public Object get(Object key)\n   {\n-    Object k;\n-    Map.Entry entry;\n-    Iterator entries = entrySet().iterator();\n-  \n-    while( entries.hasNext() )\n-    {\n-      entry = (Map.Entry)entries.next();\n-      k = entry.getKey();\n-      if( key == null ? k == null : key.equals( k ) )\n-\treturn entry.getValue();\n-    }\n+    Set s = entrySet();\n+    Iterator entries = s.iterator();\n+    int size = size();\n+\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tMap.Entry entry = (Map.Entry) entries.next();\n+\tObject k = entry.getKey();\n+\tif (key == null ? k == null : key.equals(k))\n+\t  return entry.getValue();\n+      }\n \n     return null;\n   }\n \n   public int hashCode()\n   {\n     int hashcode = 0;\n-    Iterator entries = entrySet().iterator();\n-  \n-    while( entries.hasNext() )\n-      hashcode += entries.next().hashCode();\n-\n+    Iterator itr = entrySet().iterator();\n+    int size = size();\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\thashcode += itr.next().hashCode();\n+      }\n     return hashcode;\n   }\n \n@@ -135,84 +138,84 @@ public boolean isEmpty()\n \n   public Set keySet()\n   {\n-    if( this.keySet == null )\n-    {\n-      this.keySet =\n-\tnew AbstractSet()\n+    if (this.keySet == null)\n+      {\n+\tthis.keySet = new AbstractSet()\n \t{\n \t  public int size()\n-          {\n+\t  {\n \t    return AbstractMap.this.size();\n \t  }\n \n \t  public boolean contains(Object key)\n \t  {\n \t    return AbstractMap.this.containsKey(key);\n \t  }\n-\t  \n+\n \t  public Iterator iterator()\n-          {\n+\t  {\n \t    return new Iterator()\n-            {\n+\t    {\n \t      Iterator map_iterator = AbstractMap.this.entrySet().iterator();\n-\t      \n+\n \t      public boolean hasNext()\n-              {\n+\t      {\n \t\treturn map_iterator.hasNext();\n \t      }\n \n \t      public Object next()\n-              {\n-\t\treturn ((Map.Entry)map_iterator.next()).getKey();\n+\t      {\n+\t\treturn ((Map.Entry) map_iterator.next()).getKey();\n \t      }\n-\t      \n+\n \t      public void remove()\n-              {\n+\t      {\n \t\tmap_iterator.remove();\n \t      }\n \t    };\n \t  }\n \t};\n-    }\n-    \n-    return this.keySet;    \n+      }\n+\n+    return this.keySet;\n   }\n \n-  public Object put( Object key, Object value )\n+  public Object put(Object key, Object value)\n   {\n     throw new UnsupportedOperationException();\n   }\n \n-  public void putAll( Map m )\n+  public void putAll(Map m)\n   {\n     Map.Entry entry;\n     Iterator entries = m.entrySet().iterator();\n-    while( entries.hasNext() )\n-    {\n-      entry = (Map.Entry)entries.next();\n-      put( entry.getKey(), entry.getValue() );\n-    }\n+    int size = m.size();\n+\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tentry = (Map.Entry) entries.next();\n+\tput(entry.getKey(), entry.getValue());\n+      }\n   }\n \n-  public Object remove( Object key )\n+  public Object remove(Object key)\n   {\n-    Object k, value;\n-    Map.Entry entry;\n     Iterator entries = entrySet().iterator();\n-  \n-    while( entries.hasNext() )\n-    {\n-      entry = (Map.Entry)entries.next();\n-      k = entry.getKey();\n-      if( key == null ? k == null : key.equals( k ) )\n+    int size = size();\n+\n+    for (int pos = 0; pos < size; pos++)\n       {\n-\tvalue = entry.getValue();\n-\tentries.remove();\n-\treturn value;\n+\tMap.Entry entry = (Map.Entry) entries.next();\n+\tObject k = entry.getKey();\n+\tif (key == null ? k == null : key.equals(k))\n+\t  {\n+\t    Object value = entry.getValue();\n+\t    entries.remove();\n+\t    return value;\n+\t  }\n       }\n-    }\n \n-    return null;    \n+    return null;\n   }\n \n   public int size()\n@@ -222,62 +225,58 @@ public int size()\n \n   public String toString()\n   {\n-    StringBuffer sb = new StringBuffer(\"{\");\n-    String comma = \"\";\n     Iterator entries = entrySet().iterator();\n-  \n-    while( entries.hasNext() )\n-    {\n-      Map.Entry entry = (Map.Entry)entries.next();\n-      sb.append(comma).append(entry.getKey())\n-\t.append('=').append(entry.getValue());\n-      comma = \", \";\n-    }\n-\n-    return sb.append('}').toString();\n+    int size = size();\n+    String r = \"{\";\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tr += entries.next();\n+\tif (pos < size - 1)\n+\t  r += \", \";\n+      }\n+    r += \"}\";\n+    return r;\n   }\n \n   public Collection values()\n   {\n-    if( this.valueCollection == null )\n-    {\n-      this.valueCollection =\n-\tnew AbstractCollection()\n+    if (this.valueCollection == null)\n+      {\n+\tthis.valueCollection = new AbstractCollection()\n \t{\n \t  public int size()\n-          {\n+\t  {\n \t    return AbstractMap.this.size();\n \t  }\n-\t  \n+\n \t  public Iterator iterator()\n-          {\n+\t  {\n \t    return new Iterator()\n-            {\n+\t    {\n \t      Iterator map_iterator = AbstractMap.this.entrySet().iterator();\n-\t      \n+\n \t      public boolean hasNext()\n-              {\n+\t      {\n \t\treturn map_iterator.hasNext();\n \t      }\n \n \t      public Object next()\n-              {\n-\t\treturn ((Map.Entry)map_iterator.next()).getValue();\n+\t      {\n+\t\treturn ((Map.Entry) map_iterator.next()).getValue();\n \t      }\n-\t      \n+\n \t      public void remove()\n-              {\n+\t      {\n \t\tmap_iterator.remove();\n \t      }\n \t    };\n \t  }\n \t};\n-    }\n-    \n+      }\n+\n     return this.valueCollection;\n   }\n \n-\n   private Collection valueCollection = null;\n   private Set keySet = null;\n }"}, {"sha": "07809da0c41fb410558dea6a70286822699d8aaf", "filename": "libjava/java/util/AbstractSequentialList.java", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSequentialList.java?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -1,13 +1,13 @@\n /* AbstractSequentialList.java -- List implementation for sequential access\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,7 +36,8 @@\n  * Abstract superclass to make it easier to implement the List interface when\n  * backed by a sequential-access store, such as a linked list.\n  */\n-public abstract class AbstractSequentialList extends AbstractList {\n+public abstract class AbstractSequentialList extends AbstractList\n+{\n \n   /**\n    * Returns a ListIterator over the list, starting from position index.\n@@ -57,27 +58,30 @@ public abstract class AbstractSequentialList extends AbstractList {\n    * @exception UnsupportedOperationException if the iterator returned by\n    *   listIterator(index) does not support the add method.\n    */\n-  public void add(int index, Object o) {\n+  public void add(int index, Object o)\n+  {\n     ListIterator i = listIterator(index);\n     i.add(o);\n   }\n \n-  public boolean addAll(int index, Collection c) {\n-    boolean changed = false;\n+  public boolean addAll(int index, Collection c)\n+  {\n+    boolean modified = false;\n     Iterator ci = c.iterator();\n+    int size = c.size();\n     ListIterator i = listIterator(index);\n-    while (ci.hasNext()) {\n-      i.add(ci.next());\n-      changed = true;\n-    }\n-    return changed;\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\ti.add(ci.next());\n+      }\n+    return (size > 0);\n   }\n \n-  public Object get(int index) {\n+  public Object get(int index)\n+  {\n     ListIterator i = listIterator(index);\n-    if (!i.hasNext()) {\n+    if (index < 0 || index > size())\n       throw new IndexOutOfBoundsException();\n-    }\n     return i.next();\n   }\n \n@@ -87,25 +91,26 @@ public Object get(int index) {\n    *\n    * @return an Iterator over this List\n    */\n-  public Iterator iterator() {\n+  public Iterator iterator()\n+  {\n     return listIterator();\n   }\n \n-  public Object remove(int index) {\n+  public Object remove(int index)\n+  {\n     ListIterator i = listIterator(index);\n-    if (!i.hasNext()) {\n+    if (index < 0 || index > size())\n       throw new IndexOutOfBoundsException();\n-    }\n     Object removed = i.next();\n     i.remove();\n     return removed;\n   }\n \n-  public Object set(int index, Object o) {\n+  public Object set(int index, Object o)\n+  {\n     ListIterator i = listIterator(index);\n-    if (!i.hasNext()) {\n+    if (index < 0 || index > size())\n       throw new IndexOutOfBoundsException();\n-    }\n     Object old = i.next();\n     i.set(o);\n     return old;"}, {"sha": "1014e43340888207608b686786f14758abe88e2b", "filename": "libjava/java/util/AbstractSet.java", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FAbstractSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSet.java?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -1,13 +1,13 @@\n /* AbstractSet.java -- Abstract implementation of most of Set\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,7 +36,8 @@\n  * class simply provides implementations of equals() and hashCode() to fulfil\n  * the requirements placed on them by the Set interface.\n  */\n-public abstract class AbstractSet extends AbstractCollection implements Set {\n+public abstract class AbstractSet extends AbstractCollection implements Set\n+{\n \n   /**\n    * Tests whether the given object is equal to this Set. This implementation\n@@ -48,14 +49,14 @@ public abstract class AbstractSet extends AbstractCollection implements Set {\n    * @param o the Object to be tested for equality with this Set\n    * @return true if the given object is equal to this Set\n    */\n-  public boolean equals(Object o) {\n-    if (o == this) {\n+  public boolean equals(Object o)\n+  {\n+    if (o == this)\n       return true;\n-    } else if (o instanceof Set && ((Set)o).size() == size()) {\n-      return containsAll((Collection)o);\n-    } else {\n+    else if (o instanceof Set && ((Set) o).size() == size())\n+      return containsAll((Collection) o);\n+    else\n       return false;\n-    }\n   }\n \n   /**\n@@ -66,15 +67,17 @@ public boolean equals(Object o) {\n    *\n    * @return a hash code for this Set\n    */\n-  public int hashCode() {\n+  public int hashCode()\n+  {\n+    Iterator itr = iterator();\n+    int size = size();\n     int hash = 0;\n-    Iterator i = iterator();\n-    while (i.hasNext()) {\n-      try {\n-        hash += i.next().hashCode();\n-      } catch (NullPointerException e) {\n+    for (int pos = 0; pos < size; pos++)\n+      {\n+\tObject obj = itr.next();\n+\tif (obj != null)\n+\t  hash += obj.hashCode();\n       }\n-    }\n     return hash;\n   }\n }"}, {"sha": "75d4b406b668993eb7b982fd6434e3c8ddd40378", "filename": "libjava/java/util/ArrayList.java", "status": "modified", "additions": 180, "deletions": 248, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FArrayList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FArrayList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrayList.java?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -33,6 +33,8 @@\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream.GetField;\n+import java.io.ObjectOutputStream.PutField;\n import java.io.ObjectStreamField;\n \n /**\n@@ -41,34 +43,34 @@\n  * to or removing from the end of a list, checking the size, &c.\n  *\n  * @author        Jon A. Zeppieri\n- * @version       $Id: ArrayList.java,v 1.4 2000/03/15 21:59:06 rao Exp $\n+ * @version       $Id: ArrayList.java,v 1.6 2000/10/26 10:19:00 bryce Exp $\n  * @see           java.util.AbstractList\n  * @see           java.util.List\n  */\n-public class ArrayList extends AbstractList \n+public class ArrayList extends AbstractList\n   implements List, Cloneable, Serializable\n {\n   /** the default capacity for new ArrayLists */\n   private static final int DEFAULT_CAPACITY = 16;\n \n   /** the number of elements in this list */\n-  int _iSize;\n+  int size;\n \n   /** where the data is stored */\n-  Object[] _arData;\n+  Object[] data;\n \n   /** used for serialization -- denotes which fields are serialized */\n   private static final ObjectStreamField[] serialPersistentFields =\n-  {new ObjectStreamField(\"size\", int.class)};\n+    { new ObjectStreamField(\"size\", int.class) };\n \n   /** \n    * Construct a new ArrayList with the supplied initial capacity. \n    *\n-   * @param     iCapacity\n+   * @param capacity Initial capacity of this ArrayList\n    */\n-  public ArrayList(int iCapacity)\n+  public ArrayList(int capacity)\n   {\n-    _arData = new Object[iCapacity];\n+    data = new Object[capacity];\n   }\n \n \n@@ -85,68 +87,71 @@ public ArrayList()\n    * in the supplied Collection; Sun specs say that the initial \n    * capacity is 110% of the Collection's size.\n    *\n-   * @param        oCollection     the collection whose elements will\n-   *                               initialize this list\n+   * @param c the collection whose elements will initialize this list\n    */\n-  public ArrayList(Collection oCollection)\n+  public ArrayList(Collection c)\n   {\n-    this((int) (oCollection.size() * 1.1));\n-    addAll(oCollection);\n+    this((int) (c.size() * 1.1));\n+    addAll(c);\n   }\n \n   /**\n    * Guarantees that this list will have at least enough capacity to\n-   * hold iMinCapacity elements.\n+   * hold minCapacity elements. \n    *\n-   * @param      iMinCapacity     the minimum guaranteed capacity\n+   * @specnote This implementation will grow the list to \n+   *   max(current * 2, minCapacity) if (minCapacity > current). The JCL says\n+   *   explictly that \"this method increases its capacity to minCap\", while\n+   *   the JDK 1.3 online docs specify that the list will grow to at least the\n+   *   size specified.\n+   * @param minCapacity the minimum guaranteed capacity\n    */\n-  public void ensureCapacity(int iMinCapacity)\n+  public void ensureCapacity(int minCapacity)\n   {\n-    Object[] arNewData;\n-    int iCapacity = _arData.length;\n-\n-    if (iMinCapacity > iCapacity)\n-    {\n-      arNewData = new Object[Math.max((iCapacity * 2), iMinCapacity)];\n-      System.arraycopy(_arData, 0, arNewData, 0, iCapacity);\n-      _arData = arNewData;\n-    }\n+    Object[] newData;\n+    int current = data.length;\n+\n+    if (minCapacity > current)\n+      {\n+\tnewData = new Object[Math.max((current * 2), minCapacity)];\n+\tSystem.arraycopy(data, 0, newData, 0, size);\n+\tdata = newData;\n+      }\n   }\n \n   /**\n    * Appends the supplied element to the end of this list.\n    *\n-   * @param       oElement      the element to be appended to this list\n+   * @param       e      the element to be appended to this list\n    */\n-  public boolean add(Object oElement)\n+  public boolean add(Object e)\n   {\n-    ensureCapacity(_iSize + 1);\n-    _arData[_iSize++] = oElement;\n     modCount++;\n+    ensureCapacity(size + 1);\n+    data[size++] = e;\n     return true;\n   }\n \n   /**\n    * Retrieves the element at the user-supplied index.\n    *\n-   * @param    iIndex        the index of the element we are fetching\n+   * @param    index        the index of the element we are fetching\n    * @throws   IndexOutOfBoundsException  (iIndex < 0) || (iIndex >= size())\n    */\n-  public Object get(int iIndex)\n+  public Object get(int index)\n   {\n-    if (iIndex >= _iSize)\n-      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n-                                          String.valueOf(_iSize) + \"; \" +\n-                                          \"index=\" + String.valueOf(iIndex));\n-    return _arData[iIndex];\n+    if (index < 0 || index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    return data[index];\n   }\n \n   /**\n    * Returns the number of elements in this list \n    */\n   public int size()\n   {\n-    return _iSize;\n+    return size;\n   }\n \n   /**\n@@ -156,220 +161,166 @@ public int size()\n    * @return    the removed Object\n    * @throws    IndexOutOfBoundsException  (iIndex < 0) || (iIndex >= size())\n    */\n-  public Object remove(int iIndex)\n+  public Object remove(int index)\n   {\n-    Object oResult;\n-\n-    if (iIndex >= _iSize)\n-      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n-                                          String.valueOf(_iSize) + \"; \" +\n-                                          \"index=\" + String.valueOf(iIndex));\n-\n-    oResult = _arData[iIndex];\n-\n-    if (iIndex != --_iSize)\n-      System.arraycopy(_arData, (iIndex + 1), _arData, iIndex, \n-                       (_iSize - iIndex));\n-  \n     modCount++;\n-    _arData[_iSize] = null;\n-\n-    return oResult;\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    Object r = data[index];\n+    if (index != --size)\n+      System.arraycopy(data, (index + 1), data, index, (size - index));\n+    data[size] = null;\n+    return r;\n   }\n \n   /**\n    * Removes all elements in the half-open interval [iFromIndex, iToIndex).\n    *\n-   * @param     iFromIndex   the first index which will be removed\n-   * @param     iToIndex     one greater than the last index which will be \n+   * @param     fromIndex   the first index which will be removed\n+   * @param     toIndex     one greater than the last index which will be \n    *                         removed\n    */\n-  public void removeRange(int iFromIndex, int iToIndex)\n+  protected void removeRange(int fromIndex, int toIndex)\n   {\n-    int iReduction;\n-    int i;\n-\n-    if ((iFromIndex >= _iSize) || (iToIndex >= _iSize))\n-    {\n-      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n-                                          String.valueOf(_iSize) + \"; \" +\n-                                          \"indices=\" + \n-                                          String.valueOf(iFromIndex) + \",\" +\n-                                          String.valueOf(iToIndex));\n-    }\n-    else if (iFromIndex > iToIndex)\n-    {\n-      throw new IllegalArgumentException(\"fromIndex(\" + \n-                                         String.valueOf(iFromIndex) + \n-                                         \") > toIndex(\" +\n-                                         String.valueOf(iToIndex) + \")\");\n-    }\n-    else if (iFromIndex != iToIndex)\n-    {\n-      iReduction = iToIndex - iFromIndex;\n-      System.arraycopy(_arData, (iFromIndex + iReduction), _arData,\n-                       iFromIndex, (_iSize - iFromIndex - iReduction));\n-      modCount++;\n-\n-      for (i = (iFromIndex + iReduction); i < _iSize; i++)\n-        _arData[i] = null;\n-\n-      _iSize -= iReduction;\n-    }\n+    modCount++;\n+    if (fromIndex != toIndex)\n+      {\n+\tSystem.arraycopy(data, toIndex, data, fromIndex, size - toIndex);\n+\tsize -= (fromIndex - toIndex);\n+      }\n   }\n \n   /**\n    * Adds the supplied element at the specified index, shifting all\n    * elements currently at that index or higher one to the right.\n    *\n-   * @param     iIndex      the index at which the element is being added\n-   * @param     oElement    the element being added\n+   * @param     index      the index at which the element is being added\n+   * @param     e          the item being added\n    */\n-  public void add(int iIndex, Object oElement)\n+  public void add(int index, Object e)\n   {\n-    if (iIndex > _iSize)\n-      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n-                                          String.valueOf(_iSize) + \"; \" +\n-                                          \"index=\" + String.valueOf(iIndex));\n-\n-    ensureCapacity(_iSize + 1);\n-    System.arraycopy(_arData, iIndex, _arData, \n-                      (iIndex + 1), (_iSize - iIndex));\n-    _arData[iIndex] = oElement;\n-    _iSize++;\n     modCount++;\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    ensureCapacity(size + 1);\n+    if (index != size)\n+      System.arraycopy(data, index, data, index + 1, size - index);    \n+    data[index] = e;\n+    size++;\n   }\n \n   /** \n    * Add each element in the supplied Collection to this List.\n    *\n-   * @param        oCollection     a Collection containing elements to be \n-   *                               added to this List\n+   * @param        c          a Collection containing elements to be \n+   *                          added to this List\n    */\n-  public boolean addAll(Collection oCollection)\n+  public boolean addAll(Collection c)\n   {\n-    Iterator itElements;\n-    int iLen = oCollection.size();\n-\n-    if (iLen > 0)\n-    {\n-      ensureCapacity(_iSize + iLen);\n-      modCount++;\n-\n-      itElements = oCollection.iterator();\n-\n-      while (itElements.hasNext())\n-        _arData[_iSize++] = itElements.next();\n-\n-      return true;\n-    }\n-    return false;\n+    Iterator itr = c.iterator();\n+    int csize = c.size();\n+    modCount++;\n+    ensureCapacity(size + csize);\n+    for (int pos = 0; pos < csize; pos++)\n+      {\n+\tdata[size++] = itr.next();\n+      }\n+    return (csize > 0);\n   }\n \n   /** \n    * Add all elements in the supplied collection, inserting them beginning\n    * at the specified index.\n    *\n-   * @param     iIndex       the index at which the elements will be inserted\n-   * @param     oCollection  the Collection containing the elements to be\n-   *                         inserted\n+   * @param     index       the index at which the elements will be inserted\n+   * @param     c           the Collection containing the elements to be\n+   *                        inserted\n    */\n-  public boolean addAll(int iIndex, Collection oCollection)\n+  public boolean addAll(int index, Collection c)\n   {\n-    Iterator itElements;\n-    int iLen;\n-\n-    if (iIndex > _iSize)\n-      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n-                                          String.valueOf(_iSize) + \"; \" +\n-                                          \"index=\" + String.valueOf(iIndex));\n-\n-    iLen = oCollection.size();\n-\n-    if (iLen > 0)\n-    {\n-      ensureCapacity(_iSize + iLen);\n-\n-      System.arraycopy(_arData, iIndex, _arData, \n-                       (iIndex + iLen), (_iSize - iIndex));\n-      modCount++;\n-      _iSize += iLen;\n+    Iterator itr = c.iterator();\n+    int csize = c.size();\n \n-      itElements = oCollection.iterator();\n-      while (itElements.hasNext())\n-        _arData[iIndex++] = itElements.next();\n-\n-      return true;\n-   }\n-    return false;\n+    modCount++;\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    ensureCapacity(size + csize);\n+    int end = index + csize;\n+    if (size > 0 && index != size)\n+      System.arraycopy(data, index, data, end, csize);\n+    size += csize;\n+    for (; index < end; index++)\n+      {\n+        data[index] = itr.next();\n+      }\n+    return (csize > 0);\n   }\n \n   /**\n    * Creates a shallow copy of this ArrayList\n    */\n   public Object clone()\n   {\n-    ArrayList oClone;\n-\n+    ArrayList clone = null;\n     try\n-    {\n-      oClone = (ArrayList) super.clone();\n-      oClone._arData = _arData;\n-      oClone._iSize = _iSize;\n-    }\n-    catch(CloneNotSupportedException e)\n-    {\n-      oClone = null;\n-    }\n-    return oClone;\n+      {\n+\tclone = (ArrayList) super.clone();\n+\tclone.data = new Object[data.length];\n+\tSystem.arraycopy(data, 0, clone.data, 0, size);\n+      }\n+    catch (CloneNotSupportedException e) {}\n+    return clone;\n   }\n \n   /** \n    * Returns true iff oElement is in this ArrayList.\n    *\n-   * @param     oElement     the element whose inclusion in the List is being\n-   *                         tested\n+   * @param     e     the element whose inclusion in the List is being\n+   *                  tested\n    */\n-  public boolean contains(Object oElement)\n+  public boolean contains(Object e)\n   {\n-    return (indexOf(oElement) != -1);\n+    return (indexOf(e) != -1);\n   }\n \n   /**\n    * Returns the lowest index at which oElement appears in this List, or \n    * -1 if it does not appear.\n    *\n-   * @param    oElement       the element whose inclusion in the List is being\n-   *                          tested\n+   * @param    e       the element whose inclusion in the List is being\n+   *                   tested\n    */\n-  public int indexOf(Object oElement)\n+  public int indexOf(Object e)\n   {\n     int i;\n \n-    for (i = 0; i < _iSize; i++)\n-    {\n-      if (doesEqual(oElement, _arData[i]))\n-        return i;\n-    }\n+    for (i = 0; i < size; i++)\n+      {\n+\tif (e == null ? data[i] == null : e.equals(data[i]))\n+\t  return i;\n+      }\n     return -1;\n   }\n \n   /**\n    * Returns the highest index at which oElement appears in this List, or \n    * -1 if it does not appear.\n    *\n-   * @param    oElement       the element whose inclusion in the List is being\n-   *                          tested\n+   * @param    e       the element whose inclusion in the List is being\n+   *                   tested\n    */\n-  public int lastIndexOf(Object oElement)\n+  public int lastIndexOf(Object e)\n   {\n     int i;\n \n-    for (i = _iSize - 1; i >= 0; i--)\n-    {\n-      if (doesEqual(oElement, _arData[i]))\n-        return i;\n-    }\n+    for (i = size - 1; i >= 0; i--)\n+      {\n+\tif (e == null ? data[i] == null : e.equals(data[i]))\n+\t  return i;\n+      }\n     return -1;\n   }\n \n@@ -378,49 +329,38 @@ public int lastIndexOf(Object oElement)\n    */\n   public void clear()\n   {\n-    int i;\n-\n-    if (_iSize > 0)\n-    {\n-      modCount++;\n-      _iSize = 0;\n-\n-      for (i = 0; i < _iSize; i++)\n-        _arData[i] = null;\n-    }      \n+    modCount++;\n+    size = 0;\n   }\n \n   /**\n    * Sets the element at the specified index.\n    *\n-   * @param     iIndex     the index at which the element is being set\n-   * @param     oElement   the element to be set\n+   * @param     index   the index at which the element is being set\n+   * @param     e       the element to be set\n    * @return    the element previously at the specified index, or null if\n    *            none was there\n    */\n-  public Object set(int iIndex, Object oElement)\n+  public Object set(int index, Object e)\n   {\n-    Object oResult;\n-\n-    if (iIndex >= _iSize)\n-      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n-                                          String.valueOf(_iSize) + \"; \" +\n-                                          \"index=\" + String.valueOf(iIndex));\n-    oResult = _arData[iIndex];\n+    Object result;\n+    if (index < 0 || index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    result = data[index];\n     // SEH: no structural change, so don't update modCount\n-    _arData[iIndex] = oElement;\n-\n-    return oResult;\n+    data[index] = e;\n+    return result;\n   }\n \n   /**\n    * Returns an Object Array containing all of the elements in this ArrayList\n    */\n   public Object[] toArray()\n   {\n-    Object[] arObjects = new Object[_iSize];\n-    System.arraycopy(_arData, 0, arObjects, 0, _iSize);\n-    return arObjects;\n+    Object[] array = new Object[size];\n+    System.arraycopy(data, 0, array, 0, size);\n+    return array;\n   }\n \n   /**\n@@ -429,69 +369,61 @@ public Object[] toArray()\n    * elements in this ArrayList.  If the passed-in Array is not large enough\n    * to store all of the elements in this List, a new Array will be created \n    * and returned; if the passed-in Array is <i>larger</i> than the size\n-   * of this List, then size() + 1 index will be set to null.\n+   * of this List, then size() index will be set to null.\n    *\n-   * @param      arObjects      the passed-in Array\n+   * @param      array      the passed-in Array\n    */\n-  public Object[] toArray(Object[] arObjects)\n+  public Object[] toArray(Object[] array)\n   {\n-    Object[] arReturn = (arObjects.length >= _iSize)\n-      ? arObjects \n-      : (Object[])\n-      Array.newInstance(arObjects.getClass().getComponentType(), _iSize);\n-\n-    System.arraycopy(_arData, 0, arReturn, 0, _iSize);\n-\n-    if (arReturn.length > _iSize)\n-      arReturn[_iSize] = null;\n-\n-    return arReturn;\n+    if (array.length < size)\n+      array = (Object[]) Array.newInstance(array.getClass().getComponentType(), \n+        \t\t\t\t   size);\n+    else if (array.length > size)\n+      array[size] = null;\n+    System.arraycopy(data, 0, array, 0, size);\n+    return array;\n   }\n \n   /**\n-   * Trims the capacity of tjis List to be equal to its size; \n-   * a memory saver. \n+   * Trims the capacity of this List to be equal to its size; \n+   * a memory saver.   \n    */\n   public void trimToSize()\n   {\n-    Object[] arNewData = new Object[_iSize];\n-    System.arraycopy(_arData, 0, arNewData, 0, _iSize);\n-    modCount++;\n-    _arData = arNewData;\n+    // not a structural change from the perspective of iterators on this list, \n+    // so don't update modCount\n+    Object[] newData = new Object[size];\n+    System.arraycopy(data, 0, newData, 0, size);\n+    data = newData;\n   }\n \n-  private void writeObject(ObjectOutputStream oOut)\n-    throws IOException\n+  private void writeObject(ObjectOutputStream out) throws IOException\n   {\n     int i;\n \n-    ObjectOutputStream.PutField oFields = oOut.putFields();\n-    oFields.put(\"size\", _iSize);\n-    oOut.writeFields();\n+    ObjectOutputStream.PutField fields = out.putFields();\n+    fields.put(\"size\", size);\n+    out.writeFields();\n \n-    oOut.writeInt(_arData.length);\n-    for (i = 0; i < _arData.length; i++)\n-      oOut.writeObject(_arData[i]);\n+    // FIXME: Do we really want to serialize unused list entries??\n+    out.writeInt(data.length);\n+    for (i = 0; i < data.length; i++)\n+      out.writeObject(data[i]);\n   }\n \n-  private void readObject(ObjectInputStream oIn)\n+  private void readObject(ObjectInputStream in)\n     throws IOException, ClassNotFoundException\n   {\n     int i;\n-    int iCapacity;\n-\n-    ObjectInputStream.GetField oFields = oIn.readFields();\n-    _iSize = oFields.get(\"size\", 0);\n+    int capacity;\n \n-    iCapacity = oIn.readInt();\n-    _arData = new Object[iCapacity];\n+    ObjectInputStream.GetField fields = in.readFields();\n+    size = fields.get(\"size\", 0);\n \n-    for (i = 0; i < iCapacity; i++)\n-      _arData[i] = oIn.readObject();\n-  }\n+    capacity = in.readInt();\n+    data = new Object[capacity];\n \n-  private static final boolean doesEqual(Object oOne, Object oTwo)\n-  {\n-    return ((oOne == null) ? (oTwo == null) : oOne.equals(oTwo));\n+    for (i = 0; i < capacity; i++)\n+      data[i] = in.readObject();\n   }\n }"}, {"sha": "5a2dd44e6f961a0f8a1c4ed8ed476ffc5c6ab5ee", "filename": "libjava/java/util/BitSet.java", "status": "modified", "additions": 220, "deletions": 22, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FBitSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a73757880cde4912de947d746e2fea7a4bbd0e8/libjava%2Fjava%2Futil%2FBitSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBitSet.java?ref=3a73757880cde4912de947d746e2fea7a4bbd0e8", "patch": "@@ -2,7 +2,7 @@\n \n /* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n-This file is part of libgcj.\n+   This file is part of libgcj.\n \n This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n@@ -11,32 +11,64 @@\n package java.util;\n import java.io.Serializable;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date October 23, 1998.\n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * hashCode algorithm taken from JDK 1.2 docs.\n  */\n \n+/**\n+ * This class can be thought of in two ways.  You can see it as a\n+ * vector of bits or as a set of non-negative integers.  The name\n+ * <code>BitSet</code> is a bit misleading.\n+ *\n+ * It is implemented by a bit vector, but its equally possible to see\n+ * it as set of non-negative integer; each integer in the set is\n+ * represented by a set bit at the corresponding index.  The size of\n+ * this structure is determined by the highest integer in the set.\n+ *\n+ * You can union, intersect and build (symmetric) remainders, by\n+ * invoking the logical operations and, or, andNot, resp. xor.\n+ *\n+ * This implementation is NOT synchronized against concurrent access from\n+ * multiple threads. Specifically, if one thread is reading from a bitset\n+ * while another thread is simultaneously modifying it, the results are\n+ * undefined.\n+ *\n+ * @specnote There is some confusion as to whether or not this class should\n+ *           be synchronized. JDK 1.1 javadocs explicitly state that the \n+ *           class is NOT synchronized, however the code listed in the JDK 1.3\n+ *           javadoc for the hashCode() method implies that it is. It is not\n+ *           stated elsewhere in the 1.2 javadoc that the class is \n+ *           synchronized, unlike Hashtable and Vector. From an efficiency \n+ *           perspective, it is very undesirable to synchronize this class\n+ *           because multiple locks and explicit lock ordering are required\n+ *           to safely synchronize some methods. For this reason we're going\n+ *           with the unsynchronized implementation unless the specs are \n+ *           changed to explicitly say otherwise.\n+ *\n+ * @author Jochen Hoenicke\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 23, 1998.\n+ * @status API complete to JDK 1.3.\n+ */\n public final class BitSet implements Cloneable, Serializable\n {\n-  public void and(BitSet bs)\n-  {\n-    int max = Math.min(bits.length, bs.bits.length);\n-    int i;\n-    for (i = 0; i < max; ++i)\n-      bits[i] &= bs.bits[i];\n-    for (; i < bits.length; ++i)\n-      bits[i] = 0;\n-  }\n-\n+  /**\n+   * Create a new empty bit set.\n+   */\n   public BitSet()\n   {\n     this(64);\n   }\n \n+  /**\n+   * Create a new empty bit set, with a given size.  This\n+   * constructor reserves enough space to represent the integers\n+   * from <code>0</code> to <code>nbits-1</code>.  \n+   * @param nbits the initial size of the bit set.\n+   * @throws NegativeArraySizeException if the specified initial\n+   * size is negative.  \n+   * @require nbits >= 0\n+   */\n   public BitSet(int nbits)\n   {\n     if (nbits < 0)\n@@ -47,6 +79,49 @@ public BitSet(int nbits)\n     bits = new long[length];\n   }\n \n+  /**\n+   * Performs the logical AND operation on this bit set and the\n+   * given <code>set</code>.  This means it builds the intersection\n+   * of the two sets.  The result is stored into this bit set.\n+   * @param set the second bit set.\n+   * @require set != null\n+   */\n+  public void and(BitSet bs)\n+  {\n+    int max = Math.min(bits.length, bs.bits.length);\n+    int i;\n+    for (i = 0; i < max; ++i)\n+      bits[i] &= bs.bits[i];\n+    for (; i < bits.length; ++i)\n+      bits[i] = 0;\n+  }\n+\n+  /**\n+   * Performs the logical AND operation on this bit set and the\n+   * complement of the given <code>set</code>.  This means it\n+   * selects every element in the first set, that isn't in the\n+   * second set.  The result is stored into this bit set.  \n+   * @param set the second bit set.  \n+   * @require set != null\n+   * @since JDK1.2\n+   */\n+  public void andNot(BitSet bs)\n+  {\n+    int max = Math.min(bits.length, bs.bits.length);\n+    int i;\n+    for (i = 0; i < max; ++i)\n+      bits[i] &= ~bs.bits[i];\n+  }\n+\n+  /**\n+   * Removes the integer <code>bitIndex</code> from this set. That is\n+   * the corresponding bit is cleared.  If the index is not in the set,\n+   * this method does nothing.\n+   * @param bitIndex a non-negative integer.\n+   * @exception ArrayIndexOutOfBoundsException if the specified bit index\n+   * is negative.\n+   * @require bitIndex >= 0\n+   */\n   public void clear(int pos)\n   {\n     if (pos < 0)\n@@ -57,13 +132,24 @@ public void clear(int pos)\n     bits[offset] &= ~(1L << bit);\n   }\n \n+  /**\n+   * Create a clone of this bit set, that is an instance of the same\n+   * class and contains the same elements.  But it doesn't change when\n+   * this bit set changes.\n+   * @return the clone of this object.\n+   */\n   public Object clone()\n   {\n     BitSet bs = new BitSet(bits.length * 64);\n     System.arraycopy(bits, 0, bs.bits, 0, bits.length);\n     return bs;\n   }\n \n+  /**\n+   * Returns true if the <code>obj</code> is a bit set that contains\n+   * exactly the same elements as this bit set, otherwise false.\n+   * @return true if obj equals this bit set.\n+   */\n   public boolean equals(Object obj)\n   {\n     if (!(obj instanceof BitSet))\n@@ -84,6 +170,15 @@ public boolean equals(Object obj)\n     return true;\n   }\n \n+  /**\n+   * Returns true if the integer <code>bitIndex</code> is in this bit\n+   * set, otherwise false.\n+   * @param bitIndex a non-negative integer\n+   * @return the value of the bit at the specified index.\n+   * @exception ArrayIndexOutOfBoundsException if the specified bit index\n+   * is negative.\n+   * @require bitIndex >= 0\n+   */\n   public boolean get(int pos)\n   {\n     if (pos < 0)\n@@ -98,6 +193,36 @@ public boolean get(int pos)\n     return (bits[offset] & (1L << bit)) == 0 ? false : true;\n   }\n \n+  /**\n+   * Returns a hash code value for this bit set.  The hash code of \n+   * two bit sets containing the same integers is identical.  The algorithm\n+   * used to compute it is as follows:\n+   *\n+   * Suppose the bits in the BitSet were to be stored in an array of\n+   * long integers called <code>bits</code>, in such a manner that\n+   * bit <code>k</code> is set in the BitSet (for non-negative values\n+   * of <code>k</code>) if and only if\n+   *\n+   * <pre>\n+   * ((k/64) < bits.length) && ((bits[k/64] & (1L << (bit % 64))) != 0)\n+   * </pre>\n+   *\n+   * Then the following definition of the hashCode method\n+   * would be a correct implementation of the actual algorithm:\n+   *\n+   * <pre>\n+   * public int hashCode() {\n+   *     long h = 1234;\n+   *     for (int i = bits.length-1; i>=0; i--) {\n+   *         h ^= bits[i] * (i + 1);\n+   *     }\n+   *     return (int)((h >> 32) ^ h);\n+   * }\n+   * </pre>\n+   *\n+   * Note that the hash code values changes, if the set is changed.\n+   * @return the hash code value for this bit set.\n+   */\n   public int hashCode()\n   {\n     long h = 1234;\n@@ -106,6 +231,45 @@ public int hashCode()\n     return (int) ((h >> 32) ^ h);\n   }\n \n+  /**\n+   * Returns the logical number of bits actually used by this bit\n+   * set.  It returns the index of the highest set bit plus one.\n+   * Note that this method doesn't return the number of set bits.\n+   * @return the index of the highest set bit plus one.  \n+   */\n+  public int length()\n+  {\n+    // Set i to highest index that contains a non-zero value.\n+    int i;\n+    for (i = bits.length - 1; i >= 0 && bits[i] == 0; --i)\n+      ;\n+\n+    // if i < 0 all bits are cleared.\n+    if (i < 0)\n+      return 0;\n+\n+    // Now determine the exact length.\n+    long b = bits[i];\n+    int len = (i + 1) * 64;\n+    // b >= 0 checks if the highest bit is zero.\n+    while (b >= 0)\n+      {\n+\t--len;\n+\tb <<= 1;\n+      }\n+\n+    return len;\n+  }\n+\n+  /**\n+   * Performs the logical OR operation on this bit set and the\n+   * given <code>set</code>.  This means it builds the union\n+   * of the two sets.  The result is stored into this bit set, which\n+   * grows as necessary.\n+   * @param set the second bit set.\n+   * @exception OutOfMemoryError if the current set can't grow.\n+   * @require set != null\n+   */\n   public void or(BitSet bs)\n   {\n     ensure(bs.bits.length - 1);\n@@ -114,6 +278,16 @@ public void or(BitSet bs)\n       bits[i] |= bs.bits[i];\n   }\n \n+  /**\n+   * Add the integer <code>bitIndex</code> to this set.  That is \n+   * the corresponding bit is set to true.  If the index was already in\n+   * the set, this method does nothing.  The size of this structure\n+   * is automatically increased as necessary.\n+   * @param bitIndex a non-negative integer.\n+   * @exception ArrayIndexOutOfBoundsException if the specified bit index\n+   * is negative.\n+   * @require bitIndex >= 0\n+   */\n   public void set(int pos)\n   {\n     if (pos < 0)\n@@ -124,35 +298,58 @@ public void set(int pos)\n     bits[offset] |= 1L << bit;\n   }\n \n+  /**\n+   * Returns the number of bits actually used by this bit set.  Note\n+   * that this method doesn't return the number of set bits.\n+   * @returns the number of bits currently used.  \n+   */\n   public int size()\n   {\n     return bits.length * 64;\n   }\n \n+  /**\n+   * Returns the string representation of this bit set.  This\n+   * consists of a comma separated list of the integers in this set\n+   * surrounded by curly braces.  There is a space after each comma.\n+   * @return the string representation.\n+   */\n   public String toString()\n   {\n-    StringBuffer result = new StringBuffer(\"{\");\n+    String r = \"{\";\n     boolean first = true;\n     for (int i = 0; i < bits.length; ++i)\n       {\n-\tint bit = 1;\n+\tlong bit = 1;\n \tlong word = bits[i];\n+\tif (word == 0)\n+\t  continue;\n \tfor (int j = 0; j < 64; ++j)\n \t  {\n \t    if ((word & bit) != 0)\n \t      {\n \t\tif (!first)\n-\t\t  result.append(\", \");\n-\t\tresult.append(64 * i + j);\n+\t\t  r += \", \";\n+\t\tr += Integer.toString(64 * i + j);\n \t\tfirst = false;\n \t      }\n \t    bit <<= 1;\n \t  }\n       }\n \n-    return result.append(\"}\").toString();\n+    return r += \"}\";\n   }\n \n+  /**\n+   * Performs the logical XOR operation on this bit set and the\n+   * given <code>set</code>.  This means it builds the symmetric\n+   * remainder of the two sets (the elements that are in one set,\n+   * but not in the other).  The result is stored into this bit set,\n+   * which grows as necessary.  \n+   * @param set the second bit set.\n+   * @exception OutOfMemoryError if the current set can't grow.  \n+   * @require set != null\n+   */\n   public void xor(BitSet bs)\n   {\n     ensure(bs.bits.length - 1);\n@@ -173,6 +370,7 @@ private final void ensure(int lastElt)\n   }\n \n   // The actual bits.\n-  private long[] bits;\n+  long[] bits;\n+\n   private static final long serialVersionUID = 7997698588986878753L;\n }"}]}