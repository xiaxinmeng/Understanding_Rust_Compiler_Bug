{"sha": "77059241d8049bd7626ce216caf0313a2fa964c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcwNTkyNDFkODA0OWJkNzYyNmNlMjE2Y2FmMDMxM2EyZmE5NjRjMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-04-12T12:51:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-04-12T12:51:10Z"}, "message": "genpreds.c (process_define_predicate): Move most processing to gensupport.c.\n\ngcc/\n\t* genpreds.c (process_define_predicate): Move most processing\n\tto gensupport.c.  Continue to validate the expression.\n\t* genrecog.c (did_you_mean_codes, compute_predicate_codes)\n\t(process_define_predicate): Move processing to gensupport.c.\n\t(main): Remove DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE cases.\n\t* gensupport.c (did_you_mean_codes): Moved from genrecog.c.\n\t(compute_predicate_codes): Moved from genrecog.c.  Add lineno\n\targument.\n\t(valid_predicate_name_p): New function, split out from old\n\tgenpreds.c:process_define_predicate.\n\t(process_define_predicate): New function, combining code from\n\told genpreds.c and genrecog.c functions.\n\t(process_rtx): Call it for DEFINE_PREDICATE and\n\tDEFINE_SPECIAL_PREDICATE.\n\nFrom-SVN: r172315", "tree": {"sha": "c16e8997e9a9118ec5c396648da48b7cba99bbb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c16e8997e9a9118ec5c396648da48b7cba99bbb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77059241d8049bd7626ce216caf0313a2fa964c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77059241d8049bd7626ce216caf0313a2fa964c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77059241d8049bd7626ce216caf0313a2fa964c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77059241d8049bd7626ce216caf0313a2fa964c2/comments", "author": null, "committer": null, "parents": [{"sha": "6308e208c21b6c31a4ed5e89dd02dd5880c3e346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6308e208c21b6c31a4ed5e89dd02dd5880c3e346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6308e208c21b6c31a4ed5e89dd02dd5880c3e346"}], "stats": {"total": 508, "additions": 262, "deletions": 246}, "files": [{"sha": "c95d8935625066673126c71a7b3693e7377df6e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77059241d8049bd7626ce216caf0313a2fa964c2", "patch": "@@ -1,3 +1,20 @@\n+2011-04-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* genpreds.c (process_define_predicate): Move most processing\n+\tto gensupport.c.  Continue to validate the expression.\n+\t* genrecog.c (did_you_mean_codes, compute_predicate_codes)\n+\t(process_define_predicate): Move processing to gensupport.c.\n+\t(main): Remove DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE cases.\n+\t* gensupport.c (did_you_mean_codes): Moved from genrecog.c.\n+\t(compute_predicate_codes): Moved from genrecog.c.  Add lineno\n+\targument.\n+\t(valid_predicate_name_p): New function, split out from old\n+\tgenpreds.c:process_define_predicate.\n+\t(process_define_predicate): New function, combining code from\n+\told genpreds.c and genrecog.c functions.\n+\t(process_rtx): Call it for DEFINE_PREDICATE and\n+\tDEFINE_SPECIAL_PREDICATE.\n+\n 2011-04-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/arm/arm.c (arm_print_operand): Use MEM_SIZE to get the"}, {"sha": "de913491469cbcd2e59461f4bbcad328d7eab721", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=77059241d8049bd7626ce216caf0313a2fa964c2", "patch": "@@ -93,34 +93,7 @@ validate_exp (rtx exp, const char *name, int lineno)\n static void\n process_define_predicate (rtx defn, int lineno)\n {\n-  struct pred_data *pred;\n-  const char *p;\n-\n-  if (!ISALPHA (XSTR (defn, 0)[0]) && XSTR (defn, 0)[0] != '_')\n-    goto bad_name;\n-  for (p = XSTR (defn, 0) + 1; *p; p++)\n-    if (!ISALNUM (*p) && *p != '_')\n-      goto bad_name;\n-\n-  if (validate_exp (XEXP (defn, 1), XSTR (defn, 0), lineno))\n-    return;\n-\n-  pred = XCNEW (struct pred_data);\n-  pred->name = XSTR (defn, 0);\n-  pred->exp = XEXP (defn, 1);\n-  pred->c_block = XSTR (defn, 2);\n-\n-  if (GET_CODE (defn) == DEFINE_SPECIAL_PREDICATE)\n-    pred->special = true;\n-\n-  add_predicate (pred);\n-  return;\n-\n- bad_name:\n-  error_with_line (lineno,\n-\t\t   \"%s: predicate name must be a valid C function name\",\n-\t\t   XSTR (defn, 0));\n-  return;\n+  validate_exp (XEXP (defn, 1), XSTR (defn, 0), lineno);\n }\n \n /* Given a predicate, if it has an embedded C block, write the block"}, {"sha": "824cf75f3354a946e452c2500cbdd2ce58ad9394", "filename": "gcc/genrecog.c", "status": "modified", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=77059241d8049bd7626ce216caf0313a2fa964c2", "patch": "@@ -170,219 +170,6 @@ static int max_depth;\n \n /* The line number of the start of the pattern currently being processed.  */\n static int pattern_lineno;\n-\f\n-/* Predicate handling.\n-\n-   We construct from the machine description a table mapping each\n-   predicate to a list of the rtl codes it can possibly match.  The\n-   function 'maybe_both_true' uses it to deduce that there are no\n-   expressions that can be matches by certain pairs of tree nodes.\n-   Also, if a predicate can match only one code, we can hardwire that\n-   code into the node testing the predicate.\n-\n-   Some predicates are flagged as special.  validate_pattern will not\n-   warn about modeless match_operand expressions if they have a\n-   special predicate.  Predicates that allow only constants are also\n-   treated as special, for this purpose.\n-\n-   validate_pattern will warn about predicates that allow non-lvalues\n-   when they appear in destination operands.\n-\n-   Calculating the set of rtx codes that can possibly be accepted by a\n-   predicate expression EXP requires a three-state logic: any given\n-   subexpression may definitively accept a code C (Y), definitively\n-   reject a code C (N), or may have an indeterminate effect (I).  N\n-   and I is N; Y or I is Y; Y and I, N or I are both I.  Here are full\n-   truth tables.\n-\n-     a b  a&b  a|b\n-     Y Y   Y    Y\n-     N Y   N    Y\n-     N N   N    N\n-     I Y   I    Y\n-     I N   N    I\n-     I I   I    I\n-\n-   We represent Y with 1, N with 0, I with 2.  If any code is left in\n-   an I state by the complete expression, we must assume that that\n-   code can be accepted.  */\n-\n-#define N 0\n-#define Y 1\n-#define I 2\n-\n-#define TRISTATE_AND(a,b)\t\t\t\\\n-  ((a) == I ? ((b) == N ? N : I) :\t\t\\\n-   (b) == I ? ((a) == N ? N : I) :\t\t\\\n-   (a) && (b))\n-\n-#define TRISTATE_OR(a,b)\t\t\t\\\n-  ((a) == I ? ((b) == Y ? Y : I) :\t\t\\\n-   (b) == I ? ((a) == Y ? Y : I) :\t\t\\\n-   (a) || (b))\n-\n-#define TRISTATE_NOT(a)\t\t\t\t\\\n-  ((a) == I ? I : !(a))\n-\n-/* 0 means no warning about that code yet, 1 means warned.  */\n-static char did_you_mean_codes[NUM_RTX_CODE];\n-\n-/* Recursively calculate the set of rtx codes accepted by the\n-   predicate expression EXP, writing the result to CODES.  */\n-static void\n-compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n-{\n-  char op0_codes[NUM_RTX_CODE];\n-  char op1_codes[NUM_RTX_CODE];\n-  char op2_codes[NUM_RTX_CODE];\n-  int i;\n-\n-  switch (GET_CODE (exp))\n-    {\n-    case AND:\n-      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n-      compute_predicate_codes (XEXP (exp, 1), op1_codes);\n-      for (i = 0; i < NUM_RTX_CODE; i++)\n-\tcodes[i] = TRISTATE_AND (op0_codes[i], op1_codes[i]);\n-      break;\n-\n-    case IOR:\n-      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n-      compute_predicate_codes (XEXP (exp, 1), op1_codes);\n-      for (i = 0; i < NUM_RTX_CODE; i++)\n-\tcodes[i] = TRISTATE_OR (op0_codes[i], op1_codes[i]);\n-      break;\n-    case NOT:\n-      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n-      for (i = 0; i < NUM_RTX_CODE; i++)\n-\tcodes[i] = TRISTATE_NOT (op0_codes[i]);\n-      break;\n-\n-    case IF_THEN_ELSE:\n-      /* a ? b : c  accepts the same codes as (a & b) | (!a & c).  */\n-      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n-      compute_predicate_codes (XEXP (exp, 1), op1_codes);\n-      compute_predicate_codes (XEXP (exp, 2), op2_codes);\n-      for (i = 0; i < NUM_RTX_CODE; i++)\n-\tcodes[i] = TRISTATE_OR (TRISTATE_AND (op0_codes[i], op1_codes[i]),\n-\t\t\t\tTRISTATE_AND (TRISTATE_NOT (op0_codes[i]),\n-\t\t\t\t\t      op2_codes[i]));\n-      break;\n-\n-    case MATCH_CODE:\n-      /* MATCH_CODE allows a specified list of codes.  However, if it\n-\t does not apply to the top level of the expression, it does not\n-\t constrain the set of codes for the top level.  */\n-      if (XSTR (exp, 1)[0] != '\\0')\n-\t{\n-\t  memset (codes, Y, NUM_RTX_CODE);\n-\t  break;\n-\t}\n-\n-      memset (codes, N, NUM_RTX_CODE);\n-      {\n-\tconst char *next_code = XSTR (exp, 0);\n-\tconst char *code;\n-\n-\tif (*next_code == '\\0')\n-\t  {\n-\t    error_with_line (pattern_lineno, \"empty match_code expression\");\n-\t    break;\n-\t  }\n-\n-\twhile ((code = scan_comma_elt (&next_code)) != 0)\n-\t  {\n-\t    size_t n = next_code - code;\n-\t    int found_it = 0;\n-\n-\t    for (i = 0; i < NUM_RTX_CODE; i++)\n-\t      if (!strncmp (code, GET_RTX_NAME (i), n)\n-\t\t  && GET_RTX_NAME (i)[n] == '\\0')\n-\t\t{\n-\t\t  codes[i] = Y;\n-\t\t  found_it = 1;\n-\t\t  break;\n-\t\t}\n-\t    if (!found_it)\n-\t      {\n-\t\terror_with_line (pattern_lineno,\n-\t\t\t\t \"match_code \\\"%.*s\\\" matches nothing\",\n-\t\t\t\t (int) n, code);\n-\t\tfor (i = 0; i < NUM_RTX_CODE; i++)\n-\t\t  if (!strncasecmp (code, GET_RTX_NAME (i), n)\n-\t\t      && GET_RTX_NAME (i)[n] == '\\0'\n-\t\t      && !did_you_mean_codes[i])\n-\t\t    {\n-\t\t      did_you_mean_codes[i] = 1;\n-\t\t      message_with_line (pattern_lineno, \"(did you mean \\\"%s\\\"?)\", GET_RTX_NAME (i));\n-\t\t    }\n-\t      }\n-\n-\t  }\n-      }\n-      break;\n-\n-    case MATCH_OPERAND:\n-      /* MATCH_OPERAND disallows the set of codes that the named predicate\n-\t disallows, and is indeterminate for the codes that it does allow.  */\n-      {\n-\tstruct pred_data *p = lookup_predicate (XSTR (exp, 1));\n-\tif (!p)\n-\t  {\n-\t    error_with_line (pattern_lineno,\n-\t\t\t     \"reference to unknown predicate '%s'\",\n-\t\t\t     XSTR (exp, 1));\n-\t    break;\n-\t  }\n-\tfor (i = 0; i < NUM_RTX_CODE; i++)\n-\t  codes[i] = p->codes[i] ? I : N;\n-      }\n-      break;\n-\n-\n-    case MATCH_TEST:\n-      /* (match_test WHATEVER) is completely indeterminate.  */\n-      memset (codes, I, NUM_RTX_CODE);\n-      break;\n-\n-    default:\n-      error_with_line (pattern_lineno,\n-\t\t       \"'%s' cannot be used in a define_predicate expression\",\n-\t\t       GET_RTX_NAME (GET_CODE (exp)));\n-      memset (codes, I, NUM_RTX_CODE);\n-      break;\n-    }\n-}\n-\n-#undef TRISTATE_OR\n-#undef TRISTATE_AND\n-#undef TRISTATE_NOT\n-\n-/* Process a define_predicate expression: compute the set of predicates\n-   that can be matched, and record this as a known predicate.  */\n-static void\n-process_define_predicate (rtx desc)\n-{\n-  struct pred_data *pred = XCNEW (struct pred_data);\n-  char codes[NUM_RTX_CODE];\n-  int i;\n-\n-  pred->name = XSTR (desc, 0);\n-  if (GET_CODE (desc) == DEFINE_SPECIAL_PREDICATE)\n-    pred->special = 1;\n-\n-  compute_predicate_codes (XEXP (desc, 1), codes);\n-\n-  for (i = 0; i < NUM_RTX_CODE; i++)\n-    if (codes[i] != N)\n-      add_predicate_code (pred, (enum rtx_code) i);\n-\n-  add_predicate (pred);\n-}\n-#undef I\n-#undef N\n-#undef Y\n-\n \f\n static struct decision *new_decision\n   (const char *, struct decision_head *);\n@@ -2716,11 +2503,6 @@ main (int argc, char **argv)\n \n       switch (GET_CODE (desc))\n \t{\n-\tcase DEFINE_PREDICATE:\n-\tcase DEFINE_SPECIAL_PREDICATE:\n-\t  process_define_predicate (desc);\n-\t  break;\n-\n \tcase DEFINE_INSN:\n \t  h = make_insn_sequence (desc, RECOG);\n \t  merge_trees (&recog_tree, &h);"}, {"sha": "d2c2f7157297a99cb7c75143bab40271decdc7bd", "filename": "gcc/gensupport.c", "status": "modified", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77059241d8049bd7626ce216caf0313a2fa964c2/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=77059241d8049bd7626ce216caf0313a2fa964c2", "patch": "@@ -109,6 +109,247 @@ gen_rtx_CONST_INT (enum machine_mode ARG_UNUSED (mode),\n   return rt;\n }\n \f\n+/* Predicate handling.\n+\n+   We construct from the machine description a table mapping each\n+   predicate to a list of the rtl codes it can possibly match.  The\n+   function 'maybe_both_true' uses it to deduce that there are no\n+   expressions that can be matches by certain pairs of tree nodes.\n+   Also, if a predicate can match only one code, we can hardwire that\n+   code into the node testing the predicate.\n+\n+   Some predicates are flagged as special.  validate_pattern will not\n+   warn about modeless match_operand expressions if they have a\n+   special predicate.  Predicates that allow only constants are also\n+   treated as special, for this purpose.\n+\n+   validate_pattern will warn about predicates that allow non-lvalues\n+   when they appear in destination operands.\n+\n+   Calculating the set of rtx codes that can possibly be accepted by a\n+   predicate expression EXP requires a three-state logic: any given\n+   subexpression may definitively accept a code C (Y), definitively\n+   reject a code C (N), or may have an indeterminate effect (I).  N\n+   and I is N; Y or I is Y; Y and I, N or I are both I.  Here are full\n+   truth tables.\n+\n+     a b  a&b  a|b\n+     Y Y   Y    Y\n+     N Y   N    Y\n+     N N   N    N\n+     I Y   I    Y\n+     I N   N    I\n+     I I   I    I\n+\n+   We represent Y with 1, N with 0, I with 2.  If any code is left in\n+   an I state by the complete expression, we must assume that that\n+   code can be accepted.  */\n+\n+#define N 0\n+#define Y 1\n+#define I 2\n+\n+#define TRISTATE_AND(a,b)\t\t\t\\\n+  ((a) == I ? ((b) == N ? N : I) :\t\t\\\n+   (b) == I ? ((a) == N ? N : I) :\t\t\\\n+   (a) && (b))\n+\n+#define TRISTATE_OR(a,b)\t\t\t\\\n+  ((a) == I ? ((b) == Y ? Y : I) :\t\t\\\n+   (b) == I ? ((a) == Y ? Y : I) :\t\t\\\n+   (a) || (b))\n+\n+#define TRISTATE_NOT(a)\t\t\t\t\\\n+  ((a) == I ? I : !(a))\n+\n+/* 0 means no warning about that code yet, 1 means warned.  */\n+static char did_you_mean_codes[NUM_RTX_CODE];\n+\n+/* Recursively calculate the set of rtx codes accepted by the\n+   predicate expression EXP, writing the result to CODES.  LINENO is\n+   the line number on which the directive containing EXP appeared.  */\n+\n+static void\n+compute_predicate_codes (rtx exp, int lineno, char codes[NUM_RTX_CODE])\n+{\n+  char op0_codes[NUM_RTX_CODE];\n+  char op1_codes[NUM_RTX_CODE];\n+  char op2_codes[NUM_RTX_CODE];\n+  int i;\n+\n+  switch (GET_CODE (exp))\n+    {\n+    case AND:\n+      compute_predicate_codes (XEXP (exp, 0), lineno, op0_codes);\n+      compute_predicate_codes (XEXP (exp, 1), lineno, op1_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_AND (op0_codes[i], op1_codes[i]);\n+      break;\n+\n+    case IOR:\n+      compute_predicate_codes (XEXP (exp, 0), lineno, op0_codes);\n+      compute_predicate_codes (XEXP (exp, 1), lineno, op1_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_OR (op0_codes[i], op1_codes[i]);\n+      break;\n+    case NOT:\n+      compute_predicate_codes (XEXP (exp, 0), lineno, op0_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_NOT (op0_codes[i]);\n+      break;\n+\n+    case IF_THEN_ELSE:\n+      /* a ? b : c  accepts the same codes as (a & b) | (!a & c).  */\n+      compute_predicate_codes (XEXP (exp, 0), lineno, op0_codes);\n+      compute_predicate_codes (XEXP (exp, 1), lineno, op1_codes);\n+      compute_predicate_codes (XEXP (exp, 2), lineno, op2_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_OR (TRISTATE_AND (op0_codes[i], op1_codes[i]),\n+\t\t\t\tTRISTATE_AND (TRISTATE_NOT (op0_codes[i]),\n+\t\t\t\t\t      op2_codes[i]));\n+      break;\n+\n+    case MATCH_CODE:\n+      /* MATCH_CODE allows a specified list of codes.  However, if it\n+\t does not apply to the top level of the expression, it does not\n+\t constrain the set of codes for the top level.  */\n+      if (XSTR (exp, 1)[0] != '\\0')\n+\t{\n+\t  memset (codes, Y, NUM_RTX_CODE);\n+\t  break;\n+\t}\n+\n+      memset (codes, N, NUM_RTX_CODE);\n+      {\n+\tconst char *next_code = XSTR (exp, 0);\n+\tconst char *code;\n+\n+\tif (*next_code == '\\0')\n+\t  {\n+\t    error_with_line (lineno, \"empty match_code expression\");\n+\t    break;\n+\t  }\n+\n+\twhile ((code = scan_comma_elt (&next_code)) != 0)\n+\t  {\n+\t    size_t n = next_code - code;\n+\t    int found_it = 0;\n+\n+\t    for (i = 0; i < NUM_RTX_CODE; i++)\n+\t      if (!strncmp (code, GET_RTX_NAME (i), n)\n+\t\t  && GET_RTX_NAME (i)[n] == '\\0')\n+\t\t{\n+\t\t  codes[i] = Y;\n+\t\t  found_it = 1;\n+\t\t  break;\n+\t\t}\n+\t    if (!found_it)\n+\t      {\n+\t\terror_with_line (lineno,\n+\t\t\t\t \"match_code \\\"%.*s\\\" matches nothing\",\n+\t\t\t\t (int) n, code);\n+\t\tfor (i = 0; i < NUM_RTX_CODE; i++)\n+\t\t  if (!strncasecmp (code, GET_RTX_NAME (i), n)\n+\t\t      && GET_RTX_NAME (i)[n] == '\\0'\n+\t\t      && !did_you_mean_codes[i])\n+\t\t    {\n+\t\t      did_you_mean_codes[i] = 1;\n+\t\t      message_with_line (lineno, \"(did you mean \\\"%s\\\"?)\",\n+\t\t\t\t\t GET_RTX_NAME (i));\n+\t\t    }\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case MATCH_OPERAND:\n+      /* MATCH_OPERAND disallows the set of codes that the named predicate\n+\t disallows, and is indeterminate for the codes that it does allow.  */\n+      {\n+\tstruct pred_data *p = lookup_predicate (XSTR (exp, 1));\n+\tif (!p)\n+\t  {\n+\t    error_with_line (lineno, \"reference to unknown predicate '%s'\",\n+\t\t\t     XSTR (exp, 1));\n+\t    break;\n+\t  }\n+\tfor (i = 0; i < NUM_RTX_CODE; i++)\n+\t  codes[i] = p->codes[i] ? I : N;\n+      }\n+      break;\n+\n+\n+    case MATCH_TEST:\n+      /* (match_test WHATEVER) is completely indeterminate.  */\n+      memset (codes, I, NUM_RTX_CODE);\n+      break;\n+\n+    default:\n+      error_with_line (lineno,\n+\t\t       \"'%s' cannot be used in a define_predicate expression\",\n+\t\t       GET_RTX_NAME (GET_CODE (exp)));\n+      memset (codes, I, NUM_RTX_CODE);\n+      break;\n+    }\n+}\n+\n+#undef TRISTATE_OR\n+#undef TRISTATE_AND\n+#undef TRISTATE_NOT\n+\n+/* Return true if NAME is a valid predicate name.  */\n+\n+static bool\n+valid_predicate_name_p (const char *name)\n+{\n+  const char *p;\n+\n+  if (!ISALPHA (name[0]) && name[0] != '_')\n+    return false;\n+  for (p = name + 1; *p; p++)\n+    if (!ISALNUM (*p) && *p != '_')\n+      return false;\n+  return true;\n+}\n+\n+/* Process define_predicate directive DESC, which appears on line number\n+   LINENO.  Compute the set of codes that can be matched, and record this\n+   as a known predicate.  */\n+\n+static void\n+process_define_predicate (rtx desc, int lineno)\n+{\n+  struct pred_data *pred;\n+  char codes[NUM_RTX_CODE];\n+  int i;\n+\n+  if (!valid_predicate_name_p (XSTR (desc, 0)))\n+    {\n+      error_with_line (lineno,\n+\t\t       \"%s: predicate name must be a valid C function name\",\n+\t\t       XSTR (desc, 0));\n+      return;\n+    }\n+\n+  pred = XCNEW (struct pred_data);\n+  pred->name = XSTR (desc, 0);\n+  pred->exp = XEXP (desc, 1);\n+  pred->c_block = XSTR (desc, 2);\n+  if (GET_CODE (desc) == DEFINE_SPECIAL_PREDICATE)\n+    pred->special = true;\n+\n+  compute_predicate_codes (XEXP (desc, 1), lineno, codes);\n+\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    if (codes[i] != N)\n+      add_predicate_code (pred, (enum rtx_code) i);\n+\n+  add_predicate (pred);\n+}\n+#undef I\n+#undef N\n+#undef Y\n+\f\n /* Queue PATTERN on LIST_TAIL.  Return the address of the new queue\n    element.  */\n \n@@ -182,6 +423,9 @@ process_rtx (rtx desc, int lineno)\n \n     case DEFINE_PREDICATE:\n     case DEFINE_SPECIAL_PREDICATE:\n+      process_define_predicate (desc, lineno);\n+      /* Fall through.  */\n+\n     case DEFINE_CONSTRAINT:\n     case DEFINE_REGISTER_CONSTRAINT:\n     case DEFINE_MEMORY_CONSTRAINT:"}]}