{"sha": "65e7bfe359febac74ebd3de0c36e735166205950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVlN2JmZTM1OWZlYmFjNzRlYmQzZGUwYzM2ZTczNTE2NjIwNTk1MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-07-19T14:02:32Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-07-19T14:02:32Z"}, "message": "re PR middle-end/54017 (Incorrect implementation of infinite loops in OpenMP sections leads to SIGILL)\n\n\tPR middle-end/54017\n\t* tree-cfgcleanup.c (cleanup_omp_return): Remove.\n\t(cleanup_tree_cfg_bb): Don't call it.\n\t* omp-low.c (expand_omp_sections): Fix up the !exit_reachable case\n\thandling.\n\n\t* c-c++-common/gomp/pr54017.c: New test.\n\nFrom-SVN: r189658", "tree": {"sha": "b2ceb968dce32746620d8c2755e65d81bba8a568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2ceb968dce32746620d8c2755e65d81bba8a568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65e7bfe359febac74ebd3de0c36e735166205950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e7bfe359febac74ebd3de0c36e735166205950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e7bfe359febac74ebd3de0c36e735166205950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e7bfe359febac74ebd3de0c36e735166205950/comments", "author": null, "committer": null, "parents": [{"sha": "867ff7ed192fe7f614ad5c5429519f7e865e20f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867ff7ed192fe7f614ad5c5429519f7e865e20f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867ff7ed192fe7f614ad5c5429519f7e865e20f0"}], "stats": {"total": 200, "additions": 117, "deletions": 83}, "files": [{"sha": "dc5187f1bdd58c18a9c8fc58e89b9bd634a767ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65e7bfe359febac74ebd3de0c36e735166205950", "patch": "@@ -1,3 +1,11 @@\n+2012-07-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/54017\n+\t* tree-cfgcleanup.c (cleanup_omp_return): Remove.\n+\t(cleanup_tree_cfg_bb): Don't call it.\n+\t* omp-low.c (expand_omp_sections): Fix up the !exit_reachable case\n+\thandling.\n+\n 2012-07-19  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/54029"}, {"sha": "03eb399c45831788492ec128a1962fc1aad62387", "filename": "gcc/omp-low.c", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=65e7bfe359febac74ebd3de0c36e735166205950", "patch": "@@ -4751,45 +4751,40 @@ expand_omp_sections (struct omp_region *region)\n   unsigned i, casei;\n   bool exit_reachable = region->cont != NULL;\n \n-  gcc_assert (exit_reachable == (region->exit != NULL));\n+  gcc_assert (region->exit != NULL);\n   entry_bb = region->entry;\n   l0_bb = single_succ (entry_bb);\n   l1_bb = region->cont;\n   l2_bb = region->exit;\n-  if (exit_reachable)\n+  if (single_pred_p (l2_bb) && single_pred (l2_bb) == l0_bb)\n+    l2 = gimple_block_label (l2_bb);\n+  else\n     {\n-      if (single_pred_p (l2_bb) && single_pred (l2_bb) == l0_bb)\n-\tl2 = gimple_block_label (l2_bb);\n+      /* This can happen if there are reductions.  */\n+      len = EDGE_COUNT (l0_bb->succs);\n+      gcc_assert (len > 0);\n+      e = EDGE_SUCC (l0_bb, len - 1);\n+      si = gsi_last_bb (e->dest);\n+      l2 = NULL_TREE;\n+      if (gsi_end_p (si)\n+          || gimple_code (gsi_stmt (si)) != GIMPLE_OMP_SECTION)\n+\tl2 = gimple_block_label (e->dest);\n       else\n-\t{\n-\t  /* This can happen if there are reductions.  */\n-\t  len = EDGE_COUNT (l0_bb->succs);\n-\t  gcc_assert (len > 0);\n-\t  e = EDGE_SUCC (l0_bb, len - 1);\n-\t  si = gsi_last_bb (e->dest);\n-\t  l2 = NULL_TREE;\n-\t  if (gsi_end_p (si)\n-\t      || gimple_code (gsi_stmt (si)) != GIMPLE_OMP_SECTION)\n-\t    l2 = gimple_block_label (e->dest);\n-\t  else\n-\t    FOR_EACH_EDGE (e, ei, l0_bb->succs)\n+\tFOR_EACH_EDGE (e, ei, l0_bb->succs)\n+\t  {\n+\t    si = gsi_last_bb (e->dest);\n+\t    if (gsi_end_p (si)\n+\t\t|| gimple_code (gsi_stmt (si)) != GIMPLE_OMP_SECTION)\n \t      {\n-\t\tsi = gsi_last_bb (e->dest);\n-\t\tif (gsi_end_p (si)\n-\t\t    || gimple_code (gsi_stmt (si)) != GIMPLE_OMP_SECTION)\n-\t\t  {\n-\t\t    l2 = gimple_block_label (e->dest);\n-\t\t    break;\n-\t\t  }\n+\t\tl2 = gimple_block_label (e->dest);\n+\t\tbreak;\n \t      }\n-\t}\n-      default_bb = create_empty_bb (l1_bb->prev_bb);\n+\t  }\n     }\n+  if (exit_reachable)\n+    default_bb = create_empty_bb (l1_bb->prev_bb);\n   else\n-    {\n-      default_bb = create_empty_bb (l0_bb);\n-      l2 = gimple_block_label (default_bb);\n-    }\n+    default_bb = create_empty_bb (l0_bb);\n \n   /* We will build a switch() with enough cases for all the\n      GIMPLE_OMP_SECTION regions, a '0' case to handle the end of more work\n@@ -4842,13 +4837,9 @@ expand_omp_sections (struct omp_region *region)\n       vnext = NULL_TREE;\n     }\n \n-  i = 0;\n-  if (exit_reachable)\n-    {\n-      t = build_case_label (build_int_cst (unsigned_type_node, 0), NULL, l2);\n-      VEC_quick_push (tree, label_vec, t);\n-      i++;\n-    }\n+  t = build_case_label (build_int_cst (unsigned_type_node, 0), NULL, l2);\n+  VEC_quick_push (tree, label_vec, t);\n+  i = 1;\n \n   /* Convert each GIMPLE_OMP_SECTION into a CASE_LABEL_EXPR.  */\n   for (inner = region->inner, casei = 1;\n@@ -4918,18 +4909,18 @@ expand_omp_sections (struct omp_region *region)\n       gsi_remove (&si, true);\n \n       single_succ_edge (l1_bb)->flags = EDGE_FALLTHRU;\n-\n-      /* Cleanup function replaces GIMPLE_OMP_RETURN in EXIT_BB.  */\n-      si = gsi_last_bb (l2_bb);\n-      if (gimple_omp_return_nowait_p (gsi_stmt (si)))\n-\tt = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END_NOWAIT);\n-      else\n-\tt = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END);\n-      stmt = gimple_build_call (t, 0);\n-      gsi_insert_after (&si, stmt, GSI_SAME_STMT);\n-      gsi_remove (&si, true);\n     }\n \n+  /* Cleanup function replaces GIMPLE_OMP_RETURN in EXIT_BB.  */\n+  si = gsi_last_bb (l2_bb);\n+  if (gimple_omp_return_nowait_p (gsi_stmt (si)))\n+    t = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END_NOWAIT);\n+  else\n+    t = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END);\n+  stmt = gimple_build_call (t, 0);\n+  gsi_insert_after (&si, stmt, GSI_SAME_STMT);\n+  gsi_remove (&si, true);\n+\n   set_immediate_dominator (CDI_DOMINATORS, default_bb, l0_bb);\n }\n "}, {"sha": "3283840121fa2c23883444d574937c1290c5cbd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=65e7bfe359febac74ebd3de0c36e735166205950", "patch": "@@ -1,5 +1,10 @@\n+2012-07-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/54017\n+\t* c-c++-common/gomp/pr54017.c: New test.\n+\n 2012-07-19  Richard Guenther  <rguenther@suse.de>\n-\tEric Botcazou  <ebotcazou@adacore.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/loop_optimization11.adb: New testcase.\n \t* gnat.dg/loop_optimization11_pkg.ads: Likewise."}, {"sha": "724efe1363842c101e23e4a4ff06bf207eaf9985", "filename": "gcc/testsuite/c-c++-common/gomp/pr54017.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr54017.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr54017.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr54017.c?ref=65e7bfe359febac74ebd3de0c36e735166205950", "patch": "@@ -0,0 +1,65 @@\n+/* PR middle-end/54017 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+f1 (void)\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    {\n+      for (;;)\n+\t;\n+    }\n+  }\n+}\n+\n+int\n+f2 (void)\n+{\n+  int i = 0;\n+#pragma omp parallel\n+#pragma omp sections reduction(+:i)\n+  {\n+#pragma omp section\n+    {\n+      for (;;)\n+\t;\n+    }\n+  }\n+  return i;\n+}\n+\n+void\n+f3 (void)\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    {\n+      for (;;)\n+\t;\n+    }\n+#pragma omp section\n+    ;\n+  }\n+}\n+\n+int\n+f4 (void)\n+{\n+  int i = 0;\n+#pragma omp parallel\n+#pragma omp sections reduction(+:i)\n+  {\n+#pragma omp section\n+    {\n+      for (;;)\n+\t;\n+    }\n+#pragma omp section\n+    ;\n+  }\n+  return i;\n+}"}, {"sha": "b665c5890bef65eab7cc57b069294eab9a89f3c6", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e7bfe359febac74ebd3de0c36e735166205950/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=65e7bfe359febac74ebd3de0c36e735166205950", "patch": "@@ -606,48 +606,13 @@ split_bbs_on_noreturn_calls (void)\n   return changed;\n }\n \n-/* If GIMPLE_OMP_RETURN in basic block BB is unreachable, remove it.  */\n-\n-static bool\n-cleanup_omp_return (basic_block bb)\n-{\n-  gimple stmt = last_stmt (bb);\n-  basic_block control_bb;\n-\n-  if (stmt == NULL\n-      || gimple_code (stmt) != GIMPLE_OMP_RETURN\n-      || !single_pred_p (bb))\n-    return false;\n-\n-  control_bb = single_pred (bb);\n-  stmt = last_stmt (control_bb);\n-\n-  if (stmt == NULL || gimple_code (stmt) != GIMPLE_OMP_SECTIONS_SWITCH)\n-    return false;\n-\n-  /* The block with the control statement normally has two entry edges -- one\n-     from entry, one from continue.  If continue is removed, return is\n-     unreachable, so we remove it here as well.  */\n-  if (EDGE_COUNT (control_bb->preds) == 2)\n-    return false;\n-\n-  gcc_assert (EDGE_COUNT (control_bb->preds) == 1);\n-  remove_edge_and_dominated_blocks (single_pred_edge (bb));\n-  return true;\n-}\n-\n /* Tries to cleanup cfg in basic block BB.  Returns true if anything\n    changes.  */\n \n static bool\n cleanup_tree_cfg_bb (basic_block bb)\n {\n-  bool retval = false;\n-\n-  if (cleanup_omp_return (bb))\n-    return true;\n-\n-  retval = cleanup_control_flow_bb (bb);\n+  bool retval = cleanup_control_flow_bb (bb);\n \n   if (tree_forwarder_block_p (bb, false)\n       && remove_forwarder_block (bb))"}]}