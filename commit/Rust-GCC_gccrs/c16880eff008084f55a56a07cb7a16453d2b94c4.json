{"sha": "c16880eff008084f55a56a07cb7a16453d2b94c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE2ODgwZWZmMDA4MDg0ZjU1YTU2YTA3Y2I3YTE2NDUzZDJiOTRjNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-01-10T21:02:07Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-10T21:02:07Z"}, "message": "PR tree-optimization/78775 - [7 Regression] ICE in maybe_warn_alloc_args_overflow\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/78775\n\t* builtins.c (get_size_range): Move...\n\t* calls.c: ...to here.\n\t(alloc_max_size): Accept zero argument.\n\t(operand_signed_p): Remove.\n\t(maybe_warn_alloc_args_overflow): Call get_size_range.\n\t* calls.h (get_size_range): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/78775\n\t* gcc.dg/attr-alloc_size-4.c: Add test cases.\n\t* gcc.dg/attr-alloc_size-10.c: New test.\n\t* gcc.dg/attr-alloc_size-11.c: New test.\n\t* gcc.dg/builtin-stringop-chk-7.c: New test.\n\t* gcc.dg/pr78775.c: New test.\n\t* gcc.dg/pr78973-2.c: New test.\n\t* gcc.dg/pr78973.c: New test.\n\nFrom-SVN: r244290", "tree": {"sha": "7937fe84404fc72318c09a1797cd2d2d23fdd4c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7937fe84404fc72318c09a1797cd2d2d23fdd4c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c16880eff008084f55a56a07cb7a16453d2b94c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16880eff008084f55a56a07cb7a16453d2b94c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c16880eff008084f55a56a07cb7a16453d2b94c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16880eff008084f55a56a07cb7a16453d2b94c4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d58291930dab0a54f7d2c0e5e272a1ea9b18aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d58291930dab0a54f7d2c0e5e272a1ea9b18aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d58291930dab0a54f7d2c0e5e272a1ea9b18aad"}], "stats": {"total": 690, "additions": 517, "deletions": 173}, "files": [{"sha": "d0c53d066eae29b9867607f02bd53235cbd6210b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -1,3 +1,13 @@\n+2017-01-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/78775\n+\t* builtins.c (get_size_range): Move...\n+\t* calls.c: ...to here.\n+\t(alloc_max_size): Accept zero argument.\n+\t(operand_signed_p): Remove.\n+\t(maybe_warn_alloc_args_overflow): Call get_size_range.\n+\t* calls.h (get_size_range): Declare.\n+\n 2017-01-10  Joe Seymour  <joe.s@somniumtech.com>\n \n \t* config/msp430/driver-msp430.c (msp430_mcu_data): Sync with data"}, {"sha": "bf68e317124f3ae3aa033142d9ae813e78e9ef98", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -3031,42 +3031,6 @@ expand_builtin_memcpy_args (tree dest, tree src, tree len, rtx target, tree exp)\n   return dest_addr;\n }\n \n-/* Fill the 2-element RANGE array with the minimum and maximum values\n-   EXP is known to have and return true, otherwise null and return\n-   false.  */\n-\n-static bool\n-get_size_range (tree exp, tree range[2])\n-{\n-  if (tree_fits_uhwi_p (exp))\n-    {\n-      range[0] = range[1] = exp;\n-      return true;\n-    }\n-\n-  if (TREE_CODE (exp) == SSA_NAME)\n-    {\n-      wide_int min, max;\n-      enum value_range_type range_type = get_range_info (exp, &min, &max);\n-\n-      if (range_type == VR_RANGE)\n-\t{\n-\t  /* Interpret the bound in the variable's type.  */\n-\t  range[0] = wide_int_to_tree (TREE_TYPE (exp), min);\n-\t  range[1] = wide_int_to_tree (TREE_TYPE (exp), max);\n-\t  return true;\n-\t}\n-      else if (range_type == VR_ANTI_RANGE)\n-\t{\n-\t  /* FIXME: Handle anti-ranges.  */\n-\t}\n-    }\n-\n-  range[0] = NULL_TREE;\n-  range[1] = NULL_TREE;\n-  return false;\n-}\n-\n /* Try to verify that the sizes and lengths of the arguments to a string\n    manipulation function given by EXP are within valid bounds and that\n    the operation does not lead to buffer overflow.  Arguments other than"}, {"sha": "7b45b9a111dde7391f4aa31088f76baa30ea91ee", "filename": "gcc/calls.c", "status": "modified", "additions": 139, "deletions": 135, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -1197,92 +1197,144 @@ alloc_max_size (void)\n     {\n       alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);\n \n-      unsigned HOST_WIDE_INT unit = 1;\n-\n-      char *end;\n-      errno = 0;\n-      unsigned HOST_WIDE_INT limit\n-\t= warn_alloc_size_limit ? strtoull (warn_alloc_size_limit, &end, 10) : 0;\n-\n-      if (limit && !errno)\n+      if (warn_alloc_size_limit)\n \t{\n-\t  if (end && *end)\n+\t  char *end = NULL;\n+\t  errno = 0;\n+\t  unsigned HOST_WIDE_INT unit = 1;\n+\t  unsigned HOST_WIDE_INT limit\n+\t    = strtoull (warn_alloc_size_limit, &end, 10);\n+\n+\t  if (!errno)\n \t    {\n-\t      /* Numeric option arguments are at most INT_MAX.  Make it\n-\t\t possible to specify a larger value by accepting common\n-\t\t suffixes.  */\n-\t      if (!strcmp (end, \"kB\"))\n-\t\tunit = 1000;\n-\t      else if (!strcasecmp (end, \"KiB\") || strcmp (end, \"KB\"))\n-\t\tunit = 1024;\n-\t      else if (!strcmp (end, \"MB\"))\n-\t\tunit = 1000LU * 1000;\n-\t      else if (!strcasecmp (end, \"MiB\"))\n-\t\tunit = 1024LU * 1024;\n-\t      else if (!strcasecmp (end, \"GB\"))\n-\t\tunit = 1000LU * 1000 * 1000;\n-\t      else if (!strcasecmp (end, \"GiB\"))\n-\t\tunit = 1024LU * 1024 * 1024;\n-\t      else if (!strcasecmp (end, \"TB\"))\n-\t\tunit = 1000LU * 1000 * 1000 * 1000;\n-\t      else if (!strcasecmp (end, \"TiB\"))\n-\t\tunit = 1024LU * 1024 * 1024 * 1024;\n-\t      else if (!strcasecmp (end, \"PB\"))\n-\t\tunit = 1000LU * 1000 * 1000 * 1000 * 1000;\n-\t      else if (!strcasecmp (end, \"PiB\"))\n-\t\tunit = 1024LU * 1024 * 1024 * 1024 * 1024;\n-\t      else if (!strcasecmp (end, \"EB\"))\n-\t\tunit = 1000LU * 1000 * 1000 * 1000 * 1000 * 1000;\n-\t      else if (!strcasecmp (end, \"EiB\"))\n-\t\tunit = 1024LU * 1024 * 1024 * 1024 * 1024 * 1024;\n-\t      else\n-\t\tunit = 0;\n-\t    }\n+\t      if (end && *end)\n+\t\t{\n+\t\t  /* Numeric option arguments are at most INT_MAX.  Make it\n+\t\t     possible to specify a larger value by accepting common\n+\t\t     suffixes.  */\n+\t\t  if (!strcmp (end, \"kB\"))\n+\t\t    unit = 1000;\n+\t\t  else if (!strcasecmp (end, \"KiB\") || strcmp (end, \"KB\"))\n+\t\t    unit = 1024;\n+\t\t  else if (!strcmp (end, \"MB\"))\n+\t\t    unit = 1000LU * 1000;\n+\t\t  else if (!strcasecmp (end, \"MiB\"))\n+\t\t    unit = 1024LU * 1024;\n+\t\t  else if (!strcasecmp (end, \"GB\"))\n+\t\t    unit = 1000LU * 1000 * 1000;\n+\t\t  else if (!strcasecmp (end, \"GiB\"))\n+\t\t    unit = 1024LU * 1024 * 1024;\n+\t\t  else if (!strcasecmp (end, \"TB\"))\n+\t\t    unit = 1000LU * 1000 * 1000 * 1000;\n+\t\t  else if (!strcasecmp (end, \"TiB\"))\n+\t\t    unit = 1024LU * 1024 * 1024 * 1024;\n+\t\t  else if (!strcasecmp (end, \"PB\"))\n+\t\t    unit = 1000LU * 1000 * 1000 * 1000 * 1000;\n+\t\t  else if (!strcasecmp (end, \"PiB\"))\n+\t\t    unit = 1024LU * 1024 * 1024 * 1024 * 1024;\n+\t\t  else if (!strcasecmp (end, \"EB\"))\n+\t\t    unit = 1000LU * 1000 * 1000 * 1000 * 1000 * 1000;\n+\t\t  else if (!strcasecmp (end, \"EiB\"))\n+\t\t    unit = 1024LU * 1024 * 1024 * 1024 * 1024 * 1024;\n+\t\t  else\n+\t\t    unit = 0;\n+\t\t}\n \n-\t  if (unit)\n-\t    alloc_object_size_limit = build_int_cst (ssizetype, limit * unit);\n+\t      if (unit)\n+\t\talloc_object_size_limit\n+\t\t  = build_int_cst (ssizetype, limit * unit);\n+\t    }\n \t}\n     }\n   return alloc_object_size_limit;\n }\n \n-/* Return true if the type of OP is signed, looking through any casts\n-   to an unsigned type.  */\n+/* Return true when EXP's range can be determined and set RANGE[] to it\n+   after adjusting it if necessary to make EXP a valid size argument to\n+   an allocation function declared with attribute alloc_size (whose\n+   argument may be signed), or to a string manipulation function like\n+   memset.  */\n \n-static bool\n-operand_signed_p (tree op)\n+bool\n+get_size_range (tree exp, tree range[2])\n {\n-  if (TREE_CODE (op) == SSA_NAME)\n+  if (tree_fits_uhwi_p (exp))\n     {\n-      gimple *def = SSA_NAME_DEF_STMT (op);\n-      if (is_gimple_assign (def))\n-\t{\n-\t  /* In an assignment involving a cast, ignore the type\n-\t     of the cast and consider the type of its  operand.  */\n-\t  tree_code code = gimple_assign_rhs_code (def);\n-\t  if (code == NOP_EXPR)\n-\t    op = gimple_assign_rhs1 (def);\n-\t}\n-      else if (gimple_code (def) == GIMPLE_PHI)\n+      /* EXP is a constant.  */\n+      range[0] = range[1] = exp;\n+      return true;\n+    }\n+\n+  wide_int min, max;\n+  enum value_range_type range_type\n+    = (TREE_CODE (exp) == SSA_NAME\n+       ? get_range_info (exp, &min, &max) : VR_VARYING);\n+\n+  if (range_type == VR_VARYING)\n+    {\n+      /* No range information available.  */\n+      range[0] = NULL_TREE;\n+      range[1] = NULL_TREE;\n+      return false;\n+    }\n+\n+  tree exptype = TREE_TYPE (exp);\n+  unsigned expprec = TYPE_PRECISION (exptype);\n+  wide_int wzero = wi::zero (expprec);\n+  wide_int wmaxval = wide_int (TYPE_MAX_VALUE (exptype));\n+\n+  bool signed_p = !TYPE_UNSIGNED (exptype);\n+\n+  if (range_type == VR_ANTI_RANGE)\n+    {\n+      if (signed_p)\n \t{\n-\t  /* In a phi, a constant argument may be unsigned even\n-\t     if in the source it's signed and negative.  Ignore\n-\t     those and consider the result of a phi signed if\n-\t     all its non-constant operands are.  */\n-\t  unsigned nargs = gimple_phi_num_args (def);\n-\t  for (unsigned i = 0; i != nargs; ++i)\n+\t  if (wi::les_p (max, wzero))\n \t    {\n-\t      tree op = gimple_phi_arg_def (def, i);\n-\t      if (TREE_CODE (op) != INTEGER_CST\n-\t\t  && !operand_signed_p (op))\n-\t\treturn false;\n+\t      /* EXP is not in a strictly negative range.  That means\n+\t\t it must be in some (not necessarily strictly) positive\n+\t\t range which includes zero.  Since in signed to unsigned\n+\t\t conversions negative values end up converted to large\n+\t\t positive values, and otherwise they are not valid sizes,\n+\t\t the resulting range is in both cases [0, TYPE_MAX].  */\n+\t      min = wzero;\n+\t      max = wmaxval;\n \t    }\n-\n-\t  return true;\n+\t  else if (wi::les_p (min - 1, wzero))\n+\t    {\n+\t      /* EXP is not in a negative-positive range.  That means EXP\n+\t\t is either negative, or greater than max.  Since negative\n+\t\t sizes are invalid make the range [MAX + 1, TYPE_MAX].  */\n+\t      min = max + 1;\n+\t      max = wmaxval;\n+\t    }\n+\t  else\n+\t    {\n+\t      max = min - 1;\n+\t      min = wzero;\n+\t    }\n+\t}\n+      else if (wi::eq_p (wzero, min - 1))\n+\t{\n+\t  /* EXP is unsigned and not in the range [1, MAX].  That means\n+\t     it's either zero or greater than MAX.  Even though 0 would\n+\t     normally be detected by -Walloc-zero set the range to\n+\t     [MAX, TYPE_MAX] so that when MAX is greater than the limit\n+\t     the whole range is diagnosed.  */\n+\t  min = max + 1;\n+\t  max = wmaxval;\n+\t}\n+      else\n+\t{\n+\t  max = min - 1;\n+\t  min = wzero;\n \t}\n     }\n \n-  return !TYPE_UNSIGNED (TREE_TYPE (op));\n+  range[0] = wide_int_to_tree (exptype, min);\n+  range[1] = wide_int_to_tree (exptype, max);\n+\n+  return true;\n }\n \n /* Diagnose a call EXP to function FN decorated with attribute alloc_size\n@@ -1316,8 +1368,8 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t  if (tree_int_cst_lt (args[i], integer_zero_node))\n \t    {\n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i value %qE is negative\",\n-\t\t\t\t   idx[i] + 1, args[i]);\n+\t\t\t\t   \"%Kargument %i value %qE is negative\",\n+\t\t\t\t   exp, idx[i] + 1, args[i]);\n \t    }\n \t  else if (integer_zerop (args[i]))\n \t    {\n@@ -1334,8 +1386,8 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t\t      && !lookup_attribute (\"returns_nonnull\",\n \t\t\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (fn)))))\n \t\twarned = warning_at (loc, OPT_Walloc_zero,\n-\t\t\t\t     \"argument %i value is zero\",\n-\t\t\t\t     idx[i] + 1);\n+\t\t\t\t     \"%Kargument %i value is zero\",\n+\t\t\t\t     exp, idx[i] + 1);\n \t    }\n \t  else if (tree_int_cst_lt (maxobjsize, args[i]))\n \t    {\n@@ -1351,79 +1403,31 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t\tcontinue;\n \n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i value %qE exceeds \"\n+\t\t\t\t   \"%Kargument %i value %qE exceeds \"\n \t\t\t\t   \"maximum object size %E\",\n-\t\t\t\t   idx[i] + 1, args[i], maxobjsize);\n+\t\t\t\t   exp, idx[i] + 1, args[i], maxobjsize);\n \t    }\n \t}\n-      else if (TREE_CODE (args[i]) == SSA_NAME)\n+      else if (TREE_CODE (args[i]) == SSA_NAME\n+\t       && get_size_range (args[i], argrange[i]))\n \t{\n-\t  tree type = TREE_TYPE (args[i]);\n-\n-\t  wide_int min, max;\n-\t  value_range_type range_type = get_range_info (args[i], &min, &max);\n-\t  if (range_type == VR_RANGE)\n-\t    {\n-\t      argrange[i][0] = wide_int_to_tree (type, min);\n-\t      argrange[i][1] = wide_int_to_tree (type, max);\n-\t    }\n-\t  else if (range_type == VR_ANTI_RANGE)\n-\t    {\n-\t      /* For an anti-range, if the type of the formal argument\n-\t\t is unsigned and the bounds of the range are of opposite\n-\t\t signs when interpreted as signed, check to see if the\n-\t\t type of the actual argument is signed.  If so, the lower\n-\t\t bound must be taken to be zero (rather than a large\n-\t\t positive value corresonding to the actual lower bound\n-\t\t interpreted as unsigned) and there is nothing else that\n-\t\t can be inferred from it.  */\n-\t      --min;\n-\t      ++max;\n-\t      wide_int zero = wi::uhwi (0, TYPE_PRECISION (type));\n-\t      if (TYPE_UNSIGNED (type)\n-\t\t  && wi::lts_p (zero, min) && wi::lts_p (max, zero)\n-\t\t  && operand_signed_p (args[i]))\n-\t\tcontinue;\n-\n-\t      argrange[i][0] = wide_int_to_tree (type, max);\n-\t      argrange[i][1] = wide_int_to_tree (type, min);\n-\n-\t      /* Verify that the anti-range doesn't make all arguments\n-\t\t invalid (treat the anti-range ~[0, 0] as invalid).  */\n-\t      if (tree_int_cst_lt (maxobjsize, argrange[i][0])\n-\t\t  && tree_int_cst_le (argrange[i][1], integer_zero_node))\n-\t\t{\n-\t\t  warned\n-\t\t    = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t  (TYPE_UNSIGNED (type)\n-\t\t\t\t   ? G_(\"argument %i range [%E, %E] exceeds \"\n-\t\t\t\t\t\"maximum object size %E\")\n-\t\t\t\t   : G_(\"argument %i range [%E, %E] is both \"\n-\t\t\t\t\t\"negative and exceeds maximum object \"\n-\t\t\t\t\t\"size %E\")),\n-\t\t\t\t  idx[i] + 1, argrange[i][0],\n-\t\t\t\t  argrange[i][1], maxobjsize);\n-\t\t}\n-\t      continue;\n-\t    }\n-\t  else\n-\t    continue;\n-\n \t  /* Verify that the argument's range is not negative (including\n \t     upper bound of zero).  */\n \t  if (tree_int_cst_lt (argrange[i][0], integer_zero_node)\n \t      && tree_int_cst_le (argrange[i][1], integer_zero_node))\n \t    {\n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i range [%E, %E] is negative\",\n-\t\t\t\t   idx[i] + 1, argrange[i][0], argrange[i][1]);\n+\t\t\t\t   \"%Kargument %i range [%E, %E] is negative\",\n+\t\t\t\t   exp, idx[i] + 1,\n+\t\t\t\t   argrange[i][0], argrange[i][1]);\n \t    }\n \t  else if (tree_int_cst_lt (maxobjsize, argrange[i][0]))\n \t    {\n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i range [%E, %E] exceeds \"\n+\t\t\t\t   \"%Kargument %i range [%E, %E] exceeds \"\n \t\t\t\t   \"maximum object size %E\",\n-\t\t\t\t   idx[i] + 1, argrange[i][0], argrange[i][1],\n+\t\t\t\t   exp, idx[i] + 1,\n+\t\t\t\t   argrange[i][0], argrange[i][1],\n \t\t\t\t   maxobjsize);\n \t    }\n \t}\n@@ -1450,15 +1454,15 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \n       if (vflow)\n \twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"%Kproduct %<%E * %E%> of arguments %i and %i \"\n \t\t\t     \"exceeds %<SIZE_MAX%>\",\n-\t\t\t     argrange[0][0], argrange[1][0],\n+\t\t\t     exp, argrange[0][0], argrange[1][0],\n \t\t\t     idx[0] + 1, idx[1] + 1);\n       else if (wi::ltu_p (wi::to_wide (maxobjsize, szprec), prod))\n \twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"%Kproduct %<%E * %E%> of arguments %i and %i \"\n \t\t\t     \"exceeds maximum object size %E\",\n-\t\t\t     argrange[0][0], argrange[1][0],\n+\t\t\t     exp, argrange[0][0], argrange[1][0],\n \t\t\t     idx[0] + 1, idx[1] + 1,\n \t\t\t     maxobjsize);\n "}, {"sha": "df5817fe785927af81423afee3c829b5b387d1e3", "filename": "gcc/calls.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -38,5 +38,6 @@ extern bool pass_by_reference (CUMULATIVE_ARGS *, machine_mode,\n extern bool reference_callee_copied (CUMULATIVE_ARGS *, machine_mode,\n \t\t\t\t     tree, bool);\n extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n+extern bool get_size_range (tree, tree[2]);\n \n #endif // GCC_CALLS_H"}, {"sha": "f8cba4221ab1a8d1b68faea590a19178a86c916f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -1,3 +1,14 @@\n+2017-01-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/78775\n+\t* gcc.dg/attr-alloc_size-4.c: Add test cases.\n+\t* gcc.dg/attr-alloc_size-10.c: New test.\n+\t* gcc.dg/attr-alloc_size-11.c: New test.\n+\t* gcc.dg/builtin-stringop-chk-7.c: New test.\n+\t* gcc.dg/pr78775.c: New test.\n+\t* gcc.dg/pr78973-2.c: New test.\n+\t* gcc.dg/pr78973.c: New test.\n+\n 2017-01-10  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/77766"}, {"sha": "d7a0a98700338c2bc99c05836713a1252c077a83", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-10.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-10.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -0,0 +1,142 @@\n+/* Verify that -Walloc-size-greater-than doesn't cause false positives\n+   for anti-ranges.  Note that not all of the statements used to create\n+   anti-ranges below result in the argument being represented as an anti\n+   range.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Walloc-size-larger-than=12\" } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SCHAR_MIN (-SCHAR_MAX - 1)\n+#define UCHAR_MAX (SCHAR_MAX * 2 + 1)\n+\n+#define SHRT_MAX  __SHRT_MAX__\n+#define SHRT_MIN  (-SHRT_MAX - 1)\n+#define USHRT_MAX (SHRT_MAX * 2 + 1)\n+\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+#define UINT_MAX  (INT_MAX * 2U + 1)\n+\n+#define LONG_MAX __LONG_MAX__\n+#define LONG_MIN (-LONG_MAX - 1)\n+#define ULONG_MAX (LONG_MAX * 2LU + 1)\n+\n+#define PTRDIFF_MAX __PTRDIFF_MAX__\n+#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)\n+#define SIZE_MAX    __SIZE_MAX__\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+#define CONCAT(a, b)  a ## b\n+#define CAT(a, b)     CONCAT (a, b)\n+\n+/* Macro to generate a unique function to test the anti-range\n+   ~[MIN, MAX] for type T.  */\n+#define TEST(T, min, max)\t\t\t\t\t\\\n+  void* CAT (test_anti_range_, __LINE__)(T n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    extern void* CAT (alloc_anti_range_, __LINE__)(T)\t\t\\\n+      __attribute__ ((alloc_size (1)));\t\t\t\t\\\n+    if (min <= n && n <= max)\t\t\t\t\t\\\n+      n = min - 1;\t\t\t\t\t\t\\\n+    return CAT (alloc_anti_range_, __LINE__)(n);\t\t\\\n+  } typedef void dummy   /* Require a semicolon.  */\n+\n+\n+/* Verify the anti-range ~[TYPE_MAX - 1, TYPE_MAX - 1].  */\n+TEST (signed char, SCHAR_MAX - 1, SCHAR_MAX - 1);\n+TEST (unsigned char, UCHAR_MAX - 1, UCHAR_MAX - 1);\n+TEST (short, SHRT_MAX - 1, SHRT_MAX - 1);\n+TEST (unsigned short, USHRT_MAX - 1, USHRT_MAX - 1);\n+TEST (int, INT_MAX - 1, INT_MAX - 1);\n+TEST (unsigned, UINT_MAX - 1, UINT_MAX - 1);\n+TEST (long, LONG_MAX - 1, LONG_MAX - 1);\n+TEST (unsigned long, ULONG_MAX - 1, ULONG_MAX - 1);\n+TEST (ptrdiff_t, PTRDIFF_MAX - 1, PTRDIFF_MAX - 1);\n+TEST (size_t, SIZE_MAX - 1, SIZE_MAX - 1);\n+\n+/* Verify ~[0, 0].  */\n+TEST (signed char, 0, 0);\n+TEST (unsigned char, 0, 0);\n+TEST (short, 0, 0);\n+TEST (unsigned short, 0, 0);\n+TEST (int, 0, 0);\n+TEST (unsigned, 0, 0);\n+TEST (long, 0, 0);\n+TEST (unsigned long, 0, 0);\n+TEST (ptrdiff_t, 0, 0);\n+TEST (size_t, 0, 0);\n+\n+/* Verify ~[1, 1].  */\n+TEST (signed char, 1, 1);\n+TEST (unsigned char, 1, 1);\n+TEST (short, 1, 1);\n+TEST (unsigned short, 1, 1);\n+TEST (int, 1, 1);\n+TEST (unsigned, 1, 1);\n+TEST (long, 1, 1);\n+TEST (unsigned long, 1, 1);\n+TEST (ptrdiff_t, 1, 1);\n+TEST (size_t, 1, 1);\n+\n+\n+/* Verify ~[TYPE_MAX - 2, TYPE_MAX - 1].  */\n+TEST (signed char, SCHAR_MAX - 2, SCHAR_MAX - 1);\n+TEST (unsigned char, UCHAR_MAX - 2, UCHAR_MAX - 1);\n+TEST (short, SHRT_MAX - 2, SHRT_MAX - 1);\n+TEST (unsigned short, USHRT_MAX - 2, USHRT_MAX - 1);\n+TEST (int, INT_MAX - 2, INT_MAX - 1);\n+TEST (unsigned, UINT_MAX - 2, UINT_MAX - 1);\n+TEST (long, LONG_MAX - 2, LONG_MAX - 1);\n+TEST (unsigned long, ULONG_MAX - 2, ULONG_MAX - 1);\n+TEST (ptrdiff_t, PTRDIFF_MAX - 2, PTRDIFF_MAX - 1);\n+TEST (size_t, SIZE_MAX - 2, SIZE_MAX - 1);\n+\n+/* Verify ~[0, 2].  */\n+TEST (signed char, 0, 2);\n+TEST (unsigned char, 0, 2);\n+TEST (short, 0, 2);\n+TEST (unsigned short, 0, 2);\n+TEST (int, 0, 2);\n+TEST (unsigned int, 0, 2);\n+TEST (long, 0, 2);\n+TEST (unsigned long, 0, 2);\n+TEST (ptrdiff_t, 0, 2);\n+TEST (size_t, 0, 2);\n+\n+/* Verify the signed anti-range ~[TYPE_MIN - 2, -1].  */\n+TEST (signed char, SCHAR_MIN + 2, -1);\n+TEST (short, SHRT_MIN + 2, -1);\n+TEST (int, INT_MIN + 2, -1);\n+TEST (long, LONG_MIN + 2, -1);\n+TEST (ptrdiff_t, PTRDIFF_MIN + 2, -1);\n+\n+/* Verify the signed anti-range ~[TYPE_MIN - 2, 0].  */\n+TEST (signed char, SCHAR_MIN + 2, 0);\n+TEST (short, SHRT_MIN + 2, 0);\n+TEST (int, INT_MIN + 2, 0);\n+TEST (long, LONG_MIN + 2, 0);\n+TEST (ptrdiff_t, PTRDIFF_MIN + 2, 0);\n+\n+/* Verify the signed anti-range ~[TYPE_MIN - 2, 1].  */\n+TEST (signed char, SCHAR_MIN + 2, 1);\n+TEST (short, SHRT_MIN + 2, 1);\n+TEST (int, INT_MIN + 2, 1);\n+TEST (long, LONG_MIN + 2, 1);\n+TEST (ptrdiff_t, PTRDIFF_MIN + 2, 1);\n+\n+/* Verify the signed anti-range ~[TYPE_MIN - 2, 2].  */\n+TEST (signed char, SCHAR_MIN + 2, 2);\n+TEST (short, SHRT_MIN + 2, 2);\n+TEST (int, INT_MIN + 2, 2);\n+TEST (long, LONG_MIN + 2, 2);\n+TEST (ptrdiff_t, PTRDIFF_MIN + 2, 2);\n+\n+/* Verify the signed anti-range ~[-1, 2].  */\n+TEST (signed char, -1, 2);\n+TEST (short, -1, 2);\n+TEST (int, -1, 2);\n+TEST (long, -1, 2);\n+TEST (ptrdiff_t, 01, 2);"}, {"sha": "fac8b18de6140331764a33e42e6899f9a4f0f228", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-11.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-11.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -0,0 +1,69 @@\n+/* Verify that -Walloc-size-greater-than doesn't cause false positives\n+   for anti-ranges.  Note that not all of the statements below result\n+   in the argument being represented as an anti-range.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Walloc-size-larger-than=12 -ftrack-macro-expansion=0\" } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SCHAR_MIN (-SCHAR_MAX - 1)\n+#define UCHAR_MAX (SCHAR_MAX * 2 + 1)\n+\n+#define SHRT_MAX  __SHRT_MAX__\n+#define SHRT_MIN  (-SHRT_MAX - 1)\n+#define USHRT_MAX (SHRT_MAX * 2 + 1)\n+\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+#define UINT_MAX  (INT_MAX * 2U + 1)\n+\n+#define LONG_MAX __LONG_MAX__\n+#define LONG_MIN (-LONG_MAX - 1)\n+#define ULONG_MAX (LONG_MAX * 2LU + 1)\n+\n+#define PTRDIFF_MAX __PTRDIFF_MAX__\n+#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)\n+#define SIZE_MAX    __SIZE_MAX__\n+\n+#define ALLOC_MAX   12\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+#define CONCAT(a, b)  a ## b\n+#define CAT(a, b)     CONCAT (a, b)\n+\n+/* Macro to generate a unique function to test the anti-range\n+   ~[MIN, MAX] for type T.  */\n+#define TEST(T, min, max)\t\t\t\t\t\\\n+  void* CAT (test_anti_range_, __LINE__)(T n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    extern void* CAT (alloc_anti_range_, __LINE__)(T)\t\t\\\n+      __attribute__ ((alloc_size (1)));\t\t\t\t\\\n+    if (min <= n && n <= max)\t\t\t\t\t\\\n+      n = min - 1;\t\t\t\t\t\t\\\n+    return CAT (alloc_anti_range_, __LINE__)(n);\t\t\\\n+  } typedef void dummy   /* Require a semicolon.  */\n+\n+/* The following tests fail because of missing range information.  */\n+TEST (signed char, SCHAR_MIN + 2, ALLOC_MAX);   /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" \"missing range info for signed char\" { xfail *-*-* } } */\n+TEST (short, SHRT_MIN + 2, ALLOC_MAX); /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" \"missing range info for short\" { xfail *-*-* } } */\n+\n+TEST (int, INT_MIN + 2, ALLOC_MAX);    /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (int, -3, ALLOC_MAX);             /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (int, -2, ALLOC_MAX);             /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (int, -1, ALLOC_MAX);             /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (int,  0, ALLOC_MAX);             /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (int,  1, ALLOC_MAX);             /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (int,  1, INT_MAX - 1);           /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+\n+/* The following two aren't necessarily anti-ranges.  */\n+TEST (int,  1, INT_MAX);               /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+TEST (int,  0, INT_MAX);               /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -1\\\\\\] is negative\" } */\n+\n+TEST (long, LONG_MIN + 2, ALLOC_MAX);  /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (ptrdiff_t, PTRDIFF_MIN + 2, ALLOC_MAX);  /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+\n+TEST (unsigned, 0, ALLOC_MAX);         /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (unsigned long, 0, ALLOC_MAX);    /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */\n+TEST (size_t, 0, ALLOC_MAX);           /* { dg-warning \"argument 1 range \\\\\\[13, \\[0-9\\]+\\\\\\] exceeds maximum object size 12\" } */"}, {"sha": "5ce593e069297013bfff94ef42ac48a7aa69488e", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-4.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-4.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -128,15 +128,22 @@ test_int_range (int n)\n \n   sink (f_int_1 (SR (min, 1234)));\n   sink (f_int_1 (SR (-2, -1)));   /* { dg-warning \"argument 1 range \\\\\\[-2, -1\\\\\\] is negative\" } */\n+\n   sink (f_int_1 (SR (1235, 2345)));  /* { dg-warning \"argument 1 range \\\\\\[1235, 2345\\\\\\] exceeds maximum object size 1234\" } */\n   sink (f_int_1 (SR (max - 1, max)));   /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+, \\[0-9\\]+\\\\\\] exceeds maximum object size 1234\" } */\n \n   sink (f_int_1 (SAR (-1, 1)));\n   sink (f_int_1 (SAR (-2, 12)));\n   sink (f_int_1 (SAR (-3, 123)));\n-  sink (f_int_1 (SAR (-4, 1234)));   /* { dg-warning \"argument 1 range \\\\\\[1235, -5\\\\\\] is both negative and exceeds maximum object size 1234\" } */\n+  sink (f_int_1 (SAR (-4, 1234)));   /* { dg-warning \"argument 1 range \\\\\\[1235, \\[0-9\\]+\\\\\\] exceeds maximum object size 1234\" } */\n   sink (f_int_1 (SAR (min + 1, 1233)));\n-  sink (f_int_1 (SAR (min + 2, 1235)));   /* { dg-warning \"argument 1 range \\\\\\[1236, -\\[0-9\\]+\\\\\\] is both negative and exceeds maximum object size 1234\" } */\n+  sink (f_int_1 (SAR (min + 2, 1235)));   /* { dg-warning \"argument 1 range \\\\\\[1236, \\[0-9\\]+\\\\\\] exceeds maximum object size 1234\" } */\n+  sink (f_int_1 (SAR (0, max)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]*, -1\\\\\\] is negative\" } */\n+  /* The range below includes zero which would be diagnosed by\n+     -Walloc-size-zero but since all other values are negative it\n+     is diagnosed by -Walloc-size-larger-than.  */\n+  sink (f_int_1 (SAR (1, max)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]*, 0\\\\\\] is negative\" } */\n+  sink (f_int_1 (SAR (2, max)));\n }\n \n void"}, {"sha": "173e4ff7e2af61ddf3be9fb5d028c738f2d253d7", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-7.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-7.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -0,0 +1,72 @@\n+/* Verify that -Wstringop-overflow doesn't cause false positives for\n+   anti-ranges.  Note that not all of the statements below result in\n+   the memset argument being represented as an anti-range.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wstringop-overflow\" } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define UCHAR_MAX (SCHAR_MAX * 2 + 1)\n+\n+#define SHRT_MAX  __SHRT_MAX__\n+#define USHRT_MAX (SHRT_MAX * 2 + 1)\n+\n+#define INT_MAX   __INT_MAX__\n+#define UINT_MAX  (INT_MAX * 2U + 1)\n+\n+#define LONG_MAX __LONG_MAX__\n+#define ULONG_MAX (LONG_MAX * 2LU + 1)\n+\n+#define PTRDIFF_MAX __PTRDIFF_MAX__\n+#define SIZE_MAX    __SIZE_MAX__\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+#define TEST_AR_1(T, prefix)\t\t\t\\\n+  void test_ar_1_ ## prefix (void *d, T n)\t\\\n+  {\t\t\t\t\t\t\\\n+    if (n == prefix ## _MAX - 1)\t\t\\\n+      n = prefix ## _MAX - 2;\t\t\t\\\n+    __builtin_memset (d, 0, n);\t\t\t\\\n+  } typedef void dummy\n+\n+#define TEST_AR_2(T, prefix)\t\t\t\t\t\\\n+  void test_ar_2_ ## prefix (void *d, T n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    if (prefix ## _MAX - 2 <= n && n <= prefix ## _MAX - 1)\t\\\n+      n = prefix ## _MAX - 3;\t\t\t\t\t\\\n+    __builtin_memset (d, 0, n);\t\t\t\t\t\\\n+  } typedef void dummy\n+\n+/* Verify antirange where MIN == MAX.  */\n+TEST_AR_1 (signed char, SCHAR);\n+TEST_AR_1 (unsigned char, UCHAR);\n+\n+TEST_AR_1 (short, SHRT);\n+TEST_AR_1 (unsigned short, USHRT);\n+\n+TEST_AR_1 (int, INT);\n+TEST_AR_1 (unsigned, UINT);\n+\n+TEST_AR_1 (long, LONG);\n+TEST_AR_1 (unsigned long, ULONG);\n+\n+TEST_AR_1 (ptrdiff_t, PTRDIFF);\n+TEST_AR_1 (size_t, SIZE);\n+\n+/* Verify antirange where MIN < MAX.  */\n+TEST_AR_2 (signed char, SCHAR);\n+TEST_AR_2 (unsigned char, UCHAR);\n+\n+TEST_AR_2 (short, SHRT);\n+TEST_AR_2 (unsigned short, USHRT);\n+\n+TEST_AR_2 (int, INT);\n+TEST_AR_2 (unsigned, UINT);\n+\n+TEST_AR_2 (long, LONG);\n+TEST_AR_2 (unsigned long, ULONG);\n+\n+TEST_AR_2 (ptrdiff_t, PTRDIFF);\n+TEST_AR_2 (size_t, SIZE);"}, {"sha": "120c252c99ee128be05ff3d660c0bc91e5707bf6", "filename": "gcc/testsuite/gcc.dg/pr78775.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78775.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78775.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78775.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -0,0 +1,19 @@\n+/* PR c/78775 - [7 Regression] ICE in maybe_warn_alloc_args_overflow\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+int a, b, *c;\n+\n+int main (void)\n+{\n+  unsigned long d = 0;\n+  while (1)\n+    {\n+      switch (b)\n+      case 'S':\n+\td = a;\n+      c = __builtin_malloc (d);\n+    }\n+\n+  return 0;\n+}"}, {"sha": "cc3cfc5b157da45044fdb9cfa0e17e0ff9063496", "filename": "gcc/testsuite/gcc.dg/pr78973-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78973-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78973-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78973-2.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -0,0 +1,25 @@\n+/* PR c/78973 - warning: \u2018memcpy\u2019: specified size exceeds maximum object\n+   size [-Wstringop-overflow=]\n+\n+   This is a companion test for the bug above that verifies that the correct\n+   range of the int variable is detected.\n+\n+   { dg-do compile }\n+   { dg-require-effective-target int32plus }\n+   { dg-options \"-O2 -Walloc-size-larger-than=4\" }  */\n+\n+void *p;\n+\n+void f (int n)\n+{\n+  if (n <= 4)\n+    p = __builtin_malloc (n);\n+  /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+, \\[0-9\\]+\\\\\\] exceeds maximum object size 4\" \"ilp32\" { xfail { ! lp64 } } .-1 } */\n+}\n+\n+void g (unsigned n)\n+{\n+  if (n < 5)\n+    n = 5;\n+  f (n);\n+}"}, {"sha": "a6195f051d959eb343cec2253a8bda2570a43506", "filename": "gcc/testsuite/gcc.dg/pr78973.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78973.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16880eff008084f55a56a07cb7a16453d2b94c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78973.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78973.c?ref=c16880eff008084f55a56a07cb7a16453d2b94c4", "patch": "@@ -0,0 +1,20 @@\n+/* PR c/78973 - warning: \u2018memcpy\u2019: specified size exceeds maximum object size\n+\n+   Test case for what was initially thought to be a false positive but after\n+   deeper investigation turned out to be a true positive.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" }  */\n+\n+void f (void *p, int n)\n+{\n+  if (n <= 4)\n+    __builtin_memset (p, 0, n);   /* { dg-warning \"exceeds maximum object size\" } */\n+}\n+\n+void g (void *d, unsigned n)\n+{\n+  if (n < 5)\n+    n = 5;\n+  f (d, n);\n+}"}]}