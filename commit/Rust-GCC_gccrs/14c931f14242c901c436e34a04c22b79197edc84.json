{"sha": "14c931f14242c901c436e34a04c22b79197edc84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRjOTMxZjE0MjQyYzkwMWM0MzZlMzRhMDRjMjJiNzkxOTdlZGM4NA==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2007-08-30T23:09:28Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2007-08-30T23:09:28Z"}, "message": "c-lex.c (interpret_fixed): Declare.\n\n\t* c-lex.c (interpret_fixed): Declare.\n\t(interpret_float): Process _Fract and _Accum.\n\t(interpret_fixed): New function.\n\t* final.c (output_addr_const): Process CONST_FIXED.\n\t* simplify-rtx.c (simplify_const_unary_operation): Handle US_NEG.\n\t(simplify_binary_operation_1): Handle US_ASHIFT, SS_MULT, US_MULT,\n\tSS_DIV, US_DIV.\n\t(simplify_const_binary_operation): Handle SS_MULT, US_MULT, SS_DIV,\n\tUS_DIV, US_ASHIFT.\n\t(simplify_immed_subreg): Support CONST_FIXED.\n\tProcess MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM.\n\t(simplify_subreg): Support CONST_FIXED.\n\nFrom-SVN: r127941", "tree": {"sha": "147d8f8e5f66c5b18b1af215b5ed27814c9a27a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/147d8f8e5f66c5b18b1af215b5ed27814c9a27a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14c931f14242c901c436e34a04c22b79197edc84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c931f14242c901c436e34a04c22b79197edc84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14c931f14242c901c436e34a04c22b79197edc84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c931f14242c901c436e34a04c22b79197edc84/comments", "author": null, "committer": null, "parents": [{"sha": "ac6b1c676c9713beb3cfe1ac663c60317c57e1f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6b1c676c9713beb3cfe1ac663c60317c57e1f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6b1c676c9713beb3cfe1ac663c60317c57e1f6"}], "stats": {"total": 207, "additions": 205, "deletions": 2}, "files": [{"sha": "b2bde282f1dc97a76dc3efb54add60c126355473", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c931f14242c901c436e34a04c22b79197edc84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c931f14242c901c436e34a04c22b79197edc84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14c931f14242c901c436e34a04c22b79197edc84", "patch": "@@ -1,3 +1,18 @@\n+2007-08-30  Chao-ying Fu  <fu@mips.com>\n+\n+\t* c-lex.c (interpret_fixed): Declare.\n+\t(interpret_float): Process _Fract and _Accum.\n+\t(interpret_fixed): New function.\n+\t* final.c (output_addr_const): Process CONST_FIXED.\n+\t* simplify-rtx.c (simplify_const_unary_operation): Handle US_NEG.\n+\t(simplify_binary_operation_1): Handle US_ASHIFT, SS_MULT, US_MULT,\n+\tSS_DIV, US_DIV.\n+\t(simplify_const_binary_operation): Handle SS_MULT, US_MULT, SS_DIV,\n+\tUS_DIV, US_ASHIFT.\n+\t(simplify_immed_subreg): Support CONST_FIXED.\n+\tProcess MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM.\n+\t(simplify_subreg): Support CONST_FIXED.\n+\n 2007-08-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* config/rs6000/ppu_intrinsics.h: New file."}, {"sha": "17cb9ed5e22ed41212204aaf1d11350eb80aa1c3", "filename": "gcc/c-lex.c", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c931f14242c901c436e34a04c22b79197edc84/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c931f14242c901c436e34a04c22b79197edc84/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=14c931f14242c901c436e34a04c22b79197edc84", "patch": "@@ -61,6 +61,7 @@ bool c_lex_return_raw_strings = false;\n \n static tree interpret_integer (const cpp_token *, unsigned int);\n static tree interpret_float (const cpp_token *, unsigned int);\n+static tree interpret_fixed (const cpp_token *, unsigned int);\n static enum integer_type_kind narrowest_unsigned_type\n \t(unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, unsigned int);\n static enum integer_type_kind narrowest_signed_type\n@@ -640,6 +641,10 @@ interpret_float (const cpp_token *token, unsigned int flags)\n   char *copy;\n   size_t copylen;\n \n+  /* Decode _Fract and _Accum.  */\n+  if (flags & CPP_N_FRACT || flags & CPP_N_ACCUM)\n+    return interpret_fixed (token, flags);\n+\n   /* Decode type based on width and properties. */\n   if (flags & CPP_N_DFLOAT)\n     if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n@@ -731,6 +736,131 @@ interpret_float (const cpp_token *token, unsigned int flags)\n   return value;\n }\n \n+/* Interpret TOKEN, a fixed-point number with FLAGS as classified\n+   by cpplib.  */\n+\n+static tree\n+interpret_fixed (const cpp_token *token, unsigned int flags)\n+{\n+  tree type;\n+  tree value;\n+  FIXED_VALUE_TYPE fixed;\n+  char *copy;\n+  size_t copylen;\n+\n+  copylen = token->val.str.len;\n+\n+  if (flags & CPP_N_FRACT) /* _Fract.  */\n+    {\n+      if (flags & CPP_N_UNSIGNED) /* Unsigned _Fract.  */\n+\t{\n+\t  if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n+\t    {\n+\t      type = unsigned_long_long_fract_type_node;\n+\t      copylen -= 4;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_MEDIUM)\n+\t    {\n+\t      type = unsigned_long_fract_type_node;\n+\t      copylen -= 3;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL)\n+\t    {\n+\t      type = unsigned_short_fract_type_node;\n+\t      copylen -= 3;\n+\t    }\n+          else\n+\t    {\n+\t      type = unsigned_fract_type_node;\n+\t      copylen -= 2;\n+\t    }\n+\t}\n+      else /* Signed _Fract.  */\n+\t{\n+\t  if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n+\t    {\n+\t      type = long_long_fract_type_node;\n+\t      copylen -= 3;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_MEDIUM)\n+\t    {\n+\t      type = long_fract_type_node;\n+\t      copylen -= 2;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL)\n+\t    {\n+\t      type = short_fract_type_node;\n+\t      copylen -= 2;\n+\t    }\n+          else\n+\t    {\n+\t      type = fract_type_node;\n+\t      copylen --;\n+\t    }\n+\t  }\n+    }\n+  else /* _Accum.  */\n+    {\n+      if (flags & CPP_N_UNSIGNED) /* Unsigned _Accum.  */\n+\t{\n+\t  if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n+\t    {\n+\t      type = unsigned_long_long_accum_type_node;\n+\t      copylen -= 4;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_MEDIUM)\n+\t    {\n+\t      type = unsigned_long_accum_type_node;\n+\t      copylen -= 3;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL)\n+\t    {\n+\t      type = unsigned_short_accum_type_node;\n+\t      copylen -= 3;\n+\t     }\n+\t  else\n+\t    {\n+\t      type = unsigned_accum_type_node;\n+\t      copylen -= 2;\n+\t    }\n+\t}\n+      else /* Signed _Accum.  */\n+        {\n+\t  if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n+\t    {\n+\t      type = long_long_accum_type_node;\n+\t      copylen -= 3;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_MEDIUM)\n+\t    {\n+\t      type = long_accum_type_node;\n+\t      copylen -= 2;\n+\t    }\n+\t  else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL)\n+\t    {\n+\t      type = short_accum_type_node;\n+\t      copylen -= 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      type = accum_type_node;\n+\t      copylen --;\n+\t    }\n+\t}\n+    }\n+\n+  copy = (char *) alloca (copylen + 1);\n+  memcpy (copy, token->val.str.text, copylen);\n+  copy[copylen] = '\\0';\n+\n+  fixed_from_string (&fixed, copy, TYPE_MODE (type));\n+\n+  /* Create a node with determined type and value.  */\n+  value = build_fixed (type, fixed);\n+\n+  return value;\n+}\n+\n /* Convert a series of STRING and/or WSTRING tokens into a tree,\n    performing string constant concatenation.  TOK is the first of\n    these.  VALP is the location to write the string into.  OBJC_STRING"}, {"sha": "7c2b4ea9f08d0b7312aa3f1a5fa4d562c314459a", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c931f14242c901c436e34a04c22b79197edc84/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c931f14242c901c436e34a04c22b79197edc84/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=14c931f14242c901c436e34a04c22b79197edc84", "patch": "@@ -3377,6 +3377,10 @@ output_addr_const (FILE *file, rtx x)\n \toutput_operand_lossage (\"floating constant misused\");\n       break;\n \n+    case CONST_FIXED:\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, CONST_FIXED_VALUE_LOW (x));\n+      break;\n+\n     case PLUS:\n       /* Some assemblers need integer constants to appear last (eg masm).  */\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)"}, {"sha": "857b7412343f88b61a1d10b8981ae0da65255084", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c931f14242c901c436e34a04c22b79197edc84/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c931f14242c901c436e34a04c22b79197edc84/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=14c931f14242c901c436e34a04c22b79197edc84", "patch": "@@ -1149,6 +1149,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \tcase SS_TRUNCATE:\n \tcase US_TRUNCATE:\n \tcase SS_NEG:\n+\tcase US_NEG:\n \t  return 0;\n \n \tdefault:\n@@ -2565,6 +2566,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n     case ASHIFT:\n     case SS_ASHIFT:\n+    case US_ASHIFT:\n       if (trueop1 == CONST0_RTX (mode))\n \treturn op0;\n       if (trueop0 == CONST0_RTX (mode) && ! side_effects_p (op1))\n@@ -2644,6 +2646,10 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n     case US_PLUS:\n     case SS_MINUS:\n     case US_MINUS:\n+    case SS_MULT:\n+    case US_MULT:\n+    case SS_DIV:\n+    case US_DIV:\n       /* ??? There are simplifications that can be done.  */\n       return 0;\n \n@@ -3353,7 +3359,12 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \tcase US_PLUS:\n \tcase SS_MINUS:\n \tcase US_MINUS:\n+\tcase SS_MULT:\n+\tcase US_MULT:\n+\tcase SS_DIV:\n+\tcase US_DIV:\n \tcase SS_ASHIFT:\n+\tcase US_ASHIFT:\n \t  /* ??? There are simplifications that can be done.  */\n \t  return 0;\n \t  \n@@ -4466,8 +4477,9 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n   return 0;\n }\n \n-/* Evaluate a SUBREG of a CONST_INT or CONST_DOUBLE or CONST_VECTOR,\n-   returning another CONST_INT or CONST_DOUBLE or CONST_VECTOR.\n+/* Evaluate a SUBREG of a CONST_INT or CONST_DOUBLE or CONST_FIXED\n+   or CONST_VECTOR,\n+   returning another CONST_INT or CONST_DOUBLE or CONST_FIXED or CONST_VECTOR.\n \n    Works by unpacking OP into a collection of 8-bit values\n    represented as a little-endian array of 'unsigned char', selecting by BYTE,\n@@ -4605,6 +4617,25 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t\t*vp++ = 0;\n \t    }\n \t  break;\n+\n+        case CONST_FIXED:\n+\t  if (elem_bitsize <= HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      for (i = 0; i < elem_bitsize; i += value_bit)\n+\t\t*vp++ = CONST_FIXED_VALUE_LOW (el) >> i;\n+\t    }\n+\t  else\n+\t    {\n+\t      for (i = 0; i < HOST_BITS_PER_WIDE_INT; i += value_bit)\n+\t\t*vp++ = CONST_FIXED_VALUE_LOW (el) >> i;\n+              for (; i < 2 * HOST_BITS_PER_WIDE_INT && i < elem_bitsize;\n+\t\t   i += value_bit)\n+\t\t*vp++ = CONST_FIXED_VALUE_HIGH (el)\n+\t\t\t>> (i - HOST_BITS_PER_WIDE_INT);\n+\t      for (; i < elem_bitsize; i += value_bit)\n+\t\t*vp++ = 0;\n+\t    }\n+          break;\n \t  \n \tdefault:\n \t  gcc_unreachable ();\n@@ -4723,6 +4754,28 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t    elems[elem] = CONST_DOUBLE_FROM_REAL_VALUE (r, outer_submode);\n \t  }\n \t  break;\n+\n+\tcase MODE_FRACT:\n+\tcase MODE_UFRACT:\n+\tcase MODE_ACCUM:\n+\tcase MODE_UACCUM:\n+\t  {\n+\t    FIXED_VALUE_TYPE f;\n+\t    f.data.low = 0;\n+\t    f.data.high = 0;\n+\t    f.mode = outer_submode;\n+\n+\t    for (i = 0;\n+\t\t i < HOST_BITS_PER_WIDE_INT && i < elem_bitsize;\n+\t\t i += value_bit)\n+\t      f.data.low |= (HOST_WIDE_INT)(*vp++ & value_mask) << i;\n+\t    for (; i < elem_bitsize; i += value_bit)\n+\t      f.data.high |= ((HOST_WIDE_INT)(*vp++ & value_mask)\n+\t\t\t     << (i - HOST_BITS_PER_WIDE_INT));\n+\n+\t    elems[elem] = CONST_FIXED_FROM_FIXED_VALUE (f, outer_submode);\n+          }\n+          break;\n \t    \n \tdefault:\n \t  gcc_unreachable ();\n@@ -4757,6 +4810,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n \n   if (GET_CODE (op) == CONST_INT\n       || GET_CODE (op) == CONST_DOUBLE\n+      || GET_CODE (op) == CONST_FIXED\n       || GET_CODE (op) == CONST_VECTOR)\n     return simplify_immed_subreg (outermode, op, innermode, byte);\n "}]}