{"sha": "84530511d2506d48804420cae40495950199ff0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ1MzA1MTFkMjUwNmQ0ODgwNDQyMGNhZTQwNDk1OTUwMTk5ZmYwZQ==", "commit": {"author": {"name": "Stan Cox", "email": "scox@cygnus.com", "date": "1998-07-27T11:56:18Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "1998-07-27T11:56:18Z"}, "message": "configure.in: Added i[34567]86-*-win32.\n\nconfig.sub: Ditto.\nconfigure: Rebuilt.\nlonglong.h (count_leading_zeros): Sparclite scan instruction\ni386.c (ix86_prologue): Added SUBTARGET_PROLOGUE invocation.\ni386/cygwin32.h (STARTFILE_SPEC, LIB_SPEC, SUBTARGET_PROLOGUE): Add -pg support.\ni386/win.h: New file.  Hybrid mingw32.h/cygwin32.h configuration.\n\nFrom-SVN: r21411", "tree": {"sha": "627dfb989a3c27cc7535c40fd163b45c714e6b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/627dfb989a3c27cc7535c40fd163b45c714e6b21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84530511d2506d48804420cae40495950199ff0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84530511d2506d48804420cae40495950199ff0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84530511d2506d48804420cae40495950199ff0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84530511d2506d48804420cae40495950199ff0e/comments", "author": null, "committer": null, "parents": [{"sha": "cb99b4a0ce31c0018f08f9d713ac4ecf75d7e705", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb99b4a0ce31c0018f08f9d713ac4ecf75d7e705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb99b4a0ce31c0018f08f9d713ac4ecf75d7e705"}], "stats": {"total": 350, "additions": 343, "deletions": 7}, "files": [{"sha": "a325bad9621c0cc1946f4b6620b90e27c06784fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -1,3 +1,16 @@\n+Mon Jul 27 11:43:54 1998  Stan Cox  <scox@cygnus.com>\n+\n+\t* longlong.h (count_leading_zeros): Sparclite scan instruction was\n+\tbeing invoked incorrectly.\n+\n+\t* i386.c (ix86_prologue): Added SUBTARGET_PROLOGUE invocation.\n+\t* i386/cygwin32.h (STARTFILE_SPEC, LIB_SPEC, SUBTARGET_PROLOGUE): \n+\tAdd -pg support. \n+\t* i386/win32.h: New file.  Hybrid mingw32.h/cygwin32.h configuration.\n+\t* configure.in: Added i[34567]86-*-win32\n+\t* config.sub: Ditto.\n+\t* configure: Rebuilt.\n+\t\n Sun Jul 26 01:11:12 1998  H.J. Lu  (hjl@gnu.org)\n \n \t* i386.h (CONST_DOUBLE_OK_FOR_LETTER_P): Return 0 when eliminating"}, {"sha": "0691e25bdcee5fb84c00002dd8de08c74a995841", "filename": "gcc/config.sub", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.sub?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -732,6 +732,7 @@ case $os in\n \t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n \t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n \t      | -cygwin32* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n+\t      | -win32* | -mingw32* | -linux-gnu* | -uxpv* | -beos* )\n \t      | -mingw32* | -linux-gnu* | -uxpv* | -beos* )\n \t# Remember, each alternative MUST END IN *, to match a version number.\n \t\t;;"}, {"sha": "5ccc51d5e114a35b7ee63096d0c4d2a4f00c8400", "filename": "gcc/config/i386/cygwin32.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin32.h?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -59,17 +59,18 @@ Boston, MA 02111-1307, USA. */\n    ld, but that doesn't work just yet.  */\n \n #undef LIB_SPEC\n-#define LIB_SPEC \"-lcygwin %{mwindows:-luser32 -lgdi32 -lcomdlg32} -lkernel32 \\\n-  -ladvapi32 -lshell32\"\n+#define LIB_SPEC \"%{pg:-lgmon} -lcygwin %{mwindows:-luser32 -lgdi32 -lcomdlg32}\\\n+   -lkernel32 -ladvapi32 -lshell32\"\n \n #define LINK_SPEC \"%{mwindows:--subsystem windows}\"\n \n /* Normally, -lgcc is not needed since everything in it is in the DLL, but we\n    want to allow things to be added to it when installing new versions of\n-   GCC without making a new CYGWIN.DLL, so we leave it.  */\n+   GCC without making a new CYGWIN.DLL, so we leave it.  Profiling is handled\n+   by calling the init function from the prologue. */\n \n #undef STARTFILE_SPEC\n-#define STARTFILE_SPEC \"crt0%O%s\"\n+#define STARTFILE_SPEC \"%{pg:gcrt0%O%s} crt0%O%s\"\n \n #define SIZE_TYPE \"unsigned int\"\n #define PTRDIFF_TYPE \"int\"\n@@ -389,6 +390,20 @@ do {\t\t\t\t\t\t\t\t\\\n /* Don't assume anything about the header files. */\n #define NO_IMPLICIT_EXTERN_C\n \n+#define SUBTARGET_PROLOGUE\t\t\t\t\t\t\\\n+  if (profile_flag \t\t\t\t\t\t\t\\\n+      && strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\\\n+\t\t \"main\") == 0)\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\t\\\n+      rtx xops[1];\t\t\t\t\t\t\t\\\n+      xops[0] = gen_rtx_MEM (FUNCTION_MODE,\t\t\t\t\\\n+\t\t\t gen_rtx (SYMBOL_REF, Pmode, \"_monstartup\"));\t\\\n+      if (do_rtl)\t\t\t\t\t\t\t\\\n+\temit_call_insn (gen_rtx (CALL, VOIDmode, xops[0], const0_rtx));\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\toutput_asm_insn (AS1 (call,%P1), xops);\t\t\t\\\n+     }\n+\n /* External function declarations.  */\n \n #ifndef PROTO"}, {"sha": "a529b0fb21bcc794a2fcb599f1e956aacd4dee30", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -2179,6 +2179,10 @@ ix86_prologue (do_rtl)\n  \t  }\n       }\n \n+#ifdef SUBTARGET_PROLOGUE\n+  SUBTARGET_PROLOGUE;\n+#endif  \n+\n   if (pic_reg_used)\n     load_pic_register (do_rtl);\n "}, {"sha": "32fd2949b3f6b37002189b35aa8ffabe69d3e9bc", "filename": "gcc/config/i386/win32.h", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig%2Fi386%2Fwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfig%2Fi386%2Fwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwin32.h?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -0,0 +1,277 @@\n+/* Operating system specific defines to be used when targeting GCC for\n+   hosting on Windows NT 3.x, using a Unix style C library and tools,\n+   as distinct from winnt.h, which is used to build GCC for use with a\n+   windows style library and tool set and uses the Microsoft tools.\n+   Copyright (C) 1995-1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. */\n+\n+#define YES_UNDERSCORES\n+\n+#define DBX_DEBUGGING_INFO \n+#define SDB_DEBUGGING_INFO \n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#include \"i386/gas.h\"\n+#include \"dbxcoff.h\"\n+\n+/* Augment TARGET_SWITCHES with the cygwin/win32 options. */\n+#define MASK_WIN32 0x40000000 /* Use -lming32 interface */\n+#define MASK_CYGWIN  0x20000000 /* Use -lcygwin interface */\n+#define MASK_WINDOWS 0x10000000 /* Use windows interface */\n+#define MASK_DLL     0x08000000 /* Use dll interface    */\n+#define MASK_NOP_FUN_DLLIMPORT 0x20000 /* Ignore dllimport for functions */\n+\n+#define TARGET_WIN32             (target_flags & MASK_WIN32)\n+#define TARGET_CYGWIN            (target_flags & MASK_CYGWIN)\n+#define TARGET_WINDOWS           (target_flags & MASK_WINDOWS)\n+#define TARGET_DLL               (target_flags & MASK_DLL)\n+#define TARGET_NOP_FUN_DLLIMPORT (target_flags & MASK_NOP_FUN_DLLIMPORT)\n+\n+#undef  SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES \\\n+    { \"win32\",                           MASK_WIN32 }, \\\n+    { \"cygwin\",                          MASK_CYGWIN },  \\\n+    { \"windows\",                         MASK_WINDOWS }, \\\n+    { \"dll\",                             MASK_DLL },     \\\n+    { \"nop-fun-dllimport\",\t\t MASK_NOP_FUN_DLLIMPORT }, \\\n+    { \"no-nop-fun-dllimport\",\t\t MASK_NOP_FUN_DLLIMPORT },\n+\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-D_WIN32 \\\n+  -DWINNT  -D_X86_=1 -D__STDC__=1\\\n+  -D__stdcall=__attribute__((__stdcall__)) \\\n+  -D__cdecl=__attribute__((__cdecl__)) \\\n+  -Asystem(winnt)\"\n+\n+#undef STARTFILE_SPEC\n+\n+#define STARTFILE_SPEC \"%{mdll:dllcrt0%O%s} %{!mdll: %{!mcygwin:mcrt0%O%s} \\\n+                        %{mcygwin:crt0%O%s} %{pg:gcrt0%O%s}}\"\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%(cpp_cpu) %{posix:-D_POSIX_SOURCE} \\\n+  %{!mcygwin:-iwithprefixbefore include/mingw32 -D__MINGW32__}    \\\n+  %{mcygwin:-D__CYGWIN32__}\"\n+\n+/* We have to dynamic link to get to the system DLLs.  All of libc, libm and\n+   the Unix stuff is in cygwin.dll.  The import library is called\n+   'libcygwin.a'.  For Windows applications, include more libraries, but\n+   always include kernel32.  We'd like to specific subsystem windows to\n+   ld, but that doesn't work just yet.  */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{pg:-lgmon}\t\t\t\t\t\t\\\n+\t\t  %{!mcygwin:-lmingw32 -lmoldname -lmsvcrt -lcrtdll}\t\\\n+                  %{mcygwin:-lcygwin} %{mwindows:-luser32 -lgdi32 -lcomdlg32} \\\n+                  -lkernel32 -ladvapi32 -lshell32\"\n+\n+#define LINK_SPEC \"%{mwindows:--subsystem windows} \\\n+  %{mdll:--dll -e _DllMainCRTStartup@12}\"\n+\n+#define SIZE_TYPE \"unsigned int\"\n+#define PTRDIFF_TYPE \"int\"\n+#define WCHAR_UNSIGNED 1\n+#define WCHAR_TYPE_SIZE 16\n+#define WCHAR_TYPE \"short unsigned int\"\n+/* Currently we do not have the atexit() function,\n+   so take that from libgcc2.c */\n+\n+#define NEED_ATEXIT 1\n+#define HAVE_ATEXIT 1     \n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_ctor, in_dtor\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+  CTOR_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTOR_SECTION_FUNCTION\n+\n+#define CTOR_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+ctor_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctor)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.section .ctor\\n\");\t\t\\\n+      in_section = in_ctor;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTOR_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+dtor_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtor)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.section .dtor\\n\");\t\t\\\n+      in_section = in_dtor;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n+  do {\t\t\t\t\t\t\\\n+    ctor_section ();\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t\", ASM_LONG);\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\\\n+  } while (0)\n+\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\\\n+  do {\t\t\t\t\t\t\\\n+    dtor_section ();                   \t\t\\\n+    fprintf (FILE, \"%s\\t\", ASM_LONG);\t\t\\\n+    assemble_name (FILE, NAME);              \t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   On i386, if using PIC, mark a SYMBOL_REF for a non-global symbol\n+   so that we may access it directly in the GOT.\n+\n+   On i386 running Windows NT, modify the assembler name with a suffix \n+   consisting of an atsign (@) followed by string of digits that represents\n+   the number of bytes of arguments passed to the function, if it has the \n+   attribute STDCALL. */\n+\n+#ifdef ENCODE_SECTION_INFO\n+#undef ENCODE_SECTION_INFO\n+#define ENCODE_SECTION_INFO(DECL) \t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n+\t\t   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\t\\\n+\tSYMBOL_REF_FLAG (XEXP (rtl, 0))\t\t\t\t\t\\\n+\t  = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\t\\\n+\t     || ! TREE_PUBLIC (DECL));\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (TREE_CODE (DECL) == FUNCTION_DECL) \t\t\t\t\\\n+      if (lookup_attribute (\"stdcall\",\t\t\t\t\t\\\n+\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (DECL))))\t\\\n+        XEXP (DECL_RTL (DECL), 0) = \t\t\t\t\t\\\n+          gen_rtx (SYMBOL_REF, Pmode, gen_stdcall_suffix (DECL)); \t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+#endif\n+\n+/* This macro gets just the user-specified name\n+   out of the string in a SYMBOL_REF.  Discard\n+   trailing @[NUM] encoded by ENCODE_SECTION_INFO. \n+   Do we need the stripping of leading '*'?  */\n+#undef  STRIP_NAME_ENCODING\n+#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  char *_p;\t\t\t\t\t\t\t\t\\\n+  char *_name = ((SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*'));\t\t\\\n+  for (_p = _name; *_p && *_p != '@'; ++_p)\t\t\t\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  if (*_p == '@')\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int _len = _p - _name;\t\t\t\t\t\t\\\n+      (VAR) = (char *) alloca (_len + 1);\t\t\t\t\\\n+      strncpy ((VAR), _name, _len);\t\t\t\t\t\\\n+      (VAR)[_len] = '\\0';\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    (VAR) = _name;\t\t\t\t\t\t\t\\\n+} while (0)\n+      \n+\n+/* Emit code to check the stack when allocating more that 4000\n+   bytes in one go. */\n+\n+#define CHECK_STACK_LIMIT 4000\n+\n+/* By default, target has a 80387, uses IEEE compatible arithmetic,\n+   and returns float values in the 387 and needs stack probes */\n+#undef TARGET_DEFAULT\n+\n+#define TARGET_DEFAULT \\\n+   (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE) \n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n+\n+/* Define this macro if in some cases global symbols from one translation\n+   unit may not be bound to undefined symbols in another translation unit\n+   without user intervention.  For instance, under Microsoft Windows\n+   symbols must be explicitly imported from shared libraries (DLLs).  */\n+#define MULTIPLE_SYMBOL_SPACES\n+\n+#define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n+extern void i386_pe_unique_section ();\n+#define UNIQUE_SECTION(DECL,RELOC) i386_pe_unique_section (DECL, RELOC)\n+\n+#define SUPPORTS_ONE_ONLY 1\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#undef ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n+  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n+  /* Functions may have been compiled at various levels of\t\\\n+     optimization so we can't use `same_size' here.  Instead,\t\\\n+     have the linker pick one.  */\t\t\t\t\\\n+  if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n+\t     TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+\t     ? \"discard\" : \"same_size\");\t\t\t\\\n+} while (0)\n+\n+#undef ASM_COMMENT_START\n+#define ASM_COMMENT_START \" #\"\n+\n+/* DWARF2 Unwinding doesn't work with exception handling yet. */\n+#define DWARF2_UNWIND_INFO 0\n+\n+/* Don't assume anything about the header files. */\n+#define NO_IMPLICIT_EXTERN_C\n+\n+#define SUBTARGET_PROLOGUE\t\t\t\t\t\t\\\n+  if (profile_flag \t\t\t\t\t\t\t\\\n+      && strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\\\n+\t\t \"main\") == 0)\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\t\\\n+      rtx xops[1];\t\t\t\t\t\t\t\\\n+      xops[0] = gen_rtx_MEM (FUNCTION_MODE,\t\t\t\t\\\n+\t\t\t gen_rtx (SYMBOL_REF, Pmode, \"_monstartup\"));\t\\\n+      if (do_rtl)\t\t\t\t\t\t\t\\\n+\temit_call_insn (gen_rtx (CALL, VOIDmode, xops[0], const0_rtx));\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\toutput_asm_insn (AS1 (call,%P1), xops);\t\t\t\\\n+     }"}, {"sha": "1fbcbe48fdad7c7b2e5799b71346adf4f6215fe3", "filename": "gcc/configure", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -3048,6 +3048,18 @@ for machine in $build $host $target; do\n \t\ttmake_file=i386/t-vsta\n \t\txmake_file=i386/x-vsta\n \t\t;;\n+\ti[34567]86-*-win32)\n+\t\txm_file=\"${xm_file} i386/xm-cygwin32.h\"\n+\t\ttmake_file=i386/t-cygwin32\n+\t\ttm_file=i386/win32.h\n+\t\txmake_file=i386/x-cygwin32\n+\t\textra_objs=winnt.o\n+\t\tfixincludes=Makefile.in\n+ \t\tif [ x$enable_threads = xyes ]; then\n+\t\t\tthread_file='win32'\n+\t\tfi\n+\t\texeext=.exe\n+\t\t;;\n \ti[34567]86-*-pe | i[34567]86-*-cygwin32)\n \t\txm_file=\"${xm_file} i386/xm-cygwin32.h\"\n \t\ttmake_file=i386/t-cygwin32"}, {"sha": "75044f8a6a5da6c8605ad18e2d4b50113eb354cf", "filename": "gcc/configure.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -1139,6 +1139,18 @@ for machine in $build $host $target; do\n \t\ttmake_file=i386/t-vsta\n \t\txmake_file=i386/x-vsta\n \t\t;;\n+\ti[[34567]]86-*-win32)\n+\t\txm_file=\"${xm_file} i386/xm-cygwin32.h\"\n+\t\ttmake_file=i386/t-cygwin32\n+\t\ttm_file=i386/win32.h\n+\t\txmake_file=i386/x-cygwin32\n+\t\textra_objs=winnt.o\n+\t\tfixincludes=Makefile.in\n+ \t\tif [[ x$enable_threads = xyes ]]; then\n+\t\t\tthread_file='win32'\n+\t\tfi\n+\t\texeext=.exe\n+\t\t;;\n \ti[[34567]]86-*-pe | i[[34567]]86-*-cygwin32)\n \t\txm_file=\"${xm_file} i386/xm-cygwin32.h\"\n \t\ttmake_file=i386/t-cygwin32"}, {"sha": "2c047117d44a0ef9d6b9e43a6d3883bfc5842cad", "filename": "gcc/longlong.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84530511d2506d48804420cae40495950199ff0e/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84530511d2506d48804420cae40495950199ff0e/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=84530511d2506d48804420cae40495950199ff0e", "patch": "@@ -978,9 +978,11 @@ UDItype __umulsidi3 (USItype, USItype);\n \t   : \"%g1\" __AND_CLOBBER_CC)\n #define UDIV_TIME 37\n #define count_leading_zeros(count, x) \\\n-  __asm__ (\"scan %1,0,%0\"\t\t\t\t\t\t\\\n-\t   : \"=r\" ((USItype) (x))\t\t\t\t\t\\\n-\t   : \"r\" ((USItype) (count)))\n+  do {                                                                  \\\n+  __asm__ (\"scan %1,1,%0\"                                               \\\n+           : \"=r\" ((USItype) (count))                                   \\\n+           : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n+  } while (0)    \n #else\n /* SPARC without integer multiplication and divide instructions.\n    (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */"}]}