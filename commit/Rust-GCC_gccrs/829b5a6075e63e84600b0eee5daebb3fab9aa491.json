{"sha": "829b5a6075e63e84600b0eee5daebb3fab9aa491", "node_id": "C_kwDOANBUbNoAKDgyOWI1YTYwNzVlNjNlODQ2MDBiMGVlZTVkYWViYjNmYWI5YWE0OTE", "commit": {"author": {"name": "Julien Bortolussi", "email": "bortolussi@adacore.com", "date": "2022-05-19T13:49:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-12T12:24:10Z"}, "message": "[Ada] Add new unbounded and indefinite formal doubly linked list\n\nBefore this patch, the only formal doubly linked lists were bounded and\ndefinite. This means that it is necessary to provide their maximum\nlength or capacity at instantiation and that they can only be used with\ndefinite element types.\n\nThe formal lists added by this patch are unbounded and indefinite.\nTheir length grows dynamically until Count_Type'Last. This makes them\neasier to use but requires the use of dynamic allocation and controlled\ntypes.\n\ngcc/ada/\n\n\t* libgnat/a-cfidll.adb, libgnat/a-cfidll.ads: Implementation\n\tfiles of the formal unbounded indefinite list.\n\t* Makefile.rtl, impunit.adb: Take into account the add of the\n\tnew files.", "tree": {"sha": "ad1991735576def5549aaabde62d2b2ed1a656aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad1991735576def5549aaabde62d2b2ed1a656aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/829b5a6075e63e84600b0eee5daebb3fab9aa491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829b5a6075e63e84600b0eee5daebb3fab9aa491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/829b5a6075e63e84600b0eee5daebb3fab9aa491", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829b5a6075e63e84600b0eee5daebb3fab9aa491/comments", "author": {"login": "JulienBortolussiAda", "id": 103429088, "node_id": "U_kgDOBioz4A", "avatar_url": "https://avatars.githubusercontent.com/u/103429088?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulienBortolussiAda", "html_url": "https://github.com/JulienBortolussiAda", "followers_url": "https://api.github.com/users/JulienBortolussiAda/followers", "following_url": "https://api.github.com/users/JulienBortolussiAda/following{/other_user}", "gists_url": "https://api.github.com/users/JulienBortolussiAda/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulienBortolussiAda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulienBortolussiAda/subscriptions", "organizations_url": "https://api.github.com/users/JulienBortolussiAda/orgs", "repos_url": "https://api.github.com/users/JulienBortolussiAda/repos", "events_url": "https://api.github.com/users/JulienBortolussiAda/events{/privacy}", "received_events_url": "https://api.github.com/users/JulienBortolussiAda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "474946c61a5dd5335ced09d52a95d1e3d90d1455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474946c61a5dd5335ced09d52a95d1e3d90d1455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/474946c61a5dd5335ced09d52a95d1e3d90d1455"}], "stats": {"total": 3726, "additions": 3726, "deletions": 0}, "files": [{"sha": "00137f20433f9fbc8d0e5223acae078420b32afc", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=829b5a6075e63e84600b0eee5daebb3fab9aa491", "patch": "@@ -113,6 +113,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cfdlli$(objext) \\\n   a-cfhama$(objext) \\\n   a-cfhase$(objext) \\\n+  a-cfidll$(objext) \\\n   a-cfinve$(objext) \\\n   a-cfinse$(objext) \\\n   a-cforma$(objext) \\"}, {"sha": "343a9dbe8f94f713623f8071c320232b19d8f283", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=829b5a6075e63e84600b0eee5daebb3fab9aa491", "patch": "@@ -605,6 +605,7 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 2012 --\n    ----------------------------------------\n \n+    (\"a-cfidll\", F),  -- Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists\n     (\"a-cfinse\", F),  -- Ada.Containers.Functional_Infinite_Sequences\n     (\"a-cfinve\", F),  -- Ada.Containers.Formal_Indefinite_Vectors\n     (\"a-coboho\", F),  -- Ada.Containers.Bounded_Holders"}, {"sha": "17e48d29e65fbd60403a55972d1ee932cd343e6a", "filename": "gcc/ada/libgnat/a-cfidll.adb", "status": "added", "additions": 2054, "deletions": 0, "changes": 2054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb?ref=829b5a6075e63e84600b0eee5daebb3fab9aa491", "patch": "@@ -0,0 +1,2054 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--           ADA.CONTAINERS.FORMAL_INDEFINITE_DOUBLY_LINKED_LISTS           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n+\n+with System; use type System.Address;\n+\n+with Ada.Numerics.Big_Numbers.Big_Integers;\n+use Ada.Numerics.Big_Numbers.Big_Integers;\n+\n+package body Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists with\n+  SPARK_Mode => Off\n+is\n+   --  Convert Count_Type to Big_Integer\n+\n+   package Conversions is new Signed_Conversions (Int => Count_Type);\n+   use Conversions;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type);\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Node  : out Count_Type);\n+\n+   procedure Free (Container : in out List; X : Count_Type);\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type);\n+\n+   function Vet (L : List; Position : Cursor) return Boolean with Inline;\n+\n+   procedure Resize (Container : in out List) with\n+   --  Add more room in the internal array\n+\n+     Global => null,\n+     Pre    => Container.Nodes = null\n+                 or else Length (Container) = Container.Nodes'Length,\n+     Post   => Model (Container) = Model (Container)'Old\n+                 and Positions (Container) = Positions (Container)'Old;\n+\n+   procedure Finalize_Element is new Ada.Unchecked_Deallocation\n+     (Object => Element_Type,\n+      Name   => Element_Access);\n+\n+   procedure Finalize_Nodes is new Ada.Unchecked_Deallocation\n+     (Object => Node_Array,\n+      Name   => Node_Array_Access);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left : List; Right : List) return Boolean is\n+      LI : Count_Type;\n+      RI : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Length /= Right.Length then\n+         return False;\n+      end if;\n+\n+      LI := Left.First;\n+      RI := Right.First;\n+      while LI /= 0 loop\n+         if Left.Nodes (LI).Element.all /= Right.Nodes (RI).Element.all then\n+            return False;\n+         end if;\n+\n+         LI := Left.Nodes (LI).Next;\n+         RI := Right.Nodes (RI).Next;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   overriding procedure Adjust (Container : in out List) is\n+      N_Src : Node_Array_Access renames Container.Nodes;\n+      N_Tar : Node_Array_Access;\n+\n+   begin\n+      if N_Src = null then\n+         return;\n+      end if;\n+\n+      if Container.Length = 0 then\n+         Container.Nodes := null;\n+         Container.Free := -1;\n+         return;\n+      end if;\n+\n+      N_Tar := new Node_Array (1 .. N_Src'Length);\n+\n+      for X in 1 .. Count_Type (N_Src'Length) loop\n+         N_Tar (X) := N_Src (X);\n+         if N_Src (X).Element /= null\n+         then\n+            N_Tar (X).Element := new Element_Type'(N_Src (X).Element.all);\n+         end if;\n+      end loop;\n+\n+      N_Src := N_Tar;\n+\n+   end Adjust;\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Node  : out Count_Type)\n+   is\n+      N : Node_Array_Access renames Container.Nodes;\n+\n+   begin\n+      if Container.Nodes = null\n+        or else Length (Container) = Container.Nodes'Length\n+      then\n+         Resize (Container);\n+      end if;\n+\n+      if Container.Free >= 0 then\n+         New_Node := Container.Free;\n+         Container.Free := N (New_Node).Next;\n+      else\n+         New_Node := abs Container.Free;\n+         Container.Free := Container.Free - 1;\n+      end if;\n+\n+      N (New_Node).Element := null;\n+   end Allocate;\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type)\n+   is\n+      N : Node_Array_Access renames Container.Nodes;\n+\n+   begin\n+      Allocate (Container, New_Node);\n+\n+      N (New_Node).Element := new Element_Type'(New_Item);\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append (Container : in out List; New_Item : Element_Type) is\n+   begin\n+      Insert (Container, No_Element, New_Item, 1);\n+   end Append;\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      Insert (Container, No_Element, New_Item, Count);\n+   end Append;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out List; Source : List) is\n+      N : Node_Array_Access renames Source.Nodes;\n+      J : Count_Type;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Clear (Target);\n+\n+      J := Source.First;\n+      while J /= 0 loop\n+         Append (Target, N (J).Element.all);\n+         J := N (J).Next;\n+      end loop;\n+   end Assign;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out List) is\n+      N : Node_Array_Access renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last  = 0);\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last  >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next  = 0);\n+\n+      while Container.Length > 1 loop\n+         X := Container.First;\n+\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+\n+      X := Container.First;\n+\n+      Container.First := 0;\n+      Container.Last := 0;\n+      Container.Length := 0;\n+\n+      Free (Container, X);\n+   end Clear;\n+\n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : List;\n+      Position  : Cursor) return not null access constant Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container => Container, Position  => Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return Container.Nodes (Position.Node).Element;\n+   end Constant_Reference;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : List) return List\n+   is\n+      N : Count_Type;\n+      P : List;\n+\n+   begin\n+      if Source.Nodes = null then\n+         return P;\n+      end if;\n+\n+      P.Nodes := new Node_Array (1 .. Source.Nodes'Length);\n+\n+      N := 1;\n+      while N <= Source.Nodes'Length loop\n+         P.Nodes (N).Prev := Source.Nodes (N).Prev;\n+         P.Nodes (N).Next := Source.Nodes (N).Next;\n+         if Source.Nodes (N).Element /= null then\n+            P.Nodes (N).Element :=\n+              new Element_Type'(Source.Nodes (N).Element.all);\n+         end if;\n+         N := N + 1;\n+      end loop;\n+\n+      P.Free   := Source.Free;\n+      P.Length := Source.Length;\n+      P.First  := Source.First;\n+      P.Last   := Source.Last;\n+\n+      return P;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out List; Position : in out Cursor) is\n+   begin\n+      Delete\n+        (Container => Container,\n+         Position  => Position,\n+         Count     => 1);\n+   end Delete;\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type)\n+   is\n+      N : Node_Array_Access renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if not Has_Element (Container => Container,\n+                          Position  => Position)\n+      then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last  >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next  = 0);\n+\n+      if Position.Node = Container.First then\n+         Delete_First (Container, Count);\n+         Position := No_Element;\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := No_Element;\n+         return;\n+      end if;\n+\n+      for Index in 1 .. Count loop\n+         pragma Assert (Container.Length >= 2);\n+\n+         X := Position.Node;\n+         Container.Length := Container.Length - 1;\n+\n+         if X = Container.Last then\n+            Position := No_Element;\n+\n+            Container.Last := N (X).Prev;\n+            N (Container.Last).Next := 0;\n+\n+            Free (Container, X);\n+            return;\n+         end if;\n+\n+         Position.Node := N (X).Next;\n+         pragma Assert (N (Position.Node).Prev >= 0);\n+\n+         N (N (X).Next).Prev := N (X).Prev;\n+         N (N (X).Prev).Next := N (X).Next;\n+\n+         Free (Container, X);\n+      end loop;\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out List) is\n+   begin\n+      Delete_First\n+        (Container => Container,\n+         Count     => 1);\n+   end Delete_First;\n+\n+   procedure Delete_First (Container : in out List; Count : Count_Type) is\n+      N : Node_Array_Access renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      for J in 1 .. Count loop\n+         X := Container.First;\n+         pragma Assert (N (N (X).Next).Prev = Container.First);\n+\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out List) is\n+   begin\n+      Delete_Last\n+        (Container => Container,\n+         Count     => 1);\n+   end Delete_Last;\n+\n+   procedure Delete_Last (Container : in out List; Count : Count_Type) is\n+      N : Node_Array_Access renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      for J in 1 .. Count loop\n+         X := Container.Last;\n+         pragma Assert (N (N (X).Prev).Next = Container.Last);\n+\n+         Container.Last := N (X).Prev;\n+         N (Container.Last).Next := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Container : List;\n+      Position  : Cursor) return Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container => Container, Position  => Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return Container.Nodes (Position.Node).Element.all;\n+   end Element;\n+\n+   ----------------\n+   -- Empty_List --\n+   ----------------\n+\n+   function Empty_List return List is\n+      ((Controlled with others => <>));\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Container : in out List) is\n+      X : Count_Type := Container.First;\n+      N : Node_Array_Access renames Container.Nodes;\n+   begin\n+\n+      if N = null then\n+         return;\n+      end if;\n+\n+      while X /= 0 loop\n+         Finalize_Element (N (X).Element);\n+         X := N (X).Next;\n+      end loop;\n+\n+      Finalize_Nodes (N);\n+\n+      Container.Free := 0;\n+      Container.Last := 0;\n+      Container.First := 0;\n+      Container.Length := 0;\n+   end Finalize;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      From : Count_Type := Position.Node;\n+\n+   begin\n+      if From = 0 and Container.Length = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if From = 0 then\n+         From := Container.First;\n+      end if;\n+\n+      if Position.Node /= 0 and then not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      while From /= 0 loop\n+         if Container.Nodes (From).Element.all = Item then\n+            return (Node => From);\n+         end if;\n+\n+         From := Container.Nodes (From).Next;\n+      end loop;\n+\n+      return No_Element;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : List) return Cursor is\n+   begin\n+      if Container.First = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return (Node => Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : List) return Element_Type is\n+      F : constant Count_Type := Container.First;\n+   begin\n+      if F = 0 then\n+         raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.Nodes (F).Element.all;\n+      end if;\n+   end First_Element;\n+\n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n+\n+   package body Formal_Model is\n+\n+      ----------------------------\n+      -- Lift_Abstraction_Level --\n+      ----------------------------\n+\n+      procedure Lift_Abstraction_Level (Container : List) is null;\n+\n+      -------------------------\n+      -- M_Elements_In_Union --\n+      -------------------------\n+\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n+      is\n+         Elem : Element_Type;\n+\n+      begin\n+         for Index in 1 .. M.Length (Container) loop\n+            Elem := Element (Container, Index);\n+\n+            if not M.Contains (Left, 1, M.Length (Left), Elem)\n+               and then not M.Contains (Right, 1, M.Length (Right), Elem)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_In_Union;\n+\n+      -------------------------\n+      -- M_Elements_Included --\n+      -------------------------\n+\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Positive_Count_Type := 1;\n+         L_Lst : Count_Type;\n+         Right : M.Sequence;\n+         R_Fst : Positive_Count_Type := 1;\n+         R_Lst : Count_Type) return Boolean\n+      is\n+      begin\n+         for I in L_Fst .. L_Lst loop\n+            declare\n+               Found : Boolean := False;\n+               J     : Count_Type := R_Fst - 1;\n+\n+            begin\n+               while not Found and J < R_Lst loop\n+                  J := J + 1;\n+                  if Element (Left, I) = Element (Right, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               if not Found then\n+                  return False;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Included;\n+\n+      -------------------------\n+      -- M_Elements_Reversed --\n+      -------------------------\n+\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      is\n+         L : constant Count_Type := M.Length (Left);\n+\n+      begin\n+         if L /= M.Length (Right) then\n+            return False;\n+         end if;\n+\n+         for I in 1 .. L loop\n+            if Element (Left, I) /= Element (Right, L - I + 1) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Reversed;\n+\n+      ------------------------\n+      -- M_Elements_Swapped --\n+      ------------------------\n+\n+      function M_Elements_Swapped\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X     : Positive_Count_Type;\n+         Y     : Positive_Count_Type) return Boolean\n+      is\n+      begin\n+         if M.Length (Left) /= M.Length (Right)\n+           or else Element (Left, X) /= Element (Right, Y)\n+           or else Element (Left, Y) /= Element (Right, X)\n+         then\n+            return False;\n+         end if;\n+\n+         for I in 1 .. M.Length (Left) loop\n+            if I /= X and then I /= Y\n+              and then Element (Left, I) /= Element (Right, I)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Swapped;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : List) return M.Sequence is\n+         Position : Count_Type := Container.First;\n+         R        : M.Sequence;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := M.Add (R, Container.Nodes (Position).Element.all);\n+            Position := Container.Nodes (Position).Next;\n+         end loop;\n+\n+         return R;\n+      end Model;\n+\n+      -----------------------\n+      -- Mapping_Preserved --\n+      -----------------------\n+\n+      function Mapping_Preserved\n+        (M_Left  : M.Sequence;\n+         M_Right : M.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      is\n+      begin\n+         for C of P_Left loop\n+            if not P.Has_Key (P_Right, C)\n+              or else P.Get (P_Left,  C) > M.Length (M_Left)\n+              or else P.Get (P_Right, C) > M.Length (M_Right)\n+              or else M.Get (M_Left,  P.Get (P_Left,  C)) /=\n+                      M.Get (M_Right, P.Get (P_Right, C))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for C of P_Right loop\n+            if not P.Has_Key (P_Left, C) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Mapping_Preserved;\n+\n+      -------------------------\n+      -- P_Positions_Shifted --\n+      -------------------------\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      is\n+      begin\n+         for Cu of Small loop\n+            if not P.Has_Key (Big, Cu) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for Cu of Big loop\n+            declare\n+               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+\n+            begin\n+               if Pos < Cut then\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu)\n+                  then\n+                     return False;\n+                  end if;\n+\n+               elsif Pos >= Cut + Count then\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu) + Count\n+                  then\n+                     return False;\n+                  end if;\n+\n+               else\n+                  if P.Has_Key (Small, Cu) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end P_Positions_Shifted;\n+\n+      -------------------------\n+      -- P_Positions_Swapped --\n+      -------------------------\n+\n+      function P_Positions_Swapped\n+        (Left  : P.Map;\n+         Right : P.Map;\n+         X     : Cursor;\n+         Y     : Cursor) return Boolean\n+      is\n+      begin\n+         if not P.Has_Key (Left, X)\n+           or not P.Has_Key (Left, Y)\n+           or not P.Has_Key (Right, X)\n+           or not P.Has_Key (Right, Y)\n+         then\n+            return False;\n+         end if;\n+\n+         if P.Get (Left, X) /= P.Get (Right, Y)\n+           or P.Get (Left, Y) /= P.Get (Right, X)\n+         then\n+            return False;\n+         end if;\n+\n+         for C of Left loop\n+            if not P.Has_Key (Right, C) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for C of Right loop\n+            if not P.Has_Key (Left, C)\n+              or else (C /= X\n+                        and C /= Y\n+                        and P.Get (Left, C) /= P.Get (Right, C))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end P_Positions_Swapped;\n+\n+      ---------------------------\n+      -- P_Positions_Truncated --\n+      ---------------------------\n+\n+      function P_Positions_Truncated\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      is\n+      begin\n+         for Cu of Small loop\n+            if not P.Has_Key (Big, Cu) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for Cu of Big loop\n+            declare\n+               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+\n+            begin\n+               if Pos < Cut then\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu)\n+                  then\n+                     return False;\n+                  end if;\n+\n+               elsif Pos >= Cut + Count then\n+                  return False;\n+\n+               elsif P.Has_Key (Small, Cu) then\n+                  return False;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end P_Positions_Truncated;\n+\n+      ---------------\n+      -- Positions --\n+      ---------------\n+\n+      function Positions (Container : List) return P.Map is\n+         I        : Count_Type := 1;\n+         Position : Count_Type := Container.First;\n+         R        : P.Map;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := P.Add (R, (Node => Position), I);\n+            pragma Assert (P.Length (R) = To_Big_Integer (I));\n+            Position := Container.Nodes (Position).Next;\n+            I := I + 1;\n+         end loop;\n+\n+         return R;\n+      end Positions;\n+\n+   end Formal_Model;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Container : in out List; X : Count_Type) is\n+      pragma Assert (X > 0);\n+      pragma Assert (X <= Container.Nodes'Length);\n+\n+      N : Node_Array_Access renames Container.Nodes;\n+\n+   begin\n+      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n+\n+      if N (X).Element /= null then\n+         Finalize_Element (N (X).Element);\n+      end if;\n+\n+      if Container.Free >= 0 then\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+      elsif X + 1 = abs Container.Free then\n+         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n+         Container.Free := Container.Free + 1;\n+      else\n+         Container.Free := abs Container.Free;\n+\n+         for J in Container.Free .. Container.Nodes'Length loop\n+            N (J).Next := J + 1;\n+         end loop;\n+\n+         N (Container.Nodes'Length).Next := 0;\n+\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+      end if;\n+   end Free;\n+\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n+\n+   package body Generic_Sorting with SPARK_Mode => Off is\n+\n+      ------------------\n+      -- Formal_Model --\n+      ------------------\n+\n+      package body Formal_Model is\n+\n+         -----------------------\n+         -- M_Elements_Sorted --\n+         -----------------------\n+\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n+         begin\n+            if M.Length (Container) = 0 then\n+               return True;\n+            end if;\n+\n+            declare\n+               E1 : Element_Type := Element (Container, 1);\n+\n+            begin\n+               for I in 2 .. M.Length (Container) loop\n+                  declare\n+                     E2 : constant Element_Type := Element (Container, I);\n+\n+                  begin\n+                     if E2 < E1 then\n+                        return False;\n+                     end if;\n+\n+                     E1 := E2;\n+                  end;\n+               end loop;\n+            end;\n+\n+            return True;\n+         end M_Elements_Sorted;\n+\n+      end Formal_Model;\n+\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : List) return Boolean is\n+         Nodes : Node_Array_Access renames Container.Nodes;\n+         Node  : Count_Type := Container.First;\n+\n+      begin\n+         for J in 2 .. Container.Length loop\n+            if Nodes (Nodes (Node).Next).Element.all < Nodes (Node).Element.all\n+            then\n+               return False;\n+            else\n+               Node := Nodes (Node).Next;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge (Target : in out List; Source : in out List) is\n+         LN : Node_Array_Access renames Target.Nodes;\n+         RN : Node_Array_Access renames Source.Nodes;\n+         LI : Cursor;\n+         RI : Cursor;\n+\n+      begin\n+         if Target'Address = Source'Address then\n+            raise Program_Error with \"Target and Source denote same container\";\n+         end if;\n+\n+         LI := First (Target);\n+         RI := First (Source);\n+         while RI.Node /= 0 loop\n+            pragma Assert\n+              (RN (RI.Node).Next = 0\n+                or else not (RN (RN (RI.Node).Next).Element.all <\n+                             RN (RI.Node).Element.all));\n+\n+            if LI.Node = 0 then\n+               Splice (Target, No_Element, Source);\n+               return;\n+            end if;\n+\n+            pragma Assert\n+              (LN (LI.Node).Next = 0\n+                or else not (LN (LN (LI.Node).Next).Element.all <\n+                             LN (LI.Node).Element.all));\n+\n+            if RN (RI.Node).Element.all < LN (LI.Node).Element.all then\n+               declare\n+                  RJ : Cursor := RI;\n+                  pragma Warnings (Off, RJ);\n+               begin\n+                  RI.Node := RN (RI.Node).Next;\n+                  Splice (Target, LI, Source, RJ);\n+               end;\n+\n+            else\n+               LI.Node := LN (LI.Node).Next;\n+            end if;\n+         end loop;\n+      end Merge;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out List) is\n+         N : Node_Array_Access renames Container.Nodes;\n+      begin\n+         if Container.Length <= 1 then\n+            return;\n+         end if;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         declare\n+            package Descriptors is new List_Descriptors\n+              (Node_Ref => Count_Type, Nil => 0);\n+            use Descriptors;\n+\n+            function Next (Idx : Count_Type) return Count_Type is\n+              (N (Idx).Next);\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n+              with Inline;\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n+              with Inline;\n+            function \"<\" (L, R : Count_Type) return Boolean is\n+              (N (L).Element.all < N (R).Element.all);\n+            procedure Update_Container (List : List_Descriptor) with Inline;\n+\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n+            begin\n+               N (Idx).Next := Next;\n+            end Set_Next;\n+\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n+            begin\n+               N (Idx).Prev := Prev;\n+            end Set_Prev;\n+\n+            procedure Update_Container (List : List_Descriptor) is\n+            begin\n+               Container.First  := List.First;\n+               Container.Last   := List.Last;\n+               Container.Length := List.Length;\n+            end Update_Container;\n+\n+            procedure Sort_List is new Doubly_Linked_List_Sort;\n+         begin\n+            Sort_List (List_Descriptor'(First  => Container.First,\n+                                        Last   => Container.Last,\n+                                        Length => Container.Length));\n+         end;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+      end Sort;\n+\n+   end Generic_Sorting;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Container : List; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return False;\n+      end if;\n+\n+      return Container.Nodes (Position.Node).Prev /= -1;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type)\n+   is\n+      J : Count_Type;\n+\n+   begin\n+      if Before.Node /= 0 then\n+         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+      Allocate (Container, New_Item, New_Node => J);\n+      Insert_Internal (Container, Before.Node, New_Node => J);\n+      Position := (Node => J);\n+\n+      for Index in 2 .. Count loop\n+         Allocate (Container, New_Item, New_Node => J);\n+         Insert_Internal (Container, Before.Node, New_Node => J);\n+      end loop;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor)\n+   is\n+   begin\n+      Insert\n+        (Container => Container,\n+         Before    => Before,\n+         New_Item  => New_Item,\n+         Position  => Position,\n+         Count     => 1);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+      Position : Cursor;\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, 1);\n+   end Insert;\n+\n+   ---------------------\n+   -- Insert_Internal --\n+   ---------------------\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type)\n+   is\n+      N : Node_Array_Access renames Container.Nodes;\n+\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Before = 0);\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last = 0);\n+\n+         Container.First := New_Node;\n+         Container.Last := New_Node;\n+\n+         N (Container.First).Prev := 0;\n+         N (Container.Last).Next := 0;\n+\n+      elsif Before = 0 then\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         N (Container.Last).Next := New_Node;\n+         N (New_Node).Prev := Container.Last;\n+\n+         Container.Last := New_Node;\n+         N (Container.Last).Next := 0;\n+\n+      elsif Before = Container.First then\n+         pragma Assert (N (Container.First).Prev = 0);\n+\n+         N (Container.First).Prev := New_Node;\n+         N (New_Node).Next := Container.First;\n+\n+         Container.First := New_Node;\n+         N (Container.First).Prev := 0;\n+\n+      else\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         N (New_Node).Next := Before;\n+         N (New_Node).Prev := N (Before).Prev;\n+\n+         N (N (Before).Prev).Next := New_Node;\n+         N (Before).Prev := New_Node;\n+      end if;\n+      Container.Length := Container.Length + 1;\n+   end Insert_Internal;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : List) return Boolean is\n+   begin\n+      return Length (Container) = 0;\n+   end Is_Empty;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : List) return Cursor is\n+   begin\n+      if Container.Last = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return (Node => Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : List) return Element_Type is\n+      L : constant Count_Type := Container.Last;\n+\n+   begin\n+      if L = 0 then\n+         raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.Nodes (L).Element.all;\n+      end if;\n+   end Last_Element;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : List) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out List; Source : in out List) is\n+      N     : Node_Array_Access renames Source.Nodes;\n+\n+      procedure Finalize_Node_Array is new Ada.Unchecked_Deallocation\n+        (Object => Node_Array,\n+         Name   => Node_Array_Access);\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Clear (Target);\n+\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n+\n+      --  Make sure that Target is large enough\n+\n+      if Target.Nodes = null\n+        or else Target.Nodes'Length < Source.Length\n+      then\n+         if Target.Nodes /= null then\n+            Finalize_Node_Array (Target.Nodes);\n+         end if;\n+         Target.Nodes := new Node_Array (1 .. Source.Length);\n+      end if;\n+\n+      --  Copy first element from Source to Target\n+\n+      Target.First := 1;\n+\n+      Target.Nodes (1).Prev := 0;\n+      Target.Nodes (1).Element := N (Source.First).Element;\n+      N (Source.First).Element := null;\n+\n+      --  Copy the other elements\n+\n+      declare\n+         X_Src : Count_Type := N (Source.First).Next;\n+         X_Tar : Count_Type := 2;\n+\n+      begin\n+         while X_Src /= 0 loop\n+            Target.Nodes (X_Tar).Prev := X_Tar - 1;\n+            Target.Nodes (X_Tar - 1).Next := X_Tar;\n+\n+            Target.Nodes (X_Tar).Element := N (X_Src).Element;\n+            N (X_Src).Element := null;\n+\n+            X_Src := N (X_Src).Next;\n+            X_Tar := X_Tar + 1;\n+         end loop;\n+      end;\n+\n+      Target.Last := Source.Length;\n+      Target.Length := Source.Length;\n+      Target.Nodes (Target.Last).Next := 0;\n+\n+      --  Set up the free list\n+\n+      Target.Free := -Source.Length - 1;\n+\n+      --  It is possible to Clear Source because the Element accesses were\n+      --  set to null.\n+\n+      Clear (Source);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Container : List; Position : in out Cursor) is\n+   begin\n+      Position := Next (Container, Position);\n+   end Next;\n+\n+   function Next (Container : List; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Program_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return (Node => Container.Nodes (Position.Node).Next);\n+   end Next;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend (Container : in out List; New_Item : Element_Type) is\n+   begin\n+      Insert (Container, First (Container), New_Item, 1);\n+   end Prepend;\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      Insert (Container, First (Container), New_Item, Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Container : List; Position : in out Cursor) is\n+   begin\n+      Position := Previous (Container, Position);\n+   end Previous;\n+\n+   function Previous (Container : List; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Program_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return (Node => Container.Nodes (Position.Node).Prev);\n+   end Previous;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference\n+     (Container : not null access List;\n+      Position  : Cursor) return not null access Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container.all, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return Container.Nodes (Position.Node).Element;\n+   end Reference;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n+\n+      Finalize_Element (Container.Nodes (Position.Node).Element);\n+      Container.Nodes (Position.Node).Element := new Element_Type'(New_Item);\n+   end Replace_Element;\n+\n+   ------------\n+   -- Resize --\n+   ------------\n+\n+   procedure Resize (Container : in out List) is\n+      Min_Size : constant Count_Type := 100;\n+   begin\n+      if Container.Nodes = null then\n+         Container.Nodes := new Node_Array (1 .. Min_Size);\n+         Container.First := 0;\n+         Container.Last := 0;\n+         Container.Length := 0;\n+         Container.Free := -1;\n+\n+         return;\n+      end if;\n+\n+      if Container.Length /= Container.Nodes'Length then\n+         raise Program_Error with \"List must be at size max to resize\";\n+      end if;\n+\n+      declare\n+         procedure Finalize_Node_Array is new Ada.Unchecked_Deallocation\n+              (Object => Node_Array,\n+               Name   => Node_Array_Access);\n+\n+         New_Size : constant Count_Type :=\n+           (if Container.Nodes'Length > Count_Type'Last / 2\n+            then Count_Type'Last\n+            else 2 * Container.Nodes'Length);\n+         New_Nodes : Node_Array_Access;\n+\n+      begin\n+         New_Nodes :=\n+           new Node_Array (1 .. Count_Type'Max (New_Size, Min_Size));\n+\n+         New_Nodes (1 .. Container.Nodes'Length) :=\n+           Container.Nodes (1 .. Container.Nodes'Length);\n+\n+         Container.Free := -Container.Nodes'Length - 1;\n+\n+         Finalize_Node_Array (Container.Nodes);\n+         Container.Nodes := New_Nodes;\n+      end;\n+   end Resize;\n+\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out List) is\n+      N : Node_Array_Access renames Container.Nodes;\n+      I : Count_Type := Container.First;\n+      J : Count_Type := Container.Last;\n+\n+      procedure Swap (L : Count_Type; R : Count_Type);\n+\n+      ----------\n+      -- Swap --\n+      ----------\n+\n+      procedure Swap (L : Count_Type; R : Count_Type) is\n+         LN : constant Count_Type := N (L).Next;\n+         LP : constant Count_Type := N (L).Prev;\n+\n+         RN : constant Count_Type := N (R).Next;\n+         RP : constant Count_Type := N (R).Prev;\n+\n+      begin\n+         if LP /= 0 then\n+            N (LP).Next := R;\n+         end if;\n+\n+         if RN /= 0 then\n+            N (RN).Prev := L;\n+         end if;\n+\n+         N (L).Next := RN;\n+         N (R).Prev := LP;\n+\n+         if LN = R then\n+            pragma Assert (RP = L);\n+\n+            N (L).Prev := R;\n+            N (R).Next := L;\n+\n+         else\n+            N (L).Prev := RP;\n+            N (RP).Next := L;\n+\n+            N (R).Next := LN;\n+            N (LN).Prev := R;\n+         end if;\n+      end Swap;\n+\n+   --  Start of processing for Reverse_Elements\n+\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+\n+      Container.First := J;\n+      Container.Last  := I;\n+      loop\n+         Swap (L => I, R => J);\n+\n+         J := N (J).Next;\n+         exit when I = J;\n+\n+         I := N (I).Prev;\n+         exit when I = J;\n+\n+         Swap (L => J, R => I);\n+\n+         I := N (I).Next;\n+         exit when I = J;\n+\n+         J := N (J).Prev;\n+         exit when I = J;\n+      end loop;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      CFirst : Count_Type := Position.Node;\n+\n+   begin\n+      if CFirst = 0 then\n+         CFirst := Container.Last;\n+      end if;\n+\n+      if Container.Length = 0 then\n+         return No_Element;\n+      else\n+         while CFirst /= 0 loop\n+            if Container.Nodes (CFirst).Element.all = Item then\n+               return (Node => CFirst);\n+            else\n+               CFirst := Container.Nodes (CFirst).Prev;\n+            end if;\n+         end loop;\n+\n+         return No_Element;\n+      end if;\n+   end Reverse_Find;\n+\n+   ------------\n+   -- Splice --\n+   ------------\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List)\n+   is\n+      SN : Node_Array_Access renames Source.Nodes;\n+      TN : Node_Array_Access renames Target.Nodes;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         raise Program_Error with \"Target and Source denote same container\";\n+      end if;\n+\n+      if Before.Node /= 0 then\n+         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n+      end if;\n+\n+      if Is_Empty (Source) then\n+         return;\n+      end if;\n+\n+      pragma Assert (SN (Source.First).Prev = 0);\n+      pragma Assert (SN (Source.Last).Next  = 0);\n+\n+      declare\n+         X : Count_Type;\n+\n+      begin\n+         while not Is_Empty (Source) loop\n+            Allocate (Target, X);\n+\n+            TN (X).Element := SN (Source.Last).Element;\n+\n+            --  Insert the new node in Target\n+\n+            Insert_Internal (Target, Before.Node, X);\n+\n+            --  Free the last node of Source\n+\n+            SN (Source.Last).Element := null;\n+            Delete_Last (Source);\n+         end loop;\n+      end;\n+\n+   end Splice;\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : in out Cursor)\n+   is\n+   begin\n+      if Target'Address = Source'Address then\n+         raise Program_Error with \"Target and Source denote same container\";\n+      end if;\n+\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Source, Position), \"bad Position cursor in Splice\");\n+\n+      declare\n+         X : Count_Type;\n+\n+      begin\n+         Allocate (Target, X);\n+\n+         Target.Nodes (X).Element := Source.Nodes (Position.Node).Element;\n+\n+         --  Insert the new node in Target\n+\n+         Insert_Internal (Target, Before.Node, X);\n+\n+         --  Free the node at position Position in Source\n+\n+         Source.Nodes (Position.Node).Element := null;\n+         Delete (Source, Position);\n+\n+         Position := (Node => X);\n+      end;\n+   end Splice;\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : Cursor)\n+   is\n+      N : Node_Array_Access renames Container.Nodes;\n+\n+   begin\n+      if Before.Node /= 0 then\n+         pragma Assert\n+           (Vet (Container, Before), \"bad Before cursor in Splice\");\n+      end if;\n+\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container, Position), \"bad Position cursor in Splice\");\n+\n+      if Position.Node = Before.Node\n+        or else N (Position.Node).Next = Before.Node\n+      then\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.Length >= 2);\n+\n+      if Before.Node = 0 then\n+         pragma Assert (Position.Node /= Container.Last);\n+\n+         if Position.Node = Container.First then\n+            Container.First := N (Position.Node).Next;\n+            N (Container.First).Prev := 0;\n+\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+         end if;\n+\n+         N (Container.Last).Next := Position.Node;\n+         N (Position.Node).Prev := Container.Last;\n+\n+         Container.Last := Position.Node;\n+         N (Container.Last).Next := 0;\n+\n+         return;\n+      end if;\n+\n+      if Before.Node = Container.First then\n+         pragma Assert (Position.Node /= Container.First);\n+\n+         if Position.Node = Container.Last then\n+            Container.Last := N (Position.Node).Prev;\n+            N (Container.Last).Next := 0;\n+\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+         end if;\n+\n+         N (Container.First).Prev := Position.Node;\n+         N (Position.Node).Next := Container.First;\n+\n+         Container.First := Position.Node;\n+         N (Container.First).Prev := 0;\n+\n+         return;\n+      end if;\n+\n+      if Position.Node = Container.First then\n+         Container.First := N (Position.Node).Next;\n+         N (Container.First).Prev := 0;\n+\n+      elsif Position.Node = Container.Last then\n+         Container.Last := N (Position.Node).Prev;\n+         N (Container.Last).Next := 0;\n+\n+      else\n+         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+      end if;\n+\n+      N (N (Before.Node).Prev).Next := Position.Node;\n+      N (Position.Node).Prev := N (Before.Node).Prev;\n+\n+      N (Before.Node).Prev := Position.Node;\n+      N (Position.Node).Next := Before.Node;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+   end Splice;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I         : Cursor;\n+      J         : Cursor)\n+   is\n+   begin\n+      if I.Node = 0 then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if J.Node = 0 then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      pragma Assert (Vet (Container, I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n+\n+      declare\n+         NN : Node_Array_Access renames Container.Nodes;\n+         NI : Node_Type renames NN (I.Node);\n+         NJ : Node_Type renames NN (J.Node);\n+\n+         EI_Copy : constant Element_Access := NI.Element;\n+\n+      begin\n+         NI.Element := NJ.Element;\n+         NJ.Element := EI_Copy;\n+      end;\n+   end Swap;\n+\n+   ----------------\n+   -- Swap_Links --\n+   ----------------\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I         : Cursor;\n+      J         : Cursor)\n+   is\n+      I_Next : Cursor;\n+      J_Next : Cursor;\n+\n+   begin\n+      if I.Node = 0 then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if J.Node = 0 then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      pragma Assert (Vet (Container, I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (Container, J), \"bad J cursor in Swap_Links\");\n+\n+      I_Next := Next (Container, I);\n+\n+      if I_Next = J then\n+         Splice (Container, Before => I, Position => J);\n+\n+      else\n+         J_Next := Next (Container, J);\n+\n+         if J_Next = I then\n+            Splice (Container, Before => J, Position => I);\n+\n+         else\n+            pragma Assert (Container.Length >= 3);\n+            Splice (Container, Before => I_Next, Position => J);\n+            Splice (Container, Before => J_Next, Position => I);\n+         end if;\n+      end if;\n+   end Swap_Links;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (L : List; Position : Cursor) return Boolean is\n+      N : Node_Array_Access renames L.Nodes;\n+   begin\n+      if not Container_Checks'Enabled then\n+         return True;\n+      end if;\n+\n+      if L.Length = 0 then\n+         return False;\n+      end if;\n+\n+      if L.First = 0 then\n+         return False;\n+      end if;\n+\n+      if L.Last = 0 then\n+         return False;\n+      end if;\n+\n+      if Position.Node > L.Nodes'Length then\n+         return False;\n+      end if;\n+\n+      if N (Position.Node).Prev < 0\n+        or else N (Position.Node).Prev > L.Nodes'Length\n+      then\n+         return False;\n+      end if;\n+\n+      if N (Position.Node).Next > L.Nodes'Length then\n+         return False;\n+      end if;\n+\n+      if N (L.First).Prev /= 0 then\n+         return False;\n+      end if;\n+\n+      if N (L.Last).Next /= 0 then\n+         return False;\n+      end if;\n+\n+      if N (Position.Node).Prev = 0 and then Position.Node /= L.First then\n+         return False;\n+      end if;\n+\n+      if N (Position.Node).Next = 0 and then Position.Node /= L.Last then\n+         return False;\n+      end if;\n+\n+      if L.Length = 1 then\n+         return L.First = L.Last;\n+      end if;\n+\n+      if L.First = L.Last then\n+         return False;\n+      end if;\n+\n+      if N (L.First).Next = 0 then\n+         return False;\n+      end if;\n+\n+      if N (L.Last).Prev = 0 then\n+         return False;\n+      end if;\n+\n+      if N (N (L.First).Next).Prev /= L.First then\n+         return False;\n+      end if;\n+\n+      if N (N (L.Last).Prev).Next /= L.Last then\n+         return False;\n+      end if;\n+\n+      if L.Length = 2 then\n+         if N (L.First).Next /= L.Last then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev /= L.First then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end if;\n+\n+      if N (L.First).Next = L.Last then\n+         return False;\n+      end if;\n+\n+      if N (L.Last).Prev = L.First then\n+         return False;\n+      end if;\n+\n+      if Position.Node = L.First then\n+         return True;\n+      end if;\n+\n+      if Position.Node = L.Last then\n+         return True;\n+      end if;\n+\n+      if N (Position.Node).Next = 0 then\n+         return False;\n+      end if;\n+\n+      if N (Position.Node).Prev = 0 then\n+         return False;\n+      end if;\n+\n+      if N (N (Position.Node).Next).Prev /= Position.Node then\n+         return False;\n+      end if;\n+\n+      if N (N (Position.Node).Prev).Next /= Position.Node then\n+         return False;\n+      end if;\n+\n+      if L.Length = 3 then\n+         if N (L.First).Next /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev /= Position.Node then\n+            return False;\n+         end if;\n+      end if;\n+\n+      return True;\n+   end Vet;\n+\n+end Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists;"}, {"sha": "c4d244a30b08cb3bbfdb324d9d9b6f16d4cbfcc1", "filename": "gcc/ada/libgnat/a-cfidll.ads", "status": "added", "additions": 1670, "deletions": 0, "changes": 1670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829b5a6075e63e84600b0eee5daebb3fab9aa491/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads?ref=829b5a6075e63e84600b0eee5daebb3fab9aa491", "patch": "@@ -0,0 +1,1670 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--           ADA.CONTAINERS.FORMAL_INDEFINITE_DOUBLY_LINKED_LISTS           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Functional_Vectors;\n+with Ada.Containers.Functional_Maps;\n+private with Ada.Finalization;\n+\n+generic\n+   type Element_Type is private;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists with\n+  SPARK_Mode\n+is\n+   --  Contracts in this unit are meant for analysis only, not for run-time\n+   --  checking.\n+\n+   pragma Assertion_Policy (Pre => Ignore);\n+   pragma Assertion_Policy (Post => Ignore);\n+   pragma Assertion_Policy (Contract_Cases => Ignore);\n+   pragma Annotate (CodePeer, Skip_Analysis);\n+\n+   type List is private with\n+     Iterable => (First       => First,\n+                  Next        => Next,\n+                  Has_Element => Has_Element,\n+                  Element     => Element),\n+     Default_Initial_Condition => Is_Empty (List);\n+\n+   type Cursor is record\n+      Node : Count_Type := 0;\n+   end record;\n+\n+   No_Element : constant Cursor := Cursor'(Node => 0);\n+\n+   function Length (Container : List) return Count_Type with\n+     Global => null;\n+\n+   function Empty_List return List with\n+     Global => null,\n+     Post   => Length (Empty_List'Result) = 0;\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+      package M is new Ada.Containers.Functional_Vectors\n+        (Index_Type   => Positive_Count_Type,\n+         Element_Type => Element_Type);\n+\n+      function \"=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"=\";\n+\n+      function \"<\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<\";\n+\n+      function \"<=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<=\";\n+\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n+      --  The elements of Container are contained in either Left or Right\n+      with\n+        Global => null,\n+        Post   =>\n+          M_Elements_In_Union'Result =\n+            (for all I in 1 .. M.Length (Container) =>\n+              (for some J in 1 .. M.Length (Left) =>\n+                Element (Container, I) = Element (Left, J))\n+                  or (for some J in 1 .. M.Length (Right) =>\n+                       Element (Container, I) = Element (Right, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n+\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Positive_Count_Type := 1;\n+         L_Lst : Count_Type;\n+         Right : M.Sequence;\n+         R_Fst : Positive_Count_Type := 1;\n+         R_Lst : Count_Type) return Boolean\n+      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n+      --  in the slide from R_Fst to R_Lst in Right.\n+      with\n+        Global => null,\n+        Pre    => L_Lst <= M.Length (Left) and R_Lst <= M.Length (Right),\n+        Post   =>\n+          M_Elements_Included'Result =\n+            (for all I in L_Fst .. L_Lst =>\n+              (for some J in R_Fst .. R_Lst =>\n+                Element (Left, I) = Element (Right, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n+\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      --  Right is Left in reverse order\n+      with\n+        Global => null,\n+        Post   =>\n+          M_Elements_Reversed'Result =\n+            (M.Length (Left) = M.Length (Right)\n+              and (for all I in 1 .. M.Length (Left) =>\n+                    Element (Left, I) =\n+                      Element (Right, M.Length (Left) - I + 1))\n+              and (for all I in 1 .. M.Length (Left) =>\n+                    Element (Right, I) =\n+                      Element (Left, M.Length (Left) - I + 1)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n+\n+      function M_Elements_Swapped\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X     : Positive_Count_Type;\n+         Y     : Positive_Count_Type) return Boolean\n+      --  Elements stored at X and Y are reversed in Left and Right\n+      with\n+        Global => null,\n+        Pre    => X <= M.Length (Left) and Y <= M.Length (Left),\n+        Post   =>\n+          M_Elements_Swapped'Result =\n+            (M.Length (Left) = M.Length (Right)\n+              and Element (Left, X) = Element (Right, Y)\n+              and Element (Left, Y) = Element (Right, X)\n+              and M.Equal_Except (Left, Right, X, Y));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n+\n+      package P is new Ada.Containers.Functional_Maps\n+        (Key_Type                       => Cursor,\n+         Element_Type                   => Positive_Count_Type,\n+         Equivalent_Keys                => \"=\",\n+         Enable_Handling_Of_Equivalence => False);\n+\n+      function \"=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"=\";\n+\n+      function \"<=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"<=\";\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      with\n+        Global => null,\n+        Post   =>\n+          P_Positions_Shifted'Result =\n+\n+            --  Big contains all cursors of Small\n+\n+            (P.Keys_Included (Small, Big)\n+\n+              --  Cursors located before Cut are not moved, cursors located\n+              --  after are shifted by Count.\n+\n+              and (for all I of Small =>\n+                    (if P.Get (Small, I) < Cut then\n+                        P.Get (Big, I) = P.Get (Small, I)\n+                     else\n+                        P.Get (Big, I) - Count = P.Get (Small, I)))\n+\n+              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n+              --  Count.\n+\n+              and (for all I of Big =>\n+                    P.Has_Key (Small, I)\n+                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n+\n+      function P_Positions_Swapped\n+        (Left  : P.Map;\n+         Right : P.Map;\n+         X     : Cursor;\n+         Y     : Cursor) return Boolean\n+      --  Left and Right contain the same cursors, but the positions of X and Y\n+      --  are reversed.\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          P_Positions_Swapped'Result =\n+            (P.Same_Keys (Left, Right)\n+              and P.Elements_Equal_Except (Left, Right, X, Y)\n+              and P.Has_Key (Left, X)\n+              and P.Has_Key (Left, Y)\n+              and P.Get (Left, X) = P.Get (Right, Y)\n+              and P.Get (Left, Y) = P.Get (Right, X));\n+\n+      function P_Positions_Truncated\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          P_Positions_Truncated'Result =\n+\n+            --  Big contains all cursors of Small at the same position\n+\n+            (Small <= Big\n+\n+              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n+              --  Count.\n+\n+              and (for all I of Big =>\n+                    P.Has_Key (Small, I)\n+                      or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n+\n+      function Mapping_Preserved\n+        (M_Left  : M.Sequence;\n+         M_Right : M.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (if Mapping_Preserved'Result then\n+\n+             --  Left and Right contain the same cursors\n+\n+             P.Same_Keys (P_Left, P_Right)\n+\n+               --  Mappings from cursors to elements induced by M_Left, P_Left\n+               --  and M_Right, P_Right are the same.\n+\n+               and (for all C of P_Left =>\n+                     M.Get (M_Left, P.Get (P_Left, C)) =\n+                     M.Get (M_Right, P.Get (P_Right, C))));\n+\n+      function Model (Container : List) return M.Sequence with\n+      --  The high-level model of a list is a sequence of elements. Cursors are\n+      --  not represented in this model.\n+\n+        Ghost,\n+        Global => null,\n+        Post   => M.Length (Model'Result) = Length (Container);\n+      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Model);\n+\n+      function Positions (Container : List) return P.Map with\n+      --  The Positions map is used to model cursors. It only contains valid\n+      --  cursors and map them to their position in the container.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          not P.Has_Key (Positions'Result, No_Element)\n+\n+            --  Positions of cursors are smaller than the container's length\n+\n+            and then\n+              (for all I of Positions'Result =>\n+                P.Get (Positions'Result, I) in 1 .. Length (Container)\n+\n+            --  No two cursors have the same position. Note that we do not\n+            --  state that there is a cursor in the map for each position, as\n+            --  it is rarely needed.\n+\n+            and then\n+              (for all J of Positions'Result =>\n+                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n+                  then I = J)));\n+\n+      procedure Lift_Abstraction_Level (Container : List) with\n+        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n+        --  assume that we can access to the same elements by iterating over\n+        --  positions or cursors.\n+        --  This information is not generally useful except when switching from\n+        --  a low-level cursor-aware view of a container to a high-level\n+        --  position-based view.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (for all Elt of Model (Container) =>\n+            (for some I of Positions (Container) =>\n+              M.Get (Model (Container), P.Get (Positions (Container), I)) =\n+                Elt));\n+\n+      function Element\n+        (S : M.Sequence;\n+         I : Count_Type) return Element_Type renames M.Get;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  access an element in the model to Element.\n+\n+   end Formal_Model;\n+   use Formal_Model;\n+\n+   function \"=\" (Left, Right : List) return Boolean with\n+     Global => null,\n+     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n+\n+   function Is_Empty (Container : List) return Boolean with\n+     Global => null,\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n+\n+   procedure Clear (Container : in out List) with\n+     Global => null,\n+     Post   => Length (Container) = 0;\n+\n+   procedure Assign (Target : in out List; Source : List) with\n+     Global => null,\n+     Post   => Model (Target) = Model (Source);\n+\n+   function Copy (Source : List) return List with\n+     Global => null,\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and Positions (Copy'Result) = Positions (Source);\n+\n+   function Element\n+     (Container : List;\n+      Position : Cursor) return Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Element'Result =\n+         Element (Model (Container), P.Get (Positions (Container), Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old\n+\n+         --  Cursors are preserved\n+\n+         and Positions (Container)'Old = Positions (Container)\n+\n+         --  The element at the position of Position in Container is New_Item\n+\n+         and Element\n+               (Model (Container),\n+                P.Get (Positions (Container), Position)) = New_Item\n+\n+         --  Other elements are preserved\n+\n+         and M.Equal_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                P.Get (Positions (Container), Position));\n+\n+   function At_End (E : access constant List) return access constant List\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function At_End\n+     (E : access constant Element_Type) return access constant Element_Type\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function Constant_Reference\n+     (Container : List;\n+      Position  : Cursor) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Constant_Reference'Result.all =\n+         Element (Model (Container), P.Get (Positions (Container), Position));\n+\n+   function Reference\n+     (Container : not null access List;\n+      Position  : Cursor) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container.all, Position),\n+     Post   =>\n+      Length (Container.all) = Length (At_End (Container).all)\n+\n+         --  Cursors are preserved\n+\n+         and Positions (Container.all) = Positions (At_End (Container).all)\n+\n+         --  Container will have Result.all at position Position\n+\n+         and At_End (Reference'Result).all =\n+           Element (Model (At_End (Container).all),\n+                    P.Get (Positions (At_End (Container).all), Position))\n+\n+         --  All other elements are preserved\n+\n+         and M.Equal_Except\n+               (Model (Container.all),\n+                Model (At_End (Container).all),\n+                P.Get (Positions (At_End (Container).all), Position));\n+\n+   procedure Move (Target : in out List; Source : in out List) with\n+     Global => null,\n+     Post   => Model (Target) = Model (Source'Old) and Length (Source) = 0;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Count_Type'Last\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n+     Post           => Length (Container) = Length (Container)'Old + 1,\n+     Contract_Cases =>\n+       (Before = No_Element =>\n+\n+          --  Positions contains a new mapping from the last cursor of\n+          --  Container to its length.\n+\n+          P.Get (Positions (Container), Last (Container)) = Length (Container)\n+\n+            --  Other cursors come from Container'Old\n+\n+            and P.Keys_Included_Except\n+                  (Left    => Positions (Container),\n+                   Right   => Positions (Container)'Old,\n+                   New_Key => Last (Container))\n+\n+            --  Cursors of Container'Old keep the same position\n+\n+            and Positions (Container)'Old <= Positions (Container)\n+\n+            --  Model contains a new element New_Item at the end\n+\n+            and Element (Model (Container), Length (Container)) = New_Item\n+\n+            --  Elements of Container'Old are preserved\n+\n+            and Model (Container)'Old <= Model (Container),\n+\n+        others =>\n+\n+          --  The elements of Container located before Before are preserved\n+\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n+\n+            --  Other elements are shifted by 1\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Before),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => 1)\n+\n+            --  New_Item is stored at the previous position of Before in\n+            --  Container.\n+\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container)'Old, Before)) = New_Item\n+\n+            --  A new cursor has been inserted at position Before in Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut => P.Get (Positions (Container)'Old, Before)));\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) <= Count_Type'Last - Count\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n+     Post           => Length (Container) = Length (Container)'Old + Count,\n+     Contract_Cases =>\n+       (Before = No_Element =>\n+\n+          --  The elements of Container are preserved\n+\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => Length (Container)'Old)\n+\n+            --  Container contains Count times New_Item at the end\n+\n+            and (if Count > 0 then\n+                    M.Constant_Range\n+                      (Container => Model (Container),\n+                       Fst       => Length (Container)'Old + 1,\n+                       Lst       => Length (Container),\n+                       Item      => New_Item))\n+\n+            --  Count cursors have been inserted at the end of Container\n+\n+            and P_Positions_Truncated\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut   => Length (Container)'Old + 1,\n+                   Count => Count),\n+\n+        others =>\n+\n+          --  The elements of Container located before Before are preserved\n+\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n+\n+            --  Other elements are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Before),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => Count)\n+\n+            --  Container contains Count times New_Item after position Before\n+\n+            and M.Constant_Range\n+                  (Container => Model (Container),\n+                   Fst       => P.Get (Positions (Container)'Old, Before),\n+                   Lst       =>\n+                     P.Get (Positions (Container)'Old, Before) - 1 + Count,\n+                   Item      => New_Item)\n+\n+            --  Count cursors have been inserted at position Before in\n+            --  Container.\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut   => P.Get (Positions (Container)'Old, Before),\n+                   Count => Count));\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor)\n+   with\n+     Global => null,\n+     Pre    =>\n+       Length (Container) < Count_Type'Last\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+          --  Positions is valid in Container and it is located either before\n+          --  Before if it is valid in Container or at the end if it is\n+          --  No_Element.\n+\n+          and P.Has_Key (Positions (Container), Position)\n+          and (if Before = No_Element then\n+                  P.Get (Positions (Container), Position) = Length (Container)\n+               else\n+                  P.Get (Positions (Container), Position) =\n+                  P.Get (Positions (Container)'Old, Before))\n+\n+          --  The elements of Container located before Position are preserved\n+\n+          and M.Range_Equal\n+                (Left  => Model (Container)'Old,\n+                 Right => Model (Container),\n+                 Fst   => 1,\n+                 Lst   => P.Get (Positions (Container), Position) - 1)\n+\n+          --  Other elements are shifted by 1\n+\n+          and M.Range_Shifted\n+                (Left   => Model (Container)'Old,\n+                 Right  => Model (Container),\n+                 Fst    => P.Get (Positions (Container), Position),\n+                 Lst    => Length (Container)'Old,\n+                 Offset => 1)\n+\n+          --  New_Item is stored at Position in Container\n+\n+          and Element\n+                (Model (Container),\n+                 P.Get (Positions (Container), Position)) = New_Item\n+\n+          --  A new cursor has been inserted at position Position in Container\n+\n+          and P_Positions_Shifted\n+                (Positions (Container)'Old,\n+                 Positions (Container),\n+                 Cut => P.Get (Positions (Container), Position));\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) <= Count_Type'Last - Count\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n+     Post           => Length (Container) = Length (Container)'Old + Count,\n+     Contract_Cases =>\n+       (Count = 0 =>\n+         Position = Before\n+           and Model (Container) = Model (Container)'Old\n+           and Positions (Container) = Positions (Container)'Old,\n+\n+        others =>\n+\n+          --  Positions is valid in Container and it is located either before\n+          --  Before if it is valid in Container or at the end if it is\n+          --  No_Element.\n+\n+          P.Has_Key (Positions (Container), Position)\n+            and (if Before = No_Element then\n+                    P.Get (Positions (Container), Position) =\n+                    Length (Container)'Old + 1\n+                 else\n+                    P.Get (Positions (Container), Position) =\n+                    P.Get (Positions (Container)'Old, Before))\n+\n+            --  The elements of Container located before Position are preserved\n+\n+            and M.Range_Equal\n+                  (Left  => Model (Container)'Old,\n+                   Right => Model (Container),\n+                   Fst   => 1,\n+                   Lst   => P.Get (Positions (Container), Position) - 1)\n+\n+            --  Other elements are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container), Position),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => Count)\n+\n+            --  Container contains Count times New_Item after position Position\n+\n+            and M.Constant_Range\n+                  (Container => Model (Container),\n+                   Fst       => P.Get (Positions (Container), Position),\n+                   Lst       =>\n+                     P.Get (Positions (Container), Position) - 1 + Count,\n+                   Item      => New_Item)\n+\n+            --  Count cursor have been inserted at Position in Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut   => P.Get (Positions (Container), Position),\n+                   Count => Count));\n+\n+   procedure Prepend (Container : in out List; New_Item : Element_Type) with\n+     Global => null,\n+     Pre    => Length (Container) < Count_Type'Last,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Elements are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => 1,\n+                Lst    => Length (Container)'Old,\n+                Offset => 1)\n+\n+         --  New_Item is the first element of Container\n+\n+         and Element (Model (Container), 1) = New_Item\n+\n+         --  A new cursor has been inserted at the beginning of Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut => 1);\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Count_Type'Last - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  Elements are shifted by Count\n+\n+         and M.Range_Shifted\n+               (Left     => Model (Container)'Old,\n+                Right     => Model (Container),\n+                Fst    => 1,\n+                Lst    => Length (Container)'Old,\n+                Offset => Count)\n+\n+         --  Container starts with Count times New_Item\n+\n+         and M.Constant_Range\n+               (Container => Model (Container),\n+                Fst       => 1,\n+                Lst       => Count,\n+                Item      => New_Item)\n+\n+         --  Count cursors have been inserted at the beginning of Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut   => 1,\n+                Count => Count);\n+\n+   procedure Append (Container : in out List; New_Item : Element_Type) with\n+     Global => null,\n+     Pre    => Length (Container) < Count_Type'Last,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Positions contains a new mapping from the last cursor of Container\n+         --  to its length.\n+\n+         and P.Get (Positions (Container), Last (Container)) =\n+               Length (Container)\n+\n+         --  Other cursors come from Container'Old\n+\n+         and P.Keys_Included_Except\n+               (Left    => Positions (Container),\n+                Right   => Positions (Container)'Old,\n+                New_Key => Last (Container))\n+\n+         --  Cursors of Container'Old keep the same position\n+\n+         and Positions (Container)'Old <= Positions (Container)\n+\n+         --  Model contains a new element New_Item at the end\n+\n+         and Element (Model (Container), Length (Container)) = New_Item\n+\n+         --  Elements of Container'Old are preserved\n+\n+         and Model (Container)'Old <= Model (Container);\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Count_Type'Last - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  The elements of Container are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+\n+         --  Container contains Count times New_Item at the end\n+\n+         and (if Count > 0 then\n+                 M.Constant_Range\n+                   (Container => Model (Container),\n+                     Fst       => Length (Container)'Old + 1,\n+                     Lst       => Length (Container),\n+                     Item      => New_Item))\n+\n+         --  Count cursors have been inserted at the end of Container\n+\n+         and P_Positions_Truncated\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut   => Length (Container)'Old + 1,\n+                Count => Count);\n+\n+   procedure Delete (Container : in out List; Position : in out Cursor) with\n+     Global  => null,\n+     Depends => (Container =>+ Position, Position => null),\n+     Pre     => Has_Element (Container, Position),\n+     Post    =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Position is set to No_Element\n+\n+         and Position = No_Element\n+\n+         --  The elements of Container located before Position are preserved.\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n+\n+         --  The elements located after Position are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n+                Lst    => Length (Container),\n+                Offset => 1)\n+\n+         --  Position has been removed from Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Pre            => Has_Element (Container, Position),\n+     Post           =>\n+       Length (Container) in\n+         Length (Container)'Old - Count .. Length (Container)'Old\n+\n+         --  Position is set to No_Element\n+\n+         and Position = No_Element\n+\n+         --  The elements of Container located before Position are preserved.\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1),\n+\n+     Contract_Cases =>\n+\n+       --  All the elements after Position have been erased\n+\n+       (Length (Container) - Count < P.Get (Positions (Container), Position) =>\n+          Length (Container) =\n+            P.Get (Positions (Container)'Old, Position'Old) - 1\n+\n+            --  At most Count cursors have been removed at the end of Container\n+\n+            and P_Positions_Truncated\n+                 (Positions (Container),\n+                  Positions (Container)'Old,\n+                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n+                  Count => Count),\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  Other elements are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => P.Get (Positions (Container)'Old, Position'Old),\n+                   Lst    => Length (Container),\n+                   Offset => Count)\n+\n+            --  Count cursors have been removed from Container at Position\n+\n+            and P_Positions_Shifted\n+                 (Positions (Container),\n+                  Positions (Container)'Old,\n+                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n+                  Count => Count));\n+\n+   procedure Delete_First (Container : in out List) with\n+     Global => null,\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  The elements of Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => 1,\n+                Lst    => Length (Container),\n+                Offset => 1)\n+\n+         --  The first cursor of Container has been removed\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   => 1);\n+\n+   procedure Delete_First (Container : in out List; Count : Count_Type) with\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  All the elements of Container have been erased\n+\n+       (Length (Container) <= Count =>\n+          Length (Container) = 0,\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  Elements of Container are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => 1,\n+                   Lst    => Length (Container),\n+                   Offset => Count)\n+\n+            --  The first Count cursors have been removed from Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => 1,\n+                   Count => Count));\n+\n+   procedure Delete_Last (Container : in out List) with\n+     Global => null,\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  The elements of Container are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+\n+         --  The last cursor of Container has been removed\n+\n+         and not P.Has_Key (Positions (Container), Last (Container)'Old)\n+\n+         --  Other cursors are still valid\n+\n+         and P.Keys_Included_Except\n+               (Left    => Positions (Container)'Old,\n+                Right   => Positions (Container)'Old,\n+                New_Key => Last (Container)'Old)\n+\n+         --  The positions of other cursors are preserved\n+\n+         and Positions (Container) <= Positions (Container)'Old;\n+\n+   procedure Delete_Last (Container : in out List; Count : Count_Type) with\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  All the elements of Container have been erased\n+\n+       (Length (Container) <= Count =>\n+          Length (Container) = 0,\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  The elements of Container are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+\n+            --  At most Count cursors have been removed at the end of Container\n+\n+            and P_Positions_Truncated\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => Length (Container) + 1,\n+                   Count => Count));\n+\n+   procedure Reverse_Elements (Container : in out List) with\n+     Global => null,\n+     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I         : Cursor;\n+      J         : Cursor)\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n+     Post   =>\n+       M_Elements_Swapped\n+         (Model (Container)'Old,\n+          Model (Container),\n+          X => P.Get (Positions (Container)'Old, I),\n+          Y => P.Get (Positions (Container)'Old, J))\n+\n+         and Positions (Container) = Positions (Container)'Old;\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I         : Cursor;\n+      J         : Cursor)\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n+     Post   =>\n+       M_Elements_Swapped\n+         (Model (Container'Old),\n+          Model (Container),\n+          X => P.Get (Positions (Container)'Old, I),\n+          Y => P.Get (Positions (Container)'Old, J))\n+         and P_Positions_Swapped\n+               (Positions (Container)'Old, Positions (Container), I, J);\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List)\n+   --  Target and Source should not be aliased\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Length (Source) <= Count_Type'Last - Length (Target)\n+         and then (Has_Element (Target, Before) or else Before = No_Element),\n+     Post           =>\n+       Length (Source) = 0\n+         and Length (Target) = Length (Target)'Old + Length (Source)'Old,\n+     Contract_Cases =>\n+       (Before = No_Element =>\n+\n+          --  The elements of Target are preserved\n+\n+          M.Range_Equal\n+            (Left  => Model (Target)'Old,\n+             Right => Model (Target),\n+             Fst   => 1,\n+             Lst   => Length (Target)'Old)\n+\n+            --  The elements of Source are appended to target, the order is not\n+            --  specified.\n+\n+            and M_Elements_Included\n+                  (Left   => Model (Source)'Old,\n+                   L_Lst  => Length (Source)'Old,\n+                   Right  => Model (Target),\n+                   R_Fst  => Length (Target)'Old + 1,\n+                   R_Lst  => Length (Target))\n+\n+            and M_Elements_Included\n+                  (Left   => Model (Target),\n+                   L_Fst  => Length (Target)'Old + 1,\n+                   L_Lst  => Length (Target),\n+                   Right  => Model (Source)'Old,\n+                   R_Lst  => Length (Source)'Old)\n+\n+            --  Cursors have been inserted at the end of Target\n+\n+            and P_Positions_Truncated\n+                  (Positions (Target)'Old,\n+                   Positions (Target),\n+                   Cut   => Length (Target)'Old + 1,\n+                   Count => Length (Source)'Old),\n+\n+        others =>\n+\n+          --  The elements of Target located before Before are preserved\n+\n+          M.Range_Equal\n+            (Left  => Model (Target)'Old,\n+             Right => Model (Target),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Target)'Old, Before) - 1)\n+\n+            --  The elements of Source are inserted before Before, the order is\n+            --  not specified.\n+\n+            and M_Elements_Included\n+                  (Left   => Model (Source)'Old,\n+                   L_Lst  => Length (Source)'Old,\n+                   Right  => Model (Target),\n+                   R_Fst  => P.Get (Positions (Target)'Old, Before),\n+                   R_Lst  =>\n+                     P.Get (Positions (Target)'Old, Before) - 1 +\n+                       Length (Source)'Old)\n+\n+            and M_Elements_Included\n+                  (Left   => Model (Target),\n+                   L_Fst  => P.Get (Positions (Target)'Old, Before),\n+                   L_Lst  =>\n+                     P.Get (Positions (Target)'Old, Before) - 1 +\n+                       Length (Source)'Old,\n+                   Right  => Model (Source)'Old,\n+                   R_Lst  => Length (Source)'Old)\n+\n+          --  Other elements are shifted by the length of Source\n+\n+          and M.Range_Shifted\n+                (Left   => Model (Target)'Old,\n+                 Right  => Model (Target),\n+                 Fst    => P.Get (Positions (Target)'Old, Before),\n+                 Lst    => Length (Target)'Old,\n+                 Offset => Length (Source)'Old)\n+\n+          --  Cursors have been inserted at position Before in Target\n+\n+          and P_Positions_Shifted\n+                (Positions (Target)'Old,\n+                 Positions (Target),\n+                 Cut   => P.Get (Positions (Target)'Old, Before),\n+                 Count => Length (Source)'Old));\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : in out Cursor)\n+   --  Target and Source should not be aliased\n+   with\n+     Global => null,\n+     Pre    =>\n+       (Has_Element (Target, Before) or else Before = No_Element)\n+         and then Has_Element (Source, Position)\n+         and then Length (Target) < Count_Type'Last,\n+     Post   =>\n+       Length (Target) = Length (Target)'Old + 1\n+         and Length (Source) = Length (Source)'Old - 1\n+\n+         --  The elements of Source located before Position are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Source)'Old,\n+                Right => Model (Source),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Source)'Old, Position'Old) - 1)\n+\n+         --  The elements located after Position are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Source)'Old,\n+                Right  => Model (Source),\n+                Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n+                Lst    => Length (Source)'Old,\n+                Offset => -1)\n+\n+         --  Position has been removed from Source\n+\n+         and P_Positions_Shifted\n+               (Positions (Source),\n+                Positions (Source)'Old,\n+                Cut   => P.Get (Positions (Source)'Old, Position'Old))\n+\n+         --  Positions is valid in Target and it is located either before\n+         --  Before if it is valid in Target or at the end if it is No_Element.\n+\n+         and P.Has_Key (Positions (Target), Position)\n+         and (if Before = No_Element then\n+                 P.Get (Positions (Target), Position) = Length (Target)\n+              else\n+                 P.Get (Positions (Target), Position) =\n+                 P.Get (Positions (Target)'Old, Before))\n+\n+         --  The elements of Target located before Position are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Target)'Old,\n+                Right => Model (Target),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Target), Position) - 1)\n+\n+         --  Other elements are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Target)'Old,\n+                Right  => Model (Target),\n+                Fst    => P.Get (Positions (Target), Position),\n+                Lst    => Length (Target)'Old,\n+                Offset => 1)\n+\n+         --  The element located at Position in Source is moved to Target\n+\n+         and Element (Model (Target),\n+                      P.Get (Positions (Target), Position)) =\n+             Element (Model (Source)'Old,\n+                      P.Get (Positions (Source)'Old, Position'Old))\n+\n+         --  A new cursor has been inserted at position Position in Target\n+\n+         and P_Positions_Shifted\n+               (Positions (Target)'Old,\n+                Positions (Target),\n+                Cut => P.Get (Positions (Target), Position));\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : Cursor)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       (Has_Element (Container, Before) or else Before = No_Element)\n+         and then Has_Element (Container, Position),\n+     Post           => Length (Container) = Length (Container)'Old,\n+     Contract_Cases =>\n+       (Before = Position =>\n+          Model (Container) = Model (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        Before = No_Element =>\n+\n+          --  The elements located before Position are preserved\n+\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Position) - 1)\n+\n+          --  The elements located after Position are shifted by 1\n+\n+          and M.Range_Shifted\n+                (Left   => Model (Container)'Old,\n+                 Right  => Model (Container),\n+                 Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n+                 Lst    => Length (Container)'Old,\n+                 Offset => -1)\n+\n+          --  The last element of Container is the one that was previously at\n+          --  Position.\n+\n+          and Element (Model (Container),\n+                       Length (Container)) =\n+              Element (Model (Container)'Old,\n+                       P.Get (Positions (Container)'Old, Position))\n+\n+          --  Cursors from Container continue designating the same elements\n+\n+          and Mapping_Preserved\n+                (M_Left  => Model (Container)'Old,\n+                 M_Right => Model (Container),\n+                 P_Left  => Positions (Container)'Old,\n+                 P_Right => Positions (Container)),\n+\n+        others =>\n+\n+          --  The elements located before Position and Before are preserved\n+\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   =>\n+               Count_Type'Min\n+                 (P.Get (Positions (Container)'Old, Position) - 1,\n+                  P.Get (Positions (Container)'Old, Before) - 1))\n+\n+            --  The elements located after Position and Before are preserved\n+\n+            and M.Range_Equal\n+                  (Left  => Model (Container)'Old,\n+                   Right => Model (Container),\n+                   Fst   =>\n+                     Count_Type'Max\n+                       (P.Get (Positions (Container)'Old, Position) + 1,\n+                        P.Get (Positions (Container)'Old, Before) + 1),\n+                   Lst   => Length (Container))\n+\n+            --  The elements located after Before and before Position are\n+            --  shifted by 1 to the right.\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n+                   Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n+                   Offset => 1)\n+\n+            --  The elements located after Position and before Before are\n+            --  shifted by 1 to the left.\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n+                   Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n+                   Offset => -1)\n+\n+            --  The element previously at Position is now before Before\n+\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container)'Old, Before)) =\n+                Element\n+                  (Model (Container)'Old,\n+                   P.Get (Positions (Container)'Old, Position))\n+\n+            --  Cursors from Container continue designating the same elements\n+\n+            and Mapping_Preserved\n+                  (M_Left  => Model (Container)'Old,\n+                   M_Right => Model (Container),\n+                   P_Left  => Positions (Container)'Old,\n+                   P_Right => Positions (Container)));\n+\n+   function First (Container : List) return Cursor with\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          First'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, First'Result)\n+            and P.Get (Positions (Container), First'Result) = 1);\n+\n+   function First_Element (Container : List) return Element_Type with\n+     Global => null,\n+     Pre    => not Is_Empty (Container),\n+     Post   => First_Element'Result = M.Get (Model (Container), 1);\n+\n+   function Last (Container : List) return Cursor with\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          Last'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Last'Result)\n+            and P.Get (Positions (Container), Last'Result) =\n+                  Length (Container));\n+\n+   function Last_Element (Container : List) return Element_Type with\n+     Global => null,\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Last_Element'Result = M.Get (Model (Container), Length (Container));\n+\n+   function Next (Container : List; Position : Cursor) return Cursor with\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Next'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Next'Result)\n+            and then P.Get (Positions (Container), Next'Result) =\n+                     P.Get (Positions (Container), Position) + 1);\n+\n+   procedure Next (Container : List; Position : in out Cursor) with\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) + 1);\n+\n+   function Previous (Container : List; Position : Cursor) return Cursor with\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = 1\n+        =>\n+          Previous'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Previous'Result)\n+            and then P.Get (Positions (Container), Previous'Result) =\n+                     P.Get (Positions (Container), Position) - 1);\n+\n+   procedure Previous (Container : List; Position : in out Cursor) with\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = 1\n+         =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) - 1);\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+\n+       --  If Item is not contained in Container after Position, Find returns\n+       --  No_Element.\n+\n+       (not M.Contains\n+              (Container => Model (Container),\n+               Fst       =>\n+                 (if Position = No_Element then\n+                     1\n+                  else\n+                     P.Get (Positions (Container), Position)),\n+               Lst       => Length (Container),\n+               Item      => Item)\n+        =>\n+          Find'Result = No_Element,\n+\n+        --  Otherwise, Find returns a valid cursor in Container\n+\n+        others =>\n+          P.Has_Key (Positions (Container), Find'Result)\n+\n+            --  The element designated by the result of Find is Item\n+\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container), Find'Result)) = Item\n+\n+            --  The result of Find is located after Position\n+\n+            and (if Position /= No_Element then\n+                    P.Get (Positions (Container), Find'Result) >=\n+                    P.Get (Positions (Container), Position))\n+\n+            --  It is the first occurrence of Item in this slice\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       =>\n+                         (if Position = No_Element then\n+                             1\n+                          else\n+                             P.Get (Positions (Container), Position)),\n+                       Lst       =>\n+                         P.Get (Positions (Container), Find'Result) - 1,\n+                       Item      => Item));\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+\n+       --  If Item is not contained in Container before Position, Find returns\n+       --  No_Element.\n+\n+       (not M.Contains\n+              (Container => Model (Container),\n+               Fst       => 1,\n+               Lst       =>\n+                 (if Position = No_Element then\n+                     Length (Container)\n+                  else\n+                     P.Get (Positions (Container), Position)),\n+               Item      => Item)\n+        =>\n+          Reverse_Find'Result = No_Element,\n+\n+        --  Otherwise, Find returns a valid cursor in Container\n+\n+        others =>\n+          P.Has_Key (Positions (Container), Reverse_Find'Result)\n+\n+            --  The element designated by the result of Find is Item\n+\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container), Reverse_Find'Result)) = Item\n+\n+            --  The result of Find is located before Position\n+\n+            and (if Position /= No_Element then\n+                    P.Get (Positions (Container), Reverse_Find'Result) <=\n+                    P.Get (Positions (Container), Position))\n+\n+            --  It is the last occurrence of Item in this slice\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       =>\n+                         P.Get (Positions (Container),\n+                                Reverse_Find'Result) + 1,\n+                       Lst       =>\n+                         (if Position = No_Element then\n+                             Length (Container)\n+                          else\n+                             P.Get (Positions (Container), Position)),\n+                       Item      => Item));\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean\n+   with\n+     Global => null,\n+     Post   =>\n+       Contains'Result = M.Contains (Container => Model (Container),\n+                                     Fst       => 1,\n+                                     Lst       => Length (Container),\n+                                     Item      => Item);\n+\n+   function Has_Element\n+     (Container : List;\n+      Position  : Cursor) return Boolean\n+   with\n+     Global => null,\n+     Post   =>\n+       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+   package Generic_Sorting with SPARK_Mode is\n+\n+      package Formal_Model with Ghost is\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n+         with\n+           Global => null,\n+           Post   =>\n+             M_Elements_Sorted'Result =\n+               (for all I in 1 .. M.Length (Container) =>\n+                 (for all J in I .. M.Length (Container) =>\n+                   not (Element (Container, J) < Element (Container, I))));\n+         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n+\n+      end Formal_Model;\n+      use Formal_Model;\n+\n+      function Is_Sorted (Container : List) return Boolean with\n+        Global => null,\n+        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n+\n+      procedure Sort (Container : in out List) with\n+        Global => null,\n+        Post   =>\n+          Length (Container) = Length (Container)'Old\n+            and M_Elements_Sorted (Model (Container))\n+            and M_Elements_Included\n+                  (Left  => Model (Container)'Old,\n+                   L_Lst => Length (Container),\n+                   Right => Model (Container),\n+                   R_Lst => Length (Container))\n+            and M_Elements_Included\n+                  (Left  => Model (Container),\n+                   L_Lst => Length (Container),\n+                   Right => Model (Container)'Old,\n+                   R_Lst => Length (Container));\n+\n+      procedure Merge (Target : in out List; Source : in out List) with\n+      --  Target and Source should not be aliased\n+        Global => null,\n+        Pre    => Length (Target) <= Count_Type'Last - Length (Source),\n+        Post   =>\n+          Length (Target) = Length (Target)'Old + Length (Source)'Old\n+            and Length (Source) = 0\n+            and (if M_Elements_Sorted (Model (Target)'Old)\n+                   and M_Elements_Sorted (Model (Source)'Old)\n+                 then\n+                    M_Elements_Sorted (Model (Target)))\n+            and M_Elements_Included\n+                  (Left  => Model (Target)'Old,\n+                   L_Lst => Length (Target)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Length (Target))\n+            and M_Elements_Included\n+                  (Left  => Model (Source)'Old,\n+                   L_Lst => Length (Source)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Length (Target))\n+            and M_Elements_In_Union\n+                  (Model (Target),\n+                   Model (Source)'Old,\n+                   Model (Target)'Old);\n+   end Generic_Sorting;\n+\n+private\n+   pragma SPARK_Mode (Off);\n+\n+   use Ada.Finalization;\n+\n+   type Element_Access is access all Element_Type;\n+\n+   type Node_Type is record\n+      Prev    : Count_Type'Base := -1;\n+      Next    : Count_Type := 0;\n+      Element : Element_Access := null;\n+   end record;\n+\n+   type Node_Access is access all Node_Type;\n+\n+   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n+\n+   type Node_Array is array (Count_Type range <>) of Node_Type;\n+   function \"=\" (L, R : Node_Array) return Boolean is abstract;\n+\n+   type Node_Array_Access is access all Node_Array;\n+\n+   type List is new Controlled with record\n+      Free   : Count_Type'Base := -1;\n+      Length : Count_Type := 0;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+      Nodes  : Node_Array_Access := null;\n+   end record;\n+\n+   overriding procedure Finalize (Container : in out List);\n+   overriding procedure Adjust (Container : in out List);\n+end Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists;"}]}