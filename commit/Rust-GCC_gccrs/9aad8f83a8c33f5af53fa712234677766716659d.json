{"sha": "9aad8f83a8c33f5af53fa712234677766716659d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFhZDhmODNhOGMzM2Y1YWY1M2ZhNzEyMjM0Njc3NzY2NzE2NjU5ZA==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2003-01-03T19:48:55Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2003-01-03T19:48:55Z"}, "message": "cp-tree.h (struct lang_type_class): add field for key method\n\n        * cp-tree.h (struct lang_type_class): add field for key method\n        (cp_global_trees): rename dynamic_classes to keyed_classes\n        (key_method): add definition\n        * class.c (finish_struct_1): compute class's key method, and add\n        the class to keyed_classes list if there is no key method.\n        * decl.c (finish_function): add class to keyed_classes list if we\n        see a definition of the class's key method.\n        * pt.c (instantiate_class_template): add template specialization\n        of a dynamic class to keyed_classes list.\n        * decl2.c (key_method): remove\n        (finish_file): iterate only through keyed_classes list when\n        deciding whether to emit vtables, remove class from its list after\n        we do the emission.\n\nFrom-SVN: r60850", "tree": {"sha": "fcf7fb52bf769a2736649a456198023537d5a286", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcf7fb52bf769a2736649a456198023537d5a286"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9aad8f83a8c33f5af53fa712234677766716659d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aad8f83a8c33f5af53fa712234677766716659d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9aad8f83a8c33f5af53fa712234677766716659d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aad8f83a8c33f5af53fa712234677766716659d/comments", "author": null, "committer": null, "parents": [{"sha": "6cce57b0d073bc545a9a2855885e65a4ca43ce4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cce57b0d073bc545a9a2855885e65a4ca43ce4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cce57b0d073bc545a9a2855885e65a4ca43ce4d"}], "stats": {"total": 144, "additions": 106, "deletions": 38}, "files": [{"sha": "344630d722d2eaf4e423097c42e039bd463a8aa2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9aad8f83a8c33f5af53fa712234677766716659d", "patch": "@@ -1,3 +1,19 @@\n+2003-01-03  Matt Austern  <austern@apple.com>\n+\n+\t* cp-tree.h (struct lang_type_class): add field for key method\n+\t(cp_global_trees): rename dynamic_classes to keyed_classes\n+\t(key_method): add definition\n+\t* class.c (finish_struct_1): compute class's key method, and add\n+\tthe class to keyed_classes list if there is no key method.\n+\t* decl.c (finish_function): add class to keyed_classes list if we\n+\tsee a definition of the class's key method.\n+\t* pt.c (instantiate_class_template): add template specialization\n+\tof a dynamic class to keyed_classes list.\n+\t* decl2.c (key_method): remove\n+\t(finish_file): iterate only through keyed_classes list when\n+\tdeciding whether to emit vtables, remove class from its list after\n+\twe do the emission.\n+\t\n 2003-01-02  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (cp_make_fname_decl): Push the decls inside the"}, {"sha": "c278aa5e91b9c409284bc29d10e8d4f9ac70f9f9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9aad8f83a8c33f5af53fa712234677766716659d", "patch": "@@ -5224,6 +5224,30 @@ layout_class_type (tree t, tree *virtuals_p)\n   splay_tree_delete (empty_base_offsets);\n }\n \n+/* Returns the virtual function with which the vtable for TYPE is\n+   emitted, or NULL_TREE if that heuristic is not applicable to TYPE.  */\n+\n+static tree\n+key_method (tree type)\n+{\n+  tree method;\n+\n+  if (TYPE_FOR_JAVA (type)\n+      || processing_template_decl\n+      || CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n+      || CLASSTYPE_INTERFACE_KNOWN (type))\n+    return NULL_TREE;\n+\n+  for (method = TYPE_METHODS (type); method != NULL_TREE;\n+       method = TREE_CHAIN (method))\n+    if (DECL_VINDEX (method) != NULL_TREE\n+\t&& ! DECL_DECLARED_INLINE_P (method)\n+\t&& ! DECL_PURE_VIRTUAL_P (method))\n+      return method;\n+\n+  return NULL_TREE;\n+}\n+\n /* Perform processing required when the definition of T (a class type)\n    is complete.  */\n \n@@ -5265,6 +5289,17 @@ finish_struct_1 (t)\n      bases and members and add implicitly generated methods.  */\n   check_bases_and_members (t);\n \n+  /* Find the key method */\n+    if (TYPE_CONTAINS_VPTR_P (t))\n+    {\n+      CLASSTYPE_KEY_METHOD (t) = key_method (t);\n+\n+      /* If a polymorphic class has no key method, we may emit the vtable\n+\t in every translation unit where the class definition appears. */\n+      if (CLASSTYPE_KEY_METHOD (t) == NULL_TREE)\n+\tkeyed_classes = tree_cons (NULL_TREE, t, keyed_classes);\n+    }\n+\n   /* Layout the class itself.  */\n   layout_class_type (t, &virtuals);\n \n@@ -5342,9 +5377,6 @@ finish_struct_1 (t)\n \t  else if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n \t    DECL_VINDEX (fndecl) = build_shared_int_cst (vindex);\n \t}\n-\n-      /* Add this class to the list of dynamic classes.  */\n-      dynamic_classes = tree_cons (NULL_TREE, t, dynamic_classes);\n     }\n \n   finish_struct_bits (t);"}, {"sha": "8f77d10bab78f9f34717e81b543498e839e080ab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9aad8f83a8c33f5af53fa712234677766716659d", "patch": "@@ -628,7 +628,7 @@ enum cp_tree_index\n     CPTI_DSO_HANDLE,\n     CPTI_DCAST,\n \n-    CPTI_DYNAMIC_CLASSES,\n+    CPTI_KEYED_CLASSES,\n \n     CPTI_MAX\n };\n@@ -761,9 +761,10 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    destructors.  */\n #define vtt_parm_type                   cp_global_trees[CPTI_VTT_PARM_TYPE]\n \n-/* A TREE_LIST of all of the dynamic classes in the program.  */\n+/* A TREE_LIST of the dynamic classes whose vtables may have to be\n+   emitted in this translation unit.  */\n \n-#define dynamic_classes                 cp_global_trees[CPTI_DYNAMIC_CLASSES]\n+#define keyed_classes                   cp_global_trees[CPTI_KEYED_CLASSES]\n \n /* Global state.  */\n \n@@ -1182,6 +1183,7 @@ struct lang_type_class GTY(())\n   tree pure_virtuals;\n   tree friend_classes;\n   tree methods;\n+  tree key_method;\n   tree decl_list;\n   tree template_info;\n   tree befriending_classes;\n@@ -1302,6 +1304,11 @@ struct lang_type GTY(())\n    hierarchy, then we can use more efficient search techniques.  */\n #define TYPE_USES_VIRTUAL_BASECLASSES(NODE) (TREE_LANG_FLAG_3 (NODE))\n \n+/* The member function with which the vtable will be emitted:\n+   the first noninline non-pure-virtual member function.  NULL_TREE\n+   if there is no key function or if this is a class template */\n+#define CLASSTYPE_KEY_METHOD(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->key_method)\n+\n /* Vector member functions defined in this class.  Each element is\n    either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  All\n    functions with the same name end up in the same slot.  The first"}, {"sha": "63ec317d7dc5e1881832f1c13586838bd3343bc2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9aad8f83a8c33f5af53fa712234677766716659d", "patch": "@@ -14360,6 +14360,15 @@ finish_function (flags)\n   if (fndecl == NULL_TREE)\n     return error_mark_node;\n \n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl)\n+      && DECL_VIRTUAL_P (fndecl)\n+      && !processing_template_decl)\n+    {\n+      tree fnclass = DECL_CONTEXT (fndecl);\n+      if (fndecl == CLASSTYPE_KEY_METHOD (fnclass))\n+\tkeyed_classes = tree_cons (NULL_TREE, fnclass, keyed_classes);\n+    }\n+\n   nested = function_depth > 1;\n   fntype = TREE_TYPE (fndecl);\n "}, {"sha": "73e37ad5f1b0a869fcdfb5322b7eb0cc728a2b92", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9aad8f83a8c33f5af53fa712234677766716659d", "patch": "@@ -88,7 +88,6 @@ static int generate_ctor_and_dtor_functions_for_priority (splay_tree_node,\n static tree prune_vars_needing_no_initialization (tree);\n static void write_out_vars (tree);\n static void import_export_class (tree);\n-static tree key_method (tree); \n static tree get_guard_bits (tree);\n \n /* A list of static class variables.  This is needed, because a\n@@ -1536,29 +1535,6 @@ maybe_make_one_only (tree decl)\n     }\n }\n \n-/* Returns the virtual function with which the vtable for TYPE is\n-   emitted, or NULL_TREE if that heuristic is not applicable to TYPE.  */\n-\n-static tree\n-key_method (tree type)\n-{\n-  tree method;\n-\n-  if (TYPE_FOR_JAVA (type)\n-      || CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n-      || CLASSTYPE_INTERFACE_KNOWN (type))\n-    return NULL_TREE;\n-\n-  for (method = TYPE_METHODS (type); method != NULL_TREE;\n-       method = TREE_CHAIN (method))\n-    if (DECL_VINDEX (method) != NULL_TREE\n-\t&& ! DECL_DECLARED_INLINE_P (method)\n-\t&& ! DECL_PURE_VIRTUAL_P (method))\n-      return method;\n-\n-  return NULL_TREE;\n-}\n-\n /* Set TREE_PUBLIC and/or DECL_EXTERN on the vtable DECL,\n    based on TYPE and other static flags.\n \n@@ -1589,7 +1565,7 @@ import_export_vtable (tree decl, tree type, int final)\n \t functions in our class, or if we come from a template.  */\n \n       int found = (CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n-\t\t   || key_method (type));\n+\t\t   || CLASSTYPE_KEY_METHOD (type) != NULL_TREE);\n \n       if (final || ! found)\n \t{\n@@ -1648,7 +1624,7 @@ import_export_class (tree ctype)\n   if (import_export == 0\n       && TYPE_POLYMORPHIC_P (ctype))\n     {\n-      tree method = key_method (ctype);\n+      tree method = CLASSTYPE_KEY_METHOD (ctype);\n       if (method)\n \timport_export = (DECL_REALLY_EXTERN (method) ? -1 : 1);\n     }\n@@ -2639,12 +2615,37 @@ finish_file ()\n       instantiate_pending_templates ();\n \n       /* Write out virtual tables as required.  Note that writing out\n-\t the virtual table for a template class may cause the\n-\t instantiation of members of that class.  */\n-      for (t = dynamic_classes; t; t = TREE_CHAIN (t))\n-\tif (maybe_emit_vtables (TREE_VALUE (t)))\n-\t  reconsider = true;\n-      \n+  \t the virtual table for a template class may cause the\n+ \t instantiation of members of that class.  If we write out\n+ \t vtables then we remove the class from our list so we don't\n+ \t have to look at it again. */\n+ \n+      while (keyed_classes != NULL_TREE\n+ \t     && maybe_emit_vtables (TREE_VALUE (keyed_classes)))\n+ \t{\n+  \t  reconsider = 1;\n+ \t  keyed_classes = TREE_CHAIN (keyed_classes);\n+ \t}\n+ \n+      t = keyed_classes;\n+      if (t != NULL_TREE)\n+ \t{\n+ \t  tree next = TREE_CHAIN (t);\n+ \n+ \t  while (next)\n+ \t    {\n+ \t      if (maybe_emit_vtables (TREE_VALUE (next)))\n+ \t\t{\n+ \t\t  reconsider = 1;\n+ \t\t  TREE_CHAIN (t) = TREE_CHAIN (next);\n+ \t\t}\n+ \t      else\n+ \t\tt = next;\n+ \n+ \t      next = TREE_CHAIN (t);\n+ \t    }\n+ \t}\n+       \n       /* Write out needed type info variables. Writing out one variable\n          might cause others to be needed.  */\n       if (walk_globals (unemitted_tinfo_decl_p, emit_tinfo_decl, /*data=*/0))"}, {"sha": "aedc90d2ec6f4b59a66fdc98417eb8827dde7fba", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aad8f83a8c33f5af53fa712234677766716659d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9aad8f83a8c33f5af53fa712234677766716659d", "patch": "@@ -5487,6 +5487,9 @@ instantiate_class_template (type)\n   pop_from_top_level ();\n   pop_tinst_level ();\n \n+  if (TYPE_CONTAINS_VPTR_P (type))\n+    keyed_classes = tree_cons (NULL_TREE, type, keyed_classes);\n+\n   return type;\n }\n "}]}