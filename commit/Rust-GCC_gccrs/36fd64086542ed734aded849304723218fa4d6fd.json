{"sha": "36fd64086542ed734aded849304723218fa4d6fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZmZDY0MDg2NTQyZWQ3MzRhZGVkODQ5MzA0NzIzMjE4ZmE0ZDZmZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:51:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:51:50Z"}, "message": "poly_int: tree constants\n\nThis patch adds a tree representation for poly_ints.  Unlike the\nrtx version, the coefficients are INTEGER_CSTs rather than plain\nintegers, so that we can easily access them as poly_widest_ints\nand poly_offset_ints.\n\nThe patch also adjusts some places that previously\nrelied on \"constant\" meaning \"INTEGER_CST\".  It also makes\nsure that the TYPE_SIZE agrees with the TYPE_SIZE_UNIT for\nvector booleans, given the existing:\n\n\t/* Several boolean vector elements may fit in a single unit.  */\n\tif (VECTOR_BOOLEAN_TYPE_P (type)\n\t    && type->type_common.mode != BLKmode)\n\t  TYPE_SIZE_UNIT (type)\n\t    = size_int (GET_MODE_SIZE (type->type_common.mode));\n\telse\n\t  TYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n\t\t\t\t\t\t   TYPE_SIZE_UNIT (innertype),\n\t\t\t\t\t\t   size_int (nunits));\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/generic.texi (POLY_INT_CST): Document.\n\t* tree.def (POLY_INT_CST): New tree code.\n\t* treestruct.def (TS_POLY_INT_CST): New tree layout.\n\t* tree-core.h (tree_poly_int_cst): New struct.\n\t(tree_node): Add a poly_int_cst field.\n\t* tree.h (POLY_INT_CST_P, POLY_INT_CST_COEFF): New macros.\n\t(wide_int_to_tree, force_fit_type): Take a poly_wide_int_ref\n\tinstead of a wide_int_ref.\n\t(build_int_cst, build_int_cst_type): Take a poly_int64 instead\n\tof a HOST_WIDE_INT.\n\t(build_int_cstu, build_array_type_nelts): Take a poly_uint64\n\tinstead of an unsigned HOST_WIDE_INT.\n\t(build_poly_int_cst, tree_fits_poly_int64_p, tree_fits_poly_uint64_p)\n\t(ptrdiff_tree_p): Declare.\n\t(tree_to_poly_int64, tree_to_poly_uint64): Likewise.  Provide\n\textern inline implementations if the target doesn't use POLY_INT_CST.\n\t(poly_int_tree_p): New function.\n\t(wi::unextended_tree): New class.\n\t(wi::int_traits <unextended_tree>): New override.\n\t(wi::extended_tree): Add a default constructor.\n\t(wi::extended_tree::get_tree): New function.\n\t(wi::widest_extended_tree, wi::offset_extended_tree): New typedefs.\n\t(wi::tree_to_widest_ref, wi::tree_to_offset_ref): Use them.\n\t(wi::tree_to_poly_widest_ref, wi::tree_to_poly_offset_ref)\n\t(wi::tree_to_poly_wide_ref): New typedefs.\n\t(wi::ints_for): Provide overloads for extended_tree and\n\tunextended_tree.\n\t(poly_int_cst_value, wi::to_poly_widest, wi::to_poly_offset)\n\t(wi::to_wide): New functions.\n\t(wi::fits_to_boolean_p, wi::fits_to_tree_p): Handle poly_ints.\n\t* tree.c (poly_int_cst_hasher): New struct.\n\t(poly_int_cst_hash_table): New variable.\n\t(tree_node_structure_for_code, tree_code_size, simple_cst_equal)\n\t(valid_constant_size_p, add_expr, drop_tree_overflow): Handle\n\tPOLY_INT_CST.\n\t(initialize_tree_contains_struct): Handle TS_POLY_INT_CST.\n\t(init_ttree): Initialize poly_int_cst_hash_table.\n\t(build_int_cst, build_int_cst_type, build_invariant_address): Take\n\ta poly_int64 instead of a HOST_WIDE_INT.\n\t(build_int_cstu, build_array_type_nelts): Take a poly_uint64\n\tinstead of an unsigned HOST_WIDE_INT.\n\t(wide_int_to_tree): Rename to...\n\t(wide_int_to_tree_1): ...this.\n\t(build_new_poly_int_cst, build_poly_int_cst): New functions.\n\t(force_fit_type): Take a poly_wide_int_ref instead of a wide_int_ref.\n\t(wide_int_to_tree): New function that takes a poly_wide_int_ref.\n\t(ptrdiff_tree_p, tree_to_poly_int64, tree_to_poly_uint64)\n\t(tree_fits_poly_int64_p, tree_fits_poly_uint64_p): New functions.\n\t* lto-streamer-out.c (DFS::DFS_write_tree_body, hash_tree): Handle\n\tTS_POLY_INT_CST.\n\t* tree-streamer-in.c (lto_input_ts_poly_tree_pointers): Likewise.\n\t(streamer_read_tree_body): Likewise.\n\t* tree-streamer-out.c (write_ts_poly_tree_pointers): Likewise.\n\t(streamer_write_tree_body): Likewise.\n\t* tree-streamer.c (streamer_check_handled_ts_structures): Likewise.\n\t* asan.c (asan_protect_global): Require the size to be an INTEGER_CST.\n\t* cfgexpand.c (expand_debug_expr): Handle POLY_INT_CST.\n\t* expr.c (expand_expr_real_1, const_vector_from_tree): Likewise.\n\t* gimple-expr.h (is_gimple_constant): Likewise.\n\t* gimplify.c (maybe_with_size_expr): Likewise.\n\t* print-tree.c (print_node): Likewise.\n\t* tree-data-ref.c (data_ref_compare_tree): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-ssa-address.c (addr_for_mem_ref): Likewise.\n\t* tree-vect-data-refs.c (dr_group_sort_cmp): Likewise.\n\t* tree-vrp.c (compare_values_warnv): Likewise.\n\t* tree-ssa-loop-ivopts.c (determine_base_object, constant_multiple_of)\n\t(get_loop_invariant_expr, add_candidate_1, get_computation_aff_1)\n\t(force_expr_to_var_cost): Likewise.\n\t* tree-ssa-loop.c (for_each_index): Likewise.\n\t* fold-const.h (build_invariant_address, size_int_kind): Take a\n\tpoly_int64 instead of a HOST_WIDE_INT.\n\t* fold-const.c (fold_negate_expr_1, const_binop, const_unop)\n\t(fold_convert_const, multiple_of_p, fold_negate_const): Handle\n\tPOLY_INT_CST.\n\t(size_binop_loc): Likewise.  Allow int_const_binop_1 to fail.\n\t(int_const_binop_2): New function, split out from...\n\t(int_const_binop_1): ...here.  Handle POLY_INT_CST.\n\t(size_int_kind): Take a poly_int64 instead of a HOST_WIDE_INT.\n\t* expmed.c (make_tree): Handle CONST_POLY_INT_P.\n\t* gimple-ssa-strength-reduction.c (slsr_process_add)\n\t(slsr_process_mul): Check for INTEGER_CSTs before using them\n\tas candidates.\n\t* stor-layout.c (bits_from_bytes): New function.\n\t(bit_from_pos): Use it.\n\t(layout_type): Likewise.  For vectors, multiply the TYPE_SIZE_UNIT\n\tby BITS_PER_UNIT to get the TYPE_SIZE.\n\t* tree-cfg.c (verify_expr, verify_types_in_gimple_reference): Allow\n\tMEM_REF and TARGET_MEM_REF offsets to be a POLY_INT_CST.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255863", "tree": {"sha": "8ecb64d56e437c9912d8f6db4a70c9aec93c5019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ecb64d56e437c9912d8f6db4a70c9aec93c5019"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36fd64086542ed734aded849304723218fa4d6fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36fd64086542ed734aded849304723218fa4d6fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36fd64086542ed734aded849304723218fa4d6fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36fd64086542ed734aded849304723218fa4d6fd/comments", "author": null, "committer": null, "parents": [{"sha": "0c12fc9b2d605cf323cfdab28a972d86398e71a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c12fc9b2d605cf323cfdab28a972d86398e71a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c12fc9b2d605cf323cfdab28a972d86398e71a1"}], "stats": {"total": 911, "additions": 831, "deletions": 80}, "files": [{"sha": "2b57ea6c98d454378e92a5b4944a91f04b817531", "filename": "gcc/ChangeLog", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1,3 +1,97 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/generic.texi (POLY_INT_CST): Document.\n+\t* tree.def (POLY_INT_CST): New tree code.\n+\t* treestruct.def (TS_POLY_INT_CST): New tree layout.\n+\t* tree-core.h (tree_poly_int_cst): New struct.\n+\t(tree_node): Add a poly_int_cst field.\n+\t* tree.h (POLY_INT_CST_P, POLY_INT_CST_COEFF): New macros.\n+\t(wide_int_to_tree, force_fit_type): Take a poly_wide_int_ref\n+\tinstead of a wide_int_ref.\n+\t(build_int_cst, build_int_cst_type): Take a poly_int64 instead\n+\tof a HOST_WIDE_INT.\n+\t(build_int_cstu, build_array_type_nelts): Take a poly_uint64\n+\tinstead of an unsigned HOST_WIDE_INT.\n+\t(build_poly_int_cst, tree_fits_poly_int64_p, tree_fits_poly_uint64_p)\n+\t(ptrdiff_tree_p): Declare.\n+\t(tree_to_poly_int64, tree_to_poly_uint64): Likewise.  Provide\n+\textern inline implementations if the target doesn't use POLY_INT_CST.\n+\t(poly_int_tree_p): New function.\n+\t(wi::unextended_tree): New class.\n+\t(wi::int_traits <unextended_tree>): New override.\n+\t(wi::extended_tree): Add a default constructor.\n+\t(wi::extended_tree::get_tree): New function.\n+\t(wi::widest_extended_tree, wi::offset_extended_tree): New typedefs.\n+\t(wi::tree_to_widest_ref, wi::tree_to_offset_ref): Use them.\n+\t(wi::tree_to_poly_widest_ref, wi::tree_to_poly_offset_ref)\n+\t(wi::tree_to_poly_wide_ref): New typedefs.\n+\t(wi::ints_for): Provide overloads for extended_tree and\n+\tunextended_tree.\n+\t(poly_int_cst_value, wi::to_poly_widest, wi::to_poly_offset)\n+\t(wi::to_wide): New functions.\n+\t(wi::fits_to_boolean_p, wi::fits_to_tree_p): Handle poly_ints.\n+\t* tree.c (poly_int_cst_hasher): New struct.\n+\t(poly_int_cst_hash_table): New variable.\n+\t(tree_node_structure_for_code, tree_code_size, simple_cst_equal)\n+\t(valid_constant_size_p, add_expr, drop_tree_overflow): Handle\n+\tPOLY_INT_CST.\n+\t(initialize_tree_contains_struct): Handle TS_POLY_INT_CST.\n+\t(init_ttree): Initialize poly_int_cst_hash_table.\n+\t(build_int_cst, build_int_cst_type, build_invariant_address): Take\n+\ta poly_int64 instead of a HOST_WIDE_INT.\n+\t(build_int_cstu, build_array_type_nelts): Take a poly_uint64\n+\tinstead of an unsigned HOST_WIDE_INT.\n+\t(wide_int_to_tree): Rename to...\n+\t(wide_int_to_tree_1): ...this.\n+\t(build_new_poly_int_cst, build_poly_int_cst): New functions.\n+\t(force_fit_type): Take a poly_wide_int_ref instead of a wide_int_ref.\n+\t(wide_int_to_tree): New function that takes a poly_wide_int_ref.\n+\t(ptrdiff_tree_p, tree_to_poly_int64, tree_to_poly_uint64)\n+\t(tree_fits_poly_int64_p, tree_fits_poly_uint64_p): New functions.\n+\t* lto-streamer-out.c (DFS::DFS_write_tree_body, hash_tree): Handle\n+\tTS_POLY_INT_CST.\n+\t* tree-streamer-in.c (lto_input_ts_poly_tree_pointers): Likewise.\n+\t(streamer_read_tree_body): Likewise.\n+\t* tree-streamer-out.c (write_ts_poly_tree_pointers): Likewise.\n+\t(streamer_write_tree_body): Likewise.\n+\t* tree-streamer.c (streamer_check_handled_ts_structures): Likewise.\n+\t* asan.c (asan_protect_global): Require the size to be an INTEGER_CST.\n+\t* cfgexpand.c (expand_debug_expr): Handle POLY_INT_CST.\n+\t* expr.c (expand_expr_real_1, const_vector_from_tree): Likewise.\n+\t* gimple-expr.h (is_gimple_constant): Likewise.\n+\t* gimplify.c (maybe_with_size_expr): Likewise.\n+\t* print-tree.c (print_node): Likewise.\n+\t* tree-data-ref.c (data_ref_compare_tree): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-ssa-address.c (addr_for_mem_ref): Likewise.\n+\t* tree-vect-data-refs.c (dr_group_sort_cmp): Likewise.\n+\t* tree-vrp.c (compare_values_warnv): Likewise.\n+\t* tree-ssa-loop-ivopts.c (determine_base_object, constant_multiple_of)\n+\t(get_loop_invariant_expr, add_candidate_1, get_computation_aff_1)\n+\t(force_expr_to_var_cost): Likewise.\n+\t* tree-ssa-loop.c (for_each_index): Likewise.\n+\t* fold-const.h (build_invariant_address, size_int_kind): Take a\n+\tpoly_int64 instead of a HOST_WIDE_INT.\n+\t* fold-const.c (fold_negate_expr_1, const_binop, const_unop)\n+\t(fold_convert_const, multiple_of_p, fold_negate_const): Handle\n+\tPOLY_INT_CST.\n+\t(size_binop_loc): Likewise.  Allow int_const_binop_1 to fail.\n+\t(int_const_binop_2): New function, split out from...\n+\t(int_const_binop_1): ...here.  Handle POLY_INT_CST.\n+\t(size_int_kind): Take a poly_int64 instead of a HOST_WIDE_INT.\n+\t* expmed.c (make_tree): Handle CONST_POLY_INT_P.\n+\t* gimple-ssa-strength-reduction.c (slsr_process_add)\n+\t(slsr_process_mul): Check for INTEGER_CSTs before using them\n+\tas candidates.\n+\t* stor-layout.c (bits_from_bytes): New function.\n+\t(bit_from_pos): Use it.\n+\t(layout_type): Likewise.  For vectors, multiply the TYPE_SIZE_UNIT\n+\tby BITS_PER_UNIT to get the TYPE_SIZE.\n+\t* tree-cfg.c (verify_expr, verify_types_in_gimple_reference): Allow\n+\tMEM_REF and TARGET_MEM_REF offsets to be a POLY_INT_CST.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e27338fda77074ec78bd568e9bb6228f64486100", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1651,6 +1651,7 @@ asan_protect_global (tree decl, bool ignore_decl_rtl_set_p)\n \t  && !section_sanitized_p (DECL_SECTION_NAME (decl)))\n       || DECL_SIZE (decl) == 0\n       || ASAN_RED_ZONE_SIZE * BITS_PER_UNIT > MAX_OFILE_ALIGNMENT\n+      || TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST\n       || !valid_constant_size_p (DECL_SIZE_UNIT (decl))\n       || DECL_ALIGN_UNIT (decl) > 2 * ASAN_RED_ZONE_SIZE\n       || TREE_TYPE (decl) == ubsan_get_source_location_type ()"}, {"sha": "3bd36ebba2edb6112872272a2c7513e11e259504", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -4264,6 +4264,9 @@ expand_debug_expr (tree exp)\n       op0 = expand_expr (exp, NULL_RTX, mode, EXPAND_INITIALIZER);\n       return op0;\n \n+    case POLY_INT_CST:\n+      return immed_wide_int_const (poly_int_cst_value (exp), mode);\n+\n     case COMPLEX_CST:\n       gcc_assert (COMPLEX_MODE_P (mode));\n       op0 = expand_debug_expr (TREE_REALPART (exp));"}, {"sha": "33fef20b817a3271f47d3a236043cba0afb014d8", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1037,6 +1037,7 @@ As this example indicates, the operands are zero-indexed.\n @tindex COMPLEX_CST\n @tindex VECTOR_CST\n @tindex STRING_CST\n+@tindex POLY_INT_CST\n @findex TREE_STRING_LENGTH\n @findex TREE_STRING_POINTER\n \n@@ -1175,6 +1176,16 @@ of the @code{STRING_CST}.\n FIXME: The formats of string constants are not well-defined when the\n target system bytes are not the same width as host system bytes.\n \n+@item POLY_INT_CST\n+These nodes represent invariants that depend on some target-specific\n+runtime parameters.  They consist of @code{NUM_POLY_INT_COEFFS}\n+coefficients, with the first coefficient being the constant term and\n+the others being multipliers that are applied to the runtime parameters.\n+\n+@code{POLY_INT_CST_ELT (@var{x}, @var{i})} references coefficient number\n+@var{i} of @code{POLY_INT_CST} node @var{x}.  Each coefficient is an\n+@code{INTEGER_CST}.\n+\n @end table\n \n @node Storage References"}, {"sha": "cc57d3cf12f9e66b7c8402211dc6b4d3179e79d1", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -5278,6 +5278,9 @@ make_tree (tree type, rtx x)\n       /* fall through.  */\n \n     default:\n+      if (CONST_POLY_INT_P (x))\n+\treturn wide_int_to_tree (t, const_poly_int_value (x));\n+\n       t = build_decl (RTL_LOCATION (x), VAR_DECL, NULL_TREE, type);\n \n       /* If TYPE is a POINTER_TYPE, we might need to convert X from"}, {"sha": "a6b236507fa96322effdd2d2b3ee9fe13f07d4e1", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -10101,6 +10101,9 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\t\t      copy_rtx (XEXP (temp, 0)));\n       return temp;\n \n+    case POLY_INT_CST:\n+      return immed_wide_int_const (poly_int_cst_value (exp), mode);\n+\n     case SAVE_EXPR:\n       {\n \ttree val = treeop0;\n@@ -11816,7 +11819,8 @@ const_vector_from_tree (tree exp)\n \tRTVEC_ELT (v, i) = CONST_FIXED_FROM_FIXED_VALUE (TREE_FIXED_CST (elt),\n \t\t\t\t\t\t\t inner);\n       else\n-\tRTVEC_ELT (v, i) = immed_wide_int_const (wi::to_wide (elt), inner);\n+\tRTVEC_ELT (v, i) = immed_wide_int_const (wi::to_poly_wide (elt),\n+\t\t\t\t\t\t inner);\n     }\n \n   return gen_rtx_CONST_VECTOR (mode, v);"}, {"sha": "c219ed8a6af1aff2be867dbc50f908521b594b9a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 106, "deletions": 24, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -547,10 +547,8 @@ fold_negate_expr_1 (location_t loc, tree t)\n \treturn tem;\n       break;\n \n+    case POLY_INT_CST:\n     case REAL_CST:\n-      tem = fold_negate_const (t, type);\n-      return tem;\n-\n     case FIXED_CST:\n       tem = fold_negate_const (t, type);\n       return tem;\n@@ -961,13 +959,10 @@ int_binop_types_match_p (enum tree_code code, const_tree type1, const_tree type2\n \t && TYPE_MODE (type1) == TYPE_MODE (type2);\n }\n \n-\n-/* Combine two integer constants PARG1 and PARG2 under operation CODE\n-   to produce a new constant.  Return NULL_TREE if we don't know how\n-   to evaluate CODE at compile-time.  */\n+/* Subroutine of int_const_binop_1 that handles two INTEGER_CSTs.  */\n \n static tree\n-int_const_binop_1 (enum tree_code code, const_tree parg1, const_tree parg2,\n+int_const_binop_2 (enum tree_code code, const_tree parg1, const_tree parg2,\n \t\t   int overflowable)\n {\n   wide_int res;\n@@ -1115,6 +1110,74 @@ int_const_binop_1 (enum tree_code code, const_tree parg1, const_tree parg2,\n   return t;\n }\n \n+/* Combine two integer constants PARG1 and PARG2 under operation CODE\n+   to produce a new constant.  Return NULL_TREE if we don't know how\n+   to evaluate CODE at compile-time.  */\n+\n+static tree\n+int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n+\t\t   int overflowable)\n+{\n+  if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST)\n+    return int_const_binop_2 (code, arg1, arg2, overflowable);\n+\n+  gcc_assert (NUM_POLY_INT_COEFFS != 1);\n+\n+  if (poly_int_tree_p (arg1) && poly_int_tree_p (arg2))\n+    {\n+      poly_wide_int res;\n+      bool overflow;\n+      tree type = TREE_TYPE (arg1);\n+      signop sign = TYPE_SIGN (type);\n+      switch (code)\n+\t{\n+\tcase PLUS_EXPR:\n+\t  res = wi::add (wi::to_poly_wide (arg1),\n+\t\t\t wi::to_poly_wide (arg2), sign, &overflow);\n+\t  break;\n+\n+\tcase MINUS_EXPR:\n+\t  res = wi::sub (wi::to_poly_wide (arg1),\n+\t\t\t wi::to_poly_wide (arg2), sign, &overflow);\n+\t  break;\n+\n+\tcase MULT_EXPR:\n+\t  if (TREE_CODE (arg2) == INTEGER_CST)\n+\t    res = wi::mul (wi::to_poly_wide (arg1),\n+\t\t\t   wi::to_wide (arg2), sign, &overflow);\n+\t  else if (TREE_CODE (arg1) == INTEGER_CST)\n+\t    res = wi::mul (wi::to_poly_wide (arg2),\n+\t\t\t   wi::to_wide (arg1), sign, &overflow);\n+\t  else\n+\t    return NULL_TREE;\n+\t  break;\n+\n+\tcase LSHIFT_EXPR:\n+\t  if (TREE_CODE (arg2) == INTEGER_CST)\n+\t    res = wi::to_poly_wide (arg1) << wi::to_wide (arg2);\n+\t  else\n+\t    return NULL_TREE;\n+\t  break;\n+\n+\tcase BIT_IOR_EXPR:\n+\t  if (TREE_CODE (arg2) != INTEGER_CST\n+\t      || !can_ior_p (wi::to_poly_wide (arg1), wi::to_wide (arg2),\n+\t\t\t     &res))\n+\t    return NULL_TREE;\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+      return force_fit_type (type, res, overflowable,\n+\t\t\t     (((sign == SIGNED || overflowable == -1)\n+\t\t\t       && overflow)\n+\t\t\t      | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2)));\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n tree\n int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2)\n {\n@@ -1157,7 +1220,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n   STRIP_NOPS (arg1);\n   STRIP_NOPS (arg2);\n \n-  if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST)\n+  if (poly_int_tree_p (arg1) && poly_int_tree_p (arg2))\n     {\n       if (code == POINTER_PLUS_EXPR)\n \treturn int_const_binop (PLUS_EXPR,\n@@ -1701,6 +1764,8 @@ const_unop (enum tree_code code, tree type, tree arg0)\n     case BIT_NOT_EXPR:\n       if (TREE_CODE (arg0) == INTEGER_CST)\n \treturn fold_not_const (arg0, type);\n+      else if (POLY_INT_CST_P (arg0))\n+\treturn wide_int_to_tree (type, -poly_int_cst_value (arg0));\n       /* Perform BIT_NOT_EXPR on each element individually.  */\n       else if (TREE_CODE (arg0) == VECTOR_CST)\n \t{\n@@ -1792,7 +1857,7 @@ const_unop (enum tree_code code, tree type, tree arg0)\n    indicates which particular sizetype to create.  */\n \n tree\n-size_int_kind (HOST_WIDE_INT number, enum size_type_kind kind)\n+size_int_kind (poly_int64 number, enum size_type_kind kind)\n {\n   return build_int_cst (sizetype_tab[(int) kind], number);\n }\n@@ -1813,8 +1878,8 @@ size_binop_loc (location_t loc, enum tree_code code, tree arg0, tree arg1)\n   gcc_assert (int_binop_types_match_p (code, TREE_TYPE (arg0),\n                                        TREE_TYPE (arg1)));\n \n-  /* Handle the special case of two integer constants faster.  */\n-  if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n+  /* Handle the special case of two poly_int constants faster.  */\n+  if (poly_int_tree_p (arg0) && poly_int_tree_p (arg1))\n     {\n       /* And some specific cases even faster than that.  */\n       if (code == PLUS_EXPR)\n@@ -1838,7 +1903,9 @@ size_binop_loc (location_t loc, enum tree_code code, tree arg0, tree arg1)\n       /* Handle general case of two integer constants.  For sizetype\n          constant calculations we always want to know about overflow,\n \t even in the unsigned case.  */\n-      return int_const_binop_1 (code, arg0, arg1, -1);\n+      tree res = int_const_binop_1 (code, arg0, arg1, -1);\n+      if (res != NULL_TREE)\n+\treturn res;\n     }\n \n   return fold_build2_loc (loc, code, type, arg0, arg1);\n@@ -2162,9 +2229,20 @@ fold_convert_const_fixed_from_real (tree type, const_tree arg1)\n static tree\n fold_convert_const (enum tree_code code, tree type, tree arg1)\n {\n-  if (TREE_TYPE (arg1) == type)\n+  tree arg_type = TREE_TYPE (arg1);\n+  if (arg_type == type)\n     return arg1;\n \n+  /* We can't widen types, since the runtime value could overflow the\n+     original type before being extended to the new type.  */\n+  if (POLY_INT_CST_P (arg1)\n+      && (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type))\n+      && TYPE_PRECISION (type) <= TYPE_PRECISION (arg_type))\n+    return build_poly_int_cst (type,\n+\t\t\t       poly_wide_int::from (poly_int_cst_value (arg1),\n+\t\t\t\t\t\t    TYPE_PRECISION (type),\n+\t\t\t\t\t\t    TYPE_SIGN (arg_type)));\n+\n   if (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type)\n       || TREE_CODE (type) == OFFSET_TYPE)\n     {\n@@ -12562,6 +12640,10 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n       /* fall through */\n \n     default:\n+      if (POLY_INT_CST_P (top) && poly_int_tree_p (bottom))\n+\treturn multiple_p (wi::to_poly_widest (top),\n+\t\t\t   wi::to_poly_widest (bottom));\n+\n       return 0;\n     }\n }\n@@ -13624,16 +13706,6 @@ fold_negate_const (tree arg0, tree type)\n \n   switch (TREE_CODE (arg0))\n     {\n-    case INTEGER_CST:\n-      {\n-\tbool overflow;\n-\twide_int val = wi::neg (wi::to_wide (arg0), &overflow);\n-\tt = force_fit_type (type, val, 1,\n-\t\t\t    (overflow && ! TYPE_UNSIGNED (type))\n-\t\t\t    || TREE_OVERFLOW (arg0));\n-\tbreak;\n-      }\n-\n     case REAL_CST:\n       t = build_real (type, real_value_negate (&TREE_REAL_CST (arg0)));\n       break;\n@@ -13652,6 +13724,16 @@ fold_negate_const (tree arg0, tree type)\n       }\n \n     default:\n+      if (poly_int_tree_p (arg0))\n+\t{\n+\t  bool overflow;\n+\t  poly_wide_int res = wi::neg (wi::to_poly_wide (arg0), &overflow);\n+\t  t = force_fit_type (type, res, 1,\n+\t\t\t      (overflow && ! TYPE_UNSIGNED (type))\n+\t\t\t      || TREE_OVERFLOW (arg0));\n+\t  break;\n+\t}\n+\n       gcc_unreachable ();\n     }\n "}, {"sha": "73a8764d7ce765f6900e298bc216f7c0b1b72e93", "filename": "gcc/fold-const.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -115,7 +115,7 @@ extern tree build_simple_mem_ref_loc (location_t, tree);\n #define build_simple_mem_ref(T)\\\n \tbuild_simple_mem_ref_loc (UNKNOWN_LOCATION, T)\n extern offset_int mem_ref_offset (const_tree);\n-extern tree build_invariant_address (tree, tree, HOST_WIDE_INT);\n+extern tree build_invariant_address (tree, tree, poly_int64);\n extern tree constant_boolean_node (bool, tree);\n extern tree div_if_zero_remainder (const_tree, const_tree);\n \n@@ -152,7 +152,7 @@ extern bool may_negate_without_overflow_p (const_tree);\n extern tree round_up_loc (location_t, tree, unsigned int);\n #define round_down(T,N) round_down_loc (UNKNOWN_LOCATION, T, N)\n extern tree round_down_loc (location_t, tree, int);\n-extern tree size_int_kind (HOST_WIDE_INT, enum size_type_kind);\n+extern tree size_int_kind (poly_int64, enum size_type_kind);\n #define size_binop(CODE,T1,T2)\\\n    size_binop_loc (UNKNOWN_LOCATION, CODE, T1, T2)\n extern tree size_binop_loc (location_t, enum tree_code, tree, tree);"}, {"sha": "05d99894bf2414c604637b8f4c0955222eb38460", "filename": "gcc/gimple-expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -130,6 +130,7 @@ is_gimple_constant (const_tree t)\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:\n+    case POLY_INT_CST:\n     case REAL_CST:\n     case FIXED_CST:\n     case COMPLEX_CST:"}, {"sha": "45ddfc4d76374c08e46bffc81088c7aa28b96ddf", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1258,7 +1258,7 @@ slsr_process_mul (gimple *gs, tree rhs1, tree rhs2, bool speed)\n       c2 = create_mul_ssa_cand (gs, rhs2, rhs1, speed);\n       c->next_interp = c2->cand_num;\n     }\n-  else\n+  else if (TREE_CODE (rhs2) == INTEGER_CST)\n     {\n       /* Record an interpretation for the multiply-immediate.  */\n       c = create_mul_imm_cand (gs, rhs1, rhs2, speed);\n@@ -1499,7 +1499,7 @@ slsr_process_add (gimple *gs, tree rhs1, tree rhs2, bool speed)\n \t    add_cand_for_stmt (gs, c2);\n \t}\n     }\n-  else\n+  else if (TREE_CODE (rhs2) == INTEGER_CST)\n     {\n       /* Record an interpretation for the add-immediate.  */\n       widest_int index = wi::to_widest (rhs2);"}, {"sha": "9da462569f635a902ff10b23d1b3bfebd7942359", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -3124,7 +3124,7 @@ maybe_with_size_expr (tree *expr_p)\n \n   /* If the size isn't known or is a constant, we have nothing to do.  */\n   size = TYPE_SIZE_UNIT (type);\n-  if (!size || TREE_CODE (size) == INTEGER_CST)\n+  if (!size || poly_int_tree_p (size))\n     return;\n \n   /* Otherwise, make a WITH_SIZE_EXPR.  */"}, {"sha": "ba29bd088e6103d5d0f1fb79a3d2918ecf77ba97", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -752,6 +752,10 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \tDFS_follow_tree_edge (VECTOR_CST_ENCODED_ELT (expr, i));\n     }\n \n+  if (CODE_CONTAINS_STRUCT (code, TS_POLY_INT_CST))\n+    for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+      DFS_follow_tree_edge (POLY_INT_CST_COEFF (expr, i));\n+\n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n     {\n       DFS_follow_tree_edge (TREE_REALPART (expr));\n@@ -1202,6 +1206,10 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n \tvisit (VECTOR_CST_ENCODED_ELT (t, i));\n     }\n \n+  if (CODE_CONTAINS_STRUCT (code, TS_POLY_INT_CST))\n+    for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+      visit (POLY_INT_CST_COEFF (t, i));\n+\n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n     {\n       visit (TREE_REALPART (t));"}, {"sha": "4b698dfa6333a8b1532be71fa68ae634a0b87f49", "filename": "gcc/print-tree.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -799,6 +799,18 @@ print_node (FILE *file, const char *prefix, tree node, int indent,\n \t  }\n \t  break;\n \n+\tcase POLY_INT_CST:\n+\t  {\n+\t    char buf[10];\n+\t    for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\t      {\n+\t\tsnprintf (buf, sizeof (buf), \"elt%u: \", i);\n+\t\tprint_node (file, buf, POLY_INT_CST_COEFF (node, i),\n+\t\t\t    indent + 4);\n+\t      }\n+\t  }\n+\t  break;\n+\n \tcase IDENTIFIER_NODE:\n \t  lang_hooks.print_identifier (file, node, indent);\n \t  break;"}, {"sha": "0056d75153d1a040e085cbcc6d63c374b066f96f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -841,6 +841,28 @@ start_record_layout (tree t)\n   return rli;\n }\n \n+/* Fold sizetype value X to bitsizetype, given that X represents a type\n+   size or offset.  */\n+\n+static tree\n+bits_from_bytes (tree x)\n+{\n+  if (POLY_INT_CST_P (x))\n+    /* The runtime calculation isn't allowed to overflow sizetype;\n+       increasing the runtime values must always increase the size\n+       or offset of the object.  This means that the object imposes\n+       a maximum value on the runtime parameters, but we don't record\n+       what that is.  */\n+    return build_poly_int_cst\n+      (bitsizetype,\n+       poly_wide_int::from (poly_int_cst_value (x),\n+\t\t\t    TYPE_PRECISION (bitsizetype),\n+\t\t\t    TYPE_SIGN (TREE_TYPE (x))));\n+  x = fold_convert (bitsizetype, x);\n+  gcc_checking_assert (x);\n+  return x;\n+}\n+\n /* Return the combined bit position for the byte offset OFFSET and the\n    bit position BITPOS.\n \n@@ -854,8 +876,7 @@ tree\n bit_from_pos (tree offset, tree bitpos)\n {\n   return size_binop (PLUS_EXPR, bitpos,\n-\t\t     size_binop (MULT_EXPR,\n-\t\t\t\t fold_convert (bitsizetype, offset),\n+\t\t     size_binop (MULT_EXPR, bits_from_bytes (offset),\n \t\t\t\t bitsize_unit_node));\n }\n \n@@ -2272,9 +2293,10 @@ layout_type (tree type)\n \t  TYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n \t\t\t\t\t\t   TYPE_SIZE_UNIT (innertype),\n \t\t\t\t\t\t   size_int (nunits));\n-\tTYPE_SIZE (type) = int_const_binop (MULT_EXPR,\n-\t\t\t\t\t    TYPE_SIZE (innertype),\n-\t\t\t\t\t    bitsize_int (nunits));\n+\tTYPE_SIZE (type) = int_const_binop\n+\t  (MULT_EXPR,\n+\t   bits_from_bytes (TYPE_SIZE_UNIT (type)),\n+\t   bitsize_int (BITS_PER_UNIT));\n \n \t/* For vector types, we do not default to the mode's alignment.\n \t   Instead, query a target hook, defaulting to natural alignment.\n@@ -2387,8 +2409,7 @@ layout_type (tree type)\n \t      length = size_zero_node;\n \n \t    TYPE_SIZE (type) = size_binop (MULT_EXPR, element_size,\n-\t\t\t\t\t   fold_convert (bitsizetype,\n-\t\t\t\t\t\t\t length));\n+\t\t\t\t\t   bits_from_bytes (length));\n \n \t    /* If we know the size of the element, calculate the total size\n \t       directly, rather than do some division thing below.  This"}, {"sha": "48fbe52edd8c34efbeee6e44b08bd214ab41556c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -3022,7 +3022,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t  error (\"invalid first operand of MEM_REF\");\n \t  return x;\n \t}\n-      if (TREE_CODE (TREE_OPERAND (t, 1)) != INTEGER_CST\n+      if (!poly_int_tree_p (TREE_OPERAND (t, 1))\n \t  || !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 1))))\n \t{\n \t  error (\"invalid offset operand of MEM_REF\");\n@@ -3447,7 +3447,7 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n \t  debug_generic_stmt (expr);\n \t  return true;\n \t}\n-      if (TREE_CODE (TREE_OPERAND (expr, 1)) != INTEGER_CST\n+      if (!poly_int_tree_p (TREE_OPERAND (expr, 1))\n \t  || !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 1))))\n \t{\n \t  error (\"invalid offset operand in MEM_REF\");\n@@ -3464,7 +3464,7 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n \t  return true;\n \t}\n       if (!TMR_OFFSET (expr)\n-\t  || TREE_CODE (TMR_OFFSET (expr)) != INTEGER_CST\n+\t  || !poly_int_tree_p (TMR_OFFSET (expr))\n \t  || !POINTER_TYPE_P (TREE_TYPE (TMR_OFFSET (expr))))\n \t{\n \t  error (\"invalid offset operand in TARGET_MEM_REF\");"}, {"sha": "b08d2151f3489345f97a0cc496249759eb712d16", "filename": "gcc/tree-core.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1337,6 +1337,11 @@ struct GTY(()) tree_vector {\n   tree GTY ((length (\"vector_cst_encoded_nelts ((tree) &%h)\"))) elts[1];\n };\n \n+struct GTY(()) tree_poly_int_cst {\n+  struct tree_typed typed;\n+  tree coeffs[NUM_POLY_INT_COEFFS];\n+};\n+\n struct GTY(()) tree_identifier {\n   struct tree_common common;\n   struct ht_identifier id;\n@@ -1863,6 +1868,7 @@ union GTY ((ptr_alias (union lang_tree_node),\n   struct tree_typed GTY ((tag (\"TS_TYPED\"))) typed;\n   struct tree_common GTY ((tag (\"TS_COMMON\"))) common;\n   struct tree_int_cst GTY ((tag (\"TS_INT_CST\"))) int_cst;\n+  struct tree_poly_int_cst GTY ((tag (\"TS_POLY_INT_CST\"))) poly_int_cst;\n   struct tree_real_cst GTY ((tag (\"TS_REAL_CST\"))) real_cst;\n   struct tree_fixed_cst GTY ((tag (\"TS_FIXED_CST\"))) fixed_cst;\n   struct tree_vector GTY ((tag (\"TS_VECTOR\"))) vector;"}, {"sha": "50e11f5765a7de040e4071c644934581361c6fa5", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1235,6 +1235,10 @@ data_ref_compare_tree (tree t1, tree t2)\n       break;\n \n     default:\n+      if (POLY_INT_CST_P (t1))\n+\treturn compare_sizes_for_sort (wi::to_poly_widest (t1),\n+\t\t\t\t       wi::to_poly_widest (t2));\n+\n       tclass = TREE_CODE_CLASS (code);\n \n       /* For decls, compare their UIDs.  */"}, {"sha": "ae0107e78e3b7cdd9cbfdab2da96e32cfffccc30", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1734,6 +1734,18 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \tpp_string (pp, \"(OVF)\");\n       break;\n \n+    case POLY_INT_CST:\n+      pp_string (pp, \"POLY_INT_CST [\");\n+      dump_generic_node (pp, POLY_INT_CST_COEFF (node, 0), spc, flags, false);\n+      for (unsigned int i = 1; i < NUM_POLY_INT_COEFFS; ++i)\n+\t{\n+\t  pp_string (pp, \", \");\n+\t  dump_generic_node (pp, POLY_INT_CST_COEFF (node, i),\n+\t\t\t     spc, flags, false);\n+\t}\n+      pp_string (pp, \"]\");\n+      break;\n+\n     case REAL_CST:\n       /* Code copied from print_node.  */\n       {"}, {"sha": "d1c15d6a7032e0c2a849e4ce97602f2c94d3494d", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -203,7 +203,8 @@ addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n \n   if (addr->offset && !integer_zerop (addr->offset))\n     {\n-      offset_int dc = offset_int::from (wi::to_wide (addr->offset), SIGNED);\n+      poly_offset_int dc\n+\t= poly_offset_int::from (wi::to_poly_wide (addr->offset), SIGNED);\n       off = immed_wide_int_const (dc, pointer_mode);\n     }\n   else"}, {"sha": "d5743c5935ec85354d8bc5ec42ee5e0d2ba62e18", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -1127,6 +1127,8 @@ determine_base_object (tree expr)\n       gcc_unreachable ();\n \n     default:\n+      if (POLY_INT_CST_P (expr))\n+\treturn NULL_TREE;\n       return fold_convert (ptr_type_node, expr);\n     }\n }\n@@ -2165,6 +2167,12 @@ constant_multiple_of (tree top, tree bot, widest_int *mul)\n       return res == 0;\n \n     default:\n+      if (POLY_INT_CST_P (top)\n+\t  && POLY_INT_CST_P (bot)\n+\t  && constant_multiple_p (wi::to_poly_widest (top),\n+\t\t\t\t  wi::to_poly_widest (bot), mul))\n+\treturn true;\n+\n       return false;\n     }\n }\n@@ -2964,7 +2972,8 @@ get_loop_invariant_expr (struct ivopts_data *data, tree inv_expr)\n {\n   STRIP_NOPS (inv_expr);\n \n-  if (TREE_CODE (inv_expr) == INTEGER_CST || TREE_CODE (inv_expr) == SSA_NAME)\n+  if (poly_int_tree_p (inv_expr)\n+      || TREE_CODE (inv_expr) == SSA_NAME)\n     return NULL;\n \n   /* Don't strip constant part away as we used to.  */\n@@ -3061,7 +3070,7 @@ add_candidate_1 (struct ivopts_data *data,\n       cand->incremented_at = incremented_at;\n       data->vcands.safe_push (cand);\n \n-      if (TREE_CODE (step) != INTEGER_CST)\n+      if (!poly_int_tree_p (step))\n \t{\n \t  find_inv_vars (data, &step, &cand->inv_vars);\n \n@@ -3797,7 +3806,7 @@ get_computation_aff_1 (struct loop *loop, gimple *at, struct iv_use *use,\n   if (TYPE_PRECISION (utype) < TYPE_PRECISION (ctype))\n     {\n       if (cand->orig_iv != NULL && CONVERT_EXPR_P (cbase)\n-\t  && (CONVERT_EXPR_P (cstep) || TREE_CODE (cstep) == INTEGER_CST))\n+\t  && (CONVERT_EXPR_P (cstep) || poly_int_tree_p (cstep)))\n \t{\n \t  tree inner_base, inner_step, inner_type;\n \t  inner_base = TREE_OPERAND (cbase, 0);\n@@ -4055,7 +4064,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n \n   if (is_gimple_min_invariant (expr))\n     {\n-      if (TREE_CODE (expr) == INTEGER_CST)\n+      if (poly_int_tree_p (expr))\n \treturn comp_cost (integer_cost [speed], 0);\n \n       if (TREE_CODE (expr) == ADDR_EXPR)"}, {"sha": "a809552fa752da0841c9a4856510046eb9054c79", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -618,6 +618,7 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \tcase VECTOR_CST:\n \tcase COMPLEX_CST:\n \tcase INTEGER_CST:\n+\tcase POLY_INT_CST:\n \tcase REAL_CST:\n \tcase FIXED_CST:\n \tcase CONSTRUCTOR:"}, {"sha": "ea999a7431c7568e54194328c6b10501dcfd75b7", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -658,6 +658,19 @@ lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n }\n \n \n+/* Read all pointer fields in the TS_POLY_INT_CST structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_poly_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t struct data_in *data_in, tree expr)\n+{\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    POLY_INT_CST_COEFF (expr, i) = stream_read_tree (ib, data_in);\n+}\n+\n+\n /* Read all pointer fields in the TS_COMPLEX structure of EXPR from input\n    block IB.  DATA_IN contains tables and descriptors for the\n    file being read.  */\n@@ -1041,6 +1054,9 @@ streamer_read_tree_body (struct lto_input_block *ib, struct data_in *data_in,\n   if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n     lto_input_ts_vector_tree_pointers (ib, data_in, expr);\n \n+  if (CODE_CONTAINS_STRUCT (code, TS_POLY_INT_CST))\n+    lto_input_ts_poly_tree_pointers (ib, data_in, expr);\n+\n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n     lto_input_ts_complex_tree_pointers (ib, data_in, expr);\n "}, {"sha": "30dc78c6b6820d2f055522c4283edb856447ffd2", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -541,6 +541,18 @@ write_ts_vector_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n }\n \n \n+/* Write all pointer fields in the TS_POLY_INT_CST structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+write_ts_poly_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    stream_write_tree (ob, POLY_INT_CST_COEFF (expr, i), ref_p);\n+}\n+\n+\n /* Write all pointer fields in the TS_COMPLEX structure of EXPR to output\n    block OB.  If REF_P is true, write a reference to EXPR's pointer\n    fields.  */\n@@ -882,6 +894,9 @@ streamer_write_tree_body (struct output_block *ob, tree expr, bool ref_p)\n   if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n     write_ts_vector_tree_pointers (ob, expr, ref_p);\n \n+  if (CODE_CONTAINS_STRUCT (code, TS_POLY_INT_CST))\n+    write_ts_poly_tree_pointers (ob, expr, ref_p);\n+\n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n     write_ts_complex_tree_pointers (ob, expr, ref_p);\n "}, {"sha": "fd34cffd742a70967784d4a9c122f39976994e66", "filename": "gcc/tree-streamer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -55,6 +55,7 @@ streamer_check_handled_ts_structures (void)\n   handled_p[TS_TYPED] = true;\n   handled_p[TS_COMMON] = true;\n   handled_p[TS_INT_CST] = true;\n+  handled_p[TS_POLY_INT_CST] = true;\n   handled_p[TS_REAL_CST] = true;\n   handled_p[TS_FIXED_CST] = true;\n   handled_p[TS_VECTOR] = true;"}, {"sha": "78ee673a9d332d75ef5195c0a7fabd872299de89", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -2753,7 +2753,7 @@ dr_group_sort_cmp (const void *dra_, const void *drb_)\n     return cmp;\n \n   /* Then sort after DR_INIT.  In case of identical DRs sort after stmt UID.  */\n-  cmp = tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb));\n+  cmp = data_ref_compare_tree (DR_INIT (dra), DR_INIT (drb));\n   if (cmp == 0)\n     return gimple_uid (DR_STMT (dra)) < gimple_uid (DR_STMT (drb)) ? -1 : 1;\n   return cmp;"}, {"sha": "0adf9600330dcc859fd8936297190d111edaa5b4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -731,7 +731,24 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n       if (TREE_OVERFLOW (val1) || TREE_OVERFLOW (val2))\n \treturn -2;\n \n-      return tree_int_cst_compare (val1, val2);\n+      if (TREE_CODE (val1) == INTEGER_CST\n+\t  && TREE_CODE (val2) == INTEGER_CST)\n+\treturn tree_int_cst_compare (val1, val2);\n+\n+      if (poly_int_tree_p (val1) && poly_int_tree_p (val2))\n+\t{\n+\t  if (known_eq (wi::to_poly_widest (val1),\n+\t\t\twi::to_poly_widest (val2)))\n+\t    return 0;\n+\t  if (known_lt (wi::to_poly_widest (val1),\n+\t\t\twi::to_poly_widest (val2)))\n+\t    return -1;\n+\t  if (known_gt (wi::to_poly_widest (val1),\n+\t\t\twi::to_poly_widest (val2)))\n+\t    return 1;\n+\t}\n+\n+      return -2;\n     }\n   else\n     {"}, {"sha": "93a05496692247a1e2f3ff411f588e37a7323a90", "filename": "gcc/tree.c", "status": "modified", "additions": 233, "deletions": 16, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -204,6 +204,17 @@ struct int_cst_hasher : ggc_cache_ptr_hash<tree_node>\n \n static GTY ((cache)) hash_table<int_cst_hasher> *int_cst_hash_table;\n \n+/* Class and variable for making sure that there is a single POLY_INT_CST\n+   for a given value.  */\n+struct poly_int_cst_hasher : ggc_cache_ptr_hash<tree_node>\n+{\n+  typedef std::pair<tree, const poly_wide_int *> compare_type;\n+  static hashval_t hash (tree t);\n+  static bool equal (tree x, const compare_type &y);\n+};\n+\n+static GTY ((cache)) hash_table<poly_int_cst_hasher> *poly_int_cst_hash_table;\n+\n /* Hash table for optimization flags and target option flags.  Use the same\n    hash table for both sets of options.  Nodes for building the current\n    optimization and target option nodes.  The assumption is most of the time\n@@ -459,6 +470,7 @@ tree_node_structure_for_code (enum tree_code code)\n       /* tcc_constant cases.  */\n     case VOID_CST:\t\treturn TS_TYPED;\n     case INTEGER_CST:\t\treturn TS_INT_CST;\n+    case POLY_INT_CST:\t\treturn TS_POLY_INT_CST;\n     case REAL_CST:\t\treturn TS_REAL_CST;\n     case FIXED_CST:\t\treturn TS_FIXED_CST;\n     case COMPLEX_CST:\t\treturn TS_COMPLEX;\n@@ -516,6 +528,7 @@ initialize_tree_contains_struct (void)\n \n \tcase TS_COMMON:\n \tcase TS_INT_CST:\n+\tcase TS_POLY_INT_CST:\n \tcase TS_REAL_CST:\n \tcase TS_FIXED_CST:\n \tcase TS_VECTOR:\n@@ -649,6 +662,8 @@ init_ttree (void)\n \n   int_cst_hash_table = hash_table<int_cst_hasher>::create_ggc (1024);\n \n+  poly_int_cst_hash_table = hash_table<poly_int_cst_hasher>::create_ggc (64);\n+\n   int_cst_node = make_int_cst (1, 1);\n \n   cl_option_hash_table = hash_table<cl_option_hasher>::create_ggc (64);\n@@ -835,6 +850,7 @@ tree_code_size (enum tree_code code)\n \t{\n \tcase VOID_CST:\t\treturn sizeof (tree_typed);\n \tcase INTEGER_CST:\tgcc_unreachable ();\n+\tcase POLY_INT_CST:\treturn sizeof (tree_poly_int_cst);\n \tcase REAL_CST:\t\treturn sizeof (tree_real_cst);\n \tcase FIXED_CST:\t\treturn sizeof (tree_fixed_cst);\n \tcase COMPLEX_CST:\treturn sizeof (tree_complex);\n@@ -1313,31 +1329,51 @@ build_new_int_cst (tree type, const wide_int &cst)\n   return nt;\n }\n \n-/* Create an INT_CST node with a LOW value sign extended to TYPE.  */\n+/* Return a new POLY_INT_CST with coefficients COEFFS and type TYPE.  */\n+\n+static tree\n+build_new_poly_int_cst (tree type, tree (&coeffs)[NUM_POLY_INT_COEFFS])\n+{\n+  size_t length = sizeof (struct tree_poly_int_cst);\n+  record_node_allocation_statistics (POLY_INT_CST, length);\n+\n+  tree t = ggc_alloc_cleared_tree_node_stat (length PASS_MEM_STAT);\n+\n+  TREE_SET_CODE (t, POLY_INT_CST);\n+  TREE_CONSTANT (t) = 1;\n+  TREE_TYPE (t) = type;\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    POLY_INT_CST_COEFF (t, i) = coeffs[i];\n+  return t;\n+}\n+\n+/* Create a constant tree that contains CST sign-extended to TYPE.  */\n \n tree\n-build_int_cst (tree type, HOST_WIDE_INT low)\n+build_int_cst (tree type, poly_int64 cst)\n {\n   /* Support legacy code.  */\n   if (!type)\n     type = integer_type_node;\n \n-  return wide_int_to_tree (type, wi::shwi (low, TYPE_PRECISION (type)));\n+  return wide_int_to_tree (type, wi::shwi (cst, TYPE_PRECISION (type)));\n }\n \n+/* Create a constant tree that contains CST zero-extended to TYPE.  */\n+\n tree\n-build_int_cstu (tree type, unsigned HOST_WIDE_INT cst)\n+build_int_cstu (tree type, poly_uint64 cst)\n {\n   return wide_int_to_tree (type, wi::uhwi (cst, TYPE_PRECISION (type)));\n }\n \n-/* Create an INT_CST node with a LOW value sign extended to TYPE.  */\n+/* Create a constant tree that contains CST sign-extended to TYPE.  */\n \n tree\n-build_int_cst_type (tree type, HOST_WIDE_INT low)\n+build_int_cst_type (tree type, poly_int64 cst)\n {\n   gcc_assert (type);\n-  return wide_int_to_tree (type, wi::shwi (low, TYPE_PRECISION (type)));\n+  return wide_int_to_tree (type, wi::shwi (cst, TYPE_PRECISION (type)));\n }\n \n /* Constructs tree in type TYPE from with value given by CST.  Signedness\n@@ -1365,7 +1401,7 @@ double_int_to_tree (tree type, double_int cst)\n \n \n tree\n-force_fit_type (tree type, const wide_int_ref &cst,\n+force_fit_type (tree type, const poly_wide_int_ref &cst,\n \t\tint overflowable, bool overflowed)\n {\n   signop sign = TYPE_SIGN (type);\n@@ -1377,8 +1413,21 @@ force_fit_type (tree type, const wide_int_ref &cst,\n \t  || overflowable < 0\n \t  || (overflowable > 0 && sign == SIGNED))\n \t{\n-\t  wide_int tmp = wide_int::from (cst, TYPE_PRECISION (type), sign);\n-\t  tree t = build_new_int_cst (type, tmp);\n+\t  poly_wide_int tmp = poly_wide_int::from (cst, TYPE_PRECISION (type),\n+\t\t\t\t\t\t   sign);\n+\t  tree t;\n+\t  if (tmp.is_constant ())\n+\t    t = build_new_int_cst (type, tmp.coeffs[0]);\n+\t  else\n+\t    {\n+\t      tree coeffs[NUM_POLY_INT_COEFFS];\n+\t      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\t\t{\n+\t\t  coeffs[i] = build_new_int_cst (type, tmp.coeffs[i]);\n+\t\t  TREE_OVERFLOW (coeffs[i]) = 1;\n+\t\t}\n+\t      t = build_new_poly_int_cst (type, coeffs);\n+\t    }\n \t  TREE_OVERFLOW (t) = 1;\n \t  return t;\n \t}\n@@ -1435,8 +1484,8 @@ int_cst_hasher::equal (tree x, tree y)\n    the upper bits and ensures that hashing and value equality based\n    upon the underlying HOST_WIDE_INTs works without masking.  */\n \n-tree\n-wide_int_to_tree (tree type, const wide_int_ref &pcst)\n+static tree\n+wide_int_to_tree_1 (tree type, const wide_int_ref &pcst)\n {\n   tree t;\n   int ix = -1;\n@@ -1583,6 +1632,66 @@ wide_int_to_tree (tree type, const wide_int_ref &pcst)\n   return t;\n }\n \n+hashval_t\n+poly_int_cst_hasher::hash (tree t)\n+{\n+  inchash::hash hstate;\n+\n+  hstate.add_int (TYPE_UID (TREE_TYPE (t)));\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    hstate.add_wide_int (wi::to_wide (POLY_INT_CST_COEFF (t, i)));\n+\n+  return hstate.end ();\n+}\n+\n+bool\n+poly_int_cst_hasher::equal (tree x, const compare_type &y)\n+{\n+  if (TREE_TYPE (x) != y.first)\n+    return false;\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    if (wi::to_wide (POLY_INT_CST_COEFF (x, i)) != y.second->coeffs[i])\n+      return false;\n+  return true;\n+}\n+\n+/* Build a POLY_INT_CST node with type TYPE and with the elements in VALUES.\n+   The elements must also have type TYPE.  */\n+\n+tree\n+build_poly_int_cst (tree type, const poly_wide_int_ref &values)\n+{\n+  unsigned int prec = TYPE_PRECISION (type);\n+  gcc_assert (prec <= values.coeffs[0].get_precision ());\n+  poly_wide_int c = poly_wide_int::from (values, prec, SIGNED);\n+\n+  inchash::hash h;\n+  h.add_int (TYPE_UID (type));\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    h.add_wide_int (c.coeffs[i]);\n+  poly_int_cst_hasher::compare_type comp (type, &c);\n+  tree *slot = poly_int_cst_hash_table->find_slot_with_hash (comp, h.end (),\n+\t\t\t\t\t\t\t     INSERT);\n+  if (*slot == NULL_TREE)\n+    {\n+      tree coeffs[NUM_POLY_INT_COEFFS];\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tcoeffs[i] = wide_int_to_tree_1 (type, c.coeffs[i]);\n+      *slot = build_new_poly_int_cst (type, coeffs);\n+    }\n+  return *slot;\n+}\n+\n+/* Create a constant tree with value VALUE in type TYPE.  */\n+\n+tree\n+wide_int_to_tree (tree type, const poly_wide_int_ref &value)\n+{\n+  if (value.is_constant ())\n+    return wide_int_to_tree_1 (type, value.coeffs[0]);\n+  return build_poly_int_cst (type, value);\n+}\n+\n void\n cache_integer_cst (tree t)\n {\n@@ -2716,6 +2825,55 @@ really_constant_p (const_tree exp)\n     exp = TREE_OPERAND (exp, 0);\n   return TREE_CONSTANT (exp);\n }\n+\n+/* Return true if T holds a polynomial pointer difference, storing it in\n+   *VALUE if so.  A true return means that T's precision is no greater\n+   than 64 bits, which is the largest address space we support, so *VALUE\n+   never loses precision.  However, the signedness of the result does\n+   not necessarily match the signedness of T: sometimes an unsigned type\n+   like sizetype is used to encode a value that is actually negative.  */\n+\n+bool\n+ptrdiff_tree_p (const_tree t, poly_int64_pod *value)\n+{\n+  if (!t)\n+    return false;\n+  if (TREE_CODE (t) == INTEGER_CST)\n+    {\n+      if (!cst_and_fits_in_hwi (t))\n+\treturn false;\n+      *value = int_cst_value (t);\n+      return true;\n+    }\n+  if (POLY_INT_CST_P (t))\n+    {\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tif (!cst_and_fits_in_hwi (POLY_INT_CST_COEFF (t, i)))\n+\t  return false;\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tvalue->coeffs[i] = int_cst_value (POLY_INT_CST_COEFF (t, i));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+poly_int64\n+tree_to_poly_int64 (const_tree t)\n+{\n+  gcc_assert (tree_fits_poly_int64_p (t));\n+  if (POLY_INT_CST_P (t))\n+    return poly_int_cst_value (t).force_shwi ();\n+  return TREE_INT_CST_LOW (t);\n+}\n+\n+poly_uint64\n+tree_to_poly_uint64 (const_tree t)\n+{\n+  gcc_assert (tree_fits_poly_uint64_p (t));\n+  if (POLY_INT_CST_P (t))\n+    return poly_int_cst_value (t).force_uhwi ();\n+  return TREE_INT_CST_LOW (t);\n+}\n \f\n /* Return first list element whose TREE_VALUE is ELEM.\n    Return 0 if ELEM is not in LIST.  */\n@@ -4707,7 +4865,7 @@ mem_ref_offset (const_tree t)\n    offsetted by OFFSET units.  */\n \n tree\n-build_invariant_address (tree type, tree base, HOST_WIDE_INT offset)\n+build_invariant_address (tree type, tree base, poly_int64 offset)\n {\n   tree ref = fold_build2 (MEM_REF, TREE_TYPE (type),\n \t\t\t  build_fold_addr_expr (base),\n@@ -6603,6 +6761,25 @@ tree_fits_shwi_p (const_tree t)\n \t  && wi::fits_shwi_p (wi::to_widest (t)));\n }\n \n+/* Return true if T is an INTEGER_CST or POLY_INT_CST whose numerical\n+   value (extended according to TYPE_UNSIGNED) fits in a poly_int64.  */\n+\n+bool\n+tree_fits_poly_int64_p (const_tree t)\n+{\n+  if (t == NULL_TREE)\n+    return false;\n+  if (POLY_INT_CST_P (t))\n+    {\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; i++)\n+\tif (!wi::fits_shwi_p (wi::to_wide (POLY_INT_CST_COEFF (t, i))))\n+\t  return false;\n+      return true;\n+    }\n+  return (TREE_CODE (t) == INTEGER_CST\n+\t  && wi::fits_shwi_p (wi::to_widest (t)));\n+}\n+\n /* Return true if T is an INTEGER_CST whose numerical value (extended\n    according to TYPE_UNSIGNED) fits in an unsigned HOST_WIDE_INT.  */\n \n@@ -6614,6 +6791,25 @@ tree_fits_uhwi_p (const_tree t)\n \t  && wi::fits_uhwi_p (wi::to_widest (t)));\n }\n \n+/* Return true if T is an INTEGER_CST or POLY_INT_CST whose numerical\n+   value (extended according to TYPE_UNSIGNED) fits in a poly_uint64.  */\n+\n+bool\n+tree_fits_poly_uint64_p (const_tree t)\n+{\n+  if (t == NULL_TREE)\n+    return false;\n+  if (POLY_INT_CST_P (t))\n+    {\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; i++)\n+\tif (!wi::fits_uhwi_p (wi::to_widest (POLY_INT_CST_COEFF (t, i))))\n+\t  return false;\n+      return true;\n+    }\n+  return (TREE_CODE (t) == INTEGER_CST\n+\t  && wi::fits_uhwi_p (wi::to_widest (t)));\n+}\n+\n /* T is an INTEGER_CST whose numerical value (extended according to\n    TYPE_UNSIGNED) fits in a signed HOST_WIDE_INT.  Return that\n    HOST_WIDE_INT.  */\n@@ -6822,6 +7018,12 @@ simple_cst_equal (const_tree t1, const_tree t2)\n       return 0;\n \n     default:\n+      if (POLY_INT_CST_P (t1))\n+\t/* A false return means maybe_ne rather than known_ne.  */\n+\treturn known_eq (poly_widest_int::from (poly_int_cst_value (t1),\n+\t\t\t\t\t\tTYPE_SIGN (TREE_TYPE (t1))),\n+\t\t\t poly_widest_int::from (poly_int_cst_value (t2),\n+\t\t\t\t\t\tTYPE_SIGN (TREE_TYPE (t2))));\n       break;\n     }\n \n@@ -6881,6 +7083,15 @@ compare_tree_int (const_tree t, unsigned HOST_WIDE_INT u)\n bool\n valid_constant_size_p (const_tree size)\n {\n+  if (POLY_INT_CST_P (size))\n+    {\n+      if (TREE_OVERFLOW (size))\n+\treturn false;\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tif (!valid_constant_size_p (POLY_INT_CST_COEFF (size, i)))\n+\t  return false;\n+      return true;\n+    }\n   if (! tree_fits_uhwi_p (size)\n       || TREE_OVERFLOW (size)\n       || tree_int_cst_sign_bit (size) != 0)\n@@ -7176,6 +7387,12 @@ add_expr (const_tree t, inchash::hash &hstate, unsigned int flags)\n \t}\n       /* FALL THROUGH */\n     default:\n+      if (POLY_INT_CST_P (t))\n+\t{\n+\t  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\t    hstate.add_wide_int (wi::to_wide (POLY_INT_CST_COEFF (t, i)));\n+\t  return;\n+\t}\n       tclass = TREE_CODE_CLASS (code);\n \n       if (tclass == tcc_declaration)\n@@ -7715,7 +7932,7 @@ build_nonshared_array_type (tree elt_type, tree index_type)\n    sizetype.  */\n \n tree\n-build_array_type_nelts (tree elt_type, unsigned HOST_WIDE_INT nelts)\n+build_array_type_nelts (tree elt_type, poly_uint64 nelts)\n {\n   return build_array_type (elt_type, build_index_type (size_int (nelts - 1)));\n }\n@@ -12487,8 +12704,8 @@ drop_tree_overflow (tree t)\n   gcc_checking_assert (TREE_OVERFLOW (t));\n \n   /* For tree codes with a sharing machinery re-build the result.  */\n-  if (TREE_CODE (t) == INTEGER_CST)\n-    return wide_int_to_tree (TREE_TYPE (t), wi::to_wide (t));\n+  if (poly_int_tree_p (t))\n+    return wide_int_to_tree (TREE_TYPE (t), wi::to_poly_wide (t));\n \n   /* For VECTOR_CST, remove the overflow bits from the encoded elements\n      and canonicalize the result.  */"}, {"sha": "a4a7f1a995c7a6e464768c22c599f2239f678d57", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -291,6 +291,9 @@ DEFTREECODE (VOID_CST, \"void_cst\", tcc_constant, 0)\n    some circumstances.  */\n DEFTREECODE (INTEGER_CST, \"integer_cst\", tcc_constant, 0)\n \n+/* Contents are given by POLY_INT_CST_COEFF.  */\n+DEFTREECODE (POLY_INT_CST, \"poly_int_cst\", tcc_constant, 0)\n+\n /* Contents are in TREE_REAL_CST field.  */\n DEFTREECODE (REAL_CST, \"real_cst\", tcc_constant, 0)\n "}, {"sha": "a7b8c2f400c9d7badc27b090e211b8dfd7fbae1b", "filename": "gcc/tree.h", "status": "modified", "additions": 225, "deletions": 17, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -991,6 +991,15 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define TREE_INT_CST_LOW(NODE) \\\n   ((unsigned HOST_WIDE_INT) TREE_INT_CST_ELT (NODE, 0))\n \n+/* Return true if NODE is a POLY_INT_CST.  This is only ever true on\n+   targets with variable-sized modes.  */\n+#define POLY_INT_CST_P(NODE) \\\n+  (NUM_POLY_INT_COEFFS > 1 && TREE_CODE (NODE) == POLY_INT_CST)\n+\n+/* In a POLY_INT_CST node.  */\n+#define POLY_INT_CST_COEFF(NODE, I) \\\n+  (POLY_INT_CST_CHECK (NODE)->poly_int_cst.coeffs[I])\n+\n #define TREE_REAL_CST_PTR(NODE) (REAL_CST_CHECK (NODE)->real_cst.real_cst_ptr)\n #define TREE_REAL_CST(NODE) (*TREE_REAL_CST_PTR (NODE))\n \n@@ -4040,15 +4049,15 @@ build5_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n \n extern tree double_int_to_tree (tree, double_int);\n \n-extern tree wide_int_to_tree (tree type, const wide_int_ref &cst);\n-extern tree force_fit_type (tree, const wide_int_ref &, int, bool);\n+extern tree wide_int_to_tree (tree type, const poly_wide_int_ref &cst);\n+extern tree force_fit_type (tree, const poly_wide_int_ref &, int, bool);\n \n /* Create an INT_CST node with a CST value zero extended.  */\n \n /* static inline */\n-extern tree build_int_cst (tree, HOST_WIDE_INT);\n-extern tree build_int_cstu (tree type, unsigned HOST_WIDE_INT cst);\n-extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n+extern tree build_int_cst (tree, poly_int64);\n+extern tree build_int_cstu (tree type, poly_uint64);\n+extern tree build_int_cst_type (tree, poly_int64);\n extern tree make_vector (unsigned, unsigned CXX_MEM_STAT_INFO);\n extern tree build_vector_from_ctor (tree, vec<constructor_elt, va_gc> *);\n extern tree build_vector_from_val (tree, tree);\n@@ -4068,6 +4077,7 @@ extern tree build_minus_one_cst (tree);\n extern tree build_all_ones_cst (tree);\n extern tree build_zero_cst (tree);\n extern tree build_string (int, const char *);\n+extern tree build_poly_int_cst (tree, const poly_wide_int_ref &);\n extern tree build_tree_list (tree, tree CXX_MEM_STAT_INFO);\n extern tree build_tree_list_vec (const vec<tree, va_gc> * CXX_MEM_STAT_INFO);\n extern tree build_decl (location_t, enum tree_code,\n@@ -4117,7 +4127,7 @@ extern tree build_opaque_vector_type (tree innertype, int nunits);\n extern tree build_index_type (tree);\n extern tree build_array_type (tree, tree, bool = false);\n extern tree build_nonshared_array_type (tree, tree);\n-extern tree build_array_type_nelts (tree, unsigned HOST_WIDE_INT);\n+extern tree build_array_type_nelts (tree, poly_uint64);\n extern tree build_function_type (tree, tree);\n extern tree build_function_type_list (tree, ...);\n extern tree build_varargs_function_type_list (tree, ...);\n@@ -4141,12 +4151,14 @@ extern tree chain_index (int, tree);\n \n extern int tree_int_cst_equal (const_tree, const_tree);\n \n-extern bool tree_fits_shwi_p (const_tree)\n-  ATTRIBUTE_PURE;\n-extern bool tree_fits_uhwi_p (const_tree)\n-  ATTRIBUTE_PURE;\n+extern bool tree_fits_shwi_p (const_tree) ATTRIBUTE_PURE;\n+extern bool tree_fits_poly_int64_p (const_tree) ATTRIBUTE_PURE;\n+extern bool tree_fits_uhwi_p (const_tree) ATTRIBUTE_PURE;\n+extern bool tree_fits_poly_uint64_p (const_tree) ATTRIBUTE_PURE;\n extern HOST_WIDE_INT tree_to_shwi (const_tree);\n+extern poly_int64 tree_to_poly_int64 (const_tree);\n extern unsigned HOST_WIDE_INT tree_to_uhwi (const_tree);\n+extern poly_uint64 tree_to_poly_uint64 (const_tree);\n #if !defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 4003)\n extern inline __attribute__ ((__gnu_inline__)) HOST_WIDE_INT\n tree_to_shwi (const_tree t)\n@@ -4161,6 +4173,21 @@ tree_to_uhwi (const_tree t)\n   gcc_assert (tree_fits_uhwi_p (t));\n   return TREE_INT_CST_LOW (t);\n }\n+#if NUM_POLY_INT_COEFFS == 1\n+extern inline __attribute__ ((__gnu_inline__)) poly_int64\n+tree_to_poly_int64 (const_tree t)\n+{\n+  gcc_assert (tree_fits_poly_int64_p (t));\n+  return TREE_INT_CST_LOW (t);\n+}\n+\n+extern inline __attribute__ ((__gnu_inline__)) poly_uint64\n+tree_to_poly_uint64 (const_tree t)\n+{\n+  gcc_assert (tree_fits_poly_uint64_p (t));\n+  return TREE_INT_CST_LOW (t);\n+}\n+#endif\n #endif\n extern int tree_int_cst_sgn (const_tree);\n extern int tree_int_cst_sign_bit (const_tree);\n@@ -4169,6 +4196,33 @@ extern tree strip_array_types (tree);\n extern tree excess_precision_type (tree);\n extern bool valid_constant_size_p (const_tree);\n \n+/* Return true if T holds a value that can be represented as a poly_int64\n+   without loss of precision.  Store the value in *VALUE if so.  */\n+\n+inline bool\n+poly_int_tree_p (const_tree t, poly_int64_pod *value)\n+{\n+  if (tree_fits_poly_int64_p (t))\n+    {\n+      *value = tree_to_poly_int64 (t);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if T holds a value that can be represented as a poly_uint64\n+   without loss of precision.  Store the value in *VALUE if so.  */\n+\n+inline bool\n+poly_int_tree_p (const_tree t, poly_uint64_pod *value)\n+{\n+  if (tree_fits_poly_uint64_p (t))\n+    {\n+      *value = tree_to_poly_uint64 (t);\n+      return true;\n+    }\n+  return false;\n+}\n \n /* From expmed.c.  Since rtl.h is included after tree.h, we can't\n    put the prototype here.  Rtl.h does declare the prototype if\n@@ -4722,8 +4776,17 @@ complete_or_array_type_p (const_tree type)\n \t     && COMPLETE_TYPE_P (TREE_TYPE (type)));\n }\n \n+/* Return true if the value of T could be represented as a poly_widest_int.  */\n+\n+inline bool\n+poly_int_tree_p (const_tree t)\n+{\n+  return (TREE_CODE (t) == INTEGER_CST || POLY_INT_CST_P (t));\n+}\n+\n extern tree strip_float_extensions (tree);\n extern int really_constant_p (const_tree);\n+extern bool ptrdiff_tree_p (const_tree, poly_int64_pod *);\n extern bool decl_address_invariant_p (const_tree);\n extern bool decl_address_ip_invariant_p (const_tree);\n extern bool int_fits_type_p (const_tree, const_tree);\n@@ -5159,18 +5222,43 @@ extern bool anon_aggrname_p (const_tree);\n /* The tree and const_tree overload templates.   */\n namespace wi\n {\n+  class unextended_tree\n+  {\n+  private:\n+    const_tree m_t;\n+\n+  public:\n+    unextended_tree () {}\n+    unextended_tree (const_tree t) : m_t (t) {}\n+\n+    unsigned int get_precision () const;\n+    const HOST_WIDE_INT *get_val () const;\n+    unsigned int get_len () const;\n+    const_tree get_tree () const { return m_t; }\n+  };\n+\n+  template <>\n+  struct int_traits <unextended_tree>\n+  {\n+    static const enum precision_type precision_type = VAR_PRECISION;\n+    static const bool host_dependent_precision = false;\n+    static const bool is_sign_extended = false;\n+  };\n+\n   template <int N>\n   class extended_tree\n   {\n   private:\n     const_tree m_t;\n \n   public:\n+    extended_tree () {}\n     extended_tree (const_tree);\n \n     unsigned int get_precision () const;\n     const HOST_WIDE_INT *get_val () const;\n     unsigned int get_len () const;\n+    const_tree get_tree () const { return m_t; }\n   };\n \n   template <int N>\n@@ -5182,17 +5270,46 @@ namespace wi\n     static const unsigned int precision = N;\n   };\n \n-  typedef const generic_wide_int <extended_tree <WIDE_INT_MAX_PRECISION> >\n-    tree_to_widest_ref;\n-  typedef const generic_wide_int <extended_tree <ADDR_MAX_PRECISION> >\n-    tree_to_offset_ref;\n+  typedef extended_tree <WIDE_INT_MAX_PRECISION> widest_extended_tree;\n+  typedef extended_tree <ADDR_MAX_PRECISION> offset_extended_tree;\n+\n+  typedef const generic_wide_int <widest_extended_tree> tree_to_widest_ref;\n+  typedef const generic_wide_int <offset_extended_tree> tree_to_offset_ref;\n   typedef const generic_wide_int<wide_int_ref_storage<false, false> >\n     tree_to_wide_ref;\n \n   tree_to_widest_ref to_widest (const_tree);\n   tree_to_offset_ref to_offset (const_tree);\n   tree_to_wide_ref to_wide (const_tree);\n   wide_int to_wide (const_tree, unsigned int);\n+\n+  typedef const poly_int <NUM_POLY_INT_COEFFS,\n+\t\t\t  generic_wide_int <widest_extended_tree> >\n+    tree_to_poly_widest_ref;\n+  typedef const poly_int <NUM_POLY_INT_COEFFS,\n+\t\t\t  generic_wide_int <offset_extended_tree> >\n+    tree_to_poly_offset_ref;\n+  typedef const poly_int <NUM_POLY_INT_COEFFS,\n+\t\t\t  generic_wide_int <unextended_tree> >\n+    tree_to_poly_wide_ref;\n+\n+  tree_to_poly_widest_ref to_poly_widest (const_tree);\n+  tree_to_poly_offset_ref to_poly_offset (const_tree);\n+  tree_to_poly_wide_ref to_poly_wide (const_tree);\n+\n+  template <int N>\n+  struct ints_for <generic_wide_int <extended_tree <N> >, CONST_PRECISION>\n+  {\n+    typedef generic_wide_int <extended_tree <N> > extended;\n+    static extended zero (const extended &);\n+  };\n+\n+  template <>\n+  struct ints_for <generic_wide_int <unextended_tree>, VAR_PRECISION>\n+  {\n+    typedef generic_wide_int <unextended_tree> unextended;\n+    static unextended zero (const unextended &);\n+  };\n }\n \n /* Refer to INTEGER_CST T as though it were a widest_int.\n@@ -5337,6 +5454,95 @@ wi::extended_tree <N>::get_len () const\n     gcc_unreachable ();\n }\n \n+inline unsigned int\n+wi::unextended_tree::get_precision () const\n+{\n+  return TYPE_PRECISION (TREE_TYPE (m_t));\n+}\n+\n+inline const HOST_WIDE_INT *\n+wi::unextended_tree::get_val () const\n+{\n+  return &TREE_INT_CST_ELT (m_t, 0);\n+}\n+\n+inline unsigned int\n+wi::unextended_tree::get_len () const\n+{\n+  return TREE_INT_CST_NUNITS (m_t);\n+}\n+\n+/* Return the value of a POLY_INT_CST in its native precision.  */\n+\n+inline wi::tree_to_poly_wide_ref\n+poly_int_cst_value (const_tree x)\n+{\n+  poly_int <NUM_POLY_INT_COEFFS, generic_wide_int <wi::unextended_tree> > res;\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    res.coeffs[i] = POLY_INT_CST_COEFF (x, i);\n+  return res;\n+}\n+\n+/* Access INTEGER_CST or POLY_INT_CST tree T as if it were a\n+   poly_widest_int.  See wi::to_widest for more details.  */\n+\n+inline wi::tree_to_poly_widest_ref\n+wi::to_poly_widest (const_tree t)\n+{\n+  if (POLY_INT_CST_P (t))\n+    {\n+      poly_int <NUM_POLY_INT_COEFFS,\n+\t\tgeneric_wide_int <widest_extended_tree> > res;\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tres.coeffs[i] = POLY_INT_CST_COEFF (t, i);\n+      return res;\n+    }\n+  return t;\n+}\n+\n+/* Access INTEGER_CST or POLY_INT_CST tree T as if it were a\n+   poly_offset_int.  See wi::to_offset for more details.  */\n+\n+inline wi::tree_to_poly_offset_ref\n+wi::to_poly_offset (const_tree t)\n+{\n+  if (POLY_INT_CST_P (t))\n+    {\n+      poly_int <NUM_POLY_INT_COEFFS,\n+\t\tgeneric_wide_int <offset_extended_tree> > res;\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tres.coeffs[i] = POLY_INT_CST_COEFF (t, i);\n+      return res;\n+    }\n+  return t;\n+}\n+\n+/* Access INTEGER_CST or POLY_INT_CST tree T as if it were a\n+   poly_wide_int.  See wi::to_wide for more details.  */\n+\n+inline wi::tree_to_poly_wide_ref\n+wi::to_poly_wide (const_tree t)\n+{\n+  if (POLY_INT_CST_P (t))\n+    return poly_int_cst_value (t);\n+  return t;\n+}\n+\n+template <int N>\n+inline generic_wide_int <wi::extended_tree <N> >\n+wi::ints_for <generic_wide_int <wi::extended_tree <N> >,\n+\t      wi::CONST_PRECISION>::zero (const extended &x)\n+{\n+  return build_zero_cst (TREE_TYPE (x.get_tree ()));\n+}\n+\n+inline generic_wide_int <wi::unextended_tree>\n+wi::ints_for <generic_wide_int <wi::unextended_tree>,\n+\t      wi::VAR_PRECISION>::zero (const unextended &x)\n+{\n+  return build_zero_cst (TREE_TYPE (x.get_tree ()));\n+}\n+\n namespace wi\n {\n   template <typename T>\n@@ -5354,7 +5560,9 @@ template <typename T>\n bool\n wi::fits_to_boolean_p (const T &x, const_tree type)\n {\n-  return eq_p (x, 0) || eq_p (x, TYPE_UNSIGNED (type) ? 1 : -1);\n+  typedef typename poly_int_traits<T>::int_type int_type;\n+  return (known_eq (x, int_type (0))\n+\t  || known_eq (x, int_type (TYPE_UNSIGNED (type) ? 1 : -1)));\n }\n \n template <typename T>\n@@ -5367,9 +5575,9 @@ wi::fits_to_tree_p (const T &x, const_tree type)\n     return fits_to_boolean_p (x, type);\n \n   if (TYPE_UNSIGNED (type))\n-    return eq_p (x, zext (x, TYPE_PRECISION (type)));\n+    return known_eq (x, zext (x, TYPE_PRECISION (type)));\n   else\n-    return eq_p (x, sext (x, TYPE_PRECISION (type)));\n+    return known_eq (x, sext (x, TYPE_PRECISION (type)));\n }\n \n /* Produce the smallest number that is represented in TYPE.  The precision"}, {"sha": "491d2ddb8c2606e58391e382f2c36df346b8103f", "filename": "gcc/treestruct.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36fd64086542ed734aded849304723218fa4d6fd/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=36fd64086542ed734aded849304723218fa4d6fd", "patch": "@@ -34,6 +34,7 @@ DEFTREESTRUCT(TS_BASE, \"base\")\n DEFTREESTRUCT(TS_TYPED, \"typed\")\n DEFTREESTRUCT(TS_COMMON, \"common\")\n DEFTREESTRUCT(TS_INT_CST, \"integer cst\")\n+DEFTREESTRUCT(TS_POLY_INT_CST, \"poly_int_cst\")\n DEFTREESTRUCT(TS_REAL_CST, \"real cst\")\n DEFTREESTRUCT(TS_FIXED_CST, \"fixed cst\")\n DEFTREESTRUCT(TS_VECTOR, \"vector\")"}]}