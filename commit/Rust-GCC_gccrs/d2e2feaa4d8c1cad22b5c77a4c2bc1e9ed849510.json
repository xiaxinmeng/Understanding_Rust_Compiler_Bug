{"sha": "d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJlMmZlYWE0ZDhjMWNhZDIyYjVjNzdhNGMyYmMxZTllZDg0OTUxMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-11-09T09:02:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-11-09T09:02:27Z"}, "message": "[PATCH] Minor refactoring in tree-ssanames.c & freelists verifier\n\n[PATCH] Minor refactoring in tree-ssanames.c & freelists verifier\n\t* tree-into-ssa.c (names_to_release): No longer static.\n\t* tree-into-ssa.h (names_to_release): Declare.\n\t* tree-ssanames.c (verify_ssaname_freelists): New debug function.\n\t(release_free_names_and_compact_live_names): New function extracted\n\tfrom pass_release_ssa_names::execute.\n\t(pass_release_ssa_names::execute): Use it.\n\nCo-Authored-By: Nathan Sidwell <nathan@acm.org>\n\nFrom-SVN: r229995", "tree": {"sha": "103055f9e10c1979941f0838689144f848d49953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/103055f9e10c1979941f0838689144f848d49953"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/comments", "author": null, "committer": null, "parents": [{"sha": "cdffe78809311f95847d43190626c10bd6f34a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdffe78809311f95847d43190626c10bd6f34a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdffe78809311f95847d43190626c10bd6f34a46"}], "stats": {"total": 216, "additions": 181, "deletions": 35}, "files": [{"sha": "c70ab87805993798873feaf07096e8667df26260", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "patch": "@@ -1,3 +1,12 @@\n+2015-11-09  Jeff Law  <law@redhat.com>\n+\n+\t* tree-into-ssa.c (names_to_release): No longer static.\n+\t* tree-into-ssa.h (names_to_release): Declare.\n+\t* tree-ssanames.c (verify_ssaname_freelists): New debug function.\n+\t(release_free_names_and_compact_live_names): New function extracted\n+\tfrom pass_release_ssa_names::execute.\n+\t(pass_release_ssa_names::execute): Use it.\n+\n 2015-11-09  Alan Modra  <amodra@gmail.com>\n \n \t* gensupport.c (add_mnemonic_string): Make len param a size_t.\n@@ -11,7 +20,7 @@\n \t* gcc/bb-reorder.c (reorder_basic_blocks_simple): Treat a conditional\n \tbranch with only one successor just like unconditional branches.\n \n-2015-11-08  Jeff Law  <jeff@redhat.com>\n+2015-11-08  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-threadupdate.c (register_jump_thraed): Assert that a\n \tnon-FSM path has no edges marked with EDGE_DFS_BACK.\n@@ -369,7 +378,7 @@\n \tthe dominance info; free it if we can't.\n \t(pass_call_cdce::execute): Don't free the dominance info here.\n \n-2015-11-06  Jeff Law <jeff@redhat.com>\n+2015-11-06  Jeff Law <law@redhat.com>\n \n \t* tree-ssa-threadedge.c (dummy_simplify): Remove.\n \t(thread_around_empty_blocks): Remove backedge_seen_p argument.\n@@ -402,7 +411,7 @@\n \t(build_scop_scattering): Call build_pbb_minimal_scattering_polyhedrons.\n \t(build_poly_scop): Call build_scop_minimal_scattering.\n \n-2015-11-06  Jeff Law <jeff@redhat.com>\n+2015-11-06  Jeff Law <law@redhat.com>\n \n \t* cfg-flags.def (IGNORE): New edge flag.\n \t* tree-vrp.c (identify_jump_threads): Mark and clear edges\n@@ -1174,7 +1183,7 @@\n \t* tree-ssa.c (gimple_uses_undefined_value_p): New.\n \t* tree-ssa.h (gimple_uses_undefined_value_p): Declare.\n \n-2015-11-02  Jeff Law <jeff@redhat.com>\n+2015-11-02  Jeff Law <law@redhat.com>\n \n \t* tree-ssa-threadupdate.c (valid_jump_thread_path): Also detect\n \tcases where the loop latch edge is in the middle of an FSM path.\n@@ -1238,7 +1247,7 @@\n \tPR middle-end/68166\n \t* fold-const.c: Include \"md5.h\".\n \n-2015-11-01  Jeff Law <jeff@redhat.com>\n+2015-11-01  Jeff Law <law@redhat.com>\n \n \t* vmsdbgout.c: Revert unused header file reduction patch.\n \n@@ -1287,7 +1296,7 @@\n \n \t* tree-ssa-structalias.c (ipa_pta_execute): Use make_copy_constraint.\n \n-2015-10-30  Jeff Law <jeff@redhat.com>\n+2015-10-30  Jeff Law <law@redhat.com>\n \t    Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.h (HARD_REGNO_NREGS): Avoid warning on unused"}, {"sha": "3086f8247cbda4939e75ba7ed9417b5edcc63b38", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "patch": "@@ -94,7 +94,7 @@ static sbitmap interesting_blocks;\n /* Set of SSA names that have been marked to be released after they\n    were registered in the replacement table.  They will be finally\n    released after we finish updating the SSA web.  */\n-static bitmap names_to_release;\n+bitmap names_to_release;\n \n /* vec of vec of PHIs to rewrite in a basic block.  Element I corresponds\n    the to basic block with index I.  Allocated once per compilation, *not*"}, {"sha": "aed1e9588fdf099ff597f6d32bac403a812b9b18", "filename": "gcc/tree-into-ssa.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2Ftree-into-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2Ftree-into-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.h?ref=d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "patch": "@@ -48,5 +48,6 @@ extern void dump_names_replaced_by (FILE *, tree);\n extern void debug_names_replaced_by (tree);\n extern void dump_update_ssa (FILE *);\n extern void debug_update_ssa (void);\n+extern bitmap names_to_release;\n \n #endif /* GCC_TREE_INTO_SSA_H */"}, {"sha": "096b75b10e0b18948d2d8986690cb2d1efed26d0", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 164, "deletions": 28, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=d2e2feaa4d8c1cad22b5c77a4c2bc1e9ed849510", "patch": "@@ -114,6 +114,133 @@ ssanames_print_statistics (void)\n   fprintf (stderr, \"SSA_NAME nodes reused: %u\\n\", ssa_name_nodes_reused);\n }\n \n+/* Verify the state of the SSA_NAME lists.\n+\n+   There must be no duplicates on the free list.\n+   Every name on the free list must be marked as on the free list.\n+   Any name on the free list must not appear in the IL.\n+   No names can be leaked.  */\n+\n+DEBUG_FUNCTION void\n+verify_ssaname_freelists (struct function *fun)\n+{\n+  /* Do nothing if we are in RTL format.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      if (bb->flags & BB_RTL)\n+\treturn;\n+    }\n+\n+  bitmap names_in_il = BITMAP_ALLOC (NULL);\n+\n+  /* Walk the entire IL noting every SSA_NAME we see.  */\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      tree t;\n+      /* First note the result and arguments of PHI nodes.  */\n+      for (gphi_iterator gsi = gsi_start_phis (bb);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  t = gimple_phi_result (phi);\n+\t  bitmap_set_bit (names_in_il, SSA_NAME_VERSION (t));\n+\n+\t  for (unsigned int i = 0; i < gimple_phi_num_args (phi); i++)\n+\t    {\n+\t      t = gimple_phi_arg_def (phi, i);\n+\t      if (TREE_CODE (t) == SSA_NAME)\n+\t\tbitmap_set_bit (names_in_il, SSA_NAME_VERSION (t));\n+\t    }\n+\t}\n+\n+      /* Then note the operands of each statement.  */\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  ssa_op_iter iter;\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  FOR_EACH_SSA_TREE_OPERAND (t, stmt, iter, SSA_OP_ALL_OPERANDS)\n+\t    if (TREE_CODE (t) == SSA_NAME)\n+\t      bitmap_set_bit (names_in_il, SSA_NAME_VERSION (t));\n+\t}\n+    }\n+\n+  /* Now walk the free list noting what we find there and verifying\n+     there are no duplicates.  */\n+  bitmap names_in_freelists = BITMAP_ALLOC (NULL);\n+  if (FREE_SSANAMES (fun))\n+    {\n+      for (unsigned int i = 0; i < FREE_SSANAMES (fun)->length (); i++)\n+\t{\n+\t  tree t = (*FREE_SSANAMES (fun))[i];\n+\n+\t  /* Verify that the name is marked as being in the free list.  */\n+\t  gcc_assert (SSA_NAME_IN_FREE_LIST (t));\n+\n+\t  /* Verify the name has not already appeared in the free list and\n+\t     note it in the list of names found in the free list.  */\n+\t  gcc_assert (!bitmap_bit_p (names_in_freelists, SSA_NAME_VERSION (t)));\n+\t  bitmap_set_bit (names_in_freelists, SSA_NAME_VERSION (t));\n+\t}\n+    }\n+\n+  /* Similarly for the names in the pending free list.  */\n+  if (FREE_SSANAMES_QUEUE (fun))\n+    {\n+      for (unsigned int i = 0; i < FREE_SSANAMES_QUEUE (fun)->length (); i++)\n+\t{\n+\t  tree t = (*FREE_SSANAMES_QUEUE (fun))[i];\n+\n+\t  /* Verify that the name is marked as being in the free list.  */\n+\t  gcc_assert (SSA_NAME_IN_FREE_LIST (t));\n+\n+\t  /* Verify the name has not already appeared in the free list and\n+\t     note it in the list of names found in the free list.  */\n+\t  gcc_assert (!bitmap_bit_p (names_in_freelists, SSA_NAME_VERSION (t)));\n+\t  bitmap_set_bit (names_in_freelists, SSA_NAME_VERSION (t));\n+\t}\n+    }\n+\n+  /* If any name appears in both the IL and the freelists, then\n+     something horrible has happened.  */\n+  bool intersect_p = bitmap_intersect_p (names_in_il, names_in_freelists);\n+  gcc_assert (!intersect_p);\n+\n+  /* Names can be queued up for release if there is an ssa update\n+     pending.  Pretend we saw them in the IL.  */\n+  if (names_to_release)\n+    bitmap_ior_into (names_in_il, names_to_release);\n+\n+  /* Function splitting can \"lose\" SSA_NAMEs in an effort to ensure that\n+     debug/non-debug compilations have the same SSA_NAMEs.  So for each\n+     lost SSA_NAME, see if it's likely one from that wart.  These will always\n+     be marked as default definitions.  So we loosely assume that anything\n+     marked as a default definition isn't leaked by pretening they are\n+     in the IL.  */\n+  for (unsigned int i = UNUSED_NAME_VERSION + 1; i < num_ssa_names; i++)\n+    if (ssa_name (i) && SSA_NAME_IS_DEFAULT_DEF (ssa_name (i)))\n+      bitmap_set_bit (names_in_il, i);\n+\n+  unsigned int i;\n+  bitmap_iterator bi;\n+  bitmap all_names = BITMAP_ALLOC (NULL);\n+  bitmap_set_range (all_names, UNUSED_NAME_VERSION + 1, num_ssa_names - 1);\n+  bitmap_ior_into (names_in_il, names_in_freelists);\n+\n+  /* Any name not mentioned in the IL and not in the feelists\n+     has been leaked.  */\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP(all_names, names_in_il,\n+\t\t\t\t UNUSED_NAME_VERSION + 1, i, bi)\n+    gcc_assert (!ssa_name (i));\n+\n+  BITMAP_FREE (all_names);\n+  BITMAP_FREE (names_in_freelists);\n+  BITMAP_FREE (names_in_il);\n+}\n+\n /* Move all SSA_NAMEs from FREE_SSA_NAMES_QUEUE to FREE_SSA_NAMES.\n \n    We do not, but should have a mode to verify the state of the SSA_NAMEs\n@@ -604,6 +731,42 @@ replace_ssa_name_symbol (tree ssa_name, tree sym)\n   TREE_TYPE (ssa_name) = TREE_TYPE (sym);\n }\n \n+/* Release the vector of free SSA_NAMEs and compact the the\n+   vector of SSA_NAMEs that are live.  */\n+\n+static void\n+release_free_names_and_compact_live_names (function *fun)\n+{\n+  unsigned i, j;\n+  int n = vec_safe_length (FREE_SSANAMES (fun));\n+\n+  /* Now release the freelist.  */\n+  vec_free (FREE_SSANAMES (fun));\n+\n+  /* And compact the SSA number space.  We make sure to not change the\n+     relative order of SSA versions.  */\n+  for (i = 1, j = 1; i < fun->gimple_df->ssa_names->length (); ++i)\n+    {\n+      tree name = ssa_name (i);\n+      if (name)\n+\t{\n+\t  if (i != j)\n+\t    {\n+\t      SSA_NAME_VERSION (name) = j;\n+\t      (*fun->gimple_df->ssa_names)[j] = name;\n+\t    }\n+\t  j++;\n+\t}\n+    }\n+  fun->gimple_df->ssa_names->truncate (j);\n+\n+  statistics_counter_event (fun, \"SSA names released\", n);\n+  statistics_counter_event (fun, \"SSA name holes removed\", i - j);\n+  if (dump_file)\n+    fprintf (dump_file, \"Released %i names, %.2f%%, removed %i holes\\n\",\n+\t     n, n * 100.0 / num_ssa_names, i - j);\n+}\n+\n /* Return SSA names that are unused to GGC memory and compact the SSA\n    version namespace.  This is used to keep footprint of compiler during\n    interprocedural optimization.  */\n@@ -638,34 +801,7 @@ class pass_release_ssa_names : public gimple_opt_pass\n unsigned int\n pass_release_ssa_names::execute (function *fun)\n {\n-  unsigned i, j;\n-  int n = vec_safe_length (FREE_SSANAMES (fun));\n-\n-  /* Now release the freelist.  */\n-  vec_free (FREE_SSANAMES (fun));\n-\n-  /* And compact the SSA number space.  We make sure to not change the\n-     relative order of SSA versions.  */\n-  for (i = 1, j = 1; i < fun->gimple_df->ssa_names->length (); ++i)\n-    {\n-      tree name = ssa_name (i);\n-      if (name)\n-\t{\n-\t  if (i != j)\n-\t    {\n-\t      SSA_NAME_VERSION (name) = j;\n-\t      (*fun->gimple_df->ssa_names)[j] = name;\n-\t    }\n-\t  j++;\n-\t}\n-    }\n-  fun->gimple_df->ssa_names->truncate (j);\n-\n-  statistics_counter_event (fun, \"SSA names released\", n);\n-  statistics_counter_event (fun, \"SSA name holes removed\", i - j);\n-  if (dump_file)\n-    fprintf (dump_file, \"Released %i names, %.2f%%, removed %i holes\\n\",\n-\t     n, n * 100.0 / num_ssa_names, i - j);\n+  release_free_names_and_compact_live_names (fun);\n   return 0;\n }\n "}]}