{"sha": "49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlhMTljZmQzNDc4M2JkN2QyNjFiYjBjYWE0ZmZjZGE1YWE0NGI5Ng==", "commit": {"author": {"name": "Jim Blandy", "email": "jimb@redhat.com", "date": "2003-05-15T19:02:13Z"}, "committer": {"name": "Jim Blandy", "email": "jimb@gcc.gnu.org", "date": "2003-05-15T19:02:13Z"}, "message": "hex.c (_hex_value): Make this unsigned.\n\nlibiberty/ChangeLog:\n2003-05-14  Jim Blandy  <jimb@redhat.com>\n\n\t* hex.c (_hex_value): Make this unsigned.\n\t(hex_value): Update documentation for new return type.  hex_value\n\tnow expands to an unsigned int expression, to avoid unexpected\n\tsign extension when we store it in a bfd_vma, which is larger than\n\tint on some platforms.\n\t* functions.texi: Regenerated.\n\ninclude/ChangeLog:\n2003-05-14  Jim Blandy  <jimb@redhat.com>\n\n\t* libiberty.h (hex_value): Make the value an unsigned int, to\n\tavoid unexpected sign-extension when cast to unsigned types larger\n\tthan int --- like bfd_vma, on some platforms.\n\t(_hex_value): Update declaration.\n\nFrom-SVN: r66840", "tree": {"sha": "d12d899096b8ea3aba0270edec52389c46f4100e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d12d899096b8ea3aba0270edec52389c46f4100e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/comments", "author": null, "committer": null, "parents": [{"sha": "4b3c2e48c46352fc7b22bbce659422d07dac5604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3c2e48c46352fc7b22bbce659422d07dac5604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b3c2e48c46352fc7b22bbce659422d07dac5604"}], "stats": {"total": 40, "additions": 34, "deletions": 6}, "files": [{"sha": "c7c271b1ca9570e7f24188f69ba7d1adfef77abf", "filename": "include/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "patch": "@@ -1,3 +1,10 @@\n+2003-05-15  Jim Blandy  <jimb@redhat.com>\n+\n+\t* libiberty.h (hex_value): Make the value an unsigned int, to\n+\tavoid unexpected sign-extension when cast to unsigned types larger\n+\tthan int --- like bfd_vma, on some platforms.\n+\t(_hex_value): Update declaration.\n+\n 2003-05-07  Jason Merrill  <jason@redhat.com>\n \n \t* hashtab.h (iterative_hash): Prototype."}, {"sha": "761b2cf060ff5a33f4cfe7229099b85ef55351c9", "filename": "include/libiberty.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "patch": "@@ -254,12 +254,12 @@ extern double physmem_available PARAMS ((void));\n \n #define _hex_array_size 256\n #define _hex_bad\t99\n-extern const char _hex_value[_hex_array_size];\n+extern const unsigned char _hex_value[_hex_array_size];\n extern void hex_init PARAMS ((void));\n #define hex_p(c)\t(hex_value (c) != _hex_bad)\n /* If you change this, note well: Some code relies on side effects in\n    the argument being performed exactly once.  */\n-#define hex_value(c)\t(_hex_value[(unsigned char) (c)])\n+#define hex_value(c)\t((unsigned int) _hex_value[(unsigned char) (c)])\n \n /* Definitions used by the pexecute routine.  */\n "}, {"sha": "d30c591d24720f396f5545e52fbbe258cb93bea6", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "patch": "@@ -1,3 +1,12 @@\n+2003-05-15  Jim Blandy  <jimb@redhat.com>\n+\n+\t* hex.c (_hex_value): Make this unsigned.\n+\t(hex_value): Update documentation for new return type.  hex_value\n+\tnow expands to an unsigned int expression, to avoid unexpected\n+\tsign extension when we store it in a bfd_vma, which is larger than\n+\tint on some platforms.\n+\t* functions.texi: Regenerated.\n+\n 2003-05-07  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* splay-tree.c (splay_tree_predecessor): Fix comment."}, {"sha": "b34c20409e31058caae7b76eb37a194f29546ed2", "filename": "libiberty/functions.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "patch": "@@ -337,13 +337,19 @@ or zero if it is not.  Note that the value you pass will be cast to\n @end deftypefn\n \n @c hex.c:42\n-@deftypefn Extension int hex_value (int @var{c})\n+@deftypefn Extension unsigned int hex_value (int @var{c})\n \n Returns the numeric equivalent of the given character when interpreted\n as a hexidecimal digit.  The result is undefined if you pass an\n invalid hex digit.  Note that the value you pass will be cast to\n @code{unsigned char} within the macro.\n \n+The @code{hex_value} macro returns @code{unsigned int}, rather than\n+signed @code{int}, to make it easier to use in parsing addresses from\n+hex dump files: a signed @code{int} would be sign-extended when\n+converted to a wider unsigned type --- like @code{bfd_vma}, on some\n+systems.\n+\n @end deftypefn\n \n @c index.c:5"}, {"sha": "f425509be75c0d510addeb7f3c9578c30a5800e1", "filename": "libiberty/hex.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/libiberty%2Fhex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a19cfd34783bd7d261bb0caa4ffcda5aa44b96/libiberty%2Fhex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhex.c?ref=49a19cfd34783bd7d261bb0caa4ffcda5aa44b96", "patch": "@@ -39,13 +39,19 @@ or zero if it is not.  Note that the value you pass will be cast to\n \n @end deftypefn\n \n-@deftypefn Extension int hex_value (int @var{c})\n+@deftypefn Extension unsigned int hex_value (int @var{c})\n \n Returns the numeric equivalent of the given character when interpreted\n as a hexidecimal digit.  The result is undefined if you pass an\n invalid hex digit.  Note that the value you pass will be cast to\n @code{unsigned char} within the macro.\n \n+The @code{hex_value} macro returns @code{unsigned int}, rather than\n+signed @code{int}, to make it easier to use in parsing addresses from\n+hex dump files: a signed @code{int} would be sign-extended when\n+converted to a wider unsigned type --- like @code{bfd_vma}, on some\n+systems.\n+\n @end deftypefn\n \n @undocumented _hex_array_size\n@@ -60,7 +66,7 @@ invalid hex digit.  Note that the value you pass will be cast to\n   && 'A' == 0x41 && 'a' == 0x61 && '!' == 0x21 \\\n   && EOF == -1\n \n-const char _hex_value[_hex_array_size] =\n+const unsigned char _hex_value[_hex_array_size] =\n {\n   _hex_bad, _hex_bad, _hex_bad, _hex_bad,   /* NUL SOH STX ETX */\n   _hex_bad, _hex_bad, _hex_bad, _hex_bad,   /* EOT ENQ ACK BEL */\n@@ -139,7 +145,7 @@ const char _hex_value[_hex_array_size] =\n \n #else\n \n-char _hex_value[_hex_array_size];\n+unsigned char _hex_value[_hex_array_size];\n \n #endif /* not ASCII */\n "}]}