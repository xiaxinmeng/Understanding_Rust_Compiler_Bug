{"sha": "bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYzZjk1ODE2ZjgxYjliYmM3M2YwMWJiOTU5MWNhYjZmN2RkNTljMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2007-09-25T12:59:32Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2007-09-25T12:59:32Z"}, "message": "bfin.c (expand_prologue_reg_save, [...]): Code to save and restore I/M/B/L regs and ASTAT moved here...\n\n\t* config/bfin/bfin.c (expand_prologue_reg_save,\n\texpand_epilogue_reg_restore): Code to save and restore I/M/B/L regs and\n\tASTAT moved here...\n\t(expand_interrupt_handler_prologue, expand_interrupt_handler_epilogue):\n\t... from here.  New argument ALL; callers changed.\n\t(n_regs_saved_by_prologue): Count ASTAT for plain saveall functions.\n\t(bfin_expand_prologue, bfin_expand_epilogue): Deal with functions that\n\thave the \"saveall\" attribute.\n\nFrom-SVN: r128762", "tree": {"sha": "545f5d3d1adea9facf28db08a70069214f49303d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/545f5d3d1adea9facf28db08a70069214f49303d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3/comments", "author": null, "committer": null, "parents": [{"sha": "1bde00421fc1d93e9a92ffe6cd0c221f4494fd33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bde00421fc1d93e9a92ffe6cd0c221f4494fd33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bde00421fc1d93e9a92ffe6cd0c221f4494fd33"}], "stats": {"total": 140, "additions": 84, "deletions": 56}, "files": [{"sha": "b09860450bb0feca0fb593b87da63fefab596540", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3", "patch": "@@ -1,3 +1,14 @@\n+2007-09-25  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (expand_prologue_reg_save,\n+\texpand_epilogue_reg_restore): Code to save and restore I/M/B/L regs and\n+\tASTAT moved here...\n+\t(expand_interrupt_handler_prologue, expand_interrupt_handler_epilogue):\n+\t... from here.  New argument ALL; callers changed.\n+\t(n_regs_saved_by_prologue): Count ASTAT for plain saveall functions.\n+\t(bfin_expand_prologue, bfin_expand_epilogue): Deal with functions that\n+\thave the \"saveall\" attribute.\n+\n 2007-09-25  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* config/mmix/mmix.h (FUNCTION_INCOMING_ARG_REGNO_P): Don't define"}, {"sha": "c3b59880104da5bfafd8a9fd2ef234d6b31542f7", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 73, "deletions": 56, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=bf3f95816f81b9bbc73f01bb9591cab6f7dd59c3", "patch": "@@ -416,6 +416,8 @@ stack_frame_needed_p (void)\n static void\n expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n {\n+  rtx predec1 = gen_rtx_PRE_DEC (SImode, spreg);\n+  rtx predec = gen_rtx_MEM (SImode, predec1);\n   int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler);\n   int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler);\n   int dregno = REG_R7 + 1 - ndregs;\n@@ -424,7 +426,13 @@ expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n   int i;\n   rtx pat, insn, val;\n \n-  if (total == 0)\n+  if (saveall || is_inthandler)\n+    {\n+      insn = emit_move_insn (predec, gen_rtx_REG (SImode, REG_ASTAT));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  if (total == 0 && !saveall)\n     return;\n \n   val = GEN_INT (-total * 4);\n@@ -458,6 +466,20 @@ expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n     }\n   insn = emit_insn (pat);\n   RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  for (i = REG_P7 + 1; i < REG_CC; i++)\n+    if (saveall \n+\t|| (is_inthandler\n+\t    && (df_regs_ever_live_p (i)\n+\t\t|| (!leaf_function_p () && call_used_regs[i]))))\n+      {\n+\tif (i == REG_A0 || i == REG_A1)\n+\t  insn = emit_move_insn (gen_rtx_MEM (PDImode, predec1),\n+\t\t\t\t gen_rtx_REG (PDImode, i));\n+\telse\n+\t  insn = emit_move_insn (predec, gen_rtx_REG (SImode, i));\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+      }\n }\n \n /* Emit code to restore registers in the epilogue.  SAVEALL is nonzero if we\n@@ -468,12 +490,35 @@ expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n static void\n expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n {\n+  rtx postinc1 = gen_rtx_POST_INC (SImode, spreg);\n+  rtx postinc = gen_rtx_MEM (SImode, postinc1);\n+\n   int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler);\n   int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler);\n   int total = ndregs + npregs;\n   int i, regno;\n   rtx pat, insn;\n \n+  /* A slightly crude technique to stop flow from trying to delete \"dead\"\n+     insns.  */\n+  MEM_VOLATILE_P (postinc) = 1;\n+\n+  for (i = REG_CC - 1; i > REG_P7; i--)\n+    if (saveall\n+\t|| (is_inthandler\n+\t    && (df_regs_ever_live_p (i)\n+\t\t|| (!leaf_function_p () && call_used_regs[i]))))\n+      {\n+\tif (i == REG_A0 || i == REG_A1)\n+\t  {\n+\t    rtx mem = gen_rtx_MEM (PDImode, postinc1);\n+\t    MEM_VOLATILE_P (mem) = 1;\n+\t    emit_move_insn (gen_rtx_REG (PDImode, i), mem);\n+\t  }\n+\telse\n+\t  emit_move_insn (gen_rtx_REG (SImode, i), postinc);\n+      }\n+\n   if (total == 0)\n     return;\n \n@@ -507,6 +552,9 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n \n   insn = emit_insn (pat);\n   RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  if (saveall || is_inthandler)\n+    emit_move_insn (gen_rtx_REG (SImode, REG_ASTAT), postinc);\n }\n \n /* Perform any needed actions needed for a function that is receiving a\n@@ -591,6 +639,7 @@ n_regs_saved_by_prologue (void)\n   int ndregs = all ? 8 : n_dregs_to_save (is_inthandler);\n   int npregs = all ? 6 : n_pregs_to_save (is_inthandler);  \n   int n = ndregs + npregs;\n+  int i;\n \n   if (all || stack_frame_needed_p ())\n     /* We use a LINK instruction in this case.  */\n@@ -603,23 +652,24 @@ n_regs_saved_by_prologue (void)\n \tn++;\n     }\n \n+  if (fkind != SUBROUTINE || all)\n+    /* Increment once for ASTAT.  */\n+    n++;\n+\n   if (fkind != SUBROUTINE)\n     {\n-      int i;\n-\n-      /* Increment once for ASTAT.  */\n-      n++;\n-\n       /* RETE/X/N.  */\n       if (lookup_attribute (\"nesting\", attrs))\n \tn++;\n-\n-      for (i = REG_P7 + 1; i < REG_CC; i++)\n-\tif (all \n-\t    || df_regs_ever_live_p (i)\n-\t    || (!leaf_function_p () && call_used_regs[i]))\n-\t  n += i == REG_A0 || i == REG_A1 ? 2 : 1;\n     }\n+\n+  for (i = REG_P7 + 1; i < REG_CC; i++)\n+    if (all\n+\t|| (fkind != SUBROUTINE\n+\t    && (df_regs_ever_live_p (i)\n+\t\t|| (!leaf_function_p () && call_used_regs[i]))))\n+      n += i == REG_A0 || i == REG_A1 ? 2 : 1;\n+\n   return n;\n }\n \n@@ -882,15 +932,13 @@ do_unlink (rtx spreg, HOST_WIDE_INT frame_size, bool all, int epilogue_p)\n    SPREG contains (reg:SI REG_SP).  */\n \n static void\n-expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n+expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind, bool all)\n {\n-  int i;\n   HOST_WIDE_INT frame_size = get_frame_size ();\n   rtx predec1 = gen_rtx_PRE_DEC (SImode, spreg);\n   rtx predec = gen_rtx_MEM (SImode, predec1);\n   rtx insn;\n   tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n-  bool all = lookup_attribute (\"saveall\", attrs) != NULL_TREE;\n   tree kspisusp = lookup_attribute (\"kspisusp\", attrs);\n \n   if (kspisusp)\n@@ -907,28 +955,12 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  insn = emit_move_insn (predec, gen_rtx_REG (SImode, REG_ASTAT));\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-\n   /* If we're calling other functions, they won't save their call-clobbered\n      registers, so we must save everything here.  */\n   if (!current_function_is_leaf)\n     all = true;\n   expand_prologue_reg_save (spreg, all, true);\n \n-  for (i = REG_P7 + 1; i < REG_CC; i++)\n-    if (all \n-\t|| df_regs_ever_live_p (i)\n-\t|| (!leaf_function_p () && call_used_regs[i]))\n-      {\n-\tif (i == REG_A0 || i == REG_A1)\n-\t  insn = emit_move_insn (gen_rtx_MEM (PDImode, predec1),\n-\t\t\t\t gen_rtx_REG (PDImode, i));\n-\telse\n-\t  insn = emit_move_insn (predec, gen_rtx_REG (SImode, i));\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n-      }\n-\n   if (lookup_attribute (\"nesting\", attrs))\n     {\n       rtx srcreg = gen_rtx_REG (Pmode, (fkind == EXCPT_HANDLER ? REG_RETX\n@@ -961,13 +993,11 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n    SPREG contains (reg:SI REG_SP).  */\n \n static void\n-expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind)\n+expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind, bool all)\n {\n-  int i;\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n   rtx postinc1 = gen_rtx_POST_INC (SImode, spreg);\n   rtx postinc = gen_rtx_MEM (SImode, postinc1);\n-  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n-  bool all = lookup_attribute (\"saveall\", attrs) != NULL_TREE;\n \n   /* A slightly crude technique to stop flow from trying to delete \"dead\"\n      insns.  */\n@@ -988,25 +1018,8 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind)\n   if (!current_function_is_leaf)\n     all = true;\n \n-  for (i = REG_CC - 1; i > REG_P7; i--)\n-    if (all\n-\t|| df_regs_ever_live_p (i)\n-\t|| (!leaf_function_p () && call_used_regs[i]))\n-      {\n-\tif (i == REG_A0 || i == REG_A1)\n-\t  {\n-\t    rtx mem = gen_rtx_MEM (PDImode, postinc1);\n-\t    MEM_VOLATILE_P (mem) = 1;\n-\t    emit_move_insn (gen_rtx_REG (PDImode, i), mem);\n-\t  }\n-\telse\n-\t  emit_move_insn (gen_rtx_REG (SImode, i), postinc);\n-      }\n-\n   expand_epilogue_reg_restore (spreg, all, true);\n \n-  emit_move_insn (gen_rtx_REG (SImode, REG_ASTAT), postinc);\n-\n   /* Deallocate any space we left on the stack in case we needed to save the\n      argument registers.  */\n   if (fkind == EXCPT_HANDLER)\n@@ -1051,10 +1064,12 @@ bfin_expand_prologue (void)\n   rtx spreg = gen_rtx_REG (Pmode, REG_SP);\n   e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n   rtx pic_reg_loaded = NULL_RTX;\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  bool all = lookup_attribute (\"saveall\", attrs) != NULL_TREE;\n \n   if (fkind != SUBROUTINE)\n     {\n-      expand_interrupt_handler_prologue (spreg, fkind);\n+      expand_interrupt_handler_prologue (spreg, fkind, all);\n       return;\n     }\n \n@@ -1104,7 +1119,7 @@ bfin_expand_prologue (void)\n       emit_insn (gen_compare_lt (bfin_cc_rtx, spreg, lim));\n       emit_insn (gen_trapifcc ());\n     }\n-  expand_prologue_reg_save (spreg, 0, false);\n+  expand_prologue_reg_save (spreg, all, false);\n \n   do_link (spreg, frame_size, false);\n \n@@ -1126,16 +1141,18 @@ bfin_expand_epilogue (int need_return, int eh_return, bool sibcall_p)\n   rtx spreg = gen_rtx_REG (Pmode, REG_SP);\n   e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n   int e = sibcall_p ? -1 : 1;\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  bool all = lookup_attribute (\"saveall\", attrs) != NULL_TREE;\n \n   if (fkind != SUBROUTINE)\n     {\n-      expand_interrupt_handler_epilogue (spreg, fkind);\n+      expand_interrupt_handler_epilogue (spreg, fkind, all);\n       return;\n     }\n \n   do_unlink (spreg, get_frame_size (), false, e);\n \n-  expand_epilogue_reg_restore (spreg, false, false);\n+  expand_epilogue_reg_restore (spreg, all, false);\n \n   /* Omit the return insn if this is for a sibcall.  */\n   if (! need_return)"}]}