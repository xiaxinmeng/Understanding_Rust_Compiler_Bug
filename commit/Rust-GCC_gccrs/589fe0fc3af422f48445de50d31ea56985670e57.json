{"sha": "589fe0fc3af422f48445de50d31ea56985670e57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg5ZmUwZmMzYWY0MjJmNDg0NDVkZTUwZDMxZWE1Njk4NTY3MGU1Nw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-27T13:15:13Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-27T13:15:13Z"}, "message": "arm.md (*addsi3_compare0_scratch): New insn.\n\n* arm.md (*addsi3_compare0_scratch): New insn.\n(*movsi_compare0, *cmpsi_insn, *cmpsi_shiftsi): Make sure the\ncompare has mode CC.\n(cmp{si,sf,df,xf} expands): Just provide sufficient information\nto allow the parameters to be matched properly.\n(*cmpsi_negsi): Delete (of dubious validity).\n(*cmpsi_shiftsi_swp): New pattern.\n(*condbranch_reversed): No longer needs to check REVERSIBLE_CC_MODE.\n(mov{si,sf,df}cc, *mov{si,sf,df}{,_hard,_soft}_insn): The mode of the\nIF_THEN_ELSE must be appropriate to the target (not void).\n(*and_scc): Match cc_register, not reversible_cc_register.\n(*ior_compare_compare): Delete.\n(split for ior_compare_compare + condjump): Delete.\n(*impossible_cond_compare): Delete.\n(*condition_compare_ior): Delete.\n(*cond_move): Mode for the IF_THEN_ELSE must be SImode.\n(*and_scc_scc): Delete.\n(split for and_scc_scc + condjump): Delete.\n(*impossible_cond_branch_and): Delete.\n(*cmp_ite0, *cmp_ite1): New patterns.\n(if_compare_not): Should be an anonymous pattern.\n(Peephole for move and compare): Compare mode must be mode CCmode.\n(Split pattern for comparing shifted reg then branch): Delete.\n(*loadqi_compare): Delete, replaced with a split pattern to do\nthe same thing.\n(*cond_move_not): Match cc_register, not reversible_cc_register.\n(load/store multiple peepholes): Rewrite using the above\nfunctions.\n(all patterns taking immediate_operand): If the code later assumes\nthis is a CONST_INT, then match const_int_operand instead.\n\nFrom-SVN: r11352", "tree": {"sha": "f208627193059f7c487399efe0dbad6b358aecc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f208627193059f7c487399efe0dbad6b358aecc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/589fe0fc3af422f48445de50d31ea56985670e57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/589fe0fc3af422f48445de50d31ea56985670e57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/589fe0fc3af422f48445de50d31ea56985670e57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/589fe0fc3af422f48445de50d31ea56985670e57/comments", "author": null, "committer": null, "parents": [{"sha": "84ed5e792bfe27b881eab1593a636d75382f6eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ed5e792bfe27b881eab1593a636d75382f6eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84ed5e792bfe27b881eab1593a636d75382f6eca"}], "stats": {"total": 754, "additions": 235, "deletions": 519}, "files": [{"sha": "4aff77d1b718c7fcdbabb7915b1ac70d07d420f3", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 235, "deletions": 519, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589fe0fc3af422f48445de50d31ea56985670e57/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589fe0fc3af422f48445de50d31ea56985670e57/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=589fe0fc3af422f48445de50d31ea56985670e57", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for Advanced RISC Machines' ARM for GNU compiler\n-;;  Copyright (C) 1991, 1993, 1994, 1995 Free Software Foundation, Inc.\n+;;  Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n ;;  Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n ;;             and Martin Simmons (@harleqn.co.uk).\n ;;  More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n@@ -320,6 +320,18 @@\n    sub%?s\\\\t%0, %1, #%n2\"\n [(set_attr \"conds\" \"set\")])\n \n+(define_insn \"*addsi3_compare0_scratch\"\n+  [(set (reg:CC_NOOV 24)\n+\t(compare:CC_NOOV\n+\t (plus:SI (match_operand:SI 0 \"s_register_operand\" \"r,r\")\n+\t\t  (match_operand:SI 1 \"arm_add_operand\" \"rI,L\"))\n+\t (const_int 0)))]\n+  \"\"\n+  \"@\n+   cmn%?\\\\t%0, %1\n+   cmp%?\\\\t%0, #%n1\"\n+[(set_attr \"conds\" \"set\")])\n+\n (define_insn \"*addsi3_compareneg\"\n   [(set (reg:CC 24)\n \t(compare:CC (match_operand:SI 1 \"s_register_operand\" \"r,r\")\n@@ -351,7 +363,7 @@\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))]\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"!(const_ok_for_arm (INTVAL (operands[2]))\n      || const_ok_for_arm (-INTVAL (operands[2])))\"\n   [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n@@ -2254,8 +2266,8 @@\n ;; result is being tested against zero.\n \n (define_insn \"*movsi_compare0\"\n-  [(set (reg:CC 24) (compare (match_operand:SI 1 \"s_register_operand\" \"0,r\")\n-\t\t\t     (const_int 0)))\n+  [(set (reg:CC 24) (compare:CC (match_operand:SI 1 \"s_register_operand\" \"0,r\")\n+\t\t\t        (const_int 0)))\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r,r\") (match_dup 1))]\n   \"\"\n   \"@\n@@ -2869,11 +2881,11 @@\n \n (define_insn \"*ldmsi_postinc\"\n   [(match_parallel 0 \"load_multiple_operation\"\n-                   [(set (match_operand:SI 1 \"s_register_operand\" \"+r\")\n-                         (plus:SI (match_dup 1)\n-                                  (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-                    (set (match_operand:SI 3 \"s_register_operand\" \"=r\")\n-                         (mem:SI (match_dup 1)))])]\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"+r\")\n+\t  (plus:SI (match_dup 1)\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+     (set (match_operand:SI 3 \"s_register_operand\" \"=r\")\n+\t  (mem:SI (match_dup 1)))])]\n   \"(INTVAL (operands[2])  == 4 * (XVECLEN (operands[0], 0) - 2))\"\n   \"*\n {\n@@ -2938,11 +2950,11 @@\n \n (define_insn \"*stmsi_postinc\"\n   [(match_parallel 0 \"store_multiple_operation\"\n-                   [(set (match_operand:SI 1 \"s_register_operand\" \"+r\")\n-                         (plus:SI (match_dup 1)\n-                                  (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-                    (set (mem:SI (match_dup 1))\n-                         (match_operand:SI 3 \"s_register_operand\" \"r\"))])]\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"+r\")\n+\t  (plus:SI (match_dup 1)\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+     (set (mem:SI (match_dup 1))\n+\t  (match_operand:SI 3 \"s_register_operand\" \"r\"))])]\n   \"(INTVAL (operands[2]) == 4 * (XVECLEN (operands[0], 0) - 2))\"\n   \"*\n {\n@@ -3011,9 +3023,8 @@\n ;; Comparison and test insns\n \n (define_expand \"cmpsi\"\n-  [(set (reg:CC 24)\n-\t(compare:CC (match_operand:SI 0 \"s_register_operand\" \"\")\n-   \t\t    (match_operand:SI 1 \"arm_add_operand\" \"\")))]\n+  [(match_operand:SI 0 \"s_register_operand\" \"\")\n+   (match_operand:SI 1 \"arm_add_operand\" \"\")]\n   \"\"\n   \"\n {\n@@ -3025,9 +3036,8 @@\n \")\n \n (define_expand \"cmpsf\"\n-  [(set (reg:CC 24)\n-\t(compare:CC (match_operand:SF 0 \"s_register_operand\" \"\")\n-\t\t    (match_operand:SF 1 \"fpu_rhs_operand\" \"\")))]\n+  [(match_operand:SF 0 \"s_register_operand\" \"\")\n+   (match_operand:SF 1 \"fpu_rhs_operand\" \"\")]\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n@@ -3039,9 +3049,8 @@\n \")\n \n (define_expand \"cmpdf\"\n-  [(set (reg:CC 24)\n-\t(compare:CC (match_operand:DF 0 \"s_register_operand\" \"\")\n-\t\t    (match_operand:DF 1 \"fpu_rhs_operand\" \"\")))]\n+  [(match_operand:DF 0 \"s_register_operand\" \"\")\n+   (match_operand:DF 1 \"fpu_rhs_operand\" \"\")]\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n@@ -3053,9 +3062,8 @@\n \")\n \n (define_expand \"cmpxf\"\n-  [(set (reg:CC 24)\n-\t(compare:CC (match_operand:XF 0 \"s_register_operand\" \"\")\n-\t\t    (match_operand:XF 1 \"fpu_rhs_operand\" \"\")))]\n+  [(match_operand:XF 0 \"s_register_operand\" \"\")\n+   (match_operand:XF 1 \"fpu_rhs_operand\" \"\")]\n   \"ENABLE_XF_PATTERNS && TARGET_HARD_FLOAT\"\n   \"\n {\n@@ -3067,41 +3075,43 @@\n \")\n \n (define_insn \"*cmpsi_insn\"\n-  [(set (match_operand 0 \"cc_register\" \"\")\n-\t(compare (match_operand:SI 1 \"s_register_operand\" \"r,r\")\n-\t\t (match_operand:SI 2 \"arm_add_operand\" \"rI,L\")))]\n+  [(set (reg:CC 24)\n+\t(compare:CC (match_operand:SI 0 \"s_register_operand\" \"r,r\")\n+\t\t    (match_operand:SI 1 \"arm_add_operand\" \"rI,L\")))]\n   \"\"\n   \"@\n-   cmp%?\\\\t%1, %2\n-   cmn%?\\\\t%1, #%n2\"\n+   cmp%?\\\\t%0, %1\n+   cmn%?\\\\t%0, #%n1\"\n [(set_attr \"conds\" \"set\")])\n \n-(define_insn \"*cmpsi_negsi\"\n-  [(set (match_operand 0 \"cc_register\" \"\")\n-\t(compare (match_operand:SI 1 \"s_register_operand\" \"r\")\n-\t\t (neg:SI (match_operand:SI 2 \"s_register_operand\" \"r\"))))]\n+(define_insn \"*cmpsi_shiftsi\"\n+  [(set (reg:CC 24)\n+\t(compare:CC (match_operand:SI 0 \"s_register_operand\" \"r\")\n+\t\t    (match_operator:SI 3 \"shift_operator\"\n+\t\t     [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t      (match_operand:SI 2 \"arm_rhs_operand\" \"rM\")])))]\n   \"\"\n-  \"cmn%?\\\\t%1, %2\"\n+  \"cmp%?\\\\t%0, %1%S3\"\n [(set_attr \"conds\" \"set\")])\n \n-(define_insn \"*cmpsi_shiftsi\"\n-  [(set (match_operand 0 \"cc_register\" \"\")\n-\t(compare (match_operand:SI 1 \"s_register_operand\" \"r\")\n-\t\t (match_operator:SI 2 \"shift_operator\"\n-\t\t  [(match_operand:SI 3 \"s_register_operand\" \"r\")\n-\t\t   (match_operand:SI 4 \"arm_rhs_operand\" \"rM\")])))]\n+(define_insn \"*cmpsi_shiftsi_swp\"\n+  [(set (reg:CC_SWP 24)\n+\t(compare:CC_SWP (match_operator:SI 3 \"shift_operator\"\n+\t\t\t [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 2 \"reg_or_int_operand\" \"rM\")])\n+\t\t\t(match_operand:SI 0 \"s_register_operand\" \"r\")))]\n   \"\"\n-  \"cmp%?\\\\t%1, %3%S2\"\n+  \"cmp%?\\\\t%0, %1%S3\"\n [(set_attr \"conds\" \"set\")])\n \n (define_insn \"*cmpsi_neg_shiftsi\"\n-  [(set (match_operand 0 \"cc_register\" \"\")\n-\t(compare (match_operand:SI 1 \"s_register_operand\" \"r\")\n-\t\t (neg:SI (match_operator:SI 2 \"shift_operator\"\n-\t\t\t  [(match_operand:SI 3 \"s_register_operand\" \"r\")\n-\t\t\t   (match_operand:SI 4 \"arm_rhs_operand\" \"rM\")]))))]\n+  [(set (reg:CC 24)\n+\t(compare:CC (match_operand:SI 0 \"s_register_operand\" \"r\")\n+\t\t    (neg:SI (match_operator:SI 3 \"shift_operator\"\n+\t\t\t     [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 2 \"arm_rhs_operand\" \"rM\")]))))]\n   \"\"\n-  \"cmn%?\\\\t%1, %3%S2\"\n+  \"cmn%?\\\\t%0, %1%S3\"\n [(set_attr \"conds\" \"set\")])\n \n (define_insn \"*cmpsf_insn\"\n@@ -3388,7 +3398,7 @@\n \t\t\t\t\t[(reg 24) (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"REVERSIBLE_CC_MODE (GET_MODE (XEXP (operands[1], 0)))\"\n+  \"\"\n   \"*\n {\n   extern int arm_ccfsm_state;\n@@ -3546,9 +3556,9 @@\n \n (define_expand \"movsicc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n-\t\t      (match_operand:SI 2 \"arm_not_operand\" \"\")\n-\t\t      (match_operand:SI 3 \"register_operand\" \"\")))]\n+\t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:SI 2 \"arm_not_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -3561,9 +3571,9 @@\n \n (define_expand \"movsfcc\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n-\t\t      (match_operand:SF 2 \"nonmemory_operand\" \"\")\n-\t\t      (match_operand:SF 3 \"register_operand\" \"\")))]\n+\t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:SF 2 \"nonmemory_operand\" \"\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -3576,9 +3586,9 @@\n \n (define_expand \"movdfcc\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n-\t\t      (match_operand:DF 2 \"nonmemory_operand\" \"\")\n-\t\t      (match_operand:DF 3 \"register_operand\" \"\")))]\n+\t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:DF 2 \"nonmemory_operand\" \"\")\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n@@ -3591,10 +3601,10 @@\n \n (define_insn \"*movsicc_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else (match_operator 1 \"comparison_operator\" \n-\t\t       [(reg 24) (const_int 0)])\n-\t\t      (match_operand:SI 2 \"arm_not_operand\" \"rI,K\")\n-\t\t      (match_operand:SI 3 \"register_operand\" \"0,0\")))]\n+\t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n+\t\t\t  [(reg 24) (const_int 0)])\n+\t\t\t (match_operand:SI 2 \"arm_not_operand\" \"rI,K\")\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"0,0\")))]\n   \"\"\n   \"@\n    mov%d1\\\\t%0, %2\n@@ -3604,32 +3614,32 @@\n \n (define_insn \"*movsfcc_hard_insn\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(if_then_else (match_operator 1 \"comparison_operator\" \n-\t\t       [(reg 24) (const_int 0)])\n-\t\t      (match_operand:SF 2 \"register_operand\" \"f\")\n-\t\t      (match_operand:SF 3 \"register_operand\" \"0\")))]\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n+\t\t\t  [(reg 24) (const_int 0)])\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"f\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"0\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"mvf%d1s\\\\t%0, %2\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"conds\" \"use\")])\n \n (define_insn \"*movsfcc_soft_insn\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t       [(reg 24) (const_int 0)])\n-\t\t      (match_operand:SF 2 \"register_operand\" \"r\")\n-\t\t      (match_operand:SF 3 \"register_operand\" \"0\")))]\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\"\n+\t\t\t  [(reg 24) (const_int 0)])\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"0\")))]\n   \"TARGET_SOFT_FLOAT\"\n   \"mov%d1\\\\t%0, %2\"\n   [(set_attr \"type\" \"*\")\n    (set_attr \"conds\" \"use\")])\n \n (define_insn \"*movdfcc_insn\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t       [(reg 24) (const_int 0)])\n-\t\t      (match_operand:DF 2 \"register_operand\" \"f\")\n-\t\t      (match_operand:DF 3 \"register_operand\" \"0\")))]\n+\t(if_then_else:DF (match_operator 1 \"comparison_operator\"\n+\t\t\t  [(reg 24) (const_int 0)])\n+\t\t\t (match_operand:DF 2 \"register_operand\" \"f\")\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"0\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"mvf%d1d\\\\t%0, %2\"\n   [(set_attr \"type\" \"ffarith\")\n@@ -3748,7 +3758,7 @@\n     arm_ccfsm_state += 2;\n     return \\\"\\\";\n   }\n-  return output_return_instruction (NULL, TRUE);\n+  return output_return_instruction (NULL, TRUE, FALSE);\n }\"\n [(set_attr \"type\" \"load\")])\n \n@@ -3768,7 +3778,7 @@\n     arm_ccfsm_state += 2;\n     return \\\"\\\";\n   }\n-  return output_return_instruction (operands[0], TRUE);\n+  return output_return_instruction (operands[0], TRUE, FALSE);\n }\"\n [(set_attr \"conds\" \"use\")\n  (set_attr \"type\" \"load\")])\n@@ -3789,11 +3799,7 @@\n     arm_ccfsm_state += 2;\n     return \\\"\\\";\n   }\n-  return output_return_instruction \n-\t(gen_rtx (reverse_condition (GET_CODE (operands[0])),\n-\t\t  GET_MODE (operands[0]), XEXP (operands[0], 0),\n-\t\t  XEXP (operands[0], 1)),\n-\t TRUE);\n+  return output_return_instruction (operands[0], TRUE, TRUE);\n }\"\n [(set_attr \"conds\" \"use\")\n  (set_attr \"type\" \"load\")])\n@@ -3839,8 +3845,8 @@\n \n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"s_register_operand\" \"\")\t; index to jump on\n-   (match_operand:SI 1 \"immediate_operand\" \"\")\t; lower bound\n-   (match_operand:SI 2 \"immediate_operand\" \"\")\t; total range\n+   (match_operand:SI 1 \"const_int_operand\" \"\")\t; lower bound\n+   (match_operand:SI 2 \"const_int_operand\" \"\")\t; total range\n    (match_operand:SI 3 \"\" \"\")\t\t\t; table label\n    (match_operand:SI 4 \"\" \"\")]\t\t\t; Out of range label\n   \"\"\n@@ -4106,7 +4112,7 @@\n (define_insn \"*and_scc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(and:SI (match_operator 1 \"comparison_operator\"\n-\t\t [(match_operand 3 \"reversible_cc_register\" \"\") (const_int 0)])\n+\t\t [(match_operand 3 \"cc_register\" \"\") (const_int 0)])\n \t\t(match_operand:SI 2 \"s_register_operand\" \"r\")))]\n   \"\"\n   \"mov%D1\\\\t%0, #0\\;and%d1\\\\t%0, %2, #1\"\n@@ -4154,171 +4160,14 @@\n [(set_attr \"conds\" \"clob\")\n  (set_attr \"length\" \"12\")])\n \n-(define_insn \"*ior_compare_compare\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-\t(ior:SI (match_operator 1 \"comparison_operator\"\n-\t\t [(match_operand:SI 2 \"s_register_operand\" \"r\")\n-\t\t  (match_operand:SI 3 \"arm_rhs_operand\" \"rI\")])\n-\t\t(match_operator 4 \"comparison_operator\"\n-\t\t [(match_operand:SI 5 \"s_register_operand\" \"r\")\n-\t\t  (match_operand:SI 6 \"arm_rhs_operand\" \"rI\")])))\n-   (clobber (reg 24))]\n-  \"\"\n-  \"*\n-{\n-  int dominant = comparison_dominates_p (GET_CODE (operands[4]),\n-\t\t\t\t\t GET_CODE (operands[1]));\n-\n-  output_asm_insn (dominant ? \\\"cmp\\\\t%5, %6\\\" : \\\"cmp\\\\t%2, %3\\\",\n-\t\t   operands);\n-  output_asm_insn (\\\"mov\\\\t%0, #0\\\", operands);\n-  if (GET_CODE (operands[1]) == GET_CODE (operands[4])\n-      || comparison_dominates_p (GET_CODE (operands[1]),\n-\t\t\t\t GET_CODE (operands[4]))\n-      || dominant)\n-    output_asm_insn (dominant ? \\\"cmp%D4\\\\t%2, %3\\\" : \\\"cmp%D1\\\\t%5,%6\\\",\n-\t\t     operands);\n-  else\n-    output_asm_insn (\\\"mov%d1\\\\t%0, #1\\;cmp\\\\t%5, %6\\\", operands);\n-  return dominant ? \\\"mov%d1\\\\t%0, #1\\\" : \\\"mov%d4\\\\t%0, #1\\\";\n-}\n-\"\n-[(set_attr \"conds\" \"clob\")\n-; worst case length\n- (set_attr \"length\" \"20\")])\n-\n-(define_split\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 5 \"equality_operator\"\n-\t  [(ior:SI (match_operator 6 \"comparison_operator\"\n-\t\t    [(match_operand:SI 0 \"s_register_operand\" \"\")\n-\t\t     (match_operand:SI 1 \"arm_add_operand\" \"\")])\n-\t\t   (match_operator 7 \"comparison_operator\"\n-\t\t    [(match_operand:SI 2 \"s_register_operand\" \"\")\n-\t\t     (match_operand:SI 3 \"arm_add_operand\" \"\")]))\n-\t  (const_int 0)])\n-\t (label_ref (match_operand 4 \"\" \"\"))\n-\t (pc)))\n-   (clobber (reg 24))]\n-  \"(GET_CODE (operands[6]) == GET_CODE (operands[7])\n-    || comparison_dominates_p (GET_CODE (operands[6]), GET_CODE (operands[7]))\n-    || comparison_dominates_p (GET_CODE (operands[7]), GET_CODE (operands[6])))\"\n-  [(set (reg:CC 24)\n-\t(compare:CC (ior:CC (match_op_dup 6\n-\t\t\t     [(match_dup 0) (match_dup 1)])\n-\t\t\t    (match_op_dup 7\n-\t\t\t     [(match_dup 2) (match_dup 3)]))\n-\t\t    (const_int 0)))\n-   (set (pc)\n-        (if_then_else (match_op_dup 5 [(reg:CC 24) (const_int 0)])\n-\t\t      (label_ref (match_dup 4))\n-\t\t      (pc)))]\n-  \"\n-{\n-  enum rtx_code code = comparison_dominates_p (GET_CODE (operands[6]),\n-\t\t\t\t\t       GET_CODE (operands[7]))\n-\t\t       ? GET_CODE (operands[7]) : GET_CODE (operands[6]);\n-\n-  if (GET_CODE (operands[5]) == NE)\n-    operands[5] = gen_rtx (code, CCmode,\n-\t\t\t   XEXP (operands[5], 0), XEXP (operands[5], 1));\n-  else\n-    operands[5] = gen_rtx (reverse_condition (code), CCmode,\n-\t\t\t   XEXP (operands[5], 0), XEXP (operands[5], 1));\n-}\n-\")\n-\n-;; Don't match these patterns if we can use a conditional compare, since they\n-;; tell the final prescan branch eliminator code that full branch inlining\n-;; can't be done.\n-\n-(define_insn \"*impossible_cond_compare\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ne (ior:SI (match_operator 5 \"comparison_operator\"\n-\t\t      [(match_operand:SI 0 \"s_register_operand\" \"r,r,r,r\")\n-\t\t       (match_operand:SI 1 \"arm_add_operand\" \"rI,L,rI,L\")])\n-\t\t     (match_operator 6 \"comparison_operator\"\n-\t\t      [(match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n-\t\t       (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI,L,L\")]))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 4 \"\" \"\"))\n-\t (pc)))\n-   (clobber (reg 24))]\n-  \"!(GET_CODE (operands[5]) == GET_CODE (operands[6])\n-     || comparison_dominates_p (GET_CODE (operands[5]), GET_CODE (operands[6]))\n-     || comparison_dominates_p (GET_CODE (operands[6]), GET_CODE (operands[5])))\"\n-  \"*\n-{\n-  extern int arm_ccfsm_state;\n-\n-  if (which_alternative & 1)\n-    output_asm_insn (\\\"cmn\\\\t%0, #%n1\\;b%d5\\\\t%l4\\\", operands);\n-  else\n-    output_asm_insn (\\\"cmp\\\\t%0, %1\\;b%d5\\\\t%l4\\\", operands);\n-\n-  if (which_alternative >= 2)\n-    output_asm_insn (\\\"cmn\\\\t%2, #%n3\\\", operands);\n-  else\n-    output_asm_insn (\\\"cmp\\\\t%2, %3\\\", operands);\n-\n-  if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)\n-  {\n-    arm_ccfsm_state += 2;\n-    return \\\"\\\";\n-  }\n-  return \\\"b%d6\\\\t%l4\\\";\n-}\"\n-[(set_attr \"conds\" \"jump_clob\")\n- (set_attr \"length\" \"16\")])\n-\n-(define_insn \"*condition_compare_ior\"\n-  [(set (reg:CC 24)\n-\t(compare:CC\n-\t (ior:CC (match_operator 4 \"comparison_operator\"\n-\t\t  [(match_operand:SI 0 \"s_register_operand\" \"r,r,r,r\")\n-\t\t   (match_operand:SI 1 \"arm_add_operand\" \"rI,L,rI,L\")])\n-\t\t (match_operator 5 \"comparison_operator\"\n-\t\t  [(match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n-\t\t   (match_operand:SI 3 \"arm_add_operand\" \"rI,rI,L,L\")]))\n-\t (const_int 0)))]\n-  \"(GET_CODE (operands[4]) == GET_CODE (operands[5])\n-    || comparison_dominates_p (GET_CODE (operands[4]), GET_CODE (operands[5]))\n-    || comparison_dominates_p (GET_CODE (operands[5]), GET_CODE (operands[4])))\"\n-  \"*\n-  if (comparison_dominates_p (GET_CODE (operands[5]), GET_CODE (operands[4])))\n-    {\n-      if (which_alternative >= 2)\n-\toutput_asm_insn (\\\"cmn\\\\t%2, #%n3\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"cmp\\\\t%2, %3\\\", operands);\n-\n-      if (which_alternative & 1)\n-\treturn \\\"cmn%D5\\\\t%0, #%n1\\\";\n-      return \\\"cmp%D5\\\\t%0, %1\\\";\n-    }\n-\n-  if (which_alternative & 1)\n-    output_asm_insn (\\\"cmn\\\\t%0, #%n1\\\", operands);\n-  else\n-    output_asm_insn (\\\"cmp\\\\t%0, %1\\\", operands);\n-\n-  if (which_alternative >= 2)\n-    return \\\"cmn%D4\\\\t%2, #%n3\\\";\n-  return \\\"cmp%D4\\\\t%2, %3\\\";\n-\"\n-[(set_attr \"conds\" \"set\")\n- (set_attr \"length\" \"8\")])\n-\n (define_insn \"*cond_move\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r\")\n-\t(if_then_else (match_operator 3 \"equality_operator\"\n-\t\t       [(match_operator 4 \"comparison_operator\"\n-\t\t\t [(reg 24) (const_int 0)])\n-\t\t\t(const_int 0)])\n-\t\t      (match_operand:SI 1 \"arm_rhs_operand\" \"0,rI,?rI\")\n-\t\t      (match_operand:SI 2 \"arm_rhs_operand\" \"rI,0,rI\")))]\n+\t(if_then_else:SI (match_operator 3 \"equality_operator\"\n+\t\t\t  [(match_operator 4 \"comparison_operator\"\n+\t\t\t    [(reg 24) (const_int 0)])\n+\t\t\t   (const_int 0)])\n+\t\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,rI,?rI\")\n+\t\t\t (match_operand:SI 2 \"arm_rhs_operand\" \"rI,0,rI\")))]\n   \"\"\n   \"*\n   if (GET_CODE (operands[3]) == NE)\n@@ -4380,139 +4229,70 @@\n [(set_attr \"conds\" \"clob\")\n  (set_attr \"length\" \"8,12\")])\n \n-(define_insn \"*and_scc_scc\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-\t(and:SI (match_operator 1 \"comparison_operator\"\n-\t\t [(match_operand:SI 2 \"s_register_operand\" \"r\")\n-\t\t  (match_operand:SI 3 \"arm_rhs_operand\" \"rI\")])\n-\t\t(match_operator 4 \"comparison_operator\"\n-\t\t [(match_operand:SI 5 \"s_register_operand\" \"r\")\n-\t\t  (match_operand:SI 6 \"arm_rhs_operand\" \"rI\")])))\n-   (clobber (reg 24))]\n+(define_insn \"*cmp_ite0\"\n+  [(set (match_operand 6 \"dominant_cc_register\" \"\")\n+\t(compare\n+\t (if_then_else:SI\n+\t  (match_operator 4 \"comparison_operator\"\n+\t   [(match_operand:SI 0 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 1 \"arm_add_operand\" \"rI,L,rI,L\")])\n+\t  (match_operator:SI 5 \"comparison_operator\"\n+\t   [(match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 3 \"arm_add_operand\" \"rI,rI,L,L\")])\n+\t  (const_int 0))\n+\t (const_int 0)))]\n   \"\"\n   \"*\n {\n-  int dominant =\n-\tcomparison_dominates_p (reverse_condition (GET_CODE (operands[1])),\n-\t\t\t\treverse_condition (GET_CODE (operands[4])))\n-\t? 1 \n-\t: comparison_dominates_p (reverse_condition (GET_CODE (operands[4])),\n-\t\t\t\t  reverse_condition (GET_CODE (operands[1])))\n-\t? 2 : 0;\n-  output_asm_insn (dominant == 2 ? \\\"cmp\\\\t%5, %6\\\" : \\\"cmp\\\\t%2, %3\\\",\n-\t\t       operands);\n-  output_asm_insn (\\\"mov\\\\t%0, #1\\\", operands);\n-  if (GET_CODE (operands[1]) == GET_CODE (operands[4]) || dominant)\n-    {\n-      output_asm_insn (dominant == 2 ? \\\"cmp%d4\\\\t%2, %3\\\"\n-\t\t\t   : \\\"cmp%d1\\\\t%5, %6\\\", operands);\n-    }\n-  else\n-    {\n-      output_asm_insn (\\\"mov%D1\\\\t%0, #0\\\", operands);\n-      output_asm_insn (\\\"cmp\\\\t%5, %6\\\", operands);\n-    }\n-  return dominant == 2 ? \\\"mov%D1\\\\t%0, #0\\\" : \\\"mov%D4\\\\t%0, #0\\\";\n+  char* opcodes[4][2] =\n+  {\n+    {\\\"cmp\\\\t%2, %3\\;cmp%d5\\\\t%0, %1\\\",\\\"cmp\\\\t%0, %1\\;cmp%d4\\\\t%2, %3\\\"},\n+    {\\\"cmp\\\\t%2, %3\\;cmn%d5\\\\t%0, #%n1\\\", \\\"cmn\\\\t%0, #%n1\\;cmp%d4\\\\t%2, %3\\\"},\n+    {\\\"cmn\\\\t%2, #%n3\\;cmp%d5\\\\t%0, %1\\\", \\\"cmp\\\\t%0, %1\\;cmn%d4\\\\t%2, #%n3\\\"},\n+    {\\\"cmn\\\\t%2, #%n3\\;cmn%d5\\\\t%0, #%n1\\\",\n+     \\\"cmn\\\\t%0, #%n1\\;cmn%d4\\\\t%2, #%n3\\\"}\n+  };\n+  int swap =\n+    comparison_dominates_p (GET_CODE (operands[5]), GET_CODE (operands[4]));\n+\n+  return opcodes[which_alternative][swap];\n }\n \"\n-[(set_attr \"conds\" \"clob\")\n- (set_attr \"length\" \"20\")])\n-\n-(define_split\n-  [(set (pc)\n-\t(if_then_else (match_operator 1 \"equality_operator\"\n-\t\t       [(and:SI (match_operator 2 \"comparison_operator\"\n-\t\t\t\t [(match_operand:SI 3 \"s_register_operand\" \"\")\n-\t\t\t\t  (match_operand:SI 4 \"arm_add_operand\" \"\")])\n-\t\t\t\t(match_operator 0 \"comparison_operator\"\n-\t\t\t\t [(match_operand:SI 5 \"s_register_operand\" \"\")\n-\t\t\t\t  (match_operand:SI 6 \"arm_add_operand\" \"\")]))\n-\t\t\t(const_int 0)])\n-\t\t      (label_ref (match_operand 7 \"\" \"\"))\n-\t\t      (pc)))\n-   (clobber (reg 24))]\n-  \"(GET_CODE (operands[2]) == GET_CODE (operands[0])\n-    || comparison_dominates_p (reverse_condition (GET_CODE (operands[2])),\n-\t\t\t       reverse_condition (GET_CODE (operands[0])))\n-    || comparison_dominates_p (reverse_condition (GET_CODE (operands[0])),\n-\t\t\t       reverse_condition (GET_CODE (operands[2]))))\"\n-  [(set (reg:CC 24)\n-\t(compare:CC (ior:CC (match_op_dup 2\n-\t\t\t     [(match_dup 3) (match_dup 4)])\n-\t\t\t    (match_op_dup 0\n-\t\t\t     [(match_dup 5) (match_dup 6)]))\n-\t\t    (const_int 0)))\n-   (set (pc)\n-        (if_then_else (match_op_dup 1 [(reg:CC 24) (const_int 0)])\n-\t\t      (label_ref (match_dup 7))\n-\t\t      (pc)))]\n-  \"\n-{\n-  /* Use DeMorgans law to convert this into an IOR of the inverse conditions \n-     This is safe since we only do it for integer comparisons. */\n-  enum rtx_code code = \n-\tcomparison_dominates_p (reverse_condition (GET_CODE (operands[2])),\n-\t\t\t\treverse_condition (GET_CODE (operands[0])))\n-\t? GET_CODE (operands[0]) : GET_CODE (operands[2]);\n-\n-  operands[2] = gen_rtx (reverse_condition (GET_CODE (operands[2])),\n-\t\t\t GET_MODE (operands[2]), operands[3], operands[4]);\n-  operands[0] = gen_rtx (reverse_condition (GET_CODE (operands[0])),\n-\t\t\t GET_MODE (operands[0]), operands[5], operands[6]);\n-  if (GET_CODE (operands[1]) == NE)\n-    operands[1] = gen_rtx (code, CCmode,\n-\t\t\t   XEXP (operands[1], 0), XEXP (operands[1], 1));\n-  else\n-    operands[1] = gen_rtx (reverse_condition (code), CCmode,\n-\t\t\t   XEXP (operands[1], 0), XEXP (operands[1], 1));\n-}\n-\")\n-\n-;; Don't match these patterns if we can use a conditional compare, since they\n-;; tell the final prescan branch eliminator code that full branch inlining\n-;; can't be done.\n+[(set_attr \"conds\" \"set\")\n+ (set_attr \"length\" \"8\")])\n \n-(define_insn \"*impossible_cond_branch_and\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (eq (and:SI (match_operator 1 \"comparison_operator\"\n-\t\t      [(match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n-\t\t       (match_operand:SI 3 \"arm_add_operand\" \"rI,L,rI,L\")])\n-\t\t     (match_operator 4 \"comparison_operator\"\n-\t\t      [(match_operand:SI 5 \"s_register_operand\" \"r,r,r,r\")\n-\t\t       (match_operand:SI 6 \"arm_rhs_operand\" \"rI,rI,L,L\")]))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 0 \"\" \"\"))\n-\t (pc)))\n-   (clobber (reg 24))]\n-  \"!(GET_CODE (operands[1]) == GET_CODE (operands[4])\n-     || comparison_dominates_p (reverse_condition (GET_CODE (operands[1])),\n-\t\t\t        reverse_condition (GET_CODE (operands[4])))\n-     || comparison_dominates_p (reverse_condition (GET_CODE (operands[4])),\n-\t\t\t        reverse_condition (GET_CODE (operands[1]))))\"\n+(define_insn \"*cmp_ite1\"\n+  [(set (match_operand 6 \"dominant_cc_register\" \"\")\n+\t(compare\n+\t (if_then_else:SI\n+\t  (match_operator 4 \"comparison_operator\"\n+\t   [(match_operand:SI 0 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 1 \"arm_rhs_operand\" \"rI,L,rI,L\")])\n+\t  (match_operator:SI 5 \"comparison_operator\"\n+\t   [(match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI,L,L\")])\n+\t  (const_int 1))\n+\t (const_int 0)))]\n+  \"\"\n   \"*\n {\n-  extern int arm_ccfsm_state;\n-\n-  if (which_alternative & 1)\n-    output_asm_insn (\\\"cmn\\\\t%2, #%n3\\;b%D1\\\\t%l0\\\", operands);\n-  else\n-    output_asm_insn (\\\"cmp\\\\t%2, %3\\;b%D1\\\\t%l0\\\", operands);\n-\n-  if (which_alternative >= 2)\n-    output_asm_insn (\\\"cmn\\\\t%5, #%n6\\\", operands);\n-  else\n-    output_asm_insn (\\\"cmp\\\\t%5, %6\\\", operands);\n-\n-  if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)\n+  char* opcodes[4][2] =\n   {\n-    arm_ccfsm_state += 2;\n-    return \\\"\\\";\n-  }\n-  return \\\"b%D4\\\\t%l0\\\";\n-}\"\n-[(set_attr \"conds\" \"jump_clob\")\n- (set_attr \"length\" \"16\")])\n+    {\\\"cmp\\\\t%0, %1\\;cmp%d4\\\\t%2, %3\\\", \\\"cmp\\\\t%2, %3\\;cmp%D5\\\\t%0, %1\\\"},\n+    {\\\"cmn\\\\t%0, #%n1\\;cmp%d4\\\\t%2, %3\\\", \\\"cmp\\\\t%2, %3\\;cmn%D5\\\\t%0, #%n1\\\"},\n+    {\\\"cmp\\\\t%0, %1\\;cmn%d4\\\\t%2, #%n3\\\", \\\"cmn\\\\t%2, #%n3\\;cmp%D5\\\\t%0, %1\\\"},\n+    {\\\"cmn\\\\t%0, #%n1\\;cmn%d4\\\\t%2, #%n3\\\",\n+     \\\"cmn\\\\t%2, #%n3\\;cmn%D5\\\\t%0, #%n1\\\"}\n+  };\n+  int swap =\n+    comparison_dominates_p (GET_CODE (operands[5]),\n+\t\t\t    reverse_condition (GET_CODE (operands[4])));\n+\n+  return opcodes[which_alternative][swap];\n+}\n+\"\n+[(set_attr \"conds\" \"set\")\n+ (set_attr \"length\" \"8\")])\n \n (define_insn \"*negscc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n@@ -4782,7 +4562,7 @@\n [(set_attr \"conds\" \"clob\")\n  (set_attr \"length\" \"8,12\")])\n \n-(define_insn \"ifcompare_move_not\"\n+(define_insn \"*ifcompare_move_not\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(if_then_else:SI (match_operator 5 \"comparison_operator\"\n \t\t\t  [(match_operand:SI 3 \"s_register_operand\" \"r,r\")\n@@ -5427,8 +5207,8 @@\n (define_peephole\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(match_operand:SI 1 \"s_register_operand\" \"r\"))\n-   (set (match_operand 2 \"cc_register\" \"\")\n-\t(compare (match_dup 1) (const_int 0)))]\n+   (set (reg:CC 24)\n+\t(compare:CC (match_dup 1) (const_int 0)))]\n   \"\"\n   \"sub%?s\\\\t%0, %1, #0\"\n [(set_attr \"conds\" \"set\")])\n@@ -5438,110 +5218,75 @@\n \n (define_peephole\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (mem:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                         (const_int 12))))\n+        (match_operand:SI 4 \"memory_operand\" \"m\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+        (match_operand:SI 5 \"memory_operand\" \"m\"))\n    (set (match_operand:SI 2 \"s_register_operand\" \"=r\")\n-        (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+        (match_operand:SI 6 \"memory_operand\" \"m\"))\n    (set (match_operand:SI 3 \"s_register_operand\" \"=r\")\n-        (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-   (set (match_operand:SI 4 \"s_register_operand\" \"=r\")\n-        (mem:SI (match_dup 1)))]\n-  \"REGNO (operands[0]) > REGNO (operands[2])\n-   && REGNO (operands[2]) > REGNO (operands[3])\n-   && REGNO (operands[3]) > REGNO (operands[4])\n-   && !(REGNO (operands[1]) == REGNO (operands[0])\n-       || REGNO (operands[1]) == REGNO (operands[2])\n-       || REGNO (operands[1]) == REGNO (operands[3])\n-       || REGNO (operands[1]) == REGNO (operands[4]))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (insn)))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (prev_nonnote_insn (insn))))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (prev_nonnote_insn\n-\t\t\t\t\t (prev_nonnote_insn (insn)))))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (prev_nonnote_insn\n-\t\t\t\t\t (prev_nonnote_insn \n-\t\t\t\t\t  (prev_nonnote_insn (insn))))))\"\n-  \"ldm%?ia\\\\t%1, {%4, %3, %2, %0}\\\\t%@ phole ldm\")\n+        (match_operand:SI 7 \"memory_operand\" \"m\"))]\n+  \"load_multiple_sequence (operands, 4, NULL, NULL, NULL)\"\n+  \"*\n+  return emit_ldm_seq (operands, 4);\n+\")\n \n (define_peephole\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (mem:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                         (const_int 8))))\n+        (match_operand:SI 3 \"memory_operand\" \"m\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+        (match_operand:SI 4 \"memory_operand\" \"m\"))\n    (set (match_operand:SI 2 \"s_register_operand\" \"=r\")\n-        (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-   (set (match_operand:SI 3 \"s_register_operand\" \"=r\")\n-        (mem:SI (match_dup 1)))]\n-  \"REGNO (operands[0]) >  REGNO (operands[2])\n-   && REGNO (operands[2]) > REGNO (operands[3])\n-   && !(REGNO (operands[1]) == REGNO (operands[0])\n-       || REGNO (operands[1]) == REGNO (operands[2])\n-       || REGNO (operands[1]) == REGNO (operands[3]))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (insn)))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (prev_nonnote_insn (insn))))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (prev_nonnote_insn\n-\t\t\t\t\t (prev_nonnote_insn (insn)))))\"\n-  \"ldm%?ia\\\\t%1, {%3, %2, %0}\\\\t%@ phole ldm\")\n+        (match_operand:SI 5 \"memory_operand\" \"m\"))]\n+  \"load_multiple_sequence (operands, 3, NULL, NULL, NULL)\"\n+  \"*\n+  return emit_ldm_seq (operands, 3);\n+\")\n \n (define_peephole\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (mem:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                         (const_int 4))))\n-   (set (match_operand:SI 2 \"s_register_operand\" \"=r\")\n-        (mem:SI (match_dup 1)))]\n-  \"REGNO (operands[0]) > REGNO (operands[2])\n-   && !(REGNO (operands[1]) == REGNO (operands[0])\n-       || REGNO (operands[1]) == REGNO (operands[2]))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (insn)))\n-   && !MEM_VOLATILE_P (SET_SRC (PATTERN (prev_nonnote_insn (insn))))\"\n-  \"ldm%?ia\\\\t%1, {%2, %0}\\\\t%@ phole ldm\")\n+        (match_operand:SI 2 \"memory_operand\" \"m\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+        (match_operand:SI 3 \"memory_operand\" \"m\"))]\n+  \"load_multiple_sequence (operands, 2, NULL, NULL, NULL)\"\n+  \"*\n+  return emit_ldm_seq (operands, 2);\n+\")\n \n (define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                         (const_int 12)))\n+  [(set (match_operand:SI 4 \"memory_operand\" \"=m\")\n         (match_operand:SI 0 \"s_register_operand\" \"r\"))\n-   (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n+   (set (match_operand:SI 5 \"memory_operand\" \"=m\")\n+        (match_operand:SI 1 \"s_register_operand\" \"r\"))\n+   (set (match_operand:SI 6 \"memory_operand\" \"=m\")\n         (match_operand:SI 2 \"s_register_operand\" \"r\"))\n-   (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-        (match_operand:SI 3 \"s_register_operand\" \"r\"))\n-   (set (mem:SI (match_dup 1))\n-        (match_operand:SI 4 \"s_register_operand\" \"r\"))]\n-  \"REGNO (operands[0]) >  REGNO (operands[2])\n-   && REGNO (operands[2]) > REGNO (operands[3])\n-   && REGNO (operands[3]) > REGNO (operands[4])\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (insn)))\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (prev_nonnote_insn (insn))))\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (prev_nonnote_insn\n-\t\t\t\t\t  (prev_nonnote_insn (insn)))))\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (prev_nonnote_insn\n-\t\t\t\t\t  (prev_nonnote_insn \n-\t\t\t\t\t   (prev_nonnote_insn (insn))))))\"\n-  \"stm%?ia\\\\t%1, {%4, %3, %2, %0}\\\\t%@ phole stm\")\n+   (set (match_operand:SI 7 \"memory_operand\" \"=m\")\n+        (match_operand:SI 3 \"s_register_operand\" \"r\"))]\n+  \"store_multiple_sequence (operands, 4, NULL, NULL, NULL)\"\n+  \"*\n+  return emit_stm_seq (operands, 4);\n+\")\n \n (define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                         (const_int 8)))\n+  [(set (match_operand:SI 3 \"memory_operand\" \"=m\")\n         (match_operand:SI 0 \"s_register_operand\" \"r\"))\n-   (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-        (match_operand:SI 2 \"s_register_operand\" \"r\"))\n-   (set (mem:SI (match_dup 1))\n-        (match_operand:SI 3 \"s_register_operand\" \"r\"))]\n-  \"REGNO (operands[0]) >  REGNO (operands[2])\n-   && REGNO (operands[2]) > REGNO (operands[3])\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (insn)))\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (prev_nonnote_insn (insn))))\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (prev_nonnote_insn\n-\t\t\t\t\t  (prev_nonnote_insn (insn)))))\"\n-  \"stm%?ia\\\\t%1, {%3, %2, %0}\\\\t%@ phole stm\")\n+   (set (match_operand:SI 4 \"memory_operand\" \"=m\")\n+        (match_operand:SI 1 \"s_register_operand\" \"r\"))\n+   (set (match_operand:SI 5 \"memory_operand\" \"=m\")\n+        (match_operand:SI 2 \"s_register_operand\" \"r\"))]\n+  \"store_multiple_sequence (operands, 3, NULL, NULL, NULL)\"\n+  \"*\n+  return emit_stm_seq (operands, 3);\n+\")\n \n (define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                         (const_int 4)))\n+  [(set (match_operand:SI 2 \"memory_operand\" \"=m\")\n         (match_operand:SI 0 \"s_register_operand\" \"r\"))\n-   (set (mem:SI (match_dup 1))\n-        (match_operand:SI 2 \"s_register_operand\" \"r\"))]\n-  \"REGNO (operands[0]) >  REGNO (operands[2])\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (insn)))\n-   && !MEM_VOLATILE_P (SET_DEST (PATTERN (prev_nonnote_insn (insn))))\"\n-  \"stm%?ia\\\\t%1, {%2, %0}\\\\t%@ phole stm\")\n+   (set (match_operand:SI 3 \"memory_operand\" \"=m\")\n+        (match_operand:SI 1 \"s_register_operand\" \"r\"))]\n+  \"store_multiple_sequence (operands, 2, NULL, NULL, NULL)\"\n+  \"*\n+  return emit_stm_seq (operands, 2);\n+\")\n \n ;; A call followed by return can be replaced by restoring the regs and\n ;; jumping to the subroutine, provided we aren't passing the address of\n@@ -5568,17 +5313,17 @@\n   \"*\n {\n   extern rtx arm_target_insn;\n-  extern int arm_ccfsm_state, arm_current_cc;\n+  extern int arm_ccfsm_state;\n \n   if (arm_ccfsm_state && arm_target_insn && INSN_DELETED_P (arm_target_insn))\n   {\n-    arm_current_cc ^= 1;\n-    output_return_instruction (NULL, TRUE);\n+    arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n+    output_return_instruction (NULL, TRUE, FALSE);\n     arm_ccfsm_state = 0;\n     arm_target_insn = NULL;\n   }\n \n-  output_return_instruction (NULL, FALSE);\n+  output_return_instruction (NULL, FALSE, FALSE);\n   return \\\"b%?\\\\t%a0\\\";\n }\"\n [(set_attr \"type\" \"call\")\n@@ -5596,17 +5341,17 @@\n   \"*\n {\n   extern rtx arm_target_insn;\n-  extern int arm_ccfsm_state, arm_current_cc;\n+  extern int arm_ccfsm_state;\n \n   if (arm_ccfsm_state && arm_target_insn && INSN_DELETED_P (arm_target_insn))\n   {\n-    arm_current_cc ^= 1;\n-    output_return_instruction (NULL, TRUE);\n+    arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n+    output_return_instruction (NULL, TRUE, FALSE);\n     arm_ccfsm_state = 0;\n     arm_target_insn = NULL;\n   }\n \n-  output_return_instruction (NULL, FALSE);\n+  output_return_instruction (NULL, FALSE, FALSE);\n   return \\\"b%?\\\\t%a1\\\";\n }\"\n [(set_attr \"type\" \"call\")\n@@ -5628,17 +5373,17 @@\n   \"*\n {\n   extern rtx arm_target_insn;\n-  extern int arm_ccfsm_state, arm_current_cc;\n+  extern int arm_ccfsm_state;\n \n   if (arm_ccfsm_state && arm_target_insn && INSN_DELETED_P (arm_target_insn))\n   {\n-    arm_current_cc ^= 1;\n-    output_return_instruction (NULL, TRUE);\n+    arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n+    output_return_instruction (NULL, TRUE, FALSE);\n     arm_ccfsm_state = 0;\n     arm_target_insn = NULL;\n   }\n \n-  output_return_instruction (NULL, FALSE);\n+  output_return_instruction (NULL, FALSE, FALSE);\n   return \\\"b%?\\\\t%a1\\\";\n }\"\n [(set_attr \"type\" \"call\")\n@@ -5736,29 +5481,6 @@\n \t\t    (const_int 8)\n \t\t    (const_int 12)))])\n \n-(define_split\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t       [(match_operator:SI 1 \"shift_operator\"\n-\t\t\t [(match_operand:SI 2 \"s_register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 3 \"reg_or_int_operand\" \"rM\")])\n-\t\t\t(match_operand:SI 4 \"s_register_operand\" \"r\")])\n-\t\t      (label_ref (match_operand 5 \"\" \"\"))\n-\t\t      (pc)))\n-   (clobber (reg 24))]\n-  \"\"\n-  [(set (reg:CC 24)\n-\t(compare:CC (match_dup 4)\n-\t\t    (match_op_dup 1 [(match_dup 2) (match_dup 3)])))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 0 [(reg 24) (const_int 0)])\n-\t\t      (label_ref (match_dup 5))\n-\t\t      (pc)))]\n-  \"\n-  operands[0] = gen_rtx (swap_condition (GET_CODE (operands[0])), VOIDmode,\n-\t\t\t operands[1], operands[2]);\n-\")\n-\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(and:SI (ge:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -5773,29 +5495,24 @@\n \t\t\t      (match_dup 5)))]\n   \"\")\n \n-;; This pattern can be used because cc_noov mode implies that the following\n-;; branch will be an equality (EQ or NE), so the sign extension is not\n-;; needed.  Combine doesn't eliminate these because by the time it sees the\n-;; branch it no-longer knows that the data came from memory.\n+;; This split can be used because CC_Z mode implies that the following\n+;; branch will be an equality, or an unsigned inequality, so the sign\n+;; extension is not needed.\n \n-(define_insn \"*loadqi_compare\"\n-  [(set (reg:CC_NOOV 24)\n-\t(compare:CC_NOOV\n-\t (ashift:SI (subreg:SI (match_operand:QI 0 \"memory_operand\" \"m\") 0)\n+(define_split\n+  [(set (reg:CC_Z 24)\n+\t(compare:CC_Z\n+\t (ashift:SI (subreg:SI (match_operand:QI 0 \"memory_operand\" \"\") 0)\n \t\t    (const_int 24))\n-\t (match_operand 1 \"immediate_operand\" \"I\")))\n-   (clobber (match_scratch:SI 2 \"=r\"))]\n-  \"((unsigned long) INTVAL (operands[1]))\n-   == (((unsigned long) INTVAL (operands[1])) >> 24) << 24\"\n-  \"*\n+\t (match_operand 1 \"const_int_operand\" \"\")))\n+   (clobber (match_scratch:SI 2 \"\"))]\n+  \"((unsigned HOST_WIDE_INT) INTVAL (operands[1]))\n+   == (((unsigned HOST_WIDE_INT) INTVAL (operands[1])) >> 24) << 24\"\n+  [(set (match_dup 2) (zero_extend:SI (match_dup 0)))\n+   (set (reg:CC 24) (compare:CC (match_dup 2) (match_dup 1)))]\n+  \"\n   operands[1] = GEN_INT (((unsigned long) INTVAL (operands[1])) >> 24);\n-  output_asm_insn (\\\"ldr%?b\\\\t%2, %0\\\", operands);\n-  output_asm_insn (\\\"cmp%?\\\\t%2, %1\\\", operands);\n-  return \\\"\\\";\n-\"\n-[(set_attr \"conds\" \"set\")\n- (set_attr \"length\" \"8\")\n- (set_attr \"type\" \"load\")])\n+\")\n \n (define_expand \"prologue\"\n   [(clobber (const_int 0))]\n@@ -5839,8 +5556,7 @@\n (define_insn \"*cond_move_not\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(if_then_else:SI (match_operator 4 \"comparison_operator\"\n-\t\t\t  [(match_operand 3 \"reversible_cc_register\" \"\")\n-\t\t\t   (const_int 0)])\n+\t\t\t  [(match_operand 3 \"cc_register\" \"\") (const_int 0)])\n \t\t\t (match_operand:SI 1 \"arm_rhs_operand\" \"0,?rI\")\n \t\t\t (not:SI\n \t\t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\"))))]\n@@ -5858,7 +5574,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n \t\t\t (const_int 1)\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))]\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n   \"*\n   operands[2] = GEN_INT (1 << INTVAL (operands[2]));\n@@ -5873,7 +5589,7 @@\n \t(not:SI\n \t (sign_extract:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n \t\t\t  (const_int 1)\n-\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"n\"))))]\n+\t\t\t  (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n   \"\"\n   \"*\n   operands[2] = GEN_INT (1 << INTVAL (operands[2]));"}]}