{"sha": "bd9837bc3ca1344c32aef7ba9f8fa1785063132e", "node_id": "C_kwDOANBUbNoAKGJkOTgzN2JjM2NhMTM0NGMzMmFlZjdiYTlmOGZhMTc4NTA2MzEzMmU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-20T10:28:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-21T11:05:42Z"}, "message": "Teach VN about masked/len stores\n\nThe following teaches VN to handle reads from .MASK_STORE and\n.LEN_STORE.  For this push_partial_def is extended first for\nconvenience so we don't have to handle the full def case in the\ncaller (possibly other paths can be simplified then).  Also\nthe partial definition stored value can have an offset applied\nso we don't have to build a fake RHS when we register the pieces\nof an existing store.\n\n\tPR tree-optimization/106365\n\t* tree-ssa-sccvn.cc (pd_data::rhs_off): New field determining\n\tthe offset to start encoding of RHS from.\n\t(vn_walk_cb_data::vn_walk_cb_data): Initialize it.\n\t(vn_walk_cb_data::push_partial_def): Allow the first partial\n\tdefinition to be fully providing the def.  Offset RHS\n\tbefore encoding if requested.\n\t(vn_reference_lookup_3): Initialize def_rhs everywhere.\n\tAdd support for .MASK_STORE and .LEN_STORE (partial) definitions.\n\n\t* gcc.target/i386/vec-maskstore-vn.c: New testcase.", "tree": {"sha": "37e494bdc17a57e16af86c4d491cb9cbb40ab691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37e494bdc17a57e16af86c4d491cb9cbb40ab691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd9837bc3ca1344c32aef7ba9f8fa1785063132e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9837bc3ca1344c32aef7ba9f8fa1785063132e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd9837bc3ca1344c32aef7ba9f8fa1785063132e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9837bc3ca1344c32aef7ba9f8fa1785063132e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4ed610d02aaf8cfcdcb5cf03e0cde65f1f5f890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ed610d02aaf8cfcdcb5cf03e0cde65f1f5f890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4ed610d02aaf8cfcdcb5cf03e0cde65f1f5f890"}], "stats": {"total": 285, "additions": 228, "deletions": 57}, "files": [{"sha": "98213905ecefacbbe7e028dc7a2578ea2e24aa28", "filename": "gcc/testsuite/gcc.target/i386/vec-maskstore-vn.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9837bc3ca1344c32aef7ba9f8fa1785063132e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvec-maskstore-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9837bc3ca1344c32aef7ba9f8fa1785063132e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvec-maskstore-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvec-maskstore-vn.c?ref=bd9837bc3ca1344c32aef7ba9f8fa1785063132e", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx2 -fdump-tree-fre5\" } */\n+\n+void __attribute__((noinline,noclone))\n+foo (int *out, int *res)\n+{\n+  int mask[] = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };\n+  int i;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      if (mask[i])\n+        out[i] = i;\n+    }\n+  int o0 = out[0];\n+  int o7 = out[7];\n+  int o14 = out[14];\n+  int o15 = out[15];\n+  res[0] = o0;\n+  res[2] = o7;\n+  res[4] = o14;\n+  res[6] = o15;\n+}\n+\n+/* Vectorization produces .MASK_STORE, unrolling will unroll the two\n+   vector iterations.  FRE5 after that should be able to CSE\n+   out[7] and out[15], but leave out[0] and out[14] alone.  */\n+/* { dg-final { scan-tree-dump \" = o0_\\[0-9\\]+;\" \"fre5\" } } */\n+/* { dg-final { scan-tree-dump \" = 7;\" \"fre5\" } } */\n+/* { dg-final { scan-tree-dump \" = o14_\\[0-9\\]+;\" \"fre5\" } } */\n+/* { dg-final { scan-tree-dump \" = 15;\" \"fre5\" } } */"}, {"sha": "7d947b55a2780f07a5fd5f7eacec3d44ab6db9d0", "filename": "gcc/tree-ssa-sccvn.cc", "status": "modified", "additions": 198, "deletions": 57, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9837bc3ca1344c32aef7ba9f8fa1785063132e/gcc%2Ftree-ssa-sccvn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9837bc3ca1344c32aef7ba9f8fa1785063132e/gcc%2Ftree-ssa-sccvn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.cc?ref=bd9837bc3ca1344c32aef7ba9f8fa1785063132e", "patch": "@@ -1790,6 +1790,7 @@ struct pd_range\n struct pd_data\n {\n   tree rhs;\n+  HOST_WIDE_INT rhs_off;\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT size;\n };\n@@ -1816,6 +1817,7 @@ struct vn_walk_cb_data\n \tunsigned int pos = 0, prec = w.get_precision ();\n \tpd_data pd;\n \tpd.rhs = build_constructor (NULL_TREE, NULL);\n+\tpd.rhs_off = 0;\n \t/* When bitwise and with a constant is done on a memory load,\n \t   we don't really need all the bits to be defined or defined\n \t   to constants, we don't really care what is in the position\n@@ -1976,6 +1978,7 @@ vn_walk_cb_data::push_partial_def (pd_data pd,\n \n   bool pd_constant_p = (TREE_CODE (pd.rhs) == CONSTRUCTOR\n \t\t\t|| CONSTANT_CLASS_P (pd.rhs));\n+  pd_range *r;\n   if (partial_defs.is_empty ())\n     {\n       /* If we get a clobber upfront, fail.  */\n@@ -1989,65 +1992,70 @@ vn_walk_cb_data::push_partial_def (pd_data pd,\n       first_set = set;\n       first_base_set = base_set;\n       last_vuse_ptr = NULL;\n-      /* Continue looking for partial defs.  */\n-      return NULL;\n-    }\n-\n-  if (!known_ranges)\n-    {\n-      /* ???  Optimize the case where the 2nd partial def completes things.  */\n-      gcc_obstack_init (&ranges_obstack);\n-      known_ranges = splay_tree_new_with_allocator (pd_range_compare, 0, 0,\n-\t\t\t\t\t\t    pd_tree_alloc,\n-\t\t\t\t\t\t    pd_tree_dealloc, this);\n-      splay_tree_insert (known_ranges,\n-\t\t\t (splay_tree_key)&first_range.offset,\n-\t\t\t (splay_tree_value)&first_range);\n-    }\n-\n-  pd_range newr = { pd.offset, pd.size };\n-  splay_tree_node n;\n-  pd_range *r;\n-  /* Lookup the predecessor of offset + 1 and see if we need to merge.  */\n-  HOST_WIDE_INT loffset = newr.offset + 1;\n-  if ((n = splay_tree_predecessor (known_ranges, (splay_tree_key)&loffset))\n-      && ((r = (pd_range *)n->value), true)\n-      && ranges_known_overlap_p (r->offset, r->size + 1,\n-\t\t\t\t newr.offset, newr.size))\n-    {\n-      /* Ignore partial defs already covered.  Here we also drop shadowed\n-         clobbers arriving here at the floor.  */\n-      if (known_subrange_p (newr.offset, newr.size, r->offset, r->size))\n-\treturn NULL;\n-      r->size = MAX (r->offset + r->size, newr.offset + newr.size) - r->offset;\n+      r = &first_range;\n+      /* Go check if the first partial definition was a full one in case\n+\t the caller didn't optimize for this.  */\n     }\n   else\n     {\n-      /* newr.offset wasn't covered yet, insert the range.  */\n-      r = XOBNEW (&ranges_obstack, pd_range);\n-      *r = newr;\n-      splay_tree_insert (known_ranges, (splay_tree_key)&r->offset,\n-\t\t\t (splay_tree_value)r);\n-    }\n-  /* Merge r which now contains newr and is a member of the splay tree with\n-     adjacent overlapping ranges.  */\n-  pd_range *rafter;\n-  while ((n = splay_tree_successor (known_ranges, (splay_tree_key)&r->offset))\n-\t && ((rafter = (pd_range *)n->value), true)\n-\t && ranges_known_overlap_p (r->offset, r->size + 1,\n-\t\t\t\t    rafter->offset, rafter->size))\n-    {\n-      r->size = MAX (r->offset + r->size,\n-\t\t     rafter->offset + rafter->size) - r->offset;\n-      splay_tree_remove (known_ranges, (splay_tree_key)&rafter->offset);\n-    }\n-  /* If we get a clobber, fail.  */\n-  if (TREE_CLOBBER_P (pd.rhs))\n-    return (void *)-1;\n-  /* Non-constants are OK as long as they are shadowed by a constant.  */\n-  if (!pd_constant_p)\n-    return (void *)-1;\n-  partial_defs.safe_push (pd);\n+      if (!known_ranges)\n+\t{\n+\t  /* ???  Optimize the case where the 2nd partial def completes\n+\t     things.  */\n+\t  gcc_obstack_init (&ranges_obstack);\n+\t  known_ranges = splay_tree_new_with_allocator (pd_range_compare, 0, 0,\n+\t\t\t\t\t\t\tpd_tree_alloc,\n+\t\t\t\t\t\t\tpd_tree_dealloc, this);\n+\t  splay_tree_insert (known_ranges,\n+\t\t\t     (splay_tree_key)&first_range.offset,\n+\t\t\t     (splay_tree_value)&first_range);\n+\t}\n+\n+      pd_range newr = { pd.offset, pd.size };\n+      splay_tree_node n;\n+      /* Lookup the predecessor of offset + 1 and see if we need to merge.  */\n+      HOST_WIDE_INT loffset = newr.offset + 1;\n+      if ((n = splay_tree_predecessor (known_ranges, (splay_tree_key)&loffset))\n+\t  && ((r = (pd_range *)n->value), true)\n+\t  && ranges_known_overlap_p (r->offset, r->size + 1,\n+\t\t\t\t     newr.offset, newr.size))\n+\t{\n+\t  /* Ignore partial defs already covered.  Here we also drop shadowed\n+\t     clobbers arriving here at the floor.  */\n+\t  if (known_subrange_p (newr.offset, newr.size, r->offset, r->size))\n+\t    return NULL;\n+\t  r->size\n+\t    = MAX (r->offset + r->size, newr.offset + newr.size) - r->offset;\n+\t}\n+      else\n+\t{\n+\t  /* newr.offset wasn't covered yet, insert the range.  */\n+\t  r = XOBNEW (&ranges_obstack, pd_range);\n+\t  *r = newr;\n+\t  splay_tree_insert (known_ranges, (splay_tree_key)&r->offset,\n+\t\t\t     (splay_tree_value)r);\n+\t}\n+      /* Merge r which now contains newr and is a member of the splay tree with\n+\t adjacent overlapping ranges.  */\n+      pd_range *rafter;\n+      while ((n = splay_tree_successor (known_ranges,\n+\t\t\t\t\t(splay_tree_key)&r->offset))\n+\t     && ((rafter = (pd_range *)n->value), true)\n+\t     && ranges_known_overlap_p (r->offset, r->size + 1,\n+\t\t\t\t\trafter->offset, rafter->size))\n+\t{\n+\t  r->size = MAX (r->offset + r->size,\n+\t\t\t rafter->offset + rafter->size) - r->offset;\n+\t  splay_tree_remove (known_ranges, (splay_tree_key)&rafter->offset);\n+\t}\n+      /* If we get a clobber, fail.  */\n+      if (TREE_CLOBBER_P (pd.rhs))\n+\treturn (void *)-1;\n+      /* Non-constants are OK as long as they are shadowed by a constant.  */\n+      if (!pd_constant_p)\n+\treturn (void *)-1;\n+      partial_defs.safe_push (pd);\n+    }\n \n   /* Now we have merged newr into the range tree.  When we have covered\n      [offseti, sizei] then the tree will contain exactly one node which has\n@@ -2081,7 +2089,8 @@ vn_walk_cb_data::push_partial_def (pd_data pd,\n       else\n \t{\n \t  len = native_encode_expr (pd.rhs, this_buffer, bufsize,\n-\t\t\t\t    MAX (0, -pd.offset) / BITS_PER_UNIT);\n+\t\t\t\t    (MAX (0, -pd.offset)\n+\t\t\t\t     + pd.rhs_off) / BITS_PER_UNIT);\n \t  if (len <= 0\n \t      || len < (ROUND_UP (pd.size, BITS_PER_UNIT) / BITS_PER_UNIT\n \t\t\t- MAX (0, -pd.offset) / BITS_PER_UNIT))\n@@ -2906,6 +2915,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t{\n \t  pd_data pd;\n \t  pd.rhs = build_constructor (NULL_TREE, NULL);\n+\t  pd.rhs_off = 0;\n \t  pd.offset = offset2i;\n \t  pd.size = leni << LOG2_BITS_PER_UNIT;\n \t  return data->push_partial_def (pd, 0, 0, offseti, maxsizei);\n@@ -2955,6 +2965,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t by a later def.  */\n \t      pd_data pd;\n \t      pd.rhs = gimple_assign_rhs1 (def_stmt);\n+\t      pd.rhs_off = 0;\n \t      pd.offset = offset2i;\n \t      pd.size = size2i;\n \t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),\n@@ -3107,6 +3118,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      if (TREE_CODE (rhs) == SSA_NAME)\n \t\trhs = SSA_VAL (rhs);\n \t      pd.rhs = rhs;\n+\t      pd.rhs_off = 0;\n \t      pd.offset = offset2i;\n \t      pd.size = size2i;\n \t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),\n@@ -3186,6 +3198,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t    {\n \t      pd_data pd;\n \t      pd.rhs = SSA_VAL (def_rhs);\n+\t      pd.rhs_off = 0;\n \t      pd.offset = offset2i;\n \t      pd.size = size2i;\n \t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),\n@@ -3195,6 +3208,133 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t}\n     }\n \n+  /* 4b) Assignment done via one of the vectorizer internal store\n+     functions where we may be able to access pieces from or we can\n+     combine to a larger entity.  */\n+  else if (known_eq (ref->size, maxsize)\n+\t   && is_gimple_reg_type (vr->type)\n+\t   && !reverse_storage_order_for_component_p (vr->operands)\n+\t   && !contains_storage_order_barrier_p (vr->operands)\n+\t   && is_gimple_call (def_stmt)\n+\t   && gimple_call_internal_p (def_stmt)\n+\t   && internal_store_fn_p (gimple_call_internal_fn (def_stmt)))\n+    {\n+      gcall *call = as_a <gcall *> (def_stmt);\n+      internal_fn fn = gimple_call_internal_fn (call);\n+      tree def_rhs = gimple_call_arg (call,\n+\t\t\t\t      internal_fn_stored_value_index (fn));\n+      def_rhs = vn_valueize (def_rhs);\n+      if (TREE_CODE (def_rhs) != VECTOR_CST)\n+\treturn (void *)-1;\n+\n+      tree mask = NULL_TREE, len = NULL_TREE, bias = NULL_TREE;\n+      switch (fn)\n+\t{\n+\tcase IFN_MASK_STORE:\n+\t  mask = gimple_call_arg (call, internal_fn_mask_index (fn));\n+\t  mask = vn_valueize (mask);\n+\t  if (TREE_CODE (mask) != VECTOR_CST)\n+\t    return (void *)-1;\n+\t  break;\n+\tcase IFN_LEN_STORE:\n+\t  len = gimple_call_arg (call, 2);\n+\t  bias = gimple_call_arg (call, 4);\n+\t  if (!tree_fits_uhwi_p (len) || !tree_fits_shwi_p (bias))\n+\t    return (void *)-1;\n+\t  break;\n+\tdefault:\n+\t  return (void *)-1;\n+\t}\n+      ao_ref_init_from_ptr_and_size (&lhs_ref,\n+\t\t\t\t     vn_valueize (gimple_call_arg (call, 0)),\n+\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (def_rhs)));\n+      tree base2;\n+      poly_int64 offset2, size2, maxsize2;\n+      HOST_WIDE_INT offset2i, size2i, offseti;\n+      base2 = ao_ref_base (&lhs_ref);\n+      offset2 = lhs_ref.offset;\n+      size2 = lhs_ref.size;\n+      maxsize2 = lhs_ref.max_size;\n+      if (known_size_p (maxsize2)\n+\t  && known_eq (maxsize2, size2)\n+\t  && adjust_offsets_for_equal_base_address (base, &offset,\n+\t\t\t\t\t\t    base2, &offset2)\n+\t  && maxsize.is_constant (&maxsizei)\n+\t  && offset.is_constant (&offseti)\n+\t  && offset2.is_constant (&offset2i)\n+\t  && size2.is_constant (&size2i))\n+\t{\n+\t  if (!ranges_maybe_overlap_p (offset, maxsize, offset2, size2))\n+\t    /* Poor-mans disambiguation.  */\n+\t    return NULL;\n+\t  else if (ranges_known_overlap_p (offset, maxsize, offset2, size2))\n+\t    {\n+\t      pd_data pd;\n+\t      pd.rhs = def_rhs;\n+\t      tree aa = gimple_call_arg (call, 1);\n+\t      alias_set_type set = get_deref_alias_set (TREE_TYPE (aa));\n+\t      tree vectype = TREE_TYPE (def_rhs);\n+\t      unsigned HOST_WIDE_INT elsz\n+\t\t= tree_to_uhwi (TYPE_SIZE (TREE_TYPE (vectype)));\n+\t      if (mask)\n+\t\t{\n+\t\t  HOST_WIDE_INT start = 0, len = 0;\n+\t\t  unsigned mask_idx = 0;\n+\t\t  do\n+\t\t    {\n+\t\t      if (integer_zerop (VECTOR_CST_ELT (mask, mask_idx)))\n+\t\t\t{\n+\t\t\t  if (len != 0)\n+\t\t\t    {\n+\t\t\t      pd.rhs_off = start;\n+\t\t\t      pd.offset = offset2i + start;\n+\t\t\t      pd.size = len;\n+\t\t\t      if (ranges_known_overlap_p\n+\t\t\t\t    (offset, maxsize, pd.offset, pd.size))\n+\t\t\t\t{\n+\t\t\t\t  void *res = data->push_partial_def\n+\t\t\t\t\t      (pd, set, set, offseti, maxsizei);\n+\t\t\t\t  if (res != NULL)\n+\t\t\t\t    return res;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  start = (mask_idx + 1) * elsz;\n+\t\t\t  len = 0;\n+\t\t\t}\n+\t\t      else\n+\t\t\tlen += elsz;\n+\t\t      mask_idx++;\n+\t\t    }\n+\t\t  while (known_lt (mask_idx, TYPE_VECTOR_SUBPARTS (vectype)));\n+\t\t  if (len != 0)\n+\t\t    {\n+\t\t      pd.rhs_off = start;\n+\t\t      pd.offset = offset2i + start;\n+\t\t      pd.size = len;\n+\t\t      if (ranges_known_overlap_p (offset, maxsize,\n+\t\t\t\t\t\t  pd.offset, pd.size))\n+\t\t\treturn data->push_partial_def (pd, set, set,\n+\t\t\t\t\t\t       offseti, maxsizei);\n+\t\t    }\n+\t\t}\n+\t      else if (fn == IFN_LEN_STORE)\n+\t\t{\n+\t\t  pd.rhs_off = 0;\n+\t\t  pd.offset = offset2i;\n+\t\t  pd.size = (tree_to_uhwi (len)\n+\t\t\t     + -tree_to_shwi (bias)) * BITS_PER_UNIT;\n+\t\t  if (ranges_known_overlap_p (offset, maxsize,\n+\t\t\t\t\t      pd.offset, pd.size))\n+\t\t    return data->push_partial_def (pd, set, set,\n+\t\t\t\t\t\t   offseti, maxsizei);\n+\t\t}\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      return NULL;\n+\t    }\n+\t}\n+    }\n+\n   /* 5) For aggregate copies translate the reference through them if\n      the copy kills ref.  */\n   else if (data->vn_walk_kind == VN_WALKREWRITE\n@@ -3327,6 +3467,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t    {\n \t      pd_data pd;\n \t      pd.rhs = val;\n+\t      pd.rhs_off = 0;\n \t      pd.offset = 0;\n \t      pd.size = maxsizei;\n \t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),"}]}