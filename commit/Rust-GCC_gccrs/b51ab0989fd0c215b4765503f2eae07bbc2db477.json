{"sha": "b51ab0989fd0c215b4765503f2eae07bbc2db477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUxYWIwOTg5ZmQwYzIxNWI0NzY1NTAzZjJlYWUwN2JiYzJkYjQ3Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-13T19:50:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-13T19:50:49Z"}, "message": "(FLOAT_WORDS_BIG_ENDIAN...\n\n(FLOAT_WORDS_BIG_ENDIAN, HOST_FLOAT_WORDS_BIG_ENDIAN): Use everywhere\nin place of WORDS_BIG_ENDIAN, HOST_WORDS_BIG_ENDIAN, except in\nreference to endian-ness of integers.\n(etrunci, etruncui, efixi, efixui, ereal_from_int, ereal_to_int, ltoe,\nultoe, eifrac, euifrac): Change `long' to `HOST_WIDE_INT'.\n\nFrom-SVN: r5776", "tree": {"sha": "ad9bbf436d8d7e4920cb6773c8d450e2d4a22e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad9bbf436d8d7e4920cb6773c8d450e2d4a22e36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b51ab0989fd0c215b4765503f2eae07bbc2db477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51ab0989fd0c215b4765503f2eae07bbc2db477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b51ab0989fd0c215b4765503f2eae07bbc2db477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51ab0989fd0c215b4765503f2eae07bbc2db477/comments", "author": null, "committer": null, "parents": [{"sha": "91d6120782050bdad564ebaa258195b74ec676cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d6120782050bdad564ebaa258195b74ec676cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d6120782050bdad564ebaa258195b74ec676cd"}], "stats": {"total": 129, "additions": 72, "deletions": 57}, "files": [{"sha": "2dfac5cb134fbfdc7f6769749da99da0a8409eb8", "filename": "gcc/real.c", "status": "modified", "additions": 72, "deletions": 57, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b51ab0989fd0c215b4765503f2eae07bbc2db477/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b51ab0989fd0c215b4765503f2eae07bbc2db477/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=b51ab0989fd0c215b4765503f2eae07bbc2db477", "patch": "@@ -92,7 +92,19 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n \n    The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support\n    and may deactivate XFmode since `long double' is used to refer\n-   to both modes.    */\n+   to both modes.\n+\n+   The macros FLOAT_WORDS_BIG_ENDIAN, HOST_FLOAT_WORDS_BIG_ENDIAN,\n+   contributed by Richard Earnshaw <Richard.Earnshaw@cl.cam.ac.uk>,\n+   separate the floating point unit's endian-ness from that of\n+   the integer addressing.  This permits one to define a big-endian\n+   FPU on a little-endian machine (e.g., ARM).  An extension to\n+   BYTES_BIG_ENDIAN may be required for some machines in the future.\n+   These optional macros may be defined in tm.h.  In real.h, they\n+   default to WORDS_BIG_ENDIAN, etc., so there is no need to define\n+   them for any normal host or target machine on which the floats\n+   and the integers have the same endian-ness.   */\n+\n \n /* The following converts gcc macros into the ones used by this file.  */\n \n@@ -109,7 +121,7 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n #define IBM 1\n #else /* it's also not an IBM */\n #if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#if WORDS_BIG_ENDIAN\n+#if FLOAT_WORDS_BIG_ENDIAN\n /* Motorola IEEE, high order words come first (Sun workstation): */\n #define MIEEE 1\n #else /* not big-endian */\n@@ -139,7 +151,7 @@ unknown arithmetic type\n #define IBM 1\n #else /* it's also not an IBM */\n #if HOST_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#ifdef HOST_WORDS_BIG_ENDIAN\n+#if HOST_FLOAT_WORDS_BIG_ENDIAN\n #define MIEEE 1\n #else /* not big-endian */\n #define IBMPC 1\n@@ -252,7 +264,7 @@ unknown arithmetic type\n /* Emulator uses target format internally\n    but host stores it in host endian-ness. */\n \n-#if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n+#if HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN\n #define GET_REAL(r,e) e53toe ((r), (e))\n #define PUT_REAL(e,r) etoe53 ((e), (r))\n \n@@ -326,8 +338,9 @@ void enan ();\n extern unsigned EMUSHORT ezero[], ehalf[], eone[], etwo[];\n extern unsigned EMUSHORT elog2[], esqrt2[];\n \f\n-/* Pack output array with 32-bit numbers obtained from\n-   array containing 16-bit numbers, swapping ends if required. */\n+/* Copy 32-bit numbers obtained from array containing 16-bit numbers,\n+   swapping ends if required, into output array of longs.  The\n+   result is normally passed to fprintf by the ASM_OUTPUT_ macros.   */\n void \n endian (e, x, mode)\n      unsigned EMUSHORT e[];\n@@ -336,7 +349,7 @@ endian (e, x, mode)\n {\n   unsigned long th, t;\n \n-#if WORDS_BIG_ENDIAN\n+#if FLOAT_WORDS_BIG_ENDIAN\n   switch (mode)\n     {\n \n@@ -517,7 +530,7 @@ etrunci (x)\n {\n   unsigned EMUSHORT f[NE], g[NE];\n   REAL_VALUE_TYPE r;\n-  long l;\n+  HOST_WIDE_INT l;\n \n   GET_REAL (&x, g);\n #ifdef NANS\n@@ -540,7 +553,7 @@ etruncui (x)\n {\n   unsigned EMUSHORT f[NE], g[NE];\n   REAL_VALUE_TYPE r;\n-  unsigned long l;\n+  unsigned HOST_WIDE_INT l;\n \n   GET_REAL (&x, g);\n #ifdef NANS\n@@ -616,12 +629,12 @@ ereal_negate (x)\n /* Round real toward zero to HOST_WIDE_INT\n  * implements REAL_VALUE_FIX (x).\n  */\n-long\n+HOST_WIDE_INT\n efixi (x)\n      REAL_VALUE_TYPE x;\n {\n   unsigned EMUSHORT f[NE], g[NE];\n-  long l;\n+  HOST_WIDE_INT l;\n \n   GET_REAL (&x, f);\n #ifdef NANS\n@@ -639,12 +652,12 @@ efixi (x)\n  * implements  REAL_VALUE_UNSIGNED_FIX (x).\n  * Negative input returns zero.\n  */\n-unsigned long\n+unsigned HOST_WIDE_INT\n efixui (x)\n      REAL_VALUE_TYPE x;\n {\n   unsigned EMUSHORT f[NE], g[NE];\n-  unsigned long l;\n+  unsigned HOST_WIDE_INT l;\n \n   GET_REAL (&x, f);\n #ifdef NANS\n@@ -664,10 +677,10 @@ efixui (x)\n void \n ereal_from_int (d, i, j)\n      REAL_VALUE_TYPE *d;\n-     long i, j;\n+     HOST_WIDE_INT i, j;\n {\n   unsigned EMUSHORT df[NE], dg[NE];\n-  long low, high;\n+  HOST_WIDE_INT low, high;\n   int sign;\n \n   sign = 0;\n@@ -682,7 +695,7 @@ ereal_from_int (d, i, j)\n       else\n \thigh += 1;\n     }\n-  eldexp (eone, HOST_BITS_PER_LONG, df);\n+  eldexp (eone, HOST_BITS_PER_WIDE_INT, df);\n   ultoe (&high, dg);\n   emul (dg, df, dg);\n   ultoe (&low, df);\n@@ -698,14 +711,14 @@ ereal_from_int (d, i, j)\n void \n ereal_from_uint (d, i, j)\n      REAL_VALUE_TYPE *d;\n-     unsigned long i, j;\n+     unsigned HOST_WIDE_INT i, j;\n {\n   unsigned EMUSHORT df[NE], dg[NE];\n-  unsigned long low, high;\n+  unsigned HOST_WIDE_INT low, high;\n \n   low = i;\n   high = j;\n-  eldexp (eone, HOST_BITS_PER_LONG, df);\n+  eldexp (eone, HOST_BITS_PER_WIDE_INT, df);\n   ultoe (&high, dg);\n   emul (dg, df, dg);\n   ultoe (&low, df);\n@@ -718,7 +731,7 @@ ereal_from_uint (d, i, j)\n  */\n void \n ereal_to_int (low, high, rr)\n-     long *low, *high;\n+     HOST_WIDE_INT *low, *high;\n      REAL_VALUE_TYPE rr;\n {\n   unsigned EMUSHORT d[NE], df[NE], dg[NE], dh[NE];\n@@ -741,7 +754,7 @@ ereal_to_int (low, high, rr)\n       eneg (d);\n       s = 1;\n     }\n-  eldexp (eone, HOST_BITS_PER_LONG, df);\n+  eldexp (eone, HOST_BITS_PER_WIDE_INT, df);\n   ediv (df, d, dg);\t\t/* dg = d / 2^32 is the high word */\n   euifrac (dg, high, dh);\n   emul (df, dh, dg);\t\t/* fractional part is the low word */\n@@ -1035,8 +1048,8 @@ ereal_isneg (x)\n  *\tediv (a, b, c)\t\tc = b / a\n  *\tefloor (a, b)\t\ttruncate to integer, toward -infinity\n  *\tefrexp (a, exp, s)\textract exponent and significand\n- *\teifrac (e, &l, frac)    e to long integer and e type fraction\n- *\teuifrac (e, &l, frac)   e to unsigned long integer and e type fraction\n+ *\teifrac (e, &l, frac)    e to HOST_WIDE_INT and e type fraction\n+ *\teuifrac (e, &l, frac)   e to unsigned HOST_WIDE_INT and e type fraction\n  *\teinfin (e)\t\tset e to infinity, leaving its sign alone\n  *\teldexp (a, n, b)\tmultiply by 2**n\n  *\temov (a, b)\t\tb = a\n@@ -1052,8 +1065,8 @@ ereal_isneg (x)\n  *\tetoe24 (e, &f)\t\tconvert e type to IEEE single precision\n  *\tetoe53 (e, &d)\t\tconvert e type to IEEE double precision\n  *\tetoe64 (e, &d)\t\tconvert e type to IEEE long double precision\n- *\tltoe (&l, e)\t\tlong (32 bit) integer to e type\n- *\tultoe (&l, e)\t\tunsigned long (32 bit) integer to e type\n+ *\tltoe (&l, e)\t\tHOST_WIDE_INT to e type\n+ *\tultoe (&l, e)\t\tunsigned HOST_WIDE_INT to e type\n  *      eisneg (e)              1 if sign bit of e != 0, else 0\n  *      eisinf (e)              1 if e has maximum exponent (non-IEEE)\n  *\t\t\t\tor is infinite (IEEE)\n@@ -3720,35 +3733,35 @@ eround (x, y)\n \n \n /*\n-; convert long integer to e type\n+; convert HOST_WIDE_INT to e type\n ;\n-;\tlong l;\n+;\tHOST_WIDE_INT l;\n ;\tunsigned EMUSHORT x[NE];\n ;\tltoe (&l, x);\n ; note &l is the memory address of l\n */\n void \n ltoe (lp, y)\n-     long *lp;\t\t\t/* lp is the memory address of a long integer */\n-     unsigned EMUSHORT *y;\t\t/* y is the address of a short */\n+     HOST_WIDE_INT *lp;\n+     unsigned EMUSHORT *y;\n {\n   unsigned EMUSHORT yi[NI];\n-  unsigned long ll;\n+  unsigned HOST_WIDE_INT ll;\n   int k;\n \n   ecleaz (yi);\n   if (*lp < 0)\n     {\n       /* make it positive */\n-      ll = (unsigned long) (-(*lp));\n+      ll = (unsigned HOST_WIDE_INT) (-(*lp));\n       yi[0] = 0xffff;\t\t/* put correct sign in the e type number */\n     }\n   else\n     {\n-      ll = (unsigned long) (*lp);\n+      ll = (unsigned HOST_WIDE_INT) (*lp);\n     }\n   /* move the long integer to yi significand area */\n-#if HOST_BITS_PER_LONG == 64\n+#if HOST_BITS_PER_WIDE_INT == 64\n   yi[M] = (unsigned EMUSHORT) (ll >> 48);\n   yi[M + 1] = (unsigned EMUSHORT) (ll >> 32);\n   yi[M + 2] = (unsigned EMUSHORT) (ll >> 16);\n@@ -3768,27 +3781,27 @@ ltoe (lp, y)\n }\n \n /*\n-; convert unsigned long integer to e type\n+; convert unsigned HOST_WIDE_INT to e type\n ;\n-;\tunsigned long l;\n+;\tunsigned HOST_WIDE_INT l;\n ;\tunsigned EMUSHORT x[NE];\n ;\tltox (&l, x);\n ; note &l is the memory address of l\n */\n void \n ultoe (lp, y)\n-     unsigned long *lp;\t\t/* lp is the memory address of a long integer */\n-     unsigned EMUSHORT *y;\t\t/* y is the address of a short */\n+     unsigned HOST_WIDE_INT *lp;\n+     unsigned EMUSHORT *y;\n {\n   unsigned EMUSHORT yi[NI];\n-  unsigned long ll;\n+  unsigned HOST_WIDE_INT ll;\n   int k;\n \n   ecleaz (yi);\n   ll = *lp;\n \n   /* move the long integer to ayi significand area */\n-#if HOST_BITS_PER_LONG == 64\n+#if HOST_BITS_PER_WIDE_INT == 64\n   yi[M] = (unsigned EMUSHORT) (ll >> 48);\n   yi[M + 1] = (unsigned EMUSHORT) (ll >> 32);\n   yi[M + 2] = (unsigned EMUSHORT) (ll >> 16);\n@@ -3809,9 +3822,9 @@ ultoe (lp, y)\n \n \n /*\n-;\tFind long integer and fractional parts\n+;\tFind signed HOST_WIDE_INT integer and floating point fractional parts\n \n-;\tlong i;\n+;\tHOST_WIDE_INT i;\n ;\tunsigned EMUSHORT x[NE], frac[NE];\n ;\txifrac (x, &i, frac);\n \n@@ -3821,12 +3834,12 @@ the positive fractional part of abs (x).\n void \n eifrac (x, i, frac)\n      unsigned EMUSHORT *x;\n-     long *i;\n+     HOST_WIDE_INT *i;\n      unsigned EMUSHORT *frac;\n {\n   unsigned EMUSHORT xi[NI];\n   int j, k;\n-  unsigned long ll;\n+  unsigned HOST_WIDE_INT ll;\n \n   emovi (x, xi);\n   k = (int) xi[E] - (EXONE - 1);\n@@ -3837,14 +3850,14 @@ eifrac (x, i, frac)\n       emovo (xi, frac);\n       return;\n     }\n-  if (k > (HOST_BITS_PER_LONG - 1))\n+  if (k > (HOST_BITS_PER_WIDE_INT - 1))\n     {\n       /* long integer overflow: output large integer\n \t and correct fraction  */\n       if (xi[0])\n-\t*i = ((unsigned long) 1) << (HOST_BITS_PER_LONG - 1);\n+\t*i = ((unsigned HOST_WIDE_INT) 1) << (HOST_BITS_PER_WIDE_INT - 1);\n       else\n-\t*i = (((unsigned long) 1) << (HOST_BITS_PER_LONG - 1)) - 1;\n+\t*i = (((unsigned HOST_WIDE_INT) 1) << (HOST_BITS_PER_WIDE_INT - 1)) - 1;\n       eshift (xi, k);\n       if (extra_warnings)\n \twarning (\"overflow on truncation to integer\");\n@@ -3871,7 +3884,7 @@ eifrac (x, i, frac)\n       {\n         /* shift not more than 16 bits */\n           eshift (xi, k);\n-        *i = (long) xi[M] & 0xffff;\n+        *i = (HOST_WIDE_INT) xi[M] & 0xffff;\n         if (xi[0])\n \t  *i = -(*i);\n       }\n@@ -3887,17 +3900,17 @@ eifrac (x, i, frac)\n }\n \n \n-/* Find unsigned long integer and fractional parts.\n+/* Find unsigned HOST_WIDE_INT integer and floating point fractional parts.\n    A negative e type input yields integer output = 0\n    but correct fraction.  */\n \n void \n euifrac (x, i, frac)\n      unsigned EMUSHORT *x;\n-     unsigned long *i;\n+     unsigned HOST_WIDE_INT *i;\n      unsigned EMUSHORT *frac;\n {\n-  unsigned long ll;\n+  unsigned HOST_WIDE_INT ll;\n   unsigned EMUSHORT xi[NI];\n   int j, k;\n \n@@ -3910,7 +3923,7 @@ euifrac (x, i, frac)\n       emovo (xi, frac);\n       return;\n     }\n-  if (k > HOST_BITS_PER_LONG)\n+  if (k > HOST_BITS_PER_WIDE_INT)\n     {\n       /* Long integer overflow: output large integer\n \t and correct fraction.\n@@ -3941,7 +3954,7 @@ euifrac (x, i, frac)\n     {\n       /* shift not more than 16 bits */\n       eshift (xi, k);\n-      *i = (long) xi[M] & 0xffff;\n+      *i = (HOST_WIDE_INT) xi[M] & 0xffff;\n     }\n \n   if (xi[0])  /* A negative value yields unsigned integer 0. */\n@@ -5063,7 +5076,7 @@ efrexp (x, exp, s)\n \n \n /* unsigned EMUSHORT x[], y[];\n- * long pwr2;\n+ * int pwr2;\n  *\n  * eldexp (x, pwr2, y);\n  *\n@@ -5619,7 +5632,7 @@ ereal_from_float (f)\n \n   /* Convert 32 bit integer to array of 16 bit pieces in target machine order.\n    This is the inverse operation to what the function `endian' does.  */\n-#if WORDS_BIG_ENDIAN\n+#if FLOAT_WORDS_BIG_ENDIAN\n   s[0] = (unsigned EMUSHORT) (f >> 16);\n   s[1] = (unsigned EMUSHORT) f;\n #else\n@@ -5638,7 +5651,7 @@ ereal_from_float (f)\n    This is the inverse of the function `etardouble' invoked by\n    REAL_VALUE_TO_TARGET_DOUBLE.\n \n-   The DFmode is stored as an array of longs (i.e., HOST_WIDE_INTs)\n+   The DFmode is stored as an array of long ints\n    with 32 bits of the value per each long.  The first element\n    of the input array holds the bits that would come first in the\n    target computer's memory.  */\n@@ -5653,7 +5666,7 @@ ereal_from_double (d)\n \n   /* Convert array of 32 bit pieces to equivalent array of 16 bit pieces.\n    This is the inverse of `endian'.   */\n-#if WORDS_BIG_ENDIAN\n+#if FLOAT_WORDS_BIG_ENDIAN\n   s[0] = (unsigned EMUSHORT) (d[0] >> 16);\n   s[1] = (unsigned EMUSHORT) d[0];\n   s[2] = (unsigned EMUSHORT) (d[1] >> 16);\n@@ -5672,7 +5685,9 @@ ereal_from_double (d)\n }\n \n \n-/* Convert target computer unsigned 64-bit integer to e-type. */\n+/* Convert target computer unsigned 64-bit integer to e-type.\n+   The endian-ness of DImode follows the convention for integers,\n+   so we use WORDS_BIG_ENDIAN here, not FLOAT_WORDS_BIG_ENDIAN.  */\n \n void\n uditoe (di, e)"}]}