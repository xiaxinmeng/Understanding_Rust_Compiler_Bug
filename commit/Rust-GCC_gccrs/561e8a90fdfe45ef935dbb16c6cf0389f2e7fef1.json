{"sha": "561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxZThhOTBmZGZlNDVlZjkzNWRiYjE2YzZjZjAzODlmMmU3ZmVmMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-05-24T14:02:12Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-24T14:02:12Z"}, "message": "re PR middle-end/32018 (ICE on optimization)\n\n\tPR middle-end/32018\n\t* tree-ssa-threadupdate.c (thread_through_loop_header): Use\n\tset_loop_copy.\n\t(thread_through_all_blocks): Call initialize_original_copy_tables\n\tand free_original_copy_tables.\n\t* cfgloopmanip.c (duplicate_loop, duplicate_loop_to_header_edge):\n\tUse set_loop_copy.\n\t* tree-cfg.c (tree_duplicate_sese_region): Ditto.\n\t* cfghooks.c (duplicate_block): Use get_loop_copy.\n\t* cfg.c: Include cfgloop.h.\n\t(loop_copy): New hash table.\n\t(initialize_original_copy_tables): Initialize loop_copy table.\n\t(free_original_copy_tables): Free loop_copy table.\n\t(copy_original_table_clear, copy_original_table_set,\n\tset_loop_copy, get_loop_copy): New functions.\n\t(set_bb_original, set_bb_copy): Use copy_original_table_set.\n\t* cfgloop.h (struct loop): Remove copy field.\n\t* Makefile.in (cfg.o): Add CFGLOOP_H dependency.\n\t* basic-block.h (set_loop_copy, get_loop_copy): Declare.\n\nFrom-SVN: r125024", "tree": {"sha": "9bb72d30323dfced6a574b1c6fc4064792090034", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb72d30323dfced6a574b1c6fc4064792090034"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/comments", "author": null, "committer": null, "parents": [{"sha": "66da42bc85b1004d6ad17b514673a9eea6fa0eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66da42bc85b1004d6ad17b514673a9eea6fa0eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66da42bc85b1004d6ad17b514673a9eea6fa0eb2"}], "stats": {"total": 173, "additions": 121, "deletions": 52}, "files": [{"sha": "5b4258a9894c77d6ab9b23bc36bb5970482b4c08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -1,3 +1,25 @@\n+2007-05-24  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR middle-end/32018\n+\t* tree-ssa-threadupdate.c (thread_through_loop_header): Use\n+\tset_loop_copy.\n+\t(thread_through_all_blocks): Call initialize_original_copy_tables\n+\tand free_original_copy_tables.\n+\t* cfgloopmanip.c (duplicate_loop, duplicate_loop_to_header_edge):\n+\tUse set_loop_copy.\n+\t* tree-cfg.c (tree_duplicate_sese_region): Ditto.\n+\t* cfghooks.c (duplicate_block): Use get_loop_copy.\n+\t* cfg.c: Include cfgloop.h.\n+\t(loop_copy): New hash table.\n+\t(initialize_original_copy_tables): Initialize loop_copy table.\n+\t(free_original_copy_tables): Free loop_copy table.\n+\t(copy_original_table_clear, copy_original_table_set,\n+\tset_loop_copy, get_loop_copy): New functions.\n+\t(set_bb_original, set_bb_copy): Use copy_original_table_set.\n+\t* cfgloop.h (struct loop): Remove copy field.\n+\t* Makefile.in (cfg.o): Add CFGLOOP_H dependency.\n+\t* basic-block.h (set_loop_copy, get_loop_copy): Declare.\n+\n 2007-05-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (ix86_handle_option): Handle SSE4.1 for"}, {"sha": "8fd13294eb6da4a9372049553796b06ecdf1e70f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -2517,7 +2517,8 @@ flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(EXPR_H) $(TM_P_H) $(OBSTACK_H) $(SPLAY_TREE_H) $(TIMEVAR_H) tree-pass.h\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    $(REGS_H) hard-reg-set.h output.h toplev.h $(FUNCTION_H) except.h $(GGC_H) \\\n-   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h $(HASHTAB_H)\n+   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h $(HASHTAB_H) \\\n+   $(CFGLOOP_H)\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h $(CFGLOOP_H)\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\"}, {"sha": "ce0aba06ade1896e1ad77055bae198142bf87b28", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -988,6 +988,9 @@ extern void set_bb_original (basic_block, basic_block);\n extern basic_block get_bb_original (basic_block);\n extern void set_bb_copy (basic_block, basic_block);\n extern basic_block get_bb_copy (basic_block);\n+void set_loop_copy (struct loop *, struct loop *);\n+struct loop *get_loop_copy (struct loop *);\n+\n \n extern rtx insert_insn_end_bb_new (rtx, basic_block);\n "}, {"sha": "63d053067fda39c50bb055b419eb2309dd4dd21d", "filename": "gcc/cfg.c", "status": "modified", "additions": 83, "deletions": 36, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -66,6 +66,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"hashtab.h\"\n #include \"alloc-pool.h\"\n+#include \"cfgloop.h\"\n \n /* The obstack on which the flow graph components are allocated.  */\n \n@@ -1027,6 +1028,9 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n    copies.  */\n static htab_t bb_original;\n static htab_t bb_copy;\n+\n+/* And between loops and copies.  */\n+static htab_t loop_copy;\n static alloc_pool original_copy_bb_pool;\n \n struct htab_bb_copy_original_entry\n@@ -1068,6 +1072,7 @@ initialize_original_copy_tables (void)\n   bb_original = htab_create (10, bb_copy_original_hash,\n \t\t\t     bb_copy_original_eq, NULL);\n   bb_copy = htab_create (10, bb_copy_original_hash, bb_copy_original_eq, NULL);\n+  loop_copy = htab_create (10, bb_copy_original_hash, bb_copy_original_eq, NULL);\n }\n \n /* Free the data structures to maintain mapping between blocks and\n@@ -1078,35 +1083,64 @@ free_original_copy_tables (void)\n   gcc_assert (original_copy_bb_pool);\n   htab_delete (bb_copy);\n   htab_delete (bb_original);\n+  htab_delete (loop_copy);\n   free_alloc_pool (original_copy_bb_pool);\n   bb_copy = NULL;\n   bb_original = NULL;\n+  loop_copy = NULL;\n   original_copy_bb_pool = NULL;\n }\n \n+/* Removes the value associated with OBJ from table TAB.  */\n+\n+static void\n+copy_original_table_clear (htab_t tab, unsigned obj)\n+{\n+  void **slot;\n+  struct htab_bb_copy_original_entry key, *elt;\n+\n+  if (!original_copy_bb_pool)\n+    return;\n+\n+  key.index1 = obj;\n+  slot = htab_find_slot (tab, &key, NO_INSERT);\n+  if (!slot)\n+    return;\n+\n+  elt = *slot;\n+  htab_clear_slot (tab, slot);\n+  pool_free (original_copy_bb_pool, elt);\n+}\n+\n+/* Sets the value associated with OBJ in table TAB to VAL.\n+   Do nothing when data structures are not initialized.  */\n+\n+static void\n+copy_original_table_set (htab_t tab, unsigned obj, unsigned val)\n+{\n+  struct htab_bb_copy_original_entry **slot;\n+  struct htab_bb_copy_original_entry key;\n+\n+  if (!original_copy_bb_pool)\n+    return;\n+\n+  key.index1 = obj;\n+  slot = (struct htab_bb_copy_original_entry **)\n+\t\thtab_find_slot (tab, &key, INSERT);\n+  if (!*slot)\n+    {\n+      *slot = pool_alloc (original_copy_bb_pool);\n+      (*slot)->index1 = obj;\n+    }\n+  (*slot)->index2 = val;\n+}\n+\n /* Set original for basic block.  Do nothing when data structures are not\n    initialized so passes not needing this don't need to care.  */\n void\n set_bb_original (basic_block bb, basic_block original)\n {\n-  if (original_copy_bb_pool)\n-    {\n-      struct htab_bb_copy_original_entry **slot;\n-      struct htab_bb_copy_original_entry key;\n-\n-      key.index1 = bb->index;\n-      slot =\n-\t(struct htab_bb_copy_original_entry **) htab_find_slot (bb_original,\n-\t\t\t\t\t\t\t       &key, INSERT);\n-      if (*slot)\n-\t(*slot)->index2 = original->index;\n-      else\n-\t{\n-\t  *slot = pool_alloc (original_copy_bb_pool);\n-\t  (*slot)->index1 = bb->index;\n-\t  (*slot)->index2 = original->index;\n-\t}\n-    }\n+  copy_original_table_set (bb_original, bb->index, original->index);\n }\n \n /* Get the original basic block.  */\n@@ -1131,24 +1165,7 @@ get_bb_original (basic_block bb)\n void\n set_bb_copy (basic_block bb, basic_block copy)\n {\n-  if (original_copy_bb_pool)\n-    {\n-      struct htab_bb_copy_original_entry **slot;\n-      struct htab_bb_copy_original_entry key;\n-\n-      key.index1 = bb->index;\n-      slot =\n-\t(struct htab_bb_copy_original_entry **) htab_find_slot (bb_copy,\n-\t\t\t\t\t\t\t       &key, INSERT);\n-      if (*slot)\n-\t(*slot)->index2 = copy->index;\n-      else\n-\t{\n-\t  *slot = pool_alloc (original_copy_bb_pool);\n-\t  (*slot)->index1 = bb->index;\n-\t  (*slot)->index2 = copy->index;\n-\t}\n-    }\n+  copy_original_table_set (bb_copy, bb->index, copy->index);\n }\n \n /* Get the copy of basic block.  */\n@@ -1167,3 +1184,33 @@ get_bb_copy (basic_block bb)\n   else\n     return NULL;\n }\n+\n+/* Set copy for LOOP to COPY.  Do nothing when data structures are not\n+   initialized so passes not needing this don't need to care.  */\n+\n+void\n+set_loop_copy (struct loop *loop, struct loop *copy)\n+{\n+  if (!copy)\n+    copy_original_table_clear (loop_copy, loop->num);\n+  else\n+    copy_original_table_set (loop_copy, loop->num, copy->num);\n+}\n+\n+/* Get the copy of LOOP.  */\n+\n+struct loop *\n+get_loop_copy (struct loop *loop)\n+{\n+  struct htab_bb_copy_original_entry *entry;\n+  struct htab_bb_copy_original_entry key;\n+\n+  gcc_assert (original_copy_bb_pool);\n+\n+  key.index1 = loop->num;\n+  entry = (struct htab_bb_copy_original_entry *) htab_find (loop_copy, &key);\n+  if (entry)\n+    return get_loop (entry->index2);\n+  else\n+    return NULL;\n+}"}, {"sha": "51405bb923a364d77bfa37c467fdd8fa9aaff905", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -928,9 +928,8 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n   if (current_loops != NULL)\n     {\n       struct loop *cloop = bb->loop_father;\n-      if (cloop->copy)\n-\tcloop = cloop->copy;\n-      add_bb_to_loop (new_bb, cloop);\n+      struct loop *copy = get_loop_copy (cloop);\n+      add_bb_to_loop (new_bb, copy ? copy : cloop);\n     }\n \n   return new_bb;"}, {"sha": "59815ccdc826981fd75e9420c8a491d05cd137f4", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -123,9 +123,6 @@ struct loop GTY ((chain_next (\"%h.next\")))\n   /* Link to the next (sibling) loop.  */\n   struct loop *next;\n \n-  /* Loop that is copy of this loop.  */\n-  struct loop *copy;\n-\n   /* Auxiliary info specific to a pass.  */\n   PTR GTY ((skip (\"\"))) aux;\n "}, {"sha": "99b41d7ceae4f021ebb009d7561aeae50e33ce6e", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -653,7 +653,7 @@ duplicate_loop (struct loop *loop, struct loop *target)\n   place_new_loop (cloop);\n \n   /* Mark the new loop as copy of LOOP.  */\n-  loop->copy = cloop;\n+  set_loop_copy (loop, cloop);\n \n   /* Add it to target.  */\n   flow_loop_tree_node_add (target, cloop);\n@@ -917,7 +917,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   for (aloop = loop->inner, i = 0; aloop; aloop = aloop->next, i++)\n     orig_loops[i] = aloop;\n \n-  loop->copy = target;\n+  set_loop_copy (loop, target);\n \n   first_active = XNEWVEC (basic_block, n);\n   if (is_latch)"}, {"sha": "83ab930d9355e3c5f9c2d15aa2dcf4cce4cb6e7b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -4360,14 +4360,14 @@ tree_duplicate_sese_region (edge entry, edge exit,\n \treturn false;\n     }\n \n-  loop->copy = loop;\n+  set_loop_copy (loop, loop);\n \n   /* In case the function is used for loop header copying (which is the primary\n      use), ensure that EXIT and its copy will be new latch and entry edges.  */\n   if (loop->header == entry->dest)\n     {\n       copying_header = true;\n-      loop->copy = loop_outer (loop);\n+      set_loop_copy (loop, loop_outer (loop));\n \n       if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src))\n \treturn false;"}, {"sha": "6732f2e28991749916c8c72a0cfb114bf206de63", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=561e8a90fdfe45ef935dbb16c6cf0389f2e7fef1", "patch": "@@ -918,10 +918,10 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \n       /* The duplicate of the header is the new preheader of the loop.  Ensure\n \t that it is placed correctly in the loop hierarchy.  */\n-      loop->copy = loop_outer (loop);\n+      set_loop_copy (loop, loop_outer (loop));\n \n       thread_block (header, false);\n-      loop->copy = NULL;\n+      set_loop_copy (loop, NULL);\n       new_preheader = e->dest;\n \n       /* Create the new latch block.  This is always necessary, as the latch\n@@ -1031,9 +1031,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n \n   mark_threaded_blocks (threaded_blocks);\n \n-  if (current_loops)\n-    FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n-      loop->copy = NULL;\n+  initialize_original_copy_tables ();\n \n   /* First perform the threading requests that do not affect\n      loop structure.  */\n@@ -1067,6 +1065,8 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n     fprintf (dump_file, \"\\nJumps threaded: %lu\\n\",\n \t     thread_stats.num_threaded_edges);\n \n+  free_original_copy_tables ();\n+\n   BITMAP_FREE (threaded_blocks);\n   threaded_blocks = NULL;\n   VEC_free (edge, heap, threaded_edges);"}]}