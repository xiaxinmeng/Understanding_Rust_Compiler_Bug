{"sha": "d644189f51968195dc2fe1b9c4e851f8538475f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0NDE4OWY1MTk2ODE5NWRjMmZlMWI5YzRlODUxZjg1Mzg0NzVmMw==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2001-12-07T16:10:03Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2001-12-07T16:10:03Z"}, "message": "rtl.h (get_jump_table_offset): Declare.\n\n\t* rtl.h (get_jump_table_offset): Declare.\n\t* rtlanal.c (get_jump_table_offset): Implement.\n\nFrom-SVN: r47756", "tree": {"sha": "91871aa733ca0ae38e63395948c525a3d872a6d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91871aa733ca0ae38e63395948c525a3d872a6d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d644189f51968195dc2fe1b9c4e851f8538475f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d644189f51968195dc2fe1b9c4e851f8538475f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d644189f51968195dc2fe1b9c4e851f8538475f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d644189f51968195dc2fe1b9c4e851f8538475f3/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5af0b89c0d06133ec4fda00a308232f585361850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af0b89c0d06133ec4fda00a308232f585361850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af0b89c0d06133ec4fda00a308232f585361850"}], "stats": {"total": 147, "additions": 147, "deletions": 0}, "files": [{"sha": "8c11b636392bca437b480b4a0160ff81a4bce46b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d644189f51968195dc2fe1b9c4e851f8538475f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d644189f51968195dc2fe1b9c4e851f8538475f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d644189f51968195dc2fe1b9c4e851f8538475f3", "patch": "@@ -1,3 +1,8 @@\n+Fri Dec  7 11:07:35 EST 2001  John Wehle  (john@feith.com)\n+\n+\t* rtl.h (get_jump_table_offset): Declare.\n+\t* rtlanal.c (get_jump_table_offset): Implement.\n+\n Fri Dec  7 07:06:17 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* final.c (bb_head, bb_tail, bb_file_label_num, bb_func_label_num):"}, {"sha": "0fe43aae3709134f8e347f31735a497d3b63499b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d644189f51968195dc2fe1b9c4e851f8538475f3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d644189f51968195dc2fe1b9c4e851f8538475f3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d644189f51968195dc2fe1b9c4e851f8538475f3", "patch": "@@ -1427,6 +1427,7 @@ extern int rtx_varies_p\t\t\tPARAMS ((rtx, int));\n extern int rtx_addr_varies_p\t\tPARAMS ((rtx, int));\n extern HOST_WIDE_INT get_integer_term\tPARAMS ((rtx));\n extern rtx get_related_value\t\tPARAMS ((rtx));\n+extern rtx get_jump_table_offset\tPARAMS ((rtx, rtx *));\n extern int reg_mentioned_p\t\tPARAMS ((rtx, rtx));\n extern int count_occurrences\t\tPARAMS ((rtx, rtx, int));\n extern int reg_referenced_p\t\tPARAMS ((rtx, rtx));"}, {"sha": "f105950d9853cd614a9c640051a5f8f50497a4e3", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d644189f51968195dc2fe1b9c4e851f8538475f3/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d644189f51968195dc2fe1b9c4e851f8538475f3/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=d644189f51968195dc2fe1b9c4e851f8538475f3", "patch": "@@ -339,6 +339,147 @@ get_related_value (x)\n   return 0;\n }\n \f\n+/* Given a tablejump insn INSN, return the RTL expression for the offset\n+   into the jump table.  If the offset cannot be determined, then return\n+   NULL_RTX.\n+\n+   If EARLIEST is non-zero, it is a pointer to a place where the earliest\n+   insn used in locating the offset was found.  */\n+\n+rtx\n+get_jump_table_offset (insn, earliest)\n+     rtx insn;\n+     rtx *earliest;\n+{\n+  rtx label;\n+  rtx table;\n+  rtx set;\n+  rtx old_insn;\n+  rtx x;\n+  rtx old_x;\n+  rtx y;\n+  rtx old_y;\n+  int i;\n+  int j;\n+\n+  if (GET_CODE (insn) != JUMP_INSN\n+      || ! (label = JUMP_LABEL (insn))\n+      || ! (table = NEXT_INSN (label))\n+      || GET_CODE (table) != JUMP_INSN\n+      || (GET_CODE (PATTERN (table)) != ADDR_VEC\n+\t  && GET_CODE (PATTERN (table)) != ADDR_DIFF_VEC)\n+      || ! (set = single_set (insn)))\n+    return NULL_RTX;\n+\n+  x = SET_SRC (set);\n+\n+  /* Some targets (eg, ARM) emit a tablejump that also\n+     contains the out-of-range target.  */\n+  if (GET_CODE (x) == IF_THEN_ELSE\n+      && GET_CODE (XEXP (x, 2)) == LABEL_REF)\n+    x = XEXP (x, 1);\n+\n+  /* Search backwards and locate the expression stored in X.  */\n+  for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+       old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n+    ;\n+\n+  /* If X is an expression using a relative address then strip\n+     off the addition / subtraction of PC, PIC_OFFSET_TABLE_REGNUM,\n+     or the jump table label.  */\n+  if (GET_CODE (PATTERN (table)) == ADDR_DIFF_VEC\n+      && (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS))\n+    {\n+      for (i = 0; i < 2; i++)\n+\t{\n+\t  old_insn = insn;\n+\t  y = XEXP (x, i);\n+\n+\t  if (y == pc_rtx || y == pic_offset_table_rtx)\n+\t    break;\n+\n+\t  for (old_y = NULL_RTX; GET_CODE (y) == REG && y != old_y;\n+\t       old_y = y, y = find_last_value (y, &old_insn, NULL_RTX, 0))\n+\t    ;\n+\n+\t  if ((GET_CODE (y) == LABEL_REF && XEXP (y, 0) == label))\n+\t    break;\n+\t}\n+\n+      if (i >= 2)\n+\treturn NULL_RTX;\n+\n+      x = XEXP (x, 1 - i);\n+\n+      for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+\t   old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n+\t;\n+    }\n+\n+  /* Strip off any sign or zero extension.  */\n+  if (GET_CODE (x) == SIGN_EXTEND || GET_CODE (x) == ZERO_EXTEND)\n+    {\n+      x = XEXP (x, 0);\n+\n+      for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+\t   old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n+\t;\n+    }\n+\n+  /* If X isn't a MEM then this isn't a tablejump we understand.  */\n+  if (GET_CODE (x) != MEM)\n+    return NULL_RTX;\n+\n+  /* Strip off the MEM.  */\n+  x = XEXP (x, 0);\n+\n+  for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+       old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n+    ;\n+\n+  /* If X isn't a PLUS than this isn't a tablejump we understand.  */\n+  if (GET_CODE (x) != PLUS)\n+    return NULL_RTX;\n+\n+  /* At this point we should have an expression representing the jump table\n+     plus an offset.  Examine each operand in order to determine which one\n+     represents the jump table.  Knowing that tells us that the other operand\n+     must represent the offset.  */\n+  for (i = 0; i < 2; i++)\n+    {\n+      old_insn = insn;\n+      y = XEXP (x, i);\n+\n+      for (old_y = NULL_RTX; GET_CODE (y) == REG && y != old_y;\n+\t   old_y = y, y = find_last_value (y, &old_insn, NULL_RTX, 0))\n+\t;\n+\n+      if ((GET_CODE (y) == CONST || GET_CODE (y) == LABEL_REF)\n+\t  && reg_mentioned_p (label, y))\n+\tbreak;\n+    }\n+\n+  if (i >= 2)\n+    return NULL_RTX;\n+\n+  x = XEXP (x, 1 - i);\n+\n+  /* Strip off the addition / subtraction of PIC_OFFSET_TABLE_REGNUM.  */\n+  if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)\n+    for (i = 0; i < 2; i++)\n+      if (XEXP (x, i) == pic_offset_table_rtx)\n+\t{\n+\t  x = XEXP (x, 1 - i);\n+\t  break;\n+\t}\n+\n+  if (earliest)\n+    *earliest = insn;\n+\n+  /* Return the RTL expression representing the offset.  */\n+  return x;\n+}\n+\f\n /* Return the number of places FIND appears within X.  If COUNT_DEST is\n    zero, we do not count occurrences inside the destination of a SET.  */\n "}]}