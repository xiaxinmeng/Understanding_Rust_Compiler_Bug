{"sha": "8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVlNGRiNmYzYTA4OTIyZDRmMmI5ZDVkMWY1YmM4NTUxNmEzMTg5ZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-09-06T18:14:15Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-09-06T18:14:15Z"}, "message": "Fix for PR java.lang/339:\n\n\t* java/lang/natPosixProcess.cc (fail): New function.\n\t(cleanup): New function.\n\t(startProcess): Use them.  Create pipe so child can communicate\n\texec failure back to parent.\n\nFrom-SVN: r36202", "tree": {"sha": "289b4525c66995dea35e3456158ab22ce4deff81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/289b4525c66995dea35e3456158ab22ce4deff81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e/comments", "author": null, "committer": null, "parents": [{"sha": "1bac0fb486f48c039679aa8fd958c8e8bae853fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bac0fb486f48c039679aa8fd958c8e8bae853fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bac0fb486f48c039679aa8fd958c8e8bae853fb"}], "stats": {"total": 159, "additions": 125, "deletions": 34}, "files": [{"sha": "1c0cbcdc055e1cdb4ae850b758258eeab0773f0a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e", "patch": "@@ -1,3 +1,11 @@\n+2000-09-06  Tom Tromey  <tromey@cygnus.com>\n+\n+\tFix for PR java.lang/339:\n+\t* java/lang/natPosixProcess.cc (fail): New function.\n+\t(cleanup): New function.\n+\t(startProcess): Use them.  Create pipe so child can communicate\n+\texec failure back to parent.\n+\n 2000-09-05  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/net/natPlainDatagramSocketImpl.cc: Change various `JvThrow'\n@@ -7,7 +15,7 @@\n \t* java/net/natPlainSocketImpl.cc: Change various `JvThrow' calls to \n \t`throw'.\n \t* java/net/natInetAdress.cc: Ditto.\n-\t\n+\n \t* java/net/natPlainDatagramSocketImpl.cc (mcastGrp): Fix typo.\n \n 2000-09-05  Tom Tromey  <tromey@cygnus.com>"}, {"sha": "0582bd1e82bb23fe774f4a9f84e9aaceb114f6dd", "filename": "libjava/java/lang/natPosixProcess.cc", "status": "modified", "additions": 116, "deletions": 33, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e/libjava%2Fjava%2Flang%2FnatPosixProcess.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e/libjava%2Fjava%2Flang%2FnatPosixProcess.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatPosixProcess.cc?ref=8ee4db6f3a08922d4f2b9d5d1f5bc85516a3189e", "patch": "@@ -1,6 +1,6 @@\n // natPosixProcess.cc - Native side of POSIX process code.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -34,6 +34,7 @@ details.  */\n #include <java/io/FileInputStream.h>\n #include <java/io/FileOutputStream.h>\n #include <java/io/IOException.h>\n+#include <java/lang/OutOfMemoryError.h>\n \n extern char **environ;\n \n@@ -100,6 +101,55 @@ new_string (jstring string)\n   return buf;\n }\n \n+static void\n+cleanup (char **args, char **env)\n+{\n+  if (args != NULL)\n+    {\n+      for (int i = 0; args[i] != NULL; ++i)\n+\t_Jv_Free (args[i]);\n+      _Jv_Free (args);\n+    }\n+  if (env != NULL)\n+    {\n+      for (int i = 0; env[i] != NULL; ++i)\n+\t_Jv_Free (env[i]);\n+      _Jv_Free (env);\n+    }\n+}\n+\n+static void\n+fail (int error_value, char **args, char **env,\n+      int *one = NULL, int *two = NULL,\n+      int *three = NULL, int *four = NULL,\n+      java::lang::Throwable *t = NULL)\n+{\n+  cleanup (args, env);\n+  if (one != NULL)\n+    {\n+      close (one[0]);\n+      close (one[1]);\n+    }\n+  if (two != NULL)\n+    {\n+      close (two[0]);\n+      close (two[1]);\n+    }\n+  if (three != NULL)\n+    {\n+      close (three[0]);\n+      close (three[1]);\n+    }\n+  if (four != NULL)\n+    {\n+      close (four[0]);\n+      close (four[1]);\n+    }\n+  if (t == NULL)\n+    t = new java::io::IOException (JvNewStringLatin1 (strerror (error_value)));\n+  throw t;\n+}\n+\n void\n java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n \t\t\t\t\t   jstringArray envp)\n@@ -109,57 +159,76 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n   hasExited = false;\n \n   if (! progarray)\n-    _Jv_Throw (new NullPointerException);\n+    throw new NullPointerException;\n \n   // Transform arrays to native form.\n-  // FIXME: we use malloc here.  We shouldn't.  If an exception is\n-  // thrown we will leak memory.\n   char **args = (char **) _Jv_Malloc ((progarray->length + 1)\n \t\t\t\t      * sizeof (char *));\n   char **env = NULL;\n \n-  // FIXME: GC will fail here if _Jv_Malloc throws an exception.\n-  // That's because we have to manually free the contents, but we \n+  // Initialize so we can gracefully recover.\n   jstring *elts = elements (progarray);\n-  for (int i = 0; i < progarray->length; ++i)\n-    args[i] = new_string (elts[i]);\n-  args[progarray->length] = NULL;\n+  for (int i = 0; i <= progarray->length; ++i)\n+    args[i] = NULL;\n \n-  if (envp)\n+  try\n     {\n-      env = (char **) _Jv_Malloc ((envp->length + 1) * sizeof (char *));\n-      elts = elements (envp);\n-      for (int i = 0; i < envp->length; ++i)\n-\tenv[i] = new_string (elts[i]);\n-      env[envp->length] = NULL;\n-    }\n+      for (int i = 0; i < progarray->length; ++i)\n+\targs[i] = new_string (elts[i]);\n+      args[progarray->length] = NULL;\n+\n+      if (envp)\n+\t{\n+\t  env = (char **) _Jv_Malloc ((envp->length + 1) * sizeof (char *));\n+\t  elts = elements (envp);\n \n-  // Create pipes for I/O.\n-  int inp[2], outp[2], errp[2];\n+\t  // Initialize so we can gracefully recover.\n+\t  for (int i = 0; i <= envp->length; ++i)\n+\t    env[i] = NULL;\n \n-  if (pipe (inp)\n-      || pipe (outp)\n-      || pipe (errp))\n+\t  for (int i = 0; i < envp->length; ++i)\n+\t    env[i] = new_string (elts[i]);\n+\t  env[envp->length] = NULL;\n+\t}\n+    }\n+  catch (java::lang::OutOfMemoryError *oome)\n     {\n-    ioerror:\n-      // FIXME.\n-      _Jv_Free (args);\n-      if (env)\n-\t_Jv_Free (env);\n-      _Jv_Throw (new IOException (JvNewStringLatin1 (strerror (errno))));\n+      fail (0, args, env, NULL, NULL, NULL, NULL, oome);\n+      throw oome;\n     }\n \n+  // Create pipes for I/O.  MSGP is for communicating exec() status.\n+  int inp[2], outp[2], errp[2], msgp[2];\n+\n+  if (pipe (inp))\n+    fail (errno, args, env);\n+  if (pipe (outp))\n+    fail (errno, args, env, inp);\n+  if (pipe (errp))\n+    fail (errno, args, env, inp, outp);\n+  if (pipe (msgp))\n+    fail (errno, args, env, inp, outp, errp);\n+  if (fcntl (msgp[1], F_SETFD, FD_CLOEXEC))\n+    fail (errno, args, env, inp, outp, errp, msgp);\n+\n   // We create the streams before forking.  Otherwise if we had an\n   // error while creating the streams we would have run the child with\n   // no way to communicate with it.\n-  errorStream = new FileInputStream (new FileDescriptor (errp[0]));\n-  inputStream = new FileInputStream (new FileDescriptor (inp[0]));\n-  outputStream = new FileOutputStream (new FileDescriptor (outp[1]));\n+  try\n+    {\n+      errorStream = new FileInputStream (new FileDescriptor (errp[0]));\n+      inputStream = new FileInputStream (new FileDescriptor (inp[0]));\n+      outputStream = new FileOutputStream (new FileDescriptor (outp[1]));\n+    }\n+  catch (java::lang::Throwable *t)\n+    {\n+      fail (0, args, env, inp, outp, errp, msgp, t);\n+    }\n \n   // We don't use vfork() because that would cause the local\n   // environment to be set by the child.\n   if ((pid = (jlong) fork ()) == -1)\n-    goto ioerror;\n+    fail (errno, args, env, inp, outp, errp, msgp);\n \n   if (pid == 0)\n     {\n@@ -190,10 +259,13 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n       close (errp[1]);\n       close (outp[0]);\n       close (outp[1]);\n+      close (msgp[0]);\n \n       execvp (args[0], args);\n-      // FIXME: should throw an IOException if execvp() fails. Not trivial,\n-      // because _Jv_Throw won't work from child process\n+\n+      // Send the parent notification that the exec failed.\n+      char c = errno;\n+      write (msgp[1], &c, 1);\n       _exit (127);\n     }\n \n@@ -202,6 +274,17 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n   close (outp[0]);\n   close (inp[1]);\n   close (errp[1]);\n+  close (msgp[1]);\n+\n+  char c;\n+  int r = read (msgp[0], &c, 1);\n+  if (r == -1)\n+    fail (errno, args, env, inp, outp, errp, msgp);\n+  else if (r != 0)\n+    fail (c, args, env, inp, outp, errp, msgp);\n+\n+  close (msgp[0]);\n+  cleanup (args, env);\n \n   fcntl (outp[1], F_SETFD, 1);\n   fcntl (inp[0], F_SETFD, 1);"}]}