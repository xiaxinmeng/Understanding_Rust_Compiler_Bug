{"sha": "4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4Y2FlODM3MGE5YzdjY2FmZjJkZjViNTUyZjUyZGI1MWViOWY5Yg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-06-17T05:57:04Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-06-17T05:57:04Z"}, "message": "Remove libcall notes.\n\n\t* see.c (see_analyse_one_def): Do not look for REG_LIBCALL and\n\tREG_RETVAL notes.\n\t(see_update_relevancy): Likewise.\n\t* fwprop.c (try_fwprop_subst): Likewise.\n\t* rtlanal.c (noop_move_p): Likewise.\n\t* builtins.c (expand_buitlin_mathfn): Don't try to add REG_EQUAL\n\tnotes to non-existing libcall blocks.\n\t* cse.c (cse_insn): Change prototype.  Don't update libcall notes.\n\tRemove orig_set.\n\t(cse_extended_basic_block): Don't track libcall and no-conflict notes.\n\t(dead_libcall_p): Remove.\n\t(delete_trivially_dead_insns): Don't use it.\n\t* web.c (union_defs): Remove comment about keeping nops.\n\t* gcse.c (hash_scan_insn): Don't take libcall pointers.\n\t(compute_hash_table_work): Don't track libcall notes.\n\t(do_local_cprop): Don't take libcall pointers.  Don't update\n\tlibcall notes.\n\t(adjust_libcall_notes): Deleted.\n\t(local_cprop_pass): Remove stack for nested libcalls (which shouldn't\n\tever have existed in the first place).\n\t(replace_store_insn): Don't try to remove libcall notes.\n\t* lower-subreg.c (move_libcall_note, move_retval_note): Deleted.\n\t(resolve_reg_notes): Don't call them.\n\t(resolve_simple_move): Likewise.\n\t(decompose_multiword_subregs): Remove block handling REG_RETVAL notes.\n\tDon't remove REG_RETVAL notes.\n\t* emit-rtl.c (try_split): Don't update libcall notes.\n\t(emit_copy_of_insn_after): Dito.\n\t* cselib.c (cselib_current_insn_in_libcall): Remove.\n\t(cselib_process_insn): Don't set/clear it.\n\t(new_elt_loc_list): Don't record it.\n\t(cselib_init): Don't initialize it.\n\t* cselib.c (struct elt_loc_list): Remove in_libcall field.\n\t* loop-invariant.c (find_invariant_insn): Don't look for libcall\n\tnotes.\n\t* sched-deps.c (sched_analyze_insn): Don't group libcall blocks.\n\t(sched_analyze): Don't set up deps->libcall_block_tail_insn.\n\t(init_deps): Don't initialize it.\n\t* sched-int.h (struct deps): Rremove libcall_block_tail_insn field.\n\t* combine.c (delete_noop_moves): Don't update libcall notes.\n\t(can_combine_p): Remove now pointless #if 0 block.\n\t(try_combine): Remove another obsolete #if 0 block.\n\t(distribute_notes): Don't distribute libcall notes.\n\t* reg-notes.def (REG_LIBCALL, REG_RETVAL): Remove.\n\t* dce.c (libcall_dead_p): Remove.\n\t(delete_unmarked_insns): Don't handle libcall blocks.\n\t(preserve_libcall_for_dce): Remove.\n\t(prescan_insns_for_dce): Don't special-case libcall block insns.\n\t* reload1 (reload): Don't handle libcall notes. \n\t* doc/rtl.texi (REG_LIBCALL, REG_RETVAL, REG_LIBCALL_ID): Remove\n\tdocumentation.\n\nFrom-SVN: r136861", "tree": {"sha": "8e1097fff4f927ebe993aa6e075eafcfd576b7bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e1097fff4f927ebe993aa6e075eafcfd576b7bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/comments", "author": null, "committer": null, "parents": [{"sha": "e989f2d107b3251230471242c6f78cb220137cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e989f2d107b3251230471242c6f78cb220137cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e989f2d107b3251230471242c6f78cb220137cb8"}], "stats": {"total": 942, "additions": 109, "deletions": 833}, "files": [{"sha": "91430aff4a038e82c2a60dd1582963c95007bc9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -1,3 +1,57 @@\n+2008-06-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* see.c (see_analyse_one_def): Do not look for REG_LIBCALL and\n+\tREG_RETVAL notes.\n+\t(see_update_relevancy): Likewise.\n+\t* fwprop.c (try_fwprop_subst): Likewise.\n+\t* rtlanal.c (noop_move_p): Likewise.\n+\t* builtins.c (expand_buitlin_mathfn): Don't try to add REG_EQUAL\n+\tnotes to non-existing libcall blocks.\n+\t* cse.c (cse_insn): Change prototype.  Don't update libcall notes.\n+\tRemove orig_set.\n+\t(cse_extended_basic_block): Don't track libcall and no-conflict notes.\n+\t(dead_libcall_p): Remove.\n+\t(delete_trivially_dead_insns): Don't use it.\n+\t* web.c (union_defs): Remove comment about keeping nops.\n+\t* gcse.c (hash_scan_insn): Don't take libcall pointers.\n+\t(compute_hash_table_work): Don't track libcall notes.\n+\t(do_local_cprop): Don't take libcall pointers.  Don't update\n+\tlibcall notes.\n+\t(adjust_libcall_notes): Deleted.\n+\t(local_cprop_pass): Remove stack for nested libcalls (which shouldn't\n+\tever have existed in the first place).\n+\t(replace_store_insn): Don't try to remove libcall notes.\n+\t* lower-subreg.c (move_libcall_note, move_retval_note): Deleted.\n+\t(resolve_reg_notes): Don't call them.\n+\t(resolve_simple_move): Likewise.\n+\t(decompose_multiword_subregs): Remove block handling REG_RETVAL notes.\n+\tDon't remove REG_RETVAL notes.\n+\t* emit-rtl.c (try_split): Don't update libcall notes.\n+\t(emit_copy_of_insn_after): Dito.\n+\t* cselib.c (cselib_current_insn_in_libcall): Remove.\n+\t(cselib_process_insn): Don't set/clear it.\n+\t(new_elt_loc_list): Don't record it.\n+\t(cselib_init): Don't initialize it.\n+\t* cselib.c (struct elt_loc_list): Remove in_libcall field.\n+\t* loop-invariant.c (find_invariant_insn): Don't look for libcall\n+\tnotes.\n+\t* sched-deps.c (sched_analyze_insn): Don't group libcall blocks.\n+\t(sched_analyze): Don't set up deps->libcall_block_tail_insn.\n+\t(init_deps): Don't initialize it.\n+\t* sched-int.h (struct deps): Rremove libcall_block_tail_insn field.\n+\t* combine.c (delete_noop_moves): Don't update libcall notes.\n+\t(can_combine_p): Remove now pointless #if 0 block.\n+\t(try_combine): Remove another obsolete #if 0 block.\n+\t(distribute_notes): Don't distribute libcall notes.\n+\t* reg-notes.def (REG_LIBCALL, REG_RETVAL): Remove.\n+\t* dce.c (libcall_dead_p): Remove.\n+\t(delete_unmarked_insns): Don't handle libcall blocks.\n+\t(preserve_libcall_for_dce): Remove.\n+\t(prescan_insns_for_dce): Don't special-case libcall block insns.\n+\t* reload1 (reload): Don't handle libcall notes. \n+\t* doc/rtl.texi (REG_LIBCALL, REG_RETVAL, REG_LIBCALL_ID): Remove\n+\tdocumentation.\n+\n 2008-06-16  Eric B. Weddington  <eric.weddington@atmel.com>\n \n \t* config/avr/avr.c (avr_mcu_t): Add atmega32c1."}, {"sha": "57d9379983bbe639d9d394959f2f84defbbb5b3f", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -1945,48 +1945,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n \n   before_call = get_last_insn ();\n \n-  target = expand_call (exp, target, target == const0_rtx);\n-\n-  /* If this is a sqrt operation and we don't care about errno, try to\n-     attach a REG_EQUAL note with a SQRT rtx to the emitted libcall.\n-     This allows the semantics of the libcall to be visible to the RTL\n-     optimizers.  */\n-  if (builtin_optab == sqrt_optab && !errno_set)\n-    {\n-      /* Search backwards through the insns emitted by expand_call looking\n-\t for the instruction with the REG_RETVAL note.  */\n-      rtx last = get_last_insn ();\n-      while (last != before_call)\n-\t{\n-\t  if (find_reg_note (last, REG_RETVAL, NULL))\n-\t    {\n-\t      rtx note = find_reg_note (last, REG_EQUAL, NULL);\n-\t      /* Check that the REQ_EQUAL note is an EXPR_LIST with\n-\t\t two elements, i.e. symbol_ref(sqrt) and the operand.  */\n-\t      if (note\n-\t\t  && GET_CODE (note) == EXPR_LIST\n-\t\t  && GET_CODE (XEXP (note, 0)) == EXPR_LIST\n-\t\t  && XEXP (XEXP (note, 0), 1) != NULL_RTX\n-\t\t  && XEXP (XEXP (XEXP (note, 0), 1), 1) == NULL_RTX)\n-\t\t{\n-\t\t  rtx operand = XEXP (XEXP (XEXP (note, 0), 1), 0);\n-\t\t  /* Check operand is a register with expected mode.  */\n-\t\t  if (operand\n-\t\t      && REG_P (operand)\n-\t\t      && GET_MODE (operand) == mode)\n-\t\t    {\n-\t\t      /* Replace the REG_EQUAL note with a SQRT rtx.  */\n-\t\t      rtx equiv = gen_rtx_SQRT (mode, operand);\n-\t\t      set_unique_reg_note (last, REG_EQUAL, equiv);\n-\t\t    }\n-\t\t}\n-\t      break;\n-\t    }\n-\t  last = PREV_INSN (last);\n-\t}\n-    }\n-\n-  return target;\n+  return expand_call (exp, target, target == const0_rtx);\n }\n \n /* Expand a call to the builtin binary math functions (pow and atan2)."}, {"sha": "79d96ed37635ea53c6fec266d297505756302c74", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 77, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -882,23 +882,6 @@ delete_noop_moves (void)\n \t  next = NEXT_INSN (insn);\n \t  if (INSN_P (insn) && noop_move_p (insn))\n \t    {\n-\t      rtx note;\n-\n-\t      /* If we're about to remove the first insn of a libcall\n-\t\t then move the libcall note to the next real insn and\n-\t\t update the retval note.  */\n-\t      if ((note = find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t\t       && XEXP (note, 0) != insn)\n-\t\t{\n-\t\t  rtx new_libcall_insn = next_real_insn (insn);\n-\t\t  rtx retval_note = find_reg_note (XEXP (note, 0),\n-\t\t\t\t\t\t   REG_RETVAL, NULL_RTX);\n-\t\t  REG_NOTES (new_libcall_insn)\n-\t\t    = gen_rtx_INSN_LIST (REG_LIBCALL, XEXP (note, 0),\n-\t\t\t\t\t REG_NOTES (new_libcall_insn));\n-\t\t  XEXP (retval_note, 0) = new_libcall_insn;\n-\t\t}\n-\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"deleting noop move %d\\n\", INSN_UID (insn));\n \n@@ -1676,14 +1659,6 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n       || (succ && FIND_REG_INC_NOTE (succ, dest))\n       /* Don't substitute into a non-local goto, this confuses CFG.  */\n       || (JUMP_P (i3) && find_reg_note (i3, REG_NON_LOCAL_GOTO, NULL_RTX))\n-#if 0\n-      /* Don't combine the end of a libcall into anything.  */\n-      /* ??? This gives worse code, and appears to be unnecessary, since no\n-\t pass after flow uses REG_LIBCALL/REG_RETVAL notes.  Local-alloc does\n-\t use REG_RETVAL notes for noconflict blocks, but other code here\n-\t makes sure that those insns don't disappear.  */\n-      || find_reg_note (insn, REG_RETVAL, NULL_RTX)\n-#endif\n       /* Make sure that DEST is not used after SUCC but before I3.  */\n       || (succ && ! all_adjacent\n \t  && reg_used_between_p (dest, succ, i3))\n@@ -2241,16 +2216,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   if (cant_combine_insn_p (i3)\n       || cant_combine_insn_p (i2)\n       || (i1 && cant_combine_insn_p (i1))\n-      || likely_spilled_retval_p (i3)\n-      /* We also can't do anything if I3 has a\n-\t REG_LIBCALL note since we don't want to disrupt the contiguity of a\n-\t libcall.  */\n-#if 0\n-      /* ??? This gives worse code, and appears to be unnecessary, since no\n-\t pass after flow uses REG_LIBCALL/REG_RETVAL notes.  */\n-      || find_reg_note (i3, REG_LIBCALL, NULL_RTX)\n-#endif\n-      )\n+      || likely_spilled_retval_p (i3))\n     return 0;\n \n   combine_attempts++;\n@@ -12547,48 +12513,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t     to simply delete it.  */\n \t  break;\n \n-\tcase REG_RETVAL:\n-\t  /* If the insn previously containing this note still exists,\n-\t     put it back where it was.  Otherwise move it to the previous\n-\t     insn.  Adjust the corresponding REG_LIBCALL note.  */\n-\t  if (!NOTE_P (from_insn))\n-\t    place = from_insn;\n-\t  else\n-\t    {\n-\t      tem = find_reg_note (XEXP (note, 0), REG_LIBCALL, NULL_RTX);\n-\t      place = prev_real_insn (from_insn);\n-\t      if (tem && place)\n-\t\tXEXP (tem, 0) = place;\n-\t      /* If we're deleting the last remaining instruction of a\n-\t\t libcall sequence, don't add the notes.  */\n-\t      else if (XEXP (note, 0) == from_insn)\n-\t\ttem = place = 0;\n-\t      /* Don't add the dangling REG_RETVAL note.  */\n-\t      else if (! tem)\n-\t\tplace = 0;\n-\t    }\n-\t  break;\n-\n-\tcase REG_LIBCALL:\n-\t  /* This is handled similarly to REG_RETVAL.  */\n-\t  if (!NOTE_P (from_insn))\n-\t    place = from_insn;\n-\t  else\n-\t    {\n-\t      tem = find_reg_note (XEXP (note, 0), REG_RETVAL, NULL_RTX);\n-\t      place = next_real_insn (from_insn);\n-\t      if (tem && place)\n-\t\tXEXP (tem, 0) = place;\n-\t      /* If we're deleting the last remaining instruction of a\n-\t\t libcall sequence, don't add the notes.  */\n-\t      else if (XEXP (note, 0) == from_insn)\n-\t\ttem = place = 0;\n-\t      /* Don't add the dangling REG_LIBCALL note.  */\n-\t      else if (! tem)\n-\t\tplace = 0;\n-\t    }\n-\t  break;\n-\n \tcase REG_DEAD:\n \t  /* If we replaced the right hand side of FROM_INSN with a\n \t     REG_EQUAL note, the original use of the dying register"}, {"sha": "02420f1a076407adec17d049f641bfa115cf9372", "filename": "gcc/cse.c", "status": "modified", "additions": 18, "deletions": 168, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -584,7 +584,7 @@ static rtx equiv_constant (rtx);\n static void record_jump_equiv (rtx, bool);\n static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n \t\t\t      int);\n-static void cse_insn (rtx, rtx);\n+static void cse_insn (rtx);\n static void cse_prescan_path (struct cse_basic_block_data *);\n static void invalidate_from_clobbers (rtx);\n static rtx cse_process_notes (rtx, rtx, bool *);\n@@ -599,7 +599,6 @@ static int check_dependence (rtx *, void *);\n static void flush_hash_table (void);\n static bool insn_live_p (rtx, int *);\n static bool set_live_p (rtx, rtx, int *);\n-static bool dead_libcall_p (rtx, int *);\n static int cse_change_cc_mode (rtx *, void *);\n static void cse_change_cc_mode_insn (rtx, rtx);\n static void cse_change_cc_mode_insns (rtx, rtx, rtx);\n@@ -3929,11 +3928,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n    First simplify sources and addresses of all assignments\n    in the instruction, using previously-computed equivalents values.\n    Then install the new sources and destinations in the table\n-   of available values.\n-\n-   If LIBCALL_INSN is nonzero, don't record any equivalence made in\n-   the insn.  It means that INSN is inside libcall block.  In this\n-   case LIBCALL_INSN is the corresponding insn with REG_LIBCALL.  */\n+   of available values.  */\n \n /* Data on one SET contained in the instruction.  */\n \n@@ -3962,8 +3957,6 @@ struct set\n   ENUM_BITFIELD(machine_mode) mode : 8;\n   /* A constant equivalent for SET_SRC, if any.  */\n   rtx src_const;\n-  /* Original SET_SRC value used for libcall notes.  */\n-  rtx orig_src;\n   /* Hash value of constant equivalent for SET_SRC.  */\n   unsigned src_const_hash;\n   /* Table entry for constant equivalent for SET_SRC, if any.  */\n@@ -3973,7 +3966,7 @@ struct set\n };\n \n static void\n-cse_insn (rtx insn, rtx libcall_insn)\n+cse_insn (rtx insn)\n {\n   rtx x = PATTERN (insn);\n   int i;\n@@ -4170,7 +4163,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n       rtx src = SET_SRC (sets[i].rtl);\n       rtx new = canon_reg (src, insn);\n \n-      sets[i].orig_src = src;\n       validate_change (insn, &SET_SRC (sets[i].rtl), new, 1);\n \n       if (GET_CODE (dest) == ZERO_EXTRACT)\n@@ -4821,22 +4813,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t    {\n \t      rtx new = canon_reg (SET_SRC (sets[i].rtl), insn);\n \n-\t      /* If we just made a substitution inside a libcall, then we\n-\t\t need to make the same substitution in any notes attached\n-\t\t to the RETVAL insn.  */\n-\t      if (libcall_insn\n-\t\t  && (REG_P (sets[i].orig_src)\n-\t\t      || GET_CODE (sets[i].orig_src) == SUBREG\n-\t\t      || MEM_P (sets[i].orig_src)))\n-\t\t{\n-\t          rtx note = find_reg_equal_equiv_note (libcall_insn);\n-\t\t  if (note != 0)\n-\t\t    XEXP (note, 0) = simplify_replace_rtx (XEXP (note, 0),\n-\t\t\t\t\t\t\t   sets[i].orig_src,\n-\t\t\t\t\t\t\t   copy_rtx (new));\n-\t\t  df_notes_rescan (libcall_insn);\n-\t\t}\n-\n \t      /* The result of apply_change_group can be ignored; see\n \t\t canon_reg.  */\n \n@@ -5175,27 +5151,19 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n \t    if (sets[i].src_elt == 0)\n \t      {\n-\t\t/* Don't put a hard register source into the table if this is\n-\t\t   the last insn of a libcall.  In this case, we only need\n-\t\t   to put src_eqv_elt in src_elt.  */\n-\t\tif (! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t\t  {\n-\t\t    struct table_elt *elt;\n+\t\tstruct table_elt *elt;\n \n-\t\t    /* Note that these insert_regs calls cannot remove\n-\t\t       any of the src_elt's, because they would have failed to\n-\t\t       match if not still valid.  */\n-\t\t    if (insert_regs (src, classp, 0))\n-\t\t      {\n-\t\t\trehash_using_reg (src);\n-\t\t\tsets[i].src_hash = HASH (src, mode);\n-\t\t      }\n-\t\t    elt = insert (src, classp, sets[i].src_hash, mode);\n-\t\t    elt->in_memory = sets[i].src_in_memory;\n-\t\t    sets[i].src_elt = classp = elt;\n+\t\t/* Note that these insert_regs calls cannot remove\n+\t\t   any of the src_elt's, because they would have failed to\n+\t\t   match if not still valid.  */\n+\t\tif (insert_regs (src, classp, 0))\n+\t\t  {\n+\t\t    rehash_using_reg (src);\n+\t\t    sets[i].src_hash = HASH (src, mode);\n \t\t  }\n-\t\telse\n-\t\t  sets[i].src_elt = classp;\n+\t\telt = insert (src, classp, sets[i].src_hash, mode);\n+\t\telt->in_memory = sets[i].src_in_memory;\n+\t\tsets[i].src_elt = classp = elt;\n \t      }\n \t    if (sets[i].src_const && sets[i].src_const_elt == 0\n \t\t&& src != sets[i].src_const\n@@ -5392,11 +5360,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t       size of it, and can't be sure that other BLKmode values\n \t       have the same or smaller size.  */\n \t    || GET_MODE (dest) == BLKmode\n-\t    /* Don't record values of destinations set inside a libcall block\n-\t       since we might delete the libcall.  Things should have been set\n-\t       up so we won't want to reuse such a value, but we play it safe\n-\t       here.  */\n-\t    || libcall_insn\n \t    /* If we didn't put a REG_EQUAL value or a source into the hash\n \t       table, there is no point is recording DEST.  */\n \t    || sets[i].src_elt == 0\n@@ -5540,11 +5503,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n      then be used in the sequel and we may be changing a two-operand insn\n      into a three-operand insn.\n \n-     Also do not do this if we are operating on a copy of INSN.\n-\n-     Also don't do this if INSN ends a libcall; this would cause an unrelated\n-     register to be set in the middle of a libcall, and we then get bad code\n-     if the libcall is deleted.  */\n+     Also do not do this if we are operating on a copy of INSN.  */\n \n   if (n_sets == 1 && sets[0].rtl && REG_P (SET_DEST (sets[0].rtl))\n       && NEXT_INSN (PREV_INSN (insn)) == insn\n@@ -5555,8 +5514,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n       int src_q = REG_QTY (REGNO (SET_SRC (sets[0].rtl)));\n       struct qty_table_elem *src_ent = &qty_table[src_q];\n \n-      if ((src_ent->first_reg == REGNO (SET_DEST (sets[0].rtl)))\n-\t  && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+      if (src_ent->first_reg == REGNO (SET_DEST (sets[0].rtl)))\n \t{\n \t  /* Scan for the previous nonnote insn, but stop at a basic\n \t     block boundary.  */\n@@ -5993,8 +5951,6 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n     {\n       basic_block bb;\n       rtx insn;\n-      rtx libcall_insn = NULL_RTX;\n-      int no_conflict = 0;\n \n       bb = ebb_data->path[path_entry].bb;\n \n@@ -6043,39 +5999,8 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t    df_notes_rescan (insn);\n \t\t}\n \n-\t      /* Track when we are inside in LIBCALL block.  Inside such\n-\t\t a block we do not want to record destinations.  The last\n-\t\t insn of a LIBCALL block is not considered to be part of\n-\t\t the block, since its destination is the result of the\n-\t\t block and hence should be recorded.  */\n-\t      if (REG_NOTES (insn) != 0)\n-\t\t{\n-\t\t  rtx p;\n+\t      cse_insn (insn);\n \n-\t\t  if ((p = find_reg_note (insn, REG_LIBCALL, NULL_RTX)))\n-\t\t    libcall_insn = XEXP (p, 0);\n-\t\t  else if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t\t    {\n-\t\t      /* Keep libcall_insn for the last SET insn of\n-\t\t\t a no-conflict block to prevent changing the\n-\t\t\t destination.  */\n-\t\t      if (!no_conflict)\n-\t\t\tlibcall_insn = NULL_RTX;\n-\t\t      else\n-\t\t\tno_conflict = -1;\n-\t\t    }\n-\t\t}\n-\n-\t      cse_insn (insn, libcall_insn);\n-\n-\t      /* If we kept libcall_insn for a no-conflict bock,\n-\t\t clear it here.  */\n-\t      if (no_conflict == -1)\n-\t\t{\n-\t\t  libcall_insn = NULL_RTX;\n-\t\t  no_conflict = 0;\n-\t\t}\n-\t    \n \t      /* If we haven't already found an insn where we added a LABEL_REF,\n \t\t check this one.  */\n \t      if (INSN_P (insn) && !recorded_label_ref\n@@ -6112,9 +6037,6 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t    }\n \t}\n \n-      /* Make sure that libcalls don't span multiple basic blocks.  */\n-      gcc_assert (libcall_insn == NULL_RTX);\n-\n       /* With non-call exceptions, we are not always able to update\n \t the CFG properly inside cse_insn.  So clean up possibly\n \t redundant EH edges here.  */\n@@ -6479,57 +6401,6 @@ insn_live_p (rtx insn, int *counts)\n     return true;\n }\n \n-/* Return true if libcall is dead as a whole.  */\n-\n-static bool\n-dead_libcall_p (rtx insn, int *counts)\n-{\n-  rtx note, set, new;\n-\n-  /* See if there's a REG_EQUAL note on this insn and try to\n-     replace the source with the REG_EQUAL expression.\n-\n-     We assume that insns with REG_RETVALs can only be reg->reg\n-     copies at this point.  */\n-  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-  if (!note)\n-    return false;\n-\n-  set = single_set (insn);\n-  if (!set)\n-    return false;\n-\n-  new = simplify_rtx (XEXP (note, 0));\n-  if (!new)\n-    new = XEXP (note, 0);\n-\n-  /* While changing insn, we must update the counts accordingly.  */\n-  count_reg_usage (insn, counts, NULL_RTX, -1);\n-\n-  if (validate_change (insn, &SET_SRC (set), new, 0))\n-    {\n-      count_reg_usage (insn, counts, NULL_RTX, 1);\n-      remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n-      remove_note (insn, note);\n-      return true;\n-    }\n-\n-  if (CONSTANT_P (new))\n-    {\n-      new = force_const_mem (GET_MODE (SET_DEST (set)), new);\n-      if (new && validate_change (insn, &SET_SRC (set), new, 0))\n-\t{\n-\t  count_reg_usage (insn, counts, NULL_RTX, 1);\n-\t  remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n-\t  remove_note (insn, note);\n-\t  return true;\n-\t}\n-    }\n-\n-  count_reg_usage (insn, counts, NULL_RTX, 1);\n-  return false;\n-}\n-\n /* Scan all the insns and delete any that are dead; i.e., they store a register\n    that is never used or they copy a register to itself.\n \n@@ -6543,7 +6414,6 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n {\n   int *counts;\n   rtx insn, prev;\n-  int in_libcall = 0, dead_libcall = 0;\n   int ndead = 0;\n \n   timevar_push (TV_DELETE_TRIVIALLY_DEAD);\n@@ -6568,21 +6438,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      /* Don't delete any insns that are part of a libcall block unless\n-\t we can delete the whole libcall block.\n-\n-\t Flow or loop might get confused if we did that.  Remember\n-\t that we are scanning backwards.  */\n-      if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t{\n-\t  in_libcall = 1;\n-\t  live_insn = 1;\n-\t  dead_libcall = dead_libcall_p (insn, counts);\n-\t}\n-      else if (in_libcall)\n-\tlive_insn = ! dead_libcall;\n-      else\n-\tlive_insn = insn_live_p (insn, counts);\n+      live_insn = insn_live_p (insn, counts);\n \n       /* If this is a dead insn, delete it and show registers in it aren't\n \t being used.  */\n@@ -6593,12 +6449,6 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n \t  delete_insn_and_edges (insn);\n \t  ndead++;\n \t}\n-\n-      if (in_libcall && find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t{\n-\t  in_libcall = 0;\n-\t  dead_libcall = 0;\n-\t}\n     }\n \n   if (dump_file && ndead)"}, {"sha": "69ad207f00abe6ea93f9d31568075f0f7e8102bb", "filename": "gcc/cselib.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -78,7 +78,6 @@ static htab_t cselib_hash_table;\n /* This is a global so we don't have to pass this through every function.\n    It is used in new_elt_loc_list to set SETTING_INSN.  */\n static rtx cselib_current_insn;\n-static bool cselib_current_insn_in_libcall;\n \n /* Every new unknown value gets a unique number.  */\n static unsigned int next_unknown_value;\n@@ -160,7 +159,6 @@ new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n   el->next = next;\n   el->loc = loc;\n   el->setting_insn = cselib_current_insn;\n-  el->in_libcall = cselib_current_insn_in_libcall;\n   return el;\n }\n \n@@ -1655,8 +1653,6 @@ cselib_process_insn (rtx insn)\n   int i;\n   rtx x;\n \n-  if (find_reg_note (insn, REG_LIBCALL, NULL))\n-    cselib_current_insn_in_libcall = true;\n   cselib_current_insn = insn;\n \n   /* Forget everything at a CODE_LABEL, a volatile asm, or a setjmp.  */\n@@ -1667,16 +1663,12 @@ cselib_process_insn (rtx insn)\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n \t  && MEM_VOLATILE_P (PATTERN (insn))))\n     {\n-      if (find_reg_note (insn, REG_RETVAL, NULL))\n-        cselib_current_insn_in_libcall = false;\n       cselib_clear_table ();\n       return;\n     }\n \n   if (! INSN_P (insn))\n     {\n-      if (find_reg_note (insn, REG_RETVAL, NULL))\n-        cselib_current_insn_in_libcall = false;\n       cselib_current_insn = 0;\n       return;\n     }\n@@ -1719,8 +1711,6 @@ cselib_process_insn (rtx insn)\n       if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n \tcselib_invalidate_rtx (XEXP (XEXP (x, 0), 0));\n \n-  if (find_reg_note (insn, REG_RETVAL, NULL))\n-    cselib_current_insn_in_libcall = false;\n   cselib_current_insn = 0;\n \n   if (n_useless_values > MAX_USELESS_VALUES\n@@ -1769,7 +1759,6 @@ cselib_init (bool record_memory)\n   n_used_regs = 0;\n   cselib_hash_table = htab_create (31, get_value_hash,\n \t\t\t\t   entry_and_rtx_equal_p, NULL);\n-  cselib_current_insn_in_libcall = false;\n }\n \n /* Called when the current user is done with cselib.  */"}, {"sha": "09c2006b843ff5147ec75b9ea798b02de629f75f", "filename": "gcc/cselib.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -47,8 +47,6 @@ struct elt_loc_list GTY(())\n   rtx loc;\n   /* The insn that made the equivalence.  */\n   rtx setting_insn;\n-  /* True when setting insn is inside libcall.  */\n-  bool in_libcall;\n };\n \n /* A list of cselib_val structures.  */"}, {"sha": "b75a8b1b113ae0158eedb3c690d633f09581a8e5", "filename": "gcc/dce.c", "status": "modified", "additions": 1, "deletions": 151, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -214,62 +214,6 @@ mark_nonreg_stores (rtx body, rtx insn, bool fast)\n }\n \n \n-/* Return true if the entire libcall sequence starting at INSN is dead.\n-   NOTE is the REG_LIBCALL note attached to INSN.\n-\n-   A libcall sequence is a block of insns with no side-effects, i.e.\n-   that is only used for its return value.  The terminology derives\n-   from that of a call, but a libcall sequence need not contain one.\n-   It is only defined by a pair of REG_LIBCALL/REG_RETVAL notes.\n-\n-   From a dataflow viewpoint, a libcall sequence has the property that\n-   no UD chain can enter it from the outside.  As a consequence, if a\n-   libcall sequence has a dead return value, it is effectively dead.\n-   This is both enforced by CSE (cse_extended_basic_block) and relied\n-   upon by delete_trivially_dead_insns.\n-\n-   However, in practice, the return value business is a tricky one and\n-   only checking the liveness of the last insn is not sufficient to\n-   decide whether the whole sequence is dead (e.g. PR middle-end/19551)\n-   so we check the liveness of every insn starting from the call.  */\n-\n-static bool\n-libcall_dead_p (rtx insn, rtx note)\n-{\n-  rtx last = XEXP (note, 0);\n-\n-  /* Find the call insn.  */\n-  while (insn != last && !CALL_P (insn))\n-    insn = NEXT_INSN (insn);\n-\n-  /* If there is none, do nothing special, since ordinary death handling\n-     can understand these insns.  */\n-  if (!CALL_P (insn))\n-    return false;\n-\n-  /* If this is a call that returns a value via an invisible pointer, the\n-     dataflow engine cannot see it so it has been marked unconditionally.\n-     Skip it unless it has been made the last insn in the libcall, for\n-     example by the combiner, in which case we're left with no easy way\n-     of asserting its liveness.  */\n-  if (!single_set (insn))\n-    {\n-      if (insn == last)\n-\treturn false;\n-      insn = NEXT_INSN (insn);\n-    }\n-\n-  while (insn != NEXT_INSN (last))\n-    {\n-      if (INSN_P (insn) && marked_insn_p (insn))\n-\treturn false;\n-      insn = NEXT_INSN (insn);\n-    }\n-\n-  return true;\n-}\n-\n-\n /* Delete all REG_EQUAL notes of the registers INSN writes, to prevent\n    bad dangling REG_EQUAL notes. */\n \n@@ -316,29 +260,10 @@ delete_unmarked_insns (void)\n     FOR_BB_INSNS_SAFE (bb, insn, next)\n       if (INSN_P (insn))\n \t{\n-\t  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-\n \t  /* Always delete no-op moves.  */\n \t  if (noop_move_p (insn))\n \t    ;\n \n-\t  /* Try to delete libcall sequences as a whole.  */\n-\t  else if (note && libcall_dead_p (insn, note))\n-\t    {\n-\t      rtx last = XEXP (note, 0);\n-\n-\t      if (!dbg_cnt (dce))\n-\t\tcontinue;\n-\n-\t      if (dump_file)\n-\t        fprintf (dump_file, \"DCE: Deleting libcall %d-%d\\n\",\n-\t\t\t INSN_UID (insn), INSN_UID (last));\n-\n-\t      next = NEXT_INSN (last);\n-\t      delete_insn_chain_and_edges (insn, last);\n-\t      continue;\n-\t    }\n-\n \t  /* Otherwise rely only on the DCE algorithm.  */\n \t  else if (marked_insn_p (insn))\n \t    continue;\n@@ -353,41 +278,6 @@ delete_unmarked_insns (void)\n \t     for the destination regs in order to avoid dangling notes.  */\n \t  delete_corresponding_reg_eq_notes (insn);\n \n-\t  /* If we're about to delete the first insn of a libcall, then\n-\t     move the REG_LIBCALL note to the next real insn and update\n-\t     the REG_RETVAL note.  */\n-\t  if (note && (XEXP (note, 0) != insn))\n-\t    {\n-\t      rtx new_libcall_insn = next_real_insn (insn);\n-\t      rtx retval_note = find_reg_note (XEXP (note, 0),\n-\t\t\t\t\t       REG_RETVAL, NULL_RTX);\n-\t      /* If the RETVAL and LIBCALL notes would land on the same\n-\t\t insn just remove them.  */\n-\t      if (XEXP (note, 0) == new_libcall_insn)\n-\t\tremove_note (new_libcall_insn, retval_note);\n-\t      else\n-\t\t{\n-\t\t  REG_NOTES (new_libcall_insn)\n-\t\t    = gen_rtx_INSN_LIST (REG_LIBCALL, XEXP (note, 0),\n-\t\t\t\t\t REG_NOTES (new_libcall_insn));\n-\t\t  XEXP (retval_note, 0) = new_libcall_insn;\n-\t\t}\n-\t    }\n-\n-\t  /* If the insn contains a REG_RETVAL note and is dead, but the\n-\t     libcall as a whole is not dead, then we want to remove the\n-\t     insn, but not the whole libcall sequence.  However, we also\n-\t     need to remove the dangling REG_LIBCALL note in order to\n-\t     avoid mismatched notes.  We could find a new location for\n-\t     the REG_RETVAL note, but it hardly seems worth the effort.  */\n-\t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n-\t  if (note && (XEXP (note, 0) != insn))\n-\t    {\n-\t      rtx libcall_note\n-\t\t= find_reg_note (XEXP (note, 0), REG_LIBCALL, NULL_RTX);\n-\t      remove_note (XEXP (note, 0), libcall_note);\n-\t    }\n-\n \t  /* If a pure or const call is deleted, this may make the cfg\n \t     have unreachable blocks.  We rememeber this and call\n \t     delete_unreachable_blocks at the end.  */\n@@ -404,43 +294,6 @@ delete_unmarked_insns (void)\n }\n \n \n-/* Helper function for prescan_insns_for_dce: prescan the entire libcall\n-   sequence starting at INSN and return the insn following the libcall.\n-   NOTE is the REG_LIBCALL note attached to INSN.  */\n-\n-static rtx\n-prescan_libcall_for_dce (rtx insn, rtx note, bool fast)\n-{\n-  rtx last = XEXP (note, 0);\n-\n-  /* A libcall is never necessary on its own but we need to mark the stores\n-     to a non-register destination.  */\n-  while (insn != last && !CALL_P (insn))\n-    {\n-      if (INSN_P (insn))\n-\tmark_nonreg_stores (PATTERN (insn), insn, fast);\n-      insn = NEXT_INSN (insn);\n-    }\n-\n-  /* If this is a call that returns a value via an invisible pointer, the\n-     dataflow engine cannot see it so it has to be marked unconditionally.  */\n-  if (CALL_P (insn) && !single_set (insn))\n-    {\n-      mark_insn (insn, fast);\n-      insn = NEXT_INSN (insn);\n-    }\n-\n-  while (insn != NEXT_INSN (last))\n-    {\n-      if (INSN_P (insn))\n-\tmark_nonreg_stores (PATTERN (insn), insn, fast);\n-      insn = NEXT_INSN (insn);\n-    }\n-\n-  return insn;\n-}\n-\n-\n /* Go through the instructions and mark those whose necessity is not\n    dependent on inter-instruction information.  Make sure all other\n    instructions are not marked.  */\n@@ -458,10 +311,7 @@ prescan_insns_for_dce (bool fast)\n     FOR_BB_INSNS_SAFE (bb, insn, next)\n       if (INSN_P (insn))\n \t{\n-\t  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-\t  if (note)\n-\t    next = prescan_libcall_for_dce (insn, note, fast);\n-\t  else if (deletable_insn_p (insn, fast))\n+\t  if (deletable_insn_p (insn, fast))\n \t    mark_nonreg_stores (PATTERN (insn), insn, fast);\n \t  else\n \t    mark_insn (insn, fast);"}, {"sha": "10e4999ca9f14da6209ecd82fd6a5ceecf44db5b", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -3754,31 +3754,6 @@ insn has one of a pair of notes that points to a second insn, which has\n the inverse note pointing back to the first insn.\n \n @table @code\n-@findex REG_RETVAL\n-@item REG_RETVAL\n-This insn copies the value of a multi-insn sequence (for example, a\n-library call), and @var{op} is the first insn of the sequence (for a\n-library call, the first insn that was generated to set up the arguments\n-for the library call).\n-\n-Loop optimization uses this note to treat such a sequence as a single\n-operation for code motion purposes and flow analysis uses this note to\n-delete such sequences whose results are dead.\n-\n-A @code{REG_EQUAL} note will also usually be attached to this insn to\n-provide the expression being computed by the sequence.\n-\n-These notes will be deleted after reload, since they are no longer\n-accurate or useful.\n-\n-@findex REG_LIBCALL\n-@item REG_LIBCALL\n-This is the inverse of @code{REG_RETVAL}: it is placed on the first\n-insn of a multi-insn sequence, and it points to the last one.\n-\n-These notes are deleted after reload, since they are no longer useful or\n-accurate.\n-\n @findex REG_CC_SETTER\n @findex REG_CC_USER\n @item REG_CC_SETTER\n@@ -3836,12 +3811,6 @@ of the JUMP@.  The format is a bitmask of ATTR_FLAG_* values.\n This is used on an RTX_FRAME_RELATED_P insn wherein the attached expression\n is used in place of the actual insn pattern.  This is done in cases where\n the pattern is either complex or misleading.\n-\n-@findex REG_LIBCALL_ID\n-@item REG_LIBCALL_ID\n-This is used to specify that an insn is part of a libcall.  Each libcall\n-in a function has a unique id, and all the insns that are part of that\n-libcall will have a REG_LIBCALL_ID note attached with the same ID.\n @end table\n \n For convenience, the machine mode in an @code{insn_list} or"}, {"sha": "d6929cf154b39105e7f4deb17726056c8d6569bd", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -3160,8 +3160,7 @@ try_split (rtx pat, rtx trial, int last)\n   rtx before = PREV_INSN (trial);\n   rtx after = NEXT_INSN (trial);\n   int has_barrier = 0;\n-  rtx tem, note_retval, note_libcall;\n-  rtx note, seq;\n+  rtx note, seq, tem;\n   int probability;\n   rtx insn_last, insn;\n   int njumps = 0;\n@@ -3296,30 +3295,6 @@ try_split (rtx pat, rtx trial, int last)\n \t  break;\n #endif\n \n-\tcase REG_LIBCALL:\n-\t  /* Relink the insns with REG_LIBCALL note and with REG_RETVAL note \n-\t     after split.  */\n-\t  REG_NOTES (insn_last) \n-\t    = gen_rtx_INSN_LIST (REG_LIBCALL,\n-\t\t\t\t XEXP (note, 0),\n-\t\t\t\t REG_NOTES (insn_last)); \n-\n-\t  note_retval = find_reg_note (XEXP (note, 0), REG_RETVAL, NULL);\n-\t  XEXP (note_retval, 0) = insn_last;\n-\t  break;\n-\n-\tcase REG_RETVAL:\n-\t  /* Relink the insns with REG_LIBCALL note and with REG_RETVAL note\n-\t     after split.  */\n-\t  REG_NOTES (insn_last) \n-\t    = gen_rtx_INSN_LIST (REG_RETVAL,\n-\t\t\t\t XEXP (note, 0),\n-\t\t\t\t REG_NOTES (insn_last)); \n-\n-\t  note_libcall = find_reg_note (XEXP (note, 0), REG_LIBCALL, NULL);\n-\t  XEXP (note_libcall, 0) = insn_last;\n-\t  break;\n-\n \tdefault:\n \t  break;\n \t}\n@@ -5501,8 +5476,7 @@ init_emit_once (int line_numbers)\n rtx\n emit_copy_of_insn_after (rtx insn, rtx after)\n {\n-  rtx new;\n-  rtx note1, note2, link;\n+  rtx new, link;\n \n   switch (GET_CODE (insn))\n     {\n@@ -5556,15 +5530,6 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n \t\t XEXP (link, 0),  REG_NOTES (new));\n       }\n \n-  /* Fix the libcall sequences.  */\n-  if ((note1 = find_reg_note (new, REG_RETVAL, NULL_RTX)) != NULL)\n-    {\n-      rtx p = new;\n-      while ((note2 = find_reg_note (p, REG_LIBCALL, NULL_RTX)) == NULL)\n-\tp = PREV_INSN (p);\n-      XEXP (note1, 0) = p;\n-      XEXP (note2, 0) = new;\n-    }\n   INSN_CODE (new) = INSN_CODE (insn);\n   return new;\n }"}, {"sha": "35bc230fa3418c4fd3a5691e96347e3b77873697", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -776,11 +776,8 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new, rtx def_insn, bool set_\n       cancel_changes (0);\n \n       /* Can also record a simplified value in a REG_EQUAL note,\n-\t making a new one if one does not already exist.\n-\t Don't do this if the insn has a REG_RETVAL note, because the\n-\t combined presence means that the REG_EQUAL note refers to the\n-\t (full) contents of the libcall value.  */\n-      if (set_reg_equal && !find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t making a new one if one does not already exist.  */\n+      if (set_reg_equal)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \" Setting REG_EQUAL note\\n\");"}, {"sha": "f7e42fb0641eb828aef3ab38e7a1d9b8163b0b94", "filename": "gcc/gcse.c", "status": "modified", "additions": 13, "deletions": 117, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -519,7 +519,7 @@ static void free_reg_set_mem (void);\n static void record_one_set (int, rtx);\n static void record_set_info (rtx, const_rtx, void *);\n static void compute_sets (void);\n-static void hash_scan_insn (rtx, struct hash_table *, int);\n+static void hash_scan_insn (rtx, struct hash_table *);\n static void hash_scan_set (rtx, rtx, struct hash_table *);\n static void hash_scan_clobber (rtx, rtx, struct hash_table *);\n static void hash_scan_call (rtx, rtx, struct hash_table *);\n@@ -635,8 +635,7 @@ static void clear_modify_mem_tables (void);\n static void free_modify_mem_tables (void);\n static rtx gcse_emit_move_after (rtx, rtx, rtx);\n static void local_cprop_find_used_regs (rtx *, void *);\n-static bool do_local_cprop (rtx, rtx, bool, rtx*);\n-static bool adjust_libcall_notes (rtx, rtx, rtx, rtx*);\n+static bool do_local_cprop (rtx, rtx, bool);\n static void local_cprop_pass (bool);\n static bool is_too_expensive (const char *);\n \f\n@@ -1838,19 +1837,14 @@ hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n    are also in the PARALLEL.  Later.\n \n    If SET_P is nonzero, this is for the assignment hash table,\n-   otherwise it is for the expression hash table.\n-   If IN_LIBCALL_BLOCK nonzero, we are in a libcall block, and should\n-   not record any expressions.  */\n+   otherwise it is for the expression hash table.  */\n \n static void\n-hash_scan_insn (rtx insn, struct hash_table *table, int in_libcall_block)\n+hash_scan_insn (rtx insn, struct hash_table *table)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n \n-  if (in_libcall_block)\n-    return;\n-\n   /* Pick out the sets of INSN and for other forms of instructions record\n      what's been modified.  */\n \n@@ -2063,7 +2057,6 @@ compute_hash_table_work (struct hash_table *table)\n     {\n       rtx insn;\n       unsigned int regno;\n-      int in_libcall_block;\n \n       /* First pass over the instructions records information used to\n \t determine when registers and memory are first and last set.\n@@ -2094,18 +2087,9 @@ compute_hash_table_work (struct hash_table *table)\n \t\t       BB_HEAD (current_bb), table);\n \n       /* The next pass builds the hash table.  */\n-      in_libcall_block = 0;\n       FOR_BB_INSNS (current_bb, insn)\n \tif (INSN_P (insn))\n-\t  {\n-\t    if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t      in_libcall_block = 1;\n-\t    else if (table->set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t      in_libcall_block = 0;\n-\t    hash_scan_insn (insn, table, in_libcall_block);\n-\t    if (!table->set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t      in_libcall_block = 0;\n-\t  }\n+\t  hash_scan_insn (insn, table);\n     }\n \n   free (reg_avail_info);\n@@ -3077,11 +3061,11 @@ local_cprop_find_used_regs (rtx *xptr, void *data)\n   find_used_regs (xptr, data);\n }\n \n-/* LIBCALL_SP is a zero-terminated array of insns at the end of a libcall;\n-   their REG_EQUAL notes need updating.  */\n+/* Try to perform local const/copy propagation on X in INSN.\n+   If ALTER_JUMPS is false, changing jump insns is not allowed.  */\n \n static bool\n-do_local_cprop (rtx x, rtx insn, bool alter_jumps, rtx *libcall_sp)\n+do_local_cprop (rtx x, rtx insn, bool alter_jumps)\n {\n   rtx newreg = NULL, newcnst = NULL;\n \n@@ -3102,10 +3086,6 @@ do_local_cprop (rtx x, rtx insn, bool alter_jumps, rtx *libcall_sp)\n \t  rtx this_rtx = l->loc;\n \t  rtx note;\n \n-\t  /* Don't CSE non-constant values out of libcall blocks.  */\n-\t  if (l->in_libcall && ! CONSTANT_P (this_rtx))\n-\t    continue;\n-\n \t  if (gcse_constant_p (this_rtx))\n \t    newcnst = this_rtx;\n \t  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER\n@@ -3120,16 +3100,6 @@ do_local_cprop (rtx x, rtx insn, bool alter_jumps, rtx *libcall_sp)\n \t}\n       if (newcnst && constprop_register (insn, x, newcnst, alter_jumps))\n \t{\n-\t  /* If we find a case where we can't fix the retval REG_EQUAL notes\n-\t     match the new register, we either have to abandon this replacement\n-\t     or fix delete_trivially_dead_insns to preserve the setting insn,\n-\t     or make it delete the REG_EQUAL note, and fix up all passes that\n-\t     require the REG_EQUAL note there.  */\n-\t  bool adjusted;\n-\n-\t  adjusted = adjust_libcall_notes (x, newcnst, insn, libcall_sp);\n-\t  gcc_assert (adjusted);\n-\t  \n \t  if (dump_file != NULL)\n \t    {\n \t      fprintf (dump_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n@@ -3144,7 +3114,6 @@ do_local_cprop (rtx x, rtx insn, bool alter_jumps, rtx *libcall_sp)\n \t}\n       else if (newreg && newreg != x && try_replace_reg (x, newreg, insn))\n \t{\n-\t  adjust_libcall_notes (x, newreg, insn, libcall_sp);\n \t  if (dump_file != NULL)\n \t    {\n \t      fprintf (dump_file,\n@@ -3159,47 +3128,6 @@ do_local_cprop (rtx x, rtx insn, bool alter_jumps, rtx *libcall_sp)\n   return false;\n }\n \n-/* LIBCALL_SP is a zero-terminated array of insns at the end of a libcall;\n-   their REG_EQUAL notes need updating to reflect that OLDREG has been\n-   replaced with NEWVAL in INSN.  Return true if all substitutions could\n-   be made.  */\n-static bool\n-adjust_libcall_notes (rtx oldreg, rtx newval, rtx insn, rtx *libcall_sp)\n-{\n-  rtx end;\n-\n-  while ((end = *libcall_sp++))\n-    {\n-      rtx note = find_reg_equal_equiv_note (end);\n-\n-      if (! note)\n-\tcontinue;\n-\n-      if (REG_P (newval))\n-\t{\n-\t  if (reg_set_between_p (newval, PREV_INSN (insn), end))\n-\t    {\n-\t      do\n-\t\t{\n-\t\t  note = find_reg_equal_equiv_note (end);\n-\t\t  if (! note)\n-\t\t    continue;\n-\t\t  if (reg_mentioned_p (newval, XEXP (note, 0)))\n-\t\t    return false;\n-\t\t}\n-\t      while ((end = *libcall_sp++));\n-\t      return true;\n-\t    }\n-\t}\n-      XEXP (note, 0) = simplify_replace_rtx (XEXP (note, 0), oldreg, newval);\n-      df_notes_rescan (end);\n-      insn = end;\n-    }\n-  return true;\n-}\n-\n-#define MAX_NESTED_LIBCALLS 9\n-\n /* Do local const/copy propagation (i.e. within each basic block).\n    If ALTER_JUMPS is true, allow propagating into jump insns, which\n    could modify the CFG.  */\n@@ -3210,29 +3138,16 @@ local_cprop_pass (bool alter_jumps)\n   basic_block bb;\n   rtx insn;\n   struct reg_use *reg_used;\n-  rtx libcall_stack[MAX_NESTED_LIBCALLS + 1], *libcall_sp;\n   bool changed = false;\n \n   cselib_init (false);\n-  libcall_sp = &libcall_stack[MAX_NESTED_LIBCALLS];\n-  *libcall_sp = 0;\n   FOR_EACH_BB (bb)\n     {\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  if (INSN_P (insn))\n \t    {\n-\t      rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-\n-\t      if (note)\n-\t\t{\n-\t\t  gcc_assert (libcall_sp != libcall_stack);\n-\t\t  *--libcall_sp = XEXP (note, 0);\n-\t\t}\n-\t      note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n-\t      if (note)\n-\t\tlibcall_sp++;\n-\t      note = find_reg_equal_equiv_note (insn);\n+\t      rtx note = find_reg_equal_equiv_note (insn);\n \t      do\n \t\t{\n \t\t  reg_use_count = 0;\n@@ -3244,8 +3159,7 @@ local_cprop_pass (bool alter_jumps)\n \t\t  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n \t\t       reg_used++, reg_use_count--)\n \t\t    {\n-\t\t      if (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps,\n-\t\t\t\t\t  libcall_sp))\n+\t\t      if (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps))\n \t\t\t{\n \t\t\t  changed = true;\n \t\t\t  break;\n@@ -3259,10 +3173,8 @@ local_cprop_pass (bool alter_jumps)\n \t  cselib_process_insn (insn);\n \t}\n \n-      /* Forget everything at the end of a basic block.  Make sure we are\n-\t not inside a libcall, they should never cross basic blocks.  */\n+      /* Forget everything at the end of a basic block.  */\n       cselib_clear_table ();\n-      gcc_assert (libcall_sp == &libcall_stack[MAX_NESTED_LIBCALLS]);\n     }\n \n   cselib_finish ();\n@@ -6376,7 +6288,7 @@ remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n static void\n replace_store_insn (rtx reg, rtx del, basic_block bb, struct ls_expr *smexpr)\n {\n-  rtx insn, mem, note, set, ptr, pair;\n+  rtx insn, mem, note, set, ptr;\n \n   mem = smexpr->pattern;\n   insn = gen_move_insn (reg, SET_SRC (single_set (del)));\n@@ -6388,25 +6300,9 @@ replace_store_insn (rtx reg, rtx del, basic_block bb, struct ls_expr *smexpr)\n \tbreak;\n       }\n \n-  /* Move the notes from the deleted insn to its replacement, and patch\n-     up the LIBCALL notes.  */\n+  /* Move the notes from the deleted insn to its replacement.  */\n   REG_NOTES (insn) = REG_NOTES (del);\n \n-  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n-  if (note)\n-    {\n-      pair = XEXP (note, 0);\n-      note = find_reg_note (pair, REG_LIBCALL, NULL_RTX);\n-      XEXP (note, 0) = insn;\n-    }\n-  note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-  if (note)\n-    {\n-      pair = XEXP (note, 0);\n-      note = find_reg_note (pair, REG_RETVAL, NULL_RTX);\n-      XEXP (note, 0) = insn;\n-    }\n-\n   /* Emit the insn AFTER all the notes are transferred.\n      This is cheaper since we avoid df rescanning for the note change.  */\n   insn = emit_insn_after (insn, del);"}, {"sha": "66773075dd60eed5069688b6ccdd63408456c6c0", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -18,9 +18,9 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* This implements the loop invariant motion pass.  It is very simple\n-   (no calls, libcalls, etc.).  This should be sufficient to cleanup things\n-   like address arithmetics -- other more complicated invariants should be\n-   eliminated on tree level either in tree-ssa-loop-im.c or in tree-ssa-pre.c.\n+   (no calls, no loads/stores, etc.).  This should be sufficient to cleanup\n+   things like address arithmetics -- other more complicated invariants should\n+   be eliminated on GIMPLE either in tree-ssa-loop-im.c or in tree-ssa-pre.c.\n \n    We proceed loop by loop -- it is simpler than trying to handle things\n    globally and should not lose much.  First we inspect all sets inside loop\n@@ -795,11 +795,6 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n   bool simple = true;\n   struct invariant *inv;\n \n-  /* Until we get rid of LIBCALLS.  */\n-  if (find_reg_note (insn, REG_RETVAL, NULL_RTX)\n-      || find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-    return;\n-\n #ifdef HAVE_cc0\n   /* We can't move a CC0 setter without the user.  */\n   if (sets_cc0_p (insn))"}, {"sha": "67a95984fab266f82ee96bd65a84193e00bba908", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 8, "deletions": 86, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -225,11 +225,9 @@ enum classify_move_insn\n {\n   /* Not a simple move from one location to another.  */\n   NOT_SIMPLE_MOVE,\n-  /* A simple move from one pseudo-register to another with no\n-     REG_RETVAL note.  */\n+  /* A simple move from one pseudo-register to another.  */\n   SIMPLE_PSEUDO_REG_MOVE,\n-  /* A simple move involving a non-pseudo-register, or from one\n-     pseudo-register to another with a REG_RETVAL note.  */\n+  /* A simple move involving a non-pseudo-register.  */\n   SIMPLE_MOVE\n };\n \n@@ -304,10 +302,10 @@ find_decomposable_subregs (rtx *px, void *data)\n \n \t If this is not a simple copy from one location to another,\n \t then we can not decompose this register.  If this is a simple\n-\t copy from one pseudo-register to another, with no REG_RETVAL\n-\t note, and the mode is right, then we mark the register as\n-\t decomposable.  Otherwise we don't say anything about this\n-\t register--it could be decomposed, but whether that would be\n+\t copy from one pseudo-register to another, and the mode is right\n+\t then we mark the register as decomposable.\n+\t Otherwise we don't say anything about this register --\n+\t it could be decomposed, but whether that would be\n \t profitable depends upon how it is used elsewhere.\n \n \t We only set bits in the bitmap for multi-word\n@@ -558,47 +556,6 @@ move_eh_region_note (rtx insn, rtx insns)\n     }\n }\n \n-/* If there is a REG_LIBCALL note on OLD_START, move it to NEW_START,\n-   and link the corresponding REG_RETVAL note to NEW_START.  */\n-\n-static void\n-move_libcall_note (rtx old_start, rtx new_start)\n-{\n-  rtx note0, note1, end;\n-\n-  note0 = find_reg_note (old_start, REG_LIBCALL, NULL);\n-  if (note0 == NULL_RTX)\n-    return;\n-\n-  remove_note (old_start, note0);\n-  end = XEXP (note0, 0);\n-  note1 = find_reg_note (end, REG_RETVAL, NULL);\n-\n-  XEXP (note0, 1) = REG_NOTES (new_start);\n-  REG_NOTES (new_start) = note0;\n-  XEXP (note1, 0) = new_start;\n-}\n-\n-/* Remove any REG_RETVAL note, the corresponding REG_LIBCALL note, and\n-   any markers for a no-conflict block.  We have decomposed the\n-   registers so the non-conflict is now obvious.  */\n-\n-static void\n-remove_retval_note (rtx insn1)\n-{\n-  rtx note0, insn0, note1;\n-\n-  note1 = find_reg_note (insn1, REG_RETVAL, NULL);\n-  if (note1 == NULL_RTX)\n-    return;\n-\n-  insn0 = XEXP (note1, 0);\n-  note0 = find_reg_note (insn0, REG_LIBCALL, NULL);\n-\n-  remove_note (insn0, note0);\n-  remove_note (insn1, note1);\n-}\n-\n /* Resolve any decomposed registers which appear in register notes on\n    INSN.  */\n \n@@ -612,10 +569,7 @@ resolve_reg_notes (rtx insn)\n     {\n       int old_count = num_validated_changes ();\n       if (for_each_rtx (&XEXP (note, 0), resolve_subreg_use, NULL))\n-\t{\n-\t  remove_note (insn, note);\n-\t  remove_retval_note (insn);\n-\t}\n+\tremove_note (insn, note);\n       else\n \tif (old_count != num_validated_changes ())\n \t  df_notes_rescan (insn);\n@@ -870,8 +824,6 @@ resolve_simple_move (rtx set, rtx insn)\n \n   emit_insn_before (insns, insn);\n \n-  move_libcall_note (insn, insns);\n-  remove_retval_note (insn);\n   delete_insn (insn);\n \n   return insns;\n@@ -1156,34 +1108,8 @@ decompose_multiword_subregs (void)\n \t    cmi = NOT_SIMPLE_MOVE;\n \t  else\n \t    {\n-\t      bool retval;\n-\n-\t      retval = find_reg_note (insn, REG_RETVAL, NULL_RTX) != NULL_RTX;\n-\n-\t      if (find_pseudo_copy (set) && !retval)\n+\t      if (find_pseudo_copy (set))\n \t\tcmi = SIMPLE_PSEUDO_REG_MOVE;\n-\t      else if (retval\n-\t\t       && REG_P (SET_SRC (set))\n-\t\t       && HARD_REGISTER_P (SET_SRC (set)))\n-\t\t{\n-\t\t  rtx note;\n-\n-\t\t  /* We don't want to decompose an assignment which\n-\t\t     copies the value returned by a libcall to a\n-\t\t     pseudo-register.  Doing that will lose the RETVAL\n-\t\t     note with no real gain.  */\n-\t\t  cmi = NOT_SIMPLE_MOVE;\n-\n-\t\t  /* If we have a RETVAL note, there should be an\n-\t\t     EQUAL note.  We don't want to decompose any\n-\t\t     registers which that EQUAL note refers to\n-\t\t     directly.  If we do, we will no longer know the\n-\t\t     value of the libcall.  */\n-\t\t  note = find_reg_equal_equiv_note (insn);\n-\t\t  if (note != NULL_RTX)\n-\t\t    for_each_rtx (&XEXP (note, 0), find_decomposable_subregs,\n-\t\t\t\t  &cmi);\n-\t\t}\n \t      else\n \t\tcmi = SIMPLE_MOVE;\n \t    }\n@@ -1277,8 +1203,6 @@ decompose_multiword_subregs (void)\n \t\t      insn = resolve_simple_move (set, insn);\n \t\t      if (insn != orig_insn)\n \t\t\t{\n-\t\t\t  remove_retval_note (insn);\n-\n \t\t\t  recog_memoized (insn);\n \t\t\t  extract_insn (insn);\n \n@@ -1319,8 +1243,6 @@ decompose_multiword_subregs (void)\n \n \t\t      i = apply_change_group ();\n \t\t      gcc_assert (i);\n-\n-\t\t      remove_retval_note (insn);\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "5a5325f01ae35a05c37403b9cf00917e06e10ce7", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -52,23 +52,9 @@ REG_NOTE (EQUIV)\n \n /* Like REG_EQUIV except that the destination is only momentarily\n    equal to the specified rtx.  Therefore, it cannot be used for\n-   substitution; but it can be used for cse.  Together with a\n-   REG_RETVAL note, it means that the insn sets the full contents of\n-   the libcall value.  */\n+   substitution; but it can be used for cse.  */\n REG_NOTE (EQUAL)\n \n-/* This insn copies the return-value of a library call out of the hard\n-   reg for return values.  This note is actually an INSN_LIST and it\n-   points to the first insn involved in setting up arguments for the\n-   call.  flow.c uses this to delete the entire library call when its\n-   result is dead.  */\n-REG_NOTE (RETVAL)\n-\n-/* The inverse of REG_RETVAL: it goes on the first insn of the library\n-   call and points at the one that has the REG_RETVAL.  This note is\n-   also an INSN_LIST.  */\n-REG_NOTE (LIBCALL)\n-\n /* The register is always nonnegative during the containing loop.\n    This is used in branches so that decrement and branch instructions\n    terminating on zero can be matched.  There must be an insn pattern"}, {"sha": "48424abb68fb04f17a5de398e21f8fe19d59f348", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -1219,9 +1219,8 @@ reload (rtx first, int global)\n      notes.  Delete all CLOBBER insns, except those that refer to the return\n      value and the special mem:BLK CLOBBERs added to prevent the scheduler\n      from misarranging variable-array code, and simplify (subreg (reg))\n-     operands.  Also remove all REG_RETVAL and REG_LIBCALL notes since they\n-     are no longer useful or accurate.  Strip and regenerate REG_INC notes\n-     that may have been moved around.  */\n+     operands.  Strip and regenerate REG_INC notes that may have been moved\n+     around.  */\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n@@ -1274,9 +1273,7 @@ reload (rtx first, int global)\n \t  {\n \t    if (REG_NOTE_KIND (*pnote) == REG_DEAD\n \t\t|| REG_NOTE_KIND (*pnote) == REG_UNUSED\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_INC\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_RETVAL\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_LIBCALL)\n+\t\t|| REG_NOTE_KIND (*pnote) == REG_INC)\n \t      *pnote = XEXP (*pnote, 1);\n \t    else\n \t      pnote = &XEXP (*pnote, 1);"}, {"sha": "56311d970e9034f6d887cbb4d48fe7c39bf36982", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -1123,11 +1123,6 @@ noop_move_p (const_rtx insn)\n   if (find_reg_note (insn, REG_EQUAL, NULL_RTX))\n     return 0;\n \n-  /* For now treat an insn with a REG_RETVAL note as a\n-     special insn which should not be considered a no-op.  */\n-  if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-    return 0;\n-\n   if (GET_CODE (pat) == SET && set_noop_p (pat))\n     return 1;\n "}, {"sha": "b8b3a4418dfc63325ef5a4a4383594fea9a825a8", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -2121,16 +2121,6 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n       reg_pending_barrier = NOT_A_BARRIER;\n     }\n \n-  /* If we are currently in a libcall scheduling group, then mark the\n-     current insn as being in a scheduling group and that it can not\n-     be moved into a different basic block.  */\n-\n-  if (deps->libcall_block_tail_insn)\n-    {\n-      SCHED_GROUP_P (insn) = 1;\n-      CANT_MOVE (insn) = 1;\n-    }\n-\n   /* If a post-call group is still open, see if it should remain so.\n      This insn must be a simple move of a hard reg to a pseudo or\n      vice-versa.\n@@ -2226,8 +2216,6 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n     }\n   for (insn = head;; insn = NEXT_INSN (insn))\n     {\n-      rtx link, end_seq, r0, set;\n-\n       if (INSN_P (insn))\n \t{\n \t  /* And initialize deps_lists.  */\n@@ -2326,45 +2314,6 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n       if (current_sched_info->use_cselib)\n \tcselib_process_insn (insn);\n \n-      /* Now that we have completed handling INSN, check and see if it is\n-\t a CLOBBER beginning a libcall block.   If it is, record the\n-\t end of the libcall sequence.\n-\n-\t We want to schedule libcall blocks as a unit before reload.  While\n-\t this restricts scheduling, it preserves the meaning of a libcall\n-\t block.\n-\n-\t As a side effect, we may get better code due to decreased register\n-\t pressure as well as less chance of a foreign insn appearing in\n-\t a libcall block.  */\n-      if (!reload_completed\n-\t  /* Note we may have nested libcall sequences.  We only care about\n-\t     the outermost libcall sequence.  */\n-\t  && deps->libcall_block_tail_insn == 0\n-\t  /* The sequence must start with a clobber of a register.  */\n-\t  && NONJUMP_INSN_P (insn)\n-\t  && GET_CODE (PATTERN (insn)) == CLOBBER\n-          && (r0 = XEXP (PATTERN (insn), 0), REG_P (r0))\n-\t  && REG_P (XEXP (PATTERN (insn), 0))\n-\t  /* The CLOBBER must also have a REG_LIBCALL note attached.  */\n-\t  && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n-\t  && (end_seq = XEXP (link, 0)) != 0\n-\t  /* The insn referenced by the REG_LIBCALL note must be a\n-\t     simple nop copy with the same destination as the register\n-\t     mentioned in the clobber.  */\n-\t  && (set = single_set (end_seq)) != 0\n-\t  && SET_DEST (set) == r0 && SET_SRC (set) == r0\n-\t  /* And finally the insn referenced by the REG_LIBCALL must\n-\t     also contain a REG_EQUAL note and a REG_RETVAL note.  */\n-\t  && find_reg_note (end_seq, REG_EQUAL, NULL_RTX) != 0\n-\t  && find_reg_note (end_seq, REG_RETVAL, NULL_RTX) != 0)\n-\tdeps->libcall_block_tail_insn = XEXP (link, 0);\n-\n-      /* If we have reached the end of a libcall block, then close the\n-\t block.  */\n-      if (deps->libcall_block_tail_insn == insn)\n-\tdeps->libcall_block_tail_insn = 0;\n-\n       if (insn == tail)\n \t{\n \t  if (current_sched_info->use_cselib)\n@@ -2452,7 +2401,6 @@ init_deps (struct deps *deps)\n   deps->last_function_call = 0;\n   deps->sched_before_next_call = 0;\n   deps->in_post_call_group_p = not_post_call;\n-  deps->libcall_block_tail_insn = 0;\n }\n \n /* Free insn lists found in DEPS.  */"}, {"sha": "f2e39bf4fc3e39943ac9b6dbcea976ef7ce32999", "filename": "gcc/sched-int.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -307,12 +307,6 @@ struct deps\n      the call.  */\n   enum { not_post_call, post_call, post_call_initial } in_post_call_group_p;\n \n-  /* Set to the tail insn of the outermost libcall block.\n-\n-     When nonzero, we will mark each insn processed by sched_analyze_insn\n-     with SCHED_GROUP_P to ensure libcalls are scheduled as a unit.  */\n-  rtx libcall_block_tail_insn;\n-\n   /* The maximum register number for the following arrays.  Before reload\n      this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n   int max_reg;"}, {"sha": "2d664e17cfb2e1cd0cb94c9384d4f30028aab1f8", "filename": "gcc/see.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -3489,12 +3489,6 @@ see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n       if (!reg_set_between_p (source_register, PREV_INSN (prev_insn), insn))\n \treturn NOT_RELEVANT;\n \n-      if (find_reg_note (prev_insn, REG_LIBCALL, NULL_RTX))\n-\treturn NOT_RELEVANT;\n-\n-      if (find_reg_note (prev_insn, REG_RETVAL, NULL_RTX))\n-\treturn NOT_RELEVANT;\n-\n       /* If we can't use copy_rtx on the reference it can't be a reference.  */\n       if (GET_CODE (PATTERN (prev_insn)) == PARALLEL\n \t   && asm_noperands (PATTERN (prev_insn)) >= 0)\n@@ -3690,11 +3684,7 @@ see_update_relevancy (void)\n \t  unsigned int uid = INSN_UID (insn);\n \t  if (INSN_P (insn))\n \t    {\n-\t      if (find_reg_note (insn, REG_LIBCALL, NULL_RTX)\n-\t\t  || find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t\tet = NOT_RELEVANT;\n-\t      else\n-\t\tet = RELEVANT_USE;\n+\t      et = RELEVANT_USE;\n \n \t      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t\t{"}, {"sha": "84987df5e1ffa443aae31b206e62d0b7a0f9b836", "filename": "gcc/web.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=4a8cae8370a9c7ccaff2df5b552f52db51eb9f9b", "patch": "@@ -152,9 +152,7 @@ union_defs (struct df_ref *use, struct web_entry *def_entry,\n \teq_use_link++;\n     }\n \n-  /* Recognize trivial noop moves and attempt to keep them as noop.\n-     While most of noop moves should be removed, we still keep some\n-     of them at libcall boundaries and such.  */\n+  /* Recognize trivial noop moves and attempt to keep them as noop.  */\n \n   if (set\n       && SET_SRC (set) == DF_REF_REG (use)"}]}