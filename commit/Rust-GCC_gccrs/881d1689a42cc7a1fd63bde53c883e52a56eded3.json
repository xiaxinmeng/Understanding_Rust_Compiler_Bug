{"sha": "881d1689a42cc7a1fd63bde53c883e52a56eded3", "node_id": "C_kwDOANBUbNoAKDg4MWQxNjg5YTQyY2M3YTFmZDYzYmRlNTNjODgzZTUyYTU2ZWRlZDM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-06T12:28:57Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-06T19:12:01Z"}, "message": "libstdc++: Implement std::move_only_function for C++23 (P0288R9)\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new headers.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/functional: Include <bits/move_only_function.h>.\n\t* include/std/version (__cpp_lib_move_only_function): Define.\n\t* include/bits/mofunc_impl.h: New file.\n\t* include/bits/move_only_function.h: New file.\n\t* testsuite/20_util/move_only_function/call.cc: New test.\n\t* testsuite/20_util/move_only_function/cons.cc: New test.\n\t* testsuite/20_util/move_only_function/move.cc: New test.\n\t* testsuite/20_util/move_only_function/version.cc: New test.", "tree": {"sha": "34d9c085ad1880963f1cea61893672cd28901b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34d9c085ad1880963f1cea61893672cd28901b76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/881d1689a42cc7a1fd63bde53c883e52a56eded3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881d1689a42cc7a1fd63bde53c883e52a56eded3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881d1689a42cc7a1fd63bde53c883e52a56eded3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881d1689a42cc7a1fd63bde53c883e52a56eded3/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad451b020a24fe7111e668f8c41a3ba648104569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad451b020a24fe7111e668f8c41a3ba648104569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad451b020a24fe7111e668f8c41a3ba648104569"}], "stats": {"total": 828, "additions": 828, "deletions": 0}, "files": [{"sha": "27b548607b9f553da80b5a63b088923f4e1b75b4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -154,7 +154,9 @@ bits_headers = \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/max_size_type.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n+\t${bits_srcdir}/mofunc_impl.h \\\n \t${bits_srcdir}/move.h \\\n+\t${bits_srcdir}/move_only_function.h \\\n \t${bits_srcdir}/node_handle.h \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\"}, {"sha": "8a45d9670aa9d9426413d5f0e98f52dcf3502c0a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -504,7 +504,9 @@ bits_headers = \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/max_size_type.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n+\t${bits_srcdir}/mofunc_impl.h \\\n \t${bits_srcdir}/move.h \\\n+\t${bits_srcdir}/move_only_function.h \\\n \t${bits_srcdir}/node_handle.h \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\"}, {"sha": "543c6f547b70b529c8a0bc17e2ee921008ef2b9a", "filename": "libstdc++-v3/include/bits/mofunc_impl.h", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmofunc_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmofunc_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmofunc_impl.h?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -0,0 +1,200 @@\n+// Implementation of std::move_only_function -*- C++ -*-\n+\n+// Copyright The GNU Toolchain Authors.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/mofunc_impl.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{functional}\n+ */\n+\n+#ifndef _GLIBCXX_MOF_CV\n+# define _GLIBCXX_MOF_CV\n+#endif\n+\n+#ifdef _GLIBCXX_MOF_REF\n+# define _GLIBCXX_MOF_INV_QUALS _GLIBCXX_MOF_CV _GLIBCXX_MOF_REF\n+#else\n+# define _GLIBCXX_MOF_REF\n+# define _GLIBCXX_MOF_INV_QUALS _GLIBCXX_MOF_CV &\n+#endif\n+\n+#define _GLIBCXX_MOF_CV_REF _GLIBCXX_MOF_CV _GLIBCXX_MOF_REF\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Res, typename... _ArgTypes, bool _Noex>\n+    class move_only_function<_Res(_ArgTypes...) _GLIBCXX_MOF_CV\n+\t\t\t       _GLIBCXX_MOF_REF noexcept(_Noex)>\n+    : _Mofunc_base\n+    {\n+      template<typename _Tp>\n+\tusing __callable\n+\t  = __conditional_t<_Noex,\n+\t\t\t    is_nothrow_invocable_r<_Res, _Tp, _ArgTypes...>,\n+\t\t\t    is_invocable_r<_Res, _Tp, _ArgTypes...>>;\n+\n+      // [func.wrap.mov.con]/1 is-callable-from<VT>\n+      template<typename _Vt>\n+\tstatic constexpr bool __is_callable_from\n+\t  = __and_v<__callable<_Vt _GLIBCXX_MOF_CV_REF>,\n+\t\t    __callable<_Vt _GLIBCXX_MOF_INV_QUALS>>;\n+\n+    public:\n+      using result_type = _Res;\n+\n+      move_only_function() noexcept { }\n+\n+      move_only_function(nullptr_t) noexcept { }\n+\n+      move_only_function(move_only_function&& __x) noexcept\n+      : _Mofunc_base(static_cast<_Mofunc_base&&>(__x)),\n+\t_M_invoke(std::__exchange(__x._M_invoke, nullptr))\n+      { }\n+\n+      template<typename _Fn, typename _Vt = decay_t<_Fn>>\n+\trequires (!is_same_v<_Vt, move_only_function>)\n+\t  && (!__is_in_place_type_v<_Vt>) && __is_callable_from<_Vt>\n+\tmove_only_function(_Fn&& __f) noexcept(_S_nothrow_init<_Vt, _Fn>())\n+\t{\n+\t  if constexpr (is_function_v<remove_pointer_t<_Vt>>\n+\t\t\t|| is_member_pointer_v<_Vt>\n+\t\t\t|| __is_move_only_function_v<_Vt>)\n+\t    {\n+\t      if (__f == nullptr)\n+\t\treturn;\n+\t    }\n+\t  _M_init<_Vt>(std::forward<_Fn>(__f));\n+\t  _M_invoke = &_S_invoke<_Vt>;\n+\t}\n+\n+      template<typename _Tp, typename... _Args>\n+\trequires is_constructible_v<_Tp, _Args...>\n+\t  && __is_callable_from<_Tp>\n+\texplicit\n+\tmove_only_function(in_place_type_t<_Tp>, _Args&&... __args)\n+\tnoexcept(_S_nothrow_init<_Tp, _Args...>())\n+\t: _M_invoke(&_S_invoke<_Tp>)\n+\t{\n+\t  static_assert(is_same_v<decay_t<_Tp>, _Tp>);\n+\t  _M_init<_Tp>(std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename _Tp, typename _Up, typename... _Args>\n+\trequires is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>\n+\t  && __is_callable_from<_Tp>\n+\texplicit\n+\tmove_only_function(in_place_type_t<_Tp>, initializer_list<_Up> __il,\n+\t\t\t   _Args&&... __args)\n+\tnoexcept(_S_nothrow_init<_Tp, initializer_list<_Up>&, _Args...>())\n+\t: _Mofunc_base(nullptr), _M_invoke(&_S_invoke<_Tp>)\n+\t{\n+\t  static_assert(is_same_v<decay_t<_Tp>, _Tp>);\n+\t  _M_init<_Tp>(__il, std::forward<_Args>(__args)...);\n+\t}\n+\n+      move_only_function&\n+      operator=(move_only_function&& __x) noexcept\n+      {\n+\t_Mofunc_base::operator=(static_cast<_Mofunc_base&&>(__x));\n+\t_M_invoke = std::__exchange(__x._M_invoke, nullptr);\n+\treturn *this;\n+      }\n+\n+      move_only_function&\n+      operator=(nullptr_t) noexcept\n+      {\n+\t_Mofunc_base::operator=(nullptr);\n+\t_M_invoke = nullptr;\n+\treturn *this;\n+      }\n+\n+      template<typename _Fn>\n+\trequires is_constructible_v<move_only_function, _Fn>\n+\tmove_only_function&\n+\toperator=(_Fn&& __f)\n+\tnoexcept(is_nothrow_constructible_v<move_only_function, _Fn>)\n+\t{\n+\t  move_only_function(std::forward<_Fn>(__f)).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      ~move_only_function() = default;\n+\n+      explicit operator bool() const noexcept { return _M_invoke != nullptr; }\n+\n+      _Res\n+      operator()(_ArgTypes... __args) _GLIBCXX_MOF_CV_REF noexcept(_Noex)\n+      {\n+\t__glibcxx_assert(*this != nullptr);\n+\treturn _M_invoke(this, std::forward<_ArgTypes>(__args)...);\n+      }\n+\n+      void\n+      swap(move_only_function& __x) noexcept\n+      {\n+\t_Mofunc_base::swap(__x);\n+\tstd::swap(_M_invoke, __x._M_invoke);\n+      }\n+\n+      friend void\n+      swap(move_only_function& __x, move_only_function& __y) noexcept\n+      { __x.swap(__y); }\n+\n+      friend bool\n+      operator==(const move_only_function& __x, nullptr_t) noexcept\n+      { return __x._M_invoke == nullptr; }\n+\n+    private:\n+      template<typename _Tp>\n+\tusing __param_t\n+\t  = __conditional_t<is_trivially_copyable_v<_Tp>\n+\t\t\t      && sizeof(_Tp) <= sizeof(long),\n+\t\t\t    _Tp, _Tp&&>;\n+\n+      using _Invoker = _Res (*)(_Mofunc_base _GLIBCXX_MOF_CV*,\n+\t\t\t\t__param_t<_ArgTypes>...) noexcept(_Noex);\n+\n+      template<typename _Tp>\n+\tstatic _Res\n+\t_S_invoke(_Mofunc_base _GLIBCXX_MOF_CV* __self,\n+\t\t  __param_t<_ArgTypes>... __args) noexcept(_Noex)\n+\t{\n+\t  using _TpCv = _Tp _GLIBCXX_MOF_CV;\n+\t  using _TpInv = _Tp _GLIBCXX_MOF_INV_QUALS;\n+\t  return std::__invoke_r<_Res>(\n+\t      std::forward<_TpInv>(*_S_access<_TpCv>(__self)),\n+\t      std::forward<__param_t<_ArgTypes>>(__args)...);\n+\t}\n+\n+      _Invoker _M_invoke = nullptr;\n+    };\n+\n+#undef _GLIBCXX_MOF_CV_REF\n+#undef _GLIBCXX_MOF_CV\n+#undef _GLIBCXX_MOF_REF\n+#undef _GLIBCXX_MOF_INV_QUALS\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std"}, {"sha": "f96552a7c89b9dd637e99c7ae0695b84bd1a97af", "filename": "libstdc++-v3/include/bits/move_only_function.h", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove_only_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove_only_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove_only_function.h?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -0,0 +1,204 @@\n+// Implementation of std::move_only_function -*- C++ -*-\n+\n+// Copyright The GNU Toolchain Authors.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/move_only_function.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{functional}\n+ */\n+\n+#ifndef _GLIBCXX_MOVE_ONLY_FUNCTION_H\n+#define _GLIBCXX_MOVE_ONLY_FUNCTION_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 202002L\n+\n+#include <bits/invoke.h>\n+#include <bits/utility.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#define __cpp_lib_move_only_function 202110L\n+\n+  template<typename... _Signature>\n+    class move_only_function; // not defined\n+\n+  /// @cond undocumented\n+  class _Mofunc_base\n+  {\n+  protected:\n+    _Mofunc_base() noexcept\n+    : _M_manage(_S_empty)\n+    { }\n+\n+    _Mofunc_base(_Mofunc_base&& __x) noexcept\n+    {\n+      _M_manage = std::__exchange(__x._M_manage, _S_empty);\n+      _M_manage(_M_storage, &__x._M_storage);\n+    }\n+\n+    template<typename _Tp, typename... _Args>\n+      static constexpr bool\n+      _S_nothrow_init() noexcept\n+      {\n+\tif constexpr (__stored_locally<_Tp>)\n+\t  return is_nothrow_constructible_v<_Tp, _Args...>;\n+\treturn false;\n+      }\n+\n+    template<typename _Tp, typename... _Args>\n+      void\n+      _M_init(_Args&&... __args) noexcept(_S_nothrow_init<_Tp, _Args...>())\n+      {\n+\tif constexpr (__stored_locally<_Tp>)\n+\t  ::new (_M_storage._M_addr()) _Tp(std::forward<_Args>(__args)...);\n+\telse\n+\t  _M_storage._M_p = new _Tp(std::forward<_Args>(__args)...);\n+\n+\t_M_manage = &_S_manage<_Tp>;\n+      }\n+\n+    _Mofunc_base&\n+    operator=(_Mofunc_base&& __x) noexcept\n+    {\n+      _M_manage(_M_storage, nullptr);\n+      _M_manage = std::__exchange(__x._M_manage, _S_empty);\n+      _M_manage(_M_storage, &__x._M_storage);\n+      return *this;\n+    }\n+\n+    _Mofunc_base&\n+    operator=(nullptr_t) noexcept\n+    {\n+      _M_manage(_M_storage, nullptr);\n+      _M_manage = _S_empty;\n+      return *this;\n+    }\n+\n+    ~_Mofunc_base() { _M_manage(_M_storage, nullptr); }\n+\n+    void\n+    swap(_Mofunc_base& __x) noexcept\n+    {\n+      // Order of operations here is more efficient if __x is empty.\n+      _Storage __s;\n+      __x._M_manage(__s, &__x._M_storage);\n+      _M_manage(__x._M_storage, &_M_storage);\n+      __x._M_manage(_M_storage, &__s);\n+      std::swap(_M_manage, __x._M_manage);\n+    }\n+\n+    template<typename _Tp, typename _Self>\n+      static _Tp*\n+      _S_access(_Self* __self) noexcept\n+      {\n+\tif constexpr (__stored_locally<remove_const_t<_Tp>>)\n+\t  return static_cast<_Tp*>(__self->_M_storage._M_addr());\n+\telse\n+\t  return static_cast<_Tp*>(__self->_M_storage._M_p);\n+      }\n+\n+  private:\n+    struct _Storage\n+    {\n+      void*       _M_addr() noexcept       { return &_M_bytes[0]; }\n+      const void* _M_addr() const noexcept { return &_M_bytes[0]; }\n+\n+      // We want to have enough space to store a simple delegate type.\n+      struct _Delegate { void (_Storage::*__pfm)(); _Storage* __obj; };\n+      union {\n+\tvoid* _M_p;\n+\talignas(_Delegate) alignas(void(*)())\n+\t  unsigned char _M_bytes[sizeof(_Delegate)];\n+      };\n+    };\n+\n+    template<typename _Tp>\n+      static constexpr bool __stored_locally\n+\t= sizeof(_Tp) <= sizeof(_Storage) && alignof(_Tp) <= alignof(_Storage)\n+\t    && is_nothrow_move_constructible_v<_Tp>;\n+\n+    // A function that either destroys the target object stored in __target,\n+    // or moves the target object from *__src to __target.\n+    using _Manager = void (*)(_Storage& __target, _Storage* __src) noexcept;\n+\n+    // The no-op manager function for objects with no target.\n+    static void _S_empty(_Storage&, _Storage*) noexcept { }\n+\n+    // The real manager function for a target object of type _Tp.\n+    template<typename _Tp>\n+      static void\n+      _S_manage(_Storage& __target, _Storage* __src) noexcept\n+      {\n+\tif constexpr (__stored_locally<_Tp>)\n+\t  {\n+\t    if (__src)\n+\t      {\n+\t\t_Tp* __rval = static_cast<_Tp*>(__src->_M_addr());\n+\t\t::new (__target._M_addr()) _Tp(std::move(*__rval));\n+\t\t__rval->~_Tp();\n+\t      }\n+\t    else\n+\t      static_cast<_Tp*>(__target._M_addr())->~_Tp();\n+\t  }\n+\telse\n+\t  {\n+\t    if (__src)\n+\t      __target._M_p = __src->_M_p;\n+\t    else\n+\t      delete static_cast<_Tp*>(__target._M_p);\n+\t  }\n+      }\n+\n+    _Storage _M_storage;\n+    _Manager _M_manage;\n+  };\n+\n+  template<typename _Tp>\n+    inline constexpr bool __is_move_only_function_v = false;\n+  template<typename _Tp>\n+    constexpr bool __is_move_only_function_v<move_only_function<_Tp>> = true;\n+  /// @endcond\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#include \"mofunc_impl.h\"\n+#define _GLIBCXX_MOF_CV const\n+#include \"mofunc_impl.h\"\n+#define _GLIBCXX_MOF_REF &\n+#include \"mofunc_impl.h\"\n+#define _GLIBCXX_MOF_REF &&\n+#include \"mofunc_impl.h\"\n+#define _GLIBCXX_MOF_CV const\n+#define _GLIBCXX_MOF_REF &\n+#include \"mofunc_impl.h\"\n+#define _GLIBCXX_MOF_CV const\n+#define _GLIBCXX_MOF_REF &&\n+#include \"mofunc_impl.h\"\n+\n+#endif // C++23\n+#endif // _GLIBCXX_MOVE_ONLY_FUNCTION_H"}, {"sha": "2db1c05349b4f9208d01c3321011fed809084674", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -67,6 +67,9 @@\n # include <bits/ranges_cmp.h>\n # include <compare>\n #endif\n+#if __cplusplus > 202002L\n+# include <bits/move_only_function.h>\n+#endif\n \n #endif // C++11\n "}, {"sha": "24b86e0fa639239f209e579abc65cd610f36e606", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -284,6 +284,7 @@\n #define __cpp_lib_adaptor_iterator_pair_constructor 202106L\n #define __cpp_lib_invoke_r 202106L\n #define __cpp_lib_is_scoped_enum 202011L\n+#define __cpp_lib_move_only_function 202110L\n #define __cpp_lib_string_contains 202011L\n #define __cpp_lib_to_underlying 202102L\n #endif // C++2b"}, {"sha": "9ca0a60a24e8983cda69e0a3f41d7953ca2b4c09", "filename": "libstdc++-v3/testsuite/20_util/move_only_function/call.cc", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fcall.cc?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -0,0 +1,199 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <functional>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+using std::move_only_function;\n+\n+using std::is_same_v;\n+using std::is_invocable_v;\n+using std::is_nothrow_invocable_v;\n+using std::invoke_result_t;\n+\n+// Check return types\n+static_assert( is_same_v<void, invoke_result_t<move_only_function<void()>>> );\n+static_assert( is_same_v<int, invoke_result_t<move_only_function<int()>>> );\n+static_assert( is_same_v<int&, invoke_result_t<move_only_function<int&()>>> );\n+\n+// With const qualifier\n+static_assert( ! is_invocable_v< move_only_function<void()> const > );\n+static_assert( ! is_invocable_v< move_only_function<void()> const &> );\n+static_assert( is_invocable_v< move_only_function<void() const> > );\n+static_assert( is_invocable_v< move_only_function<void() const> &> );\n+static_assert( is_invocable_v< move_only_function<void() const> const > );\n+static_assert( is_invocable_v< move_only_function<void() const> const &> );\n+\n+// With no ref-qualifier\n+static_assert( is_invocable_v< move_only_function<void()> > );\n+static_assert( is_invocable_v< move_only_function<void()> &> );\n+static_assert( is_invocable_v< move_only_function<void() const> > );\n+static_assert( is_invocable_v< move_only_function<void() const> &> );\n+static_assert( is_invocable_v< move_only_function<void() const> const > );\n+static_assert( is_invocable_v< move_only_function<void() const> const &> );\n+\n+// With & ref-qualifier\n+static_assert( ! is_invocable_v< move_only_function<void()&> > );\n+static_assert( is_invocable_v< move_only_function<void()&> &> );\n+static_assert( is_invocable_v< move_only_function<void() const&> > );\n+static_assert( is_invocable_v< move_only_function<void() const&> &> );\n+static_assert( is_invocable_v< move_only_function<void() const&> const > );\n+static_assert( is_invocable_v< move_only_function<void() const&> const &> );\n+\n+// With && ref-qualifier\n+static_assert( is_invocable_v< move_only_function<void()&&> > );\n+static_assert( ! is_invocable_v< move_only_function<void()&&> &> );\n+static_assert( is_invocable_v< move_only_function<void() const&&> > );\n+static_assert( ! is_invocable_v< move_only_function<void() const&&> &> );\n+static_assert( is_invocable_v< move_only_function<void() const&&> const > );\n+static_assert( ! is_invocable_v< move_only_function<void() const&&> const &> );\n+\n+// With noexcept-specifier\n+static_assert( ! is_nothrow_invocable_v< move_only_function<void()> > );\n+static_assert( ! is_nothrow_invocable_v< move_only_function<void() noexcept(false)> > );\n+static_assert( is_nothrow_invocable_v< move_only_function<void() noexcept> > );\n+static_assert( is_nothrow_invocable_v< move_only_function<void()& noexcept>& > );\n+\n+void\n+test01()\n+{\n+  struct F\n+  {\n+    int operator()() { return 0; }\n+    int operator()() const { return 1; }\n+  };\n+\n+  move_only_function<int()> f0{F{}};\n+  VERIFY( f0() == 0 );\n+  VERIFY( std::move(f0)() == 0 );\n+\n+  move_only_function<int() const> f1{F{}};\n+  VERIFY( f1() == 1 );\n+  VERIFY( std::as_const(f1)() == 1 );\n+  VERIFY( std::move(f1)() == 1 );\n+  VERIFY( std::move(std::as_const(f1))() == 1 );\n+\n+  move_only_function<int()&> f2{F{}};\n+  VERIFY( f2() == 0 );\n+  // Not rvalue-callable: std::move(f2)()\n+\n+  move_only_function<int() const&> f3{F{}};\n+  VERIFY( f3() == 1 );\n+  VERIFY( std::as_const(f3)() == 1 );\n+  VERIFY( std::move(f3)() == 1 );\n+  VERIFY( std::move(std::as_const(f3))() == 1 );\n+\n+  move_only_function<int()&&> f4{F{}};\n+  // Not lvalue-callable: f4()\n+  VERIFY( std::move(f4)() == 0 );\n+\n+  move_only_function<int() const&&> f5{F{}};\n+  // Not lvalue-callable: f5()\n+  VERIFY( std::move(f5)() == 1 );\n+  VERIFY( std::move(std::as_const(f5))() == 1 );\n+}\n+\n+void\n+test02()\n+{\n+  struct F\n+  {\n+    int operator()() & { return 0; }\n+    int operator()() && { return 1; }\n+  };\n+\n+  move_only_function<int()> f0{F{}};\n+  VERIFY( f0() == 0 );\n+  VERIFY( std::move(f0)() == 0 );\n+\n+  move_only_function<int()&&> f1{F{}};\n+  // Not lvalue callable: f1()\n+  VERIFY( std::move(f1)() == 1 );\n+\n+  move_only_function<int()&> f2{F{}};\n+  VERIFY( f2() == 0 );\n+  // Not rvalue-callable: std::move(f2)()\n+}\n+\n+void\n+test03()\n+{\n+  struct F\n+  {\n+    int operator()() const & { return 0; }\n+    int operator()() && { return 1; }\n+  };\n+\n+  move_only_function<int()> f0{F{}};\n+  VERIFY( f0() == 0 );\n+  VERIFY( std::move(f0)() == 0 );\n+\n+  move_only_function<int()&&> f1{F{}};\n+  // Not lvalue callable: f1()\n+  VERIFY( std::move(f1)() == 1 );\n+\n+  move_only_function<int() const> f2{F{}};\n+  VERIFY( f2() == 0 );\n+  VERIFY( std::as_const(f2)() == 0 );\n+  VERIFY( std::move(f2)() == 0 );\n+  VERIFY( std::move(std::as_const(f2))() == 0 );\n+\n+  move_only_function<int() const &&> f3{F{}};\n+  // Not lvalue callable: f3()\n+  VERIFY( std::move(f3)() == 0 );\n+  VERIFY( std::move(std::as_const(f3))() == 0 );\n+\n+  move_only_function<int() const &> f4{F{}};\n+  VERIFY( f4() == 0 );\n+  VERIFY( std::as_const(f4)() == 0 );\n+  // Not rvalue-callable: std::move(f4)()\n+}\n+\n+void\n+test04()\n+{\n+  struct F\n+  {\n+    int operator()() & { return 0; }\n+    int operator()() && { return 1; }\n+    int operator()() const & { return 2; }\n+    int operator()() const && { return 3; }\n+  };\n+\n+  move_only_function<int()> f0{F{}};\n+  VERIFY( f0() == 0 );\n+  VERIFY( std::move(f0)() == 0 );\n+\n+  move_only_function<int()&> f1{F{}};\n+  VERIFY( f1() == 0 );\n+  // Not rvalue-callable: std::move(f1)()\n+\n+  move_only_function<int()&&> f2{F{}};\n+  // Not lvalue callable: f2()\n+  VERIFY( std::move(f2)() == 1 );\n+\n+  move_only_function<int() const> f3{F{}};\n+  VERIFY( f3() == 2 );\n+  VERIFY( std::as_const(f3)() == 2 );\n+  VERIFY( std::move(f3)() == 2 );\n+  VERIFY( std::move(std::as_const(f3))() == 2 );\n+\n+  move_only_function<int() const &> f4{F{}};\n+  VERIFY( f4() == 2 );\n+  VERIFY( std::as_const(f4)() == 2 );\n+  // Not rvalue-callable: std::move(f4)()\n+\n+  move_only_function<int() const &&> f5{F{}};\n+  // Not lvalue callable: f5()\n+  VERIFY( std::move(f5)() == 3 );\n+  VERIFY( std::move(std::as_const(f5))() == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "0992f1070038344c0310198cbbec2b62ca2b85de", "filename": "libstdc++-v3/testsuite/20_util/move_only_function/cons.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fcons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fcons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fcons.cc?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -0,0 +1,98 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <functional>\n+\n+#ifndef __cpp_lib_move_only_function\n+# error \"Feature-test macro for move_only_function missing in <functional>\"\n+#elif __cpp_lib_move_only_function != 202110L\n+# error \"Feature-test macro for move_only_function has wrong value in <functional>\"\n+#endif\n+\n+using std::move_only_function;\n+\n+using std::is_constructible_v;\n+using std::is_copy_constructible_v;\n+using std::is_nothrow_default_constructible_v;\n+using std::is_nothrow_move_constructible_v;\n+using std::is_nothrow_constructible_v;\n+using std::nullptr_t;\n+using std::in_place_type_t;\n+\n+static_assert( is_nothrow_default_constructible_v<move_only_function<void()>> );\n+static_assert( is_nothrow_constructible_v<move_only_function<void()>, nullptr_t> );\n+static_assert( is_nothrow_move_constructible_v<move_only_function<void()>> );\n+static_assert( ! is_copy_constructible_v<move_only_function<void()>> );\n+\n+static_assert( is_constructible_v<move_only_function<void()>, void()> );\n+static_assert( is_constructible_v<move_only_function<void()>, void(&)()> );\n+static_assert( is_constructible_v<move_only_function<void()>, void(*)()> );\n+static_assert( is_constructible_v<move_only_function<void()>, int()> );\n+static_assert( is_constructible_v<move_only_function<void()>, int(&)()> );\n+static_assert( is_constructible_v<move_only_function<void()>, int(*)()> );\n+static_assert( ! is_constructible_v<move_only_function<void()>, void(int)> );\n+static_assert( is_constructible_v<move_only_function<void(int)>, void(int)> );\n+\n+static_assert( is_constructible_v<move_only_function<void(int)>,\n+\t\t\t\t  in_place_type_t<void(*)(int)>, void(int)> );\n+\n+static_assert( is_constructible_v<move_only_function<void()>,\n+\t\t\t\t  void() noexcept> );\n+static_assert( is_constructible_v<move_only_function<void() noexcept>,\n+\t\t\t\t  void() noexcept> );\n+static_assert( ! is_constructible_v<move_only_function<void() noexcept>,\n+\t\t\t\t    void() > );\n+\n+struct Q\n+{\n+  void operator()() const &;\n+  void operator()() &&;\n+};\n+\n+static_assert( is_constructible_v<move_only_function<void()>, Q> );\n+static_assert( is_constructible_v<move_only_function<void() const>, Q> );\n+static_assert( is_constructible_v<move_only_function<void() &>, Q> );\n+static_assert( is_constructible_v<move_only_function<void() const &>, Q> );\n+static_assert( is_constructible_v<move_only_function<void() &&>, Q> );\n+static_assert( is_constructible_v<move_only_function<void() const &&>, Q> );\n+\n+struct R\n+{\n+  void operator()() &;\n+  void operator()() &&;\n+};\n+\n+static_assert( is_constructible_v<move_only_function<void()>, R> );\n+static_assert( is_constructible_v<move_only_function<void()&>, R> );\n+static_assert( is_constructible_v<move_only_function<void()&&>, R> );\n+static_assert( ! is_constructible_v<move_only_function<void() const>, R> );\n+static_assert( ! is_constructible_v<move_only_function<void() const&>, R> );\n+static_assert( ! is_constructible_v<move_only_function<void() const&&>, R> );\n+\n+// The following nothrow-constructible guarantees are a GCC extension,\n+// not required by the standard.\n+\n+static_assert( is_nothrow_constructible_v<move_only_function<void()>, void()> );\n+static_assert( is_nothrow_constructible_v<move_only_function<void(int)>,\n+\t\t\t\t\t  in_place_type_t<void(*)(int)>,\n+\t\t\t\t\t  void(int)> );\n+\n+// These types are all small and nothrow move constructible\n+struct F { void operator()(); };\n+struct G { void operator()() const; };\n+static_assert( is_nothrow_constructible_v<move_only_function<void()>, F> );\n+static_assert( is_nothrow_constructible_v<move_only_function<void()>, G> );\n+static_assert( is_nothrow_constructible_v<move_only_function<void() const>, G> );\n+\n+struct H {\n+  H(int);\n+  H(int, int) noexcept;\n+  void operator()() noexcept;\n+};\n+static_assert( is_nothrow_constructible_v<move_only_function<void()>, H> );\n+static_assert( is_nothrow_constructible_v<move_only_function<void() noexcept>,\n+\t\t\t\t\t  H> );\n+static_assert( ! is_nothrow_constructible_v<move_only_function<void() noexcept>,\n+\t\t\t\t\t    in_place_type_t<H>, int> );\n+static_assert( is_nothrow_constructible_v<move_only_function<void() noexcept>,\n+\t\t\t\t\t  in_place_type_t<H>, int, int> );"}, {"sha": "f1f0fb597e5a5141b819d954ecdd67ef8e08be13", "filename": "libstdc++-v3/testsuite/20_util/move_only_function/move.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fmove.cc?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -0,0 +1,109 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+using std::move_only_function;\n+\n+void\n+test01()\n+{\n+  // Small type with non-throwing move constructor. Not allocated on the heap.\n+  struct F\n+  {\n+    F() = default;\n+    F(const F& f) : counters(f.counters) { ++counters.copy; }\n+    F(F&& f) noexcept : counters(f.counters) { ++counters.move; }\n+\n+    F& operator=(F&&) = delete;\n+\n+    struct Counters\n+    {\n+      int copy = 0;\n+      int move = 0;\n+    } counters;\n+\n+    const Counters& operator()() const { return counters; }\n+  };\n+\n+  F f;\n+  std::move_only_function<const F::Counters&() const> m1(f);\n+  VERIFY( m1().copy == 1 );\n+  VERIFY( m1().move == 0 );\n+\n+  // This will move construct a new target object and destroy the old one:\n+  auto m2 = std::move(m1);\n+  VERIFY( m1 == nullptr && m2 != nullptr );\n+  VERIFY( m2().copy == 1 );\n+  VERIFY( m2().move == 1 );\n+\n+  m1 = std::move(m2);\n+  VERIFY( m1 != nullptr && m2 == nullptr );\n+  VERIFY( m1().copy == 1 );\n+  VERIFY( m1().move == 2 );\n+\n+  m2 = std::move(f);\n+  VERIFY( m2().copy == 0 );\n+  VERIFY( m2().move == 2 ); // Move construct target object, then swap into m2.\n+  const int moves = m1().move + m2().move;\n+  // This will do three moves:\n+  swap(m1, m2);\n+  VERIFY( m1().copy == 0 );\n+  VERIFY( m2().copy == 1 );\n+  VERIFY( (m1().move + m2().move) == (moves + 3) );\n+}\n+\n+void\n+test02()\n+{\n+  // Move constructor is potentially throwing. Allocated on the heap.\n+  struct F\n+  {\n+    F() = default;\n+    F(const F& f) noexcept : counters(f.counters) { ++counters.copy; }\n+    F(F&& f) noexcept(false) : counters(f.counters) { ++counters.move; }\n+\n+    F& operator=(F&&) = delete;\n+\n+    struct Counters\n+    {\n+      int copy = 0;\n+      int move = 0;\n+    } counters;\n+\n+    Counters operator()() const noexcept { return counters; }\n+  };\n+\n+  F f;\n+  std::move_only_function<F::Counters() const> m1(f);\n+  VERIFY( m1().copy == 1 );\n+  VERIFY( m1().move == 0 );\n+\n+  // The target object is on the heap so this just moves a pointer:\n+  auto m2 = std::move(m1);\n+  VERIFY( m1 == nullptr && m2 != nullptr );\n+  VERIFY( m2().copy == 1 );\n+  VERIFY( m2().move == 0 );\n+\n+  m1 = std::move(m2);\n+  VERIFY( m1 != nullptr && m2 == nullptr );\n+  VERIFY( m1().copy == 1 );\n+  VERIFY( m1().move == 0 );\n+\n+  m2 = std::move(f);\n+  VERIFY( m2().copy == 0 );\n+  VERIFY( m2().move == 1 );\n+  const int moves = m1().move + m2().move;\n+  // This just swaps the pointers, so no moves:\n+  swap(m1, m2);\n+  VERIFY( m1().copy == 0 );\n+  VERIFY( m2().copy == 1 );\n+  VERIFY( (m1().move + m2().move) == moves );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "9fe52f46123bd34f4e6133a3371877e4aa4751c6", "filename": "libstdc++-v3/testsuite/20_util/move_only_function/version.cc", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881d1689a42cc7a1fd63bde53c883e52a56eded3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmove_only_function%2Fversion.cc?ref=881d1689a42cc7a1fd63bde53c883e52a56eded3", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_move_only_function\n+# error \"Feature-test macro for move_only_function missing in <version>\"\n+#elif __cpp_lib_move_only_function != 202110L\n+# error \"Feature-test macro for move_only_function has wrong value in <version>\"\n+#endif"}]}