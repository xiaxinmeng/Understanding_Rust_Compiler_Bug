{"sha": "de70723b1d7a97c50386a44ec93bb81580947e7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU3MDcyM2IxZDdhOTdjNTAzODZhNDRlYzkzYmI4MTU4MDk0N2U3Zg==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2004-03-02T22:40:57Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2004-03-02T22:40:57Z"}, "message": "m68hc11.c (m68hc11_addr_mode): New variable.\n\n\t* config/m68hc11/m68hc11.c (m68hc11_addr_mode): New variable.\n\t(m68hc11_mov_addr_mode): Likewise.\n\t(m68hc11_override_options): Initialize them based on target.\n\t(register_indirect_p): Allow a MEM for indirect addressing modes and\n\tuse flags to control what is allowed.\n\t(m68hc11_small_indexed_indirect_p): Use m68hc11_mov_addr_mode for\n\tsupported addressing modes.\n\t(m68hc11_register_indirect_p): Use m68hc11_addr_mode.\n\t(go_if_legitimate_address_internal): Likewise.\n\t(m68hc11_indirect_p): Likewise and check the mode.\n\t(print_operand): Allow a (MEM (MEM)) and generate indirect addressing.\n\nFrom-SVN: r78792", "tree": {"sha": "658e9739cd9735ba9bb88ca14c4590094d5a4506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/658e9739cd9735ba9bb88ca14c4590094d5a4506"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de70723b1d7a97c50386a44ec93bb81580947e7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de70723b1d7a97c50386a44ec93bb81580947e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de70723b1d7a97c50386a44ec93bb81580947e7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de70723b1d7a97c50386a44ec93bb81580947e7f/comments", "author": null, "committer": null, "parents": [{"sha": "d6da68b9d4dec53bfd5d0ac6b80847cbc65eb806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6da68b9d4dec53bfd5d0ac6b80847cbc65eb806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6da68b9d4dec53bfd5d0ac6b80847cbc65eb806"}], "stats": {"total": 128, "additions": 108, "deletions": 20}, "files": [{"sha": "8bc1d5a0e0336b00c80f73a726b8d9dfe9246aee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de70723b1d7a97c50386a44ec93bb81580947e7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de70723b1d7a97c50386a44ec93bb81580947e7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de70723b1d7a97c50386a44ec93bb81580947e7f", "patch": "@@ -1,3 +1,17 @@\n+2004-03-02  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/m68hc11.c (m68hc11_addr_mode): New variable.\n+\t(m68hc11_mov_addr_mode): Likewise.\n+\t(m68hc11_override_options): Initialize them based on target.\n+\t(register_indirect_p): Allow a MEM for indirect addressing modes and\n+\tuse flags to control what is allowed.\n+\t(m68hc11_small_indexed_indirect_p): Use m68hc11_mov_addr_mode for\n+\tsupported addressing modes.\n+\t(m68hc11_register_indirect_p): Use m68hc11_addr_mode.\n+\t(go_if_legitimate_address_internal): Likewise.\n+\t(m68hc11_indirect_p): Likewise and check the mode.\n+\t(print_operand): Allow a (MEM (MEM)) and generate indirect addressing.\n+\n 2004-03-02  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* builtins.c (BUILTIN_SETJMP_FRAME_VALUE): Remove."}, {"sha": "cca40ed2be07d70450513038673096848ff66ff5", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 94, "deletions": 20, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de70723b1d7a97c50386a44ec93bb81580947e7f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de70723b1d7a97c50386a44ec93bb81580947e7f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=de70723b1d7a97c50386a44ec93bb81580947e7f", "patch": "@@ -139,6 +139,16 @@ unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n    This is 1 for 68HC11 and 0 for 68HC12.  */\n int m68hc11_sp_correction;\n \n+#define ADDR_STRICT       0x01  /* Accept only registers in class A_REGS  */\n+#define ADDR_INCDEC       0x02  /* Post/Pre inc/dec */\n+#define ADDR_INDEXED      0x04  /* D-reg index */\n+#define ADDR_OFFSET       0x08\n+#define ADDR_INDIRECT     0x10  /* Accept (mem (mem ...)) for [n,X] */\n+#define ADDR_CONST        0x20  /* Accept const and symbol_ref  */\n+\n+int m68hc11_addr_mode;\n+int m68hc11_mov_addr_mode;\n+\n /* Comparison operands saved by the \"tstxx\" and \"cmpxx\" expand patterns.  */\n rtx m68hc11_compare_op0;\n rtx m68hc11_compare_op1;\n@@ -298,6 +308,8 @@ m68hc11_override_options (void)\n       m68hc11_reg_valid_for_base[HARD_Z_REGNUM] = 1;\n       m68hc11_sp_correction = 1;\n       m68hc11_tmp_regs_class = D_REGS;\n+      m68hc11_addr_mode = ADDR_OFFSET;\n+      m68hc11_mov_addr_mode = 0;\n       if (m68hc11_soft_reg_count == 0 && !TARGET_M6812)\n \tm68hc11_soft_reg_count = \"4\";\n     }\n@@ -317,6 +329,10 @@ m68hc11_override_options (void)\n       m68hc11_reg_valid_for_index[HARD_D_REGNUM] = 1;\n       m68hc11_sp_correction = 0;\n       m68hc11_tmp_regs_class = TMP_REGS;\n+      m68hc11_addr_mode = ADDR_INDIRECT | ADDR_OFFSET | ADDR_CONST\n+        | (TARGET_AUTO_INC_DEC ? ADDR_INCDEC : 0);\n+      m68hc11_mov_addr_mode = ADDR_OFFSET | ADDR_CONST\n+        | (TARGET_AUTO_INC_DEC ? ADDR_INCDEC : 0);\n       target_flags &= ~MASK_M6811;\n       target_flags |= MASK_NO_DIRECT_MODE;\n       if (m68hc11_soft_reg_count == 0)\n@@ -551,18 +567,25 @@ preferred_reload_class (rtx operand, enum reg_class class)\n    For 68hc11:  n,r    with n in [0..255] and r in A_REGS class\n    For 68hc12:  n,r    no constraint on the constant, r in A_REGS class.  */\n static int\n-register_indirect_p (rtx operand, enum machine_mode mode, int strict)\n+register_indirect_p (rtx operand, enum machine_mode mode, int addr_mode)\n {\n   rtx base, offset;\n \n   switch (GET_CODE (operand))\n     {\n+    case MEM:\n+      if ((addr_mode & ADDR_INDIRECT) && GET_MODE_SIZE (mode) <= 2)\n+        return register_indirect_p (XEXP (operand, 0), mode,\n+                                    addr_mode & (ADDR_STRICT | ADDR_OFFSET));\n+      return 0;\n+\n     case POST_INC:\n     case PRE_INC:\n     case POST_DEC:\n     case PRE_DEC:\n-      if (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n-\treturn register_indirect_p (XEXP (operand, 0), mode, strict);\n+      if (addr_mode & ADDR_INCDEC)\n+\treturn register_indirect_p (XEXP (operand, 0), mode,\n+                                    addr_mode & ADDR_STRICT);\n       return 0;\n \n     case PLUS:\n@@ -574,36 +597,57 @@ register_indirect_p (rtx operand, enum machine_mode mode, int strict)\n       if (GET_CODE (offset) == MEM)\n \treturn 0;\n \n+      /* Indexed addressing mode with 2 registers.  */\n+      if (GET_CODE (base) == REG && GET_CODE (offset) == REG)\n+        {\n+          if (!(addr_mode & ADDR_INDEXED))\n+            return 0;\n+\n+          addr_mode &= ADDR_STRICT;\n+          if (REGNO_OK_FOR_BASE_P2 (REGNO (base), addr_mode)\n+              && REGNO_OK_FOR_INDEX_P2 (REGNO (offset), addr_mode))\n+            return 1;\n+\n+          if (REGNO_OK_FOR_BASE_P2 (REGNO (offset), addr_mode)\n+              && REGNO_OK_FOR_INDEX_P2 (REGNO (base), addr_mode))\n+            return 1;\n+\n+          return 0;\n+        }\n+\n+      if (!(addr_mode & ADDR_OFFSET))\n+        return 0;\n+\n       if (GET_CODE (base) == REG)\n \t{\n-\t  if (!VALID_CONSTANT_OFFSET_P (offset, mode))\n+          if (!VALID_CONSTANT_OFFSET_P (offset, mode))\n \t    return 0;\n \n-\t  if (strict == 0)\n+\t  if (!(addr_mode & ADDR_STRICT))\n \t    return 1;\n \n-\t  return REGNO_OK_FOR_BASE_P2 (REGNO (base), strict);\n+\t  return REGNO_OK_FOR_BASE_P2 (REGNO (base), 1);\n \t}\n+\n       if (GET_CODE (offset) == REG)\n \t{\n \t  if (!VALID_CONSTANT_OFFSET_P (base, mode))\n \t    return 0;\n \n-\t  if (strict == 0)\n+\t  if (!(addr_mode & ADDR_STRICT))\n \t    return 1;\n \n-\t  return REGNO_OK_FOR_BASE_P2 (REGNO (offset), strict);\n+\t  return REGNO_OK_FOR_BASE_P2 (REGNO (offset), 1);\n \t}\n       return 0;\n \n     case REG:\n-      return REGNO_OK_FOR_BASE_P2 (REGNO (operand), strict);\n+      return REGNO_OK_FOR_BASE_P2 (REGNO (operand), addr_mode & ADDR_STRICT);\n \n     case CONST_INT:\n-      if (TARGET_M6811)\n-        return 0;\n-\n-      return VALID_CONSTANT_OFFSET_P (operand, mode);\n+      if (addr_mode & ADDR_CONST)\n+        return VALID_CONSTANT_OFFSET_P (operand, mode);\n+      return 0;\n \n     default:\n       return 0;\n@@ -616,6 +660,7 @@ int\n m68hc11_small_indexed_indirect_p (rtx operand, enum machine_mode mode)\n {\n   rtx base, offset;\n+  int addr_mode;\n \n   if (GET_CODE (operand) == REG && reload_in_progress\n       && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n@@ -635,7 +680,8 @@ m68hc11_small_indexed_indirect_p (rtx operand, enum machine_mode mode)\n   if (PUSH_POP_ADDRESS_P (operand))\n     return 1;\n \n-  if (!register_indirect_p (operand, mode, reload_completed))\n+  addr_mode = m68hc11_mov_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n+  if (!register_indirect_p (operand, mode, addr_mode))\n     return 0;\n \n   if (TARGET_M6812 && GET_CODE (operand) == PLUS\n@@ -676,18 +722,29 @@ m68hc11_small_indexed_indirect_p (rtx operand, enum machine_mode mode)\n int\n m68hc11_register_indirect_p (rtx operand, enum machine_mode mode)\n {\n+  int addr_mode;\n+\n+  if (GET_CODE (operand) == REG && reload_in_progress\n+      && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+      && reg_equiv_memory_loc[REGNO (operand)])\n+    {\n+      operand = reg_equiv_memory_loc[REGNO (operand)];\n+      operand = eliminate_regs (operand, 0, NULL_RTX);\n+    }\n   if (GET_CODE (operand) != MEM)\n     return 0;\n \n   operand = XEXP (operand, 0);\n-  return register_indirect_p (operand, mode,\n-                              (reload_completed | reload_in_progress));\n+  addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n+  return register_indirect_p (operand, mode, addr_mode);\n }\n \n static int\n go_if_legitimate_address_internal (rtx operand, enum machine_mode mode,\n                                    int strict)\n {\n+  int addr_mode;\n+\n   if (CONSTANT_ADDRESS_P (operand) && TARGET_M6812)\n     {\n       /* Reject the global variables if they are too wide.  This forces\n@@ -697,7 +754,8 @@ go_if_legitimate_address_internal (rtx operand, enum machine_mode mode,\n \n       return 1;\n     }\n-  if (register_indirect_p (operand, mode, strict))\n+  addr_mode = m68hc11_addr_mode | (strict ? ADDR_STRICT : 0);\n+  if (register_indirect_p (operand, mode, addr_mode))\n     {\n       return 1;\n     }\n@@ -984,18 +1042,20 @@ m68hc11_symbolic_p (rtx operand, enum machine_mode mode)\n int\n m68hc11_indirect_p (rtx operand, enum machine_mode mode)\n {\n-  if (GET_CODE (operand) == MEM)\n+  if (GET_CODE (operand) == MEM && GET_MODE (operand) == mode)\n     {\n       rtx op = XEXP (operand, 0);\n+      int addr_mode;\n \n       if (symbolic_memory_operand (op, mode))\n-\treturn 0;\n+\treturn TARGET_M6812;\n \n       if (reload_in_progress)\n         return 1;\n \n       operand = XEXP (operand, 0);\n-      return register_indirect_p (operand, mode, reload_completed);\n+      addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n+      return register_indirect_p (operand, mode, addr_mode);\n     }\n   return 0;\n }\n@@ -2247,7 +2307,21 @@ print_operand (FILE *file, rtx op, int letter)\n \t    abort ();\n \t  break;\n \n+        case MEM:\n+          if (TARGET_M6812)\n+            {\n+              fprintf (file, \"[\");\n+              print_operand_address (file, XEXP (base, 0));\n+              fprintf (file, \"]\");\n+            }\n+          else\n+            abort ();\n+          break;\n+\n \tdefault:\n+          if (m68hc11_page0_symbol_p (base))\n+            fprintf (file, \"*\");\n+\n \t  output_address (base);\n \t  break;\n \t}"}]}