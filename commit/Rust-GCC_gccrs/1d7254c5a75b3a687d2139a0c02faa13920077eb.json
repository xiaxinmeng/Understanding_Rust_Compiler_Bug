{"sha": "1d7254c5a75b3a687d2139a0c02faa13920077eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3MjU0YzVhNzViM2E2ODdkMjEzOWEwYzAyZmFhMTM5MjAwNzdlYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-08T23:07:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-08T23:07:10Z"}, "message": "* reload1.c: Fix formatting.\n\nFrom-SVN: r35574", "tree": {"sha": "6a91ae709b8ab7388a03c20f4647e3672df2c2fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a91ae709b8ab7388a03c20f4647e3672df2c2fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d7254c5a75b3a687d2139a0c02faa13920077eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7254c5a75b3a687d2139a0c02faa13920077eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d7254c5a75b3a687d2139a0c02faa13920077eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7254c5a75b3a687d2139a0c02faa13920077eb/comments", "author": null, "committer": null, "parents": [{"sha": "0499c2e4ddfa69d2c40873885bfdfb2142774e35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0499c2e4ddfa69d2c40873885bfdfb2142774e35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0499c2e4ddfa69d2c40873885bfdfb2142774e35"}], "stats": {"total": 104, "additions": 53, "deletions": 51}, "files": [{"sha": "7ce02ba7f3b402a358065d1871fb95d85b92bf7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d7254c5a75b3a687d2139a0c02faa13920077eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d7254c5a75b3a687d2139a0c02faa13920077eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d7254c5a75b3a687d2139a0c02faa13920077eb", "patch": "@@ -1,3 +1,7 @@\n+2000-08-08  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* reload1.c: Fix formatting.\n+\n 2000-08-08  Rodney Brown  <RodneyBrown@mynd.com>\n \n \t* alpha/alpha.c (alpha_emit_xfloating_libcall):"}, {"sha": "f6daf4899e21e7cc0f5b5e2a9599d7e1babeda97", "filename": "gcc/reload1.c", "status": "modified", "additions": 49, "deletions": 51, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d7254c5a75b3a687d2139a0c02faa13920077eb/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d7254c5a75b3a687d2139a0c02faa13920077eb/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1d7254c5a75b3a687d2139a0c02faa13920077eb", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n \n@@ -81,7 +80,6 @@ Boston, MA 02111-1307, USA.  */\n    fixing up each insn, and generating the new insns to copy values\n    into the reload registers.  */\n \n-\n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n #endif\n@@ -325,10 +323,10 @@ struct elim_table\n   rtx to_rtx;\t\t\t/* REG rtx for the replacement.  */\n };\n \n-static struct elim_table * reg_eliminate = 0;\n+static struct elim_table *reg_eliminate = 0;\n \n /* This is an intermediate structure to initialize the table.  It has\n-   exactly the members provided by ELIMINABLE_REGS. */\n+   exactly the members provided by ELIMINABLE_REGS.  */\n static struct elim_table_1\n {\n   int from;\n@@ -1449,7 +1447,7 @@ reload_reg_class_lower (r1p, r2p)\n      const PTR r1p;\n      const PTR r2p;\n {\n-  register int r1 = *(const short *)r1p, r2 = *(const short *)r2p;\n+  register int r1 = *(const short *) r1p, r2 = *(const short *) r2p;\n   register int t;\n \n   /* Consider required reloads before optional ones.  */\n@@ -1504,7 +1502,7 @@ count_pseudo (reg)\n \n   if (r < 0)\n     abort ();\n-  \n+\n   spill_add_cost[r] += n_refs;\n \n   nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n@@ -2782,7 +2780,7 @@ check_eliminable_occurrences (x)\n \n   if (x == 0)\n     return;\n-  \n+\n   code = GET_CODE (x);\n \n   if (code == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n@@ -2794,7 +2792,7 @@ check_eliminable_occurrences (x)\n \t  ep->can_eliminate = 0;\n       return;\n     }\n-  \n+\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n@@ -2933,7 +2931,7 @@ eliminate_regs_in_insn (insn, replace)\n \t       process it since it won't be used unless something changes.  */\n \t    if (replace)\n \t      {\n-\t        delete_dead_insn (insn);\n+\t\tdelete_dead_insn (insn);\n \t\treturn 1;\n \t      }\n \t    val = 1;\n@@ -3042,7 +3040,7 @@ eliminate_regs_in_insn (insn, replace)\n \n   for (i = 0; i < recog_data.n_dups; i++)\n     *recog_data.dup_loc[i]\n-      = *recog_data.operand_loc[(int)recog_data.dup_num[i]];\n+      = *recog_data.operand_loc[(int) recog_data.dup_num[i]];\n \n   /* If any eliminable remain, they aren't eliminable anymore.  */\n   check_eliminable_occurrences (old_body);\n@@ -3052,7 +3050,7 @@ eliminate_regs_in_insn (insn, replace)\n   for (i = 0; i < recog_data.n_operands; i++)\n     *recog_data.operand_loc[i] = substed_operand[i];\n   for (i = 0; i < recog_data.n_dups; i++)\n-    *recog_data.dup_loc[i] = substed_operand[(int)recog_data.dup_num[i]];\n+    *recog_data.dup_loc[i] = substed_operand[(int) recog_data.dup_num[i]];\n \n   /* If we are replacing a body that was a (set X (plus Y Z)), try to\n      re-recognize the insn.  We do this in case we had a simple addition\n@@ -3061,7 +3059,7 @@ eliminate_regs_in_insn (insn, replace)\n      If re-recognition fails, the old insn code number will still be used,\n      and some register operands may have changed into PLUS expressions.\n      These will be handled by find_reloads by loading them into a register\n-     again.*/\n+     again.  */\n \n   if (val)\n     {\n@@ -3116,7 +3114,7 @@ eliminate_regs_in_insn (insn, replace)\n       for (i = 0; i < recog_data.n_operands; i++)\n \t*recog_data.operand_loc[i] = orig_operand[i];\n       for (i = 0; i < recog_data.n_dups; i++)\n-\t*recog_data.dup_loc[i] = orig_operand[(int)recog_data.dup_num[i]];\n+\t*recog_data.dup_loc[i] = orig_operand[(int) recog_data.dup_num[i]];\n     }\n \n   /* Update all elimination pairs to reflect the status after the current\n@@ -3404,7 +3402,7 @@ init_elim_table ()\n \n   if (!reg_eliminate)\n     reg_eliminate = (struct elim_table *)\n-      xcalloc(sizeof(struct elim_table), NUM_ELIMINABLE_REGS);\n+      xcalloc (sizeof (struct elim_table), NUM_ELIMINABLE_REGS);\n \n   /* Does this function require a frame pointer?  */\n \n@@ -3703,7 +3701,7 @@ scan_paradoxical_subregs (x)\n       else if (fmt[i] == 'E')\n \t{\n \t  register int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >=0; j--)\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    scan_paradoxical_subregs (XVECEXP (x, i, j));\n \t}\n     }\n@@ -3940,7 +3938,7 @@ reload_as_needed (live_known)\n \t\t\t  reg_has_output_reload[REGNO (XEXP (in_reg, 0))] = 1;\n \t\t\t}\n \t\t      else\n-\t\t\tforget_old_reloads_1 (XEXP (in_reg, 0), NULL_RTX, \n+\t\t\tforget_old_reloads_1 (XEXP (in_reg, 0), NULL_RTX,\n \t\t\t\t\t      NULL);\n \t\t    }\n \t\t  else if ((code == PRE_INC || code == PRE_DEC)\n@@ -4847,7 +4845,7 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t      /* Earlyclobbered outputs must conflict with inputs.  */\n \t\t      if (earlyclobber_operand_p (rld[i].out))\n \t\t\ttime2 = MAX_RECOG_OPERANDS * 4 + 3;\n-\t\t\t  \n+\n \t\t      break;\n \t\t    }\n \t\t  time2 = 1;\n@@ -5070,7 +5068,7 @@ allocate_reload_reg (chain, r, last_reload)\n       if (count < n_spills)\n \tbreak;\n     }\n-    \n+\n   /* We should have found a spill register by now.  */\n   if (count >= n_spills)\n     return 0;\n@@ -5176,7 +5174,7 @@ choose_reload_regs (chain)\n \t{\n \t  max_group_size = MAX (rld[j].nregs, max_group_size);\n \t  group_class\n-\t    = reg_class_superunion[(int)rld[j].class][(int)group_class];\n+\t    = reg_class_superunion[(int) rld[j].class][(int)group_class];\n \t}\n \n       save_reload_reg_rtx[j] = rld[j].reg_rtx;\n@@ -5329,7 +5327,7 @@ choose_reload_regs (chain)\n #ifdef CLASS_CANNOT_CHANGE_MODE\n \t\t      (TEST_HARD_REG_BIT\n \t\t       (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE], i)\n-\t\t       ? ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (last_reg), \n+\t\t       ? ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (last_reg),\n \t\t\t\t\t\t       need_mode)\n \t\t       : (GET_MODE_SIZE (GET_MODE (last_reg))\n \t\t\t  >= GET_MODE_SIZE (need_mode)))\n@@ -5368,8 +5366,7 @@ choose_reload_regs (chain)\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n-\t\t      int nr\n-\t\t\t= HARD_REGNO_NREGS (i, rld[r].mode);\n+\t\t      int nr = HARD_REGNO_NREGS (i, rld[r].mode);\n \t\t      int k;\n \n \t\t      for (k = 1; k < nr; k++)\n@@ -5406,7 +5403,8 @@ choose_reload_regs (chain)\n \t\t\t\t  && rld[r].out\n \t\t\t\t  && ! TEST_HARD_REG_BIT (reg_reloaded_dead, i))\n \t\t\t      /* Don't clobber the frame pointer.  */\n-\t\t\t      || (i == HARD_FRAME_POINTER_REGNUM && rld[r].out)\n+\t\t\t      || (i == HARD_FRAME_POINTER_REGNUM\n+\t\t\t\t  && rld[r].out)\n \t\t\t      /* Don't really use the inherited spill reg\n \t\t\t\t if we need it wider than we've got it.  */\n \t\t\t      || (GET_MODE_SIZE (rld[r].mode)\n@@ -5545,7 +5543,7 @@ choose_reload_regs (chain)\n \t\t    case RELOAD_FOR_INPUT:\n \t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n \t\t      reload_override_in[r] = equiv;\n-\t\t      /* Fall through. */\n+\t\t      /* Fall through.  */\n \t\t    default:\n \t\t      equiv = 0;\n \t\t      break;\n@@ -5589,8 +5587,9 @@ choose_reload_regs (chain)\n \t  if (rld[r].reg_rtx != 0 || rld[r].optional != 0)\n \t    continue;\n \n-#if 0 /* No longer needed for correct operation.  Might or might not\n-\t give better code on the average.  Want to experiment?  */\n+#if 0\n+\t  /* No longer needed for correct operation.  Might or might\n+\t     not give better code on the average.  Want to experiment?  */\n \n \t  /* See if there is a later reload that has a class different from our\n \t     class that intersects our class or that requires less register\n@@ -5920,7 +5919,6 @@ merge_assigned_reloads (insn)\n \t}\n     }\n }\n-\n \f\n /* These arrays are filled by emit_reload_insns and its subroutines.  */\n static rtx input_reload_insns[MAX_RECOG_OPERANDS];\n@@ -6548,7 +6546,7 @@ emit_output_reload_insns (chain, rl, j)\n       rtx set;\n \n       /* Don't output the last reload if OLD is not the dest of\n-\t INSN and is in the src and is clobbered by INSN. */\n+\t INSN and is in the src and is clobbered by INSN.  */\n       if (! flag_expensive_optimizations\n \t  || GET_CODE (old) != REG\n \t  || !(set = single_set (insn))\n@@ -6593,9 +6591,10 @@ emit_output_reload_insns (chain, rl, j)\n \t\t   register, the secondary reload does the actual\n \t\t   store.  */\n \t\tif (s >= 0 && set == NULL_RTX)\n-\t\t  ; /* We can't tell what function the secondary reload\n-\t\t       has and where the actual store to the pseudo is\n-\t\t       made; leave new_spill_reg_store alone.  */\n+\t\t  /* We can't tell what function the secondary reload\n+\t\t     has and where the actual store to the pseudo is\n+\t\t     made; leave new_spill_reg_store alone.  */\n+\t\t  ;\n \t\telse if (s >= 0\n \t\t\t && SET_SRC (set) == rl->reg_rtx\n \t\t\t && SET_DEST (set) == rld[s].reg_rtx)\n@@ -6631,7 +6630,7 @@ emit_output_reload_insns (chain, rl, j)\n   else\n     output_reload_insns[rl->opnum] = get_insns ();\n \n-  end_sequence (); \n+  end_sequence ();\n }\n \n /* Do input reloading for reload RL, which is for the insn described by CHAIN\n@@ -6666,8 +6665,7 @@ do_input_reload (chain, rl, j)\n     {\n       expect_occurrences\n \t= count_occurrences (PATTERN (insn), rl->in, 0) == 1 ? 0 : -1;\n-      rl->in\n-\t= regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n+      rl->in = regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n     }\n \n   /* If we are reloading a register that was recently stored in with an\n@@ -6909,8 +6907,7 @@ emit_reload_insns (chain)\n \n       if (i >= 0 && rld[r].reg_rtx != 0)\n \t{\n-\t  int nr\n-\t    = HARD_REGNO_NREGS (i, GET_MODE (rld[r].reg_rtx));\n+\t  int nr = HARD_REGNO_NREGS (i, GET_MODE (rld[r].reg_rtx));\n \t  int k;\n \t  int part_reaches_end = 0;\n \t  int all_reaches_end = 1;\n@@ -7136,7 +7133,7 @@ emit_reload_insns (chain)\n \t    }\n \t  else\n \t    {\n-\t      int num_regs = HARD_REGNO_NREGS (nregno,GET_MODE (rld[r].out));\n+\t      int num_regs = HARD_REGNO_NREGS (nregno, GET_MODE (rld[r].out));\n \n \t      while (num_regs-- > 0)\n \t\treg_last_reload_reg[nregno + num_regs] = 0;\n@@ -7569,7 +7566,7 @@ delete_address_reloads (dead_insn, current_insn)\n       || ! rtx_equal_p (dst, XEXP (SET_SRC (set), 0))\n       || ! rtx_equal_p (dst, XEXP (SET_SRC (set2), 0))\n       || (INTVAL (XEXP (SET_SRC (set), 1))\n-\t  != - INTVAL (XEXP (SET_SRC (set2), 1))))\n+\t  != -INTVAL (XEXP (SET_SRC (set2), 1))))\n     return;\n   delete_insn (prev);\n   delete_insn (next);\n@@ -7586,14 +7583,14 @@ delete_address_reloads_1 (dead_insn, x, current_insn)\n \n   if (code != REG)\n     {\n-      const char *fmt= GET_RTX_FORMAT (code);\n+      const char *fmt = GET_RTX_FORMAT (code);\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n \t    delete_address_reloads_1 (dead_insn, XEXP (x, i), current_insn);\n \t  else if (fmt[i] == 'E')\n \t    {\n-\t      for (j = XVECLEN (x, i) - 1; j >=0; j--)\n+\t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t\tdelete_address_reloads_1 (dead_insn, XVECEXP (x, i, j),\n \t\t\t\t\t  current_insn);\n \t    }\n@@ -7723,7 +7720,7 @@ inc_for_reload (reloadreg, in, value, inc_amount)\n     reg_last_reload_reg[REGNO (incloc)] = 0;\n \n   if (GET_CODE (value) == PRE_DEC || GET_CODE (value) == POST_DEC)\n-    inc_amount = - inc_amount;\n+    inc_amount = -inc_amount;\n \n   inc = GEN_INT (inc_amount);\n \n@@ -7965,7 +7962,7 @@ reload_cse_regs_1 (first)\n {\n   rtx insn;\n \n-  cselib_init ();  \n+  cselib_init ();\n   init_alias_analysis ();\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n@@ -8053,7 +8050,7 @@ reload_cse_simplify_set (set, insn)\n \t   || (this_cost == old_cost\n \t       && GET_CODE (l->loc) == REG\n \t       && GET_CODE (SET_SRC (set)) != REG))\n-      \t  && validate_change (insn, &SET_SRC (set), copy_rtx (l->loc), 1))\n+\t  && validate_change (insn, &SET_SRC (set), copy_rtx (l->loc), 1))\n \told_cost = this_cost, did_change = 1;\n     }\n \n@@ -8075,7 +8072,7 @@ static int\n reload_cse_simplify_operands (insn)\n      rtx insn;\n {\n-  int i,j;\n+  int i, j;\n \n   /* For each operand, all registers that are equivalent to it.  */\n   HARD_REG_SET equiv_regs[MAX_RECOG_OPERANDS];\n@@ -8103,7 +8100,7 @@ reload_cse_simplify_operands (insn)\n   /* Figure out which alternative currently matches.  */\n   if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n-  \n+\n   alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n@@ -8218,7 +8215,7 @@ reload_cse_simplify_operands (insn)\n \t\t  /* See if REGNO fits this alternative, and set it up as the\n \t\t     replacement register if we don't have one for this\n \t\t     alternative yet and the operand being replaced is not\n-\t\t     a cheap CONST_INT. */\n+\t\t     a cheap CONST_INT.  */\n \t\t  if (op_alt_regno[i][j] == -1\n \t\t      && reg_fits_class_p (reg, class, 0, mode)\n \t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n@@ -8542,7 +8539,7 @@ reload_combine ()\n \t\t  if (reg_state[regno].offset != const0_rtx)\n \t\t    /* Previous REG_EQUIV / REG_EQUAL notes for PREV\n \t\t       are now invalid.  */\n-\t\t    for (np = &REG_NOTES (prev); *np; )\n+\t\t    for (np = &REG_NOTES (prev); *np;)\n \t\t      {\n \t\t\tif (REG_NOTE_KIND (*np) == REG_EQUAL\n \t\t\t    || REG_NOTE_KIND (*np) == REG_EQUIV)\n@@ -8559,7 +8556,7 @@ reload_combine ()\n \t    }\n \t}\n \n-  note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n+      note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n \n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n@@ -8716,7 +8713,8 @@ reload_combine_note_use (xp, insn)\n \n     case PLUS:\n       /* We are interested in (plus (reg) (const_int)) .  */\n-      if (GET_CODE (XEXP (x, 0)) != REG || GET_CODE (XEXP (x, 1)) != CONST_INT)\n+      if (GET_CODE (XEXP (x, 0)) != REG\n+\t  || GET_CODE (XEXP (x, 1)) != CONST_INT)\n \tbreak;\n       offset = XEXP (x, 1);\n       x = XEXP (x, 0);\n@@ -8845,7 +8843,7 @@ reload_cse_move2add (first)\n   rtx insn;\n   int last_label_luid;\n \n-  for (i = FIRST_PSEUDO_REGISTER-1; i >= 0; i--)\n+  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n     reg_set_luid[i] = 0;\n \n   last_label_luid = 0;\n@@ -8994,7 +8992,7 @@ reload_cse_move2add (first)\n \t unknown values.  */\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  for (i = FIRST_PSEUDO_REGISTER-1; i >= 0; i--)\n+\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n \t    {\n \t      if (call_used_regs[i])\n \t\t{"}]}