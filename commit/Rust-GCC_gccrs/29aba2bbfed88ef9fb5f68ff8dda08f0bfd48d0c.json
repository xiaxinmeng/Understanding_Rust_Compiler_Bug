{"sha": "29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhYmEyYmJmZWQ4OGVmOWZiNWY2OGZmOGRkYTA4ZjBiZmQ0OGQwYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-10T14:46:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-10T14:46:40Z"}, "message": "df-problems.c (df_live_problem_data): Add live_bitmaps.\n\n\n\t* df-problems.c (df_live_problem_data): Add live_bitmaps.\n\t(df_live_alloc): Initialize problem data and live_osbtacks.\n\t(df_live_finalize): Remove obstack, problem data; do not\n\tclear all bitmaps.\n\t(df_live_top_dump, df_live_bottom_dump): Do not dump old\n\tdata when not allocated.\n\t(df_live_verify_solution_start): Do not allocate problem data.\n\t(df_live_verify_solution_end): Check if out is allocated.\n\t(struct df_md_problem_data): New structure.\n\t(df_md_alloc): Allocate problem data.\n\t(df_md_free): Free problem data; do not clear bitmaps.\n\nFrom-SVN: r160549", "tree": {"sha": "39bbcb2e07cd1960455a2d440dab7b8f0fa1cd38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39bbcb2e07cd1960455a2d440dab7b8f0fa1cd38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c/comments", "author": null, "committer": null, "parents": [{"sha": "d247d6625a001979ba41d51d73cb3311e362c9c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d247d6625a001979ba41d51d73cb3311e362c9c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d247d6625a001979ba41d51d73cb3311e362c9c2"}], "stats": {"total": 131, "additions": 77, "deletions": 54}, "files": [{"sha": "f5ad8a0e75a019e88c25033392866c5575cabd5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "patch": "@@ -1,3 +1,17 @@\n+2010-06-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* df-problems.c (df_live_problem_data): Add live_bitmaps.\n+\t(df_live_alloc): Initialize problem data and live_osbtacks.\n+\t(df_live_finalize): Remove obstack, problem data; do not\n+\tclear all bitmaps.\n+\t(df_live_top_dump, df_live_bottom_dump): Do not dump old\n+\tdata when not allocated.\n+\t(df_live_verify_solution_start): Do not allocate problem data.\n+\t(df_live_verify_solution_end): Check if out is allocated.\n+\t(struct df_md_problem_data): New structure.\n+\t(df_md_alloc): Allocate problem data.\n+\t(df_md_free): Free problem data; do not clear bitmaps.\n+\n 2010-06-10  Jan Beulich  <jbeulich@novell.com>\n \n \t* configure.ac: Replace $() with ${} when intending to expand"}, {"sha": "8438c9059b7685571c40a7104cd374aa95f95624", "filename": "gcc/df-problems.c", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "patch": "@@ -1361,6 +1361,8 @@ struct df_live_problem_data\n {\n   bitmap_head *in;\n   bitmap_head *out;\n+  /* An obstack for the bitmaps we need for this problem.  */\n+  bitmap_obstack live_bitmaps;\n };\n \n /* Scratch var used by transfer functions.  This is used to implement\n@@ -1406,12 +1408,24 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n+  struct df_live_problem_data *problem_data;\n \n   if (!df_live->block_pool)\n     df_live->block_pool = create_alloc_pool (\"df_live_block pool\",\n \t\t\t\t\t   sizeof (struct df_live_bb_info), 100);\n+  if (df_live->problem_data)\n+    problem_data = (struct df_live_problem_data *) df_live->problem_data;\n+  else\n+    {\n+      problem_data = XNEW (struct df_live_problem_data);\n+      df_live->problem_data = problem_data;\n+\n+      problem_data->out = NULL;\n+      problem_data->in = NULL;\n+      bitmap_obstack_initialize (&problem_data->live_bitmaps);\n+    }\n   if (!df_live_scratch)\n-    df_live_scratch = BITMAP_ALLOC (NULL);\n+    df_live_scratch = BITMAP_ALLOC (&problem_data->live_bitmaps);\n \n   df_grow_bb_info (df_live);\n \n@@ -1427,10 +1441,10 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t{\n \t  bb_info = (struct df_live_bb_info *) pool_alloc (df_live->block_pool);\n \t  df_live_set_bb_info (bb_index, bb_info);\n-\t  bitmap_initialize (&bb_info->kill, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->gen, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->in, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->out, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->kill, &problem_data->live_bitmaps);\n+\t  bitmap_initialize (&bb_info->gen, &problem_data->live_bitmaps);\n+\t  bitmap_initialize (&bb_info->in, &problem_data->live_bitmaps);\n+\t  bitmap_initialize (&bb_info->out, &problem_data->live_bitmaps);\n \t}\n     }\n   df_live->optional_p = (optimize <= 1);\n@@ -1622,25 +1636,14 @@ df_live_finalize (bitmap all_blocks)\n static void\n df_live_free (void)\n {\n+  struct df_live_problem_data *problem_data\n+    = (struct df_live_problem_data *) df_live->problem_data;\n   if (df_live->block_info)\n     {\n-      unsigned int i;\n-\n-      for (i = 0; i < df_live->block_info_size; i++)\n-\t{\n-\t  struct df_live_bb_info *bb_info = df_live_get_bb_info (i);\n-\t  if (bb_info)\n-\t    {\n-\t      bitmap_clear (&bb_info->gen);\n-\t      bitmap_clear (&bb_info->kill);\n-\t      bitmap_clear (&bb_info->in);\n-\t      bitmap_clear (&bb_info->out);\n-\t    }\n-\t}\n-\n       free_alloc_pool (df_live->block_pool);\n       df_live->block_info_size = 0;\n       free (df_live->block_info);\n+      bitmap_obstack_release (&problem_data->live_bitmaps);\n \n       if (df_live_scratch)\n \tBITMAP_FREE (df_live_scratch);\n@@ -1666,8 +1669,11 @@ df_live_top_dump (basic_block bb, FILE *file)\n   if (df_live->problem_data)\n     {\n       problem_data = (struct df_live_problem_data *)df_live->problem_data;\n-      fprintf (file, \";;  old in  \\t\");\n-      df_print_regset (file, &problem_data->in[bb->index]);\n+      if (problem_data->in)\n+\t{\n+\t  fprintf (file, \";;  old in  \\t\");\n+\t  df_print_regset (file, &problem_data->in[bb->index]);\n+\t}\n     }\n   fprintf (file, \";; live  gen \\t\");\n   df_print_regset (file, &bb_info->gen);\n@@ -1692,8 +1698,11 @@ df_live_bottom_dump (basic_block bb, FILE *file)\n   if (df_live->problem_data)\n     {\n       problem_data = (struct df_live_problem_data *)df_live->problem_data;\n-      fprintf (file, \";;  old out  \\t\");\n-      df_print_regset (file, &problem_data->out[bb->index]);\n+      if (problem_data->out)\n+\t{\n+\t  fprintf (file, \";;  old out  \\t\");\n+\t  df_print_regset (file, &problem_data->out[bb->index]);\n+\t}\n     }\n }\n \n@@ -1707,23 +1716,19 @@ df_live_verify_solution_start (void)\n   basic_block bb;\n   struct df_live_problem_data *problem_data;\n   if (df_live->solutions_dirty)\n-    {\n-      df_live->problem_data = NULL;\n-      return;\n-    }\n+    return;\n \n   /* Set it true so that the solution is recomputed.  */\n   df_live->solutions_dirty = true;\n \n-  problem_data = XNEW (struct df_live_problem_data);\n-  df_live->problem_data = problem_data;\n+  problem_data = (struct df_live_problem_data *)df_live->problem_data;\n   problem_data->in = XNEWVEC (bitmap_head, last_basic_block);\n   problem_data->out = XNEWVEC (bitmap_head, last_basic_block);\n \n   FOR_ALL_BB (bb)\n     {\n-      bitmap_initialize (&problem_data->in[bb->index], &bitmap_default_obstack);\n-      bitmap_initialize (&problem_data->out[bb->index], &bitmap_default_obstack);\n+      bitmap_initialize (&problem_data->in[bb->index], &problem_data->live_bitmaps);\n+      bitmap_initialize (&problem_data->out[bb->index], &problem_data->live_bitmaps);\n       bitmap_copy (&problem_data->in[bb->index], DF_LIVE_IN (bb));\n       bitmap_copy (&problem_data->out[bb->index], DF_LIVE_OUT (bb));\n     }\n@@ -1739,10 +1744,9 @@ df_live_verify_solution_end (void)\n   struct df_live_problem_data *problem_data;\n   basic_block bb;\n \n-  if (df_live->problem_data == NULL)\n-    return;\n-\n   problem_data = (struct df_live_problem_data *)df_live->problem_data;\n+  if (!problem_data->out)\n+    return;\n \n   FOR_ALL_BB (bb)\n     {\n@@ -4199,6 +4203,13 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n     propagating the information to BB3's successors.\n    ---------------------------------------------------------------------------*/\n \n+/* Private data used to verify the solution for this problem.  */\n+struct df_md_problem_data\n+{\n+  /* An obstack for the bitmaps we need for this problem.  */\n+  bitmap_obstack md_bitmaps;\n+};\n+\n /* Scratch var used by transfer functions.  This is used to do md analysis\n    only for live registers.  */\n static bitmap_head df_md_scratch;\n@@ -4240,13 +4251,22 @@ df_md_alloc (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n+  struct df_md_problem_data *problem_data;\n \n   if (!df_md->block_pool)\n     df_md->block_pool = create_alloc_pool (\"df_md_block pool\",\n                                            sizeof (struct df_md_bb_info), 50);\n \n   df_grow_bb_info (df_md);\n-  bitmap_initialize (&df_md_scratch, &bitmap_default_obstack);\n+  if (df_md->problem_data)\n+    problem_data = (struct df_md_problem_data *) df_md->problem_data;\n+  else\n+    {\n+      problem_data = XNEW (struct df_md_problem_data);\n+      df_md->problem_data = problem_data;\n+      bitmap_obstack_initialize (&problem_data->md_bitmaps);\n+    }\n+  bitmap_initialize (&df_md_scratch, &problem_data->md_bitmaps);\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n@@ -4263,11 +4283,11 @@ df_md_alloc (bitmap all_blocks)\n         {\n           bb_info = (struct df_md_bb_info *) pool_alloc (df_md->block_pool);\n           df_md_set_bb_info (bb_index, bb_info);\n-\t  bitmap_initialize (&bb_info->init, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->gen, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->kill, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->in, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->out, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->init, &problem_data->md_bitmaps);\n+\t  bitmap_initialize (&bb_info->gen, &problem_data->md_bitmaps);\n+\t  bitmap_initialize (&bb_info->kill, &problem_data->md_bitmaps);\n+\t  bitmap_initialize (&bb_info->in, &problem_data->md_bitmaps);\n+\t  bitmap_initialize (&bb_info->out, &problem_data->md_bitmaps);\n         }\n     }\n \n@@ -4520,21 +4540,10 @@ df_md_confluence_n (edge e)\n static void\n df_md_free (void)\n {\n-  unsigned int i;\n-  for (i = 0; i < df_md->block_info_size; i++)\n-    {\n-      struct df_md_bb_info *bb_info = df_md_get_bb_info (i);\n-      if (bb_info)\n-\t{\n-\t  bitmap_clear (&bb_info->kill);\n-\t  bitmap_clear (&bb_info->gen);\n-\t  bitmap_clear (&bb_info->init);\n-\t  bitmap_clear (&bb_info->in);\n-\t  bitmap_clear (&bb_info->out);\n-\t}\n-    }\n+  struct df_md_problem_data *problem_data\n+    = (struct df_md_problem_data *) df_md->problem_data;\n \n-  bitmap_clear (&df_md_scratch);\n+  bitmap_obstack_release (&problem_data->md_bitmaps);\n   free_alloc_pool (df_md->block_pool);\n \n   df_md->block_info_size = 0;"}]}