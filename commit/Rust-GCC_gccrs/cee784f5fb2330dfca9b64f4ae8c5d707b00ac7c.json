{"sha": "cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlNzg0ZjVmYjIzMzBkZmNhOWI2NGY0YWU4YzVkNzA3YjAwYWM3Yw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-08T06:29:12Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-08T06:29:12Z"}, "message": "re PR middle-end/54146 (Very slow compile with attribute((flatten)))\n\n\tPR middle-end/54146\n\t* ira.c (init_live_subregs): Take live_subregs_used as a bitmap.\n\t(build_insn_chain): Make live_subregs_used a bitmap.\n\tUse SBITMAP_SIZE to ignore the paradoxical bytes of subregs.\n\tUse sbitmap_free to free the live_subreg sbitmaps.\n\nFrom-SVN: r190223", "tree": {"sha": "85ff7b9a2224e6cc10cb44bcc6599cb4bdc69a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85ff7b9a2224e6cc10cb44bcc6599cb4bdc69a5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c/comments", "author": null, "committer": null, "parents": [{"sha": "985e963f0c0bda074b9b71e3f443297452eee372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985e963f0c0bda074b9b71e3f443297452eee372", "html_url": "https://github.com/Rust-GCC/gccrs/commit/985e963f0c0bda074b9b71e3f443297452eee372"}], "stats": {"total": 45, "additions": 25, "deletions": 20}, "files": [{"sha": "f0687ad1c8f390525b99604796b901e1719c08a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c", "patch": "@@ -1,5 +1,11 @@\n 2012-08-08  Steven Bosscher  <steven@gcc.gnu.org>\n \n+\tPR middle-end/54146\n+\t* ira.c (init_live_subregs): Take live_subregs_used as a bitmap.\n+\t(build_insn_chain): Make live_subregs_used a bitmap.\n+\tUse SBITMAP_SIZE to ignore the paradoxical bytes of subregs.\n+\tUse sbitmap_free to free the live_subreg sbitmaps.\n+\n \tPR middle-end/54146\n \t* ifcvt.c: Include pointer-set.h.\n \t(cond_move_process_if_block): Change type of then_regs and"}, {"sha": "6699d2bacf7127010c2a690947e901173ae9c502", "filename": "gcc/ira.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=cee784f5fb2330dfca9b64f4ae8c5d707b00ac7c", "patch": "@@ -3251,18 +3251,18 @@ pseudo_for_reload_consideration_p (int regno)\n    initialization.  ALLOCNUM need not be the regno of REG.  */\n static void\n init_live_subregs (bool init_value, sbitmap *live_subregs,\n-\t\t   int *live_subregs_used, int allocnum, rtx reg)\n+\t\t   bitmap live_subregs_used, int allocnum, rtx reg)\n {\n   unsigned int regno = REGNO (SUBREG_REG (reg));\n   int size = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n \n   gcc_assert (size > 0);\n \n   /* Been there, done that.  */\n-  if (live_subregs_used[allocnum])\n+  if (bitmap_bit_p (live_subregs_used, allocnum))\n     return;\n \n-  /* Create a new one with zeros.  */\n+  /* Create a new one.  */\n   if (live_subregs[allocnum] == NULL)\n     live_subregs[allocnum] = sbitmap_alloc (size);\n \n@@ -3273,8 +3273,7 @@ init_live_subregs (bool init_value, sbitmap *live_subregs,\n   else\n     sbitmap_zero (live_subregs[allocnum]);\n \n-  /* Set the number of bits that we really want.  */\n-  live_subregs_used[allocnum] = size;\n+  bitmap_set_bit (live_subregs_used, allocnum);\n }\n \n /* Walk the insns of the current function and build reload_insn_chain,\n@@ -3293,11 +3292,11 @@ build_insn_chain (void)\n      which hardregs are live in multiword pseudos.  live_subregs and\n      live_subregs_used are indexed by pseudo number.  The live_subreg\n      entry for a particular pseudo is only used if the corresponding\n-     element is non zero in live_subregs_used.  The value in\n-     live_subregs_used is number of bytes that the pseudo can\n+     element is non zero in live_subregs_used.  The sbitmap size of\n+     live_subreg[allocno] is number of bytes that the pseudo can\n      occupy.  */\n   sbitmap *live_subregs = XCNEWVEC (sbitmap, max_regno);\n-  int *live_subregs_used = XNEWVEC (int, max_regno);\n+  bitmap live_subregs_used = BITMAP_ALLOC (NULL);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (TEST_HARD_REG_BIT (eliminable_regset, i))\n@@ -3308,7 +3307,7 @@ build_insn_chain (void)\n       rtx insn;\n \n       CLEAR_REG_SET (live_relevant_regs);\n-      memset (live_subregs_used, 0, max_regno * sizeof (int));\n+      bitmap_clear (live_subregs_used);\n \n       EXECUTE_IF_SET_IN_BITMAP (DF_LR_OUT (bb), 0, i, bi)\n \t{\n@@ -3393,8 +3392,8 @@ build_insn_chain (void)\n \t\t\t      }\n \n \t\t\t    /* Ignore the paradoxical bits.  */\n-\t\t\t    if ((int)last > live_subregs_used[regno])\n-\t\t\t      last = live_subregs_used[regno];\n+\t\t\t    if (last > SBITMAP_SIZE (live_subregs[regno]))\n+\t\t\t      last = SBITMAP_SIZE (live_subregs[regno]);\n \n \t\t\t    while (start < last)\n \t\t\t      {\n@@ -3404,7 +3403,7 @@ build_insn_chain (void)\n \n \t\t\t    if (sbitmap_empty_p (live_subregs[regno]))\n \t\t\t      {\n-\t\t\t\tlive_subregs_used[regno] = 0;\n+\t\t\t\tbitmap_clear_bit (live_subregs_used, regno);\n \t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n \t\t\t      }\n \t\t\t    else\n@@ -3422,8 +3421,8 @@ build_insn_chain (void)\n \t\t\t       modeling the def as a killing def.  */\n \t\t\t    if (!DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL))\n \t\t\t      {\n+\t\t\t\tbitmap_clear_bit (live_subregs_used, regno);\n \t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n-\t\t\t\tlive_subregs_used[regno] = 0;\n \t\t\t      }\n \t\t\t  }\n \t\t      }\n@@ -3479,8 +3478,8 @@ build_insn_chain (void)\n \t\t\t       live_subregs, live_subregs_used, regno, reg);\n \n \t\t\t    /* Ignore the paradoxical bits.  */\n-\t\t\t    if ((int)last > live_subregs_used[regno])\n-\t\t\t      last = live_subregs_used[regno];\n+\t\t\t    if (last > SBITMAP_SIZE (live_subregs[regno]))\n+\t\t\t      last = SBITMAP_SIZE (live_subregs[regno]);\n \n \t\t\t    while (start < last)\n \t\t\t      {\n@@ -3493,7 +3492,7 @@ build_insn_chain (void)\n \t\t\t     effectively saying do not use the subregs\n \t\t\t     because we are reading the whole\n \t\t\t     pseudo.  */\n-\t\t\t  live_subregs_used[regno] = 0;\n+\t\t\t  bitmap_clear_bit (live_subregs_used, regno);\n \t\t\tbitmap_set_bit (live_relevant_regs, regno);\n \t\t      }\n \t\t  }\n@@ -3536,14 +3535,14 @@ build_insn_chain (void)\n \t}\n     }\n \n-  for (i = 0; i < (unsigned int) max_regno; i++)\n-    free (live_subregs[i]);\n-\n   reload_insn_chain = c;\n   *p = NULL;\n \n+  for (i = 0; i < (unsigned int) max_regno; i++)\n+    if (live_subregs[i] != NULL)\n+      sbitmap_free (live_subregs[i]);\n   free (live_subregs);\n-  free (live_subregs_used);\n+  BITMAP_FREE (live_subregs_used);\n   BITMAP_FREE (live_relevant_regs);\n   BITMAP_FREE (elim_regset);\n "}]}