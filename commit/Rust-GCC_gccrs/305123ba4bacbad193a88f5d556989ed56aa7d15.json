{"sha": "305123ba4bacbad193a88f5d556989ed56aa7d15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA1MTIzYmE0YmFjYmFkMTkzYTg4ZjVkNTU2OTg5ZWQ1NmFhN2QxNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-01-14T04:15:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-01-14T04:15:10Z"}, "message": "pa.md (pre_ldwm): Fix bug exposed by recent changes.\n\n        * pa.md (pre_ldwm): Fix bug exposed by recent changes.\n        Simplify.\n        (pre_stwm, post_ldwm, post_stwm): Likewise.\n        (HImode and QImode variants): Likewise.\n        * pa.c (hppa_expand_prologue): Corresponding changes.\n        (hppa_expand_epilogue): Likewise.\n\n        * pa.c (hppa_legitimize_address): Generate more indexing\n        address modes.\n\nFrom-SVN: r10972", "tree": {"sha": "10b08585d29e49ff0e27b728947c637001086e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10b08585d29e49ff0e27b728947c637001086e97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/305123ba4bacbad193a88f5d556989ed56aa7d15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305123ba4bacbad193a88f5d556989ed56aa7d15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305123ba4bacbad193a88f5d556989ed56aa7d15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305123ba4bacbad193a88f5d556989ed56aa7d15/comments", "author": null, "committer": null, "parents": [{"sha": "6b0bd7a3ba339ec6aa14ab3fc8a552b171c2b0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0bd7a3ba339ec6aa14ab3fc8a552b171c2b0bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b0bd7a3ba339ec6aa14ab3fc8a552b171c2b0bb"}], "stats": {"total": 220, "additions": 149, "deletions": 71}, "files": [{"sha": "5c00d45bf5dcd14ee5282c19c59b45a234e46820", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 104, "deletions": 25, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305123ba4bacbad193a88f5d556989ed56aa7d15/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305123ba4bacbad193a88f5d556989ed56aa7d15/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=305123ba4bacbad193a88f5d556989ed56aa7d15", "patch": "@@ -718,10 +718,8 @@ hppa_legitimize_address (x, oldx, mode)\n      only do so if indexing is safe.\n \n      Indexing is safe when the second operand for the outer PLUS\n-     is a REG, SUBREG, SYMBOL_REF or the like.\n+     is a REG, SUBREG, SYMBOL_REF or the like.  */\n \n-     For 2.5, indexing is also safe for (plus (symbol_ref) (const_int))\n-     if the integer is > 0.  */\n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n       && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1)))\n@@ -741,8 +739,64 @@ hppa_legitimize_address (x, oldx, mode)\n \t\t\t\t reg1));\n     }\n \n+  /* Similarly for (plus (plus (mult (a) (shadd_constant)) (b)) (c)).\n+\n+     Only do so for floating point modes since this is more speculative\n+     and we lose if it's an integer store.  */\n+  if ((mode == DFmode || mode == SFmode)\n+      && GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n+      && shadd_constant_p (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))))\n+    {\n+      rtx regx1, regx2;\n+\n+      /* Add the two unscaled terms B and C; only force them into registers\n+\t if it's absolutely necessary.  */\n+      regx1 = XEXP (XEXP (x, 0), 1);\n+      if (! (GET_CODE (regx1) == REG\n+\t     || (GET_CODE (regx1) == CONST_INT\n+\t\t && INT_14_BITS (regx1))))\n+\tregx1 = force_reg (Pmode, force_operand (XEXP (XEXP (x, 0), 1), 0));\n+      \n+      regx2 = XEXP (x, 1);\n+      if (! (GET_CODE (regx2) == REG\n+\t     || (GET_CODE (regx2) == CONST_INT\n+\t\t && INT_14_BITS (regx2))))\n+\tregx2 = force_reg (Pmode, force_operand (XEXP (x, 1), 0));\n+      \n+      /* Add them, make sure the result is in canonical form.  */\n+      if (GET_CODE (regx1) == REG)\n+\tregx1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regx2));\n+      else if (GET_CODE (regx2) == REG)\n+\tregx1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, regx2, regx1));\n+      else\n+\tregx1 = force_reg (Pmode, gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t   force_reg (Pmode, regx1),\n+\t\t\t\t\t   regx2));\n+\n+      /* Get the term to scale in a register.  */\n+      regx2 = XEXP (XEXP (XEXP (x, 0), 0), 0);\n+      if (GET_CODE (regx2) != REG)\n+\tregx2 = force_reg (Pmode, force_operand (regx2, 0));\n+\n+      /* And make an indexed address.  */\n+      regx2 = gen_rtx (PLUS, Pmode,\n+\t\t       gen_rtx (MULT, Pmode, regx2,\n+\t\t\t\tXEXP (XEXP (XEXP (x, 0), 0), 1)),\n+\t\t\tregx1);\n+\n+      /* Return it.  */\n+      return force_reg (Pmode, regx2);\n+    }\n+\n   /* Uh-oh.  We might have an address for x[n-100000].  This needs\n-     special handling.  */\n+     special handling.\n+\n+     This is common enough that we want to try and rearrange the terms\n+     so that we can use indexing for these addresses too.  Again, only\n+     do the optimization for floatint point modes.  */\n \n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n@@ -757,7 +811,7 @@ hppa_legitimize_address (x, oldx, mode)\n \t to access memory, or better yet have the MI parts of the compiler\n \t handle this.  */\n \n-      rtx regx1, regy1, regy2, y;\n+      rtx regx1, regx2, regy1, regy2, y;\n \n       /* Strip off any CONST.  */\n       y = XEXP (x, 1);\n@@ -766,11 +820,41 @@ hppa_legitimize_address (x, oldx, mode)\n \n       if (GET_CODE (y) == PLUS || GET_CODE (y) == MINUS)\n \t{\n-\t  regx1 = force_reg (Pmode, force_operand (XEXP (x, 0), 0));\n-\t  regy1 = force_reg (Pmode, force_operand (XEXP (y, 0), 0));\n-\t  regy2 = force_reg (Pmode, force_operand (XEXP (y, 1), 0));\n-\t  regx1 = force_reg (Pmode, gen_rtx (GET_CODE (y), Pmode, regx1, regy2));\n-\t  return force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regy1));\n+\t  /* See if this looks like\n+\t\t(plus (mult (reg) (shadd_const))\n+\t\t      (const (plus (symbol_ref) (const_int))))\n+\n+\t     Where const_int can be divided evenly by shadd_const and\n+\t     added to (reg).  This allows more scaled indexed addresses.  */\n+\t  if ((mode == DFmode || mode == SFmode)\n+\t      && GET_CODE (XEXP (y, 0)) == SYMBOL_REF\n+\t      && GET_CODE (XEXP (y, 1)) == CONST_INT\n+\t      && INTVAL (XEXP (y, 1)) % INTVAL (XEXP (XEXP (x, 0), 1)) == 0)\n+\t    {\n+\t      regx1\n+\t\t= force_reg (Pmode, GEN_INT (INTVAL (XEXP (y, 1))\n+\t\t\t\t\t     / INTVAL (XEXP (XEXP (x, 0), 1))));\n+\t      regx2 = XEXP (XEXP (x, 0), 0);\n+\t      if (GET_CODE (regx2) != REG)\n+\t\tregx2 = force_reg (Pmode, force_operand (regx2, 0));\n+\t      regx2 = force_reg (Pmode, gen_rtx (GET_CODE (y), Pmode,\n+\t\t\t\t\t\t regx2, regx1));\n+\t      return force_reg (Pmode,\n+\t\t\t\tgen_rtx (PLUS, Pmode,\n+\t\t\t\t\t gen_rtx (MULT, Pmode, regx2,\n+\t\t\t\t\t\t  XEXP (XEXP (x, 0), 1)),\n+\t\t\t\t\t force_reg (Pmode, XEXP (y, 0))));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Doesn't look like one we can optimize.  */\n+\t      regx1 = force_reg (Pmode, force_operand (XEXP (x, 0), 0));\n+\t      regy1 = force_reg (Pmode, force_operand (XEXP (y, 0), 0));\n+\t      regy2 = force_reg (Pmode, force_operand (XEXP (y, 1), 0));\n+\t      regx1 = force_reg (Pmode,\n+\t\t\t\t gen_rtx (GET_CODE (y), Pmode, regx1, regy2));\n+\t      return force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regy1));\n+\t    }\n \t}\n     }\n \n@@ -2077,9 +2161,7 @@ hppa_expand_prologue()\n \temit_move_insn (tmpreg, frame_pointer_rtx);\n \temit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n \tif (VAL_14_BITS_P (actual_fsize))\n-\t  emit_insn (gen_post_stwm (stack_pointer_rtx,\n-\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t    size_rtx, tmpreg));\n+\t  emit_insn (gen_post_stwm (stack_pointer_rtx, tmpreg, size_rtx));\n \telse\n \t  {\n \t    /* It is incorrect to store the saved frame pointer at *sp,\n@@ -2088,9 +2170,7 @@ hppa_expand_prologue()\n \t       So instead use stwm to store at *sp and post-increment the\n \t       stack pointer as an atomic operation.  Then increment sp to\n \t       finish allocating the new frame.  */\n-\t    emit_insn (gen_post_stwm (stack_pointer_rtx,\n-\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t      GEN_INT (64), tmpreg));\n+\t    emit_insn (gen_post_stwm (stack_pointer_rtx, tmpreg, GEN_INT (64)));\n \t    set_reg_plus_d (STACK_POINTER_REGNUM,\n \t\t\t    STACK_POINTER_REGNUM,\n \t\t\t    actual_fsize - 64);\n@@ -2209,9 +2289,8 @@ hppa_expand_prologue()\n \t      {\n \t\tmerge_sp_adjust_with_store = 0;\n \t        emit_insn (gen_post_stwm (stack_pointer_rtx,\n-\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t  GEN_INT (-offset),\n-\t\t\t\t\t  gen_rtx (REG, SImode, i)));\n+\t\t\t\t\t  gen_rtx (REG, SImode, i),\n+\t\t\t\t\t  GEN_INT (-offset)));\n \t      }\n \t    else\n \t      store_reg (i, offset, STACK_POINTER_REGNUM);\n@@ -2425,16 +2504,16 @@ hppa_expand_epilogue ()\n \t stream, doing so avoids some very obscure problems.  */\n       emit_insn (gen_blockage ());\n       set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64);\n-      emit_insn (gen_pre_ldwm (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (-64), frame_pointer_rtx));\n+      emit_insn (gen_pre_ldwm (frame_pointer_rtx, \n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       GEN_INT (-64)));\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n   else if (! frame_pointer_needed  && merge_sp_adjust_with_load)\n-    emit_insn (gen_pre_ldwm (stack_pointer_rtx,\n+    emit_insn (gen_pre_ldwm (gen_rtx (REG, SImode,\n+\t\t\t\t      merge_sp_adjust_with_load),\n \t\t\t     stack_pointer_rtx,\n-\t\t\t     GEN_INT (- actual_fsize),\n-\t\t\t     gen_rtx (REG, SImode,\n-\t\t\t     merge_sp_adjust_with_load)));\n+\t\t\t     GEN_INT (- actual_fsize)));\n   else if (actual_fsize != 0)\n     set_reg_plus_d (STACK_POINTER_REGNUM,\n \t\t    STACK_POINTER_REGNUM,"}, {"sha": "abaaa36b4d647f61d59deb27ed2ec10abd528d65", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305123ba4bacbad193a88f5d556989ed56aa7d15/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305123ba4bacbad193a88f5d556989ed56aa7d15/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=305123ba4bacbad193a88f5d556989ed56aa7d15", "patch": "@@ -1549,65 +1549,65 @@\n ;; Load or store with base-register modification.\n \n (define_insn \"pre_ldwm\"\n-  [(set (match_operand:SI 3 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"=r\")\n \t\t\t (match_operand:SI 2 \"pre_cint_operand\" \"\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+   (set (match_dup 1)\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"*\n {\n   if (INTVAL (operands[2]) < 0)\n-    return \\\"ldwm %2(0,%0),%3\\\";\n-  return \\\"ldws,mb %2(0,%0),%3\\\";\n+    return \\\"ldwm %2(0,%1),%0\\\";\n+  return \\\"ldws,mb %2(0,%1),%0\\\";\n }\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"pre_stwm\"\n-  [(set (mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t\t (match_operand:SI 2 \"pre_cint_operand\" \"\")))\n-\t(match_operand:SI 3 \"reg_or_0_operand\" \"rM\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t\t (match_operand:SI 1 \"pre_cint_operand\" \"\")))\n+\t(match_operand:SI 2 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0) (match_dup 1)))]\n   \"\"\n   \"*\n {\n-  if (INTVAL (operands[2]) < 0)\n-    return \\\"stwm %r3,%2(0,%0)\\\";\n-  return \\\"stws,mb %r3,%2(0,%0)\\\";\n+  if (INTVAL (operands[1]) < 0)\n+    return \\\"stwm %r2,%1(0,%0)\\\";\n+  return \\\"stws,mb %r2,%1(0,%0)\\\";\n }\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"post_ldwm\"\n-  [(set (match_operand:SI 3 \"register_operand\" \"r\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"0\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1)\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"=r\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 2 \"post_cint_operand\" \"\")))]\n   \"\"\n   \"*\n {\n   if (INTVAL (operands[2]) > 0)\n-    return \\\"ldwm %2(0,%0),%3\\\";\n-  return \\\"ldws,ma %2(0,%0),%3\\\";\n+    return \\\"ldwm %2(0,%1),%0\\\";\n+  return \\\"ldws,ma %2(0,%1),%1\\\";\n }\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"post_stwm\"\n-  [(set (mem:SI (match_operand:SI 1 \"register_operand\" \"0\"))\n-\t(match_operand:SI 3 \"reg_or_0_operand\" \"rM\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1)\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"=r\"))\n+\t(match_operand:SI 1 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 2 \"post_cint_operand\" \"\")))]\n   \"\"\n   \"*\n {\n   if (INTVAL (operands[2]) > 0)\n-    return \\\"stwm %r3,%2(0,%0)\\\";\n-  return \\\"stws,ma %r3,%2(0,%0)\\\";\n+    return \\\"stwm %r1,%2(0,%0)\\\";\n+  return \\\"stws,ma %r1,%2(0,%0)\\\";\n }\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n@@ -1887,24 +1887,24 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:HI 3 \"register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"=r\")\n \t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+   (set (match_dup 1)\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"ldhs,mb %2(0,%0),%3\"\n+  \"ldhs,mb %2(0,%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\")))\n-\t(match_operand:HI 3 \"reg_or_0_operand\" \"rM\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  [(set (mem:HI (plus:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t\t (match_operand:SI 1 \"int5_operand\" \"L\")))\n+\t(match_operand:HI 2 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0) (match_dup 1)))]\n   \"\"\n-  \"sths,mb %r3,%2(0,%0)\"\n+  \"sths,mb %r2,%1(0,%0)\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n \n@@ -1972,24 +1972,23 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:QI 3 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"=r\")\n \t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n+   (set (match_dup 1) (plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"ldbs,mb %2(0,%0),%3\"\n+  \"ldbs,mb %2(0,%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\")))\n-\t(match_operand:QI 3 \"reg_or_0_operand\" \"rM\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  [(set (mem:QI (plus:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t\t (match_operand:SI 1 \"int5_operand\" \"L\")))\n+\t(match_operand:QI 2 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0) (match_dup 1)))]\n   \"\"\n-  \"stbs,mb %r3,%2(0,%0)\"\n+  \"stbs,mb %r2,%1(0,%0)\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n "}]}