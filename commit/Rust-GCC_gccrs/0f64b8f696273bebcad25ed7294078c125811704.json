{"sha": "0f64b8f696273bebcad25ed7294078c125811704", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY2NGI4ZjY5NjI3M2JlYmNhZDI1ZWQ3Mjk0MDc4YzEyNTgxMTcwNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-07T12:51:35Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-07T12:51:35Z"}, "message": "(qty_changes_size): New variable.\n\n(alloc_qty{,_for_scratch}, update_qty_class): Set it.\n(local_alloc): Allocate it.\n(find_free_reg): If CLASS_CANNOT_CHANGE_SIZE, avoid its registers if\nqty_changes_size.\n\nFrom-SVN: r7865", "tree": {"sha": "8009b1a9099b53491838e129da2a592308226d62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8009b1a9099b53491838e129da2a592308226d62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f64b8f696273bebcad25ed7294078c125811704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f64b8f696273bebcad25ed7294078c125811704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f64b8f696273bebcad25ed7294078c125811704", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f64b8f696273bebcad25ed7294078c125811704/comments", "author": null, "committer": null, "parents": [{"sha": "80f8f04ad15566e8bf9ef95b458d83a1a1586637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f8f04ad15566e8bf9ef95b458d83a1a1586637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f8f04ad15566e8bf9ef95b458d83a1a1586637"}], "stats": {"total": 17, "additions": 17, "deletions": 0}, "files": [{"sha": "f7774e0e7518932a2063b66b689da2ead4b734d4", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f64b8f696273bebcad25ed7294078c125811704/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f64b8f696273bebcad25ed7294078c125811704/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=0f64b8f696273bebcad25ed7294078c125811704", "patch": "@@ -165,6 +165,11 @@ static enum reg_class *qty_alternate_class;\n \n static rtx *qty_scratch_rtx;\n \n+/* Element Q is nonzero if this quantity has been used in a SUBREG\n+   that changes its size.  */\n+\n+static char *qty_changes_size;\n+\n /* Element Q is the register number of one pseudo register whose\n    reg_qty value is Q, or -1 is this quantity is for a SCRATCH.  This\n    register should be the head of the chain maintained in reg_next_in_qty.  */\n@@ -289,6 +294,7 @@ alloc_qty (regno, mode, size, birth)\n   qty_min_class[qty] = reg_preferred_class (regno);\n   qty_alternate_class[qty] = reg_alternate_class (regno);\n   qty_n_refs[qty] = reg_n_refs[regno];\n+  qty_changes_size[qty] = reg_changes_size[regno];\n }\n \f\n /* Similar to `alloc_qty', but allocates a quantity for a SCRATCH rtx\n@@ -378,6 +384,7 @@ alloc_qty_for_scratch (scratch, n, insn, insn_code_num, insn_number)\n   qty_min_class[qty] = class;\n   qty_alternate_class[qty] = NO_REGS;\n   qty_n_refs[qty] = 1;\n+  qty_changes_size[qty] = 0;\n }\n \f\n /* Main entry point of this file.  */\n@@ -439,6 +446,7 @@ local_alloc ()\n   qty_alternate_class\n     = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n   qty_n_refs = (int *) alloca (max_qty * sizeof (int));\n+  qty_changes_size = (char *) alloca (max_qty * sizeof (char));\n \n   reg_qty = (int *) alloca (max_regno * sizeof (int));\n   reg_offset = (char *) alloca (max_regno * sizeof (char));\n@@ -1925,6 +1933,9 @@ update_qty_class (qty, reg)\n   rclass = reg_alternate_class (reg);\n   if (reg_class_subset_p (rclass, qty_alternate_class[qty]))\n     qty_alternate_class[qty] = rclass;\n+\n+  if (reg_changes_size[reg])\n+    qty_changes_size[qty] = 1;\n }\n \f\n /* Handle something which alters the value of an rtx REG.\n@@ -2108,6 +2119,12 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n   SET_HARD_REG_BIT (used, FRAME_POINTER_REGNUM);\n #endif\n \n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+  if (qty_changes_size[qty])\n+    IOR_HARD_REG_SET (first_used,\n+\t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE]);\n+#endif\n+\n   /* Normally, the registers that can be used for the first register in\n      a multi-register quantity are the same as those that can be used for\n      subsequent registers.  However, if just trying suggested registers,"}]}