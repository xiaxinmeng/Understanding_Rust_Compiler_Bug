{"sha": "49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDljM2JiMTI3NWZiZGRlNjM5ZTc3OGJlYjVhYTVmNGM2MzYxYTUyZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-20T14:04:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-20T14:04:12Z"}, "message": "basic-block.h (PROP_*): Move constants from ...\n\n        * basic-block.h (PROP_*): Move constants from ...\n        * flow.c: ... here.\n        (compute_bb_for_insn): Free the array before reallocating.\n        (update_life_info): New arg PROP_FLAGS; pass on to propagate_block.\n        (allocate_reg_life_data): Reset all reg variables collected by\n        propagate_block.\n        (get_block_head_tail): Don't convert from bb to block.\n        (get_bb_head_tail): New.  Update all callers of get_block_head_tail.\n        (find_insn_reg_weight): Take block not bb.\n        (schedule_block): Don't set block num for moved insns.\n        (schedule_region): Don't update_life_info or find_insn_reg_weight.\n        (schedule_insns): Do it here instead.\n        * combine.c (combine_instructions): Invoke compute_bb_for_insn\n        before update_life_info.\n        * recog.c (split_all_insns, peephole2_optimize): Update for\n        new arg to update_life_info.\n        * rtlanal.c (remove_note): Cope with NULL note.\n        * toplev.c (rest_of_compilation): Don't invoke recompute_reg_usage\n        if we did sched1.\n\nFrom-SVN: r30103", "tree": {"sha": "861e406256a60c2c63e3e1c6624c268ca1f60944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/861e406256a60c2c63e3e1c6624c268ca1f60944"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/comments", "author": null, "committer": null, "parents": [{"sha": "5b9188072e2e72aef010fdd9e9f4bf517cb49f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9188072e2e72aef010fdd9e9f4bf517cb49f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b9188072e2e72aef010fdd9e9f4bf517cb49f6d"}], "stats": {"total": 254, "additions": 172, "deletions": 82}, "files": [{"sha": "18d76291144cdb3930cdf6aa14580389c6affec2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -1,3 +1,25 @@\n+Wed Oct 20 06:26:58 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* basic-block.h (PROP_*): Move constants from ...\n+\t* flow.c: ... here.\n+\t(compute_bb_for_insn): Free the array before reallocating.\n+\t(update_life_info): New arg PROP_FLAGS; pass on to propagate_block.\n+\t(allocate_reg_life_data): Reset all reg variables collected by\n+\tpropagate_block.\n+\t(get_block_head_tail): Don't convert from bb to block.\n+\t(get_bb_head_tail): New.  Update all callers of get_block_head_tail.\n+\t(find_insn_reg_weight): Take block not bb.\n+\t(schedule_block): Don't set block num for moved insns.\n+\t(schedule_region): Don't update_life_info or find_insn_reg_weight.\n+\t(schedule_insns): Do it here instead.\n+\t* combine.c (combine_instructions): Invoke compute_bb_for_insn\n+\tbefore update_life_info.\n+\t* recog.c (split_all_insns, peephole2_optimize): Update for\n+\tnew arg to update_life_info.\n+\t* rtlanal.c (remove_note): Cope with NULL note.\n+\t* toplev.c (rest_of_compilation): Don't invoke recompute_reg_usage\n+\tif we did sched1.\n+\n Wed Oct 20 10:46:41 1999  Richard Earnshaw (rearnsha@arm.com)\n \n \t* jump.c (jump_optimize_1): More accurately detect casesi insns."}, {"sha": "a311a3aac37c79cf59717338fdd310449685f7bd", "filename": "gcc/basic-block.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -300,14 +300,26 @@ extern void compute_dominators\t\tPROTO ((sbitmap *, sbitmap *,\n extern void compute_flow_dominators\tPROTO ((sbitmap *, sbitmap *));\n extern void compute_immediate_dominators\tPROTO ((int *, sbitmap *));\n \n+\n enum update_life_extent\n {\n   UPDATE_LIFE_LOCAL = 0,\n   UPDATE_LIFE_GLOBAL = 1,\n   UPDATE_LIFE_GLOBAL_RM_NOTES = 2,\n };\n \n-extern void update_life_info\tPROTO ((sbitmap, enum update_life_extent));\n+/* Flags for life_analysis and update_life_info.  */\n+\n+#define PROP_DEATH_NOTES\t1\t/* Create DEAD and UNUSED notes.  */\n+#define PROP_LOG_LINKS\t\t2\t/* Create LOG_LINKS.  */\n+#define PROP_REG_INFO\t\t4\t/* Update regs_ever_live et al.  */\n+#define PROP_KILL_DEAD_CODE\t8\t/* Remove dead code.  */\n+#define PROP_SCAN_DEAD_CODE\t16\t/* Scan for dead code.  */\n+#define PROP_AUTOINC\t\t32\t/* Create autoinc mem references.  */\n+#define PROP_FINAL\t\t63\t/* All of the above.  */\n+\n+extern void update_life_info\tPROTO ((sbitmap, enum update_life_extent,\n+\t\t\t\t\tint));\n extern int count_or_remove_death_notes\tPROTO ((sbitmap, int));\n \n /* In lcm.c */"}, {"sha": "9f30666fe7200ba5fed60d218bbf7906cec8c266", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -696,7 +696,11 @@ combine_instructions (f, nregs)\n     }\n \n   if (need_refresh)\n-    update_life_info (refresh_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES);\n+    {\n+      compute_bb_for_insn (get_max_uid ());\n+      update_life_info (refresh_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t        PROP_DEATH_NOTES);\n+    }\n   sbitmap_free (refresh_blocks);\n \n   total_attempts += combine_attempts;"}, {"sha": "35a8ad576a3e28fe31beabcfda0c53e2afc29153", "filename": "gcc/flow.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -371,15 +371,6 @@ static void remove_fake_successors\tPROTO ((basic_block));\n    it being unused. */\n void verify_flow_info\t\t\tPROTO ((void));\n \n-/* Flags for propagate_block.  */\n-\n-#define PROP_DEATH_NOTES\t1\t/* Create DEAD and UNUSED notes.  */\n-#define PROP_LOG_LINKS\t\t2\t/* Create LOG_LINKS.  */\n-#define PROP_REG_INFO\t\t4\t/* Update regs_ever_live et al.  */\n-#define PROP_KILL_DEAD_CODE\t8\t/* Remove dead code.  */\n-#define PROP_SCAN_DEAD_CODE\t16\t/* Scan for dead code.  */\n-#define PROP_AUTOINC\t\t32\t/* Create autoinc mem references.  */\n-#define PROP_FINAL\t\t63\t/* All of the above.  */\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -838,6 +829,8 @@ compute_bb_for_insn (max)\n {\n   int i;\n \n+  if (basic_block_for_insn)\n+    VARRAY_FREE (basic_block_for_insn);\n   VARRAY_BB_INIT (basic_block_for_insn, max, \"basic_block_for_insn\");\n \n   for (i = 0; i < n_basic_blocks; ++i)\n@@ -2567,16 +2560,21 @@ verify_local_live_at_start (new_live_at_start, bb)\n    If we find registers removed from live_at_start, that means we have\n    a broken peephole that is killing a register it shouldn't.\n \n-   BLOCK_FOR_INSN is assumed to be correct.\n-\n    ??? This is not true in one situation -- when a pre-reload splitter\n    generates subregs of a multi-word pseudo, current life analysis will\n-   lose the kill.  So we _can_ have a pseudo go live.  How irritating.  */\n+   lose the kill.  So we _can_ have a pseudo go live.  How irritating.\n+\n+   BLOCK_FOR_INSN is assumed to be correct.\n+\n+   ??? PROP_FLAGS should not contain PROP_LOG_LINKS.  Need to set up\n+   reg_next_use for that.  Including PROP_REG_INFO does not refresh\n+   regs_ever_live unless the caller resets it to zero.  */\n \n void\n-update_life_info (blocks, extent)\n+update_life_info (blocks, extent, prop_flags)\n      sbitmap blocks;\n      enum update_life_extent extent;\n+     int prop_flags;\n {\n   regset tmp;\n   int i;\n@@ -2586,7 +2584,8 @@ update_life_info (blocks, extent)\n   /* For a global update, we go through the relaxation process again.  */\n   if (extent != UPDATE_LIFE_LOCAL)\n     {\n-      calculate_global_regs_live (blocks, blocks, 0);\n+      calculate_global_regs_live (blocks, blocks,\n+\t\t\t\t  prop_flags & PROP_SCAN_DEAD_CODE);\n \n       /* If asked, remove notes from the blocks we'll update.  */\n       if (extent == UPDATE_LIFE_GLOBAL_RM_NOTES)\n@@ -2599,7 +2598,7 @@ update_life_info (blocks, extent)\n \n       COPY_REG_SET (tmp, bb->global_live_at_end);\n       propagate_block (tmp, bb->head, bb->end, (regset) NULL, i,\n-\t\t       PROP_DEATH_NOTES);\n+\t\t       prop_flags);\n \n       if (extent == UPDATE_LIFE_LOCAL)\n \tverify_local_live_at_start (tmp, bb);\n@@ -3194,12 +3193,17 @@ allocate_reg_life_data ()\n      vector oriented regsets would set regset_{size,bytes} here also.  */\n   allocate_reg_info (max_regno, FALSE, FALSE);\n \n-  /* Because both reg_scan and flow_analysis want to set up the REG_N_SETS\n-     information, explicitly reset it here.  The allocation should have\n-     already happened on the previous reg_scan pass.  Make sure in case\n-     some more registers were allocated.  */\n+  /* Reset all the data we'll collect in propagate_block and its \n+     subroutines.  */\n   for (i = 0; i < max_regno; i++)\n-    REG_N_SETS (i) = 0;\n+    {\n+      REG_N_SETS (i) = 0;\n+      REG_N_REFS (i) = 0;\n+      REG_N_DEATHS (i) = 0;\n+      REG_N_CALLS_CROSSED (i) = 0;\n+      REG_LIVE_LENGTH (i) = 0;\n+      REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+    }\n }\n \n /* Compute the registers live at the beginning of a basic block"}, {"sha": "6fc172222a29fc2f284cc31403c5f53b3f0c2a81", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 98, "deletions": 56, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -698,6 +698,7 @@ static void rm_other_notes PROTO ((rtx, rtx));\n static rtx reemit_notes PROTO ((rtx, rtx));\n \n static void get_block_head_tail PROTO ((int, rtx *, rtx *));\n+static void get_bb_head_tail PROTO ((int, rtx *, rtx *));\n \n static int queue_to_ready PROTO ((rtx [], int));\n \n@@ -4299,17 +4300,14 @@ unlink_line_notes (insn, tail)\n /* Return the head and tail pointers of BB.  */\n \n HAIFA_INLINE static void\n-get_block_head_tail (bb, headp, tailp)\n-     int bb;\n+get_block_head_tail (b, headp, tailp)\n+     int b;\n      rtx *headp;\n      rtx *tailp;\n {\n \n   rtx head;\n   rtx tail;\n-  int b;\n-\n-  b = BB_TO_BLOCK (bb);\n \n   /* HEAD and TAIL delimit the basic block being scheduled.  */\n   head = BLOCK_HEAD (b);\n@@ -4333,6 +4331,15 @@ get_block_head_tail (bb, headp, tailp)\n   *tailp = tail;\n }\n \n+HAIFA_INLINE static void\n+get_bb_head_tail (bb, headp, tailp)\n+     int bb;\n+     rtx *headp;\n+     rtx *tailp;\n+{\n+  get_block_head_tail (BB_TO_BLOCK (bb), headp, tailp);\n+}\n+\n /* Delete line notes from bb. Save them so they can be later restored\n    (in restore_line_notes ()).  */\n \n@@ -4345,7 +4352,7 @@ rm_line_notes (bb)\n   rtx head;\n   rtx insn;\n \n-  get_block_head_tail (bb, &head, &tail);\n+  get_bb_head_tail (bb, &head, &tail);\n \n   if (head == tail\n       && (GET_RTX_CLASS (GET_CODE (head)) != 'i'))\n@@ -4391,7 +4398,7 @@ save_line_notes (bb)\n   rtx line = line_note_head[BB_TO_BLOCK (bb)];\n   rtx insn;\n \n-  get_block_head_tail (bb, &head, &tail);\n+  get_bb_head_tail (bb, &head, &tail);\n   next_tail = NEXT_INSN (tail);\n \n   for (insn = BLOCK_HEAD (BB_TO_BLOCK (bb));\n@@ -4562,12 +4569,12 @@ rm_other_notes (head, tail)\n /* Calculate INSN_REG_WEIGHT for all insns of a block.  */\n \n static void\n-find_insn_reg_weight (bb)\n-    int bb;\n+find_insn_reg_weight (b)\n+    int b;\n {\n   rtx insn, next_tail, head, tail;\n \n-  get_block_head_tail (bb, &head, &tail);\n+  get_block_head_tail (b, &head, &tail);\n   next_tail = NEXT_INSN (tail);\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n@@ -5726,7 +5733,7 @@ schedule_block (bb, rgn_n_insns)\n      However, it was removed when it proved to be of marginal benefit\n      and caused problems because schedule_block and compute_forward_dependences\n      had different notions of what the \"head\" insn was.  */\n-  get_block_head_tail (bb, &head, &tail);\n+  get_bb_head_tail (bb, &head, &tail);\n \n   /* Interblock scheduling could have moved the original head insn from this\n      block into a proceeding block.  This may also cause schedule_block and\n@@ -5838,7 +5845,7 @@ schedule_block (bb, rgn_n_insns)\n \trtx src_next_tail;\n \trtx tail, head;\n \n-\tget_block_head_tail (bb_src, &head, &tail);\n+\tget_bb_head_tail (bb_src, &head, &tail);\n \tsrc_next_tail = NEXT_INSN (tail);\n \tsrc_head = head;\n \n@@ -5968,15 +5975,14 @@ schedule_block (bb, rgn_n_insns)\n \t\t}\n \t      nr_inter++;\n \n-\t      /* Find the beginning of the scheduling group; update the\n-\t\t containing block number for the insns.  */\n+\t      /* Find the beginning of the scheduling group.  */\n+\t      /* ??? Ought to update basic block here, but later bits of \n+\t\t schedule_block assumes the original insn block is \n+\t\t still intact.  */\n+\n \t      temp = insn;\n-\t      set_block_num (temp, target_bb);\n \t      while (SCHED_GROUP_P (insn))\n-\t\t{\n-\t\t  temp = PREV_INSN (temp);\n-\t\t  set_block_num (temp, target_bb);\n-\t\t}\n+\t\ttemp = PREV_INSN (temp);\n \n \t      /* Update source block boundaries.   */\n \t      b1 = BLOCK_FOR_INSN (temp);\n@@ -6118,7 +6124,7 @@ compute_block_forward_dependences (bb)\n   rtx next_tail;\n   enum reg_note dep_type;\n \n-  get_block_head_tail (bb, &head, &tail);\n+  get_bb_head_tail (bb, &head, &tail);\n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n@@ -6337,7 +6343,7 @@ compute_block_backward_dependences (bb)\n     }\n \n   /* Do the analysis for this block.  */\n-  get_block_head_tail (bb, &head, &tail);\n+  get_bb_head_tail (bb, &head, &tail);\n   sched_analyze (head, tail);\n   add_branch_dependences (head, tail);\n \n@@ -6520,7 +6526,7 @@ debug_dependencies ()\n \t  rtx next_tail;\n \t  rtx insn;\n \n-\t  get_block_head_tail (bb, &head, &tail);\n+\t  get_bb_head_tail (bb, &head, &tail);\n \t  next_tail = NEXT_INSN (tail);\n \t  fprintf (dump, \"\\n;;   --- Region Dependences --- b %d bb %d \\n\",\n \t\t   BB_TO_BLOCK (bb), bb);\n@@ -6591,7 +6597,7 @@ set_priorities (bb)\n   rtx prev_head;\n   rtx head;\n \n-  get_block_head_tail (bb, &head, &tail);\n+  get_bb_head_tail (bb, &head, &tail);\n   prev_head = PREV_INSN (head);\n \n   if (head == tail\n@@ -6647,8 +6653,6 @@ schedule_region (rgn)\n   int bb;\n   int rgn_n_insns = 0;\n   int sched_rgn_n_insns = 0;\n-  int initial_deaths;\n-  sbitmap blocks;\n \n   /* Set variables for the current region.  */\n   current_nr_blocks = RGN_NR_BLOCKS (rgn);\n@@ -6658,13 +6662,6 @@ schedule_region (rgn)\n   reg_pending_clobbers = ALLOCA_REG_SET ();\n   reg_pending_sets_all = 0;\n \n-  /* Create a bitmap of the blocks in this region.  */\n-  blocks = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_zero (blocks);\n-\n-  for (bb = current_nr_blocks - 1; bb >= 0; --bb)\n-    SET_BIT (blocks, BB_TO_BLOCK (bb));\n-\n   /* Initializations for region data dependence analyisis.  */\n   if (current_nr_blocks > 1)\n     {\n@@ -6714,13 +6711,6 @@ schedule_region (rgn)\n   for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n     compute_block_forward_dependences (bb);\n \n-  /* Compute INSN_REG_WEIGHT.  */\n-  for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n-    find_insn_reg_weight (bb);\n-\n-  /* Remove death notes.  */\n-  initial_deaths = count_or_remove_death_notes (blocks, 1);\n-\n   /* Delete line notes and set priorities.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {\n@@ -6797,20 +6787,6 @@ schedule_region (rgn)\n   if (sched_rgn_n_insns != rgn_n_insns)\n     abort ();\n \n-  /* Update register life and usage information.  Scheduling a multi-block\n-     region requires a global update.  */\n-  if (current_nr_blocks > 1)\n-    update_life_info (blocks, UPDATE_LIFE_GLOBAL);\n-  else\n-    {\n-      update_life_info (blocks, UPDATE_LIFE_LOCAL);\n-\n-      /* In the single block case, the count of registers that died should\n-\t not have changed during the schedule.  */\n-      if (count_or_remove_death_notes (blocks, 0) != initial_deaths)\n-        abort (); \n-    }\n-\n   /* Restore line notes.  */\n   if (write_symbols != NO_DEBUG)\n     {\n@@ -6823,7 +6799,6 @@ schedule_region (rgn)\n \n   FREE_REG_SET (reg_pending_sets);\n   FREE_REG_SET (reg_pending_clobbers);\n-  sbitmap_free (blocks);\n }\n \n /* The one entry point in this file.  DUMP_FILE is the dump file for\n@@ -6833,13 +6808,14 @@ void\n schedule_insns (dump_file)\n      FILE *dump_file;\n {\n-\n+  int *deaths_in_region;\n+  sbitmap blocks, large_region_blocks;\n   int max_uid;\n   int b;\n   rtx insn;\n   int rgn;\n-\n   int luid;\n+  int any_large_regions;\n \n   /* Disable speculative loads in their presence if cc0 defined.  */\n #ifdef HAVE_cc0\n@@ -6905,6 +6881,9 @@ schedule_insns (dump_file)\n   block_to_bb = (int *) alloca ((n_basic_blocks) * sizeof (int));\n   containing_rgn = (int *) alloca ((n_basic_blocks) * sizeof (int));\n \n+  blocks = sbitmap_alloc (n_basic_blocks);\n+  large_region_blocks = sbitmap_alloc (n_basic_blocks);\n+\n   compute_bb_for_insn (max_uid);\n \n   /* Compute regions for scheduling.  */\n@@ -6992,6 +6971,8 @@ schedule_insns (dump_file)\n   insn_dep_count = (int *) xcalloc (max_uid, sizeof (int));\n   insn_depend = (rtx *) xcalloc (max_uid, sizeof (rtx));\n \n+  deaths_in_region = (int *) alloca (sizeof(int) * nr_regions);\n+\n   init_alias_analysis ();\n \n   if (write_symbols != NO_DEBUG)\n@@ -7034,6 +7015,21 @@ schedule_insns (dump_file)\n \t       && GET_CODE (NEXT_INSN (insn)) == BARRIER)))\n     emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n \n+  /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before\n+     removing death notes.  */\n+  for (b = n_basic_blocks - 1; b >= 0; b--)\n+    find_insn_reg_weight (b);\n+\n+  /* Remove all death notes from the subroutine.  */\n+  for (rgn = 0; rgn < nr_regions; rgn++)\n+    {\n+      sbitmap_zero (blocks);\n+      for (b = RGN_NR_BLOCKS (rgn) - 1; b >= 0; --b)\n+\tSET_BIT (blocks, rgn_bb_table [RGN_BLOCKS (rgn) + b]);\n+\n+      deaths_in_region[rgn] = count_or_remove_death_notes (blocks, 1);\n+    }\n+\n   /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     {\n@@ -7044,6 +7040,49 @@ schedule_insns (dump_file)\n #endif\n     }\n \n+  /* Update life analysis for the subroutine.  Do single block regions\n+     first so that we can verify that live_at_start didn't change.  Then\n+     do all other blocks.   */\n+  /* ??? There is an outside possibility that update_life_info, or more\n+     to the point propagate_block, could get called with non-zero flags\n+     more than once for one basic block.  This would be kinda bad if it\n+     were to happen, since REG_INFO would be accumulated twice for the\n+     block, and we'd have twice the REG_DEAD notes.\n+\n+     I'm fairly certain that this _shouldn't_ happen, since I don't think\n+     that live_at_start should change at region heads.  Not sure what the\n+     best way to test for this kind of thing... */\n+\n+  allocate_reg_life_data ();\n+  compute_bb_for_insn (max_uid);\n+\n+  any_large_regions = 0;\n+  sbitmap_ones (large_region_blocks);\n+\n+  for (rgn = 0; rgn < nr_regions; rgn++)\n+    if (RGN_NR_BLOCKS (rgn) > 1)\n+      any_large_regions = 1;\n+    else\n+      {\n+\tsbitmap_zero (blocks);\n+\tSET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn)]);\n+\tRESET_BIT (large_region_blocks, rgn_bb_table[RGN_BLOCKS (rgn)]);\n+\n+\tupdate_life_info (blocks, UPDATE_LIFE_LOCAL,\n+\t\t\t  PROP_DEATH_NOTES | PROP_REG_INFO);\n+\n+\t/* In the single block case, the count of registers that died should\n+\t   not have changed during the schedule.  */\n+\tif (count_or_remove_death_notes (blocks, 0) != deaths_in_region[rgn])\n+          abort (); \n+      }\n+\n+  if (any_large_regions)\n+    {\n+      update_life_info (large_region_blocks, UPDATE_LIFE_GLOBAL,\n+\t\t        PROP_DEATH_NOTES | PROP_REG_INFO);\n+    }\n+\n   /* Reposition the prologue and epilogue notes in case we moved the\n      prologue/epilogue insns.  */\n   if (reload_completed)\n@@ -7108,5 +7147,8 @@ schedule_insns (dump_file)\n       free (out_edges);\n       out_edges = NULL;\n     }\n+\n+  sbitmap_free (blocks);\n+  sbitmap_free (large_region_blocks);\n }\n #endif /* INSN_SCHEDULING */"}, {"sha": "91c8af0d94f05abc4ce6f33270cfebbd271a5377", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -2661,7 +2661,7 @@ split_all_insns (upd_life)\n     {\n       compute_bb_for_insn (get_max_uid ());\n       count_or_remove_death_notes (blocks, 1);\n-      update_life_info (blocks, UPDATE_LIFE_LOCAL);\n+      update_life_info (blocks, UPDATE_LIFE_LOCAL, PROP_DEATH_NOTES);\n     }\n \n   sbitmap_free (blocks);\n@@ -2762,6 +2762,6 @@ peephole2_optimize (dump_file)\n \n   compute_bb_for_insn (get_max_uid ());\n   count_or_remove_death_notes (blocks, 1);\n-  update_life_info (blocks, UPDATE_LIFE_LOCAL);\n+  update_life_info (blocks, UPDATE_LIFE_LOCAL, PROP_DEATH_NOTES);\n }\n #endif"}, {"sha": "012f6db9468549fb2ce71ad3bf44212a700b5376", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -1513,11 +1513,14 @@ find_regno_fusage (insn, code, regno)\n \n void\n remove_note (insn, note)\n-     register rtx note;\n      register rtx insn;\n+     register rtx note;\n {\n   register rtx link;\n \n+  if (note == NULL_RTX)\n+    return;\n+\n   if (REG_NOTES (insn) == note)\n     {\n       REG_NOTES (insn) = XEXP (note, 1);"}, {"sha": "d8c5819c641b5707d44283c1bfe6524c4cfaae3e", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c3bb1275fbdde639e778beb5aa5f4c6361a52d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=49c3bb1275fbdde639e778beb5aa5f4c6361a52d", "patch": "@@ -4112,7 +4112,10 @@ rest_of_compilation (decl)\n   if (!obey_regdecls)\n     TIMEVAR (local_alloc_time,\n \t     {\n-\t       recompute_reg_usage (insns, ! optimize_size);\n+\t       /* We recomputed reg usage as part of updating the rest\n+\t\t  of life info during sched.  */\n+\t       if (! flag_schedule_insns)\n+\t\t recompute_reg_usage (insns, ! optimize_size);\n \t       regclass (insns, max_reg_num ());\n \t       rebuild_label_notes_after_reload = local_alloc ();\n \t     });"}]}