{"sha": "1b1562a55947daed482e2d8ef47a4f577397beb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIxNTYyYTU1OTQ3ZGFlZDQ4MmUyZDhlZjQ3YTRmNTc3Mzk3YmViOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-10-15T17:42:05Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-10-15T17:42:05Z"}, "message": "Add fma support\n\nFrom-SVN: r165515", "tree": {"sha": "5a6ace72e7cb1c4c33366822e3836c93b74e3f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a6ace72e7cb1c4c33366822e3836c93b74e3f78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b1562a55947daed482e2d8ef47a4f577397beb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1562a55947daed482e2d8ef47a4f577397beb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b1562a55947daed482e2d8ef47a4f577397beb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1562a55947daed482e2d8ef47a4f577397beb9/comments", "author": null, "committer": null, "parents": [{"sha": "e74bf53a08b08e94ef88b0e1b0401e393efb1dac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74bf53a08b08e94ef88b0e1b0401e393efb1dac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e74bf53a08b08e94ef88b0e1b0401e393efb1dac"}], "stats": {"total": 1240, "additions": 1086, "deletions": 154}, "files": [{"sha": "6bcaec9a34628eaae354c2e195af14bda89a41ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -1,3 +1,74 @@\n+2010-10-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* doc/md.texi (Standard Names): Add fma@var{m}4 documentation.\n+\n+\t* doc/rtl.texi (RTX_TERNARY): Document FMA is ternary.  Add\n+\tSIGN_EXTRACT and ZERO_EXTRACT which were missing.\n+\t(Standard names): Document fma.\n+\n+\t* doc/cpp.texi (Common Predefined Macros): Document __FP_FAST_FMA,\n+\t__FP_FAST_FMAF, __FP_FAST_FMAL.\n+\n+\t* builitns.c (expand_builtin_mathfn_ternary): New function for\n+\texpanding ternary math functions, like fma.\n+\t(expand_builtin): Call it for the fma builtins.\n+\n+\t* simplify-rtx.c (simplify_ternary_operation): Don't simplify FMA\n+\tops at present.\n+\n+\t* tree-vect-stmts.c (vectorizable_call): Allow 3 argument\n+\tvectorizable functions to support vectorizing fma.\n+\n+\t* config/rs6000/rs6000.c (rs6000_builtin_vectorized_function):\n+\tHandle fma builtins.\n+\n+\t* config/rs6000/vsx.md (UNSPEC_VSX_MADD): Delete.\n+\t(UNSPEC_VSX_MSUB): Ditto.\n+\t(UNSPEC_VSX_NMADD): Ditto.\n+\t(UNSPEC_VSX_NMSUB): Ditto.\n+\t(vsx_fmadd<mode>4*): Rewrite to use FMA rtl in some cases instead\n+\tof UNSPEC. Renumber combiner patterns.\n+\t(vsx_fmsub<mode>4*): Ditto.\n+\t(vsx_fnmadd<mode>4*): Ditto.\n+\t(vsx_fnmsub<mode>4*): Ditto.\n+\n+\t* config/rs6000/altivec.md (UNSPEC_VNMSUBFP): Delete.\n+\t(altivec_vmaddfp): Rewrite to use FMA rtl if no fused\n+\tmultiply/add.  Rename combiner pattern, and add TARGET_FUSED_MADD\n+\ttest.\n+\t(altivec_vmaddfp_1): Ditto.\n+\t(altivec_vmaddfp_2): Ditto.\n+\t(atlivec_mulv4sf3): Ditto.\n+\t(altivec_vnmsubfp): Ditto.\n+\t(altivec_vnmsubfp_1): Ditto.\n+\t(altivec_vnmsubfp_2): Ditto.\n+\t(altivec_vnmsubfp_3): Delete.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_FMA): Delete.\n+\t(fmasf4): Rewrite to always use FMA rtl.  Add combiners to\n+\tgenerate the four fused multiply/add ops.  Combine power, powerpc\n+\tops.\n+\t(fmasf4_fpr): Ditto.\n+\t(fmssf4_fpr): Ditto.\n+\t(fnmasf4_fpr): Ditto.\n+\t(fnmssf4_fpr): Ditto.\n+\t(fmadf4): Ditto.\n+\t(fmadf4_fpr): Ditto.\n+\t(fmsdf4_fpr): Ditto.\n+\t(fnmadf4_fpr): Ditto.\n+\t(fnmsdf4_fpr): Ditto.\n+\n+\t* optabs.h (OTI_fma): Add fma optab.\n+\t(fma_optab): Ditto.\n+\n+\t* genopinit.c (optabs): Set fma optab.\n+\n+\t* rtl.def (FMA): Add FMA rtl.\n+\n+\t* tree.h (mode_has_fma): New function to return if MODE supports a\n+\tfast multiply and add instruction.\n+\t* builtins.c (mode_has_fma): Ditto.\n+\n 2010-10-15  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-streamer-out.c (write_symbol): Use pointer set of seen"}, {"sha": "370d521bcdc83d3c3c6354be21352ffcac39dbc5", "filename": "gcc/builtins.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -106,6 +106,7 @@ static void expand_errno_check (tree, rtx);\n static rtx expand_builtin_mathfn (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_2 (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_3 (tree, rtx, rtx);\n+static rtx expand_builtin_mathfn_ternary (tree, rtx, rtx);\n static rtx expand_builtin_interclass_mathfn (tree, rtx);\n static rtx expand_builtin_sincos (tree);\n static rtx expand_builtin_cexpi (tree, rtx);\n@@ -2185,6 +2186,79 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   return target;\n }\n \n+/* Expand a call to the builtin trinary math functions (fma).\n+   Return NULL_RTX if a normal call should be emitted rather than expanding the\n+   function in-line.  EXP is the expression that is a call to the builtin\n+   function; if convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing one of EXP's\n+   operands.  */\n+\n+static rtx\n+expand_builtin_mathfn_ternary (tree exp, rtx target, rtx subtarget)\n+{\n+  optab builtin_optab;\n+  rtx op0, op1, op2, insns;\n+  tree fndecl = get_callee_fndecl (exp);\n+  tree arg0, arg1, arg2;\n+  enum machine_mode mode;\n+\n+  if (!validate_arglist (exp, REAL_TYPE, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n+  arg2 = CALL_EXPR_ARG (exp, 2);\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    CASE_FLT_FN (BUILT_IN_FMA):\n+      builtin_optab = fma_optab; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Make a suitable register to place result in.  */\n+  mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  /* Before working hard, check whether the instruction is available.  */\n+  if (optab_handler (builtin_optab, mode) == CODE_FOR_nothing)\n+    return NULL_RTX;\n+\n+  target = gen_reg_rtx (mode);\n+\n+  /* Always stabilize the argument list.  */\n+  CALL_EXPR_ARG (exp, 0) = arg0 = builtin_save_expr (arg0);\n+  CALL_EXPR_ARG (exp, 1) = arg1 = builtin_save_expr (arg1);\n+  CALL_EXPR_ARG (exp, 2) = arg2 = builtin_save_expr (arg2);\n+\n+  op0 = expand_expr (arg0, subtarget, VOIDmode, EXPAND_NORMAL);\n+  op1 = expand_normal (arg1);\n+  op2 = expand_normal (arg2);\n+\n+  start_sequence ();\n+\n+  /* Compute into TARGET.\n+     Set TARGET to wherever the result comes back.  */\n+  target = expand_ternary_op (mode, builtin_optab, op0, op1, op2,\n+\t\t\t      target, 0);\n+\n+  /* If we were unable to expand via the builtin, stop the sequence\n+     (without outputting the insns) and call to the library function\n+     with the stabilized argument list.  */\n+  if (target == 0)\n+    {\n+      end_sequence ();\n+      return expand_call (exp, target, target == const0_rtx);\n+    }\n+\n+  /* Output the entire sequence.  */\n+  insns = get_insns ();\n+  end_sequence ();\n+  emit_insn (insns);\n+\n+  return target;\n+}\n+\n /* Expand a call to the builtin sin and cos math functions.\n    Return NULL_RTX if a normal call should be emitted rather than expanding the\n    function in-line.  EXP is the expression that is a call to the builtin\n@@ -5828,6 +5902,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n+    CASE_FLT_FN (BUILT_IN_FMA):\n+      target = expand_builtin_mathfn_ternary (exp, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     CASE_FLT_FN (BUILT_IN_ILOGB):\n       if (! flag_unsafe_math_optimizations)\n \tbreak;\n@@ -13830,3 +13910,10 @@ is_inexpensive_builtin (tree decl)\n   return false;\n }\n \n+/* Return true if MODE provides a fast multiply/add (FMA) builtin function.  */\n+\n+bool\n+mode_has_fma (enum machine_mode mode)\n+{\n+  return optab_handler (fma_optab, mode) != CODE_FOR_nothing;\n+}"}, {"sha": "29fc3a1e37d22cca9376c334ff6299580245c596", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -1,8 +1,15 @@\n+2010-10-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* c-cppbuiltin.c (builtin_define_float_constants): Emit\n+\t__FP_FAST_FMA, __FP_FAST_FMAF, and __FP_FAST_FMAL if the machine\n+\thas the appropriate fma builtins.\n+\t(c_cpp_builtins): Adjust call to builtin_define_float_constants.\n+\n 2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\tmerge from FSF apple 'trunk' branch. \n+\tmerge from FSF apple 'trunk' branch.\n \t2006 Fariborz Jahanian <fjahanian@apple.com>\n-\t\n+\n \tRadars 4436866, 4505126, 4506903, 4517826\n \t* c-common.c (c_common_resword): Define @property and its attributes.\n \t* c-common.h: Define property attribute enum entries.\n@@ -14,17 +21,17 @@\n \t(objc_add_property_variable): Likewise.\n \t(objc_build_getter_call): Likewise.\n \t(objc_build_setter_call) Likewise.\n-\t\n+\n 2010-10-13  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\tmerge from FSF apple 'trunk' branch. \n+\tmerge from FSF apple 'trunk' branch.\n \t2006-04-26 Fariborz Jahanian <fjahanian@apple.com>\n \n \tRadar 3803157 (method attributes)\n \t* c-common.c (handle_deprecated_attribute): Recognize\n \tobjc methods as valid declarations.\n \t* c-common.h: Declare objc_method_decl ().\n-\t* stub-objc.c (objc_method_decl): New stub. \n+\t* stub-objc.c (objc_method_decl): New stub.\n \n 2010-10-08  Joseph Myers  <joseph@codesourcery.com>\n "}, {"sha": "0ad77c7415ed8cdd3720dddfba04b61507d0e3a1", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -60,6 +60,7 @@ static void builtin_define_type_max (const char *, tree);\n static void builtin_define_type_minmax (const char *, const char *, tree);\n static void builtin_define_type_sizeof (const char *, tree);\n static void builtin_define_float_constants (const char *,\n+\t\t\t\t\t    const char *,\n \t\t\t\t\t    const char *,\n \t\t\t\t\t    const char *,\n \t\t\t\t\t    tree);\n@@ -78,6 +79,7 @@ static void\n builtin_define_float_constants (const char *name_prefix,\n \t\t                const char *fp_suffix,\n \t\t\t\tconst char *fp_cast,\n+\t\t\t\tconst char *fma_suffix,\n \t\t\t\ttree type)\n {\n   /* Used to convert radix-based values to base 10 values in several cases.\n@@ -260,6 +262,13 @@ builtin_define_float_constants (const char *name_prefix,\n      NaN has quiet NaNs.  */\n   sprintf (name, \"__%s_HAS_QUIET_NAN__\", name_prefix);\n   builtin_define_with_int_value (name, MODE_HAS_NANS (TYPE_MODE (type)));\n+\n+  /* Note whether we have fast FMA.  */\n+  if (mode_has_fma (TYPE_MODE (type)))\n+    {\n+      sprintf (name, \"__FP_FAST_FMA%s\", fma_suffix);\n+      builtin_define_with_int_value (name, 1);\n+    }\n }\n \n /* Define __DECx__ constants for TYPE using NAME_PREFIX and SUFFIX. */\n@@ -607,13 +616,15 @@ c_cpp_builtins (cpp_reader *pfile)\n   builtin_define_with_int_value (\"__DEC_EVAL_METHOD__\",\n                                  TARGET_DEC_EVAL_METHOD);\n \n-  builtin_define_float_constants (\"FLT\", \"F\", \"%s\", float_type_node);\n+  builtin_define_float_constants (\"FLT\", \"F\", \"%s\", \"F\", float_type_node);\n   /* Cast the double precision constants.  This is needed when single\n      precision constants are specified or when pragma FLOAT_CONST_DECIMAL64\n      is used.  The correct result is computed by the compiler when using\n      macros that include a cast.  */\n-  builtin_define_float_constants (\"DBL\", \"L\", \"((double)%s)\", double_type_node);\n-  builtin_define_float_constants (\"LDBL\", \"L\", \"%s\", long_double_type_node);\n+  builtin_define_float_constants (\"DBL\", \"L\", \"((double)%s)\", \"\",\n+\t\t\t\t  double_type_node);\n+  builtin_define_float_constants (\"LDBL\", \"L\", \"%s\", \"L\",\n+\t\t\t\t  long_double_type_node);\n \n   /* For decfloat.h.  */\n   builtin_define_decimal_float_constants (\"DEC32\", \"DF\", dfloat32_type_node);"}, {"sha": "9f1b3fe7f8a875a79c0469647fadc9ce2e9a9495", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -143,7 +143,6 @@\n    (UNSPEC_VUPKLS_V4SF  325)\n    (UNSPEC_VUPKHU_V4SF  326)\n    (UNSPEC_VUPKLU_V4SF  327)\n-   (UNSPEC_VNMSUBFP\t328)\n ])\n \n (define_constants\n@@ -513,12 +512,39 @@\n   \"vsel %0,%3,%2,%1\"\n   [(set_attr \"type\" \"vecperm\")])\n \n-;; Fused multiply add\n-(define_insn \"altivec_vmaddfp\"\n+;; Fused multiply add.  By default expand the FMA into (plus (mult)) to help\n+;; loop unrolling.  Don't do negate multiply ops, because of complications with\n+;; honoring signed zero and fused-madd.\n+\n+(define_expand \"altivec_vmaddfp\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+\t(plus:V4SF (mult:V4SF (match_operand:V4SF 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:V4SF 2 \"register_operand\" \"\"))\n+\t  \t   (match_operand:V4SF 3 \"register_operand\" \"\")))]\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n+{\n+  if (!TARGET_FUSED_MADD)\n+    {\n+      emit_insn (gen_altivec_vmaddfp_2 (operands[0], operands[1], operands[2],\n+\t\t\t\t\toperands[3]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*altivec_vmaddfp_1\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n \t(plus:V4SF (mult:V4SF (match_operand:V4SF 1 \"register_operand\" \"v\")\n \t\t\t      (match_operand:V4SF 2 \"register_operand\" \"v\"))\n \t  \t   (match_operand:V4SF 3 \"register_operand\" \"v\")))]\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode) && TARGET_FUSED_MADD\"\n+  \"vmaddfp %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"altivec_vmaddfp_2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(fma:V4SF (match_operand:V4SF 1 \"register_operand\" \"v\")\n+\t\t  (match_operand:V4SF 2 \"register_operand\" \"v\")\n+\t\t  (match_operand:V4SF 3 \"register_operand\" \"v\")))]\n   \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n   \"vmaddfp %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecfloat\")])\n@@ -529,7 +555,7 @@\n   [(use (match_operand:V4SF 0 \"register_operand\" \"\"))\n    (use (match_operand:V4SF 1 \"register_operand\" \"\"))\n    (use (match_operand:V4SF 2 \"register_operand\" \"\"))]\n-  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode) && TARGET_FUSED_MADD\"\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n   \"\n {\n   rtx neg0;\n@@ -627,34 +653,18 @@\n }\")\n \n ;; Fused multiply subtract \n-(define_expand \"altivec_vnmsubfp\"\n-  [(match_operand:V4SF 0 \"register_operand\" \"\")\n-   (match_operand:V4SF 1 \"register_operand\" \"\")\n-   (match_operand:V4SF 2 \"register_operand\" \"\")\n-   (match_operand:V4SF 3 \"register_operand\" \"\")]\n+(define_insn \"altivec_vnmsubfp\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(neg:V4SF\n+\t (fma:V4SF (match_operand:V4SF 1 \"register_operand\" \"v\")\n+\t\t   (match_operand:V4SF 2 \"register_operand\" \"v\")\n+\t\t   (neg:V4SF\n+\t\t    (match_operand:V4SF 3 \"register_operand\" \"v\")))))]\n   \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n-{\n-  if (TARGET_FUSED_MADD && HONOR_SIGNED_ZEROS (SFmode))\n-    {\n-       emit_insn (gen_altivec_vnmsubfp_1 (operands[0], operands[1],\n-\t\t\t\t\t  operands[2], operands[3]));\n-       DONE;\n-    }\n-  else if (TARGET_FUSED_MADD && !HONOR_SIGNED_ZEROS (DFmode))\n-    {\n-       emit_insn (gen_altivec_vnmsubfp_2 (operands[0], operands[1],\n-\t\t\t\t\t  operands[2], operands[3]));\n-       DONE;\n-    }\n-  else\n-    {\n-       emit_insn (gen_altivec_vnmsubfp_3 (operands[0], operands[1],\n-\t\t\t\t\t  operands[2], operands[3]));\n-       DONE;\n-    }\n-})\n+  \"vnmsubfp %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecfloat\")])\n \n-(define_insn \"altivec_vnmsubfp_1\"\n+(define_insn \"*altivec_vnmsubfp_1\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n \t(neg:V4SF\n \t (minus:V4SF\n@@ -667,7 +677,7 @@\n   \"vnmsubfp %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecfloat\")])\n \n-(define_insn \"altivec_vnmsubfp_2\"\n+(define_insn \"*altivec_vnmsubfp_2\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n \t(minus:V4SF\n \t (match_operand:V4SF 3 \"register_operand\" \"v\")\n@@ -679,16 +689,6 @@\n   \"vnmsubfp %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecfloat\")])\n \n-(define_insn \"altivec_vnmsubfp_3\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n-\t(unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")\n-\t\t       (match_operand:V4SF 2 \"register_operand\" \"v\")\n-\t\t       (match_operand:V4SF 3 \"register_operand\" \"v\")]\n-\t\t      UNSPEC_VNMSUBFP))]\n-  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n-  \"vnmsubfp %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"vecfloat\")])\n-\n (define_insn \"altivec_vmsumu<VI_char>m\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:VIshort 1 \"register_operand\" \"v\")"}, {"sha": "f97730181272dd4ff91c622dab4e5b6a46da6ece", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -3938,6 +3938,22 @@ rs6000_builtin_vectorized_function (tree fndecl, tree type_out,\n \t  if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n \t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIM];\n \t  break;\n+\tcase BUILT_IN_FMA:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVMADDDP];\n+\t  break;\n+\tcase BUILT_IN_FMAF:\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode)\n+\t      && out_mode == SFmode && out_n == 4\n+\t      && in_mode == SFmode && in_n == 4)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVMADDSP];\n+\t  else if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n+\t      && out_mode == SFmode && out_n == 4\n+\t      && in_mode == SFmode && in_n == 4)\n+\t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_VMADDFP];\n+\t  break;\n \tcase BUILT_IN_TRUNC:\n \t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t      && out_mode == DFmode && out_n == 2"}, {"sha": "f1e63ccc79038897bdc31285e80e1ca8c1481eae", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -5844,6 +5844,78 @@\n   \"fres %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n+; builtin fmaf support\n+; If the user explicitly uses the fma builtin, don't convert this to\n+; (plus (mult op1 op2) op3)\n+(define_expand \"fmasf4\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+\t(fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:SF 3 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"\")\n+\n+(define_insn \"fmasf4_fpr\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"*\n+{\n+  return ((TARGET_POWERPC)\n+\t  ? \\\"fmadds %0,%1,%2,%3\\\"\n+\t  : \\\"{fma|fmadd} %0,%1,%2,%3\\\");\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+(define_insn \"*fmssf4_fpr\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n+\t\t(neg:SF (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"*\n+{\n+  return ((TARGET_POWERPC)\n+\t  ? \\\"fmsubs %0,%1,%2,%3\\\"\n+\t  : \\\"{fms|fmsub} %0,%1,%2,%3\\\");\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+(define_insn \"*fnmasf4_fpr\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(neg:SF (fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t(match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"*\n+{\n+  return ((TARGET_POWERPC)\n+\t  ? \\\"fnmadds %0,%1,%2,%3\\\"\n+\t  : \\\"{fnma|fnmadd} %0,%1,%2,%3\\\");\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+(define_insn \"*fnmssf4_fpr\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(neg:SF (fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t(neg:SF (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"*\n+{\n+  return ((TARGET_POWERPC)\n+\t  ? \\\"fnmsubs %0,%1,%2,%3\\\"\n+\t  : \\\"{fnms|fnmsub} %0,%1,%2,%3\\\");\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+; Fused multiply/add ops created by the combiner\n (define_insn \"*fmaddsf4_powerpc\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n@@ -5854,7 +5926,7 @@\n   \"fmadds %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_maddsub_s\")])\n-\n+ \n (define_insn \"*fmaddsf4_power\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n@@ -6312,6 +6384,62 @@\n   \"frsqrte %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n+; builtin fma support\n+; If the user explicitly uses the fma builtin, don't convert this to\n+; (plus (mult op1 op2) op3)\n+(define_expand \"fmadf4\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DF 3 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"\")\n+\n+(define_insn \"fmadf4_fpr\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:DF 3 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && VECTOR_UNIT_NONE_P (DFmode)\"\n+  \"{fma|fmadd} %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+(define_insn \"*fmsdf4_fpr\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n+\t\t(neg:DF (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && VECTOR_UNIT_NONE_P (DFmode)\"\n+  \"{fms|fmsub} %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+(define_insn \"*fnmadf4_fpr\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(neg:DF (fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t(match_operand:DF 3 \"gpc_reg_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && VECTOR_UNIT_NONE_P (DFmode)\"\n+  \"{fnma|fnmadd} %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+(define_insn \"*fnmsdf4_fpr\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(neg:DF (fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t(neg:DF (match_operand:DF 3 \"gpc_reg_operand\" \"f\")))))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && VECTOR_UNIT_NONE_P (DFmode)\"\n+  \"{fnms|fnmsub} %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n+\n+; Fused multiply/add ops created by the combiner\n (define_insn \"*fmadddf4_fpr\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n \t(plus:DF (mult:DF (match_operand:DF 1 \"gpc_reg_operand\" \"%d\")"}, {"sha": "a861cc0d915cf5db941177f2d730937e44eaa775", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 44, "deletions": 99, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -194,11 +194,7 @@\n    (UNSPEC_VSX_CVUXDSP\t\t507)\n    (UNSPEC_VSX_CVSPSXDS\t\t508)\n    (UNSPEC_VSX_CVSPUXDS\t\t509)\n-   (UNSPEC_VSX_MADD\t\t510)\n-   (UNSPEC_VSX_MSUB\t\t511)\n-   (UNSPEC_VSX_NMADD\t\t512)\n-   (UNSPEC_VSX_NMSUB\t\t513)\n-   ;; 514 deleted\n+   ;; 510-514 deleted\n    (UNSPEC_VSX_TDIV\t\t515)\n    (UNSPEC_VSX_TSQRT\t\t516)\n    (UNSPEC_VSX_XXPERMDI\t\t517)\n@@ -499,19 +495,22 @@\n ;; does not check -mfused-madd to allow users to use these ops when they know\n ;; they want the fused multiply/add.\n \n+;; Fused multiply add.  By default expand the FMA into (plus (mult)) to help\n+;; loop unrolling.  Don't do negate multiply ops, because of complications with\n+;; honoring signed zero and fused-madd.\n+\n (define_expand \"vsx_fmadd<mode>4\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"\")\n \t(plus:VSX_B\n-\t (mult:VSX_B\n-\t  (match_operand:VSX_B 1 \"vsx_register_operand\" \"\")\n-\t  (match_operand:VSX_B 2 \"vsx_register_operand\" \"\"))\n+\t (mult:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"\")\n+\t\t     (match_operand:VSX_B 2 \"vsx_register_operand\" \"\"))\n \t (match_operand:VSX_B 3 \"vsx_register_operand\" \"\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n {\n   if (!TARGET_FUSED_MADD)\n     {\n-      emit_insn (gen_vsx_fmadd<mode>4_2 (operands[0], operands[1], operands[2],\n-\t\t\t\t\t operands[3]));\n+      emit_insn (gen_vsx_fmadd<mode>4_2 (operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3]));\n       DONE;\n     }\n })\n@@ -534,10 +533,9 @@\n \n (define_insn \"vsx_fmadd<mode>4_2\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,wa,wa\")\n-\t\t       (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n-\t\t       (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\")]\n-\t\t      UNSPEC_VSX_MADD))]\n+\t(fma:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,wa,wa\")\n+\t\t   (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n+\t\t   (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"@\n    x<VSv>madda<VSs> %x0,%x1,%x2\n@@ -550,16 +548,15 @@\n (define_expand \"vsx_fmsub<mode>4\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"\")\n \t(minus:VSX_B\n-\t (mult:VSX_B\n-\t  (match_operand:VSX_B 1 \"vsx_register_operand\" \"\")\n-\t  (match_operand:VSX_B 2 \"vsx_register_operand\" \"\"))\n+\t (mult:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"\")\n+\t\t     (match_operand:VSX_B 2 \"vsx_register_operand\" \"\"))\n \t (match_operand:VSX_B 3 \"vsx_register_operand\" \"\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n {\n   if (!TARGET_FUSED_MADD)\n     {\n-      emit_insn (gen_vsx_fmsub<mode>4_2 (operands[0], operands[1], operands[2],\n-\t\t\t\t\t operands[3]));\n+      emit_insn (gen_vsx_fmsub<mode>4_2 (operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3]));\n       DONE;\n     }\n })\n@@ -582,10 +579,10 @@\n \n (define_insn \"vsx_fmsub<mode>4_2\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,wa,wa\")\n-\t\t       (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n-\t\t       (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\")]\n-\t\t      UNSPEC_VSX_MSUB))]\n+\t(fma:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,wa,wa\")\n+\t\t   (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n+\t\t   (neg:VSX_B\n+\t\t    (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"@\n    x<VSv>msuba<VSs> %x0,%x1,%x2\n@@ -595,32 +592,21 @@\n   [(set_attr \"type\" \"<VStype_mul>\")\n    (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n-(define_expand \"vsx_fnmadd<mode>4\"\n-  [(match_operand:VSX_B 0 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_B 1 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_B 2 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_B 3 \"vsx_register_operand\" \"\")]\n+(define_insn \"vsx_fnmadd<mode>4\"\n+  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n+\t(neg:VSX_B\n+\t (fma:VSX_B\n+\t  (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSr>,wa,wa\")\n+\t  (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n+\t  (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-{\n-  if (TARGET_FUSED_MADD && HONOR_SIGNED_ZEROS (DFmode))\n-    {\n-       emit_insn (gen_vsx_fnmadd<mode>4_1 (operands[0], operands[1],\n-\t\t\t\t\t   operands[2], operands[3]));\n-       DONE;\n-    }\n-  else if (TARGET_FUSED_MADD && !HONOR_SIGNED_ZEROS (DFmode))\n-    {\n-       emit_insn (gen_vsx_fnmadd<mode>4_2 (operands[0], operands[1],\n-\t\t\t\t\t   operands[2], operands[3]));\n-       DONE;\n-    }\n-  else\n-    {\n-       emit_insn (gen_vsx_fnmadd<mode>4_3 (operands[0], operands[1],\n-\t\t\t\t\t   operands[2], operands[3]));\n-       DONE;\n-    }\n-})\n+  \"@\n+   x<VSv>nmadda<VSs> %x0,%x1,%x2\n+   x<VSv>nmaddm<VSs> %x0,%x1,%x3\n+   x<VSv>nmadda<VSs> %x0,%x1,%x2\n+   x<VSv>nmaddm<VSs> %x0,%x1,%x3\"\n+  [(set_attr \"type\" \"<VStype_mul>\")\n+   (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n (define_insn \"vsx_fnmadd<mode>4_1\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n@@ -658,48 +644,22 @@\n   [(set_attr \"type\" \"<VStype_mul>\")\n    (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n-(define_insn \"vsx_fnmadd<mode>4_3\"\n+(define_insn \"vsx_fnmsub<mode>4\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSr>,wa,wa\")\n-\t\t       (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n-\t\t       (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\")]\n-\t\t      UNSPEC_VSX_NMADD))]\n+\t(neg:VSX_B\n+\t (fma:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,wa,wa\")\n+\t\t    (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n+\t\t    (neg:VSX_B\n+\t\t     (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\")))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"@\n-   x<VSv>nmadda<VSs> %x0,%x1,%x2\n-   x<VSv>nmaddm<VSs> %x0,%x1,%x3\n-   x<VSv>nmadda<VSs> %x0,%x1,%x2\n-   x<VSv>nmaddm<VSs> %x0,%x1,%x3\"\n+   x<VSv>nmsuba<VSs> %x0,%x1,%x2\n+   x<VSv>nmsubm<VSs> %x0,%x1,%x3\n+   x<VSv>nmsuba<VSs> %x0,%x1,%x2\n+   x<VSv>nmsubm<VSs> %x0,%x1,%x3\"\n   [(set_attr \"type\" \"<VStype_mul>\")\n    (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n-(define_expand \"vsx_fnmsub<mode>4\"\n-  [(match_operand:VSX_B 0 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_B 1 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_B 2 \"vsx_register_operand\" \"\")\n-   (match_operand:VSX_B 3 \"vsx_register_operand\" \"\")]\n-  \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-{\n-  if (TARGET_FUSED_MADD && HONOR_SIGNED_ZEROS (DFmode))\n-    {\n-       emit_insn (gen_vsx_fnmsub<mode>4_1 (operands[0], operands[1],\n-\t\t\t\t\t   operands[2], operands[3]));\n-       DONE;\n-    }\n-  else if (TARGET_FUSED_MADD && !HONOR_SIGNED_ZEROS (DFmode))\n-    {\n-       emit_insn (gen_vsx_fnmsub<mode>4_2 (operands[0], operands[1],\n-\t\t\t\t\t   operands[2], operands[3]));\n-       DONE;\n-    }\n-  else\n-    {\n-       emit_insn (gen_vsx_fnmsub<mode>4_3 (operands[0], operands[1],\n-\t\t\t\t\t   operands[2], operands[3]));\n-       DONE;\n-    }\n-})\n-\n (define_insn \"vsx_fnmsub<mode>4_1\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n \t(neg:VSX_B\n@@ -735,21 +695,6 @@\n   [(set_attr \"type\" \"<VStype_mul>\")\n    (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n-(define_insn \"vsx_fnmsub<mode>4_3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,wa,wa\")\n-\t\t       (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n-\t\t       (match_operand:VSX_B 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\")]\n-\t\t      UNSPEC_VSX_NMSUB))]\n-  \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"@\n-   x<VSv>nmsuba<VSs> %x0,%x1,%x2\n-   x<VSv>nmsubm<VSs> %x0,%x1,%x3\n-   x<VSv>nmsuba<VSs> %x0,%x1,%x2\n-   x<VSv>nmsubm<VSs> %x0,%x1,%x3\"\n-  [(set_attr \"type\" \"<VStype_mul>\")\n-   (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n-\n ;; Vector conditional expressions (no scalar version for these instructions)\n (define_insn \"vsx_eq<mode>\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")"}, {"sha": "a580e6108c8106d1029c113696820d43ab34f552", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -2345,6 +2345,15 @@ and swap operations on operands 1, 2, 4, 8 or 16 bytes in length, respectively.\n This macro is defined when the compiler is emitting Dwarf2 CFI directives\n to the assembler.  When this is defined, it is possible to emit those same\n directives in inline assembly.\n+\n+@item __FP_FAST_FMA\n+@itemx __FP_FAST_FMAF\n+@itemx __FP_FAST_FMAL\n+These macros are defined with value 1 if the backend supports the\n+@code{fma}, @code{fmaf}, and @code{fmal} builtin functions, so that\n+the include file @file{math.h} can define the macros\n+@code{FP_FAST_FMA}, @code{FP_FAST_FMAF}, and @code{FP_FAST_FMAL}\n+for compatibility with the 1999 C standard.\n @end table\n \n @node System-specific Predefined Macros"}, {"sha": "6de4f3658a6d0304d3a20a57f768c9ede34b53a7", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -3948,6 +3948,16 @@ means of constraints requiring operands 1 and 0 to be the same location.\n @itemx @samp{and@var{m}3}, @samp{ior@var{m}3}, @samp{xor@var{m}3}\n Similar, for other arithmetic operations.\n \n+@cindex @code{fma@var{m}4} instruction pattern\n+@item @samp{fma@var{m}4}\n+Multiply operand 2 and operand 1, then add operand 3, storing the\n+result in operand 0.  All operands must have mode @var{m}.  This\n+pattern is used to implement the @code{fma}, @code{fmaf}, and\n+@code{fmal} builtin functions from the ISO C99 standard.  The\n+@code{fma} operation may produce different results than doing the\n+multiply followed by the add if the machine does not perform a\n+rounding step between the operations.\n+\n @cindex @code{min@var{m}3} instruction pattern\n @cindex @code{max@var{m}3} instruction pattern\n @item @samp{smin@var{m}3}, @samp{smax@var{m}3}"}, {"sha": "6fae670b8b9893d1ab43249525dc0730681df0a2", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -182,7 +182,8 @@ and are lvalues (so they can be used for insertion as well).\n \n @item RTX_TERNARY\n An RTX code for other three input operations.  Currently only\n-@code{IF_THEN_ELSE} and @code{VEC_MERGE}.\n+@code{IF_THEN_ELSE},  @code{VEC_MERGE}, @code{SIGN_EXTRACT},\n+@code{ZERO_EXTRACT}, and @code{FMA}.\n \n @item RTX_INSN\n An RTX code for an entire instruction:  @code{INSN}, @code{JUMP_INSN}, and\n@@ -2234,6 +2235,12 @@ not be the same.\n For unsigned widening multiplication, use the same idiom, but with\n @code{zero_extend} instead of @code{sign_extend}.\n \n+@findex fma\n+@item (fma:@var{m} @var{x} @var{y} @var{z})\n+Represents the @code{fma}, @code{fmaf}, and @code{fmal} builtin\n+functions that do a combined multiply of @var{x} and @var{y} and then\n+adding to@var{z} without doing an intermediate rounding step.\n+\n @findex div\n @findex ss_div\n @cindex division"}, {"sha": "6e0a714f49e21801b0cea0cda9b3dae053ed8345", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -159,6 +159,7 @@ static const char * const optabs[] =\n   \"set_optab_handler (sqrt_optab, $A, CODE_FOR_$(sqrt$a2$))\",\n   \"set_optab_handler (floor_optab, $A, CODE_FOR_$(floor$a2$))\",\n   \"set_convert_optab_handler (lfloor_optab, $B, $A, CODE_FOR_$(lfloor$F$a$I$b2$))\",\n+  \"set_optab_handler (fma_optab, $A, CODE_FOR_$(fma$a4$))\",\n   \"set_optab_handler (ceil_optab, $A, CODE_FOR_$(ceil$a2$))\",\n   \"set_convert_optab_handler (lceil_optab, $B, $A, CODE_FOR_$(lceil$F$a$I$b2$))\",\n   \"set_optab_handler (round_optab, $A, CODE_FOR_$(round$a2$))\","}, {"sha": "8b9c9a730e01df0ce6ac3080dd7414d189494101", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -190,6 +190,8 @@ enum optab_index\n   OTI_pow,\n   /* Arc tangent of y/x */\n   OTI_atan2,\n+  /* Floating multiply/add */\n+  OTI_fma,\n \n   /* Move instruction.  */\n   OTI_mov,\n@@ -432,6 +434,7 @@ enum optab_index\n #define umax_optab (&optab_table[OTI_umax])\n #define pow_optab (&optab_table[OTI_pow])\n #define atan2_optab (&optab_table[OTI_atan2])\n+#define fma_optab (&optab_table[OTI_fma])\n \n #define mov_optab (&optab_table[OTI_mov])\n #define movstrict_optab (&optab_table[OTI_movstrict])"}, {"sha": "6e2aa8beede46630319ee1df868eed74ee2d9420", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -706,6 +706,9 @@ DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", RTX_UNARY)\n /* Unsigned saturating truncate.  */\n DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", RTX_UNARY)\n \n+/* Floating point multiply/add combined instruction.  */\n+DEF_RTL_EXPR(FMA, \"fma\", \"eee\", RTX_TERNARY)\n+\n /* Information about the variable and its location.  */\n /* Changed 'te' to 'tei'; the 'i' field is for recording\n    initialization status of variables.  */"}, {"sha": "f700958c4f0ada47b2922b35cb714c4119e07e6e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -4712,6 +4712,12 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \n   switch (code)\n     {\n+      /* At present, don't simplify fused multiply and add ops, because we need\n+\t to make sure there are no intermediate rounding steps used, and that\n+\t we get the right sign if negative 0 would be returned.  */\n+    case FMA:\n+      return NULL_RTX;\n+\n     case SIGN_EXTRACT:\n     case ZERO_EXTRACT:\n       if (CONST_INT_P (op0)"}, {"sha": "f1469a2548381ae13d522c4027120e47d7ee091f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -1,3 +1,13 @@\n+2010-10-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc-fma-1.c: New tests for powerpc FMA\n+\tbuiltin combiner patterns.\n+\t* gcc.target/powerpc/ppc-fma-2.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fma-3.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fma-4.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fma-5.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fma-6.c: Ditto.\n+\n 2010-10-15  Richard Guenther  <rguenther@suse.de>\n \n \t* g++.dg/lto/20101015-1_0.C: New testcase."}, {"sha": "674115a285ae9104c263e719fb293e9da6fda0a4", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fma-1.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-1.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -0,0 +1,183 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -ftree-vectorize -mcpu=power7 -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"xvmadd\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xsmadd\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmadds\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xvmsub\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsmsub\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvnmadd\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsnmadd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmadds\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvnmsub\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsnmsub\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmsubs\" 1 } } */\n+\n+/* All functions should generate an appropriate (a * b) + c instruction\n+   since -mfused-madd is on by default.  */\n+\n+double\n+builtin_fma (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, d);\t\t\t/* xsmadd{a,m}dp */\n+}\n+\n+double\n+builtin_fms (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, -d);\t\t\t/* xsmsub{a,b}dp */\n+}\n+\n+double\n+builtin_fnma (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, d);\t\t\t/* xsnmadd{a,b}dp */\n+}\n+\n+double\n+builtin_fnms (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, -d);\t\t\t/* xsnmsub{a,b}dp */\n+}\n+\n+float\n+builtin_fmaf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, d);\t\t\t/* fmadds */\n+}\n+\n+float\n+builtin_fmsf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, -d);\t\t\t/* fmsubs */\n+}\n+\n+float\n+builtin_fnmaf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, d);\t\t\t/* fnmadds */\n+}\n+\n+float\n+builtin_fnmsf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, -d);\t\t\t/* fnmsubs */\n+}\n+\n+double\n+normal_fma (double b, double c, double d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* xsmadd{a,m}dp */\n+}\n+\n+float\n+normal_fmaf (float b, float c, float d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* fmadds */\n+}\n+\n+#ifndef SIZE\n+#define SIZE 1024\n+#endif\n+\n+double vda[SIZE] __attribute__((__aligned__(32)));\n+double vdb[SIZE] __attribute__((__aligned__(32)));\n+double vdc[SIZE] __attribute__((__aligned__(32)));\n+double vdd[SIZE] __attribute__((__aligned__(32)));\n+\n+float vfa[SIZE] __attribute__((__aligned__(32)));\n+float vfb[SIZE] __attribute__((__aligned__(32)));\n+float vfc[SIZE] __attribute__((__aligned__(32)));\n+float vfd[SIZE] __attribute__((__aligned__(32)));\n+\n+void\n+vector_fma (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = __builtin_fma (vdb[i], vdc[i], vdd[i]);\t/* xvmadd{a,m}dp */\n+}\n+\n+void\n+vector_fms (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = __builtin_fma (vdb[i], vdc[i], -vdd[i]);\t/* xvmsub{a,m}dp */\n+}\n+\n+void\n+vector_fnma (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = - __builtin_fma (vdb[i], vdc[i], vdd[i]);\t/* xvnmadd{a,m}dp */\n+}\n+\n+void\n+vector_fnms (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = - __builtin_fma (vdb[i], vdc[i], -vdd[i]);\t/* xvnmsub{a,m}dp */\n+}\n+\n+void\n+vector_fmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = __builtin_fmaf (vfb[i], vfc[i], vfd[i]);\t/* xvmadd{a,m}sp */\n+}\n+\n+void\n+vector_fmsf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = __builtin_fmaf (vfb[i], vfc[i], -vfd[i]);\t/* xvmsub{a,m}sp */\n+}\n+\n+void\n+vector_fnmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = - __builtin_fmaf (vfb[i], vfc[i], vfd[i]);\t/* xvnmadd{a,m}sp */\n+}\n+\n+void\n+vector_fnmsf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = - __builtin_fmaf (vfb[i], vfc[i], -vfd[i]); /* xvnmsub{a,m}sp */\n+}\n+\n+void\n+vnormal_fma (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = (vdb[i] * vdc[i]) + vdd[i];\t\t/* xvmadd{a,m}dp */\n+}\n+\n+void\n+vnormal_fmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = (vfb[i] * vfc[i]) + vfd[i];\t\t/* xvmadd{a,m}sp */\n+}"}, {"sha": "a17565b2c909056ecb8ba1e4865567532d8b946d", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fma-2.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-2.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -0,0 +1,183 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -ftree-vectorize -mcpu=power7 -ffast-math -mno-fused-madd\" } */\n+/* { dg-final { scan-assembler-times \"xvmadd\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsmadd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmadds\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvmsub\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsmsub\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvnmadd\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsnmadd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmadds\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvnmsub\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsnmsub\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmsubs\" 1 } } */\n+\n+/* Only the functions calling the bulitin should generate an appropriate (a *\n+   b) + c instruction.  */\n+\n+double\n+builtin_fma (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, d);\t\t\t/* xsmadd{a,m}dp */\n+}\n+\n+double\n+builtin_fms (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, -d);\t\t\t/* xsmsub{a,b}dp */\n+}\n+\n+double\n+builtin_fnma (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, d);\t\t\t/* xsnmadd{a,b}dp */\n+}\n+\n+double\n+builtin_fnms (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, -d);\t\t\t/* xsnmsub{a,b}dp */\n+}\n+\n+float\n+builtin_fmaf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, d);\t\t\t/* fmadds */\n+}\n+\n+float\n+builtin_fmsf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, -d);\t\t\t/* fmsubs */\n+}\n+\n+float\n+builtin_fnmaf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, d);\t\t\t/* fnmadds */\n+}\n+\n+float\n+builtin_fnmsf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, -d);\t\t\t/* fnmsubs */\n+}\n+\n+double\n+normal_fma (double b, double c, double d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* fmul/fadd */\n+}\n+\n+float\n+normal_fmaf (float b, float c, float d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* fmuls/fadds */\n+}\n+\n+#ifndef SIZE\n+#define SIZE 1024\n+#endif\n+\n+double vda[SIZE] __attribute__((__aligned__(32)));\n+double vdb[SIZE] __attribute__((__aligned__(32)));\n+double vdc[SIZE] __attribute__((__aligned__(32)));\n+double vdd[SIZE] __attribute__((__aligned__(32)));\n+\n+float vfa[SIZE] __attribute__((__aligned__(32)));\n+float vfb[SIZE] __attribute__((__aligned__(32)));\n+float vfc[SIZE] __attribute__((__aligned__(32)));\n+float vfd[SIZE] __attribute__((__aligned__(32)));\n+\n+void\n+vector_fma (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = __builtin_fma (vdb[i], vdc[i], vdd[i]);\t/* xvmadd{a,m}dp */\n+}\n+\n+void\n+vector_fms (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = __builtin_fma (vdb[i], vdc[i], -vdd[i]);\t/* xvmsub{a,m}dp */\n+}\n+\n+void\n+vector_fnma (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = - __builtin_fma (vdb[i], vdc[i], vdd[i]);\t/* xvnmadd{a,m}dp */\n+}\n+\n+void\n+vector_fnms (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = - __builtin_fma (vdb[i], vdc[i], -vdd[i]);\t/* xvnmsub{a,m}dp */\n+}\n+\n+void\n+vector_fmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = __builtin_fmaf (vfb[i], vfc[i], vfd[i]);\t/* xvmadd{a,m}sp */\n+}\n+\n+void\n+vector_fmsf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = __builtin_fmaf (vfb[i], vfc[i], -vfd[i]);\t/* xvmsub{a,m}sp */\n+}\n+\n+void\n+vector_fnmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = - __builtin_fmaf (vfb[i], vfc[i], vfd[i]);\t/* xvnmadd{a,m}sp */\n+}\n+\n+void\n+vector_fnmsf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = - __builtin_fmaf (vfb[i], vfc[i], -vfd[i]); /* xvnmsub{a,m}sp */\n+}\n+\n+void\n+vnormal_fma (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vda[i] = (vdb[i] * vdc[i]) + vdd[i];\t\t/* xvmadd{a,m}dp */\n+}\n+\n+void\n+vnormal_fmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = (vfb[i] * vfc[i]) + vfd[i];\t\t/* xvmadd{a,m}sp */\n+}"}, {"sha": "c83c58298bde94ee6ce7ec5815fb65d1dc879524", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fma-3.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-3.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-O3 -ftree-vectorize -mcpu=power6 -maltivec -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"vmaddfp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmadd \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmadds\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmsub \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmadd \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmadds\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmsub \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmsubs\" 1 } } */\n+\n+/* All functions should generate an appropriate (a * b) + c instruction\n+   since -mfused-madd is on by default.  */\n+\n+double\n+builtin_fma (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, d);\t\t\t/* fmadd */\n+}\n+\n+double\n+builtin_fms (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, -d);\t\t\t/* fmsub */\n+}\n+\n+double\n+builtin_fnma (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, d);\t\t\t/* fnmadd */\n+}\n+\n+double\n+builtin_fnms (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, -d);\t\t\t/* fnmsub */\n+}\n+\n+float\n+builtin_fmaf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, d);\t\t\t/* fmadds */\n+}\n+\n+float\n+builtin_fmsf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, -d);\t\t\t/* fmsubs */\n+}\n+\n+float\n+builtin_fnmaf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, d);\t\t\t/* fnmadds */\n+}\n+\n+float\n+builtin_fnmsf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, -d);\t\t\t/* fnmsubs */\n+}\n+\n+double\n+normal_fma (double b, double c, double d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* fmadd */\n+}\n+\n+float\n+normal_fmaf (float b, float c, float d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* fmadds */\n+}\n+\n+#ifndef SIZE\n+#define SIZE 1024\n+#endif\n+\n+float vfa[SIZE] __attribute__((__aligned__(32)));\n+float vfb[SIZE] __attribute__((__aligned__(32)));\n+float vfc[SIZE] __attribute__((__aligned__(32)));\n+float vfd[SIZE] __attribute__((__aligned__(32)));\n+\n+void\n+vector_fmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = __builtin_fmaf (vfb[i], vfc[i], vfd[i]);\t/* vaddfp */\n+}\n+\n+void\n+vnormal_fmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = (vfb[i] * vfc[i]) + vfd[i];\t\t/* vaddfp */\n+}"}, {"sha": "50e43178477004db9311e6bc653064706396c06b", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fma-4.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-4.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-O3 -ftree-vectorize -mcpu=power6 -maltivec -ffast-math -mno-fused-madd\" } */\n+/* { dg-final { scan-assembler-times \"vmaddfp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmadd \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmadds\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmsub \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmadd \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmadds\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmsub \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fnmsubs\" 1 } } */\n+\n+/* Only the functions calling the builtin should generate an appropriate\n+   (a * b) + c instruction.  */\n+\n+double\n+builtin_fma (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, d);\t\t\t/* fmadd */\n+}\n+\n+double\n+builtin_fms (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, -d);\t\t\t/* fmsub */\n+}\n+\n+double\n+builtin_fnma (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, d);\t\t\t/* fnmadd */\n+}\n+\n+double\n+builtin_fnms (double b, double c, double d)\n+{\n+  return - __builtin_fma (b, c, -d);\t\t\t/* fnmsub */\n+}\n+\n+float\n+builtin_fmaf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, d);\t\t\t/* fmadds */\n+}\n+\n+float\n+builtin_fmsf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, -d);\t\t\t/* fmsubs */\n+}\n+\n+float\n+builtin_fnmaf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, d);\t\t\t/* fnmadds */\n+}\n+\n+float\n+builtin_fnmsf (float b, float c, float d)\n+{\n+  return - __builtin_fmaf (b, c, -d);\t\t\t/* fnmsubs */\n+}\n+\n+double\n+normal_fma (double b, double c, double d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* fmul/fadd */\n+}\n+\n+float\n+normal_fmaf (float b, float c, float d)\n+{\n+  return (b * c) + d;\t\t\t\t\t/* fmuls/fadds */\n+}\n+\n+#ifndef SIZE\n+#define SIZE 1024\n+#endif\n+\n+float vfa[SIZE] __attribute__((__aligned__(32)));\n+float vfb[SIZE] __attribute__((__aligned__(32)));\n+float vfc[SIZE] __attribute__((__aligned__(32)));\n+float vfd[SIZE] __attribute__((__aligned__(32)));\n+\n+void\n+vector_fmaf (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    vfa[i] = __builtin_fmaf (vfb[i], vfc[i], vfd[i]);\t/* vaddfp */\n+}"}, {"sha": "97243afb7c4ffeec3349b29243aab9f5e97895b5", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fma-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-5.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mcpu=power5 -std=c99\" } */\n+\n+#ifndef __FP_FAST_FMA\n+#error \"__FP_FAST_FMA should be defined\"\n+#endif\n+\n+#ifndef __FP_FAST_FMAF\n+#error \"__FP_FAST_FMAF should be defined\"\n+#endif\n+\n+double d_a = 2.0,  d_b = 3.0,  d_c = 4.0;\n+float  f_a = 2.0f, f_b = 3.0f, f_c = 4.0f;\n+\n+int\n+main (void)\n+{\n+  if (__builtin_fma (d_a, d_b, d_c) != (2.0 * 3.0) + 4.0)\n+    __builtin_abort ();\n+\n+  if (__builtin_fmaf (f_a, f_b, f_c) != (2.0f * 3.0f) + 4.0f)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "c9132bbf8a473625bd058b27067b94f2ebaabc74", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fma-6.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fma-6.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -mcpu=power5 -std=c99 -msoft-float\" } */\n+/* { dg-final { scan-assembler-not \"fmadd\" } } */\n+/* { dg-final { scan-assembler-not \"xsfmadd\" } } */\n+\n+/* Test whether -msoft-float turns off the macros math.h uses for\n+   FP_FAST_FMA{,F,L}.  */\n+#ifdef __FP_FAST_FMA\n+#error \"__FP_FAST_FMA should not be defined\"\n+#endif\n+\n+#ifdef __FP_FAST_FMAF\n+#error \"__FP_FAST_FMAF should not be defined\"\n+#endif\n+\n+double\n+builtin_fma (double b, double c, double d)\n+{\n+  return __builtin_fma (b, c, d);\t\t\t/* bl fma  */\n+}\n+\n+float\n+builtin_fmaf (float b, float c, float d)\n+{\n+  return __builtin_fmaf (b, c, -d);\t\t\t/* bl fmaf */\n+}"}, {"sha": "63af34e9161c6dcccd4a8e53bc220d6eacfea82f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -1357,10 +1357,10 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   vectype_in = NULL_TREE;\n   nargs = gimple_call_num_args (stmt);\n \n-  /* Bail out if the function has more than two arguments, we\n-     do not have interesting builtin functions to vectorize with\n-     more than two arguments.  No arguments is also not good.  */\n-  if (nargs == 0 || nargs > 2)\n+  /* Bail out if the function has more than three arguments, we do not have\n+     interesting builtin functions to vectorize with more than two arguments\n+     except for fma.  No arguments is also not good.  */\n+  if (nargs == 0 || nargs > 3)\n     return false;\n \n   for (i = 0; i < nargs; i++)"}, {"sha": "af14b8bca5f663adf84866cecc87dda30f52eecb", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1562a55947daed482e2d8ef47a4f577397beb9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1b1562a55947daed482e2d8ef47a4f577397beb9", "patch": "@@ -5068,6 +5068,7 @@ extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);\n+extern bool mode_has_fma (enum machine_mode mode);\n \n /* In convert.c */\n extern tree strip_float_extensions (tree);"}]}