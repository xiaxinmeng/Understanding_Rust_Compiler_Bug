{"sha": "cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M5NzExYTM2YTI0Y2Q1ZWZiZDY0YmJkNGFjNjg1OGZiMzI2MmZjNg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-06T23:34:32Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-06T23:34:32Z"}, "message": "libsupc++: New directory.\n\n\n2000-10-06  Benjamin Kosnik  <bkoz@cygnus.com>\n            Richard Henderson  <rth@cygnus.com>\n\t    Alexandre Oliva  <aoliva@redhat.com>\n\n\t* libsupc++: New directory.\n\t* libsupc++/*: Populate.\n\t* libsupc++/Makefile.am (INCLUDES): Add -I../../gcc for\n\teh-common.h, gansidecl.h.\n\t* configure.in: Add in libsupc++/Makefile to AC_OUTPUT.\n\t* configure: Regenerate.\n\t* Makefile.am (SUBDIRS): Add libsupc++.\n\t* Makefile.in: Regenerate.\n\t* src/Makefile.am (libstdc___la_LIBADD): Add in libsupc++.la\n\t* src/Makefile.in: Regenerate.\n\t* libio/Makefile.am: Remove extraneous, confusing bits.\n\t* libio/Makefile.in: Regenerate.\n\nFrom-SVN: r36764", "tree": {"sha": "81204c73c949ad0bf1c0420e25d9d00d7c96dbe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81204c73c949ad0bf1c0420e25d9d00d7c96dbe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/comments", "author": null, "committer": null, "parents": [{"sha": "06bd10fb63d7bcdb508e34474fa72e75770b052d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bd10fb63d7bcdb508e34474fa72e75770b052d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bd10fb63d7bcdb508e34474fa72e75770b052d"}], "stats": {"total": 824, "additions": 824, "deletions": 0}, "files": [{"sha": "908d7c467fec0b25c5bc20e955090e5a7fbb454e", "filename": "libstdc++-v3/libsupc++/include/cxxabi.h", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fcxxabi.h?ref=cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "patch": "@@ -0,0 +1,519 @@\n+/* new abi support -*- C++ -*-\n+   Copyright (C) 2000\n+   Free Software Foundation, Inc.\n+   Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>  */\n+\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/* This file declares the new abi entry points into the runtime. It is not\n+   normally necessary for user programs to include this header, or use the\n+   entry points directly. However, this header is available should that be\n+   needed.\n+   \n+   Some of the entry points are intended for both C and C++, thus this header\n+   is includable from both C and C++. Though the C++ specific parts are not\n+   available in C, naturally enough.  */\n+\n+#ifndef __CXXABI_H\n+#define __CXXABI_H 1\n+\n+#if defined(__cplusplus) && (!defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n+/* These structures only make sense when targeting the new abi, catch a\n+   bonehead error early rather than let the user get very confused.  */\n+#error \"Not targetting the new abi, supply -fnew-abi\"\n+#endif\n+\n+#ifdef __cplusplus\n+\n+// We use the compiler builtins __SIZE_TYPE__ and __PTRDIFF_TYPE__ instead of\n+// std::size_t and std::ptrdiff_t respectively. This makes us independant of\n+// the conformance level of <cstddef> and whether -fhonor-std was supplied.\n+// <cstddef> is not currently available during compiler building anyway.\n+// Including <stddef.h> would be wrong, as that would rudely place size_t in\n+// the global namespace.\n+\n+#include <typeinfo>\n+\n+namespace __cxxabiv1\n+{\n+\n+/* type information for int, float etc */\n+class __fundamental_type_info\n+  : public std::type_info\n+{\n+public:\n+  virtual ~__fundamental_type_info ();\n+public:\n+  explicit __fundamental_type_info (const char *__n)\n+    : std::type_info (__n)\n+    { }\n+};\n+\n+/* type information for array objects */\n+class __array_type_info\n+  : public std::type_info\n+{\n+/* abi defined member functions */\n+protected:\n+  virtual ~__array_type_info ();\n+public:\n+  explicit __array_type_info (const char *__n)\n+    : std::type_info (__n)\n+    { }\n+};\n+\n+/* type information for functions (both member and non-member) */\n+class __function_type_info\n+  : public std::type_info\n+{\n+/* abi defined member functions */\n+public:\n+  virtual ~__function_type_info ();\n+public:\n+  explicit __function_type_info (const char *__n)\n+    : std::type_info (__n)\n+    { }\n+  \n+/* implementation defined member functions */\n+protected:\n+  virtual bool __is_function_p () const;\n+};\n+\n+/* type information for enumerations */\n+class __enum_type_info\n+  : public std::type_info\n+{\n+/* abi defined member functions */\n+public:\n+  virtual ~__enum_type_info ();\n+public:\n+  explicit __enum_type_info (const char *__n)\n+    : std::type_info (__n)\n+    { }\n+};\n+\n+/* common type information for simple pointers and pointers to member */\n+class __pbase_type_info\n+  : public std::type_info\n+{\n+/* abi defined member variables */\n+public:\n+  unsigned int __qualifier_flags; /* qualification of the target object */\n+  const std::type_info *__pointee;   /* type of pointed to object */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__pbase_type_info ();\n+public:\n+  explicit __pbase_type_info (const char *__n,\n+                                int __quals,\n+                                const std::type_info *__type)\n+    : std::type_info (__n), __qualifier_flags (__quals), __pointee (__type)\n+    { }\n+\n+/* implementation defined types */\n+public:\n+  enum __qualifier_masks {\n+    __const_mask = 0x1,\n+    __volatile_mask = 0x2,\n+    __restrict_mask = 0x4,\n+    __incomplete_mask = 0x8,\n+    __incomplete_class_mask = 0x10\n+  };\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool __do_catch (const std::type_info *__thr_type,\n+                           void **__thr_obj,\n+                           unsigned __outer) const;\n+protected:\n+  inline virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n+                                       void **__thr_obj,\n+                                       unsigned __outer) const;\n+};\n+\n+/* type information for simple pointers */\n+class __pointer_type_info\n+  : public __pbase_type_info\n+{\n+/* abi defined member functions */\n+public:\n+  virtual ~__pointer_type_info ();\n+public:\n+  explicit __pointer_type_info (const char *__n,\n+                                int __quals,\n+                                const std::type_info *__type)\n+    : __pbase_type_info (__n, __quals, __type)\n+    { }\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool __is_pointer_p () const;\n+\n+protected:\n+  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n+                                void **__thr_obj,\n+                                unsigned __outer) const;\n+};\n+\n+/* type information for a pointer to member variable */\n+class __pointer_to_member_type_info\n+  : public __pbase_type_info\n+{\n+/* abi defined member variables */\n+public:\n+  __class_type_info *__context_class;   /* class of the member */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__pointer_to_member_type_info ();\n+public:\n+  explicit __pointer_to_member_type_info (const char *__n,\n+                                          int __quals,\n+                                          const std::type_info *__type,\n+                                          __class_type_info *__klass)\n+    : __pbase_type_info (__n, __quals, __type), __context_class (__klass)\n+    { }\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n+                                void **__thr_obj,\n+                                unsigned __outer) const;\n+};\n+\n+class __class_type_info;\n+\n+/* helper class for __vmi_class_type */\n+class __base_class_info\n+{\n+/* abi defined member variables */\n+public:\n+  const __class_type_info *__base;    /* base class type */\n+  long __offset_flags;            /* offset and info */\n+\n+/* implementation defined types */\n+public:\n+  enum __offset_flags_masks {\n+    __virtual_mask = 0x1,\n+    __public_mask = 0x2,\n+    hwm_bit = 2,\n+    offset_shift = 8          /* bits to shift offset by */\n+  };\n+  \n+/* implementation defined member functions */\n+public:\n+  bool __is_virtual_p () const\n+    { return __offset_flags & __virtual_mask; }\n+  bool __is_public_p () const\n+    { return __offset_flags & __public_mask; }\n+  __PTRDIFF_TYPE__ __offset () const\n+    { \n+      // This shift, being of a signed type, is implementation defined. GCC\n+      // implements such shifts as arithmetic, which is what we want.\n+      return static_cast<__PTRDIFF_TYPE__> (__offset_flags) >> offset_shift;\n+    }\n+};\n+\n+/* type information for a class */\n+class __class_type_info\n+  : public std::type_info\n+{\n+/* abi defined member functions */\n+public:\n+  virtual ~__class_type_info ();\n+public:\n+  explicit __class_type_info (const char *__n)\n+    : type_info (__n)\n+    { }\n+\n+/* implementation defined types */\n+public:\n+  /* sub_kind tells us about how a base object is contained within a derived\n+     object. We often do this lazily, hence the UNKNOWN value. At other times\n+     we may use NOT_CONTAINED to mean not publicly contained. */\n+  enum __sub_kind\n+  {\n+    __unknown = 0,              /* we have no idea */\n+    __not_contained,            /* not contained within us (in some */\n+                                /* circumstances this might mean not contained */\n+                                /* publicly) */\n+    __contained_ambig,          /* contained ambiguously */\n+    \n+    __contained_virtual_mask = __base_class_info::__virtual_mask, /* via a virtual path */\n+    __contained_public_mask = __base_class_info::__public_mask,   /* via a public path */\n+    __contained_mask = 1 << __base_class_info::hwm_bit,         /* contained within us */\n+    \n+    __contained_private = __contained_mask,\n+    __contained_public = __contained_mask | __contained_public_mask\n+  };\n+\n+public:  \n+  struct __upcast_result;\n+  struct __dyncast_result;\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool __do_upcast (const __class_type_info *__dst_type, void **__obj_ptr) const;\n+\n+protected:\n+  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n+                           unsigned __outer) const;\n+\n+\n+public:\n+  /* Helper for upcast. See if DST is us, or one of our bases. */\n+  /* Return false if not found, true if found. */\n+  virtual bool __do_upcast (const __class_type_info *__dst,\n+                            const void *__obj,\n+                            __upcast_result &__restrict __result) const;\n+\n+public:\n+  /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n+     OBJ_PTR. OBJ_PTR points to a base object of our type, which is the\n+     destination type. SRC2DST indicates how SRC objects might be contained\n+     within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n+     virtuality. Returns not_contained for non containment or private\n+     containment. */\n+  inline __sub_kind __find_public_src (__PTRDIFF_TYPE__ __src2dst,\n+                                       const void *__obj_ptr,\n+                                       const __class_type_info *__src_type,\n+                                       const void *__src_ptr) const;\n+\n+public:\n+  /* dynamic cast helper. ACCESS_PATH gives the access from the most derived\n+     object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR\n+     points to a base of our type within the complete object. SRC_TYPE\n+     indicates the static type started from and SRC_PTR points to that base\n+     within the most derived object. Fill in RESULT with what we find. Return\n+     true if we have located an ambiguous match. */\n+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n+                             __sub_kind __access_path,\n+                             const __class_type_info *__dst_type,\n+                             const void *__obj_ptr,\n+                             const __class_type_info *__src_type,\n+                             const void *__src_ptr,\n+                             __dyncast_result &__result) const;\n+public:\n+  /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n+     inherited by the type started from -- which is not necessarily the\n+     current type. The current type will be a base of the destination type.\n+     OBJ_PTR points to the current base. */\n+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n+                                           const void *__obj_ptr,\n+                                           const __class_type_info *__src_type,\n+                                           const void *__src_ptr) const;\n+};\n+\n+/* type information for a class with a single non-virtual base */\n+class __si_class_type_info\n+  : public __class_type_info\n+{\n+/* abi defined member variables */\n+public:\n+  const __class_type_info *__base_type;\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__si_class_type_info ();\n+public:\n+  explicit __si_class_type_info (const char *__n,\n+                                 const __class_type_info *__base)\n+    : __class_type_info (__n), __base_type (__base)\n+    { }\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n+                             __sub_kind __access_path,\n+                             const __class_type_info *__dst_type,\n+                             const void *__obj_ptr,\n+                             const __class_type_info *__src_type,\n+                             const void *__src_ptr,\n+                             __dyncast_result &__result) const;\n+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n+                                           const void *__obj_ptr,\n+                                           const __class_type_info *__src_type,\n+                                           const void *__sub_ptr) const;\n+  virtual bool __do_upcast (const __class_type_info *__dst,\n+                            const void *__obj,\n+                            __upcast_result &__restrict __result) const;\n+};\n+\n+/* type information for a class with multiple and/or virtual bases */\n+class __vmi_class_type_info : public __class_type_info {\n+/* abi defined member variables */\n+public:\n+  unsigned int __flags;         /* details about the class heirarchy */\n+  unsigned int __base_count;    /* number of direct bases */\n+  __base_class_info const __base_info[1]; /* array of bases */\n+  /* The array of bases uses the trailing array struct hack\n+     so this class is not constructable with a normal constructor. It is\n+     internally generated by the compiler. */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__vmi_class_type_info ();\n+public:\n+  explicit __vmi_class_type_info (const char *__n,\n+                                  int ___flags)\n+    : __class_type_info (__n), __flags (___flags), __base_count (0)\n+    { }\n+\n+/* implementation defined types */\n+public:\n+  enum __flags_masks {\n+    __non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */\n+    __diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */\n+    non_public_base_mask = 0x4,      /* has non-public direct or indirect base */\n+    public_base_mask = 0x8,          /* has public base (direct) */\n+    \n+    __flags_unknown_mask = 0x10\n+  };\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n+                             __sub_kind __access_path,\n+                             const __class_type_info *__dst_type,\n+                             const void *__obj_ptr,\n+                             const __class_type_info *__src_type,\n+                             const void *__src_ptr,\n+                             __dyncast_result &__result) const;\n+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n+                                           const void *__obj_ptr,\n+                                           const __class_type_info *__src_type,\n+                                           const void *__src_ptr) const;\n+  virtual bool __do_upcast (const __class_type_info *__dst,\n+                            const void *__obj,\n+                            __upcast_result &__restrict __result) const;\n+};\n+\n+/* dynamic cast runtime */\n+extern \"C\"\n+void *__dynamic_cast (const void *__src_ptr,    /* object started from */\n+                      const __class_type_info *__src_type, /* static type of object */\n+                      const __class_type_info *__dst_type, /* desired target type */\n+                      __PTRDIFF_TYPE__ __src2dst); /* how src and dst are related */\n+\n+    /* src2dst has the following possible values\n+       >= 0: src_type is a unique public non-virtual base of dst_type\n+             dst_ptr + src2dst == src_ptr\n+       -1: unspecified relationship\n+       -2: src_type is not a public base of dst_type\n+       -3: src_type is a multiple public non-virtual base of dst_type */\n+\n+/* array ctor/dtor routines */\n+\n+/* allocate and construct array */\n+extern \"C\"\n+void *__cxa_vec_new (__SIZE_TYPE__ __element_count,\n+                     __SIZE_TYPE__ __element_size,\n+                     __SIZE_TYPE__ __padding_size,\n+                     void (*__constructor) (void *),\n+                     void (*__destructor) (void *));\n+\n+extern \"C\"\n+void *__cxa_vec_new2 (__SIZE_TYPE__ __element_count,\n+                      __SIZE_TYPE__ __element_size,\n+                      __SIZE_TYPE__ __padding_size,\n+                      void (*__constructor) (void *),\n+                      void (*__destructor) (void *),\n+                      void *(*__alloc) (__SIZE_TYPE__),\n+                      void (*__dealloc) (void *));\n+\n+extern \"C\"\n+void *__cxa_vec_new3 (__SIZE_TYPE__ __element_count,\n+                      __SIZE_TYPE__ __element_size,\n+                      __SIZE_TYPE__ __padding_size,\n+                      void (*__constructor) (void *),\n+                      void (*__destructor) (void *),\n+                      void *(*__alloc) (__SIZE_TYPE__),\n+                      void (*__dealloc) (void *, __SIZE_TYPE__));\n+\n+/* construct array */\n+extern \"C\"\n+void __cxa_vec_ctor (void *__array_address,\n+                     __SIZE_TYPE__ __element_count,\n+                     __SIZE_TYPE__ __element_size,\n+                     void (*__constructor) (void *),\n+                     void (*__destructor) (void *));\n+\n+extern \"C\"\n+void __cxa_vec_cctor (void *dest_array,\n+\t\t      void *src_array,\n+\t\t      __SIZE_TYPE__ element_count,\n+\t\t      __SIZE_TYPE__ element_size,\n+\t\t      void (*constructor) (void *, void *),\n+\t\t      void (*destructor) (void *));\n+ \n+/* destruct array */\n+extern \"C\"\n+void __cxa_vec_dtor (void *__array_address,\n+                     __SIZE_TYPE__ __element_count,\n+                     __SIZE_TYPE__ __element_size,\n+                     void (*__destructor) (void *));\n+\n+/* destruct and release array */\n+extern \"C\"\n+void __cxa_vec_delete (void *__array_address,\n+                       __SIZE_TYPE__ __element_size,\n+                       __SIZE_TYPE__ __padding_size,\n+                       void (*__destructor) (void *));\n+\n+extern \"C\"\n+void __cxa_vec_delete2 (void *__array_address,\n+                        __SIZE_TYPE__ __element_size,\n+                        __SIZE_TYPE__ __padding_size,\n+                        void (*__destructor) (void *),\n+                        void (*__dealloc) (void *));\n+                  \n+extern \"C\"\n+void __cxa_vec_delete3 (void *__array_address,\n+                        __SIZE_TYPE__ __element_size,\n+                        __SIZE_TYPE__ __padding_size,\n+                        void (*__destructor) (void *),\n+                        void (*__dealloc) (void *, __SIZE_TYPE__));\n+                  \n+/* demangling routines */\n+\n+extern \"C\" \n+char *__cxa_demangle (const char *__mangled_name,\n+\t\t      char *__output_buffer,\n+\t\t      __SIZE_TYPE__ *__length,\n+\t\t      int *__status);\n+\n+} /* namespace __cxxabiv1 */\n+\n+/* User programs should use the alias `abi'. */\n+namespace abi = __cxxabiv1;\n+\n+#else\n+#endif /* __cplusplus */\n+\n+\n+#endif /* __CXXABI_H */"}, {"sha": "4d35c56c4054ecadc6615534e174c4479aaeba30", "filename": "libstdc++-v3/libsupc++/include/exception", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fexception?ref=cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "patch": "@@ -0,0 +1,65 @@\n+// Exception Handling support header for -*- C++ -*-\n+// Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef __EXCEPTION__\n+#define __EXCEPTION__\n+\n+#pragma interface \"exception\"\n+\n+extern \"C++\" {\n+\n+namespace std {\n+\n+class exception {\n+public:\n+  exception () { }\n+  virtual ~exception () { }\n+  virtual const char* what () const;\n+};\n+\n+class bad_exception : public exception {\n+public:\n+  bad_exception () { }\n+  virtual ~bad_exception () { }\n+};\n+\n+typedef void (*terminate_handler) ();\n+typedef void (*unexpected_handler) ();\n+\n+terminate_handler set_terminate (terminate_handler);\n+void terminate () __attribute__ ((__noreturn__));\n+unexpected_handler set_unexpected (unexpected_handler);\n+void unexpected () __attribute__ ((__noreturn__));\n+bool uncaught_exception ();\n+\n+} // namespace std\n+\n+} // extern \"C++\"\n+\n+#endif"}, {"sha": "cbb8d107acff183f8d109e5d341ff9fd00cab464", "filename": "libstdc++-v3/libsupc++/include/new", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew?ref=cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "patch": "@@ -0,0 +1,68 @@\n+// The -*- C++ -*- dynamic memory management header.\n+// Copyright (C) 1994, 1996, 1997, 1998, 2000 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef __NEW__\n+#define __NEW__\n+\n+#pragma interface \"new\"\n+#include <stddef.h>\n+#include <exception>\n+\n+extern \"C++\" {\n+\n+namespace std {\n+\n+  class bad_alloc : public exception {\n+  public:\n+    virtual const char* what() const throw() { return \"bad_alloc\"; }\n+  };\n+\n+  struct nothrow_t {};\n+  extern const nothrow_t nothrow;\n+  typedef void (*new_handler)();\n+  new_handler set_new_handler (new_handler);\n+\n+} // namespace std\n+\n+// replaceable signatures\n+void *operator new (size_t) throw (std::bad_alloc);\n+void *operator new[] (size_t) throw (std::bad_alloc);\n+void operator delete (void *) throw();\n+void operator delete[] (void *) throw();\n+void *operator new (size_t, const std::nothrow_t&) throw();\n+void *operator new[] (size_t, const std::nothrow_t&) throw();\n+void operator delete (void *, const std::nothrow_t&) throw();\n+void operator delete[] (void *, const std::nothrow_t&) throw();\n+\n+// default placement versions of operator new\n+inline void *operator new(size_t, void *place) throw() { return place; }\n+inline void *operator new[](size_t, void *place) throw() { return place; }\n+} // extern \"C++\"\n+\n+#endif"}, {"sha": "cb1fa4cb5caa3becee3728a9a79acb64649d8205", "filename": "libstdc++-v3/libsupc++/include/new.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Fnew.h?ref=cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "patch": "@@ -0,0 +1,38 @@\n+// -*- C++ -*- forwarding header.\n+// Copyright (C) 2000 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef __NEW_H__\n+#define __NEW_H__\n+\n+#include <new>\n+\n+using std::new_handler;\n+using std::set_new_handler;\n+\n+#endif // __NEW_H__"}, {"sha": "91f0de2c720c8b7885685bdb2ffc9f34e7c1a55b", "filename": "libstdc++-v3/libsupc++/include/typeinfo", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finclude%2Ftypeinfo?ref=cc9711a36a24cd5efbd64bbd4ac6858fb3262fc6", "patch": "@@ -0,0 +1,134 @@\n+// RTTI support for -*- C++ -*-\n+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// __GXX_ABI_VERSION distinguishes the ABI that is being used. Values <100\n+// indicate the `old' abi, which grew as C++ was defined. Values >=100\n+// indicate the `new' abi, which is a cross vendor C++ abi, documented at\n+// `http://reality.sgi.com/dehnert_engr/cxx/'.\n+\n+#ifndef __TYPEINFO__\n+#define __TYPEINFO__\n+\n+#pragma interface \"typeinfo\"\n+\n+#include <exception>\n+\n+extern \"C++\" {\n+\n+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+namespace __cxxabiv1\n+{\n+  class __class_type_info;\n+} // namespace __cxxabiv1\n+#endif\n+\n+namespace std {\n+\n+class type_info {\n+public:\n+  // Destructor. Being the first non-inline virtual function, this controls in\n+  // which translation unit the vtable is emitted. The compiler makes use of\n+  // that information to know where to emit the runtime-mandated type_info\n+  // structures in the new-abi.\n+  virtual ~type_info ();\n+\n+private:\n+  // Assigning type_info is not supported.  made private.\n+  type_info& operator= (const type_info&);\n+  type_info (const type_info&);\n+\n+protected:\n+  const char *__name;\n+\n+protected:\n+  explicit type_info (const char *__n): __name (__n) { }\n+\n+public:\n+  // the public interface\n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+  // In old abi, there can be multiple instances of a type_info object for one\n+  // type. Uniqueness must use the _name value, not object address.\n+  bool before (const type_info& arg) const;\n+  const char* name () const\n+    { return __name; }\n+  bool operator== (const type_info& __arg) const;\n+  bool operator!= (const type_info& __arg) const\n+    { return !operator== (__arg); }\n+\n+#else\n+  // In new abi we can rely on type_info's NTBS being unique,\n+  // and therefore address comparisons are sufficient.\n+  bool before (const type_info& __arg) const\n+    { return __name < __arg.__name; }\n+  const char* name () const\n+    { return __name; }\n+  bool operator== (const type_info& __arg) const\n+    { return __name == __arg.__name; }\n+  bool operator!= (const type_info& __arg) const\n+    { return !operator== (__arg); }\n+#endif\n+\n+  // the internal interface\n+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+public:\n+  // return true if this is a pointer type of some kind\n+  virtual bool __is_pointer_p () const;\n+  // return true if this is a function type\n+  virtual bool __is_function_p () const;\n+\n+  // Try and catch a thrown type. Store an adjusted pointer to the caught type\n+  // in THR_OBJ. If THR_TYPE is not a pointer type, then THR_OBJ points to the\n+  // thrown object. If THR_TYPE is a pointer type, then THR_OBJ is the pointer\n+  // itself. OUTER indicates the number of outer pointers, and whether they\n+  // were const qualified.\n+  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n+                         unsigned __outer) const;\n+\n+  // internally used during catch matching\n+  virtual bool __do_upcast (const __cxxabiv1::__class_type_info *__target,\n+\t\t\t    void **__obj_ptr) const;\n+#endif\n+};\n+\n+class bad_cast : public exception {\n+public:\n+  bad_cast() { }\n+  virtual ~bad_cast() { }\n+};\n+\n+class bad_typeid : public exception {\n+ public:\n+  bad_typeid () { }\n+  virtual ~bad_typeid () { }\n+};\n+\n+} // namespace std\n+\n+} // extern \"C++\"\n+#endif"}]}