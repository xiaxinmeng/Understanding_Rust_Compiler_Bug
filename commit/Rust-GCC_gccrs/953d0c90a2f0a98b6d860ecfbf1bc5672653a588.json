{"sha": "953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUzZDBjOTBhMmYwYTk4YjZkODYwZWNmYmYxYmM1NjcyNjUzYTU4OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-07-13T11:16:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-07-13T11:16:36Z"}, "message": "tree.h (categorize_ctor_elements): Remove comment.\n\ngcc/\n\t* tree.h (categorize_ctor_elements): Remove comment.  Fix long line.\n\t(count_type_elements): Delete.\n\t(complete_ctor_at_level_p): Declare.\n\t* expr.c (flexible_array_member_p): New function, split out from...\n\t(count_type_elements): ...here.  Make static.  Replace allow_flexarr\n\tparameter with for_ctor_p.  When for_ctor_p is true, return the\n\tnumber of elements that should appear in the top-level constructor,\n\totherwise return an estimate of the number of scalars.\n\t(categorize_ctor_elements): Replace p_must_clear with p_complete.\n\t(categorize_ctor_elements_1): Likewise.  Use complete_ctor_at_level_p.\n\t(complete_ctor_at_level_p): New function, borrowing union logic\n\tfrom old categorize_ctor_elements_1.\n\t(mostly_zeros_p): Return true if the constructor is not complete.\n\t(all_zeros_p): Update call to categorize_ctor_elements.\n\t* gimplify.c (gimplify_init_constructor): Update call to\n\tcategorize_ctor_elements.  Don't call count_type_elements.\n\tUnconditionally prevent clearing for variable-sized types,\n\totherwise rely on categorize_ctor_elements to detect\n\tincomplete initializers.\n\ngcc/cp/\n\t* typeck2.c (split_nonconstant_init_1): Pass the initializer directly,\n\trather than a pointer to it.  Return true if the whole of the value\n\twas initialized by the generated statements.  Use\n\tcomplete_ctor_at_level_p instead of count_type_elements.\n\ngcc/testsuite/\n2011-07-12  Chung-Lin Tang  <cltang@codesourcery.com>\n\n\t* gcc.target/arm/pr48183.c: New test.\n\nFrom-SVN: r176228", "tree": {"sha": "b416f9a74ed2aeda3b26a2a7af943a1535790bb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b416f9a74ed2aeda3b26a2a7af943a1535790bb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/comments", "author": null, "committer": null, "parents": [{"sha": "9111c715537d8ea0829d6ab7511017ed8658f303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9111c715537d8ea0829d6ab7511017ed8658f303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9111c715537d8ea0829d6ab7511017ed8658f303"}], "stats": {"total": 491, "additions": 278, "deletions": 213}, "files": [{"sha": "db549522ee70f8fa4274514508d66526ba2a3275", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -1,3 +1,25 @@\n+2011-07-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree.h (categorize_ctor_elements): Remove comment.  Fix long line.\n+\t(count_type_elements): Delete.\n+\t(complete_ctor_at_level_p): Declare.\n+\t* expr.c (flexible_array_member_p): New function, split out from...\n+\t(count_type_elements): ...here.  Make static.  Replace allow_flexarr\n+\tparameter with for_ctor_p.  When for_ctor_p is true, return the\n+\tnumber of elements that should appear in the top-level constructor,\n+\totherwise return an estimate of the number of scalars.\n+\t(categorize_ctor_elements): Replace p_must_clear with p_complete.\n+\t(categorize_ctor_elements_1): Likewise.  Use complete_ctor_at_level_p.\n+\t(complete_ctor_at_level_p): New function, borrowing union logic\n+\tfrom old categorize_ctor_elements_1.\n+\t(mostly_zeros_p): Return true if the constructor is not complete.\n+\t(all_zeros_p): Update call to categorize_ctor_elements.\n+\t* gimplify.c (gimplify_init_constructor): Update call to\n+\tcategorize_ctor_elements.  Don't call count_type_elements.\n+\tUnconditionally prevent clearing for variable-sized types,\n+\totherwise rely on categorize_ctor_elements to detect\n+\tincomplete initializers.\n+\n 2011-07-13  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vrp.c (simplify_conversion_using_ranges): Make sure"}, {"sha": "cfe3bab6f8cc199453cab8eae476afd4d3a3bbed", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -1,3 +1,10 @@\n+2011-07-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* typeck2.c (split_nonconstant_init_1): Pass the initializer directly,\n+\trather than a pointer to it.  Return true if the whole of the value\n+\twas initialized by the generated statements.  Use\n+\tcomplete_ctor_at_level_p instead of count_type_elements.\n+\n 2011-07-12   Diego Novillo  <dnovillo@google.com>\n \n \t* name-lookup.h (cp_binding_level): Rename from cxx_scope."}, {"sha": "ac4f383ce80585b7808b68cadc7ad461e67b7279", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -481,18 +481,20 @@ cxx_incomplete_type_error (const_tree value, const_tree type)\n \n \f\n /* The recursive part of split_nonconstant_init.  DEST is an lvalue\n-   expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.  */\n+   expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.\n+   Return true if the whole of the value was initialized by the\n+   generated statements.  */\n \n-static void\n-split_nonconstant_init_1 (tree dest, tree *initp)\n+static bool\n+split_nonconstant_init_1 (tree dest, tree init)\n {\n   unsigned HOST_WIDE_INT idx;\n-  tree init = *initp;\n   tree field_index, value;\n   tree type = TREE_TYPE (dest);\n   tree inner_type = NULL;\n   bool array_type_p = false;\n-  HOST_WIDE_INT num_type_elements, num_initialized_elements;\n+  bool complete_p = true;\n+  HOST_WIDE_INT num_split_elts = 0;\n \n   switch (TREE_CODE (type))\n     {\n@@ -504,7 +506,6 @@ split_nonconstant_init_1 (tree dest, tree *initp)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      num_initialized_elements = 0;\n       FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx,\n \t\t\t\tfield_index, value)\n \t{\n@@ -527,13 +528,14 @@ split_nonconstant_init_1 (tree dest, tree *initp)\n \t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE);\n \n-\t      split_nonconstant_init_1 (sub, &value);\n+\t      if (!split_nonconstant_init_1 (sub, value))\n+\t\tcomplete_p = false;\n+\t      num_split_elts++;\n \t    }\n \t  else if (!initializer_constant_valid_p (value, inner_type))\n \t    {\n \t      tree code;\n \t      tree sub;\n-\t      HOST_WIDE_INT inner_elements;\n \n \t      /* FIXME: Ordered removal is O(1) so the whole function is\n \t\t worst-case quadratic. This could be fixed using an aside\n@@ -557,21 +559,9 @@ split_nonconstant_init_1 (tree dest, tree *initp)\n \t      code = build_stmt (input_location, EXPR_STMT, code);\n \t      add_stmt (code);\n \n-\t      inner_elements = count_type_elements (inner_type, true);\n-\t      if (inner_elements < 0)\n-\t\tnum_initialized_elements = -1;\n-\t      else if (num_initialized_elements >= 0)\n-\t\tnum_initialized_elements += inner_elements;\n-\t      continue;\n+\t      num_split_elts++;\n \t    }\n \t}\n-\n-      num_type_elements = count_type_elements (type, true);\n-      /* If all elements of the initializer are non-constant and\n-\t have been split out, we don't need the empty CONSTRUCTOR.  */\n-      if (num_type_elements > 0\n-\t  && num_type_elements == num_initialized_elements)\n-\t*initp = NULL;\n       break;\n \n     case VECTOR_TYPE:\n@@ -583,6 +573,7 @@ split_nonconstant_init_1 (tree dest, tree *initp)\n \t  code = build2 (MODIFY_EXPR, type, dest, cons);\n \t  code = build_stmt (input_location, EXPR_STMT, code);\n \t  add_stmt (code);\n+\t  num_split_elts += CONSTRUCTOR_NELTS (init);\n \t}\n       break;\n \n@@ -592,6 +583,8 @@ split_nonconstant_init_1 (tree dest, tree *initp)\n \n   /* The rest of the initializer is now a constant. */\n   TREE_CONSTANT (init) = 1;\n+  return complete_p && complete_ctor_at_level_p (TREE_TYPE (init),\n+\t\t\t\t\t\t num_split_elts, inner_type);\n }\n \n /* A subroutine of store_init_value.  Splits non-constant static\n@@ -607,7 +600,8 @@ split_nonconstant_init (tree dest, tree init)\n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n       code = push_stmt_list ();\n-      split_nonconstant_init_1 (dest, &init);\n+      if (split_nonconstant_init_1 (dest, init))\n+\tinit = NULL_TREE;\n       code = pop_stmt_list (code);\n       DECL_INITIAL (dest) = init;\n       TREE_READONLY (dest) = 0;"}, {"sha": "ed921aa31879861443015fe3ee0bbb7c06d0bde6", "filename": "gcc/expr.c", "status": "modified", "additions": 178, "deletions": 156, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -4846,16 +4846,136 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n   return NULL_RTX;\n }\n \f\n+/* Return true if field F of structure TYPE is a flexible array.  */\n+\n+static bool\n+flexible_array_member_p (const_tree f, const_tree type)\n+{\n+  const_tree tf;\n+\n+  tf = TREE_TYPE (f);\n+  return (DECL_CHAIN (f) == NULL\n+\t  && TREE_CODE (tf) == ARRAY_TYPE\n+\t  && TYPE_DOMAIN (tf)\n+\t  && TYPE_MIN_VALUE (TYPE_DOMAIN (tf))\n+\t  && integer_zerop (TYPE_MIN_VALUE (TYPE_DOMAIN (tf)))\n+\t  && !TYPE_MAX_VALUE (TYPE_DOMAIN (tf))\n+\t  && int_size_in_bytes (type) >= 0);\n+}\n+\n+/* If FOR_CTOR_P, return the number of top-level elements that a constructor\n+   must have in order for it to completely initialize a value of type TYPE.\n+   Return -1 if the number isn't known.\n+\n+   If !FOR_CTOR_P, return an estimate of the number of scalars in TYPE.  */\n+\n+static HOST_WIDE_INT\n+count_type_elements (const_tree type, bool for_ctor_p)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case ARRAY_TYPE:\n+      {\n+\ttree nelts;\n+\n+\tnelts = array_type_nelts (type);\n+\tif (nelts && host_integerp (nelts, 1))\n+\t  {\n+\t    unsigned HOST_WIDE_INT n;\n+\n+\t    n = tree_low_cst (nelts, 1) + 1;\n+\t    if (n == 0 || for_ctor_p)\n+\t      return n;\n+\t    else\n+\t      return n * count_type_elements (TREE_TYPE (type), false);\n+\t  }\n+\treturn for_ctor_p ? -1 : 1;\n+      }\n+\n+    case RECORD_TYPE:\n+      {\n+\tunsigned HOST_WIDE_INT n;\n+\ttree f;\n+\n+\tn = 0;\n+\tfor (f = TYPE_FIELDS (type); f ; f = DECL_CHAIN (f))\n+\t  if (TREE_CODE (f) == FIELD_DECL)\n+\t    {\n+\t      if (!for_ctor_p)\n+\t\tn += count_type_elements (TREE_TYPE (f), false);\n+\t      else if (!flexible_array_member_p (f, type))\n+\t\t/* Don't count flexible arrays, which are not supposed\n+\t\t   to be initialized.  */\n+\t\tn += 1;\n+\t    }\n+\n+\treturn n;\n+      }\n+\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree f;\n+\tHOST_WIDE_INT n, m;\n+\n+\tgcc_assert (!for_ctor_p);\n+\t/* Estimate the number of scalars in each field and pick the\n+\t   maximum.  Other estimates would do instead; the idea is simply\n+\t   to make sure that the estimate is not sensitive to the ordering\n+\t   of the fields.  */\n+\tn = 1;\n+\tfor (f = TYPE_FIELDS (type); f ; f = DECL_CHAIN (f))\n+\t  if (TREE_CODE (f) == FIELD_DECL)\n+\t    {\n+\t      m = count_type_elements (TREE_TYPE (f), false);\n+\t      /* If the field doesn't span the whole union, add an extra\n+\t\t scalar for the rest.  */\n+\t      if (simple_cst_equal (TYPE_SIZE (TREE_TYPE (f)),\n+\t\t\t\t    TYPE_SIZE (type)) != 1)\n+\t\tm++;\n+\t      if (n < m)\n+\t\tn = m;\n+\t    }\n+\treturn n;\n+      }\n+\n+    case COMPLEX_TYPE:\n+      return 2;\n+\n+    case VECTOR_TYPE:\n+      return TYPE_VECTOR_SUBPARTS (type);\n+\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case POINTER_TYPE:\n+    case OFFSET_TYPE:\n+    case REFERENCE_TYPE:\n+      return 1;\n+\n+    case ERROR_MARK:\n+      return 0;\n+\n+    case VOID_TYPE:\n+    case METHOD_TYPE:\n+    case FUNCTION_TYPE:\n+    case LANG_TYPE:\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Helper for categorize_ctor_elements.  Identical interface.  */\n \n static bool\n categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n-\t\t\t    HOST_WIDE_INT *p_elt_count,\n-\t\t\t    bool *p_must_clear)\n+\t\t\t    HOST_WIDE_INT *p_init_elts, bool *p_complete)\n {\n   unsigned HOST_WIDE_INT idx;\n-  HOST_WIDE_INT nz_elts, elt_count;\n-  tree value, purpose;\n+  HOST_WIDE_INT nz_elts, init_elts, num_fields;\n+  tree value, purpose, elt_type;\n \n   /* Whether CTOR is a valid constant initializer, in accordance with what\n      initializer_constant_valid_p does.  If inferred from the constructor\n@@ -4864,7 +4984,9 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n   bool const_p = const_from_elts_p ? true : TREE_STATIC (ctor);\n \n   nz_elts = 0;\n-  elt_count = 0;\n+  init_elts = 0;\n+  num_fields = 0;\n+  elt_type = NULL_TREE;\n \n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), idx, purpose, value)\n     {\n@@ -4879,18 +5001,20 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t    mult = (tree_low_cst (hi_index, 1)\n \t\t    - tree_low_cst (lo_index, 1) + 1);\n \t}\n+      num_fields += mult;\n+      elt_type = TREE_TYPE (value);\n \n       switch (TREE_CODE (value))\n \t{\n \tcase CONSTRUCTOR:\n \t  {\n \t    HOST_WIDE_INT nz = 0, ic = 0;\n \n-\t    bool const_elt_p\n-\t      = categorize_ctor_elements_1 (value, &nz, &ic, p_must_clear);\n+\t    bool const_elt_p = categorize_ctor_elements_1 (value, &nz, &ic,\n+\t\t\t\t\t\t\t   p_complete);\n \n \t    nz_elts += mult * nz;\n- \t    elt_count += mult * ic;\n+ \t    init_elts += mult * ic;\n \n \t    if (const_from_elts_p && const_p)\n \t      const_p = const_elt_p;\n@@ -4902,20 +5026,20 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \tcase FIXED_CST:\n \t  if (!initializer_zerop (value))\n \t    nz_elts += mult;\n-\t  elt_count += mult;\n+\t  init_elts += mult;\n \t  break;\n \n \tcase STRING_CST:\n \t  nz_elts += mult * TREE_STRING_LENGTH (value);\n-\t  elt_count += mult * TREE_STRING_LENGTH (value);\n+\t  init_elts += mult * TREE_STRING_LENGTH (value);\n \t  break;\n \n \tcase COMPLEX_CST:\n \t  if (!initializer_zerop (TREE_REALPART (value)))\n \t    nz_elts += mult;\n \t  if (!initializer_zerop (TREE_IMAGPART (value)))\n \t    nz_elts += mult;\n-\t  elt_count += mult;\n+\t  init_elts += mult;\n \t  break;\n \n \tcase VECTOR_CST:\n@@ -4925,65 +5049,31 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t      {\n \t\tif (!initializer_zerop (TREE_VALUE (v)))\n \t\t  nz_elts += mult;\n-\t\telt_count += mult;\n+\t\tinit_elts += mult;\n \t      }\n \t  }\n \t  break;\n \n \tdefault:\n \t  {\n-\t    HOST_WIDE_INT tc = count_type_elements (TREE_TYPE (value), true);\n-\t    if (tc < 1)\n-\t      tc = 1;\n+\t    HOST_WIDE_INT tc = count_type_elements (elt_type, false);\n \t    nz_elts += mult * tc;\n-\t    elt_count += mult * tc;\n+\t    init_elts += mult * tc;\n \n \t    if (const_from_elts_p && const_p)\n-\t      const_p = initializer_constant_valid_p (value, TREE_TYPE (value))\n+\t      const_p = initializer_constant_valid_p (value, elt_type)\n \t\t\t!= NULL_TREE;\n \t  }\n \t  break;\n \t}\n     }\n \n-  if (!*p_must_clear\n-      && (TREE_CODE (TREE_TYPE (ctor)) == UNION_TYPE\n-\t  || TREE_CODE (TREE_TYPE (ctor)) == QUAL_UNION_TYPE))\n-    {\n-      tree init_sub_type;\n-      bool clear_this = true;\n-\n-      if (!VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (ctor)))\n-\t{\n-\t  /* We don't expect more than one element of the union to be\n-\t     initialized.  Not sure what we should do otherwise... */\n-          gcc_assert (VEC_length (constructor_elt, CONSTRUCTOR_ELTS (ctor))\n-\t\t      == 1);\n-\n-          init_sub_type = TREE_TYPE (VEC_index (constructor_elt,\n-\t\t\t\t\t\tCONSTRUCTOR_ELTS (ctor),\n-\t\t\t\t\t\t0)->value);\n-\n-\t  /* ??? We could look at each element of the union, and find the\n-\t     largest element.  Which would avoid comparing the size of the\n-\t     initialized element against any tail padding in the union.\n-\t     Doesn't seem worth the effort...  */\n-\t  if (simple_cst_equal (TYPE_SIZE (TREE_TYPE (ctor)),\n-\t\t\t\tTYPE_SIZE (init_sub_type)) == 1)\n-\t    {\n-\t      /* And now we have to find out if the element itself is fully\n-\t\t constructed.  E.g. for union { struct { int a, b; } s; } u\n-\t\t = { .s = { .a = 1 } }.  */\n-\t      if (elt_count == count_type_elements (init_sub_type, false))\n-\t\tclear_this = false;\n-\t    }\n-\t}\n-\n-      *p_must_clear = clear_this;\n-    }\n+  if (*p_complete && !complete_ctor_at_level_p (TREE_TYPE (ctor),\n+\t\t\t\t\t\tnum_fields, elt_type))\n+    *p_complete = false;\n \n   *p_nz_elts += nz_elts;\n-  *p_elt_count += elt_count;\n+  *p_init_elts += init_elts;\n \n   return const_p;\n }\n@@ -4993,111 +5083,50 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n      and place it in *P_NZ_ELTS;\n    * how many scalar fields in total are in CTOR,\n      and place it in *P_ELT_COUNT.\n-   * if a type is a union, and the initializer from the constructor\n-     is not the largest element in the union, then set *p_must_clear.\n+   * whether the constructor is complete -- in the sense that every\n+     meaningful byte is explicitly given a value --\n+     and place it in *P_COMPLETE.\n \n    Return whether or not CTOR is a valid static constant initializer, the same\n    as \"initializer_constant_valid_p (CTOR, TREE_TYPE (CTOR)) != 0\".  */\n \n bool\n categorize_ctor_elements (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n-\t\t\t  HOST_WIDE_INT *p_elt_count,\n-\t\t\t  bool *p_must_clear)\n+\t\t\t  HOST_WIDE_INT *p_init_elts, bool *p_complete)\n {\n   *p_nz_elts = 0;\n-  *p_elt_count = 0;\n-  *p_must_clear = false;\n+  *p_init_elts = 0;\n+  *p_complete = true;\n \n-  return\n-    categorize_ctor_elements_1 (ctor, p_nz_elts, p_elt_count, p_must_clear);\n+  return categorize_ctor_elements_1 (ctor, p_nz_elts, p_init_elts, p_complete);\n }\n \n-/* Count the number of scalars in TYPE.  Return -1 on overflow or\n-   variable-sized.  If ALLOW_FLEXARR is true, don't count flexible\n-   array member at the end of the structure.  */\n+/* TYPE is initialized by a constructor with NUM_ELTS elements, the last\n+   of which had type LAST_TYPE.  Each element was itself a complete\n+   initializer, in the sense that every meaningful byte was explicitly\n+   given a value.  Return true if the same is true for the constructor\n+   as a whole.  */\n \n-HOST_WIDE_INT\n-count_type_elements (const_tree type, bool allow_flexarr)\n+bool\n+complete_ctor_at_level_p (const_tree type, HOST_WIDE_INT num_elts,\n+\t\t\t  const_tree last_type)\n {\n-  const HOST_WIDE_INT max = ~((HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT-1));\n-  switch (TREE_CODE (type))\n+  if (TREE_CODE (type) == UNION_TYPE\n+      || TREE_CODE (type) == QUAL_UNION_TYPE)\n     {\n-    case ARRAY_TYPE:\n-      {\n-\ttree telts = array_type_nelts (type);\n-\tif (telts && host_integerp (telts, 1))\n-\t  {\n-\t    HOST_WIDE_INT n = tree_low_cst (telts, 1) + 1;\n-\t    HOST_WIDE_INT m = count_type_elements (TREE_TYPE (type), false);\n-\t    if (n == 0)\n-\t      return 0;\n-\t    else if (max / n > m)\n-\t      return n * m;\n-\t  }\n-\treturn -1;\n-      }\n-\n-    case RECORD_TYPE:\n-      {\n-\tHOST_WIDE_INT n = 0, t;\n-\ttree f;\n-\n-\tfor (f = TYPE_FIELDS (type); f ; f = DECL_CHAIN (f))\n-\t  if (TREE_CODE (f) == FIELD_DECL)\n-\t    {\n-\t      t = count_type_elements (TREE_TYPE (f), false);\n-\t      if (t < 0)\n-\t\t{\n-\t\t  /* Check for structures with flexible array member.  */\n-\t\t  tree tf = TREE_TYPE (f);\n-\t\t  if (allow_flexarr\n-\t\t      && DECL_CHAIN (f) == NULL\n-\t\t      && TREE_CODE (tf) == ARRAY_TYPE\n-\t\t      && TYPE_DOMAIN (tf)\n-\t\t      && TYPE_MIN_VALUE (TYPE_DOMAIN (tf))\n-\t\t      && integer_zerop (TYPE_MIN_VALUE (TYPE_DOMAIN (tf)))\n-\t\t      && !TYPE_MAX_VALUE (TYPE_DOMAIN (tf))\n-\t\t      && int_size_in_bytes (type) >= 0)\n-\t\t    break;\n-\n-\t\t  return -1;\n-\t\t}\n-\t      n += t;\n-\t    }\n-\n-\treturn n;\n-      }\n-\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      return -1;\n-\n-    case COMPLEX_TYPE:\n-      return 2;\n-\n-    case VECTOR_TYPE:\n-      return TYPE_VECTOR_SUBPARTS (type);\n-\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case FIXED_POINT_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-    case POINTER_TYPE:\n-    case OFFSET_TYPE:\n-    case REFERENCE_TYPE:\n-      return 1;\n+      if (num_elts == 0)\n+\treturn false;\n \n-    case ERROR_MARK:\n-      return 0;\n+      gcc_assert (num_elts == 1 && last_type);\n \n-    case VOID_TYPE:\n-    case METHOD_TYPE:\n-    case FUNCTION_TYPE:\n-    case LANG_TYPE:\n-    default:\n-      gcc_unreachable ();\n+      /* ??? We could look at each element of the union, and find the\n+\t largest element.  Which would avoid comparing the size of the\n+\t initialized element against any tail padding in the union.\n+\t Doesn't seem worth the effort...  */\n+      return simple_cst_equal (TYPE_SIZE (type), TYPE_SIZE (last_type)) == 1;\n     }\n+\n+  return count_type_elements (type, true) == num_elts;\n }\n \n /* Return 1 if EXP contains mostly (3/4)  zeros.  */\n@@ -5106,18 +5135,12 @@ static int\n mostly_zeros_p (const_tree exp)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n-\n     {\n-      HOST_WIDE_INT nz_elts, count, elts;\n-      bool must_clear;\n-\n-      categorize_ctor_elements (exp, &nz_elts, &count, &must_clear);\n-      if (must_clear)\n-\treturn 1;\n+      HOST_WIDE_INT nz_elts, init_elts;\n+      bool complete_p;\n \n-      elts = count_type_elements (TREE_TYPE (exp), false);\n-\n-      return nz_elts < elts / 4;\n+      categorize_ctor_elements (exp, &nz_elts, &init_elts, &complete_p);\n+      return !complete_p || nz_elts < init_elts / 4;\n     }\n \n   return initializer_zerop (exp);\n@@ -5129,13 +5152,12 @@ static int\n all_zeros_p (const_tree exp)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n-\n     {\n-      HOST_WIDE_INT nz_elts, count;\n-      bool must_clear;\n+      HOST_WIDE_INT nz_elts, init_elts;\n+      bool complete_p;\n \n-      categorize_ctor_elements (exp, &nz_elts, &count, &must_clear);\n-      return nz_elts == 0;\n+      categorize_ctor_elements (exp, &nz_elts, &init_elts, &complete_p);\n+      return nz_elts == init_elts;\n     }\n \n   return initializer_zerop (exp);"}, {"sha": "1d0b9071e4a1dd6c1023754364214ffe8f23d534", "filename": "gcc/gimplify.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -3731,9 +3731,8 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     case ARRAY_TYPE:\n       {\n \tstruct gimplify_init_ctor_preeval_data preeval_data;\n-\tHOST_WIDE_INT num_type_elements, num_ctor_elements;\n-\tHOST_WIDE_INT num_nonzero_elements;\n-\tbool cleared, valid_const_initializer;\n+\tHOST_WIDE_INT num_ctor_elements, num_nonzero_elements;\n+\tbool cleared, complete_p, valid_const_initializer;\n \n \t/* Aggregate types must lower constructors to initialization of\n \t   individual elements.  The exception is that a CONSTRUCTOR node\n@@ -3750,7 +3749,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t   can only do so if it known to be a valid constant initializer.  */\n \tvalid_const_initializer\n \t  = categorize_ctor_elements (ctor, &num_nonzero_elements,\n-\t\t\t\t      &num_ctor_elements, &cleared);\n+\t\t\t\t      &num_ctor_elements, &complete_p);\n \n \t/* If a const aggregate variable is being initialized, then it\n \t   should never be a lose to promote the variable to be static.  */\n@@ -3788,26 +3787,29 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t   parts in, then generate code for the non-constant parts.  */\n \t/* TODO.  There's code in cp/typeck.c to do this.  */\n \n-\tnum_type_elements = count_type_elements (type, true);\n-\n-\t/* If count_type_elements could not determine number of type elements\n-\t   for a constant-sized object, assume clearing is needed.\n-\t   Don't do this for variable-sized objects, as store_constructor\n-\t   will ignore the clearing of variable-sized objects.  */\n-\tif (num_type_elements < 0 && int_size_in_bytes (type) >= 0)\n+\tif (int_size_in_bytes (TREE_TYPE (ctor)) < 0)\n+\t  /* store_constructor will ignore the clearing of variable-sized\n+\t     objects.  Initializers for such objects must explicitly set\n+\t     every field that needs to be set.  */\n+\t  cleared = false;\n+\telse if (!complete_p)\n+\t  /* If the constructor isn't complete, clear the whole object\n+\t     beforehand.\n+\n+\t     ??? This ought not to be needed.  For any element not present\n+\t     in the initializer, we should simply set them to zero.  Except\n+\t     we'd need to *find* the elements that are not present, and that\n+\t     requires trickery to avoid quadratic compile-time behavior in\n+\t     large cases or excessive memory use in small cases.  */\n \t  cleared = true;\n-\t/* If there are \"lots\" of zeros, then block clear the object first.  */\n-\telse if (num_type_elements - num_nonzero_elements\n+\telse if (num_ctor_elements - num_nonzero_elements\n \t\t > CLEAR_RATIO (optimize_function_for_speed_p (cfun))\n-\t\t && num_nonzero_elements < num_type_elements/4)\n-\t  cleared = true;\n-\t/* ??? This bit ought not be needed.  For any element not present\n-\t   in the initializer, we should simply set them to zero.  Except\n-\t   we'd need to *find* the elements that are not present, and that\n-\t   requires trickery to avoid quadratic compile-time behavior in\n-\t   large cases or excessive memory use in small cases.  */\n-\telse if (num_ctor_elements < num_type_elements)\n+\t\t && num_nonzero_elements < num_ctor_elements / 4)\n+\t  /* If there are \"lots\" of zeros, it's more efficient to clear\n+\t     the memory and then set the nonzero elements.  */\n \t  cleared = true;\n+\telse\n+\t  cleared = false;\n \n \t/* If there are \"lots\" of initialized elements, and all of them\n \t   are valid address constants, then the entire initializer can"}, {"sha": "4febcdfb84ff67c888bffdabea017dab662b7b98", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -1,3 +1,7 @@\n+2011-07-13  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* gcc.target/arm/pr48183.c: New test.\n+\n 2011-07-13  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/torture/20110713-1.c: New testcase."}, {"sha": "f021825b108484dffa5a65bc5d7507d6dd2c0007", "filename": "gcc/testsuite/gcc.target/arm/pr48183.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr48183.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr48183.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr48183.c?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -0,0 +1,25 @@\n+/* testsuite/gcc.target/arm/pr48183.c */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-add-options arm_neon } */\n+\n+#include <arm_neon.h>\n+\n+void move_16bit_to_32bit (int32_t *dst, const short *src, unsigned n)\n+{\n+    unsigned i;\n+    int16x4x2_t input;\n+    int32x4x2_t mid;\n+    int32x4x2_t output;\n+\n+    for (i = 0; i < n/2; i += 8) {\n+        input = vld2_s16(src + i);\n+        mid.val[0] = vmovl_s16(input.val[0]);\n+        mid.val[1] = vmovl_s16(input.val[1]);\n+        output.val[0] = vshlq_n_s32(mid.val[0], 8);\n+        output.val[1] = vshlq_n_s32(mid.val[1], 8);\n+        vst2q_s32((int32_t *)dst + i, output);\n+    }\n+}"}, {"sha": "fe76f8fe5b995a997238587aa662671842d97198", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953d0c90a2f0a98b6d860ecfbf1bc5672653a588/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=953d0c90a2f0a98b6d860ecfbf1bc5672653a588", "patch": "@@ -4804,21 +4804,10 @@ extern bool initializer_zerop (const_tree);\n \n extern VEC(tree,gc) *ctor_to_vec (tree);\n \n-/* Examine CTOR to discover:\n-   * how many scalar fields are set to nonzero values,\n-     and place it in *P_NZ_ELTS;\n-   * how many scalar fields in total are in CTOR,\n-     and place it in *P_ELT_COUNT.\n-   * if a type is a union, and the initializer from the constructor\n-     is not the largest element in the union, then set *p_must_clear.\n+extern bool categorize_ctor_elements (const_tree, HOST_WIDE_INT *,\n+\t\t\t\t      HOST_WIDE_INT *, bool *);\n \n-   Return whether or not CTOR is a valid static constant initializer, the same\n-   as \"initializer_constant_valid_p (CTOR, TREE_TYPE (CTOR)) != 0\".  */\n-\n-extern bool categorize_ctor_elements (const_tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t      bool *);\n-\n-extern HOST_WIDE_INT count_type_elements (const_tree, bool);\n+extern bool complete_ctor_at_level_p (const_tree, HOST_WIDE_INT, const_tree);\n \n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0.  */\n "}]}