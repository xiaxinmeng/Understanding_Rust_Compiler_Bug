{"sha": "045399546355a249baae4df245c77abf59e50a58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ1Mzk5NTQ2MzU1YTI0OWJhYWU0ZGYyNDVjNzdhYmY1OWU1MGE1OA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2005-04-04T22:43:34Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2005-04-04T22:43:34Z"}, "message": "CRIS epilogue as RTL.\n\n\t* config/cris/cris.md: Change all 0 in unspec 0 to\n\tCRIS_UNSPEC_PLT.\n \t(CRIS_UNSPEC_PLT, CRIS_UNSPEC_FRAME_DEALLOC): New constants.\n\t(\"*cris_load_multiple\", \"cris_frame_deallocated_barrier\"): New\n\tpatterns.\n\t(\"return\"): Change to define_expand.  Call cris_expand_return for\n\tactual expansion.\n\t(\"*return_expanded\"): New pattern.\n\t(\"epilogue\"): New define_expand.\n\t* config/cris/cris.h (PREDICATE_CODES): Add\n\tcris_load_multiple_op.\n\t* config/cris/cris.c (ASSERT_PLT_UNSPEC): Correct test for unspec\n\ttype.\n\t(enum cris_retinsn_type): New.\n\t(struct machine_function): New member return_type.\n\t(TARGET_ASM_FUNCTION_EPILOGUE): Don't override.\n\t(cris_target_asm_function_epilogue): Remove, moving RTLified\n\tcontents to...\n\t(cris_expand_epilogue): New function.\n\t(cris_reg_saved_in_regsave_area, cris_movem_load_rest_p,\n\t(cris_gen_movem_load, cris_load_multiple_op)\n\t(cris_return_address_on_stack_for_return, cris_expand_return): New\n\tfunctions.\n\t(cris_target_asm_function_prologue)\n\t(cris_initial_frame_pointer_offset): Call\n\tcris_reg_saved_in_regsave_area instead of complicated expression.\n\tCall cris_return_address_on_stack instead of an expression.\n\t(cris_print_operand) <case 'o', case 'O'>: New cases.\n\t(cris_return_address_on_stack): Change return-type to bool.\n\t(cris_simple_epilogue): Ditto.  Return false if registers are\n\tsaved.\n\t* config/cris/cris-protos.h (cris_simple_epilogue)\n\t(cris_return_address_on_stack): Adjust prototype return type.\n\t(cris_gen_movem_load, cris_expand_epilogue, cris_expand_return)\n\t(cris_return_address_on_stack_for_return): New prototypes.\n\nFrom-SVN: r97580", "tree": {"sha": "5683f66fe68ef666ae69695c68ddb45571ebfbed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5683f66fe68ef666ae69695c68ddb45571ebfbed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/045399546355a249baae4df245c77abf59e50a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/045399546355a249baae4df245c77abf59e50a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/045399546355a249baae4df245c77abf59e50a58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/045399546355a249baae4df245c77abf59e50a58/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87cd3586543b09902224ebba7fa1a3950f58bd8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87cd3586543b09902224ebba7fa1a3950f58bd8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87cd3586543b09902224ebba7fa1a3950f58bd8e"}], "stats": {"total": 927, "additions": 565, "deletions": 362}, "files": [{"sha": "7f512e2575a4fd2b67fcd8413d28fee045fb0dd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045399546355a249baae4df245c77abf59e50a58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045399546355a249baae4df245c77abf59e50a58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=045399546355a249baae4df245c77abf59e50a58", "patch": "@@ -1,3 +1,42 @@\n+2005-04-05  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tCRIS epilogue as RTL.\n+\t* config/cris/cris.md: Change all 0 in unspec 0 to\n+\tCRIS_UNSPEC_PLT.\n+ \t(CRIS_UNSPEC_PLT, CRIS_UNSPEC_FRAME_DEALLOC): New constants.\n+\t(\"*cris_load_multiple\", \"cris_frame_deallocated_barrier\"): New\n+\tpatterns.\n+\t(\"return\"): Change to define_expand.  Call cris_expand_return for\n+\tactual expansion.\n+\t(\"*return_expanded\"): New pattern.\n+\t(\"epilogue\"): New define_expand.\n+\t* config/cris/cris.h (PREDICATE_CODES): Add\n+\tcris_load_multiple_op.\n+\t* config/cris/cris.c (ASSERT_PLT_UNSPEC): Correct test for unspec\n+\ttype.\n+\t(enum cris_retinsn_type): New.\n+\t(struct machine_function): New member return_type.\n+\t(TARGET_ASM_FUNCTION_EPILOGUE): Don't override.\n+\t(cris_target_asm_function_epilogue): Remove, moving RTLified\n+\tcontents to...\n+\t(cris_expand_epilogue): New function.\n+\t(cris_reg_saved_in_regsave_area, cris_movem_load_rest_p,\n+\t(cris_gen_movem_load, cris_load_multiple_op)\n+\t(cris_return_address_on_stack_for_return, cris_expand_return): New\n+\tfunctions.\n+\t(cris_target_asm_function_prologue)\n+\t(cris_initial_frame_pointer_offset): Call\n+\tcris_reg_saved_in_regsave_area instead of complicated expression.\n+\tCall cris_return_address_on_stack instead of an expression.\n+\t(cris_print_operand) <case 'o', case 'O'>: New cases.\n+\t(cris_return_address_on_stack): Change return-type to bool.\n+\t(cris_simple_epilogue): Ditto.  Return false if registers are\n+\tsaved.\n+\t* config/cris/cris-protos.h (cris_simple_epilogue)\n+\t(cris_return_address_on_stack): Adjust prototype return type.\n+\t(cris_gen_movem_load, cris_expand_epilogue, cris_expand_return)\n+\t(cris_return_address_on_stack_for_return): New prototypes.\n+\n 2005-04-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/frv/frv.h (PREDICATE_CODES): Add CONST to"}, {"sha": "ecd963280922a9860d068090bf12067d65aa2e22", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=045399546355a249baae4df245c77abf59e50a58", "patch": "@@ -27,7 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n extern void cris_conditional_register_usage (void);\n-extern int cris_simple_epilogue (void);\n+extern bool cris_simple_epilogue (void);\n #ifdef RTX_CODE\n extern const char *cris_op_str (rtx);\n extern void cris_notice_update_cc (rtx, rtx);\n@@ -44,12 +44,14 @@ extern int cris_symbol (rtx);\n extern void cris_asm_output_symbol_ref (FILE *, rtx);\n extern bool cris_output_addr_const_extra (FILE *, rtx);\n extern int cris_cfun_uses_pic_table (void);\n+extern rtx cris_gen_movem_load (rtx, rtx, int);\n #endif /* RTX_CODE */\n extern void cris_asm_output_label_ref (FILE *, char *);\n extern void cris_target_asm_named_section (const char *, unsigned int, tree);\n-\n-extern int cris_return_address_on_stack (void);\n-\n+extern void cris_expand_epilogue (void);\n+extern void cris_expand_return (bool);\n+extern bool cris_return_address_on_stack_for_return (void);\n+extern bool cris_return_address_on_stack (void);\n extern void cris_pragma_expand_mul (struct cpp_reader *);\n \n /* Need one that returns an int; usable in expressions.  */"}, {"sha": "a9512a606b1da57676af3f77bed72197d7996c32", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 453, "deletions": 300, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=045399546355a249baae4df245c77abf59e50a58", "patch": "@@ -54,7 +54,7 @@ Boston, MA 02111-1307, USA.  */\n #define ASSERT_PLT_UNSPEC(x)\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if (XEXP (x, 1) != NULL_RTX\t\t\t\t\\\n+      if (XINT (x, 1) != CRIS_UNSPEC_PLT\t\t\t\\\n \t  || (GET_CODE (XVECEXP (x, 0, 0)) != SYMBOL_REF\t\\\n \t      && GET_CODE (XVECEXP (x, 0, 0)) != LABEL_REF))\t\\\n \tabort ();\t\t\t\t\t\t\\\n@@ -67,10 +67,14 @@ Boston, MA 02111-1307, USA.  */\n       return;\t\t\t\t\t\\\n     } while (0)\n \n+enum cris_retinsn_type\n+ { CRIS_RETINSN_UNKNOWN = 0, CRIS_RETINSN_RET, CRIS_RETINSN_JUMP };\n+\n /* Per-function machine data.  */\n struct machine_function GTY(())\n  {\n    int needs_return_address_on_stack;\n+   enum cris_retinsn_type return_type;\n  };\n \n /* This little fix suppresses the 'u' or 's' when '%e' in assembly\n@@ -109,10 +113,12 @@ static int saved_regs_mentioned (rtx);\n \n static void cris_target_asm_function_prologue (FILE *, HOST_WIDE_INT);\n \n-static void cris_target_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n-\n static void cris_operand_lossage (const char *, rtx);\n \n+static int cris_reg_saved_in_regsave_area  (unsigned int, bool);\n+\n+static int cris_movem_load_rest_p (rtx, int);\n+\n static void cris_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n \n@@ -168,9 +174,6 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE cris_target_asm_function_prologue\n \n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE cris_target_asm_function_epilogue\n-\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK cris_asm_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n@@ -454,7 +457,7 @@ cris_general_operand_or_plt_symbol (rtx op, enum machine_mode mode)\n    (MEM (cris_general_operand_or_symbol)).  The second one isn't a valid\n    memory_operand, so we need this predicate to recognize call\n    destinations before we change them to a PLT operand (by wrapping in\n-   UNSPEC 0).  */\n+   UNSPEC CRIS_UNSPEC_PLT).  */\n \n int\n cris_mem_call_operand (rtx op, enum machine_mode mode)\n@@ -472,6 +475,94 @@ cris_mem_call_operand (rtx op, enum machine_mode mode)\n   return cris_general_operand_or_symbol (xmem, GET_MODE (op));\n }\n \n+/* Helper for cris_load_multiple_op and cris_ret_movem_op.  */\n+\n+static int\n+cris_movem_load_rest_p (rtx op, int offs)\n+{\n+  unsigned int reg_count = XVECLEN (op, 0) - offs;\n+  rtx src_addr;\n+  int i;\n+  rtx elt;\n+  int setno;\n+  int regno_dir = 1;\n+  unsigned int regno = 0;\n+\n+  /* Perform a quick check so we don't blow up below.  FIXME: Adjust for\n+     other than (MEM reg).  */\n+  if (reg_count <= 1\n+      || GET_CODE (XVECEXP (op, 0, offs)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, offs))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, offs))) != MEM)\n+    return 0;\n+\n+  /* Check a possible post-inc indicator.  */\n+  if (GET_CODE (SET_SRC (XVECEXP (op, 0, offs + 1))) == PLUS)\n+    {\n+      rtx reg = XEXP (SET_SRC (XVECEXP (op, 0, offs + 1)), 0);\n+      rtx inc = XEXP (SET_SRC (XVECEXP (op, 0, offs + 1)), 1);\n+\n+      reg_count--;\n+\n+      if (reg_count == 1\n+\t  || !REG_P (reg)\n+\t  || !REG_P (SET_DEST (XVECEXP (op, 0, offs + 1)))\n+\t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, offs + 1)))\n+\t  || GET_CODE (inc) != CONST_INT\n+\t  || INTVAL (inc) != (HOST_WIDE_INT) reg_count * 4)\n+\treturn 0;\n+      i = offs + 2;\n+    }\n+  else\n+    i = offs + 1;\n+\n+  /* FIXME: These two only for pre-v32.  */\n+  regno_dir = -1;\n+  regno = reg_count - 1;\n+\n+  elt = XVECEXP (op, 0, offs);\n+  src_addr = XEXP (SET_SRC (elt), 0);\n+\n+  if (GET_CODE (elt) != SET\n+      || GET_CODE (SET_DEST (elt)) != REG\n+      || GET_MODE (SET_DEST (elt)) != SImode\n+      || REGNO (SET_DEST (elt)) != regno\n+      || GET_CODE (SET_SRC (elt)) != MEM\n+      || GET_MODE (SET_SRC (elt)) != SImode\n+      || !memory_address_p (SImode, src_addr))\n+    return 0;\n+\n+  for (setno = 1; i < XVECLEN (op, 0); setno++, i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+      regno += regno_dir;\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || REGNO (SET_DEST (elt)) != regno\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != setno * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Predicate for the parallel contents in a movem from-memory.  */\n+\n+int\n+cris_load_multiple_op (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return cris_movem_load_rest_p (op, 0);\n+}\n+\n /* The CONDITIONAL_REGISTER_USAGE worker.  */\n \n void\n@@ -657,6 +748,33 @@ cris_fatal (char *arg)\n   return 0;\n }\n \n+/* Return nonzero if REGNO is an ordinary register that *needs* to be\n+   saved together with other registers, possibly by a MOVEM instruction,\n+   or is saved for target-independent reasons.  There may be\n+   target-dependent reasons to save the register anyway; this is just a\n+   wrapper for a complicated conditional.  */\n+\n+static int\n+cris_reg_saved_in_regsave_area (unsigned int regno, bool got_really_used)\n+{\n+  return\n+    (((regs_ever_live[regno]\n+       && !call_used_regs[regno])\n+      || (regno == PIC_OFFSET_TABLE_REGNUM\n+\t  && (got_really_used\n+\t      /* It is saved anyway, if there would be a gap.  */\n+\t      || (flag_pic\n+\t\t  && regs_ever_live[regno + 1]\n+\t\t  && !call_used_regs[regno + 1]))))\n+     && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n+     && regno != CRIS_SRP_REGNUM)\n+    || (current_function_calls_eh_return\n+\t&& (regno == EH_RETURN_DATA_REGNO (0)\n+\t    || regno == EH_RETURN_DATA_REGNO (1)\n+\t    || regno == EH_RETURN_DATA_REGNO (2)\n+\t    || regno == EH_RETURN_DATA_REGNO (3)));\n+}\n+\n /* This variable belongs to cris_target_asm_function_prologue but must\n    be located outside it for GTY reasons.  */\n static GTY(()) unsigned long cfa_label_num = 0;\n@@ -676,9 +794,8 @@ cris_target_asm_function_prologue (FILE *file, HOST_WIDE_INT size)\n   int faked_args_size = 0;\n   int cfa_write_offset = 0;\n   static char cfa_label[30];\n-  int return_address_on_stack\n-    = regs_ever_live[CRIS_SRP_REGNUM]\n-    || cfun->machine->needs_return_address_on_stack != 0;\n+  bool return_address_on_stack = cris_return_address_on_stack ();\n+  bool got_really_used = current_function_uses_pic_offset_table;\n \n   /* Don't do anything if no prologues or epilogues are wanted.  */\n   if (!TARGET_PROLOGUE_EPILOGUE)\n@@ -771,21 +888,7 @@ cris_target_asm_function_prologue (FILE *file, HOST_WIDE_INT size)\n      to be saved.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     {\n-      if ((((regs_ever_live[regno]\n-\t     && !call_used_regs[regno])\n-\t    || (regno == (int) PIC_OFFSET_TABLE_REGNUM\n-\t\t&& (current_function_uses_pic_offset_table\n-\t\t    /* It is saved anyway, if there would be a gap.  */\n-\t\t    || (flag_pic\n-\t\t\t&& regs_ever_live[regno + 1]\n-\t\t\t&& !call_used_regs[regno + 1]))))\n-\t   && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t   && regno != CRIS_SRP_REGNUM)\n-\t  || (current_function_calls_eh_return\n-\t      && (regno == EH_RETURN_DATA_REGNO (0)\n-\t\t  || regno == EH_RETURN_DATA_REGNO (1)\n-\t\t  || regno == EH_RETURN_DATA_REGNO (2)\n-\t\t  || regno == EH_RETURN_DATA_REGNO (3))))\n+      if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n \t{\n \t  /* Check if movem may be used for registers so far.  */\n \t  if (regno == last_movem_reg + 1)\n@@ -997,239 +1100,6 @@ saved_regs_mentioned (rtx x)\n   return 0;\n }\n \n-/* Textual function epilogue.  */\n-\n-static void\n-cris_target_asm_function_epilogue (FILE *file, HOST_WIDE_INT size)\n-{\n-  int regno;\n-  int last_movem_reg = -1;\n-  rtx insn = get_last_insn ();\n-  int argspace_offset = current_function_outgoing_args_size;\n-  int pretend =\t current_function_pretend_args_size;\n-  int return_address_on_stack\n-    = regs_ever_live[CRIS_SRP_REGNUM]\n-    || cfun->machine->needs_return_address_on_stack != 0;\n-  char save_last[80];\n-\n-  save_last[0] = 0;\n-\n-  if (!TARGET_PROLOGUE_EPILOGUE)\n-    return;\n-\n-  if (TARGET_PDEBUG)\n-    fprintf (file, \";;\\n\");\n-\n-  /* Align byte count of stack frame.  */\n-  if (TARGET_STACK_ALIGN)\n-    size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n-\n-  /* If the last insn was a BARRIER, we don't have to write any code,\n-     then all returns were covered by \"return\" insns.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn\n-      && (GET_CODE (insn) == BARRIER\n-\t  /* We must make sure that the insn really is a \"return\" and\n-\t     not a conditional branch.  Try to match the return exactly,\n-\t     and if it doesn't match, assume it is a conditional branch\n-\t     (and output an epilogue).  */\n-\t  || (GET_CODE (insn) == JUMP_INSN\n-\t      && GET_CODE (PATTERN (insn)) == RETURN)))\n-    {\n-      if (TARGET_PDEBUG)\n-\tfprintf (file, \";;;;;\\n\");\n-      return;\n-    }\n-\n-  /* Check how many saved regs we can movem.  They start at r0 and must\n-     be contiguous.  */\n-  for (regno = 0;\n-       regno < FIRST_PSEUDO_REGISTER;\n-       regno++)\n-    if ((((regs_ever_live[regno]\n-\t   && !call_used_regs[regno])\n-\t  || (regno == (int) PIC_OFFSET_TABLE_REGNUM\n-\t      && (current_function_uses_pic_offset_table\n-\t\t  /* It is saved anyway, if there would be a gap.  */\n-\t\t  || (flag_pic\n-\t\t      && regs_ever_live[regno + 1]\n-\t\t      && !call_used_regs[regno + 1]))))\n-\t && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regno != CRIS_SRP_REGNUM)\n-\t|| (current_function_calls_eh_return\n-\t    && (regno == EH_RETURN_DATA_REGNO (0)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (1)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (2)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (3))))\n-\n-      {\n-\tif (regno == last_movem_reg + 1)\n-\t  last_movem_reg++;\n-\telse\n-\t  break;\n-      }\n-\n-  for (regno = FIRST_PSEUDO_REGISTER - 1;\n-       regno > last_movem_reg;\n-       regno--)\n-    if ((((regs_ever_live[regno]\n-\t   && !call_used_regs[regno])\n-\t  || (regno == (int) PIC_OFFSET_TABLE_REGNUM\n-\t      && (current_function_uses_pic_offset_table\n-\t\t  /* It is saved anyway, if there would be a gap.  */\n-\t\t  || (flag_pic\n-\t\t      && regs_ever_live[regno + 1]\n-\t\t      && !call_used_regs[regno + 1]))))\n-\t && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regno != CRIS_SRP_REGNUM)\n-\t|| (current_function_calls_eh_return\n-\t    && (regno == EH_RETURN_DATA_REGNO (0)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (1)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (2)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (3))))\n-      {\n-\tif (argspace_offset)\n-\t  {\n-\t    /* There is an area for outgoing parameters located before\n-\t       the saved registers.  We have to adjust for that.  */\n-\t    fprintf (file, \"\\tAdd%s %d,$sp\\n\",\n-\t\t     ADDITIVE_SIZE_MODIFIER (argspace_offset),\n-\t\t     argspace_offset);\n-\n-\t    /* Make sure we only do this once.  */\n-\t    argspace_offset = 0;\n-\t  }\n-\n-\t/* Flush previous non-movem:ed registers.  */\n-\tif (*save_last)\n-\t  fprintf (file, save_last);\n-\tsprintf (save_last, \"\\tPop $%s\\n\", reg_names[regno]);\n-      }\n-\n-  if (last_movem_reg != -1)\n-    {\n-      if (argspace_offset)\n-\t{\n-\t  /* Adjust for the outgoing parameters area, if that's not\n-\t     handled yet.  */\n-\t  if (*save_last)\n-\t    {\n-\t      fprintf (file, save_last);\n-\t      *save_last = 0;\n-\t    }\n-\n-\t  fprintf (file, \"\\tAdd%s %d,$sp\\n\",\n-\t\t   ADDITIVE_SIZE_MODIFIER (argspace_offset),\n-\t\t   argspace_offset);\n-\t  argspace_offset = 0;\n-\t}\n-      /* Flush previous non-movem:ed registers.  */\n-      else if (*save_last)\n-\tfprintf (file, save_last);\n-      sprintf (save_last, \"\\tmovem [$sp+],$%s\\n\", reg_names[last_movem_reg]);\n-    }\n-\n-  /* Restore frame pointer if necessary.  */\n-  if (frame_pointer_needed)\n-    {\n-      if (*save_last)\n-\tfprintf (file, save_last);\n-\n-      fprintf (file, \"\\tmove.d $%s,$sp\\n\",\n-\t       reg_names[FRAME_POINTER_REGNUM]);\n-      sprintf (save_last, \"\\tPop $%s\\n\",\n-\t       reg_names[FRAME_POINTER_REGNUM]);\n-    }\n-  else\n-    {\n-      /* If there was no frame-pointer to restore sp from, we must\n-\t explicitly deallocate local variables.  */\n-\n-      /* Handle space for outgoing parameters that hasn't been handled\n-\t yet.  */\n-      size += argspace_offset;\n-\n-      if (size)\n-\t{\n-\t  if (*save_last)\n-\t    fprintf (file, save_last);\n-\n-\t  sprintf (save_last, \"\\tadd%s \"HOST_WIDE_INT_PRINT_DEC\",$sp\\n\",\n-\t\t   ADDITIVE_SIZE_MODIFIER (size), size);\n-\t}\n-\n-      /* If the size was not in the range for a \"quick\", we must flush\n-\t it here.  */\n-      if (size > 63)\n-\t{\n-\t  fprintf (file, save_last);\n-\t  *save_last = 0;\n-\t}\n-    }\n-\n-  /* If this function has no pushed register parameters\n-     (stdargs/varargs), and if it is not a leaf function, then we can\n-     just jump-return here.  */\n-  if (return_address_on_stack && pretend == 0)\n-    {\n-      if (*save_last)\n-\tfprintf (file, save_last);\n-      *save_last = 0;\n-\n-      if (current_function_calls_eh_return)\n-\t{\n-\t  /* The installed EH-return address is in *this* frame, so we\n-\t     need to pop it before we return.  */\n-\t  fprintf (file, \"\\tpop $srp\\n\");\n-\t  fprintf (file, \"\\tret\\n\");\n-\t  fprintf (file, \"\\tadd.d $%s,$sp\\n\", reg_names[CRIS_STACKADJ_REG]);\n-\t}\n-      else\n-\tfprintf (file, \"\\tJump [$sp+]\\n\");\n-\n-      return;\n-    }\n-\n-  /* Rather than add current_function_calls_eh_return conditions\n-     everywhere in the following code (and not be able to test it\n-     thoroughly), assert the assumption that all usage of\n-     __builtin_eh_return are handled above.  */\n-  if (current_function_calls_eh_return)\n-    internal_error (\"unexpected function type needing stack adjustment for\\\n- __builtin_eh_return\");\n-\n-  /* If we pushed some register parameters, then adjust the stack for\n-     them.  */\n-  if (pretend)\n-    {\n-      /* Since srp is stored on the way, we need to restore it first.  */\n-      if (return_address_on_stack)\n-\t{\n-\t  if (*save_last)\n-\t    fprintf (file, save_last);\n-\t  *save_last = 0;\n-\n-\t  fprintf (file, \"\\tpop $srp\\n\");\n-\t}\n-\n-      if (*save_last)\n-\tfprintf (file, save_last);\n-\n-      sprintf (save_last, \"\\tadd%s %d,$sp\\n\",\n-\t       ADDITIVE_SIZE_MODIFIER (pretend), pretend);\n-    }\n-\n-  fprintf (file, \"\\tRet\\n\");\n-\n-  /* If the GCC did not do it, we have to use whatever insn we have, or\n-     a nop.  */\n-  if (*save_last)\n-    fprintf (file, save_last);\n-  else\n-    fprintf (file, \"\\tnOp\\n\");\n-}\n-\n /* The PRINT_OPERAND worker.  */\n \n void\n@@ -1272,6 +1142,49 @@ cris_print_operand (FILE *file, rtx x, int code)\n       cris_pic_sympart_only--;\n       return;\n \n+    case 'o':\n+      {\n+\t/* A movem modifier working on a parallel; output the register\n+\t   name.  */\n+\tint regno;\n+\n+\tif (GET_CODE (x) != PARALLEL)\n+\t  LOSE_AND_RETURN (\"invalid operand for 'o' modifier\", x);\n+\n+\t/* The second item can be (set reg (plus reg const)) to denote a\n+\t   postincrement.  */\n+\tregno\n+\t  = (GET_CODE (SET_SRC (XVECEXP (x, 0, 1))) == PLUS\n+\t     ? XVECLEN (x, 0) - 2\n+\t     : XVECLEN (x, 0) - 1);\n+\n+\tfprintf (file, \"$%s\", reg_names [regno]);\n+      }\n+      return;\n+\n+    case 'O':\n+      {\n+\t/* A similar movem modifier; output the memory operand.  */\n+\trtx addr;\n+\n+\tif (GET_CODE (x) != PARALLEL)\n+\t  LOSE_AND_RETURN (\"invalid operand for 'O' modifier\", x);\n+\n+\t/* The lowest mem operand is in the first item, but perhaps it\n+\t   needs to be output as postincremented.  */\n+\taddr = GET_CODE (SET_SRC (XVECEXP (x, 0, 0))) == MEM\n+\t  ? XEXP (SET_SRC (XVECEXP (x, 0, 0)), 0)\n+\t  : XEXP (SET_DEST (XVECEXP (x, 0, 0)), 0);\n+\n+\t/* The second item can be a (set reg (plus reg const)) to denote a\n+\t   post-increment.  */\n+\tif (GET_CODE (SET_SRC (XVECEXP (x, 0, 1))) == PLUS)\n+\t  addr = gen_rtx_POST_INC (SImode, addr);\n+\n+\toutput_address (addr);\n+      }\n+      return;\n+\n     case 'P':\n       /* Print the PIC register.  Applied to a GOT-less PIC symbol for\n          sanity.  */\n@@ -1647,10 +1560,21 @@ cris_return_addr_rtx (int count, rtx frameaddr ATTRIBUTE_UNUSED)\n /* Accessor used in cris.md:return because cfun->machine isn't available\n    there.  */\n \n-int\n+bool\n cris_return_address_on_stack ()\n {\n-  return cfun->machine->needs_return_address_on_stack;\n+  return regs_ever_live[CRIS_SRP_REGNUM]\n+    || cfun->machine->needs_return_address_on_stack;\n+}\n+\n+/* Accessor used in cris.md:return because cfun->machine isn't available\n+   there.  */\n+\n+bool\n+cris_return_address_on_stack_for_return ()\n+{\n+  return cfun->machine->return_type == CRIS_RETINSN_RET ? false\n+    : cris_return_address_on_stack ();\n }\n \n /* This used to be the INITIAL_FRAME_POINTER_OFFSET worker; now only\n@@ -1663,24 +1587,11 @@ cris_initial_frame_pointer_offset (void)\n \n   /* Initial offset is 0 if we don't have a frame pointer.  */\n   int offs = 0;\n+  bool got_really_used = current_function_uses_pic_offset_table;\n \n   /* And 4 for each register pushed.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if ((((regs_ever_live[regno]\n-\t   && !call_used_regs[regno])\n-\t  || (regno == (int) PIC_OFFSET_TABLE_REGNUM\n-\t      && (current_function_uses_pic_offset_table\n-\t\t  /* It is saved anyway, if there would be a gap.  */\n-\t\t  || (flag_pic\n-\t\t      && regs_ever_live[regno + 1]\n-\t\t      && !call_used_regs[regno + 1]))))\n-\t && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regno != CRIS_SRP_REGNUM)\n-\t|| (current_function_calls_eh_return\n-\t    && (regno == EH_RETURN_DATA_REGNO (0)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (1)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (2)\n-\t\t|| regno == EH_RETURN_DATA_REGNO (3))))\n+    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n       offs += 4;\n \n   /* And then, last, we add the locals allocated.  */\n@@ -1709,9 +1620,7 @@ cris_initial_elimination_offset (int fromreg, int toreg)\n \n   /* We should be able to use regs_ever_live and related prologue\n      information here, or alpha should not as well.  */\n-  int return_address_on_stack\n-    = regs_ever_live[CRIS_SRP_REGNUM]\n-    || cfun->machine->needs_return_address_on_stack != 0;\n+  bool return_address_on_stack = cris_return_address_on_stack ();\n \n   /* Here we act as if the frame-pointer were needed.  */\n   int ap_fp_offset = 4 + (return_address_on_stack ? 4 : 0);\n@@ -2003,15 +1912,15 @@ cris_notice_update_cc (rtx exp, rtx insn)\n }\n \n /* Return != 0 if the return sequence for the current function is short,\n-   like \"ret\" or \"jump [sp+]\".  Prior to reloading, we can't tell how\n-   many registers must be saved, so return 0 then.  */\n+   like \"ret\" or \"jump [sp+]\".  Prior to reloading, we can't tell if\n+   registers must be saved, so return 0 then.  */\n \n-int\n+bool\n cris_simple_epilogue (void)\n {\n-  int regno;\n-  int reglimit = STACK_POINTER_REGNUM;\n-  int lastreg = -1;\n+  unsigned int regno;\n+  unsigned int reglimit = STACK_POINTER_REGNUM;\n+  bool got_really_used = current_function_uses_pic_offset_table;\n \n   if (! reload_completed\n       || frame_pointer_needed\n@@ -2024,25 +1933,36 @@ cris_simple_epilogue (void)\n       /* If we're not supposed to emit prologue and epilogue, we must\n \t not emit return-type instructions.  */\n       || !TARGET_PROLOGUE_EPILOGUE)\n-    return 0;\n+    return false;\n \n-  /* We allow a \"movem [sp+],rN\" to sit in front if the \"jump [sp+]\" or\n-     in the delay-slot of the \"ret\".  */\n+  /* No simple epilogue if there are saved registers.  */\n   for (regno = 0; regno < reglimit; regno++)\n-    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t|| (regno == (int) PIC_OFFSET_TABLE_REGNUM\n-\t    && (current_function_uses_pic_offset_table\n-\t\t/* It is saved anyway, if there would be a gap.  */\n-\t\t|| (flag_pic\n-\t\t    && regs_ever_live[regno + 1]\n-\t\t    && !call_used_regs[regno + 1]))))\n-      {\n-\tif (lastreg != regno - 1)\n-\t  return 0;\n-\tlastreg = regno;\n-      }\n+    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+      return false;\n \n-  return 1;\n+  return true;\n+}\n+\n+/* Expand a return insn (just one insn) marked as using SRP or stack\n+   slot depending on parameter ON_STACK.  */\n+\n+void\n+cris_expand_return (bool on_stack)\n+{\n+  /* FIXME: emit a parallel with a USE for SRP or the stack-slot, to\n+     tell \"ret\" from \"jump [sp+]\".  Some, but not all, other parts of\n+     GCC expect just (return) to do the right thing when optimizing, so\n+     we do that until they're fixed.  Currently, all return insns in a\n+     function must be the same (not really a limiting factor) so we need\n+     to check that it doesn't change half-way through.  */\n+  emit_jump_insn (gen_rtx_RETURN (VOIDmode));\n+\n+  if ((cfun->machine->return_type == CRIS_RETINSN_RET && on_stack)\n+      || (cfun->machine->return_type == CRIS_RETINSN_JUMP && !on_stack))\n+    abort ();\n+\n+  cfun->machine->return_type\n+    = on_stack ? CRIS_RETINSN_JUMP : CRIS_RETINSN_RET;\n }\n \n /* Compute a (partial) cost for rtx X.  Return true if the complete\n@@ -2886,6 +2806,239 @@ cris_split_movdx (rtx *operands)\n   return val;\n }\n \n+/* The expander for the epilogue pattern.  */\n+\n+void\n+cris_expand_epilogue (void)\n+{\n+  int regno;\n+  int size = get_frame_size ();\n+  int last_movem_reg = -1;\n+  int argspace_offset = current_function_outgoing_args_size;\n+  int pretend =\t current_function_pretend_args_size;\n+  rtx mem;\n+  bool return_address_on_stack = cris_return_address_on_stack ();\n+  /* A reference may have been optimized out\n+     (like the abort () in fde_split in unwind-dw2-fde.c, at least 3.2.1)\n+     so check that it's still used.  */\n+  int got_really_used = current_function_uses_pic_offset_table;\n+  int n_movem_regs = 0;\n+\n+  if (!TARGET_PROLOGUE_EPILOGUE)\n+    return;\n+\n+  /* Align byte count of stack frame.  */\n+  if (TARGET_STACK_ALIGN)\n+    size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n+\n+  /* Check how many saved regs we can movem.  They start at r0 and must\n+     be contiguous.  */\n+  for (regno = 0;\n+       regno < FIRST_PSEUDO_REGISTER;\n+       regno++)\n+    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+      {\n+\tn_movem_regs++;\n+\n+\tif (regno == last_movem_reg + 1)\n+\t  last_movem_reg = regno;\n+\telse\n+\t  break;\n+      }\n+\n+  /* If there was only one register that really needed to be saved\n+     through movem, don't use movem.  */\n+  if (n_movem_regs == 1)\n+    last_movem_reg = -1;\n+\n+  /* Now emit \"normal\" move insns for all regs higher than the movem\n+     regs.  */\n+  for (regno = FIRST_PSEUDO_REGISTER - 1;\n+       regno > last_movem_reg;\n+       regno--)\n+    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+      {\n+\tif (argspace_offset)\n+\t  {\n+\t    /* There is an area for outgoing parameters located before\n+\t       the saved registers.  We have to adjust for that.  */\n+\t    emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t   argspace_offset)));\n+\t    /* Make sure we only do this once.  */\n+\t    argspace_offset = 0;\n+\t  }\n+\n+\tmem = gen_rtx_MEM (SImode, gen_rtx_POST_INC (SImode,\n+\t\t\t\t\t\t     stack_pointer_rtx));\n+\tset_mem_alias_set (mem, get_frame_alias_set ());\n+\temit_move_insn (gen_rtx_raw_REG (SImode, regno), mem);\n+      }\n+\n+  /* If we have any movem-restore, do it now.  */\n+  if (last_movem_reg != -1)\n+    {\n+      if (argspace_offset)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t argspace_offset)));\n+\t  argspace_offset = 0;\n+\t}\n+\n+      mem = gen_rtx_MEM (SImode,\n+\t\t\t gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n+      set_mem_alias_set (mem, get_frame_alias_set ());\n+      emit_insn (cris_gen_movem_load (mem, GEN_INT (last_movem_reg + 1), 0));\n+    }\n+\n+  /* If we don't clobber all of the allocated stack area (we've already\n+     deallocated saved registers), GCC might want to schedule loads from\n+     the stack to *after* the stack-pointer restore, which introduces an\n+     interrupt race condition.  This happened for the initial-value\n+     SRP-restore for g++.dg/eh/registers1.C (noticed by inspection of\n+     other failure for that test).  It also happened for the stack slot\n+     for the return value in (one version of)\n+     linux/fs/dcache.c:__d_lookup, at least with \"-O2\n+     -fno-omit-frame-pointer\".  */\n+\n+  /* Restore frame pointer if necessary.  */\n+  if (frame_pointer_needed)\n+    {\n+      emit_insn (gen_cris_frame_deallocated_barrier ());\n+\n+      emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+      mem = gen_rtx_MEM (SImode, gen_rtx_POST_INC (SImode,\n+\t\t\t\t\t\t   stack_pointer_rtx));\n+      set_mem_alias_set (mem, get_frame_alias_set ());\n+      emit_move_insn (frame_pointer_rtx, mem);\n+    }\n+  else if ((size + argspace_offset) != 0)\n+    {\n+      emit_insn (gen_cris_frame_deallocated_barrier ());\n+\n+      /* If there was no frame-pointer to restore sp from, we must\n+\t explicitly deallocate local variables.  */\n+\n+      /* Handle space for outgoing parameters that hasn't been handled\n+\t yet.  */\n+      size += argspace_offset;\n+\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      stack_pointer_rtx,\n+\t\t\t      plus_constant (stack_pointer_rtx, size)));\n+    }\n+\n+  /* If this function has no pushed register parameters\n+     (stdargs/varargs), and if it is not a leaf function, then we have\n+     the return address on the stack.  */\n+  if (return_address_on_stack && pretend == 0)\n+    {\n+      if (current_function_calls_eh_return)\n+\t{\n+\t  rtx mem;\n+\t  rtx srpreg = gen_rtx_raw_REG (SImode, CRIS_SRP_REGNUM);\n+\t  mem = gen_rtx_MEM (SImode,\n+\t\t\t     gen_rtx_POST_INC (SImode,\n+\t\t\t\t\t       stack_pointer_rtx));\n+\t  set_mem_alias_set (mem, get_frame_alias_set ());\n+\t  emit_move_insn (srpreg, mem);\n+\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t gen_rtx_raw_REG (SImode,\n+\t\t\t\t\t\t  CRIS_STACKADJ_REG)));\n+\t  cris_expand_return (false);\n+\t}\n+      else\n+\tcris_expand_return (true);\n+\n+      return;\n+    }\n+\n+  /* If we pushed some register parameters, then adjust the stack for\n+     them.  */\n+  if (pretend != 0)\n+    {\n+      /* If SRP is stored on the way, we need to restore it first.  */\n+      if (return_address_on_stack)\n+\t{\n+\t  rtx mem;\n+\t  rtx srpreg = gen_rtx_raw_REG (SImode, CRIS_SRP_REGNUM);\n+\t  mem = gen_rtx_MEM (SImode,\n+\t\t\t     gen_rtx_POST_INC (SImode,\n+\t\t\t\t\t       stack_pointer_rtx));\n+\t  set_mem_alias_set (mem, get_frame_alias_set ());\n+\t  emit_move_insn (srpreg, mem);\n+\t}\n+\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      stack_pointer_rtx,\n+\t\t\t      plus_constant (stack_pointer_rtx, pretend)));\n+    }\n+\n+  /* Perform the \"physical\" unwinding that the EH machinery calculated.  */\n+  if (current_function_calls_eh_return)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   gen_rtx_raw_REG (SImode,\n+\t\t\t\t\t    CRIS_STACKADJ_REG)));\n+  cris_expand_return (false);\n+}\n+\n+/* Worker function for generating movem from mem for load_multiple.  */\n+\n+rtx\n+cris_gen_movem_load (rtx osrc, rtx nregs_rtx, int nprefix)\n+{\n+  int nregs = INTVAL (nregs_rtx);\n+  rtvec vec;\n+  int eltno = 1;\n+  int i;\n+  rtx srcreg = XEXP (osrc, 0);\n+  rtx src = osrc;\n+  unsigned int regno = nregs - 1;\n+  int regno_inc = -1;\n+\n+  if (GET_CODE (srcreg) == POST_INC)\n+    srcreg = XEXP (srcreg, 0);\n+\n+  if (!REG_P (srcreg))\n+    abort ();\n+\n+  /* Don't use movem for just one insn.  The insns are equivalent except\n+     for the pipeline hazard; movem does not forward the loaded\n+     registers so there's a three cycles penalty for use.  */\n+  if (nregs == 1)\n+    return gen_movsi (gen_rtx_REG (SImode, regno), osrc);\n+\n+  vec = rtvec_alloc (nprefix + nregs\n+\t\t     + (GET_CODE (XEXP (osrc, 0)) == POST_INC));\n+  src = replace_equiv_address (osrc, srcreg);\n+  RTVEC_ELT (vec, nprefix)\n+    = gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regno), src);\n+  regno += regno_inc;\n+\n+  if (GET_CODE (XEXP (osrc, 0)) == POST_INC)\n+    {\n+      RTVEC_ELT (vec, nprefix + 1)\n+\t= gen_rtx_SET (VOIDmode, srcreg, plus_constant (srcreg, nregs * 4));\n+      eltno++;\n+    }\n+\n+  for (i = 1; i < nregs; i++, eltno++)\n+    {\n+      RTVEC_ELT (vec, nprefix + eltno)\n+\t= gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regno),\n+\t\t       adjust_address_nv (src, SImode, i * 4));\n+      regno += regno_inc;\n+    }\n+\n+  return gen_rtx_PARALLEL (VOIDmode, vec);\n+}\n+\n /* Use from within code, from e.g. PRINT_OPERAND and\n    PRINT_OPERAND_ADDRESS.  Macros used in output_addr_const need to emit\n    different things depending on whether code operand or constant is"}, {"sha": "96c73037a486340623ff93b5f561fd6f4f67662a", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=045399546355a249baae4df245c77abf59e50a58", "patch": "@@ -1627,6 +1627,8 @@ struct cum_args {int regs;};\n   {PLUS, UMIN}},\t\t\t\t\t\\\n  {\"cris_mem_op\",\t\t\t\t\t\\\n   {MEM}},\t\t\t\t\t\t\\\n+ {\"cris_load_multiple_op\",\t\t\t\t\\\n+  {PARALLEL}},\t\t\t\t\t\t\\\n  {\"cris_bdap_operand\",\t\t\t\t\t\\\n   {SUBREG, REG, LABEL_REF, SYMBOL_REF, MEM, CONST_INT,\t\\\n    CONST_DOUBLE, CONST, SIGN_EXTEND}},\t\t\t\\"}, {"sha": "98f42ee80d98276825680842cfacb2ceb7ecf897", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 65, "deletions": 58, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045399546355a249baae4df245c77abf59e50a58/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=045399546355a249baae4df245c77abf59e50a58", "patch": "@@ -58,6 +58,11 @@\n ;; UNSPEC Usage:\n ;; 0 PLT reference from call expansion: operand 0 is the address,\n ;;   the mode is VOIDmode.  Always wrapped in CONST.\n+;; 1 Stack frame deallocation barrier.\n+\n+(define_constants\n+  [(CRIS_UNSPEC_PLT 0)\n+   (CRIS_UNSPEC_FRAME_DEALLOC 1)])\n \n \n ;; Register numbers.\n@@ -1381,6 +1386,24 @@\n    move %1,%0\n    move %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no,yes,yes,yes,no,yes,no\")])\n+\n+;; Note that the order of the registers is the reverse of that of the\n+;; standard pattern \"load_multiple\".\n+(define_insn \"*cris_load_multiple\"\n+  [(match_parallel 0 \"cris_load_multiple_op\"\n+\t\t   [(set (match_operand:SI 1 \"register_operand\" \"=r,r\")\n+\t\t\t (match_operand:SI 2 \"memory_operand\" \"Q,m\"))])]\n+  \"\"\n+  \"movem %O0,%o0\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"slottable\" \"yes,no\")\n+   ;; Not true, but setting the length to 0 causes return sequences (ret\n+   ;; movem) to have the cost they had when (return) included the movem\n+   ;; and reduces the performance penalty taken for needing to emit an\n+   ;; epilogue (in turn copied by bb-reorder) instead of return patterns.\n+   ;; FIXME: temporary change until all insn lengths are correctly\n+   ;; described.  FIXME: have better target control over bb-reorder.\n+   (set_attr \"length\" \"0\")])\n \f\n \n ;; Sign- and zero-extend insns with standard names.\n@@ -3467,69 +3490,37 @@\n   \"jump %0\")\n \n ;; Return insn.  Used whenever the epilogue is very simple; if it is only\n-;; a single ret or jump [sp+] or a contiguous sequence of movem:able saved\n-;; registers.  No allocated stack space is allowed.\n+;; a single ret or jump [sp+].  No allocated stack space or saved\n+;; registers are allowed.\n ;; Note that for this pattern, although named, it is ok to check the\n ;; context of the insn in the test, not only compiler switches.\n \n-(define_insn \"return\"\n+(define_expand \"return\"\n   [(return)]\n   \"cris_simple_epilogue ()\"\n-  \"*\n-{\n-  int i;\n-\n-  /* Just needs to hold a 'movem [sp+],rN'.  */\n-  char rd[sizeof (\\\"movem [$sp+],$r99\\\")];\n-\n-  *rd = 0;\n-\n-  /* Start from the last call-saved register.  We know that we have a\n-     simple epilogue, so we just have to find the last register in the\n-     movem sequence.  */\n-  for (i = 8; i >= 0; i--)\n-    if (regs_ever_live[i]\n-\t|| (i == PIC_OFFSET_TABLE_REGNUM\n-\t    && current_function_uses_pic_offset_table))\n-      break;\n-\n-  if (i >= 0)\n-    sprintf (rd, \\\"movem [$sp+],$%s\\\", reg_names [i]);\n-\n-  if (regs_ever_live[CRIS_SRP_REGNUM]\n-      || cris_return_address_on_stack ())\n-    {\n-      if (*rd)\n-\toutput_asm_insn (rd, operands);\n-      return \\\"jump [$sp+]\\\";\n-    }\n+  \"cris_expand_return (cris_return_address_on_stack ()); DONE;\")\n \n-  if (*rd)\n-    {\n-      output_asm_insn (\\\"reT\\\", operands);\n-      output_asm_insn (rd, operands);\n-      return \\\"\\\";\n-    }\n-\n-  return \\\"ret%#\\\";\n-}\"\n+(define_insn \"*return_expanded\"\n+  [(return)]\n+  \"\"\n+{\n+  return cris_return_address_on_stack_for_return ()\n+    ? \"jump [$sp+]\" : \"ret%#\";\n+}\n   [(set (attr \"slottable\")\n-\t(if_then_else\n-\t (ne (symbol_ref\n-\t      \"(regs_ever_live[CRIS_SRP_REGNUM]\n-\t        || cris_return_address_on_stack ())\")\n-\t     (const_int 0))\n-\t (const_string \"no\")\t     ; If jump then not slottable.\n-\t (if_then_else\n-\t  (ne (symbol_ref\n-\t       \"(regs_ever_live[0]\n-\t\t || (flag_pic != 0 && regs_ever_live[1])\n-\t\t || (PIC_OFFSET_TABLE_REGNUM == 0\n-\t\t     && cris_cfun_uses_pic_table ()))\")\n-\t      (const_int 0))\n-\t  (const_string \"no\") ; ret+movem [sp+],rx: slot already filled.\n-\t  (const_string \"has_slot\")))) ; If ret then need to fill a slot.\n-   (set_attr \"cc\" \"none\")])\n+ \t(if_then_else\n+ \t (ne (symbol_ref\n+\t      \"(cris_return_address_on_stack_for_return ())\")\n+ \t     (const_int 0))\n+ \t (const_string \"no\")\n+\t (const_string \"has_slot\")))])\n+\n+;; Note that the (return) from the expander itself is always the last\n+;; insn in the epilogue.\n+(define_expand \"epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"cris_expand_epilogue (); DONE;\")\n \f\n ;; Conditional branches.\n \n@@ -3929,7 +3920,8 @@\n \t\t\t     gen_rtx_CONST\n \t\t\t     (VOIDmode,\n \t\t\t      gen_rtx_UNSPEC (VOIDmode,\n-\t\t\t\t\t      gen_rtvec (1, op0), 0)));\n+\t\t\t\t\t      gen_rtvec (1, op0),\n+\t\t\t\t\t      CRIS_UNSPEC_PLT)));\n \t  else\n \t    abort ();\n \n@@ -3994,7 +3986,8 @@\n \t\t\t     gen_rtx_CONST\n \t\t\t     (VOIDmode,\n \t\t\t      gen_rtx_UNSPEC (VOIDmode,\n-\t\t\t\t\t      gen_rtvec (1, op1), 0)));\n+\t\t\t\t\t      gen_rtvec (1, op1),\n+\t\t\t\t\t      CRIS_UNSPEC_PLT)));\n \t  else\n \t    abort ();\n \n@@ -4040,6 +4033,20 @@\n   \"nop\"\n   [(set_attr \"cc\" \"none\")])\n \f\n+;; We need to stop accesses to the stack after the memory is\n+;; deallocated.  Unfortunately, reorg doesn't look at naked clobbers,\n+;; e.g. (insn ... (clobber (mem:BLK (stack_pointer_rtx)))) and we don't\n+;; want to use a naked (unspec_volatile) as that would stop any\n+;; scheduling in the epilogue.  Hence we model it as a \"real\" insn that\n+;; sets the memory in an unspecified manner.  FIXME: Unfortunately it\n+;; still has the effect of an unspec_volatile.\n+(define_insn \"cris_frame_deallocated_barrier\"\n+  [(set (mem:BLK (reg:SI CRIS_SP_REGNUM))\n+\t(unspec:BLK [(const_int 0)] CRIS_UNSPEC_FRAME_DEALLOC))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n ;; We expand on casesi so we can use \"bound\" and \"add offset fetched from\n ;; a table to pc\" (adds.w [pc+%0.w],pc).\n "}]}