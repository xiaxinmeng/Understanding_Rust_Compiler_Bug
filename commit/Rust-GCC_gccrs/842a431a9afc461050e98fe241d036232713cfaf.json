{"sha": "842a431a9afc461050e98fe241d036232713cfaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyYTQzMWE5YWZjNDYxMDUwZTk4ZmUyNDFkMDM2MjMyNzEzY2ZhZg==", "commit": {"author": {"name": "David Miller", "email": "davem@redhat.com", "date": "2003-06-05T16:31:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-06-05T16:31:49Z"}, "message": "optabs.c (HAVE_conditional_trap): Provide default.\n\n        * optabs.c (HAVE_conditional_trap): Provide default.\n        (gen_conditional_trap): Likewise.\n        (init_optabs): Merge init_traps.\n        (gen_cond_trap): Use prepare_operand.  Restructure and avoid ifdef.\n\t* gcc.c-torture/compile/20030605-1.c: New.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r67497", "tree": {"sha": "ef1c0ed207c9a04740d15d901f47845160bb2f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef1c0ed207c9a04740d15d901f47845160bb2f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/842a431a9afc461050e98fe241d036232713cfaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842a431a9afc461050e98fe241d036232713cfaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/842a431a9afc461050e98fe241d036232713cfaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842a431a9afc461050e98fe241d036232713cfaf/comments", "author": null, "committer": null, "parents": [{"sha": "ad23ad2cbe2d00b1f4daf87c3b8caa5166fdc81f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad23ad2cbe2d00b1f4daf87c3b8caa5166fdc81f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad23ad2cbe2d00b1f4daf87c3b8caa5166fdc81f"}], "stats": {"total": 94, "additions": 53, "deletions": 41}, "files": [{"sha": "1b1ad9ac56615721a610f764094388c58d21a262", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842a431a9afc461050e98fe241d036232713cfaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842a431a9afc461050e98fe241d036232713cfaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=842a431a9afc461050e98fe241d036232713cfaf", "patch": "@@ -1,3 +1,11 @@\n+2003-06-05  David Miller  <davem@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.c (HAVE_conditional_trap): Provide default.\n+\t(gen_conditional_trap): Likewise.\n+\t(init_optabs): Merge init_traps.\n+\t(gen_cond_trap): Use prepare_operand.  Restructure and avoid ifdef.\n+\n Thu Jun  5 14:59:44 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* combine.c (simplify_if_then_else): (IF_THEN_ELSE (NE REG 0) (0) (8))"}, {"sha": "8b7f3ea0481ad4df902228074be56a303461de93", "filename": "gcc/optabs.c", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842a431a9afc461050e98fe241d036232713cfaf/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842a431a9afc461050e98fe241d036232713cfaf/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=842a431a9afc461050e98fe241d036232713cfaf", "patch": "@@ -88,6 +88,11 @@ enum insn_code setcc_gen_code[NUM_RTX_CODE];\n enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n #endif\n \n+/* The insn generating function can not take an rtx_code argument.\n+   TRAP_RTX is used as an rtx argument.  Its code is replaced with\n+   the code to be used in the trap insn and all other fields are ignored.  */\n+static GTY(()) rtx trap_rtx;\n+\n static int add_equal_note\tPARAMS ((rtx, rtx, enum rtx_code, rtx, rtx));\n static rtx widen_operand\tPARAMS ((rtx, enum machine_mode,\n \t\t\t\t       enum machine_mode, int, int));\n@@ -114,9 +119,6 @@ static inline optab init_optabv\tPARAMS ((enum rtx_code));\n static void init_libfuncs PARAMS ((optab, int, int, const char *, int));\n static void init_integral_libfuncs PARAMS ((optab, const char *, int));\n static void init_floating_libfuncs PARAMS ((optab, const char *, int));\n-#ifdef HAVE_conditional_trap\n-static void init_traps PARAMS ((void));\n-#endif\n static void emit_cmp_and_jump_insn_1 PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t    enum rtx_code, int, rtx));\n static void prepare_float_lib_cmp PARAMS ((rtx *, rtx *, enum rtx_code *,\n@@ -128,6 +130,11 @@ static rtx expand_vector_unop PARAMS ((enum machine_mode, optab, rtx, rtx,\n \t\t\t\t       int));\n static rtx widen_clz PARAMS ((enum machine_mode, rtx, rtx));\n static rtx expand_parity PARAMS ((enum machine_mode, rtx, rtx));\n+\n+#ifndef HAVE_conditional_trap\n+#define HAVE_conditional_trap 0\n+#define gen_conditional_trap(a,b) (abort (), NULL_RTX)\n+#endif\n \f\n /* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to\n    the result of operation CODE applied to OP0 (and OP1 if it is a binary\n@@ -5806,34 +5813,15 @@ init_optabs ()\n   gcov_flush_libfunc = init_one_libfunc (\"__gcov_flush\");\n   gcov_init_libfunc = init_one_libfunc (\"__gcov_init\");\n \n-#ifdef HAVE_conditional_trap\n-  init_traps ();\n-#endif\n+  if (HAVE_conditional_trap)\n+    trap_rtx = gen_rtx_fmt_ee (EQ, VOIDmode, NULL_RTX, NULL_RTX);\n \n #ifdef INIT_TARGET_OPTABS\n   /* Allow the target to add more libcalls or rename some, etc.  */\n   INIT_TARGET_OPTABS;\n #endif\n }\n \f\n-static GTY(()) rtx trap_rtx;\n-\n-#ifdef HAVE_conditional_trap\n-/* The insn generating function can not take an rtx_code argument.\n-   TRAP_RTX is used as an rtx argument.  Its code is replaced with\n-   the code to be used in the trap insn and all other fields are\n-   ignored.  */\n-\n-static void\n-init_traps ()\n-{\n-  if (HAVE_conditional_trap)\n-    {\n-      trap_rtx = gen_rtx_fmt_ee (EQ, VOIDmode, NULL_RTX, NULL_RTX);\n-    }\n-}\n-#endif\n-\n /* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition\n    CODE.  Return 0 on failure.  */\n \n@@ -5843,30 +5831,34 @@ gen_cond_trap (code, op1, op2, tcode)\n      rtx op1, op2 ATTRIBUTE_UNUSED, tcode ATTRIBUTE_UNUSED;\n {\n   enum machine_mode mode = GET_MODE (op1);\n+  enum insn_code icode;\n+  rtx insn;\n+\n+  if (!HAVE_conditional_trap)\n+    return 0;\n \n   if (mode == VOIDmode)\n     return 0;\n \n-#ifdef HAVE_conditional_trap\n-  if (HAVE_conditional_trap\n-      && cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  icode = cmp_optab->handlers[(int) mode].insn_code;\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  start_sequence ();\n+  op1 = prepare_operand (icode, op1, 0, mode, mode, 0);\n+  op2 = prepare_operand (icode, op2, 0, mode, mode, 0);\n+  emit_insn (GEN_FCN (icode) (op1, op2));\n+\n+  PUT_CODE (trap_rtx, code);\n+  insn = gen_conditional_trap (trap_rtx, tcode);\n+  if (insn)\n     {\n-      rtx insn;\n-      start_sequence ();\n-      emit_insn (GEN_FCN (cmp_optab->handlers[(int) mode].insn_code) (op1, op2));\n-      PUT_CODE (trap_rtx, code);\n-      insn = gen_conditional_trap (trap_rtx, tcode);\n-      if (insn)\n-\t{\n-\t  emit_insn (insn);\n-\t  insn = get_insns ();\n-\t}\n-      end_sequence ();\n-      return insn;\n+      emit_insn (insn);\n+      insn = get_insns ();\n     }\n-#endif\n+  end_sequence ();\n \n-  return 0;\n+  return insn;\n }\n \n #include \"gt-optabs.h\""}, {"sha": "f5e102318b2d907d46a705d678f5871342aa8418", "filename": "gcc/testsuite/gcc.c-torture/compile/20030605-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842a431a9afc461050e98fe241d036232713cfaf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030605-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842a431a9afc461050e98fe241d036232713cfaf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030605-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030605-1.c?ref=842a431a9afc461050e98fe241d036232713cfaf", "patch": "@@ -0,0 +1,12 @@\n+/* Test for proper preparation of the comparison operands for \n+   generation of a conditional trap.  Produced unrecognizable\n+   rtl on Sparc.  */\n+\n+struct blah { char *b_data; };\n+\n+void set_bh_page(struct blah *bh, unsigned long offset)\n+{\n+        if ((1UL << 12 ) <= offset)\n+                __builtin_trap() ;\n+        bh->b_data = (char *)offset;\n+}"}]}