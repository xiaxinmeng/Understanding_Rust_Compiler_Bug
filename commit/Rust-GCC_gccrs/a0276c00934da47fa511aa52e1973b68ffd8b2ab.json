{"sha": "a0276c00934da47fa511aa52e1973b68ffd8b2ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyNzZjMDA5MzRkYTQ3ZmE1MTFhYTUyZTE5NzNiNjhmZmQ4YjJhYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-06-27T12:07:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-06-27T12:07:43Z"}, "message": "class.c (layout_class_type): Set TYPE_CXX_ODR_P for as-base type copy.\n\n\n\n\t* class.c (layout_class_type): Set TYPE_CXX_ODR_P for as-base\n\ttype copy.\n\n\t* ipa-devirt.c (odr_type_d): Add tbaa_enabled flag.\n\t(add_type_duplicate): When odr hash is not allocated, to nothing.\n\t(odr_based_tbaa_p): New function.\n\t(set_type_canonical_for_odr_type): New function.\n\t* ipa-utils.h (enable_odr_based_tbaa, odr_based_tbaa_p,\n\tset_type_canonical_for_odr_type): New.\n\t* tree.c (gimple_canonical_types_compatible_p): ODR types with\n\tODR based TBAA are not equivalent to non-ODR types.\n\n\t* lto-common.c: Include demangle.h and tree-pretty-print.h\n\t(type_streaming_finished): New static var.\n\t(gimple_register_canonical_type_1): Return updated hash; handle ODR\n\ttypes.\n\t(iterative_hash_canonical_type): Update use of\n\tgimple_register_canonical_type_1.\n\n\t* g++.dg/lto/alias-2_0.C: New testcase.\n\t* g++.dg/lto/alias-2_1.C: New testcase.\n\nFrom-SVN: r272749", "tree": {"sha": "665e4f690d6caafce10b0ade27ecfeef5909742f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/665e4f690d6caafce10b0ade27ecfeef5909742f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0276c00934da47fa511aa52e1973b68ffd8b2ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0276c00934da47fa511aa52e1973b68ffd8b2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0276c00934da47fa511aa52e1973b68ffd8b2ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0276c00934da47fa511aa52e1973b68ffd8b2ab/comments", "author": null, "committer": null, "parents": [{"sha": "ef874db611879d5004e1d834543e55d31f2bfe1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef874db611879d5004e1d834543e55d31f2bfe1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef874db611879d5004e1d834543e55d31f2bfe1c"}], "stats": {"total": 262, "additions": 255, "deletions": 7}, "files": [{"sha": "948948f20fd5e6f3444c4ac1d38f9f35abdabf7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -1,3 +1,14 @@\n+2019-06-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-devirt.c (odr_type_d): Add tbaa_enabled flag.\n+\t(add_type_duplicate): When odr hash is not allocated, to nothing.\n+\t(odr_based_tbaa_p): New function.\n+\t(set_type_canonical_for_odr_type): New function.\n+\t* ipa-utils.h (enable_odr_based_tbaa, odr_based_tbaa_p,\n+\tset_type_canonical_for_odr_type): New.\n+\t* tree.c (gimple_canonical_types_compatible_p): ODR types with\n+\tODR based TBAA are not equivalent to non-ODR types.\n+\n 2019-06-27  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/90974"}, {"sha": "e616765143193b6de6dcaa1d846d76fa0e774563", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -1,3 +1,8 @@\n+2019-06-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* class.c (layout_class_type): Set TYPE_CXX_ODR_P for as-base\n+\ttype copy.\n+\n 2019-06-27  Martin Liska  <mliska@suse.cz>\n \n \t* class.c (adjust_clone_args): Remove obviously"}, {"sha": "73291b341fe8815d433f46f959bf2640675e4b04", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -6393,6 +6393,7 @@ layout_class_type (tree t, tree *virtuals_p)\n       SET_TYPE_ALIGN (base_t, rli->record_align);\n       TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);\n       TYPE_TYPELESS_STORAGE (base_t) = TYPE_TYPELESS_STORAGE (t);\n+      TYPE_CXX_ODR_P (base_t) = TYPE_CXX_ODR_P (t);\n \n       /* Copy the non-static data members of T. This will include its\n \t direct non-virtual bases & vtable.  */"}, {"sha": "252d9206181ebdd61dc7ca80e4d4a0e391b510fd", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -213,6 +213,8 @@ struct GTY(()) odr_type_d\n   bool odr_violated;\n   /* Set when virtual table without RTTI previaled table with.  */\n   bool rtti_broken;\n+  /* Set when the canonical type is determined using the type name.  */\n+  bool tbaa_enabled;\n };\n \n /* Return TRUE if all derived types of T are known and thus\n@@ -1610,6 +1612,9 @@ add_type_duplicate (odr_type val, tree type)\n \n   val->types_set->add (type);\n \n+  if (!odr_hash)\n+    return NULL;\n+\n   gcc_checking_assert (can_be_name_hashed_p (type)\n \t\t       && can_be_name_hashed_p (val->type));\n \n@@ -1989,6 +1994,46 @@ prevailing_odr_type (tree type)\n   return t->type;\n }\n \n+/* Set tbaa_enabled flag for TYPE.  */\n+\n+void\n+enable_odr_based_tbaa (tree type)\n+{\n+  odr_type t = get_odr_type (type, true);\n+  t->tbaa_enabled = true;\n+}\n+\n+/* True if canonical type of TYPE is determined using ODR name.  */\n+\n+bool\n+odr_based_tbaa_p (const_tree type)\n+{\n+  if (!RECORD_OR_UNION_TYPE_P (type))\n+    return false;\n+  odr_type t = get_odr_type (const_cast <tree> (type), false);\n+  if (!t || !t->tbaa_enabled)\n+    return false;\n+  return true;\n+}\n+\n+/* Set TYPE_CANONICAL of type and all its variants and duplicates\n+   to CANONICAL.  */\n+\n+void\n+set_type_canonical_for_odr_type (tree type, tree canonical)\n+{\n+  odr_type t = get_odr_type (type, false);\n+  unsigned int i;\n+  tree tt;\n+\n+  for (tree t2 = t->type; t2; t2 = TYPE_NEXT_VARIANT (t2))\n+    TYPE_CANONICAL (t2) = canonical;\n+  if (t->types)\n+    FOR_EACH_VEC_ELT (*t->types, i, tt)\n+      for (tree t2 = tt; t2; t2 = TYPE_NEXT_VARIANT (t2))\n+        TYPE_CANONICAL (t2) = canonical;\n+}\n+\n /* Return true if we reported some ODR violation on TYPE.  */\n \n bool"}, {"sha": "22e6970234a448d52ddcff4ef53037a1e65b7957", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -93,6 +93,9 @@ bool odr_or_derived_type_p (const_tree t);\n bool odr_types_equivalent_p (tree type1, tree type2);\n bool odr_type_violation_reported_p (tree type);\n tree prevailing_odr_type (tree type);\n+void enable_odr_based_tbaa (tree type);\n+bool odr_based_tbaa_p (const_tree type);\n+void set_type_canonical_for_odr_type (tree type, tree canonical);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If COMPLETEP is non-NULL, store true if the list is complete. "}, {"sha": "1275b673506a414add8fe24d532947a863f7ecaa", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 129, "deletions": 7, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -1,5 +1,5 @@\n /* Top-level LTO routines.\n-   Copyright (C) 2009-2018 Free Software Foundation, Inc.\n+   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n    Contributed by CodeSourcery, Inc.\n \n This file is part of GCC.\n@@ -56,6 +56,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"builtins.h\"\n #include \"lto-common.h\"\n+#include \"tree-pretty-print.h\"\n+\n+/* True when no new types are going to be streamd from the global stream.  */\n+\n+static bool type_streaming_finished = false;\n \n GTY(()) tree first_personality_decl;\n \n@@ -217,9 +222,14 @@ static hash_map<const_tree, hashval_t> *canonical_type_hash_cache;\n static unsigned long num_canonical_type_hash_entries;\n static unsigned long num_canonical_type_hash_queries;\n \n+/* Types postponed for registration to the canonical type table.\n+   During streaming we postpone all TYPE_CXX_ODR_P types so we can alter\n+   decide whether there is conflict with non-ODR type or not.  */\n+static GTY(()) vec<tree, va_gc> *types_to_register = NULL;\n+\n static void iterative_hash_canonical_type (tree type, inchash::hash &hstate);\n static hashval_t gimple_canonical_type_hash (const void *p);\n-static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n+static hashval_t gimple_register_canonical_type_1 (tree t, hashval_t hash);\n \n /* Returning a hash value for gimple type TYPE.\n \n@@ -357,9 +367,9 @@ iterative_hash_canonical_type (tree type, inchash::hash &hstate)\n \t optimal order.  To avoid quadratic behavior also register the\n \t type here.  */\n       v = hash_canonical_type (type);\n-      gimple_register_canonical_type_1 (type, v);\n+      v = gimple_register_canonical_type_1 (type, v);\n     }\n-  hstate.add_int (v);\n+  hstate.merge_hash (v);\n }\n \n /* Returns the hash for a canonical type P.  */\n@@ -388,7 +398,7 @@ gimple_canonical_type_eq (const void *p1, const void *p2)\n \n /* Main worker for gimple_register_canonical_type.  */\n \n-static void\n+static hashval_t\n gimple_register_canonical_type_1 (tree t, hashval_t hash)\n {\n   void **slot;\n@@ -397,6 +407,75 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n \t\t       && type_with_alias_set_p (t)\n \t\t       && canonical_type_used_p (t));\n \n+  /* ODR types for which there is no ODR violation and we did not record\n+     structurally equivalent non-ODR type can be treated as unique by their\n+     name.\n+\n+     hash passed to gimple_register_canonical_type_1 is a structural hash\n+     that we can use to lookup structurally equivalent non-ODR type.\n+     In case we decide to treat type as unique ODR type we recompute hash based\n+     on name and let TBAA machinery know about our decision.  */\n+  if (RECORD_OR_UNION_TYPE_P (t)\n+      && odr_type_p (t) && !odr_type_violation_reported_p (t))\n+    {\n+      /* Here we rely on fact that all non-ODR types was inserted into\n+\t canonical type hash and thus we can safely detect conflicts between\n+\t ODR types and interoperable non-ODR types.  */\n+      gcc_checking_assert (type_streaming_finished\n+\t\t\t   && TYPE_MAIN_VARIANT (t) == t);\n+      slot = htab_find_slot_with_hash (gimple_canonical_types, t, hash,\n+\t\t\t\t       NO_INSERT);\n+      if (slot && !TYPE_CXX_ODR_P (*(tree *)slot))\n+\t{\n+\t  tree nonodr = *(tree *)slot;\n+\t  if (symtab->dump_file)\n+\t    {\n+\t      fprintf (symtab->dump_file,\n+\t\t       \"ODR and non-ODR type conflict: \");\n+\t      print_generic_expr (symtab->dump_file, t);\n+\t      fprintf (symtab->dump_file, \" and \");\n+\t      print_generic_expr (symtab->dump_file, nonodr);\n+\t      fprintf (symtab->dump_file, \" mangled:%s\\n\",\n+\t\t\t IDENTIFIER_POINTER\n+\t\t\t   (DECL_ASSEMBLER_NAME (TYPE_NAME (t))));\n+\t    }\n+\t  /* Set canonical for T and all other ODR equivalent duplicates\n+\t     including incomplete structures.  */\n+\t  set_type_canonical_for_odr_type (t, nonodr);\n+\t}\n+      else\n+\t{\n+\t  tree prevail = prevailing_odr_type (t);\n+\n+\t  if (symtab->dump_file)\n+\t    {\n+\t      fprintf (symtab->dump_file,\n+\t\t       \"New canonical ODR type: \");\n+\t      print_generic_expr (symtab->dump_file, t);\n+\t      fprintf (symtab->dump_file, \" mangled:%s\\n\",\n+\t\t\t IDENTIFIER_POINTER\n+\t\t\t   (DECL_ASSEMBLER_NAME (TYPE_NAME (t))));\n+\t    }\n+\t  /* Set canonical for T and all other ODR equivalent duplicates\n+\t     including incomplete structures.  */\n+\t  set_type_canonical_for_odr_type (t, prevail);\n+\t  enable_odr_based_tbaa (t);\n+\t  if (!type_in_anonymous_namespace_p (t))\n+\t    hash = htab_hash_string (IDENTIFIER_POINTER\n+\t\t\t\t\t   (DECL_ASSEMBLER_NAME\n+\t\t\t\t\t\t   (TYPE_NAME (t))));\n+\t  else\n+\t    hash = TYPE_UID (t);\n+\n+\t  /* All variants of t now have TYPE_CANONICAL set to prevail.\n+\t     Update canonical type hash cache accordingly.  */\n+\t  num_canonical_type_hash_entries++;\n+\t  bool existed_p = canonical_type_hash_cache->put (prevail, hash);\n+\t  gcc_checking_assert (!existed_p);\n+\t}\n+      return hash;\n+    }\n+\n   slot = htab_find_slot_with_hash (gimple_canonical_types, t, hash, INSERT);\n   if (*slot)\n     {\n@@ -413,6 +492,7 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n       bool existed_p = canonical_type_hash_cache->put (t, hash);\n       gcc_assert (!existed_p);\n     }\n+  return hash;\n }\n \n /* Register type T in the global type table gimple_types and set\n@@ -464,6 +544,34 @@ lto_register_canonical_types (tree node, bool first_p)\n     gimple_register_canonical_type (node);\n }\n \n+/* Finish canonical type calculation: after all units has been streamed in we\n+   can check if given ODR type structurally conflicts with a non-ODR type.  In\n+   the first case we set type canonical according to the canonical type hash.\n+   In the second case we use type names.  */\n+\n+static void\n+lto_register_canonical_types_for_odr_types ()\n+{\n+  tree t;\n+  unsigned int i;\n+\n+  if (!types_to_register)\n+    return;\n+\n+  type_streaming_finished = true;\n+\n+  /* Be sure that no types derived from ODR types was\n+     not inserted into the hash table.  */\n+  if (flag_checking)\n+    FOR_EACH_VEC_ELT (*types_to_register, i, t)\n+      gcc_assert (!TYPE_CANONICAL (t));\n+\n+  /* Register all remaining types.  */\n+  FOR_EACH_VEC_ELT (*types_to_register, i, t)\n+    if (!TYPE_CANONICAL (t))\n+      gimple_register_canonical_type (t);\n+}\n+\n \n /* Remember trees that contains references to declarations.  */\n vec <tree, va_gc> *tree_with_vars;\n@@ -1657,6 +1765,7 @@ unify_scc (struct data_in *data_in, unsigned from,\n }\n \n \n+\n /* Read all the symbols from buffer DATA, using descriptors in DECL_DATA.\n    RESOLUTIONS is the set of symbols picked by the linker (read from the\n    resolution file when the linker plugin is being used).  */\n@@ -1749,12 +1858,23 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t  num_prevailing_types++;\n \t\t  lto_fixup_prevailing_type (t);\n \n-\t\t  /* Compute the canonical type of all types.\n+\t\t  /* Compute the canonical type of all non-ODR types.\n+\t\t     Delay ODR types for the end of merging process - the canonical\n+\t\t     type for those can be computed using the (unique) name however\n+\t\t     we want to do this only if units in other languages do not\n+\t\t     contain structurally equivalent type.\n+\n \t\t     Because SCC components are streamed in random (hash) order\n \t\t     we may have encountered the type before while registering\n \t\t     type canonical of a derived type in the same SCC.  */\n \t\t  if (!TYPE_CANONICAL (t))\n-\t\t    gimple_register_canonical_type (t);\n+\t\t    {\n+\t\t      if (!RECORD_OR_UNION_TYPE_P (t)\n+\t\t\t  || !TYPE_CXX_ODR_P (t))\n+\t\t        gimple_register_canonical_type (t);\n+\t\t      else if (COMPLETE_TYPE_P (t))\n+\t\t\tvec_safe_push (types_to_register, t);\n+\t\t    }\n \t\t  if (TYPE_MAIN_VARIANT (t) == t && odr_type_p (t))\n \t\t    register_odr_type (t);\n \t\t}\n@@ -2605,6 +2725,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   ggc_free(decl_data);\n   real_file_decl_data = NULL;\n \n+  lto_register_canonical_types_for_odr_types ();\n+\n   if (resolution_file_name)\n     fclose (resolution);\n "}, {"sha": "250efa3e072a4675c6c863591e39517f443717c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -1,3 +1,8 @@\n+2019-06-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* g++.dg/lto/alias-2_0.C: New testcase.\n+\t* g++.dg/lto/alias-2_1.C: New testcase.\n+\n 2019-06-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/90991"}, {"sha": "ef2d8f9279a08a722e6636de760187e9c38d0d52", "filename": "gcc/testsuite/g++.dg/lto/alias-2_0.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-2_0.C?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options { { -O2 -flto } } } */\n+\n+/* With LTO we consider all pointers to incomplete types to be possibly\n+   aliasing.  This makes *bptr to alias with aptr.\n+   For C++ ODR types we however can work out that they are actually\n+   different.  */\n+\n+#include <string.h>\n+\n+typedef int (*fnptr) ();\n+\n+__attribute__ ((used))\n+struct a *aptr;\n+\n+__attribute__ ((used))\n+struct b **bptr = (struct b**)&aptr;\n+extern void init ();\n+extern void inline_me_late (int);\n+\n+\n+int\n+main (int argc, char **argv)\n+{\n+  init ();\n+  aptr = 0;\n+  inline_me_late (argc);\n+  if (!__builtin_constant_p (aptr == 0))\n+    __builtin_abort ();\n+  return (size_t)aptr;\n+}"}, {"sha": "1cbebf1ef0d9db45e6660500f4bba31a8af76eda", "filename": "gcc/testsuite/g++.dg/lto/alias-2_1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-2_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-2_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-2_1.C?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -0,0 +1,16 @@\n+#include <string.h>\n+struct a {int a;} a;\n+struct b {int b;} b;\n+extern struct b **bptr;\n+void\n+inline_me_late (int argc)\n+{\n+  if (argc == -1)\n+    *bptr = (struct b *)(size_t)1;\n+}\n+void\n+init()\n+{\n+  a.a=1;\n+  b.b=2;\n+}"}, {"sha": "34912583bba4ebee064a9fb4349465d05abde6c2", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0276c00934da47fa511aa52e1973b68ffd8b2ab/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a0276c00934da47fa511aa52e1973b68ffd8b2ab", "patch": "@@ -14101,6 +14101,7 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n \n   gcc_assert (!trust_type_canonical\n \t      || (type_with_alias_set_p (t1) && type_with_alias_set_p (t2)));\n+\n   /* If the types have been previously registered and found equal\n      they still are.  */\n \n@@ -14118,6 +14119,14 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n       return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n     }\n \n+  /* For types where we do ODR based TBAA the canonical type is always\n+     set correctly, so we know that types are different if their\n+     canonical types does not match.  */\n+  if (trust_type_canonical\n+      && (odr_type_p (t1) && odr_based_tbaa_p (t1))\n+\t  != (odr_type_p (t2) && odr_based_tbaa_p (t2)))\n+    return false;\n+\n   /* Can't be the same type if the types don't have the same code.  */\n   enum tree_code code = tree_code_for_canonical_type_merging (TREE_CODE (t1));\n   if (code != tree_code_for_canonical_type_merging (TREE_CODE (t2)))"}]}