{"sha": "ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQwNzFiMmI2MzhlYWMzMDM4ZGJkNmYxMmRlYTdjMjFmYmJmZTg2Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-06-10T16:23:06Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-06-10T16:23:06Z"}, "message": "re PR tree-optimization/71335 (wrong code at -O2 and -O3 in 32-bit and 64-bit modes on x86_64-linux-gnu)\n\n\tPR tree-optimization/71335\n\t* tree-ssa-threadbackward.c (profitable_jump_thread_path): Filter out\n\tzero length paths here.\n\t(convert_and_register_jump_thread_path): Remove hacks related to\n\tduplicated blocks in the jump thread path.\n\t(fsm_find_control_statement_thread_paths): Avoid putting the same\n\tblock on the thread path twice, but ensure the thread path is\n\tunchanged from the caller's point of view.\n\n\tPR tree-optimization/71335\n\t* gcc.c-torture/execute/pr71335.c: New test.\n\nFrom-SVN: r237312", "tree": {"sha": "57be0b488c2eba0366c07cbc9967b5f47936899a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57be0b488c2eba0366c07cbc9967b5f47936899a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/comments", "author": null, "committer": null, "parents": [{"sha": "66b4d2611346c270f63a49b778bef0be28f95ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66b4d2611346c270f63a49b778bef0be28f95ccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66b4d2611346c270f63a49b778bef0be28f95ccb"}], "stats": {"total": 73, "additions": 51, "deletions": 22}, "files": [{"sha": "bd9476ea93122525da9e43a6739b0e2444fb8709", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "patch": "@@ -1,3 +1,14 @@\n+2016-06-10  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/71335\n+\t* tree-ssa-threadbackward.c (profitable_jump_thread_path): Filter out\n+\tzero length paths here.\n+\t(convert_and_register_jump_thread_path): Remove hacks related to\n+\tduplicated blocks in the jump thread path.\n+\t(fsm_find_control_statement_thread_paths): Avoid putting the same\n+\tblock on the thread path twice, but ensure the thread path is\n+\tunchanged from the caller's point of view.\n+\t\n 2016-06-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* predict.c (predict_loops): Remove PRED_LOOP_BRANCH."}, {"sha": "b76e477d3e5ebcab9111ab225cf74c9a3ac087aa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "patch": "@@ -1,3 +1,8 @@\n+2016-06-10  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/71335\n+\t* gcc.c-torture/execute/pr71335.c: New test.\n+\n 2016-06-10  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/must-tail-call-2.c: Remove all details from"}, {"sha": "cbfd99083d072d9fb16ae2c8c754b079d5df260f", "filename": "gcc/testsuite/gcc.c-torture/execute/pr71335.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr71335.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr71335.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr71335.c?ref=ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "patch": "@@ -0,0 +1,13 @@\n+int a;\n+int\n+main ()\n+{\n+  int b = 0;\n+  while (a < 0 || b)\n+    {\n+      b = 0;\n+      for (; b < 9; b++)\n+\t;\n+    }\n+  exit (0);\n+}"}, {"sha": "139d376d1cb90bd2e3ce2c6d3c6eb1f7c9b41d34", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad071b2b638eac3038dbd6f12dea7c21fbbfe863/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=ad071b2b638eac3038dbd6f12dea7c21fbbfe863", "patch": "@@ -109,6 +109,19 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n   /* Note BBI is not in the path yet, hence the +1 in the test below\n      to make sure BBI is accounted for in the path length test.  */\n   int path_length = path->length ();\n+\n+  /* We can get a length of 0 here when the statement that\n+     makes a conditional generate a compile-time constant\n+     result is in the same block as the conditional.\n+\n+     That's not really a jump threading opportunity, but instead is\n+     simple cprop & simplification.  We could handle it here if we\n+     wanted by wiring up all the incoming edges.  If we run this\n+     early in IPA, that might be worth doing.   For now we just\n+     reject that case.  */\n+  if (path_length == 0)\n+      return NULL;\n+\n   if (path_length + 1 > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -376,34 +389,12 @@ convert_and_register_jump_thread_path (vec<basic_block, va_gc> *&path,\n       basic_block bb1 = (*path)[path->length () - j - 1];\n       basic_block bb2 = (*path)[path->length () - j - 2];\n \n-      /* This can happen when we have an SSA_NAME as a PHI argument and\n-\t its initialization block is the head of the PHI argument's\n-\t edge.  */\n-      if (bb1 == bb2)\n-\tcontinue;\n-\n       edge e = find_edge (bb1, bb2);\n       gcc_assert (e);\n       jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n       jump_thread_path->safe_push (x);\n     }\n \n-  /* As a consequence of the test for duplicate blocks in the path\n-     above, we can get a path with no blocks.  This happens if a\n-     conditional can be fully evaluated at compile time using just\n-     defining statements in the same block as the test.\n-\n-     When we no longer push the block associated with a PHI argument\n-     onto the stack, then this as well as the test in the loop above\n-     can be removed.  */\n-  if (jump_thread_path->length () == 0)\n-    {\n-      jump_thread_path->release ();\n-      delete jump_thread_path;\n-      path->pop ();\n-      return;\n-    }\n-\n   /* Add the edge taken when the control variable has value ARG.  */\n   jump_thread_edge *x\n     = new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n@@ -579,10 +570,19 @@ fsm_find_control_statement_thread_paths (tree name,\n \n       else\n \t{\n+\t  /* profitable_jump_thread_path is going to push the current\n+\t     block onto the path.  But the path will always have the current\n+\t     block at this point.  So we can just pop it.  */\n+\t  path->pop ();\n+\n \t  edge taken_edge = profitable_jump_thread_path (path, var_bb,\n \t\t\t\t\t\t     name, arg);\n \t  if (taken_edge)\n \t    convert_and_register_jump_thread_path (path, taken_edge);\n+\n+\t  /* And put the current block back onto the path so that the\n+\t     state of the stack is unchanged when we leave.  */\n+\t  vec_safe_push (path, var_bb);\n \t}\n     }\n "}]}