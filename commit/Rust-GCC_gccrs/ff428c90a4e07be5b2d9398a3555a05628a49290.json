{"sha": "ff428c90a4e07be5b2d9398a3555a05628a49290", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY0MjhjOTBhNGUwN2JlNWIyZDkzOThhMzU1NWEwNTYyOGE0OTI5MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-10-23T22:01:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-10-23T22:01:23Z"}, "message": "Accept a unary operator in find_reloads\n\nFrom-SVN: r13016", "tree": {"sha": "3719bb68e505390f4d90896ae31094e96f0d09df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3719bb68e505390f4d90896ae31094e96f0d09df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff428c90a4e07be5b2d9398a3555a05628a49290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff428c90a4e07be5b2d9398a3555a05628a49290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff428c90a4e07be5b2d9398a3555a05628a49290", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff428c90a4e07be5b2d9398a3555a05628a49290/comments", "author": null, "committer": null, "parents": [{"sha": "1e1eb6c543d54c116cfe44eb1defeb5ea46e5d71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1eb6c543d54c116cfe44eb1defeb5ea46e5d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1eb6c543d54c116cfe44eb1defeb5ea46e5d71"}], "stats": {"total": 12, "additions": 9, "deletions": 3}, "files": [{"sha": "049c3a008b25f1d4fcf86e236308165c63adf777", "filename": "gcc/reload.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff428c90a4e07be5b2d9398a3555a05628a49290/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff428c90a4e07be5b2d9398a3555a05628a49290/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ff428c90a4e07be5b2d9398a3555a05628a49290", "patch": "@@ -2533,9 +2533,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t ind_levels,\n \t\t\t\t set != 0\n \t\t\t\t && &SET_DEST (set) == recog_operand_loc[i]);\n-      else if (code == PLUS)\n-\t/* We can get a PLUS as an \"operand\" as a result of\n-\t   register elimination.  See eliminate_regs and gen_reload.  */\n+      else if (code == PLUS || GET_RTX_CLASS (code) == '1')\n+\t/* We can get a PLUS as an \"operand\" as a result of register\n+\t   elimination.  See eliminate_regs and gen_reload.  We handle\n+\t   a unary operator by reloading the operand.  */\n \tsubsted_operand[i] = recog_operand[i] = *recog_operand_loc[i]\n \t  = find_reloads_toplev (recog_operand[i], i, address_type[i],\n \t\t\t\t ind_levels, 0);\n@@ -2674,6 +2675,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  int constmemok = 0;\n \t  int earlyclobber = 0;\n \n+\t  /* If the predicate accepts a unary operator, it means that\n+             we need to reload the operand.  */\n+\t  if (GET_RTX_CLASS (GET_CODE (operand)) == '1')\n+\t    operand = XEXP (operand, 0);\n+\n \t  /* If the operand is a SUBREG, extract\n \t     the REG or MEM (or maybe even a constant) within.\n \t     (Constants can occur as a result of reg_equiv_constant.)  */"}]}