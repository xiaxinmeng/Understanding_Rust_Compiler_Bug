{"sha": "fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQxOGM3NmFjOGM4NTk3NmJkN2ZlNDEzYWNhMmMyNjI5NmNhNmQ1NA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-09-09T17:29:32Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-09-09T17:29:32Z"}, "message": "Make std::deque meet C++11 allocator requirements.\n\n\t* include/bits/deque.tcc (deque::operator=(const deque&)): Handle\n\tallocator propagation.\n\t(deque::emplace_front, deque::emplace_back): Use allocator traits.\n\t(deque::_M_push_back_aux, deque::_M_push_front_aux): Likewise.\n\t(deque::_M_pop_back_aux, deque::_M_pop_front_aux): Likewise.\n\t* include/bits/stl_deque.h (__deque_buf_size): Add constexpr.\n\t(_Deque_iterator): Handle allocators with custom pointers.\n\t(_Deque_base): Likewise. Use allocator traits.\n\t(deque): Likewise. Add allocator-extended constructors.\n\t(deque::_M_move_assign1, deque::_M_move_assign2): Implement move\n\tassignment via tag dispatching.\n\t(deque::_M_replace_map): Replace existing data.\n\t* include/debug/deque (deque): Add allocator-extended constructors.\n\t* include/profile/deque (deque): Likewise.\n\t* testsuite/23_containers/deque/allocator/copy.cc: New.\n\t* testsuite/23_containers/deque/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/deque/allocator/ext_ptr.cc: New.\n\t* testsuite/23_containers/deque/allocator/minimal.cc: New.\n\t* testsuite/23_containers/deque/allocator/move.cc: New.\n\t* testsuite/23_containers/deque/allocator/move_assign-2.cc: New.\n\t* testsuite/23_containers/deque/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/deque/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/deque/allocator/swap.cc: New.\n\t* testsuite/23_containers/deque/requirements/dr438/assign_neg.cc:\n\tAdjust dg-error line number.\n\t* testsuite/23_containers/deque/requirements/dr438/\n\tconstructor_1_neg.cc: Likewise.\n\t* testsuite/23_containers/deque/requirements/dr438/\n\tconstructor_2_neg.cc: Likewise.\n\t* testsuite/23_containers/deque/requirements/dr438/insert_neg.cc:\n\tLikewise.\n\t* testsuite/23_containers/vector/52591.cc: Test both the propagating\n\tand always-equal cases.\n\nFrom-SVN: r215090", "tree": {"sha": "55818653d7216532f7c0186498ada0fe0a1ece63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55818653d7216532f7c0186498ada0fe0a1ece63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8a54173bc7575981beaa9ccd44400c085ed74ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8a54173bc7575981beaa9ccd44400c085ed74ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8a54173bc7575981beaa9ccd44400c085ed74ff"}], "stats": {"total": 1033, "additions": 938, "deletions": 95}, "files": [{"sha": "a5acf92b2dc04de53d79299856f86bcbe011c3e7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -1,3 +1,39 @@\n+2014-09-09  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/deque.tcc (deque::operator=(const deque&)): Handle\n+\tallocator propagation.\n+\t(deque::emplace_front, deque::emplace_back): Use allocator traits.\n+\t(deque::_M_push_back_aux, deque::_M_push_front_aux): Likewise.\n+\t(deque::_M_pop_back_aux, deque::_M_pop_front_aux): Likewise.\n+\t* include/bits/stl_deque.h (__deque_buf_size): Add constexpr.\n+\t(_Deque_iterator): Handle allocators with custom pointers.\n+\t(_Deque_base): Likewise. Use allocator traits.\n+\t(deque): Likewise. Add allocator-extended constructors.\n+\t(deque::_M_move_assign1, deque::_M_move_assign2): Implement move\n+\tassignment via tag dispatching.\n+\t(deque::_M_replace_map): Replace existing data.\n+\t* include/debug/deque (deque): Add allocator-extended constructors.\n+\t* include/profile/deque (deque): Likewise.\n+\t* testsuite/23_containers/deque/allocator/copy.cc: New.\n+\t* testsuite/23_containers/deque/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/deque/allocator/ext_ptr.cc: New.\n+\t* testsuite/23_containers/deque/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/deque/allocator/move.cc: New.\n+\t* testsuite/23_containers/deque/allocator/move_assign-2.cc: New.\n+\t* testsuite/23_containers/deque/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/deque/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/deque/allocator/swap.cc: New.\n+\t* testsuite/23_containers/deque/requirements/dr438/assign_neg.cc:\n+\tAdjust dg-error line number.\n+\t* testsuite/23_containers/deque/requirements/dr438/\n+\tconstructor_1_neg.cc: Likewise.\n+\t* testsuite/23_containers/deque/requirements/dr438/\n+\tconstructor_2_neg.cc: Likewise.\n+\t* testsuite/23_containers/deque/requirements/dr438/insert_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/vector/52591.cc: Test both the propagating\n+\tand always-equal cases.\n+\n 2014-09-06  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/bits/hashtable_policy.h (_Prime_rehash_policy): Constructor"}, {"sha": "9c8dd36f1f5590a3d620777857e2e3c0e54df730", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -92,9 +92,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     deque<_Tp, _Alloc>::\n     operator=(const deque& __x)\n     {\n-      const size_type __len = size();\n       if (&__x != this)\n \t{\n+#if __cplusplus >= 201103L\n+\t  if (_Alloc_traits::_S_propagate_on_copy_assign())\n+\t    {\n+\t      if (!_Alloc_traits::_S_always_equal()\n+\t          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())\n+\t        {\n+\t\t  // Replacement allocator cannot free existing storage,\n+\t\t  // so deallocate everything and take copy of __x's data.\n+\t\t  _M_replace_map(__x, __x.get_allocator());\n+\t\t  std::__alloc_on_copy(_M_get_Tp_allocator(),\n+\t\t\t\t       __x._M_get_Tp_allocator());\n+\t\t  return *this;\n+\t\t}\n+\t      std::__alloc_on_copy(_M_get_Tp_allocator(),\n+\t\t\t\t   __x._M_get_Tp_allocator());\n+\t    }\n+#endif\n+\t  const size_type __len = size();\n \t  if (__len >= __x.size())\n \t    _M_erase_at_end(std::copy(__x.begin(), __x.end(),\n \t\t\t\t      this->_M_impl._M_start));\n@@ -117,8 +134,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       {\n \tif (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)\n \t  {\n-\t    this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1,\n-\t\t\t\t    std::forward<_Args>(__args)...);\n+\t    _Alloc_traits::construct(this->_M_impl,\n+\t                             this->_M_impl._M_start._M_cur - 1,\n+\t\t\t             std::forward<_Args>(__args)...);\n \t    --this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n@@ -134,8 +152,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tif (this->_M_impl._M_finish._M_cur\n \t    != this->_M_impl._M_finish._M_last - 1)\n \t  {\n-\t    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,\n-\t\t\t\t    std::forward<_Args>(__args)...);\n+\t    _Alloc_traits::construct(this->_M_impl,\n+\t                             this->_M_impl._M_finish._M_cur,\n+\t\t\t             std::forward<_Args>(__args)...);\n \t    ++this->_M_impl._M_finish._M_cur;\n \t  }\n \telse\n@@ -453,8 +472,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t__try\n \t  {\n #if __cplusplus >= 201103L\n-\t    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,\n-\t\t\t\t    std::forward<_Args>(__args)...);\n+\t    _Alloc_traits::construct(this->_M_impl,\n+\t                             this->_M_impl._M_finish._M_cur,\n+\t\t\t             std::forward<_Args>(__args)...);\n #else\n \t    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);\n #endif\n@@ -490,8 +510,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t\t\t       - 1);\n \t    this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;\n #if __cplusplus >= 201103L\n-\t    this->_M_impl.construct(this->_M_impl._M_start._M_cur,\n-\t\t\t\t    std::forward<_Args>(__args)...);\n+\t    _Alloc_traits::construct(this->_M_impl,\n+\t                             this->_M_impl._M_start._M_cur,\n+\t\t\t             std::forward<_Args>(__args)...);\n #else\n \t    this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);\n #endif\n@@ -512,7 +533,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_deallocate_node(this->_M_impl._M_finish._M_first);\n       this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);\n       this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;\n-      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);\n+      _Alloc_traits::destroy(_M_get_Tp_allocator(),\n+\t\t\t     this->_M_impl._M_finish._M_cur);\n     }\n \n   // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.\n@@ -524,7 +546,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     void deque<_Tp, _Alloc>::\n     _M_pop_front_aux()\n     {\n-      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);\n+      _Alloc_traits::destroy(_M_get_Tp_allocator(),\n+\t\t\t     this->_M_impl._M_start._M_cur);\n       _M_deallocate_node(this->_M_impl._M_start._M_first);\n       this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);\n       this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;"}, {"sha": "acb7715f71773e5c89e641ae9a452b5769402a98", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 242, "deletions": 74, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -85,7 +85,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #define _GLIBCXX_DEQUE_BUF_SIZE 512\n #endif\n \n-  inline size_t\n+  _GLIBCXX_CONSTEXPR inline size_t\n   __deque_buf_size(size_t __size)\n   { return (__size < _GLIBCXX_DEQUE_BUF_SIZE\n \t    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }\n@@ -105,8 +105,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     struct _Deque_iterator\n     {\n+#if __cplusplus < 201103L\n       typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n       typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n+      typedef _Tp*                                         _Elt_pointer;\n+      typedef _Tp**                                        _Map_pointer;\n+#else\n+    private:\n+      template<typename _Up>\n+\tusing __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;\n+      template<typename _CvTp>\n+\tusing __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;\n+    public:\n+      typedef __iter<_Tp>\t\titerator;\n+      typedef __iter<const _Tp>\t\tconst_iterator;\n+      typedef __ptr_to<_Tp>\t\t_Elt_pointer;\n+      typedef __ptr_to<_Elt_pointer>\t_Map_pointer;\n+#endif\n \n       static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT\n       { return __deque_buf_size(sizeof(_Tp)); }\n@@ -117,20 +132,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef _Ref                            reference;\n       typedef size_t                          size_type;\n       typedef ptrdiff_t                       difference_type;\n-      typedef _Tp**                           _Map_pointer;\n       typedef _Deque_iterator                 _Self;\n \n-      _Tp* _M_cur;\n-      _Tp* _M_first;\n-      _Tp* _M_last;\n+      _Elt_pointer _M_cur;\n+      _Elt_pointer _M_first;\n+      _Elt_pointer _M_last;\n       _Map_pointer _M_node;\n \n-      _Deque_iterator(_Tp* __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT\n+      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT\n       : _M_cur(__x), _M_first(*__y),\n         _M_last(*__y + _S_buffer_size()), _M_node(__y) { }\n \n       _Deque_iterator() _GLIBCXX_NOEXCEPT\n-      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }\n+      : _M_cur(), _M_first(), _M_last(), _M_node() { }\n \n       _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT\n       : _M_cur(__x._M_cur), _M_first(__x._M_first),\n@@ -443,15 +457,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc>\n     class _Deque_base\n     {\n+    protected:\n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+\trebind<_Tp>::other _Tp_alloc_type;\n+      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>\t _Alloc_traits;\n+\n+#if __cplusplus < 201103L\n+      typedef _Tp*\t\t\t\t\t_Ptr;\n+      typedef const _Tp*\t\t\t\t_Ptr_const;\n+#else\n+      typedef typename _Alloc_traits::pointer\t\t_Ptr;\n+      typedef typename _Alloc_traits::const_pointer\t_Ptr_const;\n+#endif\n+\n+      typedef typename _Alloc_traits::template rebind<_Ptr>::other\n+\t_Map_alloc_type;\n+      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;\n+\n     public:\n       typedef _Alloc                  allocator_type;\n+      typedef typename _Alloc_traits::size_type size_type;\n \n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n       { return allocator_type(_M_get_Tp_allocator()); }\n \n-      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n-      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n+      typedef _Deque_iterator<_Tp, _Tp&, _Ptr>          iterator;\n+      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;\n \n       _Deque_base()\n       : _M_impl()\n@@ -467,57 +499,87 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       _Deque_base(const allocator_type& __a)\n       : _M_impl(__a)\n-      { }\n+      { /* Caller must initialize map. */ }\n \n #if __cplusplus >= 201103L\n       _Deque_base(_Deque_base&& __x)\n       : _M_impl(std::move(__x._M_get_Tp_allocator()))\n       {\n-\t_M_initialize_map(0);\n \tif (__x._M_impl._M_map)\n \t  {\n-\t    std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n-\t    std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n-\t    std::swap(this->_M_impl._M_map, __x._M_impl._M_map);\n-\t    std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);\n+\t    this->_M_impl._M_swap_data(__x._M_impl);\n+\t    __try\n+\t      {\n+\t\t// Re-initialize __x using its moved-from allocator.\n+\t\t__x._M_initialize_map(0);\n+\t      }\n+\t    __catch (...)\n+\t      {\n+\t\tthis->_M_impl._M_swap_data(__x._M_impl);\n+\t\t__x._M_get_Tp_allocator() = std::move(_M_get_Tp_allocator());\n+\t\t__throw_exception_again;\n+\t      }\n+\t  }\n+      }\n+\n+      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)\n+      : _M_impl(__a)\n+      {\n+\tif (__x.get_allocator() == __a)\n+\t  {\n+\t    if (__x._M_impl._M_map)\n+\t      {\n+\t\t_M_initialize_map(0);\n+\t\tthis->_M_impl._M_swap_data(__x._M_impl);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    _M_initialize_map(__n);\n \t  }\n       }\n #endif\n \n       ~_Deque_base() _GLIBCXX_NOEXCEPT;\n \n     protected:\n-      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n-\n-      typedef typename _Alloc::template rebind<_Tp>::other  _Tp_alloc_type;\n+      typedef typename iterator::_Map_pointer _Map_pointer;\n \n       //This struct encapsulates the implementation of the std::deque\n       //standard container and at the same time makes use of the EBO\n       //for empty allocators.\n       struct _Deque_impl\n       : public _Tp_alloc_type\n       {\n-\t_Tp** _M_map;\n+\t_Map_pointer _M_map;\n \tsize_t _M_map_size;\n \titerator _M_start;\n \titerator _M_finish;\n \n \t_Deque_impl()\n-\t: _Tp_alloc_type(), _M_map(0), _M_map_size(0),\n+\t: _Tp_alloc_type(), _M_map(), _M_map_size(0),\n \t  _M_start(), _M_finish()\n \t{ }\n \n \t_Deque_impl(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT\n-\t: _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),\n+\t: _Tp_alloc_type(__a), _M_map(), _M_map_size(0),\n \t  _M_start(), _M_finish()\n \t{ }\n \n #if __cplusplus >= 201103L\n \t_Deque_impl(_Tp_alloc_type&& __a) _GLIBCXX_NOEXCEPT\n-\t: _Tp_alloc_type(std::move(__a)), _M_map(0), _M_map_size(0),\n+\t: _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),\n \t  _M_start(), _M_finish()\n \t{ }\n #endif\n+\n+\tvoid _M_swap_data(_Deque_impl& __x)\n+\t{\n+\t  std::swap(this->_M_start, __x._M_start);\n+\t  std::swap(this->_M_finish, __x._M_finish);\n+\t  std::swap(this->_M_map, __x._M_map);\n+\t  std::swap(this->_M_map_size, __x._M_map_size);\n+\t}\n       };\n \n       _Tp_alloc_type&\n@@ -532,30 +594,39 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_get_map_allocator() const _GLIBCXX_NOEXCEPT\n       { return _Map_alloc_type(_M_get_Tp_allocator()); }\n \n-      _Tp*\n+      _Ptr\n       _M_allocate_node()\n       { \n-\treturn _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));\n+\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;\n+\treturn _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));\n       }\n \n       void\n-      _M_deallocate_node(_Tp* __p) _GLIBCXX_NOEXCEPT\n+      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT\n       {\n-\t_M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n+\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;\n+\t_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));\n       }\n \n-      _Tp**\n+      _Map_pointer\n       _M_allocate_map(size_t __n)\n-      { return _M_get_map_allocator().allocate(__n); }\n+      {\n+\t_Map_alloc_type __map_alloc = _M_get_map_allocator();\n+\treturn _Map_alloc_traits::allocate(__map_alloc, __n);\n+      }\n \n       void\n-      _M_deallocate_map(_Tp** __p, size_t __n) _GLIBCXX_NOEXCEPT\n-      { _M_get_map_allocator().deallocate(__p, __n); }\n+      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT\n+      {\n+\t_Map_alloc_type __map_alloc = _M_get_map_allocator();\n+\t_Map_alloc_traits::deallocate(__map_alloc, __p, __n);\n+      }\n \n     protected:\n       void _M_initialize_map(size_t);\n-      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n-      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT;\n+      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);\n+      void _M_destroy_nodes(_Map_pointer __nstart,\n+\t\t\t    _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT;\n       enum { _S_initial_map_size = 8 };\n \n       _Deque_impl _M_impl;\n@@ -576,7 +647,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   /**\n    *  @brief Layout storage.\n    *  @param  __num_elements  The count of T's for which to allocate space\n-   *                        at first.\n+   *                          at first.\n    *  @return   Nothing.\n    *\n    *  The initial underlying memory layout is a bit complicated...\n@@ -598,16 +669,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // the beginning of _M_map, but for small maps it may be as far in as\n       // _M_map+3.\n \n-      _Tp** __nstart = (this->_M_impl._M_map\n-\t\t\t+ (this->_M_impl._M_map_size - __num_nodes) / 2);\n-      _Tp** __nfinish = __nstart + __num_nodes;\n+      _Map_pointer __nstart = (this->_M_impl._M_map\n+\t\t\t       + (this->_M_impl._M_map_size - __num_nodes) / 2);\n+      _Map_pointer __nfinish = __nstart + __num_nodes;\n \n       __try\n \t{ _M_create_nodes(__nstart, __nfinish); }\n       __catch(...)\n \t{\n \t  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);\n-\t  this->_M_impl._M_map = 0;\n+\t  this->_M_impl._M_map = _Map_pointer();\n \t  this->_M_impl._M_map_size = 0;\n \t  __throw_exception_again;\n \t}\n@@ -623,9 +694,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc>\n     void\n     _Deque_base<_Tp, _Alloc>::\n-    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n+    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)\n     {\n-      _Tp** __cur;\n+      _Map_pointer __cur;\n       __try\n \t{\n \t  for (__cur = __nstart; __cur < __nfinish; ++__cur)\n@@ -641,9 +712,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc>\n     void\n     _Deque_base<_Tp, _Alloc>::\n-    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish) _GLIBCXX_NOEXCEPT\n+    _M_destroy_nodes(_Map_pointer __nstart,\n+\t\t     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT\n     {\n-      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)\n+      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)\n \t_M_deallocate_node(*__n);\n     }\n \n@@ -739,15 +811,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n \n-      typedef _Deque_base<_Tp, _Alloc>           _Base;\n-      typedef typename _Base::_Tp_alloc_type\t _Tp_alloc_type;\n+      typedef _Deque_base<_Tp, _Alloc>\t\t\t_Base;\n+      typedef typename _Base::_Tp_alloc_type\t\t_Tp_alloc_type;\n+      typedef typename _Base::_Alloc_traits\t\t_Alloc_traits;\n+      typedef typename _Base::_Map_pointer\t\t_Map_pointer;\n \n     public:\n       typedef _Tp                                        value_type;\n-      typedef typename _Tp_alloc_type::pointer           pointer;\n-      typedef typename _Tp_alloc_type::const_pointer     const_pointer;\n-      typedef typename _Tp_alloc_type::reference         reference;\n-      typedef typename _Tp_alloc_type::const_reference   const_reference;\n+      typedef typename _Alloc_traits::pointer            pointer;\n+      typedef typename _Alloc_traits::const_pointer      const_pointer;\n+      typedef typename _Alloc_traits::reference          reference;\n+      typedef typename _Alloc_traits::const_reference    const_reference;\n       typedef typename _Base::iterator                   iterator;\n       typedef typename _Base::const_iterator             const_iterator;\n       typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n@@ -757,8 +831,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef _Alloc                             allocator_type;\n \n     protected:\n-      typedef pointer*                           _Map_pointer;\n-\n       static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT\n       { return __deque_buf_size(sizeof(_Tp)); }\n \n@@ -804,8 +876,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  constructed elements.\n        */\n       explicit\n-      deque(size_type __n)\n-      : _Base(__n)\n+      deque(size_type __n, const allocator_type& __a = allocator_type())\n+      : _Base(__a, __n)\n       { _M_default_initialize(); }\n \n       /**\n@@ -844,7 +916,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  by @a __x.\n        */\n       deque(const deque& __x)\n-      : _Base(__x._M_get_Tp_allocator(), __x.size())\n+      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),\n+\t      __x.size())\n       { std::__uninitialized_copy_a(__x.begin(), __x.end(), \n \t\t\t\t    this->_M_impl._M_start,\n \t\t\t\t    _M_get_Tp_allocator()); }\n@@ -860,6 +933,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       deque(deque&& __x)\n       : _Base(std::move(__x)) { }\n \n+      /// Copy constructor with alternative allocator\n+      deque(const deque& __x, const allocator_type& __a)\n+      : _Base(__a, __x.size())\n+      { std::__uninitialized_copy_a(__x.begin(), __x.end(),\n+\t\t\t\t    this->_M_impl._M_start,\n+\t\t\t\t    _M_get_Tp_allocator()); }\n+\n+      /// Move constructor with alternative allocator\n+      deque(deque&& __x, const allocator_type& __a)\n+      : _Base(std::move(__x), __a, __x.size())\n+      {\n+\tif (__x.get_allocator() != __a)\n+\t  {\n+\t    std::__uninitialized_move_a(__x.begin(), __x.end(),\n+\t\t\t\t\tthis->_M_impl._M_start,\n+\t\t\t\t\t_M_get_Tp_allocator());\n+\t    __x.clear();\n+\t  }\n+      }\n+\n       /**\n        *  @brief  Builds a %deque from an initializer list.\n        *  @param  __l  An initializer_list.\n@@ -919,7 +1012,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  themselves are pointers, the pointed-to memory is not touched in any\n        *  way.  Managing the pointer is the user's responsibility.\n        */\n-      ~deque() _GLIBCXX_NOEXCEPT\n+      ~deque()\n       { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }\n \n       /**\n@@ -937,16 +1030,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @brief  %Deque move assignment operator.\n        *  @param  __x  A %deque of identical element and allocator types.\n        *\n-       *  The contents of @a __x are moved into this deque (without copying).\n+       *  The contents of @a __x are moved into this deque (without copying,\n+       *  if the allocators permit it).\n        *  @a __x is a valid, but unspecified %deque.\n        */\n       deque&\n-      operator=(deque&& __x) noexcept\n+      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n+\tconstexpr bool __always_equal = _Alloc_traits::_S_always_equal();\n+\t_M_move_assign1(std::move(__x),\n+\t\t        integral_constant<bool, __always_equal>());\n \treturn *this;\n       }\n \n@@ -1150,7 +1243,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       /**  Returns the size() of the largest possible %deque.  */\n       size_type\n       max_size() const _GLIBCXX_NOEXCEPT\n-      { return _M_get_Tp_allocator().max_size(); }\n+      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -1368,7 +1461,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       {\n \tif (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)\n \t  {\n-\t    this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);\n+\t    _Alloc_traits::construct(this->_M_impl,\n+\t                             this->_M_impl._M_start._M_cur - 1,\n+\t                             __x);\n \t    --this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n@@ -1400,7 +1495,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tif (this->_M_impl._M_finish._M_cur\n \t    != this->_M_impl._M_finish._M_last - 1)\n \t  {\n-\t    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);\n+\t    _Alloc_traits::construct(this->_M_impl,\n+\t                             this->_M_impl._M_finish._M_cur, __x);\n \t    ++this->_M_impl._M_finish._M_cur;\n \t  }\n \telse\n@@ -1431,7 +1527,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tif (this->_M_impl._M_start._M_cur\n \t    != this->_M_impl._M_start._M_last - 1)\n \t  {\n-\t    this->_M_impl.destroy(this->_M_impl._M_start._M_cur);\n+\t    _Alloc_traits::destroy(this->_M_impl,\n+\t                           this->_M_impl._M_start._M_cur);\n \t    ++this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n@@ -1453,7 +1550,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    != this->_M_impl._M_finish._M_first)\n \t  {\n \t    --this->_M_impl._M_finish._M_cur;\n-\t    this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);\n+\t    _Alloc_traits::destroy(this->_M_impl,\n+\t                           this->_M_impl._M_finish._M_cur);\n \t  }\n \telse\n \t  _M_pop_back_aux();\n@@ -1659,17 +1757,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  std::swap(d1,d2) will feed to this function.\n        */\n       void\n-      swap(deque& __x) _GLIBCXX_NOEXCEPT\n+      swap(deque& __x)\n+#if __cplusplus >= 201103L\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n+#endif\n       {\n-\tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n-\tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n-\tstd::swap(this->_M_impl._M_map, __x._M_impl._M_map);\n-\tstd::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);\n-\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 431. Swapping containers with unequal allocators.\n-\tstd::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),\n-\t\t\t\t\t\t    __x._M_get_Tp_allocator());\n+\t_M_impl._M_swap_data(__x._M_impl);\n+\t_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),\n+\t\t\t\t  __x._M_get_Tp_allocator());\n       }\n \n       /**\n@@ -2011,6 +2106,79 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       void\n       _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n       //@}\n+\n+#if __cplusplus >= 201103L\n+      // Constant-time, nothrow move assignment when source object's memory\n+      // can be moved because the allocators are equal.\n+      void\n+      _M_move_assign1(deque&& __x, /* always equal: */ true_type) noexcept\n+      {\n+\tthis->_M_impl._M_swap_data(__x._M_impl);\n+\t__x.clear();\n+\tstd::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());\n+      }\n+\n+      void\n+      _M_move_assign1(deque&& __x, /* always equal: */ false_type)\n+      {\n+\tconstexpr bool __move_storage =\n+\t  _Alloc_traits::_S_propagate_on_move_assign();\n+\t_M_move_assign2(std::move(__x),\n+\t\t\tintegral_constant<bool, __move_storage>());\n+      }\n+\n+      // Destroy all elements and deallocate all memory, then replace\n+      // with elements created from __args.\n+      template<typename... _Args>\n+      void\n+      _M_replace_map(_Args&&... __args)\n+      {\n+\t// Create new data first, so if allocation fails there are no effects.\n+\tdeque __newobj(std::forward<_Args>(__args)...);\n+\t// Free existing storage using existing allocator.\n+\tclear();\n+\t_M_deallocate_node(*begin()._M_node); // one node left after clear()\n+\t_M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);\n+\tthis->_M_impl._M_map = nullptr;\n+\tthis->_M_impl._M_map_size = 0;\n+\t// Take ownership of replacement memory.\n+\tthis->_M_impl._M_swap_data(__newobj._M_impl);\n+      }\n+\n+      // Do move assignment when the allocator propagates.\n+      void\n+      _M_move_assign2(deque&& __x, /* propagate: */ true_type)\n+      {\n+\t// Make a copy of the original allocator state.\n+\tauto __alloc = __x._M_get_Tp_allocator();\n+\t// The allocator propagates so storage can be moved from __x,\n+\t// leaving __x in a valid empty state with a moved-from allocator.\n+\t_M_replace_map(std::move(__x));\n+\t// Move the corresponding allocator state too.\n+\t_M_get_Tp_allocator() = std::move(__alloc);\n+      }\n+\n+      // Do move assignment when it may not be possible to move source\n+      // object's memory, resulting in a linear-time operation.\n+      void\n+      _M_move_assign2(deque&& __x, /* propagate: */ false_type)\n+      {\n+\tif (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())\n+\t  {\n+\t    // The allocators are equal so storage can be moved from __x,\n+\t    // leaving __x in a valid empty state with its current allocator.\n+\t    _M_replace_map(std::move(__x), __x.get_allocator());\n+\t  }\n+\telse\n+\t  {\n+\t    // The rvalue's allocator cannot be moved and is not equal,\n+\t    // so we need to individually move each element.\n+\t    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),\n+\t\t\t std::__make_move_if_noexcept_iterator(__x.end()));\n+\t    __x.clear();\n+\t  }\n+      }\n+#endif\n     };\n \n "}, {"sha": "824cb289112a4f0518e1db1f77def2fcaa4551df", "filename": "libstdc++-v3/include/debug/deque", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -88,6 +88,12 @@ namespace __debug\n       deque(const deque&) = default;\n       deque(deque&&) = default;\n \n+      deque(const deque& __d, const _Allocator& __a)\n+      : _Base(__d, __a) { }\n+\n+      deque(deque&& __d, const _Allocator& __a)\n+      : _Safe(std::move(__d)), _Base(std::move(__d), __a) { }\n+\n       deque(initializer_list<value_type> __l,\n \t    const allocator_type& __a = allocator_type())\n       : _Base(__l, __a) { }\n@@ -101,8 +107,8 @@ namespace __debug\n \n #if __cplusplus >= 201103L\n       explicit\n-      deque(size_type __n)\n-      : _Base(__n) { }\n+      deque(size_type __n, const _Allocator& __a = _Allocator())\n+      : _Base(__n, __a) { }\n \n       deque(size_type __n, const _Tp& __value,\n \t    const _Allocator& __a = _Allocator())"}, {"sha": "c825cbe2ad9183181ed074e9346cb4e16caca29a", "filename": "libstdc++-v3/include/profile/deque", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -60,6 +60,12 @@ namespace __profile\n       deque(const deque&) = default;\n       deque(deque&&) = default;\n \n+      deque(const deque& __d, const _Allocator& __a)\n+      : _Base(__d, __a) { }\n+\n+      deque(deque&& __d, const _Allocator& __a)\n+      : _Base(std::move(__d), __a) { }\n+\n       ~deque() = default;\n \n       deque(initializer_list<value_type> __l,\n@@ -73,8 +79,8 @@ namespace __profile\n \n #if __cplusplus >= 201103L\n       explicit\n-      deque(size_type __n)\n-      : _Base(__n) { }\n+      deque(size_type __n, const _Allocator& __a = _Allocator())\n+      : _Base(__n, __a) { }\n \n       deque(size_type __n, const _Tp& __value,\n \t    const _Allocator& __a = _Allocator())"}, {"sha": "f33349c796a84269414ea247b155dacb7edae1bd", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/copy.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fcopy.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2014 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "83ebc7b8fca2ea5a9390c667478e8ffed44f80a3", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/copy_assign.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fcopy_assign.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2014 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(1, alloc_type(2));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(1, alloc_type(2));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "e17c08474f1cb21fd50998023db55b8ebbfaac7f", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/ext_ptr.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fext_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fext_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fext_ptr.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,43 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::CustomPointerAlloc;\n+\n+template class std::deque<T, CustomPointerAlloc<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef CustomPointerAlloc<T> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v(1);\n+  VERIFY( ++v.begin() == v.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "70ca09ddb3de4438d6ee1004a9d4fe8facbb4d5b", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/minimal.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fminimal.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::deque<T, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v(1, alloc_type{});\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1e8d848c6eb9ed7af28abb9e114713a790494a32", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/move.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  auto it = v1.begin();\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "5f337a07099dcd6656abdbe43ac28aec6130e632", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/move_assign-2.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove_assign-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove_assign-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove_assign-2.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,78 @@\n+// Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11 -fno-access-control\" }\n+\n+// libstdc++/52591\n+\n+#include <deque>\n+#include <memory>\n+#include <type_traits>\n+\n+\n+// As an extension we allow move-assignment of std::deque when the element\n+// type is not MoveAssignable, as long as the allocator type propagates or\n+// is known to always compare equal.\n+\n+struct C\n+{\n+    C& operator=(C&&) = delete;\n+};\n+\n+template<typename T>\n+struct A1 : std::allocator<T>\n+{\n+  template<typename U> struct rebind { typedef A1<U> other; };\n+\n+  A1() = default;\n+  template<typename U> A1(const A1<U>&) { }\n+\n+  using propagate_on_container_move_assignment = std::true_type;\n+};\n+\n+void test01()\n+{\n+  using test_type = std::deque<C, A1<C>>;\n+  static_assert(std::is_move_assignable<test_type>::value,\n+      \"deque is move-assignable if allocator propagates\");\n+}\n+\n+template<typename T>\n+struct A2 : std::allocator<T>\n+{\n+  template<typename U> struct rebind { typedef A2<U> other; };\n+\n+  A2() = default;\n+  template<typename U> A2(const A2<U>&) { }\n+\n+  using propagate_on_container_move_assignment = std::false_type;\n+};\n+\n+namespace __gnu_cxx\n+{\n+  template<typename T>\n+    struct __allocator_always_compares_equal<A2<T>> : std::true_type\n+    { };\n+}\n+\n+void test02()\n+{\n+  using test_type = std::deque<C, A2<C>>;\n+  static_assert(std::is_nothrow_move_assignable<test_type>::value,\n+      \"deque is nothrow move-assignable if allocator is always equal\");\n+}"}, {"sha": "2b5febc0d03073d7d87d30022fc6854200f1576c", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/move_assign.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fmove_assign.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2014 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(1, alloc_type(2));\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  auto it = v1.begin();\n+  test_type v2(1, alloc_type(2));\n+  v2 = std::move(v1);\n+  VERIFY( it == v2.begin() );\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  auto it = v1.begin();\n+  test_type v2(1, alloc_type(1));\n+  v2 = std::move(v1);\n+  VERIFY( it == v2.begin() );\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "6d199cc37ef4922ab9549169053d1eab302a4cae", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/noexcept.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fnoexcept.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+namespace __gnu_test\n+{\n+  template<typename U>\n+    inline void\n+    swap(propagating_allocator<U, true>& l, propagating_allocator<U, true>& r)\n+    noexcept(false)\n+    { }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  // static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  // static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  // noexcept spec of deque::swap depends on swap overload at top of this file\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}"}, {"sha": "c504581c44ec6c5800170e9a72fab6056f004015", "filename": "libstdc++-v3/testsuite/23_containers/deque/allocator/swap.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fallocator%2Fswap.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2013 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return false;\n+}\n+\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(1, alloc_type(2));\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::deque<T, alloc_type> test_type;\n+  test_type v1(1, alloc_type(1));\n+  test_type v2(1, alloc_type(2));\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "8092ead6d41df1f2f30f4044d9c791585fb9cf8b", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1764 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1859 }\n \n #include <deque>\n "}, {"sha": "4abdf4682bea8c85e05238f56292377432e6d910", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1697 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1792 }\n \n #include <deque>\n "}, {"sha": "61bce4eb049a1628e3254624c6f58611ec841fa7", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1697 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1792 }\n \n #include <deque>\n #include <utility>"}, {"sha": "a0ca00caf8ad67ab5aca908fafd23eac3a997f33", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1848 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1943 }\n \n #include <deque>\n "}, {"sha": "073d29adb905ad63a9793bccc4653fe7e290852f", "filename": "libstdc++-v3/testsuite/23_containers/vector/52591.cc", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2F52591.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd18c76ac8c85976bd7fe413aca2c26296ca6d54/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2F52591.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2F52591.cc?ref=fd18c76ac8c85976bd7fe413aca2c26296ca6d54", "patch": "@@ -21,6 +21,8 @@\n // libstdc++/52591\n \n #include <vector>\n+#include <memory>\n+#include <type_traits>\n \n // As an extension we allow move-assignment of std::vector when the element\n // type is not MoveAssignable, as long as the allocator type propagates or\n@@ -31,8 +33,45 @@ struct C\n     C& operator=(C&&) = delete;\n };\n \n+template<typename T>\n+struct A1 : std::allocator<T>\n+{\n+  template<typename U> struct rebind { typedef A1<U> other; };\n+\n+  A1() = default;\n+  template<typename U> A1(const A1<U>&) { }\n+\n+  using propagate_on_container_move_assignment = std::true_type;\n+};\n+\n void test01()\n {\n-    std::vector<C> a;\n-    a = std::vector<C>();\n+  using test_type = std::vector<C, A1<C>>;\n+  static_assert(std::is_nothrow_move_assignable<test_type>::value,\n+      \"vector is nothrow move-assignable if allocator propagates\");\n+}\n+\n+template<typename T>\n+struct A2 : std::allocator<T>\n+{\n+  template<typename U> struct rebind { typedef A1<U> other; };\n+\n+  A2() = default;\n+  template<typename U> A2(const A2<U>&) { }\n+\n+  using propagate_on_container_move_assignment = std::false_type;\n+};\n+\n+namespace __gnu_cxx\n+{\n+  template<typename T>\n+    struct __allocator_always_compares_equal<A2<T>> : std::true_type\n+    { };\n+}\n+\n+void test02()\n+{\n+  using test_type = std::vector<C, A2<C>>;\n+  static_assert(std::is_nothrow_move_assignable<test_type>::value,\n+      \"vector is nothrow move-assignable if allocator is always equal\");\n }"}]}