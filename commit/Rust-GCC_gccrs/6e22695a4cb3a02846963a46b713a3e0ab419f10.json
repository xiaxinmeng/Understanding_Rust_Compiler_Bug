{"sha": "6e22695a4cb3a02846963a46b713a3e0ab419f10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyMjY5NWE0Y2IzYTAyODQ2OTYzYTQ2YjcxM2EzZTBhYjQxOWYxMA==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-10-05T07:17:34Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-10-05T07:17:34Z"}, "message": "[multiple changes]\n\nTue Oct  3 13:44:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * decl.c (find_local_variable): Removed uncessary type check and\n        fixed range check typo. From Corey Minyard.\n\nWed Sep 13 16:06:52 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * decl.c (give_name_to_locals): New local `code_offset'. Call\n        `maybe_adjust_start_pc.'\n        * expr.c (note_instructions): New function.\n        (expand_byte_code): Don't collect insn starts here.\n        (peek_opcode_at_pc): New function.\n        (maybe_adjust_start_pc): Likewise.\n        * java-tree.h (maybe_adjust_start_pc): Declare.\n        (note_instructions): Likewise.\n        * jcf-parse.c (parse_class_file): Call `note_instructions.'\n\nWed Sep 13 11:50:35 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.y (field_access:): Fixed indentation.\n        (qualify_ambiguous_name): Properly qualify `this.a[b].c'.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-10/msg00067.html)\n\nFrom-SVN: r36717", "tree": {"sha": "4d5c18c324994e5c054b7c48872b57170975b1b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d5c18c324994e5c054b7c48872b57170975b1b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e22695a4cb3a02846963a46b713a3e0ab419f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e22695a4cb3a02846963a46b713a3e0ab419f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e22695a4cb3a02846963a46b713a3e0ab419f10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e22695a4cb3a02846963a46b713a3e0ab419f10/comments", "author": null, "committer": null, "parents": [{"sha": "e23062d5a741b3eba6bb8fc66bd0b99e759cd6cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e23062d5a741b3eba6bb8fc66bd0b99e759cd6cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e23062d5a741b3eba6bb8fc66bd0b99e759cd6cd"}], "stats": {"total": 260, "additions": 221, "deletions": 39}, "files": [{"sha": "c82acb4e5d27cdd116a871a2715f23572e2cd113", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6e22695a4cb3a02846963a46b713a3e0ab419f10", "patch": "@@ -1,3 +1,25 @@\n+Tue Oct  3 13:44:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* decl.c (find_local_variable): Removed uncessary type check and\n+\tfixed range check typo. From Corey Minyard.\n+\n+Wed Sep 13 16:06:52 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* decl.c (give_name_to_locals): New local `code_offset'. Call\n+ \t`maybe_adjust_start_pc.'\n+\t* expr.c (note_instructions): New function.\n+\t(expand_byte_code): Don't collect insn starts here.\n+\t(peek_opcode_at_pc): New function.\n+\t(maybe_adjust_start_pc): Likewise.\n+\t* java-tree.h (maybe_adjust_start_pc): Declare.\n+\t(note_instructions): Likewise.\n+\t* jcf-parse.c (parse_class_file): Call `note_instructions.'\n+\n+Wed Sep 13 11:50:35 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (field_access:): Fixed indentation.\n+\t(qualify_ambiguous_name): Properly qualify `this.a[b].c'.\n+\n 2000-09-07  Tom Tromey  <tromey@cygnus.com>\n \n \tFix for PR gcj/307:"}, {"sha": "8dd349ff8c77ce94229124fcf5b670bf2b303644", "filename": "gcc/java/decl.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=6e22695a4cb3a02846963a46b713a3e0ab419f10", "patch": "@@ -170,9 +170,8 @@ find_local_variable (index, type, pc)\n \t   && in_range)\n \t{\n \t  if (best == NULL_TREE\n-\t      || (TREE_TYPE (decl) == type && TREE_TYPE (best) != type)\n-\t      || DECL_LOCAL_START_PC (decl) > DECL_LOCAL_START_PC (best)\n-\t      || DECL_LOCAL_END_PC (decl) < DECL_LOCAL_START_PC (decl))\n+              || (DECL_LOCAL_START_PC (decl) > DECL_LOCAL_START_PC (best)\n+                  && DECL_LOCAL_END_PC (decl) < DECL_LOCAL_START_PC (best)))\n \t    best = decl;\n \t}\n       decl = DECL_LOCAL_SLOT_CHAIN (decl);\n@@ -1517,6 +1516,7 @@ give_name_to_locals (jcf)\n      JCF *jcf;\n {\n   int i, n = DECL_LOCALVARIABLES_OFFSET (current_function_decl);\n+  int code_offset = DECL_CODE_OFFSET (current_function_decl);\n   tree parm;\n   pending_local_decls = NULL_TREE;\n   if (n == 0)\n@@ -1553,6 +1553,13 @@ give_name_to_locals (jcf)\n \t\t\t \"bad PC range for debug info for local `%s'\");\n \t      end_pc = DECL_CODE_LENGTH (current_function_decl);\n \t    }\n+\n+\t  /* Adjust start_pc if necessary so that the local's first\n+\t     store operation will use the relevant DECL as a\n+\t     destination. Fore more information, read the leading\n+\t     comments for expr.c:maybe_adjust_start_pc. */\n+\t  start_pc = maybe_adjust_start_pc (jcf, code_offset, start_pc, slot);\n+\n \t  DECL_LANG_SPECIFIC (decl)\n \t    = (struct lang_decl *) ggc_alloc (sizeof (struct lang_decl_var));\n \t  DECL_LOCAL_SLOT_NUMBER (decl) = slot;"}, {"sha": "1dd26c38c4d52d3e0102195ea379fa9046b6a7bc", "filename": "gcc/java/expr.c", "status": "modified", "additions": 175, "deletions": 34, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=6e22695a4cb3a02846963a46b713a3e0ab419f10", "patch": "@@ -80,6 +80,7 @@ static tree build_java_throw_out_of_bounds_exception PARAMS ((tree));\n static tree build_java_check_indexed_type PARAMS ((tree, tree)); \n static tree java_array_data_offset PARAMS ((tree)); \n static tree case_identity PARAMS ((tree, tree)); \n+static unsigned char peek_opcode_at_pc PARAMS ((struct JCF *, int, int));\n \n static tree operand_type[59];\n extern struct obstack permanent_obstack;\n@@ -2479,16 +2480,20 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n     }\n }\n \n+/* Go over METHOD's bytecode and note instruction starts in\n+   instruction_bits[].  */\n+\n void\n-expand_byte_code (jcf, method)\n+note_instructions (jcf, method)\n      JCF *jcf;\n      tree method;\n {\n-  int PC;\n-  int i;\n+  int PC; \n+  unsigned char* byte_ops;\n+  long length = DECL_CODE_LENGTH (method);\n+\n   int saw_index;\n-  const unsigned char *linenumber_pointer;\n-  int dead_code_index = -1;\n+  jint INT_temp;\n \n #undef RET /* Defined by config/i386/i386.h */\n #undef AND /* Causes problems with opcodes for iand and land. */\n@@ -2503,43 +2508,19 @@ expand_byte_code (jcf, method)\n #define FLOAT_type_node float_type_node\n #define DOUBLE_type_node double_type_node\n #define VOID_type_node void_type_node\n-  jint INT_temp;\n-  unsigned char* byte_ops;\n-  long length = DECL_CODE_LENGTH (method);\n-\n-  stack_pointer = 0;\n-  JCF_SEEK (jcf, DECL_CODE_OFFSET (method));\n-  byte_ops = jcf->read_ptr;\n-\n #define CONST_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n #define CONST_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n #define VAR_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n #define VAR_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n \n #define CHECK_PC_IN_RANGE(PC) ((void)1) /* Already handled by verifier. */\n \n+  JCF_SEEK (jcf, DECL_CODE_OFFSET (method));\n+  byte_ops = jcf->read_ptr;\n   instruction_bits = oballoc (length + 1);\n   bzero (instruction_bits, length + 1);\n \n-  /* We make an initial pass of the line number table, to note\n-     which instructions have associated line number entries. */\n-  linenumber_pointer = linenumber_table;\n-  for (i = 0; i < linenumber_count; i++)\n-    {\n-      int pc = GET_u2 (linenumber_pointer);\n-      linenumber_pointer += 4;\n-      if (pc >= length)\n-\twarning (\"invalid PC in line number table\");\n-      else\n-\t{\n-\t  if ((instruction_bits[pc] & BCODE_HAS_LINENUMBER) != 0)\n-\t    instruction_bits[pc] |= BCODE_HAS_MULTI_LINENUMBERS;\n-\t  instruction_bits[pc] |= BCODE_HAS_LINENUMBER;\n-\t}\n-    }  \n-\n-  /* Do a preliminary pass.\n-   * This figures out which PC can be the targets of jumps. */\n+  /* This pass figures out which PC can be the targets of jumps. */\n   for (PC = 0; PC < length;)\n     {\n       int oldpc = PC; /* PC at instruction start. */\n@@ -2586,8 +2567,6 @@ expand_byte_code (jcf, method)\n       } \\\n   }\n \n-/* nothing */ /* XXX JH */\n-\n #define PRE_IMPL(IGNORE1, IGNORE2) /* nothing */\n \n #define PRE_MONITOR(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n@@ -2647,6 +2626,40 @@ expand_byte_code (jcf, method)\n #undef JAVAOP\n \t}\n     } /* for */\n+}\n+\n+void\n+expand_byte_code (jcf, method)\n+     JCF *jcf;\n+     tree method;\n+{\n+  int PC;\n+  int i;\n+  const unsigned char *linenumber_pointer;\n+  int dead_code_index = -1;\n+  unsigned char* byte_ops;\n+  long length = DECL_CODE_LENGTH (method);\n+\n+  stack_pointer = 0;\n+  JCF_SEEK (jcf, DECL_CODE_OFFSET (method));\n+  byte_ops = jcf->read_ptr;\n+\n+  /* We make an initial pass of the line number table, to note\n+     which instructions have associated line number entries. */\n+  linenumber_pointer = linenumber_table;\n+  for (i = 0; i < linenumber_count; i++)\n+    {\n+      int pc = GET_u2 (linenumber_pointer);\n+      linenumber_pointer += 4;\n+      if (pc >= length)\n+\twarning (\"invalid PC in line number table\");\n+      else\n+\t{\n+\t  if ((instruction_bits[pc] & BCODE_HAS_LINENUMBER) != 0)\n+\t    instruction_bits[pc] |= BCODE_HAS_MULTI_LINENUMBERS;\n+\t  instruction_bits[pc] |= BCODE_HAS_LINENUMBER;\n+\t}\n+    }  \n \n   if (! verify_jvm_instructions (jcf, byte_ops, length))\n     return;\n@@ -3064,6 +3077,134 @@ process_jvm_instruction (PC, byte_ops, length)\n   return PC;\n }\n \n+/* Return the opcode at PC in the code section pointed to by\n+   CODE_OFFSET.  */\n+\n+static unsigned char\n+peek_opcode_at_pc (jcf, code_offset, pc)\n+    JCF *jcf;\n+    int code_offset, pc;\n+{\n+  unsigned char opcode;\n+  long absolute_offset = (long)JCF_TELL (jcf);\n+\n+  JCF_SEEK (jcf, code_offset);\n+  opcode = jcf->read_ptr [pc];\n+  JCF_SEEK (jcf, absolute_offset);\n+  return opcode;\n+}\n+\n+/* Some bytecode compilers are emitting accurate LocalVariableTable\n+   attributes. Here's an example:\n+   \n+     PC   <t>store_<n>\n+     PC+1 ...\n+     \n+     Attribute \"LocalVariableTable\"\n+     slot #<n>: ... (PC: PC+1 length: L)\n+   \n+   This is accurate because the local in slot <n> really exists after\n+   the opcode at PC is executed, hence from PC+1 to PC+1+L.\n+\n+   This procedure recognizes this situation and extends the live range\n+   of the local in SLOT to START_PC-1 or START_PC-2 (depending on the\n+   length of the store instruction.)\n+\n+   This function is used by `give_name_to_locals' so that a local's\n+   DECL features a DECL_LOCAL_START_PC such that the first related\n+   store operation will use DECL as a destination, not a unrelated\n+   temporary created for the occasion.\n+\n+   This function uses a global (instruction_bits) `note_instructions' should\n+   have allocated and filled properly.  */\n+\n+int\n+maybe_adjust_start_pc (jcf, code_offset, start_pc, slot)\n+     struct JCF *jcf;\n+     int code_offset, start_pc, slot;\n+{\n+  int first, index, opcode;\n+  int pc, insn_pc;\n+  int wide_found = 0;\n+\n+  if (!start_pc)\n+    return start_pc;\n+\n+  first = index = -1;\n+\n+  /* Find last previous instruction and remember it */\n+  for (pc = start_pc-1; pc; pc--) \n+    if (instruction_bits [pc] & BCODE_INSTRUCTION_START)\n+      break;\n+  insn_pc = pc;\n+\n+  /* Retrieve the instruction, handle `wide'. */  \n+  opcode = (int) peek_opcode_at_pc (jcf, code_offset, pc++);\n+  if (opcode == OPCODE_wide)\n+    {\n+      wide_found = 1;\n+      opcode = (int) peek_opcode_at_pc (jcf, code_offset, pc++);\n+    }\n+\n+  switch (opcode)\n+    {\n+    case OPCODE_astore_0:\n+    case OPCODE_astore_1:\n+    case OPCODE_astore_2:\n+    case OPCODE_astore_3:\n+      first = OPCODE_astore_0;\n+      break;\n+\n+    case OPCODE_istore_0:\n+    case OPCODE_istore_1:\n+    case OPCODE_istore_2:\n+    case OPCODE_istore_3:\n+      first = OPCODE_istore_0;\n+      break;\n+      \n+    case OPCODE_lstore_0:\n+    case OPCODE_lstore_1:\n+    case OPCODE_lstore_2:\n+    case OPCODE_lstore_3:\n+      first = OPCODE_lstore_0;\n+      break;\n+\n+    case OPCODE_fstore_0:\n+    case OPCODE_fstore_1:\n+    case OPCODE_fstore_2:\n+    case OPCODE_fstore_3:\n+      first = OPCODE_fstore_0;\n+      break;\n+\n+    case OPCODE_dstore_0:\n+    case OPCODE_dstore_1:\n+    case OPCODE_dstore_2:\n+    case OPCODE_dstore_3:\n+      first = OPCODE_dstore_0;\n+      break;\n+\n+    case OPCODE_astore:\n+    case OPCODE_istore:\n+    case OPCODE_lstore:\n+    case OPCODE_fstore:\n+    case OPCODE_dstore:\n+      index = peek_opcode_at_pc (jcf, code_offset, pc);\n+      if (wide_found)\n+\t{\n+\t  int other = peek_opcode_at_pc (jcf, code_offset, ++pc);\n+\t  index = (other << 8) + index;\n+\t}\n+      break;\n+    }\n+\n+  /* Now we decide: first >0 means we have a <t>store_<n>, index >0\n+     means we have a <t>store. */\n+  if ((first > 0 && opcode - first == slot) || (index > 0 && index == slot))\n+    start_pc = insn_pc;\n+\n+  return start_pc;\n+}\n+\n /* Force the (direct) sub-operands of NODE to be evaluated in left-to-right\n    order, as specified by Java Language Specification.\n "}, {"sha": "17b76925c28aed3fa556a7acc1ea42b8768b5fd0", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=6e22695a4cb3a02846963a46b713a3e0ab419f10", "patch": "@@ -1003,6 +1003,7 @@ extern void maybe_pushlevels PARAMS ((int));\n extern void maybe_poplevels PARAMS ((int));\n extern void force_poplevels PARAMS ((int));\n extern int process_jvm_instruction PARAMS ((int, const unsigned char *, long));\n+extern int maybe_adjust_start_pc PARAMS ((struct JCF *, int, int, int));\n extern void set_local_type PARAMS ((int, tree));\n extern int merge_type_state PARAMS ((tree));\n extern void push_type PARAMS ((tree));\n@@ -1016,6 +1017,7 @@ extern int verify_constant_pool PARAMS ((struct JCF *));\n extern void start_java_method PARAMS ((tree));\n extern void end_java_method PARAMS ((void));\n extern void give_name_to_locals PARAMS ((struct JCF *));\n+extern void note_instructions PARAMS ((struct JCF *, tree));\n extern void expand_byte_code PARAMS ((struct JCF *, tree));\n extern int open_in_zip PARAMS ((struct JCF *, const char *, const char *, int));\n extern void set_constant_value PARAMS ((tree, tree));"}, {"sha": "5db2edcc076f4b5fdd12becdcf7ececa305d32f3", "filename": "gcc/java/parse.y", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e22695a4cb3a02846963a46b713a3e0ab419f10/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=6e22695a4cb3a02846963a46b713a3e0ab419f10", "patch": "@@ -2172,8 +2172,7 @@ field_access:\n \t\t{ $$ = build_binop (COMPONENT_REF, $2.location, $1, $3); } */\n |\tSUPER_TK DOT_TK identifier\n \t\t{\n-\t\t  tree super_wfl = \n-\t\t    build_wfl_node (super_identifier_node);\n+\t\t  tree super_wfl = build_wfl_node (super_identifier_node);\n \t\t  EXPR_WFL_LINECOL (super_wfl) = $1.location;\n \t\t  $$ = make_qualified_name (super_wfl, $3, $2.location);\n \t\t}\n@@ -10741,6 +10740,17 @@ qualify_ambiguous_name (id)\n     /* If we have a THIS (from a primary), we set the context accordingly */\n     if (name == this_identifier_node)\n       {\n+\t/* This isn't really elegant. One more added irregularity\n+\t   before I start using COMPONENT_REF (hopefully very soon.)  */\n+\tif (TREE_CODE (TREE_PURPOSE (qual)) == ARRAY_REF\n+\t    && TREE_CODE (TREE_OPERAND (TREE_PURPOSE (qual), 0)) ==\n+\t       EXPR_WITH_FILE_LOCATION\n+\t    && EXPR_WFL_NODE (TREE_OPERAND (TREE_PURPOSE (qual), 0)) == \n+\t       this_identifier_node)\n+\t    {\n+\t      qual = TREE_OPERAND (TREE_PURPOSE (qual), 0);\n+\t      qual = EXPR_WFL_QUALIFICATION (qual);\n+\t    }\n \tqual = TREE_CHAIN (qual);\n \tqual_wfl = QUAL_WFL (qual);\n \tif (TREE_CODE (qual_wfl) == CALL_EXPR)"}]}