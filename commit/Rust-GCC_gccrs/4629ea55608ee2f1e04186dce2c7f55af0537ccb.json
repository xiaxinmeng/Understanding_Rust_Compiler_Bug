{"sha": "4629ea55608ee2f1e04186dce2c7f55af0537ccb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYyOWVhNTU2MDhlZTJmMWUwNDE4NmRjZTJjN2Y1NWFmMDUzN2NjYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-07T17:06:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-07T17:06:09Z"}, "message": "Implement D1959R0, remove weak_equality and strong_equality.\n\nShortly after I finished implementing the previous semantics, the\ncommittee decided to remove the *_equality comparison categories, because\nthey were largely obsoleted by the earlier change that separated operator==\nfrom its original dependency on operator<=>.\n\ngcc/cp/\n\t* method.c (enum comp_cat_tag, comp_cat_info): Remove *_equality.\n\t(genericize_spaceship, common_comparison_type): Likewise.\n\t* typeck.c (cp_build_binary_op): Move SPACESHIP_EXPR to be with the\n\trelational operators, exclude other types no longer supported.\nlibstdc++-v3/\n\t* libsupc++/compare: Remove strong_equality and weak_equality.\n\nFrom-SVN: r277925", "tree": {"sha": "346c49fc402d4acd850ead528e3511d706db7946", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/346c49fc402d4acd850ead528e3511d706db7946"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4629ea55608ee2f1e04186dce2c7f55af0537ccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4629ea55608ee2f1e04186dce2c7f55af0537ccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4629ea55608ee2f1e04186dce2c7f55af0537ccb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4629ea55608ee2f1e04186dce2c7f55af0537ccb/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c38ee9a2e87ea6d23580c364b3997acfce4a125c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c38ee9a2e87ea6d23580c364b3997acfce4a125c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c38ee9a2e87ea6d23580c364b3997acfce4a125c"}], "stats": {"total": 290, "additions": 56, "deletions": 234}, "files": [{"sha": "2aa0afae11352943df4d39b3480770d218148388", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -1,3 +1,11 @@\n+2019-11-07  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement D1959R0, remove weak_equality and strong_equality.\n+\t* method.c (enum comp_cat_tag, comp_cat_info): Remove *_equality.\n+\t(genericize_spaceship, common_comparison_type): Likewise.\n+\t* typeck.c (cp_build_binary_op): Move SPACESHIP_EXPR to be with the\n+\trelational operators, exclude other types no longer supported.\n+\n 2019-11-06  Jason Merrill  <jason@redhat.com>\n \n \tImplement D1907R1 \"structural type\"."}, {"sha": "47441c10c52fb1ea4e5b320402120aa21ef021ec", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -882,8 +882,6 @@ do_build_copy_assign (tree fndecl)\n \n enum comp_cat_tag\n {\n-  cc_weak_equality,\n-  cc_strong_equality,\n   cc_partial_ordering,\n   cc_weak_ordering,\n   cc_strong_ordering,\n@@ -901,8 +899,6 @@ struct comp_cat_info_t\n };\n static const comp_cat_info_t comp_cat_info[cc_last]\n = {\n-   { \"weak_equality\", \"equivalent\", \"nonequivalent\" },\n-   { \"strong_equality\", \"equal\", \"nonequal\" },\n    { \"partial_ordering\", \"equivalent\", \"greater\", \"less\", \"unordered\" },\n    { \"weak_ordering\", \"equivalent\", \"greater\", \"less\" },\n    { \"strong_ordering\", \"equal\", \"greater\", \"less\" }\n@@ -1028,21 +1024,8 @@ spaceship_comp_cat (tree optype)\n     return cc_strong_ordering;\n   else if (TREE_CODE (optype) == REAL_TYPE)\n     return cc_partial_ordering;\n-  else if (TYPE_PTRFN_P (optype) || TYPE_PTRMEM_P (optype)\n-\t   || NULLPTR_TYPE_P (optype))\n-    return cc_strong_equality;\n-  else if (TREE_CODE (optype) == COMPLEX_TYPE)\n-    {\n-      tree intype = optype;\n-      while (TREE_CODE (intype) == COMPLEX_TYPE)\n-\tintype = TREE_TYPE (intype);\n-      if (TREE_CODE (intype) == REAL_TYPE)\n-\treturn cc_weak_equality;\n-      else\n-\treturn cc_strong_equality;\n-    }\n \n-  /* FIXME should vector <=> produce a vector of one of the above?  */\n+  /* ??? should vector <=> produce a vector of one of the above?  */\n   gcc_unreachable ();\n }\n \n@@ -1065,35 +1048,29 @@ genericize_spaceship (tree type, tree op0, tree op1)\n   comp_cat_tag tag = cat_tag_for (type);\n   gcc_checking_assert (tag < cc_last);\n \n-  tree eq = lookup_comparison_result (tag, type, 0);\n-  tree negt = lookup_comparison_result (tag, type, 1);\n-\n-  if (tag == cc_strong_equality || tag == cc_weak_equality)\n-    {\n-      tree comp = fold_build2 (EQ_EXPR, boolean_type_node, op0, op1);\n-      return fold_build3 (COND_EXPR, type, comp, eq, negt);\n-    }\n-\n   tree r;\n   op0 = save_expr (op0);\n   op1 = save_expr (op1);\n \n+  tree gt = lookup_comparison_result (tag, type, 1);\n+\n   if (tag == cc_partial_ordering)\n     {\n       /* op0 == op1 ? equivalent : op0 < op1 ? less :\n \t op0 > op1 ? greater : unordered */\n       tree uo = lookup_comparison_result (tag, type, 3);\n       tree comp = fold_build2 (GT_EXPR, boolean_type_node, op0, op1);\n-      r = fold_build3 (COND_EXPR, type, comp, negt, uo);\n+      r = fold_build3 (COND_EXPR, type, comp, gt, uo);\n     }\n   else\n     /* op0 == op1 ? equal : op0 < op1 ? less : greater */\n-    r = negt;\n+    r = gt;\n \n   tree lt = lookup_comparison_result (tag, type, 2);\n   tree comp = fold_build2 (LT_EXPR, boolean_type_node, op0, op1);\n   r = fold_build3 (COND_EXPR, type, comp, lt, r);\n \n+  tree eq = lookup_comparison_result (tag, type, 0);\n   comp = fold_build2 (EQ_EXPR, boolean_type_node, op0, op1);\n   r = fold_build3 (COND_EXPR, type, comp, eq, r);\n \n@@ -1178,18 +1155,6 @@ common_comparison_type (vec<tree> &comps)\n \treturn void_type_node;\n     }\n \n-  /* Otherwise, if at least one T i is std::weak_equality, or at least one T i\n-     is std::strong_equality and at least one T j is std::partial_ordering or\n-     std::weak_ordering, U is std::weak_equality.  */\n-  if (tree t = seen[cc_weak_equality]) return t;\n-  if (seen[cc_strong_equality]\n-      && (seen[cc_partial_ordering] || seen[cc_weak_ordering]))\n-    return lookup_comparison_category (cc_weak_equality);\n-\n-  /* Otherwise, if at least one T i is std::strong_equality, U is\n-     std::strong_equality.  */\n-  if (tree t = seen[cc_strong_equality]) return t;\n-\n   /* Otherwise, if at least one T i is std::partial_ordering, U is\n      std::partial_ordering.  */\n   if (tree t = seen[cc_partial_ordering]) return t;"}, {"sha": "124d16a31fbb0d090c602a1ec6a7e9bcd8fe2ba5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -4889,7 +4889,6 @@ cp_build_binary_op (const op_location_t &location,\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-    case SPACESHIP_EXPR:\n       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n \tgoto vector_compare;\n       if ((complain & tf_warning)\n@@ -4966,9 +4965,7 @@ cp_build_binary_op (const op_location_t &location,\n \t  warn_for_null_address (location, op1, complain);\n \t}\n       else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n-\t       || (code == SPACESHIP_EXPR\n-\t\t   ? TYPE_PTRMEM_P (type0) && TYPE_PTRMEM_P (type1)\n-\t\t   : TYPE_PTRDATAMEM_P (type0) && TYPE_PTRDATAMEM_P (type1)))\n+\t       || (TYPE_PTRDATAMEM_P (type0) && TYPE_PTRDATAMEM_P (type1)))\n \tresult_type = composite_pointer_type (location,\n \t\t\t\t\t      type0, type1, op0, op1,\n \t\t\t\t\t      CPO_COMPARISON, complain);\n@@ -5172,6 +5169,7 @@ cp_build_binary_op (const op_location_t &location,\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n+    case SPACESHIP_EXPR:\n       if (TREE_CODE (orig_op0) == STRING_CST\n \t  || TREE_CODE (orig_op1) == STRING_CST)\n \t{\n@@ -5369,7 +5367,9 @@ cp_build_binary_op (const op_location_t &location,\n       tree_code orig_code0 = TREE_CODE (orig_type0);\n       tree orig_type1 = TREE_TYPE (orig_op1);\n       tree_code orig_code1 = TREE_CODE (orig_type1);\n-      if ((orig_code0 == BOOLEAN_TYPE) != (orig_code1 == BOOLEAN_TYPE))\n+      if (!result_type)\n+\t/* Nope.  */;\n+      else if ((orig_code0 == BOOLEAN_TYPE) != (orig_code1 == BOOLEAN_TYPE))\n \t/* \"If one of the operands is of type bool and the other is not, the\n \t   program is ill-formed.\"  */\n \tresult_type = NULL_TREE;\n@@ -5378,6 +5378,9 @@ cp_build_binary_op (const op_location_t &location,\n \t/* We only do array/function-to-pointer conversion if \"at least one of\n \t   the operands is of pointer type\".  */\n \tresult_type = NULL_TREE;\n+      else if (TYPE_PTRFN_P (result_type) || NULLPTR_TYPE_P (result_type))\n+\t/* <=> no longer supports equality relations.  */\n+\tresult_type = NULL_TREE;\n       else if (orig_code0 == ENUMERAL_TYPE && orig_code1 == ENUMERAL_TYPE\n \t       && !(same_type_ignoring_top_level_qualifiers_p\n \t\t    (orig_type0, orig_type1)))"}, {"sha": "012416a212b1d244f0e70cd7ccbba55aac404d84", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar1-neg.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1-neg.C?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while(0)\n+\n+void f(){}\n+void g(){}\n+\n+int main()\n+{\n+  {\n+    const auto v = &f <=> &g;\t// { dg-error \"invalid operands\" }\n+  }\n+\n+  {\n+    struct A { int i; int j; };\n+    constexpr auto v = &A::i <=> &A::j; // { dg-error \"invalid operands\" }\n+  }\n+\n+  {\n+    struct A { void f(); };\n+    constexpr auto v = &A::f <=> &A::f; // { dg-error \"invalid operands\" }\n+  }\n+}"}, {"sha": "0d1dd63d36835c88701f01af987dcb1fc47fc6e2", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar1.C", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1.C?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -4,9 +4,6 @@\n \n #define assert(X) do { if (!(X)) __builtin_abort(); } while(0)\n \n-void f(){}\n-void g(){}\n-\n int main()\n {\n   {\n@@ -66,28 +63,4 @@ int main()\n     static_assert (!is_gt (v));\n     static_assert (is_gteq (v));\n   }\n-\n-  {\n-    // GCC doesn't consider &f == &g to be a constant expression (PR 69681)\n-    const auto v = &f <=> &g;\n-    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n-    assert (!is_eq (v));\n-    assert (is_neq (v));\n-  }\n-\n-  {\n-    struct A { int i; int j; };\n-    constexpr auto v = &A::i <=> &A::j;\n-    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n-    static_assert (!is_eq (v));\n-    static_assert (is_neq (v));\n-  }\n-\n-  {\n-    struct A { void f(); };\n-    constexpr auto v = &A::f <=> &A::f;\n-    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n-    static_assert (is_eq (v));\n-    static_assert (!is_neq (v));\n-  }\n }"}, {"sha": "552c92aa5bd3a45ada765da3255a5820135cb71c", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar1a.C", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1a.C?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -4,9 +4,6 @@\n \n #define assert(X) do { if (!(X)) __builtin_abort(); } while(0)\n \n-void f(){}\n-void g(){}\n-\n template <class T, class U, class R>\n constexpr bool check(T a, U b, R expected)\n {\n@@ -29,13 +26,4 @@ int main()\n   static_assert (check (&ar[1], &ar[0], std::strong_ordering::greater));\n \n   static_assert (check (3.14, 3.14, std::partial_ordering::equivalent));\n-\n-  // GCC doesn't consider &f == &g to be a constant expression (PR 69681)\n-  assert (check (&f, &g, std::strong_equality::nonequal));\n-\n-  struct A { int i; int j; };\n-  static_assert (check (&A::i, &A::j, std::strong_equality::nonequal));\n-\n-  struct A2 { void f(); };\n-  static_assert (check (&A2::f, &A2::f, std::strong_equality::equal));\n }"}, {"sha": "7dacaf4b81d03885262fdcbd3aaf09b742bb471b", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar3.C", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar3.C?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -1,21 +1,9 @@\n-// { dg-do run { target c++2a } }\n+// { dg-do compile { target c++2a } }\n // { dg-options \"-fext-numeric-literals\" }\n \n-#include <compare>\n-\n int main()\n {\n   // GCC complex literal extension  \n-  {\n-    constexpr auto v = 1 <=> 1i;\n-    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n-    static_assert (!is_eq (v));\n-    static_assert (is_neq (v));\n-  }\n-  {\n-    constexpr auto v = 1i <=> 1.0i;\n-    static_assert (__is_same_as (decltype (v), const std::weak_equality));\n-    static_assert (is_eq (v));\n-    static_assert (!is_neq (v));\n-  }\n+  { constexpr auto v = 1 <=> 1i; } // { dg-error \"invalid operands\" }\n+  { constexpr auto v = 1i <=> 1.0i; } // { dg-error \"invalid operands\" }\n }"}, {"sha": "cbea95ba40371d3df0957e3a21cfbe737e14cde4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -1,3 +1,7 @@\n+2019-11-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* libsupc++/compare: Remove strong_equality and weak_equality.\n+\n 2019-11-06  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/Makefile.in: Regenerate."}, {"sha": "84cc3f5c85fe0aa37cc776ef73759e42a250ded7", "filename": "libstdc++-v3/libsupc++/compare", "status": "modified", "additions": 2, "deletions": 134, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4629ea55608ee2f1e04186dce2c7f55af0537ccb/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4629ea55608ee2f1e04186dce2c7f55af0537ccb/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare?ref=4629ea55608ee2f1e04186dce2c7f55af0537ccb", "patch": "@@ -59,103 +59,6 @@ namespace std\n     };\n   }\n \n-  class weak_equality\n-  {\n-    int _M_value;\n-\n-    constexpr explicit\n-    weak_equality(__cmp_cat::_Eq __val) noexcept\n-    : _M_value(int(__val))\n-    { }\n-\n-  public:\n-    // valid values\n-\n-    static const weak_equality equivalent;\n-    static const weak_equality nonequivalent;\n-\n-    // comparisons\n-\n-    friend constexpr bool\n-    operator==(weak_equality __v, __cmp_cat::__unspec) noexcept\n-    { return __v._M_value == 0; }\n-\n-    friend constexpr bool\n-    operator==(weak_equality, weak_equality) noexcept = default;\n-\n-    friend constexpr weak_equality\n-    operator<=>(weak_equality __v, __cmp_cat::__unspec) noexcept\n-    { return __v; }\n-\n-    friend constexpr weak_equality\n-    operator<=>(__cmp_cat::__unspec, weak_equality __v) noexcept\n-    { return __v; }\n-  };\n-\n-  // valid values' definitions\n-  inline constexpr weak_equality\n-  weak_equality::equivalent(__cmp_cat::_Eq::equivalent);\n-\n-  inline constexpr weak_equality\n-  weak_equality::nonequivalent(__cmp_cat::_Eq::nonequivalent);\n-\n-  class strong_equality\n-  {\n-    int _M_value;\n-\n-    constexpr explicit\n-    strong_equality(__cmp_cat::_Eq __val) noexcept\n-    : _M_value(int(__val))\n-    { }\n-\n-  public:\n-    // valid values\n-\n-    static const strong_equality equal;\n-    static const strong_equality nonequal;\n-    static const strong_equality equivalent;\n-    static const strong_equality nonequivalent;\n-\n-    // conversion\n-    constexpr operator weak_equality() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn weak_equality::equivalent;\n-      else\n-\treturn weak_equality::nonequivalent;\n-    }\n-\n-    // comparisons\n-\n-    friend constexpr bool\n-    operator==(strong_equality __v, __cmp_cat::__unspec) noexcept\n-    { return __v._M_value == 0; }\n-\n-    friend constexpr bool\n-    operator==(strong_equality, strong_equality) noexcept = default;\n-\n-    friend constexpr strong_equality\n-    operator<=>(strong_equality __v, __cmp_cat::__unspec) noexcept\n-    { return __v; }\n-\n-    friend constexpr strong_equality\n-    operator<=>(__cmp_cat::__unspec, strong_equality __v) noexcept\n-    { return __v; }\n-  };\n-\n-  // valid values' definitions\n-  inline constexpr strong_equality\n-  strong_equality::equal(__cmp_cat::_Eq::equal);\n-\n-  inline constexpr strong_equality\n-  strong_equality::nonequal(__cmp_cat::_Eq::nonequal);\n-\n-  inline constexpr strong_equality\n-  strong_equality::equivalent(__cmp_cat::_Eq::equivalent);\n-\n-  inline constexpr strong_equality\n-  strong_equality::nonequivalent(__cmp_cat::_Eq::nonequivalent);\n-\n   class partial_ordering\n   {\n     int _M_value;\n@@ -183,15 +86,6 @@ namespace std\n     static const partial_ordering greater;\n     static const partial_ordering unordered;\n \n-    // conversion\n-    constexpr operator weak_equality() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn weak_equality::equivalent;\n-      else\n-\treturn weak_equality::nonequivalent;\n-    }\n-\n     // comparisons\n     friend constexpr bool\n     operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept\n@@ -279,15 +173,6 @@ namespace std\n     static const weak_ordering equivalent;\n     static const weak_ordering greater;\n \n-    // conversions\n-    constexpr operator weak_equality() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn weak_equality::equivalent;\n-      else\n-\treturn weak_equality::nonequivalent;\n-    }\n-\n     constexpr operator partial_ordering() const noexcept\n     {\n       if (_M_value == 0)\n@@ -385,23 +270,6 @@ namespace std\n     static const strong_ordering equivalent;\n     static const strong_ordering greater;\n \n-    // conversions\n-    constexpr operator weak_equality() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn weak_equality::equivalent;\n-      else\n-\treturn weak_equality::nonequivalent;\n-    }\n-\n-    constexpr operator strong_equality() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn strong_equality::equal;\n-      else\n-\treturn strong_equality::nonequal;\n-    }\n-\n     constexpr operator partial_ordering() const noexcept\n     {\n       if (_M_value == 0)\n@@ -494,11 +362,11 @@ namespace std\n \n   // named comparison functions\n   constexpr bool\n-  is_eq(weak_equality __cmp) noexcept\n+  is_eq(partial_ordering __cmp) noexcept\n   { return __cmp == 0; }\n \n   constexpr bool\n-  is_neq(weak_equality __cmp) noexcept\n+  is_neq(partial_ordering __cmp) noexcept\n   { return __cmp != 0; }\n \n   constexpr bool"}]}