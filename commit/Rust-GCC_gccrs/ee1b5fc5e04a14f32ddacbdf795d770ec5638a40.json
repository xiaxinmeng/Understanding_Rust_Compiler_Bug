{"sha": "ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUxYjVmYzVlMDRhMTRmMzJkZGFjYmRmNzk1ZDc3MGVjNTYzOGE0MA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2008-02-18T00:00:00Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-02-18T00:00:00Z"}, "message": "re PR libstdc++/34797 ([parallel mode] Settings are separated for each compilation unit)\n\n2008-02-17  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/34797\n\t* include/parallel/settings.h (_Settings): Reconstruct Settings class\n\there, uglify, remove anonymous namespace and static\n\tmembers. Convert to datum.\t\n\t* include/parallel/types.h: Move Settings:: enumerations here, uglify.\n\t* src/parallel_settings.cc: New, definition for _Settings member\n\tfunctions.\t\n\t* include/parallel/multiway_merge.h: Same.\n\t* include/parallel/for_each.h: Same.\n\t* include/parallel/workstealing.h: Same.\n\t* include/parallel/base.h: Same.\n\t* include/parallel/numeric\n\t* include/parallel/features.h: Same.\n\t* include/parallel/quicksort.h: Same.\n\t* include/parallel/equally_split.h: Same.\n\t* include/parallel/algorithmfwd.h: Same.\n\t* include/parallel/omp_loop_static.h: Same.\n\t* include/parallel/random_shuffle.h: Same.\n\t* include/parallel/balanced_quicksort.h: Same.\n\t* include/parallel/tags.h: Same.\n\t* include/parallel/multiway_mergesort.h: Same.\n\t* include/parallel/numericfwd.h: Same.\n\t* include/parallel/partition.h: Same.\n\t* include/parallel/partial_sum.h: Same.\n\t* include/parallel/find.h: Same.\n\t* include/parallel/algo.h: Same.\n\t* include/parallel/omp_loop.h: Same.\n\t* include/parallel/sort.h: Same.\n\n\t* src/Makefile.am (parallel_sources): Add parallel_settings.cc.\n\t* src/Makefile.in: Regenerate.\n\t\n\t* config/abi/pre/gnu.ver: Export _Settings::get and _Settings::set.\n\nFrom-SVN: r132383", "tree": {"sha": "1ae40954f4791f14a61bb95b87627d6a6817f38b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ae40954f4791f14a61bb95b87627d6a6817f38b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/comments", "author": null, "committer": null, "parents": [{"sha": "e69044cb350bcc40d6c812a673b74e9007de8ba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69044cb350bcc40d6c812a673b74e9007de8ba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69044cb350bcc40d6c812a673b74e9007de8ba1"}], "stats": {"total": 1107, "additions": 575, "deletions": 532}, "files": [{"sha": "133e83bc0e6cb9a3acccd1e4b7423b9e61f01ac7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -1,3 +1,39 @@\n+2008-02-17  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/34797\n+\t* include/parallel/settings.h (_Settings): Reconstruct Settings class\n+\there, uglify, remove anonymous namespace and static\n+\tmembers. Convert to datum.\t\n+\t* include/parallel/types.h: Move Settings:: enumerations here, uglify.\n+\t* src/parallel_settings.cc: New, definition for _Settings member\n+\tfunctions.\t\n+\t* include/parallel/multiway_merge.h: Same.\n+\t* include/parallel/for_each.h: Same.\n+\t* include/parallel/workstealing.h: Same.\n+\t* include/parallel/base.h: Same.\n+\t* include/parallel/numeric\n+\t* include/parallel/features.h: Same.\n+\t* include/parallel/quicksort.h: Same.\n+\t* include/parallel/equally_split.h: Same.\n+\t* include/parallel/algorithmfwd.h: Same.\n+\t* include/parallel/omp_loop_static.h: Same.\n+\t* include/parallel/random_shuffle.h: Same.\n+\t* include/parallel/balanced_quicksort.h: Same.\n+\t* include/parallel/tags.h: Same.\n+\t* include/parallel/multiway_mergesort.h: Same.\n+\t* include/parallel/numericfwd.h: Same.\n+\t* include/parallel/partition.h: Same.\n+\t* include/parallel/partial_sum.h: Same.\n+\t* include/parallel/find.h: Same.\n+\t* include/parallel/algo.h: Same.\n+\t* include/parallel/omp_loop.h: Same.\n+\t* include/parallel/sort.h: Same.\n+\n+\t* src/Makefile.am (parallel_sources): Add parallel_settings.cc.\n+\t* src/Makefile.in: Regenerate.\n+\t\n+\t* config/abi/pre/gnu.ver: Export _Settings::get and _Settings::set.\n+\n 2008-02-17  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/35221"}, {"sha": "0467a8032fab50615f73e6c629d07f1e85cdd956", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -779,7 +779,15 @@ GLIBCXX_3.4.10 {\n     _ZNKSt4hashISt10error_codeEclES0_;\n     _ZNKSt4hashI[eg]EclE[eg];\n \n+    _ZSt17__verify_grouping*;\n+    \n+    _ZNSt8__detail12__prime_listE;\n+    _ZNSt3tr18__detail12__prime_listE;\n+\n     # for parallel mode\n+    _ZN14__gnu_parallel9_Settings3getEv;\n+    _ZN14__gnu_parallel9_Settings3setERS0_;\n+\n     _ZNSt9__cxx199815_List_node_base4hook*;\n     _ZNSt9__cxx199815_List_node_base4swap*;\n     _ZNSt9__cxx199815_List_node_base6unhookEv;\n@@ -788,10 +796,6 @@ GLIBCXX_3.4.10 {\n \n     _ZNSt15basic_streambufI[cw]St11char_traitsI[cw]EE6stosscEv;\n \n-    _ZSt17__verify_grouping*;\n-    \n-    _ZNSt8__detail12__prime_listE;\n-    _ZNSt3tr18__detail12__prime_listE;\n \n     _ZN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EE4syncEv;\n     _ZN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EE[5-9CD]*;"}, {"sha": "e836b284fd3d333f1e8d09a6f4b9c15f4b021431", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -87,17 +87,16 @@ namespace __parallel\n     Function\n     for_each_switch(RandomAccessIterator begin, RandomAccessIterator end, \n \t\t    Function f, random_access_iterator_tag, \n-\t\t    __gnu_parallel::parallelism parallelism_tag\n+\t\t    __gnu_parallel::_Parallelism parallelism_tag\n \t\t    = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::for_each_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().for_each_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy;\n-\t  __gnu_parallel::for_each_selector<RandomAccessIterator>\n-\t    functionality;\n+\t  __gnu_parallel::for_each_selector<RandomAccessIterator> functionality;\n \n \t  return __gnu_parallel::\n \t    for_each_template_random_access(begin, end, f, functionality,\n@@ -112,7 +111,7 @@ namespace __parallel\n   template<typename Iterator, typename Function>\n     inline Function\n     for_each(Iterator begin, Iterator end, Function f, \n-\t     __gnu_parallel::parallelism parallelism_tag)\n+\t     __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef std::iterator_traits<Iterator> iterator_traits;\n       typedef typename iterator_traits::iterator_category iterator_category;\n@@ -333,7 +332,7 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(last - begin)\n-\t    > __gnu_parallel::Settings::unique_copy_minimal_n))\n+\t    > __gnu_parallel::_Settings::get().unique_copy_minimal_n))\n \treturn __gnu_parallel::parallel_unique_copy(begin, last, out, pred);\n       else\n \treturn _GLIBCXX_STD_P::unique_copy(begin, last, out, pred);\n@@ -413,9 +412,9 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n-\t    >= __gnu_parallel::Settings::set_union_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().set_union_minimal_n\n \t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n-\t    >= __gnu_parallel::Settings::set_union_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().set_union_minimal_n))\n \treturn __gnu_parallel::parallel_set_union(begin1, end1,\n \t\t\t\t\t\t  begin2, end2, result, pred);\n       else\n@@ -519,9 +518,9 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n-\t    >= __gnu_parallel::Settings::set_union_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().set_union_minimal_n\n \t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n-\t    >= __gnu_parallel::Settings::set_union_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().set_union_minimal_n))\n \treturn __gnu_parallel::parallel_set_intersection(begin1, end1, begin2, \n \t\t\t\t\t\t\t end2, result, pred);\n       else\n@@ -632,9 +631,9 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n-\t    >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().set_symmetric_difference_minimal_n\n \t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n-\t    >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().set_symmetric_difference_minimal_n))\n \treturn __gnu_parallel::parallel_set_symmetric_difference(begin1, end1,\n \t\t\t\t\t\t\t\t begin2, end2,\n \t\t\t\t\t\t\t\t result, pred);\n@@ -741,9 +740,9 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n-\t    >= __gnu_parallel::Settings::set_difference_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().set_difference_minimal_n\n \t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n-\t    >= __gnu_parallel::Settings::set_difference_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().set_difference_minimal_n))\n \treturn __gnu_parallel::parallel_set_difference(begin1, end1,\n \t\t\t\t\t\t       begin2, end2,\n \t\t\t\t\t\t       result, pred);\n@@ -903,7 +902,7 @@ namespace __parallel\n     typename iterator_traits<RandomAccessIterator>::difference_type\n     count_switch(RandomAccessIterator begin, RandomAccessIterator end, \n \t\t const T& value, random_access_iterator_tag, \n-\t\t __gnu_parallel::parallelism parallelism_tag \n+\t\t __gnu_parallel::_Parallelism parallelism_tag \n \t\t = __gnu_parallel::parallel_unbalanced)\n     {\n       typedef iterator_traits<RandomAccessIterator> traits_type;\n@@ -913,7 +912,7 @@ namespace __parallel\n \n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::count_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().count_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  __gnu_parallel::count_selector<RandomAccessIterator, difference_type>\n@@ -941,7 +940,7 @@ namespace __parallel\n   template<typename InputIterator, typename T>\n     inline typename iterator_traits<InputIterator>::difference_type\n     count(InputIterator begin, InputIterator end, const T& value, \n-\t  __gnu_parallel::parallelism parallelism_tag)\n+\t  __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<InputIterator> traits_type;\n       typedef typename traits_type::iterator_category iterator_category;\n@@ -971,7 +970,7 @@ namespace __parallel\n     typename iterator_traits<RandomAccessIterator>::difference_type\n     count_if_switch(RandomAccessIterator begin, RandomAccessIterator end, \n \t\t    Predicate pred, random_access_iterator_tag, \n-\t\t    __gnu_parallel::parallelism parallelism_tag\n+\t\t    __gnu_parallel::_Parallelism parallelism_tag\n \t\t    = __gnu_parallel::parallel_unbalanced)\n     {\n       typedef iterator_traits<RandomAccessIterator> traits_type;\n@@ -981,7 +980,7 @@ namespace __parallel\n \n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::count_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().count_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  difference_type res = 0;\n@@ -1010,7 +1009,7 @@ namespace __parallel\n   template<typename InputIterator, typename Predicate>\n     inline typename iterator_traits<InputIterator>::difference_type\n     count_if(InputIterator begin, InputIterator end, Predicate pred, \n-\t     __gnu_parallel::parallelism parallelism_tag)\n+\t     __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<InputIterator> traits_type;\n       typedef typename traits_type::iterator_category iterator_category;\n@@ -1217,12 +1216,12 @@ namespace __parallel\n     transform1_switch(RandomAccessIterator1 begin, RandomAccessIterator1 end,\n \t\t      RandomAccessIterator2 result, UnaryOperation unary_op,\n \t\t      random_access_iterator_tag, random_access_iterator_tag,\n-\t\t      __gnu_parallel::parallelism parallelism_tag\n+\t\t      __gnu_parallel::_Parallelism parallelism_tag\n \t\t      = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::transform_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().transform_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy = true;\n@@ -1259,7 +1258,7 @@ namespace __parallel\n     inline OutputIterator\n     transform(InputIterator begin, InputIterator end, OutputIterator result,\n \t      UnaryOperation unary_op, \n-\t      __gnu_parallel::parallelism parallelism_tag)\n+\t      __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef std::iterator_traits<InputIterator> iteratori_traits;\n       typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n@@ -1306,11 +1305,11 @@ namespace __parallel\n \t\t      RandomAccessIterator3 result, BinaryOperation binary_op,\n \t\t      random_access_iterator_tag, random_access_iterator_tag,\n \t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::parallelism parallelism_tag \n+\t\t      __gnu_parallel::_Parallelism parallelism_tag \n \t\t      = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n-\t    (end1 - begin1) >= __gnu_parallel::Settings::transform_minimal_n\n+\t\t\t\t      (end1 - begin1) >= __gnu_parallel::_Settings::get().transform_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy = true;\n@@ -1352,7 +1351,7 @@ namespace __parallel\n     transform(InputIterator1 begin1, InputIterator1 end1,\n \t      InputIterator2 begin2, OutputIterator result,\n \t      BinaryOperation binary_op, \n-\t      __gnu_parallel::parallelism parallelism_tag)\n+\t      __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n       typedef typename iteratori1_traits::iterator_category\n@@ -1410,7 +1409,7 @@ namespace __parallel\n     replace_switch(RandomAccessIterator begin, RandomAccessIterator end, \n \t\t   const T& old_value, const T& new_value, \n \t\t   random_access_iterator_tag, \n-\t\t   __gnu_parallel::parallelism parallelism_tag\n+\t\t   __gnu_parallel::_Parallelism parallelism_tag\n \t\t   = __gnu_parallel::parallel_balanced)\n     {\n       // XXX parallel version is where?\n@@ -1422,7 +1421,7 @@ namespace __parallel\n   template<typename ForwardIterator, typename T>\n     inline void\n     replace(ForwardIterator begin, ForwardIterator end, const T& old_value, \n-\t    const T& new_value, __gnu_parallel::parallelism parallelism_tag)\n+\t    const T& new_value, __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<ForwardIterator> traits_type;\n       typedef typename traits_type::iterator_category iterator_category;\n@@ -1463,12 +1462,12 @@ namespace __parallel\n     replace_if_switch(RandomAccessIterator begin, RandomAccessIterator end,\n \t\t      Predicate pred, const T& new_value,\n \t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::parallelism parallelism_tag\n+\t\t      __gnu_parallel::_Parallelism parallelism_tag\n \t\t      = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::replace_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().replace_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy;\n@@ -1491,7 +1490,7 @@ namespace __parallel\n     inline void\n     replace_if(ForwardIterator begin, ForwardIterator end,\n \t       Predicate pred, const T& new_value, \n-\t       __gnu_parallel::parallelism parallelism_tag)\n+\t       __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef std::iterator_traits<ForwardIterator> iterator_traits;\n       typedef typename iterator_traits::iterator_category iterator_category;\n@@ -1528,12 +1527,12 @@ namespace __parallel\n     void\n     generate_switch(RandomAccessIterator begin, RandomAccessIterator end,\n \t\t    Generator gen, random_access_iterator_tag, \n-\t\t    __gnu_parallel::parallelism parallelism_tag\n+\t\t    __gnu_parallel::_Parallelism parallelism_tag\n \t\t    = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::generate_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().generate_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy;\n@@ -1552,7 +1551,7 @@ namespace __parallel\n   template<typename ForwardIterator, typename Generator>\n     inline void\n     generate(ForwardIterator begin, ForwardIterator end,\n-\t     Generator gen, __gnu_parallel::parallelism parallelism_tag)\n+\t     Generator gen, __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef std::iterator_traits<ForwardIterator> iterator_traits;\n       typedef typename iterator_traits::iterator_category iterator_category;\n@@ -1588,7 +1587,7 @@ namespace __parallel\n     inline RandomAccessIterator\n     generate_n_switch(RandomAccessIterator begin, Size n, Generator gen, \n \t\t      random_access_iterator_tag, \n-\t\t      __gnu_parallel::parallelism parallelism_tag\n+\t\t      __gnu_parallel::_Parallelism parallelism_tag\n \t\t      = __gnu_parallel::parallel_balanced)\n     {\n       // XXX parallel version is where?\n@@ -1599,7 +1598,7 @@ namespace __parallel\n   template<typename OutputIterator, typename Size, typename Generator>\n     inline OutputIterator\n     generate_n(OutputIterator begin, Size n, Generator gen, \n-\t       __gnu_parallel::parallelism parallelism_tag)\n+\t       __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef std::iterator_traits<OutputIterator> iterator_traits;\n       typedef typename iterator_traits::iterator_category iterator_category;\n@@ -1661,7 +1660,7 @@ namespace __parallel\n \treturn;\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::random_shuffle_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().random_shuffle_minimal_n))\n \t__gnu_parallel::parallel_random_shuffle(begin, end, rand);\n       else\n \t__gnu_parallel::sequential_random_shuffle(begin, end, rand);\n@@ -1689,7 +1688,7 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::partition_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().partition_minimal_n))\n \t{\n \t  typedef typename std::iterator_traits<RandomAccessIterator>::\n \t    difference_type difference_type;\n@@ -1748,7 +1747,7 @@ namespace __parallel\n \t{\n \t  if (_GLIBCXX_PARALLEL_CONDITION(\n \t\tstatic_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t\t>= __gnu_parallel::Settings::sort_minimal_n))\n+\t\t>= __gnu_parallel::_Settings::get().sort_minimal_n))\n \t    __gnu_parallel::parallel_sort(begin, end, comp, false);\n \t  else\n \t    sort(begin, end, comp, __gnu_parallel::sequential_tag());\n@@ -1788,7 +1787,7 @@ namespace __parallel\n \t{\n \t  if (_GLIBCXX_PARALLEL_CONDITION(\n \t\tstatic_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t\t>= __gnu_parallel::Settings::sort_minimal_n))\n+\t\t>= __gnu_parallel::_Settings::get().sort_minimal_n))\n \t    __gnu_parallel::parallel_sort(begin, end, comp, true);\n \t  else\n \t    stable_sort(begin, end, comp, __gnu_parallel::sequential_tag());\n@@ -1837,9 +1836,9 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    (static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n-\t     >= __gnu_parallel::Settings::merge_minimal_n\n+\t     >= __gnu_parallel::_Settings::get().merge_minimal_n\n \t     || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n-\t     >= __gnu_parallel::Settings::merge_minimal_n)))\n+\t     >= __gnu_parallel::_Settings::get().merge_minimal_n)))\n \treturn __gnu_parallel::parallel_merge_advance(begin1, end1,\n \t\t\t\t\t\t      begin2, end2,\n \t\t\t\t\t\t      result, (end1 - begin1)\n@@ -1913,7 +1912,7 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::nth_element_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().nth_element_minimal_n))\n \t__gnu_parallel::parallel_nth_element(begin, nth, end, comp);\n       else\n \tnth_element(begin, nth, end, comp, __gnu_parallel::sequential_tag());\n@@ -1953,7 +1952,7 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::partial_sort_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().partial_sort_minimal_n))\n \t__gnu_parallel::parallel_partial_sort(begin, middle, end, comp);\n       else\n \tpartial_sort(begin, middle, end, comp,\n@@ -1997,12 +1996,12 @@ namespace __parallel\n     RandomAccessIterator\n     max_element_switch(RandomAccessIterator begin, RandomAccessIterator end, \n \t\t       Comparator comp, random_access_iterator_tag, \n-\t\t       __gnu_parallel::parallelism parallelism_tag\n+\t\t       __gnu_parallel::_Parallelism parallelism_tag\n \t\t       = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::max_element_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().max_element_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  RandomAccessIterator res(begin);\n@@ -2026,7 +2025,7 @@ namespace __parallel\n   template<typename ForwardIterator>\n     inline ForwardIterator\n     max_element(ForwardIterator begin, ForwardIterator end, \n-\t\t__gnu_parallel::parallelism parallelism_tag)\n+\t\t__gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n       return max_element(begin, end, std::less<value_type>(), parallelism_tag);\n@@ -2044,7 +2043,7 @@ namespace __parallel\n   template<typename ForwardIterator, typename Comparator>\n     inline ForwardIterator\n     max_element(ForwardIterator begin, ForwardIterator end, Comparator comp,\n-\t\t__gnu_parallel::parallelism parallelism_tag)\n+\t\t__gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<ForwardIterator> traits_type;\n       typedef typename traits_type::iterator_category iterator_category;\n@@ -2088,12 +2087,12 @@ namespace __parallel\n     RandomAccessIterator\n     min_element_switch(RandomAccessIterator begin, RandomAccessIterator end, \n \t\t       Comparator comp, random_access_iterator_tag, \n-\t\t       __gnu_parallel::parallelism parallelism_tag\n+\t\t       __gnu_parallel::_Parallelism parallelism_tag\n \t\t       = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::min_element_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().min_element_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  RandomAccessIterator res(begin);\n@@ -2117,7 +2116,7 @@ namespace __parallel\n   template<typename ForwardIterator>\n     inline ForwardIterator\n     min_element(ForwardIterator begin, ForwardIterator end, \n-\t\t__gnu_parallel::parallelism parallelism_tag)\n+\t\t__gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n       return min_element(begin, end, std::less<value_type>(), parallelism_tag);\n@@ -2135,7 +2134,7 @@ namespace __parallel\n   template<typename ForwardIterator, typename Comparator>\n     inline ForwardIterator\n     min_element(ForwardIterator begin, ForwardIterator end, Comparator comp,\n-\t\t__gnu_parallel::parallelism parallelism_tag)\n+\t\t__gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<ForwardIterator> traits_type;\n       typedef typename traits_type::iterator_category iterator_category;"}, {"sha": "ea6b245eb7e2b2a1ac29c76d2d0c7583e21799c3", "filename": "libstdc++-v3/include/parallel/algorithmfwd.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -90,7 +90,7 @@ namespace __parallel\n \n   template<typename _IIter, typename _Tp>\n     typename iterator_traits<_IIter>::difference_type\n-    count(_IIter, _IIter, const _Tp&, __gnu_parallel::parallelism);\n+    count(_IIter, _IIter, const _Tp&, __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _Tp, typename _IterTag>\n     typename iterator_traits<_IIter>::difference_type\n@@ -99,7 +99,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Tp>\n     typename iterator_traits<_RAIter>::difference_type\n     count_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag,\n-\t\t __gnu_parallel::parallelism);\n+\t\t __gnu_parallel::_Parallelism);\n \n \n   template<typename _IIter, typename _Predicate>\n@@ -112,7 +112,7 @@ namespace __parallel\n \n   template<typename _IIter, typename _Predicate>\n     typename iterator_traits<_IIter>::difference_type\n-    count_if(_IIter, _IIter, _Predicate, __gnu_parallel::parallelism);\n+    count_if(_IIter, _IIter, _Predicate, __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _Predicate, typename _IterTag>\n     typename iterator_traits<_IIter>::difference_type\n@@ -121,7 +121,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Predicate>\n     typename iterator_traits<_RAIter>::difference_type\n     count_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag,\n-\t\t    __gnu_parallel::parallelism);\n+\t\t    __gnu_parallel::_Parallelism);\n \n   // algobase.h\n   template<typename _IIter1, typename _IIter2>\n@@ -219,7 +219,7 @@ namespace __parallel\n \n   template<typename _Iterator, typename _Function>\n     _Function\n-    for_each(_Iterator, _Iterator, _Function, __gnu_parallel::parallelism);\n+    for_each(_Iterator, _Iterator, _Function, __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _Function, typename _IterTag>\n     _Function\n@@ -228,7 +228,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Function>\n     _Function\n     for_each_switch(_RAIter, _RAIter, _Function, random_access_iterator_tag, \n-\t\t    __gnu_parallel::parallelism);\n+\t\t    __gnu_parallel::_Parallelism);\n \n \n   template<typename _FIter, typename _Generator>\n@@ -241,7 +241,7 @@ namespace __parallel\n \n   template<typename _FIter, typename _Generator>\n     void\n-    generate(_FIter, _FIter, _Generator, __gnu_parallel::parallelism);\n+    generate(_FIter, _FIter, _Generator, __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Generator, typename _IterTag>\n     void\n@@ -250,7 +250,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Generator>\n     void\n     generate_switch(_RAIter, _RAIter, _Generator, random_access_iterator_tag, \n-\t\t    __gnu_parallel::parallelism);\n+\t\t    __gnu_parallel::_Parallelism);\n \n   template<typename _OIter, typename _Size, typename _Generator>\n     _OIter\n@@ -262,7 +262,7 @@ namespace __parallel\n \n   template<typename _OIter, typename _Size, typename _Generator>\n     _OIter\n-    generate_n(_OIter, _Size, _Generator, __gnu_parallel::parallelism);\n+    generate_n(_OIter, _Size, _Generator, __gnu_parallel::_Parallelism);\n \n   template<typename _OIter, typename _Size, typename _Generator,\n \t   typename _IterTag>\n@@ -272,7 +272,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Size, typename _Generator>\n     _RAIter\n     generate_n_switch(_RAIter, _Size, _Generator, random_access_iterator_tag, \n-\t\t      __gnu_parallel::parallelism);\n+\t\t      __gnu_parallel::_Parallelism);\n \n   template<typename _IIter1, typename _IIter2>\n     bool\n@@ -416,7 +416,7 @@ namespace __parallel\n   template<typename _IIter, typename _OIter, typename UnaryOperation>\n     _OIter\n     transform(_IIter, _IIter, _OIter, UnaryOperation, \n-\t      __gnu_parallel::parallelism);\n+\t      __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _OIter, typename UnaryOperation,\n \t   typename _IterTag1, typename _IterTag2>\n@@ -429,7 +429,7 @@ namespace __parallel\n     _RAOIter\n     transform1_switch(_RAIIter, _RAIIter, _RAOIter, UnaryOperation, \n \t\t      random_access_iterator_tag, random_access_iterator_tag, \n-\t\t      __gnu_parallel::parallelism);\n+\t\t      __gnu_parallel::_Parallelism);\n \n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n@@ -447,15 +447,15 @@ namespace __parallel\n \t   typename _BiOperation>\n     _OIter\n     transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n-\t      __gnu_parallel::parallelism);\n+\t      __gnu_parallel::_Parallelism);\n \n   template<typename _RAIter1, typename _RAIter2, typename _RAIter3,\n \t   typename _BiOperation>\n     _RAIter3\n     transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, \n \t\t      random_access_iterator_tag, random_access_iterator_tag, \n \t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::parallelism);\n+\t\t      __gnu_parallel::_Parallelism);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n \t   typename _BiOperation, typename _Tag1,\n@@ -477,7 +477,7 @@ namespace __parallel\n   template<typename _FIter, typename _Tp>\n     void\n     replace(_FIter, _FIter, const _Tp&, const _Tp&,\n-\t    __gnu_parallel::parallelism);\n+\t    __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Tp, typename _IterTag>\n     void\n@@ -486,7 +486,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Tp>\n     void\n     replace_switch(_RAIter, _RAIter, const _Tp&, const _Tp&, \n-\t\t   random_access_iterator_tag, __gnu_parallel::parallelism);\n+\t\t   random_access_iterator_tag, __gnu_parallel::_Parallelism);\n \n \n   template<typename _FIter, typename _Predicate, typename _Tp>\n@@ -501,7 +501,7 @@ namespace __parallel\n   template<typename _FIter, typename _Predicate, typename _Tp>\n     void\n     replace_if(_FIter, _FIter, _Predicate, const _Tp&,\n-\t       __gnu_parallel::parallelism);\n+\t       __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Predicate, typename _Tp,\n \t   typename _IterTag>\n@@ -512,7 +512,7 @@ namespace __parallel\n     void\n     replace_if_switch(_RAIter, _RAIter, _Predicate, const _Tp&,\n \t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::parallelism);\n+\t\t      __gnu_parallel::_Parallelism);\n \n \n   template<typename _FIter>\n@@ -525,7 +525,7 @@ namespace __parallel\n \n   template<typename _FIter>\n     _FIter\n-    max_element(_FIter, _FIter, __gnu_parallel::parallelism);\n+    max_element(_FIter, _FIter, __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Compare>\n     _FIter\n@@ -537,7 +537,7 @@ namespace __parallel\n \n   template<typename _FIter, typename _Compare>\n     _FIter\n-    max_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism);\n+    max_element(_FIter, _FIter, _Compare, __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Compare, typename _IterTag>\n     _FIter\n@@ -546,7 +546,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Compare>\n     _RAIter\n     max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n-\t\t       __gnu_parallel::parallelism);\n+\t\t       __gnu_parallel::_Parallelism);\n \n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n@@ -594,7 +594,7 @@ namespace __parallel\n \n   template<typename _FIter>\n     _FIter\n-    min_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag);\n+    min_element(_FIter, _FIter, __gnu_parallel::_Parallelism parallelism_tag);\n \n   template<typename _FIter, typename _Compare>\n     _FIter\n@@ -606,7 +606,7 @@ namespace __parallel\n \n   template<typename _FIter, typename _Compare>\n     _FIter\n-    min_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism);\n+    min_element(_FIter, _FIter, _Compare, __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Compare, typename _IterTag>\n     _FIter\n@@ -615,7 +615,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Compare>\n     _RAIter\n     min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n-\t\t       __gnu_parallel::parallelism);\n+\t\t       __gnu_parallel::_Parallelism);\n \n   template<typename _RAIter>\n     void"}, {"sha": "f6b3297cb4509752f32d15bb1b9fde34654acff1", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -252,7 +252,7 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     QSBThreadLocal<RandomAccessIterator>& tl = *tls[iam];\n \n-    difference_type base_case_n = Settings::sort_qsb_base_case_maximal_n;\n+    difference_type base_case_n = _Settings::get().sort_qsb_base_case_maximal_n;\n     if (base_case_n < 2)\n       base_case_n = 2;\n     thread_index_t num_threads = tl.num_threads;"}, {"sha": "2060d817e0ca2b0a2d01849500b098a8a6fb2690", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -38,11 +38,12 @@\n #ifndef _GLIBCXX_PARALLEL_BASE_H\n #define _GLIBCXX_PARALLEL_BASE_H 1\n \n-#include <parallel/features.h>\n+#include <cstdio>\n #include <functional>\n+#include <omp.h>\n+#include <parallel/features.h>\n #include <parallel/basic_iterator.h>\n #include <parallel/parallel.h>\n-#include <cstdio>\n \n \n // Parallel mode namespaces.\n@@ -67,6 +68,7 @@ namespace __gnu_parallel\n  */\n namespace __gnu_sequential \n { \n+  // Import whatever is the serial version.\n #ifdef _GLIBCXX_PARALLEL\n   using namespace std::__norm;\n #else\n@@ -77,6 +79,22 @@ namespace __gnu_sequential\n \n namespace __gnu_parallel\n {\n+  // NB: Including this file cannot produce (unresolved) symbols from\n+  // the OpenMP runtime unless the parallel mode is actually invoked\n+  // and active, which imples that the OpenMP runtime is actually\n+  // going to be linked in.\n+  inline int\n+  get_max_threads() \n+  { \n+    int __i = omp_get_max_threads();\n+    return __i > 1 ? __i : 1; \n+  }\n+\n+  \n+  inline bool \n+  is_parallel(const _Parallelism __p) { return __p != sequential; }\n+\n+\n   // XXX remove std::duplicates from here if possible,\n   // XXX but keep minimal dependencies.\n \n@@ -175,11 +193,8 @@ template<typename _Predicate, typename argument_type>\n \n /** @brief Similar to std::binder1st,\n   *  but giving the argument types explicitly. */\n-template<\n-    typename _Operation,\n-    typename first_argument_type,\n-    typename second_argument_type,\n-    typename result_type>\n+template<typename _Operation, typename first_argument_type,\n+\t typename second_argument_type, typename result_type>\n   class binder1st\n   : public std::unary_function<second_argument_type, result_type>\n   {\n@@ -207,11 +222,8 @@ template<\n   *  @brief Similar to std::binder2nd, but giving the argument types\n   *  explicitly.\n   */\n-template<\n-    typename _Operation,\n-    typename first_argument_type,\n-    typename second_argument_type,\n-    typename result_type>\n+template<typename _Operation, typename first_argument_type,\n+\t typename second_argument_type, typename result_type>\n   class binder2nd\n   : public std::unary_function<first_argument_type, result_type>\n   {"}, {"sha": "37e458167278b6339471b1b1c1541a67c805d533", "filename": "libstdc++-v3/include/parallel/equally_split.h", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -51,13 +51,11 @@ namespace __gnu_parallel\n  *  @returns End of splitter sequence, i. e. @c s+num_threads+1 */\n template<typename difference_type, typename OutputIterator>\n   OutputIterator\n-  equally_split(difference_type n,\n-                thread_index_t num_threads,\n-                OutputIterator s)\n+  equally_split(difference_type n, thread_index_t num_threads, OutputIterator s)\n   {\n-    difference_type chunk_length = n / num_threads,\n-                    num_longer_chunks = n % num_threads,\n-                    pos = 0;\n+    difference_type chunk_length = n / num_threads;\n+    difference_type num_longer_chunks = n % num_threads;\n+    difference_type pos = 0;\n     for (thread_index_t i = 0; i < num_threads; ++i)\n       {\n         *s++ = pos;\n@@ -75,17 +73,16 @@ template<typename difference_type, typename OutputIterator>\n  *  thread number thread_no+1 (excluded).\n  *  @param n Number of elements\n  *  @param num_threads Number of parts\n- *  @returns Splitting point */\n+ *  @returns _SplittingAlgorithm point */\n template<typename difference_type>\n   difference_type\n   equally_split_point(difference_type n,\n                       thread_index_t num_threads,\n                       thread_index_t thread_no)\n   {\n-    difference_type chunk_length = n / num_threads,\n-                    num_longer_chunks = n % num_threads;\n-\n-    if(thread_no < num_longer_chunks)\n+    difference_type chunk_length = n / num_threads;\n+    difference_type num_longer_chunks = n % num_threads;\n+    if (thread_no < num_longer_chunks)\n       return thread_no * (chunk_length + 1);\n     else\n       return num_longer_chunks * (chunk_length + 1)"}, {"sha": "2e09980405ed9a6873cb663b0939c348c53137bb", "filename": "libstdc++-v3/include/parallel/features.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -43,100 +43,100 @@\n #ifndef _GLIBCXX_MERGESORT\n /** @def _GLIBCXX_MERGESORT\n  *  @brief Include parallel multi-way mergesort.\n- *  @see __gnu_parallel::Settings::sort_algorithm */\n+ *  @see __gnu_parallel::_Settings::sort_algorithm */\n #define _GLIBCXX_MERGESORT 1\n #endif\n \n #ifndef _GLIBCXX_QUICKSORT\n /** @def _GLIBCXX_QUICKSORT\n  *  @brief Include parallel unbalanced quicksort.\n- *  @see __gnu_parallel::Settings::sort_algorithm */\n+ *  @see __gnu_parallel::_Settings::sort_algorithm */\n #define _GLIBCXX_QUICKSORT 1\n #endif\n \n #ifndef _GLIBCXX_BAL_QUICKSORT\n /** @def _GLIBCXX_BAL_QUICKSORT\n  *  @brief Include parallel dynamically load-balanced quicksort.\n- *  @see __gnu_parallel::Settings::sort_algorithm */\n+ *  @see __gnu_parallel::_Settings::sort_algorithm */\n #define _GLIBCXX_BAL_QUICKSORT 1\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE\n /** @def _GLIBCXX_LOSER_TREE\n  *  @brief Include guarded (sequences may run empty) loser tree,\n  *  moving objects.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE 1\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_EXPLICIT\n /** @def _GLIBCXX_LOSER_TREE_EXPLICIT\n  *  @brief Include standard loser tree, storing two flags for infimum\n  *  and supremum.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE_EXPLICIT 0\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_REFERENCE\n /** @def _GLIBCXX_LOSER_TREE_REFERENCE\n  *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE_REFERENCE 0\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_POINTER\n /** @def _GLIBCXX_LOSER_TREE_POINTER\n  *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE_POINTER 1\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_UNGUARDED\n /** @def _GLIBCXX_LOSER_TREE_UNGUARDED\n  *  @brief Include unguarded (sequences must not run empty) loser\n  *  tree, moving objects.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE_UNGUARDED 0\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n /** @def _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n  *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED 1\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_COMBINED\n /** @def _GLIBCXX_LOSER_TREE_COMBINED\n  *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE_COMBINED 0\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_SENTINEL\n /** @def _GLIBCXX_LOSER_TREE_SENTINEL\n  *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+ *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n #define _GLIBCXX_LOSER_TREE_SENTINEL 0\n #endif\n \n \n #ifndef _GLIBCXX_FIND_GROWING_BLOCKS\n /** @brief Include the growing blocks variant for std::find.\n- *  @see __gnu_parallel::Settings::find_distribution */\n+ *  @see __gnu_parallel::_Settings::find_algorithm */\n #define _GLIBCXX_FIND_GROWING_BLOCKS 1\n #endif\n \n #ifndef _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS\n /** @brief Include the equal-sized blocks variant for std::find.\n- *  @see __gnu_parallel::Settings::find_distribution */\n+ *  @see __gnu_parallel::_Settings::find_algorithm */\n #define _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS 1\n #endif\n \n #ifndef _GLIBCXX_FIND_EQUAL_SPLIT\n /** @def _GLIBCXX_FIND_EQUAL_SPLIT\n  *  @brief Include the equal splitting variant for std::find.\n- *  @see __gnu_parallel::Settings::find_distribution */\n+ *  @see __gnu_parallel::_Settings::find_algorithm */\n #define _GLIBCXX_FIND_EQUAL_SPLIT 1\n #endif\n "}, {"sha": "3e0084f68ab6ea08fa8cd77a8cbe98dbf829acc4", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -66,15 +66,15 @@ template<typename RandomAccessIterator1,\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n                 RandomAccessIterator2 begin2, Pred pred, Selector selector)\n   {\n-    switch (Settings::find_distribution)\n+    switch (_Settings::get().find_algorithm)\n       {\n-      case Settings::GROWING_BLOCKS:\n+      case GROWING_BLOCKS:\n         return find_template(begin1, end1, begin2, pred, selector,\n \t\t\t     growing_blocks_tag());\n-      case Settings::CONSTANT_SIZE_BLOCKS:\n+      case CONSTANT_SIZE_BLOCKS:\n         return find_template(begin1, end1, begin2, pred, selector,\n \t\t\t     constant_size_blocks_tag());\n-      case Settings::EQUAL_SPLIT:\n+      case EQUAL_SPLIT:\n         return find_template(begin1, end1, begin2, pred, selector,\n \t\t\t     equal_split_tag());\n       default:\n@@ -176,10 +176,10 @@ template<typename RandomAccessIterator1,\n  *  @param pred Find predicate.\n  *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n- *  @see __gnu_parallel::Settings::find_sequential_search_size\n- *  @see __gnu_parallel::Settings::find_initial_block_size\n- *  @see __gnu_parallel::Settings::find_maximum_block_size\n- *  @see __gnu_parallel::Settings::find_increasing_factor\n+ *  @see __gnu_parallel::_Settings::find_sequential_search_size\n+ *  @see __gnu_parallel::_Settings::find_initial_block_size\n+ *  @see __gnu_parallel::_Settings::find_maximum_block_size\n+ *  @see __gnu_parallel::_Settings::find_increasing_factor\n  *\n  *  There are two main differences between the growing blocks and\n  *  the constant-size blocks variants.\n@@ -204,10 +204,12 @@ template<typename RandomAccessIterator1,\n     typedef typename traits_type::difference_type difference_type;\n     typedef typename traits_type::value_type value_type;\n \n+    const _Settings& __s = _Settings::get();\n+\n     difference_type length = end1 - begin1;\n \n     difference_type sequential_search_size =\n-      std::min<difference_type>(length, Settings::find_sequential_search_size);\n+      std::min<difference_type>(length, __s.find_sequential_search_size);\n \n     // Try it sequentially first.\n     std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n@@ -233,7 +235,7 @@ template<typename RandomAccessIterator1,\n         // Not within first k elements -> start parallel.\n         thread_index_t iam = omp_get_thread_num();\n \n-        difference_type block_size = Settings::find_initial_block_size;\n+        difference_type block_size = __s.find_initial_block_size;\n         difference_type start =\n             fetch_and_add<difference_type>(&next_block_start, block_size);\n \n@@ -269,9 +271,8 @@ template<typename RandomAccessIterator1,\n               }\n \n             block_size =\n-\t      std::min<difference_type>(block_size\n-\t\t\t\t\t* Settings::find_increasing_factor,\n-\t\t\t\t\tSettings::find_maximum_block_size);\n+\t      std::min<difference_type>(block_size * __s.find_increasing_factor,\n+\t\t\t\t\t__s.find_maximum_block_size);\n \n             // Get new block, update pointer to next block.\n             start =\n@@ -302,8 +303,8 @@ template<typename RandomAccessIterator1,\n  *  @param pred Find predicate.\n  *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n- *  @see __gnu_parallel::Settings::find_sequential_search_size\n- *  @see __gnu_parallel::Settings::find_block_size\n+ *  @see __gnu_parallel::_Settings::find_sequential_search_size\n+ *  @see __gnu_parallel::_Settings::find_block_size\n  *  There are two main differences between the growing blocks and the\n  *  constant-size blocks variants.\n  *  1. For GB, the block size grows; for CSB, the block size is fixed.\n@@ -325,10 +326,12 @@ template<typename RandomAccessIterator1,\n     typedef typename traits_type::difference_type difference_type;\n     typedef typename traits_type::value_type value_type;\n \n+    const _Settings& __s = _Settings::get();\n+\n     difference_type length = end1 - begin1;\n \n     difference_type sequential_search_size = std::min<difference_type>(\n-        length, Settings::find_sequential_search_size);\n+        length, __s.find_sequential_search_size);\n \n     // Try it sequentially first.\n     std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n@@ -351,7 +354,7 @@ template<typename RandomAccessIterator1,\n           num_threads = omp_get_num_threads();\n \n         thread_index_t iam = omp_get_thread_num();\n-        difference_type block_size = Settings::find_initial_block_size;\n+        difference_type block_size = __s.find_initial_block_size;\n \n         // First element of thread's current iteration.\n         difference_type iteration_start = sequential_search_size;"}, {"sha": "8a4d702d2d548a18525752780b95765a99e7ddc0", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -71,7 +71,7 @@ namespace __gnu_parallel\n \t\t\t\t    Result& output, typename\n \t\t\t\t    std::iterator_traits<InputIterator>::\n \t\t\t\t    difference_type bound,\n-\t\t\t\t    parallelism parallelism_tag)\n+\t\t\t\t    _Parallelism parallelism_tag)\n     {\n       if (parallelism_tag == parallel_unbalanced)\n \treturn for_each_template_random_access_ed(begin, end, user_op,"}, {"sha": "6cc724b6015bf01b073ffa6be9cdd343d83f27c0", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -1359,11 +1359,10 @@ template<typename RandomAccessIteratorIterator,\n     RandomAccessIterator3 return_target = target;\n     int k = static_cast<int>(seqs_end - seqs_begin);\n \n-    Settings::MultiwayMergeAlgorithm mwma =\n-        Settings::multiway_merge_algorithm;\n+    _MultiwayMergeAlgorithm mwma = _Settings::get().multiway_merge_algorithm;\n \n-    if (!sentinel && mwma == Settings::LOSER_TREE_SENTINEL)\n-      mwma = Settings::LOSER_TREE_COMBINED;\n+    if (!sentinel && mwma == LOSER_TREE_SENTINEL)\n+      mwma = LOSER_TREE_COMBINED;\n \n     switch (k)\n       {\n@@ -1385,14 +1384,14 @@ template<typename RandomAccessIteratorIterator,\n       case 3:\n         switch (mwma)\n           {\n-          case Settings::LOSER_TREE_COMBINED:\n+          case LOSER_TREE_COMBINED:\n             return_target = multiway_merge_3_combined(seqs_begin,\n \t\t\t\t\t\t      seqs_end,\n \t\t\t\t\t\t      target,\n \t\t\t\t\t\t      comp, length,\n \t\t\t\t\t\t      stable);\n             break;\n-          case Settings::LOSER_TREE_SENTINEL:\n+          case LOSER_TREE_SENTINEL:\n             return_target =\n \t      multiway_merge_3_variant<unguarded_iterator>(seqs_begin,\n \t\t\t\t\t\t\t   seqs_end,\n@@ -1413,13 +1412,13 @@ template<typename RandomAccessIteratorIterator,\n       case 4:\n         switch (mwma)\n           {\n-          case Settings::LOSER_TREE_COMBINED:\n+          case LOSER_TREE_COMBINED:\n             return_target = multiway_merge_4_combined(seqs_begin,\n \t\t\t\t\t\t      seqs_end,\n \t\t\t\t\t\t      target,\n \t\t\t\t\t\t      comp, length, stable);\n             break;\n-          case Settings::LOSER_TREE_SENTINEL:\n+          case LOSER_TREE_SENTINEL:\n             return_target = \n \t      multiway_merge_4_variant<unguarded_iterator>(seqs_begin,\n \t\t\t\t\t\t\t   seqs_end,\n@@ -1440,14 +1439,14 @@ template<typename RandomAccessIteratorIterator,\n         {\n           switch (mwma)\n             {\n-            case Settings::BUBBLE:\n+            case BUBBLE:\n               return_target = multiway_merge_bubble(seqs_begin,\n \t\t\t\t\t\t    seqs_end,\n \t\t\t\t\t\t    target,\n \t\t\t\t\t\t    comp, length, stable);\n               break;\n #if _GLIBCXX_LOSER_TREE_EXPLICIT\n-            case Settings::LOSER_TREE_EXPLICIT:\n+            case LOSER_TREE_EXPLICIT:\n               return_target = multiway_merge_loser_tree<\n \t      LoserTreeExplicit<value_type, Comparator> >(seqs_begin,\n \t\t\t\t\t\t\t  seqs_end,\n@@ -1457,7 +1456,7 @@ template<typename RandomAccessIteratorIterator,\n               break;\n #endif\n #if _GLIBCXX_LOSER_TREE\n-            case Settings::LOSER_TREE:\n+            case LOSER_TREE:\n               return_target = multiway_merge_loser_tree<\n                     LoserTree<value_type, Comparator> >(seqs_begin,\n \t\t\t\t\t\t\tseqs_end,\n@@ -1467,7 +1466,7 @@ template<typename RandomAccessIteratorIterator,\n               break;\n #endif\n #if _GLIBCXX_LOSER_TREE_COMBINED\n-            case Settings::LOSER_TREE_COMBINED:\n+            case LOSER_TREE_COMBINED:\n               return_target = multiway_merge_loser_tree_combined(seqs_begin,\n \t\t\t\t\t\t\t\t seqs_end,\n \t\t\t\t\t\t\t\t target,\n@@ -1476,7 +1475,7 @@ template<typename RandomAccessIteratorIterator,\n               break;\n #endif\n #if _GLIBCXX_LOSER_TREE_SENTINEL\n-            case Settings::LOSER_TREE_SENTINEL:\n+            case LOSER_TREE_SENTINEL:\n               return_target = multiway_merge_loser_tree_sentinel(seqs_begin,\n \t\t\t\t\t\t\t\t seqs_end,\n \t\t\t\t\t\t\t\t target,\n@@ -1550,6 +1549,7 @@ template<typename RandomAccessIteratorIterator,\n \n       thread_index_t num_threads = static_cast<thread_index_t>(\n \tstd::min<difference_type>(get_max_threads(), total_length));\n+      const _Settings& __s = _Settings::get();\n \n #     pragma omp parallel num_threads (num_threads)\n         {\n@@ -1562,10 +1562,10 @@ template<typename RandomAccessIteratorIterator,\n               for (int s = 0; s < num_threads; ++s)\n                 pieces[s].resize(k);\n \n-              difference_type num_samples =\n-                  Settings::merge_oversampling * num_threads;\n+              difference_type num_samples = __s.merge_oversampling \n+\t\t\t\t\t    * num_threads;\n \n-              if (Settings::multiway_merge_splitting == Settings::SAMPLING)\n+              if (__s.multiway_merge_splitting == SAMPLING)\n                 {\n                   value_type* samples = static_cast<value_type*>(\n                     ::operator new(sizeof(value_type) * k * num_samples));\n@@ -1623,7 +1623,7 @@ template<typename RandomAccessIteratorIterator,\n                 }\n               else\n                 {\n-                  // (Settings::multiway_merge_splitting == Settings::EXACT).\n+                  // (_Settings::multiway_merge_splitting == _Settings::EXACT).\n                   std::vector<RandomAccessIterator1>* offsets =\n                       new std::vector<RandomAccessIterator1>[num_threads];\n                   std::vector<\n@@ -1768,10 +1768,12 @@ template<typename RandomAccessIteratorPairIterator,\n     if (seqs_begin == seqs_end)\n       return target;\n \n+    const _Settings& __s = _Settings::get();\n+\n     RandomAccessIterator3 target_end;\n     if (_GLIBCXX_PARALLEL_CONDITION(\n-        ((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k)\n-        && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n+        ((seqs_end - seqs_begin) >= __s.multiway_merge_minimal_k)\n+        && ((sequence_index_t)length >= __s.multiway_merge_minimal_n)))\n       target_end = parallel_multiway_merge(seqs_begin, seqs_end,\n \t\t\t\t\t   target, comp,\n \t\t\t\t\t  static_cast<difference_type>(length),\n@@ -1813,15 +1815,14 @@ template<typename RandomAccessIteratorPairIterator,\n \n     _GLIBCXX_CALL(seqs_end - seqs_begin)\n \n-    if (_GLIBCXX_PARALLEL_CONDITION(\n-        ((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k)\n-        && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n-      return parallel_multiway_merge(\n-          seqs_begin, seqs_end,\n-          target, comp, static_cast<difference_type>(length), stable, true);\n+    const _Settings& __s = _Settings::get();\n+    const bool cond1 = seqs_end - seqs_begin >= __s.multiway_merge_minimal_k;\n+    const bool cond2 = sequence_index_t(length) >= __s.multiway_merge_minimal_n;\n+    if (_GLIBCXX_PARALLEL_CONDITION(cond1 && cond2))\n+      return parallel_multiway_merge(seqs_begin, seqs_end, target, comp, \n+\t\t\t\t     length, stable, true);\n     else\n-      return multiway_merge(seqs_begin, seqs_end,\n-\t\t\t    target, comp, length, stable,\n+      return multiway_merge(seqs_begin, seqs_end, target, comp, length, stable,\n \t\t\t    true, sequential_tag());\n   }\n }"}, {"sha": "c8ceb2f40b7d42508fdfd656932d8a3b2f0e4a0d", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -130,8 +130,7 @@ template<typename RandomAccessIterator, typename _DifferenceTp>\n \n     thread_index_t iam = omp_get_thread_num();\n \n-    num_samples =\n-        Settings::sort_mwms_oversampling * sd->num_threads - 1;\n+    num_samples = _Settings::get().sort_mwms_oversampling * sd->num_threads - 1;\n \n     difference_type* es = new difference_type[num_samples + 2];\n \n@@ -194,8 +193,8 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     // Invariant: locally sorted subsequence in sd->sorting_places[iam],\n     // sd->sorting_places[iam] + length_local.\n-\n-    if (Settings::sort_splitting == Settings::SAMPLING)\n+    const _Settings& __s = _Settings::get();\n+    if (__s.sort_splitting == SAMPLING)\n       {\n         difference_type num_samples;\n         determine_samples(sd, num_samples);\n@@ -237,7 +236,7 @@ template<typename RandomAccessIterator, typename Comparator>\n               sd->pieces[iam][s].end = sd->starts[s + 1] - sd->starts[s];\n             }\n       }\n-    else if (Settings::sort_splitting == Settings::EXACT)\n+    else if (__s.sort_splitting == EXACT)\n       {\n #       pragma omp barrier\n \n@@ -355,6 +354,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     // shared variables\n     PMWMSSortingData<RandomAccessIterator> sd;\n     difference_type* starts;\n+    const _Settings& __s = _Settings::get();\n \n #   pragma omp parallel num_threads(num_threads)\n       {\n@@ -374,10 +374,10 @@ template<typename RandomAccessIterator, typename Comparator>\n             sd.merging_places = new RandomAccessIterator[num_threads];\n #endif\n \n-            if (Settings::sort_splitting == Settings::SAMPLING)\n+            if (__s.sort_splitting == SAMPLING)\n               {\n                 unsigned int size = \n-                    (Settings::sort_mwms_oversampling * num_threads - 1)\n+                    (__s.sort_mwms_oversampling * num_threads - 1)\n                         * num_threads;\n                 sd.samples = static_cast<value_type*>(\n \t\t  ::operator new(size * sizeof(value_type)));\n@@ -412,7 +412,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     delete[] sd.sorting_places;\n     delete[] sd.merging_places;\n \n-    if (Settings::sort_splitting == Settings::SAMPLING)\n+    if (__s.sort_splitting == SAMPLING)\n       ::operator delete(sd.samples);\n \n     delete[] sd.offsets;"}, {"sha": "1269c5251e4b8a7a1e6d510e2e2df5df81c8fe37", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -91,12 +91,12 @@ namespace __parallel\n     accumulate_switch(_RandomAccessIterator begin, _RandomAccessIterator end, \n \t\t      T init, BinaryOperation binary_op, \n \t\t      random_access_iterator_tag, \n-\t\t      __gnu_parallel::parallelism parallelism_tag  \n+\t\t      __gnu_parallel::_Parallelism parallelism_tag  \n \t\t      = __gnu_parallel::parallel_unbalanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::accumulate_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().accumulate_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  T res = init;\n@@ -121,7 +121,7 @@ namespace __parallel\n   template<typename InputIterator, typename T>\n     inline T\n     accumulate(InputIterator begin, InputIterator end, T init, \n-\t       __gnu_parallel::parallelism parallelism_tag)\n+\t       __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef std::iterator_traits<InputIterator> iterator_traits;\n       typedef typename iterator_traits::value_type value_type;\n@@ -149,7 +149,7 @@ namespace __parallel\n     inline T\n     accumulate(InputIterator begin, InputIterator end, T init, \n \t       BinaryOperation binary_op, \n-\t       __gnu_parallel::parallelism parallelism_tag)\n+\t       __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<InputIterator> iterator_traits;\n       typedef typename iterator_traits::iterator_category iterator_category;\n@@ -197,11 +197,11 @@ namespace __parallel\n \t\t\t BinaryFunction2 binary_op2,\n \t\t\t random_access_iterator_tag,\n \t\t\t random_access_iterator_tag,\n-\t\t\t __gnu_parallel::parallelism parallelism_tag\n+\t\t\t __gnu_parallel::_Parallelism parallelism_tag\n \t\t\t = __gnu_parallel::parallel_unbalanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION((last1 - first1)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n+\t\t\t\t      >= __gnu_parallel::_Settings::get().\n \t\t\t\t      accumulate_minimal_n\n \t\t\t\t      && __gnu_parallel::\n \t\t\t\t      is_parallel(parallelism_tag)))\n@@ -241,7 +241,7 @@ namespace __parallel\n     inner_product(InputIterator1 first1, InputIterator1 last1, \n \t\t  InputIterator2 first2, T init, BinaryFunction1 binary_op1, \n \t\t  BinaryFunction2 binary_op2, \n-\t\t  __gnu_parallel::parallelism parallelism_tag)\n+\t\t  __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<InputIterator1> traits1_type;\n       typedef typename traits1_type::iterator_category iterator1_category;\n@@ -276,7 +276,7 @@ namespace __parallel\n     inline T\n     inner_product(InputIterator1 first1, InputIterator1 last1, \n \t\t  InputIterator2 first2, T init, \n-\t\t  __gnu_parallel::parallelism parallelism_tag)\n+\t\t  __gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<InputIterator1> traits_type1;\n       typedef typename traits_type1::value_type value_type1;\n@@ -347,7 +347,7 @@ namespace __parallel\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::partial_sum_minimal_n))\n+\t    >= __gnu_parallel::_Settings::get().partial_sum_minimal_n))\n \treturn __gnu_parallel::parallel_partial_sum(begin, end,\n \t\t\t\t\t\t    result, bin_op);\n       else\n@@ -416,12 +416,12 @@ namespace __parallel\n \t\t\t       OutputIterator result, BinaryOperation bin_op,\n \t\t\t       random_access_iterator_tag, \n \t\t\t       random_access_iterator_tag,\n-\t\t\t       __gnu_parallel::parallelism parallelism_tag\n+\t\t\t       __gnu_parallel::_Parallelism parallelism_tag\n \t\t\t       = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n \t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n-\t    >= __gnu_parallel::Settings::adjacent_difference_minimal_n\n+\t    >= __gnu_parallel::_Settings::get().adjacent_difference_minimal_n\n \t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy = true;\n@@ -448,7 +448,7 @@ namespace __parallel\n     inline OutputIterator\n     adjacent_difference(InputIterator begin, InputIterator end,\n \t\t\tOutputIterator result,\n-\t\t\t__gnu_parallel::parallelism parallelism_tag)\n+\t\t\t__gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<InputIterator> traits_type;\n       typedef typename traits_type::value_type value_type;\n@@ -471,7 +471,7 @@ namespace __parallel\n     inline OutputIterator\n     adjacent_difference(InputIterator begin, InputIterator end,\n \t\t\tOutputIterator result, BinaryOperation binary_op,\n-\t\t\t__gnu_parallel::parallelism parallelism_tag)\n+\t\t\t__gnu_parallel::_Parallelism parallelism_tag)\n     {\n       typedef iterator_traits<InputIterator> traitsi_type;\n       typedef typename traitsi_type::iterator_category iteratori_category;"}, {"sha": "581ceaad6f4678f702df5a733d49f3fd20528336", "filename": "libstdc++-v3/include/parallel/numericfwd.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -54,7 +54,7 @@ namespace __parallel\n \n   template<typename _IIter, typename _Tp>\n     _Tp\n-    accumulate(_IIter, _IIter, _Tp, __gnu_parallel::parallelism);\n+    accumulate(_IIter, _IIter, _Tp, __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _Tp, typename _Tag>\n     _Tp\n@@ -72,7 +72,7 @@ namespace __parallel\n   template<typename _IIter, typename _Tp, typename _BinaryOper>\n     _Tp\n     accumulate(_IIter, _IIter, _Tp, _BinaryOper,\n-\t       __gnu_parallel::parallelism);\n+\t       __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _Tp, typename _BinaryOper,\n \t   typename _Tag>\n@@ -83,7 +83,7 @@ namespace __parallel\n     _Tp\n     accumulate_switch(_RAIter, _RAIter, _Tp, _BinaryOper,\n \t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::parallelism);\n+\t\t      __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _OIter>\n     _OIter\n@@ -106,12 +106,12 @@ namespace __parallel\n   template<typename _IIter, typename _OIter>\n     _OIter\n     adjacent_difference(_IIter, _IIter, _OIter,\n-\t\t\t__gnu_parallel::parallelism);\n+\t\t\t__gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n     adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n-\t\t\t__gnu_parallel::parallelism);\n+\t\t\t__gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper,\n \t   typename _Tag1, typename _Tag2>\n@@ -124,7 +124,7 @@ namespace __parallel\n     adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, \n \t\t\t       random_access_iterator_tag, \n \t\t\t       random_access_iterator_tag, \n-\t\t\t       __gnu_parallel::parallelism);\n+\t\t\t       __gnu_parallel::_Parallelism);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     _Tp\n@@ -138,7 +138,7 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     _Tp\n     inner_product(_IIter1, _IIter1, _IIter2, _Tp,\n-\t\t  __gnu_parallel::parallelism);\n+\t\t  __gnu_parallel::_Parallelism);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n \t   typename _BinaryFunction1, typename _BinaryFunction2>\n@@ -156,15 +156,15 @@ namespace __parallel\n \t   typename BinaryFunction1, typename BinaryFunction2>\n     _Tp\n     inner_product(_IIter1, _IIter1, _IIter2, _Tp, BinaryFunction1,\n-\t\t  BinaryFunction2, __gnu_parallel::parallelism);\n+\t\t  BinaryFunction2, __gnu_parallel::_Parallelism);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Tp,\n \t   typename BinaryFunction1, typename BinaryFunction2>\n     _Tp\n     inner_product_switch(_RAIter1, _RAIter1, _RAIter2, _Tp, BinaryFunction1, \n \t\t\t BinaryFunction2, random_access_iterator_tag, \n \t\t\t random_access_iterator_tag, \n-\t\t\t __gnu_parallel::parallelism);\n+\t\t\t __gnu_parallel::_Parallelism);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n \t   typename _BinaryFunction1, typename _BinaryFunction2,"}, {"sha": "bc34aed285756991013308344cd15efb88014e23", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -101,7 +101,7 @@ template<typename RandomAccessIterator,\n \n         thread_index_t iam = omp_get_thread_num();\n \n-#       pragma omp for schedule(dynamic, Settings::workstealing_chunk_size)\n+#      pragma omp for schedule(dynamic, _Settings::get().workstealing_chunk_size)\n         for (difference_type pos = 0; pos < length; ++pos)\n           thread_results[iam] =\n               r(thread_results[iam], f(o, begin+pos));"}, {"sha": "96692e8645a0ad202fa7b0298c78cfe8d7e9c657", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -101,7 +101,7 @@ template<typename RandomAccessIterator,\n \n         thread_index_t iam = omp_get_thread_num();\n \n-#       pragma omp for schedule(static, Settings::workstealing_chunk_size)\n+#       pragma omp for schedule(static, _Settings::get().workstealing_chunk_size)\n         for (difference_type pos = 0; pos < length; ++pos)\n           thread_results[iam] = r(thread_results[iam], f(o, begin+pos));\n       } //parallel"}, {"sha": "fd4954d456dab1e357988fd5898328ad7eb62e40", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -118,6 +118,8 @@ template<typename InputIterator,\n     difference_type* borders;\n     value_type* sums;\n \n+    const _Settings& __s = _Settings::get();\n+\n #   pragma omp parallel num_threads(num_threads)\n       {\n #       pragma omp single\n@@ -126,14 +128,13 @@ template<typename InputIterator,\n \n             borders = new difference_type[num_threads + 2];\n \n-            if (Settings::partial_sum_dilatation == 1.0f)\n+            if (__s.partial_sum_dilation == 1.0f)\n               equally_split(n, num_threads + 1, borders);\n             else\n               {\n                 difference_type chunk_length =\n                     ((double)n\n-\t\t     / ((double)num_threads\n-\t\t\t+ Settings::partial_sum_dilatation)),\n+\t\t     / ((double)num_threads + __s.partial_sum_dilation)),\n \t\t  borderstart = n - num_threads * chunk_length;\n                 borders[0] = 0;\n                 for (int i = 1; i < (num_threads + 1); ++i)\n@@ -209,9 +210,9 @@ template<typename InputIterator,\n \n     difference_type n = end - begin;\n \n-    switch (Settings::partial_sum_algorithm)\n+    switch (_Settings::get().partial_sum_algorithm)\n       {\n-      case Settings::LINEAR:\n+      case LINEAR:\n         // Need an initial offset.\n         return parallel_partial_sum_linear(begin, end, result, bin_op, n);\n       default:"}, {"sha": "7747b7e9980041cb2657fd5a2f3b31e9d0ef22c8", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -69,6 +69,8 @@ template<typename RandomAccessIterator, typename Predicate>\n \n     _GLIBCXX_CALL(n)\n \n+    const _Settings& __s = _Settings::get();\n+\n     // Shared.\n     _GLIBCXX_VOLATILE difference_type left = 0, right = n - 1;\n     _GLIBCXX_VOLATILE difference_type leftover_left, leftover_right;\n@@ -91,14 +93,12 @@ template<typename RandomAccessIterator, typename Predicate>\n             reserved_left = new bool[num_threads];\n             reserved_right = new bool[num_threads];\n \n-            if (Settings::partition_chunk_share > 0.0)\n-              chunk_size = std::max<difference_type>(Settings::\n-\t\t\t\t\t\t     partition_chunk_size,\n-\t\t\t\t\t\t     (double)n * Settings::\n-\t\t\t\t\t\t     partition_chunk_share\n+            if (__s.partition_chunk_share > 0.0)\n+              chunk_size = std::max<difference_type>(__s.partition_chunk_size,\n+\t\t\t\t    (double)n * __s.partition_chunk_share\n \t\t\t\t\t\t     / (double)num_threads);\n             else\n-              chunk_size = Settings::partition_chunk_size;\n+              chunk_size = __s.partition_chunk_size;\n           }\n \n         while (right - left + 1 >= 2 * num_threads * chunk_size)\n@@ -346,7 +346,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     random_number rng;\n \n     difference_type minimum_length =\n-      std::max<difference_type>(2, Settings::partition_minimal_n);\n+      std::max<difference_type>(2, _Settings::get().partition_minimal_n);\n \n     // Break if input range to small.\n     while (static_cast<sequence_index_t>(end - begin) >= minimum_length)\n@@ -409,7 +409,7 @@ template<typename RandomAccessIterator, typename Comparator>\n           break;\n       }\n \n-    // Only at most Settings::partition_minimal_n elements left.\n+    // Only at most _Settings::partition_minimal_n elements left.\n     __gnu_sequential::sort(begin, end, comp);\n   }\n "}, {"sha": "de95549772ad32c55f5aedae5f4bd1d4cc4e9708", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -134,7 +134,7 @@ namespace __gnu_parallel\n \n       difference_type split =\n \tparallel_sort_qs_divide(begin, end, comp, pivot_rank,\n-\t\t\t\tSettings::sort_qs_num_samples_preset,\n+\t\t\t\t_Settings::get().sort_qs_num_samples_preset,\n \t\t\t\tnum_threads);\n \n #pragma omp parallel sections\n@@ -179,8 +179,6 @@ namespace __gnu_parallel\n       if (num_threads > n)\n \tnum_threads = static_cast<thread_index_t>(n);\n \n-      Settings::sort_qs_num_samples_preset = 100;\n-\n       // Hard to avoid.\n       omp_set_num_threads(num_threads);\n "}, {"sha": "75d9e18d23af3d9f7a45c76c69584ca253d8609d", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -274,6 +274,8 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n \n     _GLIBCXX_CALL(n)\n \n+    const _Settings& __s = _Settings::get();\n+\n     if (num_threads > n)\n       num_threads = static_cast<thread_index_t>(n);\n \n@@ -284,7 +286,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n \n     // Must fit into L1.\n     num_bins_cache = std::max<difference_type>(\n-        1, n / (Settings::L1_cache_size_lb / sizeof(value_type)));\n+        1, n / (__s.L1_cache_size_lb / sizeof(value_type)));\n     num_bins_cache = round_up_to_pow2(num_bins_cache);\n \n     // No more buckets than TLB entries, power of 2\n@@ -293,7 +295,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n     // 2 TLB entries needed per bin.\n-    num_bins = std::min<difference_type>(Settings::TLB_size / 2, num_bins);\n+    num_bins = std::min<difference_type>(__s.TLB_size / 2, num_bins);\n #endif\n     num_bins = round_up_to_pow2(num_bins);\n \n@@ -303,7 +305,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n         // Now try the L2 cache\n         // Must fit into L2\n         num_bins_cache = static_cast<bin_index>(std::max<difference_type>(\n-            1, n / (Settings::L2_cache_size / sizeof(value_type))));\n+            1, n / (__s.L2_cache_size / sizeof(value_type))));\n         num_bins_cache = round_up_to_pow2(num_bins_cache);\n \n         // No more buckets than TLB entries, power of 2.\n@@ -313,7 +315,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n         // 2 TLB entries needed per bin.\n         num_bins = std::min(\n-            static_cast<difference_type>(Settings::TLB_size / 2), num_bins);\n+            static_cast<difference_type>(__s.TLB_size / 2), num_bins);\n #endif\n           num_bins = round_up_to_pow2(num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n@@ -403,22 +405,23 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n     typedef typename traits_type::difference_type difference_type;\n \n     difference_type n = end - begin;\n+    const _Settings& __s = _Settings::get();\n \n     bin_index num_bins, num_bins_cache;\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n     // Try the L1 cache first, must fit into L1.\n     num_bins_cache =\n         std::max<difference_type>\n-            (1, n / (Settings::L1_cache_size_lb / sizeof(value_type)));\n+            (1, n / (__s.L1_cache_size_lb / sizeof(value_type)));\n     num_bins_cache = round_up_to_pow2(num_bins_cache);\n \n     // No more buckets than TLB entries, power of 2\n     // Power of 2 and at least one element per bin, at most the TLB size\n     num_bins = std::min(n, (difference_type)num_bins_cache);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n     // 2 TLB entries needed per bin\n-    num_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+    num_bins = std::min((difference_type)__s.TLB_size / 2, num_bins);\n #endif\n     num_bins = round_up_to_pow2(num_bins);\n \n@@ -428,7 +431,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n         // Now try the L2 cache, must fit into L2.\n         num_bins_cache =\n             static_cast<bin_index>(std::max<difference_type>(\n-                1, n / (Settings::L2_cache_size / sizeof(value_type))));\n+                1, n / (__s.L2_cache_size / sizeof(value_type))));\n         num_bins_cache = round_up_to_pow2(num_bins_cache);\n \n         // No more buckets than TLB entries, power of 2\n@@ -439,7 +442,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n         // 2 TLB entries needed per bin\n         num_bins =\n-            std::min<difference_type>(Settings::TLB_size / 2, num_bins);\n+            std::min<difference_type>(__s.TLB_size / 2, num_bins);\n #endif\n         num_bins = round_up_to_pow2(num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1"}, {"sha": "ae1ae5ca063174e9d588a61b67add392b8e59a46", "filename": "libstdc++-v3/include/parallel/settings.h", "status": "modified", "additions": 170, "deletions": 283, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -29,372 +29,259 @@\n // Public License.\n \n /** @file parallel/settings.h\n- *  @brief Settings and tuning parameters, heuristics to decide\n+ *  @brief Runtime settings and tuning parameters, heuristics to decide\n  *  whether to use parallelized algorithms.\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  *\n- *  @section parallelization_decision  The decision whether to run\n- *                                     an algorithm in parallel.\n+ *  @section parallelization_decision \n+ *  The decision whether to run an algorithm in parallel.\n  *\n- *  There are several ways the user can switch on and off the \n- *  parallel execution of an algorithm, both at compile- and \n- *  run-time.\n+ *  There are several ways the user can switch on and off the parallel\n+ *  execution of an algorithm, both at compile- and run-time.\n  *\n- *  Only sequential execution can be forced at compile-time.\n- *  This reduces code size and protects code parts that have \n+ *  Only sequential execution can be forced at compile-time.  This\n+ *  reduces code size and protects code parts that have\n  *  non-thread-safe side effects.\n  *\n- *  Ultimately forcing parallel execution at compile-time does \n- *  make much sense.\n- *  Often, the sequential algorithm implementation is used as\n- *  a subroutine, so no reduction in code size can be achieved.\n- *  Also, the machine the program is run on might have only one\n- *  processor core, so to avoid overhead, the algorithm is\n- *  executed sequentially.\n+ *  Ultimately, forcing parallel execution at compile-time makes\n+ *  sense.  Often, the sequential algorithm implementation is used as\n+ *  a subroutine, so no reduction in code size can be achieved.  Also,\n+ *  the machine the program is run on might have only one processor\n+ *  core, so to avoid overhead, the algorithm is executed\n+ *  sequentially.\n  *\n- *  To force sequential execution of an algorithm ultimately\n- *  at compile-time, the user must add the tag \n- *  __gnu_parallel::sequential_tag() to the end of the\n- *  parameter list, e. g.\n+ *  To force sequential execution of an algorithm ultimately at\n+ *  compile-time, the user must add the tag\n+ *  __gnu_parallel::sequential_tag() to the end of the parameter list,\n+ *  e. g.\n  *\n  *  \\code\n  *  std::sort(v.begin(), v.end(), __gnu_parallel::sequential_tag());\n  *  \\endcode\n  *\n- *  This is compatible with all overloaded algorithm variants.\n- *  No additional code will be instantiated, at all.\n- *  The same holds for most algorithm calls with iterators \n- *  not providing random access.\n+ *  This is compatible with all overloaded algorithm variants.  No\n+ *  additional code will be instantiated, at all.  The same holds for\n+ *  most algorithm calls with iterators not providing random access.\n  *\n  *  If the algorithm call is not forced to be executed sequentially\n- *  at compile-time, the decision is made at run-time, for each call.\n- *  First, the two (conceptually) global variables \n- *  __gnu_parallel::Settings::force_sequential and \n- *  __gnu_parallel::Settings::force_parallel are executed.\n- *  If the former one is true, the sequential algorithm is executed.\n- *  If the latter one is true and the former one is false, \n- *  the algorithm is executed in parallel.\n+ *  at compile-time, the decision is made at run-time.\n+ *  The global variable __gnu_parallel::_Settings::algorithm_strategy\n+ *  is checked. It is a tristate variable corresponding to:\n  *\n- *  If none of these conditions has fired so far, a heuristic is used.\n- *  The parallel algorithm implementation is called only if the\n- *  input size is sufficiently large.\n- *  For most algorithms, the input size is the (combined) length of \n- *  the input sequence(s).\n- *  The threshold can be set by the user, individually for each\n- *  algorithm.\n- *  The according variables are called \n- *  __gnu_parallel::Settings::[algorithm]_minimal_n .\n+ *  a. force_sequential, meaning the sequential algorithm is executed.\n+ *  b. force_parallel, meaning the parallel algorithm is executed.\n+ *  c. heuristic\n+ *\n+ *  For heuristic, the parallel algorithm implementation is called\n+ *  only if the input size is sufficiently large.  For most\n+ *  algorithms, the input size is the (combined) length of the input\n+ *  sequence(s).  The threshold can be set by the user, individually\n+ *  for each algorithm.  The according variables are called\n+ *  __gnu_parallel::_Settings::[algorithm]_minimal_n .\n  *\n  *  For some of the algorithms, there are even more tuning options,\n- *  e. g. the ability to choose from multiple algorithm variants.\n- *  See the __gnu_parallel::Settings class for details.\n+ *  e. g. the ability to choose from multiple algorithm variants.  See\n+ *  below for details.\n  */\n \n // Written by Johannes Singler and Felix Putze.\n \n #ifndef _GLIBCXX_PARALLEL_SETTINGS_H\n #define _GLIBCXX_PARALLEL_SETTINGS_H 1\n \n-#include <omp.h>\n #include <parallel/types.h>\n \n /** \n-  * @brief The extensible condition on whether the parallel variant of\n-  * an algorithm should be called.\n-  * @param c A condition that is overruled by\n-  * __gnu_parallel::Settings::force_parallel, i. e. usually a decision based on\n-  * the input size.\n+  * @brief Determine at compile(?)-time if the parallel variant of an\n+  * algorithm should be called.\n+  * @param c A condition that is convertible to bool that is overruled by\n+  * __gnu_parallel::_Settings::algorithm_strategy. Usually a decision\n+  * based on the input size.\n   */\n-#define _GLIBCXX_PARALLEL_CONDITION(c) \\\n-(!(__gnu_parallel::Settings::force_sequential) \\\n- && ((__gnu_parallel::get_max_threads() > 1 \\\n-      && (c)) || __gnu_parallel::Settings::force_parallel))\n+#define _GLIBCXX_PARALLEL_CONDITION(c) (__gnu_parallel::_Settings::get().algorithm_strategy != __gnu_parallel::force_sequential && ((__gnu_parallel::get_max_threads() > 1 && (c)) || __gnu_parallel::_Settings::get().algorithm_strategy == __gnu_parallel::force_parallel))\n \n-namespace __gnu_parallel\n+/*\n+inline bool\n+parallel_condition(bool c)\n {\n-  // NB: Including this file cannot produce (unresolved) symbols from\n-  // the OpenMP runtime unless the parallel mode is actually invoked\n-  // and active, which implies that the OpenMP runtime is actually\n-  // going to be linked in.\n-  inline int\n-  get_max_threads() \n-  { return omp_get_max_threads() > 1 ? omp_get_max_threads() : 1; }\n-\n-namespace \n+  bool ret = false;\n+  const _Settings& s = _Settings::get();\n+  if (s.algorithm_strategy != force_seqential)\n+    {\n+      if (s.algorithm_strategy == force_parallel)\n+\tret = true;\n+      else\n+\tret = get_max_threads() > 1 && c;\n+    }\n+  return ret;\n+}\n+*/\n+\n+namespace __gnu_parallel\n {\n-  // XXX look at _Tune in mt_allocator.h\n-  /** @brief Run-time settings for the parallel mode. */\n-  struct Settings\n+  /// class _Settings \n+  /// Run-time settings for the parallel mode, including all tunable parameters.\n+  struct _Settings\n   {\n-    /** @brief Different parallel sorting algorithms to choose\n-\tfrom: multi-way mergesort, quicksort, load-balanced\n-\tquicksort. */\n-    enum SortAlgorithm \n-    { MWMS, QS, QS_BALANCED };\n-\n-    /** @brief Different merging algorithms: bubblesort-alike,\n-\tloser-tree variants, enum sentinel */\n-    enum MultiwayMergeAlgorithm\n-    { BUBBLE, LOSER_TREE_EXPLICIT, LOSER_TREE, LOSER_TREE_COMBINED,\n-      LOSER_TREE_SENTINEL, MWM_ALGORITHM_LAST };\n-\n-    /** @brief Different splitting strategies for sorting/merging:\n-\tby sampling, exact */\n-    enum Splitting \n-    { SAMPLING, EXACT };\n+    _AlgorithmStrategy \t\talgorithm_strategy;\n+    \n+    _SortAlgorithm \t\tsort_algorithm;\n+    _PartialSumAlgorithm \tpartial_sum_algorithm;\n+    _MultiwayMergeAlgorithm \tmultiway_merge_algorithm;\n+    _FindAlgorithm \t\tfind_algorithm;\n \n-    /** @brief Different partial sum algorithms: recursive, linear */\n-    enum PartialSumAlgorithm \n-    { RECURSIVE, LINEAR };\n+    _SplittingAlgorithm \tsort_splitting;\n+    _SplittingAlgorithm \tmerge_splitting;\n+    _SplittingAlgorithm \tmultiway_merge_splitting;\n \n-    /** @brief Different find distribution strategies: growing\n-\tblocks, equal-sized blocks, equal splitting. */\n-    enum FindDistribution \n-    { GROWING_BLOCKS, CONSTANT_SIZE_BLOCKS, EQUAL_SPLIT };\n+    // Per-algorithm settings.\n \n-    /** @brief Force all algorithms to be executed sequentially.\n-     * This setting cannot be overwritten. */\n-    static volatile bool force_sequential;\n+    /// Minimal input size for accumulate.\n+    sequence_index_t \t\taccumulate_minimal_n;\n \n-    /** @brief Force all algorithms to be executed in parallel.\n-     * This setting can be overridden by __gnu_parallel::sequential_tag\n-     * (compile-time), and force_sequential (run-time). */\n-    static volatile bool force_parallel;\n+    /// Minimal input size for adjacent_difference.\n+    unsigned int \t\tadjacent_difference_minimal_n;\n \n-    /** @brief Algorithm to use for sorting. */\n-    static volatile SortAlgorithm sort_algorithm;\n+    /// Minimal input size for count and count_if.\n+    sequence_index_t \t\tcount_minimal_n;\n \n-    /** @brief Strategy to use for splitting the input when\n-\tsorting (MWMS). */\n-    static volatile Splitting sort_splitting;\n+    /// Minimal input size for fill.\n+    sequence_index_t \t\tfill_minimal_n;\n \n-    /** @brief Minimal input size for parallel sorting. */\n-    static volatile sequence_index_t sort_minimal_n;\n+    /// Block size increase factor for find.\n+    double \t\t\tfind_increasing_factor;\n \n-    /** @brief Oversampling factor for parallel std::sort (MWMS). */\n-    static volatile unsigned int sort_mwms_oversampling;\n+    /// Initial block size for find.\n+    sequence_index_t \t\tfind_initial_block_size;\n \n-    /** @brief Such many samples to take to find a good pivot\n-\t(quicksort). */\n-    static volatile unsigned int sort_qs_num_samples_preset;\n+    /// Maximal block size for find.\n+    sequence_index_t \t\tfind_maximum_block_size;\n \n-    /** @brief Maximal subsequence length to switch to unbalanced\n-     * base case.  Applies to std::sort with dynamically\n-     * load-balanced quicksort. */\n-    static volatile sequence_index_t sort_qsb_base_case_maximal_n;\n+    /// Start with looking for this many elements sequentially, for find.\n+    sequence_index_t \t\tfind_sequential_search_size;\n \n-    /** @brief Minimal input size for parallel std::partition. */\n-    static volatile sequence_index_t partition_minimal_n;\n+    /// Minimal input size for for_each.\n+    sequence_index_t \t\tfor_each_minimal_n;\n \n-    /** @brief Chunk size for parallel std::partition. */\n-    static volatile sequence_index_t partition_chunk_size;\n+    /// Minimal input size for generate.\n+    sequence_index_t \t\tgenerate_minimal_n;\n \n-    /** @brief Chunk size for parallel std::partition, relative to\n-     * input size.  If >0.0, this value overrides\n-     * partition_chunk_size. */\n-    static volatile double partition_chunk_share;\n+    /// Minimal input size for max_element.\n+    sequence_index_t \t\tmax_element_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::nth_element. */\n-    static volatile sequence_index_t nth_element_minimal_n;\n+    /// Minimal input size for merge.\n+    sequence_index_t \t\tmerge_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::partial_sort. */\n-    static volatile sequence_index_t partial_sort_minimal_n;\n+    /// Oversampling factor for merge.\n+    unsigned int \t\tmerge_oversampling;\n \n-    /** @brief Minimal input size for parallel std::adjacent_difference. */\n-    static volatile unsigned int adjacent_difference_minimal_n;\n+    /// Minimal input size for min_element.\n+    sequence_index_t \t\tmin_element_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::partial_sum. */\n-    static volatile unsigned int partial_sum_minimal_n;\n+    /// Minimal input size for multiway_merge.\n+    sequence_index_t \t\tmultiway_merge_minimal_n;\n \n-    /** @brief Algorithm to use for std::partial_sum. */\n-    static volatile PartialSumAlgorithm partial_sum_algorithm;\n+    /// Oversampling factor for multiway_merge.\n+    int \t\t\tmultiway_merge_minimal_k;\n \n-    /** @brief Assume \"sum and write result\" to be that factor\n-     *  slower than just \"sum\".  This value is used for\n-     *  std::partial_sum. */\n-    static volatile float partial_sum_dilatation;\n+    /// Oversampling factor for multiway_merge.\n+    unsigned int \t\tmultiway_merge_oversampling;\n \n-    /** @brief Minimal input size for parallel std::random_shuffle. */\n-    static volatile unsigned int random_shuffle_minimal_n;\n+    /// Minimal input size for nth_element.\n+    sequence_index_t \t\tnth_element_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::merge. */\n-    static volatile sequence_index_t merge_minimal_n;\n+    /// Chunk size for partition.\n+    sequence_index_t \t\tpartition_chunk_size;\n \n-    /** @brief Splitting strategy for parallel std::merge. */\n-    static volatile Splitting merge_splitting;\n+    /// Chunk size for partition, relative to input size.  If > 0.0,\n+    /// this value overrides partition_chunk_size.\n+    double \t\t\tpartition_chunk_share;\n \n-    /** @brief Oversampling factor for parallel std::merge.\n-     * Such many samples per thread are collected. */\n-    static volatile unsigned int merge_oversampling;\n+    /// Minimal input size for partition.\n+    sequence_index_t \t\tpartition_minimal_n;\n \n-    /** @brief Algorithm to use for parallel\n-\t__gnu_parallel::multiway_merge. */\n-    static volatile MultiwayMergeAlgorithm multiway_merge_algorithm;\n+    /// Minimal input size for partial_sort.\n+    sequence_index_t \t\tpartial_sort_minimal_n;\n \n-    /** @brief Splitting strategy to use for parallel\n-\t__gnu_parallel::multiway_merge. */\n-    static volatile Splitting multiway_merge_splitting;\n+    /// Ratio for partial_sum. Assume \"sum and write result\" to be\n+    /// this factor slower than just \"sum\".\n+    float \t\t\tpartial_sum_dilation;\n \n-    //// Oversampling factor for parallel __gnu_parallel::multiway_merge.\n-    static volatile unsigned int multiway_merge_oversampling;\n+    /// Minimal input size for partial_sum.\n+    unsigned int \t\tpartial_sum_minimal_n;\n \n-    /// Minimal input size for parallel __gnu_parallel::multiway_merge.\n-    static volatile sequence_index_t multiway_merge_minimal_n;\n+    /// Minimal input size for random_shuffle.\n+    unsigned int \t\trandom_shuffle_minimal_n;\n \n-    /// Oversampling factor for parallel __gnu_parallel::multiway_merge.\n-    static volatile int multiway_merge_minimal_k;\n+    /// Minimal input size for replace and replace_if.\n+    sequence_index_t \t\treplace_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::unique_copy. */\n-    static volatile sequence_index_t unique_copy_minimal_n;\n+    /// Minimal input size for set_difference.\n+    sequence_index_t \t\tset_difference_minimal_n;\n \n-    static volatile sequence_index_t workstealing_chunk_size;\n+    /// Minimal input size for set_intersection.\n+    sequence_index_t \t\tset_intersection_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::for_each. */\n-    static volatile sequence_index_t for_each_minimal_n;\n+    /// Minimal input size for set_symmetric_difference.\n+    sequence_index_t \t\tset_symmetric_difference_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::count and\n-\tstd::count_if. */\n-    static volatile sequence_index_t count_minimal_n;\n+    /// Minimal input size for set_union.\n+    sequence_index_t \t\tset_union_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::transform. */\n-    static volatile sequence_index_t transform_minimal_n;\n+    /// Minimal input size for parallel sorting.\n+    sequence_index_t \t\tsort_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::replace and\n-\tstd::replace_if. */\n-    static volatile sequence_index_t replace_minimal_n;\n+    /// Oversampling factor for parallel std::sort (MWMS).\n+    unsigned int \t\tsort_mwms_oversampling;\n \n-    /** @brief Minimal input size for parallel std::generate. */\n-    static volatile sequence_index_t generate_minimal_n;\n+    /// Such many samples to take to find a good pivot (quicksort).\n+    unsigned int \t\tsort_qs_num_samples_preset;\n \n-    /** @brief Minimal input size for parallel std::fill. */\n-    static volatile sequence_index_t fill_minimal_n;\n+    /// Maximal subsequence length to switch to unbalanced base case.\n+    /// Applies to std::sort with dynamically load-balanced quicksort.\n+    sequence_index_t \t\tsort_qsb_base_case_maximal_n;\n \n-    /** @brief Minimal input size for parallel std::min_element. */\n-    static volatile sequence_index_t min_element_minimal_n;\n+    /// Minimal input size for parallel std::transform.\n+    sequence_index_t \t\ttransform_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::max_element. */\n-    static volatile sequence_index_t max_element_minimal_n;\n+    /// Minimal input size for unique_copy. \n+    sequence_index_t \t\tunique_copy_minimal_n;\n \n-    /** @brief Minimal input size for parallel std::accumulate. */\n-    static volatile sequence_index_t accumulate_minimal_n;\n+    sequence_index_t \t\tworkstealing_chunk_size;\n \n-    /** @brief Distribution strategy for parallel std::find. */\n-    static volatile FindDistribution find_distribution;\n+    // Hardware dependent tuning parameters.\n \n-    /** @brief Start with looking for that many elements\n-\tsequentially, for std::find. */\n-    static volatile sequence_index_t find_sequential_search_size;\n+    /// Size of the L1 cache in bytes (underestimation).\n+    unsigned long long \t\tL1_cache_size;\n \n-    /** @brief Initial block size for parallel std::find. */\n-    static volatile sequence_index_t find_initial_block_size;\n+    /// Size of the L2 cache in bytes (underestimation).\n+    unsigned long long \t\tL2_cache_size;\n \n-    /** @brief Maximal block size for parallel std::find. */\n-    static volatile sequence_index_t find_maximum_block_size;\n+    /// Size of the Translation Lookaside Buffer (underestimation).\n+    unsigned int \t\tTLB_size;\n \n-    /** @brief Block size increase factor for parallel std::find. */\n-    static volatile double find_increasing_factor;\n+    /// Overestimation of cache line size.  Used to avoid false\n+    /// sharing, i. e. elements of different threads are at least this\n+    /// amount apart.\n+    unsigned int \t\tcache_line_size;\n \n-    //set operations\n-    /** @brief Minimal input size for parallel std::set_union. */\n-    static volatile sequence_index_t set_union_minimal_n;\n+    // Statistics.\n \n-    /** @brief Minimal input size for parallel\n-\tstd::set_symmetric_difference. */\n-    static volatile sequence_index_t set_symmetric_difference_minimal_n;\n+    /// The number of stolen ranges in load-balanced quicksort.\n+    sequence_index_t \t\tqsb_steals;\n \n-    /** @brief Minimal input size for parallel std::set_difference. */\n-    static volatile sequence_index_t set_difference_minimal_n;\n+    /// Get the global settings.\n+    static const _Settings&\n+    get() throw();\n \n-    /** @brief Minimal input size for parallel std::set_intersection. */\n-    static volatile sequence_index_t set_intersection_minimal_n;\n+    /// Set the global settings.\n+    static void\n+    set(_Settings&) throw();\n \n-    //hardware dependent tuning parameters\n-    /** @brief Size of the L1 cache in bytes (underestimation). */\n-    static volatile unsigned long long L1_cache_size;\n-\n-    /** @brief Size of the L2 cache in bytes (underestimation). */\n-    static volatile unsigned long long L2_cache_size;\n-\n-    /** @brief Size of the Translation Lookaside Buffer\n-\t(underestimation). */\n-    static volatile unsigned int TLB_size;\n-\n-    /** @brief Overestimation of cache line size.  Used to avoid\n-     * false sharing, i. e. elements of different threads are at\n-     * least this amount apart. */\n-    static unsigned int cache_line_size;\n-\n-    //statistics\n-    /** @brief Statistic on the number of stolen ranges in\n-\tload-balanced quicksort.*/\n-    static volatile sequence_index_t qsb_steals;\n+    explicit \n+    _Settings() : algorithm_strategy(heuristic), sort_algorithm(MWMS), partial_sum_algorithm(LINEAR), multiway_merge_algorithm(LOSER_TREE), find_algorithm(CONSTANT_SIZE_BLOCKS), sort_splitting(EXACT), merge_splitting(EXACT), multiway_merge_splitting(EXACT), accumulate_minimal_n(1000), adjacent_difference_minimal_n(1000), count_minimal_n(1000), fill_minimal_n(1000), find_increasing_factor(2.0), find_initial_block_size(256), find_maximum_block_size(8192), find_sequential_search_size(256), for_each_minimal_n(1000), generate_minimal_n(1000), max_element_minimal_n(1000), merge_minimal_n(1000), merge_oversampling(10), min_element_minimal_n(1000), multiway_merge_minimal_n(1000), multiway_merge_minimal_k(2), multiway_merge_oversampling(10), nth_element_minimal_n(1000), partition_chunk_size(1000), partition_chunk_share(0.0), partition_minimal_n(1000), partial_sort_minimal_n(1000), partial_sum_dilation(1.0f), partial_sum_minimal_n(1000), random_shuffle_minimal_n(1000), replace_minimal_n(1000), set_difference_minimal_n(1000), set_intersection_minimal_n(1000), set_symmetric_difference_minimal_n(1000), set_union_minimal_n(1000), sort_minimal_n(1000), sort_mwms_oversampling(10), sort_qs_num_samples_preset(100), sort_qsb_base_case_maximal_n(100), transform_minimal_n(1000), unique_copy_minimal_n(10000), workstealing_chunk_size(100), L1_cache_size(16 << 10), L2_cache_size(256 << 10), TLB_size(128), cache_line_size(64), qsb_steals(0)\n+    { }\n   };\n-\n-  volatile bool Settings::force_parallel = false;\n-  volatile bool Settings::force_sequential = false;\n-  volatile  Settings::SortAlgorithm Settings::sort_algorithm = Settings::MWMS;\n-  volatile  Settings::Splitting Settings::sort_splitting = Settings::EXACT;\n-  volatile sequence_index_t Settings::sort_minimal_n = 1000;\n-\n-  volatile unsigned int Settings::sort_mwms_oversampling = 10;\n-  volatile unsigned int Settings::sort_qs_num_samples_preset = 100;\n-  volatile sequence_index_t Settings::sort_qsb_base_case_maximal_n = 100;\n-  volatile sequence_index_t Settings::partition_minimal_n = 1000;\n-  volatile sequence_index_t Settings::nth_element_minimal_n = 1000;\n-  volatile sequence_index_t Settings::partial_sort_minimal_n = 1000;\n-  volatile sequence_index_t Settings::partition_chunk_size = 1000;\n-  volatile double Settings::partition_chunk_share = 0.0;\n-  volatile unsigned int Settings::adjacent_difference_minimal_n = 1000;\n-  volatile  Settings::PartialSumAlgorithm Settings::\n-  partial_sum_algorithm = Settings::LINEAR;\n-  volatile unsigned int Settings::partial_sum_minimal_n = 1000;\n-  volatile float Settings::partial_sum_dilatation = 1.0f;\n-  volatile unsigned int Settings::random_shuffle_minimal_n = 1000;\n-  volatile  Settings::Splitting Settings::merge_splitting = Settings::EXACT;\n-  volatile sequence_index_t Settings::merge_minimal_n = 1000;\n-  volatile unsigned int Settings::merge_oversampling = 10;\n-  volatile sequence_index_t Settings::multiway_merge_minimal_n = 1000;\n-  volatile int Settings::multiway_merge_minimal_k = 2;\n-\n-  // unique copy\n-  volatile sequence_index_t Settings::unique_copy_minimal_n = 10000;\n-  volatile  Settings::MultiwayMergeAlgorithm Settings::\n-  multiway_merge_algorithm = Settings::LOSER_TREE;\n-  volatile  Settings::Splitting Settings::multiway_merge_splitting =\n-    Settings::EXACT;\n-  volatile unsigned int Settings::multiway_merge_oversampling = 10;\n-  volatile  Settings::FindDistribution Settings::find_distribution =\n-    Settings::CONSTANT_SIZE_BLOCKS;\n-  volatile sequence_index_t Settings::find_sequential_search_size = 256;\n-  volatile sequence_index_t Settings::find_initial_block_size = 256;\n-  volatile sequence_index_t Settings::find_maximum_block_size = 8192;\n-  volatile double Settings::find_increasing_factor = 2.0;\n-  volatile sequence_index_t Settings::workstealing_chunk_size = 100;\n-  volatile sequence_index_t Settings::for_each_minimal_n = 1000;\n-  volatile sequence_index_t Settings::count_minimal_n = 1000;\n-  volatile sequence_index_t Settings::transform_minimal_n = 1000;\n-  volatile sequence_index_t Settings::replace_minimal_n = 1000;\n-  volatile sequence_index_t Settings::generate_minimal_n = 1000;\n-  volatile sequence_index_t Settings::fill_minimal_n = 1000;\n-  volatile sequence_index_t Settings::min_element_minimal_n = 1000;\n-  volatile sequence_index_t Settings::max_element_minimal_n = 1000;\n-  volatile sequence_index_t Settings::accumulate_minimal_n = 1000;\n-\n-  //set operations\n-  volatile sequence_index_t Settings::set_union_minimal_n = 1000;\n-  volatile sequence_index_t Settings::set_intersection_minimal_n = 1000;\n-  volatile sequence_index_t Settings::set_difference_minimal_n = 1000;\n-  volatile sequence_index_t Settings::set_symmetric_difference_minimal_n =\n-    1000;\n-  volatile unsigned long long Settings::L1_cache_size = 16 << 10;\n-  volatile unsigned long long Settings::L2_cache_size = 256 << 10;\n-  volatile unsigned int Settings::TLB_size = 128;\n-  unsigned int Settings::cache_line_size = 64;\n-\n-  //statistics\n-  volatile sequence_index_t Settings::qsb_steals = 0;\n-} // end anonymous namespace\n-\n }\n \n #endif /* _GLIBCXX_SETTINGS_H */"}, {"sha": "edf4eea02d8a08a1e0e1e0572d00dedaf243e640", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -84,16 +84,15 @@ namespace __gnu_parallel\n \n \t  if (false) ;\n #if _GLIBCXX_MERGESORT\n-\t  else if (Settings::sort_algorithm == Settings::MWMS || stable)\n+\t  else if (stable || _Settings::get().sort_algorithm == MWMS)\n \t    parallel_sort_mwms(begin, end, comp, n, get_max_threads(), stable);\n #endif\n #if _GLIBCXX_QUICKSORT\n-\t  else if (Settings::sort_algorithm == Settings::QS && !stable)\n+\t  else if (!stable && _Settings::get().sort_algorithm == QS)\n \t    parallel_sort_qs(begin, end, comp, n, get_max_threads());\n #endif\n #if _GLIBCXX_BAL_QUICKSORT\n-\t  else if (Settings::sort_algorithm == Settings::QS_BALANCED\n-\t\t   && !stable)\n+\t  else if (!stable && _Settings::get().sort_algorithm == QS_BALANCED)\n \t    parallel_sort_qsb(begin, end, comp, n, get_max_threads());\n #endif\n \t  else"}, {"sha": "b3f2ec86912abaad9deeac2d3674546f18da94fd", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -64,18 +64,19 @@ namespace __gnu_parallel\n   struct omp_loop_static_tag : public parallel_tag { };\n \n \n-  // XXX settings.h Settings::FindDistribution\n+  struct find_tag { };\n+\n   /** @brief Selects the growing block size variant for std::find().\n       @see _GLIBCXX_FIND_GROWING_BLOCKS */\n-  struct growing_blocks_tag { };\n+  struct growing_blocks_tag : public find_tag { };\n \n   /** @brief Selects the constant block size variant for std::find().\n       @see _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS */\n-  struct constant_size_blocks_tag { };\n+  struct constant_size_blocks_tag : public find_tag { };\n \n   /** @brief Selects the equal splitting variant for std::find().\n       @see _GLIBCXX_FIND_EQUAL_SPLIT */\n-  struct equal_split_tag { };\n+  struct equal_split_tag : public find_tag { };\n }\n \n #endif /* _GLIBCXX_PARALLEL_TAGS_H */"}, {"sha": "ded617edb6dc99a98e29d0ea5d8d5b3e71d0a209", "filename": "libstdc++-v3/include/parallel/types.h", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -44,8 +44,8 @@ namespace __gnu_parallel\n {\n   // Enumerated types.\n \n-  /// @brief Run-time equivalents for the compile-time tags.\n-  enum parallelism\n+  /// Run-time equivalents for the compile-time tags.\n+  enum _Parallelism\n     {\n       /// Not parallel.\n       sequential,\n@@ -66,9 +66,60 @@ namespace __gnu_parallel\n       parallel_taskqueue\n     };\n \n-  inline bool \n-  is_parallel(const parallelism __p) { return __p != sequential; }\n+  /// Strategies for run-time algorithm selection: \n+  // force_sequential, force_parallel, heuristic.\n+  enum _AlgorithmStrategy\n+    {\n+      heuristic,\n+      force_sequential,\n+      force_parallel\n+    };\n+\n+  /// Sorting algorithms: \n+  // multi-way mergesort, quicksort, load-balanced quicksort.\n+  enum _SortAlgorithm \n+    { \n+      MWMS, \n+      QS, \n+      QS_BALANCED \n+    };\n+\n+  /// Merging algorithms: \n+  // bubblesort-alike, loser-tree variants, enum sentinel.\n+  enum _MultiwayMergeAlgorithm\n+    { \n+      BUBBLE, \n+      LOSER_TREE_EXPLICIT, \n+      LOSER_TREE, \n+      LOSER_TREE_COMBINED, \n+      LOSER_TREE_SENTINEL, \n+      ENUM_SENTINEL \n+    };\n+  \n+  /// Partial sum algorithms: recursive, linear.\n+  enum _PartialSumAlgorithm \n+    { \n+      RECURSIVE, \n+      LINEAR \n+    };\n+\n+  /// Sorting/merging algorithms: sampling, exact.\n+  enum _SplittingAlgorithm \n+    { \n+      SAMPLING, \n+      EXACT \n+    };\n \n+  /// Find algorithms:\n+  // growing blocks, equal-sized blocks, equal splitting.\n+  enum _FindAlgorithm \n+    { \n+      GROWING_BLOCKS, \n+      CONSTANT_SIZE_BLOCKS, \n+      EQUAL_SPLIT \n+    };\n+\n+  /// Integer Types.\n   // XXX need to use <cstdint>\n   /** @brief 16-bit signed integer. */\n   typedef short int16;\n@@ -101,20 +152,14 @@ namespace __gnu_parallel\n   typedef uint16 thread_index_t;\n \n   // XXX atomics interface?\n-  /**\n-   * @brief Longest compare-and-swappable integer type on this platform.\n-   */\n+  /// Longest compare-and-swappable integer type on this platform.\n   typedef int64 lcas_t;\n \n   // XXX numeric_limits::digits?\n-  /**\n-   * @brief Number of bits of ::lcas_t.\n-   */\n+  /// Number of bits of ::lcas_t.\n   static const int lcas_t_bits = sizeof(lcas_t) * 8;\n \n-  /**\n-   * @brief ::lcas_t with the right half of bits set to 1.\n-   */\n+  /// ::lcas_t with the right half of bits set to 1.\n   static const lcas_t lcas_t_mask = ((lcas_t(1) << (lcas_t_bits / 2)) - 1);\n }\n "}, {"sha": "628f12cca2cb47c381c3af74ae8febbd014221f3", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -114,17 +114,16 @@ template<typename RandomAccessIterator,\n \n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;\n+    \n+    const _Settings& __s = _Settings::get();\n \n-\n-    difference_type chunk_size =\n-        static_cast<difference_type>(Settings::workstealing_chunk_size);\n+    difference_type chunk_size = static_cast<difference_type>(__s.workstealing_chunk_size);\n \n     // How many jobs?\n     difference_type length = (bound < 0) ? (end - begin) : bound;\n \n     // To avoid false sharing in a cache line.\n-    const int stride =\n-        Settings::cache_line_size * 10 / sizeof(Job<difference_type>) + 1;\n+    const int stride = __s.cache_line_size * 10 / sizeof(Job<difference_type>) + 1;\n \n     // Total number of threads currently working.\n     thread_index_t busy = 0;"}, {"sha": "654861902121f89bd2b8ff3dd6988c61921876a2", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -121,7 +121,7 @@ basic_file.cc: ${glibcxx_srcdir}/$(BASIC_FILE_CC)\n \t$(LN_S) ${glibcxx_srcdir}/$(BASIC_FILE_CC) ./$@ || true\n \n if ENABLE_PARALLEL\n-parallel_sources = parallel_list.cc \n+parallel_sources = parallel_list.cc parallel_settings.cc\n else\n parallel_sources =\n endif\n@@ -221,6 +221,11 @@ parallel_list.lo: parallel_list.cc\n parallel_list.o: parallel_list.cc\n \t$(CXXCOMPILE) $(PARALLEL_FLAGS) -c $<\n \n+parallel_settings.lo: parallel_settings.cc\n+\t$(LTCXXCOMPILE) $(PARALLEL_FLAGS) -c $<\n+parallel_settings.o: parallel_settings.cc\n+\t$(CXXCOMPILE) $(PARALLEL_FLAGS) -c $<\n+\n # Use special rules for the C++0x sources so that the proper flags are passed.\n system_error.lo: system_error.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<"}, {"sha": "8c55b6f20d367518c1411adc7d3949f759e6e7ee", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -84,12 +84,13 @@ am__libstdc___la_SOURCES_DIST = bitmap_allocator.cc pool_allocator.cc \\\n \tcodecvt_members.cc collate_members.cc ctype_members.cc \\\n \tmessages_members.cc monetary_members.cc numeric_members.cc \\\n \ttime_members.cc basic_file.cc c++locale.cc \\\n-\tcompatibility-ldbl.cc parallel_list.cc\n+\tcompatibility-ldbl.cc parallel_list.cc parallel_settings.cc\n am__objects_1 = atomicity.lo codecvt_members.lo collate_members.lo \\\n \tctype_members.lo messages_members.lo monetary_members.lo \\\n \tnumeric_members.lo time_members.lo\n @GLIBCXX_LDBL_COMPAT_TRUE@am__objects_2 = compatibility-ldbl.lo\n-@ENABLE_PARALLEL_TRUE@am__objects_3 = parallel_list.lo\n+@ENABLE_PARALLEL_TRUE@am__objects_3 = parallel_list.lo \\\n+@ENABLE_PARALLEL_TRUE@\tparallel_settings.lo\n am__objects_4 = basic_file.lo c++locale.lo $(am__objects_2) \\\n \t$(am__objects_3)\n am__objects_5 = bitmap_allocator.lo pool_allocator.lo mt_allocator.lo \\\n@@ -359,7 +360,7 @@ host_sources_extra = \\\n \tbasic_file.cc c++locale.cc ${ldbl_compat_sources} ${parallel_sources}\n \n @ENABLE_PARALLEL_FALSE@parallel_sources = \n-@ENABLE_PARALLEL_TRUE@parallel_sources = parallel_list.cc \n+@ENABLE_PARALLEL_TRUE@parallel_sources = parallel_list.cc parallel_settings.cc\n @GLIBCXX_LDBL_COMPAT_FALSE@ldbl_compat_sources = \n @GLIBCXX_LDBL_COMPAT_TRUE@ldbl_compat_sources = compatibility-ldbl.cc\n \n@@ -810,6 +811,11 @@ parallel_list.lo: parallel_list.cc\n parallel_list.o: parallel_list.cc\n \t$(CXXCOMPILE) $(PARALLEL_FLAGS) -c $<\n \n+parallel_settings.lo: parallel_settings.cc\n+\t$(LTCXXCOMPILE) $(PARALLEL_FLAGS) -c $<\n+parallel_settings.o: parallel_settings.cc\n+\t$(CXXCOMPILE) $(PARALLEL_FLAGS) -c $<\n+\n # Use special rules for the C++0x sources so that the proper flags are passed.\n system_error.lo: system_error.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<"}, {"sha": "c47e1f2816d09848a1136d17ae57577fd8b4127b", "filename": "libstdc++-v3/src/parallel_settings.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fsrc%2Fparallel_settings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee1b5fc5e04a14f32ddacbdf795d770ec5638a40/libstdc%2B%2B-v3%2Fsrc%2Fparallel_settings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fparallel_settings.cc?ref=ee1b5fc5e04a14f32ddacbdf795d770ec5638a40", "patch": "@@ -0,0 +1,47 @@\n+// Default settings for parallel mode -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <parallel/settings.h>\n+\n+namespace\n+{\n+  __gnu_parallel::_Settings s;\n+}\n+\n+namespace __gnu_parallel\n+{\n+  const _Settings&\n+  _Settings::get() throw()\n+  { return s; }\n+\n+  // XXX MT\n+  void\n+  _Settings::set(_Settings& obj) throw()\n+  { s = obj; }\n+}"}]}