{"sha": "9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVjNmQ3YWIwZmJmNWVkMDU3YWQ5YmNlNjE1MGFhNmIwMzM2YjFlMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-30T11:01:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-30T11:01:53Z"}, "message": "ifcvt.c: New file.\n\n        * ifcvt.c: New file.\n        * Makefile.in (OBJS): Add it.\n        (ifcvt.o): New target.\n        * jump.c (jump_optimize_1): Remove all code related to if-conversion,\n        and conditional arithmetic.\n        (find_insert_position): Remove.\n        * timevar.def (TV_IFCVT, TV_IFCVT2): New.\n        * toplev.c (DFI_ce, DFI_ce2): New.\n        (dump_file): Add ce and ce2 dumps.\n        (rest_of_compilation): Run if_convert a couple o times.  Set\n        cse_not_expected after cse2.  Don't set no_new_pseudos until\n        after sched1 or recompute_reg_usage.\n\nFrom-SVN: r33547", "tree": {"sha": "925f6eae61dfe3a5d2f84372d731b4bb1fa58df9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/925f6eae61dfe3a5d2f84372d731b4bb1fa58df9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/comments", "author": null, "committer": null, "parents": [{"sha": "927b868f8ce55b4cc88fd093c03d4a301d06fda9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927b868f8ce55b4cc88fd093c03d4a301d06fda9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/927b868f8ce55b4cc88fd093c03d4a301d06fda9"}], "stats": {"total": 3641, "additions": 2147, "deletions": 1494}, "files": [{"sha": "312ec98f4bbc3a5a9be8959f16ba2427165f83e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "patch": "@@ -1,3 +1,18 @@\n+2000-04-30  Richard Henderson  <rth@cygnus.com>\n+\n+\t* ifcvt.c: New file.\n+\t* Makefile.in (OBJS): Add it.\n+\t(ifcvt.o): New target.\n+\t* jump.c (jump_optimize_1): Remove all code related to if-conversion, \n+\tand conditional arithmetic.\n+\t(find_insert_position): Remove.\n+\t* timevar.def (TV_IFCVT, TV_IFCVT2): New.\n+\t* toplev.c (DFI_ce, DFI_ce2): New.\n+\t(dump_file): Add ce and ce2 dumps.\n+\t(rest_of_compilation): Run if_convert a couple o times.  Set\n+\tcse_not_expected after cse2.  Don't set no_new_pseudos until\n+\tafter sched1 or recompute_reg_usage.\n+\n 2000-04-30  Richard Henderson  <rth@cygnus.com>\n \n \t* config/alpha/t-crtbe (crtbegin.o): Add \"-I.\"."}, {"sha": "f7b8de3d927a61f51b85b142e3e7bc45dac0bc23", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "patch": "@@ -684,7 +684,7 @@ OBJS = diagnostic.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n  predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o \\\n- sibcall.o conflict.o timevar.o\n+ sibcall.o conflict.o timevar.o ifcvt.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1663,6 +1663,9 @@ timevar.o : timevar.c $(CONFIG_H) system.h $(TIMEVAR_H) flags.h\n regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h \\\n    $(RECOG_H) function.h resource.h\n+ifcvt.o : ifcvt.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n+   flags.h insn-config.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(EXPR_H) \\\n+   output.h\n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) $(GGC_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\\n    insn-flags.h output.h insn-attr.h insn-codes.h system.h toplev.h function.h"}, {"sha": "33c1918313278e505406ce660021b1328cbd6931", "filename": "gcc/ifcvt.c", "status": "added", "additions": 2024, "deletions": 0, "changes": 2024, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "patch": "@@ -0,0 +1,2024 @@\n+/* If-conversion support.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"function.h\"\n+#include \"flags.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"basic-block.h\"\n+#include \"expr.h\"\n+#include \"output.h\"\n+#include \"hard-reg-set.h\"\n+#include \"tm_p.h\"\n+\n+\n+#ifndef HAVE_conditional_execution\n+#define HAVE_conditional_execution 0\n+#endif\n+#ifndef HAVE_conditional_move\n+#define HAVE_conditional_move 0\n+#endif\n+#ifndef HAVE_incscc\n+#define HAVE_incscc 0\n+#endif\n+#ifndef HAVE_decscc\n+#define HAVE_decscc 0\n+#endif\n+\n+#ifndef MAX_CONDITIONAL_EXECUTE\n+#define MAX_CONDITIONAL_EXECUTE   (BRANCH_COST + 1)\n+#endif\n+\n+#define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n+\n+#define NULL_EDGE\t((struct edge_def *)NULL)\n+#define NULL_BLOCK\t((struct basic_block_def *)NULL)\n+\n+/* # of IF-THEN or IF-THEN-ELSE blocks we looked at  */\n+static int num_possible_if_blocks;\n+\n+/* # of IF-THEN or IF-THEN-ELSE blocks were converted to conditional\n+   execution.  */\n+static int num_updated_if_blocks;\n+\n+/* # of basic blocks that were removed.  */\n+static int num_removed_blocks;\n+\n+/* The post-dominator relation on the original block numbers.  */\n+static sbitmap *post_dominators;\n+\n+/* Forward references.  */\n+static int count_bb_insns\t\tPARAMS ((basic_block));\n+static rtx first_active_insn\t\tPARAMS ((basic_block));\n+static int last_active_insn_p\t\tPARAMS ((basic_block, rtx));\n+\n+static int cond_exec_process_insns\tPARAMS ((rtx, rtx, rtx, int));\n+static rtx cond_exec_get_condition\tPARAMS ((rtx));\n+static int cond_exec_process_if_block\tPARAMS ((basic_block, basic_block,\n+\t\t\t\t\t\t basic_block, basic_block));\n+\n+static rtx noce_get_condition\t\tPARAMS ((rtx, rtx *));\n+static int noce_process_if_block\tPARAMS ((basic_block, basic_block,\n+\t\t\t\t\t\t basic_block, basic_block));\n+\n+static int process_if_block\t\tPARAMS ((basic_block, basic_block,\n+\t\t\t\t\t\t basic_block, basic_block));\n+static void merge_if_block\t\tPARAMS ((basic_block, basic_block,\n+\t\t\t\t\t\t basic_block, basic_block));\n+\n+static int find_if_header\t\tPARAMS ((basic_block));\n+static int find_if_block\t\tPARAMS ((basic_block, edge, edge));\n+static int find_if_case_1\t\tPARAMS ((basic_block, edge, edge));\n+static int find_if_case_2\t\tPARAMS ((basic_block, edge, edge));\n+static int find_memory\t\t\tPARAMS ((rtx *, void *));\n+static int dead_or_predicable\t\tPARAMS ((basic_block, basic_block,\n+\t\t\t\t\t\t basic_block, rtx, int));\n+\f\n+/* Abuse the basic_block AUX field to store the original block index,\n+   as well as a flag indicating that the block should be rescaned for\n+   life analysis.  */\n+\n+#define SET_ORIG_INDEX(BB,I)\t((BB)->aux = (void *)((size_t)(I) << 1))\n+#define ORIG_INDEX(BB)\t\t((size_t)(BB)->aux >> 1)\n+#define SET_UPDATE_LIFE(BB)\t((BB)->aux = (void *)((size_t)(BB)->aux | 1))\n+#define UPDATE_LIFE(BB)\t\t((size_t)(BB)->aux & 1)\n+\n+\f\n+/* Count the number of non-jump active insns in BB.  */\n+\n+static int\n+count_bb_insns (bb)\n+     basic_block bb;\n+{\n+  int count = 0;\n+  rtx insn = bb->head;\n+\n+  while (1)\n+    {\n+      if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == INSN)\n+\tcount++;\n+\n+      if (insn == bb->end)\n+\tbreak;\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  return count;\n+}\n+\n+/* Return the first non-jump active insn in the basic block.  */\n+\n+static rtx\n+first_active_insn (bb)\n+     basic_block bb;\n+{\n+  rtx insn = bb->head;\n+\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    {\n+      if (insn == bb->end)\n+\treturn NULL_RTX;\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  while (GET_CODE (insn) == NOTE)\n+    {\n+      if (insn == bb->end)\n+\treturn NULL_RTX;\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    return NULL_RTX;\n+\n+  return insn;\n+}\n+\n+/* Return true if INSN is the last active non-jump insn in BB.  */\n+\n+static int\n+last_active_insn_p (bb, insn)\n+     basic_block bb;\n+     rtx insn;\n+{\n+  do\n+    {\n+      if (insn == bb->end)\n+\treturn TRUE;\n+      insn = NEXT_INSN (insn);\n+    }\n+  while (GET_CODE (insn) == NOTE);\n+\n+  return GET_CODE (insn) == JUMP_INSN;\n+}\n+\f\n+/* Go through a bunch of insns, converting them to conditional\n+   execution format if possible.  Return TRUE if all of the non-note\n+   insns were processed.  */\n+\n+static int\n+cond_exec_process_insns (start, end, test, mod_ok)\n+     rtx start;\t\t\t/* first insn to look at */\n+     rtx end;\t\t\t/* last insn to look at */\n+     rtx test;\t\t\t/* conditional execution test */\n+     int mod_ok;\t\t/* true if modifications ok last insn.  */\n+{\n+  int must_be_last = FALSE;\n+  rtx insn;\n+\n+  for (insn = start; ; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE)\n+\tgoto insn_done;\n+\n+      if (GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n+\tabort ();\n+\n+      /* Last insn wasn't last?  */\n+      if (must_be_last)\n+\treturn FALSE;\n+\n+      if (modified_in_p (test, insn))\n+\t{\n+\t  if (!mod_ok)\n+\t    return FALSE;\n+\t  must_be_last = TRUE;\n+\t}\n+\n+      /* Now build the conditional form of the instruction.  */\n+      validate_change (insn, &PATTERN (insn),\n+\t\t       gen_rtx_COND_EXEC (VOIDmode, copy_rtx (test),\n+\t\t\t\t\t  PATTERN (insn)), 1);\n+\n+    insn_done:\n+      if (insn == end)\n+\tbreak;\n+    }\n+\n+  return TRUE;\n+}\n+\n+/* Return the condition for a jump.  Do not do any special processing.  */\n+\n+static rtx\n+cond_exec_get_condition (jump)\n+     rtx jump;\n+{\n+  rtx test_if, cond;\n+\n+  if (condjump_p (jump))\n+    test_if = SET_SRC (PATTERN (jump));\n+  else if (condjump_in_parallel_p (jump))\n+    test_if = SET_SRC (XVECEXP (PATTERN (jump), 0, 0));\n+  else\n+    return NULL_RTX;\n+  cond = XEXP (test_if, 0);\n+\n+  /* If this branches to JUMP_LABEL when the condition is false,\n+     reverse the condition.  */\n+  if (GET_CODE (XEXP (test_if, 2)) == LABEL_REF\n+      && XEXP (XEXP (test_if, 2), 0) == JUMP_LABEL (jump))\n+    cond = gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond)),\n+\t\t\t   GET_MODE (cond), XEXP (cond, 0),\n+\t\t\t   XEXP (cond, 1));\n+\n+  return cond;\n+}\n+\n+/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it\n+   to conditional execution.  Return TRUE if we were successful at\n+   converting the the block.  */\n+\n+static int\n+cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n+     basic_block test_bb;\t/* Basic block test is in */\n+     basic_block then_bb;\t/* Basic block for THEN block */\n+     basic_block else_bb;\t/* Basic block for ELSE block */\n+     basic_block join_bb;\t/* Basic block the join label is in */\n+{\n+  rtx test_expr;\t\t/* expression in IF_THEN_ELSE that is tested */\n+  rtx then_start;\t\t/* first insn in THEN block */\n+  rtx then_end;\t\t\t/* last insn + 1 in THEN block */\n+  rtx else_start;\t\t/* first insn in ELSE block or NULL */\n+  rtx else_end;\t\t\t/* last insn + 1 in ELSE block */\n+  int max;\t\t\t/* max # of insns to convert. */\n+  int then_mod_ok;\t\t/* whether conditional mods are ok in THEN */\n+  rtx true_expr;\t\t/* test for else block insns */\n+  rtx false_expr;\t\t/* test for then block insns */\n+  int n_insns;\n+\n+  /* Find the conditional jump to the ELSE or JOIN part, and isolate\n+     the test.  */\n+  test_expr = cond_exec_get_condition (test_bb->end);\n+  if (! test_expr)\n+    return FALSE;\n+\n+  /* Collect the bounds of where we're to search.  */\n+\n+  then_start = then_bb->head;\n+  then_end = then_bb->end;\n+\n+  /* Skip a (use (const_int 0)) or branch as the final insn.  */\n+  if (GET_CODE (then_end) == INSN\n+      && GET_CODE (PATTERN (then_end)) == USE\n+      && GET_CODE (XEXP (PATTERN (then_end), 0)) == CONST_INT)\n+    then_end = PREV_INSN (then_end);\n+  else if (GET_CODE (then_end) == JUMP_INSN)\n+    then_end = PREV_INSN (then_end);\n+\n+  if (else_bb)\n+    {\n+      /* Skip the ELSE block's label.  */\n+      else_start = NEXT_INSN (else_bb->head);\n+      else_end = else_bb->end;\n+\n+      /* Skip a (use (const_int 0)) or branch as the final insn.  */\n+      if (GET_CODE (else_end) == INSN\n+\t  && GET_CODE (PATTERN (else_end)) == USE\n+\t  && GET_CODE (XEXP (PATTERN (else_end), 0)) == CONST_INT)\n+\telse_end = PREV_INSN (else_end);\n+      else if (GET_CODE (else_end) == JUMP_INSN)\n+\telse_end = PREV_INSN (else_end);\n+    }\n+\n+  /* How many instructions should we convert in total?  */\n+  n_insns = 0;\n+  if (else_bb)\n+    {\n+      max = 2 * MAX_CONDITIONAL_EXECUTE;\n+      n_insns = count_bb_insns (else_bb);\n+    }\n+  else\n+    max = MAX_CONDITIONAL_EXECUTE;\n+  n_insns += count_bb_insns (then_bb);\n+  if (n_insns > max)\n+    return FALSE;\n+\n+  /* Map test_expr/test_jump into the appropriate MD tests to use on\n+     the conditionally executed code.  */\n+  \n+  true_expr = test_expr;\n+  false_expr = gen_rtx_fmt_ee (reverse_condition (GET_CODE (true_expr)),\n+\t\t\t       GET_MODE (true_expr), XEXP (true_expr, 0),\n+\t\t\t       XEXP (true_expr, 1));\n+\n+  /* For IF-THEN-ELSE blocks, we don't allow modifications of the test\n+     on then THEN block.  */\n+  then_mod_ok = (else_bb == NULL_BLOCK);\n+\n+  /* Go through the THEN and ELSE blocks converting the insns if possible\n+     to conditional execution.  */\n+\n+  if (then_end\n+      && ! cond_exec_process_insns (then_start, then_end,\n+\t\t\t\t    false_expr, then_mod_ok))\n+    goto fail;\n+\n+  if (else_bb\n+      && ! cond_exec_process_insns (else_start, else_end,\n+\t\t\t\t    true_expr, TRUE))\n+    goto fail;\n+\n+  if (! apply_change_group ())\n+    return FALSE;\n+\n+  /* Conversion succeeded.  */\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"%d insn%s converted to conditional execution.\\n\",\n+\t     n_insns, (n_insns == 1) ? \" was\" : \"s were\");\n+\n+  /* Merge the blocks!  */\n+  merge_if_block (test_bb, then_bb, else_bb, join_bb);\n+  return TRUE;\n+\n+ fail:\n+  cancel_changes (0);\n+  return FALSE;\n+}\n+\f\n+/* Used by noce_process_if_block to communicate with its subroutines. \n+\n+   The subroutines know that A and B may be evaluated freely.  They\n+   know that X is a register.  They should insert new instructions \n+   before cond_earliest.  */\n+\n+struct noce_if_info\n+{\n+  rtx insn_a, insn_b;\n+  rtx x, a, b;\n+  rtx jump, cond, cond_earliest;\n+};\n+\n+static rtx noce_emit_store_flag\t\tPARAMS ((struct noce_if_info *,\n+\t\t\t\t\t\t rtx, int, int));\n+static int noce_try_store_flag\t\tPARAMS ((struct noce_if_info *));\n+static int noce_try_store_flag_inc\tPARAMS ((struct noce_if_info *));\n+static int noce_try_store_flag_constants PARAMS ((struct noce_if_info *));\n+static int noce_try_store_flag_mask\tPARAMS ((struct noce_if_info *));\n+static rtx noce_emit_cmove\t\tPARAMS ((struct noce_if_info *,\n+\t\t\t\t\t\t rtx, enum rtx_code, rtx,\n+\t\t\t\t\t\t rtx, rtx, rtx));\n+static int noce_try_cmove\t\tPARAMS ((struct noce_if_info *));\n+static int noce_try_cmove_arith\t\tPARAMS ((struct noce_if_info *));\n+\n+/* Helper function for noce_try_store_flag*.  */\n+\n+static rtx\n+noce_emit_store_flag (if_info, x, reversep, normalize)\n+     struct noce_if_info *if_info;\n+     rtx x;\n+     int reversep, normalize;\n+{\n+  rtx cond = if_info->cond;\n+  int cond_complex;\n+  enum rtx_code code;\n+\n+  cond_complex = (! general_operand (XEXP (cond, 0), VOIDmode)\n+\t\t  || ! general_operand (XEXP (cond, 1), VOIDmode));\n+\n+  /* If earliest == jump, or when the condition is complex, try to\n+     build the store_flag insn directly.  */\n+\n+  if (cond_complex)\n+    cond = XEXP (SET_SRC (PATTERN (if_info->jump)), 0);\n+\n+  if ((if_info->cond_earliest == if_info->jump || cond_complex)\n+      && (normalize == 0 || STORE_FLAG_VALUE == normalize))\n+    {\n+      rtx tmp;\n+\n+      code = GET_CODE (cond);\n+      if (reversep)\n+\tcode = reverse_condition (code);\n+\n+      tmp = gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (cond, 0),\n+\t\t\t    XEXP (cond, 1));\n+      tmp = gen_rtx_SET (VOIDmode, x, tmp);\n+\n+      start_sequence ();\n+      tmp = emit_insn (tmp);\n+\n+      if (recog_memoized (tmp) >= 0)\n+\t{\n+\t  tmp = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insns (tmp);\n+\n+\t  if_info->cond_earliest = if_info->jump;\n+\n+\t  return x;\n+\t}\n+\n+      end_sequence ();\n+    }\n+\n+  /* Don't even try if the comparison operands are weird.  */\n+  if (cond_complex)\n+    return NULL_RTX;\n+\n+  code = GET_CODE (cond);\n+  if (reversep)\n+    code = reverse_condition (code);\n+\n+  return emit_store_flag (x, code, XEXP (cond, 0),\n+\t\t\t  XEXP (cond, 1), VOIDmode,\n+\t\t\t  (code == LTU || code == LEU\n+\t\t\t   || code == GEU || code == GTU), normalize);\n+}\n+\n+/* Convert \"if (test) x = 1; else x = 0\".\n+\n+   Only try 0 and STORE_FLAG_VALUE here.  Other combinations will be\n+   tried in noce_try_store_flag_constants after noce_try_cmove has had\n+   a go at the conversion.  */\n+\n+static int\n+noce_try_store_flag (if_info)\n+     struct noce_if_info *if_info;\n+{\n+  int reversep;\n+  rtx target, seq;\n+\n+  if (GET_CODE (if_info->b) == CONST_INT\n+      && INTVAL (if_info->b) == STORE_FLAG_VALUE\n+      && if_info->a == const0_rtx)\n+    reversep = 0;\n+  else if (if_info->b == const0_rtx\n+\t   && GET_CODE (if_info->a) == CONST_INT\n+\t   && INTVAL (if_info->a) == STORE_FLAG_VALUE\n+\t   && can_reverse_comparison_p (if_info->cond, if_info->jump))\n+    reversep = 1;\n+  else\n+    return FALSE;\n+\n+  start_sequence ();\n+\n+  target = noce_emit_store_flag (if_info, if_info->x, reversep, 0);\n+  if (target)\n+    {\n+      if (target != if_info->x)\n+\temit_move_insn (if_info->x, target);\n+\n+      seq = get_insns ();\n+      end_sequence ();\n+      emit_insns_before (seq, if_info->cond_earliest);\n+\n+      return TRUE;\n+    }\n+  else\n+    {\n+      end_sequence ();\n+      return FALSE;\n+    }\n+}\n+\n+/* Convert \"if (test) x = a; else x = b\", for A and B constant.  */\n+\n+static int\n+noce_try_store_flag_constants (if_info)\n+     struct noce_if_info *if_info;\n+{\n+  rtx target, seq;\n+  int reversep;\n+  HOST_WIDE_INT itrue, ifalse, diff, tmp;\n+  int normalize, can_reverse;\n+\n+  if (! no_new_pseudos\n+      && GET_CODE (if_info->a) == CONST_INT\n+      && GET_CODE (if_info->b) == CONST_INT)\n+    {\n+      ifalse = INTVAL (if_info->a);\n+      itrue = INTVAL (if_info->b);\n+      diff = itrue - ifalse;\n+\n+      can_reverse = can_reverse_comparison_p (if_info->cond, if_info->jump);\n+\n+      reversep = 0;\n+      if (diff == STORE_FLAG_VALUE || diff == -STORE_FLAG_VALUE)\n+\tnormalize = 0;\n+      else if (ifalse == 0 && exact_log2 (itrue) >= 0\n+\t       && (STORE_FLAG_VALUE == 1\n+\t\t   || BRANCH_COST >= 2))\n+\tnormalize = 1;\n+      else if (itrue == 0 && exact_log2 (ifalse) >= 0 && can_reverse\n+\t       && (STORE_FLAG_VALUE == 1 || BRANCH_COST >= 2))\n+\tnormalize = 1, reversep = 1;\n+      else if (itrue == -1\n+\t       && (STORE_FLAG_VALUE == -1\n+\t\t   || BRANCH_COST >= 2))\n+\tnormalize = -1;\n+      else if (ifalse == -1 && can_reverse\n+\t       && (STORE_FLAG_VALUE == -1 || BRANCH_COST >= 2))\n+\tnormalize = -1, reversep = 1;\n+      else if ((BRANCH_COST >= 2 && STORE_FLAG_VALUE == -1)\n+\t       || BRANCH_COST >= 3)\n+\tnormalize = -1;\n+      else\n+\treturn FALSE;\n+\n+      if (reversep)\n+      \t{\n+\t  tmp = itrue; itrue = ifalse; ifalse = tmp;\n+\t  diff = -diff;\n+\t}\n+\n+      start_sequence ();\n+      target = noce_emit_store_flag (if_info, if_info->x, reversep, normalize);\n+      if (! target)\n+\t{\n+\t  end_sequence ();\n+\t  return FALSE;\n+\t}\n+\n+      /* if (test) x = 3; else x = 4;\n+\t =>   x = 3 + (test == 0);  */\n+      if (diff == STORE_FLAG_VALUE || diff == -STORE_FLAG_VALUE)\n+\t{\n+\t  target = expand_binop (GET_MODE (if_info->x),\n+\t\t\t\t (diff == STORE_FLAG_VALUE\n+\t\t\t\t  ? add_optab : sub_optab),\n+\t\t\t\t GEN_INT (ifalse), target, if_info->x, 0,\n+\t\t\t\t OPTAB_WIDEN);\n+\t}\n+\n+      /* if (test) x = 8; else x = 0;\n+\t =>   x = (test != 0) << 3;  */\n+      else if (ifalse == 0 && (tmp = exact_log2 (itrue)) >= 0)\n+\t{\n+\t  target = expand_binop (GET_MODE (if_info->x), ashl_optab,\n+\t\t\t\t target, GEN_INT (tmp), if_info->x, 0,\n+\t\t\t\t OPTAB_WIDEN);\n+\t}\n+\n+      /* if (test) x = -1; else x = b;\n+\t =>   x = -(test != 0) | b;  */\n+      else if (itrue == -1)\n+\t{\n+\t  target = expand_binop (GET_MODE (if_info->x), ior_optab,\n+\t\t\t\t target, GEN_INT (ifalse), if_info->x, 0,\n+\t\t\t\t OPTAB_WIDEN);\n+\t}\n+\n+      /* if (test) x = a; else x = b;\n+\t =>   x = (-(test != 0) & (b - a)) + a;  */\n+      else\n+\t{\n+\t  target = expand_binop (GET_MODE (if_info->x), and_optab,\n+\t\t\t\t target, GEN_INT (diff), if_info->x, 0,\n+\t\t\t\t OPTAB_WIDEN);\n+\t  if (target)\n+\t    target = expand_binop (GET_MODE (if_info->x), add_optab,\n+\t\t\t\t   target, GEN_INT (ifalse), if_info->x, 0,\n+\t\t\t\t   OPTAB_WIDEN);\n+\t}\n+\n+      if (! target)\n+\t{\n+\t  end_sequence ();\n+\t  return FALSE;\n+\t}\n+\n+      if (target != if_info->x)\n+\temit_move_insn (if_info->x, target);\n+\n+      seq = get_insns ();\n+      end_sequence ();\n+      emit_insns_before (seq, if_info->cond_earliest);\n+\n+      return TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Convert \"if (test) foo++\" into \"foo += (test != 0)\", and \n+   similarly for \"foo--\".  */\n+\n+static int\n+noce_try_store_flag_inc (if_info)\n+     struct noce_if_info *if_info;\n+{\n+  rtx target, seq;\n+  int subtract, normalize;\n+\n+  if (! no_new_pseudos\n+      && (BRANCH_COST >= 2\n+\t  || HAVE_incscc\n+\t  || HAVE_decscc)\n+      /* Should be no `else' case to worry about.  */\n+      && if_info->b == if_info->x\n+      && GET_CODE (if_info->a) == PLUS\n+      && (XEXP (if_info->a, 1) == const1_rtx\n+\t  || XEXP (if_info->a, 1) == constm1_rtx)\n+      && rtx_equal_p (XEXP (if_info->a, 0), if_info->x)\n+      && can_reverse_comparison_p (if_info->cond, if_info->jump))\n+    {\n+      if (STORE_FLAG_VALUE == INTVAL (XEXP (if_info->a, 1)))\n+\tsubtract = 0, normalize = 0;\n+      else if (-STORE_FLAG_VALUE == INTVAL (XEXP (if_info->a, 1)))\n+\tsubtract = 1, normalize = 0;\n+      else\n+\tsubtract = 0, normalize = INTVAL (XEXP (if_info->a, 1));\n+      \n+      start_sequence ();\n+\n+      target = noce_emit_store_flag (if_info,\n+\t\t\t\t     gen_reg_rtx (GET_MODE (if_info->x)),\n+\t\t\t\t     1, normalize);\n+\n+      if (target)\n+\ttarget = expand_binop (GET_MODE (if_info->x),\n+\t\t\t       subtract ? sub_optab : add_optab,\n+\t\t\t       if_info->x, target, if_info->x, 0, OPTAB_WIDEN);\n+      if (target)\n+\t{\n+\t  if (target != if_info->x)\n+\t    emit_move_insn (if_info->x, target);\n+\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insns_before (seq, if_info->cond_earliest);\n+\n+\t  return TRUE;\n+\t}\n+\n+      end_sequence ();\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Convert \"if (test) x = 0;\" to \"x &= -(test == 0);\"  */\n+\n+static int\n+noce_try_store_flag_mask (if_info)\n+     struct noce_if_info *if_info;\n+{\n+  rtx target, seq;\n+  int reversep;\n+\n+  reversep = 0;\n+  if (! no_new_pseudos\n+      && (BRANCH_COST >= 2\n+\t  || STORE_FLAG_VALUE == -1)\n+      && ((if_info->a == const0_rtx\n+\t   && rtx_equal_p (if_info->b, if_info->x))\n+\t  || ((reversep = can_reverse_comparison_p (if_info->cond,\n+\t\t\t\t\t\t    if_info->jump))\n+\t      && if_info->b == const0_rtx\n+\t      && rtx_equal_p (if_info->a, if_info->x))))\n+    {\n+      start_sequence ();\n+      target = noce_emit_store_flag (if_info,\n+\t\t\t\t     gen_reg_rtx (GET_MODE (if_info->x)),\n+\t\t\t\t     reversep, -1);\n+      if (target)\n+        target = expand_binop (GET_MODE (if_info->x), and_optab,\n+\t\t\t       if_info->x, target, if_info->x, 0,\n+\t\t\t       OPTAB_WIDEN);\n+\n+      if (target)\n+\t{\n+\t  if (target != if_info->x)\n+\t    emit_move_insn (if_info->x, target);\n+\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insns_before (seq, if_info->cond_earliest);\n+\n+\t  return TRUE;\n+\t}\n+\n+      end_sequence ();\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Helper function for noce_try_cmove and noce_try_cmove_arith.  */\n+\n+static rtx\n+noce_emit_cmove (if_info, x, code, cmp_a, cmp_b, vfalse, vtrue)\n+     struct noce_if_info *if_info;\n+     rtx x, cmp_a, cmp_b, vfalse, vtrue;\n+     enum rtx_code code;\n+{\n+  /* If earliest == jump, try to build the cmove insn directly.\n+     This is helpful when combine has created some complex condition\n+     (like for alpha's cmovlbs) that we can't hope to regenerate\n+     through the normal interface.  */\n+\n+  if (if_info->cond_earliest == if_info->jump)\n+    {\n+      rtx tmp;\n+\n+      tmp = gen_rtx_fmt_ee (code, GET_MODE (if_info->cond), cmp_a, cmp_b);\n+      tmp = gen_rtx_IF_THEN_ELSE (GET_MODE (x), tmp, vtrue, vfalse);\n+      tmp = gen_rtx_SET (VOIDmode, x, tmp);\n+\n+      start_sequence ();\n+      tmp = emit_insn (tmp);\n+\n+      if (recog_memoized (tmp) >= 0)\n+\t{\n+\t  tmp = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insns (tmp);\n+\n+\t  return x;\n+\t}\n+\n+      end_sequence ();\n+    }\n+\n+  /* Don't even try if the comparison operands are weird.  */\n+  if (! general_operand (cmp_a, GET_MODE (cmp_a))\n+      || ! general_operand (cmp_b, GET_MODE (cmp_b)))\n+    return NULL_RTX;\n+\n+  return emit_conditional_move (x, code, cmp_a, cmp_b, VOIDmode,\n+\t\t\t\tvtrue, vfalse, GET_MODE (x),\n+\t\t\t        (code == LTU || code == GEU\n+\t\t\t\t || code == LEU || code == GTU));\n+}\n+\n+/* Try only simple constants and registers here.  More complex cases\n+   are handled in noce_try_cmove_arith after noce_try_store_flag_arith\n+   has had a go at it.  */\n+\n+static int\n+noce_try_cmove (if_info)\n+     struct noce_if_info *if_info;\n+{\n+  enum rtx_code code;\n+  rtx target, seq;\n+\n+  if ((CONSTANT_P (if_info->a) || register_operand (if_info->a, VOIDmode))\n+      && (CONSTANT_P (if_info->b) || register_operand (if_info->b, VOIDmode)))\n+    {\n+      start_sequence ();\n+\n+      code = GET_CODE (if_info->cond);\n+      target = noce_emit_cmove (if_info, if_info->x, code,\n+\t\t\t\tXEXP (if_info->cond, 0),\n+\t\t\t\tXEXP (if_info->cond, 1),\n+\t\t\t\tif_info->a, if_info->b);\n+\n+      if (target)\n+\t{\n+\t  if (target != if_info->x)\n+\t    emit_move_insn (if_info->x, target);\n+\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insns_before (seq, if_info->cond_earliest);\n+\t  return TRUE;\n+\t}\n+      else\n+\t{\n+\t  end_sequence ();\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Try more complex cases involving conditional_move.  */\n+\n+static int\n+noce_try_cmove_arith (if_info)\n+     struct noce_if_info *if_info;\n+{\n+  rtx a = if_info->a;\n+  rtx b = if_info->b;\n+  rtx x = if_info->x;\n+  rtx insn_a, insn_b;\n+  rtx tmp, target;\n+  int is_mem = 0;\n+  enum rtx_code code;\n+\n+  /* A conditional move from two memory sources is equivalent to a\n+     conditional on their addresses followed by a load.  Don't do this\n+     early because it'll screw alias analysis.  Note that we've\n+     already checked for no side effects.  */\n+  if (! no_new_pseudos && cse_not_expected\n+      && GET_CODE (a) == MEM && GET_CODE (b) == MEM\n+      && BRANCH_COST >= 5)\n+    {\n+      a = XEXP (a, 0);\n+      b = XEXP (b, 0);\n+      x = gen_reg_rtx (Pmode);\n+      is_mem = 1;\n+    }\n+\n+  /* ??? We could handle this if we knew that a load from A or B could\n+     not fault.  This is true of stack memories or if we've already loaded\n+     from the address along the path from ENTRY.  */\n+  else if (GET_CODE (a) == MEM || GET_CODE (b) == MEM)\n+    return FALSE;\n+\n+  /* if (test) x = a + b; else x = c - d;\n+     => y = a + b;\n+        x = c - d;\n+\tif (test)\n+\t  x = y;\n+  */\n+  \n+  code = GET_CODE (if_info->cond);\n+  insn_a = if_info->insn_a;\n+  insn_b = if_info->insn_b;\n+\n+  /* Possibly rearrange operands to make things come out more natural.  */\n+  if (can_reverse_comparison_p (if_info->cond, if_info->jump))\n+    {\n+      int reversep = 0;\n+      if (rtx_equal_p (b, x))\n+\treversep = 1;\n+      else if (general_operand (b, GET_MODE (b)))\n+\treversep = 1;\n+\n+      if (reversep)\n+\t{\n+\t  code = reverse_condition (code);\n+\t  tmp = a, a = b, b = tmp;\n+\t  tmp = insn_a, insn_a = insn_b, insn_b = tmp;\n+\t}\n+    }\n+\n+  start_sequence ();\n+\n+  /* If either operand is complex, load it into a register first.\n+     The best way to do this is to copy the original insn.  In this\n+     way we preserve any clobbers etc that the insn may have had.  \n+     This is of course not possible in the IS_MEM case.  */\n+  if (! general_operand (a, GET_MODE (a)))\n+    {\n+      rtx set;\n+\n+      if (no_new_pseudos)\n+\tgoto end_seq_and_fail;\n+\n+      if (is_mem)\n+\t{\n+\t  tmp = gen_reg_rtx (GET_MODE (a));\n+\t  tmp = emit_insn (gen_rtx_SET (VOIDmode, tmp, a));\n+\t}\n+      else if (! insn_a)\n+\tgoto end_seq_and_fail;\n+      else\n+\t{\n+\t  a = gen_reg_rtx (GET_MODE (a));\n+\t  tmp = copy_rtx (insn_a);\n+\t  set = single_set (tmp);\n+\t  SET_DEST (set) = a;\n+\t  tmp = emit_insn (PATTERN (tmp));\n+\t}\n+      if (recog_memoized (tmp) < 0)\n+\tgoto end_seq_and_fail;\n+    }\n+  if (! general_operand (b, GET_MODE (b)))\n+    {\n+      rtx set;\n+\n+      if (no_new_pseudos)\n+\tgoto end_seq_and_fail;\n+\n+      if (is_mem)\n+\t{\n+          tmp = gen_reg_rtx (GET_MODE (b));\n+\t  tmp = emit_insn (gen_rtx_SET (VOIDmode, tmp, b));\n+\t}\n+      else if (! insn_b)\n+\tgoto end_seq_and_fail;\n+      else\n+\t{\n+          b = gen_reg_rtx (GET_MODE (b));\n+\t  tmp = copy_rtx (insn_b);\n+\t  set = single_set (tmp);\n+\t  SET_DEST (set) = b;\n+\t  tmp = emit_insn (PATTERN (tmp));\n+\t}\n+      if (recog_memoized (tmp) < 0)\n+\tgoto end_seq_and_fail;\n+    }\n+\n+  target = noce_emit_cmove (if_info, x, code, XEXP (if_info->cond, 0),\n+\t\t\t    XEXP (if_info->cond, 1), a, b);\n+\n+  if (! target)\n+    goto end_seq_and_fail;\n+\n+  /* If we're handling a memory for above, emit the load now.  */\n+  if (is_mem)\n+    {\n+      tmp = gen_rtx_MEM (GET_MODE (if_info->x), target);\n+\n+      /* Copy over flags as appropriate.  */\n+      if (MEM_VOLATILE_P (if_info->a) || MEM_VOLATILE_P (if_info->b))\n+\tMEM_VOLATILE_P (tmp) = 1;\n+      if (MEM_IN_STRUCT_P (if_info->a) && MEM_IN_STRUCT_P (if_info->b))\n+\tMEM_IN_STRUCT_P (tmp) = 1;\n+      if (MEM_SCALAR_P (if_info->a) && MEM_SCALAR_P (if_info->b))\n+\tMEM_SCALAR_P (tmp) = 1;\n+      if (MEM_ALIAS_SET (if_info->a) == MEM_ALIAS_SET (if_info->b))\n+\tMEM_ALIAS_SET (tmp) = MEM_ALIAS_SET (if_info->a);\n+\n+      emit_move_insn (if_info->x, tmp);\n+    }\n+  else if (target != x)\n+    emit_move_insn (x, target);\n+\n+  tmp = get_insns ();\n+  end_sequence ();\n+  emit_insns_before (tmp, if_info->cond_earliest);\n+  return TRUE;\n+\n+ end_seq_and_fail:\n+  end_sequence ();\n+  return FALSE;\n+}\n+\n+/* Look for the condition for the jump first.  We'd prefer to avoid\n+   get_condition if we can -- it tries to look back for the contents\n+   of an original compare.  On targets that use normal integers for\n+   comparisons, e.g. alpha, this is wasteful.  */\n+\n+static rtx\n+noce_get_condition (jump, earliest)\n+     rtx jump;\n+     rtx *earliest;\n+{\n+  rtx cond;\n+\n+  /* If the condition variable is a register and is MODE_INT, accept it.\n+     Otherwise, fall back on get_condition.  */\n+\n+  if (! condjump_p (jump))\n+    return NULL_RTX;\n+\n+  cond = XEXP (SET_SRC (PATTERN (jump)), 0);\n+  if (GET_CODE (XEXP (cond, 0)) == REG\n+      && GET_MODE_CLASS (GET_MODE (XEXP (cond, 0))) == MODE_INT)\n+    {\n+      *earliest = jump;\n+\n+      /* If this branches to JUMP_LABEL when the condition is false,\n+\t reverse the condition.  */\n+      if (GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 2)) == LABEL_REF\n+\t  && XEXP (XEXP (SET_SRC (PATTERN (jump)), 2), 0) == JUMP_LABEL (jump))\n+\tcond = gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond)),\n+\t\t\t       GET_MODE (cond), XEXP (cond, 0),\n+\t\t\t       XEXP (cond, 1));\n+    }\n+  else\n+    cond = get_condition (jump, earliest);\n+\n+  return cond;\n+}\n+\n+/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it\n+   without using conditional execution.  Return TRUE if we were\n+   successful at converting the the block.  */\n+\n+static int\n+noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n+     basic_block test_bb;\t/* Basic block test is in */\n+     basic_block then_bb;\t/* Basic block for THEN block */\n+     basic_block else_bb;\t/* Basic block for ELSE block */\n+     basic_block join_bb;\t/* Basic block the join label is in */\n+{\n+  /* We're looking for patterns of the form\n+\n+     (1) if (...) x = a; else x = b;\n+     (2) x = b; if (...) x = a;\n+     (3) if (...) x = a;   // as if with an initial x = x.\n+\n+     The later patterns require jumps to be more expensive.\n+\n+     ??? For future expansion, look for multiple X in such patterns.  */\n+\n+  struct noce_if_info if_info;\n+  rtx insn_a, insn_b;\n+  rtx set_a, set_b;\n+  rtx orig_x, x, a, b;\n+  rtx jump, cond;\n+\n+  /* If this is not a standard conditional jump, we can't parse it.  */\n+  jump = test_bb->end;\n+  cond = noce_get_condition (jump, &if_info.cond_earliest);\n+  if (! cond)\n+    return FALSE;\n+\n+  /* We must be comparing objects whose modes imply the size.  */\n+  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n+    return FALSE;\n+\n+  /* Look for one of the potential sets.  */\n+  insn_a = first_active_insn (then_bb);\n+  if (! insn_a\n+      || ! last_active_insn_p (then_bb, insn_a)\n+      || (set_a = single_set (insn_a)) == NULL_RTX)\n+    return FALSE;\n+\n+  x = SET_DEST (set_a);\n+  a = SET_SRC (set_a);\n+\n+  /* Look for the other potential set.  Make sure we've got equivalent\n+     destinations.  */\n+  /* ??? This is overconservative.  Storing to two different mems is\n+     as easy as conditionally computing the address.  Storing to a\n+     single mem merely requires a scratch memory to use as one of the\n+     destination addresses; often the memory immediately below the\n+     stack pointer is available for this.  */\n+  set_b = NULL_RTX;\n+  if (else_bb)\n+    {\n+      insn_b = first_active_insn (else_bb);\n+      if (! insn_b\n+\t  || ! last_active_insn_p (else_bb, insn_b)\n+\t  || (set_b = single_set (insn_b)) == NULL_RTX\n+\t  || ! rtx_equal_p (x, SET_DEST (set_b)))\n+\treturn FALSE;\n+    }\n+  else\n+    {\n+      insn_b = prev_nonnote_insn (if_info.cond_earliest);\n+      if (! insn_b\n+\t  || GET_CODE (insn_b) != INSN\n+\t  || (set_b = single_set (insn_b)) == NULL_RTX\n+\t  || ! rtx_equal_p (x, SET_DEST (set_b))\n+\t  || reg_mentioned_p (x, cond))\n+\tinsn_b = set_b = NULL_RTX;\n+    }\n+  b = (set_b ? SET_SRC (set_b) : x);\n+\n+  /* Only operate on register destinations, and even then avoid extending\n+     the lifetime of hard registers on small register class machines.  */\n+  orig_x = x;\n+  if (GET_CODE (x) != REG\n+      || (SMALL_REGISTER_CLASSES\n+\t  && REGNO (x) < FIRST_PSEUDO_REGISTER))\n+    {\n+      if (no_new_pseudos)\n+\treturn FALSE;\n+      x = gen_reg_rtx (GET_MODE (x));\n+    }\n+\n+  /* Don't operate on sources that may trap or are volatile.  */\n+  if (side_effects_p (a) || side_effects_p (b)\n+      || (GET_CODE (a) != MEM && may_trap_p (a))\n+      || (GET_CODE (b) != MEM && may_trap_p (b)))\n+    return FALSE;\n+\n+  /* Set up the info block for our subroutines.  */\n+  if_info.cond = cond;\n+  if_info.jump = jump;\n+  if_info.insn_a = insn_a;\n+  if_info.insn_b = insn_b;\n+  if_info.x = x;\n+  if_info.a = a;\n+  if_info.b = b;\n+\n+  /* Try optimizations in some approximation of a useful order.  */\n+  /* ??? Should first look to see if X is live incoming at all.  If it\n+     isn't, we don't need anything but an unconditional set.  */\n+\n+  /* Look and see if A and B are really the same.  Avoid creating silly\n+     cmove constructs that no one will fix up later.  */\n+  if (rtx_equal_p (a, b))\n+    {\n+      /* If we have an INSN_B, we don't have to create any new rtl.  Just\n+\t move the instruction that we already have.  If we don't have an\n+\t INSN_B, that means that A == X, and we've got a noop move.  In\n+\t that case don't do anything and let the code below delete INSN_A.  */\n+      if (insn_b && else_bb)\n+\t{\n+\t  if (else_bb && insn_b == else_bb->end)\n+\t    else_bb->end = PREV_INSN (insn_b);\n+\t  reorder_insns (insn_b, insn_b, PREV_INSN (if_info.cond_earliest));\n+\t  insn_b = NULL_RTX;\n+\t  x = orig_x;\n+\t}\n+      goto success;\n+    }\n+\n+  if (noce_try_store_flag (&if_info))\n+    goto success;\n+  if (HAVE_conditional_move\n+      && noce_try_cmove (&if_info))\n+    goto success;\n+  if (! HAVE_conditional_execution)\n+    {\n+      if (noce_try_store_flag_constants (&if_info))\n+\tgoto success;\n+      if (noce_try_store_flag_inc (&if_info))\n+\tgoto success;\n+      if (noce_try_store_flag_mask (&if_info))\n+\tgoto success;\n+      if (HAVE_conditional_move\n+\t  && noce_try_cmove_arith (&if_info))\n+\tgoto success;\n+    }\n+\n+  return FALSE;\n+\n+ success:\n+  /* The original sets may now be killed.  */\n+  if (insn_a == then_bb->end)\n+    then_bb->end = PREV_INSN (insn_a);\n+  flow_delete_insn (insn_a);\n+\n+  /* Several special cases here: First, we may have reused insn_b above,\n+     in which case insn_b is now NULL.  Second, we want to delete insn_b\n+     if it came from the ELSE block, because follows the now correct\n+     write that appears in the TEST block.  However, if we got insn_b from\n+     the TEST block, it may in fact be loading data needed for the comparison.\n+     We'll let life_analysis remove the insn if it's really dead.  */\n+  if (insn_b && else_bb)\n+    {\n+      if (insn_b == else_bb->end)\n+\telse_bb->end = PREV_INSN (insn_b);\n+      flow_delete_insn (insn_b);\n+    }\n+\n+  /* The new insns will have been inserted before cond_earliest.  We should\n+     be able to remove cond_earliest through the jump with impunity.  */\n+  insn_a = prev_nonnote_insn (if_info.cond_earliest);\n+  flow_delete_insn_chain (if_info.cond_earliest, test_bb->end);\n+  test_bb->end = insn_a;\n+\n+  /* If we used a temporary, fix it up now.  */\n+  if (orig_x != x)\n+    {\n+      start_sequence ();\n+      emit_move_insn (orig_x, x);\n+      insn_b = gen_sequence ();\n+      end_sequence ();\n+\n+      test_bb->end = emit_insn_after (insn_b, insn_a);\n+    }\n+\n+  /* Merge the blocks!  */\n+  merge_if_block (test_bb, then_bb, else_bb, join_bb);\n+\n+  return TRUE;\n+}\n+\f\n+/* Attempt to convert an IF-THEN or IF-THEN-ELSE block into\n+   straight line code.  Return true if successful.  */\n+\n+static int\n+process_if_block (test_bb, then_bb, else_bb, join_bb)\n+     basic_block test_bb;\t/* Basic block test is in */\n+     basic_block then_bb;\t/* Basic block for THEN block */\n+     basic_block else_bb;\t/* Basic block for ELSE block */\n+     basic_block join_bb;\t/* Basic block the join label is in */\n+{\n+  if (! reload_completed\n+      && noce_process_if_block (test_bb, then_bb, else_bb, join_bb))\n+    return TRUE;\n+\n+  if (HAVE_conditional_execution\n+      && reload_completed\n+      && cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb))\n+    return TRUE;\n+\n+  return FALSE;\n+}\n+\n+/* Merge the blocks and mark for local life update.  */\n+\n+static void\n+merge_if_block (test_bb, then_bb, else_bb, join_bb)\n+     basic_block test_bb;\t/* Basic block test is in */\n+     basic_block then_bb;\t/* Basic block for THEN block */\n+     basic_block else_bb;\t/* Basic block for ELSE block */\n+     basic_block join_bb;\t/* Basic block the join label is in */\n+{\n+  basic_block combo_bb;\n+\n+  /* All block merging is done into the lower block numbers.  */\n+\n+  combo_bb = test_bb;\n+\n+  /* First merge TEST block into THEN block.  This is a no-brainer since\n+     the THEN block did not have a code label to begin with.  */\n+\n+  if (combo_bb->global_live_at_end)\n+    COPY_REG_SET (combo_bb->global_live_at_end, then_bb->global_live_at_end);\n+  merge_blocks_nomove (combo_bb, then_bb);\n+  num_removed_blocks++;\n+\n+  /* The ELSE block, if it existed, had a label.  That label count\n+     will almost always be zero, but odd things can happen when labels\n+     get their addresses taken.  */\n+  if (else_bb)\n+    {\n+      if (LABEL_NUSES (else_bb->head) == 0\n+\t  && ! LABEL_PRESERVE_P (else_bb->head)\n+\t  && ! LABEL_NAME (else_bb->head))\n+\t{\n+\t  /* We can merge the ELSE.  */\n+\t  merge_blocks_nomove (combo_bb, else_bb);\n+\t  num_removed_blocks++;\n+\t}\n+      else\n+\t{\n+\t  /* We cannot merge the ELSE.  */\n+\n+\t  /* Properly rewire the edge out of the now combined\n+\t     TEST-THEN block to point here.  */\n+\t  remove_edge (combo_bb->succ);\n+\t  if (combo_bb->succ || else_bb->pred)\n+\t    abort ();\n+\t  make_edge (NULL, combo_bb, else_bb, EDGE_FALLTHRU);\n+\n+\t  /* Remove the jump and cruft from the end of the TEST-THEN block.  */\n+\t  tidy_fallthru_edge (combo_bb->succ, combo_bb, else_bb);\n+\n+\t  /* Make sure we update life info properly.  */\n+\t  SET_UPDATE_LIFE(combo_bb);\n+\t  if (else_bb->global_live_at_end)\n+\t    COPY_REG_SET (else_bb->global_live_at_start,\n+\t\t\t  else_bb->global_live_at_end);\n+\n+\t  /* The ELSE is the new combo block.  */\n+\t  combo_bb = else_bb;\n+\t}\n+    }\n+\n+  /* If there was no join block reported, that means it was not adjacent\n+     to the others, and so we cannot merge them.  */\n+\n+  if (! join_bb)\n+    {\n+      /* The outgoing edge for the current COMBO block should already\n+\t be correct.  Verify this.  */\n+      if (combo_bb->succ == NULL_EDGE)\n+\tabort ();\n+\n+      /* There should sill be a branch at the end of the THEN or ELSE\n+         blocks taking us to our final destination.  */\n+      if (! simplejump_p (combo_bb->end)\n+          && ! returnjump_p (combo_bb->end))\n+\tabort ();\n+    }\n+\n+  /* The JOIN block had a label.  It may have had quite a number\n+     of other predecessors too, but probably not.  See if we can\n+     merge this with the others.  */\n+  else if (LABEL_NUSES (join_bb->head) == 0\n+      && ! LABEL_PRESERVE_P (join_bb->head)\n+      && ! LABEL_NAME (join_bb->head))\n+    {\n+      /* We can merge the JOIN.  */\n+      if (combo_bb->global_live_at_end)\n+\tCOPY_REG_SET (combo_bb->global_live_at_end,\n+\t\t      join_bb->global_live_at_end);\n+      merge_blocks_nomove (combo_bb, join_bb);\n+      num_removed_blocks++;\n+    }\n+  else\n+    {\n+      /* We cannot merge the JOIN.  */\n+\n+      /* The outgoing edge for the current COMBO block should already\n+\t be correct.  Verify this.  */\n+      if (combo_bb->succ->succ_next != NULL_EDGE\n+\t  || combo_bb->succ->dest != join_bb)\n+\tabort ();\n+\n+      /* Remove the jump and cruft from the end of the COMBO block.  */\n+      tidy_fallthru_edge (combo_bb->succ, combo_bb, join_bb);\n+    }\n+\n+  /* Make sure we update life info properly.  */\n+  SET_UPDATE_LIFE (combo_bb);\n+\n+  num_updated_if_blocks++;\n+}\n+\f\n+/* Find a block ending in a simple IF condition.  Return TRUE if\n+   we were able to transform it in some way.  */\n+\n+static int\n+find_if_header (test_bb)\n+     basic_block test_bb;\n+{\n+  edge then_edge;\n+  edge else_edge;\n+\n+  /* The kind of block we're looking for has exactly two successors.  */\n+  if ((then_edge = test_bb->succ) == NULL_EDGE\n+      || (else_edge = then_edge->succ_next) == NULL_EDGE\n+      || else_edge->succ_next != NULL_EDGE)\n+    return FALSE;\n+\n+  /* Neither edge should be abnormal.  */\n+  if ((then_edge->flags & EDGE_COMPLEX)\n+      || (else_edge->flags & EDGE_COMPLEX))\n+    return FALSE;\n+\n+  /* The THEN edge is canonically the one that falls through.  */\n+  if (then_edge->flags & EDGE_FALLTHRU)\n+    ;\n+  else if (else_edge->flags & EDGE_FALLTHRU)\n+    {\n+      edge e = else_edge;\n+      else_edge = then_edge;\n+      then_edge = e;\n+    }\n+  else\n+    /* Otherwise this must be a multiway branch of some sort.  */\n+    return FALSE;\n+\n+  if (find_if_block (test_bb, then_edge, else_edge))\n+    goto success;\n+  if (post_dominators\n+      && (! HAVE_conditional_execution || reload_completed))\n+    {\n+      if (find_if_case_1 (test_bb, then_edge, else_edge))\n+\tgoto success;\n+      if (find_if_case_2 (test_bb, then_edge, else_edge))\n+\tgoto success;\n+    }\n+\n+  return FALSE;\n+\n+ success:\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Conversion succeeded.\\n\");\n+  return TRUE;\n+}\n+\n+/* Determine if a given basic block heads a simple IF-THEN or IF-THEN-ELSE\n+   block.  If so, we'll try to convert the insns to not require the branch.\n+   Return TRUE if we were successful at converting the the block.  */\n+\n+static int\n+find_if_block (test_bb, then_edge, else_edge)\n+      basic_block test_bb;\n+      edge then_edge, else_edge;\n+{\n+  basic_block then_bb = then_edge->dest;\n+  basic_block else_bb = else_edge->dest;\n+  basic_block join_bb = NULL_BLOCK;\n+  edge then_succ = then_bb->succ;\n+  edge else_succ = else_bb->succ;\n+  int next_index;\n+\n+  /* The THEN block of an IF-THEN combo must have exactly one predecessor.  */\n+  if (then_bb->pred->pred_next != NULL_EDGE)\n+    return FALSE;\n+\n+  /* The THEN block of an IF-THEN combo must have exactly one successor.  */\n+  if (then_succ == NULL_EDGE\n+      || then_succ->succ_next != NULL_EDGE\n+      || (then_succ->flags & EDGE_COMPLEX))\n+    return FALSE;\n+\n+  /* The THEN block may not start with a label, as might happen with an\n+     unused user label that has had its address taken.  */\n+  if (GET_CODE (then_bb->head) == CODE_LABEL)\n+    return FALSE;\n+\n+  /* If the THEN block's successor is the other edge out of the TEST block,\n+     then we have an IF-THEN combo without an ELSE.  */\n+  if (then_succ->dest == else_bb)\n+    {\n+      join_bb = else_bb;\n+      else_bb = NULL_BLOCK;\n+    }\n+\n+  /* If the THEN and ELSE block meet in a subsequent block, and the ELSE\n+     has exactly one predecessor and one successor, and the outgoing edge\n+     is not complex, then we have an IF-THEN-ELSE combo.  */\n+  else if (else_succ != NULL_EDGE\n+\t   && then_succ->dest == else_succ->dest\n+\t   && else_bb->pred->pred_next == NULL_EDGE\n+\t   && else_succ->succ_next == NULL_EDGE\n+\t   && ! (else_succ->flags & EDGE_COMPLEX))\n+    join_bb = else_succ->dest;\n+\n+  /* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */\n+  else\n+    return FALSE;\t   \n+\n+  num_possible_if_blocks++;\n+\n+  if (rtl_dump_file)\n+    {\n+      if (else_bb)\n+\tfprintf (rtl_dump_file,\n+\t\t \"\\nIF-THEN-ELSE block found, start %d, then %d, else %d, join %d\\n\",\n+\t\t test_bb->index, then_bb->index, else_bb->index,\n+\t\t join_bb->index);\n+      else\n+\tfprintf (rtl_dump_file,\n+\t\t \"\\nIF-THEN block found, start %d, then %d, join %d\\n\",\n+\t\t test_bb->index, then_bb->index, join_bb->index);\n+    }\n+\n+  /* Make sure IF, THEN, and ELSE, blocks are adjacent.  Actually, we\n+     get the first condition for free, since we've already asserted that\n+     there's a fallthru edge from IF to THEN.  */\n+  /* ??? As an enhancement, move the ELSE block.  Have to deal with EH and\n+     BLOCK notes, if by no other means than aborting the merge if they\n+     exist.  Sticky enough I don't want to think about it now.  */\n+  next_index = then_bb->index;\n+  if (else_bb && ++next_index != else_bb->index)\n+    return FALSE;\n+  if (++next_index != join_bb->index)\n+    {\n+      if (else_bb)\n+\tjoin_bb = NULL;\n+      else\n+\treturn FALSE;\n+    }\n+\n+  /* Do the real work.  */\n+  return process_if_block (test_bb, then_bb, else_bb, join_bb);\n+}\n+\n+/* Look for IF-THEN-ELSE cases in which one of THEN or ELSE is\n+   transformable, but not necessarily the other.  There need be no\n+   JOIN block.\n+\n+   Return TRUE if we were successful at converting the the block.\n+\n+   Cases we'd like to look at:\n+\n+   (1)\n+\tif (test) goto over; // x not live\n+\tx = a;\n+\tgoto label;\n+\tover:\n+\n+   becomes\n+\n+\tx = a;\n+\tif (! test) goto label;\n+\n+   (2)\n+\tif (test) goto E; // x not live\n+\tx = big();\n+\tgoto L;\n+\tE:\n+\tx = b;\n+\tgoto M;\n+\n+   becomes\n+\n+\tx = b;\n+\tif (test) goto M;\n+\tx = big();\n+\tgoto L;\n+\n+   (3) // This one's really only interesting for targets that can do\n+       // multiway branching, e.g. IA-64 BBB bundles.  For other targets\n+       // it results in multiple branches on a cache line, which often\n+       // does not sit well with predictors.\n+\n+\tif (test1) goto E; // predicted not taken\n+\tx = a;\n+\tif (test2) goto F;\n+\t...\n+\tE:\n+\tx = b;\n+\tJ:\n+\n+   becomes\n+\n+\tx = a;\n+\tif (test1) goto E;\n+\tif (test2) goto F;\n+\n+   Notes:\n+\n+   (A) Don't do (2) if the branch is predicted against the block we're\n+   eliminating.  Do it anyway if we can eliminate a branch; this requires\n+   that the sole successor of the eliminated block postdominate the other\n+   side of the if.\n+\n+   (B) With CE, on (3) we can steal from both sides of the if, creating\n+\n+\tif (test1) x = a;\n+\tif (!test1) x = b;\n+\tif (test1) goto J;\n+\tif (test2) goto F;\n+\t...\n+\tJ:\n+\n+   Again, this is most useful if J postdominates.\n+\n+   (C) CE substitutes for helpful life information.\n+\n+   (D) These heuristics need a lot of work.  */\n+\n+/* Tests for case 1 above.  */\n+\n+static int\n+find_if_case_1 (test_bb, then_edge, else_edge)\n+      basic_block test_bb;\n+      edge then_edge, else_edge;\n+{\n+  basic_block then_bb = then_edge->dest;\n+  basic_block else_bb = else_edge->dest;\n+  edge then_succ = then_bb->succ;\n+  rtx new_lab;\n+\n+  /* THEN has one successor.  */\n+  if (!then_succ || then_succ->succ_next != NULL)\n+    return FALSE;\n+\n+  /* THEN does not fall through, but is not strange either.  */\n+  if (then_succ->flags & (EDGE_COMPLEX | EDGE_FALLTHRU))\n+    return FALSE;\n+\n+  /* THEN has one predecessor.  */\n+  if (then_bb->pred->pred_next != NULL)\n+    return FALSE;\n+\n+  /* THEN has no label.  */\n+  if (GET_CODE (then_bb->head) == CODE_LABEL)\n+    return FALSE;\n+\n+  /* ELSE follows THEN.  (??? could be moved)  */\n+  if (else_bb->index != then_bb->index + 1)\n+    return FALSE;\n+\n+  num_possible_if_blocks++;\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \"\\nIF-CASE-1 found, start %d, then %d\\n\",\n+\t     test_bb->index, then_bb->index);\n+\n+  /* THEN is small.  */\n+  if (count_bb_insns (then_bb) > BRANCH_COST)\n+    return FALSE;\n+\n+  /* Find the label for THEN's destination.  */\n+  if (then_succ->dest == EXIT_BLOCK_PTR)\n+    new_lab = NULL_RTX;\n+  else\n+    {\n+      new_lab = JUMP_LABEL (then_bb->end);\n+      if (! new_lab)\n+\tabort ();\n+    }\n+\n+  /* Registers set are dead, or are predicable.  */\n+  if (! dead_or_predicable (test_bb, then_bb, else_bb, new_lab, 1))\n+    return FALSE;\n+\n+  /* Conversion went ok, including moving the insns and fixing up the\n+     jump.  Adjust the CFG to match.  */\n+\n+  SET_UPDATE_LIFE (test_bb);\n+  bitmap_operation (test_bb->global_live_at_end,\n+\t\t    else_bb->global_live_at_start,\n+\t\t    then_bb->global_live_at_end, BITMAP_IOR);\n+  \n+  make_edge (NULL, test_bb, then_succ->dest, 0);\n+  flow_delete_block (then_bb);\n+  tidy_fallthru_edge (else_edge, test_bb, else_bb);\n+\n+  num_removed_blocks++;\n+  num_updated_if_blocks++;\n+\n+  return TRUE;\n+}\n+\n+/* Test for case 2 above.  */\n+\n+static int\n+find_if_case_2 (test_bb, then_edge, else_edge)\n+      basic_block test_bb;\n+      edge then_edge, else_edge;\n+{\n+  basic_block then_bb = then_edge->dest;\n+  basic_block else_bb = else_edge->dest;\n+  edge else_succ = else_bb->succ;\n+  rtx new_lab, note;\n+\n+  /* ELSE has one successor.  */\n+  if (!else_succ || else_succ->succ_next != NULL)\n+    return FALSE;\n+\n+  /* ELSE outgoing edge is not complex.  */\n+  if (else_succ->flags & EDGE_COMPLEX)\n+    return FALSE;\n+\n+  /* ELSE has one predecessor.  */\n+  if (else_bb->pred->pred_next != NULL)\n+    return FALSE;\n+\n+  /* ELSE has a label we can delete.  */\n+  if (LABEL_NUSES (else_bb->head) > 1\n+      || LABEL_PRESERVE_P (else_bb->head)\n+      || LABEL_NAME (else_bb->head))\n+    return FALSE;\n+\n+  /* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */\n+  note = find_reg_note (test_bb->end, REG_BR_PROB, NULL_RTX);\n+  if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n+    ;\n+  else if (else_succ->dest->index < 0\n+\t   || (then_bb->index >= 0\n+\t       && TEST_BIT (post_dominators[ORIG_INDEX (then_bb)], \n+\t\t\t    ORIG_INDEX (else_succ->dest))))\n+    ;\n+  else\n+    return FALSE;\n+\n+  num_possible_if_blocks++;\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \"\\nIF-CASE-2 found, start %d, else %d\\n\",\n+\t     test_bb->index, else_bb->index);\n+\n+  /* ELSE is small.  */\n+  if (count_bb_insns (then_bb) > BRANCH_COST)\n+    return FALSE;\n+\n+  /* Find the label for ELSE's destination.  */\n+  if (else_succ->dest == EXIT_BLOCK_PTR)\n+    new_lab = NULL_RTX;\n+  else\n+    {\n+      if (else_succ->flags & EDGE_FALLTHRU)\n+\t{\n+\t  new_lab = else_succ->dest->head;\n+\t  if (GET_CODE (new_lab) != CODE_LABEL)\n+\t    abort ();\n+\t}\n+      else\n+\t{\n+\t  new_lab = JUMP_LABEL (else_bb->end);\n+\t  if (! new_lab)\n+\t    abort ();\n+\t}\n+    }\n+\n+  /* Registers set are dead, or are predicable.  */\n+  if (! dead_or_predicable (test_bb, else_bb, then_bb, new_lab, 0))\n+    return FALSE;\n+\n+  /* Conversion went ok, including moving the insns and fixing up the\n+     jump.  Adjust the CFG to match.  */\n+\n+  SET_UPDATE_LIFE (test_bb);\n+  bitmap_operation (test_bb->global_live_at_end,\n+\t\t    then_bb->global_live_at_start,\n+\t\t    else_bb->global_live_at_end, BITMAP_IOR);\n+  \n+  remove_edge (else_edge);\n+  make_edge (NULL, test_bb, else_succ->dest, 0);\n+  flow_delete_block (else_bb);\n+\n+  num_removed_blocks++;\n+  num_updated_if_blocks++;\n+\n+  /* ??? We may now fallthru from one of THEN's successors into a join\n+     block.  Rerun cleanup_cfg?  Examine things manually?  Wait?  */\n+\n+  return TRUE;\n+}\n+\n+/* A subroutine of dead_or_predicable called through for_each_rtx.\n+   Return 1 if a memory is found.  */\n+\n+static int\n+find_memory (px, data)\n+     rtx *px;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return GET_CODE (*px) == MEM;\n+}\n+\n+/* Used by the code above to perform the actual rtl transformations.\n+   Return TRUE if successful.\n+\n+   TEST_BB is the block containing the conditional branch.  MERGE_BB\n+   is the block containing the code to manipulate.  NEW_DEST is the\n+   label TEST_BB should be branching to after the conversion.\n+   REVERSEP is true if the sense of the branch should be reversed.  */\n+\n+static int\n+dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n+     basic_block test_bb, merge_bb, other_bb;\n+     rtx new_dest;\n+     int reversep;\n+{\n+  rtx head, end, jump, earliest, old_dest;\n+\n+  jump = test_bb->end;\n+\n+  /* Find the extent of the real code in the merge block.  */\n+  head = merge_bb->head;\n+  end = merge_bb->end;\n+\n+  if (GET_CODE (head) == CODE_LABEL)\n+    head = NEXT_INSN (head);\n+  if (GET_CODE (head) == NOTE)\n+    {\n+      if (head == end)\n+\t{\n+\t  head = end = NULL_RTX;\n+\t  goto no_body;\n+\t}\n+      head = NEXT_INSN (head);\n+    }\n+\n+  if (GET_CODE (end) == JUMP_INSN)\n+    {\n+      if (head == end)\n+\t{\n+\t  head = end = NULL_RTX;\n+\t  goto no_body;\n+\t}\n+      end = PREV_INSN (end);\n+    }\n+\n+  if (HAVE_conditional_execution)\n+    {\n+      /* In the conditional execution case, we have things easy.  We know\n+\t the condition is reversable.  We don't have to check life info,\n+\t becase we're going to conditionally execute the code anyway.\n+\t All that's left is making sure the insns involved can actually\n+\t be predicated.  */\n+\n+      rtx cond;\n+\n+      cond = cond_exec_get_condition (jump);\n+      if (reversep)\n+\tcond = gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond)),\n+\t\t\t       GET_MODE (cond), XEXP (cond, 0),\n+\t\t\t       XEXP (cond, 1));\n+\n+      if (! cond_exec_process_insns (head, end, cond, 0))\n+\tgoto cancel;\n+\n+      earliest = jump;\n+    }\n+  else\n+    {\n+      /* In the non-conditional execution case, we have to verify that there\n+\t are no trapping operations, no calls, no references to memory, and\n+\t that any registers modified are dead at the branch site.  */\n+\n+      rtx insn, cond, prev;\n+      regset_head merge_set_head, tmp_head, test_live_head, test_set_head;\n+      regset merge_set, tmp, test_live, test_set;\n+      struct propagate_block_info *pbi;\n+      int i, fail = 0;\n+\n+      /* Check for no calls or trapping operations.  */\n+      for (insn = head; ; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == CALL_INSN)\n+\t    return FALSE;\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      if (may_trap_p (PATTERN (insn)))\n+\t\treturn FALSE;\n+\n+\t      /* ??? Even non-trapping memories such as stack frame\n+\t\t references must be avoided.  For stores, we collect\n+\t\t no lifetime info; for reads, we'd have to assert\n+\t\t true_dependance false against every store in the\n+\t\t TEST range.  */\n+\t      if (for_each_rtx (&PATTERN (insn), find_memory, NULL))\n+\t\treturn FALSE;\n+\t    }\n+\t  if (insn == end)\n+\t    break;\n+\t}\n+\n+      if (! condjump_p (jump))\n+\treturn FALSE;\n+\n+      /* Find the extent of the conditional.  */\n+      cond = noce_get_condition (jump, &earliest);\n+      if (! cond)\n+\treturn FALSE;\n+\n+      /* Collect:\n+\t   MERGE_SET = set of registers set in MERGE_BB\n+\t   TEST_LIVE = set of registers live at EARLIEST\n+\t   TEST_SET  = set of registers set between EARLIEST and the\n+\t\t       end of the block.  */\n+\n+      tmp = INITIALIZE_REG_SET (tmp_head);\n+      merge_set = INITIALIZE_REG_SET (merge_set_head);\n+      test_live = INITIALIZE_REG_SET (test_live_head);\n+      test_set = INITIALIZE_REG_SET (test_set_head);\n+\n+      /* ??? bb->local_set is only valid during calculate_global_regs_live,\n+\t so we must recompute usage for MERGE_BB.  Not so bad, I suppose, \n+         since we've already asserted that MERGE_BB is small.  */\n+      propagate_block (merge_bb, tmp, merge_set, 0);\n+\n+      /* For small register class machines, don't lengthen lifetimes of\n+\t hard registers before reload.  */\n+      if (SMALL_REGISTER_CLASSES && ! reload_completed)\n+\t{\n+          EXECUTE_IF_SET_IN_BITMAP\n+\t    (merge_set, 0, i,\n+\t     {\n+\t       if (i < FIRST_PSEUDO_REGISTER\n+\t\t   && ! fixed_regs[i]\n+\t\t   && ! global_regs[i])\n+\t\tfail = 1;\n+\t     });\n+\t}\n+\n+      /* For TEST, we're interested in a range of insns, not a whole block.\n+\t Moreover, we're interested in the insns live from OTHER_BB.  */\n+\n+      COPY_REG_SET (test_live, other_bb->global_live_at_start);\n+      pbi = init_propagate_block_info (test_bb, test_live, test_set, 0);\n+\n+      for (insn = jump; ; insn = prev)\n+\t{\n+\t  prev = propagate_one_insn (pbi, insn);\n+\t  if (insn == earliest)\n+\t    break;\n+\t}\n+\n+      free_propagate_block_info (pbi);\n+\n+      /* We can perform the transformation if\n+\t   MERGE_SET & (TEST_SET | TEST_LIVE)\n+\t and\n+\t   TEST_SET & merge_bb->global_live_at_start\n+\t are empty.  */\n+\n+      bitmap_operation (tmp, test_set, test_live, BITMAP_IOR);\n+      bitmap_operation (tmp, tmp, merge_set, BITMAP_AND);\n+      EXECUTE_IF_SET_IN_BITMAP(tmp, 0, i, fail = 1);\n+\n+      bitmap_operation (tmp, test_set, merge_bb->global_live_at_start,\n+\t\t\tBITMAP_AND);\n+      EXECUTE_IF_SET_IN_BITMAP(tmp, 0, i, fail = 1);\n+\n+      FREE_REG_SET (tmp);\n+      FREE_REG_SET (merge_set);\n+      FREE_REG_SET (test_live);\n+      FREE_REG_SET (test_set);\n+\n+      if (fail)\n+\treturn FALSE;\n+    }\n+\n+ no_body:\n+  /* We don't want to use normal invert_jump or redirect_jump because\n+     we don't want to delete_insn called.  Also, we want to do our own\n+     change group management.  */\n+\n+  old_dest = JUMP_LABEL (jump);\n+  if (reversep\n+      ? ! invert_jump_1 (jump, new_dest)\n+      : ! redirect_jump_1 (jump, new_dest))\n+    goto cancel;\n+\n+  if (! apply_change_group ())\n+    return FALSE;\n+\n+  if (old_dest)\n+    LABEL_NUSES (old_dest) -= 1;\n+  if (new_dest)\n+    LABEL_NUSES (new_dest) += 1;\n+  JUMP_LABEL (jump) = new_dest;\n+\n+  if (reversep)\n+    {\n+      rtx note = find_reg_note (jump, REG_BR_PROB, NULL_RTX);\n+      if (note)\n+\tXEXP (note, 0) = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (note, 0)));\n+    }\n+\n+  /* Move the insns out of MERGE_BB to before the branch.  */\n+  if (end == merge_bb->end)\n+    merge_bb->end = merge_bb->head;\n+  if (head != NULL)\n+    {\n+      head = squeeze_notes (head, end);\n+      reorder_insns (head, end, PREV_INSN (earliest));\n+    }\n+  return TRUE;\n+\n+ cancel:\n+  cancel_changes (0);\n+  return FALSE;\n+}\n+\f\n+/* Main entry point for all if-conversion.  */\n+\n+void\n+if_convert (life_data_ok)\n+     int life_data_ok;\n+{\n+  int block_num;\n+\n+  num_possible_if_blocks = 0;\n+  num_updated_if_blocks = 0;\n+  num_removed_blocks = 0;\n+\n+  /* Free up basic_block_for_insn so that we don't have to keep it \n+     up to date, either here or in merge_blocks_nomove.  */\n+  free_basic_block_vars (1);\n+\n+  /* Compute postdominators if we think we'll use them.  */\n+  post_dominators = NULL;\n+  if (HAVE_conditional_execution || life_data_ok)\n+    {\n+      post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+      compute_flow_dominators (NULL, post_dominators);\n+    }\n+\n+  /* Record initial block numbers.  */\n+  for (block_num = 0; block_num < n_basic_blocks; block_num++)\n+    SET_ORIG_INDEX (BASIC_BLOCK (block_num), block_num);\n+\n+  /* Go through each of the basic blocks looking for things to convert.  */\n+  for (block_num = 0; block_num < n_basic_blocks; )\n+    {\n+      basic_block bb = BASIC_BLOCK (block_num);\n+      if (find_if_header (bb))\n+\tblock_num = bb->index;\n+      else \n+\tblock_num++;\n+    }\n+\n+  sbitmap_vector_free (post_dominators);\n+\n+  if (rtl_dump_file)\n+    fflush (rtl_dump_file);\n+\n+  /* Rebuild basic_block_for_insn for update_life_info and for gcse.  */\n+  compute_bb_for_insn (get_max_uid ());\n+\n+  /* Rebuild life info for basic blocks that require it.  */\n+  if (num_removed_blocks && life_data_ok)\n+    {\n+      sbitmap update_life_blocks = sbitmap_alloc (n_basic_blocks);\n+      sbitmap_zero (update_life_blocks);\n+\n+      /* If we allocated new pseudos, we must resize the array for sched1.  */\n+      if (max_regno < max_reg_num ())\n+\t{\n+\t  max_regno = max_reg_num ();\n+\t  allocate_reg_info (max_regno, FALSE, FALSE);\n+\t}\n+\n+      for (block_num = 0; block_num < n_basic_blocks; block_num++)\n+\tif (UPDATE_LIFE (BASIC_BLOCK (block_num)))\n+\t  SET_BIT (update_life_blocks, block_num);\n+\n+      count_or_remove_death_notes (update_life_blocks, 1);\n+      update_life_info (update_life_blocks, UPDATE_LIFE_LOCAL,\n+\t\t\tPROP_DEATH_NOTES);\n+\n+      sbitmap_free (update_life_blocks);\n+    }\n+\n+  /* Write the final stats.  */\n+  if (rtl_dump_file && num_possible_if_blocks > 0)\n+    {\n+      fprintf (rtl_dump_file,\n+\t       \"\\n%d possible IF blocks searched.\\n\",\n+\t       num_possible_if_blocks);\n+      fprintf (rtl_dump_file,\n+\t       \"%d IF blocks converted.\\n\",\n+\t       num_updated_if_blocks);\n+      fprintf (rtl_dump_file,\n+\t       \"%d basic blocks deleted.\\n\\n\\n\",\n+\t       num_removed_blocks);\n+    }\n+\n+  verify_flow_info ();\n+}"}, {"sha": "baffdf03b7bbe6184d6f838e51bc9183f7489490", "filename": "gcc/jump.c", "status": "modified", "additions": 13, "deletions": 1478, "changes": 1491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "patch": "@@ -128,9 +128,6 @@ static int delete_labelref_insn\t\tPARAMS ((rtx, rtx, int));\n static void mark_modified_reg\t\tPARAMS ((rtx, rtx, void *));\n static void redirect_tablejump\t\tPARAMS ((rtx, rtx));\n static void jump_optimize_1\t\tPARAMS ((rtx, int, int, int, int, int));\n-#if ! defined(HAVE_cc0) && ! defined(HAVE_conditional_arithmetic)\n-static rtx find_insert_position         PARAMS ((rtx, rtx));\n-#endif\n static int returnjump_p_1\t        PARAMS ((rtx *, void *));\n static void delete_prior_computation    PARAMS ((rtx, rtx));\n \f\n@@ -300,9 +297,10 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n       for (insn = f; insn; insn = next)\n \t{\n \t  rtx reallabelprev;\n-\t  rtx temp, temp1, temp2 = NULL_RTX, temp3, temp4, temp5, temp6;\n+\t  rtx temp, temp1, temp2 = NULL_RTX;\n+\t  rtx temp4 ATTRIBUTE_UNUSED;\n \t  rtx nlabel;\n-\t  int this_is_simplejump, this_is_condjump, reversep = 0;\n+\t  int this_is_simplejump, this_is_condjump;\n \t  int this_is_condjump_in_parallel;\n \n \t  next = NEXT_INSN (insn);\n@@ -514,1437 +512,18 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t      next = NEXT_INSN (insn);\n \t    }\n \n-\t  /* Simplify   if (...) x = a; else x = b; by converting it\n-\t     to         x = b; if (...) x = a;\n-\t     if B is sufficiently simple, the test doesn't involve X,\n-\t     and nothing in the test modifies B or X.\n-\n-\t     If we have small register classes, we also can't do this if X\n-\t     is a hard register.\n-\n-\t     If the \"x = b;\" insn has any REG_NOTES, we don't do this because\n-\t     of the possibility that we are running after CSE and there is a\n-\t     REG_EQUAL note that is only valid if the branch has already been\n-\t     taken.  If we move the insn with the REG_EQUAL note, we may\n-\t     fold the comparison to always be false in a later CSE pass.\n-\t     (We could also delete the REG_NOTES when moving the insn, but it\n-\t     seems simpler to not move it.)  An exception is that we can move\n-\t     the insn if the only note is a REG_EQUAL or REG_EQUIV whose\n-\t     value is the same as \"b\".\n-\n-\t     INSN is the branch over the `else' part. \n-\n-\t     We set:\n-\n-\t     TEMP to the jump insn preceding \"x = a;\"\n-\t     TEMP1 to X\n-\t     TEMP2 to the insn that sets \"x = b;\"\n-\t     TEMP3 to the insn that sets \"x = a;\"\n-\t     TEMP4 to the set of \"x = b\";  */\n-\n-\t  if (this_is_simplejump\n-\t      && (temp3 = prev_active_insn (insn)) != 0\n-\t      && GET_CODE (temp3) == INSN\n-\t      && (temp4 = single_set (temp3)) != 0\n-\t      && GET_CODE (temp1 = SET_DEST (temp4)) == REG\n-\t      && (! SMALL_REGISTER_CLASSES\n-\t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n-\t      && (temp2 = next_active_insn (insn)) != 0\n-\t      && GET_CODE (temp2) == INSN\n-\t      && (temp4 = single_set (temp2)) != 0\n-\t      && rtx_equal_p (SET_DEST (temp4), temp1)\n-\t      && ! side_effects_p (SET_SRC (temp4))\n-\t      && ! may_trap_p (SET_SRC (temp4))\n-\t      && (REG_NOTES (temp2) == 0\n-\t\t  || ((REG_NOTE_KIND (REG_NOTES (temp2)) == REG_EQUAL\n-\t\t       || REG_NOTE_KIND (REG_NOTES (temp2)) == REG_EQUIV)\n-\t\t      && XEXP (REG_NOTES (temp2), 1) == 0\n-\t\t      && rtx_equal_p (XEXP (REG_NOTES (temp2), 0),\n-\t\t\t\t      SET_SRC (temp4))))\n-\t      && (temp = prev_active_insn (temp3)) != 0\n-\t      && condjump_p (temp) && ! simplejump_p (temp)\n-\t      /* TEMP must skip over the \"x = a;\" insn */\n-\t      && prev_real_insn (JUMP_LABEL (temp)) == insn\n-\t      && no_labels_between_p (insn, JUMP_LABEL (temp))\n-\t      /* There must be no other entries to the \"x = b;\" insn.  */\n-\t      && no_labels_between_p (JUMP_LABEL (temp), temp2)\n-\t      /* INSN must either branch to the insn after TEMP2 or the insn\n-\t\t after TEMP2 must branch to the same place as INSN.  */\n-\t      && (reallabelprev == temp2\n-\t\t  || ((temp5 = next_active_insn (temp2)) != 0\n-\t\t      && simplejump_p (temp5)\n-\t\t      && JUMP_LABEL (temp5) == JUMP_LABEL (insn))))\n-\t    {\n-\t      /* The test expression, X, may be a complicated test with\n-\t\t multiple branches.  See if we can find all the uses of\n-\t\t the label that TEMP branches to without hitting a CALL_INSN\n-\t\t or a jump to somewhere else.  */\n-\t      rtx target = JUMP_LABEL (temp);\n-\t      int nuses = LABEL_NUSES (target);\n-\t      rtx p;\n-#ifdef HAVE_cc0\n-\t      rtx q;\n-#endif\n-\n-\t      /* Set P to the first jump insn that goes around \"x = a;\".  */\n-\t      for (p = temp; nuses && p; p = prev_nonnote_insn (p))\n-\t\t{\n-\t\t  if (GET_CODE (p) == JUMP_INSN)\n-\t\t    {\n-\t\t      if (condjump_p (p) && ! simplejump_p (p)\n-\t\t\t  && JUMP_LABEL (p) == target)\n-\t\t\t{\n-\t\t\t  nuses--;\n-\t\t\t  if (nuses == 0)\n-\t\t\t    break;\n-\t\t\t}\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  else if (GET_CODE (p) == CALL_INSN)\n-\t\t    break;\n-\t\t}\n-\n-#ifdef HAVE_cc0\n-\t      /* We cannot insert anything between a set of cc and its use\n-\t\t so if P uses cc0, we must back up to the previous insn.  */\n-\t      q = prev_nonnote_insn (p);\n-\t      if (q && GET_RTX_CLASS (GET_CODE (q)) == 'i'\n-\t\t  && sets_cc0_p (PATTERN (q)))\n-\t\tp = q;\n-#endif\n-\n-\t      if (p)\n-\t\tp = PREV_INSN (p);\n-\n-\t      /* If we found all the uses and there was no data conflict, we\n-\t\t can move the assignment unless we can branch into the middle\n-\t\t from somewhere.  */\n-\t      if (nuses == 0 && p\n-\t\t  && no_labels_between_p (p, insn)\n-\t\t  && ! reg_referenced_between_p (temp1, p, NEXT_INSN (temp3))\n-\t\t  && ! reg_set_between_p (temp1, p, temp3)\n-\t\t  && (GET_CODE (SET_SRC (temp4)) == CONST_INT\n-\t\t      || ! modified_between_p (SET_SRC (temp4), p, temp2))\n-\t\t  /* Verify that registers used by the jump are not clobbered\n-\t\t     by the instruction being moved.  */\n-\t\t  && ! regs_set_between_p (PATTERN (temp),\n-\t\t\t\t\t   PREV_INSN (temp2),\n-\t\t\t\t\t   NEXT_INSN (temp2)))\n-\t\t{\n-\t\t  emit_insn_after_with_line_notes (PATTERN (temp2), p, temp2);\n-\t\t  delete_insn (temp2);\n-\n-\t\t  /* Set NEXT to an insn that we know won't go away.  */\n-\t\t  next = next_active_insn (insn);\n-\n-\t\t  /* Delete the jump around the set.  Note that we must do\n-\t\t     this before we redirect the test jumps so that it won't\n-\t\t     delete the code immediately following the assignment\n-\t\t     we moved (which might be a jump).  */\n-\n-\t\t  delete_insn (insn);\n-\n-\t\t  /* We either have two consecutive labels or a jump to\n-\t\t     a jump, so adjust all the JUMP_INSNs to branch to where\n-\t\t     INSN branches to.  */\n-\t\t  for (p = NEXT_INSN (p); p != next; p = NEXT_INSN (p))\n-\t\t    if (GET_CODE (p) == JUMP_INSN)\n-\t\t      redirect_jump (p, target);\n-\n-\t\t  changed = 1;\n-\t\t  next = NEXT_INSN (insn);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n-\t  /* Simplify   if (...) { x = a; goto l; } x = b; by converting it\n-\t     to         x = a; if (...) goto l; x = b;\n-\t     if A is sufficiently simple, the test doesn't involve X,\n-\t     and nothing in the test modifies A or X.\n-\n-\t     If we have small register classes, we also can't do this if X\n-\t     is a hard register.\n-\n-\t     If the \"x = a;\" insn has any REG_NOTES, we don't do this because\n-\t     of the possibility that we are running after CSE and there is a\n-\t     REG_EQUAL note that is only valid if the branch has already been\n-\t     taken.  If we move the insn with the REG_EQUAL note, we may\n-\t     fold the comparison to always be false in a later CSE pass.\n-\t     (We could also delete the REG_NOTES when moving the insn, but it\n-\t     seems simpler to not move it.)  An exception is that we can move\n-\t     the insn if the only note is a REG_EQUAL or REG_EQUIV whose\n-\t     value is the same as \"a\".\n-\n-\t     INSN is the goto.\n-\n-\t     We set:\n-\n-\t     TEMP to the jump insn preceding \"x = a;\"\n-\t     TEMP1 to X\n-\t     TEMP2 to the insn that sets \"x = b;\"\n-\t     TEMP3 to the insn that sets \"x = a;\"\n-\t     TEMP4 to the set of \"x = a\";  */\n-\n-\t  if (this_is_simplejump\n-\t      && (temp2 = next_active_insn (insn)) != 0\n-\t      && GET_CODE (temp2) == INSN\n-\t      && (temp4 = single_set (temp2)) != 0\n-\t      && GET_CODE (temp1 = SET_DEST (temp4)) == REG\n-\t      && (! SMALL_REGISTER_CLASSES\n-\t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n-\t      && (temp3 = prev_active_insn (insn)) != 0\n-\t      && GET_CODE (temp3) == INSN\n-\t      && (temp4 = single_set (temp3)) != 0\n-\t      && rtx_equal_p (SET_DEST (temp4), temp1)\n-\t      && ! side_effects_p (SET_SRC (temp4))\n-\t      && ! may_trap_p (SET_SRC (temp4))\n-\t      && (REG_NOTES (temp3) == 0\n-\t\t  || ((REG_NOTE_KIND (REG_NOTES (temp3)) == REG_EQUAL\n-\t\t       || REG_NOTE_KIND (REG_NOTES (temp3)) == REG_EQUIV)\n-\t\t      && XEXP (REG_NOTES (temp3), 1) == 0\n-\t\t      && rtx_equal_p (XEXP (REG_NOTES (temp3), 0),\n-\t\t\t\t      SET_SRC (temp4))))\n-\t      && (temp = prev_active_insn (temp3)) != 0\n-\t      && condjump_p (temp) && ! simplejump_p (temp)\n-\t      /* TEMP must skip over the \"x = a;\" insn */\n-\t      && prev_real_insn (JUMP_LABEL (temp)) == insn\n-\t      && no_labels_between_p (temp, insn))\n-\t    {\n-\t      rtx prev_label = JUMP_LABEL (temp);\n-\t      rtx insert_after = prev_nonnote_insn (temp);\n-\n-#ifdef HAVE_cc0\n-\t      /* We cannot insert anything between a set of cc and its use.  */\n-\t      if (insert_after && GET_RTX_CLASS (GET_CODE (insert_after)) == 'i'\n-\t\t  && sets_cc0_p (PATTERN (insert_after)))\n-\t\tinsert_after = prev_nonnote_insn (insert_after);\n-#endif\n-\t      ++LABEL_NUSES (prev_label);\n-\n-\t      if (insert_after\n-\t\t  && no_labels_between_p (insert_after, temp)\n-\t\t  && ! reg_referenced_between_p (temp1, insert_after, temp3)\n-\t\t  && ! reg_referenced_between_p (temp1, temp3,\n-\t\t\t\t\t\t NEXT_INSN (temp2))\n-\t\t  && ! reg_set_between_p (temp1, insert_after, temp)\n-\t\t  && ! modified_between_p (SET_SRC (temp4), insert_after, temp)\n-\t\t  /* Verify that registers used by the jump are not clobbered\n-\t\t     by the instruction being moved.  */\n-\t\t  && ! regs_set_between_p (PATTERN (temp),\n-\t\t\t\t\t   PREV_INSN (temp3),\n-\t\t\t\t\t   NEXT_INSN (temp3))\n-\t\t  && invert_jump (temp, JUMP_LABEL (insn)))\n-\t\t{\n-\t\t  emit_insn_after_with_line_notes (PATTERN (temp3),\n-\t\t\t\t\t\t   insert_after, temp3);\n-\t\t  delete_insn (temp3);\n-\t\t  delete_insn (insn);\n-\t\t  /* Set NEXT to an insn that we know won't go away.  */\n-\t\t  next = temp2;\n-\t\t  changed = 1;\n-\t\t}\n-\t      if (prev_label && --LABEL_NUSES (prev_label) == 0)\n-\t\tdelete_insn (prev_label);\n-\t      if (changed)\n-\t\tcontinue;\n-\t    }\n-\n-#if !defined(HAVE_cc0) && !defined(HAVE_conditional_arithmetic)\n-\n-\t  /* If we have if (...) x = exp;  and branches are expensive,\n-\t     EXP is a single insn, does not have any side effects, cannot\n-\t     trap, and is not too costly, convert this to\n-\t     t = exp; if (...) x = t;\n-\n-\t     Don't do this when we have CC0 because it is unlikely to help\n-\t     and we'd need to worry about where to place the new insn and\n-\t     the potential for conflicts.  We also can't do this when we have\n-\t     notes on the insn for the same reason as above.\n-\n-\t     If we have conditional arithmetic, this will make this\n-\t     harder to optimize later and isn't needed, so don't do it\n-\t     in that case either.\n-\n-\t     We set:\n-\n-\t     TEMP to the \"x = exp;\" insn.\n-\t     TEMP1 to the single set in the \"x = exp;\" insn.\n-\t     TEMP2 to \"x\".  */\n-\n-\t  if (! reload_completed\n-\t      && this_is_condjump && ! this_is_simplejump\n-\t      && BRANCH_COST >= 3\n-\t      && (temp = next_nonnote_insn (insn)) != 0\n-\t      && GET_CODE (temp) == INSN\n-\t      && REG_NOTES (temp) == 0\n-\t      && (reallabelprev == temp\n-\t\t  || ((temp2 = next_active_insn (temp)) != 0\n-\t\t      && simplejump_p (temp2)\n-\t\t      && JUMP_LABEL (temp2) == JUMP_LABEL (insn)))\n-\t      && (temp1 = single_set (temp)) != 0\n-\t      && (temp2 = SET_DEST (temp1), GET_CODE (temp2) == REG)\n-\t      && (! SMALL_REGISTER_CLASSES\n-\t\t  || REGNO (temp2) >= FIRST_PSEUDO_REGISTER)\n-\t      && GET_CODE (SET_SRC (temp1)) != REG\n-\t      && GET_CODE (SET_SRC (temp1)) != SUBREG\n-\t      && GET_CODE (SET_SRC (temp1)) != CONST_INT\n-\t      && ! side_effects_p (SET_SRC (temp1))\n-\t      && ! may_trap_p (SET_SRC (temp1))\n-\t      && rtx_cost (SET_SRC (temp1), SET) < 10)\n-\t    {\n-\t      rtx new = gen_reg_rtx (GET_MODE (temp2));\n-\n-\t      if ((temp3 = find_insert_position (insn, temp))\n-\t\t  && validate_change (temp, &SET_DEST (temp1), new, 0))\n-\t\t{\n-\t\t  next = emit_insn_after (gen_move_insn (temp2, new), insn);\n-\t\t  emit_insn_after_with_line_notes (PATTERN (temp), \n-\t\t\t\t\t\t   PREV_INSN (temp3), temp);\n-\t\t  delete_insn (temp);\n-\t\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n-\n-\t\t  if (after_regscan)\n-\t\t    {\n-\t\t      reg_scan_update (temp3, NEXT_INSN (next), old_max_reg);\n-\t\t      old_max_reg = max_reg_num ();\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* Similarly, if it takes two insns to compute EXP but they\n-\t     have the same destination.  Here TEMP3 will be the second\n-\t     insn and TEMP4 the SET from that insn.  */\n-\n-\t  if (! reload_completed\n-\t      && this_is_condjump && ! this_is_simplejump\n-\t      && BRANCH_COST >= 4\n-\t      && (temp = next_nonnote_insn (insn)) != 0\n-\t      && GET_CODE (temp) == INSN\n-\t      && REG_NOTES (temp) == 0\n-\t      && (temp3 = next_nonnote_insn (temp)) != 0\n-\t      && GET_CODE (temp3) == INSN\n-\t      && REG_NOTES (temp3) == 0\n-\t      && (reallabelprev == temp3\n-\t\t  || ((temp2 = next_active_insn (temp3)) != 0\n-\t\t      && simplejump_p (temp2)\n-\t\t      && JUMP_LABEL (temp2) == JUMP_LABEL (insn)))\n-\t      && (temp1 = single_set (temp)) != 0\n-\t      && (temp2 = SET_DEST (temp1), GET_CODE (temp2) == REG)\n-\t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n-\t      && (! SMALL_REGISTER_CLASSES\n-\t\t  || REGNO (temp2) >= FIRST_PSEUDO_REGISTER)\n-\t      && ! side_effects_p (SET_SRC (temp1))\n-\t      && ! may_trap_p (SET_SRC (temp1))\n-\t      && rtx_cost (SET_SRC (temp1), SET) < 10\n-\t      && (temp4 = single_set (temp3)) != 0\n-\t      && rtx_equal_p (SET_DEST (temp4), temp2)\n-\t      && ! side_effects_p (SET_SRC (temp4))\n-\t      && ! may_trap_p (SET_SRC (temp4))\n-\t      && rtx_cost (SET_SRC (temp4), SET) < 10)\n-\t    {\n-\t      rtx new = gen_reg_rtx (GET_MODE (temp2));\n-\n-\t      if ((temp5 = find_insert_position (insn, temp))\n-\t\t  && (temp6 = find_insert_position (insn, temp3))\n-\t\t  && validate_change (temp, &SET_DEST (temp1), new, 0))\n-\t\t{\n-\t\t  /* Use the earliest of temp5 and temp6. */\n-\t\t  if (temp5 != insn)\n-\t\t    temp6 = temp5;\n-\t\t  next = emit_insn_after (gen_move_insn (temp2, new), insn);\n-\t\t  emit_insn_after_with_line_notes (PATTERN (temp),\n-\t\t\t\t\t\t   PREV_INSN (temp6), temp);\n-\t\t  emit_insn_after_with_line_notes\n-\t\t    (replace_rtx (PATTERN (temp3), temp2, new),\n-\t\t     PREV_INSN (temp6), temp3);\n-\t\t  delete_insn (temp);\n-\t\t  delete_insn (temp3);\n-\t\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n-\n-\t\t  if (after_regscan)\n-\t\t    {\n-\t\t      reg_scan_update (temp6, NEXT_INSN (next), old_max_reg);\n-\t\t      old_max_reg = max_reg_num ();\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* Finally, handle the case where two insns are used to \n-\t     compute EXP but a temporary register is used.  Here we must\n-\t     ensure that the temporary register is not used anywhere else.  */\n-\n-\t  if (! reload_completed\n-\t      && after_regscan\n-\t      && this_is_condjump && ! this_is_simplejump\n-\t      && BRANCH_COST >= 4\n-\t      && (temp = next_nonnote_insn (insn)) != 0\n-\t      && GET_CODE (temp) == INSN\n-\t      && REG_NOTES (temp) == 0\n-\t      && (temp3 = next_nonnote_insn (temp)) != 0\n-\t      && GET_CODE (temp3) == INSN\n-\t      && REG_NOTES (temp3) == 0\n-\t      && (reallabelprev == temp3\n-\t\t  || ((temp2 = next_active_insn (temp3)) != 0\n-\t\t      && simplejump_p (temp2)\n-\t\t      && JUMP_LABEL (temp2) == JUMP_LABEL (insn)))\n-\t      && (temp1 = single_set (temp)) != 0\n-\t      && (temp5 = SET_DEST (temp1),\n-\t\t  (GET_CODE (temp5) == REG\n-\t\t   || (GET_CODE (temp5) == SUBREG\n-\t\t       && (temp5 = SUBREG_REG (temp5),\n-\t\t\t   GET_CODE (temp5) == REG))))\n-\t      && REGNO (temp5) >= FIRST_PSEUDO_REGISTER\n-\t      && REGNO_FIRST_UID (REGNO (temp5)) == INSN_UID (temp)\n-\t      && REGNO_LAST_UID (REGNO (temp5)) == INSN_UID (temp3)\n-\t      && ! side_effects_p (SET_SRC (temp1))\n-\t      && ! may_trap_p (SET_SRC (temp1))\n-\t      && rtx_cost (SET_SRC (temp1), SET) < 10\n-\t      && (temp4 = single_set (temp3)) != 0\n-\t      && (temp2 = SET_DEST (temp4), GET_CODE (temp2) == REG)\n-\t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n-\t      && (! SMALL_REGISTER_CLASSES\n-\t\t  || REGNO (temp2) >= FIRST_PSEUDO_REGISTER)\n-\t      && rtx_equal_p (SET_DEST (temp4), temp2)\n-\t      && ! side_effects_p (SET_SRC (temp4))\n-\t      && ! may_trap_p (SET_SRC (temp4))\n-\t      && rtx_cost (SET_SRC (temp4), SET) < 10)\n-\t    {\n-\t      rtx new = gen_reg_rtx (GET_MODE (temp2));\n-\n-\t      if ((temp5 = find_insert_position (insn, temp))\n-\t\t  && (temp6 = find_insert_position (insn, temp3))\n-\t\t  && validate_change (temp3, &SET_DEST (temp4), new, 0))\n-\t\t{\n-\t\t  /* Use the earliest of temp5 and temp6. */\n-\t\t  if (temp5 != insn)\n-\t\t    temp6 = temp5;\n-\t\t  next = emit_insn_after (gen_move_insn (temp2, new), insn);\n-\t\t  emit_insn_after_with_line_notes (PATTERN (temp),\n-\t\t\t\t\t\t   PREV_INSN (temp6), temp);\n-\t\t  emit_insn_after_with_line_notes (PATTERN (temp3),\n-\t\t\t\t\t\t   PREV_INSN (temp6), temp3);\n-\t\t  delete_insn (temp);\n-\t\t  delete_insn (temp3);\n-\t\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n-\n-\t\t  if (after_regscan)\n-\t\t    {\n-\t\t      reg_scan_update (temp6, NEXT_INSN (next), old_max_reg);\n-\t\t      old_max_reg = max_reg_num ();\n-\t\t    }\n-\t\t}\n-\t    }\n-#endif /* HAVE_cc0 */\n-\n-#ifdef HAVE_conditional_arithmetic\n-\t  /* ??? This is disabled in genconfig, as this simple-minded\n-\t     transformation can incredibly lengthen register lifetimes.\n-\n-\t     Consider this example:\n-\n-\t\t234 (set (pc)\n-\t\t      (if_then_else (ne (reg:DI 149) (const_int 0 [0x0]))\n-\t\t        (label_ref 248) (pc)))\n-\t\t237 (set (reg/i:DI 0 $0) (const_int 1 [0x1]))\n-\t\t239 (set (pc) (label_ref 2382))\n-\t\t248 (code_label (\"yybackup\"))\n-\n-\t     This will be transformed to:\n-\n-\t\t237 (set (reg/i:DI 0 $0)\n-\t\t      (if_then_else:DI (eq (reg:DI 149) (const_int 0 [0x0]))\n-\t\t        (const_int 1 [0x1]) (reg/i:DI 0 $0)))\n-\t\t239 (set (pc)\n-\t\t      (if_then_else (eq (reg:DI 149) (const_int 0 [0x0]))\n-\t\t        (label_ref 2382) (pc)))\n-\n-\t     which, from this narrow viewpoint looks fine.  Except that\n-\t     between this and 3 other ocurrences of the same pattern, $0\n-\t     is now live for basically the entire function, and we'll \n-\t     get an abort in caller_save.\n-\n-\t     Any replacement for this code should recall that a set of\n-\t     a register that is not live need not, and indeed should not,\n-\t     be conditionalized.  Either that, or delay the transformation\n-\t     until after register allocation.  */\n-\n-\t  /* See if this is a conditional jump around a small number of\n-\t     instructions that we can conditionalize.  Don't do this before\n-\t     the initial CSE pass or after reload.\n-\n-\t     We reject any insns that have side effects or may trap.\n-\t     Strictly speaking, this is not needed since the machine may\n-\t     support conditionalizing these too, but we won't deal with that\n-\t     now.  Specifically, this means that we can't conditionalize a \n-\t     CALL_INSN, which some machines, such as the ARC, can do, but\n-\t     this is a very minor optimization.  */\n-\t  if (this_is_condjump && ! this_is_simplejump\n-\t      && cse_not_expected && ! reload_completed\n-\t      && BRANCH_COST > 2\n-\t      && can_reverse_comparison_p (XEXP (SET_SRC (PATTERN (insn)), 0),\n-\t\t\t\t\t   insn))\n-\t    {\n-\t      rtx ourcond = XEXP (SET_SRC (PATTERN (insn)), 0);\n-\t      int num_insns = 0;\n-\t      char *storage = (char *) oballoc (0);\n-\t      int last_insn = 0, failed = 0;\n-\t      rtx changed_jump = 0;\n-\n-\t      ourcond = gen_rtx (reverse_condition (GET_CODE (ourcond)),\n-\t\t\t\t VOIDmode, XEXP (ourcond, 0),\n-\t\t\t\t XEXP (ourcond, 1));\n-\n-\t      /* Scan forward BRANCH_COST real insns looking for the JUMP_LABEL\n-\t\t of this insn.  We see if we think we can conditionalize the\n-\t\t insns we pass.  For now, we only deal with insns that have\n-\t\t one SET.  We stop after an insn that modifies anything in\n-\t\t OURCOND, if we have too many insns, or if we have an insn\n-\t\t with a side effect or that may trip.  Note that we will\n-\t\t be modifying any unconditional jumps we encounter to be\n-\t\t conditional; this will have the effect of also doing this\n-\t\t optimization on the \"else\" the next time around.  */\n-\t      for (temp1 = NEXT_INSN (insn);\n-\t\t   num_insns <= BRANCH_COST && ! failed && temp1 != 0\n-\t\t   && GET_CODE (temp1) != CODE_LABEL;\n-\t\t   temp1 = NEXT_INSN (temp1))\n-\t\t{\n-\t\t  /* Ignore everything but an active insn.  */\n-\t\t  if (GET_RTX_CLASS (GET_CODE (temp1)) != 'i'\n-\t\t      || GET_CODE (PATTERN (temp1)) == USE\n-\t\t      || GET_CODE (PATTERN (temp1)) == CLOBBER)\n-\t\t    continue;\n-\n-\t\t  /* If this was an unconditional jump, record it since we'll\n-\t\t     need to remove the BARRIER if we succeed.  We can only\n-\t\t     have one such jump since there must be a label after\n-\t\t     the BARRIER and it's either ours, in which case it's the\n-\t\t     only one or some other, in which case we'd fail.\n-\t\t     Likewise if it's a CALL_INSN followed by a BARRIER.  */\n-\n-\t\t  if (simplejump_p (temp1)\n-\t\t      || (GET_CODE (temp1) == CALL_INSN\n-\t\t\t  && NEXT_INSN (temp1) != 0\n-\t\t\t  && GET_CODE (NEXT_INSN (temp1)) == BARRIER))\n-\t\t    {\n-\t\t      if (changed_jump == 0)\n-\t\t\tchanged_jump = temp1;\n-\t\t      else\n-\t\t\tchanged_jump\n-\t\t\t  = gen_rtx_INSN_LIST (VOIDmode, temp1, changed_jump);\n-\t\t    }\n-\n-\t\t  /* See if we are allowed another insn and if this insn\n-\t\t     if one we think we may be able to handle.  */\n-\t\t  if (++num_insns > BRANCH_COST\n-\t\t      || last_insn\n-\t\t      || (((temp2 = single_set (temp1)) == 0\n-\t\t\t   || side_effects_p (SET_SRC (temp2))\n-\t\t\t   || may_trap_p (SET_SRC (temp2)))\n-\t\t\t  && GET_CODE (temp1) != CALL_INSN))\n-\t\t      failed = 1;\n-\t\t  else if (temp2 != 0)\n-\t\t    validate_change (temp1, &SET_SRC (temp2),\n-\t\t\t\t     gen_rtx_IF_THEN_ELSE\n-\t\t\t\t     (GET_MODE (SET_DEST (temp2)),\n-\t\t\t\t      copy_rtx (ourcond),\n-\t\t\t\t      SET_SRC (temp2), SET_DEST (temp2)),\n-\t\t\t\t     1);\n-\t\t  else\n-\t\t    {\n-\t\t      /* This is a CALL_INSN that doesn't have a SET.  */\n-\t\t      rtx *call_loc = &PATTERN (temp1);\n-\n-\t\t      if (GET_CODE (*call_loc) == PARALLEL)\n-\t\t\tcall_loc = &XVECEXP (*call_loc, 0, 0);\n-\n-\t\t      validate_change (temp1, call_loc,\n-\t\t\t\t       gen_rtx_IF_THEN_ELSE\n-\t\t\t\t       (VOIDmode, copy_rtx (ourcond),\n-\t\t\t\t\t*call_loc, const0_rtx),\n-\t\t\t\t       1);\n-\t\t    }\n-\n-\n-\t\t  if (modified_in_p (ourcond, temp1))\n-\t\t    last_insn = 1;\n-\t\t}\n-\n-\t      /* If we've reached our jump label, haven't failed, and all\n-\t\t the changes above are valid, we can delete this jump\n-\t\t insn.  Also remove a BARRIER after any jump that used\n-\t\t to be unconditional and remove any REG_EQUAL or REG_EQUIV\n-\t\t that might have previously been present on insns we\n-\t\t made conditional.  */\n-\t      if (temp1 == JUMP_LABEL (insn) && ! failed\n-\t\t  && apply_change_group ())\n-\t\t{\n-\t\t  for (temp1 = NEXT_INSN (insn); temp1 != JUMP_LABEL (insn);\n-\t\t       temp1 = NEXT_INSN (temp1))\n-\t\t    if (GET_RTX_CLASS (GET_CODE (temp1)) == 'i')\n-\t\t      for (temp2 = REG_NOTES (temp1); temp2 != 0;\n-\t\t\t   temp2 = XEXP (temp2, 1))\n-\t\t\tif (REG_NOTE_KIND (temp2) == REG_EQUAL\n-\t\t\t    || REG_NOTE_KIND (temp2) == REG_EQUIV)\n-\t\t\t  remove_note (temp1, temp2);\n-\n-\t\t  if (changed_jump != 0)\n-\t\t    {\n-\t\t      while (GET_CODE (changed_jump) == INSN_LIST)\n-\t\t\t{\n-\t\t\t  delete_barrier (NEXT_INSN (XEXP (changed_jump, 0)));\n-\t\t\t  changed_jump = XEXP (changed_jump, 1);\n-\t\t\t}\n-\n-\t\t      delete_barrier (NEXT_INSN (changed_jump));\n-\t\t    }\n-\n-\t\t  delete_insn (insn);\n-\t\t  changed = 1;\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  cancel_changes (0);\n-\t\t  obfree (storage);\n-\t\t}\n-\t    }\n-#endif\n-\t  /* If branches are expensive, convert\n-\t        if (foo) bar++;    to    bar += (foo != 0);\n-\t     and similarly for \"bar--;\" \n-\n-\t     INSN is the conditional branch around the arithmetic.  We set:\n-\n-\t     TEMP is the arithmetic insn.\n-\t     TEMP1 is the SET doing the arithmetic.\n-\t     TEMP2 is the operand being incremented or decremented.\n-\t     TEMP3 to the condition being tested.\n-\t     TEMP4 to the earliest insn used to find the condition.  */\n-\n-\t  if ((BRANCH_COST >= 2\n-#ifdef HAVE_incscc\n-\t       || HAVE_incscc\n-#endif\n-#ifdef HAVE_decscc\n-\t       || HAVE_decscc\n-#endif\n-\t      )\n-\t      && ! reload_completed\n-\t      && this_is_condjump && ! this_is_simplejump\n-\t      && (temp = next_nonnote_insn (insn)) != 0\n-\t      && (temp1 = single_set (temp)) != 0\n-\t      && (temp2 = SET_DEST (temp1),\n-\t\t  GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT)\n-\t      && GET_CODE (SET_SRC (temp1)) == PLUS\n-\t      && (XEXP (SET_SRC (temp1), 1) == const1_rtx\n-\t\t  || XEXP (SET_SRC (temp1), 1) == constm1_rtx)\n-\t      && rtx_equal_p (temp2, XEXP (SET_SRC (temp1), 0))\n-\t      && ! side_effects_p (temp2)\n-\t      && ! may_trap_p (temp2)\n-\t      /* INSN must either branch to the insn after TEMP or the insn\n-\t\t after TEMP must branch to the same place as INSN.  */\n-\t      && (reallabelprev == temp\n-\t\t  || ((temp3 = next_active_insn (temp)) != 0\n-\t\t      && simplejump_p (temp3)\n-\t\t      && JUMP_LABEL (temp3) == JUMP_LABEL (insn)))\n-\t      && (temp3 = get_condition (insn, &temp4)) != 0\n-\t      /* We must be comparing objects whose modes imply the size.\n-\t\t We could handle BLKmode if (1) emit_store_flag could\n-\t\t and (2) we could find the size reliably.  */\n-\t      && GET_MODE (XEXP (temp3, 0)) != BLKmode\n-\t      && can_reverse_comparison_p (temp3, insn))\n-\t    {\n-\t      rtx temp6, target = 0, seq, init_insn = 0, init = temp2;\n-\t      enum rtx_code code = reverse_condition (GET_CODE (temp3));\n-\n-\t      start_sequence ();\n-\n-\t      /* It must be the case that TEMP2 is not modified in the range\n-\t\t [TEMP4, INSN).  The one exception we make is if the insn\n-\t\t before INSN sets TEMP2 to something which is also unchanged\n-\t\t in that range.  In that case, we can move the initialization\n-\t\t into our sequence.  */\n-\n-\t      if ((temp5 = prev_active_insn (insn)) != 0\n-\t\t  && no_labels_between_p (temp5, insn)\n-\t\t  && GET_CODE (temp5) == INSN\n-\t\t  && (temp6 = single_set (temp5)) != 0\n-\t\t  && rtx_equal_p (temp2, SET_DEST (temp6))\n-\t\t  && (CONSTANT_P (SET_SRC (temp6))\n-\t\t      || GET_CODE (SET_SRC (temp6)) == REG\n-\t\t      || GET_CODE (SET_SRC (temp6)) == SUBREG))\n-\t\t{\n-\t\t  emit_insn (PATTERN (temp5));\n-\t\t  init_insn = temp5;\n-\t\t  init = SET_SRC (temp6);\n-\t\t}\n-\n-\t      if (CONSTANT_P (init)\n-\t\t  || ! reg_set_between_p (init, PREV_INSN (temp4), insn))\n-\t\ttarget = emit_store_flag (gen_reg_rtx (GET_MODE (temp2)), code,\n-\t\t\t\t\t  XEXP (temp3, 0), XEXP (temp3, 1),\n-\t\t\t\t\t  VOIDmode,\n-\t\t\t\t\t  (code == LTU || code == LEU\n-\t\t\t\t\t   || code == GTU || code == GEU), 1);\n-\n-\t      /* If we can do the store-flag, do the addition or\n-\t\t subtraction.  */\n-\n-\t      if (target)\n-\t\ttarget = expand_binop (GET_MODE (temp2),\n-\t\t\t\t       (XEXP (SET_SRC (temp1), 1) == const1_rtx\n-\t\t\t\t\t? add_optab : sub_optab),\n-\t\t\t\t       temp2, target, temp2, 0, OPTAB_WIDEN);\n-\n-\t      if (target != 0)\n-\t\t{\n-\t\t  /* Put the result back in temp2 in case it isn't already.\n-\t\t     Then replace the jump, possible a CC0-setting insn in\n-\t\t     front of the jump, and TEMP, with the sequence we have\n-\t\t     made.  */\n-\n-\t\t  if (target != temp2)\n-\t\t    emit_move_insn (temp2, target);\n-\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\n-\t\t  emit_insns_before (seq, temp4);\n-\t\t  delete_insn (temp);\n-\n-\t\t  if (init_insn)\n-\t\t    delete_insn (init_insn);\n-\n-\t\t  next = NEXT_INSN (insn);\n-#ifdef HAVE_cc0\n-\t\t  delete_insn (prev_nonnote_insn (insn));\n-#endif\n-\t\t  delete_insn (insn);\n-\n-\t\t  if (after_regscan)\n-\t\t    {\n-\t\t      reg_scan_update (seq, NEXT_INSN (next), old_max_reg);\n-\t\t      old_max_reg = max_reg_num ();\n-\t\t    }\n-\n-\t\t  changed = 1;\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\tend_sequence ();\n-\t    }\n-\n-\t  /* Try to use a conditional move (if the target has them), or a\n-\t     store-flag insn.  If the target has conditional arithmetic as\n-\t     well as conditional move, the above code will have done something.\n-\t     Note that we prefer the above code since it is more general: the\n-\t     code below can make changes that require work to undo.\n-\n-\t     The general case here is:\n-\n-\t     1) x = a; if (...) x = b; and\n-\t     2) if (...) x = b;\n-\n-\t     If the jump would be faster, the machine should not have defined\n-\t     the movcc or scc insns!.  These cases are often made by the\n-\t     previous optimization.\n-\n-\t     The second case is treated as  x = x; if (...) x = b;.\n-\n-\t     INSN here is the jump around the store.  We set:\n-\n-\t     TEMP to the \"x op= b;\" insn.\n-\t     TEMP1 to X.\n-\t     TEMP2 to B.\n-\t     TEMP3 to A (X in the second case).\n-\t     TEMP4 to the condition being tested.\n-\t     TEMP5 to the earliest insn used to find the condition.\n-\t     TEMP6 to the SET of TEMP.  */\n-\n-\t  if (/* We can't do this after reload has completed.  */\n-\t      ! reload_completed\n-#ifdef HAVE_conditional_arithmetic\n-\t      /* Defer this until after CSE so the above code gets the\n-\t\t first crack at it.  */\n-\t      && cse_not_expected\n-#endif\n-\t      && this_is_condjump && ! this_is_simplejump\n-\t      /* Set TEMP to the \"x = b;\" insn.  */\n-\t      && (temp = next_nonnote_insn (insn)) != 0\n-\t      && GET_CODE (temp) == INSN\n-\t      && (temp6 = single_set (temp)) != NULL_RTX\n-\t      && GET_CODE (temp1 = SET_DEST (temp6)) == REG\n-\t      && (! SMALL_REGISTER_CLASSES\n-\t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n-\t      && ! side_effects_p (temp2 = SET_SRC (temp6))\n-\t      && ! may_trap_p (temp2)\n-\t      /* Allow either form, but prefer the former if both apply. \n-\t\t There is no point in using the old value of TEMP1 if\n-\t\t it is a register, since cse will alias them.  It can\n-\t\t lose if the old value were a hard register since CSE\n-\t\t won't replace hard registers.  Avoid using TEMP3 if\n-\t\t small register classes and it is a hard register.  */\n-\t      && (((temp3 = reg_set_last (temp1, insn)) != 0\n-\t\t   && ! (SMALL_REGISTER_CLASSES && GET_CODE (temp3) == REG\n-\t\t\t && REGNO (temp3) < FIRST_PSEUDO_REGISTER))\n-\t\t  /* Make the latter case look like  x = x; if (...) x = b;  */\n-\t\t  || (temp3 = temp1, 1))\n-\t      /* INSN must either branch to the insn after TEMP or the insn\n-\t\t after TEMP must branch to the same place as INSN.  */\n-\t      && (reallabelprev == temp\n-\t\t  || ((temp4 = next_active_insn (temp)) != 0\n-\t\t      && simplejump_p (temp4)\n-\t\t      && JUMP_LABEL (temp4) == JUMP_LABEL (insn)))\n-\t      && (temp4 = get_condition (insn, &temp5)) != 0\n-\t      /* We must be comparing objects whose modes imply the size.\n-\t\t We could handle BLKmode if (1) emit_store_flag could\n-\t\t and (2) we could find the size reliably.  */\n-\t      && GET_MODE (XEXP (temp4, 0)) != BLKmode\n-\t      /* Even if branches are cheap, the store_flag optimization\n-\t\t can win when the operation to be performed can be\n-\t\t expressed directly.  */\n-#ifdef HAVE_cc0\n-\t      /* If the previous insn sets CC0 and something else, we can't\n-\t\t do this since we are going to delete that insn.  */\n-\n-\t      && ! ((temp6 = prev_nonnote_insn (insn)) != 0\n-\t\t    && GET_CODE (temp6) == INSN\n-\t\t    && (sets_cc0_p (PATTERN (temp6)) == -1\n-\t\t\t|| (sets_cc0_p (PATTERN (temp6)) == 1\n-\t\t\t    && FIND_REG_INC_NOTE (temp6, NULL_RTX))))\n-#endif\n-\t      )\n-\t    {\n-#ifdef HAVE_conditional_move\n-\t      /* First try a conditional move.  */\n-\t      {\n-\t\tenum rtx_code code = GET_CODE (temp4);\n-\t\trtx var = temp1;\n-\t\trtx cond0, cond1, aval, bval;\n-\t\trtx target, new_insn;\n-\n-\t\t/* Copy the compared variables into cond0 and cond1, so that\n-\t\t   any side effects performed in or after the old comparison,\n-\t\t   will not affect our compare which will come later.  */\n-\t\t/* ??? Is it possible to just use the comparison in the jump\n-\t\t   insn?  After all, we're going to delete it.  We'd have\n-\t\t   to modify emit_conditional_move to take a comparison rtx\n-\t\t   instead or write a new function.  */\n-\n-\t\t/* We want the target to be able to simplify comparisons with\n-\t\t   zero (and maybe other constants as well), so don't create\n-\t\t   pseudos for them.  There's no need to either.  */\n-\t\tif (GET_CODE (XEXP (temp4, 0)) == CONST_INT\n-\t\t    || GET_CODE (XEXP (temp4, 0)) == CONST_DOUBLE)\n-\t\t  cond0 = XEXP (temp4, 0);\n-\t\telse\n-\t\t  cond0 = gen_reg_rtx (GET_MODE (XEXP (temp4, 0)));\n-\n-\t\tif (GET_CODE (XEXP (temp4, 1)) == CONST_INT\n-\t\t    || GET_CODE (XEXP (temp4, 1)) == CONST_DOUBLE)\n-\t\t  cond1 = XEXP (temp4, 1);\n-\t\telse\n-\t\t  cond1 = gen_reg_rtx (GET_MODE (XEXP (temp4, 1)));\n-\n-\t\t/* Careful about copying these values -- an IOR or what may\n-\t\t   need to do other things, like clobber flags.  */\n-\t\t/* ??? Assume for the moment that AVAL is ok.  */\n-\t\taval = temp3;\n-\n-\t\tstart_sequence ();\n-\n-\t\t/* We're dealing with a single_set insn with no side effects\n-\t\t   on SET_SRC.  We do need to be reasonably certain that if\n-\t\t   we need to force BVAL into a register that we won't \n-\t\t   clobber the flags -- general_operand should suffice.  */\n-\t\tif (general_operand (temp2, GET_MODE (var)))\n-\t\t  bval = temp2;\n-\t\telse\n-\t\t  {\n-\t\t    bval = gen_reg_rtx (GET_MODE (var));\n-\t\t    new_insn = copy_rtx (temp);\n-\t\t    temp6 = single_set (new_insn);\n-\t\t    SET_DEST (temp6) = bval;\n-\t\t    emit_insn (PATTERN (new_insn));\n-\t\t  }\n-\n-\t\ttarget = emit_conditional_move (var, code,\n-\t\t\t\t\t\tcond0, cond1, VOIDmode,\n-\t\t\t\t\t\taval, bval, GET_MODE (var),\n-\t\t\t\t\t\t(code == LTU || code == GEU\n-\t\t\t\t\t\t || code == LEU || code == GTU));\n-\n-\t\tif (target)\n-\t\t  {\n-\t\t    rtx seq1, seq2, last;\n-\t\t    int copy_ok;\n-\n-\t\t    /* Save the conditional move sequence but don't emit it\n-\t\t       yet.  On some machines, like the alpha, it is possible\n-\t\t       that temp5 == insn, so next generate the sequence that\n-\t\t       saves the compared values and then emit both\n-\t\t       sequences ensuring seq1 occurs before seq2.  */\n-\t\t    seq2 = get_insns ();\n-\t\t    end_sequence ();\n-\n-\t\t    /* \"Now that we can't fail...\"  Famous last words.\n-\t\t       Generate the copy insns that preserve the compared\n-\t\t       values.  */\n-\t\t    start_sequence ();\n-\t\t    emit_move_insn (cond0, XEXP (temp4, 0));\n-\t\t    if (cond1 != XEXP (temp4, 1))\n-\t\t      emit_move_insn (cond1, XEXP (temp4, 1));\n-\t\t    seq1 = get_insns ();\n-\t\t    end_sequence ();\n-\n-\t\t    /* Validate the sequence -- this may be some weird\n-\t\t       bit-extract-and-test instruction for which there\n-\t\t       exists no complimentary bit-extract insn.  */\n-\t\t    copy_ok = 1;\n-\t\t    for (last = seq1; last ; last = NEXT_INSN (last))\n-\t\t      if (recog_memoized (last) < 0)\n-\t\t\t{\n-\t\t\t  copy_ok = 0;\n-\t\t\t  break;\n-\t\t\t}\n-\n-\t\t    if (copy_ok)\n-\t\t      {\n-\t\t        emit_insns_before (seq1, temp5);\n-\n-\t\t        /* Insert conditional move after insn, to be sure\n-\t\t\t   that the jump and a possible compare won't be\n-\t\t\t   separated.  */\n-\t\t        last = emit_insns_after (seq2, insn);\n-\n-\t\t        /* ??? We can also delete the insn that sets X to A.\n-\t\t           Flow will do it too though.  */\n-\t\t        delete_insn (temp);\n-\t\t        next = NEXT_INSN (insn);\n-\t\t        delete_jump (insn);\n-\n-\t\t        if (after_regscan)\n-\t\t          {\n-\t\t\t    reg_scan_update (seq1, NEXT_INSN (last),\n-\t\t\t\t\t     old_max_reg);\n-\t\t\t    old_max_reg = max_reg_num ();\n-\t\t          }\n-\n-\t\t        changed = 1;\n-\t\t        continue;\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  end_sequence ();\n-\t      }\n-#endif\n-\n-\t      /* That didn't work, try a store-flag insn.\n-\n-\t\t We further divide the cases into:\n-\n-\t\t 1) x = a; if (...) x = b; and either A or B is zero,\n-\t\t 2) if (...) x = 0; and jumps are expensive,\n-\t\t 3) x = a; if (...) x = b; and A and B are constants where all\n-\t\t the set bits in A are also set in B and jumps are expensive,\n-\t\t 4) x = a; if (...) x = b; and A and B non-zero, and jumps are\n-\t\t more expensive, and\n-\t\t 5) if (...) x = b; if jumps are even more expensive.  */\n-\n-\t      if (GET_MODE_CLASS (GET_MODE (temp1)) == MODE_INT\n-\t\t  /* We will be passing this as operand into expand_and.  No\n-\t\t     good if it's not valid as an operand.  */\n-\t\t  && general_operand (temp2, GET_MODE (temp2))\n-\t\t  && ((GET_CODE (temp3) == CONST_INT)\n-\t\t      /* Make the latter case look like\n-\t\t\t x = x; if (...) x = 0;  */\n-\t\t      || (temp3 = temp1,\n-\t\t\t  ((BRANCH_COST >= 2\n-\t\t\t    && temp2 == const0_rtx)\n-\t\t\t   || BRANCH_COST >= 3)))\n-\t\t  /* If B is zero, OK; if A is zero, can only do (1) if we\n-\t\t     can reverse the condition.  See if (3) applies possibly\n-\t\t     by reversing the condition.  Prefer reversing to (4) when\n-\t\t     branches are very expensive.  */\n-\t\t  && (((BRANCH_COST >= 2\n-\t\t\t|| STORE_FLAG_VALUE == -1\n-\t\t\t|| (STORE_FLAG_VALUE == 1\n-\t\t\t /* Check that the mask is a power of two,\n-\t\t\t    so that it can probably be generated\n-\t\t\t    with a shift.  */\n-\t\t\t    && GET_CODE (temp3) == CONST_INT\n-\t\t\t    && exact_log2 (INTVAL (temp3)) >= 0))\n-\t\t       && (reversep = 0, temp2 == const0_rtx))\n-\t\t      || ((BRANCH_COST >= 2\n-\t\t\t   || STORE_FLAG_VALUE == -1\n-\t\t\t   || (STORE_FLAG_VALUE == 1\n-\t\t\t       && GET_CODE (temp2) == CONST_INT\n-\t\t\t       && exact_log2 (INTVAL (temp2)) >= 0))\n-\t\t\t  && temp3 == const0_rtx\n-\t\t\t  && (reversep = can_reverse_comparison_p (temp4, insn)))\n-\t\t      || (BRANCH_COST >= 2\n-\t\t\t  && GET_CODE (temp2) == CONST_INT\n-\t\t\t  && GET_CODE (temp3) == CONST_INT\n-\t\t\t  && ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp2)\n-\t\t\t      || ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp3)\n-\t\t\t\t  && (reversep = can_reverse_comparison_p (temp4,\n-\t\t\t\t\t\t\t\t\t   insn)))))\n-\t\t      || BRANCH_COST >= 3)\n-\t\t  )\n-\t\t{\n-\t\t  enum rtx_code code = GET_CODE (temp4);\n-\t\t  rtx uval, cval, var = temp1;\n-\t\t  int normalizep;\n-\t\t  rtx target;\n-\n-\t\t  /* If necessary, reverse the condition.  */\n-\t\t  if (reversep)\n-\t\t    code = reverse_condition (code), uval = temp2, cval = temp3;\n-\t\t  else\n-\t\t    uval = temp3, cval = temp2;\n-\n-\t\t  /* If CVAL is non-zero, normalize to -1.  Otherwise, if UVAL\n-\t\t     is the constant 1, it is best to just compute the result\n-\t\t     directly.  If UVAL is constant and STORE_FLAG_VALUE\n-\t\t     includes all of its bits, it is best to compute the flag\n-\t\t     value unnormalized and `and' it with UVAL.  Otherwise,\n-\t\t     normalize to -1 and `and' with UVAL.  */\n-\t\t  normalizep = (cval != const0_rtx ? -1\n-\t\t\t\t: (uval == const1_rtx ? 1\n-\t\t\t\t   : (GET_CODE (uval) == CONST_INT\n-\t\t\t\t      && (INTVAL (uval) & ~STORE_FLAG_VALUE) == 0)\n-\t\t\t\t   ? 0 : -1));\n-\n-\t\t  /* We will be putting the store-flag insn immediately in\n-\t\t     front of the comparison that was originally being done,\n-\t\t     so we know all the variables in TEMP4 will be valid.\n-\t\t     However, this might be in front of the assignment of\n-\t\t     A to VAR.  If it is, it would clobber the store-flag\n-\t\t     we will be emitting.\n-\n-\t\t     Therefore, emit into a temporary which will be copied to\n-\t\t     VAR immediately after TEMP.  */\n-\n-\t\t  start_sequence ();\n-\t\t  target = emit_store_flag (gen_reg_rtx (GET_MODE (var)), code,\n-\t\t\t\t\t    XEXP (temp4, 0), XEXP (temp4, 1),\n-\t\t\t\t\t    VOIDmode,\n-\t\t\t\t\t    (code == LTU || code == LEU \n-\t\t\t\t\t     || code == GEU || code == GTU),\n-\t\t\t\t\t    normalizep);\n-\t\t  if (target)\n-\t\t    {\n-\t\t      rtx seq;\n-\t\t      rtx before = insn;\n-\n-\t\t      seq = get_insns ();\n-\t\t      end_sequence ();\n-\n-\t\t      /* Put the store-flag insns in front of the first insn\n-\t\t\t used to compute the condition to ensure that we\n-\t\t\t use the same values of them as the current \n-\t\t\t comparison.  However, the remainder of the insns we\n-\t\t\t generate will be placed directly in front of the\n-\t\t\t jump insn, in case any of the pseudos we use\n-\t\t\t are modified earlier.  */\n-\n-\t\t      emit_insns_before (seq, temp5);\n-\n-\t\t      start_sequence ();\n-\n-\t\t      /* Both CVAL and UVAL are non-zero.  */\n-\t\t      if (cval != const0_rtx && uval != const0_rtx)\n-\t\t\t{\n-\t\t\t  rtx tem1, tem2;\n-\n-\t\t\t  tem1 = expand_and (uval, target, NULL_RTX);\n-\t\t\t  if (GET_CODE (cval) == CONST_INT\n-\t\t\t      && GET_CODE (uval) == CONST_INT\n-\t\t\t      && (INTVAL (cval) & INTVAL (uval)) == INTVAL (cval))\n-\t\t\t    tem2 = cval;\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      tem2 = expand_unop (GET_MODE (var), one_cmpl_optab,\n-\t\t\t\t\t\t  target, NULL_RTX, 0);\n-\t\t\t      tem2 = expand_and (cval, tem2,\n-\t\t\t\t\t\t (GET_CODE (tem2) == REG\n-\t\t\t\t\t\t  ? tem2 : 0));\n-\t\t\t    }\n-\n-\t\t\t  /* If we usually make new pseudos, do so here.  This\n-\t\t\t     turns out to help machines that have conditional\n-\t\t\t     move insns.  */\n-\t\t\t  /* ??? Conditional moves have already been handled.\n-\t\t\t     This may be obsolete.  */\n-\n-\t\t\t  if (flag_expensive_optimizations)\n-\t\t\t    target = 0;\n-\n-\t\t\t  target = expand_binop (GET_MODE (var), ior_optab,\n-\t\t\t\t\t\t tem1, tem2, target,\n-\t\t\t\t\t\t 1, OPTAB_WIDEN);\n-\t\t\t}\n-\t\t      else if (normalizep != 1)\n-\t\t\t{\n-\t\t\t  /* We know that either CVAL or UVAL is zero.  If\n-\t\t\t     UVAL is zero, negate TARGET and `and' with CVAL.\n-\t\t\t     Otherwise, `and' with UVAL.  */\n-\t\t\t  if (uval == const0_rtx)\n-\t\t\t    {\n-\t\t\t      target = expand_unop (GET_MODE (var), one_cmpl_optab,\n-\t\t\t\t\t\t    target, NULL_RTX, 0);\n-\t\t\t      uval = cval;\n-\t\t\t    }\n-\n-\t\t\t  target = expand_and (uval, target,\n-\t\t\t\t\t       (GET_CODE (target) == REG\n-\t\t\t\t\t\t&& ! preserve_subexpressions_p ()\n-\t\t\t\t\t\t? target : NULL_RTX));\n-\t\t\t}\n-\t\t  \n-\t\t      emit_move_insn (var, target);\n-\t\t      seq = get_insns ();\n-\t\t      end_sequence ();\n-#ifdef HAVE_cc0\n-\t\t      /* If INSN uses CC0, we must not separate it from the\n-\t\t\t insn that sets cc0.  */\n-\t\t      if (reg_mentioned_p (cc0_rtx, PATTERN (before)))\n-\t\t\tbefore = prev_nonnote_insn (before);\n-#endif\n-\t\t      emit_insns_before (seq, before);\n-\n-\t\t      delete_insn (temp);\n-\t\t      next = NEXT_INSN (insn);\n-\t\t      delete_jump (insn);\n-\n-\t\t      if (after_regscan)\n-\t\t\t{\n-\t\t\t  reg_scan_update (seq, NEXT_INSN (next), old_max_reg);\n-\t\t\t  old_max_reg = max_reg_num ();\n-\t\t\t}\n-\n-\t\t      changed = 1;\n-\t\t      continue;\n-\t\t    }\n-\t\t  else\n-\t\t    end_sequence ();\n-\t\t}\n-\t    }\n-\n-\n-\t  /* Simplify   if (...) x = 1; else {...}  if (x) ...\n-\t     We recognize this case scanning backwards as well.\n-\n-\t     TEMP is the assignment to x;\n-\t     TEMP1 is the label at the head of the second if.  */\n-\t  /* ?? This should call get_condition to find the values being\n-\t     compared, instead of looking for a COMPARE insn when HAVE_cc0\n-\t     is not defined.  This would allow it to work on the m88k.  */\n-\t  /* ?? This optimization is only safe before cse is run if HAVE_cc0\n-\t     is not defined and the condition is tested by a separate compare\n-\t     insn.  This is because the code below assumes that the result\n-\t     of the compare dies in the following branch.\n-\n-\t     Not only that, but there might be other insns between the\n-\t     compare and branch whose results are live.  Those insns need\n-\t     to be executed.\n-\n-\t     A way to fix this is to move the insns at JUMP_LABEL (insn)\n-\t     to before INSN.  If we are running before flow, they will\n-\t     be deleted if they aren't needed.   But this doesn't work\n-\t     well after flow.\n-\n-\t     This is really a special-case of jump threading, anyway.  The\n-\t     right thing to do is to replace this and jump threading with\n-\t     much simpler code in cse.\n-\n-\t     This code has been turned off in the non-cc0 case in the\n-\t     meantime.  */\n-\n-#ifdef HAVE_cc0\n-\t  else if (this_is_simplejump\n-\t\t   /* Safe to skip USE and CLOBBER insns here\n-\t\t      since they will not be deleted.  */\n-\t\t   && (temp = prev_active_insn (insn))\n-\t\t   && no_labels_between_p (temp, insn)\n-\t\t   && GET_CODE (temp) == INSN\n-\t\t   && GET_CODE (PATTERN (temp)) == SET\n-\t\t   && GET_CODE (SET_DEST (PATTERN (temp))) == REG\n-\t\t   && CONSTANT_P (SET_SRC (PATTERN (temp)))\n-\t\t   && (temp1 = next_active_insn (JUMP_LABEL (insn)))\n-\t\t   /* If we find that the next value tested is `x'\n-\t\t      (TEMP1 is the insn where this happens), win.  */\n-\t\t   && GET_CODE (temp1) == INSN\n-\t\t   && GET_CODE (PATTERN (temp1)) == SET\n-#ifdef HAVE_cc0\n-\t\t   /* Does temp1 `tst' the value of x?  */\n-\t\t   && SET_SRC (PATTERN (temp1)) == SET_DEST (PATTERN (temp))\n-\t\t   && SET_DEST (PATTERN (temp1)) == cc0_rtx\n-\t\t   && (temp1 = next_nonnote_insn (temp1))\n-#else\n-\t\t   /* Does temp1 compare the value of x against zero?  */\n-\t\t   && GET_CODE (SET_SRC (PATTERN (temp1))) == COMPARE\n-\t\t   && XEXP (SET_SRC (PATTERN (temp1)), 1) == const0_rtx\n-\t\t   && (XEXP (SET_SRC (PATTERN (temp1)), 0)\n-\t\t       == SET_DEST (PATTERN (temp)))\n-\t\t   && GET_CODE (SET_DEST (PATTERN (temp1))) == REG\n-\t\t   && (temp1 = find_next_ref (SET_DEST (PATTERN (temp1)), temp1))\n-#endif\n-\t\t   && condjump_p (temp1))\n-\t    {\n-\t      /* Get the if_then_else from the condjump.  */\n-\t      rtx choice = SET_SRC (PATTERN (temp1));\n-\t      if (GET_CODE (choice) == IF_THEN_ELSE)\n-\t\t{\n-\t\t  enum rtx_code code = GET_CODE (XEXP (choice, 0));\n-\t\t  rtx val = SET_SRC (PATTERN (temp));\n-\t\t  rtx cond\n-\t\t    = simplify_relational_operation (code, GET_MODE (SET_DEST (PATTERN (temp))),\n-\t\t\t\t\t\t     val, const0_rtx);\n-\t\t  rtx ultimate;\n-\n-\t\t  if (cond == const_true_rtx)\n-\t\t    ultimate = XEXP (choice, 1);\n-\t\t  else if (cond == const0_rtx)\n-\t\t    ultimate = XEXP (choice, 2);\n-\t\t  else\n-\t\t    ultimate = 0;\n-\n-\t\t  if (ultimate == pc_rtx)\n-\t\t    ultimate = get_label_after (temp1);\n-\t\t  else if (ultimate && GET_CODE (ultimate) != RETURN)\n-\t\t    ultimate = XEXP (ultimate, 0);\n-\n-\t\t  if (ultimate && JUMP_LABEL(insn) != ultimate)\n-\t\t    changed |= redirect_jump (insn, ultimate);\n-\t\t}\n-\t    }\n-#endif\n-\n-#if 0\n-\t  /* @@ This needs a bit of work before it will be right.\n-\n-\t     Any type of comparison can be accepted for the first and\n-\t     second compare.  When rewriting the first jump, we must\n-\t     compute the what conditions can reach label3, and use the\n-\t     appropriate code.  We can not simply reverse/swap the code\n-\t     of the first jump.  In some cases, the second jump must be\n-\t     rewritten also.\n-\n-\t     For example, \n-\t     <  == converts to >  ==\n-\t     <  != converts to ==  >\n-\t     etc.\n-\n-\t     If the code is written to only accept an '==' test for the second\n-\t     compare, then all that needs to be done is to swap the condition\n-\t     of the first branch.\n-\n-\t     It is questionable whether we want this optimization anyways,\n-\t     since if the user wrote code like this because he/she knew that\n-\t     the jump to label1 is taken most of the time, then rewriting\n-\t     this gives slower code.  */\n-\t  /* @@ This should call get_condition to find the values being\n-\t     compared, instead of looking for a COMPARE insn when HAVE_cc0\n-\t     is not defined.  This would allow it to work on the m88k.  */\n-\t  /* @@ This optimization is only safe before cse is run if HAVE_cc0\n-\t     is not defined and the condition is tested by a separate compare\n-\t     insn.  This is because the code below assumes that the result\n-\t     of the compare dies in the following branch.  */\n-\n-\t  /* Simplify  test a ~= b\n-\t\t       condjump label1;\n-\t\t       test a == b\n-\t\t       condjump label2;\n-\t\t       jump label3;\n-\t\t       label1:\n-\n-\t     rewriting as\n-\t\t       test a ~~= b\n-\t\t       condjump label3\n-\t\t       test a == b\n-\t\t       condjump label2\n-\t\t       label1:\n-\n-\t     where ~= is an inequality, e.g. >, and ~~= is the swapped\n-\t     inequality, e.g. <.\n-\n-\t     We recognize this case scanning backwards.\n-\n-\t     TEMP is the conditional jump to `label2';\n-\t     TEMP1 is the test for `a == b';\n-\t     TEMP2 is the conditional jump to `label1';\n-\t     TEMP3 is the test for `a ~= b'.  */\n-\t  else if (this_is_simplejump\n-\t\t   && (temp = prev_active_insn (insn))\n-\t\t   && no_labels_between_p (temp, insn)\n-\t\t   && condjump_p (temp)\n-\t\t   && (temp1 = prev_active_insn (temp))\n-\t\t   && no_labels_between_p (temp1, temp)\n-\t\t   && GET_CODE (temp1) == INSN\n-\t\t   && GET_CODE (PATTERN (temp1)) == SET\n-#ifdef HAVE_cc0\n-\t\t   && sets_cc0_p (PATTERN (temp1)) == 1\n-#else\n-\t\t   && GET_CODE (SET_SRC (PATTERN (temp1))) == COMPARE\n-\t\t   && GET_CODE (SET_DEST (PATTERN (temp1))) == REG\n-\t\t   && (temp == find_next_ref (SET_DEST (PATTERN (temp1)), temp1))\n-#endif\n-\t\t   && (temp2 = prev_active_insn (temp1))\n-\t\t   && no_labels_between_p (temp2, temp1)\n-\t\t   && condjump_p (temp2)\n-\t\t   && JUMP_LABEL (temp2) == next_nonnote_insn (NEXT_INSN (insn))\n-\t\t   && (temp3 = prev_active_insn (temp2))\n-\t\t   && no_labels_between_p (temp3, temp2)\n-\t\t   && GET_CODE (PATTERN (temp3)) == SET\n-\t\t   && rtx_equal_p (SET_DEST (PATTERN (temp3)),\n-\t\t\t\t   SET_DEST (PATTERN (temp1)))\n-\t\t   && rtx_equal_p (SET_SRC (PATTERN (temp1)),\n-\t\t\t\t   SET_SRC (PATTERN (temp3)))\n-\t\t   && ! inequality_comparisons_p (PATTERN (temp))\n-\t\t   && inequality_comparisons_p (PATTERN (temp2)))\n-\t    {\n-\t      rtx fallthrough_label = JUMP_LABEL (temp2);\n-\n-\t      ++LABEL_NUSES (fallthrough_label);\n-\t      if (swap_jump (temp2, JUMP_LABEL (insn)))\n-\t\t{\n-\t\t  delete_insn (insn);\n-\t\t  changed = 1;\n-\t\t}\n-\n-\t      if (--LABEL_NUSES (fallthrough_label) == 0)\n-\t\tdelete_insn (fallthrough_label);\n-\t    }\n-#endif\n-\t  /* Simplify  if (...) {... x = 1;} if (x) ...\n-\n-\t     We recognize this case backwards.\n-\n-\t     TEMP is the test of `x';\n-\t     TEMP1 is the assignment to `x' at the end of the\n-\t     previous statement.  */\n-\t  /* @@ This should call get_condition to find the values being\n-\t     compared, instead of looking for a COMPARE insn when HAVE_cc0\n-\t     is not defined.  This would allow it to work on the m88k.  */\n-\t  /* @@ This optimization is only safe before cse is run if HAVE_cc0\n-\t     is not defined and the condition is tested by a separate compare\n-\t     insn.  This is because the code below assumes that the result\n-\t     of the compare dies in the following branch.  */\n-\n-\t  /* ??? This has to be turned off.  The problem is that the\n-\t     unconditional jump might indirectly end up branching to the\n-\t     label between TEMP1 and TEMP.  We can't detect this, in general,\n-\t     since it may become a jump to there after further optimizations.\n-\t     If that jump is done, it will be deleted, so we will retry\n-\t     this optimization in the next pass, thus an infinite loop.\n-\n-\t     The present code prevents this by putting the jump after the\n-\t     label, but this is not logically correct.  */\n-#if 0\n-\t  else if (this_is_condjump\n-\t\t   /* Safe to skip USE and CLOBBER insns here\n-\t\t      since they will not be deleted.  */\n-\t\t   && (temp = prev_active_insn (insn))\n-\t\t   && no_labels_between_p (temp, insn)\n-\t\t   && GET_CODE (temp) == INSN\n-\t\t   && GET_CODE (PATTERN (temp)) == SET\n-#ifdef HAVE_cc0\n-\t\t   && sets_cc0_p (PATTERN (temp)) == 1\n-\t\t   && GET_CODE (SET_SRC (PATTERN (temp))) == REG\n-#else\n-\t\t   /* Temp must be a compare insn, we can not accept a register\n-\t\t      to register move here, since it may not be simply a\n-\t\t      tst insn.  */\n-\t\t   && GET_CODE (SET_SRC (PATTERN (temp))) == COMPARE\n-\t\t   && XEXP (SET_SRC (PATTERN (temp)), 1) == const0_rtx\n-\t\t   && GET_CODE (XEXP (SET_SRC (PATTERN (temp)), 0)) == REG\n-\t\t   && GET_CODE (SET_DEST (PATTERN (temp))) == REG\n-\t\t   && insn == find_next_ref (SET_DEST (PATTERN (temp)), temp)\n-#endif\n-\t\t   /* May skip USE or CLOBBER insns here\n-\t\t      for checking for opportunity, since we\n-\t\t      take care of them later.  */\n-\t\t   && (temp1 = prev_active_insn (temp))\n-\t\t   && GET_CODE (temp1) == INSN\n-\t\t   && GET_CODE (PATTERN (temp1)) == SET\n-#ifdef HAVE_cc0\n-\t\t   && SET_SRC (PATTERN (temp)) == SET_DEST (PATTERN (temp1))\n-#else\n-\t\t   && (XEXP (SET_SRC (PATTERN (temp)), 0)\n-\t\t       == SET_DEST (PATTERN (temp1)))\n-#endif\n-\t\t   && CONSTANT_P (SET_SRC (PATTERN (temp1)))\n-\t\t   /* If this isn't true, cse will do the job.  */\n-\t\t   && ! no_labels_between_p (temp1, temp))\n-\t    {\n-\t      /* Get the if_then_else from the condjump.  */\n-\t      rtx choice = SET_SRC (PATTERN (insn));\n-\t      if (GET_CODE (choice) == IF_THEN_ELSE\n-\t\t  && (GET_CODE (XEXP (choice, 0)) == EQ\n-\t\t      || GET_CODE (XEXP (choice, 0)) == NE))\n-\t\t{\n-\t\t  int want_nonzero = (GET_CODE (XEXP (choice, 0)) == NE);\n-\t\t  rtx last_insn;\n-\t\t  rtx ultimate;\n-\t\t  rtx p;\n-\n-\t\t  /* Get the place that condjump will jump to\n-\t\t     if it is reached from here.  */\n-\t\t  if ((SET_SRC (PATTERN (temp1)) != const0_rtx)\n-\t\t      == want_nonzero)\n-\t\t    ultimate = XEXP (choice, 1);\n-\t\t  else\n-\t\t    ultimate = XEXP (choice, 2);\n-\t\t  /* Get it as a CODE_LABEL.  */\n-\t\t  if (ultimate == pc_rtx)\n-\t\t    ultimate = get_label_after (insn);\n-\t\t  else\n-\t\t    /* Get the label out of the LABEL_REF.  */\n-\t\t    ultimate = XEXP (ultimate, 0);\n-\n-\t\t  /* Insert the jump immediately before TEMP, specifically\n-\t\t     after the label that is between TEMP1 and TEMP.  */\n-\t\t  last_insn = PREV_INSN (temp);\n-\n-\t\t  /* If we would be branching to the next insn, the jump\n-\t\t     would immediately be deleted and the re-inserted in\n-\t\t     a subsequent pass over the code.  So don't do anything\n-\t\t     in that case.  */\n-\t\t  if (next_active_insn (last_insn)\n-\t\t      != next_active_insn (ultimate))\n-\t\t    {\n-\t\t      emit_barrier_after (last_insn);\n-\t\t      p = emit_jump_insn_after (gen_jump (ultimate),\n-\t\t\t\t\t\tlast_insn);\n-\t\t      JUMP_LABEL (p) = ultimate;\n-\t\t      ++LABEL_NUSES (ultimate);\n-\t\t      if (INSN_UID (ultimate) < max_jump_chain\n-\t\t\t  && INSN_CODE (p) < max_jump_chain)\n-\t\t\t{\n-\t\t\t  jump_chain[INSN_UID (p)]\n-\t\t\t    = jump_chain[INSN_UID (ultimate)];\n-\t\t\t  jump_chain[INSN_UID (ultimate)] = p;\n-\t\t\t}\n-\t\t      changed = 1;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t    }\n-#endif\n #ifdef HAVE_trap\n \t  /* Detect a conditional jump jumping over an unconditional trap.  */\n-\t  else if (HAVE_trap\n-\t\t   && this_is_condjump && ! this_is_simplejump\n-\t\t   && reallabelprev != 0\n-\t\t   && GET_CODE (reallabelprev) == INSN\n-\t\t   && GET_CODE (PATTERN (reallabelprev)) == TRAP_IF\n-\t\t   && TRAP_CONDITION (PATTERN (reallabelprev)) == const_true_rtx\n-\t\t   && prev_active_insn (reallabelprev) == insn\n-\t\t   && no_labels_between_p (insn, reallabelprev)\n-\t\t   && (temp2 = get_condition (insn, &temp4))\n-\t\t   && can_reverse_comparison_p (temp2, insn))\n+\t  if (HAVE_trap\n+\t      && this_is_condjump && ! this_is_simplejump\n+\t      && reallabelprev != 0\n+\t      && GET_CODE (reallabelprev) == INSN\n+\t      && GET_CODE (PATTERN (reallabelprev)) == TRAP_IF\n+\t      && TRAP_CONDITION (PATTERN (reallabelprev)) == const_true_rtx\n+\t      && prev_active_insn (reallabelprev) == insn\n+\t      && no_labels_between_p (insn, reallabelprev)\n+\t      && (temp2 = get_condition (insn, &temp4))\n+\t      && can_reverse_comparison_p (temp2, insn))\n \t    {\n \t      rtx new = gen_cond_trap (reverse_condition (GET_CODE (temp2)),\n \t\t\t\t       XEXP (temp2, 0), XEXP (temp2, 1),\n@@ -5454,47 +4033,3 @@ rtx_equal_for_thread_p (x, y, yinsn)\n     }\n   return 1;\n }\n-\f\n-\n-#if !defined(HAVE_cc0) && !defined(HAVE_conditional_arithmetic)\n-/* Return the insn that NEW can be safely inserted in front of starting at\n-   the jump insn INSN.  Return 0 if it is not safe to do this jump\n-   optimization.  Note that NEW must contain a single set. */\n-\n-static rtx\n-find_insert_position (insn, new)\n-     rtx insn;\n-     rtx new;\n-{\n-  int i;\n-  rtx prev;\n-\n-  /* If NEW does not clobber, it is safe to insert NEW before INSN. */\n-  if (GET_CODE (PATTERN (new)) != PARALLEL)\n-    return insn;\n-\n-  for (i = XVECLEN (PATTERN (new), 0) - 1; i >= 0; i--)\n-    if (GET_CODE (XVECEXP (PATTERN (new), 0, i)) == CLOBBER\n-\t&& reg_overlap_mentioned_p (XEXP (XVECEXP (PATTERN (new), 0, i), 0),\n-\t\t\t\t    insn))\n-      break;\n-\n-  if (i < 0)\n-    return insn;\n-\n-  /* There is a good chance that the previous insn PREV sets the thing\n-     being clobbered (often the CC in a hard reg).  If PREV does not\n-     use what NEW sets, we can insert NEW before PREV. */\n-\n-  prev = prev_active_insn (insn);\n-  for (i = XVECLEN (PATTERN (new), 0) - 1; i >= 0; i--)\n-    if (GET_CODE (XVECEXP (PATTERN (new), 0, i)) == CLOBBER\n-\t&& reg_overlap_mentioned_p (XEXP (XVECEXP (PATTERN (new), 0, i), 0),\n-\t\t\t\t    insn)\n-\t&& ! modified_in_p (XEXP (XVECEXP (PATTERN (new), 0, i), 0),\n-\t\t\t    prev))\n-      return 0;\n-\n-  return reg_mentioned_p (SET_DEST (single_set (new)), prev) ? 0 : prev;\n-}\n-#endif /* !HAVE_cc0 */"}, {"sha": "401719a9e92313b55b65e65b5fee1f9d7701ab81", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "patch": "@@ -51,12 +51,14 @@ DEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\n DEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\n DEFTIMEVAR (TV_FLOW                  , \"flow analysis\")\n DEFTIMEVAR (TV_COMBINE               , \"combiner\")\n+DEFTIMEVAR (TV_IFCVT\t\t     , \"if-conversion\")\n DEFTIMEVAR (TV_REGMOVE               , \"regmove\")\n DEFTIMEVAR (TV_SCHED                 , \"scheduling\")\n DEFTIMEVAR (TV_LOCAL_ALLOC           , \"local alloc\")\n DEFTIMEVAR (TV_GLOBAL_ALLOC          , \"global alloc\")\n DEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\n DEFTIMEVAR (TV_FLOW2                 , \"flow 2\")\n+DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\n DEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\n DEFTIMEVAR (TV_SCHED2                , \"schedulding 2\")\n DEFTIMEVAR (TV_DBR_SCHED             , \"delay branch sched\")"}, {"sha": "0d45f6947b59ec128cf8be4f8302b110107b5c8e", "filename": "gcc/toplev.c", "status": "modified", "additions": 89, "deletions": 15, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9ec6d7ab0fbf5ed057ad9bce6150aa6b0336b1e3", "patch": "@@ -264,11 +264,13 @@ enum dump_file_index\n   DFI_bp,\n   DFI_flow,\n   DFI_combine,\n+  DFI_ce,\n   DFI_regmove,\n   DFI_sched,\n   DFI_lreg,\n   DFI_greg,\n   DFI_flow2,\n+  DFI_ce2,\n   DFI_peephole2,\n   DFI_sched2,\n   DFI_bbro,\n@@ -281,7 +283,13 @@ enum dump_file_index\n };\n \n /* Describes all the dump files.  Should be kept in order of the\n-   pass and in sync with dump_file_index above.  */\n+   pass and in sync with dump_file_index above.\n+\n+   Remaining -d letters:\n+\n+\t\"       h      o q   u     \"\n+\t\"       H  K   OPQ  TUVWXYZ\"\n+*/\n \n struct dump_file_info dump_file[DFI_MAX] = \n {\n@@ -298,11 +306,13 @@ struct dump_file_info dump_file[DFI_MAX] =\n   { \"bp\",\t'b', 1, 0, 0 },\n   { \"flow\",\t'f', 1, 0, 0 },\n   { \"combine\",\t'c', 1, 0, 0 },\n+  { \"ce\",\t'C', 1, 0, 0 },\n   { \"regmove\",\t'N', 1, 0, 0 },\n   { \"sched\",\t'S', 1, 0, 0 },\n   { \"lreg\",\t'l', 1, 0, 0 },\n   { \"greg\",\t'g', 1, 0, 0 },\n   { \"flow2\",\t'w', 1, 0, 0 },\n+  { \"ce2\",\t'E', 1, 0, 0 },\n   { \"peephole2\", 'z', 1, 0, 0 },\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"bbro\",\t'B', 1, 0, 0 },\n@@ -2814,12 +2824,23 @@ rest_of_compilation (decl)\n     }\n \n   timevar_push (TV_JUMP);\n-  /* Try to identify useless null pointer tests and delete them.  */\n-  if (flag_delete_null_pointer_checks)\n+\n+  if (optimize > 0)\n     {\n       find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n       cleanup_cfg (insns);\n-      delete_null_pointer_checks (insns);\n+\n+      /* ??? Run if-conversion before delete_null_pointer_checks,\n+         since the later does not preserve the CFG.  This should\n+\t be changed -- no since converting if's that are going to\n+\t be deleted.  */\n+      timevar_push (TV_IFCVT);\n+      if_convert (0);\n+      timevar_pop (TV_IFCVT);\n+\n+      /* Try to identify useless null pointer tests and delete them.  */\n+      if (flag_delete_null_pointer_checks)\n+\tdelete_null_pointer_checks (insns);\n     }\n \n   /* Jump optimization, and the removal of NULL pointer checks, may\n@@ -2998,11 +3019,6 @@ rest_of_compilation (decl)\n \tggc_collect ();\n     }\n \n-  /* ??? Well, nearly.  If HAVE_conditional_arithmetic, jump_optimize\n-     has put off all if-conversion until \"after CSE\".  If we put this\n-     off any longer we may miss out doing if-conversion entirely.  */\n-  cse_not_expected = 1;\n-\n   if (optimize > 0)\n     {\n       timevar_push (TV_CSE2);\n@@ -3016,9 +3032,19 @@ rest_of_compilation (decl)\n \t     max_reg_num so we must rerun reg_scan afterwards.\n \t     ??? Rework to not call reg_scan so often.  */\n \t  timevar_push (TV_JUMP);\n+\n \t  reg_scan (insns, max_reg_num (), 0);\n \t  jump_optimize (insns, !JUMP_CROSS_JUMP,\n \t\t\t !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n+\n+\t  timevar_push (TV_IFCVT);\n+\n+\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t  cleanup_cfg (insns);\n+\t  if_convert (0);\n+\n+\t  timevar_pop(TV_IFCVT);\n+\n \t  timevar_pop (TV_JUMP);\n \t  \n \t  reg_scan (insns, max_reg_num (), 0);\n@@ -3050,6 +3076,8 @@ rest_of_compilation (decl)\n \tggc_collect ();\n     }\n \n+  cse_not_expected = 1;\n+\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n       timevar_push (TV_BRANCH_PROB);\n@@ -3110,10 +3138,6 @@ rest_of_compilation (decl)\n   if (ggc_p)\n     ggc_collect ();\n \n-  /* The first life analysis pass has finished.  From now on we can not\n-     generate any new pseudos.  */\n-  no_new_pseudos = 1;\n-\n   /* If -opt, try combining insns through substitution.  */\n \n   if (optimize > 0)\n@@ -3134,6 +3158,20 @@ rest_of_compilation (decl)\n \t  timevar_push (TV_JUMP);\n \t  rebuild_jump_labels (insns);\n \t  timevar_pop (TV_JUMP);\n+\n+\t  timevar_push (TV_FLOW);\n+\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t  cleanup_cfg (insns);\n+\n+\t  /* Blimey.  We've got to have the CFG up to date for the call to\n+\t     if_convert below.  However, the random deletion of blocks\n+\t     without updating life info can wind up with Wierd Stuff in\n+\t     global_live_at_end.  We then run sched1, which updates things\n+\t     properly, discovers the wierdness and aborts.  */\n+\t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t    PROP_DEATH_NOTES);\n+\n+\t  timevar_pop (TV_FLOW);\n \t}\n \n       close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n@@ -3143,6 +3181,19 @@ rest_of_compilation (decl)\n \tggc_collect ();\n     }\n \n+  /* Rerun if-conversion, as combine may have simplified things enough to\n+     now meet sequence length restrictions.  */\n+  if (optimize > 0)\n+    {\n+      timevar_push (TV_IFCVT);\n+      open_dump_file (DFI_ce, decl);\n+\n+      if_convert (1);\n+\n+      close_dump_file (DFI_ce, print_rtl_with_bb, insns);\n+      timevar_pop (TV_IFCVT);\n+    }\n+\n   /* Register allocation pre-pass, to reduce number of moves\n      necessary for two-address machines.  */\n   if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n@@ -3185,6 +3236,10 @@ rest_of_compilation (decl)\n \n       if (ggc_p)\n \tggc_collect ();\n+\n+      /* Register lifetime information is up to date.  From now on\n+\t we can not generate any new pseudos.  */\n+      no_new_pseudos = 1;\n     }\n #endif\n \n@@ -3204,7 +3259,13 @@ rest_of_compilation (decl)\n   /* We recomputed reg usage as part of updating the rest\n      of life info during sched.  */\n   if (! flag_schedule_insns)\n-    recompute_reg_usage (insns, ! optimize_size);\n+    {\n+      recompute_reg_usage (insns, ! optimize_size);\n+\n+      /* Register lifetime information is up to date.  From now on\n+\t we can not generate any new pseudos.  */\n+      no_new_pseudos = 1;\n+    }\n   regclass (insns, max_reg_num (), rtl_dump_file);\n   rebuild_label_notes_after_reload = local_alloc ();\n \n@@ -3317,12 +3378,23 @@ rest_of_compilation (decl)\n   close_dump_file (DFI_flow2, print_rtl_with_bb, insns);\n   timevar_pop (TV_FLOW2);\n \n+  if (optimize > 0)\n+    {\n+      timevar_push (TV_IFCVT2);\n+      open_dump_file (DFI_ce2, decl);\n+\n+      if_convert (1);\n+\n+      close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n+      timevar_pop (TV_IFCVT2);\n+    }\n+\n #ifdef HAVE_peephole2\n   if (optimize > 0 && flag_peephole2)\n     {\n       timevar_push (TV_PEEPHOLE2);\n-\n       open_dump_file (DFI_peephole2, decl);\n+\n       peephole2_optimize (rtl_dump_file);\n \n       close_dump_file (DFI_peephole2, print_rtl_with_bb, insns);\n@@ -3387,6 +3459,8 @@ rest_of_compilation (decl)\n       jump_optimize (insns, JUMP_CROSS_JUMP, JUMP_NOOP_MOVES, \n \t\t     !JUMP_AFTER_REGSCAN);\n \n+      /* CFG no longer kept up to date.  */\n+\n       close_dump_file (DFI_jump2, print_rtl_with_bb, insns);\n       timevar_pop (TV_JUMP);\n     }"}]}