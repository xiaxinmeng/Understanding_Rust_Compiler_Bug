{"sha": "980f237d115e7d58e664c063e0aade7dafd636ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgwZjIzN2QxMTVlN2Q1OGU2NjRjMDYzZTBhYWRlN2RhZmQ2MzZlYQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-12-11T22:11:45Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-12-11T22:11:45Z"}, "message": "einfo.ads: Minor reformatting\n\n\t* einfo.ads: Minor reformatting\n\n\t* exp_ch5.adb: Add comment for previous.change\n\n\t* ali.adb: New interface for extended typeref stuff.\n\n\t* ali.ads: New interface for typeref stuff.\n\n\t* checks.adb (Apply_Alignment_Check): New procedure.\n\n\t* debug.adb: Add -gnatdM for modified ALI output\n\n\t* exp_pakd.adb (Known_Aligned_Enough): Replaces Known_Aligned_Enough.\n\n\t* lib-xref.adb: Extend generation of <..> notation to cover\n\tsubtype/object types. Note that this is a complete rewrite,\n\tgetting rid of the very nasty quadratic algorithm previously\n\tused for derived type output.\n\n\t* lib-xref.ads: Extend description of <..> notation to cover\n\tsubtype/object types. Uses {..} for these other cases.\n\tAlso use (..) for pointer types.\n\n\t* sem_util.adb (Check_Potentially_Blocking_Operation): Slight cleanup.\n\n\t* exp_pakd.adb: Minor reformatting.  Note that prevous RH should say:\n\t(Known_Aligned_Enough): Replaces Must_Be_Aligned.\n\nFrom-SVN: r47896", "tree": {"sha": "9a2ec6960caa6e0b10445d061c7f8838db87d84c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a2ec6960caa6e0b10445d061c7f8838db87d84c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/980f237d115e7d58e664c063e0aade7dafd636ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980f237d115e7d58e664c063e0aade7dafd636ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980f237d115e7d58e664c063e0aade7dafd636ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980f237d115e7d58e664c063e0aade7dafd636ea/comments", "author": null, "committer": null, "parents": [{"sha": "290986ede68c7fb27f1ec54c63aa7c2398601444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/290986ede68c7fb27f1ec54c63aa7c2398601444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/290986ede68c7fb27f1ec54c63aa7c2398601444"}], "stats": {"total": 566, "additions": 449, "deletions": 117}, "files": [{"sha": "c3c566bac56bd3c4b4678181bbc092e8c33a2ebb", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -133,7 +133,8 @@ package body ALI is\n       --  If Lower is set to true then the Name_Buffer will be converted to\n       --  all lower case. This only happends for systems where file names are\n       --  not case sensitive, and ensures that gnatbind works correctly on\n-      --  such systems, regardless of the case of the file name.\n+      --  such systems, regardless of the case of the file name. Note that\n+      --  a name can be terminated by a right typeref bracket.\n \n       function Get_Nat return Nat;\n       --  Skip blanks, then scan out an unsigned integer value in Nat range\n@@ -305,6 +306,7 @@ package body ALI is\n             Name_Len := Name_Len + 1;\n             Name_Buffer (Name_Len) := Getc;\n             exit when At_End_Of_Field;\n+            exit when Nextc = ')' or else Nextc = '}' or else Nextc = '>';\n          end loop;\n \n          --  Convert file name to all lower case if file names are not case\n@@ -1253,30 +1255,55 @@ package body ALI is\n \n                   Skip_Space;\n \n-                  if Nextc = '<' then\n-                     P := P + 1;\n-                     N := Get_Nat;\n+                  case Nextc is\n+                     when '<'    => XE.Tref := Tref_Derived;\n+                     when '('    => XE.Tref := Tref_Access;\n+                     when '{'    => XE.Tref := Tref_Type;\n+                     when others => XE.Tref := Tref_None;\n+                  end case;\n \n-                     if Nextc = '|' then\n-                        XE.Ptype_File_Num :=\n-                          Sdep_Id (N + Nat (First_Sdep_Entry) - 1);\n-                        Current_File_Num := XE.Ptype_File_Num;\n-                        P := P + 1;\n-                        N := Get_Nat;\n+                  --  Case of typeref field present\n+\n+                  if XE.Tref /= Tref_None then\n+                     P := P + 1; -- skip opening bracket\n+\n+                     if Nextc in 'a' .. 'z' then\n+                        XE.Tref_File_Num        := No_Sdep_Id;\n+                        XE.Tref_Line            := 0;\n+                        XE.Tref_Type            := ' ';\n+                        XE.Tref_Col             := 0;\n+                        XE.Tref_Standard_Entity := Get_Name;\n \n                      else\n-                        XE.Ptype_File_Num := Current_File_Num;\n+                        N := Get_Nat;\n+\n+                        if Nextc = '|' then\n+                           XE.Tref_File_Num :=\n+                             Sdep_Id (N + Nat (First_Sdep_Entry) - 1);\n+                           Current_File_Num := XE.Tref_File_Num;\n+                           P := P + 1;\n+                           N := Get_Nat;\n+\n+                        else\n+                           XE.Tref_File_Num := Current_File_Num;\n+                        end if;\n+\n+                        XE.Tref_Line            := N;\n+                        XE.Tref_Type            := Getc;\n+                        XE.Tref_Col             := Get_Nat;\n+                        XE.Tref_Standard_Entity := No_Name;\n                      end if;\n \n-                     XE.Ptype_Line := N;\n-                     XE.Ptype_Type := Getc;\n-                     XE.Ptype_Col  := Get_Nat;\n+                     P := P + 1; -- skip closing bracket\n+\n+                  --  No typeref entry present\n \n                   else\n-                     XE.Ptype_File_Num := No_Sdep_Id;\n-                     XE.Ptype_Line     := 0;\n-                     XE.Ptype_Type     := ' ';\n-                     XE.Ptype_Col      := 0;\n+                     XE.Tref_File_Num        := No_Sdep_Id;\n+                     XE.Tref_Line            := 0;\n+                     XE.Tref_Type            := ' ';\n+                     XE.Tref_Col             := 0;\n+                     XE.Tref_Standard_Entity := No_Name;\n                   end if;\n \n                   XE.First_Xref := Xref.Last + 1;"}, {"sha": "2079d78a47fc8c75be3044422cbcaf1075491fb8", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.71 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n@@ -588,6 +588,15 @@ package ALI is\n      Table_Increment      => 300,\n      Table_Name           => \"Xref_Section\");\n \n+   --  The following is used to indicate whether a typeref field is present\n+   --  for the entity, and if so what kind of typeref field.\n+\n+   type Tref_Kind is (\n+     Tref_None,    --  No typeref present\n+     Tref_Access,  --  Access type typeref (points to designated type)\n+     Tref_Derived, --  Derived type typeref (points to parent type)\n+     Tref_Type);   --  All other cases\n+\n    --  The following table records entities for which xrefs are recorded\n \n    type Xref_Entity_Record is record\n@@ -607,24 +616,39 @@ package ALI is\n       Entity : Name_Id;\n       --  Name of entity\n \n-      Ptype_File_Num : Sdep_Id;\n-      --  This field is set to No_Sdep_Id if no ptype (parent type) entry\n-      --  is present, otherwise it is the file dependency reference for\n-      --  the parent type declaration.\n-\n-      Ptype_Line : Nat;\n-      --  Set to zero if no ptype (parent type) entry, otherwise this is\n-      --  the line number of the declaration of the parent type.\n-\n-      Ptype_Type : Character;\n-      --  Set to blank if no ptype (parent type) entry, otherwise this is\n-      --  the identification character for the parent type. See section\n+      Tref : Tref_Kind;\n+      --  Indicates if a typeref is present, and if so what kind. Set to\n+      --  Tref_None if no typeref field is present.\n+\n+      Tref_File_Num : Sdep_Id;\n+      --  This field is set to No_Sdep_Id if no typeref is present, or\n+      --  if the typeref refers to an entity in standard. Otherwise it\n+      --  it is the dependency reference for the file containing the\n+      --  declaration of the typeref entity.\n+\n+      Tref_Line : Nat;\n+      --  This field is set to zero if no typeref is present, or if the\n+      --  typeref refers to an entity in standard. Otherwise it contains\n+      --  the line number of the declaration of the typeref entity.\n+\n+      Tref_Type : Character;\n+      --  This field is set to blank if no typeref is present, or if the\n+      --  typeref refers to an entity in standard. Otherwise it contains\n+      --  the identification character for the typeref entity. See section\n       --  \"Cross-Reference Entity Indentifiers in lib-xref.ads for details.\n \n-      Ptype_Col : Nat;\n-      --  Set to zero if no ptype (parent type) entry, otherwise this is\n+      Tref_Col : Nat;\n+      --  This field is set to zero if no typeref is present, or if the\n+      --  typeref refers to an entity in standard. Otherwise it contains\n       --  the column number of the declaration of the parent type.\n \n+      Tref_Standard_Entity : Name_Id;\n+      --  This field is set to No_Name if no typeref is present or if the\n+      --  typeref refers to a declared entity rather than an entity in\n+      --  package Standard. If there is a typeref that references an\n+      --  entity in package Standard, then this field is a Name_Id\n+      --  reference for the entity name.\n+\n       First_Xref : Nat;\n       --  Index into Xref table of first cross-reference\n "}, {"sha": "896481e86d69d314b6bd6007752f38ff36520131", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -37,6 +37,7 @@ with Freeze;   use Freeze;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Restrict; use Restrict;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n@@ -277,6 +278,79 @@ package body Checks is\n       end if;\n    end Apply_Accessibility_Check;\n \n+   ---------------------------\n+   -- Apply_Alignment_Check --\n+   ---------------------------\n+\n+   procedure Apply_Alignment_Check (E : Entity_Id; N : Node_Id) is\n+      AC   : constant Node_Id := Address_Clause (E);\n+      Expr : Node_Id;\n+      Loc  : Source_Ptr;\n+\n+   begin\n+      if No (AC) or else Range_Checks_Suppressed (E) then\n+         return;\n+      end if;\n+\n+      Loc  := Sloc (AC);\n+      Expr := Expression (AC);\n+\n+      if Nkind (Expr) = N_Unchecked_Type_Conversion then\n+         Expr := Expression (Expr);\n+\n+      elsif Nkind (Expr) = N_Function_Call\n+        and then Is_RTE (Entity (Name (Expr)), RE_To_Address)\n+      then\n+         Expr := First (Parameter_Associations (Expr));\n+\n+         if Nkind (Expr) = N_Parameter_Association then\n+            Expr := Explicit_Actual_Parameter (Expr);\n+         end if;\n+      end if;\n+\n+      --  Here Expr is the address value. See if we know that the\n+      --  value is unacceptable at compile time.\n+\n+      if Compile_Time_Known_Value (Expr)\n+        and then Known_Alignment (E)\n+      then\n+         if Expr_Value (Expr) mod Alignment (E) /= 0 then\n+               Insert_Action (N,\n+                  Make_Raise_Program_Error (Loc));\n+               Error_Msg_NE\n+                 (\"?specified address for& not \" &\n+                  \"consistent with alignment\", Expr, E);\n+         end if;\n+\n+      --  Here we do not know if the value is acceptable, generate\n+      --  code to raise PE if alignment is inappropriate.\n+\n+      else\n+         --  Skip generation of this code if we don't want elab code\n+\n+         if not Restrictions (No_Elaboration_Code) then\n+            Insert_After_And_Analyze (N,\n+              Make_Raise_Program_Error (Loc,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd =>\n+                      Make_Op_Mod (Loc,\n+                        Left_Opnd =>\n+                          Unchecked_Convert_To\n+                           (RTE (RE_Integer_Address),\n+                            Duplicate_Subexpr (Expr)),\n+                        Right_Opnd =>\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => New_Occurrence_Of (E, Loc),\n+                            Attribute_Name => Name_Alignment)),\n+                    Right_Opnd => Make_Integer_Literal (Loc, Uint_0))),\n+              Suppress => All_Checks);\n+         end if;\n+      end if;\n+\n+      return;\n+   end Apply_Alignment_Check;\n+\n    -------------------------------------\n    -- Apply_Arithmetic_Overflow_Check --\n    -------------------------------------"}, {"sha": "d80c8e6aa71bb2c0088b3ae6befbaa0b7f4ed444", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.88 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n@@ -80,7 +80,7 @@ package body Debug is\n    --  dJ   Output debugging trace info for JGNAT (Java VM version of GNAT)\n    --  dK   Kill all error messages\n    --  dL   Output trace information on elaboration checking\n-   --  dM\n+   --  dM   Modified ali file output\n    --  dN   Do not generate file/line exception messages\n    --  dO   Output immediate error messages\n    --  dP   Do not check for controlled objects in preelaborable packages\n@@ -284,6 +284,11 @@ package body Debug is\n    --       attempting to generate code with this flag set may blow up.\n    --       The flag also forces the use of 64-bits for Long_Integer.\n \n+   --  dM   Generate modified ALI output. Several ALI extensions are being\n+   --       developed for version 3.15w, and this switch is used to enable\n+   --       these extensions. This switch will disappear when this work is\n+   --       completed.\n+\n    --  dn   Generate messages for node/list allocation. Each time a node or\n    --       list header is allocated, a line of output is generated. Certain\n    --       other basic tree operations also cause a line of output to be"}, {"sha": "ad8b437f2191e45864a5c6d2cb9b09485ec8efec", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -302,6 +302,7 @@ package Einfo is\n --       only if the actual subtype differs from the nominal subtype. If the\n --       actual and nominal subtypes are the same, then the Actual_Subtype\n --       field is Empty, and Etype indicates both types.\n+--\n --       For objects, the Actual_Subtype is set only if this is a discriminated\n --       type. For arrays, the bounds of the expression are obtained and the\n --       Etype of the object is directly the constrained subtype. This is"}, {"sha": "3f5a73b8a1b6b7df19f470ccfa9775731b2523fd", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -1895,6 +1895,11 @@ package body Exp_Ch5 is\n          --  the Then statements\n \n          else\n+            --  We do not delete the condition if constant condition\n+            --  warnings are enabled, since otherwise we end up deleting\n+            --  the desired warning. Of course the backend will get rid\n+            --  of this True/False test anyway, so nothing is lost here.\n+\n             if not Constant_Condition_Warnings then\n                Kill_Dead_Code (Condition (N));\n             end if;"}, {"sha": "5656569669cbd48bda67d5fc311155f25c44c72c", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 130, "deletions": 3, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.125 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n@@ -453,6 +453,16 @@ package body Exp_Pakd is\n    --  expression whose type is the implementation type used to represent\n    --  the packed array. Aexp is analyzed and resolved on entry and on exit.\n \n+   function Known_Aligned_Enough (Obj : Node_Id; Csiz : Nat) return Boolean;\n+   --  There are two versions of the Set routines, the ones used when the\n+   --  object is known to be sufficiently well aligned given the number of\n+   --  bits, and the ones used when the object is not known to be aligned.\n+   --  This routine is used to determine which set to use. Obj is a reference\n+   --  to the object, and Csiz is the component size of the packed array.\n+   --  True is returned if the alignment of object is known to be sufficient,\n+   --  defined as 1 for odd bit sizes, 4 for bit sizes divisible by 4, and\n+   --  2 otherwise.\n+\n    function Make_Shift_Left (N : Node_Id; S : Node_Id) return Node_Id;\n    --  Build a left shift node, checking for the case of a shift count of zero\n \n@@ -1426,7 +1436,7 @@ package body Exp_Pakd is\n             --  Acquire proper Set entity. We use the aligned or unaligned\n             --  case as appropriate.\n \n-            if Must_Be_Aligned (Obj) then\n+            if Known_Aligned_Enough (Obj, Csiz) then\n                Set_nn := RTE (Set_Id (Csiz));\n             else\n                Set_nn := RTE (SetU_Id (Csiz));\n@@ -1816,7 +1826,7 @@ package body Exp_Pakd is\n             --  Acquire proper Get entity. We use the aligned or unaligned\n             --  case as appropriate.\n \n-            if Must_Be_Aligned (Obj) then\n+            if Known_Aligned_Enough (Obj, Csiz) then\n                Get_nn := RTE (Get_Id (Csiz));\n             else\n                Get_nn := RTE (GetU_Id (Csiz));\n@@ -2088,6 +2098,122 @@ package body Exp_Pakd is\n       end if;\n    end Involves_Packed_Array_Reference;\n \n+   --------------------------\n+   -- Known_Aligned_Enough --\n+   --------------------------\n+\n+   function Known_Aligned_Enough (Obj : Node_Id; Csiz : Nat) return Boolean is\n+      Typ : constant Entity_Id := Etype (Obj);\n+\n+      function In_Partially_Packed_Record (Comp : Entity_Id) return Boolean;\n+      --  If the component is in a record that contains previous packed\n+      --  components, consider it unaligned because the back-end might\n+      --  choose to pack the rest of the record. Lead to less efficient code,\n+      --  but safer vis-a-vis of back-end choices.\n+\n+      --------------------------------\n+      -- In_Partially_Packed_Record --\n+      --------------------------------\n+\n+      function In_Partially_Packed_Record (Comp : Entity_Id) return Boolean is\n+         Rec_Type  : constant Entity_Id := Scope (Comp);\n+         Prev_Comp : Entity_Id;\n+\n+      begin\n+         Prev_Comp := First_Entity (Rec_Type);\n+         while Present (Prev_Comp) loop\n+            if Is_Packed (Etype (Prev_Comp)) then\n+               return True;\n+\n+            elsif Prev_Comp = Comp then\n+               return False;\n+            end if;\n+\n+            Next_Entity (Prev_Comp);\n+         end loop;\n+\n+         return False;\n+      end  In_Partially_Packed_Record;\n+\n+   --  Start of processing for Known_Aligned_Enough\n+\n+   begin\n+      --  Odd bit sizes don't need alignment anyway\n+\n+      if Csiz mod 2 = 1 then\n+         return True;\n+\n+      --  If we have a specified alignment, see if it is sufficient, if not\n+      --  then we can't possibly be aligned enough in any case.\n+\n+      elsif Is_Entity_Name (Obj)\n+        and then Known_Alignment (Entity (Obj))\n+      then\n+         --  Alignment required is 4 if size is a multiple of 4, and\n+         --  2 otherwise (e.g. 12 bits requires 4, 10 bits requires 2)\n+\n+         if Alignment (Entity (Obj)) < 4 - (Csiz mod 4) then\n+            return False;\n+         end if;\n+      end if;\n+\n+      --  OK, alignment should be sufficient, if object is aligned\n+\n+      --  If object is strictly aligned, then it is definitely aligned\n+\n+      if Strict_Alignment (Typ) then\n+         return True;\n+\n+      --  Case of subscripted array reference\n+\n+      elsif Nkind (Obj) = N_Indexed_Component then\n+\n+         --  If we have a pointer to an array, then this is definitely\n+         --  aligned, because pointers always point to aligned versions.\n+\n+         if Is_Access_Type (Etype (Prefix (Obj))) then\n+            return True;\n+\n+         --  Otherwise, go look at the prefix\n+\n+         else\n+            return Known_Aligned_Enough (Prefix (Obj), Csiz);\n+         end if;\n+\n+      --  Case of record field\n+\n+      elsif Nkind (Obj) = N_Selected_Component then\n+\n+         --  What is significant here is whether the record type is packed\n+\n+         if Is_Record_Type (Etype (Prefix (Obj)))\n+           and then Is_Packed (Etype (Prefix (Obj)))\n+         then\n+            return False;\n+\n+         --  Or the component has a component clause which might cause\n+         --  the component to become unaligned (we can't tell if the\n+         --  backend is doing alignment computations).\n+\n+         elsif Present (Component_Clause (Entity (Selector_Name (Obj)))) then\n+            return False;\n+\n+         elsif In_Partially_Packed_Record (Entity (Selector_Name (Obj))) then\n+            return False;\n+\n+         --  In all other cases, go look at prefix\n+\n+         else\n+            return Known_Aligned_Enough (Prefix (Obj), Csiz);\n+         end if;\n+\n+      --  If not selected or indexed component, must be aligned\n+\n+      else\n+         return True;\n+      end if;\n+   end Known_Aligned_Enough;\n+\n    ---------------------\n    -- Make_Shift_Left --\n    ---------------------\n@@ -2184,6 +2310,7 @@ package body Exp_Pakd is\n    --  All we have to do here is to find the subscripts that correspond\n    --  to the index positions that have non-standard enumeration types\n    --  and insert a Pos attribute to get the proper subscript value.\n+\n    --  Finally the prefix must be uncheck converted to the corresponding\n    --  packed array type.\n "}, {"sha": "4367eb1720bb19404fe40a79c3a845ace7b087c7", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 121, "deletions": 64, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.56 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1998-2001, Free Software Foundation, Inc.         --\n --                                                                          --\n@@ -28,6 +28,7 @@\n \n with Atree;    use Atree;\n with Csets;    use Csets;\n+with Debug;    use Debug;\n with Lib.Util; use Lib.Util;\n with Namet;    use Namet;\n with Opt;      use Opt;\n@@ -84,10 +85,6 @@ package body Lib.Xref is\n      Table_Increment      => Alloc.Xrefs_Increment,\n      Table_Name           => \"Xrefs\");\n \n-   function Get_Xref_Index (E : Entity_Id) return Xref_Entry_Number;\n-   --  Returns the Xref entry table index for entity E.\n-   --  So : Xrefs.Table (Get_Xref_Index (E)).Ent = E\n-\n    -------------------------\n    -- Generate_Definition --\n    -------------------------\n@@ -328,23 +325,6 @@ package body Lib.Xref is\n       end if;\n    end Generate_Reference;\n \n-   --------------------\n-   -- Get_Xref_Index --\n-   --------------------\n-\n-   function Get_Xref_Index (E : Entity_Id) return Xref_Entry_Number is\n-   begin\n-      for K in 1 .. Xrefs.Last loop\n-         if Xrefs.Table (K).Ent = E then\n-            return K;\n-         end if;\n-      end loop;\n-\n-      --  not found, this happend if the entity is not in the compiled unit.\n-\n-      return 0;\n-   end Get_Xref_Index;\n-\n    -----------------------\n    -- Output_References --\n    -----------------------\n@@ -466,35 +446,18 @@ package body Lib.Xref is\n          Ctyp : Character;\n          --  Entity type character\n \n-         Parent_Entry : Int;\n-         --  entry for parent of derived type.\n+         Tref : Entity_Id;\n+         --  Type reference\n+\n+         Trunit : Unit_Number_Type;\n+         --  Unit number for type reference\n \n          function Name_Change (X : Entity_Id) return Boolean;\n          --  Determines if entity X has a different simple name from Curent\n \n-         function Get_Parent_Entry (X : Entity_Id) return Int;\n-         --  For a derived type, locate entry of parent type, if defined in\n-         --  in the current unit.\n-\n-         function Get_Parent_Entry (X : Entity_Id) return Int is\n-            Parent_Type : Entity_Id;\n-\n-         begin\n-            if not Is_Type (X)\n-              or else not Is_Derived_Type (X)\n-            then\n-               return 0;\n-            else\n-               Parent_Type := First_Subtype (Etype (Base_Type (X)));\n-\n-               if Comes_From_Source (Parent_Type) then\n-                  return Get_Xref_Index (Parent_Type);\n-\n-               else\n-                  return 0;\n-               end if;\n-            end if;\n-         end Get_Parent_Entry;\n+         -----------------\n+         -- Name_Change --\n+         -----------------\n \n          function Name_Change (X : Entity_Id) return Boolean is\n          begin\n@@ -529,6 +492,11 @@ package body Lib.Xref is\n                WC  : Char_Code;\n                Err : Boolean;\n                Ent : Entity_Id;\n+               Sav : Entity_Id;\n+\n+               Left  : Character;\n+               Right : Character;\n+               --  Used for {} or <> for type reference\n \n             begin\n                Ent := XE.Ent;\n@@ -709,34 +677,123 @@ package body Lib.Xref is\n                         end loop;\n                      end if;\n \n-                     --  Output derived entity name if it is available\n+                     --  Output type reference if any\n+\n+                     Tref := XE.Ent;\n+                     Left := '{';\n+                     Right := '}';\n+\n+                     loop\n+                        Sav := Tref;\n+\n+                        --  Processing for types\n+\n+                        if Is_Type (Tref) then\n+\n+                           --  Case of base type\n+\n+                           if Base_Type (Tref) = Tref then\n+\n+                              --  If derived, then get first subtype\n+\n+                              if Tref /= Etype (Tref) then\n+                                 Tref := First_Subtype (Etype (Tref));\n+                                 Left := '<';\n+                                 Right := '>';\n \n-                     Parent_Entry := Get_Parent_Entry (XE.Ent);\n+                              --  If non-derived ptr, get designated type\n \n-                     if Parent_Entry /= 0 then\n-                        declare\n-                           XD : Xref_Entry renames Xrefs.Table (Parent_Entry);\n+                              elsif Is_Access_Type (Tref) then\n+                                 Tref := Designated_Type (Tref);\n+                                 Left := '(';\n+                                 Right := ')';\n \n-                        begin\n-                           Write_Info_Char ('<');\n+                              --  For other non-derived base types, nothing\n \n-                           --  Write unit number only if different from the\n-                           --  current one.\n+                              else\n+                                 exit;\n+                              end if;\n \n-                           if XE.Eun /= XD.Eun then\n-                              Write_Info_Nat (Dependency_Num (XD.Eun));\n+                           --  For a subtype, go to ancestor subtype\n+\n+                           else\n+                              Tref := Ancestor_Subtype (Tref);\n+\n+                              --  If no ancestor subtype, go to base type\n+\n+                              if No (Tref) then\n+                                 Tref := Base_Type (Sav);\n+                              end if;\n+                           end if;\n+\n+                        --  For objects, functions, enum literals,\n+                        --  just get type from Etype field.\n+\n+                        elsif Is_Object (Tref)\n+                          or else Ekind (Tref) = E_Enumeration_Literal\n+                          or else Ekind (Tref) = E_Function\n+                          or else Ekind (Tref) = E_Operator\n+                        then\n+                           Tref := Etype (Tref);\n+\n+                        --  For anything else, exit\n+\n+                        else\n+                           exit;\n+                        end if;\n+\n+                        --  Exit if no type reference, or we are stuck in\n+                        --  some loop trying to find the type reference.\n+\n+                        exit when No (Tref) or else Tref = Sav;\n+\n+                        --  Case of standard entity, output name\n+\n+                        if Sloc (Tref) = Standard_Location then\n+\n+                           --  For now, output only if speial -gnatdM flag set\n+\n+                           exit when not Debug_Flag_MM;\n+\n+                           Write_Info_Char (Left);\n+                           Write_Info_Name (Chars (Tref));\n+                           Write_Info_Char (Right);\n+                           exit;\n+\n+                        --  Case of source entity, output location\n+\n+                        elsif Comes_From_Source (Tref) then\n+\n+                           --  For now, output only derived type entries\n+                           --  unless we have special debug flag -gnatdM\n+\n+                           exit when not (Debug_Flag_MM or else Left = '<');\n+\n+                           --  Output the reference\n+\n+                           Write_Info_Char (Left);\n+                           Trunit := Get_Source_Unit (Sloc (Tref));\n+\n+                           if Trunit /= Curxu then\n+                              Write_Info_Nat (Dependency_Num (Trunit));\n                               Write_Info_Char ('|');\n                            end if;\n \n                            Write_Info_Nat\n-                             (Int (Get_Logical_Line_Number (XD.Def)));\n+                             (Int (Get_Logical_Line_Number (Sloc (Tref))));\n                            Write_Info_Char\n-                             (Xref_Entity_Letters (Ekind (XD.Ent)));\n-                           Write_Info_Nat (Int (Get_Column_Number (XD.Def)));\n+                             (Xref_Entity_Letters (Ekind (Tref)));\n+                           Write_Info_Nat\n+                             (Int (Get_Column_Number (Sloc (Tref))));\n+                           Write_Info_Char (Right);\n+                           exit;\n \n-                           Write_Info_Char ('>');\n-                        end;\n-                     end if;\n+                        --  If non-standard, non-source entity, keep looking\n+\n+                        else\n+                           null;\n+                        end if;\n+                     end loop;\n \n                      Curru := Curxu;\n                      Crloc := No_Location;"}, {"sha": "ea99c9642ca406adbc8779d08457e59d0618fd23", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.31 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1998-2001, Free Software Foundation, Inc.         --\n --                                                                          --\n@@ -56,7 +56,7 @@ package Lib.Xref is\n    --\n    --  The lines following the header look like\n    --\n-   --     line type col level  entity ptype  ref  ref  ref\n+   --     line type col level  entity typeref  ref  ref  ref\n    --\n    --        line is the line number of the referenced entity. It starts\n    --        in column one.\n@@ -74,17 +74,30 @@ package Lib.Xref is\n    --        entity is the name of the referenced entity, with casing in\n    --        the canical casing for the source file where it is defined.\n    --\n-   --        ptype is the parent's entity reference. This part is optional (it\n-   --        is only set for derived types) and has the following format:\n-   --\n-   --        < file | line type col >\n-   --\n-   --        file is the dependency number of the file containing the\n-   --        declaration of the parent type. This number and the following\n-   --        vertical bar are omitted if the parent type is defined in the\n-   --        same file as the derived type. The line, type, col are defined\n-   --        as previously described, and give the location of the parent\n-   --        type declaration in the referenced file.\n+   --        typeref is the reference for the type. This part is optional.\n+   --        It is present for the following cases:\n+   --\n+   --          derived types (points to the parent type)   LR=<>\n+   --          access types (points to designated type)    LR=()\n+   --          subtypes (points to ancestor type)          LR={}\n+   --          functions (points to result type)           LR={}\n+   --          enumeration literals (points to enum type)  LR={}\n+   --          objects and components (points to type)     LR={}\n+   --\n+   --        In the above list LR shows the brackets used in the output,\n+   --        which has one of the two following forms:\n+   --\n+   --          L file | line type col R      user entity\n+   --          L name-in-lower-case   R      standard entity\n+   --\n+   --        For the form for a user entity, file is the dependency number\n+   --        of the file containing the declaration of the parent type. This\n+   --        number and the following vertical bar are omitted if the relevant\n+   --        type is defined in the same file as the current entity. The line,\n+   --        type, col are defined as previously described, and specify the\n+   --        location of the relevant type declaration in the referenced file.\n+   --        For the standard entity form, the name between the brackets is\n+   --        the normal name of the entity in lower case letters.\n    --\n    --     There may be zero or more ref entries on each line\n    --"}, {"sha": "df9ef755e8927cc03bf76e786955843cb9ef350a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f237d115e7d58e664c063e0aade7dafd636ea/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=980f237d115e7d58e664c063e0aade7dafd636ea", "patch": "@@ -720,8 +720,7 @@ package body Sem_Util is\n          if Is_Protected_Type (S) then\n             if Restricted_Profile then\n                Insert_Before (N,\n-                  Make_Raise_Statement (Loc,\n-                   Name => New_Occurrence_Of (Standard_Program_Error, Loc)));\n+                  Make_Raise_Program_Error (Loc));\n                Error_Msg_N (\"potentially blocking operation, \" &\n                  \" Program Error will be raised at run time?\", N);\n "}]}