{"sha": "d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRlNjEzM2YyMGM0Mzk1ZDE2YmYxZWQ3ODg3ZjUyMjNiZDNjMjQ5Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-03-22T22:29:07Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-03-22T22:29:07Z"}, "message": "cpphash.h (struct cpp_reader): Remove mls_line and mls_col.\n\n        * cpphash.h (struct cpp_reader): Remove mls_line and mls_col.\n        * cpplex.c (unterminated): Delete.\n        (parse_string): No string literal may extend over multiple\n        lines.  Suppress the error when preprocessing assembly.\n\t* cppmain.c (scan_translation_unit): Strings are single-line.\n\n        * doc/cpp.texi: Update to match.\n        * testsuite/gcc.dg/cpp/multiline.c: Update to match.\n\nFrom-SVN: r51195", "tree": {"sha": "b7200ed8ce94b6f6fbb96d7a9bf0bea3ec37efdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7200ed8ce94b6f6fbb96d7a9bf0bea3ec37efdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/comments", "author": null, "committer": null, "parents": [{"sha": "65e6c00573077208af5011dd1bebe287ae1f2ade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e6c00573077208af5011dd1bebe287ae1f2ade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e6c00573077208af5011dd1bebe287ae1f2ade"}], "stats": {"total": 152, "additions": 49, "deletions": 103}, "files": [{"sha": "984e498cbce40097714769ccda8f0b4734e80a30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "patch": "@@ -1,3 +1,13 @@\n+2002-03-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * cpphash.h (struct cpp_reader): Remove mls_line and mls_col.\n+        * cpplex.c (unterminated): Delete.\n+        (parse_string): No string literal may extend over multiple\n+        lines.  Suppress the error when preprocessing assembly.\n+\t* cppmain.c (scan_translation_unit): Strings are single-line.\n+\n+        * doc/cpp.texi: Update to match.\n+\n 2002-03-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR optimization/5854"}, {"sha": "3112bdb3b37872993b2876f6eca6ff8d2b3105a6", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "patch": "@@ -266,11 +266,6 @@ struct cpp_reader\n   /* Error counter for exit code.  */\n   unsigned int errors;\n \n-  /* Line and column where a newline was first seen in a string\n-     constant (multi-line strings).  */\n-  unsigned int mls_line;\n-  unsigned int mls_col;\n-\n   /* Buffer to hold macro definition string.  */\n   unsigned char *macro_buffer;\n   unsigned int macro_buffer_len;"}, {"sha": "a765967facec2046decfba6542996770b4a20694", "filename": "gcc/cpplex.c", "status": "modified", "additions": 11, "deletions": 58, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "patch": "@@ -82,7 +82,6 @@ static U_CHAR *parse_slow PARAMS ((cpp_reader *, const U_CHAR *, int,\n static void parse_number PARAMS ((cpp_reader *, cpp_string *, int));\n static int unescaped_terminator_p PARAMS ((cpp_reader *, const U_CHAR *));\n static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n-static void unterminated PARAMS ((cpp_reader *, int));\n static bool trigraph_p PARAMS ((cpp_reader *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n@@ -575,22 +574,6 @@ parse_number (pfile, number, leading_period)\n     }\n }\n \n-/* Subroutine of parse_string.  Emits error for unterminated strings.  */\n-static void\n-unterminated (pfile, term)\n-     cpp_reader *pfile;\n-     int term;\n-{\n-  cpp_error (pfile, \"missing terminating %c character\", term);\n-\n-  if (term == '\\\"' && pfile->mls_line && pfile->mls_line != pfile->line)\n-    {\n-      cpp_error_with_line (pfile, pfile->mls_line, pfile->mls_col,\n-\t\t\t   \"possible start of unterminated string literal\");\n-      pfile->mls_line = 0;\n-    }\n-}\n-\n /* Subroutine of parse_string.  */\n static int\n unescaped_terminator_p (pfile, dest)\n@@ -617,7 +600,6 @@ unescaped_terminator_p (pfile, dest)\n    name.  Handles embedded trigraphs and escaped newlines.  The stored\n    string is guaranteed NUL-terminated, but it is not guaranteed that\n    this is the first NUL since embedded NULs are preserved.\n-   Multi-line strings are allowed, but they are deprecated.\n \n    When this function returns, buffer->cur points to the next\n    character to be processed.  */\n@@ -630,7 +612,7 @@ parse_string (pfile, token, terminator)\n   cpp_buffer *buffer = pfile->buffer;\n   unsigned char *dest, *limit;\n   cppchar_t c;\n-  bool warned_nulls = false, warned_multi = false;\n+  bool warned_nulls = false;\n \n   dest = BUFF_FRONT (pfile->u_buff);\n   limit = BUFF_LIMIT (pfile->u_buff);\n@@ -658,49 +640,20 @@ parse_string (pfile, token, terminator)\n \t}\n       else if (is_vspace (c))\n \t{\n-\t  /* In assembly language, silently terminate string and\n-\t     character literals at end of line.  This is a kludge\n-\t     around not knowing where comments are.  */\n-\t  if (CPP_OPTION (pfile, lang) == CLK_ASM && terminator != '>')\n-\t    {\n-\t      buffer->cur--;\n-\t      break;\n-\t    }\n-\n-\t  /* Character constants and header names may not extend over\n-\t     multiple lines.  In Standard C, neither may strings.\n-\t     Unfortunately, we accept multiline strings as an\n-\t     extension, except in #include family directives.  */\n-\t  if (terminator != '\"' || pfile->state.angled_headers)\n-\t    {\n-\t      unterminated (pfile, terminator);\n-\t      buffer->cur--;\n-\t      break;\n-\t    }\n-\n-\t  if (!warned_multi)\n-\t    {\n-\t      warned_multi = true;\n-\t      cpp_pedwarn (pfile, \"multi-line string literals are deprecated\");\n-\t    }\n-\n-\t  if (pfile->mls_line == 0)\n-\t    {\n-\t      pfile->mls_line = token->line;\n-\t      pfile->mls_col = token->col;\n-\t    }\n-\t      \n-\t  handle_newline (pfile);\n-\t  c = '\\n';\n+\t  /* No string literal may extend over multiple lines.  In\n+\t     assembly language, suppress the error except for <>\n+\t     includes.  This is a kludge around not knowing where\n+\t     comments are.  */\n+\tunterminated:\n+\t  if (CPP_OPTION (pfile, lang) != CLK_ASM || terminator == '>')\n+\t    cpp_error (pfile, \"missing terminating %c character\", terminator);\n+\t  buffer->cur--;\n+\t  break;\n \t}\n       else if (c == '\\0')\n \t{\n \t  if (buffer->cur - 1 == buffer->rlimit)\n-\t    {\n-\t      unterminated (pfile, terminator);\n-\t      buffer->cur--;\n-\t      break;\n-\t    }\n+\t    goto unterminated;\n \t  if (!warned_nulls)\n \t    {\n \t      warned_nulls = true;"}, {"sha": "99ca2deb90bc931a9f7ea1f343291b4a2bfbd262", "filename": "gcc/cppmain.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "patch": "@@ -259,8 +259,7 @@ scan_translation_unit (pfile)\n       print.prev = token;\n       cpp_output_token (token, print.outf);\n \n-      if (token->type == CPP_STRING || token->type == CPP_WSTRING\n-\t  || token->type == CPP_COMMENT)\n+      if (token->type == CPP_COMMENT)\n \tcheck_multiline_token (&token->val.str);\n     }\n }"}, {"sha": "77745e73bb7d66e25985e4f08f550b8cf816bdef", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "patch": "@@ -402,26 +402,8 @@ extremely confusing and should not be used in code intended to be\n readable.\n \n There is no way to prevent a backslash at the end of a line from being\n-interpreted as a backslash-newline.\n-\n-@example\n-\"foo\\\\\n-bar\"\n-@end example\n-\n-@noindent\n-is equivalent to @code{\"foo\\bar\"}, not to @code{\"foo\\\\bar\"}.  To avoid\n-having to worry about this, do not use the deprecated GNU extension\n-which permits multi-line strings.  Instead, use string literal\n-concatenation:\n-\n-@example\n-   \"foo\\\\\"\n-   \"bar\"\n-@end example\n-\n-@noindent\n-Your program will be more portable this way, too.\n+interpreted as a backslash-newline.  This cannot affect any correct\n+program, however.\n \n @node Tokenization\n @section Tokenization\n@@ -536,11 +518,10 @@ closing quote or angle bracket.  The preprocessor looks for the header\n file in different places depending on which form you use.  @xref{Include\n Operation}.\n \n-In standard C, no string literal may extend past the end of a line.  GNU\n-CPP accepts multi-line string constants, but not multi-line character\n-constants or header file names.  This extension is deprecated and will\n-be removed in GCC 3.1.  You may use continued lines instead, or string\n-constant concatenation.  @xref{Differences from previous versions}.\n+No string literal may extend past the end of a line.  Older versions\n+of GCC accepted multi-line string constants.  You may use continued\n+lines instead, or string constant concatenation.  @xref{Differences\n+from previous versions}.\n \n @cindex punctuators\n @cindex digraphs\n@@ -796,10 +777,10 @@ those are merely the typical uses.  Any fragment of a C program can be\n included from another file.  The include file could even contain the\n beginning of a statement that is concluded in the containing file, or\n the end of a statement that was started in the including file.  However,\n-a comment or a string or character constant may not start in the\n-included file and finish in the including file.  An unterminated\n-comment, string constant or character constant in an included file is\n-considered to end (with an error message) at the end of the file.\n+an included file must consist of complete tokens.  Comments and string\n+literals which have not been closed by the end of an included file are\n+invalid.  For error recovery, they are considered to end at the end of\n+the file.\n \n To avoid confusion, it is best if header files contain only complete\n syntactic units---function declarations or definitions, type\n@@ -3785,13 +3766,11 @@ This is the same as @code{#pragma GCC poison}.  The version without the\n @cindex multi-line string constants\n @item Multi-line string constants\n \n-GCC currently allows a string constant to extend across multiple logical\n-lines of the source file.  This extension is deprecated and will be\n-removed in a future version of GCC@.  Such string constants are already\n-rejected in all directives apart from @samp{#define}.\n-\n-Instead, make use of ISO C concatenation of adjacent string literals, or\n-use @samp{\\n} followed by a backslash-newline.\n+Older versions of GCC allowed string constants to extend across\n+multiple logical lines of the source file.  This ill-considered\n+extension has now been removed.  Instead, make use of ISO C\n+concatenation of adjacent string literals, or use @samp{\\n} followed\n+by a backslash-newline.\n \n @end itemize\n "}, {"sha": "a2545b6e75a782efc2396a74168e65e5814c182f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "patch": "@@ -1,3 +1,7 @@\n+2002-03-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * gcc.dg/cpp/multiline.c: Update to match.\n+\n 2002-03-22  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* g++.old-deja/g++.abi/ptrmem.C: Mips puts vbit in delta too."}, {"sha": "efd2b6d04ed7fbd8598cfd3fab97c539b4965b25", "filename": "gcc/testsuite/gcc.dg/cpp/multiline.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e6133f20c4395d16bf1ed7887f5223bd3c249b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline.c?ref=d4e6133f20c4395d16bf1ed7887f5223bd3c249b", "patch": "@@ -22,5 +22,11 @@ L\"line 1\n    { dg-final { if \\{ [grep multiline.i \"^$\"] == \"\" \\} \\{               } }\n    { dg-final { return \\}                                               } }\n    { dg-final { fail \"multiline.c: multi-line tokens\"                   } } */\n-/* { dg-warning \"deprecated\" \"multiline strings\" { target *-*-* } 11 } */\n-/* { dg-warning \"deprecated\" \"multiline strings\" { target *-*-* } 15 } */\n+/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 11 } */\n+/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 14 } */\n+/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 15 } */\n+/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 18 } */\n+/* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 11 } */\n+/* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 14 } */\n+/* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 15 } */\n+/* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 18 } */"}]}