{"sha": "abeeec2a285eb1d65a2f20ec91d9e97c902ae140", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlZWVjMmEyODVlYjFkNjVhMmYyMGVjOTFkOWU5N2M5MDJhZTE0MA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-02-07T01:17:32Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-02-07T01:17:32Z"}, "message": "except.c (find_exception_handler_labels): Initialize label array with zeroes.\n\n        * except.c (find_exception_handler_labels): Initialize label array\n        with zeroes.\n\nFrom-SVN: r13613", "tree": {"sha": "5753dc23fed5572498b20b38f5e5a710b70b16d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5753dc23fed5572498b20b38f5e5a710b70b16d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abeeec2a285eb1d65a2f20ec91d9e97c902ae140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abeeec2a285eb1d65a2f20ec91d9e97c902ae140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abeeec2a285eb1d65a2f20ec91d9e97c902ae140", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abeeec2a285eb1d65a2f20ec91d9e97c902ae140/comments", "author": null, "committer": null, "parents": [{"sha": "312e7d50dda85f55916e792ebbb8c33c94538f5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312e7d50dda85f55916e792ebbb8c33c94538f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312e7d50dda85f55916e792ebbb8c33c94538f5b"}], "stats": {"total": 91, "additions": 46, "deletions": 45}, "files": [{"sha": "4d8d1bc9a29afdd9ea4afdfde86b8c3c6fcf3c88", "filename": "gcc/except.c", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abeeec2a285eb1d65a2f20ec91d9e97c902ae140/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abeeec2a285eb1d65a2f20ec91d9e97c902ae140/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=abeeec2a285eb1d65a2f20ec91d9e97c902ae140", "patch": "@@ -368,13 +368,13 @@ struct eh_stack ehstack;\n struct eh_queue ehqueue;\n \n /* Insns for all of the exception handlers for the current function.\n-   They are currently emitted by the frontend code. */\n+   They are currently emitted by the frontend code.  */\n \n rtx catch_clauses;\n \n /* A TREE_CHAINed list of handlers for regions that are not yet\n    closed. The TREE_VALUE of each entry contains the handler for the\n-   corresponding entry on the ehstack. */\n+   corresponding entry on the ehstack.  */\n \n static tree protect_list;\n \n@@ -384,7 +384,7 @@ static tree protect_list;\n    normal control flow out of a handler (instead of, say, returning to\n    the caller of the current function or exiting the program).  Also\n    used as the context of a throw to rethrow an exception to the outer\n-   exception region. */\n+   exception region.  */\n \n struct label_node *caught_return_label_stack = NULL;\n \n@@ -468,7 +468,7 @@ copy_eh_entry (entry)\n }\n \n /* Push a new eh_node entry onto STACK, and return the start label for\n-   the entry. */\n+   the entry.  */\n \n static rtx\n push_eh_entry (stack)\n@@ -555,7 +555,7 @@ dequeue_eh_entry (queue)\n    handling is turned off. \n \n    This is used to ensure that -fexceptions has been specified if the\n-   compiler tries to use any exception-specific functions. */\n+   compiler tries to use any exception-specific functions.  */\n \n int\n doing_eh (do_warn)\n@@ -575,7 +575,7 @@ doing_eh (do_warn)\n }\n \n /* Given a return address in ADDR, determine the address we should use\n-   to find the corresponding EH region. */\n+   to find the corresponding EH region.  */\n \n rtx\n eh_outer_context (addr)\n@@ -601,15 +601,15 @@ eh_outer_context (addr)\n \n /* Start a new exception region and push the HANDLER for the region\n    onto protect_list. All of the regions created with add_partial_entry\n-   will be ended when end_protect_partials () is invoked. */\n+   will be ended when end_protect_partials () is invoked.  */\n \n void\n add_partial_entry (handler)\n      tree handler;\n {\n   expand_eh_region_start ();\n \n-  /* Make sure the entry is on the correct obstack. */\n+  /* Make sure the entry is on the correct obstack.  */\n   push_obstacks_nochange ();\n   resume_temporary_allocation ();\n   protect_list = tree_cons (NULL_TREE, handler, protect_list);\n@@ -618,7 +618,7 @@ add_partial_entry (handler)\n \n /* Output a note marking the start of an exception handling region.\n    All instructions emitted after this point are considered to be part\n-   of the region until expand_eh_region_end () is invoked. */\n+   of the region until expand_eh_region_end () is invoked.  */\n \n void\n expand_eh_region_start ()\n@@ -647,7 +647,7 @@ expand_eh_region_start ()\n    marking the end of a try block, HANDLER is integer_zero_node.\n \n    HANDLER will be transformed to rtl when expand_leftover_cleanups ()\n-   is invoked. */\n+   is invoked.  */\n \n void\n expand_eh_region_end (handler)\n@@ -665,7 +665,7 @@ expand_eh_region_end (handler)\n   note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n   NOTE_BLOCK_NUMBER (note) = CODE_LABEL_NUMBER (entry->exception_handler_label);\n \n-  /* Emit a label marking the end of this exception region. */\n+  /* Emit a label marking the end of this exception region.  */\n   emit_label (entry->end_label);\n \n   /* Put in something that takes up space, as otherwise the end\n@@ -691,7 +691,7 @@ expand_eh_region_end (handler)\n    Before invoking throw, the __eh_pc variable must have been set up\n    to contain the PC being thrown from. This address is used by\n    __throw () to determine which exception region (if any) is\n-   responsible for handling the exception. */\n+   responsible for handling the exception.  */\n \n static void\n emit_throw ()\n@@ -707,7 +707,7 @@ emit_throw ()\n }\n \n /* An internal throw with an indirect CONTEXT we want to throw from.\n-   CONTEXT evaluates to the context of the throw. */\n+   CONTEXT evaluates to the context of the throw.  */\n \n static void\n expand_internal_throw_indirect (context)\n@@ -720,7 +720,7 @@ expand_internal_throw_indirect (context)\n \n /* An internal throw with a direct CONTEXT we want to throw from.\n    CONTEXT must be a label; its address will be used as the context of\n-   the throw. */\n+   the throw.  */\n \n void\n expand_internal_throw (context)\n@@ -730,7 +730,7 @@ expand_internal_throw (context)\n }\n \n /* Called from expand_exception_blocks and expand_end_catch_block to\n-   emit any pending handlers/cleanups queued from expand_eh_region_end (). */\n+   emit any pending handlers/cleanups queued from expand_eh_region_end ().  */\n \n void\n expand_leftover_cleanups ()\n@@ -745,10 +745,10 @@ expand_leftover_cleanups ()\n       if (entry->finalization == integer_zero_node)\n \tabort ();\n \n-      /* Output the label for the start of the exception handler. */\n+      /* Output the label for the start of the exception handler.  */\n       emit_label (entry->exception_handler_label);\n \n-      /* And now generate the insns for the handler. */\n+      /* And now generate the insns for the handler.  */\n       expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n       prev = get_last_insn ();\n@@ -765,7 +765,7 @@ expand_leftover_cleanups ()\n     }\n }\n \n-/* Called at the start of a block of try statements. */\n+/* Called at the start of a block of try statements.  */\n void\n expand_start_try_stmts ()\n {\n@@ -780,7 +780,7 @@ expand_start_try_stmts ()\n    It is responsible for starting a new instruction sequence for the\n    instructions in the catch block, and expanding the handlers for the\n    internally-generated exception regions nested within the try block\n-   corresponding to this catch block. */\n+   corresponding to this catch block.  */\n \n void\n expand_start_all_catch ()\n@@ -791,7 +791,7 @@ expand_start_all_catch ()\n   if (! doing_eh (1))\n     return;\n \n-  /* End the try block. */\n+  /* End the try block.  */\n   expand_eh_region_end (integer_zero_node);\n \n   emit_line_note (input_filename, lineno);\n@@ -809,7 +809,7 @@ expand_start_all_catch ()\n   emit_insn (gen_nop ());\n \n   /* Push the label that points to where normal flow is resumed onto\n-     the top of the label stack. */\n+     the top of the label stack.  */\n   push_label_entry (&caught_return_label_stack, NULL_RTX, label);\n \n   /* Start a new sequence for all the catch blocks.  We will add this\n@@ -830,14 +830,14 @@ expand_start_all_catch ()\n \t integer_zero_node, so no code will be generated in the\n \t expand_expr call below. But, the label for the handler will\n \t still be emitted, so any code emitted after this point will\n-\t end up being the handler. */\n+\t end up being the handler.  */\n       emit_label (entry->exception_handler_label);\n       expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n       /* When we get down to the matching entry for this try block, stop.  */\n       if (entry->finalization == integer_zero_node)\n \t{\n-\t  /* Don't forget to free this entry. */\n+\t  /* Don't forget to free this entry.  */\n \t  free (entry);\n \t  break;\n \t}\n@@ -863,7 +863,7 @@ expand_start_all_catch ()\n    catch clauses have already been generated, so we only have to add\n    them to the catch_clauses list. We also want to make sure that if\n    we fall off the end of the catch clauses that we rethrow to the\n-   outer EH region. */\n+   outer EH region.  */\n \n void\n expand_end_all_catch ()\n@@ -881,7 +881,7 @@ expand_end_all_catch ()\n      In other words, if the catch handler doesn't exit or return, we\n      do a \"throw\" (using the address of Lresume as the point being\n      thrown from) so that the outer EH region can then try to process\n-     the exception. */\n+     the exception.  */\n \n   expand_internal_throw (DECL_RTL (top_label_entry (&caught_return_label_stack)));\n \n@@ -903,7 +903,7 @@ expand_end_all_catch ()\n }\n \n /* End all the pending exception regions on protect_list. The handlers\n-   will be emitted when expand_leftover_cleanups () is invoked. */\n+   will be emitted when expand_leftover_cleanups () is invoked.  */\n \n void\n end_protect_partials ()\n@@ -921,7 +921,7 @@ end_protect_partials ()\n \n    The number in eh_table is the code label number of the exception\n    handler for the region. This is added by add_eh_table_entry () and\n-   used by output_exception_table_entry (). */\n+   used by output_exception_table_entry ().  */\n \n static int *eh_table;\n static int eh_table_size;\n@@ -933,7 +933,7 @@ static int eh_table_max_size;\n \n    Called from final_scan_insn when a NOTE_INSN_EH_REGION_BEG is seen.\n    N is the NOTE_BLOCK_NUMBER of the note, which comes from the code\n-   label number of the exception handler for the region. */\n+   label number of the exception handler for the region.  */\n \n void\n add_eh_table_entry (n)\n@@ -982,7 +982,7 @@ exception_table_p ()\n    exception region numbered N to file FILE. \n \n    N is the code label number corresponding to the handler of the\n-   region. */\n+   region.  */\n \n static void\n output_exception_table_entry (file, n)\n@@ -1007,7 +1007,7 @@ output_exception_table_entry (file, n)\n   putc ('\\n', file);\t\t/* blank line */\n }\n \n-/* Output the exception table if we have and need one. */\n+/* Output the exception table if we have and need one.  */\n \n void\n output_exception_table ()\n@@ -1059,7 +1059,7 @@ register_exception_table ()\n \n    DOESNT_NEED_UNWINDER is a target-specific macro that determines if\n    the current function actually needs a per-function unwinder or not.\n-   By default, all functions need one. */\n+   By default, all functions need one.  */\n \n void\n start_eh_unwinder ()\n@@ -1098,18 +1098,18 @@ end_eh_unwinder ()\n   start_sequence_for_rtl_expr (expr);\n \n   /* ret_val will contain the address of the code where the call\n-     to the current function occurred. */\n+     to the current function occurred.  */\n   ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n \t\t\t\t\t0, hard_frame_pointer_rtx);\n   return_val_rtx = copy_to_reg (ret_val);\n \n   /* Get the address we need to use to determine what exception\n-     handler should be invoked, and store it in __eh_pc. */\n+     handler should be invoked, and store it in __eh_pc.  */\n   return_val_rtx = eh_outer_context (return_val_rtx);\n   emit_move_insn (eh_saved_pc_rtx, return_val_rtx);\n   \n   /* Either set things up so we do a return directly to __throw, or\n-     we return here instead. */\n+     we return here instead.  */\n #ifdef JUMP_TO_THROW\n   emit_move_insn (ret_val, throw_libfunc);\n #else\n@@ -1231,8 +1231,9 @@ find_exception_handler_labels ()\n   /* Generate a handy reference to each label.  */\n \n   labels = (rtx *) alloca ((max_labelno - min_labelno) * sizeof (rtx));\n+  bzero ((char *) labels, (max_labelno - min_labelno) * sizeof (rtx));\n \n-  /* Eeeeeeew. */\n+  /* Arrange for labels to be indexed directly by CODE_LABEL_NUMBER.  */\n   labels -= min_labelno;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -1288,7 +1289,7 @@ check_exception_handler_labels ()\n \n   /* Ensure that the CODE_LABEL_NUMBER for the CODE_LABEL entry point\n      in each handler corresponds to the CODE_LABEL_NUMBER of the\n-     handler. */\n+     handler.  */\n \n   for (handler = exception_handler_labels;\n        handler;\n@@ -1348,7 +1349,7 @@ void\n init_eh ()\n {\n   /* Generate rtl to reference the variable in which the PC of the\n-     current context is saved. */\n+     current context is saved.  */\n   tree type = build_pointer_type (make_node (VOID_TYPE));\n \n   eh_saved_pc = build_decl (VAR_DECL, get_identifier (\"__eh_pc\"), type);\n@@ -1358,7 +1359,7 @@ init_eh ()\n   eh_saved_pc_rtx = DECL_RTL (eh_saved_pc);\n }\n \n-/* Initialize the per-function EH information. */\n+/* Initialize the per-function EH information.  */\n \n void\n init_eh_for_function ()\n@@ -1374,7 +1375,7 @@ init_eh_for_function ()\n /* Save some of the per-function EH info into the save area denoted by\n    P. \n \n-   This is currently called from save_stmt_status (). */\n+   This is currently called from save_stmt_status ().  */\n \n void\n save_eh_status (p)\n@@ -1394,7 +1395,7 @@ save_eh_status (p)\n \n /* Restore the per-function EH info saved into the area denoted by P.  \n \n-   This is currently called from restore_stmt_status. */\n+   This is currently called from restore_stmt_status.  */\n \n void\n restore_eh_status (p)\n@@ -1420,13 +1421,13 @@ static int\n can_throw (insn)\n      rtx insn;\n {\n-  /* Calls can always potentially throw exceptions. */\n+  /* Calls can always potentially throw exceptions.  */\n   if (GET_CODE (insn) == CALL_INSN)\n     return 1;\n \n #ifdef ASYNCH_EXCEPTIONS\n   /* If we wanted asynchronous exceptions, then everything but NOTEs\n-     and CODE_LABELs could throw. */\n+     and CODE_LABELs could throw.  */\n   if (GET_CODE (insn) != NOTE && GET_CODE (insn) != CODE_LABEL)\n     return 1;\n #endif\n@@ -1449,7 +1450,7 @@ can_throw (insn)\n    calls abort () if it can't find one.\n \n    Can abort if INSN is not a NOTE_INSN_EH_REGION_BEGIN, or if N doesn't\n-   correspond to the region number, or if DELETE_OUTER is NULL. */\n+   correspond to the region number, or if DELETE_OUTER is NULL.  */\n \n static rtx\n scan_region (insn, n, delete_outer)\n@@ -1545,7 +1546,7 @@ scan_region (insn, n, delete_outer)\n \n    We look for empty exception regions and make them go (away). The\n    jump optimization code will remove the handler if nothing else uses\n-   it. */\n+   it.  */\n \n void\n exception_optimize ()\n@@ -1563,7 +1564,7 @@ exception_optimize ()\n \t     insn, we will indirectly skip through all the insns\n \t     inbetween. We are also guaranteed that the value of insn\n \t     returned will be valid, as otherwise scan_region () won't\n-\t     return. */\n+\t     return.  */\n \t  insn = scan_region (insn, NOTE_BLOCK_NUMBER (insn), &n);\n \t}\n     }"}]}