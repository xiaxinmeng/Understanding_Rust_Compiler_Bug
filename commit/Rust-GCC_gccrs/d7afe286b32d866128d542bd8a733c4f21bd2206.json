{"sha": "d7afe286b32d866128d542bd8a733c4f21bd2206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdhZmUyODZiMzJkODY2MTI4ZDU0MmJkOGE3MzNjNGYyMWJkMjIwNg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-04-14T17:45:20Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-04-14T17:45:20Z"}, "message": "[multiple changes]\n\n2004-04-14  Andrew Haley  <aph@redhat.com>\n            Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Use\n\t_Jv_LookupInterfaceMethodIdx for calls to interfaces.\n\t* include/jvm.h (_Jv_CallAnyMethodA): Add new \tface' arg.\n\n\t* testsuite/libjava.lang/InvokeInterface.java: New file.\n\t* testsuite/libjava.lang/InvokeInterface.out: New file.\n\n2004-04-14  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* class.c (get_interface_method_index): New function. Return\n\tdispatch index for interface method.\n\t(make_method_value): For interface methods, set index field to\n\tiface dispatch index, not DECL_VINDEX.\n\t* expr.c (build_invokeinterface): Use get_interface_method_index.\n\nFrom-SVN: r80684", "tree": {"sha": "b9dbd14f53ce12873b97ef6caeb33b3335f0e3c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9dbd14f53ce12873b97ef6caeb33b3335f0e3c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7afe286b32d866128d542bd8a733c4f21bd2206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7afe286b32d866128d542bd8a733c4f21bd2206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7afe286b32d866128d542bd8a733c4f21bd2206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7afe286b32d866128d542bd8a733c4f21bd2206/comments", "author": null, "committer": null, "parents": [{"sha": "cd2b7af02951e96f1a436d6b5584267e49259930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd2b7af02951e96f1a436d6b5584267e49259930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd2b7af02951e96f1a436d6b5584267e49259930"}], "stats": {"total": 150, "additions": 126, "deletions": 24}, "files": [{"sha": "3af84d00cb148598cac7308d939e112fffcd2c07", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -1,3 +1,11 @@\n+2004-04-12  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* class.c (get_interface_method_index): New function. Return dispatch \n+\tindex for interface method.\n+\t(make_method_value): For interface methods, set index field to\n+\tiface dispatch index, not DECL_VINDEX.\n+\t* expr.c (build_invokeinterface): Use get_interface_method_index.\n+\n 2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* jcf-write.c (generate_bytecode_insns): Use TYPE_UNSIGNED."}, {"sha": "3ba60bd509ee709cf65a25d60b205232fb3068df", "filename": "gcc/java/class.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -1246,10 +1246,15 @@ make_method_value (tree mdecl)\n   tree minit;\n   tree index;\n   tree code;\n+  tree class_decl;\n #define ACC_TRANSLATED          0x4000\n   int accflags = get_access_flags_from_decl (mdecl) | ACC_TRANSLATED;\n-\n-  if (!flag_indirect_dispatch && DECL_VINDEX (mdecl) != NULL_TREE)\n+  \n+  class_decl = DECL_CONTEXT (mdecl);\n+  /* For interfaces, the index field contains the dispatch index. */\n+  if (CLASS_INTERFACE (TYPE_NAME (class_decl)))\n+    index = build_int_2 (get_interface_method_index (mdecl, class_decl), 0);\n+  else if (!flag_indirect_dispatch && DECL_VINDEX (mdecl) != NULL_TREE)\n     index = DECL_VINDEX (mdecl);\n   else\n     index = integer_minus_one_node;\n@@ -2133,6 +2138,23 @@ layout_class_methods (tree this_class)\n   TYPE_NVIRTUALS (this_class) = dtable_count;\n }\n \n+/* Return the index of METHOD in INTERFACE.  This index begins at 1 and is used as an\n+   argument for _Jv_LookupInterfaceMethodIdx(). */\n+int\n+get_interface_method_index (tree method, tree interface)\n+{\n+  tree meth;\n+  int i = 1;\n+\n+  for (meth = TYPE_METHODS (interface); ; meth = TREE_CHAIN (meth), i++)\n+    {\n+      if (meth == method)\n+\treturn i;\n+      if (meth == NULL_TREE)\n+\tabort ();\n+    }\n+}\n+\n /* Lay METHOD_DECL out, returning a possibly new value of\n    DTABLE_COUNT. Also mangle the method's name. */\n "}, {"sha": "79a3f4ddd2c7b13fdc94f39c3a729deaa1073f06", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -1974,17 +1974,7 @@ build_invokeinterface (tree dtable, tree method)\n     }\n   else\n     {\n-      i = 1;\n-      for (meth = TYPE_METHODS (interface); ; meth = TREE_CHAIN (meth), i++)\n-\t{\n-\t  if (meth == method)\n-            {\n-\t      idx = build_int_2 (i, 0);\n-\t      break;\n-\t    }\n-\t  if (meth == NULL_TREE)\n-\t    abort ();\n-\t}\n+      idx = build_int_2 (get_interface_method_index (method, interface), 0);\n     }\n \n   lookup_arg = tree_cons (NULL_TREE, dtable,"}, {"sha": "8a9f9a9b887ad472dd57bd9846e15777f230bdad", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -1149,6 +1149,7 @@ extern tree unmangle_classname (const char *name, int name_length);\n extern tree parse_signature_string (const unsigned char *, int);\n extern tree get_type_from_signature (tree);\n extern void layout_class (tree);\n+extern int get_interface_method_index (tree, tree);\n extern tree layout_class_method (tree, tree, tree, tree);\n extern void layout_class_methods (tree);\n extern tree build_class_ref (tree);"}, {"sha": "297bd7066cbcfb30cb43146533deedaceb18da9e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -1,3 +1,13 @@\n+2004-04-14  Andrew Haley  <aph@redhat.com>\n+            Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Use\n+\t_Jv_LookupInterfaceMethodIdx for calls to interfaces.\n+\t* include/jvm.h (_Jv_CallAnyMethodA): Add new `iface' arg.\n+\n+\t* testsuite/libjava.lang/InvokeInterface.java: New file.\n+\t* testsuite/libjava.lang/InvokeInterface.out: New file.\n+\n 2004-04-09  Ranjit Mathew  <rmathew@hotmail.com>\n \t\n \t* java/lang/VMThrowable.java (getStackTrace): Pass trace as-is to"}, {"sha": "398f854e7836186c7ea0053391367e2b59ddb693", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -422,7 +422,8 @@ extern jboolean _Jv_CheckAccess (jclass self_klass, jclass other_klass,\n extern jobject _Jv_CallAnyMethodA (jobject obj, jclass return_type,\n \t\t\t\t   jmethodID meth, jboolean is_constructor,\n \t\t\t\t   JArray<jclass> *parameter_types,\n-\t\t\t\t   jobjectArray args);\n+\t\t\t\t   jobjectArray args,\n+\t\t\t\t   jclass iface = NULL);\n \n union jvalue;\n extern void _Jv_CallAnyMethodA (jobject obj,\n@@ -433,7 +434,8 @@ extern void _Jv_CallAnyMethodA (jobject obj,\n \t\t\t\tJArray<jclass> *parameter_types,\n \t\t\t\tjvalue *args,\n \t\t\t\tjvalue *result,\n-\t\t\t\tjboolean is_jni_call = true);\n+\t\t\t\tjboolean is_jni_call = true,\n+\t\t\t\tjclass iface = NULL);\n \n extern jobject _Jv_NewMultiArray (jclass, jint ndims, jint* dims)\n   __attribute__((__malloc__));"}, {"sha": "96d293bf2410e881c121bfb7f5d81f41652ce068", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -143,14 +143,14 @@ jobject\n java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n {\n   using namespace java::lang::reflect;\n+  jclass iface = NULL;\n   \n   if (parameter_types == NULL)\n     getType ();\n     \n   jmethodID meth = _Jv_FromReflectedMethod (this);\n-\n   jclass objClass;\n-  \n+\n   if (Modifier::isStatic(meth->accflags))\n     {\n       // We have to initialize a static class.  It is safe to do this\n@@ -188,8 +188,11 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n \tthrow new IllegalAccessException;\n     }\n \n+  if (declaringClass->isInterface())\n+    iface = declaringClass;\n+  \n   return _Jv_CallAnyMethodA (obj, return_type, meth, false,\n-\t\t\t     parameter_types, args);\n+\t\t\t     parameter_types, args, iface);\n }\n \n jint\n@@ -341,7 +344,8 @@ _Jv_CallAnyMethodA (jobject obj,\n \t\t    JArray<jclass> *parameter_types,\n \t\t    jvalue *args,\n \t\t    jvalue *result,\n-\t\t    jboolean is_jni_call)\n+\t\t    jboolean is_jni_call,\n+\t\t    jclass iface)\n {\n   using namespace java::lang::reflect;\n   \n@@ -478,7 +482,10 @@ _Jv_CallAnyMethodA (jobject obj,\n       && (_Jv_ushort)-1 != meth->index)\n     {\n       _Jv_VTable *vtable = *(_Jv_VTable **) obj;\n-      ncode = vtable->get_method (meth->index);\n+      if (iface == NULL)\n+\tncode = vtable->get_method (meth->index);\n+      else\n+\tncode = _Jv_LookupInterfaceMethodIdx (vtable->clas, iface, meth->index);\n     }\n   else\n     {\n@@ -553,7 +560,8 @@ _Jv_CallAnyMethodA (jobject obj,\n \t\t    jmethodID meth,\n \t\t    jboolean is_constructor,\n \t\t    JArray<jclass> *parameter_types,\n-\t\t    jobjectArray args)\n+\t\t    jobjectArray args,\n+\t\t    jclass iface)\n {\n   if (parameter_types->length == 0 && args == NULL)\n     {\n@@ -621,7 +629,7 @@ _Jv_CallAnyMethodA (jobject obj,\n   _Jv_CallAnyMethodA (obj, return_type, meth, is_constructor,\n   \t\t      _Jv_isVirtualMethod (meth),\n \t\t      parameter_types, argvals, &ret_value,\n-\t\t      false);\n+\t\t      false, iface);\n \n   jobject r;\n #define VAL(Wrapper, Field)  (new Wrapper (ret_value.Field))"}, {"sha": "21c86dd9d018e0d76fa5f61e01910c463cc50314", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "6f4dc617d39fa14a55df487f8a59d1920b830d0e", "filename": "libjava/testsuite/libjava.lang/InvokeInterface.java", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Ftestsuite%2Flibjava.lang%2FInvokeInterface.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Ftestsuite%2Flibjava.lang%2FInvokeInterface.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FInvokeInterface.java?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -0,0 +1,55 @@\n+import java.lang.reflect.*;\n+\n+interface one\n+{\n+  int n(int N);\n+}\n+\n+interface two\n+{\n+  int nn(int N);\n+}\n+\n+interface three\n+{\n+  int nnn(int N);\n+}\n+\n+class arse implements one, two\n+{\n+  public int n(int N) { return N; }\n+  public int nn(int N) { return N*2; }\n+}\n+\n+class arsey implements two, one, three\n+{\n+  public int n(int N) { return N*4; }\n+  public int nn(int N) { return N*8; }\n+  public int nnn(int N) { return N*16; }\n+}\n+\n+public class InvokeInterface extends arse\n+{\n+  int f ()\n+  {\n+\treturn flunk.nn(1);\n+  }\n+  static two flunk = new arse();\n+  static three flunkey = new arsey();\n+  public static void main(String[] s) throws Throwable\n+  {\n+\tClass[] argtypes = {Integer.TYPE};\n+\tMethod m = two.class.getMethod(\"nn\", argtypes);\n+\tObject[] args = {new Integer(1)};\n+\tSystem.out.println(flunk.nn(1));\n+\tSystem.out.println(m.invoke(new arse(), args));\n+\tm = arse.class.getMethod(\"nn\", argtypes);\n+\tSystem.out.println(m.invoke(new arse(), args));\n+\tm = two.class.getMethod(\"nn\", argtypes);\n+\tSystem.out.println(m.invoke(new arsey(), args));\n+\tm = three.class.getMethod(\"nnn\", argtypes);\n+\tSystem.out.println(m.invoke(new arsey(), args));\t\n+\tm = arsey.class.getMethod(\"nnn\", argtypes);\n+\tSystem.out.println(m.invoke(new arsey(), args));\t\n+  }\n+}"}, {"sha": "803d02666a22e0a2083ad98c5741faab351edbed", "filename": "libjava/testsuite/libjava.lang/InvokeInterface.out", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Ftestsuite%2Flibjava.lang%2FInvokeInterface.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7afe286b32d866128d542bd8a733c4f21bd2206/libjava%2Ftestsuite%2Flibjava.lang%2FInvokeInterface.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FInvokeInterface.out?ref=d7afe286b32d866128d542bd8a733c4f21bd2206", "patch": "@@ -0,0 +1,6 @@\n+2\n+2\n+2\n+8\n+16\n+16"}]}