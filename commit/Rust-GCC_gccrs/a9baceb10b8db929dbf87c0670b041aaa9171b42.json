{"sha": "a9baceb10b8db929dbf87c0670b041aaa9171b42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTliYWNlYjEwYjhkYjkyOWRiZjg3YzA2NzBiMDQxYWFhOTE3MWI0Mg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-12-09T01:57:45Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-12-09T01:57:45Z"}, "message": "re PR target/11848 ([darwin] [no support for 128 doubles] internal compiler error for -mlong-double-128)\n\n\tPR target/11848\n\t* rs6000.h (CANNOT_CHANGE_MODE_CLASS): Allow change of mode\n\tin floating-point registers between TFmode and DImode.\n\t* rs6000.c (rs6000_emit_move): Split moves early.\n\t(secondary_reload_class): Random Whitespace Change.\n\t(rs6000_split_multireg_move): Support moves involving FP registers.\n\tEmit instructions directly.\n\t* rs6000-protos.h (rs6000_split_multireg_move): Update prototype.\n\t* altivec.md: Update for changes to rs6000_split_multireg_move.\n\t* rs6000.md: Update for changes to rs6000_split_multireg_move.\n\t(movtf_internal): Support moves to/from GPRs.\n\nFrom-SVN: r74454", "tree": {"sha": "a42d7b7b99c57a76ad67255b112d715ef171c90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a42d7b7b99c57a76ad67255b112d715ef171c90e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9baceb10b8db929dbf87c0670b041aaa9171b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9baceb10b8db929dbf87c0670b041aaa9171b42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9baceb10b8db929dbf87c0670b041aaa9171b42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9baceb10b8db929dbf87c0670b041aaa9171b42/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86b40947201d0457c50072eb6443ce09b68d5acc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b40947201d0457c50072eb6443ce09b68d5acc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b40947201d0457c50072eb6443ce09b68d5acc"}], "stats": {"total": 460, "additions": 156, "deletions": 304}, "files": [{"sha": "113bdcb0ceaffe17765410b837e30b417713c01f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9baceb10b8db929dbf87c0670b041aaa9171b42", "patch": "@@ -1,3 +1,17 @@\n+2003-12-08  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tPR target/11848\n+\t* rs6000.h (CANNOT_CHANGE_MODE_CLASS): Allow change of mode\n+\tin floating-point registers between TFmode and DImode.\n+\t* rs6000.c (rs6000_emit_move): Split moves early.\n+\t(secondary_reload_class): Random Whitespace Change.\n+\t(rs6000_split_multireg_move): Support moves involving FP registers.\n+\tEmit instructions directly.\n+\t* rs6000-protos.h (rs6000_split_multireg_move): Update prototype.\n+\t* altivec.md: Update for changes to rs6000_split_multireg_move.\n+\t* rs6000.md: Update for changes to rs6000_split_multireg_move.\n+\t(movtf_internal): Support moves to/from GPRs.\n+\n 2003-12-08  Stuart Hastings  <stuart@apple.com>\n \n \t* config/i386/i386.md: Typo in split of fp-valued if_then_else."}, {"sha": "73d0417771dfaab866121cb9f6254f941fdd922d", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 12, "deletions": 76, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=a9baceb10b8db929dbf87c0670b041aaa9171b42", "patch": "@@ -113,26 +113,10 @@\n (define_split\n   [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V4SI 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+  \"TARGET_ALTIVEC && reload_completed\n    && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:V4SI 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 6))\n-   (set (match_dup 3) (match_dup 7))\n-   (set (match_dup 4) (match_dup 8))\n-   (set (match_dup 5) (match_dup 9))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_split\n   [(set (match_operand:V4SI 0 \"altivec_register_operand\" \"\")\n@@ -175,26 +159,10 @@\n (define_split\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V8HI 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+  \"TARGET_ALTIVEC && reload_completed\n    && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:V8HI 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 6))\n-   (set (match_dup 3) (match_dup 7))\n-   (set (match_dup 4) (match_dup 8))\n-   (set (match_dup 5) (match_dup 9))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_split\n   [(set (match_operand:V8HI 0 \"altivec_register_operand\" \"\")\n@@ -237,26 +205,10 @@\n (define_split\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V16QI 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+  \"TARGET_ALTIVEC && reload_completed\n    && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:V16QI 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 6))\n-   (set (match_dup 3) (match_dup 7))\n-   (set (match_dup 4) (match_dup 8))\n-   (set (match_dup 5) (match_dup 9))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_split\n   [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"\")\n@@ -299,26 +251,10 @@\n (define_split\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V4SF 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+  \"TARGET_ALTIVEC && reload_completed\n    && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:V4SF 1 \"input_operand\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 6))\n-   (set (match_dup 3) (match_dup 7))\n-   (set (match_dup 4) (match_dup 8))\n-   (set (match_dup 5) (match_dup 9))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_insn \"get_vrsave_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}, {"sha": "79679f44a6cc62ba2263ab362945a65ab5964fb3", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=a9baceb10b8db929dbf87c0670b041aaa9171b42", "patch": "@@ -125,7 +125,7 @@ extern int mfcr_operation (rtx, enum machine_mode);\n extern int mtcrf_operation (rtx, enum machine_mode);\n extern int lmw_operation (rtx, enum machine_mode);\n extern struct rtx_def *create_TOC_reference (rtx);\n-extern void rs6000_split_multireg_move (rtx *);\n+extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,"}, {"sha": "647469f6ef735e6bc1eaa86ff552f964f2e38e96", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 100, "deletions": 81, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a9baceb10b8db929dbf87c0670b041aaa9171b42", "patch": "@@ -3457,7 +3457,26 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n   /* Handle the case of CONSTANT_P_RTX.  */\n   if (GET_CODE (operands[1]) == CONSTANT_P_RTX)\n     goto emit_set;\n-  \n+\n+  /* 128-bit constant floating-point values on Darwin should really be\n+     loaded as two parts.  */\n+  if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n+      && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\n+      && mode == TFmode && GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      /* DImode is used, not DFmode, because simplify_gen_subreg doesn't\n+\t know how to get a DFmode SUBREG of a TFmode.  */\n+      rs6000_emit_move (simplify_gen_subreg (DImode, operands[0], mode, 0),\n+\t\t\tsimplify_gen_subreg (DImode, operands[1], mode, 0),\n+\t\t\tDImode);\n+      rs6000_emit_move (simplify_gen_subreg (DImode, operands[0], mode,\n+\t\t\t\t\t     GET_MODE_SIZE (DImode)),\n+\t\t\tsimplify_gen_subreg (DImode, operands[1], mode,\n+\t\t\t\t\t     GET_MODE_SIZE (DImode)),\n+\t\t\tDImode);\n+      return;\n+    }\n+\n   /* FIXME:  In the long term, this switch statement should go away\n      and be replaced by a sequence of tests based on things like\n      mode == Pmode.  */\n@@ -8302,7 +8321,8 @@ addrs_ok_for_quad_peep (rtx addr1, rtx addr2)\n \n enum reg_class\n secondary_reload_class (enum reg_class class, \n-\t\tenum machine_mode mode ATTRIBUTE_UNUSED, rtx in)\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\trtx in)\n {\n   int regno;\n \n@@ -10007,73 +10027,72 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n     emit_move_insn (dest, target);\n }\n \n-/* Called by splitter for multireg moves.\n-   Input: \n-          operands[0] : Destination of move\n-          operands[1] : Source of move\n-\n-   Output:\n-\t  operands[2-n] : Destination slots\n-\t  operands[n-m] : Source slots\n-   where n = 2 + HARD_REGNO_NREGS (reg, GET_MODE (operands[0]))\n-         m = 2 + 2 * HARD_REGNO_NREGS (reg, GET_MODE (operands[0])) - 1\n+/* Emit instructions to move SRC to DST.  Called by splitters for\n+   multi-register moves.  It will emit at most one instruction for\n+   each register that is accessed; that is, it won't emit li/lis pairs\n+   (or equivalent for 64-bit code).  One of SRC or DST must be a hard\n+   register.  */\n \n-   Splits the move of operands[1] to operands[0].\n-   This is done, if GPRs are one of the operands.  In this case\n-   a sequence of simple move insns has to be issued.  The sequence of these\n-   move insns has to be done in correct order to avoid early clobber of the\n-   base register or destructive overlap of registers. \n-*/\n-\t  \n void\n-rs6000_split_multireg_move (rtx *operands)\n+rs6000_split_multireg_move (rtx dst, rtx src)\n {\n-  int nregs, reg, i, j, used_update = 0;\n-  enum machine_mode mode; \n-  rtx dst = operands[0];\n-  rtx src = operands[1];\n-  rtx insn = 0;\n-\n-  /* Calculate number to move (2/4 for 32/64 bit mode).  */ \n-\n-  reg = REG_P (operands[0]) ? REGNO (operands[0]) : REGNO (operands[1]); \n-  mode = GET_MODE (operands[0]);\n-  nregs = HARD_REGNO_NREGS (reg, mode);                                  \n+  /* The register number of the first register being moved.  */\n+  int reg;\n+  /* The mode that is to be moved.  */\n+  enum machine_mode mode;\n+  /* The mode that the move is being done in, and its size.  */\n+  enum machine_mode reg_mode;\n+  int reg_mode_size;\n+  /* The number of registers that will be moved.  */\n+  int nregs;\n+\n+  reg = REG_P (dst) ? REGNO (dst) : REGNO (src);\n+  mode = GET_MODE (dst);\n+  nregs = HARD_REGNO_NREGS (reg, mode);\n+  if (FP_REGNO_P (reg))\n+    reg_mode = DFmode;\n+  else if (ALTIVEC_REGNO_P (reg))\n+    reg_mode = V16QImode;\n+  else\n+    reg_mode = word_mode;\n+  reg_mode_size = GET_MODE_SIZE (reg_mode);\n   \n-  if (REG_P (operands[1]) \n-      && REG_P (operands[0]) \n-      && (REGNO (operands[1]) < REGNO (operands[0])))\n-    {  \n-      /* Move register range backwards, if we have destructive overlap.  */\n-\n-      j = nregs;\n-      for (i = 0; i < nregs; i++)\n-        {\n-          j--;\n-          operands[i+2] = operand_subword (operands[0], j, 0, mode);\n-          operands[i+2+nregs] = \n-            operand_subword (operands[1], j, 0, mode);   \n-        }\n-    }     \n+  if (reg_mode_size * nregs != GET_MODE_SIZE (mode))\n+    abort ();\n+  \n+  if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n+    {\n+      /* Move register range backwards, if we might have destructive\n+\t overlap.  */\n+      int i;\n+      for (i = nregs - 1; i >= 0; i--)\n+\temit_insn (gen_rtx_SET (VOIDmode, \n+\t\t\t\tsimplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t\t     i * reg_mode_size),\n+\t\t\t\tsimplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t\t     i * reg_mode_size)));\n+    }\n   else\n     {\n-      j = -1;\n+      int i;\n+      int j = -1;\n+      bool used_update = false;\n \n-      if (GET_CODE (operands[1]) == MEM)\n+      if (GET_CODE (src) == MEM && INT_REGNO_P (reg))\n         {\n           rtx breg;\n \n-\t  if (GET_CODE (XEXP (operands[1], 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+\t  if (GET_CODE (XEXP (src, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (src, 0)) == PRE_DEC)\n \t    {\n \t      rtx delta_rtx;\n-\t      breg = XEXP (XEXP (operands[1], 0), 0);\n-\t      delta_rtx =  GET_CODE (XEXP (operands[1], 0)) == PRE_INC \n-\t\t  ? GEN_INT (GET_MODE_SIZE (GET_MODE (operands[1]))) \n-\t\t  : GEN_INT (-GET_MODE_SIZE (GET_MODE (operands[1]))); \n-\t      insn = emit_insn (TARGET_32BIT\n-\t\t\t\t? gen_addsi3 (breg, breg, delta_rtx)\n-\t\t\t\t: gen_adddi3 (breg, breg, delta_rtx));\n+\t      breg = XEXP (XEXP (src, 0), 0);\n+\t      delta_rtx =  GET_CODE (XEXP (src, 0)) == PRE_INC \n+\t\t  ? GEN_INT (GET_MODE_SIZE (GET_MODE (src))) \n+\t\t  : GEN_INT (-GET_MODE_SIZE (GET_MODE (src))); \n+\t      emit_insn (TARGET_32BIT\n+\t\t\t ? gen_addsi3 (breg, breg, delta_rtx)\n+\t\t\t : gen_adddi3 (breg, breg, delta_rtx));\n \t      src = gen_rtx_MEM (mode, breg);\n \t    }\n \n@@ -10093,35 +10112,34 @@ rs6000_split_multireg_move (rtx *operands)\n \t    j = REGNO (breg) - REGNO (dst);\n         }\n \n-      if (GET_CODE (operands[0]) == MEM)\n+      if (GET_CODE (dst) == MEM && INT_REGNO_P (reg))\n \t{\n \t  rtx breg;\n \n-\t  if (GET_CODE (XEXP (operands[0], 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+\t  if (GET_CODE (XEXP (dst, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (dst, 0)) == PRE_DEC)\n \t    {\n \t      rtx delta_rtx;\n-\t      breg = XEXP (XEXP (operands[0], 0), 0);\n-\t      delta_rtx = GET_CODE (XEXP (operands[0], 0)) == PRE_INC \n-\t\t? GEN_INT (GET_MODE_SIZE (GET_MODE (operands[0]))) \n-\t\t: GEN_INT (-GET_MODE_SIZE (GET_MODE (operands[0]))); \n+\t      breg = XEXP (XEXP (dst, 0), 0);\n+\t      delta_rtx = GET_CODE (XEXP (dst, 0)) == PRE_INC \n+\t\t? GEN_INT (GET_MODE_SIZE (GET_MODE (dst))) \n+\t\t: GEN_INT (-GET_MODE_SIZE (GET_MODE (dst))); \n \n \t      /* We have to update the breg before doing the store.\n \t\t Use store with update, if available.  */\n \n \t      if (TARGET_UPDATE)\n \t\t{\n-\t\t  insn = emit_insn (TARGET_32BIT\n-\t\t\t\t    ? gen_movsi_update (breg, breg, delta_rtx, \n-\t\t\t\t\toperand_subword (src, 0, 0, mode))\n-\t\t\t\t    : gen_movdi_update (breg, breg, delta_rtx,\n-\t\t\t\t\toperand_subword (src, 0, 0, mode)));\n-\t\t  used_update = 1;\n+\t\t  rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n+\t\t  emit_insn (TARGET_32BIT\n+\t\t\t     ? gen_movsi_update (breg, breg, delta_rtx, nsrc)\n+\t\t\t     : gen_movdi_update (breg, breg, delta_rtx, nsrc));\n+\t\t  used_update = true;\n \t\t}\n \t      else\n-\t\t  insn = emit_insn (TARGET_32BIT\n-\t\t\t\t    ? gen_addsi3 (breg, breg, delta_rtx)\n-\t\t\t\t    : gen_adddi3 (breg, breg, delta_rtx));\n+\t\temit_insn (TARGET_32BIT\n+\t\t\t   ? gen_addsi3 (breg, breg, delta_rtx)\n+\t\t\t   : gen_adddi3 (breg, breg, delta_rtx));\n \t      dst = gen_rtx_MEM (mode, breg);\n \t    }\n \t}\n@@ -10133,15 +10151,16 @@ rs6000_split_multireg_move (rtx *operands)\n \t  if (j == nregs) \n \t    j = 0;\n \n-\t  operands[i+2] = operand_subword (dst, j, 0, mode);\n-\t  operands[i+2+nregs] = operand_subword (src, j, 0, mode);\n-\n+\t  /* If compiler already emited move of first word by \n+\t     store with update, no need to do anything.  */\n \t  if (j == 0 && used_update)\n-\t    {\n-\t      /* Already emited move of first word by \n-\t\t store with update -> emit dead insn instead (r := r).  */\n-\t      operands[i+2] = operands[i+2+nregs];\n-\t    }\n+\t    continue;\n+\t  \n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  simplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t\t       j * reg_mode_size),\n+\t\t\t\t  simplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t\t       j * reg_mode_size)));\n \t}\n     }\n }"}, {"sha": "761873dc63e72d45a53ef27586b0104548933560", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a9baceb10b8db929dbf87c0670b041aaa9171b42", "patch": "@@ -1480,11 +1480,14 @@ enum reg_class\n \n /* Return a class of registers that cannot change FROM mode to TO mode.  */\n \n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\t\\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t\t\\\n-   ? reg_classes_intersect_p (FLOAT_REGS, CLASS)\t\t\t\\\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\t  \\\n+  (((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\t\t  \\\n+    && GET_MODE_SIZE (FROM) >= 8 && GET_MODE_SIZE (TO) >= 8)\t\t  \\\n+   ? 0\t\t\t\t\t\t\t\t\t  \\\n+   : GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t\t  \\\n+   ? reg_classes_intersect_p (FLOAT_REGS, CLASS)\t\t\t  \\\n    : (TARGET_SPE && (SPE_VECTOR_MODE (FROM) + SPE_VECTOR_MODE (TO)) == 1) \\\n-   ? reg_classes_intersect_p (GENERAL_REGS, CLASS) \t\t\t\\\n+   ? reg_classes_intersect_p (GENERAL_REGS, CLASS)\t\t\t  \\\n    : 0)\n \n /* Stack layout; function entry, exit and calling.  */"}, {"sha": "50c3595d8fd260484defe5dc8715fea3d9dbbcbe", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 16, "deletions": 142, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a9baceb10b8db929dbf87c0670b041aaa9171b42", "patch": "@@ -8206,110 +8206,21 @@\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n   \"{ rs6000_emit_move (operands[0], operands[1], TFmode); DONE; }\")\n \n-(define_insn \"*movtf_internal\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,f,m,!r,!r,!r\")\n-\t(match_operand:TF 1 \"input_operand\" \"f,m,f,G,H,F\"))]\n+; It's important to list the o->f and f->o moves before f->f because\n+; otherwise reload, given m->f, will try to pick f->f and reload it,\n+; which doesn't make progress.\n+(define_insn_and_split \"*movtf_internal\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=o,f,f,rm,r\")\n+\t(match_operand:TF 1 \"input_operand\"         \"f,o,f,r,mGHF\"))]\n   \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\n    && (gpc_reg_operand (operands[0], TFmode)\n        || gpc_reg_operand (operands[1], TFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      abort ();\n-    case 0:\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"fmr %L0,%L1\\;fmr %0,%1\\\";\n-      else\n-\treturn \\\"fmr %0,%1\\;fmr %L0,%L1\\\";\n-    case 1:\n-      return \\\"lfd %0,%1\\;lfd %L0,%Y1\\\";\n-    case 2:\n-      return \\\"stfd %1,%0\\;stfd %L1,%Y0\\\";\n-    case 3:\n-    case 4:\n-    case 5:\n-      return \\\"#\\\";\n-    }\n-}\"\n-  [(set_attr \"type\" \"fp,fpload,fpstore,*,*,*\")\n-   (set_attr \"length\" \"8,8,8,12,16,20\")])\n-\n-(define_split\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:TF 1 \"easy_fp_constant\" \"\"))]\n-  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && ! TARGET_POWERPC64\n-   && TARGET_LONG_DOUBLE_128 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 6))\n-   (set (match_dup 3) (match_dup 7))\n-   (set (match_dup 4) (match_dup 8))\n-   (set (match_dup 5) (match_dup 9))]\n-  \"\n-{\n-  long l[4];\n-  REAL_VALUE_TYPE rv;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, l);\n-\n-  operands[2] = operand_subword (operands[0], 0, 0, TFmode);\n-  operands[3] = operand_subword (operands[0], 1, 0, TFmode);\n-  operands[4] = operand_subword (operands[0], 2, 0, TFmode);\n-  operands[5] = operand_subword (operands[0], 3, 0, TFmode);\n-  operands[6] = gen_int_mode (l[0], SImode);\n-  operands[7] = gen_int_mode (l[1], SImode);\n-  operands[8] = gen_int_mode (l[2], SImode);\n-  operands[9] = gen_int_mode (l[3], SImode);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:TF 1 \"easy_fp_constant\" \"\"))]\n-  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64\n-   && TARGET_LONG_DOUBLE_128 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-  \"\n-{\n-  long l[4];\n-  REAL_VALUE_TYPE rv;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  HOST_WIDE_INT val;\n-#endif\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, l);\n-\n-  operands[2] = gen_lowpart (DImode, operands[0]);\n-  operands[3] = gen_highpart (DImode, operands[0]);\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  val = ((HOST_WIDE_INT)(unsigned long)l[0] << 32\n-         | ((HOST_WIDE_INT)(unsigned long)l[1]));\n-  operands[4] = gen_int_mode (val, DImode);\n-\n-  val = ((HOST_WIDE_INT)(unsigned long)l[2] << 32\n-         | ((HOST_WIDE_INT)(unsigned long)l[3]));\n-  operands[5] = gen_int_mode (val, DImode);\n-#else\n-  operands[4] = immed_double_const (l[1], l[0], DImode);\n-  operands[5] = immed_double_const (l[3], l[2], DImode);\n-#endif\n-}\")\n+  \"#\"\n+  \"reload_completed\"\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+  [(set_attr \"length\" \"8,8,8,20,20\")])\n \n (define_insn \"extenddftf2\"\n   [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n@@ -8526,32 +8437,13 @@\n #endif\n }\")\n \n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT == 32 && ! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-  \"\n-{\n-  operands[2] = operand_subword_force (operands[0], WORDS_BIG_ENDIAN == 0,\n-\t\t\t\t       DImode);\n-  operands[3] = operand_subword_force (operands[0], WORDS_BIG_ENDIAN != 0,\n-\t\t\t\t       DImode);\n-  operands[4] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-  operands[5] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n-}\")\n-\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"input_operand\" \"\"))]\n   \"reload_completed && !TARGET_POWERPC64 \n    && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_split\n   [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n@@ -8780,28 +8672,10 @@\n (define_split\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TI 1 \"input_operand\" \"\"))]\n-  \"reload_completed && TARGET_POWERPC64 \n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:TI 1 \"input_operand\" \"\"))]\n-  \"reload_completed && !TARGET_POWERPC64 \n+  \"reload_completed\n    && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(set (match_dup 2) (match_dup 6))\n-   (set (match_dup 3) (match_dup 7))\n-   (set (match_dup 4) (match_dup 8))\n-   (set (match_dup 5) (match_dup 9))]\n-\"{\n-     rs6000_split_multireg_move (operands);\n-}\")\n-\n-\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \f\n (define_expand \"load_multiple\"\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")"}, {"sha": "02586dfe1c0a7b9be9326ac8ec5ec6bf7b450dbc", "filename": "gcc/testsuite/gcc.c-torture/compile/20031208-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031208-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9baceb10b8db929dbf87c0670b041aaa9171b42/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031208-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031208-1.c?ref=a9baceb10b8db929dbf87c0670b041aaa9171b42", "patch": "@@ -0,0 +1,6 @@\n+extern int foo(int, ...);\n+int bar(void) {\n+  long double l = 1.2345E6;\n+  foo(0, l);\n+  return 0;\n+}"}]}