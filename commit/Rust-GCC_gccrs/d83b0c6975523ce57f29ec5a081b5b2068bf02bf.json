{"sha": "d83b0c6975523ce57f29ec5a081b5b2068bf02bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgzYjBjNjk3NTUyM2NlNTdmMjllYzVhMDgxYjViMjA2OGJmMDJiZg==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-05-10T12:45:30Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-05-10T12:45:30Z"}, "message": "testsuite/arm: Add mve-vsub-scalar-1.c test\n\nThis patchs adds a test similar to mve-vsub_1.c, but operates on a\nscalar as second argument. For the moment we do not select the T2 vsub\nvariant operating on a scalar final argument, and we use vadd of the\nopposite.\n\n2021-05-10  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/testsuite/\n\t* gcc.target/arm/simd/mve-vsub-scalar-1.c: New test.", "tree": {"sha": "040ffbc2f9a634874266b2437f38db3de89d6154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/040ffbc2f9a634874266b2437f38db3de89d6154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d83b0c6975523ce57f29ec5a081b5b2068bf02bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83b0c6975523ce57f29ec5a081b5b2068bf02bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d83b0c6975523ce57f29ec5a081b5b2068bf02bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83b0c6975523ce57f29ec5a081b5b2068bf02bf/comments", "author": null, "committer": null, "parents": [{"sha": "c1d381f0079a8594957be0513a00627caa219b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1d381f0079a8594957be0513a00627caa219b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1d381f0079a8594957be0513a00627caa219b73"}], "stats": {"total": 47, "additions": 47, "deletions": 0}, "files": [{"sha": "61a9a0e046a48f18c74a5a5d40660c1b6e768f04", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vsub-scalar-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d83b0c6975523ce57f29ec5a081b5b2068bf02bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vsub-scalar-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d83b0c6975523ce57f29ec5a081b5b2068bf02bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vsub-scalar-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vsub-scalar-1.c?ref=d83b0c6975523ce57f29ec5a081b5b2068bf02bf", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+#define FUNC_IMM(SIGN, TYPE, BITS, NB, OP, NAME)\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS ## x ## NB (TYPE##BITS##_t * __restrict__ dest, \\\n+\t\t\t\t\t\t     TYPE##BITS##_t *a) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i<NB; i++) {\t\t\t\t\t\t\\\n+      dest[i] = a[i] OP 1;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* 128-bit vectors.  */\n+FUNC_IMM(s, int, 32, 4, -, vsubimm)\n+FUNC_IMM(u, uint, 32, 4, -, vsubimm)\n+FUNC_IMM(s, int, 16, 8, -, vsubimm)\n+FUNC_IMM(u, uint, 16, 8, -, vsubimm)\n+FUNC_IMM(s, int, 8, 16, -, vsubimm)\n+FUNC_IMM(u, uint, 8, 16, -, vsubimm)\n+\n+/* For the moment we do not select the T2 vsub variant operating on a scalar\n+   final argument, and we use vadd of the opposite.  */\n+/* { dg-final { scan-assembler-times {vadd\\.i32  q[0-9]+, q[0-9]+, r[0-9]+} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {vadd\\.i16  q[0-9]+, q[0-9]+, r[0-9]+} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {vadd\\.i8  q[0-9]+, q[0-9]+, r[0-9]+} 2 { xfail *-*-* } } } */\n+\n+void test_vsubimm_f32 (float * dest, float * a) {\n+  int i;\n+  for (i=0; i<4; i++) {\n+    dest[i] = a[i] - 5.0;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vadd\\.f32 q[0-9]+, q[0-9]+, r[0-9]+} 1 { xfail *-*-* } } } */\n+\n+/* Note that dest[i] = a[i] + 5.0f16 is not vectorized.  */\n+void test_vsubimm_f16 (__fp16 * dest, __fp16 * a) {\n+  int i;\n+  __fp16 b = 5.0f16;\n+  for (i=0; i<8; i++) {\n+    dest[i] = a[i] - b;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vadd\\.f16 q[0-9]+, q[0-9]+, r[0-9]+} 1 { xfail *-*-* } } } */"}]}