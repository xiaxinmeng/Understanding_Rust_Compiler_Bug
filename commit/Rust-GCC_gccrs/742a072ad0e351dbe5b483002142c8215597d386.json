{"sha": "742a072ad0e351dbe5b483002142c8215597d386", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQyYTA3MmFkMGUzNTFkYmU1YjQ4MzAwMjE0MmM4MjE1NTk3ZDM4Ng==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-10-03T16:28:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-10-03T16:28:03Z"}, "message": "gcc.c: Split up the driver's \"main\" into smaller functions\n\ngcc/ChangeLog:\n\t* gcc.c (class driver): New class.\n\t(main): Reimplement in terms of driver::main, moving most of the\n\tlocals to be locals within individual methods of class driver.\n\tThe remaining locals \"explicit_link_files\", \"decoded_options\" and\n\t\"decoded_options_count\" are used by multiple driver:: methods, and\n\tso become member data.  Doing so isolates the argc/argv reads and\n\twrites.  Replace \"goto out\" with a special exit code from\n\tnew method driver::prepare_infiles.  Split out the old\n\timplementation of main into the following...\n\t(driver::main): New function, corresponding to the old \"main\"\n\timplementation.\n\t(driver::set_progname): New function, taken from the old\n\t\"main\" implementation.\n\t(driver::expand_at_files): Likewise.\n\t(driver::decode_argv): Likewise.\n\t(driver::global_initializations): Likewise.\n\t(driver::build_multilib_strings): Likewise.\n\t(driver::set_up_specs): Likewise.\n\t(driver::putenv_COLLECT_GCC): Likewise.\n\t(driver::maybe_putenv_COLLECT_LTO_WRAPPER): Likewise.\n\t(driver::handle_unrecognized_options): Likewise.\n\t(driver::maybe_print_and_exit): Likewise.\n\t(driver::prepare_infiles): Likewise.\n\t(driver::do_spec_on_infiles): Likewise.\n\t(driver::maybe_run_linker): Likewise.\n\t(driver::final_actions): Likewise.\n\t(driver::get_exit_code): Likewise.\n\nFrom-SVN: r215861", "tree": {"sha": "615f9978cd919bb37720136d37c5450da39cba5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/615f9978cd919bb37720136d37c5450da39cba5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/742a072ad0e351dbe5b483002142c8215597d386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742a072ad0e351dbe5b483002142c8215597d386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/742a072ad0e351dbe5b483002142c8215597d386", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742a072ad0e351dbe5b483002142c8215597d386/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2bd8ca2100715c6a8b1f7fa1288cf3166898e1fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd8ca2100715c6a8b1f7fa1288cf3166898e1fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bd8ca2100715c6a8b1f7fa1288cf3166898e1fd"}], "stats": {"total": 266, "additions": 231, "deletions": 35}, "files": [{"sha": "8d2521eecbb7f72f3d4f9b1a3e9fe2e84998fa8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742a072ad0e351dbe5b483002142c8215597d386/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742a072ad0e351dbe5b483002142c8215597d386/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=742a072ad0e351dbe5b483002142c8215597d386", "patch": "@@ -1,3 +1,33 @@\n+2014-10-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.c (class driver): New class.\n+\t(main): Reimplement in terms of driver::main, moving most of the\n+\tlocals to be locals within individual methods of class driver.\n+\tThe remaining locals \"explicit_link_files\", \"decoded_options\" and\n+\t\"decoded_options_count\" are used by multiple driver:: methods, and\n+\tso become member data.  Doing so isolates the argc/argv reads and\n+\twrites.  Replace \"goto out\" with a special exit code from\n+\tnew method driver::prepare_infiles.  Split out the old\n+\timplementation of main into the following...\n+\t(driver::main): New function, corresponding to the old \"main\"\n+\timplementation.\n+\t(driver::set_progname): New function, taken from the old\n+\t\"main\" implementation.\n+\t(driver::expand_at_files): Likewise.\n+\t(driver::decode_argv): Likewise.\n+\t(driver::global_initializations): Likewise.\n+\t(driver::build_multilib_strings): Likewise.\n+\t(driver::set_up_specs): Likewise.\n+\t(driver::putenv_COLLECT_GCC): Likewise.\n+\t(driver::maybe_putenv_COLLECT_LTO_WRAPPER): Likewise.\n+\t(driver::handle_unrecognized_options): Likewise.\n+\t(driver::maybe_print_and_exit): Likewise.\n+\t(driver::prepare_infiles): Likewise.\n+\t(driver::do_spec_on_infiles): Likewise.\n+\t(driver::maybe_run_linker): Likewise.\n+\t(driver::final_actions): Likewise.\n+\t(driver::get_exit_code): Likewise.\n+\n 2014-10-03  Yury Gribov  <y.gribov@samsung.com>\n \n \t* asan.c (asan_finish_file): Disable __asan_init calls for KASan;"}, {"sha": "f53b92ffd1276c4bfd8b42bff33de90b80dbfbe8", "filename": "gcc/gcc.c", "status": "modified", "additions": 201, "deletions": 35, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742a072ad0e351dbe5b483002142c8215597d386/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742a072ad0e351dbe5b483002142c8215597d386/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=742a072ad0e351dbe5b483002142c8215597d386", "patch": "@@ -6724,49 +6724,132 @@ compare_files (char *cmpfile[])\n   return ret;\n }\n \n-extern int main (int, char **);\n+/* The top-level \"main\" within the driver would be ~1000 lines long.\n+   This class breaks it up into smaller functions and contains some\n+   state shared by them.  */\n \n-int\n-main (int argc, char **argv)\n+class driver\n {\n-  size_t i;\n-  int value;\n-  int linker_was_run = 0;\n-  int lang_n_infiles = 0;\n-  int num_linker_inputs = 0;\n+ public:\n+  int main (int argc, char **argv);\n+\n+ private:\n+  void set_progname (const char *argv0) const;\n+  void expand_at_files (int *argc, char ***argv) const;\n+  void decode_argv (int argc, const char **argv);\n+  void global_initializations () const;\n+  void build_multilib_strings () const;\n+  void set_up_specs () const;\n+  void putenv_COLLECT_GCC (const char *argv0) const;\n+  void maybe_putenv_COLLECT_LTO_WRAPPER () const;\n+  void handle_unrecognized_options () const;\n+  int maybe_print_and_exit () const;\n+  bool prepare_infiles ();\n+  void do_spec_on_infiles () const;\n+  void maybe_run_linker (const char *argv0) const;\n+  void final_actions () const;\n+  int get_exit_code () const;\n+\n+ private:\n   char *explicit_link_files;\n-  char *specs_file;\n-  char *lto_wrapper_file;\n-  const char *p;\n-  struct user_specs *uptr;\n-  char **old_argv = argv;\n   struct cl_decoded_option *decoded_options;\n   unsigned int decoded_options_count;\n+};\n+\n+/* Implement the top-level \"main\" within the driver in terms of\n+   driver::main.  */\n+\n+extern int main (int, char **);\n \n-  p = argv[0] + strlen (argv[0]);\n-  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))\n+int\n+main (int argc, char **argv)\n+{\n+  driver d;\n+\n+  return d.main (argc, argv);\n+}\n+\n+/* driver::main is implemented as a series of driver:: method calls.  */\n+\n+int\n+driver::main (int argc, char **argv)\n+{\n+  bool early_exit;\n+\n+  set_progname (argv[0]);\n+  expand_at_files (&argc, &argv);\n+  decode_argv (argc, const_cast <const char **> (argv));\n+  global_initializations ();\n+  build_multilib_strings ();\n+  set_up_specs ();\n+  putenv_COLLECT_GCC (argv[0]);\n+  maybe_putenv_COLLECT_LTO_WRAPPER ();\n+  handle_unrecognized_options ();\n+\n+  if (!maybe_print_and_exit ())\n+    return 0;\n+\n+  early_exit = prepare_infiles ();\n+  if (early_exit)\n+    return get_exit_code ();\n+\n+  do_spec_on_infiles ();\n+  maybe_run_linker (argv[0]);\n+  final_actions ();\n+  return get_exit_code ();\n+}\n+\n+/* Locate the final component of argv[0] after any leading path, and set\n+   the program name accordingly.  */\n+\n+void\n+driver::set_progname (const char *argv0) const\n+{\n+  const char *p = argv0 + strlen (argv0);\n+  while (p != argv0 && !IS_DIR_SEPARATOR (p[-1]))\n     --p;\n   progname = p;\n \n   xmalloc_set_program_name (progname);\n+}\n \n-  expandargv (&argc, &argv);\n+/* Expand any @ files within the command-line args,\n+   setting at_file_supplied if any were expanded.  */\n+\n+void\n+driver::expand_at_files (int *argc, char ***argv) const\n+{\n+  char **old_argv = *argv;\n+\n+  expandargv (argc, argv);\n \n   /* Determine if any expansions were made.  */\n-  if (argv != old_argv)\n+  if (*argv != old_argv)\n     at_file_supplied = true;\n+}\n \n+/* Decode the command-line arguments from argc/argv into the\n+   decoded_options array.  */\n+\n+void\n+driver::decode_argv (int argc, const char **argv)\n+{\n   /* Register the language-independent parameters.  */\n   global_init_params ();\n   finish_params ();\n \n   init_options_struct (&global_options, &global_options_set);\n \n-  decode_cmdline_options_to_array (argc, CONST_CAST2 (const char **, char **,\n-\t\t\t\t\t\t      argv),\n+  decode_cmdline_options_to_array (argc, argv,\n \t\t\t\t   CL_DRIVER,\n \t\t\t\t   &decoded_options, &decoded_options_count);\n+}\n+\n+/* Perform various initializations and setup.  */\n \n+void\n+driver::global_initializations () const\n+{\n   /* Unlock the stdio streams.  */\n   unlock_std_streams ();\n \n@@ -6808,10 +6891,16 @@ main (int argc, char **argv)\n   alloc_args ();\n \n   obstack_init (&obstack);\n+}\n+\n+/* Build multilib_select, et. al from the separate lines that make up each\n+   multilib selection.  */\n \n-  /* Build multilib_select, et. al from the separate lines that make up each\n-     multilib selection.  */\n+void\n+driver::build_multilib_strings () const\n+{\n   {\n+    const char *p;\n     const char *const *q = multilib_raw;\n     int need_space;\n \n@@ -6844,7 +6933,7 @@ main (int argc, char **argv)\n     multilib_reuse = XOBFINISH (&multilib_obstack, const char *);\n \n     need_space = FALSE;\n-    for (i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)\n+    for (size_t i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)\n       {\n \tif (need_space)\n \t  obstack_1grow (&multilib_obstack, ' ');\n@@ -6857,6 +6946,15 @@ main (int argc, char **argv)\n     obstack_1grow (&multilib_obstack, 0);\n     multilib_defaults = XOBFINISH (&multilib_obstack, const char *);\n   }\n+}\n+\n+/* Set up the spec-handling machinery.  */\n+\n+void\n+driver::set_up_specs () const\n+{\n+  char *specs_file;\n+  size_t i;\n \n #ifdef INIT_ENVIRONMENT\n   /* Set up any other necessary machine specific environment variables.  */\n@@ -7016,7 +7114,7 @@ main (int argc, char **argv)\n \n   /* Process any user specified specs in the order given on the command\n      line.  */\n-  for (uptr = user_specs_head; uptr; uptr = uptr->next)\n+  for (struct user_specs *uptr = user_specs_head; uptr; uptr = uptr->next)\n     {\n       char *filename = find_a_file (&startfile_prefixes, uptr->filename,\n \t\t\t\t    R_OK, true);\n@@ -7088,16 +7186,27 @@ main (int argc, char **argv)\n   /* Now that we have the switches and the specs, set\n      the subdirectory based on the options.  */\n   set_multilib_dir ();\n+}\n+\n+/* Set up to remember the pathname of gcc and any options\n+   needed for collect.  We use argv[0] instead of progname because\n+   we need the complete pathname.  */\n \n-  /* Set up to remember the pathname of gcc and any options\n-     needed for collect.  We use argv[0] instead of progname because\n-     we need the complete pathname.  */\n+void\n+driver::putenv_COLLECT_GCC (const char *argv0) const\n+{\n   obstack_init (&collect_obstack);\n   obstack_grow (&collect_obstack, \"COLLECT_GCC=\", sizeof (\"COLLECT_GCC=\") - 1);\n-  obstack_grow (&collect_obstack, argv[0], strlen (argv[0]) + 1);\n+  obstack_grow (&collect_obstack, argv0, strlen (argv0) + 1);\n   xputenv (XOBFINISH (&collect_obstack, char *));\n+}\n \n-  /* Set up to remember the pathname of the lto wrapper. */\n+/* Set up to remember the pathname of the lto wrapper. */\n+\n+void\n+driver::maybe_putenv_COLLECT_LTO_WRAPPER () const\n+{\n+  char *lto_wrapper_file;\n \n   if (have_c)\n     lto_wrapper_file = NULL;\n@@ -7116,14 +7225,24 @@ main (int argc, char **argv)\n       xputenv (XOBFINISH (&collect_obstack, char *));\n     }\n \n-  /* Reject switches that no pass was interested in.  */\n+}\n \n-  for (i = 0; (int) i < n_switches; i++)\n+/* Reject switches that no pass was interested in.  */\n+\n+void\n+driver::handle_unrecognized_options () const\n+{\n+  for (size_t i = 0; (int) i < n_switches; i++)\n     if (! switches[i].validated)\n       error (\"unrecognized command line option %<-%s%>\", switches[i].part1);\n+}\n \n-  /* Obey some of the options.  */\n+/* Handle the various -print-* options, returning 0 if the driver\n+   should exit, or nonzero if the driver should continue.  */\n \n+int\n+driver::maybe_print_and_exit () const\n+{\n   if (print_search_dirs)\n     {\n       printf (_(\"install: %s%s\\n\"),\n@@ -7286,11 +7405,24 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \treturn (0);\n     }\n \n+  return 1;\n+}\n+\n+/* Figure out what to do with each input file.\n+   Return true if we need to exit early from \"main\", false otherwise.  */\n+\n+bool\n+driver::prepare_infiles ()\n+{\n+  size_t i;\n+  int lang_n_infiles = 0;\n+\n   if (n_infiles == added_libraries)\n     fatal_error (\"no input files\");\n \n   if (seen_error ())\n-    goto out;\n+    /* Early exit needed from main.  */\n+    return true;\n \n   /* Make a place to record the compiler output file names\n      that correspond to the input files.  */\n@@ -7338,6 +7470,17 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n   if (!combine_inputs && have_c && have_o && lang_n_infiles > 1)\n     fatal_error (\"cannot specify -o with -c, -S or -E with multiple files\");\n \n+  /* No early exit needed from main; we can continue.  */\n+  return false;\n+}\n+\n+/* Run the spec machinery on each input file.  */\n+\n+void\n+driver::do_spec_on_infiles () const\n+{\n+  size_t i;\n+\n   for (i = 0; (int) i < n_infiles; i++)\n     {\n       int this_file_error = 0;\n@@ -7372,6 +7515,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t    }\n \t  else\n \t    {\n+\t      int value;\n+\n \t      if (compare_debug)\n \t\t{\n \t\t  free (debug_check_temp_file[0]);\n@@ -7473,6 +7618,16 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n       if (lang_specific_pre_link ())\n \terrorcount++;\n     }\n+}\n+\n+/* If we have to run the linker, do it now.  */\n+\n+void\n+driver::maybe_run_linker (const char *argv0) const\n+{\n+  size_t i;\n+  int linker_was_run = 0;\n+  int num_linker_inputs;\n \n   /* Determine if there are any linker input files.  */\n   num_linker_inputs = 0;\n@@ -7524,7 +7679,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t      linker_plugin_file_spec = convert_white_space (temp_spec);\n \t    }\n #endif\n-\t  lto_gcc_spec = argv[0];\n+\t  lto_gcc_spec = argv0;\n \t}\n \n       /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\n@@ -7539,7 +7694,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t\t    \" to the linker.\\n\\n\"));\n \t  fflush (stdout);\n \t}\n-      value = do_spec (link_command_spec);\n+      int value = do_spec (link_command_spec);\n       if (value < 0)\n \terrorcount = 1;\n       linker_was_run = (tmp != execution_count);\n@@ -7554,7 +7709,13 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t  && !(infiles[i].language && infiles[i].language[0] == '*'))\n \twarning (0, \"%s: linker input file unused because linking not done\",\n \t\t outfiles[i]);\n+}\n+\n+/* The end of \"main\".  */\n \n+void\n+driver::final_actions () const\n+{\n   /* Delete some or all of the temporary files we made.  */\n \n   if (seen_error ())\n@@ -7566,8 +7727,13 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n       printf ((\"\\nFor bug reporting instructions, please see:\\n\"));\n       printf (\"%s\\n\", bug_report_url);\n     }\n+}\n \n- out:\n+/* Determine what the exit code of the driver should be.  */\n+\n+int\n+driver::get_exit_code () const\n+{\n   return (signal_count != 0 ? 2\n \t  : seen_error () ? (pass_exit_codes ? greatest_status : 1)\n \t  : 0);"}]}