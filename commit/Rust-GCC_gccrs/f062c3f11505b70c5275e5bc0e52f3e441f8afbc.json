{"sha": "f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA2MmMzZjExNTA1YjcwYzUyNzVlNWJjMGU1MmYzZTQ0MWY4YWZiYw==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-06-02T20:00:40Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-06-17T09:06:21Z"}, "message": "amdgcn: Switch to HSACO v3 binary format\n\nThis upgrades the compiler to emit HSA Code Object v3 binaries.  This means\nchanging the assembler directives, and linker command line options.\n\nThe gcn-run and libgomp loaders need corresponding alterations.  The\nrelocations no longer need to be fixed up manually, and the kernel symbol\nnames have changed slightly.\n\nThis move makes the binaries compatible with the new rocgdb from ROCm 3.5.\n\n2020-06-17  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/gcn/gcn-hsa.h (TEXT_SECTION_ASM_OP): Use \".text\".\n\t(BSS_SECTION_ASM_OP): Use \".bss\".\n\t(ASM_SPEC): Remove \"-mattr=-code-object-v3\".\n\t(LINK_SPEC): Add \"--export-dynamic\".\n\t* config/gcn/gcn-opts.h (processor_type): Replace PROCESSOR_VEGA with\n\tPROCESSOR_VEGA10 and PROCESSOR_VEGA20.\n\t* config/gcn/gcn-run.c (HSA_RUNTIME_LIB): Use \".so.1\" variant.\n\t(load_image): Remove obsolete relocation handling.\n\tAdd \".kd\" suffix to the symbol names.\n\t* config/gcn/gcn.c (MAX_NORMAL_SGPR_COUNT): Set to 62.\n\t(gcn_option_override): Update gcn_isa test.\n\t(gcn_kernel_arg_types): Update all the assembler directives.\n\tRemove the obsolete options.\n\t(gcn_conditional_register_usage): Update MAX_NORMAL_SGPR_COUNT usage.\n\t(gcn_omp_device_kind_arch_isa): Handle PROCESSOR_VEGA10 and\n\tPROCESSOR_VEGA20.\n\t(output_file_start): Rework assembler file header.\n\t(gcn_hsa_declare_function_name): Rework kernel metadata.\n\t* config/gcn/gcn.h (GCN_KERNEL_ARG_TYPES): Set to 16.\n\t* config/gcn/gcn.opt (PROCESSOR_VEGA): Remove enum.\n\t(PROCESSOR_VEGA10): New enum value.\n\t(PROCESSOR_VEGA20): New enum value.\n\n\tlibgomp/\n\t* plugin/plugin-gcn.c (init_environment_variables): Use \".so.1\"\n\tvariant for HSA_RUNTIME_LIB name.\n\t(find_executable_symbol_1): Delete.\n\t(find_executable_symbol): Delete.\n\t(init_kernel_properties): Add \".kd\" suffix to symbol names.\n\t(find_load_offset): Delete.\n\t(create_and_finalize_hsa_program): Remove relocation handling.", "tree": {"sha": "771e2b2a81f358cfa9557c1367c1fd992184fd5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/771e2b2a81f358cfa9557c1367c1fd992184fd5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ad4fc26dcb04d57754480e491334a8af0c79897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad4fc26dcb04d57754480e491334a8af0c79897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad4fc26dcb04d57754480e491334a8af0c79897"}], "stats": {"total": 639, "additions": 121, "deletions": 518}, "files": [{"sha": "4fd1365416f4004b997775b191825c272c02c34a", "filename": "gcc/config/gcn/gcn-hsa.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h?ref=f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "patch": "@@ -18,8 +18,8 @@\n  #error elf.h included before elfos.h\n #endif\n \n-#define TEXT_SECTION_ASM_OP \"\\t.section\\t.text\"\n-#define BSS_SECTION_ASM_OP  \"\\t.section\\t.bss\"\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+#define BSS_SECTION_ASM_OP  \"\\t.bss\"\n #define GLOBAL_ASM_OP       \"\\t.globl\\t\"\n #define DATA_SECTION_ASM_OP \"\\t.data\\t\"\n #define SET_ASM_OP          \"\\t.set\\t\"\n@@ -76,10 +76,10 @@ extern unsigned int gcn_local_sym_hash (const char *name);\n #define GOMP_SELF_SPECS \"\"\n \n /* Use LLVM assembler and linker options.  */\n-#define ASM_SPEC  \"-triple=amdgcn--amdhsa -mattr=-code-object-v3 \"  \\\n+#define ASM_SPEC  \"-triple=amdgcn--amdhsa \"  \\\n \t\t  \"%:last_arg(%{march=*:-mcpu=%*}) \" \\\n \t\t  \"-filetype=obj\"\n-#define LINK_SPEC \"--pie\"\n+#define LINK_SPEC \"--pie --export-dynamic\"\n #define LIB_SPEC  \"-lc\"\n \n /* Provides a _start symbol to keep the linker happy.  */"}, {"sha": "8eefb7a348a16a6acb19f7519ef1b813cff9c973", "filename": "gcc/config/gcn/gcn-opts.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-opts.h?ref=f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "patch": "@@ -20,8 +20,9 @@\n /* Which processor to generate code or schedule for.  */\n enum processor_type\n {\n-  PROCESSOR_FIJI,\n-  PROCESSOR_VEGA\n+  PROCESSOR_FIJI,    // gfx803\n+  PROCESSOR_VEGA10,  // gfx900\n+  PROCESSOR_VEGA20   // gfx906\n };\n \n /* Set in gcn_option_override.  */"}, {"sha": "8961ea17d37c1cebdac7b8649fe0ef785b1488f3", "filename": "gcc/config/gcn/gcn-run.c", "status": "modified", "additions": 12, "deletions": 142, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-run.c?ref=f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "patch": "@@ -55,7 +55,7 @@\n #include \"hsa.h\"\n \n #ifndef HSA_RUNTIME_LIB\n-#define HSA_RUNTIME_LIB \"libhsa-runtime64.so\"\n+#define HSA_RUNTIME_LIB \"libhsa-runtime64.so.1\"\n #endif\n \n #ifndef VERSION_STRING\n@@ -429,20 +429,6 @@ load_image (const char *filename)\n \t\t\t\t\t  &executable),\n \t\"Initialize GCN executable\");\n \n-  /* Hide relocations from the HSA runtime loader.\n-     Keep a copy of the unmodified section headers to use later.  */\n-  Elf64_Shdr *image_sections =\n-    (Elf64_Shdr *) ((char *) image + image->e_shoff);\n-  Elf64_Shdr *sections = malloc (sizeof (Elf64_Shdr) * image->e_shnum);\n-  memcpy (sections, image_sections, sizeof (Elf64_Shdr) * image->e_shnum);\n-  for (int i = image->e_shnum - 1; i >= 0; i--)\n-    {\n-      if (image_sections[i].sh_type == SHT_RELA\n-\t  || image_sections[i].sh_type == SHT_REL)\n-\t/* Change section type to something harmless.  */\n-\timage_sections[i].sh_type = SHT_NOTE;\n-    }\n-\n   /* Add the HSACO to the executable.  */\n   hsa_code_object_t co = { 0 };\n   XHSA (hsa_fns.hsa_code_object_deserialize_fn (image, image_size, NULL, &co),\n@@ -457,23 +443,27 @@ load_image (const char *filename)\n \n   /* Locate the \"_init_array\" function, and read the kernel's properties.  */\n   hsa_executable_symbol_t symbol;\n-  XHSA (hsa_fns.hsa_executable_get_symbol_fn (executable, NULL, \"_init_array\",\n-\t\t\t\t\t      device, 0, &symbol),\n+  XHSA (hsa_fns.hsa_executable_get_symbol_fn (executable, NULL, \n+\t\t\t\t\t      \"_init_array.kd\", device, 0,\n+\t\t\t\t\t      &symbol),\n \t\"Find '_init_array' function\");\n   XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n-\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &init_array_kernel),\n+\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT,\n+\t     &init_array_kernel),\n \t\"Extract '_init_array' kernel object kernel object\");\n \n   /* Locate the \"_fini_array\" function, and read the kernel's properties.  */\n-  XHSA (hsa_fns.hsa_executable_get_symbol_fn (executable, NULL, \"_fini_array\",\n-\t\t\t\t\t      device, 0, &symbol),\n+  XHSA (hsa_fns.hsa_executable_get_symbol_fn (executable, NULL,\n+\t\t\t\t\t      \"_fini_array.kd\", device, 0,\n+\t\t\t\t\t      &symbol),\n \t\"Find '_fini_array' function\");\n   XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n-\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &fini_array_kernel),\n+\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT,\n+\t     &fini_array_kernel),\n \t\"Extract '_fini_array' kernel object kernel object\");\n \n   /* Locate the \"main\" function, and read the kernel's properties.  */\n-  XHSA (hsa_fns.hsa_executable_get_symbol_fn (executable, NULL, \"main\",\n+  XHSA (hsa_fns.hsa_executable_get_symbol_fn (executable, NULL, \"main.kd\",\n \t\t\t\t\t      device, 0, &symbol),\n \t\"Find 'main' function\");\n   XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n@@ -491,126 +481,6 @@ load_image (const char *filename)\n \t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE,\n \t     &private_segment_size),\n \t\"Extract private segment size\");\n-\n-  /* Find main function in ELF, and calculate actual load offset.  */\n-  Elf64_Addr load_offset;\n-  XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n-\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS,\n-\t     &load_offset),\n-\t\"Extract 'main' symbol address\");\n-  for (int i = 0; i < image->e_shnum; i++)\n-    if (sections[i].sh_type == SHT_SYMTAB)\n-      {\n-\tElf64_Shdr *strtab = &sections[sections[i].sh_link];\n-\tchar *strings = (char *) image + strtab->sh_offset;\n-\n-\tfor (size_t offset = 0;\n-\t     offset < sections[i].sh_size;\n-\t     offset += sections[i].sh_entsize)\n-\t  {\n-\t    Elf64_Sym *sym = (Elf64_Sym *) ((char *) image\n-\t\t\t\t\t    + sections[i].sh_offset + offset);\n-\t    if (strcmp (\"main\", strings + sym->st_name) == 0)\n-\t      {\n-\t\tload_offset -= sym->st_value;\n-\t\tgoto found_main;\n-\t      }\n-\t  }\n-      }\n-  /* We only get here when main was not found.\n-     This should never happen.  */\n-  fprintf (stderr, \"Error: main function not found.\\n\");\n-  abort ();\n-found_main:;\n-\n-  /* Find dynamic symbol table.  */\n-  Elf64_Shdr *dynsym = NULL;\n-  for (int i = 0; i < image->e_shnum; i++)\n-    if (sections[i].sh_type == SHT_DYNSYM)\n-      {\n-\tdynsym = &sections[i];\n-\tbreak;\n-      }\n-\n-  /* Fix up relocations.  */\n-  for (int i = 0; i < image->e_shnum; i++)\n-    {\n-      if (sections[i].sh_type == SHT_RELA)\n-\tfor (size_t offset = 0;\n-\t     offset < sections[i].sh_size;\n-\t     offset += sections[i].sh_entsize)\n-\t  {\n-\t    Elf64_Rela *reloc = (Elf64_Rela *) ((char *) image\n-\t\t\t\t\t\t+ sections[i].sh_offset\n-\t\t\t\t\t\t+ offset);\n-\t    Elf64_Sym *sym =\n-\t      (dynsym\n-\t       ? (Elf64_Sym *) ((char *) image\n-\t\t\t\t+ dynsym->sh_offset\n-\t\t\t\t+ (dynsym->sh_entsize\n-\t\t\t\t   * ELF64_R_SYM (reloc->r_info))) : NULL);\n-\n-\t    int64_t S = (sym ? sym->st_value : 0);\n-\t    int64_t P = reloc->r_offset + load_offset;\n-\t    int64_t A = reloc->r_addend;\n-\t    int64_t B = load_offset;\n-\t    int64_t V, size;\n-\t    switch (ELF64_R_TYPE (reloc->r_info))\n-\t      {\n-\t      case R_AMDGPU_ABS32_LO:\n-\t\tV = (S + A) & 0xFFFFFFFF;\n-\t\tsize = 4;\n-\t\tbreak;\n-\t      case R_AMDGPU_ABS32_HI:\n-\t\tV = (S + A) >> 32;\n-\t\tsize = 4;\n-\t\tbreak;\n-\t      case R_AMDGPU_ABS64:\n-\t\tV = S + A;\n-\t\tsize = 8;\n-\t\tbreak;\n-\t      case R_AMDGPU_REL32:\n-\t\tV = S + A - P;\n-\t\tsize = 4;\n-\t\tbreak;\n-\t      case R_AMDGPU_REL64:\n-\t\t/* FIXME\n-\t\t   LLD seems to emit REL64 where the assembler has ABS64.\n-\t\t   This is clearly wrong because it's not what the compiler\n-\t\t   is expecting.  Let's assume, for now, that it's a bug.\n-\t\t   In any case, GCN kernels are always self contained and\n-\t\t   therefore relative relocations will have been resolved\n-\t\t   already, so this should be a safe workaround.  */\n-\t\tV = S + A /* - P */ ;\n-\t\tsize = 8;\n-\t\tbreak;\n-\t      case R_AMDGPU_ABS32:\n-\t\tV = S + A;\n-\t\tsize = 4;\n-\t\tbreak;\n-\t      /* TODO R_AMDGPU_GOTPCREL */\n-\t      /* TODO R_AMDGPU_GOTPCREL32_LO */\n-\t      /* TODO R_AMDGPU_GOTPCREL32_HI */\n-\t      case R_AMDGPU_REL32_LO:\n-\t\tV = (S + A - P) & 0xFFFFFFFF;\n-\t\tsize = 4;\n-\t\tbreak;\n-\t      case R_AMDGPU_REL32_HI:\n-\t\tV = (S + A - P) >> 32;\n-\t\tsize = 4;\n-\t\tbreak;\n-\t      case R_AMDGPU_RELATIVE64:\n-\t\tV = B + A;\n-\t\tsize = 8;\n-\t\tbreak;\n-\t      default:\n-\t\tfprintf (stderr, \"Error: unsupported relocation type.\\n\");\n-\t\texit (1);\n-\t      }\n-\t    XHSA (hsa_fns.hsa_memory_copy_fn ((void *) P, &V, size),\n-\t\t  \"Fix up relocation\");\n-\t  }\n-    }\n }\n \n /* Allocate some device memory from the kernargs region."}, {"sha": "fff0e8cb3a5f69f27b40351a157ac109cc82596a", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 94, "deletions": 137, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "patch": "@@ -83,7 +83,7 @@ int gcn_isa = 3;\t\t/* Default to GCN3.  */\n /* The number of registers usable by normal non-kernel functions.\n    The SGPR count includes any special extra registers such as VCC.  */\n \n-#define MAX_NORMAL_SGPR_COUNT\t64\n+#define MAX_NORMAL_SGPR_COUNT\t62  // i.e. 64 with VCC\n #define MAX_NORMAL_VGPR_COUNT\t24\n \n /* }}}  */\n@@ -127,7 +127,7 @@ gcn_option_override (void)\n   if (!flag_pic)\n     flag_pic = flag_pie;\n \n-  gcn_isa = gcn_arch == PROCESSOR_VEGA ? 5 : 3;\n+  gcn_isa = gcn_arch == PROCESSOR_FIJI ? 3 : 5;\n \n   /* The default stack size needs to be small for offload kernels because\n      there may be many, many threads.  Also, a smaller stack gives a\n@@ -168,37 +168,31 @@ static const struct gcn_kernel_arg_type\n   {\"exec\", NULL, DImode, EXEC_REG},\n #define PRIVATE_SEGMENT_BUFFER_ARG 1\n   {\"private_segment_buffer\",\n-    \"enable_sgpr_private_segment_buffer\", TImode, -1},\n+    \".amdhsa_user_sgpr_private_segment_buffer\", TImode, -1},\n #define DISPATCH_PTR_ARG 2\n-  {\"dispatch_ptr\", \"enable_sgpr_dispatch_ptr\", DImode, -1},\n+  {\"dispatch_ptr\", \".amdhsa_user_sgpr_dispatch_ptr\", DImode, -1},\n #define QUEUE_PTR_ARG 3\n-  {\"queue_ptr\", \"enable_sgpr_queue_ptr\", DImode, -1},\n+  {\"queue_ptr\", \".amdhsa_user_sgpr_queue_ptr\", DImode, -1},\n #define KERNARG_SEGMENT_PTR_ARG 4\n-  {\"kernarg_segment_ptr\", \"enable_sgpr_kernarg_segment_ptr\", DImode, -1},\n-  {\"dispatch_id\", \"enable_sgpr_dispatch_id\", DImode, -1},\n+  {\"kernarg_segment_ptr\", \".amdhsa_user_sgpr_kernarg_segment_ptr\", DImode, -1},\n+  {\"dispatch_id\", \".amdhsa_user_sgpr_dispatch_id\", DImode, -1},\n #define FLAT_SCRATCH_INIT_ARG 6\n-  {\"flat_scratch_init\", \"enable_sgpr_flat_scratch_init\", DImode, -1},\n+  {\"flat_scratch_init\", \".amdhsa_user_sgpr_flat_scratch_init\", DImode, -1},\n #define FLAT_SCRATCH_SEGMENT_SIZE_ARG 7\n-  {\"private_segment_size\", \"enable_sgpr_private_segment_size\", SImode, -1},\n-  {\"grid_workgroup_count_X\",\n-    \"enable_sgpr_grid_workgroup_count_x\", SImode, -1},\n-  {\"grid_workgroup_count_Y\",\n-    \"enable_sgpr_grid_workgroup_count_y\", SImode, -1},\n-  {\"grid_workgroup_count_Z\",\n-    \"enable_sgpr_grid_workgroup_count_z\", SImode, -1},\n-#define WORKGROUP_ID_X_ARG 11\n-  {\"workgroup_id_X\", \"enable_sgpr_workgroup_id_x\", SImode, -2},\n-  {\"workgroup_id_Y\", \"enable_sgpr_workgroup_id_y\", SImode, -2},\n-  {\"workgroup_id_Z\", \"enable_sgpr_workgroup_id_z\", SImode, -2},\n-  {\"workgroup_info\", \"enable_sgpr_workgroup_info\", SImode, -1},\n-#define PRIVATE_SEGMENT_WAVE_OFFSET_ARG 15\n+  {\"private_segment_size\", \".amdhsa_user_sgpr_private_segment_size\", SImode, -1},\n+#define WORKGROUP_ID_X_ARG 8\n+  {\"workgroup_id_X\", \".amdhsa_system_sgpr_workgroup_id_x\", SImode, -2},\n+  {\"workgroup_id_Y\", \".amdhsa_system_sgpr_workgroup_id_y\", SImode, -2},\n+  {\"workgroup_id_Z\", \".amdhsa_system_sgpr_workgroup_id_z\", SImode, -2},\n+  {\"workgroup_info\", \".amdhsa_system_sgpr_workgroup_info\", SImode, -1},\n+#define PRIVATE_SEGMENT_WAVE_OFFSET_ARG 12\n   {\"private_segment_wave_offset\",\n-    \"enable_sgpr_private_segment_wave_byte_offset\", SImode, -2},\n-#define WORK_ITEM_ID_X_ARG 16\n+    \".amdhsa_system_sgpr_private_segment_wavefront_offset\", SImode, -2},\n+#define WORK_ITEM_ID_X_ARG 13\n   {\"work_item_id_X\", NULL, V64SImode, FIRST_VGPR_REG},\n-#define WORK_ITEM_ID_Y_ARG 17\n+#define WORK_ITEM_ID_Y_ARG 14\n   {\"work_item_id_Y\", NULL, V64SImode, FIRST_VGPR_REG + 1},\n-#define WORK_ITEM_ID_Z_ARG 18\n+#define WORK_ITEM_ID_Z_ARG 15\n   {\"work_item_id_Z\", NULL, V64SImode, FIRST_VGPR_REG + 2}\n };\n \n@@ -2075,7 +2069,7 @@ gcn_conditional_register_usage (void)\n   if (cfun->machine->normal_function)\n     {\n       /* Restrict the set of SGPRs and VGPRs used by non-kernel functions.  */\n-      for (int i = SGPR_REGNO (MAX_NORMAL_SGPR_COUNT - 2);\n+      for (int i = SGPR_REGNO (MAX_NORMAL_SGPR_COUNT);\n \t   i <= LAST_SGPR_REG; i++)\n \tfixed_regs[i] = 1, call_used_regs[i] = 1;\n \n@@ -2574,9 +2568,9 @@ gcn_omp_device_kind_arch_isa (enum omp_device_kind_arch_isa trait,\n       if (strcmp (name, \"fiji\") == 0)\n \treturn gcn_arch == PROCESSOR_FIJI;\n       if (strcmp (name, \"gfx900\") == 0)\n-\treturn gcn_arch == PROCESSOR_VEGA;\n+\treturn gcn_arch == PROCESSOR_VEGA10;\n       if (strcmp (name, \"gfx906\") == 0)\n-\treturn gcn_arch == PROCESSOR_VEGA;\n+\treturn gcn_arch == PROCESSOR_VEGA20;\n       return 0;\n     default:\n       gcc_unreachable ();\n@@ -4943,11 +4937,16 @@ gcn_fixup_accel_lto_options (tree fndecl)\n static void\n output_file_start (void)\n {\n-  fprintf (asm_out_file, \"\\t.text\\n\");\n-  fprintf (asm_out_file, \"\\t.hsa_code_object_version 2,0\\n\");\n-  fprintf (asm_out_file, \"\\t.hsa_code_object_isa\\n\");\t/* Autodetect.  */\n-  fprintf (asm_out_file, \"\\t.section\\t.AMDGPU.config\\n\");\n-  fprintf (asm_out_file, \"\\t.text\\n\");\n+  char *cpu;\n+  switch (gcn_arch)\n+    {\n+    case PROCESSOR_FIJI: cpu = \"gfx803\"; break;\n+    case PROCESSOR_VEGA10: cpu = \"gfx900\"; break;\n+    case PROCESSOR_VEGA20: cpu = \"gfx906\"; break;\n+    default: gcc_unreachable ();\n+    }\n+\n+  fprintf(asm_out_file, \"\\t.amdgcn_target \\\"amdgcn-unknown-amdhsa--%s\\\"\\n\", cpu);\n }\n \n /* Implement ASM_DECLARE_FUNCTION_NAME via gcn-hsa.h.\n@@ -4963,7 +4962,8 @@ gcn_hsa_declare_function_name (FILE *file, const char *name, tree)\n {\n   int sgpr, vgpr;\n   bool xnack_enabled = false;\n-  int extra_regs = 0;\n+\n+  fputs (\"\\n\\n\", file);\n \n   if (cfun && cfun->machine && cfun->machine->normal_function)\n     {\n@@ -4986,76 +4986,20 @@ gcn_hsa_declare_function_name (FILE *file, const char *name, tree)\n       break;\n   vgpr++;\n \n-  if (xnack_enabled)\n-    extra_regs = 6;\n-  if (df_regs_ever_live_p (FLAT_SCRATCH_LO_REG)\n-      || df_regs_ever_live_p (FLAT_SCRATCH_HI_REG))\n-    extra_regs = 4;\n-  else if (df_regs_ever_live_p (VCC_LO_REG)\n-\t   || df_regs_ever_live_p (VCC_HI_REG))\n-    extra_regs = 2;\n-\n   if (!leaf_function_p ())\n     {\n       /* We can't know how many registers function calls might use.  */\n       if (vgpr < MAX_NORMAL_VGPR_COUNT)\n \tvgpr = MAX_NORMAL_VGPR_COUNT;\n-      if (sgpr + extra_regs < MAX_NORMAL_SGPR_COUNT)\n-\tsgpr = MAX_NORMAL_SGPR_COUNT - extra_regs;\n+      if (sgpr < MAX_NORMAL_SGPR_COUNT)\n+\tsgpr = MAX_NORMAL_SGPR_COUNT;\n     }\n \n-  /* GFX8 allocates SGPRs in blocks of 8.\n-     GFX9 uses blocks of 16.  */\n-  int granulated_sgprs;\n-  if (TARGET_GCN3)\n-    granulated_sgprs = (sgpr + extra_regs + 7) / 8 - 1;\n-  else if (TARGET_GCN5)\n-    granulated_sgprs = 2 * ((sgpr + extra_regs + 15) / 16 - 1);\n-  else\n-    gcc_unreachable ();\n-\n-  fputs (\"\\t.align\\t256\\n\", file);\n-  fputs (\"\\t.type\\t\", file);\n-  assemble_name (file, name);\n-  fputs (\",@function\\n\\t.amdgpu_hsa_kernel\\t\", file);\n+  fputs (\"\\t.rodata\\n\"\n+\t \"\\t.p2align\\t6\\n\"\n+\t \"\\t.amdhsa_kernel\\t\", file);\n   assemble_name (file, name);\n   fputs (\"\\n\", file);\n-  assemble_name (file, name);\n-  fputs (\":\\n\", file);\n-  fprintf (file, \"\\t.amd_kernel_code_t\\n\"\n-\t   \"\\t\\tkernel_code_version_major = 1\\n\"\n-\t   \"\\t\\tkernel_code_version_minor = 0\\n\" \"\\t\\tmachine_kind = 1\\n\"\n-\t   /* \"\\t\\tmachine_version_major = 8\\n\"\n-\t      \"\\t\\tmachine_version_minor = 0\\n\"\n-\t      \"\\t\\tmachine_version_stepping = 1\\n\" */\n-\t   \"\\t\\tkernel_code_entry_byte_offset = 256\\n\"\n-\t   \"\\t\\tkernel_code_prefetch_byte_size = 0\\n\"\n-\t   \"\\t\\tmax_scratch_backing_memory_byte_size = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_vgprs = %i\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_sgprs = %i\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_priority = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_float_mode = 192\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_priv = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_dx10_clamp = 1\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_debug_mode = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc1_ieee_mode = 1\\n\"\n-\t   /* We enable scratch memory.  */\n-\t   \"\\t\\tcompute_pgm_rsrc2_scratch_en = 1\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_user_sgpr = %i\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_tgid_x_en = 1\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_tgid_y_en = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_tgid_z_en = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_tg_size_en = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_tidig_comp_cnt = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_excp_en_msb = 0\\n\"\n-\t   \"\\t\\tcompute_pgm_rsrc2_lds_size = 0\\n\"\t/* Set at runtime.  */\n-\t   \"\\t\\tcompute_pgm_rsrc2_excp_en = 0\\n\",\n-\t   (vgpr - 1) / 4,\n-\t   /* Must match wavefront_sgpr_count */\n-\t   granulated_sgprs,\n-\t   /* The total number of SGPR user data registers requested.  This\n-\t      number must match the number of user data registers enabled.  */\n-\t   cfun->machine->args.nsgprs);\n   int reg = FIRST_SGPR_REG;\n   for (int a = 0; a < GCN_KERNEL_ARG_TYPES; a++)\n     {\n@@ -5073,7 +5017,8 @@ gcn_hsa_declare_function_name (FILE *file, const char *name, tree)\n \n       if (gcn_kernel_arg_types[a].header_pseudo)\n \t{\n-\t  fprintf (file, \"\\t\\t%s = %i\",\n+\t  fprintf (file, \"\\t  %s%s\\t%i\",\n+\t\t   (cfun->machine->args.requested & (1 << a)) != 0 ? \"\" : \";\",\n \t\t   gcn_kernel_arg_types[a].header_pseudo,\n \t\t   (cfun->machine->args.requested & (1 << a)) != 0);\n \t  if (reg_first != -1)\n@@ -5091,54 +5036,71 @@ gcn_hsa_declare_function_name (FILE *file, const char *name, tree)\n \t}\n       else if (gcn_kernel_arg_types[a].fixed_regno >= 0\n \t       && cfun->machine->args.requested & (1 << a))\n-\tfprintf (file, \"\\t\\t; %s = %i (%s)\\n\",\n+\tfprintf (file, \"\\t  ; %s\\t%i (%s)\\n\",\n \t\t gcn_kernel_arg_types[a].name,\n \t\t (cfun->machine->args.requested & (1 << a)) != 0,\n \t\t reg_names[gcn_kernel_arg_types[a].fixed_regno]);\n     }\n-  fprintf (file, \"\\t\\tenable_vgpr_workitem_id = %i\\n\",\n+  fprintf (file, \"\\t  .amdhsa_system_vgpr_workitem_id\\t%i\\n\",\n \t   (cfun->machine->args.requested & (1 << WORK_ITEM_ID_Z_ARG))\n \t   ? 2\n \t   : cfun->machine->args.requested & (1 << WORK_ITEM_ID_Y_ARG)\n \t   ? 1 : 0);\n-  fprintf (file, \"\\t\\tenable_ordered_append_gds = 0\\n\"\n-\t   \"\\t\\tprivate_element_size = 1\\n\"\n-\t   \"\\t\\tis_ptr64 = 1\\n\"\n-\t   \"\\t\\tis_dynamic_callstack = 0\\n\"\n-\t   \"\\t\\tis_debug_enabled = 0\\n\"\n-\t   \"\\t\\tis_xnack_enabled = %i\\n\"\n-\t   \"\\t\\tworkitem_private_segment_byte_size = %i\\n\"\n-\t   \"\\t\\tworkgroup_group_segment_byte_size = %u\\n\"\n-\t   \"\\t\\tgds_segment_byte_size = 0\\n\"\n-\t   \"\\t\\tkernarg_segment_byte_size = %i\\n\"\n-\t   \"\\t\\tworkgroup_fbarrier_count = 0\\n\"\n-\t   \"\\t\\twavefront_sgpr_count = %i\\n\"\n-\t   \"\\t\\tworkitem_vgpr_count = %i\\n\"\n-\t   \"\\t\\treserved_vgpr_first = 0\\n\"\n-\t   \"\\t\\treserved_vgpr_count = 0\\n\"\n-\t   \"\\t\\treserved_sgpr_first = 0\\n\"\n-\t   \"\\t\\treserved_sgpr_count = 0\\n\"\n-\t   \"\\t\\tdebug_wavefront_private_segment_offset_sgpr = 0\\n\"\n-\t   \"\\t\\tdebug_private_segment_buffer_sgpr = 0\\n\"\n-\t   \"\\t\\tkernarg_segment_alignment = %i\\n\"\n-\t   \"\\t\\tgroup_segment_alignment = 4\\n\"\n-\t   \"\\t\\tprivate_segment_alignment = %i\\n\"\n-\t   \"\\t\\twavefront_size = 6\\n\"\n-\t   \"\\t\\tcall_convention = 0\\n\"\n-\t   \"\\t\\truntime_loader_kernel_symbol = 0\\n\"\n-\t   \"\\t.end_amd_kernel_code_t\\n\", xnack_enabled,\n+  fprintf (file,\n+\t   \"\\t  .amdhsa_next_free_vgpr\\t%i\\n\"\n+\t   \"\\t  .amdhsa_next_free_sgpr\\t%i\\n\"\n+\t   \"\\t  .amdhsa_reserve_vcc\\t1\\n\"\n+\t   \"\\t  .amdhsa_reserve_flat_scratch\\t0\\n\"\n+\t   \"\\t  .amdhsa_reserve_xnack_mask\\t%i\\n\"\n+\t   \"\\t  .amdhsa_private_segment_fixed_size\\t%i\\n\"\n+\t   \"\\t  .amdhsa_group_segment_fixed_size\\t%u\\n\"\n+\t   \"\\t  .amdhsa_float_denorm_mode_32\\t3\\n\"\n+\t   \"\\t  .amdhsa_float_denorm_mode_16_64\\t3\\n\",\n+\t   vgpr,\n+\t   sgpr,\n+\t   xnack_enabled,\n \t   /* workitem_private_segment_bytes_size needs to be\n \t      one 64th the wave-front stack size.  */\n \t   stack_size_opt / 64,\n-\t   LDS_SIZE, cfun->machine->kernarg_segment_byte_size,\n-\t   /* Number of scalar registers used by a wavefront.  This\n-\t      includes the special SGPRs for VCC, Flat Scratch (Base,\n-\t      Size) and XNACK (for GFX8 (VI)+).  It does not include the\n-\t      16 SGPR added if a trap handler is enabled.  Must match\n-\t      compute_pgm_rsrc1.sgprs.  */\n-\t   sgpr + extra_regs, vgpr,\n+\t   LDS_SIZE);\n+  fputs (\"\\t.end_amdhsa_kernel\\n\", file);\n+\n+#if 1\n+  /* The following is YAML embedded in assembler; tabs are not allowed.  */\n+  fputs (\"        .amdgpu_metadata\\n\"\n+\t \"        amdhsa.version:\\n\"\n+\t \"          - 1\\n\"\n+\t \"          - 0\\n\"\n+\t \"        amdhsa.kernels:\\n\"\n+\t \"          - .name: \", file);\n+  assemble_name (file, name);\n+  fputs (\"\\n            .symbol: \", file);\n+  assemble_name (file, name);\n+  fprintf (file,\n+\t   \".kd\\n\"\n+\t   \"            .kernarg_segment_size: %i\\n\"\n+\t   \"            .kernarg_segment_align: %i\\n\"\n+\t   \"            .group_segment_fixed_size: %u\\n\"\n+\t   \"            .private_segment_fixed_size: %i\\n\"\n+\t   \"            .wavefront_size: 64\\n\"\n+\t   \"            .sgpr_count: %i\\n\"\n+\t   \"            .vgpr_count: %i\\n\"\n+\t   \"            .max_flat_workgroup_size: 1024\\n\",\n+\t   cfun->machine->kernarg_segment_byte_size,\n \t   cfun->machine->kernarg_segment_alignment,\n-\t   crtl->stack_alignment_needed / 8);\n+\t   LDS_SIZE,\n+\t   stack_size_opt / 64,\n+\t   sgpr, vgpr);\n+  fputs (\"        .end_amdgpu_metadata\\n\", file);\n+#endif\n+\n+  fputs (\"\\t.text\\n\", file);\n+  fputs (\"\\t.align\\t256\\n\", file);\n+  fputs (\"\\t.type\\t\", file);\n+  assemble_name (file, name);\n+  fputs (\",@function\\n\", file);\n+  assemble_name (file, name);\n+  fputs (\":\\n\", file);\n \n   /* This comment is read by mkoffload.  */\n   if (flag_openacc)\n@@ -5200,11 +5162,6 @@ gcn_target_asm_function_prologue (FILE *file)\n       asm_fprintf (file, \"\\t; local vars size: %wd\\n\", offsets->local_vars);\n       asm_fprintf (file, \"\\t; outgoing args size: %wd\\n\",\n \t\t   offsets->outgoing_args_size);\n-\n-      /* Enable denorms.  */\n-      asm_fprintf (file, \"\\n\\t; Set MODE[FP_DENORM]: allow single and double\"\n-\t\t   \" input and output denorms\\n\");\n-      asm_fprintf (file, \"\\ts_setreg_imm32_b32\\thwreg(1, 4, 4), 0xf\\n\\n\");\n     }\n }\n "}, {"sha": "f63e7df3021a02d76527a457bbc008b8a182bd59", "filename": "gcc/config/gcn/gcn.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.h?ref=f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "patch": "@@ -525,7 +525,7 @@ enum gcn_address_spaces\n \n #ifndef USED_FOR_TARGET\n \n-#define GCN_KERNEL_ARG_TYPES 19\n+#define GCN_KERNEL_ARG_TYPES 16\n struct GTY(()) gcn_kernel_args\n {\n   long requested;"}, {"sha": "b1ea56e020fafe0e1f0cd2f5480b82b292403701", "filename": "gcc/config/gcn/gcn.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.opt?ref=f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "patch": "@@ -29,10 +29,10 @@ EnumValue\n Enum(gpu_type) String(fiji) Value(PROCESSOR_FIJI)\n \n EnumValue\n-Enum(gpu_type) String(gfx900) Value(PROCESSOR_VEGA)\n+Enum(gpu_type) String(gfx900) Value(PROCESSOR_VEGA10)\n \n EnumValue\n-Enum(gpu_type) String(gfx906) Value(PROCESSOR_VEGA)\n+Enum(gpu_type) String(gfx906) Value(PROCESSOR_VEGA20)\n \n march=\n Target RejectNegative Joined ToLower Enum(gpu_type) Var(gcn_arch) Init(PROCESSOR_FIJI)"}, {"sha": "0be350bba289b26c7ccf7909236a23a7d77d5603", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 5, "deletions": 230, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f062c3f11505b70c5275e5bc0e52f3e441f8afbc/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=f062c3f11505b70c5275e5bc0e52f3e441f8afbc", "patch": "@@ -1074,7 +1074,7 @@ init_environment_variables (void)\n \n   hsa_runtime_lib = secure_getenv (\"HSA_RUNTIME_LIB\");\n   if (hsa_runtime_lib == NULL)\n-    hsa_runtime_lib = HSA_RUNTIME_LIB \"libhsa-runtime64.so\";\n+    hsa_runtime_lib = HSA_RUNTIME_LIB \"libhsa-runtime64.so.1\";\n \n   support_cpu_devices = secure_getenv (\"GCN_SUPPORT_CPU_DEVICES\");\n \n@@ -1137,40 +1137,6 @@ get_executable_symbol_name (hsa_executable_symbol_t symbol)\n   return res;\n }\n \n-/* Helper function for find_executable_symbol.  */\n-\n-static hsa_status_t\n-find_executable_symbol_1 (hsa_executable_t executable,\n-\t\t\t  hsa_executable_symbol_t symbol,\n-\t\t\t  void *data)\n-{\n-  hsa_executable_symbol_t *res = (hsa_executable_symbol_t *)data;\n-  *res = symbol;\n-  return HSA_STATUS_INFO_BREAK;\n-}\n-\n-/* Find a global symbol in EXECUTABLE, save to *SYMBOL and return true.  If not\n-   found, return false.  */\n-\n-static bool\n-find_executable_symbol (hsa_executable_t executable,\n-\t\t\thsa_executable_symbol_t *symbol)\n-{\n-  hsa_status_t status;\n-\n-  status\n-    = hsa_fns.hsa_executable_iterate_symbols_fn (executable,\n-\t\t\t\t\t\t find_executable_symbol_1,\n-\t\t\t\t\t\t symbol);\n-  if (status != HSA_STATUS_INFO_BREAK)\n-    {\n-      hsa_error (\"Could not find executable symbol\", status);\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n /* Get the number of GPU Compute Units.  */\n \n static int\n@@ -2007,13 +1973,15 @@ init_kernel_properties (struct kernel_info *kernel)\n   hsa_status_t status;\n   struct agent_info *agent = kernel->agent;\n   hsa_executable_symbol_t kernel_symbol;\n+  char *buf = alloca (strlen (kernel->name) + 4);\n+  sprintf (buf, \"%s.kd\", kernel->name);\n   status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,\n-\t\t\t\t\t\t kernel->name, agent->id,\n+\t\t\t\t\t\t buf, agent->id,\n \t\t\t\t\t\t 0, &kernel_symbol);\n   if (status != HSA_STATUS_SUCCESS)\n     {\n       hsa_warn (\"Could not find symbol for kernel in the code object\", status);\n-      fprintf (stderr, \"not found name: '%s'\\n\", kernel->name);\n+      fprintf (stderr, \"not found name: '%s'\\n\", buf);\n       dump_executable_symbols (agent->executable);\n       goto failure;\n     }\n@@ -2327,61 +2295,6 @@ init_basic_kernel_info (struct kernel_info *kernel,\n   return true;\n }\n \n-/* Find the load_offset for MODULE, save to *LOAD_OFFSET, and return true.  If\n-   not found, return false.  */\n-\n-static bool\n-find_load_offset (Elf64_Addr *load_offset, struct agent_info *agent,\n-\t\t  struct module_info *module, Elf64_Ehdr *image,\n-\t\t  Elf64_Shdr *sections)\n-{\n-  bool res = false;\n-\n-  hsa_status_t status;\n-\n-  hsa_executable_symbol_t symbol;\n-  if (!find_executable_symbol (agent->executable, &symbol))\n-    return false;\n-\n-  status = hsa_fns.hsa_executable_symbol_get_info_fn\n-    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS, load_offset);\n-  if (status != HSA_STATUS_SUCCESS)\n-    {\n-      hsa_error (\"Could not extract symbol address\", status);\n-      return false;\n-    }\n-\n-  char *symbol_name = get_executable_symbol_name (symbol);\n-  if (symbol_name == NULL)\n-    return false;\n-\n-  /* Find the kernel function in ELF, and calculate actual load offset.  */\n-  for (int i = 0; i < image->e_shnum; i++)\n-    if (sections[i].sh_type == SHT_SYMTAB)\n-      {\n-\tElf64_Shdr *strtab = &sections[sections[i].sh_link];\n-\tchar *strings = (char *)image + strtab->sh_offset;\n-\n-\tfor (size_t offset = 0;\n-\t     offset < sections[i].sh_size;\n-\t     offset += sections[i].sh_entsize)\n-\t  {\n-\t    Elf64_Sym *sym = (Elf64_Sym*)((char*)image\n-\t\t\t\t\t  + sections[i].sh_offset\n-\t\t\t\t\t  + offset);\n-\t    if (strcmp (symbol_name, strings + sym->st_name) == 0)\n-\t      {\n-\t\t*load_offset -= sym->st_value;\n-\t\tres = true;\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-  free (symbol_name);\n-  return res;\n-}\n-\n /* Check that the GCN ISA of the given image matches the ISA of the agent. */\n \n static bool\n@@ -2421,7 +2334,6 @@ static bool\n create_and_finalize_hsa_program (struct agent_info *agent)\n {\n   hsa_status_t status;\n-  int reloc_count = 0;\n   bool res = true;\n   if (pthread_mutex_lock (&agent->prog_mutex))\n     {\n@@ -2450,18 +2362,6 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n       if (!isa_matches_agent (agent, image))\n \tgoto fail;\n \n-      /* Hide relocations from the HSA runtime loader.\n-\t Keep a copy of the unmodified section headers to use later.  */\n-      Elf64_Shdr *image_sections = (Elf64_Shdr *)((char *)image\n-\t\t\t\t\t\t  + image->e_shoff);\n-      for (int i = image->e_shnum - 1; i >= 0; i--)\n-\t{\n-\t  if (image_sections[i].sh_type == SHT_RELA\n-\t      || image_sections[i].sh_type == SHT_REL)\n-\t    /* Change section type to something harmless.  */\n-\t    image_sections[i].sh_type |= 0x80;\n-\t}\n-\n       hsa_code_object_t co = { 0 };\n       status = hsa_fns.hsa_code_object_deserialize_fn\n \t(module->image_desc->gcn_image->image,\n@@ -2517,131 +2417,6 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n       goto fail;\n     }\n \n-  if (agent->module)\n-    {\n-      struct module_info *module = agent->module;\n-      Elf64_Ehdr *image = (Elf64_Ehdr *)module->image_desc->gcn_image->image;\n-      Elf64_Shdr *sections = (Elf64_Shdr *)((char *)image + image->e_shoff);\n-\n-      Elf64_Addr load_offset;\n-      if (!find_load_offset (&load_offset, agent, module, image, sections))\n-\tgoto fail;\n-\n-      /* Record the physical load address range.\n-\t We need this for data copies later.  */\n-      Elf64_Phdr *segments = (Elf64_Phdr *)((char*)image + image->e_phoff);\n-      Elf64_Addr low = ~0, high = 0;\n-      for (int i = 0; i < image->e_phnum; i++)\n-\tif (segments[i].p_memsz > 0)\n-\t  {\n-\t    if (segments[i].p_paddr < low)\n-\t      low = segments[i].p_paddr;\n-\t    if (segments[i].p_paddr > high)\n-\t      high = segments[i].p_paddr + segments[i].p_memsz - 1;\n-\t  }\n-      module->phys_address_start = low + load_offset;\n-      module->phys_address_end = high + load_offset;\n-\n-      // Find dynamic symbol table\n-      Elf64_Shdr *dynsym = NULL;\n-      for (int i = 0; i < image->e_shnum; i++)\n-\tif (sections[i].sh_type == SHT_DYNSYM)\n-\t  {\n-\t    dynsym = &sections[i];\n-\t    break;\n-\t  }\n-\n-      /* Fix up relocations.  */\n-      for (int i = 0; i < image->e_shnum; i++)\n-\t{\n-\t  if (sections[i].sh_type == (SHT_RELA | 0x80))\n-\t    for (size_t offset = 0;\n-\t\t offset < sections[i].sh_size;\n-\t\t offset += sections[i].sh_entsize)\n-\t      {\n-\t\tElf64_Rela *reloc = (Elf64_Rela*)((char*)image\n-\t\t\t\t\t\t  + sections[i].sh_offset\n-\t\t\t\t\t\t  + offset);\n-\t\tElf64_Sym *sym =\n-\t\t  (dynsym\n-\t\t   ? (Elf64_Sym*)((char*)image\n-\t\t\t\t  + dynsym->sh_offset\n-\t\t\t\t  + (dynsym->sh_entsize\n-\t\t\t\t     * ELF64_R_SYM (reloc->r_info)))\n-\t\t   : NULL);\n-\n-\t\tint64_t S = (sym ? sym->st_value : 0);\n-\t\tint64_t P = reloc->r_offset + load_offset;\n-\t\tint64_t A = reloc->r_addend;\n-\t\tint64_t B = load_offset;\n-\t\tint64_t V, size;\n-\t\tswitch (ELF64_R_TYPE (reloc->r_info))\n-\t\t  {\n-\t\t  case R_AMDGPU_ABS32_LO:\n-\t\t    V = (S + A) & 0xFFFFFFFF;\n-\t\t    size = 4;\n-\t\t    break;\n-\t\t  case R_AMDGPU_ABS32_HI:\n-\t\t    V = (S + A) >> 32;\n-\t\t    size = 4;\n-\t\t    break;\n-\t\t  case R_AMDGPU_ABS64:\n-\t\t    V = S + A;\n-\t\t    size = 8;\n-\t\t    break;\n-\t\t  case R_AMDGPU_REL32:\n-\t\t    V = S + A - P;\n-\t\t    size = 4;\n-\t\t    break;\n-\t\t  case R_AMDGPU_REL64:\n-\t\t    /* FIXME\n-\t\t       LLD seems to emit REL64 where the the assembler has\n-\t\t       ABS64.  This is clearly wrong because it's not what the\n-\t\t       compiler is expecting.  Let's assume, for now, that\n-\t\t       it's a bug.  In any case, GCN kernels are always self\n-\t\t       contained and therefore relative relocations will have\n-\t\t       been resolved already, so this should be a safe\n-\t\t       workaround.  */\n-\t\t    V = S + A/* - P*/;\n-\t\t    size = 8;\n-\t\t    break;\n-\t\t  case R_AMDGPU_ABS32:\n-\t\t    V = S + A;\n-\t\t    size = 4;\n-\t\t    break;\n-\t\t    /* TODO R_AMDGPU_GOTPCREL */\n-\t\t    /* TODO R_AMDGPU_GOTPCREL32_LO */\n-\t\t    /* TODO R_AMDGPU_GOTPCREL32_HI */\n-\t\t  case R_AMDGPU_REL32_LO:\n-\t\t    V = (S + A - P) & 0xFFFFFFFF;\n-\t\t    size = 4;\n-\t\t    break;\n-\t\t  case R_AMDGPU_REL32_HI:\n-\t\t    V = (S + A - P) >> 32;\n-\t\t    size = 4;\n-\t\t    break;\n-\t\t  case R_AMDGPU_RELATIVE64:\n-\t\t    V = B + A;\n-\t\t    size = 8;\n-\t\t    break;\n-\t\t  default:\n-\t\t    fprintf (stderr, \"Error: unsupported relocation type.\\n\");\n-\t\t    exit (1);\n-\t\t  }\n-\t\tstatus = hsa_fns.hsa_memory_copy_fn ((void*)P, &V, size);\n-\t\tif (status != HSA_STATUS_SUCCESS)\n-\t\t  {\n-\t\t    hsa_error (\"Failed to fix up relocation\", status);\n-\t\t    goto fail;\n-\t\t  }\n-\t\treloc_count++;\n-\t      }\n-\t}\n-    }\n-\n-  GCN_DEBUG (\"Loaded GCN kernels to device %d (%d relocations)\\n\",\n-\t     agent->device_id, reloc_count);\n-\n final:\n   agent->prog_finalized = true;\n "}]}