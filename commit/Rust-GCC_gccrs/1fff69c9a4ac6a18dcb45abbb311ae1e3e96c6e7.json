{"sha": "1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmZjY5YzlhNGFjNmExOGRjYjQ1YWJiYjMxMWFlMWUzZTk2YzZlNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-03-29T19:39:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-03-29T19:39:35Z"}, "message": "re PR bootstrap/14316 (collect2 doesnt build on windows hosts)\n\n\tPR bootstrap/14316\n\t* collect2.c: Never include <vfork.h>.\n\t(VFORK_STRING, vfork): Don't define.\n\t(pid): Remove global variable.\n\t(handler): Call raise instead of kill (getpid(), ...).\n\t(collect_wait): Add pex parameter.  Change all callers.  Use\n\tpex_get_status rather than pwait.\n\t(do_wait): Add pex parameter.  Change all callers.\n\t(collect_execute): Return struct pex_obj * rather than void.  Use\n\tpex routines rather than pexecute.\n\t(fork_execute): Get pex_obj from collect_execute, and pass it to\n\tdo_wait.\n\t(scan_prog_file): Use pex routines rather than pipe/vfork/exec.\n\tOnly declare quit_handler if SIGQUIT is defined.\n\t(scan_libraries): Likewise.\n\t* collect2.h (collect_execute): Update declaration.\n\t(collect_wait): Update declaration.\n\t* tlink.c (tlink_execute): Get pex_obj from collect_execute, and\n\tpass it to collect_wait.\n\nFrom-SVN: r97199", "tree": {"sha": "14d07064a525534cdc2996c320b7f9f3da0183a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14d07064a525534cdc2996c320b7f9f3da0183a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1edc3936609d114f92bc547761109c2b823c8e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1edc3936609d114f92bc547761109c2b823c8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1edc3936609d114f92bc547761109c2b823c8e3"}], "stats": {"total": 235, "additions": 105, "deletions": 130}, "files": [{"sha": "467637a9282048e056dc39b40540eac68cc53cf3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "patch": "@@ -1,3 +1,25 @@\n+2005-03-29  Ian Lance Taylor  <ian@airs.com>\n+\n+\tPR bootstrap/14316\n+\t* collect2.c: Never include <vfork.h>.\n+\t(VFORK_STRING, vfork): Don't define.\n+\t(pid): Remove global variable.\n+\t(handler): Call raise instead of kill (getpid(), ...).\n+\t(collect_wait): Add pex parameter.  Change all callers.  Use\n+\tpex_get_status rather than pwait.\n+\t(do_wait): Add pex parameter.  Change all callers.\n+\t(collect_execute): Return struct pex_obj * rather than void.  Use\n+\tpex routines rather than pexecute.\n+\t(fork_execute): Get pex_obj from collect_execute, and pass it to\n+\tdo_wait.\n+\t(scan_prog_file): Use pex routines rather than pipe/vfork/exec.\n+\tOnly declare quit_handler if SIGQUIT is defined.\n+\t(scan_libraries): Likewise.\n+\t* collect2.h (collect_execute): Update declaration.\n+\t(collect_wait): Update declaration.\n+\t* tlink.c (tlink_execute): Get pex_obj from collect_execute, and\n+\tpass it to collect_wait.\n+\n 2005-03-29  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c/20672"}, {"sha": "063cb9fbde1c5d5fbb267c630c0b4cffdca6ad20", "filename": "gcc/collect2.c", "status": "modified", "additions": 75, "deletions": 124, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "patch": "@@ -35,19 +35,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #  define SIGCHLD SIGCLD\n #endif\n \n-#ifdef vfork /* Autoconf may define this to fork for us.  */\n-# define VFORK_STRING \"fork\"\n-#else\n-# define VFORK_STRING \"vfork\"\n-#endif\n-#ifdef HAVE_VFORK_H\n-#include <vfork.h>\n-#endif\n-#ifdef VMS\n-#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \\\n-               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)\n-#endif /* VMS */\n-\n #ifndef LIBRARY_PATH_ENV\n #define LIBRARY_PATH_ENV \"LIBRARY_PATH\"\n #endif\n@@ -217,9 +204,6 @@ static struct head frame_tables;\t/* list of frame unwind info tables */\n struct obstack temporary_obstack;\n char * temporary_firstobj;\n \n-/* Holds the return value of pexecute and fork.  */\n-int pid;\n-\n /* Structure to hold all the directories in which to search for files to\n    execute.  */\n \n@@ -251,7 +235,7 @@ static char *find_a_file (struct path_prefix *, const char *);\n static void add_prefix (struct path_prefix *, const char *);\n static void prefix_from_env (const char *, struct path_prefix *);\n static void prefix_from_string (const char *, struct path_prefix *);\n-static void do_wait (const char *);\n+static void do_wait (const char *, struct pex_obj *);\n static void fork_execute (const char *, char **);\n static void maybe_unlink (const char *);\n static void add_to_list (struct head *, const char *);\n@@ -420,7 +404,7 @@ handler (int signo)\n #endif\n \n   signal (signo, SIG_DFL);\n-  kill (getpid (), signo);\n+  raise (signo);\n }\n \n \f\n@@ -1501,11 +1485,14 @@ main (int argc, char **argv)\n /* Wait for a process to finish, and exit if a nonzero status is found.  */\n \n int\n-collect_wait (const char *prog)\n+collect_wait (const char *prog, struct pex_obj *pex)\n {\n   int status;\n \n-  pwait (pid, &status, 0);\n+  if (!pex_get_status (pex, 1, &status))\n+    fatal_perror (\"can't get program status\");\n+  pex_free (pex);\n+\n   if (status)\n     {\n       if (WIFSIGNALED (status))\n@@ -1524,9 +1511,9 @@ collect_wait (const char *prog)\n }\n \n static void\n-do_wait (const char *prog)\n+do_wait (const char *prog, struct pex_obj *pex)\n {\n-  int ret = collect_wait (prog);\n+  int ret = collect_wait (prog, pex);\n   if (ret != 0)\n     {\n       error (\"%s returned %d exit status\", prog, ret);\n@@ -1537,14 +1524,12 @@ do_wait (const char *prog)\n \f\n /* Execute a program, and wait for the reply.  */\n \n-void\n+struct pex_obj *\n collect_execute (const char *prog, char **argv, const char *redir)\n {\n-  char *errmsg_fmt;\n-  char *errmsg_arg;\n-  int redir_handle = -1;\n-  int stdout_save = -1;\n-  int stderr_save = -1;\n+  struct pex_obj *pex;\n+  const char *errmsg;\n+  int err;\n \n   if (vflag || debug)\n     {\n@@ -1571,47 +1556,35 @@ collect_execute (const char *prog, char **argv, const char *redir)\n   if (argv[0] == 0)\n     fatal (\"cannot find '%s'\", prog);\n \n-  if (redir)\n-    {\n-      /* Open response file.  */\n-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);\n-\n-      /* Duplicate the stdout and stderr file handles\n-\t so they can be restored later.  */\n-      stdout_save = dup (STDOUT_FILENO);\n-      if (stdout_save == -1)\n-\tfatal_perror (\"redirecting stdout: %s\", redir);\n-      stderr_save = dup (STDERR_FILENO);\n-      if (stderr_save == -1)\n-\tfatal_perror (\"redirecting stdout: %s\", redir);\n-\n-      /* Redirect stdout & stderr to our response file.  */\n-      dup2 (redir_handle, STDOUT_FILENO);\n-      dup2 (redir_handle, STDERR_FILENO);\n-    }\n-\n-  pid = pexecute (argv[0], argv, argv[0], NULL, &errmsg_fmt, &errmsg_arg,\n-\t\t  (PEXECUTE_FIRST | PEXECUTE_LAST | PEXECUTE_SEARCH));\n+  pex = pex_init (0, \"collect2\", NULL);\n+  if (pex == NULL)\n+    fatal_perror (\"pex_init failed\");\n \n-  if (redir)\n+  errmsg = pex_run (pex,\n+\t\t    (PEX_LAST | PEX_SEARCH\n+\t\t     | (redir ? PEX_STDERR_TO_STDOUT : 0)),\n+\t\t    argv[0], argv, redir, NULL, &err);\n+  if (errmsg != NULL)\n     {\n-      /* Restore stdout and stderr to their previous settings.  */\n-      dup2 (stdout_save, STDOUT_FILENO);\n-      dup2 (stderr_save, STDERR_FILENO);\n-\n-      /* Close response file.  */\n-      close (redir_handle);\n+      if (err != 0)\n+\t{\n+\t  errno = err;\n+\t  fatal_perror (errmsg);\n+\t}\n+      else\n+\tfatal (errmsg);\n     }\n \n- if (pid == -1)\n-   fatal_perror (errmsg_fmt, errmsg_arg);\n+  return pex;\n }\n \n static void\n fork_execute (const char *prog, char **argv)\n {\n-  collect_execute (prog, argv, NULL);\n-  do_wait (prog);\n+  struct pex_obj *pex;\n+\n+  pex = collect_execute (prog, argv, NULL);\n+  do_wait (prog, pex);\n }\n \f\n /* Unlink a file unless we are debugging.  */\n@@ -2033,11 +2006,15 @@ static void\n scan_prog_file (const char *prog_name, enum pass which_pass)\n {\n   void (*int_handler) (int);\n+#ifdef SIGQUIT\n   void (*quit_handler) (int);\n+#endif\n   char *real_nm_argv[4];\n   const char **nm_argv = (const char **) real_nm_argv;\n   int argc = 0;\n-  int pipe_fd[2];\n+  struct pex_obj *pex;\n+  const char *errmsg;\n+  int err;\n   char *p, buf[1024];\n   FILE *inf;\n \n@@ -2055,13 +2032,6 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n   nm_argv[argc++] = prog_name;\n   nm_argv[argc++] = (char *) 0;\n \n-  if (pipe (pipe_fd) < 0)\n-    fatal_perror (\"pipe\");\n-\n-  inf = fdopen (pipe_fd[0], \"r\");\n-  if (inf == (FILE *) 0)\n-    fatal_perror (\"fdopen\");\n-\n   /* Trace if needed.  */\n   if (vflag)\n     {\n@@ -2077,35 +2047,30 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n   fflush (stdout);\n   fflush (stderr);\n \n-  /* Spawn child nm on pipe.  */\n-  pid = vfork ();\n-  if (pid == -1)\n-    fatal_perror (VFORK_STRING);\n+  pex = pex_init (PEX_USE_PIPES, \"collect2\", NULL);\n+  if (pex == NULL)\n+    fatal_perror (\"pex_init failed\");\n \n-  if (pid == 0)\t\t\t/* child context */\n+  errmsg = pex_run (pex, 0, nm_file_name, real_nm_argv, NULL, NULL, &err);\n+  if (errmsg != NULL)\n     {\n-      /* setup stdout */\n-      if (dup2 (pipe_fd[1], 1) < 0)\n-\tfatal_perror (\"dup2 %d 1\", pipe_fd[1]);\n-\n-      if (close (pipe_fd[0]) < 0)\n-\tfatal_perror (\"close %d\", pipe_fd[0]);\n-\n-      if (close (pipe_fd[1]) < 0)\n-\tfatal_perror (\"close %d\", pipe_fd[1]);\n-\n-      execv (nm_file_name, real_nm_argv);\n-      fatal_perror (\"execv %s\", nm_file_name);\n+      if (err != 0)\n+\t{\n+\t  errno = err;\n+\t  fatal_perror (errmsg);\n+\t}\n+      else\n+\tfatal (errmsg);\n     }\n \n-  /* Parent context from here on.  */\n   int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);\n #ifdef SIGQUIT\n   quit_handler = (void (*) (int)) signal (SIGQUIT, SIG_IGN);\n #endif\n \n-  if (close (pipe_fd[1]) < 0)\n-    fatal_perror (\"close %d\", pipe_fd[1]);\n+  inf = pex_read_output (pex, 0);\n+  if (inf == NULL)\n+    fatal_perror (\"can't open nm output\");\n \n   if (debug)\n     fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n@@ -2179,10 +2144,7 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n   if (debug)\n     fprintf (stderr, \"\\n\");\n \n-  if (fclose (inf) != 0)\n-    fatal_perror (\"fclose\");\n-\n-  do_wait (nm_file_name);\n+  do_wait (nm_file_name, pex);\n \n   signal (SIGINT,  int_handler);\n #ifdef SIGQUIT\n@@ -2202,11 +2164,15 @@ scan_libraries (const char *prog_name)\n   static struct head libraries;\t\t/* list of shared libraries found */\n   struct id *list;\n   void (*int_handler) (int);\n+#ifdef SIGQUIT\n   void (*quit_handler) (int);\n+#endif\n   char *real_ldd_argv[4];\n   const char **ldd_argv = (const char **) real_ldd_argv;\n   int argc = 0;\n-  int pipe_fd[2];\n+  struct pex_obj *pex;\n+  const char *errmsg;\n+  int err;\n   char buf[1024];\n   FILE *inf;\n \n@@ -2221,13 +2187,6 @@ scan_libraries (const char *prog_name)\n   ldd_argv[argc++] = prog_name;\n   ldd_argv[argc++] = (char *) 0;\n \n-  if (pipe (pipe_fd) < 0)\n-    fatal_perror (\"pipe\");\n-\n-  inf = fdopen (pipe_fd[0], \"r\");\n-  if (inf == (FILE *) 0)\n-    fatal_perror (\"fdopen\");\n-\n   /* Trace if needed.  */\n   if (vflag)\n     {\n@@ -2243,35 +2202,30 @@ scan_libraries (const char *prog_name)\n   fflush (stdout);\n   fflush (stderr);\n \n-  /* Spawn child ldd on pipe.  */\n-  pid = vfork ();\n-  if (pid == -1)\n-    fatal_perror (VFORK_STRING);\n+  pex = pex_init (PEX_USE_PIPES, \"collect2\", NULL);\n+  if (pex == NULL)\n+    fatal_perror (\"pex_init failed\");\n \n-  if (pid == 0)\t\t\t/* child context */\n+  errmsg = pex_run (pex, 0, ldd_file_name, real_ldd_argv, NULL, NULL, &err);\n+  if (errmsg != NULL)\n     {\n-      /* setup stdout */\n-      if (dup2 (pipe_fd[1], 1) < 0)\n-\tfatal_perror (\"dup2 %d 1\", pipe_fd[1]);\n-\n-      if (close (pipe_fd[0]) < 0)\n-\tfatal_perror (\"close %d\", pipe_fd[0]);\n-\n-      if (close (pipe_fd[1]) < 0)\n-\tfatal_perror (\"close %d\", pipe_fd[1]);\n-\n-      execv (ldd_file_name, real_ldd_argv);\n-      fatal_perror (\"execv %s\", ldd_file_name);\n+      if (err != 0)\n+\t{\n+\t  errno = err;\n+\t  fatal_perror (errmsg);\n+\t}\n+      else\n+\tfatal (errmsg);\n     }\n \n-  /* Parent context from here on.  */\n   int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);\n #ifdef SIGQUIT\n   quit_handler = (void (*) (int)) signal (SIGQUIT, SIG_IGN);\n #endif\n \n-  if (close (pipe_fd[1]) < 0)\n-    fatal_perror (\"close %d\", pipe_fd[1]);\n+  inf = pex_read_output (pex, 0);\n+  if (inf == NULL)\n+    fatal_perror (\"can't open ldd output\");\n \n   if (debug)\n     notice (\"\\nldd output with constructors/destructors.\\n\");\n@@ -2309,10 +2263,7 @@ scan_libraries (const char *prog_name)\n   if (debug)\n     fprintf (stderr, \"\\n\");\n \n-  if (fclose (inf) != 0)\n-    fatal_perror (\"fclose\");\n-\n-  do_wait (ldd_file_name);\n+  do_wait (ldd_file_name, pex);\n \n   signal (SIGINT,  int_handler);\n #ifdef SIGQUIT"}, {"sha": "9eabc63b25274d16a0c8cb492708d721a5d85db5", "filename": "gcc/collect2.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2Fcollect2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2Fcollect2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.h?ref=1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "patch": "@@ -1,5 +1,5 @@\n /* Header file for collect/tlink routines.\n-   Copyright (C) 1998, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -23,11 +23,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n extern void do_tlink (char **, char **);\n \n-extern void collect_execute (const char *, char **, const char *);\n+extern struct pex_obj *collect_execute (const char *, char **, const char *);\n \n extern void collect_exit (int) ATTRIBUTE_NORETURN;\n \n-extern int collect_wait (const char *);\n+extern int collect_wait (const char *, struct pex_obj *);\n \n extern void dump_file (const char *);\n "}, {"sha": "bf4e1d757b0f3dcfc9f9f30413a0a300a61e7e21", "filename": "gcc/tlink.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=1fff69c9a4ac6a18dcb45abbb311ae1e3e96c6e7", "patch": "@@ -1,7 +1,7 @@\n /* Scan linker error messages for missing template instantiations and provide\n    them.\n \n-   Copyright (C) 1995, 1998, 1999, 2000, 2001, 2003, 2004\n+   Copyright (C) 1995, 1998, 1999, 2000, 2001, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n    Contributed by Jason Merrill (jason@cygnus.com).\n \n@@ -281,8 +281,10 @@ tlink_init (void)\n static int\n tlink_execute (const char *prog, char **argv, const char *redir)\n {\n-  collect_execute (prog, argv, redir);\n-  return collect_wait (prog);\n+  struct pex_obj *pex;\n+\n+  pex = collect_execute (prog, argv, redir);\n+  return collect_wait (prog, pex);\n }\n \n static char *"}]}