{"sha": "246af050e7d8a91b14dc00f277a8c549260e2168", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ2YWYwNTBlN2Q4YTkxYjE0ZGMwMGYyNzdhOGM1NDkyNjBlMjE2OA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2016-07-28T11:01:34Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2016-07-28T11:01:34Z"}, "message": "make pattern_regs a vec\n\ngcc/ChangeLog:\n\n2016-07-28  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* store-motion.c (struct st_expr): Make pattern_regs a vector.\n\t(extract_mentioned_regs): Append to a vector instead of\n\treturning a rtx_expr_list.\n\t(st_expr_entry): Adjust.\n\t(free_st_expr_entry): Likewise.\n\t(store_ops_ok): Likewise.\n\t(store_killed_in_insn): Likewise.\n\t(find_moveable_store): Likewise.\n\nFrom-SVN: r238812", "tree": {"sha": "04156d321e5699e3459ada251e85df654bf1c088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04156d321e5699e3459ada251e85df654bf1c088"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/246af050e7d8a91b14dc00f277a8c549260e2168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246af050e7d8a91b14dc00f277a8c549260e2168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/246af050e7d8a91b14dc00f277a8c549260e2168", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246af050e7d8a91b14dc00f277a8c549260e2168/comments", "author": null, "committer": null, "parents": [{"sha": "1225d6b1134b5eb31bcb592ac46a4d479dcb62b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1225d6b1134b5eb31bcb592ac46a4d479dcb62b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1225d6b1134b5eb31bcb592ac46a4d479dcb62b1"}], "stats": {"total": 63, "additions": 37, "deletions": 26}, "files": [{"sha": "f8c9d175e779a234a324dc0f82e766fb725fb0d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246af050e7d8a91b14dc00f277a8c549260e2168/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246af050e7d8a91b14dc00f277a8c549260e2168/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=246af050e7d8a91b14dc00f277a8c549260e2168", "patch": "@@ -1,3 +1,14 @@\n+2016-07-28  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* store-motion.c (struct st_expr): Make pattern_regs a vector.\n+\t(extract_mentioned_regs): Append to a vector instead of\n+\treturning a rtx_expr_list.\n+\t(st_expr_entry): Adjust.\n+\t(free_st_expr_entry): Likewise.\n+\t(store_ops_ok): Likewise.\n+\t(store_killed_in_insn): Likewise.\n+\t(find_moveable_store): Likewise.\n+\n 2016-07-28  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/68025"}, {"sha": "0bac1b57626fa8e5c29e269cf580a4ec70b10e32", "filename": "gcc/store-motion.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246af050e7d8a91b14dc00f277a8c549260e2168/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246af050e7d8a91b14dc00f277a8c549260e2168/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=246af050e7d8a91b14dc00f277a8c549260e2168", "patch": "@@ -63,7 +63,7 @@ struct st_expr\n   /* Pattern of this mem.  */\n   rtx pattern;\n   /* List of registers mentioned by the mem.  */\n-  rtx pattern_regs;\n+  vec<rtx> pattern_regs;\n   /* INSN list of stores that are locally anticipatable.  */\n   vec<rtx_insn *> antic_stores;\n   /* INSN list of stores that are locally available.  */\n@@ -146,7 +146,7 @@ st_expr_entry (rtx x)\n \n   ptr->next         = store_motion_mems;\n   ptr->pattern      = x;\n-  ptr->pattern_regs = NULL_RTX;\n+  ptr->pattern_regs.create (0);\n   ptr->antic_stores.create (0);\n   ptr->avail_stores.create (0);\n   ptr->reaching_reg = NULL_RTX;\n@@ -165,6 +165,7 @@ free_st_expr_entry (struct st_expr * ptr)\n {\n   ptr->antic_stores.release ();\n   ptr->avail_stores.release ();\n+  ptr->pattern_regs.release ();\n \n   free (ptr);\n }\n@@ -248,35 +249,30 @@ print_store_motion_mems (FILE * file)\n    due to set of registers in bitmap REGS_SET.  */\n \n static bool\n-store_ops_ok (const_rtx x, int *regs_set)\n+store_ops_ok (const vec<rtx> &x, int *regs_set)\n {\n-  const_rtx reg;\n-\n-  for (; x; x = XEXP (x, 1))\n-    {\n-      reg = XEXP (x, 0);\n-      if (regs_set[REGNO (reg)])\n-\treturn false;\n-    }\n+  unsigned int i;\n+  rtx temp;\n+  FOR_EACH_VEC_ELT (x, i, temp)\n+    if (regs_set[REGNO (temp)])\n+      return false;\n \n   return true;\n }\n \n /* Returns a list of registers mentioned in X.\n    FIXME: A regset would be prettier and less expensive.  */\n \n-static rtx_expr_list *\n-extract_mentioned_regs (rtx x)\n+static void\n+extract_mentioned_regs (rtx x, vec<rtx> *mentioned_regs)\n {\n-  rtx_expr_list *mentioned_regs = NULL;\n   subrtx_var_iterator::array_type array;\n   FOR_EACH_SUBRTX_VAR (iter, array, x, NONCONST)\n     {\n       rtx x = *iter;\n       if (REG_P (x))\n-\tmentioned_regs = alloc_EXPR_LIST (0, x, mentioned_regs);\n+\tmentioned_regs->safe_push (x);\n     }\n-  return mentioned_regs;\n }\n \n /* Check to see if the load X is aliased with STORE_PATTERN.\n@@ -373,9 +369,10 @@ store_killed_in_pat (const_rtx x, const_rtx pat, int after)\n    after the insn.  Return true if it does.  */\n \n static bool\n-store_killed_in_insn (const_rtx x, const_rtx x_regs, const rtx_insn *insn, int after)\n+store_killed_in_insn (const_rtx x, const vec<rtx> &x_regs,\n+\t\t      const rtx_insn *insn, int after)\n {\n-  const_rtx reg, note, pat;\n+  const_rtx note, pat;\n \n   if (! NONDEBUG_INSN_P (insn))\n     return false;\n@@ -389,8 +386,10 @@ store_killed_in_insn (const_rtx x, const_rtx x_regs, const rtx_insn *insn, int a\n \n       /* But even a const call reads its parameters.  Check whether the\n \t base of some of registers used in mem is stack pointer.  */\n-      for (reg = x_regs; reg; reg = XEXP (reg, 1))\n-\tif (may_be_sp_based_p (XEXP (reg, 0)))\n+      rtx temp;\n+      unsigned int i;\n+      FOR_EACH_VEC_ELT (x_regs, i, temp)\n+\tif (may_be_sp_based_p (temp))\n \t  return true;\n \n       return false;\n@@ -435,8 +434,8 @@ store_killed_in_insn (const_rtx x, const_rtx x_regs, const rtx_insn *insn, int a\n    is killed, return the last insn in that it occurs in FAIL_INSN.  */\n \n static bool\n-store_killed_after (const_rtx x, const_rtx x_regs, const rtx_insn *insn,\n-\t\t    const_basic_block bb,\n+store_killed_after (const_rtx x, const vec<rtx> &x_regs,\n+\t\t    const rtx_insn *insn, const_basic_block bb,\n \t\t    int *regs_set_after, rtx *fail_insn)\n {\n   rtx_insn *last = BB_END (bb), *act;\n@@ -465,8 +464,9 @@ store_killed_after (const_rtx x, const_rtx x_regs, const rtx_insn *insn,\n    within basic block BB. X_REGS is list of registers mentioned in X.\n    REGS_SET_BEFORE is bitmap of registers set before or in this insn.  */\n static bool\n-store_killed_before (const_rtx x, const_rtx x_regs, const rtx_insn *insn,\n-\t\t     const_basic_block bb, int *regs_set_before)\n+store_killed_before (const_rtx x, const vec<rtx> &x_regs,\n+\t\t     const rtx_insn *insn, const_basic_block bb,\n+\t\t     int *regs_set_before)\n {\n   rtx_insn *first = BB_HEAD (bb);\n \n@@ -555,8 +555,8 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n     return;\n \n   ptr = st_expr_entry (dest);\n-  if (!ptr->pattern_regs)\n-    ptr->pattern_regs = extract_mentioned_regs (dest);\n+  if (ptr->pattern_regs.is_empty ())\n+    extract_mentioned_regs (dest, &ptr->pattern_regs);\n \n   /* Do not check for anticipatability if we either found one anticipatable\n      store already, or tested for one and found out that it was killed.  */"}]}