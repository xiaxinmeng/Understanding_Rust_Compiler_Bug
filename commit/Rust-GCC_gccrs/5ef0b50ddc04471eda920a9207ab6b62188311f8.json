{"sha": "5ef0b50ddc04471eda920a9207ab6b62188311f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVmMGI1MGRkYzA0NDcxZWRhOTIwYTkyMDdhYjZiNjIxODgzMTFmOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-09-14T13:28:44Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-09-14T13:28:44Z"}, "message": "re PR rtl-optimization/44194 (struct returned by value generates useless stores)\n\n\tPR rtl-optimization/44194\n\t* calls.c (expand_call): In the PARALLEL case, copy the return value\n\tinto pseudos instead of spilling it onto the stack.\n\t* emit-rtl.c (adjust_address_1): Rename ADJUST into ADJUST_ADDRESS and\n\tadd new ADJUST_OBJECT parameter.\n\tIf ADJUST_OBJECT is set, drop the underlying object if it cannot be\n\tproved that the adjusted memory access is still within its bounds.\n\t(adjust_automodify_address_1): Adjust call to adjust_address_1.\n\t(widen_memory_access): Likewise.\n\t* expmed.c (store_bit_field_1): Call adjust_bitfield_address instead\n\tof adjust_address.  Do not drop the underlying object of a MEM.\n\t(store_fixed_bit_field): Likewise.\n\t(extract_bit_field_1): Likewise.  Fix oversight in recursion.\n\t(extract_fixed_bit_field): Likewise.\n\t* expr.h (adjust_address_1): Adjust prototype.\n\t(adjust_address): Adjust call to adjust_address_1.\n\t(adjust_address_nv): Likewise.\n\t(adjust_bitfield_address): New macro.\n\t(adjust_bitfield_address_nv): Likewise.\n\t* expr.c (expand_assignment): Handle a PARALLEL in more cases.\n\t(store_expr): Likewise.\n\t(store_field): Likewise.\n\n\t* dse.c: Fix typos in the head comment.\n\nFrom-SVN: r191302", "tree": {"sha": "5c32661073d991fc5ce315762062115ab0af337c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c32661073d991fc5ce315762062115ab0af337c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ef0b50ddc04471eda920a9207ab6b62188311f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ef0b50ddc04471eda920a9207ab6b62188311f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ef0b50ddc04471eda920a9207ab6b62188311f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ef0b50ddc04471eda920a9207ab6b62188311f8/comments", "author": null, "committer": null, "parents": [{"sha": "fcf8632eede077dd7ca327768af56e28f2d3fdca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf8632eede077dd7ca327768af56e28f2d3fdca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf8632eede077dd7ca327768af56e28f2d3fdca"}], "stats": {"total": 245, "additions": 165, "deletions": 80}, "files": [{"sha": "847b12089d97379d2ec41d162768e7139f57dbe3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -1,3 +1,30 @@\n+2012-09-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/44194\n+\t* calls.c (expand_call): In the PARALLEL case, copy the return value\n+\tinto pseudos instead of spilling it onto the stack.\n+\t* emit-rtl.c (adjust_address_1): Rename ADJUST into ADJUST_ADDRESS and\n+\tadd new ADJUST_OBJECT parameter.\n+\tIf ADJUST_OBJECT is set, drop the underlying object if it cannot be\n+\tproved that the adjusted memory access is still within its bounds.\n+\t(adjust_automodify_address_1): Adjust call to adjust_address_1.\n+\t(widen_memory_access): Likewise.\n+\t* expmed.c (store_bit_field_1): Call adjust_bitfield_address instead\n+\tof adjust_address.  Do not drop the underlying object of a MEM.\n+\t(store_fixed_bit_field): Likewise.\n+\t(extract_bit_field_1): Likewise.  Fix oversight in recursion.\n+\t(extract_fixed_bit_field): Likewise.\n+\t* expr.h (adjust_address_1): Adjust prototype.\n+\t(adjust_address): Adjust call to adjust_address_1.\n+\t(adjust_address_nv): Likewise.\n+\t(adjust_bitfield_address): New macro.\n+\t(adjust_bitfield_address_nv): Likewise.\n+\t* expr.c (expand_assignment): Handle a PARALLEL in more cases.\n+\t(store_expr): Likewise.\n+\t(store_field): Likewise.\n+\n+\t* dse.c: Fix typos in the head comment.\n+\n 2012-09-14  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/54546"}, {"sha": "d4d0917bd1e42fb18134cefbad709a3fd0dd1f43", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -3272,16 +3272,8 @@ expand_call (tree exp, rtx target, int ignore)\n       else if (GET_CODE (valreg) == PARALLEL)\n \t{\n \t  if (target == 0)\n-\t    {\n-\t      /* This will only be assigned once, so it can be readonly.  */\n-\t      tree nt = build_qualified_type (rettype,\n-\t\t\t\t\t      (TYPE_QUALS (rettype)\n-\t\t\t\t\t       | TYPE_QUAL_CONST));\n-\n-\t      target = assign_temp (nt, 1, 1);\n-\t    }\n-\n-\t  if (! rtx_equal_p (target, valreg))\n+\t    target = emit_group_move_into_temps (valreg);\n+\t  else if (!rtx_equal_p (target, valreg))\n \t    emit_group_store (target, valreg, rettype,\n \t\t\t      int_size_in_bytes (rettype));\n "}, {"sha": "bd5860e35fa666e97a4c0ae583103c3c0a4e8c18", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -105,7 +105,7 @@ along with GCC; see the file COPYING3.  If not see\n    the first pass could examine a block in either direction.  The\n    forwards ordering is to accommodate cselib.\n \n-   We a simplifying assumption: addresses fall into four broad\n+   We make a simplifying assumption: addresses fall into four broad\n    categories:\n \n    1) base has rtx_varies_p == false, offset is constant.\n@@ -114,18 +114,18 @@ along with GCC; see the file COPYING3.  If not see\n    4) base has rtx_varies_p == true, offset variable.\n \n    The local passes are able to process all 4 kinds of addresses.  The\n-   global pass only handles (1).\n+   global pass only handles 1).\n \n    The global problem is formulated as follows:\n \n      A store, S1, to address A, where A is not relative to the stack\n      frame, can be eliminated if all paths from S1 to the end of the\n-     of the function contain another store to A before a read to A.\n+     function contain another store to A before a read to A.\n \n      If the address A is relative to the stack frame, a store S2 to A\n-     can be eliminated if there are no paths from S1 that reach the\n+     can be eliminated if there are no paths from S2 that reach the\n      end of the function that read A before another store to A.  In\n-     this case S2 can be deleted if there are paths to from S2 to the\n+     this case S2 can be deleted if there are paths from S2 to the\n      end of the function that have no reads or writes to A.  This\n      second case allows stores to the stack frame to be deleted that\n      would otherwise die when the function returns.  This cannot be\n@@ -136,7 +136,7 @@ along with GCC; see the file COPYING3.  If not see\n      dataflow problem where the stores are the gens and reads are the\n      kills.  Set union problems are rare and require some special\n      handling given our representation of bitmaps.  A straightforward\n-     implementation of requires a lot of bitmaps filled with 1s.\n+     implementation requires a lot of bitmaps filled with 1s.\n      These are expensive and cumbersome in our bitmap formulation so\n      care has been taken to avoid large vectors filled with 1s.  See\n      the comments in bb_info and in the dataflow confluence functions"}, {"sha": "f763945590936069fdc4101f99fc5e3454a8988c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -2051,12 +2051,16 @@ change_address (rtx memref, enum machine_mode mode, rtx addr)\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address offset by OFFSET bytes.  If VALIDATE is\n    nonzero, the memory address is forced to be valid.\n-   If ADJUST is zero, OFFSET is only used to update MEM_ATTRS\n-   and caller is responsible for adjusting MEMREF base register.  */\n+   If ADJUST_ADDRESS is zero, OFFSET is only used to update MEM_ATTRS\n+   and the caller is responsible for adjusting MEMREF base register.\n+   If ADJUST_OBJECT is zero, the underlying object associated with the\n+   memory reference is left unchanged and the caller is responsible for\n+   dealing with it.  Otherwise, if the new memory reference is outside\n+   the underlying object, even partially, then the object is dropped.  */\n \n rtx\n adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n-\t\t  int validate, int adjust)\n+\t\t  int validate, int adjust_address, int adjust_object)\n {\n   rtx addr = XEXP (memref, 0);\n   rtx new_rtx;\n@@ -2089,7 +2093,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \t\t>> shift);\n     }\n \n-  if (adjust)\n+  if (adjust_address)\n     {\n       /* If MEMREF is a LO_SUM and the offset is within the alignment of the\n \t object, we can merge it into the LO_SUM.  */\n@@ -2111,10 +2115,26 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n   if (new_rtx == memref && offset != 0)\n     new_rtx = copy_rtx (new_rtx);\n \n+  /* Conservatively drop the object if we don't know where we start from.  */\n+  if (adjust_object && (!attrs.offset_known_p || !attrs.size_known_p))\n+    {\n+      attrs.expr = NULL_TREE;\n+      attrs.alias = 0;\n+    }\n+\n   /* Compute the new values of the memory attributes due to this adjustment.\n      We add the offsets and update the alignment.  */\n   if (attrs.offset_known_p)\n-    attrs.offset += offset;\n+    {\n+      attrs.offset += offset;\n+\n+      /* Drop the object if the new left end is not within its bounds.  */\n+      if (adjust_object && attrs.offset < 0)\n+\t{\n+\t  attrs.expr = NULL_TREE;\n+\t  attrs.alias = 0;\n+\t}\n+    }\n \n   /* Compute the new alignment by taking the MIN of the alignment and the\n      lowest-order set bit in OFFSET, but don't change the alignment if OFFSET\n@@ -2129,16 +2149,24 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n   defattrs = mode_mem_attrs[(int) GET_MODE (new_rtx)];\n   if (defattrs->size_known_p)\n     {\n+      /* Drop the object if the new right end is not within its bounds.  */\n+      if (adjust_object && (offset + defattrs->size) > attrs.size)\n+\t{\n+\t  attrs.expr = NULL_TREE;\n+\t  attrs.alias = 0;\n+\t}\n       attrs.size_known_p = true;\n       attrs.size = defattrs->size;\n     }\n   else if (attrs.size_known_p)\n-    attrs.size -= offset;\n+    {\n+      attrs.size -= offset;\n+      /* ??? The store_by_pieces machinery generates negative sizes.  */\n+      gcc_assert (!(adjust_object && attrs.size < 0));\n+    }\n \n   set_mem_attrs (new_rtx, &attrs);\n \n-  /* At some point, we should validate that this offset is within the object,\n-     if all the appropriate values are known.  */\n   return new_rtx;\n }\n \n@@ -2152,7 +2180,7 @@ adjust_automodify_address_1 (rtx memref, enum machine_mode mode, rtx addr,\n \t\t\t     HOST_WIDE_INT offset, int validate)\n {\n   memref = change_address_1 (memref, VOIDmode, addr, validate);\n-  return adjust_address_1 (memref, mode, offset, validate, 0);\n+  return adjust_address_1 (memref, mode, offset, validate, 0, 0);\n }\n \n /* Return a memory reference like MEMREF, but whose address is changed by\n@@ -2234,7 +2262,7 @@ replace_equiv_address_nv (rtx memref, rtx addr)\n rtx\n widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n {\n-  rtx new_rtx = adjust_address_1 (memref, mode, offset, 1, 1);\n+  rtx new_rtx = adjust_address_1 (memref, mode, offset, 1, 1, 0);\n   struct mem_attrs attrs;\n   unsigned int size = GET_MODE_SIZE (mode);\n "}, {"sha": "cde924636377f06c42f0cb9830a3e3eaad4be721", "filename": "gcc/expmed.c", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -500,7 +500,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t && MEM_ALIGN (op0) % GET_MODE_BITSIZE (fieldmode) == 0))))\n     {\n       if (MEM_P (op0))\n-\top0 = adjust_address (op0, fieldmode, offset);\n+\top0 = adjust_bitfield_address (op0, fieldmode, offset);\n       else if (GET_MODE (op0) != fieldmode)\n \top0 = simplify_gen_subreg (fieldmode, op0, GET_MODE (op0),\n \t\t\t\t   byte_offset);\n@@ -517,7 +517,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     if (imode != GET_MODE (op0))\n       {\n \tif (MEM_P (op0))\n-\t  op0 = adjust_address (op0, imode, 0);\n+\t  op0 = adjust_bitfield_address (op0, imode, 0);\n \telse\n \t  {\n \t    gcc_assert (imode != BLKmode);\n@@ -526,16 +526,6 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       }\n   }\n \n-  /* We may be accessing data outside the field, which means\n-     we can alias adjacent data.  */\n-  /* ?? not always for C++0x memory model ?? */\n-  if (MEM_P (op0))\n-    {\n-      op0 = shallow_copy_rtx (op0);\n-      set_mem_alias_set (op0, 0);\n-      set_mem_expr (op0, 0);\n-    }\n-\n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n      On a bigendian machine, these are not the same, so convert.  */\n@@ -718,7 +708,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       /* Add OFFSET into OP0's address.  */\n       if (MEM_P (xop0))\n-\txop0 = adjust_address (xop0, byte_mode, offset);\n+\txop0 = adjust_bitfield_address (xop0, byte_mode, offset);\n \n       /* If xop0 is a register, we need it in OP_MODE\n \t to make it acceptable to the format of insv.  */\n@@ -852,7 +842,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  unit = GET_MODE_BITSIZE (bestmode);\n \t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n \t  xbitpos = bitnum % unit;\n-\t  xop0 = adjust_address (op0, bestmode, xoffset);\n+\t  xop0 = adjust_bitfield_address (op0, bestmode, xoffset);\n \n \t  /* Fetch that unit, store the bitfield in it, then store\n \t     the unit.  */\n@@ -1024,7 +1014,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \t Then alter OP0 to refer to that word.  */\n       bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;\n       offset -= (offset % (total_bits / BITS_PER_UNIT));\n-      op0 = adjust_address (op0, mode, offset);\n+      op0 = adjust_bitfield_address (op0, mode, offset);\n     }\n \n   mode = GET_MODE (op0);\n@@ -1388,7 +1378,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     if (imode != GET_MODE (op0))\n       {\n \tif (MEM_P (op0))\n-\t  op0 = adjust_address (op0, imode, 0);\n+\t  op0 = adjust_bitfield_address (op0, imode, 0);\n \telse if (imode != BLKmode)\n \t  {\n \t    op0 = gen_lowpart (imode, op0);\n@@ -1414,20 +1404,11 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    rtx mem = assign_stack_temp (GET_MODE (op0),\n \t\t\t\t\t GET_MODE_SIZE (GET_MODE (op0)));\n \t    emit_move_insn (mem, op0);\n-\t    op0 = adjust_address (mem, BLKmode, 0);\n+\t    op0 = adjust_bitfield_address (mem, BLKmode, 0);\n \t  }\n       }\n   }\n \n-  /* We may be accessing data outside the field, which means\n-     we can alias adjacent data.  */\n-  if (MEM_P (op0))\n-    {\n-      op0 = shallow_copy_rtx (op0);\n-      set_mem_alias_set (op0, 0);\n-      set_mem_expr (op0, 0);\n-    }\n-\n   /* Extraction of a full-word or multi-word value from a structure\n      in a register or aligned memory can be done with just a SUBREG.\n      A subword value in the least significant part of a register\n@@ -1487,7 +1468,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t      && MEM_ALIGN (op0) % bitsize == 0)))))\n     {\n       if (MEM_P (op0))\n-\top0 = adjust_address (op0, mode1, offset);\n+\top0 = adjust_bitfield_address (op0, mode1, offset);\n       else if (mode1 != GET_MODE (op0))\n \t{\n \t  rtx sub = simplify_gen_subreg (mode1, op0, GET_MODE (op0),\n@@ -1513,13 +1494,15 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n+      rtx last;\n \n       if (target == 0 || !REG_P (target) || !valid_multiword_target_p (target))\n \ttarget = gen_reg_rtx (mode);\n \n       /* Indicate for flow that the entire target reg is being set.  */\n       emit_clobber (target);\n \n+      last = get_last_insn ();\n       for (i = 0; i < nwords; i++)\n \t{\n \t  /* If I is 0, use the low-order word in both field and target;\n@@ -1536,12 +1519,17 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t     : (int) i * BITS_PER_WORD);\n \t  rtx target_part = operand_subword (target, wordnum, 1, VOIDmode);\n \t  rtx result_part\n-\t    = extract_bit_field (op0, MIN (BITS_PER_WORD,\n-\t\t\t\t\t   bitsize - i * BITS_PER_WORD),\n-\t\t\t\t bitnum + bit_offset, 1, false, target_part, mode,\n-\t\t\t\t word_mode);\n+\t    = extract_bit_field_1 (op0, MIN (BITS_PER_WORD,\n+\t\t\t\t\t     bitsize - i * BITS_PER_WORD),\n+\t\t\t\t   bitnum + bit_offset, 1, false, target_part,\n+\t\t\t\t   mode, word_mode, fallback_p);\n \n \t  gcc_assert (target_part);\n+\t  if (!result_part)\n+\t    {\n+\t      delete_insns_since (last);\n+\t      return NULL;\n+\t    }\n \n \t  if (result_part != target_part)\n \t    emit_move_insn (target_part, result_part);\n@@ -1629,7 +1617,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \txop0 = gen_lowpart_SUBREG (ext_mode, xop0);\n       if (MEM_P (xop0))\n \t/* Get ref to first byte containing part of the field.  */\n-\txop0 = adjust_address (xop0, byte_mode, xoffset);\n+\txop0 = adjust_bitfield_address (xop0, byte_mode, xoffset);\n \n       /* Now convert from counting within UNIT to counting in EXT_MODE.  */\n       if (BYTES_BIG_ENDIAN && !MEM_P (xop0))\n@@ -1725,7 +1713,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t      last = get_last_insn ();\n \n \t      /* Fetch it to a register in that size.  */\n-\t      xop0 = adjust_address (op0, bestmode, xoffset);\n+\t      xop0 = adjust_bitfield_address (op0, bestmode, xoffset);\n \t      xop0 = force_reg (bestmode, xop0);\n \t      result = extract_bit_field_1 (xop0, bitsize, xbitpos,\n \t\t\t\t\t    unsignedp, packedp, target,\n@@ -1906,7 +1894,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t  offset -= (offset % (total_bits / BITS_PER_UNIT));\n \t}\n \n-      op0 = adjust_address (op0, mode, offset);\n+      op0 = adjust_bitfield_address (op0, mode, offset);\n     }\n \n   mode = GET_MODE (op0);"}, {"sha": "c53f1a8dc9b7d0dba5ddb88e3c923acaaf430933", "filename": "gcc/expr.c", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -4870,8 +4870,16 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (to_rtx) == PARALLEL)\n-\temit_group_load (to_rtx, value, TREE_TYPE (from),\n-\t\t\t int_size_in_bytes (TREE_TYPE (from)));\n+\t{\n+\t  if (GET_CODE (value) == PARALLEL)\n+\t    emit_group_move (to_rtx, value);\n+\t  else\n+\t    emit_group_load (to_rtx, value, TREE_TYPE (from),\n+\t\t\t     int_size_in_bytes (TREE_TYPE (from)));\n+\t}\n+      else if (GET_CODE (value) == PARALLEL)\n+\temit_group_store (to_rtx, value, TREE_TYPE (from),\n+\t\t\t  int_size_in_bytes (TREE_TYPE (from)));\n       else if (GET_MODE (to_rtx) == BLKmode)\n \temit_block_move (to_rtx, value, expr_size (from), BLOCK_OP_NORMAL);\n       else\n@@ -4903,9 +4911,16 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       else\n \ttemp = expand_expr (from, NULL_RTX, GET_MODE (to_rtx), EXPAND_NORMAL);\n \n+      /* Handle calls that return values in multiple non-contiguous locations.\n+\t The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (to_rtx) == PARALLEL)\n-\temit_group_load (to_rtx, temp, TREE_TYPE (from),\n-\t\t\t int_size_in_bytes (TREE_TYPE (from)));\n+\t{\n+\t  if (GET_CODE (temp) == PARALLEL)\n+\t    emit_group_move (to_rtx, temp);\n+\t  else\n+\t    emit_group_load (to_rtx, temp, TREE_TYPE (from),\n+\t\t\t     int_size_in_bytes (TREE_TYPE (from)));\n+\t}\n       else if (temp)\n \temit_move_insn (to_rtx, temp);\n \n@@ -5299,16 +5314,22 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n       else if (GET_CODE (target) == PARALLEL)\n-\temit_group_load (target, temp, TREE_TYPE (exp),\n-\t\t\t int_size_in_bytes (TREE_TYPE (exp)));\n+\t{\n+\t  if (GET_CODE (temp) == PARALLEL)\n+\t    emit_group_move (target, temp);\n+\t  else\n+\t    emit_group_load (target, temp, TREE_TYPE (exp),\n+\t\t\t     int_size_in_bytes (TREE_TYPE (exp)));\n+\t}\n+      else if (GET_CODE (temp) == PARALLEL)\n+\temit_group_store (target, temp, TREE_TYPE (exp),\n+\t\t\t  int_size_in_bytes (TREE_TYPE (exp)));\n       else if (GET_MODE (temp) == BLKmode)\n \temit_block_move (target, temp, expr_size (exp),\n \t\t\t (call_param_p\n \t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n-      else if (nontemporal\n-\t       && emit_storent_insn (target, temp))\n-\t/* If we managed to emit a nontemporal store, there is nothing else to\n-\t   do.  */\n+      /* If we emit a nontemporal store, there is nothing else to do.  */\n+      else if (nontemporal && emit_storent_insn (target, temp))\n \t;\n       else\n \t{\n@@ -6429,10 +6450,18 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  return const0_rtx;\n \t}\n \n-      /* Store the value in the bitfield.  */\n-      store_bit_field (target, bitsize, bitpos,\n-\t\t       bitregion_start, bitregion_end,\n-\t\t       mode, temp);\n+      /* Handle calls that return values in multiple non-contiguous locations.\n+\t The Irix 6 ABI has examples of this.  */\n+      if (bitpos == 0\n+\t  && bitsize == GET_MODE_BITSIZE (mode)\n+\t  && GET_CODE (temp) == PARALLEL)\n+\temit_group_store (target, temp, TREE_TYPE (exp),\n+\t\t\t  int_size_in_bytes (TREE_TYPE (exp)));\n+      else\n+\t/* Store the value in the bitfield.  */\n+\tstore_bit_field (target, bitsize, bitpos,\n+\t\t         bitregion_start, bitregion_end,\n+\t\t         mode, temp);\n \n       return const0_rtx;\n     }"}, {"sha": "154648e7bffd24145370076f741486afda9401df", "filename": "gcc/expr.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -557,11 +557,22 @@ extern rtx change_address (rtx, enum machine_mode, rtx);\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address offset by OFFSET bytes.  */\n #define adjust_address(MEMREF, MODE, OFFSET) \\\n-  adjust_address_1 (MEMREF, MODE, OFFSET, 1, 1)\n+  adjust_address_1 (MEMREF, MODE, OFFSET, 1, 1, 0)\n \n /* Likewise, but the reference is not required to be valid.  */\n #define adjust_address_nv(MEMREF, MODE, OFFSET) \\\n-  adjust_address_1 (MEMREF, MODE, OFFSET, 0, 1)\n+  adjust_address_1 (MEMREF, MODE, OFFSET, 0, 1, 0)\n+\n+/* Return a memory reference like MEMREF, but with its mode changed\n+   to MODE and its address offset by OFFSET bytes.  Assume that it's\n+   for a bitfield and conservatively drop the underlying object if we\n+   cannot be sure to stay within its bounds.  */\n+#define adjust_bitfield_address(MEMREF, MODE, OFFSET) \\\n+  adjust_address_1 (MEMREF, MODE, OFFSET, 1, 1, 1)\n+\n+/* Likewise, but the reference is not required to be valid.  */\n+#define adjust_bitfield_address_nv(MEMREF, MODE, OFFSET) \\\n+  adjust_address_1 (MEMREF, MODE, OFFSET, 0, 1, 1)\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR, which is assumed to be\n@@ -573,7 +584,8 @@ extern rtx change_address (rtx, enum machine_mode, rtx);\n #define adjust_automodify_address_nv(MEMREF, MODE, ADDR, OFFSET) \\\n   adjust_automodify_address_1 (MEMREF, MODE, ADDR, OFFSET, 0)\n \n-extern rtx adjust_address_1 (rtx, enum machine_mode, HOST_WIDE_INT, int, int);\n+extern rtx adjust_address_1 (rtx, enum machine_mode, HOST_WIDE_INT, int, int,\n+\t\t\t     int);\n extern rtx adjust_automodify_address_1 (rtx, enum machine_mode, rtx,\n \t\t\t\t\tHOST_WIDE_INT, int);\n "}, {"sha": "1d61616d8a64e7a9728e61f49620b59ed1a84c55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -1,3 +1,7 @@\n+2012-09-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/pr44194-1.c: Check that there are no memory accesses left.\n+\n 2012-09-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/54564"}, {"sha": "1772a9949d3b6df6a2de783a839d16598d31d631", "filename": "gcc/testsuite/gcc.dg/pr44194-1.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef0b50ddc04471eda920a9207ab6b62188311f8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44194-1.c?ref=5ef0b50ddc04471eda920a9207ab6b62188311f8", "patch": "@@ -1,6 +1,7 @@\n /* { dg-do compile { target { { { { { i?86-*-* x86_64-*-* } && x32 } || lp64 } && { ! s390*-*-* } } &&  { ! alpha*-*-* } } } } */\n-/* { dg-options \"-O2 -fdump-rtl-dse1\" } */\n-/* Restricting to 64-bit targets since 32-bit targets return\n+/* { dg-options \"-O2 -fdump-rtl-dse1 -fdump-rtl-final\" } */\n+\n+/* Restrict to 64-bit targets since 32-bit targets usually return small\n    structures in memory.  */\n \n struct ints { int a, b, c; } foo();\n@@ -10,5 +11,9 @@ void func() {\n   struct ints s = foo();\n   bar(s.a, s.b);\n }\n-/* { dg-final { scan-rtl-dump \"global deletions = (2|3)\"  \"dse1\" } } */\n+\n+/* { dg-final { scan-rtl-dump \"global deletions = (2|3)\" \"dse1\" } } */\n /* { dg-final { cleanup-rtl-dump \"dse1\" } } */\n+\n+/* { dg-final { scan-rtl-dump-not \"set \\\\(mem\" \"final\" } } */\n+/* { dg-final { cleanup-rtl-dump \"final\" } } */"}]}