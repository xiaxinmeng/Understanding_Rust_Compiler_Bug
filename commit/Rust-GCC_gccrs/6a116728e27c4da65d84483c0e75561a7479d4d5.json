{"sha": "6a116728e27c4da65d84483c0e75561a7479d4d5", "node_id": "C_kwDOANBUbNoAKDZhMTE2NzI4ZTI3YzRkYTY1ZDg0NDgzYzBlNzU1NjFhNzQ3OWQ0ZDU", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-05-11T12:08:40Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-05-13T10:24:11Z"}, "message": "arm: correctly handle misaligned MEMs on MVE [PR105463]\n\nVector operations in MVE must be aligned to the element size, so if we\nare asked for a misaligned move in a wider mode we must recast it to a\nform suitable for the known alignment (larger elements have better\naddress offset ranges, so there is some advantage to using wider\nelement sizes if possible).  Whilst fixing this, also rework the\npredicates used for validating operands - the Neon predicates are\nnot right for MVE.\n\ngcc/ChangeLog:\n\n\tPR target/105463\n\t* config/arm/mve.md (*movmisalign<mode>_mve_store): Use\n\tmve_memory_operand.\n\t(*movmisalign<mode>_mve_load): Likewise.\n\t* config/arm/vec-common.md (movmisalign<mode>): Convert to generator\n\tform...\n\t(@movmisalign<mode>): ... thus.  Use generic predicates and then\n\trework operands if they are not valid.  For MVE rework to a\n\tnarrower element size if the alignment is not high enough.", "tree": {"sha": "7b3bcb83740b80580ed11c30c19e631ffac8dc77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b3bcb83740b80580ed11c30c19e631ffac8dc77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a116728e27c4da65d84483c0e75561a7479d4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a116728e27c4da65d84483c0e75561a7479d4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a116728e27c4da65d84483c0e75561a7479d4d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a116728e27c4da65d84483c0e75561a7479d4d5/comments", "author": null, "committer": null, "parents": [{"sha": "485a0ae0982abe8ccebdfd660aa45823a572714d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/485a0ae0982abe8ccebdfd660aa45823a572714d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/485a0ae0982abe8ccebdfd660aa45823a572714d"}], "stats": {"total": 94, "additions": 73, "deletions": 21}, "files": [{"sha": "f16991c0a347a8645c23a79f7c51bd30086c523b", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a116728e27c4da65d84483c0e75561a7479d4d5/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a116728e27c4da65d84483c0e75561a7479d4d5/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=6a116728e27c4da65d84483c0e75561a7479d4d5", "patch": "@@ -10462,7 +10462,7 @@\n )\n \n (define_insn \"*movmisalign<mode>_mve_store\"\n-  [(set (match_operand:MVE_VLD_ST 0 \"neon_permissive_struct_operand\"\t     \"=Ux\")\n+  [(set (match_operand:MVE_VLD_ST 0 \"mve_memory_operand\"\t     \"=Ux\")\n \t(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 \"s_register_operand\" \" w\")]\n \t UNSPEC_MISALIGNED_ACCESS))]\n   \"((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))\n@@ -10475,7 +10475,7 @@\n \n (define_insn \"*movmisalign<mode>_mve_load\"\n   [(set (match_operand:MVE_VLD_ST 0 \"s_register_operand\"\t\t\t\t \"=w\")\n-\t(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 \"neon_permissive_struct_operand\" \" Ux\")]\n+\t(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 \"mve_memory_operand\" \" Ux\")]\n \t UNSPEC_MISALIGNED_ACCESS))]\n   \"((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))\n     || (TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE (<MODE>mode)))"}, {"sha": "1fd68f3ac43c64bc980cb59a6bf38e7db2c78be2", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 71, "deletions": 19, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a116728e27c4da65d84483c0e75561a7479d4d5/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a116728e27c4da65d84483c0e75561a7479d4d5/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=6a116728e27c4da65d84483c0e75561a7479d4d5", "patch": "@@ -280,29 +280,81 @@\n   DONE;\n })\n \n-(define_expand \"movmisalign<mode>\"\n- [(set (match_operand:VDQ 0 \"neon_perm_struct_or_reg_operand\")\n-\t(unspec:VDQ [(match_operand:VDQ 1 \"neon_perm_struct_or_reg_operand\")]\n+(define_expand \"@movmisalign<mode>\"\n+ [(set (match_operand:VDQ 0 \"nonimmediate_operand\")\n+\t(unspec:VDQ [(match_operand:VDQ 1 \"general_operand\")]\n \t UNSPEC_MISALIGNED_ACCESS))]\n  \"ARM_HAVE_<MODE>_LDST && !BYTES_BIG_ENDIAN\n   && unaligned_access && !TARGET_REALLY_IWMMXT\"\n {\n- rtx adjust_mem;\n- /* This pattern is not permitted to fail during expansion: if both arguments\n-    are non-registers (e.g. memory := constant, which can be created by the\n-    auto-vectorizer), force operand 1 into a register.  */\n- if (!s_register_operand (operands[0], <MODE>mode)\n-     && !s_register_operand (operands[1], <MODE>mode))\n-   operands[1] = force_reg (<MODE>mode, operands[1]);\n-\n- if (s_register_operand (operands[0], <MODE>mode))\n-   adjust_mem = operands[1];\n- else\n-   adjust_mem = operands[0];\n-\n- /* Legitimize address.  */\n- if (!neon_vector_mem_operand (adjust_mem, 2, true))\n-   XEXP (adjust_mem, 0) = force_reg (Pmode, XEXP (adjust_mem, 0));\n+  rtx *memloc;\n+  bool for_store = false;\n+  /* This pattern is not permitted to fail during expansion: if both arguments\n+     are non-registers (e.g. memory := constant, which can be created by the\n+     auto-vectorizer), force operand 1 into a register.  */\n+  if (!s_register_operand (operands[0], <MODE>mode)\n+      && !s_register_operand (operands[1], <MODE>mode))\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+\n+  if (s_register_operand (operands[0], <MODE>mode))\n+    memloc = &operands[1];\n+  else\n+    {\n+      memloc = &operands[0];\n+      for_store = true;\n+    }\n+\n+  /* For MVE, vector loads/stores must be aligned to the element size.  If the\n+     alignment is less than that convert the load/store to a suitable mode.  */\n+  if (TARGET_HAVE_MVE\n+      && (MEM_ALIGN (*memloc)\n+\t  < GET_MODE_ALIGNMENT (GET_MODE_INNER (<MODE>mode))))\n+    {\n+      scalar_mode new_smode;\n+      switch (MEM_ALIGN (*memloc))\n+\t{\n+\tcase 64:\n+\tcase 32:\n+\t  new_smode = SImode;\n+\t  break;\n+\tcase 16:\n+\t  new_smode = HImode;\n+\t  break;\n+\tdefault:\n+\t  new_smode = QImode;\n+\t  break;\n+\t}\n+      machine_mode new_mode\n+\t= mode_for_vector (new_smode,\n+\t\t\t   GET_MODE_SIZE (<MODE>mode)\n+\t\t\t   / GET_MODE_SIZE (new_smode)).require ();\n+      rtx new_mem = adjust_address (*memloc, new_mode, 0);\n+\n+      if (!for_store)\n+\t{\n+\t  rtx reg = gen_reg_rtx (new_mode);\n+\t  emit_insn (gen_movmisalign (new_mode, reg, new_mem));\n+\t  emit_move_insn (operands[0], gen_lowpart (<MODE>mode, reg));\n+\t  DONE;\n+\t}\n+      emit_insn (gen_movmisalign (new_mode, new_mem,\n+\t\t\t\t  gen_lowpart (new_mode, operands[1])));\n+      DONE;\n+    }\n+\n+  /* Legitimize address.  */\n+  if ((TARGET_HAVE_MVE\n+       && !mve_vector_mem_operand (<MODE>mode, XEXP (*memloc, 0), false))\n+      || (!TARGET_HAVE_MVE\n+\t  && !neon_vector_mem_operand (*memloc, 2, false)))\n+    {\n+      rtx new_mem\n+\t= replace_equiv_address (*memloc,\n+\t\t\t\t force_reg (Pmode, XEXP (*memloc, 0)),\n+\t\t\t\t false);\n+      gcc_assert (MEM_ALIGN (new_mem) == MEM_ALIGN (*memloc));\n+      *memloc = new_mem;\n+    }\n })\n \n (define_insn \"mve_vshlq_<supf><mode>\""}]}