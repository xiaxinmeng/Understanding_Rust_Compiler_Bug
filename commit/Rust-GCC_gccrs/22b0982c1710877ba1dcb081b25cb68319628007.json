{"sha": "22b0982c1710877ba1dcb081b25cb68319628007", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJiMDk4MmMxNzEwODc3YmExZGNiMDgxYjI1Y2I2ODMxOTYyODAwNw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2010-10-04T20:37:57Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2010-10-04T20:37:57Z"}, "message": "common.opt (fira-coalesce): Remove.\n\n2010-10-04  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* common.opt (fira-coalesce): Remove.\n\n\t* doc/invoke.texi (flag_ira_coalesce): Remove.\n\n\t* ira-color.c (allocno_coalesced_p): Move before\n\tcopy_freq_compare_func.\n\tprocessed_coalesced_allocno_bitmap): Ditto.\n\t(update_conflict_hard_regno_costs): Don't use\n\tALLOCNO_FIRST_COALESCED_ALLOCNO.\n\t(allocno_cost_compare_func, print_coalesced_allocno): Remove.\n\t(assign_hard_reg): Assume no coalesced allocnos.\n\t(get_coalesced_allocnos_attributes): Remove.\n\t(bucket_allocno_compare_func): Assume no coalesced allocnos.\n\t(push_allocno_to_stack): Ditto.\n\t(remove_allocno_from_bucket_and_push): Use\n\tira_print_expanded_allocno instead of print_coalesced_allocno.\n\t(push_allocnos_to_stack): Assume uncoalesced allocnos.\n\t(all_conflicting_hard_regs_coalesced): Ditto.  Rename to\n\tall_conflicting_hard_regs.\n\t(setup_allocno_available_regs_num): Assume uncoalesced allocnos.\n\t(setup_allocno_left_conflicts_size): Ditto.\n\t(put_allocno_into_bucket): Ditto.\n\t(copy_freq_compare_func): Remove.\n\t(copy_freq_compare_func, merge_allocnos): Move before\n\tcoalesced_pseudo_reg_freq_compare.\n\tcoalesced_allocno_conflict_p): Ditto.\n\t(coalesced_allocno_conflict_p, coalesce_allocnos): Ditto.  Remove\n\tparameter.  Assume it true.\n\t(color_allocnos): Assume uncoalesced allocnos.  Use\n\tira_print_expanded_allocno instead of print_coalesced_allocno.\n\t(ira_sort_regnos_for_alter_reg): Call coalesce_allocnos without\n\tparameter.\n\n\t* ira.c: Remove comment about coalescing.\n\nFrom-SVN: r164959", "tree": {"sha": "a7c845ca19f556ec641e6a2203029b2fc16a350b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7c845ca19f556ec641e6a2203029b2fc16a350b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22b0982c1710877ba1dcb081b25cb68319628007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b0982c1710877ba1dcb081b25cb68319628007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22b0982c1710877ba1dcb081b25cb68319628007", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b0982c1710877ba1dcb081b25cb68319628007/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f770d743dff94382ba35cb2ff263cfdc64c34a84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f770d743dff94382ba35cb2ff263cfdc64c34a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f770d743dff94382ba35cb2ff263cfdc64c34a84"}], "stats": {"total": 1127, "additions": 469, "deletions": 658}, "files": [{"sha": "9ce81a037c2b5be1440c50a0253402f1a309a862", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22b0982c1710877ba1dcb081b25cb68319628007", "patch": "@@ -1,3 +1,40 @@\n+2010-10-04  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* common.opt (fira-coalesce): Remove.\n+\n+\t* doc/invoke.texi (flag_ira_coalesce): Remove.\n+\n+\t* ira-color.c (allocno_coalesced_p): Move before\n+\tcopy_freq_compare_func.\n+\tprocessed_coalesced_allocno_bitmap): Ditto.\n+\t(update_conflict_hard_regno_costs): Don't use\n+\tALLOCNO_FIRST_COALESCED_ALLOCNO.\n+\t(allocno_cost_compare_func, print_coalesced_allocno): Remove.\n+\t(assign_hard_reg): Assume no coalesced allocnos.\n+\t(get_coalesced_allocnos_attributes): Remove.\n+\t(bucket_allocno_compare_func): Assume no coalesced allocnos.\n+\t(push_allocno_to_stack): Ditto.\n+\t(remove_allocno_from_bucket_and_push): Use\n+\tira_print_expanded_allocno instead of print_coalesced_allocno.\n+\t(push_allocnos_to_stack): Assume uncoalesced allocnos.\n+\t(all_conflicting_hard_regs_coalesced): Ditto.  Rename to\n+\tall_conflicting_hard_regs.\n+\t(setup_allocno_available_regs_num): Assume uncoalesced allocnos.\n+\t(setup_allocno_left_conflicts_size): Ditto.\n+\t(put_allocno_into_bucket): Ditto.\n+\t(copy_freq_compare_func): Remove.\n+\t(copy_freq_compare_func, merge_allocnos): Move before\n+\tcoalesced_pseudo_reg_freq_compare.\n+\tcoalesced_allocno_conflict_p): Ditto.\n+\t(coalesced_allocno_conflict_p, coalesce_allocnos): Ditto.  Remove\n+\tparameter.  Assume it true.\n+\t(color_allocnos): Assume uncoalesced allocnos.  Use\n+\tira_print_expanded_allocno instead of print_coalesced_allocno.\n+\t(ira_sort_regnos_for_alter_reg): Call coalesce_allocnos without\n+\tparameter.\n+\n+\t* ira.c: Remove comment about coalescing.\n+\n 2010-10-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/mips/mips.h (target_flags_explicit): Declare for"}, {"sha": "2c1bd833f8a0910ba4d5b320d1e16bf6c70e3e35", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=22b0982c1710877ba1dcb081b25cb68319628007", "patch": "@@ -1004,10 +1004,6 @@ fira-region=\n Common Joined RejectNegative\n -fira-region=[one|all|mixed] Set regions for IRA\n \n-fira-coalesce\n-Common Report Var(flag_ira_coalesce) Init(0)\n-Do optimistic coalescing.\n-\n fira-loop-pressure\n Common Report Var(flag_ira_loop_pressure)\n Use IRA based register pressure calculation"}, {"sha": "af0c90f0d7645b430b99dd2cca47149a4d698d54", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=22b0982c1710877ba1dcb081b25cb68319628007", "patch": "@@ -349,7 +349,7 @@ Objective-C and Objective-C++ Dialects}.\n -finline-small-functions -fipa-cp -fipa-cp-clone -fipa-matrix-reorg @gol\n -fipa-pta -fipa-profile -fipa-pure-const -fipa-reference @gol\n -fipa-struct-reorg -fira-algorithm=@var{algorithm} @gol\n--fira-region=@var{region} -fira-coalesce @gol\n+-fira-region=@var{region} @gol\n -fira-loop-pressure -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n@@ -6416,11 +6416,6 @@ irregular register set, the third one results in faster and generates\n decent code and the smallest size code, and the default value usually\n give the best results in most cases and for most architectures.\n \n-@item -fira-coalesce\n-@opindex fira-coalesce\n-Do optimistic register coalescing.  This option might be profitable for\n-architectures with big regular register files.\n-\n @item -fira-loop-pressure\n @opindex fira-loop-pressure\n Use IRA to evaluate register pressure in loops for decision to move"}, {"sha": "6a6a3304a510c3d9169ddd1492964ad8b43ac040", "filename": "gcc/ira-color.c", "status": "modified", "additions": 431, "deletions": 646, "changes": 1077, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=22b0982c1710877ba1dcb081b25cb68319628007", "patch": "@@ -54,15 +54,6 @@ static bitmap coloring_allocno_bitmap;\n    allocnos.  */\n static bitmap consideration_allocno_bitmap;\n \n-/* TRUE if we coalesced some allocnos.  In other words, if we got\n-   loops formed by members first_coalesced_allocno and\n-   next_coalesced_allocno containing more one allocno.  */\n-static bool allocno_coalesced_p;\n-\n-/* Bitmap used to prevent a repeated allocno processing because of\n-   coalescing.  */\n-static bitmap processed_coalesced_allocno_bitmap;\n-\n /* All allocnos sorted according their priorities.  */\n static ira_allocno_t *sorted_allocnos;\n \n@@ -370,8 +361,7 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class cover_class,\n  \tanother_cover_class = ALLOCNO_COVER_CLASS (another_allocno);\n  \tif (! ira_reg_classes_intersect_p[cover_class][another_cover_class]\n \t    || ALLOCNO_ASSIGNED_P (another_allocno)\n-\t    || ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n-\t\t\t\t\t (another_allocno)))\n+\t    || ALLOCNO_MAY_BE_SPILLED_P (another_allocno))\n \t  continue;\n \tclass_size = ira_class_hard_regs_num[another_cover_class];\n \tira_allocate_and_copy_costs\n@@ -416,58 +406,18 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class cover_class,\n       }\n }\n \n-/* Sort allocnos according to the profit of usage of a hard register\n-   instead of memory for them. */\n-static int\n-allocno_cost_compare_func (const void *v1p, const void *v2p)\n-{\n-  ira_allocno_t p1 = *(const ira_allocno_t *) v1p;\n-  ira_allocno_t p2 = *(const ira_allocno_t *) v2p;\n-  int c1, c2;\n-\n-  c1 = ALLOCNO_UPDATED_MEMORY_COST (p1) - ALLOCNO_UPDATED_COVER_CLASS_COST (p1);\n-  c2 = ALLOCNO_UPDATED_MEMORY_COST (p2) - ALLOCNO_UPDATED_COVER_CLASS_COST (p2);\n-  if (c1 - c2)\n-    return c1 - c2;\n-\n-  /* If regs are equally good, sort by allocno numbers, so that the\n-     results of qsort leave nothing to chance.  */\n-  return ALLOCNO_NUM (p1) - ALLOCNO_NUM (p2);\n-}\n-\n-/* Print all allocnos coalesced with ALLOCNO.  */\n-static void\n-print_coalesced_allocno (ira_allocno_t allocno)\n-{\n-  ira_allocno_t a;\n-\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      ira_print_expanded_allocno (a);\n-      if (a == allocno)\n-\tbreak;\n-      fprintf (ira_dump_file, \"+\");\n-    }\n-}\n-\n-/* Choose a hard register for ALLOCNO (or for all coalesced allocnos\n-   represented by ALLOCNO).  If RETRY_P is TRUE, it means that the\n-   function called from function `ira_reassign_conflict_allocnos' and\n-   `allocno_reload_assign'.  This function implements the optimistic\n-   coalescing too: if we failed to assign a hard register to set of\n-   the coalesced allocnos, we put them onto the coloring stack for\n-   subsequent separate assigning.  */\n+/* Choose a hard register for allocno A.  If RETRY_P is TRUE, it means\n+   that the function called from function\n+   `ira_reassign_conflict_allocnos' and `allocno_reload_assign'.  */\n static bool\n-assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n+assign_hard_reg (ira_allocno_t a, bool retry_p)\n {\n   HARD_REG_SET conflicting_regs[2];\n   int i, j, hard_regno, nregs, best_hard_regno, class_size;\n-  int cost, mem_cost, min_cost, full_cost, min_full_cost, nwords;\n+  int cost, mem_cost, min_cost, full_cost, min_full_cost, nwords, word;\n   int *a_costs;\n   enum reg_class cover_class;\n   enum machine_mode mode;\n-  ira_allocno_t a;\n   static int costs[FIRST_PSEUDO_REGISTER], full_costs[FIRST_PSEUDO_REGISTER];\n #ifndef HONOR_REG_ALLOC_ORDER\n   enum reg_class rclass;\n@@ -477,131 +427,118 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   bool no_stack_reg_p;\n #endif\n \n-  nwords = ALLOCNO_NUM_OBJECTS (allocno);\n-  ira_assert (! ALLOCNO_ASSIGNED_P (allocno));\n-  cover_class = ALLOCNO_COVER_CLASS (allocno);\n+  nwords = ALLOCNO_NUM_OBJECTS (a);\n+  ira_assert (! ALLOCNO_ASSIGNED_P (a));\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n   class_size = ira_class_hard_regs_num[cover_class];\n-  mode = ALLOCNO_MODE (allocno);\n+  mode = ALLOCNO_MODE (a);\n   for (i = 0; i < nwords; i++)\n     CLEAR_HARD_REG_SET (conflicting_regs[i]);\n   best_hard_regno = -1;\n   memset (full_costs, 0, sizeof (int) * class_size);\n   mem_cost = 0;\n-  if (allocno_coalesced_p)\n-    bitmap_clear (processed_coalesced_allocno_bitmap);\n   memset (costs, 0, sizeof (int) * class_size);\n   memset (full_costs, 0, sizeof (int) * class_size);\n #ifdef STACK_REGS\n   no_stack_reg_p = false;\n #endif\n   start_update_cost ();\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      int word;\n-      mem_cost += ALLOCNO_UPDATED_MEMORY_COST (a);\n-\n-      ira_allocate_and_copy_costs (&ALLOCNO_UPDATED_HARD_REG_COSTS (a),\n-\t\t\t\t   cover_class, ALLOCNO_HARD_REG_COSTS (a));\n-      a_costs = ALLOCNO_UPDATED_HARD_REG_COSTS (a);\n+  mem_cost += ALLOCNO_UPDATED_MEMORY_COST (a);\n+  \n+  ira_allocate_and_copy_costs (&ALLOCNO_UPDATED_HARD_REG_COSTS (a),\n+\t\t\t       cover_class, ALLOCNO_HARD_REG_COSTS (a));\n+  a_costs = ALLOCNO_UPDATED_HARD_REG_COSTS (a);\n #ifdef STACK_REGS\n-      no_stack_reg_p = no_stack_reg_p || ALLOCNO_TOTAL_NO_STACK_REG_P (a);\n+  no_stack_reg_p = no_stack_reg_p || ALLOCNO_TOTAL_NO_STACK_REG_P (a);\n #endif\n-      cost = ALLOCNO_UPDATED_COVER_CLASS_COST (a);\n-      for (i = 0; i < class_size; i++)\n-\tif (a_costs != NULL)\n-\t  {\n-\t    costs[i] += a_costs[i];\n-\t    full_costs[i] += a_costs[i];\n-\t  }\n-\telse\n-\t  {\n-\t    costs[i] += cost;\n-\t    full_costs[i] += cost;\n-\t  }\n-      for (word = 0; word < nwords; word++)\n+  cost = ALLOCNO_UPDATED_COVER_CLASS_COST (a);\n+  for (i = 0; i < class_size; i++)\n+    if (a_costs != NULL)\n+      {\n+\tcosts[i] += a_costs[i];\n+\tfull_costs[i] += a_costs[i];\n+      }\n+    else\n+      {\n+\tcosts[i] += cost;\n+\tfull_costs[i] += cost;\n+      }\n+  for (word = 0; word < nwords; word++)\n+    {\n+      ira_object_t conflict_obj;\n+      ira_object_t obj = ALLOCNO_OBJECT (a, word);\n+      ira_object_conflict_iterator oci;\n+      \n+      IOR_HARD_REG_SET (conflicting_regs[word],\n+\t\t\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+      /* Take preferences of conflicting allocnos into account.  */\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t{\n-\t  ira_object_t conflict_obj;\n-\t  ira_object_t obj = ALLOCNO_OBJECT (allocno, word);\n-\t  ira_object_conflict_iterator oci;\n-\n-\t  IOR_HARD_REG_SET (conflicting_regs[word],\n-\t\t\t    OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n-\t  /* Take preferences of conflicting allocnos into account.  */\n-\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t  enum reg_class conflict_cover_class;\n+\t  \n+\t  /* Reload can give another class so we need to check all\n+\t     allocnos.  */\n+\t  if (!retry_p && !bitmap_bit_p (consideration_allocno_bitmap,\n+\t\t\t\t\t ALLOCNO_NUM (conflict_a)))\n+\t    continue;\n+\t  conflict_cover_class = ALLOCNO_COVER_CLASS (conflict_a);\n+\t  ira_assert (ira_reg_classes_intersect_p\n+\t\t      [cover_class][conflict_cover_class]);\n+\t  if (ALLOCNO_ASSIGNED_P (conflict_a))\n \t    {\n-\t      ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n-\t      enum reg_class conflict_cover_class;\n-\t      /* Reload can give another class so we need to check all\n-\t\t allocnos.  */\n-\t      if (!retry_p && !bitmap_bit_p (consideration_allocno_bitmap,\n-\t\t\t\t\t     ALLOCNO_NUM (conflict_allocno)))\n-\t\tcontinue;\n-\t      conflict_cover_class = ALLOCNO_COVER_CLASS (conflict_allocno);\n-\t      ira_assert (ira_reg_classes_intersect_p\n-\t\t\t  [cover_class][conflict_cover_class]);\n-\t      if (ALLOCNO_ASSIGNED_P (conflict_allocno))\n+\t      hard_regno = ALLOCNO_HARD_REGNO (conflict_a);\n+\t      if (hard_regno >= 0\n+\t\t  && ira_class_hard_reg_index[cover_class][hard_regno] >= 0)\n \t\t{\n-\t\t  hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno);\n-\t\t  if (hard_regno >= 0\n-\t\t      && ira_class_hard_reg_index[cover_class][hard_regno] >= 0)\n+\t\t  enum machine_mode mode = ALLOCNO_MODE (conflict_a);\n+\t\t  int conflict_nregs = hard_regno_nregs[hard_regno][mode];\n+\t\t  int n_objects = ALLOCNO_NUM_OBJECTS (conflict_a);\n+\t\t  \n+\t\t  if (conflict_nregs == n_objects && conflict_nregs > 1)\n \t\t    {\n-\t\t      enum machine_mode mode = ALLOCNO_MODE (conflict_allocno);\n-\t\t      int conflict_nregs = hard_regno_nregs[hard_regno][mode];\n-\t\t      int n_objects = ALLOCNO_NUM_OBJECTS (conflict_allocno);\n-\t\t      if (conflict_nregs == n_objects && conflict_nregs > 1)\n-\t\t\t{\n-\t\t\t  int num = OBJECT_SUBWORD (conflict_obj);\n-\t\t\t  if (WORDS_BIG_ENDIAN)\n-\t\t\t    SET_HARD_REG_BIT (conflicting_regs[word],\n-\t\t\t\t\t      hard_regno + n_objects - num - 1);\n-\t\t\t  else\n-\t\t\t    SET_HARD_REG_BIT (conflicting_regs[word],\n-\t\t\t\t\t      hard_regno + num);\n-\t\t\t}\n-\t\t      else\n-\t\t\tIOR_HARD_REG_SET (conflicting_regs[word],\n-\t\t\t\t\t  ira_reg_mode_hard_regset[hard_regno][mode]);\n-\t\t      if (hard_reg_set_subset_p (reg_class_contents[cover_class],\n-\t\t\t\t\t\t conflicting_regs[word]))\n-\t\t\tgoto fail;\n-\t\t    }\n-\t\t}\n-\t      else if (! ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n-\t\t\t\t\t\t   (conflict_allocno)))\n-\t\t{\n-\t\t  int k, *conflict_costs;\n+\t\t      int num = OBJECT_SUBWORD (conflict_obj);\n \n-\t\t  if (allocno_coalesced_p)\n-\t\t    {\n-\t\t      if (!bitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\t\tALLOCNO_NUM (conflict_allocno)))\n-\t\t\tcontinue;\n+\t\t      if (WORDS_BIG_ENDIAN)\n+\t\t\tSET_HARD_REG_BIT (conflicting_regs[word],\n+\t\t\t\t\t  hard_regno + n_objects - num - 1);\n+\t\t      else\n+\t\t\tSET_HARD_REG_BIT (conflicting_regs[word],\n+\t\t\t\t\t  hard_regno + num);\n \t\t    }\n-\n-\t\t  ira_allocate_and_copy_costs\n-\t\t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno),\n-\t\t     conflict_cover_class,\n-\t\t     ALLOCNO_CONFLICT_HARD_REG_COSTS (conflict_allocno));\n-\t\t  conflict_costs\n-\t\t    = ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno);\n-\t\t  if (conflict_costs != NULL)\n-\t\t    for (j = class_size - 1; j >= 0; j--)\n-\t\t      {\n-\t\t\thard_regno = ira_class_hard_regs[cover_class][j];\n-\t\t\tira_assert (hard_regno >= 0);\n-\t\t\tk = (ira_class_hard_reg_index\n-\t\t\t     [conflict_cover_class][hard_regno]);\n-\t\t\tif (k < 0)\n-\t\t\t  continue;\n-\t\t\tfull_costs[j] -= conflict_costs[k];\n-\t\t      }\n-\t\t  queue_update_cost (conflict_allocno, COST_HOP_DIVISOR);\n+\t\t  else\n+\t\t    IOR_HARD_REG_SET\n+\t\t      (conflicting_regs[word],\n+\t\t       ira_reg_mode_hard_regset[hard_regno][mode]);\n+\t\t  if (hard_reg_set_subset_p (reg_class_contents[cover_class],\n+\t\t\t\t\t     conflicting_regs[word]))\n+\t\t    goto fail;\n \t\t}\n \t    }\n+\t  else if (! ALLOCNO_MAY_BE_SPILLED_P (conflict_a))\n+\t    {\n+\t      int k, *conflict_costs;\n+\t      \n+\t      ira_allocate_and_copy_costs\n+\t\t(&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_a),\n+\t\t conflict_cover_class,\n+\t\t ALLOCNO_CONFLICT_HARD_REG_COSTS (conflict_a));\n+\t      conflict_costs\n+\t\t= ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_a);\n+\t      if (conflict_costs != NULL)\n+\t\tfor (j = class_size - 1; j >= 0; j--)\n+\t\t  {\n+\t\t    hard_regno = ira_class_hard_regs[cover_class][j];\n+\t\t    ira_assert (hard_regno >= 0);\n+\t\t    k = (ira_class_hard_reg_index\n+\t\t\t [conflict_cover_class][hard_regno]);\n+\t\t    if (k < 0)\n+\t\t      continue;\n+\t\t    full_costs[j] -= conflict_costs[k];\n+\t\t  }\n+\t      queue_update_cost (conflict_a, COST_HOP_DIVISOR);\n+\t    }\n \t}\n-      if (a == allocno)\n-\tbreak;\n     }\n   /* Take into account preferences of allocnos connected by copies to\n      the conflict allocnos.  */\n@@ -610,13 +547,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   /* Take preferences of allocnos connected by copies into\n      account.  */\n   start_update_cost ();\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      queue_update_cost (a, COST_HOP_DIVISOR);\n-      if (a == allocno)\n-\tbreak;\n-    }\n+  queue_update_cost (a, COST_HOP_DIVISOR);\n   update_conflict_hard_regno_costs (full_costs, cover_class, false);\n   min_cost = min_full_cost = INT_MAX;\n \n@@ -627,7 +558,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   for (i = 0; i < class_size; i++)\n     {\n       hard_regno = ira_class_hard_regs[cover_class][i];\n-      nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (allocno)];\n+      nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (a)];\n #ifdef STACK_REGS\n       if (no_stack_reg_p\n \t  && FIRST_STACK_REG <= hard_regno && hard_regno <= LAST_STACK_REG)\n@@ -689,50 +620,14 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n       best_hard_regno = -1;\n     }\n  fail:\n-  if (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n-      && best_hard_regno < 0\n-      && ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno) != allocno)\n-    {\n-      for (j = 0, a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-\t   a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-\t{\n-\t  ira_assert (! ALLOCNO_IN_GRAPH_P (a));\n-\t  sorted_allocnos[j++] = a;\n-\t  if (a == allocno)\n-\t    break;\n-\t}\n-      qsort (sorted_allocnos, j, sizeof (ira_allocno_t),\n-\t     allocno_cost_compare_func);\n-      for (i = 0; i < j; i++)\n-\t{\n-\t  a = sorted_allocnos[i];\n-\t  ALLOCNO_FIRST_COALESCED_ALLOCNO (a) = a;\n-\t  ALLOCNO_NEXT_COALESCED_ALLOCNO (a) = a;\n-\t  VEC_safe_push (ira_allocno_t, heap, allocno_stack_vec, a);\n-\t  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n-\t    {\n-\t      fprintf (ira_dump_file, \"        Pushing\");\n-\t      print_coalesced_allocno (a);\n-\t      fprintf (ira_dump_file, \"\\n\");\n-\t    }\n-\t}\n-      return false;\n-    }\n   if (best_hard_regno >= 0)\n     allocated_hardreg_p[best_hard_regno] = true;\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      ALLOCNO_HARD_REGNO (a) = best_hard_regno;\n-      ALLOCNO_ASSIGNED_P (a) = true;\n-      if (best_hard_regno >= 0)\n-\tupdate_copy_costs (a, true);\n-      ira_assert (ALLOCNO_COVER_CLASS (a) == cover_class);\n-      /* We don't need updated costs anymore: */\n-      ira_free_allocno_updated_costs (a);\n-      if (a == allocno)\n-\tbreak;\n-    }\n+  ALLOCNO_HARD_REGNO (a) = best_hard_regno;\n+  ALLOCNO_ASSIGNED_P (a) = true;\n+  if (best_hard_regno >= 0)\n+    update_copy_costs (a, true);\n+  /* We don't need updated costs anymore: */\n+  ira_free_allocno_updated_costs (a);\n   return best_hard_regno >= 0;\n }\n \n@@ -784,25 +679,6 @@ add_allocno_to_bucket (ira_allocno_t allocno, ira_allocno_t *bucket_ptr)\n   *bucket_ptr = allocno;\n }\n \n-/* The function returns frequency and number of available hard\n-   registers for allocnos coalesced with ALLOCNO.  */\n-static void\n-get_coalesced_allocnos_attributes (ira_allocno_t allocno, int *freq, int *num)\n-{\n-  ira_allocno_t a;\n-\n-  *freq = 0;\n-  *num = 0;\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      *freq += ALLOCNO_FREQ (a);\n-      *num += ALLOCNO_AVAILABLE_REGS_NUM (a);\n-      if (a == allocno)\n-\tbreak;\n-    }\n-}\n-\n /* Compare two allocnos to define which allocno should be pushed first\n    into the coloring stack.  If the return is a negative number, the\n    allocno given by the first parameter will be pushed first.  In this\n@@ -819,8 +695,10 @@ bucket_allocno_compare_func (const void *v1p, const void *v2p)\n \n   if ((diff = (int) ALLOCNO_COVER_CLASS (a2) - ALLOCNO_COVER_CLASS (a1)) != 0)\n     return diff;\n-  get_coalesced_allocnos_attributes (a1, &a1_freq, &a1_num);\n-  get_coalesced_allocnos_attributes (a2, &a2_freq, &a2_num);\n+  a1_freq = ALLOCNO_FREQ (a1);\n+  a1_num = ALLOCNO_AVAILABLE_REGS_NUM (a1);\n+  a2_freq = ALLOCNO_FREQ (a2);\n+  a2_num = ALLOCNO_AVAILABLE_REGS_NUM (a2);\n   if ((diff = a2_num - a1_num) != 0)\n     return diff;\n   else if ((diff = a1_freq - a2_freq) != 0)\n@@ -928,110 +806,91 @@ static splay_tree uncolorable_allocnos_splay_tree[N_REG_CLASSES];\n    into account.  */\n #define USE_SPLAY_P(CLASS) (uncolorable_allocnos_num[CLASS] > 4000)\n \n-/* Put ALLOCNO onto the coloring stack without removing it from its\n+/* Put allocno A onto the coloring stack without removing it from its\n    bucket.  Pushing allocno to the coloring stack can result in moving\n    conflicting allocnos from the uncolorable bucket to the colorable\n    one.  */\n static void\n-push_allocno_to_stack (ira_allocno_t allocno)\n+push_allocno_to_stack (ira_allocno_t a)\n {\n   int size;\n-  ira_allocno_t a;\n   enum reg_class cover_class;\n+  int i, n = ALLOCNO_NUM_OBJECTS (a);\n \n-  ALLOCNO_IN_GRAPH_P (allocno) = false;\n-  VEC_safe_push (ira_allocno_t, heap, allocno_stack_vec, allocno);\n-  cover_class = ALLOCNO_COVER_CLASS (allocno);\n+  ALLOCNO_IN_GRAPH_P (a) = false;\n+  VEC_safe_push (ira_allocno_t, heap, allocno_stack_vec, a);\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n   if (cover_class == NO_REGS)\n     return;\n-  size = ira_reg_class_nregs[cover_class][ALLOCNO_MODE (allocno)];\n-  if (ALLOCNO_NUM_OBJECTS (allocno) > 1)\n+  size = ira_reg_class_nregs[cover_class][ALLOCNO_MODE (a)];\n+  if (ALLOCNO_NUM_OBJECTS (a) > 1)\n     {\n       /* We will deal with the subwords individually.  */\n-      gcc_assert (size == ALLOCNO_NUM_OBJECTS (allocno));\n+      gcc_assert (size == ALLOCNO_NUM_OBJECTS (a));\n       size = 1;\n     }\n-  if (allocno_coalesced_p)\n-    bitmap_clear (processed_coalesced_allocno_bitmap);\n-\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n+  for (i = 0; i < n; i++)\n     {\n-      int i, n = ALLOCNO_NUM_OBJECTS (a);\n-      for (i = 0; i < n; i++)\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+      int conflict_size;\n+      ira_object_t conflict_obj;\n+      ira_object_conflict_iterator oci;\n+      \n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-\t  int conflict_size;\n-\t  ira_object_t conflict_obj;\n-\t  ira_object_conflict_iterator oci;\n-\n-\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t  int left_conflicts_size;\n+\t  \n+\t  conflict_a = conflict_a;\n+\t  if (!bitmap_bit_p (coloring_allocno_bitmap,\n+\t\t\t     ALLOCNO_NUM (conflict_a)))\n+\t    continue;\n+\t  \n+\t  ira_assert (cover_class\n+\t\t      == ALLOCNO_COVER_CLASS (conflict_a));\n+\t  if (!ALLOCNO_IN_GRAPH_P (conflict_a)\n+\t      || ALLOCNO_ASSIGNED_P (conflict_a))\n+\t    continue;\n+\t  \n+\t  left_conflicts_size = ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_a);\n+\t  conflict_size\n+\t    = (ira_reg_class_nregs\n+\t       [cover_class][ALLOCNO_MODE (conflict_a)]);\n+\t  ira_assert (left_conflicts_size >= size);\n+\t  if (left_conflicts_size + conflict_size\n+\t      <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_a))\n \t    {\n-\t      ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n-\t      int left_conflicts_size;\n-\n-\t      conflict_allocno = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n-\t      if (!bitmap_bit_p (coloring_allocno_bitmap,\n-\t\t\t\t ALLOCNO_NUM (conflict_allocno)))\n-\t\tcontinue;\n-\n-\t      ira_assert (cover_class\n-\t\t\t  == ALLOCNO_COVER_CLASS (conflict_allocno));\n-\t      if (allocno_coalesced_p)\n-\t\t{\n-\t\t  conflict_obj = ALLOCNO_OBJECT (conflict_allocno,\n-\t\t\t\t\t\t OBJECT_SUBWORD (conflict_obj));\n-\t\t  if (!bitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\t    OBJECT_CONFLICT_ID (conflict_obj)))\n-\t\t    continue;\n-\t\t}\n-\n-\t      if (!ALLOCNO_IN_GRAPH_P (conflict_allocno)\n-\t\t  || ALLOCNO_ASSIGNED_P (conflict_allocno))\n-\t\tcontinue;\n-\n-\t      left_conflicts_size = ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno);\n-\t      conflict_size\n-\t\t= (ira_reg_class_nregs\n-\t\t   [cover_class][ALLOCNO_MODE (conflict_allocno)]);\n-\t      ira_assert (left_conflicts_size >= size);\n-\t      if (left_conflicts_size + conflict_size\n-\t\t  <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n-\t\t{\n-\t\t  ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno) -= size;\n-\t\t  continue;\n-\t\t}\n-\t      left_conflicts_size -= size;\n-\t      if (uncolorable_allocnos_splay_tree[cover_class] != NULL\n-\t\t  && !ALLOCNO_SPLAY_REMOVED_P (conflict_allocno)\n-\t\t  && USE_SPLAY_P (cover_class))\n-\t\t{\n-\t\t  ira_assert\n-\t\t    (splay_tree_lookup\n-\t\t     (uncolorable_allocnos_splay_tree[cover_class],\n-\t\t      (splay_tree_key) conflict_allocno) != NULL);\n-\t\t  splay_tree_remove\n-\t\t    (uncolorable_allocnos_splay_tree[cover_class],\n-\t\t     (splay_tree_key) conflict_allocno);\n-\t\t  ALLOCNO_SPLAY_REMOVED_P (conflict_allocno) = true;\n-\t\t  VEC_safe_push (ira_allocno_t, heap,\n-\t\t\t\t removed_splay_allocno_vec,\n-\t\t\t\t conflict_allocno);\n-\t\t}\n-\t      ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno)\n-\t\t= left_conflicts_size;\n-\t      if (left_conflicts_size + conflict_size\n-\t\t  <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n-\t\t{\n-\t\t  delete_allocno_from_bucket\n-\t\t    (conflict_allocno, &uncolorable_allocno_bucket);\n-\t\t  add_allocno_to_ordered_bucket\n-\t\t    (conflict_allocno, &colorable_allocno_bucket);\n-\t\t}\n+\t      ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_a) -= size;\n+\t      continue;\n+\t    }\n+\t  left_conflicts_size -= size;\n+\t  if (uncolorable_allocnos_splay_tree[cover_class] != NULL\n+\t      && !ALLOCNO_SPLAY_REMOVED_P (conflict_a)\n+\t      && USE_SPLAY_P (cover_class))\n+\t    {\n+\t      ira_assert\n+\t\t(splay_tree_lookup\n+\t\t (uncolorable_allocnos_splay_tree[cover_class],\n+\t\t  (splay_tree_key) conflict_a) != NULL);\n+\t      splay_tree_remove\n+\t\t(uncolorable_allocnos_splay_tree[cover_class],\n+\t\t (splay_tree_key) conflict_a);\n+\t      ALLOCNO_SPLAY_REMOVED_P (conflict_a) = true;\n+\t      VEC_safe_push (ira_allocno_t, heap,\n+\t\t\t     removed_splay_allocno_vec,\n+\t\t\t     conflict_a);\n+\t    }\n+\t  ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_a)\n+\t    = left_conflicts_size;\n+\t  if (left_conflicts_size + conflict_size\n+\t      <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_a))\n+\t    {\n+\t      delete_allocno_from_bucket\n+\t\t(conflict_a, &uncolorable_allocno_bucket);\n+\t      add_allocno_to_ordered_bucket\n+\t\t(conflict_a, &colorable_allocno_bucket);\n \t    }\n \t}\n-      if (a == allocno)\n-\tbreak;\n     }\n }\n \n@@ -1049,7 +908,7 @@ remove_allocno_from_bucket_and_push (ira_allocno_t allocno, bool colorable_p)\n   if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n     {\n       fprintf (ira_dump_file, \"      Pushing\");\n-      print_coalesced_allocno (allocno);\n+      ira_print_expanded_allocno (allocno);\n       if (colorable_p)\n \tfprintf (ira_dump_file, \"\\n\");\n       else\n@@ -1227,7 +1086,7 @@ splay_tree_free (void *node, void *data ATTRIBUTE_UNUSED)\n static void\n push_allocnos_to_stack (void)\n {\n-  ira_allocno_t allocno, a, i_allocno, *allocno_vec;\n+  ira_allocno_t allocno, i_allocno, *allocno_vec;\n   enum reg_class cover_class, rclass;\n   int allocno_pri, i_allocno_pri, allocno_cost, i_allocno_cost;\n   int i, j, num, cover_class_allocnos_num[N_REG_CLASSES];\n@@ -1250,16 +1109,7 @@ push_allocnos_to_stack (void)\n     if ((cover_class = ALLOCNO_COVER_CLASS (allocno)) != NO_REGS)\n       {\n \tcover_class_allocnos_num[cover_class]++;\n-\tcost = 0;\n-\tfor (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-\t     a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-\t  {\n-\t    cost += calculate_allocno_spill_cost (a);\n-\t    if (a == allocno)\n-\t      break;\n-\t  }\n-\t/* ??? Remove cost of copies between the coalesced\n-\t   allocnos.  */\n+\tcost = calculate_allocno_spill_cost (allocno);\n \tALLOCNO_TEMP (allocno) = cost;\n       }\n   /* Define place where to put uncolorable allocnos of the same cover\n@@ -1412,7 +1262,7 @@ pop_allocnos_from_stack (void)\n       if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \t{\n \t  fprintf (ira_dump_file, \"      Popping\");\n-\t  print_coalesced_allocno (allocno);\n+\t  ira_print_expanded_allocno (allocno);\n \t  fprintf (ira_dump_file, \"  -- \");\n \t}\n       if (cover_class == NO_REGS)\n@@ -1440,47 +1290,41 @@ pop_allocnos_from_stack (void)\n     }\n }\n \n-/* Loop over all coalesced allocnos of ALLOCNO and their subobjects, collecting\n-   total hard register conflicts in PSET (which the caller must initialize).  */\n+/* Loop over all subobjects of allocno A, collecting total hard\n+   register conflicts in PSET (which the caller must initialize).  */\n static void\n-all_conflicting_hard_regs_coalesced (ira_allocno_t allocno, HARD_REG_SET *pset)\n+all_conflicting_hard_regs (ira_allocno_t a, HARD_REG_SET *pset)\n {\n-  ira_allocno_t a;\n-\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n+  int i;\n+  int n = ALLOCNO_NUM_OBJECTS (a);\n+  \n+  for (i = 0; i < n; i++)\n     {\n-      int i;\n-      int n = ALLOCNO_NUM_OBJECTS (a);\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-\t  IOR_HARD_REG_SET (*pset, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n-\t}\n-      if (a == allocno)\n-\tbreak;\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\n+      IOR_HARD_REG_SET (*pset, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n     }\n }\n \n-/* Set up number of available hard registers for ALLOCNO.  */\n+/* Set up number of available hard registers for allocno A.  */\n static void\n-setup_allocno_available_regs_num (ira_allocno_t allocno)\n+setup_allocno_available_regs_num (ira_allocno_t a)\n {\n   int i, n, hard_regs_num, hard_regno;\n   enum machine_mode mode;\n   enum reg_class cover_class;\n   HARD_REG_SET temp_set;\n \n-  cover_class = ALLOCNO_COVER_CLASS (allocno);\n-  ALLOCNO_AVAILABLE_REGS_NUM (allocno) = ira_available_class_regs[cover_class];\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n+  ALLOCNO_AVAILABLE_REGS_NUM (a) = ira_available_class_regs[cover_class];\n   if (cover_class == NO_REGS)\n     return;\n   CLEAR_HARD_REG_SET (temp_set);\n-  ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (allocno) == allocno);\n+  ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (a) == a);\n   hard_regs_num = ira_class_hard_regs_num[cover_class];\n-  all_conflicting_hard_regs_coalesced (allocno, &temp_set);\n+  all_conflicting_hard_regs (a, &temp_set);\n \n-  mode = ALLOCNO_MODE (allocno);\n+  mode = ALLOCNO_MODE (a);\n   for (n = 0, i = hard_regs_num - 1; i >= 0; i--)\n     {\n       hard_regno = ira_class_hard_regs[cover_class][i];\n@@ -1491,24 +1335,23 @@ setup_allocno_available_regs_num (ira_allocno_t allocno)\n     }\n   if (internal_flag_ira_verbose > 2 && n > 0 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"    Reg %d of %s has %d regs less\\n\",\n-\t     ALLOCNO_REGNO (allocno), reg_class_names[cover_class], n);\n-  ALLOCNO_AVAILABLE_REGS_NUM (allocno) -= n;\n+\t     ALLOCNO_REGNO (a), reg_class_names[cover_class], n);\n+  ALLOCNO_AVAILABLE_REGS_NUM (a) -= n;\n }\n \n-/* Set up ALLOCNO_LEFT_CONFLICTS_SIZE for ALLOCNO.  */\n+/* Set up ALLOCNO_LEFT_CONFLICTS_SIZE for allocno A.  */\n static void\n-setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n+setup_allocno_left_conflicts_size (ira_allocno_t a)\n {\n   int i, hard_regs_num, hard_regno, conflict_allocnos_size;\n-  ira_allocno_t a;\n   enum reg_class cover_class;\n   HARD_REG_SET temp_set;\n \n-  cover_class = ALLOCNO_COVER_CLASS (allocno);\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n   hard_regs_num = ira_class_hard_regs_num[cover_class];\n   CLEAR_HARD_REG_SET (temp_set);\n-  ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (allocno) == allocno);\n-  all_conflicting_hard_regs_coalesced (allocno, &temp_set);\n+  ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (a) == a);\n+  all_conflicting_hard_regs (a, &temp_set);\n \n   AND_HARD_REG_SET (temp_set, reg_class_contents[cover_class]);\n   AND_COMPL_HARD_REG_SET (temp_set, ira_no_alloc_regs);\n@@ -1527,65 +1370,47 @@ setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n \t  }\n       }\n   CLEAR_HARD_REG_SET (temp_set);\n-  if (allocno_coalesced_p)\n-    bitmap_clear (processed_coalesced_allocno_bitmap);\n   if (cover_class != NO_REGS)\n-    for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-\t a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-      {\n-\tint n = ALLOCNO_NUM_OBJECTS (a);\n-\tfor (i = 0; i < n; i++)\n-\t  {\n-\t    ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-\t    ira_object_t conflict_obj;\n-\t    ira_object_conflict_iterator oci;\n-\n-\t    FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n-\t      {\n-\t\tira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n-\n-\t\tconflict_allocno\n-\t\t  = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n-\t\tif (!bitmap_bit_p (consideration_allocno_bitmap,\n-\t\t\t\t   ALLOCNO_NUM (conflict_allocno)))\n-\t\t  continue;\n-\n-\t\tira_assert (cover_class\n-\t\t\t    == ALLOCNO_COVER_CLASS (conflict_allocno));\n-\t\tif (allocno_coalesced_p)\n-\t\t  {\n-\t\t    if (!bitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\t\t ALLOCNO_NUM (conflict_allocno)))\n-\t\t      continue;\n-\t\t  }\n+    {\n+      int n = ALLOCNO_NUM_OBJECTS (a);\n \n-\t\tif (! ALLOCNO_ASSIGNED_P (conflict_allocno))\n-\t\t  conflict_allocnos_size\n-\t\t    += (ira_reg_class_nregs\n-\t\t\t[cover_class][ALLOCNO_MODE (conflict_allocno)]);\n-\t\telse if ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno))\n-\t\t\t >= 0)\n-\t\t  {\n-\t\t    int last = (hard_regno\n-\t\t\t\t+ hard_regno_nregs\n-\t\t\t\t[hard_regno][ALLOCNO_MODE (conflict_allocno)]);\n-\n-\t\t    while (hard_regno < last)\n-\t\t      {\n-\t\t\tif (! TEST_HARD_REG_BIT (temp_set, hard_regno))\n-\t\t\t  {\n-\t\t\t    conflict_allocnos_size++;\n-\t\t\t    SET_HARD_REG_BIT (temp_set, hard_regno);\n-\t\t\t  }\n-\t\t\thard_regno++;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-        if (a == allocno)\n-\t  break;\n-      }\n-  ALLOCNO_LEFT_CONFLICTS_SIZE (allocno) = conflict_allocnos_size;\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  ira_object_t conflict_obj;\n+\t  ira_object_conflict_iterator oci;\n+\t  \n+\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t    {\n+\t      ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t      \n+\t      ira_assert (cover_class\n+\t\t\t  == ALLOCNO_COVER_CLASS (conflict_a));\n+\t      if (! ALLOCNO_ASSIGNED_P (conflict_a))\n+\t\tconflict_allocnos_size\n+\t\t  += (ira_reg_class_nregs\n+\t\t      [cover_class][ALLOCNO_MODE (conflict_a)]);\n+\t      else if ((hard_regno = ALLOCNO_HARD_REGNO (conflict_a))\n+\t\t       >= 0)\n+\t\t{\n+\t\t  int last = (hard_regno\n+\t\t\t      + hard_regno_nregs\n+\t\t\t      [hard_regno][ALLOCNO_MODE (conflict_a)]);\n+\t\t  \n+\t\t  while (hard_regno < last)\n+\t\t    {\n+\t\t      if (! TEST_HARD_REG_BIT (temp_set, hard_regno))\n+\t\t\t{\n+\t\t\t  conflict_allocnos_size++;\n+\t\t\t  SET_HARD_REG_BIT (temp_set, hard_regno);\n+\t\t\t}\n+\t\t      hard_regno++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  ALLOCNO_LEFT_CONFLICTS_SIZE (a) = conflict_allocnos_size;\n }\n \n /* Put ALLOCNO in a bucket corresponding to its number and size of its\n@@ -1596,8 +1421,6 @@ put_allocno_into_bucket (ira_allocno_t allocno)\n   enum reg_class cover_class;\n \n   cover_class = ALLOCNO_COVER_CLASS (allocno);\n-  if (ALLOCNO_FIRST_COALESCED_ALLOCNO (allocno) != allocno)\n-    return;\n   ALLOCNO_IN_GRAPH_P (allocno) = true;\n   setup_allocno_left_conflicts_size (allocno);\n   setup_allocno_available_regs_num (allocno);\n@@ -1609,220 +1432,19 @@ put_allocno_into_bucket (ira_allocno_t allocno)\n     add_allocno_to_bucket (allocno, &uncolorable_allocno_bucket);\n }\n \n-/* The function is used to sort allocnos according to their execution\n-   frequencies.  */\n-static int\n-copy_freq_compare_func (const void *v1p, const void *v2p)\n-{\n-  ira_copy_t cp1 = *(const ira_copy_t *) v1p, cp2 = *(const ira_copy_t *) v2p;\n-  int pri1, pri2;\n-\n-  pri1 = cp1->freq;\n-  pri2 = cp2->freq;\n-  if (pri2 - pri1)\n-    return pri2 - pri1;\n-\n-  /* If freqencies are equal, sort by copies, so that the results of\n-     qsort leave nothing to chance.  */\n-  return cp1->num - cp2->num;\n-}\n+/* Map: allocno number -> allocno priority.  */\n+static int *allocno_priorities;\n \n-/* Merge two sets of coalesced allocnos given correspondingly by\n-   allocnos A1 and A2 (more accurately merging A2 set into A1\n-   set).  */\n+/* Set up priorities for N allocnos in array\n+   CONSIDERATION_ALLOCNOS.  */\n static void\n-merge_allocnos (ira_allocno_t a1, ira_allocno_t a2)\n+setup_allocno_priorities (ira_allocno_t *consideration_allocnos, int n)\n {\n-  ira_allocno_t a, first, last, next;\n+  int i, length, nrefs, priority, max_priority, mult;\n+  ira_allocno_t a;\n \n-  first = ALLOCNO_FIRST_COALESCED_ALLOCNO (a1);\n-  if (first == ALLOCNO_FIRST_COALESCED_ALLOCNO (a2))\n-    return;\n-  for (last = a2, a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a2);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      ALLOCNO_FIRST_COALESCED_ALLOCNO (a) = first;\n-      if (a == a2)\n-\tbreak;\n-      last = a;\n-    }\n-  next = ALLOCNO_NEXT_COALESCED_ALLOCNO (first);\n-  ALLOCNO_NEXT_COALESCED_ALLOCNO (first) = a2;\n-  ALLOCNO_NEXT_COALESCED_ALLOCNO (last) = next;\n-}\n-\n-/* Given two sets of coalesced sets of allocnos, A1 and A2, this\n-   function determines if any conflicts exist between the two sets.\n-   If RELOAD_P is TRUE, we use live ranges to find conflicts because\n-   conflicts are represented only for allocnos of the same cover class\n-   and during the reload pass we coalesce allocnos for sharing stack\n-   memory slots.  */\n-static bool\n-coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n-\t\t\t      bool reload_p)\n-{\n-  ira_allocno_t a, conflict_allocno;\n-\n-  /* When testing for conflicts, it is sufficient to examine only the\n-     subobjects of order 0, due to the canonicalization of conflicts\n-     we do in record_object_conflict.  */\n-\n-  bitmap_clear (processed_coalesced_allocno_bitmap);\n-  if (allocno_coalesced_p)\n-    {\n-      for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a1);;\n-\t   a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-\t{\n-\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t  OBJECT_CONFLICT_ID (ALLOCNO_OBJECT (a, 0)));\n-\t  if (a == a1)\n-\t    break;\n-\t}\n-    }\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a2);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      if (reload_p)\n-\t{\n-\t  for (conflict_allocno = ALLOCNO_NEXT_COALESCED_ALLOCNO (a1);;\n-\t       conflict_allocno\n-\t\t = ALLOCNO_NEXT_COALESCED_ALLOCNO (conflict_allocno))\n-\t    {\n-\t      if (allocnos_have_intersected_live_ranges_p (a,\n-\t\t\t\t\t\t\t   conflict_allocno))\n-\t\treturn true;\n-\t      if (conflict_allocno == a1)\n-\t\tbreak;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  ira_object_t a_obj = ALLOCNO_OBJECT (a, 0);\n-\t  ira_object_t conflict_obj;\n-\t  ira_object_conflict_iterator oci;\n-\t  FOR_EACH_OBJECT_CONFLICT (a_obj, conflict_obj, oci)\n-\t    if (conflict_obj == ALLOCNO_OBJECT (a1, 0)\n-\t\t|| (allocno_coalesced_p\n-\t\t    && bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t     OBJECT_CONFLICT_ID (conflict_obj))))\n-\t      return true;\n-\t}\n-\n-      if (a == a2)\n-\tbreak;\n-    }\n-  return false;\n-}\n-\n-/* The major function for aggressive allocno coalescing.  For the\n-   reload pass (RELOAD_P) we coalesce only spilled allocnos.  If some\n-   allocnos have been coalesced, we set up flag\n-   allocno_coalesced_p.  */\n-static void\n-coalesce_allocnos (bool reload_p)\n-{\n-  ira_allocno_t a;\n-  ira_copy_t cp, next_cp, *sorted_copies;\n-  enum reg_class cover_class;\n-  enum machine_mode mode;\n-  unsigned int j;\n-  int i, n, cp_num, regno;\n-  bitmap_iterator bi;\n-\n-  sorted_copies = (ira_copy_t *) ira_allocate (ira_copies_num\n-\t\t\t\t\t       * sizeof (ira_copy_t));\n-  cp_num = 0;\n-  /* Collect copies.  */\n-  EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, j, bi)\n-    {\n-      a = ira_allocnos[j];\n-      regno = ALLOCNO_REGNO (a);\n-      if ((! reload_p && ALLOCNO_ASSIGNED_P (a))\n-\t  || (reload_p\n-\t      && (! ALLOCNO_ASSIGNED_P (a) || ALLOCNO_HARD_REGNO (a) >= 0\n-\t\t  || (regno < ira_reg_equiv_len\n-\t\t      && (ira_reg_equiv_const[regno] != NULL_RTX\n-\t\t\t  || ira_reg_equiv_invariant_p[regno])))))\n-\tcontinue;\n-      cover_class = ALLOCNO_COVER_CLASS (a);\n-      mode = ALLOCNO_MODE (a);\n-      for (cp = ALLOCNO_COPIES (a); cp != NULL; cp = next_cp)\n-\t{\n-\t  if (cp->first == a)\n-\t    {\n-\t      next_cp = cp->next_first_allocno_copy;\n-\t      regno = ALLOCNO_REGNO (cp->second);\n-\t      /* For priority coloring we coalesce allocnos only with\n-\t\t the same cover class not with intersected cover\n-\t\t classes as it were possible.  It is done for\n-\t\t simplicity.  */\n-\t      if ((reload_p\n-\t\t   || (ALLOCNO_COVER_CLASS (cp->second) == cover_class\n-\t\t       && ALLOCNO_MODE (cp->second) == mode))\n-\t\t  && (cp->insn != NULL || cp->constraint_p)\n-\t\t  && ((! reload_p && ! ALLOCNO_ASSIGNED_P (cp->second))\n-\t\t      || (reload_p\n-\t\t\t  && ALLOCNO_ASSIGNED_P (cp->second)\n-\t\t\t  && ALLOCNO_HARD_REGNO (cp->second) < 0\n-\t\t\t  && (regno >= ira_reg_equiv_len\n-\t\t\t      || (! ira_reg_equiv_invariant_p[regno]\n-\t\t\t\t  && ira_reg_equiv_const[regno] == NULL_RTX)))))\n-\t\tsorted_copies[cp_num++] = cp;\n-\t    }\n-\t  else if (cp->second == a)\n-\t    next_cp = cp->next_second_allocno_copy;\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-    }\n-  qsort (sorted_copies, cp_num, sizeof (ira_copy_t), copy_freq_compare_func);\n-  /* Coalesced copies, most frequently executed first.  */\n-  for (; cp_num != 0;)\n-    {\n-      for (i = 0; i < cp_num; i++)\n-\t{\n-\t  cp = sorted_copies[i];\n-\t  if (! coalesced_allocno_conflict_p (cp->first, cp->second, reload_p))\n-\t    {\n-\t      allocno_coalesced_p = true;\n-\t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n-\t\tfprintf\n-\t\t  (ira_dump_file,\n-\t\t   \"      Coalescing copy %d:a%dr%d-a%dr%d (freq=%d)\\n\",\n-\t\t   cp->num, ALLOCNO_NUM (cp->first), ALLOCNO_REGNO (cp->first),\n-\t\t   ALLOCNO_NUM (cp->second), ALLOCNO_REGNO (cp->second),\n-\t\t   cp->freq);\n-\t      merge_allocnos (cp->first, cp->second);\n-\t      i++;\n-\t      break;\n-\t    }\n-\t}\n-      /* Collect the rest of copies.  */\n-      for (n = 0; i < cp_num; i++)\n-\t{\n-\t  cp = sorted_copies[i];\n-\t  if (ALLOCNO_FIRST_COALESCED_ALLOCNO (cp->first)\n-\t      != ALLOCNO_FIRST_COALESCED_ALLOCNO (cp->second))\n-\t    sorted_copies[n++] = cp;\n-\t}\n-      cp_num = n;\n-    }\n-  ira_free (sorted_copies);\n-}\n-\n-/* Map: allocno number -> allocno priority.  */\n-static int *allocno_priorities;\n-\n-/* Set up priorities for N allocnos in array\n-   CONSIDERATION_ALLOCNOS.  */\n-static void\n-setup_allocno_priorities (ira_allocno_t *consideration_allocnos, int n)\n-{\n-  int i, length, nrefs, priority, max_priority, mult;\n-  ira_allocno_t a;\n-\n-  max_priority = 0;\n-  for (i = 0; i < n; i++)\n+  max_priority = 0;\n+  for (i = 0; i < n; i++)\n     {\n       a = consideration_allocnos[i];\n       nrefs = ALLOCNO_NREFS (a);\n@@ -1881,10 +1503,6 @@ color_allocnos (void)\n   bitmap_iterator bi;\n   ira_allocno_t a;\n \n-  allocno_coalesced_p = false;\n-  processed_coalesced_allocno_bitmap = ira_allocate_bitmap ();\n-  if (flag_ira_coalesce)\n-    coalesce_allocnos (false);\n   if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n     {\n       n = 0;\n@@ -1900,7 +1518,7 @@ color_allocnos (void)\n \t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \t\t{\n \t\t  fprintf (ira_dump_file, \"      Spill\");\n-\t\t  print_coalesced_allocno (a);\n+\t\t  ira_print_expanded_allocno (a);\n \t\t  fprintf (ira_dump_file, \"\\n\");\n \t\t}\n \t      continue;\n@@ -1918,7 +1536,7 @@ color_allocnos (void)\n \t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \t\t{\n \t\t  fprintf (ira_dump_file, \"      \");\n-\t\t  print_coalesced_allocno (a);\n+\t\t  ira_print_expanded_allocno (a);\n \t\t  fprintf (ira_dump_file, \"  -- \");\n \t\t}\n \t      if (assign_hard_reg (a, false))\n@@ -1952,7 +1570,7 @@ color_allocnos (void)\n \t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \t\t{\n \t\t  fprintf (ira_dump_file, \"      Spill\");\n-\t\t  print_coalesced_allocno (a);\n+\t\t  ira_print_expanded_allocno (a);\n \t\t  fprintf (ira_dump_file, \"\\n\");\n \t\t}\n \t      continue;\n@@ -1962,16 +1580,6 @@ color_allocnos (void)\n       push_allocnos_to_stack ();\n       pop_allocnos_from_stack ();\n     }\n-  if (flag_ira_coalesce)\n-    /* We don't need coalesced allocnos for ira_reassign_pseudos.  */\n-    EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n-      {\n-\ta = ira_allocnos[i];\n-\tALLOCNO_FIRST_COALESCED_ALLOCNO (a) = a;\n-\tALLOCNO_NEXT_COALESCED_ALLOCNO (a) = a;\n-      }\n-  ira_free_bitmap (processed_coalesced_allocno_bitmap);\n-  allocno_coalesced_p = false;\n }\n \n \f\n@@ -2478,6 +2086,183 @@ ira_reassign_conflict_allocnos (int start_regno)\n    On the other hand, it can worsen insn scheduling after the RA but\n    in practice it is less important than smaller stack frames.  */\n \n+/* TRUE if we coalesced some allocnos.  In other words, if we got\n+   loops formed by members first_coalesced_allocno and\n+   next_coalesced_allocno containing more one allocno.  */\n+static bool allocno_coalesced_p;\n+\n+/* Bitmap used to prevent a repeated allocno processing because of\n+   coalescing.  */\n+static bitmap processed_coalesced_allocno_bitmap;\n+\n+/* The function is used to sort allocnos according to their execution\n+   frequencies.  */\n+static int\n+copy_freq_compare_func (const void *v1p, const void *v2p)\n+{\n+  ira_copy_t cp1 = *(const ira_copy_t *) v1p, cp2 = *(const ira_copy_t *) v2p;\n+  int pri1, pri2;\n+\n+  pri1 = cp1->freq;\n+  pri2 = cp2->freq;\n+  if (pri2 - pri1)\n+    return pri2 - pri1;\n+\n+  /* If freqencies are equal, sort by copies, so that the results of\n+     qsort leave nothing to chance.  */\n+  return cp1->num - cp2->num;\n+}\n+\n+/* Merge two sets of coalesced allocnos given correspondingly by\n+   allocnos A1 and A2 (more accurately merging A2 set into A1\n+   set).  */\n+static void\n+merge_allocnos (ira_allocno_t a1, ira_allocno_t a2)\n+{\n+  ira_allocno_t a, first, last, next;\n+\n+  first = ALLOCNO_FIRST_COALESCED_ALLOCNO (a1);\n+  if (first == ALLOCNO_FIRST_COALESCED_ALLOCNO (a2))\n+    return;\n+  for (last = a2, a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a2);;\n+       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n+    {\n+      ALLOCNO_FIRST_COALESCED_ALLOCNO (a) = first;\n+      if (a == a2)\n+\tbreak;\n+      last = a;\n+    }\n+  next = ALLOCNO_NEXT_COALESCED_ALLOCNO (first);\n+  ALLOCNO_NEXT_COALESCED_ALLOCNO (first) = a2;\n+  ALLOCNO_NEXT_COALESCED_ALLOCNO (last) = next;\n+}\n+\n+/* Given two sets of coalesced sets of allocnos, A1 and A2, this\n+   function determines if any conflicts exist between the two sets.\n+   We use live ranges to find conflicts because conflicts are\n+   represented only for allocnos of the same cover class and during\n+   the reload pass we coalesce allocnos for sharing stack memory\n+   slots.  */\n+static bool\n+coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2)\n+{\n+  ira_allocno_t a, conflict_allocno;\n+\n+  bitmap_clear (processed_coalesced_allocno_bitmap);\n+  if (allocno_coalesced_p)\n+    {\n+      for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a1);;\n+\t   a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n+\t{\n+\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n+\t\t\t  OBJECT_CONFLICT_ID (ALLOCNO_OBJECT (a, 0)));\n+\t  if (a == a1)\n+\t    break;\n+\t}\n+    }\n+  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a2);;\n+       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n+    {\n+      for (conflict_allocno = ALLOCNO_NEXT_COALESCED_ALLOCNO (a1);;\n+\t   conflict_allocno\n+\t     = ALLOCNO_NEXT_COALESCED_ALLOCNO (conflict_allocno))\n+\t{\n+\t  if (allocnos_have_intersected_live_ranges_p (a, conflict_allocno))\n+\t    return true;\n+\t  if (conflict_allocno == a1)\n+\t    break;\n+\t}\n+\n+      if (a == a2)\n+\tbreak;\n+    }\n+  return false;\n+}\n+\n+/* The major function for aggressive allocno coalescing.  We coalesce\n+   only spilled allocnos.  If some allocnos have been coalesced, we\n+   set up flag allocno_coalesced_p.  */\n+static void\n+coalesce_allocnos (void)\n+{\n+  ira_allocno_t a;\n+  ira_copy_t cp, next_cp, *sorted_copies;\n+  unsigned int j;\n+  int i, n, cp_num, regno;\n+  bitmap_iterator bi;\n+\n+  sorted_copies = (ira_copy_t *) ira_allocate (ira_copies_num\n+\t\t\t\t\t       * sizeof (ira_copy_t));\n+  cp_num = 0;\n+  /* Collect copies.  */\n+  EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, j, bi)\n+    {\n+      a = ira_allocnos[j];\n+      regno = ALLOCNO_REGNO (a);\n+      if (! ALLOCNO_ASSIGNED_P (a) || ALLOCNO_HARD_REGNO (a) >= 0\n+\t  || (regno < ira_reg_equiv_len\n+\t      && (ira_reg_equiv_const[regno] != NULL_RTX\n+\t\t  || ira_reg_equiv_invariant_p[regno])))\n+\tcontinue;\n+      for (cp = ALLOCNO_COPIES (a); cp != NULL; cp = next_cp)\n+\t{\n+\t  if (cp->first == a)\n+\t    {\n+\t      next_cp = cp->next_first_allocno_copy;\n+\t      regno = ALLOCNO_REGNO (cp->second);\n+\t      /* For priority coloring we coalesce allocnos only with\n+\t\t the same cover class not with intersected cover\n+\t\t classes as it were possible.  It is done for\n+\t\t simplicity.  */\n+\t      if ((cp->insn != NULL || cp->constraint_p)\n+\t\t  && ALLOCNO_ASSIGNED_P (cp->second)\n+\t\t  && ALLOCNO_HARD_REGNO (cp->second) < 0\n+\t\t  && (regno >= ira_reg_equiv_len\n+\t\t      || (! ira_reg_equiv_invariant_p[regno]\n+\t\t\t  && ira_reg_equiv_const[regno] == NULL_RTX)))\n+\t\tsorted_copies[cp_num++] = cp;\n+\t    }\n+\t  else if (cp->second == a)\n+\t    next_cp = cp->next_second_allocno_copy;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+  qsort (sorted_copies, cp_num, sizeof (ira_copy_t), copy_freq_compare_func);\n+  /* Coalesced copies, most frequently executed first.  */\n+  for (; cp_num != 0;)\n+    {\n+      for (i = 0; i < cp_num; i++)\n+\t{\n+\t  cp = sorted_copies[i];\n+\t  if (! coalesced_allocno_conflict_p (cp->first, cp->second))\n+\t    {\n+\t      allocno_coalesced_p = true;\n+\t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\tfprintf\n+\t\t  (ira_dump_file,\n+\t\t   \"      Coalescing copy %d:a%dr%d-a%dr%d (freq=%d)\\n\",\n+\t\t   cp->num, ALLOCNO_NUM (cp->first), ALLOCNO_REGNO (cp->first),\n+\t\t   ALLOCNO_NUM (cp->second), ALLOCNO_REGNO (cp->second),\n+\t\t   cp->freq);\n+\t      merge_allocnos (cp->first, cp->second);\n+\t      i++;\n+\t      break;\n+\t    }\n+\t}\n+      /* Collect the rest of copies.  */\n+      for (n = 0; i < cp_num; i++)\n+\t{\n+\t  cp = sorted_copies[i];\n+\t  if (ALLOCNO_FIRST_COALESCED_ALLOCNO (cp->first)\n+\t      != ALLOCNO_FIRST_COALESCED_ALLOCNO (cp->second))\n+\t    sorted_copies[n++] = cp;\n+\t}\n+      cp_num = n;\n+    }\n+  ira_free (sorted_copies);\n+}\n+\n /* Usage cost and order number of coalesced allocno set to which\n    given pseudo register belongs to.  */\n static int *regno_coalesced_allocno_cost;\n@@ -2753,7 +2538,6 @@ ira_sort_regnos_for_alter_reg (int *pseudo_regnos, int n,\n   ira_allocno_iterator ai;\n   ira_allocno_t *spilled_coalesced_allocnos;\n \n-  processed_coalesced_allocno_bitmap = ira_allocate_bitmap ();\n   /* Set up allocnos can be coalesced.  */\n   coloring_allocno_bitmap = ira_allocate_bitmap ();\n   for (i = 0; i < n; i++)\n@@ -2765,7 +2549,8 @@ ira_sort_regnos_for_alter_reg (int *pseudo_regnos, int n,\n \t\t\tALLOCNO_NUM (allocno));\n     }\n   allocno_coalesced_p = false;\n-  coalesce_allocnos (true);\n+  processed_coalesced_allocno_bitmap = ira_allocate_bitmap ();\n+  coalesce_allocnos ();\n   ira_free_bitmap (coloring_allocno_bitmap);\n   regno_coalesced_allocno_cost\n     = (int *) ira_allocate (max_regno * sizeof (int));"}, {"sha": "cc297392ae9820291025536b9588eeb56c74af96", "filename": "gcc/ira.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b0982c1710877ba1dcb081b25cb68319628007/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=22b0982c1710877ba1dcb081b25cb68319628007", "patch": "@@ -168,8 +168,6 @@ along with GCC; see the file COPYING3.  If not see\n        process.  It is done in each region on top-down traverse of the\n        region tree (file ira-color.c).  There are following subpasses:\n \n-       * Optional aggressive coalescing of allocnos in the region.\n-\n        * Putting allocnos onto the coloring stack.  IRA uses Briggs\n          optimistic coloring which is a major improvement over\n          Chaitin's coloring.  Therefore IRA does not spill allocnos at"}]}