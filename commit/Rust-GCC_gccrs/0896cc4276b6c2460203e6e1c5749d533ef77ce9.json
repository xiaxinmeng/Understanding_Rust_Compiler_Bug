{"sha": "0896cc4276b6c2460203e6e1c5749d533ef77ce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5NmNjNDI3NmI2YzI0NjAyMDNlNmUxYzU3NDlkNTMzZWY3N2NlOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-22T13:44:10Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-22T13:44:10Z"}, "message": "Improve LTO streaming dumps\n\nthis patch cleans up dumping of streaming so it is clear how dump is organized\nand how much space individual components needs.\n\nCompiling:\n\nint a=1;\nmain()\n{\n  return a;\n}\n\nThe output is now:\n\nCreating output block for function_body\n    Streaming tree  <result_decl 0x7ffff7457a50 D.1931>\n     Start of LTO_trees of size 1\n      Encoding indexable  <integer_type 0x7ffff7463000 sizetype>  as 0\n     10 bytes\n\n^^^ I do not think we should need 10 bytes to stream single indexable reference\nto 0 :)\n\n     Start of LTO_trees of size 1\n      Encoding indexable  <integer_type 0x7ffff74630a8 bitsizetype>  as 1\n     10 bytes\n      Streaming header of  <result_decl 0x7ffff7457a50 D.1931>  to function_body\n      Streaming body of  <result_decl 0x7ffff7457a50 D.1931>  to function_body\n      Encoding indexable  <integer_type 0x7ffff74635e8 int>  as 2\n      Encoding indexable  <function_decl 0x7ffff757b500 main>  as 0\n      Streaming ref to  <integer_cst 0x7ffff744af18 32>\n      Streaming ref to  <integer_cst 0x7ffff744af30 4>\n    52 bytes\n\n^^^ Instead of having multiple LTO_trees sections followed by the final tree\nit would make a lot of sense to have only one LTO_trees where the first tree\nis one lto_input_tree should return.  This is easy to arrange in DFS walk -\none does not need to pop after every SCC component but pop once at the end of\nwalk.  However this breaks handling of integer_csts because they may now\nbecome of LTO_trees block and streamed as header + body.\nThis bypasses the separate code for shared integer_cst streaming.  I think\nI want to stream everything into header and materialize the tree since it is not\npart of SCC anyway.\n\n    Streaming tree  <block 0x7ffff757e420>\n      Streaming header of  <block 0x7ffff757e420>  to function_body\n      Streaming body of  <block 0x7ffff757e420>  to function_body\n    8 bytes\n  Streaming gimple stmt _2 = a;\n    Streaming ref to  <block 0x7ffff757e420>\n    4 bytes\n    Streaming tree  <mem_ref 0x7ffff7576f78>\n     Start of LTO_trees of size 1\n      Encoding indexable  <pointer_type 0x7ffff746b9d8>  as 3\n     10 bytes\n     Start of LTO_trees of size 1\n      Streaming header of  <addr_expr 0x7ffff75893c0>  to function_body\n      Streaming body of  <addr_expr 0x7ffff75893c0>  to function_body\n      Encoding indexable  <var_decl 0x7ffff7fcfb40 a>  as 0\n     15 bytes\n      Streaming header of  <mem_ref 0x7ffff7576f78>  to function_body\n      Streaming body of  <mem_ref 0x7ffff7576f78>  to function_body\n      Streaming ref to  <addr_expr 0x7ffff75893c0>\n      Streaming ref to  <integer_cst 0x7ffff75a3240 0>\n    42 bytes\n  Streaming gimple stmt return _2;\n\nOutputting global stream\n 0:  <function_decl 0x7ffff757b500 main>\n    Streaming tree  <function_decl 0x7ffff757b500 main>\n     Start of LTO_tree_scc of size 1\n      Streaming header of  <optimization_node 0x7ffff744b000>  to decls\n      Streaming body of  <optimization_node 0x7ffff744b000>  to decls\n     576 bytes\n     Start of LTO_tree_scc of size 1\n      Streaming header of  <target_option_node 0x7ffff744a018>  to decls\n      Streaming body of  <target_option_node 0x7ffff744a018>  to decls\n     68 bytes\n     Streaming single tree\n      Streaming header of  <identifier_node 0x7ffff7577aa0 main>  to decls\n      Streaming body of  <identifier_node 0x7ffff7577aa0 main>  to decls\n     3 bytes\n     Streaming single tree\n      Streaming header of  <identifier_node 0x7ffff758a8c0 t.c>  to decls\n      Streaming body of  <identifier_node 0x7ffff758a8c0 t.c>  to decls\n     3 bytes\n     Streaming single tree\n      Streaming header of  <translation_unit_decl 0x7ffff7457ac8 t.c>  to decls\n      Streaming body of  <translation_unit_decl 0x7ffff7457ac8 t.c>  to decls\n      Streaming ref to  <identifier_node 0x7ffff758a8c0 t.c>\n     22 bytes\n     Start of LTO_tree_scc of size 1\n      Streaming header of  <function_type 0x7ffff74717e0>  to decls\n      Streaming body of  <function_type 0x7ffff74717e0>  to decls\n      Streaming ref to  <integer_type 0x7ffff74635e8 int>\n      Streaming ref to  <integer_cst 0x7ffff744adc8 8>\n      Streaming ref to  <integer_cst 0x7ffff744ade0 1>\n      Streaming ref to  <function_type 0x7ffff74717e0>\n     38 bytes\n     Start of LTO_tree_scc of size 1\n      Streaming header of  <function_type 0x7ffff75832a0>  to decls\n      Streaming body of  <function_type 0x7ffff75832a0>  to decls\n      Streaming ref to  <integer_type 0x7ffff74635e8 int>\n      Streaming ref to  <integer_cst 0x7ffff744adc8 8>\n      Streaming ref to  <integer_cst 0x7ffff744ade0 1>\n      Streaming ref to  <function_type 0x7ffff74717e0>\n     38 bytes\n     Start of LTO_tree_scc of size 1\n      Streaming header of  <function_decl 0x7ffff757b500 main>  to decls\n      Streaming body of  <function_decl 0x7ffff757b500 main>  to decls\n      Streaming ref to  <function_type 0x7ffff75832a0>\n      Streaming ref to  <identifier_node 0x7ffff7577aa0 main>\n      Streaming ref to  <translation_unit_decl 0x7ffff7457ac8 t.c>\n      Streaming ref to  <identifier_node 0x7ffff7577aa0 main>\n      Streaming ref to  <target_option_node 0x7ffff744a018>\n      Streaming ref to  <optimization_node 0x7ffff744b000>\n     58 bytes\n    806 bytes\n 0:  <var_decl 0x7ffff7fcfb40 a>\n    Streaming tree  <var_decl 0x7ffff7fcfb40 a>\n     Streaming single tree\n      Streaming header of  <identifier_node 0x7ffff758a870 a>  to decls\n      Streaming body of  <identifier_node 0x7ffff758a870 a>  to decls\n     3 bytes\n     Streaming single tree\n      Streaming ref to  <integer_type 0x7ffff7463000 sizetype>\n     7 bytes\n     Streaming single tree\n      Streaming ref to  <integer_type 0x7ffff74630a8 bitsizetype>\n     7 bytes\n     Start of LTO_tree_scc of size 1\n      Streaming header of  <var_decl 0x7ffff7fcfb40 a>  to decls\n      Streaming body of  <var_decl 0x7ffff7fcfb40 a>  to decls\n      Streaming ref to  <integer_type 0x7ffff74635e8 int>\n      Streaming ref to  <identifier_node 0x7ffff758a870 a>\n      Streaming ref to  <translation_unit_decl 0x7ffff7457ac8 t.c>\n      Streaming ref to  <integer_cst 0x7ffff744af18 32>\n      Streaming ref to  <integer_cst 0x7ffff744af30 4>\n      Streaming ref to  <identifier_node 0x7ffff758a870 a>\n      Streaming ref to  <integer_cst 0x7ffff7468090 1>\n     49 bytes\n    66 bytes\n\ngcc/ChangeLog:\n\n2020-05-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-section-out.c (lto_output_decl_index): Adjust dump indentation.\n\t* lto-streamer-out.c (create_output_block): Fix whitespace\n\t(lto_write_tree_1): Add (debug) dump.\n\t(DFS::DFS): Add dump.\n\t(DFS::DFS_write_tree_body): Do not dump here.\n\t(lto_output_tree): Improve dumping; do not stream ref when not needed.\n\t(produce_asm_for_decls): Fix whitespace.\n\t* tree-streamer-out.c (streamer_write_tree_header): Add dump.", "tree": {"sha": "9c73dee7c8c40e2e609290415947ff5203b17080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c73dee7c8c40e2e609290415947ff5203b17080"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0896cc4276b6c2460203e6e1c5749d533ef77ce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0896cc4276b6c2460203e6e1c5749d533ef77ce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0896cc4276b6c2460203e6e1c5749d533ef77ce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0896cc4276b6c2460203e6e1c5749d533ef77ce9/comments", "author": null, "committer": null, "parents": [{"sha": "e740f3d73144abbca1ad98a04825c6bd63314a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e740f3d73144abbca1ad98a04825c6bd63314a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e740f3d73144abbca1ad98a04825c6bd63314a0b"}], "stats": {"total": 117, "additions": 88, "deletions": 29}, "files": [{"sha": "48a9a5f97017c028d1f9f16825fef923177ed5f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0896cc4276b6c2460203e6e1c5749d533ef77ce9", "patch": "@@ -1,3 +1,14 @@\n+2020-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-section-out.c (lto_output_decl_index): Adjust dump indentation.\n+\t* lto-streamer-out.c (create_output_block): Fix whitespace\n+\t(lto_write_tree_1): Add (debug) dump.\n+\t(DFS::DFS): Add dump.\n+\t(DFS::DFS_write_tree_body): Do not dump here.\n+\t(lto_output_tree): Improve dumping; do not stream ref when not needed.\n+\t(produce_asm_for_decls): Fix whitespace.\n+\t* tree-streamer-out.c (streamer_write_tree_header): Add dump.\n+\n 2020-05-22  Hongtao.liu  <hongtao.liu@intel.com>\n \n \tPR target/92658"}, {"sha": "0182cd6059ef0093ac75c2fe25cdcb8adbd8c786", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=0896cc4276b6c2460203e6e1c5749d533ef77ce9", "patch": "@@ -170,7 +170,7 @@ lto_output_decl_index (struct lto_output_stream *obs,\n       index = encoder->trees.length ();\n       if (streamer_dump_file)\n \t{\n-\t  print_node_brief (streamer_dump_file, \"    Encoding indexable \",\n+\t  print_node_brief (streamer_dump_file, \"     Encoding indexable \",\n \t\t\t    name, 4);\n \t  fprintf (streamer_dump_file, \"  as %i \\n\", index);\n \t}"}, {"sha": "f5daadc657b206a66a779f0676c0c3c9bc13abf6", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=0896cc4276b6c2460203e6e1c5749d533ef77ce9", "patch": "@@ -72,7 +72,7 @@ create_output_block (enum lto_section_type section_type)\n   struct output_block *ob = XCNEW (struct output_block);\n   if (streamer_dump_file)\n     fprintf (streamer_dump_file, \"Creating output block for %s\\n\",\n-\t     lto_section_name [section_type]);\n+\t     lto_section_name[section_type]);\n \n   ob->section_type = section_type;\n   ob->decl_state = lto_get_out_decl_state ();\n@@ -417,6 +417,14 @@ get_symbol_initial_value (lto_symtab_encoder_t encoder, tree expr)\n static void\n lto_write_tree_1 (struct output_block *ob, tree expr, bool ref_p)\n {\n+  if (streamer_dump_file)\n+    {\n+      print_node_brief (streamer_dump_file, \"     Streaming body of \",\n+\t\t\texpr, 4);\n+      fprintf (streamer_dump_file, \"  to %s\\n\",\n+\t       lto_section_name[ob->section_type]);\n+    }\n+\n   /* Pack all the non-pointer fields in EXPR into a bitpack and write\n      the resulting bitpack.  */\n   streamer_write_tree_bitfields (ob, expr);\n@@ -737,13 +745,20 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \n \t  worklist_vec.pop ();\n \n+\t  unsigned int prev_size = ob->main_stream->total_size;\n+\n \t  /* Only global decl sections are considered by tree merging.  */\n \t  if (ob->section_type != LTO_section_decls)\n \t    {\n \t      /* If this is the original tree we stream and it forms SCC\n \t\t by itself then we do not need to stream SCC at all.  */\n \t      if (worklist_vec.is_empty () && first == 0 && size == 1)\n \t\t return;\n+\t      if (streamer_dump_file)\n+\t\t{\n+\t\t  fprintf (streamer_dump_file,\n+\t\t\t   \"     Start of LTO_trees of size %i\\n\", size);\n+\t\t}\n \t      streamer_write_record_start (ob, LTO_trees);\n \t      streamer_write_uhwi (ob, size);\n \t    }\n@@ -760,6 +775,11 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \n \t    {\n \t      gcc_checking_assert (ob->section_type == LTO_section_decls);\n+\t      if (streamer_dump_file)\n+\t\t{\n+\t\t  fprintf (streamer_dump_file,\n+\t\t\t   \"     Start of LTO_tree_scc of size %i\\n\", size);\n+\t\t}\n \t      streamer_write_record_start (ob, LTO_tree_scc);\n \t      /* In wast majority of cases scc_entry_len is 1 and size is small\n \t\t integer.  Use extra bit of size to stream info about\n@@ -773,8 +793,18 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t     references work correctly.  */\n \t  else if (size != 1)\n \t    {\n-\t       streamer_write_record_start (ob, LTO_trees);\n-\t       streamer_write_uhwi (ob, size);\n+\t      if (streamer_dump_file)\n+\t\t{\n+\t\t  fprintf (streamer_dump_file,\n+\t\t\t   \"     Start of LTO_trees of size %i\\n\", size);\n+\t\t}\n+\t      streamer_write_record_start (ob, LTO_trees);\n+\t      streamer_write_uhwi (ob, size);\n+\t    }\n+\t  else if (streamer_dump_file)\n+\t    {\n+\t      fprintf (streamer_dump_file,\n+\t\t       \"     Streaming single tree\\n\", size);\n \t    }\n \n \t  /* Write size-1 SCCs without wrapping them inside SCC bundles.\n@@ -809,6 +839,9 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t      for (unsigned i = 0; i < size; ++i)\n \t\tlto_write_tree_1 (ob, sccstack[first+i].t, ref_p);\n \t    }\n+\t  if (streamer_dump_file)\n+\t    fprintf (streamer_dump_file, \"     %u bytes\\n\",\n+\t\t     ob->main_stream->total_size - prev_size);\n \n \t  /* Finally truncate the vector.  */\n \t  sccstack.truncate (first);\n@@ -845,14 +878,6 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \n   enum tree_code code;\n \n-  if (streamer_dump_file)\n-    {\n-      print_node_brief (streamer_dump_file, \"    Streaming \",\n-\t \t\texpr, 4);\n-      fprintf (streamer_dump_file, \"  to %s\\n\",\n-\t       lto_section_name [ob->section_type]);\n-    }\n-\n   code = TREE_CODE (expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n@@ -1246,7 +1271,7 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n     {\n       hstate.add_hwi (TYPE_MODE (t));\n       /* TYPE_NO_FORCE_BLK is private to stor-layout and need\n- \t no streaming.  */\n+\t no streaming.  */\n       hstate.add_flag (TYPE_PACKED (t));\n       hstate.add_flag (TYPE_RESTRICT (t));\n       hstate.add_flag (TYPE_USER_ALIGN (t));\n@@ -1689,6 +1714,10 @@ lto_output_tree (struct output_block *ob, tree expr,\n {\n   unsigned ix;\n   bool existed_p;\n+  unsigned int size = ob->main_stream->total_size;\n+  /* This is the first time we see EXPR, write all reachable\n+     trees to OB.  */\n+  static bool in_dfs_walk;\n \n   if (expr == NULL_TREE)\n     {\n@@ -1705,6 +1734,16 @@ lto_output_tree (struct output_block *ob, tree expr,\n   existed_p = streamer_tree_cache_lookup (ob->writer_cache, expr, &ix);\n   if (existed_p)\n     {\n+      if (streamer_dump_file)\n+\t{\n+\t  if (in_dfs_walk)\n+\t    print_node_brief (streamer_dump_file, \"     Streaming ref to \",\n+\t\t\t      expr, 4);\n+\t  else\n+\t    print_node_brief (streamer_dump_file, \"   Streaming ref to \",\n+\t\t\t      expr, 4);\n+\t  fprintf (streamer_dump_file, \"\\n\");\n+\t}\n       /* If a node has already been streamed out, make sure that\n \t we don't write it more than once.  Otherwise, the reader\n \t will instantiate two different nodes for the same object.  */\n@@ -1716,28 +1755,23 @@ lto_output_tree (struct output_block *ob, tree expr,\n     }\n   else\n     {\n-      /* This is the first time we see EXPR, write all reachable\n-\t trees to OB.  */\n-      static bool in_dfs_walk;\n-\n       /* Protect against recursion which means disconnect between\n-         what tree edges we walk in the DFS walk and what edges\n+\t what tree edges we walk in the DFS walk and what edges\n \t we stream out.  */\n       gcc_assert (!in_dfs_walk);\n \n       if (streamer_dump_file)\n \t{\n-\t  print_node_brief (streamer_dump_file, \"   Streaming SCC of \",\n+\t  print_node_brief (streamer_dump_file, \"   Streaming tree \",\n \t\t\t    expr, 4);\n-          fprintf (streamer_dump_file, \"\\n\");\n+\t  fprintf (streamer_dump_file, \"\\n\");\n \t}\n \n       /* Start the DFS walk.  */\n       /* Save ob state ... */\n       /* let's see ... */\n       in_dfs_walk = true;\n       DFS (ob, expr, ref_p, this_ref_p, false);\n-      in_dfs_walk = false;\n \n       /* Finally append a reference to the tree we were writing.  */\n       existed_p = streamer_tree_cache_lookup (ob->writer_cache, expr, &ix);\n@@ -1748,19 +1782,24 @@ lto_output_tree (struct output_block *ob, tree expr,\n \tlto_output_tree_1 (ob, expr, 0, ref_p, this_ref_p);\n       else\n \t{\n+\t  if (streamer_dump_file)\n+\t    {\n+\t      print_node_brief (streamer_dump_file,\n+\t\t\t\t\"   Streaming final ref to \",\n+\t\t\t\texpr, 4);\n+\t      fprintf (streamer_dump_file, \"\\n\");\n+\t    }\n \t  streamer_write_record_start (ob, LTO_tree_pickle_reference);\n \t  streamer_write_uhwi (ob, ix);\n \t  streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n \t\t\t       lto_tree_code_to_tag (TREE_CODE (expr)));\n \t}\n-      if (streamer_dump_file)\n-\t{\n-\t  print_node_brief (streamer_dump_file, \"   Finished SCC of \",\n-\t\t\t    expr, 4);\n-          fprintf (streamer_dump_file, \"\\n\\n\");\n-\t}\n+      in_dfs_walk = false;\n       lto_stats.num_pickle_refs_output++;\n     }\n+  if (streamer_dump_file && !in_dfs_walk)\n+    fprintf (streamer_dump_file, \"    %u bytes\\n\",\n+\t     ob->main_stream->total_size - size);\n }\n \n \n@@ -2700,7 +2739,7 @@ write_global_stream (struct output_block *ob,\n \n static void\n write_global_references (struct output_block *ob,\n- \t\t\t struct lto_tree_ref_encoder *encoder)\n+\t\t\t struct lto_tree_ref_encoder *encoder)\n {\n   tree t;\n   uint32_t index;\n@@ -3136,7 +3175,7 @@ produce_asm_for_decls (void)\n       fn_out_state =\n \tlto_function_decl_states[idx];\n       if (streamer_dump_file)\n-        fprintf (streamer_dump_file, \"Outputting stream for %s\\n\",\n+\tfprintf (streamer_dump_file, \"Outputting stream for %s\\n\",\n \t\t IDENTIFIER_POINTER\n \t\t    (DECL_ASSEMBLER_NAME (fn_out_state->fn_decl)));\n       lto_output_decl_state_streams (ob, fn_out_state);"}, {"sha": "724eaf5e54db49cf221124cf0d75b205822916ce", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc4276b6c2460203e6e1c5749d533ef77ce9/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=0896cc4276b6c2460203e6e1c5749d533ef77ce9", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alias.h\"\n #include \"stor-layout.h\"\n #include \"gomp-constants.h\"\n+#include \"print-tree.h\"\n \n \n /* Output the STRING constant to the string\n@@ -967,6 +968,14 @@ streamer_write_tree_header (struct output_block *ob, tree expr)\n   enum LTO_tags tag;\n   enum tree_code code;\n \n+  if (streamer_dump_file)\n+    {\n+      print_node_brief (streamer_dump_file, \"     Streaming header of \",\n+\t \t\texpr, 4);\n+      fprintf (streamer_dump_file, \"  to %s\\n\",\n+\t       lto_section_name[ob->section_type]);\n+    }\n+\n   /* We should not see any tree nodes not handled by the streamer.  */\n   code = TREE_CODE (expr);\n "}]}