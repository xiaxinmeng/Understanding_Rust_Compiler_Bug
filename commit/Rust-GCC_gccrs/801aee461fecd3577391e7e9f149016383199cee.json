{"sha": "801aee461fecd3577391e7e9f149016383199cee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxYWVlNDYxZmVjZDM1NzczOTFlN2U5ZjE0OTAxNjM4MzE5OWNlZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-14T01:36:09Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-14T01:36:09Z"}, "message": "(zero_extendsidi2): New pattern.\n\n(extendqidi2, extendhidi2, extendsidi2, extendplussidi): New patterns.\n(adddia_sexthishl32, adddid_sexthishl32): New patterns.\n(adddi_dilshr32, adddi_dishl32, adddi_mem): New patterns.\n(adddi3, subdi3): Allow more alternatives.\n(subdia_sexthishl32, subdid_sexthishl32): New patterns.\n(subdi_dishl32, subdi_mem): New patterns.\n(negdi2): New pattern.\n(ashldi_sexthi, ashldi_const32, ashldi_const, ashldi3): New patterns.\n(subreg1ashrdi_const32, ashrdi_const32): New patterns.\n(ashrdi_const32_mem, ashrdi_const, ashrdi3): New patterns.\n(subreg1lshrdi_const32, lshrdi_const32, lshrdi_const, lshrdi3): Ditto.\n(lshrsi_31): New pattern.\n(lshrsi_16, lshrsi_17_24): New names for old unnamed patterns.\n\nFrom-SVN: r8753", "tree": {"sha": "73a7ee33802835b0396d34e292d68f1d3ff2e162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73a7ee33802835b0396d34e292d68f1d3ff2e162"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/801aee461fecd3577391e7e9f149016383199cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801aee461fecd3577391e7e9f149016383199cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801aee461fecd3577391e7e9f149016383199cee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801aee461fecd3577391e7e9f149016383199cee/comments", "author": null, "committer": null, "parents": [{"sha": "f1d947250e78e10c44bd8fefc58cad274ce2fef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1d947250e78e10c44bd8fefc58cad274ce2fef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1d947250e78e10c44bd8fefc58cad274ce2fef4"}], "stats": {"total": 519, "additions": 507, "deletions": 12}, "files": [{"sha": "7cf501185af14d89daddc1f0718c1cee7f25f370", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 507, "deletions": 12, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801aee461fecd3577391e7e9f149016383199cee/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801aee461fecd3577391e7e9f149016383199cee/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=801aee461fecd3577391e7e9f149016383199cee", "patch": "@@ -1368,6 +1368,28 @@\n \f\n ;; zero extension instructions\n \n+;; this one is the canonical form for (lshiftrt:DI x 32)\n+(define_insn \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"ro,<,>\")\n+    (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm,rm,rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (which_alternative == 2)\n+    return \\\"clr%.l %0\\;move%.l %1,%0\\\";\n+  if (which_alternative == 1)\n+    return \\\"move%.l %1,%0\\;clr%.l %0\\\";\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[2] = adj_offsettable_operand (operands[0], 4);\n+  if (ADDRESS_REG_P (operands[0]))\n+    return \\\"move%.l %1,%2\\;sub%.l %0,%0\\\";\n+  else\n+    return \\\"move%.l %1,%2\\;clr%.l %0\\\";\n+}\")\n+\n (define_expand \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(const_int 0))\n@@ -1543,6 +1565,78 @@\n \f\n ;; sign extension instructions\n \n+(define_insn \"extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:DI\n+\t (match_operand:QI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (TARGET_68020)\n+    return \\\"move%.b %1,%2\\;extb%.l %2\\;smi %0\\;extb%.l %0\\\";\n+  else\n+    return \\\"move%.b %1,%2\\;ext%.w %0\\;ext%.l %2\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n+}\")\n+\n+(define_insn \"extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:DI\n+\t (match_operand:HI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (TARGET_68020)\n+    return \\\"move%.w %1,%2\\;ext%.l %2\\;smi %0\\;extb%.l %0\\\";\n+  else\n+    return \\\"move%.w %1,%2\\;ext%.l %2\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n+}\")\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:DI\n+\t (match_operand:SI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (TARGET_68020)\n+    return \\\"move%.l %1,%2\\;smi %0\\;extb%.l %0\\\";\n+  else\n+    return \\\"move%.l %1,%2\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n+}\")\n+\n+;; Special case when one can avoid register clobbering, copy and test\n+;; Maybe there is a way to make that the general case, by forcing the\n+;; result of the SI tree to be in the lower register of the DI target\n+\n+(define_insn \"extendplussidi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+    (sign_extend:DI (plus:SI (match_operand:SI 1 \"general_operand\" \"%rmn\")\n+            (match_operand:SI 2 \"general_operand\" \"rmn\"))))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (GET_CODE (operands[1]) == CONST_INT\n+  && (unsigned) INTVAL (operands[1]) > 8)\n+    {\n+      rtx tmp = operands[1];\n+\n+      operands[1] = operands[2];\n+      operands[2] = tmp;\n+    }\n+  if (TARGET_68020)\n+    return \\\"move%.l %2,%3\\;add%.l %1,%3\\;smi %0\\;extb%.l %0\\\";\n+  else\n+    return \\\"move%.l %2,%3\\;add%.l %1,%3\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n+}\")\n+\n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=*d,a\")\n \t(sign_extend:SI\n@@ -1839,16 +1933,104 @@\n \f\n ;; add instructions\n \n+(define_insn \"adddia_sexthishl32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+a\")\n+    (plus:DI (ashift:DI (sign_extend:DI\n+          (match_operand:HI 1 \"general_operand\" \"rm\"))\n+            (const_int 32))\n+        (match_dup 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"add%.w %1,%0\\\";\n+} \")\n+\n+(define_insn \"adddid_sexthishl32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+do\")\n+    (plus:DI (ashift:DI (sign_extend:DI\n+          (match_operand:HI 1 \"general_operand\" \"rm\"))\n+            (const_int 32))\n+        (match_dup 0)))\n+   (clobber (match_scratch:SI 2 \"=a\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"move%.w %1,%2\\;add%.l %2,%0\\\";\n+} \")\n+\n+(define_insn \"adddi_dilshr32\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=ro\")\n+    (plus:DI (lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+            (const_int 32))\n+        (match_operand:DI 2 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[0] = adj_offsettable_operand (operands[0], 4);\n+  return \\\"add%.l %1,%0\\\";\n+} \")\n+\n+(define_insn \"adddi_dishl32\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=ro\")\n+    (plus:DI (ashift:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+            (const_int 32))\n+        (match_operand:DI 2 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == REG)\n+    operands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else\n+    operands[1] = adj_offsettable_operand (operands[1], 4);\n+  return \\\"add%.l %1,%0\\\";\n+} \")\n+\n+(define_insn \"adddi_mem\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=m\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=d\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[1] = adj_offsettable_operand (operands[0], 4);\n+  operands[4] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  return \\\"add%.l %4,%1\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%0\\\";\n+} \")\n+\n (define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,<\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"ao,>,d,<\")))]\n   \"\"\n   \"*\n {\n+  if (which_alternative == 3)\n+    return \\\"add%.l %2,%0\\;addx%.l %2,%0\\\";\n   operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  operands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n-  return \\\"add%.l %3,%1\\;addx%.l %2,%0\\\";\n+  if (which_alternative == 1)\n+    {\n+      CC_STATUS_INIT;\n+      return \\\"add%.l %2,%0\\;add%.l %2,%1\\;negx%.l %0\\;neg%.l %0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == REG)\n+    operands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  else\n+    operands[3] = adj_offsettable_operand (operands[2], 4);\n+  if (which_alternative == 2)\n+    return \\\"add%.l %3,%1\\;addx%.l %2,%0\\\";\n+  CC_STATUS_INIT;\n+  /* negx + neg simulates (non-existent) addx #0 */\n+  /* TODO : this should work also for CONST operands[2] */\n+  return \\\"add%.l %3,%1\\;negx%.l %0\\;neg%.l %0\\;add%.l %2,%0\\\";\n } \")\n \n ;; Note that the middle two alternatives are near-duplicates\n@@ -2271,16 +2453,83 @@\n \f\n ;; subtract instructions\n \n+(define_insn \"subdia_sexthishl32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+a\")\n+    (minus:DI (match_dup 0)\n+        (ashift:DI (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"rm\"))\n+            (const_int 32))))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"sub%.w %1,%0\\\";\n+} \")\n+\n+(define_insn \"subdid_sexthishl32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+do\")\n+    (minus:DI (match_dup 0)\n+        (ashift:DI (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"rm\"))\n+            (const_int 32))))\n+   (clobber (match_scratch:SI 2 \"=a\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"move%.w %1,%2\\;sub%.l %2,%0\\\";\n+} \")\n+\n+(define_insn \"subdi_dishl32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+d\")\n+    (minus:DI (match_dup 0)\n+        (ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+            (const_int 32))))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  return \\\"sub%.l %1,%0\\\";\n+} \")\n+\n+(define_insn \"subdi_mem\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=m\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=d\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[1] = adj_offsettable_operand (operands[0], 4);\n+  operands[4] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  return \\\"sub%.l %4,%1\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%0\\\";\n+} \")\n+\n (define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,<\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"ao,>,d,<\")))]\n   \"\"\n   \"*\n {\n+  if (which_alternative == 3)\n+    return \\\"sub%.l %2,%0\\;subx%.l %2,%0\\\";\n   operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  operands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n-  return \\\"sub%.l %3,%1\\;subx%.l %2,%0\\\";\n+  if (which_alternative == 1)\n+    {\n+      CC_STATUS_INIT;\n+      return \\\"neg%.l %0\\;add%.l %2,%0\\;sub%.l %2,%1\\;negx%.l %0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == REG)\n+    operands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  else\n+    operands[3] = adj_offsettable_operand (operands[2], 4);\n+  if (which_alternative == 2)\n+    return \\\"sub%.l %3,%1\\;subx%.l %2,%0\\\";\n+  CC_STATUS_INIT;\n+  /* neg + negx simulates (non-existent) subx #0 */\n+  /* TODO : this should work also for CONST operands[2] */\n+  return \\\"neg%.l %0\\;sub%.l %3,%1\\;negx%.l %0\\;sub%.l %2,%0\\\";\n } \")\n \n (define_insn \"subsi3\"\n@@ -3311,6 +3560,24 @@\n \f\n ;; negation instructions\n \n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d*ao,<\")\n+\t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    return \\\"neg%.l %0\\;negx%.l %0\\\";\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[1] = adj_offsettable_operand (operands[0], 4);\n+  if (ADDRESS_REG_P (operands[0]))\n+    return \\\"exg %/d0,%1\\;neg%.l %/d0\\;exg %/d0,%1\\;exg %/d0,%0\\;negx%.l %/d0\\;exg %/d0,%0\\\";\n+  else\n+    return \\\"neg%.l %1\\;negx%.l %0\\\";\n+} \")\n+\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n@@ -3607,6 +3874,77 @@\n ;; arithmetic shift instructions\n ;; We don't need the shift memory by 1 bit instruction\n \n+(define_insn \"ashldi_sexthi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=*da\")\n+    (ashift:DI (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"rm\"))\n+        (const_int 32)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (DATA_REG_P (operands[0]))\n+    return \\\"move%.w %1,%0\\;ext%.l %0\\;clr%.l %2\\\";\n+  else\n+    return \\\"move%.w %1,%0\\;sub%.l %2,%2\\\";\n+} \")\n+\n+(define_insn \"ashldi_const32\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=ro,<,>\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"ro,ro,ro\")\n+\t\t     (const_int 32)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == REG)\n+    operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else\n+    operands[3] = adj_offsettable_operand (operands[1], 4);\n+  if (which_alternative == 1)\n+    return \\\"clr%.l %0\\;move%.l %3,%0\\\";\n+  if (which_alternative == 2)\n+    return \\\"move%.l %3,%0\\;clr%.l %0\\\";\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[2] = adj_offsettable_operand (operands[0], 4);\n+  if (ADDRESS_REG_P (operands[2]))\n+    return \\\"move%.l %3,%0\\;sub%.l %2,%2\\\";\n+  else\n+    return \\\"move%.l %3,%0\\;clr%.l %2\\\";\n+} \")\n+\n+(define_insn \"ashldi_const\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) == 1\n+   || INTVAL (operands[2]) == 2 || INTVAL (operands[2]) == 3)\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (INTVAL (operands[2]) == 1)\n+    return \\\"add%.l %1,%1\\;addx%.l %0,%0\\\";\n+  else if (INTVAL (operands[2]) == 2)\n+    return \\\"add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\\\";\n+  else/* if (INTVAL (operands[2]) == 3)*/\n+    return \\\"add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\\\";\n+} \")\n+\n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"rm\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+  || (INTVAL (operands[2]) != 1 && INTVAL (operands[2]) != 32\n+     && INTVAL (operands[2]) != 2 && INTVAL (operands[2]) != 3))\n+    FAIL;\n+} \")\n+\n ;; On all 68k models, this makes faster code in a special case.\n \n (define_insn \"\"\n@@ -3699,6 +4037,81 @@\n   return \\\"swap %0\\;asr%.w %2,%0\\;ext%.l %0\\\";\n }\")\n \n+(define_insn \"subreg1ashrdi_const32\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+    (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+            (const_int 32)) 1))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"move%.l %1,%0\\\";\n+} \")\n+\n+(define_insn \"ashrdi_const32\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+\t\t     (const_int 32)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (TARGET_68020)\n+    return \\\"move%.l %1,%2\\;smi %0\\;extb%.l %0\\\";\n+  else\n+    return \\\"move%.l %1,%2\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n+} \")\n+\n+(define_insn \"ashrdi_const32_mem\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,<\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro,ro\")\n+\t\t     (const_int 32)))\n+   (clobber (match_scratch:SI 2 \"=d,d\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (which_alternative == 1)\n+    operands[3] = operands[0];\n+  else\n+    operands[3] = adj_offsettable_operand (operands[0], 4);\n+  if (TARGET_68020)\n+    return \\\"move%.l %1,%3\\;smi %2\\;extb%.l %2\\;move%.l %2,%0\\\";\n+  else\n+    return \\\"move%.l %1,%3\\;smi %2\\;ext%.w %2\\;ext%.l %2\\;move%.l %2,%0\\\";\n+} \")\n+\n+(define_insn \"ashrdi_const\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) == 1\n+  || INTVAL (operands[2]) == 2 || INTVAL (operands[2]) == 3)\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  CC_STATUS_INIT;\n+  if (INTVAL (operands[2]) == 1)\n+    return \\\"asr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+  else if (INTVAL (operands[2]) == 2)\n+    return \\\"asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+  else/* if (INTVAL (operands[2]) == 3)*/\n+    return \\\"asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+} \")\n+\n+(define_expand \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"rm\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+  || (INTVAL (operands[2]) != 1 && INTVAL (operands[2]) != 32\n+     && INTVAL (operands[2]) != 2 && INTVAL (operands[2]) != 3))\n+    FAIL;\n+} \")\n+\n (define_insn \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n@@ -3736,10 +4149,92 @@\n \f\n ;; logical shift instructions\n \n+(define_insn \"subreg1lshrdi_const32\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+    (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+            (const_int 32)) 1))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"move%.l %1,%0\\\";\n+} \")\n+\n+(define_insn \"lshrdi_const32\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=ro,<,>\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro,ro,ro\")\n+\t\t     (const_int 32)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (which_alternative == 1)\n+    return \\\"move%.l %1,%0\\;clr%.l %0\\\";\n+  if (which_alternative == 2)\n+    return \\\"clr%.l %0\\;move%.l %1,%0\\\";\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[2] = adj_offsettable_operand (operands[0], 4);\n+  if (GET_CODE (operands[1]) == REG)\n+    operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else\n+    operands[3] = adj_offsettable_operand (operands[1], 4);\n+  if (ADDRESS_REG_P (operands[0]))\n+    return \\\"move%.l %1,%2\\;sub%.l %0,%0\\\";\n+  else\n+    return \\\"move%.l %1,%2\\;clr%.l %0\\\";\n+} \")\n+\n+(define_insn \"lshrdi_const\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) == 1 \n+    || INTVAL (operands[2]) == 2 || INTVAL (operands[2]) == 3)\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  if (INTVAL (operands[2]) == 1)\n+    return \\\"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+  else if (INTVAL (operands[2]) == 2)\n+    return \\\"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+  else /*if (INTVAL (operands[2]) == 3)*/\n+    return \\\"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+} \")\n+\n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"rm\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+  || (INTVAL (operands[2]) != 1 && INTVAL (operands[2]) != 32\n+      && INTVAL (operands[2]) != 2 && INTVAL (operands[2]) != 3))\n+    FAIL;\n+} \")\n \n ;; On all 68k models, this makes faster code in a special case.\n \n-(define_insn \"\"\n+(define_insn \"lshrsi_31\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 31)))]\n+  \"\"\n+  \"*\n+{\n+#if defined(MOTOROLA) && !defined(CRDS)\n+  return \\\"roxl%.l %#1,%0\\;moveq%.l %#0,%d0\\;roxl%.l %#1,%0\\\";\n+#else\n+  return \\\"roxl%.l %#1,%0\\;moveq %#0,%d0\\;roxl%.l %#1,%0\\\";\n+#endif\n+}\")\n+\n+;; On all 68k models, this makes faster code in a special case.\n+\n+(define_insn \"lshrsi_16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (const_int 16)))]\n@@ -3752,7 +4247,7 @@\n \n ;; On the 68000, this makes faster code in a special case.\n \n-(define_insn \"\"\n+(define_insn \"lshrsi_17_24\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]"}]}