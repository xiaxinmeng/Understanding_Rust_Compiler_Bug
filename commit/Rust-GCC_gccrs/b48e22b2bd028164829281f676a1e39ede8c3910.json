{"sha": "b48e22b2bd028164829281f676a1e39ede8c3910", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4ZTIyYjJiZDAyODE2NDgyOTI4MWY2NzZhMWUzOWVkZThjMzkxMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-07T18:57:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-07T18:57:23Z"}, "message": "tree-dfa.c (get_ref_base_and_extent): Do the offset computation using the precision of the index type.\n\n\t* tree-dfa.c (get_ref_base_and_extent) <ARRAY_REF>: Do the offset\n\tcomputation using the precision of the index type.\n\t* gimple-fold.c (fold_const_aggregate_ref_1) <ARRAY_REF>: Likewise.\n\t(fold_array_ctor_reference): Do index computations in the index type.\n\nFrom-SVN: r187268", "tree": {"sha": "1e60a64abff9d4b063851acc1b758950b2694142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e60a64abff9d4b063851acc1b758950b2694142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b48e22b2bd028164829281f676a1e39ede8c3910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48e22b2bd028164829281f676a1e39ede8c3910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48e22b2bd028164829281f676a1e39ede8c3910", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48e22b2bd028164829281f676a1e39ede8c3910/comments", "author": null, "committer": null, "parents": [{"sha": "62beea506bd1a5c688e7b88457408411c8272635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62beea506bd1a5c688e7b88457408411c8272635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62beea506bd1a5c688e7b88457408411c8272635"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "09783656bf92ae6dd8343829f53b3e70bba5bd19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48e22b2bd028164829281f676a1e39ede8c3910/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48e22b2bd028164829281f676a1e39ede8c3910/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b48e22b2bd028164829281f676a1e39ede8c3910", "patch": "@@ -1,4 +1,11 @@\n-2012-05-07    Georg-Johann Lay  <avr@gjlay.de>\n+2012-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-dfa.c (get_ref_base_and_extent) <ARRAY_REF>: Do the offset\n+\tcomputation using the precision of the index type.\n+\t* gimple-fold.c (fold_const_aggregate_ref_1) <ARRAY_REF>: Likewise.\n+\t(fold_array_ctor_reference): Do index computations in the index type.\n+\n+2012-05-07  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr.c (avr_prologue_setup_frame): Fix mode passed\n \tdown to plus_constant."}, {"sha": "55e7344043c19760dc3454d8c54cede82abefb4d", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48e22b2bd028164829281f676a1e39ede8c3910/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48e22b2bd028164829281f676a1e39ede8c3910/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=b48e22b2bd028164829281f676a1e39ede8c3910", "patch": "@@ -2745,7 +2745,7 @@ fold_array_ctor_reference (tree type, tree ctor,\n   double_int low_bound, elt_size;\n   double_int index, max_index;\n   double_int access_index;\n-  tree domain_type = NULL_TREE;\n+  tree domain_type = NULL_TREE, index_type = NULL_TREE;\n   HOST_WIDE_INT inner_offset;\n \n   /* Compute low bound and elt size.  */\n@@ -2755,6 +2755,7 @@ fold_array_ctor_reference (tree type, tree ctor,\n     {\n       /* Static constructors for variably sized objects makes no sense.  */\n       gcc_assert (TREE_CODE (TYPE_MIN_VALUE (domain_type)) == INTEGER_CST);\n+      index_type = TREE_TYPE (TYPE_MIN_VALUE (domain_type));\n       low_bound = tree_to_double_int (TYPE_MIN_VALUE (domain_type));\n     }\n   else\n@@ -2778,6 +2779,10 @@ fold_array_ctor_reference (tree type, tree ctor,\n   access_index = double_int_udiv (uhwi_to_double_int (offset / BITS_PER_UNIT),\n \t\t\t\t  elt_size, TRUNC_DIV_EXPR);\n   access_index = double_int_add (access_index, low_bound);\n+  if (index_type)\n+    access_index = double_int_ext (access_index,\n+\t\t\t\t   TYPE_PRECISION (index_type),\n+\t\t\t\t   TYPE_UNSIGNED (index_type));\n \n   /* And offset within the access.  */\n   inner_offset = offset % (double_int_to_uhwi (elt_size) * BITS_PER_UNIT);\n@@ -2788,6 +2793,11 @@ fold_array_ctor_reference (tree type, tree ctor,\n     return NULL_TREE;\n \n   index = double_int_sub (low_bound, double_int_one);\n+  if (index_type)\n+    index = double_int_ext (index,\n+\t\t\t    TYPE_PRECISION (index_type),\n+\t\t\t    TYPE_UNSIGNED (index_type));\n+\n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n     {\n       /* Array constructor might explicitely set index, or specify range\n@@ -2805,7 +2815,14 @@ fold_array_ctor_reference (tree type, tree ctor,\n \t    }\n \t}\n       else\n-\tmax_index = index = double_int_add (index, double_int_one);\n+\t{\n+\t  index = double_int_add (index, double_int_one);\n+\t  if (index_type)\n+\t    index = double_int_ext (index,\n+\t\t\t\t    TYPE_PRECISION (index_type),\n+\t\t\t\t    TYPE_UNSIGNED (index_type));\n+\t  max_index = index;\n+\t}\n \n       /* Do we have match?  */\n       if (double_int_cmp (access_index, index, 1) >= 0\n@@ -2960,18 +2977,23 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n       if (TREE_CODE (TREE_OPERAND (t, 1)) == SSA_NAME\n \t  && valueize\n \t  && (idx = (*valueize) (TREE_OPERAND (t, 1)))\n-\t  && host_integerp (idx, 0))\n+\t  && TREE_CODE (idx) == INTEGER_CST)\n \t{\n \t  tree low_bound, unit_size;\n+\t  double_int doffset;\n \n \t  /* If the resulting bit-offset is constant, track it.  */\n \t  if ((low_bound = array_ref_low_bound (t),\n-\t       host_integerp (low_bound, 0))\n+\t       TREE_CODE (low_bound) == INTEGER_CST)\n \t      && (unit_size = array_ref_element_size (t),\n-\t\t  host_integerp (unit_size, 1)))\n+\t\t  host_integerp (unit_size, 1))\n+\t      && (doffset = double_int_sext\n+\t\t\t    (double_int_sub (TREE_INT_CST (idx),\n+\t\t\t\t\t     TREE_INT_CST (low_bound)),\n+\t\t\t     TYPE_PRECISION (TREE_TYPE (idx))),\n+\t\t  double_int_fits_in_shwi_p (doffset)))\n \t    {\n-\t      offset = TREE_INT_CST_LOW (idx);\n-\t      offset -= TREE_INT_CST_LOW (low_bound);\n+\t      offset = double_int_to_shwi (doffset);\n \t      offset *= TREE_INT_CST_LOW (unit_size);\n \t      offset *= BITS_PER_UNIT;\n "}, {"sha": "3494fc9e962097512dec6d77cd61371d1f5352fe", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48e22b2bd028164829281f676a1e39ede8c3910/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48e22b2bd028164829281f676a1e39ede8c3910/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=b48e22b2bd028164829281f676a1e39ede8c3910", "patch": "@@ -814,21 +814,24 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t  {\n \t    tree index = TREE_OPERAND (exp, 1);\n \t    tree low_bound, unit_size;\n+\t    double_int doffset;\n \n \t    /* If the resulting bit-offset is constant, track it.  */\n \t    if (TREE_CODE (index) == INTEGER_CST\n-\t\t&& host_integerp (index, 0)\n \t\t&& (low_bound = array_ref_low_bound (exp),\n-\t\t    host_integerp (low_bound, 0))\n+ \t\t    TREE_CODE (low_bound) == INTEGER_CST)\n \t\t&& (unit_size = array_ref_element_size (exp),\n-\t\t    host_integerp (unit_size, 1)))\n+\t\t    host_integerp (unit_size, 1))\n+\t\t&& (doffset = double_int_sext\n+\t\t\t      (double_int_sub (TREE_INT_CST (index),\n+\t\t\t\t\t       TREE_INT_CST (low_bound)),\n+\t\t\t       TYPE_PRECISION (TREE_TYPE (index))),\n+\t\t    double_int_fits_in_shwi_p (doffset)))\n \t      {\n-\t\tHOST_WIDE_INT hindex = TREE_INT_CST_LOW (index);\n-\n-\t\thindex -= TREE_INT_CST_LOW (low_bound);\n-\t\thindex *= TREE_INT_CST_LOW (unit_size);\n-\t\thindex *= BITS_PER_UNIT;\n-\t\tbit_offset += hindex;\n+\t\tHOST_WIDE_INT hoffset = double_int_to_shwi (doffset);\n+\t\thoffset *= TREE_INT_CST_LOW (unit_size);\n+\t\thoffset *= BITS_PER_UNIT;\n+\t\tbit_offset += hoffset;\n \n \t\t/* An array ref with a constant index up in the structure\n \t\t   hierarchy will constrain the size of any variable array ref"}]}