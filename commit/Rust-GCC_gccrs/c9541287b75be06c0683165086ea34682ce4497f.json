{"sha": "c9541287b75be06c0683165086ea34682ce4497f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1NDEyODdiNzViZTA2YzA2ODMxNjUwODZlYTM0NjgyY2U0NDk3Zg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-12T15:36:21Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-09-12T15:36:21Z"}, "message": "* genattrtab.c: Fix formatting.\n\nFrom-SVN: r36364", "tree": {"sha": "9e620697b4979aea55ee09e60470159e0d0e2a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e620697b4979aea55ee09e60470159e0d0e2a1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9541287b75be06c0683165086ea34682ce4497f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9541287b75be06c0683165086ea34682ce4497f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9541287b75be06c0683165086ea34682ce4497f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9541287b75be06c0683165086ea34682ce4497f/comments", "author": null, "committer": null, "parents": [{"sha": "3ff5f682dc883c9508606535cd3ec981ac151362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff5f682dc883c9508606535cd3ec981ac151362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ff5f682dc883c9508606535cd3ec981ac151362"}], "stats": {"total": 383, "additions": 198, "deletions": 185}, "files": [{"sha": "2379b454262714bebc18755410a88ee78c3d2e91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9541287b75be06c0683165086ea34682ce4497f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9541287b75be06c0683165086ea34682ce4497f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9541287b75be06c0683165086ea34682ce4497f", "patch": "@@ -18,6 +18,8 @@ Tue Sep 12 08:53:57 2000  Jeffrey A Law  (law@cygnus.com)\n \n 2000-09-12  Kazu Hirata  <kazu@hxi.com>\n \n+\t* genattrtab.c: Fix formatting.\n+\n \t* unroll.c: Fix formatting.\n \n 2000-09-12  Bruce Korb  <bkorb@gnu.org>"}, {"sha": "46b9bdda67b3d6b14c379bd4b062aa9d973dbf8b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 196, "deletions": 185, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9541287b75be06c0683165086ea34682ce4497f/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9541287b75be06c0683165086ea34682ce4497f/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=c9541287b75be06c0683165086ea34682ce4497f", "patch": "@@ -37,7 +37,7 @@ Boston, MA 02111-1307, USA.  */\n    `constrain_operands' is called.  If either of these cases of a reference to\n    an operand is found, `extract_insn' is called.\n \n-   The special attribute `length' is also recognized.  For this operand, \n+   The special attribute `length' is also recognized.  For this operand,\n    expressions involving the address of an operand or the current insn,\n    (address (pc)), are valid.  In this case, an initial pass is made to\n    set all lengths that do not depend on address.  Those that do are set to\n@@ -52,7 +52,7 @@ Boston, MA 02111-1307, USA.  */\n    parameters as it does not depend on any particular insn.  Constant\n    attributes are typically used to specify which variety of processor is\n    used.\n-   \n+\n    Internal attributes are defined to handle DEFINE_DELAY and\n    DEFINE_FUNCTION_UNIT.  Special routines are output for these cases.\n \n@@ -95,7 +95,6 @@ Boston, MA 02111-1307, USA.  */\n    `volatil' (MEM_VOLATILE_P): During simplify_by_exploding the value of an\n       EQ_ATTR rtx is true if !volatil and false if volatil.  */\n \n-\n #include \"hconfig.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n@@ -255,7 +254,7 @@ static struct function_unit *units;\n    computed and becomes the corresponding value.  To do this, we must be\n    able to enumerate all values for each attribute used in the expression\n    (currently, we give up if we find a numeric attribute).\n-   \n+\n    If the set of EQ_ATTR tests used in an expression tests the value of N\n    different attributes, the list of all possible combinations can be made\n    by walking the N-dimensional attribute space defined by those\n@@ -283,7 +282,7 @@ static struct function_unit *units;\n    Once the dimensions are created, the algorithm enumerates all possible\n    values and computes the current value of the given expression.  */\n \n-struct dimension \n+struct dimension\n {\n   struct attr_desc *attr;\t/* Attribute for this dimension.  */\n   rtx values;\t\t\t/* List of attribute values used.  */\n@@ -347,7 +346,7 @@ int optimize = 0;\n #define SIMPLIFY_TEST_EXP(EXP,INSN_CODE,INSN_INDEX)\t\\\n   (RTX_UNCHANGING_P (EXP) || MEM_IN_STRUCT_P (EXP) ? (EXP)\t\\\n    : simplify_test_exp (EXP, INSN_CODE, INSN_INDEX))\n-  \n+\n /* Simplify (eq_attr (\"alternative\") ...)\n    when we are working with a particular alternative.  */\n #define SIMPLIFY_ALTERNATIVE(EXP)\t\t\t\t\\\n@@ -463,7 +462,6 @@ static int attr_equal_p\t\tPARAMS ((rtx, rtx));\n static rtx attr_copy_rtx\tPARAMS ((rtx));\n \n #define oballoc(size) obstack_alloc (hash_obstack, size)\n-\n \f\n /* Hash table for sharing RTL and strings.  */\n \n@@ -540,7 +538,6 @@ attr_hash_add_string (hashcode, str)\n \n    rtx attr_rtx (code, [element1, ..., elementn])  */\n \n-/*VARARGS1*/\n static rtx\n attr_rtx VPARAMS ((enum rtx_code code, ...))\n {\n@@ -689,7 +686,7 @@ attr_rtx VPARAMS ((enum rtx_code code, ...))\n     {\n     nohash:\n       rt_val = rtx_alloc (code);\t/* Allocate the storage space.  */\n-      \n+\n       fmt = GET_RTX_FORMAT (code);\t/* Find the right format...  */\n       for (i = 0; i < GET_RTX_LENGTH (code); i++)\n \t{\n@@ -720,7 +717,7 @@ attr_rtx VPARAMS ((enum rtx_code code, ...))\n \t      break;\n \n \t    default:\n-\t      abort();\n+\t      abort ();\n \t    }\n \t}\n       va_end (p);\n@@ -743,7 +740,6 @@ attr_rtx VPARAMS ((enum rtx_code code, ...))\n \n    rtx attr_printf (len, format, [arg1, ..., argn])  */\n \n-/*VARARGS2*/\n static char *\n attr_printf VPARAMS ((register int len, const char *fmt, ...))\n {\n@@ -798,9 +794,9 @@ attr_string (str, len)\n   register char *new_str;\n \n   /* Compute the hash code.  */\n-  hashcode = (len + 1) * 613 + (unsigned)str[0];\n+  hashcode = (len + 1) * 613 + (unsigned) str[0];\n   for (i = 1; i <= len; i += 2)\n-    hashcode = ((hashcode * 613) + (unsigned)str[i]);\n+    hashcode = ((hashcode * 613) + (unsigned) str[i]);\n   if (hashcode < 0)\n     hashcode = -hashcode;\n \n@@ -872,7 +868,7 @@ attr_copy_rtx (orig)\n   copy->volatil = orig->volatil;\n   copy->unchanging = orig->unchanging;\n   copy->integrated = orig->integrated;\n-  \n+\n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n   for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n@@ -978,16 +974,16 @@ check_attr_test (exp, is_const, lineno)\n \n \t  /* It shouldn't be possible to simplify the value given to a\n \t     constant attribute, so don't expand this until it's time to\n-\t     write the test expression.  */\t       \n+\t     write the test expression.  */\n \t  if (attr->is_const)\n \t    RTX_UNCHANGING_P (exp) = 1;\n \n \t  if (attr->is_numeric)\n \t    {\n \t      for (p = XSTR (exp, 1); *p; p++)\n \t\tif (*p < '0' || *p > '9')\n-\t\t   fatal (\"Attribute `%s' takes only numeric values\", \n-\t\t\t  XSTR (exp, 0));\n+\t\t  fatal (\"Attribute `%s' takes only numeric values\",\n+\t\t\t XSTR (exp, 0));\n \t    }\n \t  else\n \t    {\n@@ -1044,7 +1040,7 @@ check_attr_test (exp, is_const, lineno)\n       /* These cases can't be simplified.  */\n       RTX_UNCHANGING_P (exp) = 1;\n       break;\n- \n+\n     case LE:  case LT:  case GT:  case GE:\n     case LEU: case LTU: case GTU: case GEU:\n     case NE:  case EQ:\n@@ -1104,8 +1100,8 @@ check_attr_value (exp, attr)\n       if (INTVAL (exp) < 0 && ! attr->negative_ok)\n \t{\n \t  message_with_line (attr->lineno,\n-\t\t\t\"negative numeric value specified for attribute %s\",\n-\t\t\tattr->name);\n+\t\t\t     \"negative numeric value specified for attribute %s\",\n+\t\t\t     attr->name);\n \t  have_error = 1;\n \t  break;\n \t}\n@@ -1162,8 +1158,8 @@ check_attr_value (exp, attr)\n       if (attr && !attr->is_numeric)\n \t{\n \t  message_with_line (attr->lineno,\n-\t\t\"invalid operation `%s' for non-numeric attribute value\",\n-\t\tGET_RTX_NAME (GET_CODE (exp)));\n+\t\t\t     \"invalid operation `%s' for non-numeric attribute value\",\n+\t\t\t     GET_RTX_NAME (GET_CODE (exp)));\n \t  have_error = 1;\n \t  break;\n \t}\n@@ -1217,7 +1213,7 @@ check_attr_value (exp, attr)\n \t\tXSTR (exp, 0), attr->name);\n \t    have_error = 1;\n \t  }\n-\telse if (attr \n+\telse if (attr\n \t\t && (attr->is_numeric != attr2->is_numeric\n \t\t     || (! attr->negative_ok && attr2->negative_ok)))\n \t  {\n@@ -1261,7 +1257,7 @@ convert_set_attr_alternative (exp, id)\n   if (XVECLEN (exp, 1) != num_alt)\n     {\n       message_with_line (id->lineno,\n-\t\t\"bad number of entries in SET_ATTR_ALTERNATIVE\");\n+\t\t\t \"bad number of entries in SET_ATTR_ALTERNATIVE\");\n       have_error = 1;\n       return NULL_RTX;\n     }\n@@ -1422,7 +1418,7 @@ convert_const_symbol_ref (exp, attr)\n \n       value = attr_rtx (SYMBOL_REF, string);\n       RTX_UNCHANGING_P (value) = 1;\n-      \n+\n       XVECEXP (condexp, 0, 2 * i) = attr_rtx (EQ, exp, value);\n \n       XVECEXP (condexp, 0, 2 * i + 1) = av->value;\n@@ -1471,7 +1467,7 @@ make_canonical (attr, exp)\n #if 0\n       /* ??? Why do we do this?  With attribute values { A B C D E }, this\n          tends to generate (!(x==A) && !(x==B) && !(x==C) && !(x==D)) rather\n-\t than (x==E). */\n+\t than (x==E).  */\n       exp = convert_const_symbol_ref (exp, attr);\n       RTX_UNCHANGING_P (exp) = 1;\n       exp = check_attr_value (exp, attr);\n@@ -1636,44 +1632,46 @@ expand_delays ()\n   /* For each delay possibility and delay slot, compute an eligibility\n      attribute for non-annulled insns and for each type of annulled (annul\n      if true and annul if false).  */\n- for (delay = delays; delay; delay = delay->next)\n-   {\n-     for (i = 0; i < XVECLEN (delay->def, 1); i += 3)\n-       {\n-\t condexp = XVECEXP (delay->def, 1, i);\n-\t if (condexp == 0) condexp = false_rtx;\n-\t newexp = attr_rtx (IF_THEN_ELSE, condexp,\n-\t\t\t    make_numeric_value (1), make_numeric_value (0));\n-\n-\t p = attr_printf (sizeof (\"*delay__\") + MAX_DIGITS*2, \"*delay_%d_%d\",\n-\t\t\t  delay->num, i / 3);\n-\t make_internal_attr (p, newexp, 1);\n-\n-\t if (have_annul_true)\n-\t   {\n-\t     condexp = XVECEXP (delay->def, 1, i + 1);\n-\t     if (condexp == 0) condexp = false_rtx;\n-\t     newexp = attr_rtx (IF_THEN_ELSE, condexp,\n-\t\t\t\tmake_numeric_value (1),\n-\t\t\t\tmake_numeric_value (0));\n-\t     p = attr_printf (sizeof (\"*annul_true__\") + MAX_DIGITS*2,\n-\t\t\t      \"*annul_true_%d_%d\", delay->num, i / 3);\n-\t     make_internal_attr (p, newexp, 1);\n-\t   }\n-\n-\t if (have_annul_false)\n-\t   {\n-\t     condexp = XVECEXP (delay->def, 1, i + 2);\n-\t     if (condexp == 0) condexp = false_rtx;\n-\t     newexp = attr_rtx (IF_THEN_ELSE, condexp,\n-\t\t\t\tmake_numeric_value (1),\n-\t\t\t\tmake_numeric_value (0));\n-\t     p = attr_printf (sizeof (\"*annul_false__\") + MAX_DIGITS*2,\n-\t\t\t      \"*annul_false_%d_%d\", delay->num, i / 3);\n-\t     make_internal_attr (p, newexp, 1);\n-\t   }\n-       }\n-   }\n+  for (delay = delays; delay; delay = delay->next)\n+    {\n+      for (i = 0; i < XVECLEN (delay->def, 1); i += 3)\n+\t{\n+\t  condexp = XVECEXP (delay->def, 1, i);\n+\t  if (condexp == 0)\n+\t    condexp = false_rtx;\n+\t  newexp = attr_rtx (IF_THEN_ELSE, condexp,\n+\t\t\t     make_numeric_value (1), make_numeric_value (0));\n+\n+\t  p = attr_printf (sizeof (\"*delay__\") + MAX_DIGITS * 2,\n+\t\t\t   \"*delay_%d_%d\",\n+\t\t\t   delay->num, i / 3);\n+\t  make_internal_attr (p, newexp, 1);\n+\n+\t  if (have_annul_true)\n+\t    {\n+\t      condexp = XVECEXP (delay->def, 1, i + 1);\n+\t      if (condexp == 0) condexp = false_rtx;\n+\t      newexp = attr_rtx (IF_THEN_ELSE, condexp,\n+\t\t\t\t make_numeric_value (1),\n+\t\t\t\t make_numeric_value (0));\n+\t      p = attr_printf (sizeof (\"*annul_true__\") + MAX_DIGITS * 2,\n+\t\t\t       \"*annul_true_%d_%d\", delay->num, i / 3);\n+\t      make_internal_attr (p, newexp, 1);\n+\t    }\n+\n+\t  if (have_annul_false)\n+\t    {\n+\t      condexp = XVECEXP (delay->def, 1, i + 2);\n+\t      if (condexp == 0) condexp = false_rtx;\n+\t      newexp = attr_rtx (IF_THEN_ELSE, condexp,\n+\t\t\t\t make_numeric_value (1),\n+\t\t\t\t make_numeric_value (0));\n+\t      p = attr_printf (sizeof (\"*annul_false__\") + MAX_DIGITS * 2,\n+\t\t\t       \"*annul_false_%d_%d\", delay->num, i / 3);\n+\t      make_internal_attr (p, newexp, 1);\n+\t    }\n+\t}\n+    }\n }\n \f\n /* This function is given a left and right side expression and an operator.\n@@ -1779,7 +1777,7 @@ operate_exp (op, left, right)\n \t      XVECEXP (newexp, 0, i + 1)\n \t\t= operate_exp (op, left, XVECEXP (right, 0, i + 1));\n \t      if (! rtx_equal_p (XVECEXP (newexp, 0, i + 1),\n-\t\t\t\t defval))     \n+\t\t\t\t defval))\n \t\tallsame = 0;\n \t    }\n \n@@ -1838,7 +1836,7 @@ operate_exp (op, left, right)\n \t  XVECEXP (newexp, 0, i + 1)\n \t    = operate_exp (op, XVECEXP (left, 0, i + 1), right);\n \t  if (! rtx_equal_p (XVECEXP (newexp, 0, i + 1),\n-\t\t\t     defval))     \n+\t\t\t     defval))\n \t    allsame = 0;\n \t}\n \n@@ -1969,21 +1967,21 @@ expand_units ()\n     {\n       /* Merge each function unit into the unit mask attributes.  */\n       for (unit = units; unit; unit = unit->next)\n-        {\n-          XEXP (newexp, 0) = unit->condexp;\n-          XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n-          unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n-        }\n+\t{\n+\t  XEXP (newexp, 0) = unit->condexp;\n+\t  XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n+\t  unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n+\t}\n     }\n   else\n     {\n       /* Merge each function unit into the unit mask attributes.  */\n       for (unit = units; unit; unit = unit->next)\n-        {\n-          XEXP (newexp, 0) = unit->condexp;\n-          XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n-          unitsmask = operate_exp (ORX_OP, unitsmask, attr_copy_rtx (newexp));\n-        }\n+\t{\n+\t  XEXP (newexp, 0) = unit->condexp;\n+\t  XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n+\t  unitsmask = operate_exp (ORX_OP, unitsmask, attr_copy_rtx (newexp));\n+\t}\n     }\n \n   /* Simplify the unit mask expression, encode it, and make an attribute\n@@ -2048,11 +2046,11 @@ expand_units ()\n       /* Sort the array of ops into increasing ready cost order.  */\n       for (i = 0; i < num; i++)\n \tfor (j = num - 1; j > i; j--)\n-\t  if (op_array[j-1]->ready < op_array[j]->ready)\n+\t  if (op_array[j - 1]->ready < op_array[j]->ready)\n \t    {\n \t      op = op_array[j];\n-\t      op_array[j] = op_array[j-1];\n-\t      op_array[j-1] = op;\n+\t      op_array[j] = op_array[j - 1];\n+\t      op_array[j - 1] = op;\n \t    }\n \n       /* Determine how many distinct non-default ready cost values there\n@@ -2075,7 +2073,9 @@ expand_units ()\n \t  XVEC (readycost, 0) = rtvec_alloc (nvalues * 2);\n \t  XEXP (readycost, 1) = make_numeric_value (1);\n \n-\t  nvalues = 0; orexp = false_rtx; value = op_array[0]->ready;\n+\t  nvalues = 0;\n+\t  orexp = false_rtx;\n+\t  value = op_array[0]->ready;\n \t  for (i = 0; i < num; i++)\n \t    {\n \t      op = op_array[i];\n@@ -2190,7 +2190,7 @@ expand_units ()\n \t       || atoi (XSTR (newexp, 0)) != 1);\n \n \t  /* If the all values of BLOCKAGE (E,C) have the same value,\n-\t     neither blockage function is written.  */\t  \n+\t     neither blockage function is written.  */\n \t  unit->needs_range_function\n \t    = (unit->needs_blockage_function\n \t       || GET_CODE (max_blockage) != CONST_STRING);\n@@ -2268,8 +2268,8 @@ simplify_knowing (exp, known_true)\n       if (! unknown)\n \t{\n \t  exp = attr_rtx (IF_THEN_ELSE, known_true, exp,\n-\t\t          make_numeric_value (max));\n-          exp = simplify_by_exploding (exp);\n+\t\t\t  make_numeric_value (max));\n+\t  exp = simplify_by_exploding (exp);\n \t}\n     }\n   return exp;\n@@ -2296,7 +2296,8 @@ encode_units_mask (x)\n     case CONST_STRING:\n       i = atoi (XSTR (x, 0));\n       if (i < 0)\n-\tabort (); /* The sign bit encodes a one's compliment mask.  */\n+\t/* The sign bit encodes a one's compliment mask.  */\n+\tabort ();\n       else if (i != 0 && i == (i & -i))\n \t/* Only one bit is set, so yield that unit number.  */\n \tfor (j = 0; (i >>= 1) != 0; j++)\n@@ -2315,7 +2316,7 @@ encode_units_mask (x)\n     case CC0:\n     case EQ_ATTR:\n       return x;\n-      \n+\n     default:\n       break;\n     }\n@@ -2368,7 +2369,7 @@ fill_attr (attr)\n       value = NULL;\n       if (XVEC (id->def, id->vec_idx))\n \tfor (i = 0; i < XVECLEN (id->def, id->vec_idx); i++)\n-\t  if (! strcmp (XSTR (XEXP (XVECEXP (id->def, id->vec_idx, i), 0), 0), \n+\t  if (! strcmp (XSTR (XEXP (XVECEXP (id->def, id->vec_idx, i), 0), 0),\n \t\t\tattr->name))\n \t    value = XEXP (XVECEXP (id->def, id->vec_idx, i), 1);\n \n@@ -2566,7 +2567,7 @@ write_length_unit_log ()\n     {\n       length_or = ~length_or;\n       for (length_unit_log = 0; length_or & 1; length_or >>= 1)\n-        length_unit_log++;\n+\tlength_unit_log++;\n     }\n   printf (\"int length_unit_log = %u;\\n\", length_unit_log);\n }\n@@ -2865,7 +2866,7 @@ make_alternative_compare (mask)\n    of \"attr\" for this insn code.  From that value, we can compute a test\n    showing when the EQ_ATTR will be true.  This routine performs that\n    computation.  If a test condition involves an address, we leave the EQ_ATTR\n-   intact because addresses are only valid for the `length' attribute. \n+   intact because addresses are only valid for the `length' attribute.\n \n    EXP is the EQ_ATTR expression and VALUE is the value of that attribute\n    for the insn corresponding to INSN_CODE and INSN_INDEX.  */\n@@ -2893,19 +2894,19 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n       char *p, *string;\n \n       if (GET_CODE (exp) != EQ_ATTR)\n-\tabort();\n+\tabort ();\n \n       string = (char *) alloca (2 + strlen (XSTR (exp, 0))\n \t\t\t\t+ strlen (XSTR (exp, 1)));\n       strcpy (string, XSTR (exp, 0));\n       strcat (string, \"_\");\n       strcat (string, XSTR (exp, 1));\n-      for (p = string; *p ; p++)\n+      for (p = string; *p; p++)\n \t*p = TOUPPER (*p);\n-      \n+\n       newexp = attr_rtx (EQ, value,\n \t\t\t attr_rtx (SYMBOL_REF,\n-\t\t\t\t   attr_string(string, strlen(string))));\n+\t\t\t\t   attr_string (string, strlen (string))));\n     }\n   else if (GET_CODE (value) == COND)\n     {\n@@ -2914,7 +2915,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \t FALSE will be returned.\n \n \t Each case is the AND of the NOT's of the previous conditions with the\n-\t current condition; in the default case the current condition is TRUE. \n+\t current condition; in the default case the current condition is TRUE.\n \n \t For each possible COND value, call ourselves recursively.\n \n@@ -2983,7 +2984,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n    can be replaced with TRUE or FALSE, respectively.\n \n    Note that (eq_attr \"att\" \"v1\") and (eq_attr \"att\" \"v2\") cannot both\n-   be true and hence are complementary.  \n+   be true and hence are complementary.\n \n    There is one special case:  If we see\n \t(and (not (eq_attr \"att\" \"v1\"))\n@@ -3005,7 +3006,7 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n \n   if (GET_CODE (exp) == AND)\n     {\n-      left = simplify_and_tree (XEXP (exp, 0), pterm,  insn_code, insn_index);\n+      left  = simplify_and_tree (XEXP (exp, 0), pterm, insn_code, insn_index);\n       right = simplify_and_tree (XEXP (exp, 1), pterm, insn_code, insn_index);\n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n@@ -3020,7 +3021,7 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n       /* For the IOR case, we do the same as above, except that we can\n          only eliminate `term' if both sides of the IOR would do so.  */\n       temp = *pterm;\n-      left = simplify_and_tree (XEXP (exp, 0), &temp,  insn_code, insn_index);\n+      left = simplify_and_tree (XEXP (exp, 0), &temp, insn_code, insn_index);\n       left_eliminates_term = (temp == true_rtx);\n \n       temp = *pterm;\n@@ -3124,7 +3125,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \n   if (GET_CODE (exp) == IOR)\n     {\n-      left = simplify_or_tree (XEXP (exp, 0), pterm,  insn_code, insn_index);\n+      left  = simplify_or_tree (XEXP (exp, 0), pterm, insn_code, insn_index);\n       right = simplify_or_tree (XEXP (exp, 1), pterm, insn_code, insn_index);\n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n@@ -3139,7 +3140,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n       /* For the AND case, we do the same as above, except that we can\n          only eliminate `term' if both sides of the AND would do so.  */\n       temp = *pterm;\n-      left = simplify_or_tree (XEXP (exp, 0), &temp,  insn_code, insn_index);\n+      left = simplify_or_tree (XEXP (exp, 0), &temp, insn_code, insn_index);\n       left_eliminates_term = (temp == false_rtx);\n \n       temp = *pterm;\n@@ -3183,7 +3184,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n    code based on the values of other attributes being tested.  This can\n    eliminate nested get_attr_... calls.\n \n-   Note that if an endless recursion is specified in the patterns, the \n+   Note that if an endless recursion is specified in the patterns, the\n    optimization will loop.  However, it will do so in precisely the cases where\n    an infinite recursion loop could occur during compilation.  It's better that\n    it occurs here!  */\n@@ -3353,7 +3354,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n        */\n \n       else if (GET_CODE (left) == AND && GET_CODE (right) == AND\n-\t  && attr_equal_p (XEXP (left, 0), XEXP (right, 0)))\n+\t       && attr_equal_p (XEXP (left, 0), XEXP (right, 0)))\n \t{\n \t  newexp = attr_rtx (IOR, XEXP (left, 1), XEXP (right, 1));\n \n@@ -3367,12 +3368,12 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t in this tree.  Optimize if so.  */\n \n       else if (insn_code >= 0\n-\t  && (GET_CODE (left) == IOR\n-\t      || (GET_CODE (left) == EQ_ATTR\n-\t\t  && XSTR (left, 0) == alternative_name)\n-\t      || GET_CODE (right) == IOR\n-\t      || (GET_CODE (right) == EQ_ATTR\n-\t\t  && XSTR (right, 0) == alternative_name)))\n+\t       && (GET_CODE (left) == IOR\n+\t\t   || (GET_CODE (left) == EQ_ATTR\n+\t\t       && XSTR (left, 0) == alternative_name)\n+\t\t   || GET_CODE (right) == IOR\n+\t\t   || (GET_CODE (right) == EQ_ATTR\n+\t\t       && XSTR (right, 0) == alternative_name)))\n \t{\n \t  i = compute_alternative_mask (exp, IOR);\n \t  if (i & ~insn_alternatives[insn_code])\n@@ -3458,7 +3459,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n       if (current_alternative_string && XSTR (exp, 0) == alternative_name)\n \treturn (XSTR (exp, 1) == current_alternative_string\n \t\t? true_rtx : false_rtx);\n-\t\n+\n       /* Look at the value for this insn code in the specified attribute.\n \t We normally can replace this comparison with the condition that\n \t would give this insn the values being tested for.   */\n@@ -3469,7 +3470,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t    if (ie->insn_code == insn_code)\n \t      return evaluate_eq_attr (exp, av->value, insn_code, insn_index);\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -3497,10 +3498,13 @@ optimize_attrs ()\n   rtx newexp;\n   int something_changed = 1;\n   int i;\n-  struct attr_value_list { struct attr_value *av;\n-\t\t\t   struct insn_ent *ie;\n-\t\t\t   struct attr_desc * attr;\n-\t\t\t   struct attr_value_list *next; };\n+  struct attr_value_list\n+  {\n+    struct attr_value *av;\n+    struct insn_ent *ie;\n+    struct attr_desc *attr;\n+    struct attr_value_list *next;\n+  };\n   struct attr_value_list **insn_code_values;\n   struct attr_value_list *ivbuf;\n   struct attr_value_list *iv;\n@@ -3609,7 +3613,6 @@ simplify_by_alternatives (exp, insn_code, insn_index)\n   rtx newexp = rtx_alloc (COND);\n   rtx ultimate;\n \n-\n   XVEC (newexp, 0) = rtvec_alloc (len * 2);\n \n   /* It will not matter what value we use as the default value\n@@ -3706,8 +3709,8 @@ simplify_by_exploding (exp)\n \t{\n \t  struct dimension tmp;\n \t  tmp = space[j];\n-\t  space[j] = space[j-1];\n-\t  space[j-1] = tmp;\n+\t  space[j] = space[j - 1];\n+\t  space[j - 1] = tmp;\n \t}\n \n   /* Establish the initial current value.  */\n@@ -3875,7 +3878,8 @@ add_values_to_cover (dim)\n   if (nalt < dim->num_values)\n     abort ();\n   else if (nalt == dim->num_values)\n-    ; /* Ok.  */\n+    /* OK.  */\n+    ;\n   else if (nalt * 2 < dim->num_values * 3)\n     {\n       /* Most all the values of the attribute are used, so add all the unused\n@@ -4104,7 +4108,7 @@ clear_struct_flag (x)\n     case EQ_ATTR:\n     case ATTR_FLAG:\n       return;\n-      \n+\n     default:\n       break;\n     }\n@@ -4159,7 +4163,7 @@ count_sub_rtxs (x, max)\n     case EQ_ATTR:\n     case ATTR_FLAG:\n       return 1;\n-      \n+\n     default:\n       break;\n     }\n@@ -4248,7 +4252,8 @@ gen_attr (exp, lineno)\n \n   if (! strcmp (attr->name, \"length\") && ! attr->is_numeric)\n     {\n-      message_with_line (lineno, \"`length' attribute must take numeric values\");\n+      message_with_line (lineno,\n+\t\t\t \"`length' attribute must take numeric values\");\n       have_error = 1;\n     }\n \n@@ -4267,7 +4272,7 @@ count_alternatives (exp)\n {\n   int i, j, n;\n   const char *fmt;\n-  \n+\n   if (GET_CODE (exp) == MATCH_OPERAND)\n     return n_comma_elts (XSTR (exp, 2));\n \n@@ -4361,7 +4366,7 @@ contained_in_p (inner, exp)\n \n   return 0;\n }\n-\f\t\n+\f\n /* Process DEFINE_PEEPHOLE, DEFINE_INSN, and DEFINE_ASM_ATTRIBUTES.  */\n \n static void\n@@ -4404,7 +4409,7 @@ gen_insn (exp, lineno)\n       id->vec_idx = 0;\n       got_define_asm_attributes = 1;\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n@@ -4424,7 +4429,7 @@ gen_delay (def, lineno)\n   if (XVECLEN (def, 1) % 3 != 0)\n     {\n       message_with_line (lineno,\n-\t\"number of elements in DEFINE_DELAY must be multiple of three\");\n+\t\t\t \"number of elements in DEFINE_DELAY must be multiple of three\");\n       have_error = 1;\n       return;\n     }\n@@ -4436,7 +4441,7 @@ gen_delay (def, lineno)\n       if (XVECEXP (def, 1, i + 2))\n \thave_annul_false = 1;\n     }\n-  \n+\n   delay = (struct delay_desc *) oballoc (sizeof (struct delay_desc));\n   delay->def = def;\n   delay->num = ++num_delays;\n@@ -4445,7 +4450,7 @@ gen_delay (def, lineno)\n   delays = delay;\n }\n \f\n-/* Process a DEFINE_FUNCTION_UNIT.  \n+/* Process a DEFINE_FUNCTION_UNIT.\n \n    This gives information about a function unit contained in the CPU.\n    We fill in a `struct function_unit_op' and a `struct function_unit'\n@@ -4475,8 +4480,8 @@ gen_unit (def, lineno)\n \t    || unit->simultaneity != simultaneity)\n \t  {\n \t    message_with_line (lineno,\n-\t\t\t\"differing specifications given for function unit %s\",\n-\t\t\tunit->name);\n+\t\t\t       \"differing specifications given for function unit %s\",\n+\t\t\t       unit->name);\n \t    message_with_line (unit->first_lineno, \"previous definition\");\n \t    have_error = 1;\n \t    return;\n@@ -4537,7 +4542,7 @@ gen_unit (def, lineno)\n }\n \f\n /* Given a piece of RTX, print a C expression to test its truth value.\n-   We use AND and IOR both for logical and bit-wise operations, so \n+   We use AND and IOR both for logical and bit-wise operations, so\n    interpret them as logical unless they are inside a comparison expression.\n    The first bit of FLAGS will be non-zero in that case.\n \n@@ -4571,7 +4576,7 @@ write_test_expr (exp, flags)\n     case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n       write_test_expr (XEXP (exp, 0), flags | comparison_operator);\n       switch (code)\n-        {\n+\t{\n \tcase EQ:\n \t  printf (\" == \");\n \t  break;\n@@ -4641,7 +4646,7 @@ write_test_expr (exp, flags)\n \t  break;\n \tdefault:\n \t  abort ();\n-        }\n+\t}\n \n       write_test_expr (XEXP (exp, 1), flags | comparison_operator);\n       break;\n@@ -4657,7 +4662,7 @@ write_test_expr (exp, flags)\n \n       /* Otherwise, fall through to normal unary operator.  */\n \n-    /* Unary operators.  */   \n+    /* Unary operators.  */\n     case ABS:  case NEG:\n       switch (code)\n \t{\n@@ -4694,7 +4699,8 @@ write_test_expr (exp, flags)\n \t}\n \n       attr = find_attr (XSTR (exp, 0), 0);\n-      if (! attr) abort ();\n+      if (! attr)\n+\tabort ();\n \n       /* Now is the time to expand the value of a constant attribute.  */\n       if (attr->is_const)\n@@ -4725,7 +4731,7 @@ write_test_expr (exp, flags)\n     case MATCH_OPERAND:\n       /* If only a mode is given, just ensure the mode matches the operand.\n \t If neither a mode nor predicate is given, error.  */\n-     if (XSTR (exp, 1) == NULL || *XSTR (exp, 1) == '\\0')\n+      if (XSTR (exp, 1) == NULL || *XSTR (exp, 1) == '\\0')\n \t{\n \t  if (GET_MODE (exp) == VOIDmode)\n \t    fatal (\"Null MATCH_OPERAND specified as test\");\n@@ -4764,7 +4770,7 @@ write_test_expr (exp, flags)\n \t address of the next insn for forward branches, and both with\n \t adjustments that account for the worst-case possible stretching of\n \t intervening alignments between this insn and its destination.  */\n-      printf(\"insn_current_reference_address (insn)\");\n+      printf (\"insn_current_reference_address (insn)\");\n       break;\n \n     case CONST_STRING:\n@@ -4955,7 +4961,7 @@ write_attr_get (attr)\n      switch we will generate.  */\n   common_av = find_most_used (attr);\n \n-  /* Write out prototype of function. */\n+  /* Write out prototype of function.  */\n   if (!attr->is_numeric)\n     printf (\"extern enum attr_%s \", attr->name);\n   else if (attr->unsigned_p)\n@@ -5007,7 +5013,7 @@ write_attr_get (attr)\n     {\n       rtx p = XEXP (common_av->value, 0);\n \n-      /* No need to emit code to abort if the insn is unrecognized; the \n+      /* No need to emit code to abort if the insn is unrecognized; the\n          other get_attr_foo functions will do that when we call them.  */\n \n       write_toplevel_expr (p);\n@@ -5101,8 +5107,8 @@ write_attr_set (attr, indent, value, prefix, suffix, known_true,\n \t\t\t\t\t  XVECEXP (value, 0, i),\n \t\t\t\t\t  insn_code, insn_index);\n \t  newexp = attr_rtx (NOT, testexp);\n-\t  newexp  = insert_right_side (AND, our_known_true, newexp,\n-\t\t\t\t       insn_code, insn_index);\n+\t  newexp = insert_right_side (AND, our_known_true, newexp,\n+\t\t\t\t      insn_code, insn_index);\n \n \t  /* If the test expression is always true or if the next `known_true'\n \t     expression is always false, this is the last case, so break\n@@ -5130,7 +5136,7 @@ write_attr_set (attr, indent, value, prefix, suffix, known_true,\n \t  write_indent (indent + 2);\n \t  printf (\"{\\n\");\n \n-\t  write_attr_set (attr, indent + 4,  \n+\t  write_attr_set (attr, indent + 4,\n \t\t\t  XVECEXP (value, 0, i + 1), prefix, suffix,\n \t\t\t  inner_true, insn_code, insn_index);\n \t  write_indent (indent + 2);\n@@ -5296,11 +5302,11 @@ write_toplevel_expr (p)\n   int i;\n \n   for (i = 0; i < MAX_ATTRS_INDEX; ++i)\n-    for (attr = attrs[i]; attr ; attr = attr->next)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n       if (!attr->is_const)\n \twrite_expr_attr_cache (p, attr);\n \n-  printf(\"  register unsigned long accum = 0;\\n\\n\");\n+  printf (\"  register unsigned long accum = 0;\\n\\n\");\n \n   while (GET_CODE (p) == IOR)\n     {\n@@ -5410,7 +5416,7 @@ write_attr_value (attr, value)\n     case ATTR:\n       {\n \tstruct attr_desc *attr2 = find_attr (XSTR (value, 0), 0);\n-\tprintf (\"get_attr_%s (%s)\", attr2->name, \n+\tprintf (\"get_attr_%s (%s)\", attr2->name,\n \t\t(attr2->is_const ? \"\" : \"insn\"));\n       }\n       break;\n@@ -5449,11 +5455,11 @@ write_upcase (str)\n      const char *str;\n {\n   while (*str)\n-  {\n-    /* The argument of TOUPPER should not have side effects.  */\n-    putchar (TOUPPER(*str));\n-    str++;\n-  }\n+    {\n+      /* The argument of TOUPPER should not have side effects.  */\n+      putchar (TOUPPER(*str));\n+      str++;\n+    }\n }\n \n static void\n@@ -5481,7 +5487,7 @@ write_indent (indent)\n \n static void\n write_eligible_delay (kind)\n-  const char *kind;\n+     const char *kind;\n {\n   struct delay_desc *delay;\n   int max_slots;\n@@ -5501,8 +5507,8 @@ write_eligible_delay (kind)\n   /* Write function prelude.  */\n \n   printf (\"int\\n\");\n-  printf (\"eligible_for_%s (delay_insn, slot, candidate_insn, flags)\\n\", \n-\t   kind);\n+  printf (\"eligible_for_%s (delay_insn, slot, candidate_insn, flags)\\n\",\n+\t  kind);\n   printf (\"     rtx delay_insn;\\n\");\n   printf (\"     int slot;\\n\");\n   printf (\"     rtx candidate_insn;\\n\");\n@@ -5519,7 +5525,8 @@ write_eligible_delay (kind)\n   if (num_delays > 1)\n     {\n       attr = find_attr (\"*delay_type\", 0);\n-      if (! attr) abort ();\n+      if (! attr)\n+\tabort ();\n       common_av = find_most_used (attr);\n \n       printf (\"  insn = delay_insn;\\n\");\n@@ -5547,7 +5554,8 @@ write_eligible_delay (kind)\n       printf (\"    {\\n\");\n \n       attr = find_attr (\"*delay_1_0\", 0);\n-      if (! attr) abort ();\n+      if (! attr)\n+\tabort ();\n       common_av = find_most_used (attr);\n \n       for (av = attr->first_value; av; av = av->next)\n@@ -5576,7 +5584,8 @@ write_eligible_delay (kind)\n \n \t    sprintf (str, \"*%s_%d_%d\", kind, delay->num, i / 3);\n \t    attr = find_attr (str, 0);\n-\t    if (! attr) abort ();\n+\t    if (! attr)\n+\t      abort ();\n \t    common_av = find_most_used (attr);\n \n \t    for (av = attr->first_value; av; av = av->next)\n@@ -5588,7 +5597,7 @@ write_eligible_delay (kind)\n \t  }\n \n       printf (\"    default:\\n\");\n-      printf (\"      abort ();\\n\");     \n+      printf (\"      abort ();\\n\");\n       printf (\"    }\\n\");\n     }\n \n@@ -5681,8 +5690,7 @@ write_complex_function (unit, name, connection)\n \n   printf (\"static int %s_unit_%s PARAMS ((rtx, rtx));\\n\", unit->name, name);\n   printf (\"static int\\n\");\n-  printf (\"%s_unit_%s (executing_insn, candidate_insn)\\n\",\n-\t  unit->name, name);\n+  printf (\"%s_unit_%s (executing_insn, candidate_insn)\\n\", unit->name, name);\n   printf (\"     rtx executing_insn;\\n\");\n   printf (\"     rtx candidate_insn;\\n\");\n   printf (\"{\\n\");\n@@ -5696,7 +5704,8 @@ write_complex_function (unit, name, connection)\n   str = (char *) alloca (strlen (unit->name) + strlen (name) + strlen (connection) + 10);\n   sprintf (str, \"*%s_cases\", unit->name);\n   case_attr = find_attr (str, 0);\n-  if (! case_attr) abort ();\n+  if (! case_attr)\n+    abort ();\n   common_av = find_most_used (case_attr);\n \n   for (av = case_attr->first_value; av; av = av->next)\n@@ -5729,7 +5738,8 @@ write_complex_function (unit, name, connection)\n       printf (\"    case %d:\\n\", i);\n       sprintf (str, \"*%s_%s_%d\", unit->name, connection, i);\n       attr = find_attr (str, 0);\n-      if (! attr) abort ();\n+      if (! attr)\n+\tabort ();\n \n       /* If single value, just write it.  */\n       value = find_single_value (attr);\n@@ -5945,8 +5955,10 @@ extend_range (range, min, max)\n      int min;\n      int max;\n {\n-  if (range->min > min) range->min = min;\n-  if (range->max < max) range->max = max;\n+  if (range->min > min)\n+    range->min = min;\n+  if (range->max < max)\n+    range->max = max;\n }\n \n static rtx\n@@ -5973,15 +5985,15 @@ copy_rtx_unchanging (orig)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n       return orig;\n-      \n+\n     default:\n       break;\n     }\n \n   copy = rtx_alloc (code);\n   PUT_MODE (copy, GET_MODE (orig));\n   RTX_UNCHANGING_P (copy) = 1;\n-  \n+\n   bcopy ((char *) &XEXP (orig, 0), (char *) &XEXP (copy, 0),\n \t GET_RTX_LENGTH (GET_CODE (copy)) * sizeof (rtx));\n   return copy;\n@@ -6013,8 +6025,8 @@ write_const_num_delay_slots ()\n \t  if (length_used)\n \t    {\n \t      for (ie = av->first_insn; ie; ie = ie->next)\n-\t      if (ie->insn_code != -1)\n-\t\tprintf (\"    case %d:\\n\", ie->insn_code);\n+\t\tif (ie->insn_code != -1)\n+\t\t  printf (\"    case %d:\\n\", ie->insn_code);\n \t      printf (\"      return 0;\\n\");\n \t    }\n \t}\n@@ -6024,7 +6036,6 @@ write_const_num_delay_slots ()\n       printf (\"    }\\n}\\n\\n\");\n     }\n }\n-\n \f\n extern int main PARAMS ((int, char **));\n \n@@ -6087,29 +6098,29 @@ from the machine description file `md'.  */\\n\\n\");\n \n       switch (GET_CODE (desc))\n \t{\n-\t  case DEFINE_INSN:\n-\t  case DEFINE_PEEPHOLE:\n-\t  case DEFINE_ASM_ATTRIBUTES:\n-\t      gen_insn(desc, lineno);\n-\t      break;\n-\t  \n-\t  case DEFINE_ATTR:\n-\t      gen_attr (desc, lineno);\n-\t      break;\n+\tcase DEFINE_INSN:\n+\tcase DEFINE_PEEPHOLE:\n+\tcase DEFINE_ASM_ATTRIBUTES:\n+\t  gen_insn (desc, lineno);\n+\t  break;\n \n-\t  case DEFINE_DELAY:\n-\t      gen_delay (desc, lineno);\n-\t      break;\n+\tcase DEFINE_ATTR:\n+\t  gen_attr (desc, lineno);\n+\t  break;\n \n-\t  case DEFINE_FUNCTION_UNIT:\n-\t      gen_unit (desc, lineno);\n-\t      break;\n-\t      \t\n-\t  default:\n-\t      break;\n+\tcase DEFINE_DELAY:\n+\t  gen_delay (desc, lineno);\n+\t  break;\n+\n+\tcase DEFINE_FUNCTION_UNIT:\n+\t  gen_unit (desc, lineno);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n       if (GET_CODE (desc) != DEFINE_ASM_ATTRIBUTES)\n-        insn_index_number++;\n+\tinsn_index_number++;\n     }\n \n   if (have_error)\n@@ -6144,7 +6155,7 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"output.h\\\"\\n\");\n   printf (\"#include \\\"insn-attr.h\\\"\\n\");\n   printf (\"#include \\\"toplev.h\\\"\\n\");\n-  printf (\"\\n\");  \n+  printf (\"\\n\");\n   printf (\"#define operands recog_data.operand\\n\\n\");\n \n   /* Make `insn_alternatives'.  */"}]}