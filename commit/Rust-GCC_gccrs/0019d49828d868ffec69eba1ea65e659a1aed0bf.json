{"sha": "0019d49828d868ffec69eba1ea65e659a1aed0bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAxOWQ0OTgyOGQ4NjhmZmVjNjllYmExZWE2NWU2NTlhMWFlZDBiZg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-07-15T12:23:47Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-07-15T12:23:47Z"}, "message": "re PR fortran/44709 (BLOCK and GOTO/EXIT/CYCLE)\n\n2010-07-15  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/44709\n\t* trans.h (struct gfc_wrapped_block): New struct.\n\t(gfc_start_wrapped_block), (gfc_add_init_cleanup): New methods.\n\t(gfc_finish_wrapped_block): New method.\n\t(gfc_init_default_dt): Add new init code to block rather than\n\treturning it.\n\t* trans-array.h (gfc_trans_auto_array_allocation): Use gfc_wrapped_block\n\t(gfc_trans_dummy_array_bias): Ditto.\n\t(gfc_trans_g77_array): Ditto.\n\t(gfc_trans_deferred_array): Ditto.\n\t* trans.c (gfc_add_expr_to_block): Call add_expr_to_chain.\n\t(add_expr_to_chain): New method based on old gfc_add_expr_to_block.\n\t(gfc_start_wrapped_block), (gfc_add_init_cleanup): New methods.\n\t(gfc_finish_wrapped_block): New method.\n\t* trans-array.c (gfc_trans_auto_array_allocation): use gfc_wrapped_block\n\t(gfc_trans_g77_array), (gfc_trans_dummy_array_bias): Ditto.\n\t(gfc_trans_deferred_array): Ditto.\n\t* trans-decl.c (gfc_trans_dummy_character): Ditto.\n\t(gfc_trans_auto_character_variable), (gfc_trans_assign_aux_var): Ditto.\n\t(init_intent_out_dt): Ditto.\n\t(gfc_init_default_dt): Add new init code to block rather than\n\treturning it.\n\t(gfc_trans_deferred_vars): Use gfc_wrapped_block to collect all init\n\tand cleanup code and put it all together.\n\nFrom-SVN: r162219", "tree": {"sha": "0b4c5c6d817b7ea90e44a560553aff0ce48f0a1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b4c5c6d817b7ea90e44a560553aff0ce48f0a1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0019d49828d868ffec69eba1ea65e659a1aed0bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0019d49828d868ffec69eba1ea65e659a1aed0bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0019d49828d868ffec69eba1ea65e659a1aed0bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0019d49828d868ffec69eba1ea65e659a1aed0bf/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f644b3d1af766044c4ff14a24d3266c948785dd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f644b3d1af766044c4ff14a24d3266c948785dd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f644b3d1af766044c4ff14a24d3266c948785dd1"}], "stats": {"total": 609, "additions": 360, "deletions": 249}, "files": [{"sha": "874f828b5767bda1fe0a00e6edc2cad039affb61", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0019d49828d868ffec69eba1ea65e659a1aed0bf", "patch": "@@ -1,3 +1,30 @@\n+2010-07-15  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/44709\n+\t* trans.h (struct gfc_wrapped_block): New struct.\n+\t(gfc_start_wrapped_block), (gfc_add_init_cleanup): New methods.\n+\t(gfc_finish_wrapped_block): New method.\n+\t(gfc_init_default_dt): Add new init code to block rather than\n+\treturning it.\n+\t* trans-array.h (gfc_trans_auto_array_allocation): Use gfc_wrapped_block\n+\t(gfc_trans_dummy_array_bias): Ditto.\n+\t(gfc_trans_g77_array): Ditto.\n+\t(gfc_trans_deferred_array): Ditto.\n+\t* trans.c (gfc_add_expr_to_block): Call add_expr_to_chain.\n+\t(add_expr_to_chain): New method based on old gfc_add_expr_to_block.\n+\t(gfc_start_wrapped_block), (gfc_add_init_cleanup): New methods.\n+\t(gfc_finish_wrapped_block): New method.\n+\t* trans-array.c (gfc_trans_auto_array_allocation): use gfc_wrapped_block\n+\t(gfc_trans_g77_array), (gfc_trans_dummy_array_bias): Ditto.\n+\t(gfc_trans_deferred_array): Ditto.\n+\t* trans-decl.c (gfc_trans_dummy_character): Ditto.\n+\t(gfc_trans_auto_character_variable), (gfc_trans_assign_aux_var): Ditto.\n+\t(init_intent_out_dt): Ditto.\n+\t(gfc_init_default_dt): Add new init code to block rather than\n+\treturning it.\n+\t(gfc_trans_deferred_vars): Use gfc_wrapped_block to collect all init\n+\tand cleanup code and put it all together.\n+\n 2010-07-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans.h (gfc_build_compare_string): Add CODE argument."}, {"sha": "6dfb0699346e79be880d5a8d32c7b6b1f2410aea", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 143, "deletions": 154, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0019d49828d868ffec69eba1ea65e659a1aed0bf", "patch": "@@ -4265,10 +4265,11 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \n /* Generate code to initialize/allocate an array variable.  */\n \n-tree\n-gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n+void\n+gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym,\n+\t\t\t\t gfc_wrapped_block * block)\n {\n-  stmtblock_t block;\n+  stmtblock_t init;\n   tree type;\n   tree tmp;\n   tree size;\n@@ -4279,32 +4280,32 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   /* Do nothing for USEd variables.  */\n   if (sym->attr.use_assoc)\n-    return fnbody;\n+    return;\n \n   type = TREE_TYPE (decl);\n   gcc_assert (GFC_ARRAY_TYPE_P (type));\n   onstack = TREE_CODE (type) != POINTER_TYPE;\n \n-  gfc_start_block (&block);\n+  gfc_start_block (&init);\n \n   /* Evaluate character string length.  */\n   if (sym->ts.type == BT_CHARACTER\n       && onstack && !INTEGER_CST_P (sym->ts.u.cl->backend_decl))\n     {\n-      gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n+      gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n-      gfc_trans_vla_type_sizes (sym, &block);\n+      gfc_trans_vla_type_sizes (sym, &init);\n \n       /* Emit a DECL_EXPR for this variable, which will cause the\n \t gimplifier to allocate storage, and all that good stuff.  */\n       tmp = fold_build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n-      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_expr_to_block (&init, tmp);\n     }\n \n   if (onstack)\n     {\n-      gfc_add_expr_to_block (&block, fnbody);\n-      return gfc_finish_block (&block);\n+      gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n+      return;\n     }\n \n   type = TREE_TYPE (type);\n@@ -4315,17 +4316,18 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.u.cl->backend_decl))\n-    gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n+    gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n-  size = gfc_trans_array_bounds (type, sym, &offset, &block);\n+  size = gfc_trans_array_bounds (type, sym, &offset, &init);\n \n   /* Don't actually allocate space for Cray Pointees.  */\n   if (sym->attr.cray_pointee)\n     {\n       if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-\tgfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n-      gfc_add_expr_to_block (&block, fnbody);\n-      return gfc_finish_block (&block);\n+\tgfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+\n+      gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n+      return;\n     }\n \n   /* The size is the number of elements in the array, so multiply by the\n@@ -4335,39 +4337,35 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \t\t      fold_convert (gfc_array_index_type, tmp));\n \n   /* Allocate memory to hold the data.  */\n-  tmp = gfc_call_malloc (&block, TREE_TYPE (decl), size);\n-  gfc_add_modify (&block, decl, tmp);\n+  tmp = gfc_call_malloc (&init, TREE_TYPE (decl), size);\n+  gfc_add_modify (&init, decl, tmp);\n \n   /* Set offset of the array.  */\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-    gfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n-\n+    gfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n   /* Automatic arrays should not have initializers.  */\n   gcc_assert (!sym->value);\n \n-  gfc_add_expr_to_block (&block, fnbody);\n-\n   /* Free the temporary.  */\n   tmp = gfc_call_free (convert (pvoid_type_node, decl));\n-  gfc_add_expr_to_block (&block, tmp);\n \n-  return gfc_finish_block (&block);\n+  gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n }\n \n \n /* Generate entry and exit code for g77 calling convention arrays.  */\n \n-tree\n-gfc_trans_g77_array (gfc_symbol * sym, tree body)\n+void\n+gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)\n {\n   tree parm;\n   tree type;\n   locus loc;\n   tree offset;\n   tree tmp;\n   tree stmt;  \n-  stmtblock_t block;\n+  stmtblock_t init;\n \n   gfc_get_backend_locus (&loc);\n   gfc_set_backend_locus (&sym->declared_at);\n@@ -4377,31 +4375,29 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n   type = TREE_TYPE (parm);\n   gcc_assert (GFC_ARRAY_TYPE_P (type));\n \n-  gfc_start_block (&block);\n+  gfc_start_block (&init);\n \n   if (sym->ts.type == BT_CHARACTER\n       && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n-    gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n+    gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n   /* Evaluate the bounds of the array.  */\n-  gfc_trans_array_bounds (type, sym, &offset, &block);\n+  gfc_trans_array_bounds (type, sym, &offset, &init);\n \n   /* Set the offset.  */\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-    gfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+    gfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n   /* Set the pointer itself if we aren't using the parameter directly.  */\n   if (TREE_CODE (parm) != PARM_DECL)\n     {\n       tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));\n-      gfc_add_modify (&block, parm, tmp);\n+      gfc_add_modify (&init, parm, tmp);\n     }\n-  stmt = gfc_finish_block (&block);\n+  stmt = gfc_finish_block (&init);\n \n   gfc_set_backend_locus (&loc);\n \n-  gfc_start_block (&block);\n-\n   /* Add the initialization code to the start of the function.  */\n \n   if (sym->attr.optional || sym->attr.not_always_present)\n@@ -4410,10 +4406,7 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n       stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n     }\n   \n-  gfc_add_expr_to_block (&block, stmt);\n-  gfc_add_expr_to_block (&block, body);\n-\n-  return gfc_finish_block (&block);\n+  gfc_add_init_cleanup (block, stmt, NULL_TREE);\n }\n \n \n@@ -4428,22 +4421,22 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n    Code is also added to copy the data back at the end of the function.\n    */\n \n-tree\n-gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n+void\n+gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n+\t\t\t    gfc_wrapped_block * block)\n {\n   tree size;\n   tree type;\n   tree offset;\n   locus loc;\n-  stmtblock_t block;\n-  stmtblock_t cleanup;\n+  stmtblock_t init;\n+  tree stmtInit, stmtCleanup;\n   tree lbound;\n   tree ubound;\n   tree dubound;\n   tree dlbound;\n   tree dumdesc;\n   tree tmp;\n-  tree stmt;\n   tree stride, stride2;\n   tree stmt_packed;\n   tree stmt_unpacked;\n@@ -4456,10 +4449,13 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n   /* Do nothing for pointer and allocatable arrays.  */\n   if (sym->attr.pointer || sym->attr.allocatable)\n-    return body;\n+    return;\n \n   if (sym->attr.dummy && gfc_is_nodesc_array (sym))\n-    return gfc_trans_g77_array (sym, body);\n+    {\n+      gfc_trans_g77_array (sym, block);\n+      return;\n+    }\n \n   gfc_get_backend_locus (&loc);\n   gfc_set_backend_locus (&sym->declared_at);\n@@ -4468,50 +4464,47 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   type = TREE_TYPE (tmpdesc);\n   gcc_assert (GFC_ARRAY_TYPE_P (type));\n   dumdesc = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n-  dumdesc = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t     dumdesc);\n-  gfc_start_block (&block);\n+  dumdesc = build_fold_indirect_ref_loc (input_location, dumdesc);\n+  gfc_start_block (&init);\n \n   if (sym->ts.type == BT_CHARACTER\n       && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n-    gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n+    gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n   checkparm = (sym->as->type == AS_EXPLICIT\n \t       && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS));\n \n   no_repack = !(GFC_DECL_PACKED_ARRAY (tmpdesc)\n-                || GFC_DECL_PARTIAL_PACKED_ARRAY (tmpdesc));\n+\t\t|| GFC_DECL_PARTIAL_PACKED_ARRAY (tmpdesc));\n \n   if (GFC_DECL_PARTIAL_PACKED_ARRAY (tmpdesc))\n     {\n       /* For non-constant shape arrays we only check if the first dimension\n-         is contiguous.  Repacking higher dimensions wouldn't gain us\n-         anything as we still don't know the array stride.  */\n+\t is contiguous.  Repacking higher dimensions wouldn't gain us\n+\t anything as we still don't know the array stride.  */\n       partial = gfc_create_var (boolean_type_node, \"partial\");\n       TREE_USED (partial) = 1;\n       tmp = gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[0]);\n       tmp = fold_build2 (EQ_EXPR, boolean_type_node, tmp, gfc_index_one_node);\n-      gfc_add_modify (&block, partial, tmp);\n+      gfc_add_modify (&init, partial, tmp);\n     }\n   else\n-    {\n-      partial = NULL_TREE;\n-    }\n+    partial = NULL_TREE;\n \n   /* The naming of stmt_unpacked and stmt_packed may be counter-intuitive\n      here, however I think it does the right thing.  */\n   if (no_repack)\n     {\n       /* Set the first stride.  */\n       stride = gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[0]);\n-      stride = gfc_evaluate_now (stride, &block);\n+      stride = gfc_evaluate_now (stride, &init);\n \n       tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n \t\t\t stride, gfc_index_zero_node);\n       tmp = fold_build3 (COND_EXPR, gfc_array_index_type, tmp,\n \t\t\t gfc_index_one_node, stride);\n       stride = GFC_TYPE_ARRAY_STRIDE (type, 0);\n-      gfc_add_modify (&block, stride, tmp);\n+      gfc_add_modify (&init, stride, tmp);\n \n       /* Allow the user to disable array repacking.  */\n       stmt_unpacked = NULL_TREE;\n@@ -4546,7 +4539,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n     }\n   else\n     tmp = stmt_packed != NULL_TREE ? stmt_packed : stmt_unpacked;\n-  gfc_add_modify (&block, tmpdesc, fold_convert (type, tmp));\n+  gfc_add_modify (&init, tmpdesc, fold_convert (type, tmp));\n \n   offset = gfc_index_zero_node;\n   size = gfc_index_one_node;\n@@ -4561,34 +4554,34 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t  dlbound = gfc_conv_descriptor_lbound_get (dumdesc, gfc_rank_cst[n]);\n \t}\n       else\n-        {\n+\t{\n \t  dubound = NULL_TREE;\n \t  dlbound = NULL_TREE;\n-        }\n+\t}\n \n       lbound = GFC_TYPE_ARRAY_LBOUND (type, n);\n       if (!INTEGER_CST_P (lbound))\n-        {\n-          gfc_init_se (&se, NULL);\n-          gfc_conv_expr_type (&se, sym->as->lower[n],\n-                              gfc_array_index_type);\n-          gfc_add_block_to_block (&block, &se.pre);\n-          gfc_add_modify (&block, lbound, se.expr);\n-        }\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_type (&se, sym->as->lower[n],\n+\t\t\t      gfc_array_index_type);\n+\t  gfc_add_block_to_block (&init, &se.pre);\n+\t  gfc_add_modify (&init, lbound, se.expr);\n+\t}\n \n       ubound = GFC_TYPE_ARRAY_UBOUND (type, n);\n       /* Set the desired upper bound.  */\n       if (sym->as->upper[n])\n \t{\n \t  /* We know what we want the upper bound to be.  */\n-          if (!INTEGER_CST_P (ubound))\n-            {\n+\t  if (!INTEGER_CST_P (ubound))\n+\t    {\n \t      gfc_init_se (&se, NULL);\n \t      gfc_conv_expr_type (&se, sym->as->upper[n],\n-                                  gfc_array_index_type);\n-\t      gfc_add_block_to_block (&block, &se.pre);\n-              gfc_add_modify (&block, ubound, se.expr);\n-            }\n+\t\t\t\t  gfc_array_index_type);\n+\t      gfc_add_block_to_block (&init, &se.pre);\n+\t      gfc_add_modify (&init, ubound, se.expr);\n+\t    }\n \n \t  /* Check the sizes match.  */\n \t  if (checkparm)\n@@ -4607,11 +4600,11 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t      stride2 = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t\t     gfc_index_one_node, stride2);\n \n-              tmp = fold_build2 (NE_EXPR, gfc_array_index_type, temp, stride2);\n+\t      tmp = fold_build2 (NE_EXPR, gfc_array_index_type, temp, stride2);\n \t      asprintf (&msg, \"Dimension %d of array '%s' has extent \"\n-\t\t        \"%%ld instead of %%ld\", n+1, sym->name);\n+\t\t\t\"%%ld instead of %%ld\", n+1, sym->name);\n \n-\t      gfc_trans_runtime_check (true, false, tmp, &block, &loc, msg, \n+\t      gfc_trans_runtime_check (true, false, tmp, &init, &loc, msg, \n \t\t\tfold_convert (long_integer_type_node, temp),\n \t\t\tfold_convert (long_integer_type_node, stride2));\n \n@@ -4622,52 +4615,50 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t{\n \t  /* For assumed shape arrays move the upper bound by the same amount\n \t     as the lower bound.  */\n-          tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t     dubound, dlbound);\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound);\n-          gfc_add_modify (&block, ubound, tmp);\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound);\n+\t  gfc_add_modify (&init, ubound, tmp);\n \t}\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n       tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, lbound, stride);\n       offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n \n       /* The size of this dimension, and the stride of the next.  */\n       if (n + 1 < sym->as->rank)\n-        {\n-          stride = GFC_TYPE_ARRAY_STRIDE (type, n + 1);\n+\t{\n+\t  stride = GFC_TYPE_ARRAY_STRIDE (type, n + 1);\n \n-          if (no_repack || partial != NULL_TREE)\n-            {\n-              stmt_unpacked =\n-                gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[n+1]);\n-            }\n+\t  if (no_repack || partial != NULL_TREE)\n+\t    stmt_unpacked =\n+\t      gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[n+1]);\n \n-          /* Figure out the stride if not a known constant.  */\n-          if (!INTEGER_CST_P (stride))\n-            {\n-              if (no_repack)\n-                stmt_packed = NULL_TREE;\n-              else\n-                {\n-                  /* Calculate stride = size * (ubound + 1 - lbound).  */\n-                  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t  /* Figure out the stride if not a known constant.  */\n+\t  if (!INTEGER_CST_P (stride))\n+\t    {\n+\t      if (no_repack)\n+\t\tstmt_packed = NULL_TREE;\n+\t      else\n+\t\t{\n+\t\t  /* Calculate stride = size * (ubound + 1 - lbound).  */\n+\t\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t\t     gfc_index_one_node, lbound);\n-                  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t\t     ubound, tmp);\n-                  size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t  size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t      size, tmp);\n-                  stmt_packed = size;\n-                }\n+\t\t  stmt_packed = size;\n+\t\t}\n \n-              /* Assign the stride.  */\n-              if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n+\t      /* Assign the stride.  */\n+\t      if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n \t\ttmp = fold_build3 (COND_EXPR, gfc_array_index_type, partial,\n \t\t\t\t   stmt_unpacked, stmt_packed);\n-              else\n-                tmp = (stmt_packed != NULL_TREE) ? stmt_packed : stmt_unpacked;\n-              gfc_add_modify (&block, stride, tmp);\n-            }\n-        }\n+\t      else\n+\t\ttmp = (stmt_packed != NULL_TREE) ? stmt_packed : stmt_unpacked;\n+\t      gfc_add_modify (&init, stride, tmp);\n+\t    }\n+\t}\n       else\n \t{\n \t  stride = GFC_TYPE_ARRAY_SIZE (type);\n@@ -4681,20 +4672,18 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t\t\t\t ubound, tmp);\n \t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t GFC_TYPE_ARRAY_STRIDE (type, n), tmp);\n-\t      gfc_add_modify (&block, stride, tmp);\n+\t      gfc_add_modify (&init, stride, tmp);\n \t    }\n \t}\n     }\n \n   /* Set the offset.  */\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-    gfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+    gfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n-  gfc_trans_vla_type_sizes (sym, &block);\n+  gfc_trans_vla_type_sizes (sym, &init);\n \n-  stmt = gfc_finish_block (&block);\n-\n-  gfc_start_block (&block);\n+  stmtInit = gfc_finish_block (&init);\n \n   /* Only do the entry/initialization code if the arg is present.  */\n   dumdesc = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n@@ -4704,18 +4693,18 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   if (optional_arg)\n     {\n       tmp = gfc_conv_expr_present (sym);\n-      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n+      stmtInit = build3_v (COND_EXPR, tmp, stmtInit,\n+\t\t\t   build_empty_stmt (input_location));\n     }\n-  gfc_add_expr_to_block (&block, stmt);\n-\n-  /* Add the main function body.  */\n-  gfc_add_expr_to_block (&block, body);\n \n   /* Cleanup code.  */\n-  if (!no_repack)\n+  if (no_repack)\n+    stmtCleanup = NULL_TREE;\n+  else\n     {\n+      stmtblock_t cleanup;\n       gfc_start_block (&cleanup);\n-      \n+\n       if (sym->attr.intent != INTENT_IN)\n \t{\n \t  /* Copy the data back.  */\n@@ -4728,26 +4717,26 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       tmp = gfc_call_free (tmpdesc);\n       gfc_add_expr_to_block (&cleanup, tmp);\n \n-      stmt = gfc_finish_block (&cleanup);\n+      stmtCleanup = gfc_finish_block (&cleanup);\n \t\n       /* Only do the cleanup if the array was repacked.  */\n-      tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t     dumdesc);\n+      tmp = build_fold_indirect_ref_loc (input_location, dumdesc);\n       tmp = gfc_conv_descriptor_data_get (tmp);\n       tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n-      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n+      stmtCleanup = build3_v (COND_EXPR, tmp, stmtCleanup,\n+\t\t\t      build_empty_stmt (input_location));\n \n       if (optional_arg)\n-        {\n-          tmp = gfc_conv_expr_present (sym);\n-          stmt = build3_v (COND_EXPR, tmp, stmt,\n-\t\t\t   build_empty_stmt (input_location));\n-        }\n-      gfc_add_expr_to_block (&block, stmt);\n+\t{\n+\t  tmp = gfc_conv_expr_present (sym);\n+\t  stmtCleanup = build3_v (COND_EXPR, tmp, stmtCleanup,\n+\t\t\t\t  build_empty_stmt (input_location));\n+\t}\n     }\n+\n   /* We don't need to free any memory allocated by internal_pack as it will\n      be freed at the end of the function by pop_context.  */\n-  return gfc_finish_block (&block);\n+  gfc_add_init_cleanup (block, stmtInit, stmtCleanup);\n }\n \n \n@@ -6217,13 +6206,14 @@ gfc_copy_only_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n    Do likewise, recursively if necessary, with the allocatable components of\n    derived types.  */\n \n-tree\n-gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n+void\n+gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n {\n   tree type;\n   tree tmp;\n   tree descriptor;\n-  stmtblock_t fnblock;\n+  stmtblock_t init;\n+  stmtblock_t cleanup;\n   locus loc;\n   int rank;\n   bool sym_has_alloc_comp;\n@@ -6237,24 +6227,23 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \t\t \"allocatable attribute or derived type without allocatable \"\n \t\t \"components.\");\n \n-  gfc_init_block (&fnblock);\n+  gfc_init_block (&init);\n \n   gcc_assert (TREE_CODE (sym->backend_decl) == VAR_DECL\n \t\t|| TREE_CODE (sym->backend_decl) == PARM_DECL);\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.u.cl->backend_decl))\n     {\n-      gfc_conv_string_length (sym->ts.u.cl, NULL, &fnblock);\n-      gfc_trans_vla_type_sizes (sym, &fnblock);\n+      gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n+      gfc_trans_vla_type_sizes (sym, &init);\n     }\n \n   /* Dummy, use associated and result variables don't need anything special.  */\n   if (sym->attr.dummy || sym->attr.use_assoc || sym->attr.result)\n     {\n-      gfc_add_expr_to_block (&fnblock, body);\n-\n-      return gfc_finish_block (&fnblock);\n+      gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n+      return;\n     }\n \n   gfc_get_backend_locus (&loc);\n@@ -6268,7 +6257,9 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n     {\n       /* SAVEd variables are not freed on exit.  */\n       gfc_trans_static_array_pointer (sym);\n-      return body;\n+\n+      gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n+      return;\n     }\n \n   /* Get the descriptor type.  */\n@@ -6283,31 +6274,28 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \t      || !gfc_has_default_initializer (sym->ts.u.derived))\n \t    {\n \t      rank = sym->as ? sym->as->rank : 0;\n-\t      tmp = gfc_nullify_alloc_comp (sym->ts.u.derived, descriptor, rank);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      tmp = gfc_nullify_alloc_comp (sym->ts.u.derived,\n+\t\t\t\t\t    descriptor, rank);\n+\t      gfc_add_expr_to_block (&init, tmp);\n \t    }\n \t  else\n-\t    {\n-\t      tmp = gfc_init_default_dt (sym, NULL, false);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n-\t    }\n+\t    gfc_init_default_dt (sym, &init, false);\n \t}\n     }\n   else if (!GFC_DESCRIPTOR_TYPE_P (type))\n     {\n       /* If the backend_decl is not a descriptor, we must have a pointer\n \t to one.  */\n       descriptor = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t    sym->backend_decl);\n+\t\t\t\t\t\tsym->backend_decl);\n       type = TREE_TYPE (descriptor);\n     }\n   \n   /* NULLIFY the data pointer.  */\n   if (GFC_DESCRIPTOR_TYPE_P (type) && !sym->attr.save)\n-    gfc_conv_descriptor_data_set (&fnblock, descriptor, null_pointer_node);\n-\n-  gfc_add_expr_to_block (&fnblock, body);\n+    gfc_conv_descriptor_data_set (&init, descriptor, null_pointer_node);\n \n+  gfc_init_block (&cleanup);\n   gfc_set_backend_locus (&loc);\n \n   /* Allocatable arrays need to be freed when they go out of scope.\n@@ -6318,17 +6306,18 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n       int rank;\n       rank = sym->as ? sym->as->rank : 0;\n       tmp = gfc_deallocate_alloc_comp (sym->ts.u.derived, descriptor, rank);\n-      gfc_add_expr_to_block (&fnblock, tmp);\n+      gfc_add_expr_to_block (&cleanup, tmp);\n     }\n \n   if (sym->attr.allocatable && sym->attr.dimension\n       && !sym->attr.save && !sym->attr.result)\n     {\n       tmp = gfc_trans_dealloc_allocated (sym->backend_decl);\n-      gfc_add_expr_to_block (&fnblock, tmp);\n+      gfc_add_expr_to_block (&cleanup, tmp);\n     }\n \n-  return gfc_finish_block (&fnblock);\n+  gfc_add_init_cleanup (block, gfc_finish_block (&init),\n+\t\t\tgfc_finish_block (&cleanup));\n }\n \n /************ Expression Walking Functions ******************/"}, {"sha": "2e491c8c16be44a3770164ac6e93b9c3d875ebce", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=0019d49828d868ffec69eba1ea65e659a1aed0bf", "patch": "@@ -37,11 +37,11 @@ tree gfc_trans_create_temp_array (stmtblock_t *, stmtblock_t *, gfc_loopinfo *,\n \n /* Generate function entry code for allocation of compiler allocated array\n    variables.  */\n-tree gfc_trans_auto_array_allocation (tree, gfc_symbol *, tree);\n+void gfc_trans_auto_array_allocation (tree, gfc_symbol *, gfc_wrapped_block *);\n /* Generate entry and exit code for dummy array parameters.  */\n-tree gfc_trans_dummy_array_bias (gfc_symbol *, tree, tree);\n+void gfc_trans_dummy_array_bias (gfc_symbol *, tree, gfc_wrapped_block *);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n-tree gfc_trans_g77_array (gfc_symbol *, tree);\n+void gfc_trans_g77_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate code to deallocate an array, if it is allocated.  */\n tree gfc_trans_dealloc_allocated (tree);\n \n@@ -58,7 +58,7 @@ tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int);\n tree gfc_copy_only_alloc_comp (gfc_symbol *, tree, tree, int);\n \n /* Add initialization for deferred arrays.  */\n-tree gfc_trans_deferred_array (gfc_symbol *, tree);\n+void gfc_trans_deferred_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate an initializer for a static pointer or allocatable array.  */\n void gfc_trans_static_array_pointer (gfc_symbol *);\n "}, {"sha": "dd238fe4a4840d2fee2555f8ff77eacd0295b7d4", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 81, "deletions": 77, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0019d49828d868ffec69eba1ea65e659a1aed0bf", "patch": "@@ -2838,72 +2838,70 @@ gfc_build_builtin_function_decls (void)\n \n /* Evaluate the length of dummy character variables.  */\n \n-static tree\n-gfc_trans_dummy_character (gfc_symbol *sym, gfc_charlen *cl, tree fnbody)\n+static void\n+gfc_trans_dummy_character (gfc_symbol *sym, gfc_charlen *cl,\n+\t\t\t   gfc_wrapped_block *block)\n {\n-  stmtblock_t body;\n+  stmtblock_t init;\n \n   gfc_finish_decl (cl->backend_decl);\n \n-  gfc_start_block (&body);\n+  gfc_start_block (&init);\n \n   /* Evaluate the string length expression.  */\n-  gfc_conv_string_length (cl, NULL, &body);\n+  gfc_conv_string_length (cl, NULL, &init);\n \n-  gfc_trans_vla_type_sizes (sym, &body);\n+  gfc_trans_vla_type_sizes (sym, &init);\n \n-  gfc_add_expr_to_block (&body, fnbody);\n-  return gfc_finish_block (&body);\n+  gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n }\n \n \n /* Allocate and cleanup an automatic character variable.  */\n \n-static tree\n-gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n+static void\n+gfc_trans_auto_character_variable (gfc_symbol * sym, gfc_wrapped_block * block)\n {\n-  stmtblock_t body;\n+  stmtblock_t init;\n   tree decl;\n   tree tmp;\n \n   gcc_assert (sym->backend_decl);\n   gcc_assert (sym->ts.u.cl && sym->ts.u.cl->length);\n \n-  gfc_start_block (&body);\n+  gfc_start_block (&init);\n \n   /* Evaluate the string length expression.  */\n-  gfc_conv_string_length (sym->ts.u.cl, NULL, &body);\n+  gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n-  gfc_trans_vla_type_sizes (sym, &body);\n+  gfc_trans_vla_type_sizes (sym, &init);\n \n   decl = sym->backend_decl;\n \n   /* Emit a DECL_EXPR for this variable, which will cause the\n      gimplifier to allocate storage, and all that good stuff.  */\n   tmp = fold_build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n-  gfc_add_expr_to_block (&body, tmp);\n+  gfc_add_expr_to_block (&init, tmp);\n \n-  gfc_add_expr_to_block (&body, fnbody);\n-  return gfc_finish_block (&body);\n+  gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n }\n \n /* Set the initial value of ASSIGN statement auxiliary variable explicitly.  */\n \n-static tree\n-gfc_trans_assign_aux_var (gfc_symbol * sym, tree fnbody)\n+static void\n+gfc_trans_assign_aux_var (gfc_symbol * sym, gfc_wrapped_block * block)\n {\n-  stmtblock_t body;\n+  stmtblock_t init;\n \n   gcc_assert (sym->backend_decl);\n-  gfc_start_block (&body);\n+  gfc_start_block (&init);\n \n   /* Set the initial value to length. See the comments in\n      function gfc_add_assign_aux_vars in this file.  */\n-  gfc_add_modify (&body, GFC_DECL_STRING_LEN (sym->backend_decl),\n-\t\t       build_int_cst (NULL_TREE, -2));\n+  gfc_add_modify (&init, GFC_DECL_STRING_LEN (sym->backend_decl),\n+\t\t  build_int_cst (NULL_TREE, -2));\n \n-  gfc_add_expr_to_block (&body, fnbody);\n-  return gfc_finish_block (&body);\n+  gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n }\n \n static void\n@@ -3016,15 +3014,15 @@ gfc_trans_vla_type_sizes (gfc_symbol *sym, stmtblock_t *body)\n /* Initialize a derived type by building an lvalue from the symbol\n    and using trans_assignment to do the work. Set dealloc to false\n    if no deallocation prior the assignment is needed.  */\n-tree\n-gfc_init_default_dt (gfc_symbol * sym, tree body, bool dealloc)\n+void\n+gfc_init_default_dt (gfc_symbol * sym, stmtblock_t * block, bool dealloc)\n {\n-  stmtblock_t fnblock;\n   gfc_expr *e;\n   tree tmp;\n   tree present;\n \n-  gfc_init_block (&fnblock);\n+  gcc_assert (block);\n+\n   gcc_assert (!sym->attr.allocatable);\n   gfc_set_sym_referenced (sym);\n   e = gfc_lval_expr_from_sym (sym);\n@@ -3036,27 +3034,24 @@ gfc_init_default_dt (gfc_symbol * sym, tree body, bool dealloc)\n       tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n \t\t    tmp, build_empty_stmt (input_location));\n     }\n-  gfc_add_expr_to_block (&fnblock, tmp);\n+  gfc_add_expr_to_block (block, tmp);\n   gfc_free_expr (e);\n-  if (body)\n-    gfc_add_expr_to_block (&fnblock, body);\n-  return gfc_finish_block (&fnblock);\n }\n \n \n /* Initialize INTENT(OUT) derived type dummies.  As well as giving\n    them their default initializer, if they do not have allocatable\n    components, they have their allocatable components deallocated. */\n \n-static tree\n-init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n+static void\n+init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n {\n-  stmtblock_t fnblock;\n+  stmtblock_t init;\n   gfc_formal_arglist *f;\n   tree tmp;\n   tree present;\n \n-  gfc_init_block (&fnblock);\n+  gfc_init_block (&init);\n   for (f = proc_sym->formal; f; f = f->next)\n     if (f->sym && f->sym->attr.intent == INTENT_OUT\n \t&& !f->sym->attr.pointer\n@@ -3076,14 +3071,13 @@ init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n \t\t\t      tmp, build_empty_stmt (input_location));\n \t      }\n \n-\t    gfc_add_expr_to_block (&fnblock, tmp);\n+\t    gfc_add_expr_to_block (&init, tmp);\n \t  }\n        else if (f->sym->value)\n-\t  body = gfc_init_default_dt (f->sym, body, true);\n+\t  gfc_init_default_dt (f->sym, &init, true);\n       }\n \n-  gfc_add_expr_to_block (&fnblock, body);\n-  return gfc_finish_block (&fnblock);\n+  gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n }\n \n \n@@ -3101,9 +3095,12 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n   locus loc;\n   gfc_symbol *sym;\n   gfc_formal_arglist *f;\n-  stmtblock_t body;\n+  stmtblock_t tmpblock;\n+  gfc_wrapped_block try_block;\n   bool seen_trans_deferred_array = false;\n \n+  gfc_start_wrapped_block (&try_block, fnbody);\n+\n   /* Deal with implicit return variables.  Explicit return variables will\n      already have been added.  */\n   if (gfc_return_by_reference (proc_sym) && proc_sym->result == proc_sym)\n@@ -3125,19 +3122,17 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n       else if (proc_sym->as)\n \t{\n \t  tree result = TREE_VALUE (current_fake_result_decl);\n-\t  fnbody = gfc_trans_dummy_array_bias (proc_sym, result, fnbody);\n+\t  gfc_trans_dummy_array_bias (proc_sym, result, &try_block);\n \n \t  /* An automatic character length, pointer array result.  */\n \t  if (proc_sym->ts.type == BT_CHARACTER\n \t\t&& TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n-\t    fnbody = gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl,\n-\t\t\t\t\t\tfnbody);\n+\t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, &try_block);\n \t}\n       else if (proc_sym->ts.type == BT_CHARACTER)\n \t{\n \t  if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n-\t    fnbody = gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl,\n-\t\t\t\t\t\tfnbody);\n+\t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, &try_block);\n \t}\n       else\n \tgcc_assert (gfc_option.flag_f2c\n@@ -3147,7 +3142,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n   /* Initialize the INTENT(OUT) derived type dummy arguments.  This\n      should be done here so that the offsets and lbounds of arrays\n      are available.  */\n-  fnbody = init_intent_out_dt (proc_sym, fnbody);\n+  init_intent_out_dt (proc_sym, &try_block);\n \n   for (sym = proc_sym->tlink; sym != proc_sym; sym = sym->tlink)\n     {\n@@ -3159,35 +3154,40 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t    {\n \t    case AS_EXPLICIT:\n \t      if (sym->attr.dummy || sym->attr.result)\n-\t\tfnbody =\n-\t\t  gfc_trans_dummy_array_bias (sym, sym->backend_decl, fnbody);\n+\t\tgfc_trans_dummy_array_bias (sym, sym->backend_decl, &try_block);\n \t      else if (sym->attr.pointer || sym->attr.allocatable)\n \t\t{\n \t\t  if (TREE_STATIC (sym->backend_decl))\n \t\t    gfc_trans_static_array_pointer (sym);\n \t\t  else\n \t\t    {\n \t\t      seen_trans_deferred_array = true;\n-\t\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t\t      gfc_trans_deferred_array (sym, &try_block);\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (sym_has_alloc_comp)\n \t\t    {\n \t\t      seen_trans_deferred_array = true;\n-\t\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t\t      gfc_trans_deferred_array (sym, &try_block);\n \t\t    }\n \t\t  else if (sym->ts.type == BT_DERIVED\n \t\t\t     && sym->value\n \t\t\t     && !sym->attr.data\n \t\t\t     && sym->attr.save == SAVE_NONE)\n-\t\t    fnbody = gfc_init_default_dt (sym, fnbody, false);\n+\t\t    {\n+\t\t      gfc_start_block (&tmpblock);\n+\t\t      gfc_init_default_dt (sym, &tmpblock, false);\n+\t\t      gfc_add_init_cleanup (&try_block,\n+\t\t\t\t\t    gfc_finish_block (&tmpblock),\n+\t\t\t\t\t    NULL_TREE);\n+\t\t    }\n \n \t\t  gfc_get_backend_locus (&loc);\n \t\t  gfc_set_backend_locus (&sym->declared_at);\n-\t\t  fnbody = gfc_trans_auto_array_allocation (sym->backend_decl,\n-\t\t      sym, fnbody);\n+\t\t  gfc_trans_auto_array_allocation (sym->backend_decl,\n+\t\t\t\t\t\t   sym, &try_block);\n \t\t  gfc_set_backend_locus (&loc);\n \t\t}\n \t      break;\n@@ -3198,27 +3198,26 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \n \t      /* We should always pass assumed size arrays the g77 way.  */\n \t      if (sym->attr.dummy)\n-\t\tfnbody = gfc_trans_g77_array (sym, fnbody);\n-              break;\n+\t\tgfc_trans_g77_array (sym, &try_block);\n+\t      break;\n \n \t    case AS_ASSUMED_SHAPE:\n \t      /* Must be a dummy parameter.  */\n \t      gcc_assert (sym->attr.dummy);\n \n-\t      fnbody = gfc_trans_dummy_array_bias (sym, sym->backend_decl,\n-\t\t\t\t\t\t   fnbody);\n+\t      gfc_trans_dummy_array_bias (sym, sym->backend_decl, &try_block);\n \t      break;\n \n \t    case AS_DEFERRED:\n \t      seen_trans_deferred_array = true;\n-\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t      gfc_trans_deferred_array (sym, &try_block);\n \t      break;\n \n \t    default:\n \t      gcc_unreachable ();\n \t    }\n \t  if (sym_has_alloc_comp && !seen_trans_deferred_array)\n-\t    fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t    gfc_trans_deferred_array (sym, &try_block);\n \t}\n       else if (sym->attr.allocatable\n \t       || (sym->ts.type == BT_CLASS\n@@ -3231,7 +3230,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t      tree tmp;\n \t      gfc_expr *e;\n \t      gfc_se se;\n-\t      stmtblock_t block;\n+\t      stmtblock_t init;\n \n \t      e = gfc_lval_expr_from_sym (sym);\n \t      if (sym->ts.type == BT_CLASS)\n@@ -3243,57 +3242,61 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t      gfc_free_expr (e);\n \n \t      /* Nullify when entering the scope.  */\n-\t      gfc_start_block (&block);\n-\t      gfc_add_modify (&block, se.expr,\n+\t      gfc_start_block (&init);\n+\t      gfc_add_modify (&init, se.expr,\n \t\t\t      fold_convert (TREE_TYPE (se.expr),\n \t\t\t\t\t    null_pointer_node));\n-\t      gfc_add_expr_to_block (&block, fnbody);\n \n \t      /* Deallocate when leaving the scope. Nullifying is not\n \t\t needed.  */\n \t      tmp = gfc_deallocate_with_status (se.expr, NULL_TREE, true,\n \t\t\t\t\t\tNULL);\n-\t      gfc_add_expr_to_block (&block, tmp);\n-\t      fnbody = gfc_finish_block (&block);\n+\n+\t      gfc_add_init_cleanup (&try_block, gfc_finish_block (&init), tmp);\n \t    }\n \t}\n       else if (sym_has_alloc_comp)\n-\tfnbody = gfc_trans_deferred_array (sym, fnbody);\n+\tgfc_trans_deferred_array (sym, &try_block);\n       else if (sym->ts.type == BT_CHARACTER)\n \t{\n \t  gfc_get_backend_locus (&loc);\n \t  gfc_set_backend_locus (&sym->declared_at);\n \t  if (sym->attr.dummy || sym->attr.result)\n-\t    fnbody = gfc_trans_dummy_character (sym, sym->ts.u.cl, fnbody);\n+\t    gfc_trans_dummy_character (sym, sym->ts.u.cl, &try_block);\n \t  else\n-\t    fnbody = gfc_trans_auto_character_variable (sym, fnbody);\n+\t    gfc_trans_auto_character_variable (sym, &try_block);\n \t  gfc_set_backend_locus (&loc);\n \t}\n       else if (sym->attr.assign)\n \t{\n \t  gfc_get_backend_locus (&loc);\n \t  gfc_set_backend_locus (&sym->declared_at);\n-\t  fnbody = gfc_trans_assign_aux_var (sym, fnbody);\n+\t  gfc_trans_assign_aux_var (sym, &try_block);\n \t  gfc_set_backend_locus (&loc);\n \t}\n       else if (sym->ts.type == BT_DERIVED\n \t\t && sym->value\n \t\t && !sym->attr.data\n \t\t && sym->attr.save == SAVE_NONE)\n-\tfnbody = gfc_init_default_dt (sym, fnbody, false);\n+\t{\n+\t  gfc_start_block (&tmpblock);\n+\t  gfc_init_default_dt (sym, &tmpblock, false);\n+\t  gfc_add_init_cleanup (&try_block, gfc_finish_block (&tmpblock),\n+\t\t\t\tNULL_TREE);\n+\t}\n       else\n \tgcc_unreachable ();\n     }\n \n-  gfc_init_block (&body);\n+  gfc_init_block (&tmpblock);\n \n   for (f = proc_sym->formal; f; f = f->next)\n     {\n       if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER)\n \t{\n \t  gcc_assert (f->sym->ts.u.cl->backend_decl != NULL);\n \t  if (TREE_CODE (f->sym->ts.u.cl->backend_decl) == PARM_DECL)\n-\t    gfc_trans_vla_type_sizes (f->sym, &body);\n+\t    gfc_trans_vla_type_sizes (f->sym, &tmpblock);\n \t}\n     }\n \n@@ -3302,11 +3305,12 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n     {\n       gcc_assert (proc_sym->ts.u.cl->backend_decl != NULL);\n       if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == PARM_DECL)\n-\tgfc_trans_vla_type_sizes (proc_sym, &body);\n+\tgfc_trans_vla_type_sizes (proc_sym, &tmpblock);\n     }\n \n-  gfc_add_expr_to_block (&body, fnbody);\n-  return gfc_finish_block (&body);\n+  gfc_add_init_cleanup (&try_block, gfc_finish_block (&tmpblock), NULL_TREE);\n+\n+  return gfc_finish_wrapped_block (&try_block);\n }\n \n static GTY ((param_is (struct module_htab_entry))) htab_t module_htab;"}, {"sha": "4b20b962fba26585fd361942ff0e8f41647ddb17", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 81, "deletions": 13, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=0019d49828d868ffec69eba1ea65e659a1aed0bf", "patch": "@@ -977,31 +977,47 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n   return res;\n }\n \n-/* Add a statement to a block.  */\n \n-void\n-gfc_add_expr_to_block (stmtblock_t * block, tree expr)\n-{\n-  gcc_assert (block);\n+/* Add an expression to another one, either at the front or the back.  */\n \n+static void\n+add_expr_to_chain (tree* chain, tree expr, bool front)\n+{\n   if (expr == NULL_TREE || IS_EMPTY_STMT (expr))\n     return;\n \n-  if (block->head)\n+  if (*chain)\n     {\n-      if (TREE_CODE (block->head) != STATEMENT_LIST)\n+      if (TREE_CODE (*chain) != STATEMENT_LIST)\n \t{\n \t  tree tmp;\n \n-\t  tmp = block->head;\n-\t  block->head = NULL_TREE;\n-\t  append_to_statement_list (tmp, &block->head);\n+\t  tmp = *chain;\n+\t  *chain = NULL_TREE;\n+\t  append_to_statement_list (tmp, chain);\n \t}\n-      append_to_statement_list (expr, &block->head);\n+\n+      if (front)\n+\t{\n+\t  tree_stmt_iterator i;\n+\n+\t  i = tsi_start (*chain);\n+\t  tsi_link_before (&i, expr, TSI_CONTINUE_LINKING);\n+\t}\n+      else\n+\tappend_to_statement_list (expr, chain);\n     }\n   else\n-    /* Don't bother creating a list if we only have a single statement.  */\n-    block->head = expr;\n+    *chain = expr;\n+}\n+\n+/* Add a statement to a block.  */\n+\n+void\n+gfc_add_expr_to_block (stmtblock_t * block, tree expr)\n+{\n+  gcc_assert (block);\n+  add_expr_to_chain (&block->head, expr, false);\n }\n \n \n@@ -1393,3 +1409,55 @@ gfc_generate_module_code (gfc_namespace * ns)\n     }\n }\n \n+\n+/* Initialize an init/cleanup block with existing code.  */\n+\n+void\n+gfc_start_wrapped_block (gfc_wrapped_block* block, tree code)\n+{\n+  gcc_assert (block);\n+\n+  block->init = NULL_TREE;\n+  block->code = code;\n+  block->cleanup = NULL_TREE;\n+}\n+\n+\n+/* Add a new pair of initializers/clean-up code.  */\n+\n+void\n+gfc_add_init_cleanup (gfc_wrapped_block* block, tree init, tree cleanup)\n+{\n+  gcc_assert (block);\n+\n+  /* The new pair of init/cleanup should be \"wrapped around\" the existing\n+     block of code, thus the initialization is added to the front and the\n+     cleanup to the back.  */\n+  add_expr_to_chain (&block->init, init, true);\n+  add_expr_to_chain (&block->cleanup, cleanup, false);\n+}\n+\n+\n+/* Finish up a wrapped block by building a corresponding try-finally expr.  */\n+\n+tree\n+gfc_finish_wrapped_block (gfc_wrapped_block* block)\n+{\n+  tree result;\n+\n+  gcc_assert (block);\n+\n+  /* Build the final expression.  For this, just add init and body together,\n+     and put clean-up with that into a TRY_FINALLY_EXPR.  */\n+  result = block->init;\n+  add_expr_to_chain (&result, block->code, false);\n+  if (block->cleanup)\n+    result = build2 (TRY_FINALLY_EXPR, void_type_node, result, block->cleanup);\n+  \n+  /* Clear the block.  */\n+  block->init = NULL_TREE;\n+  block->code = NULL_TREE;\n+  block->cleanup = NULL_TREE;\n+\n+  return result;\n+}"}, {"sha": "5147852b1893754ae21280fe827f109abff2643e", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0019d49828d868ffec69eba1ea65e659a1aed0bf/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0019d49828d868ffec69eba1ea65e659a1aed0bf", "patch": "@@ -258,6 +258,29 @@ typedef struct\n gfc_saved_var;\n \n \n+/* Store information about a block of code together with special\n+   initialization and clean-up code.  This can be used to incrementally add\n+   init and cleanup, and in the end put everything together to a\n+   try-finally expression.  */\n+typedef struct\n+{\n+  tree init;\n+  tree cleanup;\n+  tree code;\n+}\n+gfc_wrapped_block;\n+\n+\n+/* Initialize an init/cleanup block.  */\n+void gfc_start_wrapped_block (gfc_wrapped_block* block, tree code);\n+/* Add a pair of init/cleanup code to the block.  Each one might be a\n+   NULL_TREE if not required.  */\n+void gfc_add_init_cleanup (gfc_wrapped_block* block, tree init, tree cleanup);\n+/* Finalize the block, that is, create a single expression encapsulating the\n+   original code together with init and clean-up code.  */\n+tree gfc_finish_wrapped_block (gfc_wrapped_block* block);\n+\n+\n /* Advance the SS chain to the next term.  */\n void gfc_advance_se_ss_chain (gfc_se *);\n \n@@ -403,7 +426,7 @@ tree gfc_get_symbol_decl (gfc_symbol *);\n tree gfc_conv_initializer (gfc_expr *, gfc_typespec *, tree, bool, bool);\n \n /* Assign a default initializer to a derived type.  */\n-tree gfc_init_default_dt (gfc_symbol *, tree, bool);\n+void gfc_init_default_dt (gfc_symbol *, stmtblock_t *, bool);\n \n /* Substitute a temporary variable in place of the real one.  */\n void gfc_shadow_sym (gfc_symbol *, tree, gfc_saved_var *);"}]}