{"sha": "9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEyNWNmOGMzM2I3MTBjMzc4YmZiM2M3ZTY3ZWMyZjlmMWM1MjNjOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-08-06T06:40:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-08-18T20:20:08Z"}, "message": "c++: Handle enumerator in C++20 alias CTAD. [PR96199]\n\nTo form a deduction guide for an alias template, we substitute the template\narguments from the pattern into the deduction guide for the underlying\nclass.  In the case of B(A1<X>), that produces B(A1<B<T,1>::X>) -> B<T,1>.\nBut since an enumerator doesn't have its own template info, and B<T,1> is a\ndependent scope, trying to look up B<T,1>::X fails and we crash.  So we need\nto produce a SCOPE_REF instead.\n\nAnd trying to use the members of the template class is wrong for other\nmembers, as well, as it gives a nonsensical result if the class is\nspecialized.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96199\n\t* pt.c (maybe_dependent_member_ref): New.\n\t(tsubst_copy) [CONST_DECL]: Use it.\n\t[VAR_DECL]: Likewise.\n\t(tsubst_aggr_type): Handle nested type.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96199\n\t* g++.dg/cpp2a/class-deduction-alias4.C: New test.", "tree": {"sha": "5204a73a439256bc622a2d8ec0b53d2d4e7ea36f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5204a73a439256bc622a2d8ec0b53d2d4e7ea36f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c04bd60e56da399a441f73ebb687b5039b9cf3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c04bd60e56da399a441f73ebb687b5039b9cf3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c04bd60e56da399a441f73ebb687b5039b9cf3f"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "585d944542b6108f6424170ffd4821839e90b177", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9", "patch": "@@ -13391,6 +13391,17 @@ tsubst_aggr_type (tree t,\n \t\t\t\t\t complain, in_decl);\n \t  if (argvec == error_mark_node)\n \t    r = error_mark_node;\n+\t  else if (cxx_dialect >= cxx20 && dependent_scope_p (context))\n+\t    {\n+\t      /* See maybe_dependent_member_ref.  */\n+\t      tree name = TYPE_IDENTIFIER (t);\n+\t      tree fullname = name;\n+\t      if (instantiates_primary_template_p (t))\n+\t\tfullname = build_nt (TEMPLATE_ID_EXPR, name,\n+\t\t\t\t     INNERMOST_TEMPLATE_ARGS (argvec));\n+\t      return build_typename_type (context, name, fullname,\n+\t\t\t\t\t  typename_type);\n+\t    }\n \t  else\n \t    {\n \t      r = lookup_template_class (t, argvec, in_decl, context,\n@@ -16313,6 +16324,32 @@ tsubst_init (tree init, tree decl, tree args,\n   return init;\n }\n \n+/* If T is a reference to a dependent member of the current instantiation C and\n+   we are trying to refer to that member in a partial instantiation of C,\n+   return a SCOPE_REF; otherwise, return NULL_TREE.\n+\n+   This can happen when forming a C++20 alias template deduction guide, as in\n+   PR96199.  */\n+\n+static tree\n+maybe_dependent_member_ref (tree t, tree args, tsubst_flags_t complain,\n+\t\t\t    tree in_decl)\n+{\n+  if (cxx_dialect < cxx20)\n+    return NULL_TREE;\n+\n+  tree ctx = context_for_name_lookup (t);\n+  if (!CLASS_TYPE_P (ctx))\n+    return NULL_TREE;\n+\n+  ctx = tsubst (ctx, args, complain, in_decl);\n+  if (dependent_scope_p (ctx))\n+    return build_qualified_name (NULL_TREE, ctx, DECL_NAME (t),\n+\t\t\t\t /*template_p=*/false);\n+\n+  return NULL_TREE;\n+}\n+\n /* Like tsubst, but deals with expressions.  This function just replaces\n    template parms; to finish processing the resultant expression, use\n    tsubst_copy_and_build or tsubst_expr.  */\n@@ -16371,6 +16408,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (args == NULL_TREE)\n \t  return scalar_constant_value (t);\n \n+\tif (tree ref = maybe_dependent_member_ref (t, args, complain, in_decl))\n+\t  return ref;\n+\n \t/* Unfortunately, we cannot just call lookup_name here.\n \t   Consider:\n \n@@ -16421,6 +16461,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       return t;\n \n     case VAR_DECL:\n+      if (tree ref = maybe_dependent_member_ref (t, args, complain, in_decl))\n+\treturn ref;\n+      gcc_fallthrough();\n     case FUNCTION_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n \tr = tsubst (t, args, complain, in_decl);"}, {"sha": "f2c3ffda85a68d2f76f1af4e4c670c072f97b801", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-alias4.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias4.C?ref=9125cf8c33b710c378bfb3c7e67ec2f9f1c523c9", "patch": "@@ -0,0 +1,44 @@\n+// PR c++/96199\n+// { dg-do compile { target c++2a } }\n+\n+template<int> struct A1 { };\n+template<int&> struct A2 { };\n+template<class> struct A3 { };\n+\n+int i;\n+template<typename V, int> struct B {\n+  enum E { X };\n+  B(A1<X>, V) { }\n+\n+  constexpr static V& ir = i;\n+  B(A2<ir>, V) { }\n+\n+  B(A3<E>, V);\n+};\n+\n+// template<class T, int I> B(A1<B<T,I>::X>,T) -> B<T,I>;\n+// template<class T, int I> B(A2<B<T,I>::ir>,T) -> B<T,I>;\n+// template<class T, int I> B(A3<typename B<T,I>::E>,T) -> B<T,I>;\n+\n+template <typename T> using U = B<T, 1>;\n+\n+// template<class T> B(A1<B<T,1>::X>,T) -> B<T,1>;\n+// template<class T> B(A2<B<T,1>::ir>,T) -> B<T,1>;\n+// template<class T> B(A3<typename B<T,1>::E>,T) -> B<T,1>;\n+\n+int j;\n+template <> struct B<int, 1> {\n+  using V = int;\n+\n+  enum E { X = 1 };\n+  B(A1<X>, V) { }\n+\n+  constexpr static V& ir = j;\n+  B(A2<ir>, V) { }\n+\n+  B(A3<E>, V);\n+};\n+\n+U u1 { A1<1>(), 42 };\n+U u2 { A2<j>(), 42 };\n+U u3 { A3<U<int>::E>(), 42 };"}]}