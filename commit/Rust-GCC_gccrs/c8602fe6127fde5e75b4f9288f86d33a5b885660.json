{"sha": "c8602fe6127fde5e75b4f9288f86d33a5b885660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg2MDJmZTYxMjdmZGU1ZTc1YjRmOTI4OGY4NmQzM2E1Yjg4NTY2MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-02-21T10:35:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-02-21T10:35:46Z"}, "message": "re PR tree-optimization/84478 (pdftex miscompilation on i386)\n\n\tPR tree-optimization/84478\n\t* gimple-fold.h (get_range_strlen): Add a bool argument defaulted to\n\tfalse.\n\t* gimple-fold.c (get_range_strlen): Make minlen const and assume it\n\tcan't be NULL.  Change FUZZY from bool to int, for 1 add PHI/COND_EXPR\n\tsupport which is conservatively correct, for 2 only stay conservative\n\tfor maxlen.  Formatting and comment capitalization fixes.  Add STRICT\n\targument to the 2 argument get_range_strlen, adjust 6 arg\n\tget_range_strlen caller and clear minmaxlen[0] and [1] if it returned\n\tfalse.\n\t(get_maxval_strlen): Adjust 6 arg get_range_strlen caller.\n\t(gimple_fold_builtin_strlen): Pass true as last argument to\n\tget_range_strlen.\n\n\t* gcc.c-torture/execute/pr84478.c: New test.\n\nCo-Authored-By: Martin Sebor <msebor@redhat.com>\n\nFrom-SVN: r257870", "tree": {"sha": "f3981f123f3057a2fd6c9ed37212047a644e425f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3981f123f3057a2fd6c9ed37212047a644e425f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8602fe6127fde5e75b4f9288f86d33a5b885660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8602fe6127fde5e75b4f9288f86d33a5b885660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8602fe6127fde5e75b4f9288f86d33a5b885660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8602fe6127fde5e75b4f9288f86d33a5b885660/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b22dbd03f06c5d3b5e71ae99b55b5d7d21a11cd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b22dbd03f06c5d3b5e71ae99b55b5d7d21a11cd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b22dbd03f06c5d3b5e71ae99b55b5d7d21a11cd9"}], "stats": {"total": 152, "additions": 120, "deletions": 32}, "files": [{"sha": "a07661b5d4a59c7146de9bb64c193e61d27ee5b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8602fe6127fde5e75b4f9288f86d33a5b885660", "patch": "@@ -1,3 +1,20 @@\n+2018-02-21  Jakub Jelinek  <jakub@redhat.com>\n+\t    Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/84478\n+\t* gimple-fold.h (get_range_strlen): Add a bool argument defaulted to\n+\tfalse.\n+\t* gimple-fold.c (get_range_strlen): Make minlen const and assume it\n+\tcan't be NULL.  Change FUZZY from bool to int, for 1 add PHI/COND_EXPR\n+\tsupport which is conservatively correct, for 2 only stay conservative\n+\tfor maxlen.  Formatting and comment capitalization fixes.  Add STRICT\n+\targument to the 2 argument get_range_strlen, adjust 6 arg\n+\tget_range_strlen caller and clear minmaxlen[0] and [1] if it returned\n+\tfalse.\n+\t(get_maxval_strlen): Adjust 6 arg get_range_strlen caller.\n+\t(gimple_fold_builtin_strlen): Pass true as last argument to\n+\tget_range_strlen.\n+\n 2018-02-20  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/84095"}, {"sha": "0b7553160b53036b119ffbaa6beb974d99e1eee6", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c8602fe6127fde5e75b4f9288f86d33a5b885660", "patch": "@@ -1283,28 +1283,30 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n    value of ARG in LENGTH[0] and LENGTH[1], respectively.\n    If ARG is an SSA name variable, follow its use-def chains.  When\n    TYPE == 0, if LENGTH[1] is not equal to the length we determine or\n-   if we are unable to determine the length or value, return False.\n+   if we are unable to determine the length or value, return false.\n    VISITED is a bitmap of visited variables.\n    TYPE is 0 if string length should be obtained, 1 for maximum string\n    length and 2 for maximum value ARG can have.\n-   When FUZZY is set and the length of a string cannot be determined,\n+   When FUZZY is non-zero and the length of a string cannot be determined,\n    the function instead considers as the maximum possible length the\n-   size of a character array it may refer to.\n+   size of a character array it may refer to.  If FUZZY is 2, it will handle\n+   PHIs and COND_EXPRs optimistically, if we can determine string length\n+   minimum and maximum, it will use the minimum from the ones where it\n+   can be determined.\n    Set *FLEXP to true if the range of the string lengths has been\n    obtained from the upper bound of an array at the end of a struct.\n    Such an array may hold a string that's longer than its upper bound\n    due to it being used as a poor-man's flexible array member.  */\n \n static bool\n get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n-\t\t  bool fuzzy, bool *flexp)\n+\t\t  int fuzzy, bool *flexp)\n {\n   tree var, val = NULL_TREE;\n   gimple *def_stmt;\n \n-  /* The minimum and maximum length.  The MAXLEN pointer stays unchanged\n-     but MINLEN may be cleared during the execution of the function.  */\n-  tree *minlen = length;\n+  /* The minimum and maximum length.  */\n+  tree *const minlen = length;\n   tree *const maxlen = length + 1;\n \n   if (TREE_CODE (arg) != SSA_NAME)\n@@ -1445,12 +1447,11 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n       if (!val)\n \treturn false;\n \n-      if (minlen\n-\t  && (!*minlen\n-\t      || (type > 0\n-\t\t  && TREE_CODE (*minlen) == INTEGER_CST\n-\t\t  && TREE_CODE (val) == INTEGER_CST\n-\t\t  && tree_int_cst_lt (val, *minlen))))\n+      if (!*minlen\n+\t  || (type > 0\n+\t      && TREE_CODE (*minlen) == INTEGER_CST\n+\t      && TREE_CODE (val) == INTEGER_CST\n+\t      && tree_int_cst_lt (val, *minlen)))\n \t*minlen = val;\n \n       if (*maxlen)\n@@ -1501,20 +1502,26 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n \t  {\n-\t    tree op2 = gimple_assign_rhs2 (def_stmt);\n-\t    tree op3 = gimple_assign_rhs3 (def_stmt);\n-\t    return get_range_strlen (op2, length, visited, type, fuzzy, flexp)\n-\t      && get_range_strlen (op3, length, visited, type, fuzzy, flexp);\n+\t    tree ops[2] = { gimple_assign_rhs2 (def_stmt),\n+\t\t\t    gimple_assign_rhs3 (def_stmt) };\n+\n+\t    for (unsigned int i = 0; i < 2; i++)\n+\t      if (!get_range_strlen (ops[i], length, visited, type, fuzzy,\n+\t\t\t\t     flexp))\n+\t\t{\n+\t\t  if (fuzzy == 2)\n+\t\t    *maxlen = build_all_ones_cst (size_type_node);\n+\t\t  else\n+\t\t    return false;\n+\t\t}\n+\t    return true;\n \t  }\n         return false;\n \n       case GIMPLE_PHI:\n-\t{\n-\t  /* All the arguments of the PHI node must have the same constant\n-\t     length.  */\n-\t  unsigned i;\n-\n-\t  for (i = 0; i < gimple_phi_num_args (def_stmt); i++)\n+\t/* All the arguments of the PHI node must have the same constant\n+\t   length.  */\n+\tfor (unsigned i = 0; i < gimple_phi_num_args (def_stmt); i++)\n           {\n             tree arg = gimple_phi_arg (def_stmt, i)->def;\n \n@@ -1529,13 +1536,12 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \n \t    if (!get_range_strlen (arg, length, visited, type, fuzzy, flexp))\n \t      {\n-\t\tif (fuzzy)\n+\t\tif (fuzzy == 2)\n \t\t  *maxlen = build_all_ones_cst (size_type_node);\n \t\telse\n \t\t  return false;\n \t      }\n           }\n-        }\n         return true;\n \n       default:\n@@ -1549,23 +1555,34 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n    character arrays, use the upper bound of the array as the maximum\n    length.  For example, given an expression like 'x ? array : \"xyz\"'\n    and array declared as 'char array[8]', MINMAXLEN[0] will be set\n-   to 3 and MINMAXLEN[1] to 7, the longest string that could be\n+   to 0 and MINMAXLEN[1] to 7, the longest string that could be\n    stored in array.\n    Return true if the range of the string lengths has been obtained\n    from the upper bound of an array at the end of a struct.  Such\n    an array may hold a string that's longer than its upper bound\n-   due to it being used as a poor-man's flexible array member.  */\n+   due to it being used as a poor-man's flexible array member.\n+\n+   STRICT is true if it will handle PHIs and COND_EXPRs conservatively\n+   and false if PHIs and COND_EXPRs are to be handled optimistically,\n+   if we can determine string length minimum and maximum; it will use\n+   the minimum from the ones where it can be determined.\n+   STRICT false should be only used for warning code.  */\n \n bool\n-get_range_strlen (tree arg, tree minmaxlen[2])\n+get_range_strlen (tree arg, tree minmaxlen[2], bool strict)\n {\n   bitmap visited = NULL;\n \n   minmaxlen[0] = NULL_TREE;\n   minmaxlen[1] = NULL_TREE;\n \n   bool flexarray = false;\n-  get_range_strlen (arg, minmaxlen, &visited, 1, true, &flexarray);\n+  if (!get_range_strlen (arg, minmaxlen, &visited, 1, strict ? 1 : 2,\n+\t\t\t &flexarray))\n+    {\n+      minmaxlen[0] = NULL_TREE;\n+      minmaxlen[1] = NULL_TREE;\n+    }\n \n   if (visited)\n     BITMAP_FREE (visited);\n@@ -1580,7 +1597,7 @@ get_maxval_strlen (tree arg, int type)\n   tree len[2] = { NULL_TREE, NULL_TREE };\n \n   bool dummy;\n-  if (!get_range_strlen (arg, len, &visited, type, false, &dummy))\n+  if (!get_range_strlen (arg, len, &visited, type, 0, &dummy))\n     len[1] = NULL_TREE;\n   if (visited)\n     BITMAP_FREE (visited);\n@@ -3534,7 +3551,7 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n   wide_int maxlen;\n \n   tree lenrange[2];\n-  if (!get_range_strlen (gimple_call_arg (stmt, 0), lenrange)\n+  if (!get_range_strlen (gimple_call_arg (stmt, 0), lenrange, true)\n       && lenrange[0] && TREE_CODE (lenrange[0]) == INTEGER_CST\n       && lenrange[1] && TREE_CODE (lenrange[1]) == INTEGER_CST)\n     {"}, {"sha": "d0c4044ef46348023b8d44a55e54708e0b095c99", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=c8602fe6127fde5e75b4f9288f86d33a5b885660", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n extern tree create_tmp_reg_or_ssa_name (tree, gimple *stmt = NULL);\n extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n-extern bool get_range_strlen (tree, tree[2]);\n+extern bool get_range_strlen (tree, tree[2], bool = false);\n extern tree get_maxval_strlen (tree, int);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);"}, {"sha": "073acf5e404b390b2718690385ab39b649c46060", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c8602fe6127fde5e75b4f9288f86d33a5b885660", "patch": "@@ -1,3 +1,8 @@\n+2018-02-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/84478\n+\t* gcc.c-torture/execute/pr84478.c: New test.\n+\n 2018-02-20  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/84095"}, {"sha": "6172b1acb0663e81008b07a1f4b303648ce0baa2", "filename": "gcc/testsuite/gcc.c-torture/execute/pr84478.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr84478.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8602fe6127fde5e75b4f9288f86d33a5b885660/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr84478.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr84478.c?ref=c8602fe6127fde5e75b4f9288f86d33a5b885660", "patch": "@@ -0,0 +1,49 @@\n+/* PR tree-optimization/84478 */\n+\n+long poolptr;\n+unsigned char *strpool;\n+static const char *poolfilearr[] = {\n+  \"mu\",\n+  \"\",\n+#define A \"x\",\n+#define B A \"xx\", A A \"xxx\", A A A A A\n+#define C B B B B B B B B B B\n+#define D C C C C C C C C C C\n+  D C C C C C C C B B B\n+ ((void *)0) \n+};\n+\n+__attribute__((noipa)) long\n+makestring (void)\n+{\n+  return 1;\n+}\n+\n+__attribute__((noipa)) long\n+loadpoolstrings (long spare_size)\n+{\n+  const char *s;\n+  long g = 0;\n+  int i = 0, j = 0;\n+  while ((s = poolfilearr[j++]))\n+    {\n+      int l = __builtin_strlen (s);\n+      i += l;\n+      if (i >= spare_size) return 0;\n+      while (l-- > 0) strpool[poolptr++] = *s++;\n+      g = makestring ();\n+    }\n+  return g;\n+}\n+\n+int\n+main ()\n+{\n+  strpool = __builtin_malloc (4000);\n+  if (!strpool)\n+    return 0;\n+  asm volatile (\"\" : : : \"memory\");\n+  volatile int r = loadpoolstrings (4000);\n+  __builtin_free (strpool);\n+  return 0;\n+}"}]}