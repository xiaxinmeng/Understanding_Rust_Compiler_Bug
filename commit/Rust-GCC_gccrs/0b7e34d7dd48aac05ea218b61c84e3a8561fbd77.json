{"sha": "0b7e34d7dd48aac05ea218b61c84e3a8561fbd77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI3ZTM0ZDdkZDQ4YWFjMDVlYTIxOGI2MWM4NGUzYTg1NjFmYmQ3Nw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-09-11T07:44:06Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-09-11T07:44:06Z"}, "message": "re PR debug/41276 (Segmentation fault in lookup_page_table_entry)\n\nPR debug/41276\nPR debug/41307\n* cselib.c (cselib_expand_value_rtx_cb): Document callback\ninterface.\n(cselib_expand_value_rtx_1): Use callback for SUBREGs.  Adjust\nfor VALUEs, to implement the documented interface.\n* var-tracking.c (vt_expand_loc_callback): Handle SUBREGs.\nAdjust for VALUEs and anything else, to implement the\ndocumented interface.\n\nFrom-SVN: r151628", "tree": {"sha": "7c4b3b077cdf1c1d929802c227b67ec378a3d383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c4b3b077cdf1c1d929802c227b67ec378a3d383"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77/comments", "author": null, "committer": null, "parents": [{"sha": "878f62e5bdb9b1adb8f234c36af5c39292c23713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878f62e5bdb9b1adb8f234c36af5c39292c23713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878f62e5bdb9b1adb8f234c36af5c39292c23713"}], "stats": {"total": 105, "additions": 80, "deletions": 25}, "files": [{"sha": "45188caa6e41a258bfac4b71a3dcd73692595b09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b7e34d7dd48aac05ea218b61c84e3a8561fbd77", "patch": "@@ -1,3 +1,15 @@\n+2009-09-11  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41276\n+\tPR debug/41307\n+\t* cselib.c (cselib_expand_value_rtx_cb): Document callback\n+\tinterface.\n+\t(cselib_expand_value_rtx_1): Use callback for SUBREGs.  Adjust\n+\tfor VALUEs, to implement the documented interface.\n+\t* var-tracking.c (vt_expand_loc_callback): Handle SUBREGs.\n+\tAdjust for VALUEs and anything else, to implement the\n+\tdocumented interface.\n+\n 2009-09-10  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/rs6000/rs6000.h (DATA_ALIGNMENT): Check that we are dealing"}, {"sha": "e6e5c143dad73502ce658dd6d2c1aa6cbcce9467", "filename": "gcc/cselib.c", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0b7e34d7dd48aac05ea218b61c84e3a8561fbd77", "patch": "@@ -1053,7 +1053,10 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n }\n \n /* Same as cselib_expand_value_rtx, but using a callback to try to\n-   resolve VALUEs that expand to nothing.  */\n+   resolve some expressions.  The CB function should return ORIG if it\n+   can't or does not want to deal with a certain RTX.  Any other\n+   return value, including NULL, will be used as the expansion for\n+   VALUE, without any further changes.  */\n \n rtx\n cselib_expand_value_rtx_cb (rtx orig, bitmap regs_active, int max_depth,\n@@ -1068,6 +1071,9 @@ cselib_expand_value_rtx_cb (rtx orig, bitmap regs_active, int max_depth,\n   return cselib_expand_value_rtx_1 (orig, &evd, max_depth);\n }\n \n+/* Internal implementation of cselib_expand_value_rtx and\n+   cselib_expand_value_rtx_cb.  */\n+\n static rtx\n cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n \t\t\t   int max_depth)\n@@ -1158,47 +1164,53 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n \n     case SUBREG:\n       {\n-\trtx subreg = cselib_expand_value_rtx_1 (SUBREG_REG (orig), evd,\n-\t\t\t\t\t\tmax_depth - 1);\n+\trtx subreg;\n+\n+\tif (evd->callback)\n+\t  {\n+\t    subreg = evd->callback (orig, evd->regs_active, max_depth,\n+\t\t\t\t    evd->callback_arg);\n+\t    if (subreg != orig)\n+\t      return subreg;\n+\t  }\n+\n+\tsubreg = cselib_expand_value_rtx_1 (SUBREG_REG (orig), evd,\n+\t\t\t\t\t    max_depth - 1);\n \tif (!subreg)\n \t  return NULL;\n \tscopy = simplify_gen_subreg (GET_MODE (orig), subreg,\n \t\t\t\t     GET_MODE (SUBREG_REG (orig)),\n \t\t\t\t     SUBREG_BYTE (orig));\n-\tif ((scopy == NULL\n-\t     || (GET_CODE (scopy) == SUBREG\n-\t\t && !REG_P (SUBREG_REG (scopy))\n-\t\t && !MEM_P (SUBREG_REG (scopy))))\n-\t    && (REG_P (SUBREG_REG (orig))\n-\t\t|| MEM_P (SUBREG_REG (orig))))\n-\t  return shallow_copy_rtx (orig);\n+\tif (scopy == NULL\n+\t    || (GET_CODE (scopy) == SUBREG\n+\t\t&& !REG_P (SUBREG_REG (scopy))\n+\t\t&& !MEM_P (SUBREG_REG (scopy))))\n+\t  return NULL;\n+\n \treturn scopy;\n       }\n \n     case VALUE:\n       {\n \trtx result;\n+\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n \t  {\n \t    fputs (\"\\nexpanding \", dump_file);\n \t    print_rtl_single (dump_file, orig);\n \t    fputs (\" into...\", dump_file);\n \t  }\n \n-\tif (!evd->callback)\n-\t  result = NULL;\n-\telse\n+\tif (evd->callback)\n \t  {\n \t    result = evd->callback (orig, evd->regs_active, max_depth,\n \t\t\t\t    evd->callback_arg);\n-\t    if (result == orig)\n-\t      result = NULL;\n-\t    else if (result)\n-\t      result = cselib_expand_value_rtx_1 (result, evd, max_depth);\n+\n+\t    if (result != orig)\n+\t      return result;\n \t  }\n \n-\tif (!result)\n-\t  result = expand_loc (CSELIB_VAL_PTR (orig)->locs, evd, max_depth);\n+\tresult = expand_loc (CSELIB_VAL_PTR (orig)->locs, evd, max_depth);\n \treturn result;\n       }\n     default:"}, {"sha": "0e665b91bed10959602f9346f65cec5e7f8e9c28", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7e34d7dd48aac05ea218b61c84e3a8561fbd77/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0b7e34d7dd48aac05ea218b61c84e3a8561fbd77", "patch": "@@ -6243,7 +6243,8 @@ check_wrap_constant (enum machine_mode mode, rtx result)\n }\n \n /* Callback for cselib_expand_value, that looks for expressions\n-   holding the value in the var-tracking hash tables.  */\n+   holding the value in the var-tracking hash tables.  Return X for\n+   standard processing, anything else is to be used as-is.  */\n \n static rtx\n vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n@@ -6254,19 +6255,46 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n   location_chain loc;\n   rtx result;\n \n-  gcc_assert (GET_CODE (x) == VALUE);\n+  if (GET_CODE (x) == SUBREG)\n+    {\n+      rtx subreg = SUBREG_REG (x);\n+\n+      if (GET_CODE (SUBREG_REG (x)) != VALUE)\n+\treturn x;\n+\n+      subreg = cselib_expand_value_rtx_cb (SUBREG_REG (x), regs,\n+\t\t\t\t\t   max_depth - 1,\n+\t\t\t\t\t   vt_expand_loc_callback, data);\n+\n+      if (!subreg)\n+\treturn NULL;\n+\n+      result = simplify_gen_subreg (GET_MODE (x), subreg,\n+\t\t\t\t    GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t    SUBREG_BYTE (x));\n+\n+      /* Invalid SUBREGs are ok in debug info.  ??? We could try\n+\t alternate expansions for the VALUE as well.  */\n+      if (!result && (REG_P (subreg) || MEM_P (subreg)))\n+\tresult = gen_rtx_raw_SUBREG (GET_MODE (x), subreg, SUBREG_BYTE (x));\n+\n+      return result;\n+    }\n+\n+  if (GET_CODE (x) != VALUE)\n+    return x;\n \n   if (VALUE_RECURSED_INTO (x))\n-    return NULL;\n+    return x;\n \n   dv = dv_from_value (x);\n   var = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n \n   if (!var)\n-    return NULL;\n+    return x;\n \n   if (var->n_var_parts == 0)\n-    return NULL;\n+    return x;\n \n   gcc_assert (var->n_var_parts == 1);\n \n@@ -6283,7 +6311,10 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n     }\n \n   VALUE_RECURSED_INTO (x) = false;\n-  return result;\n+  if (result)\n+    return result;\n+  else\n+    return x;\n }\n \n /* Expand VALUEs in LOC, using VARS as well as cselib's equivalence"}]}