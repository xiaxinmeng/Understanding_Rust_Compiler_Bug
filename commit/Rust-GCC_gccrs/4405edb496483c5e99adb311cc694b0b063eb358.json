{"sha": "4405edb496483c5e99adb311cc694b0b063eb358", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQwNWVkYjQ5NjQ4M2M1ZTk5YWRiMzExY2M2OTRiMGIwNjNlYjM1OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-20T08:39:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-20T12:06:58Z"}, "message": "Deal with (pattern) SLP consumed stmts in hybrid discovery\n\nThis makes hybrid SLP discovery deal with stmts indirectly consumed\nby SLP, for example via patterns.  This means that all uses of a\nstmt end up in SLP vectorized stmts.\n\nThis helps my prototype patches for PR97832 where I make SLP discovery\nre-associate chains to make operands match.  This ends up building\nSLP computation nodes without 1:1 representatives in the scalar IL\nand thus no scalar lane defs in SLP_TREE_SCALAR_STMTS.  Nevertheless\nall of the original scalar stmts are consumed so this represents\nanother kind of SLP pattern for the computation chain result.\n\n2020-11-20  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (maybe_push_to_hybrid_worklist): New function.\n\t(vect_detect_hybrid_slp): Use it.  Perform a backward walk\n\tover the IL.", "tree": {"sha": "886058ca1630403c1172fe975613741062776d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/886058ca1630403c1172fe975613741062776d1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4405edb496483c5e99adb311cc694b0b063eb358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4405edb496483c5e99adb311cc694b0b063eb358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4405edb496483c5e99adb311cc694b0b063eb358", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4405edb496483c5e99adb311cc694b0b063eb358/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e820b943bce54002f9343c2e39529d792291388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e820b943bce54002f9343c2e39529d792291388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e820b943bce54002f9343c2e39529d792291388"}], "stats": {"total": 79, "additions": 72, "deletions": 7}, "files": [{"sha": "37356850ca47a17f0af9c1ec373814b88f958933", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4405edb496483c5e99adb311cc694b0b063eb358/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4405edb496483c5e99adb311cc694b0b063eb358/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4405edb496483c5e99adb311cc694b0b063eb358", "patch": "@@ -3169,6 +3169,63 @@ vect_detect_hybrid_slp (tree *tp, int *, void *data)\n   return NULL_TREE;\n }\n \n+/* Look if STMT_INFO is consumed by SLP indirectly and mark it pure_slp\n+   if so, otherwise pushing it to WORKLIST.  */\n+\n+static void\n+maybe_push_to_hybrid_worklist (vec_info *vinfo,\n+\t\t\t       vec<stmt_vec_info> &worklist,\n+\t\t\t       stmt_vec_info stmt_info)\n+{\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Processing hybrid candidate : %G\", stmt_info->stmt);\n+  stmt_vec_info orig_info = vect_orig_stmt (stmt_info);\n+  imm_use_iterator iter2;\n+  ssa_op_iter iter1;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  bool any_def = false;\n+  FOR_EACH_PHI_OR_STMT_DEF (def_p, orig_info->stmt, iter1, SSA_OP_DEF)\n+    {\n+      any_def = true;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter2, DEF_FROM_PTR (def_p))\n+\t{\n+\t  stmt_vec_info use_info = vinfo->lookup_stmt (USE_STMT (use_p));\n+\t  /* An out-of loop use means this is a loop_vect sink.  */\n+\t  if (!use_info)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Found loop_vect sink: %G\", stmt_info->stmt);\n+\t      worklist.safe_push (stmt_info);\n+\t      return;\n+\t    }\n+\t  else if (!STMT_SLP_TYPE (vect_stmt_to_vectorize (use_info)))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Found loop_vect use: %G\", use_info->stmt);\n+\t      worklist.safe_push (stmt_info);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+  /* No def means this is a loo_vect sink.  */\n+  if (!any_def)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Found loop_vect sink: %G\", stmt_info->stmt);\n+      worklist.safe_push (stmt_info);\n+      return;\n+    }\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Marked SLP consumed stmt pure: %G\", stmt_info->stmt);\n+  STMT_SLP_TYPE (stmt_info) = pure_slp;\n+}\n+\n /* Find stmts that must be both vectorized and SLPed.  */\n \n void\n@@ -3178,9 +3235,14 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n \n   /* All stmts participating in SLP are marked pure_slp, all other\n      stmts are loop_vect.\n-     First collect all loop_vect stmts into a worklist.  */\n+     First collect all loop_vect stmts into a worklist.\n+     SLP patterns cause not all original scalar stmts to appear in\n+     SLP_TREE_SCALAR_STMTS and thus not all of them are marked pure_slp.\n+     Rectify this here and do a backward walk over the IL only considering\n+     stmts as loop_vect when they are used by a loop_vect stmt and otherwise\n+     mark them as pure_slp.  */\n   auto_vec<stmt_vec_info> worklist;\n-  for (unsigned i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)\n+  for (int i = LOOP_VINFO_LOOP (loop_vinfo)->num_nodes - 1; i >= 0; --i)\n     {\n       basic_block bb = LOOP_VINFO_BBS (loop_vinfo)[i];\n       for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n@@ -3189,10 +3251,11 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n \t  gphi *phi = gsi.phi ();\n \t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (phi);\n \t  if (!STMT_SLP_TYPE (stmt_info) && STMT_VINFO_RELEVANT (stmt_info))\n-\t    worklist.safe_push (stmt_info);\n+\t    maybe_push_to_hybrid_worklist (loop_vinfo,\n+\t\t\t\t\t   worklist, stmt_info);\n \t}\n-      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n-\t   gsi_next (&gsi))\n+      for (gimple_stmt_iterator gsi = gsi_last_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_prev (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n \t  if (is_gimple_debug (stmt))\n@@ -3208,12 +3271,14 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n \t\t    = loop_vinfo->lookup_stmt (gsi_stmt (gsi2));\n \t\t  if (!STMT_SLP_TYPE (patt_info)\n \t\t      && STMT_VINFO_RELEVANT (patt_info))\n-\t\t    worklist.safe_push (patt_info);\n+\t\t    maybe_push_to_hybrid_worklist (loop_vinfo,\n+\t\t\t\t\t\t   worklist, patt_info);\n \t\t}\n \t      stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n \t    }\n \t  if (!STMT_SLP_TYPE (stmt_info) && STMT_VINFO_RELEVANT (stmt_info))\n-\t    worklist.safe_push (stmt_info);\n+\t    maybe_push_to_hybrid_worklist (loop_vinfo,\n+\t\t\t\t\t   worklist, stmt_info);\n \t}\n     }\n "}]}