{"sha": "481445220b33cecb6978de0e3917980919f9d1f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgxNDQ1MjIwYjMzY2VjYjY5NzhkZTBlMzkxNzk4MDkxOWY5ZDFmMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-12-01T09:31:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-12-01T09:31:02Z"}, "message": "Improve error reporting from genattrtab.c\n\nThe errors reported by check_attr_value weren't very helpful because\nthey always used the location of the define(_enum)_attr, even if the\nerror was in a define_insn.  Also, the errors reported by\ncheck_attr_test didn't say which attribute was faulty.\n\nAlthough not technically a bug fix, it was really useful in writing\nthe patch for PR68432.\n\nTested on a variety of targets.\n\ngcc/\n\t* genattrtab.c (check_attr_test): Take an attr_desc instead of\n\tan is_const flag.  Put the file_location argument first.\n\tUpdate recursive calls.  Improve error messages.\n\t(check_attr_value): Take a file location and use it instead\n\tof attr->loc.  Improve error messages.  Update calls to\n\tcheck_attr_test.\n\t(check_defs): Update call to check_attr_value.\n\t(make_canonical): Likewise.\n\t(gen_attr): Likewise.\n\t(main): Likewise.\n\t(gen_insn_reserv): Update call to check_attr_test.\n\nFrom-SVN: r231103", "tree": {"sha": "3ebb050975be4f6dc3a15b36bc3ffa2aaf960f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ebb050975be4f6dc3a15b36bc3ffa2aaf960f09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/481445220b33cecb6978de0e3917980919f9d1f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481445220b33cecb6978de0e3917980919f9d1f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/481445220b33cecb6978de0e3917980919f9d1f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481445220b33cecb6978de0e3917980919f9d1f0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c178abcc58a87b2312bc526ceb37dd97939d7083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c178abcc58a87b2312bc526ceb37dd97939d7083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c178abcc58a87b2312bc526ceb37dd97939d7083"}], "stats": {"total": 156, "additions": 88, "deletions": 68}, "files": [{"sha": "4dd84c73e74cdd8b01afa6b4445b76c6bbaa674f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481445220b33cecb6978de0e3917980919f9d1f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481445220b33cecb6978de0e3917980919f9d1f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=481445220b33cecb6978de0e3917980919f9d1f0", "patch": "@@ -1,3 +1,17 @@\n+2015-12-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* genattrtab.c (check_attr_test): Take an attr_desc instead of\n+\tan is_const flag.  Put the file_location argument first.\n+\tUpdate recursive calls.  Improve error messages.\n+\t(check_attr_value): Take a file location and use it instead\n+\tof attr->loc.  Improve error messages.  Update calls to\n+\tcheck_attr_test.\n+\t(check_defs): Update call to check_attr_value.\n+\t(make_canonical): Likewise.\n+\t(gen_attr): Likewise.\n+\t(main): Likewise.\n+\t(gen_insn_reserv): Update call to check_attr_test.\n+\n 2015-12-01  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_builtin_reciprocal): Fix typo."}, {"sha": "2caf8f62567694291516e33fef45adb2c0280cf1", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 74, "deletions": 68, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481445220b33cecb6978de0e3917980919f9d1f0/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481445220b33cecb6978de0e3917980919f9d1f0/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=481445220b33cecb6978de0e3917980919f9d1f0", "patch": "@@ -729,9 +729,8 @@ attr_copy_rtx (rtx orig)\n   return copy;\n }\n \n-/* Given a test expression for an attribute, ensure it is validly formed.\n-   IS_CONST indicates whether the expression is constant for each compiler\n-   run (a constant expression may not test any particular insn).\n+/* Given a test expression EXP for attribute ATTR, ensure it is validly\n+   formed.  LOC is the location of the .md construct that contains EXP.\n \n    Convert (eq_attr \"att\" \"a1,a2\") to (ior (eq_attr ... ) (eq_attrq ..))\n    and (eq_attr \"att\" \"!a1\") to (not (eq_attr \"att\" \"a1\")).  Do the latter\n@@ -744,9 +743,8 @@ attr_copy_rtx (rtx orig)\n    Return the new expression, if any.  */\n \n static rtx\n-check_attr_test (rtx exp, int is_const, file_location loc)\n+check_attr_test (file_location loc, rtx exp, attr_desc *attr)\n {\n-  struct attr_desc *attr;\n   struct attr_value *av;\n   const char *name_ptr, *p;\n   rtx orexp, newexp;\n@@ -756,26 +754,27 @@ check_attr_test (rtx exp, int is_const, file_location loc)\n     case EQ_ATTR:\n       /* Handle negation test.  */\n       if (XSTR (exp, 1)[0] == '!')\n-\treturn check_attr_test (attr_rtx (NOT,\n+\treturn check_attr_test (loc,\n+\t\t\t\tattr_rtx (NOT,\n \t\t\t\t\t  attr_eq (XSTR (exp, 0),\n \t\t\t\t\t\t   &XSTR (exp, 1)[1])),\n-\t\t\t\tis_const, loc);\n+\t\t\t\tattr);\n \n       else if (n_comma_elts (XSTR (exp, 1)) == 1)\n \t{\n-\t  attr = find_attr (&XSTR (exp, 0), 0);\n-\t  if (attr == NULL)\n+\t  attr_desc *attr2 = find_attr (&XSTR (exp, 0), 0);\n+\t  if (attr2 == NULL)\n \t    {\n \t      if (! strcmp (XSTR (exp, 0), \"alternative\"))\n \t\treturn mk_attr_alt (((uint64_t) 1) << atoi (XSTR (exp, 1)));\n \t      else\n-\t\tfatal_at (loc, \"unknown attribute `%s' in EQ_ATTR\",\n-\t\t\t  XSTR (exp, 0));\n+\t\tfatal_at (loc, \"unknown attribute `%s' in definition of\"\n+\t\t\t  \" attribute `%s'\", XSTR (exp, 0), attr->name);\n \t    }\n \n-\t  if (is_const && ! attr->is_const)\n-\t    fatal_at (loc, \"constant expression uses insn attribute `%s'\"\n-\t\t      \" in EQ_ATTR\", XSTR (exp, 0));\n+\t  if (attr->is_const && ! attr2->is_const)\n+\t    fatal_at (loc, \"constant attribute `%s' cannot test non-constant\"\n+\t\t      \" attribute `%s'\", attr->name, attr2->name);\n \n \t  /* Copy this just to make it permanent,\n \t     so expressions using it can be permanent too.  */\n@@ -784,26 +783,26 @@ check_attr_test (rtx exp, int is_const, file_location loc)\n \t  /* It shouldn't be possible to simplify the value given to a\n \t     constant attribute, so don't expand this until it's time to\n \t     write the test expression.  */\n-\t  if (attr->is_const)\n+\t  if (attr2->is_const)\n \t    ATTR_IND_SIMPLIFIED_P (exp) = 1;\n \n-\t  if (attr->is_numeric)\n+\t  if (attr2->is_numeric)\n \t    {\n \t      for (p = XSTR (exp, 1); *p; p++)\n \t\tif (! ISDIGIT (*p))\n \t\t  fatal_at (loc, \"attribute `%s' takes only numeric values\",\n-\t\t\t    XSTR (exp, 0));\n+\t\t\t    attr2->name);\n \t    }\n \t  else\n \t    {\n-\t      for (av = attr->first_value; av; av = av->next)\n+\t      for (av = attr2->first_value; av; av = av->next)\n \t\tif (GET_CODE (av->value) == CONST_STRING\n \t\t    && ! strcmp (XSTR (exp, 1), XSTR (av->value, 0)))\n \t\t  break;\n \n \t      if (av == NULL)\n-\t\tfatal_at (loc, \"unknown value `%s' for `%s' attribute\",\n-\t\t\t  XSTR (exp, 1), XSTR (exp, 0));\n+\t\tfatal_at (loc, \"unknown value `%s' for attribute `%s'\",\n+\t\t\t  XSTR (exp, 1), attr2->name);\n \t    }\n \t}\n       else\n@@ -829,7 +828,7 @@ check_attr_test (rtx exp, int is_const, file_location loc)\n \t\t  orexp = insert_right_side (IOR, orexp, newexp, -2, -2);\n \t\t}\n \n-\t      return check_attr_test (orexp, is_const, loc);\n+\t      return check_attr_test (loc, orexp, attr);\n \t    }\n \t}\n       break;\n@@ -846,12 +845,12 @@ check_attr_test (rtx exp, int is_const, file_location loc)\n \n     case IOR:\n     case AND:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const, loc);\n-      XEXP (exp, 1) = check_attr_test (XEXP (exp, 1), is_const, loc);\n+      XEXP (exp, 0) = check_attr_test (loc, XEXP (exp, 0), attr);\n+      XEXP (exp, 1) = check_attr_test (loc, XEXP (exp, 1), attr);\n       break;\n \n     case NOT:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const, loc);\n+      XEXP (exp, 0) = check_attr_test (loc, XEXP (exp, 0), attr);\n       break;\n \n     case MATCH_TEST:\n@@ -860,9 +859,10 @@ check_attr_test (rtx exp, int is_const, file_location loc)\n       break;\n \n     case MATCH_OPERAND:\n-      if (is_const)\n-\tfatal_at (loc, \"RTL operator \\\"%s\\\" not valid in constant attribute\"\n-\t\t  \" test\", GET_RTX_NAME (GET_CODE (exp)));\n+      if (attr->is_const)\n+\tfatal_at (loc, \"invalid operator `%s' in definition of constant\"\n+\t\t  \" attribute `%s'\", GET_RTX_NAME (GET_CODE (exp)),\n+\t\t  attr->name);\n       /* These cases can't be simplified.  */\n       ATTR_IND_SIMPLIFIED_P (exp) = 1;\n       break;\n@@ -880,7 +880,7 @@ check_attr_test (rtx exp, int is_const, file_location loc)\n       break;\n \n     case SYMBOL_REF:\n-      if (is_const)\n+      if (attr->is_const)\n \t{\n \t  /* These cases are valid for constant attributes, but can't be\n \t     simplified.  */\n@@ -889,21 +889,21 @@ check_attr_test (rtx exp, int is_const, file_location loc)\n \t  break;\n \t}\n     default:\n-      fatal_at (loc, \"RTL operator \\\"%s\\\" not valid in attribute test\",\n-\t\tGET_RTX_NAME (GET_CODE (exp)));\n+      fatal_at (loc, \"invalid operator `%s' in definition of attribute\"\n+\t\t\" `%s'\", GET_RTX_NAME (GET_CODE (exp)), attr->name);\n     }\n \n   return exp;\n }\n \n-/* Given an expression, ensure that it is validly formed and that all named\n-   attribute values are valid for the given attribute.  Issue a fatal error\n-   if not.\n+/* Given an expression EXP, ensure that it is validly formed and that\n+   all named attribute values are valid for ATTR.  Issue an error if not.\n+   LOC is the location of the .md construct that contains EXP.\n \n    Return a perhaps modified replacement expression for the value.  */\n \n static rtx\n-check_attr_value (rtx exp, struct attr_desc *attr)\n+check_attr_value (file_location loc, rtx exp, struct attr_desc *attr)\n {\n   struct attr_value *av;\n   const char *p;\n@@ -914,16 +914,16 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n     case CONST_INT:\n       if (!attr->is_numeric)\n \t{\n-\t  error_at (attr->loc,\n-\t\t    \"CONST_INT not valid for non-numeric attribute %s\",\n+\t  error_at (loc,\n+\t\t    \"CONST_INT not valid for non-numeric attribute `%s'\",\n \t\t    attr->name);\n \t  break;\n \t}\n \n       if (INTVAL (exp) < 0)\n \t{\n-\t  error_at (attr->loc,\n-\t\t    \"negative numeric value specified for attribute %s\",\n+\t  error_at (loc,\n+\t\t    \"negative numeric value specified for attribute `%s'\",\n \t\t    attr->name);\n \t  break;\n \t}\n@@ -939,9 +939,9 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n \t  for (; *p; p++)\n \t    if (! ISDIGIT (*p))\n \t      {\n-\t\terror_at (attr->loc,\n-\t\t\t  \"non-numeric value for numeric attribute %s\",\n-\t\t\t  attr->name);\n+\t\terror_at (loc,\n+\t\t\t  \"non-numeric value specified for numeric\"\n+\t\t\t  \" attribute `%s'\", attr->name);\n \t\tbreak;\n \t      }\n \t  break;\n@@ -953,15 +953,14 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n \t  break;\n \n       if (av == NULL)\n-\terror_at (attr->loc, \"unknown value `%s' for `%s' attribute\",\n+\terror_at (loc, \"unknown value `%s' for attribute `%s'\",\n \t\t  XSTR (exp, 0), attr->name);\n       break;\n \n     case IF_THEN_ELSE:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), attr->is_const,\n-\t\t\t\t       attr->loc);\n-      XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n-      XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n+      XEXP (exp, 0) = check_attr_test (loc, XEXP (exp, 0), attr);\n+      XEXP (exp, 1) = check_attr_value (loc, XEXP (exp, 1), attr);\n+      XEXP (exp, 2) = check_attr_value (loc, XEXP (exp, 2), attr);\n       break;\n \n     case PLUS:\n@@ -971,16 +970,17 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n     case MOD:\n       if (!attr->is_numeric)\n \t{\n-\t  error_at (attr->loc, \"invalid operation `%s' for non-numeric\"\n-\t\t    \" attribute value\", GET_RTX_NAME (GET_CODE (exp)));\n+\t  error_at (loc, \"invalid operation `%s' for non-numeric\"\n+\t\t    \" attribute `%s'\", GET_RTX_NAME (GET_CODE (exp)),\n+\t\t    attr->name);\n \t  break;\n \t}\n       /* Fall through.  */\n \n     case IOR:\n     case AND:\n-      XEXP (exp, 0) = check_attr_value (XEXP (exp, 0), attr);\n-      XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n+      XEXP (exp, 0) = check_attr_value (loc, XEXP (exp, 0), attr);\n+      XEXP (exp, 1) = check_attr_value (loc, XEXP (exp, 1), attr);\n       break;\n \n     case FFS:\n@@ -989,41 +989,42 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n     case POPCOUNT:\n     case PARITY:\n     case BSWAP:\n-      XEXP (exp, 0) = check_attr_value (XEXP (exp, 0), attr);\n+      XEXP (exp, 0) = check_attr_value (loc, XEXP (exp, 0), attr);\n       break;\n \n     case COND:\n       if (XVECLEN (exp, 0) % 2 != 0)\n \t{\n-\t  error_at (attr->loc, \"first operand of COND must have even length\");\n+\t  error_at (loc, \"first operand of COND must have even length\");\n \t  break;\n \t}\n \n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n \t{\n-\t  XVECEXP (exp, 0, i) = check_attr_test (XVECEXP (exp, 0, i),\n-\t\t\t\t\t\t attr->is_const, attr->loc);\n+\t  XVECEXP (exp, 0, i) = check_attr_test (attr->loc,\n+\t\t\t\t\t\t XVECEXP (exp, 0, i),\n+\t\t\t\t\t\t attr);\n \t  XVECEXP (exp, 0, i + 1)\n-\t    = check_attr_value (XVECEXP (exp, 0, i + 1), attr);\n+\t    = check_attr_value (loc, XVECEXP (exp, 0, i + 1), attr);\n \t}\n \n-      XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n+      XEXP (exp, 1) = check_attr_value (loc, XEXP (exp, 1), attr);\n       break;\n \n     case ATTR:\n       {\n \tstruct attr_desc *attr2 = find_attr (&XSTR (exp, 0), 0);\n \tif (attr2 == NULL)\n-\t  error_at (attr->loc, \"unknown attribute `%s' in ATTR\",\n+\t  error_at (loc, \"unknown attribute `%s' in ATTR\",\n \t\t    XSTR (exp, 0));\n \telse if (attr->is_const && ! attr2->is_const)\n \t  error_at (attr->loc,\n-\t\t    \"non-constant attribute `%s' referenced from `%s'\",\n-\t\t    XSTR (exp, 0), attr->name);\n+\t\t    \"constant attribute `%s' cannot refer to non-constant\"\n+\t\t    \" attribute `%s'\", attr->name, attr2->name);\n \telse if (attr->is_numeric != attr2->is_numeric)\n-\t  error_at (attr->loc,\n+\t  error_at (loc,\n \t\t    \"numeric attribute mismatch calling `%s' from `%s'\",\n-\t\t    XSTR (exp, 0), attr->name);\n+\t\t    attr2->name, attr->name);\n       }\n       break;\n \n@@ -1034,8 +1035,8 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n       return attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n \n     default:\n-      error_at (attr->loc, \"invalid operation `%s' for attribute value\",\n-\t\tGET_RTX_NAME (GET_CODE (exp)));\n+      error_at (loc, \"invalid operator `%s' in definition of attribute `%s'\",\n+\t\tGET_RTX_NAME (GET_CODE (exp)), attr->name);\n       break;\n     }\n \n@@ -1163,7 +1164,7 @@ check_defs (void)\n \t    }\n \n \t  XVECEXP (id->def, id->vec_idx, i) = value;\n-\t  XEXP (value, 1) = check_attr_value (XEXP (value, 1), attr);\n+\t  XEXP (value, 1) = check_attr_value (id->loc, XEXP (value, 1), attr);\n \t}\n     }\n }\n@@ -1204,7 +1205,7 @@ make_canonical (file_location loc, struct attr_desc *attr, rtx exp)\n \t This makes the COND something that won't be considered an arbitrary\n \t expression by walk_attr_value.  */\n       ATTR_IND_SIMPLIFIED_P (exp) = 1;\n-      exp = check_attr_value (exp, attr);\n+      exp = check_attr_value (loc, exp, attr);\n       break;\n \n     case IF_THEN_ELSE:\n@@ -3186,7 +3187,7 @@ gen_attr (md_rtx_info *info)\n     error_at (info->loc, \"`length' attribute must take numeric values\");\n \n   /* Set up the default value.  */\n-  XEXP (def, 2) = check_attr_value (XEXP (def, 2), attr);\n+  XEXP (def, 2) = check_attr_value (info->loc, XEXP (def, 2), attr);\n   attr->default_val = get_attr_value (info->loc, XEXP (def, 2), attr, -2);\n }\n \n@@ -4755,9 +4756,14 @@ gen_insn_reserv (md_rtx_info *info)\n   struct insn_reserv *decl = oballoc (struct insn_reserv);\n   rtx def = info->def;\n \n+  struct attr_desc attr;\n+  memset (&attr, 0, sizeof (attr));\n+  attr.name = DEF_ATTR_STRING (XSTR (def, 0));\n+  attr.loc = info->loc;\n+\n   decl->name            = DEF_ATTR_STRING (XSTR (def, 0));\n   decl->default_latency = XINT (def, 1);\n-  decl->condexp         = check_attr_test (XEXP (def, 2), 0, info->loc);\n+  decl->condexp         = check_attr_test (info->loc, XEXP (def, 2), &attr);\n   decl->insn_num        = n_insn_reservs;\n   decl->bypassed\t= false;\n   decl->next            = 0;\n@@ -5287,7 +5293,7 @@ main (int argc, char **argv)\n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)\n       attr->default_val->value\n-\t= check_attr_value (attr->default_val->value, attr);\n+\t= check_attr_value (attr->loc, attr->default_val->value, attr);\n \n   if (have_error)\n     return FATAL_EXIT_CODE;"}]}