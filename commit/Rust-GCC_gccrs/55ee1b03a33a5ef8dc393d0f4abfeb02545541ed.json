{"sha": "55ee1b03a33a5ef8dc393d0f4abfeb02545541ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlZTFiMDNhMzNhNWVmOGRjMzkzZDBmNGFiZmViMDI1NDU1NDFlZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-29T22:47:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-29T22:47:11Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r626", "tree": {"sha": "327aa8ed8bf0ef4af86d9f3e03eeb4a133c3a311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/327aa8ed8bf0ef4af86d9f3e03eeb4a133c3a311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55ee1b03a33a5ef8dc393d0f4abfeb02545541ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55ee1b03a33a5ef8dc393d0f4abfeb02545541ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55ee1b03a33a5ef8dc393d0f4abfeb02545541ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55ee1b03a33a5ef8dc393d0f4abfeb02545541ed/comments", "author": null, "committer": null, "parents": [{"sha": "2b15883f5880482775fd226a134b1ec128ce53f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b15883f5880482775fd226a134b1ec128ce53f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b15883f5880482775fd226a134b1ec128ce53f6"}], "stats": {"total": 75, "additions": 63, "deletions": 12}, "files": [{"sha": "e7e32d9ce0ae8d16a6e70ec999166d2b05773da8", "filename": "gcc/config/svr4.h", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55ee1b03a33a5ef8dc393d0f4abfeb02545541ed/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55ee1b03a33a5ef8dc393d0f4abfeb02545541ed/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=55ee1b03a33a5ef8dc393d0f4abfeb02545541ed", "patch": "@@ -39,12 +39,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n    appropriate define for the type of hardware that you are targeting.\n */\n \n-/* Define a symbol so that libgcc* can know what sort of operating\n-   environment and assembler syntax we are targeting for.  */\n-#ifndef SVR4\n-#define SVR4\n-#endif\n-\n /* For the sake of libgcc2.c, indicate target supports atexit.  */\n #define HAVE_ATEXIT\n \n@@ -269,8 +263,11 @@ do {\t\t\t\t \t\t\t\t\\\n /* This is how to allocate empty space in some section.  The .zero\n    pseudo-op is used for this on most svr4 assemblers.  */\n \n+#define SKIP_ASM_OP\t\".zero\"\n+\n #undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE) fprintf (FILE, \"\\t.zero\\t%u\\n\", (SIZE))\n+#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n+  fprintf (FILE, \"\\t%s\\t%u\\n\", SKIP_ASM_OP, (SIZE))\n \n /* This is how to output a reference to a user-level label named NAME.\n    `assemble_name' uses this.\n@@ -281,6 +278,46 @@ do {\t\t\t\t \t\t\t\t\\\n #undef ASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"%s\", NAME)\n \n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+\n+   If the NUM argument is negative, we don't use it when generating the\n+   label.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler.\n+*/\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((int) (NUM) >= 0)\t\t\t\t\t\t\t\\ ???\n+    fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \".%s:\\n\", PREFIX);\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.\n+\n+   If the NUM argument is negative, we don't use it when generating the\n+   label.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler.\n+*/\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((int) (NUM) >= 0)\t\t\t\t\t\t\t\\\n+    sprintf (LABEL, \"*.%s%d\", PREFIX, NUM);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    sprintf (LABEL, \"*.%s\", PREFIX);\t\t\t\t\t\\\n+} while (0)\n+\n /* The standard SVR4 assembler seems to require that certain builtin\n    library routines (e.g. .udiv) be explicitly declared as .globl\n    in each assembly file where they are referenced.  */\n@@ -293,10 +330,12 @@ do {\t\t\t\t \t\t\t\t\\\n    the linker seems to want the alignment of data objects\n    to depend on their types.  We do exactly that here.  */\n \n+#define COMMON_ASM_OP\t\".comm\"\n+\n #undef ASM_OUTPUT_ALIGNED_COMMON\n #define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\t.comm\\t\", (FILE));\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n   assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n   fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n } while (0)\n@@ -391,7 +430,7 @@ ctors_section ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_ctors)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, CTORS_SECTION_ASM_OP);\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n       in_section = in_ctors;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n@@ -402,7 +441,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_dtors)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, DTORS_SECTION_ASM_OP);\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n       in_section = in_dtors;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n@@ -479,11 +518,22 @@ dtors_section ()\t\t\t\t\t\t\t\\\n \n #define TYPE_OPERAND_FMT\t\"@%s\"\n \n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n /* These macros generate the special .type and .size directives which\n    are used to set the corresponding fields of the linker symbol table\n-   entries in an ELF object file under SVR4.  */\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n \n-/* Write the extra assembler code needed to declare a function properly.  */\n+/* Write the extra assembler code needed to declare a function properly.\n+   Some svr4 assemblers need to also have something extra said about the\n+   function's return value.  We allow for that here.  */\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -492,6 +542,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n     putc (',', FILE);\t\t\t\t\t\t\t\\\n     fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n     putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n     ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n   } while (0)\n "}]}