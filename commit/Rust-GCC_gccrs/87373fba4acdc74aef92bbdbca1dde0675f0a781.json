{"sha": "87373fba4acdc74aef92bbdbca1dde0675f0a781", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODczNzNmYmE0YWNkYzc0YWVmOTJiYmRiY2ExZGRlMDY3NWYwYTc4MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-08-28T23:20:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-28T23:20:34Z"}, "message": "haifa-sched.c (sched_analyze): Clear LOG_LINKS before calling sched_analyze_insn.\n\n        * haifa-sched.c (sched_analyze): Clear LOG_LINKS before calling\n        sched_analyze_insn.\n        (sched_analyze_1): Let add_dependence care for not adding dups.\n        (sched_analyze_2): Likewise.\n        (add_branch_dependences): Likewise.\n\nFrom-SVN: r28945", "tree": {"sha": "b79a49c95f326c98f2bcc5902e352779c3393c9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b79a49c95f326c98f2bcc5902e352779c3393c9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87373fba4acdc74aef92bbdbca1dde0675f0a781", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87373fba4acdc74aef92bbdbca1dde0675f0a781", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87373fba4acdc74aef92bbdbca1dde0675f0a781", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87373fba4acdc74aef92bbdbca1dde0675f0a781/comments", "author": null, "committer": null, "parents": [{"sha": "8e260ba4dbc6ffff9adb85b0cac1a0565a573f29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e260ba4dbc6ffff9adb85b0cac1a0565a573f29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e260ba4dbc6ffff9adb85b0cac1a0565a573f29"}], "stats": {"total": 43, "additions": 24, "deletions": 19}, "files": [{"sha": "89de67f4df867b86dc5eaa4c1cf7c3457b34fc7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87373fba4acdc74aef92bbdbca1dde0675f0a781/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87373fba4acdc74aef92bbdbca1dde0675f0a781/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87373fba4acdc74aef92bbdbca1dde0675f0a781", "patch": "@@ -1,3 +1,11 @@\n+Sat Aug 28 16:20:12 1999  Richard Henderson  <rth@cygnus.com>\n+\n+        * haifa-sched.c (sched_analyze): Clear LOG_LINKS before calling\n+        sched_analyze_insn.\n+        (sched_analyze_1): Let add_dependence care for not adding dups.\n+        (sched_analyze_2): Likewise.\n+        (add_branch_dependences): Likewise.\n+\n Sat Aug 28 15:58:16 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \n \t* i386/winnt.c (export_list): New type."}, {"sha": "43dc9533be0c1da78f190072edaeed352fa3aa98", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87373fba4acdc74aef92bbdbca1dde0675f0a781/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87373fba4acdc74aef92bbdbca1dde0675f0a781/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=87373fba4acdc74aef92bbdbca1dde0675f0a781", "patch": "@@ -3371,10 +3371,8 @@ sched_analyze_1 (x, insn)\n \t  pending_mem = pending_read_mems;\n \t  while (pending)\n \t    {\n-\t      /* If a dependency already exists, don't create a new one.  */\n-\t      if (!find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n-\t\tif (anti_dependence (XEXP (pending_mem, 0), dest))\n-\t\t  add_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n+\t      if (anti_dependence (XEXP (pending_mem, 0), dest))\n+\t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n \n \t      pending = XEXP (pending, 1);\n \t      pending_mem = XEXP (pending_mem, 1);\n@@ -3384,10 +3382,8 @@ sched_analyze_1 (x, insn)\n \t  pending_mem = pending_write_mems;\n \t  while (pending)\n \t    {\n-\t      /* If a dependency already exists, don't create a new one.  */\n-\t      if (!find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n-\t\tif (output_dependence (XEXP (pending_mem, 0), dest))\n-\t\t  add_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n+\t      if (output_dependence (XEXP (pending_mem, 0), dest))\n+\t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n \n \t      pending = XEXP (pending, 1);\n \t      pending_mem = XEXP (pending_mem, 1);\n@@ -3529,10 +3525,8 @@ sched_analyze_2 (x, insn)\n \tpending_mem = pending_read_mems;\n \twhile (pending)\n \t  {\n-\t    /* If a dependency already exists, don't create a new one.  */\n-\t    if (!find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n-\t      if (read_dependence (XEXP (pending_mem, 0), x))\n-\t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n+\t    if (read_dependence (XEXP (pending_mem, 0), x))\n+\t      add_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n \n \t    pending = XEXP (pending, 1);\n \t    pending_mem = XEXP (pending_mem, 1);\n@@ -3542,11 +3536,9 @@ sched_analyze_2 (x, insn)\n \tpending_mem = pending_write_mems;\n \twhile (pending)\n \t  {\n-\t    /* If a dependency already exists, don't create a new one.  */\n-\t    if (!find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n-\t      if (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n-\t\t  x, rtx_varies_p))\n-\t\tadd_dependence (insn, XEXP (pending, 0), 0);\n+\t    if (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n+\t\tx, rtx_varies_p))\n+\t      add_dependence (insn, XEXP (pending, 0), 0);\n \n \t    pending = XEXP (pending, 1);\n \t    pending_mem = XEXP (pending_mem, 1);\n@@ -3819,6 +3811,9 @@ sched_analyze (head, tail)\n     {\n       if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n \t{\n+\t  /* Clear out the stale LOG_LINKS from flow.  */\n+\t  free_INSN_LIST_list (&LOG_LINKS (insn));\n+\n \t  /* Make each JUMP_INSN a scheduling barrier for memory references.  */\n \t  if (GET_CODE (insn) == JUMP_INSN)\n \t    last_pending_memory_flush\n@@ -3833,6 +3828,9 @@ sched_analyze (head, tail)\n \n \t  CANT_MOVE (insn) = 1;\n \n+\t  /* Clear out the stale LOG_LINKS from flow.  */\n+\t  free_INSN_LIST_list (&LOG_LINKS (insn));\n+\n \t  /* Any instruction using a hard register which may get clobbered\n \t     by a call needs to be marked as dependent on this call.\n \t     This prevents a use of a hard return reg from being moved\n@@ -7158,8 +7156,7 @@ add_branch_dependences (head, tail)\n \tif (INSN_REF_COUNT (insn) != 0)\n \t  continue;\n \n-\tif (!find_insn_list (last, LOG_LINKS (insn)))\n-\t  add_dependence (last, insn, REG_DEP_ANTI);\n+\tadd_dependence (last, insn, REG_DEP_ANTI);\n \tINSN_REF_COUNT (insn) = 1;\n \n \t/* Skip over insns that are part of a group.  */"}]}