{"sha": "88b939b19ab454ab2d932ef292bbc557abe4431c", "node_id": "C_kwDOANBUbNoAKDg4YjkzOWIxOWFiNDU0YWIyZDkzMmVmMjkyYmJjNTU3YWJlNDQzMWM", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-04-07T12:33:26Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-04-07T12:33:26Z"}, "message": "analyzer: fix leak false +ve with symbolic writes [PR102208]\n\nPR analyzer/102208 reports false positives from -Wanalyzer-malloc-leak.\nThe root cause is the analyzer getting confused about symbolic writes\nthat could alias a pointer referencing a malloced buffer.\n\nstruct st\n{\n  void *ptr;\n  int arr[10];\n};\n\nstruct st test (int idx)\n{\n  struct st s;\n  s.ptr = __builtin_malloc (1024);  /* (1) */\n  s.arr[idx] = 42;                  /* (2) */\n  return s;\n}\n\nWhen removing overlapping bindings at (2),\nstore::remove_overlapping_bindings was failing to pass on the\nuncertainty_t *, and thus when clobbering the binding of s.ptr, the\nheap-allocated pointer was not being added to the set of maybe-bound\nsvalues, and thus being treated as leaking.\n\nThis patch fixes this, so that s.ptr from (1) is treated as maybe-bound\nafter the write at (2), fixing the leak false postive.\n\nDoing so requires the store to be smarter about how clobbering happens\nwith various combinations of concrete keys and symbolic keys within\nconcrete clusters and symbolic clusters, so that we don't lose warnings\nabout definite leaks.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/102208\n\t* store.cc (binding_map::remove_overlapping_bindings): Add\n\t\"always_overlap\" param, using it to generalize to the case where\n\twe want to remove all bindings.  Update \"uncertainty\" logic to\n\tonly record maybe-bound values for cases where there is a symbolic\n\twrite involved.\n\t(binding_cluster::mark_region_as_unknown): Split param \"reg\" into\n\t\"reg_to_bind\" and \"reg_for_overlap\".\n\t(binding_cluster::maybe_get_compound_binding): Pass \"false\" to\n\tbinding_map::remove_overlapping_bindings new \"always_overlap\" param.\n\t(binding_cluster::remove_overlapping_bindings): Determine\n\t\"always_overlap\" and pass it to\n\tbinding_map::remove_overlapping_bindings.\n\t(store::set_value): Pass uncertainty to remove_overlapping_bindings\n\tcall.  Update for new param of\n\tbinding_cluster::mark_region_as_unknown, passing both the base\n\tregion of the iter_cluster, and the lhs_reg.\n\t(store::mark_region_as_unknown): Update for new param of\n\tbinding_cluster::mark_region_as_unknown, passing \"reg\" for both.\n\t(store::remove_overlapping_bindings): Add param \"uncertainty\", and\n\tpass it on to call to\n\tbinding_cluster::remove_overlapping_bindings.\n\t* store.h (binding_map::remove_overlapping_bindings): Add\n\t\"always_overlap\" param.\n\t(binding_cluster::mark_region_as_unknown): Split param \"reg\" into\n\t\"reg_to_bind\" and \"reg_for_overlap\".\n\t(store::remove_overlapping_bindings): Add param \"uncertainty\".\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/102208\n\t* gcc.dg/analyzer/symbolic-9.c: New test.\n\t* gcc.dg/analyzer/torture/leak-pr102308-1.c: New test.\n\t* gcc.dg/analyzer/torture/leak-pr102308-2.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "6237a43421f7efe8845780738b59116b0371ce00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6237a43421f7efe8845780738b59116b0371ce00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88b939b19ab454ab2d932ef292bbc557abe4431c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b939b19ab454ab2d932ef292bbc557abe4431c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b939b19ab454ab2d932ef292bbc557abe4431c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b939b19ab454ab2d932ef292bbc557abe4431c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27bfd13437c773a050f532ed164907de54b5a64f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27bfd13437c773a050f532ed164907de54b5a64f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27bfd13437c773a050f532ed164907de54b5a64f"}], "stats": {"total": 350, "additions": 326, "deletions": 24}, "files": [{"sha": "35f66a4b6fcf83fd0000e0f76f3ca3242ef289ba", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 91, "deletions": 21, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=88b939b19ab454ab2d932ef292bbc557abe4431c", "patch": "@@ -997,27 +997,61 @@ binding_map::get_overlapping_bindings (const binding_key *key,\n        value:  {BITS_WITHIN(bytes 4-7, inner_val: INIT_VAL((*INIT_VAL(p_33(D))).arr))}\n \n    If UNCERTAINTY is non-NULL, use it to record any svalues that\n-   were removed, as being maybe-bound.  */\n+   were removed, as being maybe-bound.\n+\n+   If ALWAYS_OVERLAP, then assume that DROP_KEY can overlap anything\n+   in the map, due to one or both of the underlying clusters being\n+   symbolic (but not the same symbolic region).  Hence even if DROP_KEY is a\n+   concrete binding it could actually be referring to the same memory as\n+   distinct concrete bindings in the map.  Remove all bindings, but\n+   register any svalues with *UNCERTAINTY.  */\n \n void\n binding_map::remove_overlapping_bindings (store_manager *mgr,\n \t\t\t\t\t  const binding_key *drop_key,\n-\t\t\t\t\t  uncertainty_t *uncertainty)\n+\t\t\t\t\t  uncertainty_t *uncertainty,\n+\t\t\t\t\t  bool always_overlap)\n {\n+  /* Get the bindings of interest within this map.  */\n   auto_vec<const binding_key *> bindings;\n-  get_overlapping_bindings (drop_key, &bindings);\n+  if (always_overlap)\n+    for (auto iter : *this)\n+      bindings.safe_push (iter.first); /* Add all bindings.  */\n+  else\n+    /* Just add overlapping bindings.  */\n+    get_overlapping_bindings (drop_key, &bindings);\n \n   unsigned i;\n   const binding_key *iter_binding;\n   FOR_EACH_VEC_ELT (bindings, i, iter_binding)\n     {\n+      /* Record any svalues that were removed to *UNCERTAINTY as being\n+\t maybe-bound, provided at least some part of the binding is symbolic.\n+\n+\t Specifically, if at least one of the bindings is symbolic, or we\n+\t have ALWAYS_OVERLAP for the case where we have possibly aliasing\n+\t regions, then we don't know that the svalue has been overwritten,\n+\t and should record that to *UNCERTAINTY.\n+\n+\t However, if we have concrete keys accessing within the same symbolic\n+\t region, then we *know* that the symbolic region has been overwritten,\n+\t so we don't record it to *UNCERTAINTY, as this could be a genuine\n+\t leak.  */\n       const svalue *old_sval = get (iter_binding);\n-      if (uncertainty)\n+      if (uncertainty\n+\t  && (drop_key->symbolic_p ()\n+\t      || iter_binding->symbolic_p ()\n+\t      || always_overlap))\n \tuncertainty->on_maybe_bound_sval (old_sval);\n \n       /* Begin by removing the old binding. */\n       m_map.remove (iter_binding);\n \n+      /* Don't attempt to handle prefixes/suffixes for the\n+\t \"always_overlap\" case; everything's being removed.  */\n+      if (always_overlap)\n+\tcontinue;\n+\n       /* Now potentially add the prefix and suffix.  */\n       if (const concrete_binding *drop_ckey\n \t  = drop_key->dyn_cast_concrete_binding ())\n@@ -1335,22 +1369,30 @@ binding_cluster::zero_fill_region (store_manager *mgr, const region *reg)\n   fill_region (mgr, reg, zero_sval);\n }\n \n-/* Mark REG within this cluster as being unknown.\n+/* Mark REG_TO_BIND within this cluster as being unknown.\n+\n+   Remove any bindings overlapping REG_FOR_OVERLAP.\n    If UNCERTAINTY is non-NULL, use it to record any svalues that\n-   had bindings to them removed, as being maybe-bound.  */\n+   had bindings to them removed, as being maybe-bound.\n+\n+   REG_TO_BIND and REG_FOR_OVERLAP are the same for\n+   store::mark_region_as_unknown, but are different in\n+   store::set_value's alias handling, for handling the case where\n+   we have a write to a symbolic REG_FOR_OVERLAP. */\n \n void\n binding_cluster::mark_region_as_unknown (store_manager *mgr,\n-\t\t\t\t\t const region *reg,\n+\t\t\t\t\t const region *reg_to_bind,\n+\t\t\t\t\t const region *reg_for_overlap,\n \t\t\t\t\t uncertainty_t *uncertainty)\n {\n-  remove_overlapping_bindings (mgr, reg, uncertainty);\n+  remove_overlapping_bindings (mgr, reg_for_overlap, uncertainty);\n \n   /* Add a default binding to \"unknown\".  */\n   region_model_manager *sval_mgr = mgr->get_svalue_manager ();\n   const svalue *sval\n-    = sval_mgr->get_or_create_unknown_svalue (reg->get_type ());\n-  bind (mgr, reg, sval);\n+    = sval_mgr->get_or_create_unknown_svalue (reg_to_bind->get_type ());\n+  bind (mgr, reg_to_bind, sval);\n }\n \n /* Purge state involving SVAL.  */\n@@ -1595,7 +1637,7 @@ binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n \t\t it overlaps with offset_concrete_key.  */\n \t      default_map.remove_overlapping_bindings (mgr,\n \t\t\t\t\t\t       offset_concrete_key,\n-\t\t\t\t\t\t       NULL);\n+\t\t\t\t\t\t       NULL, false);\n \t    }\n \t  else if (bound_range.contains_p (reg_range, &subrange))\n \t    {\n@@ -1629,7 +1671,7 @@ binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n \t\t it overlaps with overlap_concrete_key.  */\n \t      default_map.remove_overlapping_bindings (mgr,\n \t\t\t\t\t\t       overlap_concrete_key,\n-\t\t\t\t\t\t       NULL);\n+\t\t\t\t\t\t       NULL, false);\n \t    }\n \t}\n       else\n@@ -1652,7 +1694,13 @@ binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n }\n \n /* Remove, truncate, and/or split any bindings within this map that\n-   overlap REG.\n+   could overlap REG.\n+\n+   If REG's base region or this cluster is symbolic and they're different\n+   base regions, then remove everything in this cluster's map, on the\n+   grounds that REG could be referring to the same memory as anything\n+   in the map.\n+\n    If UNCERTAINTY is non-NULL, use it to record any svalues that\n    were removed, as being maybe-bound.  */\n \n@@ -1663,7 +1711,19 @@ binding_cluster::remove_overlapping_bindings (store_manager *mgr,\n {\n   const binding_key *reg_binding = binding_key::make (mgr, reg);\n \n-  m_map.remove_overlapping_bindings (mgr, reg_binding, uncertainty);\n+  const region *cluster_base_reg = get_base_region ();\n+  const region *other_base_reg = reg->get_base_region ();\n+  /* If at least one of the base regions involved is symbolic, and they're\n+     not the same base region, then consider everything in the map as\n+     potentially overlapping with reg_binding (even if it's a concrete\n+     binding and things in the map are concrete - they could be referring\n+     to the same memory when the symbolic base regions are taken into\n+     account).  */\n+  bool always_overlap = (cluster_base_reg != other_base_reg\n+\t\t\t && (cluster_base_reg->get_kind () == RK_SYMBOLIC\n+\t\t\t     || other_base_reg->get_kind () == RK_SYMBOLIC));\n+  m_map.remove_overlapping_bindings (mgr, reg_binding, uncertainty,\n+\t\t\t\t     always_overlap);\n }\n \n /* Attempt to merge CLUSTER_A and CLUSTER_B into OUT_CLUSTER, using\n@@ -2368,7 +2428,7 @@ store::set_value (store_manager *mgr, const region *lhs_reg,\n   logger *logger = mgr->get_logger ();\n   LOG_SCOPE (logger);\n \n-  remove_overlapping_bindings (mgr, lhs_reg);\n+  remove_overlapping_bindings (mgr, lhs_reg, uncertainty);\n \n   rhs_sval = simplify_for_binding (rhs_sval);\n \n@@ -2438,8 +2498,14 @@ store::set_value (store_manager *mgr, const region *lhs_reg,\n \t\t  lhs_reg->dump_to_pp (pp, true);\n \t\t  logger->end_log_line ();\n \t\t}\n-\t      iter_cluster->mark_region_as_unknown (mgr, iter_base_reg,\n-\t\t\t\t\t\t    uncertainty);\n+\t      /* Mark all of iter_cluster's iter_base_reg as unknown,\n+\t\t using LHS_REG when considering overlaps, to handle\n+\t\t symbolic vs concrete issues.  */\n+\t      iter_cluster->mark_region_as_unknown\n+\t\t(mgr,\n+\t\t iter_base_reg, /* reg_to_bind */\n+\t\t lhs_reg, /* reg_for_overlap */\n+\t\t uncertainty);\n \t      break;\n \n \t    case tristate::TS_TRUE:\n@@ -2603,7 +2669,7 @@ store::mark_region_as_unknown (store_manager *mgr, const region *reg,\n       || !base_reg->tracked_p ())\n     return;\n   binding_cluster *cluster = get_or_create_cluster (base_reg);\n-  cluster->mark_region_as_unknown (mgr, reg, uncertainty);\n+  cluster->mark_region_as_unknown (mgr, reg, reg, uncertainty);\n }\n \n /* Purge state involving SVAL.  */\n@@ -2826,10 +2892,14 @@ store::get_representative_path_vars (const region_model *model,\n }\n \n /* Remove all bindings overlapping REG within this store, removing\n-   any clusters that become redundant.  */\n+   any clusters that become redundant.\n+\n+   If UNCERTAINTY is non-NULL, use it to record any svalues that\n+   were removed, as being maybe-bound.  */\n \n void\n-store::remove_overlapping_bindings (store_manager *mgr, const region *reg)\n+store::remove_overlapping_bindings (store_manager *mgr, const region *reg,\n+\t\t\t\t    uncertainty_t *uncertainty)\n {\n   const region *base_reg = reg->get_base_region ();\n   if (binding_cluster **cluster_slot = m_cluster_map.get (base_reg))\n@@ -2842,7 +2912,7 @@ store::remove_overlapping_bindings (store_manager *mgr, const region *reg)\n \t  delete cluster;\n \t  return;\n \t}\n-      cluster->remove_overlapping_bindings (mgr, reg, NULL);\n+      cluster->remove_overlapping_bindings (mgr, reg, uncertainty);\n     }\n }\n "}, {"sha": "17485b783b8cb545aba183899bcfbd004bb447d3", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=88b939b19ab454ab2d932ef292bbc557abe4431c", "patch": "@@ -509,7 +509,8 @@ class binding_map\n \n   void remove_overlapping_bindings (store_manager *mgr,\n \t\t\t\t    const binding_key *drop_key,\n-\t\t\t\t    uncertainty_t *uncertainty);\n+\t\t\t\t    uncertainty_t *uncertainty,\n+\t\t\t\t    bool always_overlap);\n \n private:\n   void get_overlapping_bindings (const binding_key *key,\n@@ -574,7 +575,9 @@ class binding_cluster\n   void purge_region (store_manager *mgr, const region *reg);\n   void fill_region (store_manager *mgr, const region *reg, const svalue *sval);\n   void zero_fill_region (store_manager *mgr, const region *reg);\n-  void mark_region_as_unknown (store_manager *mgr, const region *reg,\n+  void mark_region_as_unknown (store_manager *mgr,\n+\t\t\t       const region *reg_to_bind,\n+\t\t\t       const region *reg_for_overlap,\n \t\t\t       uncertainty_t *uncertainty);\n   void purge_state_involving (const svalue *sval,\n \t\t\t      region_model_manager *sval_mgr);\n@@ -765,7 +768,8 @@ class store\n \t\t\t  region_model_manager *mgr);\n \n private:\n-  void remove_overlapping_bindings (store_manager *mgr, const region *reg);\n+  void remove_overlapping_bindings (store_manager *mgr, const region *reg,\n+\t\t\t\t    uncertainty_t *uncertainty);\n   tristate eval_alias_1 (const region *base_reg_a,\n \t\t\t const region *base_reg_b) const;\n "}, {"sha": "54ed30f132c6dbee498cbe3301537752a8e65c62", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-9.c", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-9.c?ref=88b939b19ab454ab2d932ef292bbc557abe4431c", "patch": "@@ -0,0 +1,197 @@\n+#include \"analyzer-decls.h\"\n+\n+struct st\n+{\n+  void *ptr[10];\n+  int arr[10];\n+};\n+\n+/* Various combinations of a pair of writes, involving\n+   symbolic vs concrete clusters, with symbolic vs concrete keys\n+   within them.  */\n+\n+struct st g;\n+\n+/* \"ptr\" write: fully concrete.  */\n+\n+struct st\n+test_conc_conc_ptr_conc_conc_arr (void)\n+{\n+  struct st s;\n+  s.ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  s.arr[5] = 42;\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  __analyzer_describe (0, s.arr[5]);  /* { dg-warning \"42\" } */\n+  return s;\n+}\n+\n+struct st\n+test_conc_conc_ptr_conc_sym_arr (int j)\n+{\n+  struct st s;\n+  s.ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  s.arr[j] = 42;\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, s.arr[j]);  /* { dg-warning \"42\" } */\n+  return s;\n+}\n+\n+struct st\n+test_conc_conc_ptr_sym_conc_arr (struct st *p)\n+{\n+  struct st s;\n+  s.ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  p->arr[5] = 42;\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  __analyzer_describe (0, p->arr[5]);  /* { dg-warning \"42\" } */\n+  return s;\n+}\n+\n+struct st\n+test_conc_conc_ptr_sym_sym_arr (struct st *p, int j)\n+{\n+  struct st s;\n+  s.ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  p->arr[j] = 42;\n+  __analyzer_describe (0, s.ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  __analyzer_describe (0, p->arr[j]);  /* { dg-warning \"42\" } */\n+  return s;\n+}\n+\n+/* \"ptr\" write: symbolic region, but at concrete offset.  */\n+\n+void\n+test_sym_conc_ptr_conc_conc_arr (struct st *p)\n+{\n+  p->ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  g.arr[5] = 42;\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, g.arr[5]);  /* { dg-warning \"42\" } */\n+}\n+\n+void\n+test_sym_conc_ptr_conc_sym_arr (struct st *p, int j)\n+{\n+  p->ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  g.arr[j] = 42;\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, g.arr[j]);  /* { dg-warning \"42\" } */\n+}\n+\n+void\n+test_sym_conc_ptr_sym_conc_arr (struct st *p, struct st *q)\n+{\n+  p->ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  q->arr[5] = 42;\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, q->arr[5]);  /* { dg-warning \"42\" } */\n+}\n+\n+void\n+test_sym_conc_ptr_sym_sym_arr (struct st *p, struct st *q, int j)\n+{\n+  p->ptr[1] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  q->arr[j] = 42;\n+  __analyzer_describe (0, p->ptr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, q->arr[j]);  /* { dg-warning \"42\" } */\n+}\n+\n+/* \"ptr\" write: concrete region, but at symbolic offset.  */\n+\n+struct st\n+test_conc_sym_ptr_conc_conc_arr (int i)\n+{\n+  struct st s;\n+  s.ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  s.arr[5] = 42;\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, s.arr[5]);  /* { dg-warning \"42\" } */\n+  return s;\n+}\n+\n+struct st\n+test_conc_sym_ptr_conc_sym_arr (int i, int j)\n+{\n+  struct st s;\n+  s.ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  s.arr[j] = 42;\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, s.arr[j]);  /* { dg-warning \"42\" } */\n+  return s;\n+}\n+\n+struct st\n+test_conc_sym_ptr_sym_conc_arr (int i, struct st *p)\n+{\n+  struct st s;\n+  s.ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  p->arr[5] = 42;\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  __analyzer_describe (0, p->arr[5]);  /* { dg-warning \"42\" } */\n+  return s;\n+} /* { dg-bogus \"leak\" \"PR analyzer/105190\" { xfail *-*-* } } */\n+\n+struct st\n+test_conc_sym_ptr_sym_sym_arr (int i, struct st *p, int j)\n+{\n+  struct st s;\n+  s.ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  p->arr[j] = 42;\n+  __analyzer_describe (0, s.ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  __analyzer_describe (0, p->arr[j]);  /* { dg-warning \"42\" } */\n+  return s;\n+} /* { dg-bogus \"leak\" \"PR analyzer/105190\" { xfail *-*-* } } */\n+\n+/* \"ptr\" write: symbolic region, with symbolic offset.  */\n+\n+void\n+test_sym_sym_ptr_conc_conc_arr (struct st *p, int i)\n+{\n+  p->ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  g.arr[5] = 42;\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, g.arr[5]);  /* { dg-warning \"42\" } */\n+}\n+\n+void\n+test_sym_sym_ptr_conc_sym_arr (struct st *p, int i, int j)\n+{\n+  p->ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  g.arr[j] = 42;\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, g.arr[j]);  /* { dg-warning \"42\" } */\n+}\n+\n+void\n+test_sym_sym_ptr_sym_conc_arr (struct st *p, int i, struct st *q)\n+{\n+  p->ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  q->arr[5] = 42;\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, q->arr[5]);  /* { dg-warning \"42\" } */\n+}\n+\n+void\n+test_sym_sym_ptr_sym_sym_arr (struct st *p, int i, struct st *q, int j)\n+{\n+  p->ptr[i] = __builtin_malloc (1024);\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"HEAP_ALLOCATED_REGION\" } */\n+  q->arr[j] = 42;\n+  __analyzer_describe (0, p->ptr[i]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_describe (0, q->arr[j]);  /* { dg-warning \"42\" } */\n+}"}, {"sha": "31747168505fbc21cba2faff1a1e4f6bbb978188", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/leak-pr102308-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fleak-pr102308-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fleak-pr102308-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fleak-pr102308-1.c?ref=88b939b19ab454ab2d932ef292bbc557abe4431c", "patch": "@@ -0,0 +1,19 @@\n+#include <stdlib.h>\n+\n+struct s {\n+  char *p;\n+  int arr[2];\n+};\n+\n+int main(void) {\n+  struct s *s = malloc(sizeof *s);\n+  if (s) {\n+    s->p = malloc(1);\n+    for (int i = 0; i < 2; i++)\n+      s->arr[i] = -1; /* { dg-bogus \"leak\" } */\n+  }\n+  if (s) {\n+    free(s->p);\n+    free(s);\n+  }\n+}"}, {"sha": "d65f1768a26531f2d4901155fb0c2c44c5caed38", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/leak-pr102308-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fleak-pr102308-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b939b19ab454ab2d932ef292bbc557abe4431c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fleak-pr102308-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fleak-pr102308-2.c?ref=88b939b19ab454ab2d932ef292bbc557abe4431c", "patch": "@@ -0,0 +1,12 @@\n+#include <stdlib.h>\n+struct s {\n+  char *p;\n+  int arr[1];\n+};\n+int main(void) {\n+  struct s s;\n+  s.p = malloc(1);\n+  for (int i = 0; i < 1; i++)\n+    s.arr[i] = -1; /* { dg-bogus \"leak\" } */\n+  free(s.p);\n+}"}]}