{"sha": "b08de47ebf98089851079227b3840a7cec3d5503", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA4ZGU0N2ViZjk4MDg5ODUxMDc5MjI3YjM4NDBhN2NlYzNkNTUwMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-05-12T17:22:04Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-05-12T17:22:04Z"}, "message": "Add better support for passing args in registers; Add loop/jump/function alignment overrides; add decrement_and_branch until 0\n\nFrom-SVN: r9647", "tree": {"sha": "1ff9e4a0352098eada7ebf6c2321b3ad556972f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ff9e4a0352098eada7ebf6c2321b3ad556972f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b08de47ebf98089851079227b3840a7cec3d5503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b08de47ebf98089851079227b3840a7cec3d5503", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b08de47ebf98089851079227b3840a7cec3d5503", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b08de47ebf98089851079227b3840a7cec3d5503/comments", "author": null, "committer": null, "parents": [{"sha": "b5f89788219bb69aa9d4c37b3673f96c4eb339a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f89788219bb69aa9d4c37b3673f96c4eb339a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f89788219bb69aa9d4c37b3673f96c4eb339a7"}], "stats": {"total": 736, "additions": 559, "deletions": 177}, "files": [{"sha": "52d64d07082e9bcb27b0f2c95e7768b4e162604f", "filename": "gcc/config/i386/gas.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgas.h?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -82,15 +82,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    For the 486, align to 16-byte boundary for sake of cache.  */\n \n #undef ASM_OUTPUT_ALIGN_CODE\n-#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\t\t\\\n-     fprintf ((FILE), \"\\t.align %d,0x90\\n\",\t\t\\\n-\t      TARGET_486 ? 4 : 2);  /* Use log of 16 or log of 4 as arg.  */\n+#define ASM_OUTPUT_ALIGN_CODE(FILE) \\\n+  fprintf ((FILE), \"\\t.align %d,0x90\\n\", 1 << i386_align_jumps)\n \n /* Align start of loop at 4-byte boundary.  */\n \n #undef ASM_OUTPUT_LOOP_ALIGN\n #define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-     fprintf ((FILE), \"\\t.align 2,0x90\\n\");  /* Use log of 4 as arg.  */\n+  fprintf ((FILE), \"\\t.align %d,0x90\\n\", 1 << i386_align_loops)\n+\n \f\n /* A C statement or statements which output an assembler instruction\n    opcode to the stdio stream STREAM.  The macro-operand PTR is a"}, {"sha": "5618a0dd0fba293ed3b982c92300e1c604ea5624", "filename": "gcc/config/i386/go32.h", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fgo32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fgo32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgo32.h?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -9,60 +9,6 @@\n \n #include \"i386/gas.h\"\n \n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.\n-\n-   This only happens if the function declaration has the STDCALL attribute and\n-   the number of arguments is not variable */\n-\n-#undef RETURN_POPS_ARGS\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n-  ( \\\n-   TREE_CODE (FUNTYPE) == IDENTIFIER_NODE \\\n-   ? \\\n-     0 \\\n-   : \\\n-     ( \\\n-      ((FUNDECL && (TREE_CODE_CLASS (TREE_CODE (FUNDECL)) == 'd') \\\n-\t? \\\n-          lookup_attribute (\"stdcall\", \\\n-\t\t\t    DECL_MACHINE_ATTRIBUTES (FUNDECL)) != NULL_TREE \\\n-\t: 0 \\\n-       ) \\\n-      ) \\\n-      && \\\n-         ( \\\n-          TYPE_ARG_TYPES (FUNTYPE) == 0 \\\n-          || \\\n-            TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE))) \\\n-            == void_type_node \\\n-         ) \\\n-     ) \\\n-     ? \\\n-       (SIZE) \\\n-     : \\\n-       (aggregate_value_p (TREE_TYPE (FUNTYPE))) \\\n-       ? \\\n-         GET_MODE_SIZE (Pmode) \\\n-       : \\\n-         0 \\\n-  )\n-\n-/* Value is 1 if the declaration has either of the attributes: CDECL or\n-   STDCALL and 0 otherwise */\n-\n-#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTR, NAME, ARGS) \\\n-  (((TREE_CODE(DECL) == FUNCTION_DECL) \\\n-    || (TREE_CODE(DECL) == FIELD_DECL) \\\n-    || (TREE_CODE(DECL) == TYPE_DECL)) \\\n-   && (is_attribute_p (\"stdcall\", (NAME)) \\\n-       || is_attribute_p (\"cdecl\", (NAME))) \\\n-   && (ARGS) == NULL)\n-\n #ifdef CPP_PREDEFINES\n #undef CPP_PREDEFINES\n #endif"}, {"sha": "cb6158cc2040ab4282aa5fb563d1efc1dc760e0c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 377, "deletions": 1, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -19,6 +19,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include <stdio.h>\n #include <setjmp.h>\n+#include <ctype.h>\n #include \"config.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -79,9 +80,22 @@ struct rtx_def *i386_compare_op1 = NULL_RTX;\n struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n \n /* Register allocation order */\n-char *i386_reg_alloc_order = (char *)0;\n+char *i386_reg_alloc_order;\n static char regs_allocated[FIRST_PSEUDO_REGISTER];\n \n+/* # of registers to use to pass arguments. */\n+char *i386_regparm_string;\t\t\t/* # registers to use to pass args */\n+int i386_regparm;\t\t\t\t/* i386_regparm_string as a number */\n+\n+/* Alignment to use for loops and jumps */\n+char *i386_align_loops_string;\t\t\t/* power of two alignment for loops */\n+char *i386_align_jumps_string;\t\t\t/* power of two alignment for non-loop jumps */\n+char *i386_align_funcs_string;\t\t\t/* power of two alignment for functions */\n+\n+int i386_align_loops;\t\t\t\t/* power of two alignment for loops */\n+int i386_align_jumps;\t\t\t\t/* power of two alignment for non-loop jumps */\n+int i386_align_funcs;\t\t\t\t/* power of two alignment for functions */\n+\n \f\n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -96,6 +110,8 @@ void\n override_options ()\n {\n   int ch, i, regno;\n+  char *p;\n+  int def_align;\n \n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n@@ -125,6 +141,49 @@ override_options ()\n \t  regs_allocated[regno] = 1;\n \t}\n     }\n+\n+  /* Validate -mregparm= value */\n+  if (i386_regparm_string)\n+    {\n+      i386_regparm = atoi (i386_regparm_string);\n+      if (i386_regparm < 0 || i386_regparm > REGPARM_MAX)\n+\tfatal (\"-mregparm=%d is not between 0 and %d\", i386_regparm, REGPARM_MAX);\n+    }\n+\n+  def_align = (TARGET_386) ? 2 : 4;\n+\n+  /* Validate -malign-loops= value, or provide default */\n+  if (i386_align_loops_string)\n+    {\n+      i386_align_loops = atoi (i386_align_loops_string);\n+      if (i386_align_loops < 0 || i386_align_loops > MAX_CODE_ALIGN)\n+\tfatal (\"-malign-loops=%d is not between 0 and %d\",\n+\t       i386_align_loops, MAX_CODE_ALIGN);\n+    }\n+  else\n+    i386_align_loops = def_align;\n+\n+  /* Validate -malign-jumps= value, or provide default */\n+  if (i386_align_jumps_string)\n+    {\n+      i386_align_jumps = atoi (i386_align_jumps_string);\n+      if (i386_align_jumps < 0 || i386_align_jumps > MAX_CODE_ALIGN)\n+\tfatal (\"-malign-jumps=%d is not between 0 and %d\",\n+\t       i386_align_jumps, MAX_CODE_ALIGN);\n+    }\n+  else\n+    i386_align_jumps = def_align;\n+\n+  /* Validate -malign-functions= value, or provide default */\n+  if (i386_align_funcs_string)\n+    {\n+      i386_align_funcs = atoi (i386_align_funcs_string);\n+      if (i386_align_funcs < 0 || i386_align_funcs > MAX_CODE_ALIGN)\n+\tfatal (\"-malign-functions=%d is not between 0 and %d\",\n+\t       i386_align_funcs, MAX_CODE_ALIGN);\n+    }\n+  else\n+    i386_align_funcs = def_align;\n }\n \f\n /* A C statement (sans semicolon) to choose the order in which to\n@@ -219,6 +278,306 @@ order_regs_for_local_alloc ()\n     }\n }\n \n+\f\n+/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n+   attribute for DECL.  The attributes in ATTRIBUTES have previously been\n+   assigned to DECL.  */\n+\n+int\n+i386_valid_decl_attribute_p (decl, attributes, identifier, args)\n+     tree decl;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  return 0;\n+}\n+\n+/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n+   attribute for TYPE.  The attributes in ATTRIBUTES have previously been\n+   assigned to TYPE.  */\n+\n+int\n+i386_valid_type_attribute_p (type, attributes, identifier, args)\n+     tree type;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  if (TREE_CODE (type) != FUNCTION_TYPE\n+      && TREE_CODE (type) != FIELD_DECL\n+      && TREE_CODE (type) != TYPE_DECL)\n+    return 0;\n+\n+  /* Stdcall attribute says callee is responsible for popping arguments\n+     if they are not variable.  */\n+  if (is_attribute_p (\"stdcall\", identifier))\n+    return (args == NULL_TREE);\n+\n+  /* Cdecl attribute says the callee is a normal C declaration */\n+  if (is_attribute_p (\"cdecl\", identifier))\n+    return (args == NULL_TREE);\n+\n+  /* Regparm attribute specifies how many integer arguments are to be\n+     passed in registers */\n+  if (is_attribute_p (\"regparm\", identifier))\n+    {\n+      tree cst;\n+\n+      if (!args || TREE_CODE (args) != TREE_LIST\n+\t  || TREE_CHAIN (args) != NULL_TREE\n+\t  || TREE_VALUE (args) == NULL_TREE)\n+\treturn 0;\n+\n+      cst = TREE_VALUE (args);\n+      if (TREE_CODE (cst) != INTEGER_CST)\n+\treturn 0;\n+\n+      if (TREE_INT_CST_HIGH (cst) != 0\n+\t  || TREE_INT_CST_LOW (cst) < 0\n+\t  || TREE_INT_CST_LOW (cst) > REGPARM_MAX)\n+\treturn 0;\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 0 if the attributes for two types are incompatible, 1 if they\n+   are compatible, and 2 if they are nearly compatible (which causes a\n+   warning to be generated).  */\n+\n+int\n+i386_comp_type_attributes (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  return 1;\n+}\n+\n+\f\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the 80386, the RTD insn may be used to pop them if the number\n+     of args is fixed, but if the number is variable then the caller\n+     must pop them all.  RTD can't be used for library calls now\n+     because the library is compiled with the Unix compiler.\n+   Use of RTD is a selectable option, since it is incompatible with\n+   standard Unix calling sequences.  If the option is not selected,\n+   the caller must always pop the args.\n+\n+   The attribute stdcall is equivalent to RTD on a per module basis.  */\n+\n+int\n+i386_return_pops_args (fundecl, funtype, size)\n+     tree fundecl;\n+     tree funtype;\n+     int size;\n+{\n+  int rtd = TARGET_RTD;\n+\n+  if (TREE_CODE (funtype) == IDENTIFIER_NODE)\n+    return 0;\n+\n+  if (fundecl && TREE_CODE_CLASS (TREE_CODE (fundecl)) == 'd')\n+    {\n+      /* Cdecl functions override -mrtd, and never pop the stack */\n+      if (lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (funtype)))\n+\treturn 0;\n+\n+      /* Stdcall functions will pop the stack if not variable args */\n+      if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (funtype)))\n+\trtd = 1;\n+    }\n+\n+  if (rtd)\n+    {\n+      if (TYPE_ARG_TYPES (funtype) == NULL_TREE\n+\t  || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (funtype))) == void_type_node))\n+\treturn size;\n+\n+      if (aggregate_value_p (TREE_TYPE (funtype)))\n+\treturn GET_MODE_SIZE (Pmode);\n+    }\n+\n+  return 0;\n+}\n+\n+\f\n+/* Argument support functions.  */\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+void\n+init_cumulative_args (cum, fntype, libname)\n+     CUMULATIVE_ARGS *cum;\t/* argument info to initialize */\n+     tree fntype;\t\t/* tree ptr for function decl */\n+     rtx libname;\t\t/* SYMBOL_REF of library name or 0 */\n+{\n+  static CUMULATIVE_ARGS zero_cum;\n+  tree param, next_param;\n+\n+  if (TARGET_DEBUG_ARG)\n+    {\n+      fprintf (stderr, \"\\ninit_cumulative_args (\");\n+      if (fntype)\n+\t{\n+\t  tree ret_type = TREE_TYPE (fntype);\n+\t  fprintf (stderr, \"fntype code = %s, ret code = %s\",\n+\t\t   tree_code_name[ (int)TREE_CODE (fntype) ],\n+\t\t   tree_code_name[ (int)TREE_CODE (ret_type) ]);\n+\t}\n+      else\n+\tfprintf (stderr, \"no fntype\");\n+\n+      if (libname)\n+\tfprintf (stderr, \", libname = %s\", XSTR (libname, 0));\n+    }\n+\n+  *cum = zero_cum;\n+\n+  /* Set up the number of registers to use for passing arguments.  */\n+  cum->nregs = i386_regparm;\n+  if (fntype)\n+    {\n+      tree attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (fntype));\n+      if (attr)\n+\tcum->nregs = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n+    }\n+\n+  /* Determine if this function has variable arguments.  This is\n+     indicated by the last argument being 'void_type_mode' if there\n+     are no variable arguments.  If there are variable arguments, then\n+     we won't pass anything in registers */\n+\n+  if (cum->nregs)\n+    {\n+      for (param = (fntype) ? TYPE_ARG_TYPES (fntype) : 0;\n+\t   param != (tree)0;\n+\t   param = next_param)\n+\t{\n+\t  next_param = TREE_CHAIN (param);\n+\t  if (next_param == (tree)0 && TREE_VALUE (param) != void_type_node)\n+\t    cum->nregs = 0;\n+\t}\n+    }\n+\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr, \", nregs=%d )\\n\", cum->nregs);\n+\n+  return;\n+}\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+void\n+function_arg_advance (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     enum machine_mode mode;\t/* current arg mode */\n+     tree type;\t\t\t/* type of the argument or 0 if lib support */\n+     int named;\t\t\t/* whether or not the argument was named */\n+{\n+  int bytes = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr,\n+\t     \"function_adv( size=%d, words=%2d, nregs=%d, mode=%4s, named=%d )\\n\\n\",\n+\t     words, cum->words, cum->nregs, GET_MODE_NAME (mode), named);\n+\n+  cum->words += words;\n+  cum->nregs -= words;\n+  cum->regno += words;\n+\n+  if (cum->nregs <= 0)\n+    {\n+      cum->nregs = 0;\n+      cum->regno = 0;\n+    }\n+\n+  return;\n+}\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+struct rtx_def *\n+function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     enum machine_mode mode;\t/* current arg mode */\n+     tree type;\t\t\t/* type of the argument or 0 if lib support */\n+     int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n+{\n+  rtx ret   = NULL_RTX;\n+  int bytes = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  switch (mode)\n+    {\n+    default:\t\t\t/* for now, pass fp/complex values on the stack */\n+      break;\n+\n+    case BLKmode:\n+    case DImode:\n+    case SImode:\n+    case HImode:\n+    case QImode:\n+      if (words <= cum->nregs)\n+\tret = gen_rtx (REG, mode, cum->regno);\n+      break;\n+    }\n+\n+  if (TARGET_DEBUG_ARG)\n+    {\n+      fprintf (stderr,\n+\t       \"function_arg( size=%d, words=%2d, nregs=%d, mode=%4s, named=%d\",\n+\t       words, cum->words, cum->nregs, GET_MODE_NAME (mode), named);\n+\n+      if (ret)\n+\tfprintf (stderr, \", reg=%%e%s\", reg_names[ REGNO(ret) ]);\n+      else\n+\tfprintf (stderr, \", stack\");\n+\n+      fprintf (stderr, \" )\\n\");\n+    }\n+\n+  return ret;\n+}\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     enum machine_mode mode;\t/* current arg mode */\n+     tree type;\t\t\t/* type of the argument or 0 if lib support */\n+     int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n+{\n+  return 0;\n+}\n+\n \f\n /* Output an insn whose source is a 386 integer register.  SRC is the\n    rtx for the register, and TEMPLATE is the op-code template.  SRC may\n@@ -1913,6 +2272,7 @@ output_pic_addr_const (file, x, code)\n    * -- print a star (in certain assembler syntax)\n    w -- print the operand as if it's a \"word\" (HImode) even if it isn't.\n    c -- don't print special prefixes before constant operands.\n+   J -- print the appropriate jump operand.\n */\n \n void\n@@ -2009,6 +2369,22 @@ print_operand (file, x, code)\n \tcase 'P':\n \t  break;\n \n+\tcase 'J':\n+\t  switch (GET_CODE (x))\n+\t    {\n+\t    case NE:  fputs (\"jne\", file); return;\n+\t    case EQ:  fputs (\"je\",  file); return;\n+\t    case GE:  fputs (\"jge\", file); return;\n+\t    case GT:  fputs (\"jg\",  file); return;\n+\t    case LE:  fputs (\"jle\", file); return;\n+\t    case LT:  fputs (\"jl\",  file); return;\n+\t    case GEU: fputs (\"jae\", file); return;\n+\t    case GTU: fputs (\"ja\",  file); return;\n+\t    case LEU: fputs (\"jbe\", file); return;\n+\t    case LTU: fputs (\"jb\",  file); return;\n+\t    }\n+\t  abort ();\n+\n \tdefault:\n \t  {\n \t    char str[50];"}, {"sha": "f9e7ac4612f747dc52482570c06e3f53b6b0d3ec", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 104, "deletions": 58, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -66,9 +66,9 @@ extern int target_flags;\n /* Masks for the -m switches */\n #define MASK_80387\t\t000000000001\t/* Hardware floating point */\n #define MASK_486\t\t000000000002\t/* 80486 specific */\n-#define MASK_NOTUSED\t\t000000000004\t/* bit not currently used */\n+#define MASK_NOTUSED1\t\t000000000004\t/* bit not currently used */\n #define MASK_RTD\t\t000000000010\t/* Use ret that pops args */\n-#define MASK_REGPARM\t\t000000000020\t/* Pass args in eax, edx */\n+#define MASK_ALIGN_DOUBLE\t000000000020\t/* align doubles to 2 word boundary */\n #define MASK_SVR3_SHLIB\t\t000000000040\t/* Uninit locals into bss */\n #define MASK_IEEE_FP\t\t000000000100\t/* IEEE fp comparisons */\n #define MASK_FLOAT_RETURNS\t000000000200\t/* Return float in st(0) */\n@@ -78,6 +78,7 @@ extern int target_flags;\n #define MASK_DEBUG_ADDR\t\t000001000000\t/* Debug GO_IF_LEGITIMATE_ADDRESS */\n #define MASK_NO_WIDE_MULTIPLY\t000002000000\t/* Disable 32x32->64 multiplies */\n #define MASK_NO_MOVE\t\t000004000000\t/* Don't generate mem->mem */\n+#define MASK_DEBUG_ARG\t\t000010000000\t/* Debug function_arg */   \n \n /* Use the floating point instructions */\n #define TARGET_80387 (target_flags & MASK_80387)\n@@ -87,11 +88,10 @@ extern int target_flags;\n    for all functions that can take varying numbers of args.  */  \n #define TARGET_RTD (target_flags & MASK_RTD)\n \n-/* Compile passing first two args in regs 0 and 1.\n-   This exists only to test compiler features that will\n-   be needed for RISC chips.  It is not usable\n-   and is not intended to be usable on this cpu.  */\n-#define TARGET_REGPARM (target_flags & MASK_RTD)\n+/* Align doubles to a two word boundary.  This breaks compatibility with\n+   the published ABI's for structures containing doubles, but produces\n+   faster code on the pentium.  */\n+#define TARGET_ALIGN_DOUBLE (target_flags & MASK_ALIGN_DOUBLE)\n \n /* Put uninitialized locals into bss, not data.\n    Meaningful only on svr3.  */\n@@ -121,6 +121,9 @@ extern int target_flags;\n /* Debug GO_IF_LEGITIMATE_ADDRESS */\n #define TARGET_DEBUG_ADDR (target_flags & MASK_DEBUG_ADDR)\n \n+/* Debug FUNCTION_ARG macros */\n+#define TARGET_DEBUG_ARG (target_flags & MASK_DEBUG_ARG)\n+\n /* Hack macros for tuning code generation */\n #define TARGET_MOVE\t((target_flags & MASK_NO_MOVE) == 0)\t/* Don't generate memory->memory */\n \n@@ -140,8 +143,8 @@ extern int target_flags;\n   { \"no-486\",\t\t\t-MASK_486 },\t\t\t\t\\\n   { \"rtd\",\t\t\t MASK_RTD },\t\t\t\t\\\n   { \"no-rtd\",\t\t\t-MASK_RTD },\t\t\t\t\\\n-  { \"regparm\",\t\t\t MASK_REGPARM },\t\t\t\\\n-  { \"no-regparm\",\t\t-MASK_REGPARM },\t\t\t\\\n+  { \"align-double\",\t\t MASK_ALIGN_DOUBLE },\t\t\t\\\n+  { \"no-align-double\",\t\t-MASK_ALIGN_DOUBLE },\t\t\t\\\n   { \"svr3-shlib\",\t\t MASK_SVR3_SHLIB },\t\t\t\\\n   { \"no-svr3-shlib\",\t\t-MASK_SVR3_SHLIB },\t\t\t\\\n   { \"ieee-fp\",\t\t\t MASK_IEEE_FP },\t\t\t\\\n@@ -156,6 +159,8 @@ extern int target_flags;\n   { \"no-debug-addr\",\t\t-MASK_DEBUG_ADDR },\t\t\t\\\n   { \"move\",\t\t\t-MASK_NO_MOVE },\t\t\t\\\n   { \"no-move\",\t\t\t MASK_NO_MOVE },\t\t\t\\\n+  { \"debug-arg\",\t\t MASK_DEBUG_ARG },\t\t\t\\\n+  { \"no-debug-arg\",\t\t-MASK_DEBUG_ARG },\t\t\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n   { \"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT}}\n \n@@ -169,8 +174,13 @@ extern int target_flags;\n    option if the fixed part matches.  The actual option name is made\n    by appending `-m' to the specified name.  */\n #define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n-{ { \"reg-alloc=\", &i386_reg_alloc_order },\t\t\t\t\\\n-  SUBTARGET_OPTIONS }\n+{ { \"reg-alloc=\",\t&i386_reg_alloc_order },\t\t\t\\\n+  { \"regparm=\",\t\t&i386_regparm_string },\t\t\t\t\\\n+  { \"align-loops=\",\t&i386_align_loops_string },\t\t\t\\\n+  { \"align-jumps=\",\t&i386_align_jumps_string },\t\t\t\\\n+  { \"align-functions=\",\t&i386_align_funcs_string },\t\t\t\\\n+  SUBTARGET_OPTIONS\t\t\t\t\t\t\t\\\n+}\n \n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -238,7 +248,7 @@ extern int target_flags;\n /* Allocation boundary (in *bits*) for the code of a function.\n    For i486, we get better performance by aligning to a cache\n    line (i.e. 16 byte) boundary.  */\n-#define FUNCTION_BOUNDARY (TARGET_486 ? 128 : 32)\n+#define FUNCTION_BOUNDARY (1 << (i386_align_funcs + 3))\n \n /* Alignment of field after `int : 0' in a structure. */\n \n@@ -248,8 +258,11 @@ extern int target_flags;\n    and all fundamental data types supported by the hardware\n    might need to be aligned. No data type wants to be aligned\n    rounder than this.  The i386 supports 64-bit floating point\n-   quantities, but these can be aligned on any 32-bit boundary.  */\n-#define BIGGEST_ALIGNMENT 32\n+   quantities, but these can be aligned on any 32-bit boundary.\n+   The published ABIs say that doubles should be aligned on word\n+   boundaries, but the Pentium gets better performance with them\n+   aligned on 64 bit boundaries. */\n+#define BIGGEST_ALIGNMENT (TARGET_ALIGN_DOUBLE ? 64 : 32)\n \n /* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n@@ -260,15 +273,17 @@ extern int target_flags;\n /* Required on the 386 since it doesn't have bitfield insns.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n+/* Maximum power of 2 that code can be aligned to.  */\n+#define MAX_CODE_ALIGN\t6\t\t\t/* 64 byte alignment */\n+\n /* Align loop starts for optimal branching.  */\n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-  ASM_OUTPUT_ALIGN (FILE, 2)\n+#define ASM_OUTPUT_LOOP_ALIGN(FILE) ASM_OUTPUT_ALIGN (FILE, i386_align_loops)\n \n /* This is how to align an instruction for optimal branching.\n    On i486 we'll get better performance by aligning on a\n    cache line (i.e. 16 byte) boundary.  */\n-#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n-  ASM_OUTPUT_ALIGN ((FILE), (TARGET_486 ? 4 : 2))\n+#define ASM_OUTPUT_ALIGN_CODE(FILE) ASM_OUTPUT_ALIGN ((FILE), i386_align_jumps)\n+\n \f\n /* Standard register usage.  */\n \n@@ -762,15 +777,12 @@ enum reg_class\n      because the library is compiled with the Unix compiler.\n    Use of RTD is a selectable option, since it is incompatible with\n    standard Unix calling sequences.  If the option is not selected,\n-   the caller must always pop the args.  */\n+   the caller must always pop the args.\n+\n+   The attribute stdcall is equivalent to RTD on a per module basis.  */\n \n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)   \\\n-  (TREE_CODE (FUNTYPE) == IDENTIFIER_NODE ? 0\t\t\t\\\n-   : (TARGET_RTD\t\t\t\t\t\t\\\n-      && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n-\t  || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n-\t      == void_type_node))) ? (SIZE)\t\t\t\\\n-   : (aggregate_value_p (TREE_TYPE (FUNTYPE))) ? GET_MODE_SIZE (Pmode) : 0)\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n+  (i386_return_pops_args (FUNDECL, FUNTYPE, SIZE))\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -792,41 +804,34 @@ enum reg_class\n \n #define APPLY_RESULT_SIZE (8+108)\n \n-/* 1 if N is a possible register number for function argument passing.\n-   On the 80386, no registers are used in this way.\n-      *NOTE* -mregparm does not work.\n-   It exists only to test register calling conventions.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n+/* 1 if N is a possible register number for function argument passing.  */\n+#define FUNCTION_ARG_REGNO_P(N) ((N) >= 0 && (N) < REGPARM_MAX)\n \n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n    and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n \n-   On the 80386, this is a single integer, which is a number of bytes\n-   of arguments scanned so far.  */\n-\n-#define CUMULATIVE_ARGS int\n+typedef struct i386_args {\n+  int words;\t\t\t/* # words passed so far */\n+  int nregs;\t\t\t/* # registers available for passing */\n+  int regno;\t\t\t/* next available register number */\n+} CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On the 80386, the offset starts at 0.  */\n+   For a library call, FNTYPE is 0.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n- ((CUM) = 0)\n+  (init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+  (function_arg_advance (&CUM, MODE, TYPE, NAMED))\n \n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n@@ -841,26 +846,15 @@ enum reg_class\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-\n-/* On the 80386 all args are pushed, except if -mregparm is specified\n-   then the first two words of arguments are passed in EAX, EDX.\n-   *NOTE* -mregparm does not work.\n-   It exists only to test register calling conventions.  */\n-\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8) ? gen_rtx (REG, (MODE), (CUM) / 4) : 0)\n+  (function_arg (&CUM, MODE, TYPE, NAMED))\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n-\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n-  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n-\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n-\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n- ? 2 - (CUM) / 4 : 0)\n+  (function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED))\n \n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n@@ -1313,6 +1307,41 @@ do\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n+\f\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRTRIBUTES, NAME, ARGS) \\\n+  (i386_valid_decl_attribute_p (DECL, ATTRTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+\n+#define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRTRIBUTES, NAME, ARGS) \\\n+  (i386_valid_type_attribute_p (TYPE, ATTRTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is zero if the attributes on\n+   TYPE1 and TYPE2 are incompatible, one if they are compatible, and\n+   two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+  (i386_comp_type_attributes (TYPE1, TYPE2))\n+\n+/* If defined, a C statement that assigns default attributes to newly\n+   defined TYPE.  */\n+\n+/* #define SET_DEFAULT_TYPE_ATTRIBUTES (TYPE) */\n+\n+/* Max number of args passed in registers.  If this is more than 3, we will\n+   have problems with ebx (register #4), since it is a caller save register and\n+   is also used as the pic register in ELF.  So for now, don't allow more than\n+   3 registers to be passed in registers.  */\n+\n+#define REGPARM_MAX 3\n+\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n@@ -1384,7 +1413,8 @@ while (0)\n /* Define this if addresses of constant functions\n    shouldn't be put through pseudo regs where they can be cse'd.\n    Desirable on the 386 because a CALL with a constant address is\n-   not much slower than one with a register address.  */\n+   not much slower than one with a register address.  On a 486,\n+   it is faster to call with a constant address than indirect.  */\n #define NO_FUNCTION_CSE\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n@@ -1828,6 +1858,14 @@ extern char *qi_high_reg_name[];\n /* Functions in i386.c */\n extern void override_options ();\n extern void order_regs_for_local_alloc ();\n+extern int i386_valid_decl_attribute_p ();\n+extern int i386_valid_type_attribute_p ();\n+extern int i386_return_pops_args ();\n+extern int i386_comp_type_attributes ();\n+extern void init_cumulative_args ();\n+extern void function_arg_advance ();\n+extern struct rtx_def *function_arg ();\n+extern int function_arg_partial_nregs ();\n extern void output_op_from_reg ();\n extern void output_to_reg ();\n extern char *singlemove_string ();\n@@ -1865,6 +1903,14 @@ extern struct rtx_def *assign_386_stack_local ();\n \n /* Variables in i386.c */\n extern char *i386_reg_alloc_order;\t\t/* register allocation order */\n+extern char *i386_regparm_string;\t\t/* # registers to use to pass args */\n+extern char *i386_align_loops_string;\t\t/* power of two alignment for loops */\n+extern char *i386_align_jumps_string;\t\t/* power of two alignment for non-loop jumps */\n+extern char *i386_align_funcs_string;\t\t/* power of two alignment for functions */\n+extern int i386_regparm;\t\t\t/* i386_regparm_string as a number */\n+extern int i386_align_loops;\t\t\t/* power of two alignment for loops */\n+extern int i386_align_jumps;\t\t\t/* power of two alignment for non-loop jumps */\n+extern int i386_align_funcs;\t\t\t/* power of two alignment for functions */\n extern char *hi_reg_name[];\t\t\t/* names for 16 bit regs */\n extern char *qi_reg_name[];\t\t\t/* names for 8 bit regs (low) */\n extern char *qi_high_reg_name[];\t\t/* names for 8 bit regs (high) */"}, {"sha": "2dfc35adcb2e2e43ce383bac6fe570bb111954cd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -38,14 +38,15 @@\n ;; 'B' Print the opcode suffix for an 8-bit integer opcode.\n ;; 'S' Print the opcode suffix for a 32-bit float opcode.\n ;; 'Q' Print the opcode suffix for a 64-bit float opcode.\n+;; 'T' Print the opcode suffix for an 80-bit extended real XFmode float opcode.\n+;; 'J' Print the appropriate jump operand.\n \n ;; 'b' Print the QImode name of the register for the indicated operand.\n ;;     %b0 would print %al if operands[0] is reg 0.\n ;; 'w' Likewise, print the HImode name of the register.\n ;; 'k' Likewise, print the SImode name of the register.\n ;; 'h' Print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n ;; 'y' Print \"st(0)\" instead of \"st\" as a register.\n-;; 'T' Print the opcode suffix for an 80-bit extended real XFmode float opcode.\n \n ;; UNSPEC usage:\n ;; 0  This is a `scas' operation.  The mode of the UNSPEC is always SImode.\n@@ -4908,6 +4909,73 @@\n   return AS1 (jmp,%*%0);\n }\")\n \n+(define_expand \"decrement_and_branch_until_zero\"\n+  [(parallel [(set (pc)\n+\t\t   (if_then_else (ge (plus:SI (match_operand:SI 0 \"general_operand\" \"\")\n+\t\t\t\t\t      (const_int -1))\n+\t\t\t\t     (const_int 0))\n+\t\t\t\t (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t\t (pc)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (const_int -1)))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(plus:SI (match_operand:SI 1 \"general_operand\" \"+r,m\")\n+\t\t\t\t\t\t(match_operand:SI 2 \"general_operand\" \"rmi,ri\"))\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (operands[2] == constm1_rtx)\n+    output_asm_insn (AS1 (dec%L1,%1), operands);\n+\n+  else if (operands[1] == const1_rtx)\n+    output_asm_insn (AS1 (inc%L1,%1), operands);\n+\n+  else\n+    output_asm_insn (AS2 (add%L1,%2,%1), operands);\n+\n+  return AS1 (%J0,%l3);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(minus:SI (match_operand:SI 1 \"general_operand\" \"+r,m\")\n+\t\t\t\t\t\t (match_operand:SI 2 \"general_operand\" \"rmi,ri\"))\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 1)\n+\t(minus:SI (match_dup 1)\n+\t\t  (match_dup 2)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (operands[2] == const1_rtx)\n+    output_asm_insn (AS1 (dec%L1,%1), operands);\n+\n+  else if (operands[1] == constm1_rtx)\n+    output_asm_insn (AS1 (inc%L1,%1), operands);\n+\n+  else\n+    output_asm_insn (AS2 (sub%L1,%2,%1), operands);\n+\n+  return AS1 (%J0,%l3);\n+}\")\n+\n ;; Implement switch statements when generating PIC code.  Switches are\n ;; implemented by `tablejump' when not using -fpic.\n "}, {"sha": "fa2040c239d638d26e2144df530ed6300a83328b", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -411,7 +411,7 @@ while (0)\n #undef\tASM_OUTPUT_ALIGN_CODE\n #define ASM_OUTPUT_ALIGN_CODE(STREAM)\t\t\t\t\t\\\n   fprintf (STREAM, \"\\t.align\\t%d\\n\",\t\t\t\t\t\\\n-\t   (TARGET_486 && TARGET_LARGE_ALIGN) ? 4 : 2)\n+\t   (!TARGET_LARGE_ALIGN && i386_align_jumps > 2) ? 2 : i386_align_jumps)\n \n /* A C expression to output text to align the location counter in the\n    way that is desirable at the beginning of a loop.\n@@ -422,7 +422,7 @@ while (0)\n \n #undef\tASM_OUTPUT_LOOP_ALIGN\n #define ASM_OUTPUT_LOOP_ALIGN(STREAM) \\\n-  fprintf (STREAM, \"\\t.align\\t2\\n\")\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\", i386_align_loops)\n \n /* A C statement to output to the stdio stream STREAM an assembler\n    command to advance the location counter to a multiple of 2 to the"}, {"sha": "6c8016d391f2cfa3157276fb0743cf7a60e0f506", "filename": "gcc/config/i386/svr3dbx.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -48,13 +48,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef ASM_OUTPUT_ALIGN_CODE\n #define ASM_OUTPUT_ALIGN_CODE(FILE)\t\t\t\\\n      fprintf ((FILE), \"\\t.align %d,0x90\\n\",\t\t\\\n-\t      TARGET_486 ? 16 : 4);  /* Use log of 16 or log of 4 as arg.  */\n+\t      1 << i386_align_jumps)\n \n /* Align start of loop at 4-byte boundary.  */\n \n #undef ASM_OUTPUT_LOOP_ALIGN\n #define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-     fprintf ((FILE), \"\\t.align 4,0x90\\n\");\n+     fprintf ((FILE), \"\\t.align %d,0x90\\n\", 1 << i386_align_loops);\n \n \n /* Additional overrides needed for dbx-in-coff gas, mostly taken from pbb.h */"}, {"sha": "19ad1d4c94db8d515e38833f5eae43a2bae6cd4a", "filename": "gcc/config/i386/win-nt.h", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08de47ebf98089851079227b3840a7cec3d5503/gcc%2Fconfig%2Fi386%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwin-nt.h?ref=b08de47ebf98089851079227b3840a7cec3d5503", "patch": "@@ -23,49 +23,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */\n \n #include \"i386/gas.h\"\n \n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.\n-\n-   This only happens if the function declaration has the STDCALL attribute and\n-   the number of arguments is not variable */\n-\n-#undef RETURN_POPS_ARGS\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n-  ( \\\n-   TREE_CODE (FUNTYPE) == IDENTIFIER_NODE \\\n-   ? \\\n-     0 \\\n-   : \\\n-     ( \\\n-      ((FUNDECL && (TREE_CODE_CLASS (TREE_CODE (FUNDECL)) == 'd') \\\n-\t? \\\n-          lookup_attribute (\"stdcall\", \\\n-\t\t\t    DECL_MACHINE_ATTRIBUTES (FUNDECL)) != NULL_TREE \\\n-\t: 0 \\\n-       ) \\\n-      ) \\\n-      && \\\n-         ( \\\n-          TYPE_ARG_TYPES (FUNTYPE) == 0 \\\n-          || \\\n-            TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE))) \\\n-            == void_type_node \\\n-         ) \\\n-     ) \\\n-     ? \\\n-       (SIZE) \\\n-     : \\\n-       (aggregate_value_p (TREE_TYPE (FUNTYPE))) \\\n-       ? \\\n-         GET_MODE_SIZE (Pmode) \\\n-       : \\\n-         0 \\\n-  )\n-\n #ifdef CPP_PREDEFINES\n #undef CPP_PREDEFINES\n #endif\n@@ -157,24 +114,13 @@ do\t\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     if (TREE_CODE (DECL) == FUNCTION_DECL) \t\t\t\t\\\n       if (lookup_attribute (\"stdcall\",\t\t\t\t\t\\\n-\t\t\t    DECL_MACHINE_ATTRIBUTES (DECL)))\t\t\\\n+\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (DECL))))\t\\\n         XEXP (DECL_RTL (DECL), 0) = \t\t\t\t\t\\\n           gen_rtx (SYMBOL_REF, Pmode, gen_stdcall_suffix (DECL)); \t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n #endif\n \n-/* Value is 1 if the declaration has either of the attributes: CDECL or\n-   STDCALL and 0 otherwise */\n-\n-#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTR, NAME, ARGS) \\\n-  (((TREE_CODE(DECL) == FUNCTION_DECL) \\\n-    || (TREE_CODE(DECL) == FIELD_DECL) \\\n-    || (TREE_CODE(DECL) == TYPE_DECL)) \\\n-   && (is_attribute_p (\"stdcall\", (NAME)) \\\n-       || is_attribute_p (\"cdecl\", (NAME))) \\\n-   && (ARGS) == NULL)\n-\n /* The global __fltused is necessary to cause the printf/scanf routines\n    for outputting/inputting floating point numbers to be loaded.  Since this\n    is kind of hard to detect, we just do it all the time. */"}]}