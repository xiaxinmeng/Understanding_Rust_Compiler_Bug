{"sha": "8234d02aa47d9cba294b4263e47a336e9c67f5b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzNGQwMmFhNDdkOWNiYTI5NGI0MjYzZTQ3YTMzNmU5YzY3ZjViMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-07-14T11:12:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-07-14T11:12:22Z"}, "message": "decl.c (gnat_to_gnu_entity): Also use the void pointer type if the designated type is incomplete and has no...\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Also use\n\tthe void pointer type if the designated type is incomplete and has no\n\tfull view in LTO mode.\n\t<E_Access_Protected_Subprogram_Type>: Adjust comment.\n\t<E_Incomplete_Type>: Likewise.\n\t* gcc-interface/trans.c (Call_to_gnu): Do not convert to the type of\n\tthe actual if it is a dummy type.\n\nFrom-SVN: r238333", "tree": {"sha": "e287b2e3d8edcae34b5fd6a01c46dd42a2598056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e287b2e3d8edcae34b5fd6a01c46dd42a2598056"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8234d02aa47d9cba294b4263e47a336e9c67f5b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8234d02aa47d9cba294b4263e47a336e9c67f5b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8234d02aa47d9cba294b4263e47a336e9c67f5b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8234d02aa47d9cba294b4263e47a336e9c67f5b1/comments", "author": null, "committer": null, "parents": [{"sha": "0a2bf18874eb2c54202b9890f3b82776b08e55a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2bf18874eb2c54202b9890f3b82776b08e55a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2bf18874eb2c54202b9890f3b82776b08e55a1"}], "stats": {"total": 51, "additions": 36, "deletions": 15}, "files": [{"sha": "54cd2dc6ddad51eb62e054107484bb0f3b2830ba", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234d02aa47d9cba294b4263e47a336e9c67f5b1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234d02aa47d9cba294b4263e47a336e9c67f5b1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8234d02aa47d9cba294b4263e47a336e9c67f5b1", "patch": "@@ -1,6 +1,15 @@\n+2016-07-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Also use\n+\tthe void pointer type if the designated type is incomplete and has no\n+\tfull view in LTO mode.\n+\t<E_Access_Protected_Subprogram_Type>: Adjust comment.\n+\t<E_Incomplete_Type>: Likewise.\n+\t* gcc-interface/trans.c (Call_to_gnu): Do not convert to the type of\n+\tthe actual if it is a dummy type.\n+\n 2016-07-11  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n-\tConvert TYPE_ALIGN_OK to a TYPE_LANG_FLAG.\n \t* gcc-interface/ada-tree.h (TYPE_ALIGN_OK): Define.\n \t* gcc-interface/trans.c (Attribute_to_gnu): Adjust call to\n \tget_inner_reference."}, {"sha": "3f468b6f5e80f903db9b99bdf9006a7b050c314d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234d02aa47d9cba294b4263e47a336e9c67f5b1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234d02aa47d9cba294b4263e47a336e9c67f5b1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=8234d02aa47d9cba294b4263e47a336e9c67f5b1", "patch": "@@ -3928,10 +3928,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  }\n \n \t/* If expansion is disabled, the equivalent type of a concurrent type\n-\t   is absent, so build a dummy pointer type.  */\n+\t   is absent, so we use the void pointer type.  */\n \telse if (type_annotate_only && No (gnat_desig_equiv))\n \t  gnu_type = ptr_type_node;\n \n+\t/* If the ultimately designated type is an incomplete type with no full\n+\t   view, we use the void pointer type in LTO mode to avoid emitting a\n+\t   dummy type in the GIMPLE IR.  We cannot do that in regular mode as\n+\t   the name of the dummy type in used by GDB for a global lookup.  */\n+\telse if (Ekind (gnat_desig_rep) == E_Incomplete_Type\n+\t\t && No (Full_View (gnat_desig_rep))\n+\t\t && flag_generate_lto)\n+\t  gnu_type = ptr_type_node;\n+\n \t/* Finally, handle the default case where we can just elaborate our\n \t   designated type.  */\n \telse\n@@ -4017,7 +4026,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n     case E_Access_Protected_Subprogram_Type:\n     case E_Anonymous_Access_Protected_Subprogram_Type:\n       /* If we are just annotating types and have no equivalent record type,\n-\t just return ptr_void_type.  */\n+\t just use the void pointer type.  */\n       if (type_annotate_only && gnat_equiv_type == gnat_entity)\n \tgnu_type = ptr_type_node;\n \n@@ -4336,8 +4345,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t: Empty;\n \n \t/* If this is an incomplete type with no full view, it must be a Taft\n-\t   Amendment type, in which case we return a dummy type.  Otherwise,\n-\t   just get the type from its Etype.  */\n+\t   Amendment type or an incomplete type coming from a limited context,\n+\t   in which cases we return a dummy type.  Otherwise, we just get the\n+\t   type from its Etype.  */\n \tif (No (full_view))\n \t  {\n \t    if (kind == E_Incomplete_Type)"}, {"sha": "b5be373a847b1c778b7a4d686f0fd6e0e1e6b657", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234d02aa47d9cba294b4263e47a336e9c67f5b1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234d02aa47d9cba294b4263e47a336e9c67f5b1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=8234d02aa47d9cba294b4263e47a336e9c67f5b1", "patch": "@@ -4374,7 +4374,6 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       Node_Id gnat_name = suppress_type_conversion\n \t\t\t  ? Expression (gnat_actual) : gnat_actual;\n       tree gnu_name = gnat_to_gnu (gnat_name), gnu_name_type;\n-      tree gnu_actual;\n \n       /* If it's possible we may need to use this expression twice, make sure\n \t that any side-effects are handled via SAVE_EXPRs; likewise if we need\n@@ -4504,7 +4503,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t}\n \n       /* Start from the real object and build the actual.  */\n-      gnu_actual = gnu_name;\n+      tree gnu_actual = gnu_name;\n \n       /* If atomic access is required for an In or In Out actual parameter,\n \t build the atomic load.  */\n@@ -4524,15 +4523,18 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       /* Put back the conversion we suppressed above in the computation of the\n \t real object.  And even if we didn't suppress any conversion there, we\n \t may have suppressed a conversion to the Etype of the actual earlier,\n-\t since the parent is a procedure call, so put it back here.  */\n-      if (suppress_type_conversion\n-\t  && Nkind (gnat_actual) == N_Unchecked_Type_Conversion)\n-\tgnu_actual\n-\t  = unchecked_convert (gnat_to_gnu_type (Etype (gnat_actual)),\n-\t\t\t       gnu_actual, No_Truncation (gnat_actual));\n+\t since the parent is a procedure call, so put it back here.  Note that\n+\t we might have a dummy type here if the actual is the dereference of a\n+\t pointer to it, but that's OK if the formal is passed by reference.  */\n+      tree gnu_actual_type = gnat_to_gnu_type (Etype (gnat_actual));\n+      if (TYPE_IS_DUMMY_P (gnu_actual_type))\n+\tgcc_assert (is_true_formal_parm && DECL_BY_REF_P (gnu_formal));\n+      else if (suppress_type_conversion\n+\t       && Nkind (gnat_actual) == N_Unchecked_Type_Conversion)\n+\tgnu_actual = unchecked_convert (gnu_actual_type, gnu_actual,\n+\t\t\t\t        No_Truncation (gnat_actual));\n       else\n-\tgnu_actual\n-\t  = convert (gnat_to_gnu_type (Etype (gnat_actual)), gnu_actual);\n+\tgnu_actual = convert (gnu_actual_type, gnu_actual);\n \n       /* Make sure that the actual is in range of the formal's type.  */\n       if (Ekind (gnat_formal) != E_Out_Parameter"}]}