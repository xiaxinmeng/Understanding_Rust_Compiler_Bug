{"sha": "333e4f86e84ad505c372908d169c11032ba5641d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMzZTRmODZlODRhZDUwNWMzNzI5MDhkMTY5YzExMDMyYmE1NjQxZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T13:35:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T13:35:50Z"}, "message": "[multiple changes]\n\n2017-09-08  Bob Duff  <duff@adacore.com>\n\n\t* par-prag.adb, sem_prag.adb, snames.ads-tmpl: Implement pragma\n\tAda_2020, along the same lines as the other Ada version pragmas.\n\n2017-09-08  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch12.adb: Minor typo fixes and reformatting.\n\n2017-09-08  Yannick Moy  <moy@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Record_Aggregate):\n\tRewrite bounds of aggregate subexpressions which may depend on\n\tdiscriminants of the enclosing aggregate.\n\n2017-09-08  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch5.adb: Prevent assertion failure on illegal code.\n\n2017-09-08  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref-spark_specific.adb (Add_SPARK_Xrefs.Is_SPARK_Scope): Avoid\n\tcalling Renamed_Entity on an entity which cannot be a renaming.\n\n2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_aggr.adb: Add with & use clause for Urealp.\n\t(Aggr_Assignment_OK_For_Backend): Accept (almost all)\n\telementary types instead of just discrete types.\n\t* sem_eval.adb (Expr_Value): Deal with N_Null for access types.\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>:\n\tBe prepared for the FP zero value in the memset case.  Add small\n\tguard.\n\n2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* s-htable.adb (Static_HTable.Reset): Use aggregate instead\n\tof loop.\n\nFrom-SVN: r251894", "tree": {"sha": "c249290412ef76c234e19d98fee12915989bdcb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c249290412ef76c234e19d98fee12915989bdcb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/333e4f86e84ad505c372908d169c11032ba5641d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/333e4f86e84ad505c372908d169c11032ba5641d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/333e4f86e84ad505c372908d169c11032ba5641d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/333e4f86e84ad505c372908d169c11032ba5641d/comments", "author": null, "committer": null, "parents": [{"sha": "683af98c7f55ab61e4764a97b749ef00fc9dfedd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683af98c7f55ab61e4764a97b749ef00fc9dfedd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683af98c7f55ab61e4764a97b749ef00fc9dfedd"}], "stats": {"total": 265, "additions": 232, "deletions": 33}, "files": [{"sha": "784d87936dd0765ec63941fd6484d7168e6e6e53", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -1,3 +1,42 @@\n+2017-09-08  Bob Duff  <duff@adacore.com>\n+\n+\t* par-prag.adb, sem_prag.adb, snames.ads-tmpl: Implement pragma\n+\tAda_2020, along the same lines as the other Ada version pragmas.\n+\n+2017-09-08  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch12.adb: Minor typo fixes and reformatting.\n+\n+2017-09-08  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Record_Aggregate):\n+\tRewrite bounds of aggregate subexpressions which may depend on\n+\tdiscriminants of the enclosing aggregate.\n+\n+2017-09-08  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch5.adb: Prevent assertion failure on illegal code.\n+\n+2017-09-08  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb (Add_SPARK_Xrefs.Is_SPARK_Scope): Avoid\n+\tcalling Renamed_Entity on an entity which cannot be a renaming.\n+\n+2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_aggr.adb: Add with & use clause for Urealp.\n+\t(Aggr_Assignment_OK_For_Backend): Accept (almost all)\n+\telementary types instead of just discrete types.\n+\t* sem_eval.adb (Expr_Value): Deal with N_Null for access types.\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>:\n+\tBe prepared for the FP zero value in the memset case.  Add small\n+\tguard.\n+\n+2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* s-htable.adb (Static_HTable.Reset): Use aggregate instead\n+\tof loop.\n+\n 2017-09-08  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_aggr.adb (Expand_Array_Aggregate): Use New_Copy_Tree instead"}, {"sha": "04fa866b73b4d08cbd0e484ffd4736d7dc5502d8", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -61,6 +61,7 @@ with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n+with Urealp;   use Urealp;\n \n package body Exp_Aggr is\n \n@@ -4894,7 +4895,7 @@ package body Exp_Aggr is\n       --    4. The array type has no null ranges (the purpose of this is to\n       --       avoid a bogus warning for an out-of-range value).\n \n-      --    5. The component type is discrete\n+      --    5. The component type is elementary\n \n       --    6. The component size is Storage_Unit or the value is of the form\n       --       M * (1 + A**1 + A**2 + .. A**(K-1)) where A = 2**(Storage_Unit)\n@@ -4970,7 +4971,13 @@ package body Exp_Aggr is\n             return False;\n          end if;\n \n-         if not Is_Discrete_Type (Ctyp) then\n+         --  All elementary types are supported except for fat pointers\n+         --  because they are not really elementary for the backend.\n+\n+         if not Is_Elementary_Type (Ctyp)\n+           or else (Is_Access_Type (Ctyp)\n+                     and then Esize (Ctyp) /= System_Address_Size)\n+         then\n             return False;\n          end if;\n \n@@ -4990,6 +4997,14 @@ package body Exp_Aggr is\n             return False;\n          end if;\n \n+         --  The only supported value for floating point is 0.0\n+\n+         if Is_Floating_Point_Type (Ctyp) then\n+            return Expr_Value_R (Expr) = Ureal_0;\n+         end if;\n+\n+         --  For other types, we can look into the value as an integer\n+\n          Value := Expr_Value (Expr);\n \n          if Has_Biased_Representation (Ctyp) then"}, {"sha": "8eff9c3c0980a89d82ac68b1877f22b8f763c4aa", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -7037,14 +7037,17 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  /* Or else, use memset when the conditions are met.  */\n \t  else if (use_memset_p)\n \t    {\n-\t      tree value = fold_convert (integer_type_node, gnu_rhs);\n+\t      tree value\n+\t\t= real_zerop (gnu_rhs)\n+\t\t  ? integer_zero_node\n+\t\t  : fold_convert (integer_type_node, gnu_rhs);\n \t      tree to = gnu_lhs;\n \t      tree type = TREE_TYPE (to);\n \t      tree size\n \t        = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (type), to);\n \t      tree to_ptr = build_fold_addr_expr (to);\n \t      tree t = builtin_decl_explicit (BUILT_IN_MEMSET);\n-\t      if (TREE_CODE (value) == INTEGER_CST)\n+\t      if (TREE_CODE (value) == INTEGER_CST && !integer_zerop (value))\n \t\t{\n \t\t  tree mask\n \t\t    = build_int_cst (integer_type_node,"}, {"sha": "8cb262872ef6fd1351fec92ebe3e00894ca20dd8", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -538,10 +538,14 @@ package body SPARK_Specific is\n       --------------------\n \n       function Is_SPARK_Scope (E : Entity_Id) return Boolean is\n+         Can_Be_Renamed : constant Boolean :=\n+           Present (E)\n+             and then (Is_Subprogram_Or_Entry (E)\n+                        or else Ekind (E) = E_Package);\n       begin\n          return Present (E)\n            and then not Is_Generic_Unit (E)\n-           and then Renamed_Entity (E) = Empty\n+           and then (not Can_Be_Renamed or else Renamed_Entity (E) = Empty)\n            and then Get_Scope_Num (E) /= No_Scope;\n       end Is_SPARK_Scope;\n "}, {"sha": "5ea129ad0b7dcf804ffdccdeb2c0dfbd97ad207f", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -326,14 +326,16 @@ begin\n \n    case Prag_Id is\n \n+      --  Ada version pragmas must be processed at parse time, because we want\n+      --  to set the Ada version properly at parse time to recognize the\n+      --  appropriate Ada version syntax. However, pragma Ada_2005 and higher\n+      --  have an optional argument; it is only the zero argument form that\n+      --  must be processed at parse time.\n+\n       ------------\n       -- Ada_83 --\n       ------------\n \n-      --  This pragma must be processed at parse time, since we want to set\n-      --  the Ada version properly at parse time to recognize the appropriate\n-      --  Ada version syntax.\n-\n       when Pragma_Ada_83 =>\n          if not Latest_Ada_Only then\n             Ada_Version := Ada_83;\n@@ -345,10 +347,6 @@ begin\n       -- Ada_95 --\n       ------------\n \n-      --  This pragma must be processed at parse time, since we want to set\n-      --  the Ada version properly at parse time to recognize the appropriate\n-      --  Ada version syntax.\n-\n       when Pragma_Ada_95 =>\n          if not Latest_Ada_Only then\n             Ada_Version := Ada_95;\n@@ -360,11 +358,6 @@ begin\n       -- Ada_05/Ada_2005 --\n       ---------------------\n \n-      --  These pragmas must be processed at parse time, since we want to set\n-      --  the Ada version properly at parse time to recognize the appropriate\n-      --  Ada version syntax. However, it is only the zero argument form that\n-      --  must be processed at parse time.\n-\n       when Pragma_Ada_05\n          | Pragma_Ada_2005\n       =>\n@@ -378,11 +371,6 @@ begin\n       -- Ada_12/Ada_2012 --\n       ---------------------\n \n-      --  These pragmas must be processed at parse time, since we want to set\n-      --  the Ada version properly at parse time to recognize the appropriate\n-      --  Ada version syntax. However, it is only the zero argument form that\n-      --  must be processed at parse time.\n-\n       when Pragma_Ada_12\n          | Pragma_Ada_2012\n       =>\n@@ -392,6 +380,17 @@ begin\n             Ada_Version_Pragma := Pragma_Node;\n          end if;\n \n+      --------------\n+      -- Ada_2020 --\n+      --------------\n+\n+      when Pragma_Ada_2020 =>\n+         if Arg_Count = 0 then\n+            Ada_Version := Ada_2020;\n+            Ada_Version_Explicit := Ada_2020;\n+            Ada_Version_Pragma := Pragma_Node;\n+         end if;\n+\n       ---------------------------\n       -- Compiler_Unit_Warning --\n       ---------------------------"}, {"sha": "8ad6eafb863a95fd5f3e022b85e59c6face6d244", "filename": "gcc/ada/s-htable.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fs-htable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fs-htable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-htable.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                    Copyright (C) 1995-2016, AdaCore                      --\n+--                    Copyright (C) 1995-2017, AdaCore                      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -171,9 +171,9 @@ package body System.HTable is\n \n       procedure Reset is\n       begin\n-         for J in Table'Range loop\n-            Table (J) := Null_Ptr;\n-         end loop;\n+         --  Use an aggregate for efficient reasons\n+\n+         Table := (others => Null_Ptr);\n       end Reset;\n \n       ---------"}, {"sha": "e02913d50dabc5269a9193397352d6df9d9ee96b", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -3297,6 +3297,12 @@ package body Sem_Aggr is\n       --  Parent pointer of Expr is not set then Expr was produced with a\n       --  New_Copy_Tree or some such.\n \n+      procedure Rewrite_Range (Root_Type : Entity_Id; Rge : Node_Id);\n+      --  Rewrite a range node Rge when its bounds refer to non-stored\n+      --  discriminants from Root_Type, to replace them with the stored\n+      --  discriminant values. This is required in GNATprove mode, and is\n+      --  adopted in all modes to avoid special-casing GNATprove mode.\n+\n       ---------------------\n       -- Add_Association --\n       ---------------------\n@@ -4011,6 +4017,66 @@ package body Sem_Aggr is\n          Add_Association (New_C, New_Expr, New_Assoc_List);\n       end Resolve_Aggr_Expr;\n \n+      -------------------\n+      -- Rewrite_Range --\n+      -------------------\n+\n+      procedure Rewrite_Range (Root_Type : Entity_Id; Rge : Node_Id) is\n+\n+         procedure Rewrite_Bound\n+           (Bound     : Node_Id;\n+            Disc      : Entity_Id;\n+            Expr_Disc : Node_Id);\n+         --  Rewrite a bound of the range Bound, when it is equal to the\n+         --  non-stored discriminant Disc, into the stored discriminant\n+         --  value Expr_Disc.\n+\n+         -------------------\n+         -- Rewrite_Bound --\n+         -------------------\n+\n+         procedure Rewrite_Bound\n+           (Bound     : Node_Id;\n+            Disc      : Entity_Id;\n+            Expr_Disc : Node_Id)\n+         is\n+         begin\n+            if Nkind (Bound) = N_Identifier\n+              and then Entity (Bound) = Disc\n+            then\n+               Rewrite (Bound, New_Copy_Tree (Expr_Disc));\n+            end if;\n+         end Rewrite_Bound;\n+\n+         ---------------------\n+         -- Local Variables --\n+         ---------------------\n+\n+         Low, High : Node_Id;\n+         Disc      : Entity_Id;\n+         Expr_Disc : Elmt_Id;\n+\n+      --  Start of processing for Rewrite_Range\n+\n+      begin\n+         if Has_Discriminants (Root_Type)\n+           and then Nkind (Rge) = N_Range\n+         then\n+            Low := Low_Bound (Rge);\n+            High := High_Bound (Rge);\n+\n+            Disc := First_Discriminant (Root_Type);\n+            Expr_Disc :=\n+              First_Elmt (Stored_Constraint (Etype (N)));\n+            while Present (Disc) loop\n+               Rewrite_Bound (Low, Disc, Node (Expr_Disc));\n+               Rewrite_Bound (High, Disc, Node (Expr_Disc));\n+               Next_Discriminant (Disc);\n+               Next_Elmt (Expr_Disc);\n+            end loop;\n+         end if;\n+      end Rewrite_Range;\n+\n       --  Local variables\n \n       Components : constant Elist_Id := New_Elmt_List;\n@@ -4596,6 +4662,43 @@ package body Sem_Aggr is\n                        New_Scope => Current_Scope,\n                        New_Sloc  => Sloc (N));\n \n+                  --  As the type of the copied default expression may refer\n+                  --  to discriminants of the record type declaration, these\n+                  --  non-stored discriminants need to be rewritten into stored\n+                  --  discriminant values for the aggregate. This is required\n+                  --  in GNATprove mode, and is adopted in all modes to avoid\n+                  --  special-casing GNATprove mode.\n+\n+                  if Is_Array_Type (Etype (Expr)) then\n+                     declare\n+                        --  Root record type whose discriminants may be used\n+                        --  as bounds in range nodes.\n+                        Root_Type : constant Entity_Id := Scope (Component);\n+                        Index     : Node_Id;\n+\n+                     begin\n+                        --  Rewrite the range nodes occurring in the indexes\n+                        --  and their types.\n+\n+                        Index := First_Index (Etype (Expr));\n+                        while Present (Index) loop\n+                           Rewrite_Range (Root_Type, Index);\n+                           Rewrite_Range\n+                             (Root_Type, Scalar_Range (Etype (Index)));\n+                           Next_Index (Index);\n+                        end loop;\n+\n+                        --  Rewrite the range nodes occurring as aggregate\n+                        --  bounds.\n+\n+                        if Nkind (Expr) = N_Aggregate\n+                          and then Present (Aggregate_Bounds (Expr))\n+                        then\n+                           Rewrite_Range (Root_Type, Aggregate_Bounds (Expr));\n+                        end if;\n+                     end;\n+                  end if;\n+\n                   Add_Association\n                     (Component  => Component,\n                      Expr       => Expr,"}, {"sha": "324ba4d0f59e1099e70499abc4651ee833827e9f", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -6421,10 +6421,10 @@ package body Sem_Ch12 is\n                   Formal_P := Next_Entity (E);\n \n                   --  If the instance is within an enclosing instance body\n-                  --  there is no need to vertify the legqlity of current\n-                  --  formsl psckages because they were legal in the generic\n-                  --  body. This optimixation may be applicable elsewhere,\n-                  --  and it also removes spurious errors that may arise with\n+                  --  there is no need to verify the legality of current formal\n+                  --  packages because they were legal in the generic body.\n+                  --  This optimization may be applicable elsewhere, and it\n+                  --  also removes spurious errors that may arise with\n                   --  on-the-fly inlining and confusion between private and\n                   --  full views.\n "}, {"sha": "e72dc4bf7c2295b5fa817e30c2704b534a72283a", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -2513,7 +2513,10 @@ package body Sem_Ch5 is\n                & \"iteration\", Discrete_Subtype_Definition (N),\n                T, Suggest_Static => True);\n \n-         elsif Inside_A_Generic and then Is_Generic_Formal (T) then\n+         elsif Inside_A_Generic\n+           and then Is_Generic_Formal (T)\n+           and then Is_Discrete_Type (T)\n+         then\n             Set_No_Dynamic_Predicate_On_Actual (T);\n          end if;\n       end Check_Predicate_Use;"}, {"sha": "0c6c2ea74725a7664e4360b443b1bfe3433fafd8", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -4199,6 +4199,12 @@ package body Sem_Eval is\n          pragma Assert (Is_Fixed_Point_Type (Underlying_Type (Etype (N))));\n          Val := Corresponding_Integer_Value (N);\n \n+      --  The NULL access value\n+\n+      elsif Kind = N_Null then\n+         pragma Assert (Is_Access_Type (Underlying_Type (Etype (N))));\n+         Val := Uint_0;\n+\n       --  Otherwise must be character literal\n \n       else"}, {"sha": "b1723f16645010fac319e9979fcbe28aab10508d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -11835,7 +11835,7 @@ package body Sem_Prag is\n \n          --  The one argument form is used for managing the transition from Ada\n          --  2005 to Ada 2012 in the run-time library. If an entity is marked\n-         --  as Ada_201 only, then referencing the entity in any pre-Ada_2012\n+         --  as Ada_2012 only, then referencing the entity in any pre-Ada_2012\n          --  mode will generate a warning. In addition, in any pre-Ada_2012\n          --  mode, a preference rule is established which does not choose\n          --  such an entity unless it is unambiguously specified. This avoids\n@@ -11883,6 +11883,28 @@ package body Sem_Prag is\n             end if;\n          end;\n \n+         --------------\n+         -- Ada_2020 --\n+         --------------\n+\n+         --  pragma Ada_2020;\n+\n+         --  Note: this pragma also has some specific processing in Par.Prag\n+         --  because we want to set the Ada 2020 version mode during parsing.\n+\n+         when Pragma_Ada_2020 =>\n+            GNAT_Pragma;\n+\n+            Check_Arg_Count (0);\n+\n+            Check_Valid_Configuration_Pragma;\n+\n+            --  Now set appropriate Ada mode\n+\n+            Ada_Version          := Ada_2020;\n+            Ada_Version_Explicit := Ada_2020;\n+            Ada_Version_Pragma   := N;\n+\n          ----------------------\n          -- All_Calls_Remote --\n          ----------------------\n@@ -29419,6 +29441,7 @@ package body Sem_Prag is\n       Pragma_Ada_2005                       => -1,\n       Pragma_Ada_12                         => -1,\n       Pragma_Ada_2012                       => -1,\n+      Pragma_Ada_2020                       => -1,\n       Pragma_All_Calls_Remote               => -1,\n       Pragma_Allow_Integer_Address          => -1,\n       Pragma_Annotate                       => 93,"}, {"sha": "717225d846dda9fc49f9b5c6bda34162822148eb", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e4f86e84ad505c372908d169c11032ba5641d/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=333e4f86e84ad505c372908d169c11032ba5641d", "patch": "@@ -388,6 +388,7 @@ package Snames is\n    Name_Ada_2005                       : constant Name_Id := N + $; -- GNAT\n    Name_Ada_12                         : constant Name_Id := N + $; -- GNAT\n    Name_Ada_2012                       : constant Name_Id := N + $; -- GNAT\n+   Name_Ada_2020                       : constant Name_Id := N + $; -- GNAT\n    Name_Allow_Integer_Address          : constant Name_Id := N + $; -- GNAT\n    Name_Annotate                       : constant Name_Id := N + $; -- GNAT\n    Name_Assertion_Policy               : constant Name_Id := N + $; -- Ada 05\n@@ -1779,6 +1780,9 @@ package Snames is\n       Pragma_Ada_2005,\n       Pragma_Ada_12,\n       Pragma_Ada_2012,\n+      Pragma_Ada_2020,\n+      --  Note that there is no Pragma_Ada_20. Pragma_Ada_05/12 are for\n+      --  compatibility reasons only; the full year names are preferred.\n       Pragma_Allow_Integer_Address,\n       Pragma_Annotate,\n       Pragma_Assertion_Policy,"}]}