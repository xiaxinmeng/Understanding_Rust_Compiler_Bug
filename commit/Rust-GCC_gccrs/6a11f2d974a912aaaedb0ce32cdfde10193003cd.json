{"sha": "6a11f2d974a912aaaedb0ce32cdfde10193003cd", "node_id": "C_kwDOANBUbNoAKDZhMTFmMmQ5NzRhOTEyYWFhZWRiMGNlMzJjZGZkZTEwMTkzMDAzY2Q", "commit": {"author": {"name": "Immad Mir", "email": "mirimmad@outlook.com", "date": "2022-08-02T16:52:07Z"}, "committer": {"name": "Immad Mir", "email": "mirimmad@outlook.com", "date": "2022-08-02T16:52:15Z"}, "message": "analyzer: support for creat, dup, dup2 and dup3 [PR106298]\n\nThis patch extends the state machine in sm-fd.cc to support\ncreat, dup, dup2 and dup3 functions.\n\nLightly tested on x86_64 Linux.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106298\n\t* sm-fd.cc (fd_state_machine::on_open): Add\n\tcreat, dup, dup2 and dup3 functions.\n\t(enum dup): New.\n\t(fd_state_machine::valid_to_unchecked_state): New.\n\t(fd_state_machine::on_creat): New.\n\t(fd_state_machine::on_dup): New.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106298\n\t* gcc.dg/analyzer/fd-1.c: Add tests for 'creat'.\n\t* gcc.dg/analyzer/fd-2.c: Likewise.\n\t* gcc.dg/analyzer/fd-4.c: Likewise.\n\t* gcc.dg/analyzer/fd-dup-1.c: New tests.\n\nSigned-off-by: Immad Mir <mirimmad@outlook.com>", "tree": {"sha": "aeb512c5b76658f4de9179ad134feebe59a17526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeb512c5b76658f4de9179ad134feebe59a17526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a11f2d974a912aaaedb0ce32cdfde10193003cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a11f2d974a912aaaedb0ce32cdfde10193003cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a11f2d974a912aaaedb0ce32cdfde10193003cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a11f2d974a912aaaedb0ce32cdfde10193003cd/comments", "author": null, "committer": null, "parents": [{"sha": "6d41f7c39cff9fb5ccce8e60b6de1679a1dc092a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d41f7c39cff9fb5ccce8e60b6de1679a1dc092a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d41f7c39cff9fb5ccce8e60b6de1679a1dc092a"}], "stats": {"total": 419, "additions": 415, "deletions": 4}, "files": [{"sha": "8bb76d72b0505489551233dab3ae8f168b5ca056", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 126, "deletions": 3, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=6a11f2d974a912aaaedb0ce32cdfde10193003cd", "patch": "@@ -69,6 +69,14 @@ enum access_directions\n   DIRS_WRITE\n };\n \n+/* An enum for distinguishing between dup, dup2 and dup3.  */\n+enum dup\n+{\n+  DUP_1,\n+  DUP_2,\n+  DUP_3\n+};\n+\n class fd_state_machine : public state_machine\n {\n public:\n@@ -114,7 +122,9 @@ class fd_state_machine : public state_machine\n   bool is_readonly_fd_p (state_t s) const;\n   bool is_writeonly_fd_p (state_t s) const;\n   enum access_mode get_access_mode_from_flag (int flag) const;\n-\n+  /* Function for one-to-one correspondence between valid\n+     and unchecked states.  */\n+  state_t valid_to_unchecked_state (state_t state) const;\n   /* State for a constant file descriptor (>= 0) */\n   state_t m_constant_fd;\n \n@@ -147,6 +157,8 @@ class fd_state_machine : public state_machine\n private:\n   void on_open (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n \t\tconst gcall *call) const;\n+  void on_creat (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+\t\tconst gcall *call) const;\n   void on_close (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n \t\t const gcall *call) const;\n   void on_read (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n@@ -170,6 +182,9 @@ class fd_state_machine : public state_machine\n \t\t\t   const gimple *stmt, const gcall *call,\n \t\t\t   const tree callee_fndecl, const char *attr_name,\n \t\t\t   access_directions fd_attr_access_dir) const;\n+  void check_for_dup (sm_context *sm_ctxt, const supernode *node,\n+       const gimple *stmt, const gcall *call, const tree callee_fndecl,\n+       enum dup kind) const;\n };\n \n /* Base diagnostic class relative to fd_state_machine.  */\n@@ -723,6 +738,20 @@ fd_state_machine::is_constant_fd_p (state_t state) const\n   return (state == m_constant_fd);\n }\n \n+fd_state_machine::state_t\n+fd_state_machine::valid_to_unchecked_state (state_t state) const\n+{\n+  if (state == m_valid_read_write)\n+    return m_unchecked_read_write;\n+  else if (state == m_valid_write_only)\n+    return m_unchecked_write_only;\n+  else if (state == m_valid_read_only)\n+    return m_unchecked_read_only;\n+  else\n+    gcc_unreachable ();\n+  return NULL;\n+}\n+\n bool\n fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n \t\t\t   const gimple *stmt) const\n@@ -736,6 +765,11 @@ fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n \t    return true;\n \t  } //  \"open\"\n \n+\tif (is_named_call_p (callee_fndecl, \"creat\", call, 2))\n+\t  {\n+\t    on_creat (sm_ctxt, node, stmt, call);\n+\t  } // \"creat\"\n+\n \tif (is_named_call_p (callee_fndecl, \"close\", call, 1))\n \t  {\n \t    on_close (sm_ctxt, node, stmt, call);\n@@ -754,6 +788,23 @@ fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n \t    return true;\n \t  } // \"read\"\n \n+\tif (is_named_call_p (callee_fndecl, \"dup\", call, 1))\n+\t  {\n+\t    check_for_dup (sm_ctxt, node, stmt, call, callee_fndecl, DUP_1);\n+\t    return true;\n+\t  }\n+\n+\tif (is_named_call_p (callee_fndecl, \"dup2\", call, 2))\n+\t  {\n+\t    check_for_dup (sm_ctxt, node, stmt, call, callee_fndecl, DUP_2);\n+\t    return true;\n+\t  }\n+\n+\tif (is_named_call_p (callee_fndecl, \"dup3\", call, 3))\n+\t  {\n+\t    check_for_dup (sm_ctxt, node, stmt, call, callee_fndecl, DUP_3);\n+\t    return true;\n+\t  }\n \n \t{\n \t  // Handle __attribute__((fd_arg))\n@@ -899,6 +950,78 @@ fd_state_machine::on_open (sm_context *sm_ctxt, const supernode *node,\n     }\n }\n \n+void\n+fd_state_machine::on_creat (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t    const gimple *stmt, const gcall *call) const\n+{\n+  tree lhs = gimple_call_lhs (call);\n+  if (lhs)\n+    sm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked_write_only);\n+  else\n+    sm_ctxt->warn (node, stmt, NULL_TREE, new fd_leak (*this, NULL_TREE));\n+}\n+\n+void\n+fd_state_machine::check_for_dup (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t\t const gimple *stmt, const gcall *call,\n+\t\t\t\t const tree callee_fndecl, enum dup kind) const\n+{\n+  tree lhs = gimple_call_lhs (call);\n+  tree arg_1 = gimple_call_arg (call, 0);\n+  state_t state_arg_1 = sm_ctxt->get_state (stmt, arg_1);\n+  if (state_arg_1 == m_stop)\n+    return;\n+  if (!(is_constant_fd_p (state_arg_1) || is_valid_fd_p (state_arg_1)))\n+    {\n+      check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl,\n+\t\t\t DIRS_READ_WRITE);\n+      if (kind == DUP_1)\n+\treturn;\n+    }\n+  switch (kind)\n+    {\n+    case DUP_1:\n+      if (lhs)\n+\t{\n+\t  if (is_constant_fd_p (state_arg_1))\n+\t    sm_ctxt->set_next_state (stmt, lhs, m_unchecked_read_write);\n+\t  else\n+\t    sm_ctxt->set_next_state (stmt, lhs,\n+\t\t\t\t     valid_to_unchecked_state (state_arg_1));\n+\t}\n+      break;\n+\n+    case DUP_2:\n+    case DUP_3:\n+      tree arg_2 = gimple_call_arg (call, 1);\n+      state_t state_arg_2 = sm_ctxt->get_state (stmt, arg_2);\n+      tree diag_arg_2 = sm_ctxt->get_diagnostic_tree (arg_2);\n+      if (state_arg_2 == m_stop)\n+\treturn;\n+      /* Check if -1 was passed as second argument to dup2.  */\n+      if (!(is_constant_fd_p (state_arg_2) || is_valid_fd_p (state_arg_2)))\n+\t{\n+\t  sm_ctxt->warn (\n+\t      node, stmt, arg_2,\n+\t      new fd_use_without_check (*this, diag_arg_2, callee_fndecl));\n+\t  return;\n+\t}\n+      /* dup2 returns value of its second argument on success.But, the\n+      access mode of the returned file descriptor depends on the duplicated\n+      file descriptor i.e the first argument.  */\n+      if (lhs)\n+\t{\n+\t  if (is_constant_fd_p (state_arg_1))\n+\t    sm_ctxt->set_next_state (stmt, lhs, m_unchecked_read_write);\n+\t  else\n+\t    sm_ctxt->set_next_state (stmt, lhs,\n+\t\t\t\t     valid_to_unchecked_state (state_arg_1));\n+\t}\n+\n+      break;\n+    }\n+}\n+\n void\n fd_state_machine::on_close (sm_context *sm_ctxt, const supernode *node,\n \t\t\t    const gimple *stmt, const gcall *call) const\n@@ -964,6 +1087,8 @@ fd_state_machine::check_for_open_fd (\n \t}\n       switch (callee_fndecl_dir)\n \t{\n+\tcase DIRS_READ_WRITE:\n+\t  break;\n \tcase DIRS_READ:\n \t  if (is_writeonly_fd_p (state))\n \t    {\n@@ -984,8 +1109,6 @@ fd_state_machine::check_for_open_fd (\n \t\t\t\t *this, diag_arg, DIRS_READ, callee_fndecl));\n \t    }\n \t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n \t}\n     }\n }"}, {"sha": "5b85a3316e832864ac9c8d6884b0e1a609b13e55", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-1.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-1.c?ref=6a11f2d974a912aaaedb0ce32cdfde10193003cd", "patch": "@@ -3,6 +3,13 @@ int open(const char *, int mode);\n #define O_WRONLY 1\n #define O_RDWR 2\n \n+typedef enum {\n+  S_IRWXU\n+  // etc\n+} mode_t;\n+\n+int creat (const char *, mode_t mode);\n+\n void\n test_1 (const char *path)\n {\n@@ -37,3 +44,17 @@ void test_4 (const char *path)\n   /* { dg-message \"\\\\(1\\\\) leaks here\" \"\" { target *-*-* } .-1 } */\n }\n \n+void \n+test_5 (const char *path, mode_t mode)\n+{\n+  creat (path, mode); /* { dg-warning \"leak of file descriptor \\\\\\[CWE-775\\\\\\]\" } */\n+}\n+\n+void\n+test_6 (const char *path, mode_t mode)\n+{\n+  int fd = creat (path, mode);\n+  return; /* { dg-warning \"leak of file descriptor 'fd' \\\\\\[CWE-775\\\\\\]\" } */\n+}\n+\n+"}, {"sha": "10c9ecdb09d97873f12ecca6dabefc0b8169ec85", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-2.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-2.c?ref=6a11f2d974a912aaaedb0ce32cdfde10193003cd", "patch": "@@ -5,6 +5,13 @@ void close(int fd);\n #define O_RDWR 2\n #define STDIN 0\n \n+typedef enum {\n+  S_IRWXU\n+  // etc\n+} mode_t;\n+\n+int creat (const char *, mode_t mode);\n+\n void \n test_1 (const char *path)\n {\n@@ -46,4 +53,12 @@ test_4 ()\n     int fd = -1;\n     close(fd);\n     close(fd);\n+}\n+\n+void\n+test_5 (const char *path, mode_t mode)\n+{\n+    int fd = creat (path, mode);\n+    close(fd);\n+    close(fd); /* { dg-warning \"double 'close' of file descriptor 'fd' \\\\\\[CWE-1341\\\\\\]\" \"warning\" } */\n }\n\\ No newline at end of file"}, {"sha": "6b8fca5408fe7a67a5f3f22e31365fb68fd54bf9", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-4.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c?ref=6a11f2d974a912aaaedb0ce32cdfde10193003cd", "patch": "@@ -9,6 +9,12 @@ int read (int fd, void *buf, int nbytes);\n #define O_WRONLY 1\n #define O_RDWR 2\n \n+typedef enum {\n+  S_IRWXU\n+  // etc\n+} mode_t;\n+\n+int creat (const char *, mode_t mode);\n \n void\n test_1 (const char *path, void *buf)\n@@ -69,4 +75,27 @@ test_5 (const char *path)\n     int fd = open (path, O_RDWR);\n     close(fd);\n     printf(\"%d\", fd); /* { dg-bogus \"'printf' on a closed file descriptor 'fd'\" } */\n-}\n\\ No newline at end of file\n+}\n+\n+\n+void\n+test_6 (const char *path, mode_t mode, void *buf)\n+{\n+  int fd = creat (path, mode);\n+  if (fd != -1)\n+  {\n+    read (fd, buf, 1); /* { dg-warning \"'read' on write-only file descriptor 'fd'\" } */\n+    close(fd);\n+  }\n+}\n+\n+void\n+test_7 (const char *path, mode_t mode, void *buf)\n+{\n+  int fd = creat (path, mode);\n+  if (fd != -1)\n+  {\n+    write (fd, buf, 1);\n+    close(fd);\n+  }\n+}"}, {"sha": "eba2570568f390de73a989dfbbfe111815b6323a", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-dup-1.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-dup-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11f2d974a912aaaedb0ce32cdfde10193003cd/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-dup-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-dup-1.c?ref=6a11f2d974a912aaaedb0ce32cdfde10193003cd", "patch": "@@ -0,0 +1,223 @@\n+int open(const char *, int mode);\n+void close(int fd);\n+int dup (int old_fd);\n+int dup2 (int old_fd, int new_fd);\n+int dup3 (int old_fd, int new_fd, int flags);\n+int write (int fd, void *buf, int nbytes);\n+int read (int fd, void *buf, int nbytes);\n+#define O_RDONLY 0\n+#define O_WRONLY 1\n+#define O_RDWR 2\n+\n+void test_1 (const char *path)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    int new_fd = dup (old_fd); /* { dg-warning \"'dup' on possibly invalid file descriptor 'old_fd'\" } */\n+    close(old_fd);\n+    close(new_fd);\n+}\n+\n+void test_2 (const char *path)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    if (old_fd != -1)\n+    {\n+        int new_fd = dup (old_fd); \n+        close(old_fd);\n+        return; /* { dg-warning \"leak of file descriptor 'new_fd' \\\\\\[CWE-775\\\\\\]\" } */\n+    }\n+}\n+\n+void test_3 (const char *path, void *buf)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    if (old_fd != -1)\n+    {\n+        int new_fd = dup (old_fd);\n+        write (new_fd, buf, 1); /* { dg-warning \"'write' on possibly invalid file descriptor 'new_fd'\" } */\n+        close (new_fd);\n+        close(old_fd);\n+    }\n+}\n+\n+\n+void test_5 (const char *path, void *buf)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    if (old_fd != -1)\n+    {\n+        int new_fd = dup (old_fd);\n+        if (new_fd != -1)\n+        {\n+            write (new_fd, buf, 1); \n+            close (new_fd);\n+            \n+        }\n+        close(old_fd);\n+    }\n+}\n+\n+\n+void test_7 (const char *path)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    dup2 (old_fd, 4); /* { dg-warning \"'dup2' on possibly invalid file descriptor 'old_fd'\" } */\n+    close(old_fd);\n+}\n+\n+void test_8 (const char *path)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    int new_fd = open (path, O_RDWR);\n+    if (old_fd != -1)\n+    {\n+        dup2 (old_fd, new_fd); /* { dg-warning \"'dup2' on possibly invalid file descriptor 'new_fd'\" } */\n+        close (old_fd);\n+    }\n+    close (new_fd);\n+}\n+\n+void test_9 (const char *path, void *buf)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    \n+    if (old_fd != -1)\n+    {\n+        int new_fd = open (path, O_RDWR);\n+        if (new_fd != -1)\n+        {\n+            int lhs = dup2 (old_fd, new_fd);\n+            write (lhs, buf, 1); /* { dg-warning \"'write' on possibly invalid file descriptor 'lhs'\" } */\n+            close(new_fd);\n+            close(lhs);\n+    }\n+        close(old_fd);        \n+    }\n+}\n+\n+void test_10 (const char *path, int flags)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    int new_fd = open (path, O_RDWR);\n+    if (old_fd != -1)\n+    {\n+        dup3 (old_fd, new_fd, flags); /* { dg-warning \"'dup3' on possibly invalid file descriptor 'new_fd'\" } */\n+        close(old_fd);\n+        \n+    }\n+    close(new_fd);\n+}\n+\n+void test_11 (const char *path, int flags)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    int new_fd = open (path, O_RDWR);\n+    if (new_fd != -1)\n+    {\n+        dup3 (old_fd, new_fd, flags); /* { dg-warning \"'dup3' on possibly invalid file descriptor 'old_fd'\" } */\n+        close(new_fd);\n+        \n+    }\n+    close(old_fd);\n+}\n+\n+void test_12 (const char *path, void *buf)\n+{\n+    int old_fd = open (path, O_RDONLY);\n+    if (old_fd != -1)\n+    {\n+        int new_fd = dup (old_fd);\n+        if (new_fd != -1)\n+        {\n+            write (new_fd, buf, 1); /* { dg-warning \"'write' on read-only file descriptor 'new_fd'\" } */\n+            close(new_fd);\n+        }\n+        close(old_fd);\n+    }\n+}\n+\n+void test_13 (const char *path, void *buf)\n+{\n+    int old_fd = open (path, O_WRONLY);\n+    if (old_fd != -1)\n+    {\n+        int new_fd = dup (old_fd);\n+        if (new_fd != -1)\n+        {\n+            read (new_fd, buf, 1); /* { dg-warning \"'read' on write-only file descriptor 'new_fd'\" } */\n+            close(new_fd);\n+        }\n+        close(old_fd);\n+    }\n+}\n+\n+void test_14 (const char *path, void *buf)\n+{\n+    int old_fd = open (path, O_RDWR);\n+    if (old_fd != -1)\n+    {\n+        int new_fd = dup (old_fd);\n+        if (new_fd != -1)\n+        {\n+            write (new_fd, buf, 1);\n+            read (new_fd, buf, 1);\n+            close(new_fd);\n+        }\n+        close(old_fd);\n+    }\n+}\n+\n+void test_15 (void *buf)\n+{\n+    int fd = dup(0);\n+    read (fd, buf, 1); /* { dg-warning \"'read' on possibly invalid file descriptor 'fd'\" } */\n+    close(fd);\n+}\n+\n+void test_16 (void *buf)\n+{\n+    int fd = dup(1);\n+    if (fd != -1)\n+    {\n+        write (fd, buf, 1);\n+        close (fd);\n+    }\n+}\n+\n+void test_17 (const char *path)\n+{\n+    int fd = open (path, O_RDWR);\n+    close(fd);\n+    dup (fd); /* { dg-warning \"'dup' on closed file descriptor 'fd'\" }  */\n+    dup2 (fd, 4); /* { dg-warning \"'dup2' on closed file descriptor 'fd'\" }  */\n+}\n+\n+void\n+test_18 (const char *path, void *buf)\n+{\n+    int fd = open (path, O_RDWR);\n+    if (fd != -1)\n+    {\n+        int fd2 = dup2 (fd, 3);\n+        read (fd2, buf, 1); /* { dg-warning \"'read' on possibly invalid file descriptor 'fd2'\" } */\n+        close(fd);\n+        close(fd2);\n+    }\n+}\n+\n+void\n+test_19 (const char *path, void *buf)\n+{\n+    int fd = open (path, O_WRONLY);\n+    if (fd != -1)\n+    {\n+        int fd2 = dup2 (fd, 4);\n+        if (fd2 != -1)\n+        {\n+            read (fd2, buf, 1); /* { dg-warning \"'read' on write-only file descriptor 'fd2'\" } */\n+            close(fd2);\n+        }\n+        close (fd);\n+    }\n+    \n+}\n\\ No newline at end of file"}]}