{"sha": "daa5998b841124471f0a514209f1468f28c2e448", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFhNTk5OGI4NDExMjQ0NzFmMGE1MTQyMDlmMTQ2OGYyOGMyZTQ0OA==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2008-04-08T06:56:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:56:58Z"}, "message": "a-direct.adb (Start_Search): Check for Name_Error before checking for Use_Error, as specified in the RM.\n\n2008-04-08  Vincent Celier  <celier@adacore.com>\n\n\t* a-direct.adb (Start_Search): Check for Name_Error before checking for\n\tUse_Error, as specified in the RM. Check if directory is open and raise\n\tUse_Error if it is not.\n\nFrom-SVN: r134059", "tree": {"sha": "44c6dffb5ed97a2aade0c729232cb1e81269f833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44c6dffb5ed97a2aade0c729232cb1e81269f833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daa5998b841124471f0a514209f1468f28c2e448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa5998b841124471f0a514209f1468f28c2e448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daa5998b841124471f0a514209f1468f28c2e448", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa5998b841124471f0a514209f1468f28c2e448/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "096249062654522b096aeb32d551b9faaeaf186d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096249062654522b096aeb32d551b9faaeaf186d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096249062654522b096aeb32d551b9faaeaf186d"}], "stats": {"total": 177, "additions": 108, "deletions": 69}, "files": [{"sha": "cdb6876411545fda0d01bb6fcab022c89ae4a0f3", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 108, "deletions": 69, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa5998b841124471f0a514209f1468f28c2e448/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa5998b841124471f0a514209f1468f28c2e448/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=daa5998b841124471f0a514209f1468f28c2e448", "patch": "@@ -158,17 +158,20 @@ package body Ada.Directories is\n       if Containing_Directory /= \"\"\n         and then not Is_Valid_Path_Name (Containing_Directory)\n       then\n-         raise Name_Error;\n+         raise Name_Error with\n+           \"invalid directory path name \"\"\" & Containing_Directory & '\"';\n \n       elsif\n         Extension'Length = 0 and then (not Is_Valid_Simple_Name (Name))\n       then\n-         raise Name_Error;\n+         raise Name_Error with\n+           \"invalid simple name \"\"\" & Name & '\"';\n \n       elsif Extension'Length /= 0\n         and then not Is_Valid_Simple_Name (Name & '.' & Extension)\n       then\n-         raise Name_Error;\n+         raise Name_Error with\n+           \"invalid file name \"\"\" & Name & '.' & Extension & '\"';\n \n       --  This is not an invalid case so build the path name\n \n@@ -211,7 +214,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"invalid path name \"\"\" & Name & '\"';\n \n       else\n          declare\n@@ -242,7 +245,8 @@ package body Ada.Directories is\n                         and then (Norm (Norm'First) in 'a' .. 'z'\n                                    or else Norm (Norm'First) in 'A' .. 'Z'))))\n             then\n-               raise Use_Error;\n+               raise Use_Error with\n+                 \"directory \"\"\" & Name & \"\"\" has no containing directory\";\n \n             else\n                declare\n@@ -309,14 +313,19 @@ package body Ada.Directories is\n    begin\n       --  First, the invalid cases\n \n-      if not Is_Valid_Path_Name (Source_Name)\n-        or else not Is_Valid_Path_Name (Target_Name)\n-        or else not Is_Regular_File (Source_Name)\n-      then\n-         raise Name_Error;\n+      if not Is_Valid_Path_Name (Source_Name) then\n+         raise Name_Error with\n+           \"invalid source path name \"\"\" & Source_Name & '\"';\n+\n+      elsif not Is_Valid_Path_Name (Target_Name) then\n+         raise Name_Error with\n+           \"invalid target path name \"\"\" & Target_Name & '\"';\n+\n+      elsif not Is_Regular_File (Source_Name) then\n+         raise Name_Error with '\"' & Source_Name & \"\"\" is not a file\";\n \n       elsif Is_Directory (Target_Name) then\n-         raise Use_Error;\n+         raise Use_Error with \"target \"\"\" & Target_Name & \"\"\" is a directory\";\n \n       else\n          --  The implementation uses System.OS_Lib.Copy_File, with parameters\n@@ -325,7 +334,7 @@ package body Ada.Directories is\n          Copy_File (Source_Name, Target_Name, Success, Overwrite, None);\n \n          if not Success then\n-            raise Use_Error;\n+            raise Use_Error with \"copy of \"\"\" & Source_Name & \"\"\" failed\";\n          end if;\n       end if;\n    end Copy_File;\n@@ -349,11 +358,13 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (New_Directory) then\n-         raise Name_Error;\n+         raise Name_Error with\n+           \"invalid new directory path name \"\"\" & New_Directory & '\"';\n \n       else\n          if mkdir (C_Dir_Name) /= 0 then\n-            raise Use_Error;\n+            raise Use_Error with\n+              \"creation of new directory \"\"\" & New_Directory & \"\"\" failed\";\n          end if;\n       end if;\n    end Create_Directory;\n@@ -375,7 +386,8 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (New_Directory) then\n-         raise Name_Error;\n+         raise Name_Error with\n+           \"invalid new directory path name \"\"\" & New_Directory & '\"';\n \n       else\n          --  Build New_Dir with a directory separator at the end, so that the\n@@ -410,7 +422,8 @@ package body Ada.Directories is\n                --  It is an error if a file with such a name already exists\n \n                elsif Is_Regular_File (New_Dir (1 .. Last)) then\n-                  raise Use_Error;\n+                  raise Use_Error with\n+                    \"file \"\"\" & New_Dir (1 .. Last) & \"\"\" already exists\";\n \n                else\n                   Create_Directory (New_Directory => New_Dir (1 .. Last));\n@@ -459,19 +472,22 @@ package body Ada.Directories is\n       --  First, the invalid cases\n \n       if not Is_Valid_Path_Name (Directory) then\n-         raise Name_Error;\n+         raise Name_Error with\n+           \"invalid directory path name \"\"\" & Directory & '\"';\n \n       elsif not Is_Directory (Directory) then\n-         raise Name_Error;\n+         raise Name_Error with '\"' & Directory & \"\"\" not a directory\";\n \n       else\n          declare\n             C_Dir_Name : constant String := Directory & ASCII.NUL;\n+\n          begin\n             rmdir (C_Dir_Name);\n \n             if System.OS_Lib.Is_Directory (Directory) then\n-               raise Use_Error;\n+               raise Use_Error with\n+                 \"deletion of directory \"\"\" & Directory & \"\"\" failed\";\n             end if;\n          end;\n       end if;\n@@ -488,18 +504,18 @@ package body Ada.Directories is\n       --  First, the invalid cases\n \n       if not Is_Valid_Path_Name (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"invalid path name \"\"\" & Name & '\"';\n \n       elsif not Is_Regular_File (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"file \"\"\" & Name & \"\"\" does not exist\";\n \n       else\n          --  The implementation uses System.OS_Lib.Delete_File\n \n          Delete_File (Name, Success);\n \n          if not Success then\n-            raise Use_Error;\n+            raise Use_Error with \"file \"\"\" & Name & \"\"\" could not be deleted\";\n          end if;\n       end if;\n    end Delete_File;\n@@ -516,10 +532,11 @@ package body Ada.Directories is\n       --  First, the invalid cases\n \n       if not Is_Valid_Path_Name (Directory) then\n-         raise Name_Error;\n+         raise Name_Error with\n+           \"invalid directory path name \"\"\" & Directory & '\"';\n \n       elsif not Is_Directory (Directory) then\n-         raise Name_Error;\n+         raise Name_Error with '\"' & Directory & \"\"\" not a directory\";\n \n       else\n          Set_Directory (Directory);\n@@ -553,7 +570,9 @@ package body Ada.Directories is\n             rmdir (C_Dir_Name);\n \n             if System.OS_Lib.Is_Directory (Directory) then\n-               raise Use_Error;\n+               raise Use_Error with\n+                 \"directory tree rooted at \"\"\" &\n+                   Directory & \"\"\" could not be deleted\";\n             end if;\n          end;\n       end if;\n@@ -568,7 +587,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"invalid path name \"\"\" & Name & '\"';\n \n       else\n          --  The implementation is in File_Exists\n@@ -586,7 +605,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"invalid path name \"\"\" & Name & '\"';\n \n       else\n          --  Look for first dot that is not followed by a directory separator\n@@ -769,7 +788,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"invalid path name \"\"\" & Name & '\"';\n \n       else\n          --  Build the return value with lower bound 1\n@@ -791,7 +810,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Directory_Entry.Is_Valid then\n-         raise Status_Error;\n+         raise Status_Error with \"invalid directory entry\";\n \n       else\n          --  The value to return has already been computed\n@@ -812,7 +831,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if Search.Value = null or else not Search.Value.Is_Valid then\n-         raise Status_Error;\n+         raise Status_Error with \"invalid search\";\n       end if;\n \n       --  Fetch the next entry, if needed\n@@ -824,7 +843,7 @@ package body Ada.Directories is\n       --  It is an error if no valid entry is found\n \n       if not Search.Value.Is_Valid then\n-         raise Status_Error;\n+         raise Status_Error with \"no next entry\";\n \n       else\n          --  Reset Entry_Fetched and return the entry\n@@ -843,7 +862,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not File_Exists (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"file \"\"\" & Name & \"\"\" does not exist\";\n \n       elsif Is_Regular_File (Name) then\n          return Ordinary_File;\n@@ -861,7 +880,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Directory_Entry.Is_Valid then\n-         raise Status_Error;\n+         raise Status_Error with \"invalid directory entry\";\n \n       else\n          --  The value to return has already be computed\n@@ -888,7 +907,7 @@ package body Ada.Directories is\n       --  First, the invalid cases\n \n       if not (Is_Regular_File (Name) or else Is_Directory (Name)) then\n-         raise Name_Error;\n+         raise Name_Error with '\"' & Name & \"\"\" not a file or directory\";\n \n       else\n          Date := File_Time_Stamp (Name);\n@@ -928,7 +947,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Directory_Entry.Is_Valid then\n-         raise Status_Error;\n+         raise Status_Error with \"invalid directory entry\";\n \n       else\n          --  The value to return has already be computed\n@@ -968,23 +987,30 @@ package body Ada.Directories is\n    begin\n       --  First, the invalid cases\n \n-      if not Is_Valid_Path_Name (Old_Name)\n-        or else not Is_Valid_Path_Name (New_Name)\n-        or else (not Is_Regular_File (Old_Name)\n-                   and then not Is_Directory (Old_Name))\n+      if not Is_Valid_Path_Name (Old_Name) then\n+         raise Name_Error with \"invalid old path name \"\"\" & Old_Name & '\"';\n+\n+      elsif not Is_Valid_Path_Name (New_Name) then\n+         raise Name_Error with \"invalid new path name \"\"\" & New_Name & '\"';\n+\n+      elsif not Is_Regular_File (Old_Name)\n+            and then not Is_Directory (Old_Name)\n       then\n-         raise Name_Error;\n+         raise Name_Error with \"old file \"\"\" & Old_Name & \"\"\" does not exist\";\n \n       elsif Is_Regular_File (New_Name) or Is_Directory (New_Name) then\n-         raise Use_Error;\n+         raise Use_Error with\n+           \"new name \"\"\" & New_Name\n+           & \"\"\" designates a file that already exists\";\n \n       else\n          --  The implementation uses System.OS_Lib.Rename_File\n \n          Rename_File (Old_Name, New_Name, Success);\n \n          if not Success then\n-            raise Use_Error;\n+            raise Use_Error with\n+              \"file \"\"\" & Old_Name & \"\"\" could not be renamed\";\n          end if;\n       end if;\n    end Rename;\n@@ -1025,8 +1051,17 @@ package body Ada.Directories is\n       pragma Import (C, chdir, \"chdir\");\n \n    begin\n-      if chdir (C_Dir_Name) /= 0 then\n-         raise Name_Error;\n+      if not Is_Valid_Path_Name (Directory) then\n+         raise Name_Error with\n+           \"invalid directory path name & \"\"\" & Directory & '\"';\n+\n+      elsif not Is_Directory (Directory) then\n+         raise Name_Error with\n+           \"directory \"\"\" & Directory & \"\"\" does not exist\";\n+\n+      elsif chdir (C_Dir_Name) /= 0 then\n+         raise Name_Error with\n+           \"could not set to designated directory \"\"\" & Directory & '\"';\n       end if;\n    end Set_Directory;\n \n@@ -1103,7 +1138,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"invalid path name \"\"\" & Name & '\"';\n \n       else\n          --  Build the value to return with lower bound 1\n@@ -1135,7 +1170,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Directory_Entry.Is_Valid then\n-         raise Status_Error;\n+         raise Status_Error with \"invalid directory entry\";\n \n       else\n          --  The value to return has already be computed\n@@ -1158,7 +1193,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Is_Regular_File (Name) then\n-         raise Name_Error;\n+         raise Name_Error with \"file \"\"\" & Name & \"\"\" does not exist\";\n \n       else\n          C_Name (1 .. Name'Length) := Name;\n@@ -1172,7 +1207,7 @@ package body Ada.Directories is\n       --  First, the invalid case\n \n       if not Directory_Entry.Is_Valid then\n-         raise Status_Error;\n+         raise Status_Error with \"invalid directory entry\";\n \n       else\n          --  The value to return has already be computed\n@@ -1195,17 +1230,32 @@ package body Ada.Directories is\n       pragma Import (C, opendir, \"__gnat_opendir\");\n \n       C_File_Name : constant String := Directory & ASCII.NUL;\n+      Pat         : Regexp;\n+      Dir         : Dir_Type_Value;\n \n    begin\n-      --  First, the invalid cases\n+      --  First, the invalid case Name_Error\n \n       if not Is_Directory (Directory) then\n-         raise Name_Error\n-           with \"unknown directory \"\"\" & Simple_Name (Directory) & '\"';\n+         raise Name_Error with\n+           \"unknown directory \"\"\" & Simple_Name (Directory) & '\"';\n+      end if;\n+\n+      --  Check the pattern\n+\n+      begin\n+         Pat := Compile (Pattern, Glob => True);\n+      exception\n+         when Error_In_Regexp =>\n+            Free (Search.Value);\n+            raise Name_Error with \"invalid pattern \"\"\" & Pattern & '\"';\n+      end;\n+\n+      Dir := Dir_Type_Value (opendir (C_File_Name));\n \n-      elsif not Is_Readable_File (Directory) then\n-         raise Use_Error\n-           with \"unreadable directory \"\"\" & Simple_Name (Directory) & '\"';\n+      if Dir = No_Dir then\n+         raise Use_Error with\n+           \"unreadable directory \"\"\" & Simple_Name (Directory) & '\"';\n       end if;\n \n       --  If needed, finalize Search\n@@ -1216,23 +1266,12 @@ package body Ada.Directories is\n \n       Search.Value := new Search_Data;\n \n-      begin\n-         --  Check the pattern\n-\n-         Search.Value.Pattern := Compile (Pattern, Glob => True);\n-\n-      exception\n-         when Error_In_Regexp =>\n-            Free (Search.Value);\n-            raise Name_Error\n-              with \"invalid pattern \"\"\" & Pattern & '\"';\n-      end;\n-\n       --  Initialize some Search components\n \n-      Search.Value.Filter := Filter;\n-      Search.Value.Name := To_Unbounded_String (Full_Name (Directory));\n-      Search.Value.Dir := Dir_Type_Value (opendir (C_File_Name));\n+      Search.Value.Filter   := Filter;\n+      Search.Value.Name     := To_Unbounded_String (Full_Name (Directory));\n+      Search.Value.Pattern  := Pat;\n+      Search.Value.Dir      := Dir;\n       Search.Value.Is_Valid := True;\n    end Start_Search;\n "}]}