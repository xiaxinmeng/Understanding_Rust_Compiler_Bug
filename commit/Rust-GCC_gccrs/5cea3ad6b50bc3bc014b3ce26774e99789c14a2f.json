{"sha": "5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNlYTNhZDZiNTBiYzNiYzAxNGIzY2UyNjc3NGU5OTc4OWMxNGEyZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-31T19:35:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-31T19:35:47Z"}, "message": "dwarf2out.h (struct dw_loc_descr_node): Adjust comment for frame_offset_rel bit.\n\n\t* dwarf2out.h (struct dw_loc_descr_node): Adjust comment\n\tfor frame_offset_rel bit.\n\t(struct array_descr_info): Add rank field.\n\t* dwarf2out.c (struct loc_descr_context): Add placeholder_arg\n\tand placeholder_seen fields.\n\t(resolve_args_picking_1): Handle also frame_offset_rel DW_OP_dup\n\tand DW_OP_over.  Optimize DW_OP_pick 0 into DW_OP_dup and\n\tDW_OP_pick 1 into DW_OP_over.\n\t(function_to_dwarf_procedure, type_byte_size, field_byte_offset,\n\tgen_variant_part): Clear placeholder_{arg,seen}.\n\t(loc_list_from_tree_1): Drop const from context argument.\n\tHandle integral PLACEHOLDER_EXPR if context->placeholder_arg.\n\t(loc_list_for_address_of_addr_expr_of_indirect_ref,\n\tloc_list_from_tree, loc_descriptor_from_tree): Drop const from\n\tcontext argument.\n\t(add_scalar_info): Drop const from context argument.  Handle\n\tcontext->placeholder_arg.\n\t(add_bound_info): Drop const from context argument.\n\t(gen_descr_array_type_die): Drop const from ctx variable.\n\tInitialize placeholder_arg and placeholder_seen.  Add DW_AT_rank\n\tattribute and use a single DW_TAG_generic_subrange instead of\n\t7 DW_TAG_subrange_type for assumed rank arrays.\nfortran/\n\t* trans-types.c (gfc_get_array_descr_info): For -gdwarf-5 or\n\t-gno-strict-dwarf, handle assumed rank arrays the way dwarf2out\n\texpects.\nada/\n\t* gcc-interface/misc.c (gnat_get_array_descr_info): Clear rank\n\tfield.\n\nFrom-SVN: r241719", "tree": {"sha": "134de51157bc15c220fdc4879ad108808f6989f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/134de51157bc15c220fdc4879ad108808f6989f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8"}], "stats": {"total": 192, "additions": 166, "deletions": 26}, "files": [{"sha": "d8725d0807b5988edfb68da2952134693488358c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "patch": "@@ -1,5 +1,28 @@\n 2016-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.h (struct dw_loc_descr_node): Adjust comment\n+\tfor frame_offset_rel bit.\n+\t(struct array_descr_info): Add rank field.\n+\t* dwarf2out.c (struct loc_descr_context): Add placeholder_arg\n+\tand placeholder_seen fields.\n+\t(resolve_args_picking_1): Handle also frame_offset_rel DW_OP_dup\n+\tand DW_OP_over.  Optimize DW_OP_pick 0 into DW_OP_dup and\n+\tDW_OP_pick 1 into DW_OP_over.\n+\t(function_to_dwarf_procedure, type_byte_size, field_byte_offset,\n+\tgen_variant_part): Clear placeholder_{arg,seen}.\n+\t(loc_list_from_tree_1): Drop const from context argument.\n+\tHandle integral PLACEHOLDER_EXPR if context->placeholder_arg.\n+\t(loc_list_for_address_of_addr_expr_of_indirect_ref,\n+\tloc_list_from_tree, loc_descriptor_from_tree): Drop const from\n+\tcontext argument.\n+\t(add_scalar_info): Drop const from context argument.  Handle\n+\tcontext->placeholder_arg.\n+\t(add_bound_info): Drop const from context argument.\n+\t(gen_descr_array_type_die): Drop const from ctx variable.\n+\tInitialize placeholder_arg and placeholder_seen.  Add DW_AT_rank\n+\tattribute and use a single DW_TAG_generic_subrange instead of\n+\t7 DW_TAG_subrange_type for assumed rank arrays.\n+\n \t* dwarf2out.h (enum dw_val_class): Add dw_val_class_loclistsptr.\n \t* dwarf2out.c (struct dw_loc_list_struct): Change emitted field\n \tfrom bool to 1-bit uchar bitfield.  Add num_assigned and"}, {"sha": "cdb4d877f2a3d2fd60a4961ec0f867b4fb046662", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "patch": "@@ -1,3 +1,8 @@\n+2016-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc-interface/misc.c (gnat_get_array_descr_info): Clear rank\n+\tfield.\n+\n 2016-10-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc-interface/Make-lang.in (lang_checks_parallelized): New target."}, {"sha": "1fed72a0520e1f16d112a49a5408975ad9e456ca", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "patch": "@@ -898,6 +898,7 @@ gnat_get_array_descr_info (const_tree const_type,\n     }\n \n   info->ndimensions = i;\n+  info->rank = NULL_TREE;\n \n   /* Too many dimensions?  Give up generating proper description: yield instead\n      nested arrays.  Note that in this case, this hook is invoked once on each"}, {"sha": "bd16d0e71b45f81efcc984eaf4cd27ec64648486", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 105, "deletions": 21, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "patch": "@@ -3452,9 +3452,9 @@ struct loc_descr_context;\n static void add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref);\n static void add_loc_list (dw_loc_list_ref *ret, dw_loc_list_ref list);\n static dw_loc_list_ref loc_list_from_tree (tree, int,\n-\t\t\t\t\t   const struct loc_descr_context *);\n+\t\t\t\t\t   struct loc_descr_context *);\n static dw_loc_descr_ref loc_descriptor_from_tree (tree, int,\n-\t\t\t\t\t\t  const struct loc_descr_context *);\n+\t\t\t\t\t\t  struct loc_descr_context *);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n static tree field_type (const_tree);\n static unsigned int simple_type_align_in_bits (const_tree);\n@@ -3479,9 +3479,9 @@ static void add_name_attribute (dw_die_ref, const char *);\n static void add_gnat_descriptive_type_attribute (dw_die_ref, tree, dw_die_ref);\n static void add_comp_dir_attribute (dw_die_ref);\n static void add_scalar_info (dw_die_ref, enum dwarf_attribute, tree, int,\n-\t\t\t     const struct loc_descr_context *);\n+\t\t\t     struct loc_descr_context *);\n static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree,\n-\t\t\t    const struct loc_descr_context *);\n+\t\t\t    struct loc_descr_context *);\n static void add_subscript_info (dw_die_ref, tree, bool);\n static void add_byte_size_attribute (dw_die_ref, tree);\n static inline void add_bit_offset_attribute (dw_die_ref, tree,\n@@ -15791,7 +15791,7 @@ cst_pool_loc_descr (tree loc)\n \n static dw_loc_list_ref\n loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev,\n-\t\t\t\t\t\t   const loc_descr_context *context)\n+\t\t\t\t\t\t   loc_descr_context *context)\n {\n   tree obj, offset;\n   HOST_WIDE_INT bitsize, bitpos, bytepos;\n@@ -15925,6 +15925,11 @@ struct loc_descr_context\n   /* Information about the DWARF procedure we are currently generating. NULL if\n      we are not generating a DWARF procedure.  */\n   struct dwarf_procedure_info *dpi;\n+  /* True if integral PLACEHOLDER_EXPR stands for the first argument passed\n+     by consumer.  Used for DW_TAG_generic_subrange attributes.  */\n+  bool placeholder_arg;\n+  /* True if PLACEHOLDER_EXPR has been seen.  */\n+  bool placeholder_seen;\n };\n \n /* DWARF procedures generation\n@@ -16034,8 +16039,23 @@ resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n \n       /* If needed, relocate the picking offset with respect to the frame\n \t offset. */\n-      if (l->dw_loc_opc == DW_OP_pick && l->frame_offset_rel)\n+      if (l->frame_offset_rel)\n \t{\n+\t  unsigned HOST_WIDE_INT off;\n+\t  switch (l->dw_loc_opc)\n+\t    {\n+\t    case DW_OP_pick:\n+\t      off = l->dw_loc_oprnd1.v.val_unsigned;\n+\t      break;\n+\t    case DW_OP_dup:\n+\t      off = 0;\n+\t      break;\n+\t    case DW_OP_over:\n+\t      off = 1;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  /* frame_offset_ is the size of the current stack frame, including\n \t     incoming arguments. Besides, the arguments are pushed\n \t     right-to-left.  Thus, in order to access the Nth argument from\n@@ -16046,11 +16066,27 @@ resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n \t     The targetted argument number (N) is already set as the operand,\n \t     and the number of temporaries can be computed with:\n \t       frame_offsets_ - dpi->args_count */\n-\t  l->dw_loc_oprnd1.v.val_unsigned += frame_offset_ - dpi->args_count;\n+\t  off += frame_offset_ - dpi->args_count;\n \n \t  /* DW_OP_pick handles only offsets from 0 to 255 (inclusive)...  */\n-\t  if (l->dw_loc_oprnd1.v.val_unsigned > 255)\n+\t  if (off > 255)\n \t    return false;\n+\n+\t  if (off == 0)\n+\t    {\n+\t      l->dw_loc_opc = DW_OP_dup;\n+\t      l->dw_loc_oprnd1.v.val_unsigned = 0;\n+\t    }\n+\t  else if (off == 1)\n+\t    {\n+\t      l->dw_loc_opc = DW_OP_over;\n+\t      l->dw_loc_oprnd1.v.val_unsigned = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      l->dw_loc_opc = DW_OP_pick;\n+\t      l->dw_loc_oprnd1.v.val_unsigned = off;\n+\t    }\n \t}\n \n       /* Update frame_offset according to the effect the current operation has\n@@ -16353,6 +16389,8 @@ function_to_dwarf_procedure (tree fndecl)\n   ctx.context_type = NULL_TREE;\n   ctx.base_decl = NULL_TREE;\n   ctx.dpi = &dpi;\n+  ctx.placeholder_arg = false;\n+  ctx.placeholder_seen = false;\n   dpi.fndecl = fndecl;\n   dpi.args_count = list_length (DECL_ARGUMENTS (fndecl));\n   loc_body = loc_descriptor_from_tree (tree_body, 0, &ctx);\n@@ -16415,7 +16453,7 @@ function_to_dwarf_procedure (tree fndecl)\n \n static dw_loc_list_ref\n loc_list_from_tree_1 (tree loc, int want_address,\n-\t\t      const struct loc_descr_context *context)\n+\t\t      struct loc_descr_context *context)\n {\n   dw_loc_descr_ref ret = NULL, ret1 = NULL;\n   dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n@@ -16461,6 +16499,18 @@ loc_list_from_tree_1 (tree loc, int want_address,\n \t  else\n \t    return NULL;\n \t}\n+      /* For DW_TAG_generic_subrange attributes, PLACEHOLDER_EXPR stands for\n+\t the single argument passed by consumer.  */\n+      else if (context != NULL\n+\t       && context->placeholder_arg\n+\t       && INTEGRAL_TYPE_P (TREE_TYPE (loc))\n+\t       && want_address == 0)\n+\t{\n+\t  ret = new_loc_descr (DW_OP_pick, 0, 0);\n+\t  ret->frame_offset_rel = 1;\n+\t  context->placeholder_seen = true;\n+\t  break;\n+\t}\n       else\n \texpansion_failed (loc, NULL_RTX,\n \t\t\t  \"PLACEHOLDER_EXPR for an unexpected type\");\n@@ -17214,7 +17264,7 @@ loc_list_from_tree_1 (tree loc, int want_address,\n \n static dw_loc_list_ref\n loc_list_from_tree (tree loc, int want_address,\n-\t\t    const struct loc_descr_context *context)\n+\t\t    struct loc_descr_context *context)\n {\n   dw_loc_list_ref result = loc_list_from_tree_1 (loc, want_address, context);\n \n@@ -17228,7 +17278,7 @@ loc_list_from_tree (tree loc, int want_address,\n /* Same as above but return only single location expression.  */\n static dw_loc_descr_ref\n loc_descriptor_from_tree (tree loc, int want_address,\n-\t\t\t  const struct loc_descr_context *context)\n+\t\t\t  struct loc_descr_context *context)\n {\n   dw_loc_list_ref ret = loc_list_from_tree (loc, want_address, context);\n   if (!ret)\n@@ -17314,6 +17364,8 @@ type_byte_size (const_tree type, HOST_WIDE_INT *cst_size)\n   ctx.context_type = const_cast<tree> (type);\n   ctx.base_decl = NULL_TREE;\n   ctx.dpi = NULL;\n+  ctx.placeholder_arg = false;\n+  ctx.placeholder_seen = false;\n \n   type = TYPE_MAIN_VARIANT (type);\n   tree_size = TYPE_SIZE_UNIT (type);\n@@ -17493,7 +17545,9 @@ field_byte_offset (const_tree decl, struct vlr_context *ctx,\n   struct loc_descr_context loc_ctx = {\n     ctx->struct_type, /* context_type */\n     NULL_TREE,\t      /* base_decl */\n-    NULL\t      /* dpi */\n+    NULL,\t      /* dpi */\n+    false,\t      /* placeholder_arg */\n+    false\t      /* placeholder_seen */\n   };\n   loc_result = loc_list_from_tree (tree_result, 0, &loc_ctx);\n \n@@ -18886,12 +18940,12 @@ add_comp_dir_attribute (dw_die_ref die)\n \n static void\n add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n-\t\t int forms, const struct loc_descr_context *context)\n+\t\t int forms, struct loc_descr_context *context)\n {\n   dw_die_ref context_die, decl_die;\n   dw_loc_list_ref list;\n-\n   bool strip_conversions = true;\n+  bool placeholder_seen = false;\n \n   while (strip_conversions)\n     switch (TREE_CODE (value))\n@@ -18986,6 +19040,11 @@ add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n     return;\n \n   list = loc_list_from_tree (value, 2, context);\n+  if (context && context->placeholder_arg)\n+    {\n+      placeholder_seen = context->placeholder_seen;\n+      context->placeholder_seen = false;\n+    }\n   if (list == NULL || single_element_loc_list_p (list))\n     {\n       /* If this attribute is not a reference nor constant, it is\n@@ -18994,14 +19053,24 @@ add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n       dw_loc_list_ref list2 = loc_list_from_tree (value, 0, context);\n       if (list2 && single_element_loc_list_p (list2))\n \t{\n+\t  if (placeholder_seen)\n+\t    {\n+\t      struct dwarf_procedure_info dpi;\n+\t      dpi.fndecl = NULL_TREE;\n+\t      dpi.args_count = 1;\n+\t      if (!resolve_args_picking (list2->expr, 1, &dpi))\n+\t\treturn;\n+\t    }\n \t  add_AT_loc (die, attr, list2->expr);\n \t  return;\n \t}\n     }\n \n   /* If that failed to give a single element location list, fall back to\n      outputting this as a reference... still if permitted.  */\n-  if (list == NULL || (forms & dw_scalar_form_reference) == 0)\n+  if (list == NULL\n+      || (forms & dw_scalar_form_reference) == 0\n+      || placeholder_seen)\n     return;\n \n   if (current_function_decl == 0)\n@@ -19064,7 +19133,7 @@ lower_bound_default (void)\n \n static void\n add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,\n-\t\ttree bound, const struct loc_descr_context *context)\n+\t\ttree bound, struct loc_descr_context *context)\n {\n   int dflt;\n \n@@ -19095,7 +19164,8 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,\n \t   encodings, GDB isn't ready yet to handle proper DWARF description\n \t   for self-referencial subrange bounds: let GNAT encodings do the\n \t   magic in such a case.  */\n-\tif (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\tif (is_ada ()\n+\t    && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n \t    && contains_placeholder_p (bound))\n \t  return;\n \n@@ -20121,7 +20191,9 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n {\n   const dw_die_ref scope_die = scope_die_for (type, context_die);\n   const dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die, type);\n-  const struct loc_descr_context context = { type, info->base_decl, NULL };\n+  struct loc_descr_context context = { type, info->base_decl, NULL,\n+\t\t\t\t       false, false };\n+  enum dwarf_tag subrange_tag = DW_TAG_subrange_type;\n   int dim;\n \n   add_name_attribute (array_die, type_tag (type));\n@@ -20169,13 +20241,23 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n \t  add_scalar_info (array_die, attr, info->stride, forms, &context);\n \t}\n     }\n+  if (dwarf_version >= 5)\n+    {\n+      if (info->rank)\n+\t{\n+\t  add_scalar_info (array_die, DW_AT_rank, info->rank,\n+\t\t\t   dw_scalar_form_constant\n+\t\t\t   | dw_scalar_form_exprloc, &context);\n+\t  subrange_tag = DW_TAG_generic_subrange;\n+\t  context.placeholder_arg = true;\n+\t}\n+    }\n \n   add_gnat_descriptive_type_attribute (array_die, type, context_die);\n \n   for (dim = 0; dim < info->ndimensions; dim++)\n     {\n-      dw_die_ref subrange_die\n-\t= new_die (DW_TAG_subrange_type, array_die, NULL);\n+      dw_die_ref subrange_die = new_die (subrange_tag, array_die, NULL);\n \n       if (info->dimen[dim].bounds_type)\n \tadd_type_attribute (subrange_die,\n@@ -23104,7 +23186,9 @@ gen_variant_part (tree variant_part_decl, struct vlr_context *vlr_ctx,\n   struct loc_descr_context ctx = {\n     vlr_ctx->struct_type, /* context_type */\n     NULL_TREE,\t\t  /* base_decl */\n-    NULL\t\t  /* dpi */\n+    NULL,\t\t  /* dpi */\n+    false,\t\t  /* placeholder_arg */\n+    false\t\t  /* placeholder_seen */\n   };\n \n   /* The FIELD_DECL node in STRUCT_TYPE that acts as the discriminant, or"}, {"sha": "ae1af572f5deb1b92f16355dfa54249c48d01c17", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "patch": "@@ -241,9 +241,9 @@ struct GTY((chain_next (\"%h.dw_loc_next\"))) dw_loc_descr_node {\n   /* Used to distinguish DW_OP_addr with a direct symbol relocation\n      from DW_OP_addr with a dtp-relative symbol relocation.  */\n   unsigned int dtprel : 1;\n-  /* For DW_OP_pick operations: true iff. it targets a DWARF prodecure\n-     argument.  In this case, it needs to be relocated according to the current\n-     frame offset.  */\n+  /* For DW_OP_pick, DW_OP_dup and DW_OP_over operations: true iff.\n+     it targets a DWARF prodecure argument.  In this case, it needs to be\n+     relocated according to the current frame offset.  */\n   unsigned int frame_offset_rel : 1;\n   int dw_loc_addr;\n   dw_val_node dw_loc_oprnd1;\n@@ -329,6 +329,7 @@ struct array_descr_info\n   tree allocated;\n   tree associated;\n   tree stride;\n+  tree rank;\n   bool stride_in_bits;\n   struct array_descr_dimen\n     {"}, {"sha": "f593ab7bb91e62cf025e8bf187ef8f01814f3845", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "patch": "@@ -1,3 +1,9 @@\n+2016-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans-types.c (gfc_get_array_descr_info): For -gdwarf-5 or\n+\t-gno-strict-dwarf, handle assumed rank arrays the way dwarf2out\n+\texpects.\n+\n 2016-10-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/67219"}, {"sha": "6f9bc381df6362826a3263a877338629d29b4d01", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cea3ad6b50bc3bc014b3ce26774e99789c14a2f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=5cea3ad6b50bc3bc014b3ce26774e99789c14a2f", "patch": "@@ -3139,7 +3139,7 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   int rank, dim;\n   bool indirect = false;\n   tree etype, ptype, field, t, base_decl;\n-  tree data_off, dim_off, dim_size, elem_size;\n+  tree data_off, dim_off, dtype_off, dim_size, elem_size;\n   tree lower_suboff, upper_suboff, stride_suboff;\n \n   if (! GFC_DESCRIPTOR_TYPE_P (type))\n@@ -3203,6 +3203,7 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   data_off = byte_position (field);\n   field = DECL_CHAIN (field);\n   field = DECL_CHAIN (field);\n+  dtype_off = byte_position (field);\n   field = DECL_CHAIN (field);\n   dim_off = byte_position (field);\n   dim_size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (field)));\n@@ -3225,6 +3226,24 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n \t   || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER_CONT)\n     info->associated = build2 (NE_EXPR, boolean_type_node,\n \t\t\t       info->data_location, null_pointer_node);\n+  if ((GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_RANK\n+       || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_RANK_CONT)\n+      && dwarf_version >= 5)\n+    {\n+      rank = 1;\n+      info->ndimensions = 1;\n+      t = base_decl;\n+      if (!integer_zerop (dtype_off))\n+\tt = fold_build_pointer_plus (t, dtype_off);\n+      t = build1 (NOP_EXPR, build_pointer_type (gfc_array_index_type), t);\n+      t = build1 (INDIRECT_REF, gfc_array_index_type, t);\n+      info->rank = build2 (BIT_AND_EXPR, gfc_array_index_type, t,\n+\t\t\t   build_int_cst (gfc_array_index_type,\n+\t\t\t\t\t  GFC_DTYPE_RANK_MASK));\n+      t = build0 (PLACEHOLDER_EXPR, TREE_TYPE (dim_off));\n+      t = size_binop (MULT_EXPR, t, dim_size);\n+      dim_off = build2 (PLUS_EXPR, TREE_TYPE (dim_off), t, dim_off);\n+    }\n \n   for (dim = 0; dim < rank; dim++)\n     {\n@@ -3260,7 +3279,8 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n       t = build1 (INDIRECT_REF, gfc_array_index_type, t);\n       t = build2 (MULT_EXPR, gfc_array_index_type, t, elem_size);\n       info->dimen[dim].stride = t;\n-      dim_off = size_binop (PLUS_EXPR, dim_off, dim_size);\n+      if (dim + 1 < rank)\n+\tdim_off = size_binop (PLUS_EXPR, dim_off, dim_size);\n     }\n \n   return true;"}]}