{"sha": "49bde17554926a2352b7f1df98d4e02becc1e065", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDliZGUxNzU1NDkyNmEyMzUyYjdmMWRmOThkNGUwMmJlY2MxZTA2NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-07-25T17:10:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-07-25T17:10:21Z"}, "message": "cgraph.c (release_function_body): Break out from ...\n\n\t* cgraph.c (release_function_body): Break out from ...\n\t(cgraph_release_function_body): ... this one; also release DECL_RESULT\n\tand DECL_ARGUMENTS.\n\t* ipa-cp.c (get_replacement_map): Add parm_num argument; do not set\n\told_tree in the map.\n\t(create_specialized_node): Update.\n\t* lto-cgraph.c (output_node_opt_summary): Do not translate old_tree\n\tinto index.\n\t* cgraphclones.c (cgraph_create_virtual_clone): Do not copy DECL_ARGUMENTS,\n\tDECL_INITIAL and DECL_RESULT.\n\t* ipa-prop.c (ipa_populate_param_decls): Look for origin of clones.\n\t* tree-inline.c (initialize_cfun): Initialize DECL_ARGUMENTS and\n\tDECL_RESULT.\n\nFrom-SVN: r201251", "tree": {"sha": "8d52c0e27c62a558679ffa973f3a0c348cef4b41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d52c0e27c62a558679ffa973f3a0c348cef4b41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49bde17554926a2352b7f1df98d4e02becc1e065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49bde17554926a2352b7f1df98d4e02becc1e065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49bde17554926a2352b7f1df98d4e02becc1e065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49bde17554926a2352b7f1df98d4e02becc1e065/comments", "author": null, "committer": null, "parents": [{"sha": "4870352d35468211accf8c293bf756eac99bc1e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4870352d35468211accf8c293bf756eac99bc1e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4870352d35468211accf8c293bf756eac99bc1e7"}], "stats": {"total": 92, "additions": 68, "deletions": 24}, "files": [{"sha": "b406b15ce471054b41052e0d8926ad9d1be9f8b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49bde17554926a2352b7f1df98d4e02becc1e065", "patch": "@@ -1,3 +1,19 @@\n+2013-07-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (release_function_body): Break out from ...\n+\t(cgraph_release_function_body): ... this one; also release DECL_RESULT\n+\tand DECL_ARGUMENTS.\n+\t* ipa-cp.c (get_replacement_map): Add parm_num argument; do not set\n+\told_tree in the map.\n+\t(create_specialized_node): Update.\n+\t* lto-cgraph.c (output_node_opt_summary): Do not translate old_tree\n+\tinto index.\n+\t* cgraphclones.c (cgraph_create_virtual_clone): Do not copy DECL_ARGUMENTS,\n+\tDECL_INITIAL and DECL_RESULT.\n+\t* ipa-prop.c (ipa_populate_param_decls): Look for origin of clones.\n+\t* tree-inline.c (initialize_cfun): Initialize DECL_ARGUMENTS and\n+\tDECL_RESULT.\n+\n 2013-07-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (arm_addsi3, addsi3_carryin_<optab>,"}, {"sha": "be3411d6a0797c5e3fe751898ca2e4f634ddcc2c", "filename": "gcc/cgraph.c", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=49bde17554926a2352b7f1df98d4e02becc1e065", "patch": "@@ -1266,17 +1266,16 @@ cgraph_node_remove_callers (struct cgraph_node *node)\n   node->callers = NULL;\n }\n \n-/* Release memory used to represent body of function NODE.\n-   Use this only for functions that are released before being translated to\n-   target code (i.e. RTL).  Functions that are compiled to RTL and beyond\n-   are free'd in final.c via free_after_compilation().  */\n+/* Helper function for cgraph_release_function_body and free_lang_data.\n+   It releases body from function DECL without having to inspect its\n+   possibly non-existent symtab node.  */\n \n void\n-cgraph_release_function_body (struct cgraph_node *node)\n+release_function_body (tree decl)\n {\n-  if (DECL_STRUCT_FUNCTION (node->symbol.decl))\n+  if (DECL_STRUCT_FUNCTION (decl))\n     {\n-      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      push_cfun (DECL_STRUCT_FUNCTION (decl));\n       if (cfun->cfg\n \t  && current_loops)\n \t{\n@@ -1299,19 +1298,35 @@ cgraph_release_function_body (struct cgraph_node *node)\n       if (cfun->value_histograms)\n \tfree_histograms ();\n       pop_cfun();\n-      gimple_set_body (node->symbol.decl, NULL);\n-      node->ipa_transforms_to_apply.release ();\n+      gimple_set_body (decl, NULL);\n       /* Struct function hangs a lot of data that would leak if we didn't\n          removed all pointers to it.   */\n-      ggc_free (DECL_STRUCT_FUNCTION (node->symbol.decl));\n-      DECL_STRUCT_FUNCTION (node->symbol.decl) = NULL;\n+      ggc_free (DECL_STRUCT_FUNCTION (decl));\n+      DECL_STRUCT_FUNCTION (decl) = NULL;\n+    }\n+  DECL_SAVED_TREE (decl) = NULL;\n+}\n+\n+/* Release memory used to represent body of function NODE.\n+   Use this only for functions that are released before being translated to\n+   target code (i.e. RTL).  Functions that are compiled to RTL and beyond\n+   are free'd in final.c via free_after_compilation().  */\n+\n+void\n+cgraph_release_function_body (struct cgraph_node *node)\n+{\n+  node->ipa_transforms_to_apply.release ();\n+  if (!node->abstract_and_needed && cgraph_state != CGRAPH_STATE_PARSING)\n+    {\n+      DECL_RESULT (node->symbol.decl) = NULL;\n+      DECL_ARGUMENTS (node->symbol.decl) = NULL;\n     }\n-  DECL_SAVED_TREE (node->symbol.decl) = NULL;\n   /* If the node is abstract and needed, then do not clear DECL_INITIAL\n      of its associated function function declaration because it's\n      needed to emit debug info later.  */\n   if (!node->abstract_and_needed && DECL_INITIAL (node->symbol.decl))\n     DECL_INITIAL (node->symbol.decl) = error_mark_node;\n+  release_function_body (node->symbol.decl);\n }\n \n /* Remove the node from cgraph.  */"}, {"sha": "04cb990cc86e635681f7b51538a89a4688d90728", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=49bde17554926a2352b7f1df98d4e02becc1e065", "patch": "@@ -305,7 +305,16 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n     new_decl = copy_node (old_decl);\n   else\n     new_decl = build_function_decl_skip_args (old_decl, args_to_skip, false);\n+\n+  /* These pointers represent function body and will be populated only when clone\n+     is materialized.  */\n+  gcc_assert (new_decl != old_decl);\n   DECL_STRUCT_FUNCTION (new_decl) = NULL;\n+  DECL_ARGUMENTS (new_decl) = NULL;\n+  DECL_INITIAL (new_decl) = NULL;\n+  DECL_RESULT (new_decl) = NULL; \n+  /* We can not do DECL_RESULT (new_decl) = NULL; here because of LTO partitioning\n+     sometimes storing only clone decl instead of original.  */\n \n   /* Generate a new name for the new version. */\n   DECL_NAME (new_decl) = clone_function_name (old_decl, suffix);"}, {"sha": "73f9d6ed4aadf07fb31b0f595d972058d794e063", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=49bde17554926a2352b7f1df98d4e02becc1e065", "patch": "@@ -2480,7 +2480,7 @@ gather_edges_for_value (struct ipcp_value *val, int caller_count)\n    Return it or NULL if for some reason it cannot be created.  */\n \n static struct ipa_replace_map *\n-get_replacement_map (tree value, tree parm)\n+get_replacement_map (tree value, tree parm, int parm_num)\n {\n   tree req_type = TREE_TYPE (parm);\n   struct ipa_replace_map *replace_map;\n@@ -2514,7 +2514,8 @@ get_replacement_map (tree value, tree parm)\n       print_generic_expr (dump_file, value, 0);\n       fprintf (dump_file, \"\\n\");\n     }\n-  replace_map->old_tree = parm;\n+  replace_map->old_tree = NULL;\n+  replace_map->parm_num = parm_num;\n   replace_map->new_tree = value;\n   replace_map->replace_p = true;\n   replace_map->ref_p = false;\n@@ -2696,7 +2697,7 @@ create_specialized_node (struct cgraph_node *node,\n \t{\n \t  struct ipa_replace_map *replace_map;\n \n-\t  replace_map = get_replacement_map (t, ipa_get_param (info, i));\n+\t  replace_map = get_replacement_map (t, ipa_get_param (info, i), i);\n \t  if (replace_map)\n \t    vec_safe_push (replace_trees, replace_map);\n \t}"}, {"sha": "bf9e903ca80ebe15096273ef3964cd7074aa71ba", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=49bde17554926a2352b7f1df98d4e02becc1e065", "patch": "@@ -130,6 +130,10 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   tree parm;\n   int param_num;\n \n+  /* We do not copy DECL_ARGUMENTS to virtual clones.  */\n+  while (node->clone_of)\n+    node = node->clone_of;\n+\n   fndecl = node->symbol.decl;\n   fnargs = DECL_ARGUMENTS (fndecl);\n   param_num = 0;\n@@ -166,6 +170,7 @@ ipa_initialize_node_params (struct cgraph_node *node)\n   if (!info->descriptors.exists ())\n     {\n       int param_count;\n+      gcc_assert (!node->clone_of);\n \n       param_count = count_formal_params (node->symbol.decl);\n       if (param_count)"}, {"sha": "d60213a5cb5fae87d9250fb05896f4a8d359da59", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=49bde17554926a2352b7f1df98d4e02becc1e065", "patch": "@@ -1549,17 +1549,10 @@ output_node_opt_summary (struct output_block *ob,\n   streamer_write_uhwi (ob, vec_safe_length (node->clone.tree_map));\n   FOR_EACH_VEC_SAFE_ELT (node->clone.tree_map, i, map)\n     {\n-      int parm_num;\n-      tree parm;\n-\n-      for (parm_num = 0, parm = DECL_ARGUMENTS (node->symbol.decl); parm;\n-\t   parm = DECL_CHAIN (parm), parm_num++)\n-\tif (map->old_tree == parm)\n-\t  break;\n       /* At the moment we assume all old trees to be PARM_DECLs, because we have no\n          mechanism to store function local declarations into summaries.  */\n-      gcc_assert (parm);\n-      streamer_write_uhwi (ob, parm_num);\n+      gcc_assert (!map->old_tree);\n+      streamer_write_uhwi (ob, map->parm_num);\n       gcc_assert (EXPR_LOCATION (map->new_tree) == UNKNOWN_LOCATION);\n       stream_write_tree (ob, map->new_tree, true);\n       bp = bitpack_create (ob->main_stream);"}, {"sha": "9b2c815de2119e086df1e2aa915c4871bbab212f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bde17554926a2352b7f1df98d4e02becc1e065/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=49bde17554926a2352b7f1df98d4e02becc1e065", "patch": "@@ -2057,6 +2057,11 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n   gcov_type count_scale;\n \n+  if (!DECL_ARGUMENTS (new_fndecl))\n+    DECL_ARGUMENTS (new_fndecl) = DECL_ARGUMENTS (callee_fndecl);\n+  if (!DECL_RESULT (new_fndecl))\n+    DECL_RESULT (new_fndecl) = DECL_RESULT (callee_fndecl);\n+\n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale\n         = GCOV_COMPUTE_SCALE (count,"}]}