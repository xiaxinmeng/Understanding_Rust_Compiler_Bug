{"sha": "add4cbca8cf60d1108959de10a6c4b66d90464dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRkNGNiY2E4Y2Y2MGQxMTA4OTU5ZGUxMGE2YzRiNjZkOTA0NjRkYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-09-03T07:51:56Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-09-03T07:51:56Z"}, "message": "Make __builtin_expect effective in switch statements (PR middle-end/PR59521).\n\n2018-09-03  Martin Liska  <mliska@suse.cz>\n\n  PR middle-end/59521\n\t* predict.c (set_even_probabilities): Add likely_edges\n        argument and handle cases where we have precisely one\n        likely edge.\n\t(combine_predictions_for_bb): Catch also likely_edges.\n\t(tree_predict_by_opcode): Handle gswitch statements.\n\t* tree-cfg.h (find_case_label_for_value): New declaration.\n\t(find_taken_edge_switch_expr): Likewise.\n\t* tree-switch-conversion.c (switch_decision_tree::balance_case_nodes):\n        Find pivot in decision tree based on probabily, not by number of\n        nodes.\n2018-09-03  Martin Liska  <mliska@suse.cz>\n\n  PR middle-end/59521\n\t* c-c++-common/pr59521-1.c: New test.\n\t* c-c++-common/pr59521-2.c: New test.\n\t* gcc.dg/tree-prof/pr59521-3.c: New test.\n\nFrom-SVN: r264050", "tree": {"sha": "42056a80e427e22c26a9f90994acf4d459f9b414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42056a80e427e22c26a9f90994acf4d459f9b414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/add4cbca8cf60d1108959de10a6c4b66d90464dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/add4cbca8cf60d1108959de10a6c4b66d90464dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/add4cbca8cf60d1108959de10a6c4b66d90464dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/add4cbca8cf60d1108959de10a6c4b66d90464dc/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "106fd43fee5e964ddf3017cfd3de1046978d490d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106fd43fee5e964ddf3017cfd3de1046978d490d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106fd43fee5e964ddf3017cfd3de1046978d490d"}], "stats": {"total": 239, "additions": 191, "deletions": 48}, "files": [{"sha": "71bf60fffaace735a80cfa80e47799c5d470aaca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -1,3 +1,17 @@\n+2018-09-03  Martin Liska  <mliska@suse.cz>\n+\n+\tPR middle-end/59521\n+\t* predict.c (set_even_probabilities): Add likely_edges\n+\targument and handle cases where we have precisely one\n+\tlikely edge.\n+\t(combine_predictions_for_bb): Catch also likely_edges.\n+\t(tree_predict_by_opcode): Handle gswitch statements.\n+\t* tree-cfg.h (find_case_label_for_value): New declaration.\n+\t(find_taken_edge_switch_expr): Likewise.\n+\t* tree-switch-conversion.c (switch_decision_tree::balance_case_nodes):\n+\tFind pivot in decision tree based on probabily, not by number of\n+\tnodes.\n+\n 2018-09-02  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/standards.texi (Standards): Update Objective-C reference."}, {"sha": "51145526d2a168fe242eeceb303a5f1204c496d4", "filename": "gcc/predict.c", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -827,11 +827,14 @@ unlikely_executed_bb_p (basic_block bb)\n /* We can not predict the probabilities of outgoing edges of bb.  Set them\n    evenly and hope for the best.  If UNLIKELY_EDGES is not null, distribute\n    even probability for all edges not mentioned in the set.  These edges\n-   are given PROB_VERY_UNLIKELY probability.  */\n+   are given PROB_VERY_UNLIKELY probability.  Similarly for LIKELY_EDGES,\n+   if we have exactly one likely edge, make the other edges predicted\n+   as not probable.  */\n \n static void\n set_even_probabilities (basic_block bb,\n-\t\t\thash_set<edge> *unlikely_edges = NULL)\n+\t\t\thash_set<edge> *unlikely_edges = NULL,\n+\t\t\thash_set<edge_prediction *> *likely_edges = NULL)\n {\n   unsigned nedges = 0, unlikely_count = 0;\n   edge e = NULL;\n@@ -843,7 +846,7 @@ set_even_probabilities (basic_block bb,\n       all -= e->probability;\n     else if (!unlikely_executed_edge_p (e))\n       {\n-        nedges ++;\n+\tnedges++;\n         if (unlikely_edges != NULL && unlikely_edges->contains (e))\n \t  {\n \t    all -= profile_probability::very_unlikely ();\n@@ -852,26 +855,54 @@ set_even_probabilities (basic_block bb,\n       }\n \n   /* Make the distribution even if all edges are unlikely.  */\n+  unsigned likely_count = likely_edges ? likely_edges->elements () : 0;\n   if (unlikely_count == nedges)\n     {\n       unlikely_edges = NULL;\n       unlikely_count = 0;\n     }\n \n-  unsigned c = nedges - unlikely_count;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->probability.initialized_p ())\n-      ;\n-    else if (!unlikely_executed_edge_p (e))\n-      {\n-\tif (unlikely_edges != NULL && unlikely_edges->contains (e))\n-\t  e->probability = profile_probability::very_unlikely ();\n+  /* If we have one likely edge, then use its probability and distribute\n+     remaining probabilities as even.  */\n+  if (likely_count == 1)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->probability.initialized_p ())\n+\t  ;\n+\telse if (!unlikely_executed_edge_p (e))\n+\t  {\n+\t    edge_prediction *prediction = *likely_edges->begin ();\n+\t    int p = prediction->ep_probability;\n+\t    profile_probability prob\n+\t      = profile_probability::from_reg_br_prob_base (p);\n+\t    profile_probability remainder = prob.invert ();\n+\n+\t    if (prediction->ep_edge == e)\n+\t      e->probability = prob;\n+\t    else\n+\t      e->probability = remainder.apply_scale (1, nedges - 1);\n+\t  }\n \telse\n-\t  e->probability = all.apply_scale (1, c).guessed ();\n-      }\n-    else\n-      e->probability = profile_probability::never ();\n+\t  e->probability = profile_probability::never ();\n+    }\n+  else\n+    {\n+      /* Make all unlikely edges unlikely and the rest will have even\n+\t probability.  */\n+      unsigned scale = nedges - unlikely_count;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->probability.initialized_p ())\n+\t  ;\n+\telse if (!unlikely_executed_edge_p (e))\n+\t  {\n+\t    if (unlikely_edges != NULL && unlikely_edges->contains (e))\n+\t      e->probability = profile_probability::very_unlikely ();\n+\t    else\n+\t      e->probability = all.apply_scale (1, scale);\n+\t  }\n+\telse\n+\t  e->probability = profile_probability::never ();\n+    }\n }\n \n /* Add REG_BR_PROB note to JUMP with PROB.  */\n@@ -1175,18 +1206,24 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n   if (nedges != 2)\n     {\n       hash_set<edge> unlikely_edges (4);\n+      hash_set<edge_prediction *> likely_edges (4);\n \n       /* Identify all edges that have a probability close to very unlikely.\n \t Doing the approach for very unlikely doesn't worth for doing as\n \t there's no such probability in SPEC2006 benchmark.  */\n       edge_prediction **preds = bb_predictions->get (bb);\n       if (preds)\n \tfor (pred = *preds; pred; pred = pred->ep_next)\n-\t  if (pred->ep_probability <= PROB_VERY_UNLIKELY)\n-\t    unlikely_edges.add (pred->ep_edge);\n+\t  {\n+\t    if (pred->ep_probability <= PROB_VERY_UNLIKELY)\n+\t      unlikely_edges.add (pred->ep_edge);\n+\t    if (pred->ep_probability >= PROB_VERY_LIKELY\n+\t\t|| pred->ep_predictor == PRED_BUILTIN_EXPECT)\n+\t      likely_edges.add (pred);\n+\t  }\n \n       if (!dry_run)\n-\tset_even_probabilities (bb, &unlikely_edges);\n+\tset_even_probabilities (bb, &unlikely_edges, &likely_edges);\n       clear_bb_predictions (bb);\n       if (dump_file)\n \t{\n@@ -2575,7 +2612,30 @@ tree_predict_by_opcode (basic_block bb)\n   enum br_predictor predictor;\n   HOST_WIDE_INT probability;\n \n-  if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n+  if (!stmt)\n+    return;\n+\n+  if (gswitch *sw = dyn_cast <gswitch *> (stmt))\n+    {\n+      tree index = gimple_switch_index (sw);\n+      tree val = expr_expected_value (index, auto_bitmap (),\n+\t\t\t\t      &predictor, &probability);\n+      if (val && TREE_CODE (val) == INTEGER_CST)\n+\t{\n+\t  edge e = find_taken_edge_switch_expr (sw, val);\n+\t  if (predictor == PRED_BUILTIN_EXPECT)\n+\t    {\n+\t      int percent = PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY);\n+\t      gcc_assert (percent >= 0 && percent <= 100);\n+\t      predict_edge (e, PRED_BUILTIN_EXPECT,\n+\t\t\t    HITRATE (percent));\n+\t    }\n+\t  else\n+\t    predict_edge_def (e, predictor, TAKEN);\n+\t}\n+    }\n+\n+  if (gimple_code (stmt) != GIMPLE_COND)\n     return;\n   FOR_EACH_EDGE (then_edge, ei, bb->succs)\n     if (then_edge->flags & EDGE_TRUE_VALUE)"}, {"sha": "e4eaeb7ef82962700e8853006104f8e6339ecb84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -1,3 +1,10 @@\n+2018-09-03  Martin Liska  <mliska@suse.cz>\n+\n+\tPR middle-end/59521\n+\t* c-c++-common/pr59521-1.c: New test.\n+\t* c-c++-common/pr59521-2.c: New test.\n+\t* gcc.dg/tree-prof/pr59521-3.c: New test.\n+\n 2018-09-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* c-c++-common/array-init.c: New test."}, {"sha": "32320b57052c4accf43ba511abb3e01118038329", "filename": "gcc/testsuite/c-c++-common/pr59521-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr59521-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr59521-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr59521-1.c?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2\" } */\n+/* { dg-do compile } */\n+\n+extern int puts (const char *);\n+\n+void\n+f(int ch) {\n+  switch (ch) {\n+    case 3: puts(\"a\"); break;\n+    case 42: puts(\"e\"); break;\n+    case 333: puts(\"i\"); break;\n+  } \n+}\n+\n+/* { dg-final { scan-assembler \"cmp.*42,.*cmp.*333,.*cmp.*3,\" { target i?86-*-* x86_64-*-* } } } */"}, {"sha": "3c48825b347b27fb977006c0dbf8204afd26500e", "filename": "gcc/testsuite/c-c++-common/pr59521-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr59521-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr59521-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr59521-2.c?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2\" } */\n+/* { dg-do compile } */\n+\n+extern int puts (const char *);\n+\n+void\n+f(int ch) {\n+  switch (__builtin_expect(ch, 333)) {\n+    case 3: puts(\"a\"); break;\n+    case 42: puts(\"e\"); break;\n+    case 333: puts(\"i\"); break;\n+  } \n+}\n+\n+/* { dg-final { scan-assembler \"cmp.*333,.*cmp.*3,.*cmp.*42,\" { target i?86-*-* x86_64-*-* } } } */"}, {"sha": "497643bed3dbcf5581b24f927d0d140c27db512c", "filename": "gcc/testsuite/gcc.dg/tree-prof/pr59521-3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr59521-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr59521-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr59521-3.c?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-options \"-O2 -save-temps\" } */\n+\n+#include <stdio.h>\n+\n+__attribute__((noinline,noclone)) void\n+sink(const char *s) {\n+  asm(\"\" :: \"r\"(s));\n+}\n+\n+void\n+foo(int ch) {\n+  switch (ch) {\n+    case 100: sink(\"100\"); break;\n+    case 10: sink(\"10\"); break;\n+    case 1: sink(\"1\"); break;\n+    } \n+}\n+\n+int main()\n+{\n+  for (int i = 0; i < 10000; i++)\n+  {\n+    int v;\n+    if (i % 100 == 0)\n+      v = 100;\n+    else if(i % 10 == 0)\n+      v = 10;\n+    else\n+      v = 1;\n+    foo(v);\n+  }\n+}\n+\n+/* { dg-final-use-not-autofdo { scan-assembler \"\\nfoo:\\n.*cmp.*1,.*cmp.*10,.*cmp.*100\" { target i?86-*-* x86_64-*-* } } } */"}, {"sha": "87979bc4d753465d56dbc4ee37c55afb70aa85a7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -171,8 +171,6 @@ static bool gimple_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (const gcond *, tree);\n-static edge find_taken_edge_switch_expr (const gswitch *, tree);\n-static tree find_case_label_for_value (const gswitch *, tree);\n static void lower_phi_internal_fn ();\n \n void\n@@ -2436,7 +2434,7 @@ find_taken_edge_cond_expr (const gcond *cond_stmt, tree val)\n    If VAL is NULL_TREE, then the current value of SWITCH_STMT's index\n    is used.  */\n \n-static edge\n+edge\n find_taken_edge_switch_expr (const gswitch *switch_stmt, tree val)\n {\n   basic_block dest_bb;\n@@ -2466,7 +2464,7 @@ find_taken_edge_switch_expr (const gswitch *switch_stmt, tree val)\n    We can make optimal use here of the fact that the case labels are\n    sorted: We can do a binary search for a case matching VAL.  */\n \n-static tree\n+tree\n find_case_label_for_value (const gswitch *switch_stmt, tree val)\n {\n   size_t low, high, n = gimple_switch_num_labels (switch_stmt);"}, {"sha": "95c070a2fb2bd6d56c0257b9023df23db892ff0a", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -102,6 +102,8 @@ extern tree gimplify_build2 (gimple_stmt_iterator *, enum tree_code,\n extern tree gimplify_build1 (gimple_stmt_iterator *, enum tree_code,\n \t\t\t     tree, tree);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n+extern tree find_case_label_for_value (const gswitch *switch_stmt, tree val);\n+extern edge find_taken_edge_switch_expr (const gswitch *switch_stmt, tree val);\n extern unsigned int execute_fixup_cfg (void);\n extern unsigned int split_critical_edges (void);\n extern basic_block insert_cond_bb (basic_block, gimple *, gimple *,"}, {"sha": "d7d1c3972a063736652d46a1d033548d926df15d", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add4cbca8cf60d1108959de10a6c4b66d90464dc/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=add4cbca8cf60d1108959de10a6c4b66d90464dc", "patch": "@@ -1914,6 +1914,7 @@ switch_decision_tree::balance_case_nodes (case_tree_node **head,\n       int ranges = 0;\n       case_tree_node **npp;\n       case_tree_node *left;\n+      profile_probability prob = profile_probability::never ();\n \n       /* Count the number of entries on branch.  Also count the ranges.  */\n \n@@ -1923,6 +1924,7 @@ switch_decision_tree::balance_case_nodes (case_tree_node **head,\n \t    ranges++;\n \n \t  i++;\n+\t  prob += np->m_c->m_prob;\n \t  np = np->m_right;\n \t}\n \n@@ -1931,39 +1933,35 @@ switch_decision_tree::balance_case_nodes (case_tree_node **head,\n \t  /* Split this list if it is long enough for that to help.  */\n \t  npp = head;\n \t  left = *npp;\n+\t  profile_probability pivot_prob = prob.apply_scale (1, 2);\n \n-\t  /* If there are just three nodes, split at the middle one.  */\n-\t  if (i == 3)\n-\t    npp = &(*npp)->m_right;\n-\t  else\n+\t  /* Find the place in the list that bisects the list's total cost,\n+\t     where ranges count as 2.  */\n+\t  while (1)\n \t    {\n-\t      /* Find the place in the list that bisects the list's total cost,\n-\t\t where ranges count as 2.\n-\t\t Here I gets half the total cost.  */\n-\t      i = (i + ranges + 1) / 2;\n-\t      while (1)\n-\t\t{\n-\t\t  /* Skip nodes while their cost does not reach that amount.  */\n-\t\t  if (!tree_int_cst_equal ((*npp)->m_c->get_low (),\n-\t\t\t\t\t   (*npp)->m_c->get_high ()))\n-\t\t    i--;\n-\t\t  i--;\n-\t\t  if (i <= 0)\n-\t\t    break;\n-\t\t  npp = &(*npp)->m_right;\n-\t\t}\n+\t      /* Skip nodes while their probability does not reach\n+\t\t that amount.  */\n+\t      prob -= (*npp)->m_c->m_prob;\n+\t      if (prob.initialized_p ()\n+\t\t  && (prob < pivot_prob || ! (*npp)->m_right))\n+\t\tbreak;\n+\t      npp = &(*npp)->m_right;\n \t    }\n-\t  *head = np = *npp;\n-\t  *npp = 0;\n+\n+\t  np = *npp;\n+ \t  *npp = 0;\n+\t  *head = np;\n \t  np->m_parent = parent;\n-\t  np->m_left = left;\n+\t  np->m_left = left == np ? NULL : left;\n \n \t  /* Optimize each of the two split parts.  */\n \t  balance_case_nodes (&np->m_left, np);\n \t  balance_case_nodes (&np->m_right, np);\n \t  np->m_c->m_subtree_prob = np->m_c->m_prob;\n-\t  np->m_c->m_subtree_prob += np->m_left->m_c->m_subtree_prob;\n-\t  np->m_c->m_subtree_prob += np->m_right->m_c->m_subtree_prob;\n+\t  if (np->m_left)\n+\t    np->m_c->m_subtree_prob += np->m_left->m_c->m_subtree_prob;\n+\t  if (np->m_right)\n+\t    np->m_c->m_subtree_prob += np->m_right->m_c->m_subtree_prob;\n \t}\n       else\n \t{"}]}