{"sha": "6bc0ff89a187517f1b11669f7065945395eeafdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJjMGZmODlhMTg3NTE3ZjFiMTE2NjlmNzA2NTk0NTM5NWVlYWZkZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-06-19T18:19:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-06-19T18:19:03Z"}, "message": "Add rtx costs for sse integer ops\n\nFrom-SVN: r188785", "tree": {"sha": "a27ef5f50fd15fbf5381eb03b6c36cb9e1cbde6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a27ef5f50fd15fbf5381eb03b6c36cb9e1cbde6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bc0ff89a187517f1b11669f7065945395eeafdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc0ff89a187517f1b11669f7065945395eeafdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc0ff89a187517f1b11669f7065945395eeafdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc0ff89a187517f1b11669f7065945395eeafdd/comments", "author": null, "committer": null, "parents": [{"sha": "b1f75d7653bd85fdd441cbfc5ca7891638caa5cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f75d7653bd85fdd441cbfc5ca7891638caa5cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1f75d7653bd85fdd441cbfc5ca7891638caa5cc"}], "stats": {"total": 55, "additions": 45, "deletions": 10}, "files": [{"sha": "f0cfa2d9d39a5aaa915aa119a3b2e2b86246bdde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bc0ff89a187517f1b11669f7065945395eeafdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bc0ff89a187517f1b11669f7065945395eeafdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bc0ff89a187517f1b11669f7065945395eeafdd", "patch": "@@ -1,3 +1,8 @@\n+2012-06-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_rtx_costs): Handle CONST_VECTOR, and\n+\tintegral vector modes.\n+\n 2012-06-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (FRNDINT_ROUNDING): New int iterator."}, {"sha": "578a7565dea828eb6aa62343ac44049a21ba516e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bc0ff89a187517f1b11669f7065945395eeafdd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bc0ff89a187517f1b11669f7065945395eeafdd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6bc0ff89a187517f1b11669f7065945395eeafdd", "patch": "@@ -31990,13 +31990,16 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int opno, int *total,\n \t    break;\n \t  case 0:\n \t  case -1:\n-\t    /* Start with (MEM (SYMBOL_REF)), since that's where\n-\t       it'll probably end up.  Add a penalty for size.  */\n-\t    *total = (COSTS_N_INSNS (1)\n-\t\t      + (flag_pic != 0 && !TARGET_64BIT)\n-\t\t      + (mode == SFmode ? 0 : mode == DFmode ? 1 : 2));\n \t    break;\n \t  }\n+      /* FALLTHRU */\n+\n+    case CONST_VECTOR:\n+      /* Start with (MEM (SYMBOL_REF)), since that's where\n+\t it'll probably end up.  Add a penalty for size.  */\n+      *total = (COSTS_N_INSNS (1)\n+\t\t+ (flag_pic != 0 && !TARGET_64BIT)\n+\t\t+ (mode == SFmode ? 0 : mode == DFmode ? 1 : 2));\n       return true;\n \n     case ZERO_EXTEND:\n@@ -32016,8 +32019,9 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int opno, int *total,\n       return false;\n \n     case ASHIFT:\n-      if (CONST_INT_P (XEXP (x, 1))\n-\t  && (GET_MODE (XEXP (x, 0)) != DImode || TARGET_64BIT))\n+      if (SCALAR_INT_MODE_P (mode)\n+\t  && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n+\t  && CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  HOST_WIDE_INT value = INTVAL (XEXP (x, 1));\n \t  if (value == 1)\n@@ -32038,7 +32042,15 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int opno, int *total,\n     case ASHIFTRT:\n     case LSHIFTRT:\n     case ROTATERT:\n-      if (!TARGET_64BIT && GET_MODE (XEXP (x, 0)) == DImode)\n+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t{\n+\t  /* ??? Should be SSE vector operation cost.  */\n+\t  /* At least for published AMD latencies, this really is the same\n+\t     as the latency for a simple fpu operation like fabs.  */\n+\t  *total = cost->fabs;\n+\t  return false;\n+\t}\n+      if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{\n \t  if (CONST_INT_P (XEXP (x, 1)))\n \t    {\n@@ -32107,6 +32119,16 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int opno, int *total,\n \t  *total = cost->fmul;\n \t  return false;\n \t}\n+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t{\n+\t  /* Without sse4.1, we don't have PMULLD; it's emulated with 7\n+\t     insns, including two PMULUDQ.  */\n+\t  if (mode == V4SImode && !(TARGET_SSE4_1 || TARGET_AVX))\n+\t    *total = cost->fmul * 2 + cost->fabs * 5;\n+\t  else\n+\t    *total = cost->fmul;\n+\t  return false;\n+\t}\n       else\n \t{\n \t  rtx op0 = XEXP (x, 0);\n@@ -32171,7 +32193,7 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int opno, int *total,\n \n     case PLUS:\n       if (GET_MODE_CLASS (mode) == MODE_INT\n-\t       && GET_MODE_BITSIZE (mode) <= GET_MODE_BITSIZE (Pmode))\n+\t  && GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n@@ -32271,6 +32293,14 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int opno, int *total,\n       /* FALLTHRU */\n \n     case NOT:\n+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t{\n+\t  /* ??? Should be SSE vector operation cost.  */\n+\t  /* At least for published AMD latencies, this really is the same\n+\t     as the latency for a simple fpu operation like fabs.  */\n+\t  *total = cost->fabs;\n+\t  return false;\n+\t}\n       if (!TARGET_64BIT && mode == DImode)\n \t*total = cost->add * 2;\n       else\n@@ -32331,7 +32361,7 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int opno, int *total,\n       /* ??? Assume all of these vector manipulation patterns are\n \t recognizable.  In which case they all pretty much have the\n \t same cost.  */\n-     *total = COSTS_N_INSNS (1);\n+     *total = cost->fabs;\n      return true;\n \n     default:"}]}