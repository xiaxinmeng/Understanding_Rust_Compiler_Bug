{"sha": "394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0MTQyZDg3YzkxMWJiYTBjZGM4YzViZTdhZTdkMmNmYzljMzZjMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-07T08:50:16Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-07T08:50:16Z"}, "message": "Initial revision\n\nFrom-SVN: r289", "tree": {"sha": "d03eebf9c659c8c7025d6d32d7516c41d5907ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d03eebf9c659c8c7025d6d32d7516c41d5907ec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2/comments", "author": null, "committer": null, "parents": [{"sha": "48f50d01bea3e35827e35625167c7a4696e5d1ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f50d01bea3e35827e35625167c7a4696e5d1ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f50d01bea3e35827e35625167c7a4696e5d1ce"}], "stats": {"total": 777, "additions": 777, "deletions": 0}, "files": [{"sha": "3ad6bc40106713af60481e530f188d6990f949d0", "filename": "gcc/config/m68k/mot3300.h", "status": "added", "additions": 777, "deletions": 0, "changes": 777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=394142d87c911bba0cdc8c5be7ae7d2cfc9c36c2", "patch": "@@ -0,0 +1,777 @@\n+/* Definitions of target machine for GNU compiler.  \n+   SysV68 Motorola 3300 Delta Series\n+\n+   Written by Abramo and Roberto Bagnara\n+   after Alex Crain's 3B1 definitions.\n+\n+   Bug reports to bagnara@dipisa.di.unipi.it\n+\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n+#define SGS\t\t\t/* Uses SGS assembler */\n+#define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n+#define SGS_SWAP_W\t\t/* Use swap.w rather than just plain swap */\n+#define SGS_SWITCH_TABLES\t/* Different switch table handling */\n+\n+#include \"m68k.h\"\n+\n+/* See m68k.h.  7 means 68020 with 68881.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define\tTARGET_DEFAULT 7\n+#endif\n+\n+/* NYI: FP= is equivalent to -msoft-float  */\n+\n+/* We use /lib/libp/lib* when profiling.  */\n+\n+/* NYI: if FP=M68881U library is -lc881u  */\n+/* NYI: if FP= library is -lc.  */\n+/* Default for us: FP=M68881 library is -lc881  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!shlib:%{p:-L/usr/lib/libp} %{pg:-L/usr/lib/libp} -lc881}\"\n+\n+#define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__}\"\n+\n+/* Shared libraries need to use crt0s.o  */\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n+   %{shlib:crt0s.o%s shlib.ifile%s} \"\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.  */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* cpp has to support a #sccs directive for the /usr/include files */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Make output for SDB.  */\n+\n+#define SDB_DEBUGGING_INFO\n+\n+#undef REGISTER_NAMES\n+#define REGISTER_NAMES \\\n+{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n+ \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%fp\", \"%sp\",\t\\\n+ \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n+\n+#undef FUNCTION_PROLOGUE\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = (SIZE);\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    { if (fsize < 0x8000)\t\t\t\t\t\\\n+        fprintf (FILE, \"\\tlink.w %%fp,&%d\\n\", -fsize);\t\t\\\n+      else if (TARGET_68020)\t\t\t\t\t\\\n+        fprintf (FILE, \"\\tlink.l %%fp,&%d\\n\", -fsize);\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tlink.w %%fp,&0\\n\\tsub.l &%d,%%sp\\n\", fsize); }  \\\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (regno - 16);\t\t\t\t\\\n+  if (mask != 0)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tfmovem &0x%x,-(%%sp)\\n\", mask & 0xff);\t\\\n+  mask = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (15 - regno);\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n+  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[15 - exact_log2 (mask)]);  \\\n+  else if (mask) fprintf (FILE, \"\\tmovm.l &0x%x,-(%%sp)\\n\", mask); }\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n+    fprintf (FILE, \"\\tmov.l &LP%%%d,%%a0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n+\n+#undef FUNCTION_EPILOGUE\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask, fmask;\t\t\t\t\t\\\n+  register int nregs;\t\t\t\t\t\t\\\n+  int offset, foffset;\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = (SIZE);\t\t\t\t\t\t\\\n+  int big = 0;\t\t\t\t\t\t\t\\\n+  nregs = 0;  fmask = 0;\t\t\t\t\t\\\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n+  foffset = nregs * 12;\t\t\t\t\t\t\\\n+  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n+  offset = foffset + nregs * 4;\t\t\t\t\t\\\n+  if (offset + fsize >= 0x8000 && frame_pointer_needed)\t\t\\\n+    { fprintf (FILE, \"\\tmov.l &%d,%%a0\\n\", -fsize);\t\t\\\n+      fsize = 0, big = 1; }\t\t\t\t\t\\\n+  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l -%d(%%fp,%%a0.l),%s\\n\",\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\",\t\t\t\\\n+\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l -%d(%%fp),%s\\n\",\t\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n+  else if (mask) {\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l -%d(%%fp,%%a0.l),&0x%x\\n\",\t\\\n+\t       offset + fsize, mask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l (%%sp)+,&0x%x\\n\", mask);\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l -%d(%%fp),&0x%x\\n\",\t\t\\\n+\t       offset + fsize, mask); }\t\t\t\t\\\n+  if (fmask) {\t\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem -%d(%%fp,%%a0.l),&0x%x\\n\",\t\\\n+\t       foffset + fsize, fmask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem (%%sp)+,&0x%x\\n\", fmask);\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem -%d(%%fp),&0x%x\\n\",\t\t\\\n+\t       foffset + fsize, fmask); }\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tunlk %%fp\\n\");\t\t\t\t\\\n+  if (current_function_pops_args)\t\t\t\t\\\n+    fprintf (FILE, \"\\trtd &%d\\n\", current_function_pops_args);\t\\\n+  else fprintf (FILE, \"\\trts\\n\"); }\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_PUSH\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_POP\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\", reg_names[REGNO])\n+\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \"\"\n+\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF \"\"\n+\n+/* We like aligned sources, and maybe our as will like them.  */\n+\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP \"\\ttext\"\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP \"\\tdata\"\n+#undef ASCII_DATA_ASM_OP\n+#define\tASCII_DATA_ASM_OP \"\\tbyte\"\n+\n+/* The file command should always begin the output.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) \\\n+output_file_directive ((FILE), main_input_filename)\n+\n+/* Don't try to define `gcc_compiled.' since the assembler might not\n+   accept symbols with periods and GDB doesn't run on this machine anyway.  */\n+\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+/* ihnp4!lmayk!lgm@eddie.mit.edu says mc68000 and m68k should not be here,\n+   on the other hand I don't care what he says.  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dm68k -Dunix -DsysV68\"\n+\n+/* Specify how to pad function arguments.\n+   Value should be `upward', `downward' or `none'.\n+   Same as the default, except no padding for large or variable-size args.  */\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n+  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n+    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE))\t== INTEGER_CST\t\t\\\n+       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n+    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n+   ? downward : none)\n+\n+/* Override part of the obstack macros.  */\n+\n+#define __PTR_TO_INT(P) ((int)(P))\n+#define __INT_TO_PTR(P) ((char *)(P))\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (68k, SGS/AT&T sysV68 syntax)\");\n+\n+/* Function calls save all but a0, a1, d0, d1, fp0, fp1.  */\n+\n+#undef CALL_USED_REGISTERS\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+ {1, 1, 0, 0, 0, 0, 0, 0,\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 1,\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0}\n+\n+/* If TARGET_68881, return SF and DF values in fp0 instead of d0.  */\n+/* NYI: If FP=M68881U return SF and DF values in d0. */\n+/* NYI: If -mold return pointer in a0 and d0 */\n+\n+#undef FUNCTION_VALUE\n+#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE(TYPE_MODE(VALTYPE))\n+\n+/* sysV68 (brain damaged) cc convention support. */\n+/* Commented out until we find a safe way to make it optional.  */\n+#if 0\n+#define FUNCTION_VALUE(VALTYPE,FUNC) \\\n+  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881 \t\\\n+   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)\t\t\\\n+   : (TREE_CODE (VALTYPE) == POINTER_TYPE \t\t\\\n+      ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8)\t\t\\\n+      : gen_rtx (REG, TYPE_MODE (VALTYPE), 0)))\n+#endif\n+\n+/* If TARGET_68881, SF and DF values are returned in fp0 instead of d0.  */\n+\n+#undef LIBCALL_VALUE\n+#define LIBCALL_VALUE(MODE) \\\n+ gen_rtx (REG, (MODE), ((TARGET_68881 && ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0))\n+\n+/* 1 if N is a possible register number for a function value.\n+   d0 may be used, and fp0 as well if -msoft-float is not specified.  */\n+\n+#undef FUNCTION_VALUE_REGNO_P\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+ ((N) == 0 || (TARGET_68881 && (N) == 16))\n+\n+/* sysV68 (brain damaged) cc convention support. */\n+/* Commented out until we find a safe way to make it optional.  */\n+#if 0\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+ ((N) == 0 || (N) == 8 || (TARGET_68881 && (N) == 16))\n+#endif \n+ \n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\tglobal \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n+  sprintf ((OUTPUT), \"%s_%%%d\", (NAME), (LABELNO)))\n+\n+/* The sysV68 as doesn't know about double's and float's.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+do { union { double d; long l[2]; } tem;\t\t\t\\\n+     tem.d = (VALUE);\t\t\t\t\t\t\\\n+     fprintf(FILE, \"\\tlong 0x%x,0x%x\\n\", tem.l[0], tem.l[1]);\t\\\n+   } while (0)\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+do { union { float f; long l;} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf (FILE, \"\\tlong 0x%x\\n\", tem.l);\t\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#undef ASM_OUTPUT_INT\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tlong \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#undef ASM_OUTPUT_SHORT\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tshort \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#undef ASM_OUTPUT_CHAR\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tbyte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#undef ASM_OUTPUT_BYTE\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tbyte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) == 1)\t\t\t\\\n+    fprintf (FILE, \"\\teven\\n\");\t\t\\\n+  else if ((LOG) != 0)\t\t\t\\\n+    abort ();\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\tspace %u\\n\", (SIZE))\n+\n+/* Can't use ASM_OUTPUT_SKIP in text section.  */\n+\n+#define ASM_NO_SKIP_IN_TEXT 1\n+\n+/* The beginnings of sdb support...  */\n+\n+#undef ASM_OUTPUT_SOURCE_FILENAME\n+#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n+  fprintf (FILE, \"\\tfile\\t\\\"%s\\\"\\n\", FILENAME)\n+\n+#undef ASM_OUTPUT_SOURCE_LINE\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n+  fprintf (FILE, \"\\tln\\t%d\\n\",\t\t\t\\\n+\t   (sdb_begin_function_line\t\t\\\n+\t    ? last_linenum - sdb_begin_function_line : 1))\n+\n+/* Yet another null terminated string format.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n+  { register int sp = 0, lp = 0;\t\t\t\t\\\n+    fprintf ((FILE), \"\\tbyte\\t\");\t\t\t\t\\\n+  loop:\t\t\t\t\t\t\t\t\\\n+    if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\')\t\\\n+      { lp += 3;\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"'%c\", (PTR)[sp]); }\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      { lp += 5;\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"0x%x\", (PTR)[sp]); }\t\t\t\\\n+    if (++sp < (LEN))\t\t\t\t\t\t\\\n+      {\tif (lp > 60)\t\t\t\t\t\t\\\n+\t  { lp = 0;\t\t\t\t\t\t\\\n+\t    fprintf ((FILE), \"\\n%s \", ASCII_DATA_ASM_OP); }\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  putc (',', (FILE));\t\t\t\t\t\\\n+\tgoto loop; }\t\t\t\t\t\t\\\n+    putc ('\\n', (FILE)); }\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+   On the 68000, we use several CODE characters:\n+   '.' for dot needed in Motorola-style opcode names.\n+   '-' for an operand pushing on the stack:\n+       sp@-, -(sp) or -(%sp) depending on the style of syntax.\n+   '+' for an operand pushing on the stack:\n+       sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n+   '@' for a reference to the top word on the stack:\n+       sp@, (sp) or (%sp) depending on the style of syntax.\n+   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n+       but & in SGS syntax).\n+   '!' for the cc register (used in an `and to cc' insn).\n+   '$' for the letter `s' in an op code, but only on the 68040.\n+   '&' for the letter `d' in an op code, but only on the 68040.\n+\n+   'b' for byte insn (no effect, on the Sun; this is for the ISI).\n+   'd' to force memory addressing to be absolute, not relative.\n+   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n+       than directly).  Second part of 'y' below.\n+   'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n+       or print pair of registers as rx:ry.\n+   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n+       CONST_DOUBLE's as SunFPA constant RAM registers if\n+       possible, so it should not be used except for the SunFPA.  */\n+\n+#undef PRINT_OPERAND\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (CODE == '.') fprintf (FILE, \".\");\t\t\t\t\t\\\n+  else if (CODE == '#') fprintf (FILE, \"&\");\t\t\t\t\\\n+  else if (CODE == '-') fprintf (FILE, \"-(%%sp)\");\t\t\t\\\n+  else if (CODE == '+') fprintf (FILE, \"(%%sp)+\");\t\t\t\\\n+  else if (CODE == '@') fprintf (FILE, \"(%%sp)\");\t\t\t\\\n+  else if (CODE == '!') fprintf (FILE, \"%%cc\");\t\t\t\t\\\n+  else if (CODE == '$') { if (TARGET_68040_ONLY) fprintf (FILE, \"s\"); }\t\\\n+  else if (CODE == '&') { if (TARGET_68040_ONLY) fprintf (FILE, \"d\"); }\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      union { float f; int i; } u1;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      u1.f = u.d;\t\t\t\t\t\t\t\\\n+      /* Use hex representation even if CODE is f, as needs it.  */\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"&0x%x\", u1.i);\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"&0x%x\", u1.i); }\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      fprintf (FILE, \"&0x%x%x\", u.i[0], u.i[1]); }\t\t\t\\\n+  else { putc ('&', FILE); output_addr_const (FILE, X); }}\n+\n+#undef PRINT_OPERAND_ADDRESS\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PRE_DEC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case POST_INC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n+\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n+/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+  */\t\t\t\t\t\t\t\t\t\\\n+      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n+\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { int scale = 1;\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n+\t    fprintf (FILE, \"12(%%pc,%s.w\",\t\t\t\t\\\n+\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"12(%%pc,%s.l\",\t\t\t\t\\\n+\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  fprintf (FILE, \")\");\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { fprintf (FILE, \"12(%%pc,%s.l\",\t\t\t\t\\\n+\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n+\t{ int scale = 1;\t\t\t\t\t\t\\\n+\t  if (breg == 0)\t\t\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\t\\\n+\t  if (addr != 0)\t\t\t\t\t\t\\\n+\t    output_addr_const (FILE, addr);\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n+\t  if (ireg != 0)\t\t\t\t\t        \\\n+\t    putc (',', FILE);\t\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n+\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n+\t  else if (ireg != 0)\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n+\t{ fprintf (FILE, \"12(%%pc,%s.w)\",\t\t\t\t\\\n+\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n+\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n+\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n+\tfprintf (FILE, \"%d\", INTVAL (addr));\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n+  sprintf ((LABEL), \"%s%%%d\", (PREFIX), (NUM))\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+    fprintf (FILE, \"%s%%%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The 68000 does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n+    fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+    fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n+    fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\",\t\t\t\t\\\n+\t     XVECLEN (PATTERN (TABLE), 1), (PREFIX), (NUM))\n+\t     \n+/* Translate some opcodes to fit the sysV68 assembler syntax.  */\n+/* The opcodes fdmov and fsmov are guesses.  */\n+\n+#define SWITCH_JUMP_MATCH   \"jmp 6(%%pc,\"\n+\n+#undef ASM_OUTPUT_OPCODE\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n+    { ++(PTR);\t\t\t\t\t\t\\\n+      while (*(PTR) != ' ')\t\t\t\t\\\n+\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n+      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n+  else if ((PTR)[0] == 'f')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!strncmp ((PTR), \"fmove\", 5))\t\t\t\\\n+\t{ fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\\\n+      else if (!strncmp ((PTR), \"f%$move\", 7))\t\t\\\n+\t{ if (TARGET_68040_ONLY)\t\t\t\\\n+\t    { fprintf ((FILE), \"fsmov\"); (PTR) += 7; }\t\\\n+\t  else\t\t\t\t\t\t\\\n+\t    { fprintf ((FILE), \"fmov\"); (PTR) += 7; } }\t\\\n+      else if (!strncmp ((PTR), \"f%&move\", 7))\t\t\\\n+\t{ if (TARGET_68040_ONLY)\t\t\t\\\n+\t    { fprintf ((FILE), \"fdmov\"); (PTR) += 7; }\t\\\n+\t  else\t\t\t\t\t\t\\\n+\t    { fprintf ((FILE), \"fmov\"); (PTR) += 7; } }\t\\\n+      else if (!strncmp ((PTR), \"ftst\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"ftest\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"fbne\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"fbneq\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"fsne\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"fsneq\"); (PTR) += 4; }\t\\\n+    }\t\t\t\t\t\t\t\\\n+/* MOVE, MOVEA, MOVEQ, MOVEC ==> MOV\t*/\t\t\\\n+  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n+    { fprintf ((FILE), \"mov\"); (PTR) += 4;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'a' ||\t\\\n+\t   (PTR)[0] == 'c') (PTR)++; }\t\t\t\\\n+/* SUB, SUBQ, SUBA, SUBI ==> SUB */\t\t\t\\\n+  else if ((PTR)[0] == 's' && (PTR)[1] == 'u' \t\t\\\n+\t   && (PTR)[2] == 'b')\t\t\t\t\\\n+    { fprintf ((FILE), \"sub\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'i' || \t\\\n+\t   (PTR)[0] == 'a') (PTR)++; }\t\t\t\\\n+/* CMP, CMPA, CMPI, CMPM ==> CMP\t*/\t\t\\\n+  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n+\t   && (PTR)[2] == 'p')\t\t\t\t\\\n+    { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'a' || (PTR)[0] == 'i' || \t\\\n+\t   (PTR)[0] == 'm') (PTR)++; }\t\t\t\\\n+/* JMP to switch label */\t\t\t\t\\\n+  else if (!strncmp((PTR), (SWITCH_JUMP_MATCH), sizeof(SWITCH_JUMP_MATCH) - 1)) \\\n+    { while (*(PTR)++ != '(');\t\t\t\t\\\n+      fprintf ((FILE), \"jmp 8(\"); }\t\t\t\\\n+}\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\tcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+\f\n+/* Override usual definitions of SDB output macros.\n+   These definitions differ only in the absence of the period\n+   at the beginning of the name of the directive\n+   and in the use of `~' as the symbol for the current location.  */\n+\n+#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\tscl\\t%d;\", (a))\n+#define PUT_SDB_INT_VAL(a) fprintf (asm_out_file, \"\\tval\\t%d;\", (a))\n+#define PUT_SDB_VAL(a)\t\t\t\t\\\n+( fputs (\"\\tval\\t\", asm_out_file),\t\t\\\n+  output_addr_const (asm_out_file, (a)),\t\\\n+  fputc (';', asm_out_file))\n+\n+#define PUT_SDB_DEF(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\tdef\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a); \t\\\n+     fprintf (asm_out_file, \";\"); } while (0)\n+\n+#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\tdef\\t~%s;\",a)\n+#define PUT_SDB_ENDEF fputs(\"\\tendef\\n\", asm_out_file)\n+#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\ttype\\t0%o;\", a)\n+#define PUT_SDB_SIZE(a) fprintf(asm_out_file, \"\\tsize\\t%d;\", a)\n+#define PUT_SDB_START_DIM fprintf(asm_out_file, \"\\tdim\\t\")\n+#define PUT_SDB_NEXT_DIM(a) fprintf(asm_out_file, \"%d,\", a)\n+#define PUT_SDB_LAST_DIM(a) fprintf(asm_out_file, \"%d;\", a)\n+\n+#define PUT_SDB_TAG(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a);\t\\\n+     fprintf (asm_out_file, \";\"); } while (0)\n+\n+#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~bb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~eb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~bf;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~ef;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_EPILOGUE_END(NAME)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t%s;\\tval\\t~;\\tscl\\t-1;\\tendef\\n\",\t\\\n+\t   (NAME))\n+\n+#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n+  sprintf ((BUFFER), \"~%dfake\", (NUMBER));\n+\n+/* Define subroutines to call to handle multiply, divide, and remainder.\n+   Use the subroutines that the 3b1's library provides.\n+   The `*' prevents an underscore from being prepended by the compiler.  */\n+\n+#define DIVSI3_LIBCALL \"*ldiv\"\n+#define UDIVSI3_LIBCALL \"*uldiv\"\n+#define MODSI3_LIBCALL \"*lrem\"\n+#define UMODSI3_LIBCALL \"*ulrem\"\n+#define MULSI3_LIBCALL \"*lmul\"\n+#define UMULSI3_LIBCALL \"*ulmul\""}]}