{"sha": "435ab23636a078a5718e3c515a11e08e37f19479", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM1YWIyMzYzNmEwNzhhNTcxOGUzYzUxNWExMWUwOGUzN2YxOTQ3OQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-07-19T10:19:19Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-07-19T10:19:19Z"}, "message": "c-decl.c (c_finish_incomplete_decl): Don't use xxx_with_decl.\n\n\t* c-decl.c (c_finish_incomplete_decl): Don't use xxx_with_decl.\n\t(pop_label_level): Likewise.\n\t(duplicate_decls): Likewise.\n\t(implicitly_declare): Likewise.\n\t(shadow_label): Likewise.\n\t(start_decl): Likewise.\n\t(finish_decl): Likewise.\n\t(grokdeclarator): Likewise.\n\t(get_parm_info): Likewise.\n\t(detect_field_duplicates): Likewise.\n\t(finish_struct): Likewise.\n\t(start_function): Likewise.\n\t(store_parm_decls): Likewise.\n\t(finish_function): Likewise.\n\t(c_expand_body_1): Likewise.\n\t(check_for_loop_decls): Likewise.\n\t(merge_translation_unit_decls): Likewise.\n\nFrom-SVN: r69582", "tree": {"sha": "3879daf63f2172569e0a77ba7f50564f6c0a8b89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3879daf63f2172569e0a77ba7f50564f6c0a8b89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/435ab23636a078a5718e3c515a11e08e37f19479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435ab23636a078a5718e3c515a11e08e37f19479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/435ab23636a078a5718e3c515a11e08e37f19479", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435ab23636a078a5718e3c515a11e08e37f19479/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2cc980567a3bf9b714295e88392798dd347fa156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cc980567a3bf9b714295e88392798dd347fa156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cc980567a3bf9b714295e88392798dd347fa156"}], "stats": {"total": 370, "additions": 229, "deletions": 141}, "files": [{"sha": "c81b0d0bd94df7b21ee22896f78f261b8e6bbfab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435ab23636a078a5718e3c515a11e08e37f19479/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435ab23636a078a5718e3c515a11e08e37f19479/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=435ab23636a078a5718e3c515a11e08e37f19479", "patch": "@@ -1,3 +1,23 @@\n+2003-07-19  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* c-decl.c (c_finish_incomplete_decl): Don't use xxx_with_decl.\n+\t(pop_label_level): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(implicitly_declare): Likewise.\n+\t(shadow_label): Likewise.\n+\t(start_decl): Likewise.\n+\t(finish_decl): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(get_parm_info): Likewise.\n+\t(detect_field_duplicates): Likewise.\n+\t(finish_struct): Likewise.\n+\t(start_function): Likewise.\n+\t(store_parm_decls): Likewise.\n+\t(finish_function): Likewise.\n+\t(c_expand_body_1): Likewise.\n+\t(check_for_loop_decls): Likewise.\n+\t(merge_translation_unit_decls): Likewise.\n+\n 2003-07-19  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* common.opt:  Document --param."}, {"sha": "d6dfcb7d9a95eb9b068306dfbe674ae90a58fd7e", "filename": "gcc/c-decl.c", "status": "modified", "additions": 209, "deletions": 141, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435ab23636a078a5718e3c515a11e08e37f19479/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435ab23636a078a5718e3c515a11e08e37f19479/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=435ab23636a078a5718e3c515a11e08e37f19479", "patch": "@@ -337,7 +337,8 @@ c_finish_incomplete_decl (tree decl)\n \t  && ! DECL_EXTERNAL (decl)\n \t  && TYPE_DOMAIN (type) == 0)\n \t{\n-\t  warning_with_decl (decl, \"array `%s' assumed to have one element\");\n+\t  warning (\"%Harray '%D' assumed to have one element\",\n+                   &DECL_SOURCE_LOCATION (decl), decl);\n \n \t  complete_array_type (type, NULL_TREE, 1);\n \n@@ -611,12 +612,14 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t  if (DECL_INITIAL (label) == 0)\n \t    {\n-\t      error_with_decl (label, \"label `%s' used but not defined\");\n+\t      error (\"%Hlabel '%D' used but not defined\",\n+                     &DECL_SOURCE_LOCATION (label), label);\n \t      /* Avoid crashing later.  */\n \t      define_label (input_location, DECL_NAME (label));\n \t    }\n \t  else if (warn_unused_label && !TREE_USED (label))\n-\t    warning_with_decl (label, \"label `%s' defined but not used\");\n+\t    warning (\"%Hlabel '%D' defined but not used\",\n+                     &DECL_SOURCE_LOCATION (label), label);\n \t  IDENTIFIER_LABEL_VALUE (DECL_NAME (label)) = 0;\n \n \t  /* Put the labels into the \"variables\" of the\n@@ -701,14 +704,16 @@ pop_label_level (void)\n \t{\n \t  if (DECL_SOURCE_LINE (TREE_VALUE (link)) == 0)\n \t    {\n-\t      error_with_decl (TREE_VALUE (link),\n-\t\t\t       \"label `%s' used but not defined\");\n+\t      error (\"%Hlabel '%D' used but not defined\",\n+                     &DECL_SOURCE_LOCATION (TREE_VALUE (link)),\n+                     TREE_VALUE (link));\n \t      /* Avoid crashing later.  */\n \t      define_label (input_location, DECL_NAME (TREE_VALUE (link)));\n \t    }\n \t  else if (warn_unused_label && !TREE_USED (TREE_VALUE (link)))\n-\t    warning_with_decl (TREE_VALUE (link),\n-\t\t\t       \"label `%s' defined but not used\");\n+\t    warning (\"%Hlabel '%D' defined but not used\",\n+                     &DECL_SOURCE_LOCATION (TREE_VALUE (link)),\n+                     TREE_VALUE (link));\n \t  IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link))) = 0;\n \n \t  /* Delete this element from the list.  */\n@@ -823,19 +828,20 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t   && DECL_UNINLINABLE (olddecl)\n \t\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t    {\n-\t      warning_with_decl (newdecl,\n-\t\t\t\t \"function `%s' redeclared as inline\");\n-\t      warning_with_decl (olddecl,\n-\t\t\t\t \"previous declaration of function `%s' with attribute noinline\");\n+\t      warning (\"%Hfunction '%D' redeclared as inline\",\n+                       &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t      warning (\"%Hprevious declaration of function '%D' \"\n+                       \"with attribute noinline\",\n+                       &DECL_SOURCE_LOCATION (olddecl), olddecl);\n \t    }\n \t  else if (DECL_DECLARED_INLINE_P (olddecl)\n \t\t   && DECL_UNINLINABLE (newdecl)\n \t\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t    {\n-\t      warning_with_decl (newdecl,\n-\t\t\t\t \"function `%s' redeclared with attribute noinline\");\n-\t      warning_with_decl (olddecl,\n-\t\t\t\t \"previous declaration of function `%s' was inline\");\n+\t      warning (\"%Hfunction '%D' redeclared with attribute noinline\",\n+                       &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t      warning (\"%Hprevious declaration of function '%D' was inline\",\n+                       &DECL_SOURCE_LOCATION (olddecl), olddecl);\n \t    }\n \t}\n \n@@ -861,16 +867,19 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t  if (!TREE_PUBLIC (newdecl))\n \t    {\n \t      if (warn_shadow)\n-\t\twarning_with_decl (newdecl, \"shadowing built-in function `%s'\");\n+\t\twarning (\"%Hshadowing built-in function '%D'\",\n+                         &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \t    }\n \t  else\n-\t    warning_with_decl (newdecl,\n-\t\t\t       \"built-in function `%s' declared as non-function\");\n+\t    warning (\"%Hbuilt-in function '%D' declared as non-function\",\n+                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \t}\n       else\n \t{\n-\t  error_with_decl (newdecl, \"`%s' redeclared as different kind of symbol\");\n-\t  error_with_decl (olddecl, \"previous declaration of `%s'\");\n+\t  error (\"%H'%D' redeclared as different kind of symbol\",\n+                 &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t  error (\"%Hprevious declaration of '%D'\",\n+                 &DECL_SOURCE_LOCATION (olddecl), olddecl);\n \t}\n \n       return 0;\n@@ -899,7 +908,8 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t     built-in definition is overridden,\n \t     but optionally warn this was a bad choice of name.  */\n \t  if (warn_shadow)\n-\t    warning_with_decl (newdecl, \"shadowing built-in function `%s'\");\n+\t    warning (\"%Hshadowing built-in function '%D'\",\n+                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \t  /* Discard the old built-in function.  */\n \t  return 0;\n \t}\n@@ -968,7 +978,8 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n       if (!types_match)\n \t{\n \t  /* If types don't match for a built-in, throw away the built-in.  */\n-\t  warning_with_decl (newdecl, \"conflicting types for built-in function `%s'\");\n+\t  warning (\"%Hconflicting types for built-in function '%D'\",\n+                   &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \t  return 0;\n \t}\n     }\n@@ -1011,7 +1022,8 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t&& TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)))\n     {\n       if (pedantic)\n-\tpedwarn_with_decl (newdecl, \"conflicting types for `%s'\");\n+\tpedwarn (\"%Hconflicting types for '%D'\",\n+                 &DECL_SOURCE_LOCATION (newdecl), newdecl);\n       /* Make sure we keep void * as ret type, not char *.  */\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)\n \tTREE_TYPE (newdecl) = newtype = oldtype;\n@@ -1029,7 +1041,8 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t   && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n \t   && C_FUNCTION_IMPLICIT_INT (newdecl))\n     {\n-      pedwarn_with_decl (newdecl, \"conflicting types for `%s'\");\n+      pedwarn (\"%Hconflicting types for '%D'\",\n+               &DECL_SOURCE_LOCATION (newdecl), newdecl);\n       /* Make sure we keep void as the return type.  */\n       TREE_TYPE (newdecl) = newtype = oldtype;\n       C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n@@ -1044,7 +1057,8 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t\t       TREE_TYPE (newtype), comptype_flags)\n \t\t && TYPE_ARG_TYPES (newtype) == 0))\n     {\n-      error_with_decl (newdecl, \"conflicting types for `%s'\");\n+      error (\"%Hconflicting types for '%D'\",\n+             &DECL_SOURCE_LOCATION (newdecl), newdecl);\n       /* Check for function type mismatch\n \t involving an empty arglist vs a nonempty one.  */\n       if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -1079,9 +1093,11 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t    }\n \t}\n       if (C_DECL_IMPLICIT (olddecl))\n-\terror_with_decl (olddecl, \"previous implicit declaration of `%s'\");\n+\terror (\"%Hprevious implicit declaration of '%D'\",\n+               &DECL_SOURCE_LOCATION (olddecl), olddecl);\n       else\n-\terror_with_decl (olddecl, \"previous declaration of `%s'\");\n+\terror (\"%Hprevious declaration of '%D'\",\n+               &DECL_SOURCE_LOCATION (olddecl), olddecl);\n \n       /* This is safer because the initializer might contain references\n \t to variables that were declared between olddecl and newdecl. This\n@@ -1094,54 +1110,62 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n   else if (TREE_CODE (olddecl) == VAR_DECL && TREE_CODE (newdecl) == VAR_DECL\n \t   && !DECL_THREAD_LOCAL (olddecl) && DECL_THREAD_LOCAL (newdecl))\n     {\n-      error_with_decl (newdecl, \"thread-local declaration of `%s' follows non thread-local declaration\");\n-      error_with_decl (olddecl, \"previous declaration of `%s'\");\n+      error (\"%Hthread-local declaration of '%D' follows non thread-local \"\n+             \"declaration\", &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+      error (\"%Hprevious declaration of '%D'\",\n+             &DECL_SOURCE_LOCATION (olddecl), olddecl);\n     }\n   /* non-TLS declaration cannot follow TLS declaration.  */\n   else if (TREE_CODE (olddecl) == VAR_DECL && TREE_CODE (newdecl) == VAR_DECL\n \t   && DECL_THREAD_LOCAL (olddecl) && !DECL_THREAD_LOCAL (newdecl))\n     {\n-      error_with_decl (newdecl, \"non thread-local declaration of `%s' follows thread-local declaration\");\n-      error_with_decl (olddecl, \"previous declaration of `%s'\");\n+      error (\"%Hnon thread-local declaration of '%D' follows \"\n+             \"thread-local declaration\",\n+             &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+      error (\"%Hprevious declaration of '%D'\",\n+             &DECL_SOURCE_LOCATION (olddecl), olddecl);\n     }\n   else\n     {\n       errmsg = redeclaration_error_message (newdecl, olddecl);\n       if (errmsg)\n \t{\n+          const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n \t  switch (errmsg)\n \t    {\n \t    case 1:\n-\t      error_with_decl (newdecl, \"redefinition of `%s'\");\n+\t      error (\"%Hredefinition of '%D'\", locus, newdecl);\n \t      break;\n \t    case 2:\n-\t      error_with_decl (newdecl, \"redeclaration of `%s'\");\n+\t      error (\"%Hredeclaration of '%D'\", locus, newdecl);\n \t      break;\n \t    case 3:\n-\t      error_with_decl (newdecl, \"conflicting declarations of `%s'\");\n+\t      error (\"%Hconflicting declarations of '%D'\", locus, newdecl);\n \t      break;\n \t    default:\n \t      abort ();\n \t    }\n \n-\t  error_with_decl (olddecl,\n-\t\t\t   ((DECL_INITIAL (olddecl)\n-\t\t\t     && current_binding_level == global_binding_level)\n-\t\t\t    ? \"`%s' previously defined here\"\n-\t\t\t    : \"`%s' previously declared here\"));\n+          locus = &DECL_SOURCE_LOCATION (olddecl);\n+          if (DECL_INITIAL (olddecl)\n+              && current_binding_level == global_binding_level)\n+            error (\"%H'%D' previously defined here\", locus, olddecl);\n+          else\n+            error (\"%H'%D' previously declared here\", locus, olddecl);\n \t  return 0;\n \t}\n       else if (TREE_CODE (newdecl) == TYPE_DECL\n                && (DECL_IN_SYSTEM_HEADER (olddecl)\n                    || DECL_IN_SYSTEM_HEADER (newdecl)))\n \t{\n-\t  warning_with_decl (newdecl, \"redefinition of `%s'\");\n-\t  warning_with_decl\n-\t    (olddecl,\n-\t     ((DECL_INITIAL (olddecl)\n-\t       && current_binding_level == global_binding_level)\n-\t      ? \"`%s' previously defined here\"\n-\t      : \"`%s' previously declared here\"));\n+          const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n+\t  warning (\"%Hredefinition of '%D'\", locus, newdecl);\n+          locus = &DECL_SOURCE_LOCATION (olddecl);\n+          if (DECL_INITIAL (olddecl)\n+              && current_binding_level == global_binding_level)\n+            warning (\"%H'%D' previously defined here\", locus, olddecl);\n+          else\n+            warning (\"%H'%D' previously declared here\", locus, olddecl);\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t       && DECL_INITIAL (olddecl) != 0\n@@ -1162,16 +1186,20 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n \t\t  && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n-\t\t  warning_with_decl (newdecl, \"prototype for `%s' follows\");\n-\t\t  warning_with_decl (olddecl, \"non-prototype definition here\");\n+                  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n+\t\t  warning (\"%Hprototype for '%D' follows\", locus, newdecl);\n+                  locus = &DECL_SOURCE_LOCATION (olddecl);\n+\t\t  warning (\"%Hnon-prototype definition here\", locus);\n \t\t  break;\n \t\t}\n \t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n \t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n-\t\t  error_with_decl (newdecl,\n-\t\t\t\t   \"prototype for `%s' follows and number of arguments doesn't match\");\n-\t\t  error_with_decl (olddecl, \"non-prototype definition here\");\n+                  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n+\t\t  error (\"%Hprototype for '%D' follows and number of \"\n+                         \"arguments doesn't match\", locus, newdecl);\n+                  locus = &DECL_SOURCE_LOCATION (olddecl);\n+\t\t  error (\"%Hnon-prototype definition here\", locus);\n \t\t  errmsg = 1;\n \t\t  break;\n \t\t}\n@@ -1180,10 +1208,11 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t      if (! comptypes (TREE_VALUE (parm), TREE_VALUE (type),\n \t\t\t       comptype_flags))\n \t\t{\n-\t\t  error_with_decl (newdecl,\n-\t\t\t\t   \"prototype for `%s' follows and argument %d doesn't match\",\n-\t\t\t\t   nargs);\n-\t\t  error_with_decl (olddecl, \"non-prototype definition here\");\n+                  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n+\t\t  error (\"%Hprototype for '%D' follows and argument %d \"\n+                         \"doesn't match\", locus, newdecl, nargs);\n+                  locus = &DECL_SOURCE_LOCATION (olddecl);\n+\t\t  error (\"%Hnon-prototype definition here\", locus);\n \t\t  errmsg = 1;\n \t\t  break;\n \t\t}\n@@ -1198,43 +1227,47 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && DECL_DECLARED_INLINE_P (newdecl)\n \t      && TREE_USED (olddecl))\n-\t    warning_with_decl (newdecl,\n-\t\t\t       \"`%s' declared inline after being called\");\n+\t    warning (\"%H'%D' declared inline after being called\",\n+                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && DECL_DECLARED_INLINE_P (newdecl)\n \t      && DECL_INITIAL (olddecl) != 0)\n-\t    warning_with_decl (newdecl,\n-\t\t\t       \"`%s' declared inline after its definition\");\n+\t    warning (\"%H'%D' declared inline after its definition\",\n+                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \n \t  /* If pedantic, warn when static declaration follows a non-static\n \t     declaration.  Otherwise, do so only for functions.  */\n \t  if ((pedantic || TREE_CODE (olddecl) == FUNCTION_DECL)\n \t      && TREE_PUBLIC (olddecl)\n \t      && !TREE_PUBLIC (newdecl))\n-\t    warning_with_decl (newdecl, \"static declaration for `%s' follows non-static\");\n+\t    warning (\"%Hstatic declaration for '%D' follows non-static\",\n+                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \n \t  /* If warn_traditional, warn when a non-static function\n \t     declaration follows a static one.  */\n \t  if (warn_traditional && !in_system_header\n \t      && TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && !TREE_PUBLIC (olddecl)\n \t      && TREE_PUBLIC (newdecl))\n-\t    warning_with_decl (newdecl, \"non-static declaration for `%s' follows static\");\n+\t    warning (\"%Hnon-static declaration for '%D' follows static\",\n+                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \n \t  /* Warn when const declaration follows a non-const\n \t     declaration, but not for functions.  */\n \t  if (TREE_CODE (olddecl) != FUNCTION_DECL\n \t      && !TREE_READONLY (olddecl)\n \t      && TREE_READONLY (newdecl))\n-\t    warning_with_decl (newdecl, \"const declaration for `%s' follows non-const\");\n+\t    warning (\"%Hconst declaration for '%D' follows non-const\",\n+                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \t  /* These bits are logically part of the type, for variables.\n \t     But not for functions\n \t     (where qualifiers are not valid ANSI anyway).  */\n \t  else if (pedantic && TREE_CODE (olddecl) != FUNCTION_DECL\n \t      && (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n \t\t  || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl)))\n-\t    pedwarn_with_decl (newdecl, \"type qualifiers for `%s' conflict with previous decl\");\n+\t    pedwarn (\"%Htype qualifiers for '%D' conflict with previous \"\n+                     \"declaration\", &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \t}\n     }\n \n@@ -1247,8 +1280,10 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n       /* Don't warn about extern decl followed by (tentative) definition.  */\n       && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl)))\n     {\n-      warning_with_decl (newdecl, \"redundant redeclaration of `%s' in same scope\");\n-      warning_with_decl (olddecl, \"previous declaration of `%s'\");\n+      warning (\"%Hredundant redeclaration of '%D' in same scope\",\n+               &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+      warning (\"%Hprevious declaration of '%D'\",\n+               &DECL_SOURCE_LOCATION (olddecl), olddecl);\n     }\n \n   /* Copy all the DECL_... slots specified in the new decl\n@@ -1875,7 +1910,8 @@ implicitly_declare (tree functionid)\n \t{\n \t  implicit_decl_warning (DECL_NAME (decl));\n \t  if (! C_DECL_FILE_SCOPE (decl))\n-\t    warning_with_decl (decl, \"previous declaration of `%s'\");\n+\t    warning (\"%Hprevious declaration of '%D'\",\n+                     &DECL_SOURCE_LOCATION (decl), decl);\n \t  C_DECL_IMPLICIT (decl) = 1;\n \t}\n       /* If this function is global, then it must already be in the\n@@ -2083,10 +2119,9 @@ shadow_label (tree name)\n       for (dup = named_labels; dup; dup = TREE_CHAIN (dup))\n \tif (TREE_VALUE (dup) == decl)\n \t  {\n-\t    error (\"duplicate label declaration `%s'\",\n-\t\t   IDENTIFIER_POINTER (name));\n-\t    error_with_decl (TREE_VALUE (dup),\n-\t\t\t     \"this is a previous declaration\");\n+\t    error (\"duplicate label declaration '%E'\", name);\n+\t    error (\"%Hthis is a previous declaration\",\n+                   &DECL_SOURCE_LOCATION (TREE_VALUE (dup)));\n \t    /* Just use the previous declaration.  */\n \t    return lookup_label (name);\n \t  }\n@@ -2620,7 +2655,8 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n \n   if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n       && MAIN_NAME_P (DECL_NAME (decl)))\n-    warning_with_decl (decl, \"`%s' is usually a function\");\n+    warning (\"%H'%D' is usually a function\",\n+             &DECL_SOURCE_LOCATION (decl), decl);\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n@@ -2727,8 +2763,8 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl)))\n-    warning_with_decl (decl,\n-\t\t       \"inline function `%s' given attribute noinline\");\n+    warning (\"%Hinline function '%D' given attribute noinline\",\n+             &DECL_SOURCE_LOCATION (decl), decl);\n \n   /* Add this decl to the current binding level.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n@@ -2800,12 +2836,14 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       type = TREE_TYPE (decl);\n \n       if (failure == 1)\n-\terror_with_decl (decl, \"initializer fails to determine size of `%s'\");\n+\terror (\"%Hinitializer fails to determine size of '%D'\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n \n       else if (failure == 2)\n \t{\n \t  if (do_default)\n-\t    error_with_decl (decl, \"array size missing in `%s'\");\n+\t    error (\"%Harray size missing in '%D'\",\n+                   &DECL_SOURCE_LOCATION (decl), decl);\n \t  /* If a `static' var's size isn't known,\n \t     make it extern as well as static, so it does not get\n \t     allocated.\n@@ -2821,7 +2859,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t warn only if the value is less than zero.  */\n       else if (pedantic && TYPE_DOMAIN (type) != 0\n \t      && tree_int_cst_sgn (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) < 0)\n-\terror_with_decl (decl, \"zero or negative size array `%s'\");\n+\terror (\"%Hzero or negative size array '%D'\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n \n       layout_decl (decl, 0);\n     }\n@@ -2849,7 +2888,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t\t   is an error.  */\n \t\t!DECL_EXTERNAL (decl)))\n \t{\n-\t  error_with_decl (decl, \"storage size of `%s' isn't known\");\n+\t  error (\"%Hstorage size of '%D' isn't known\",\n+                 &DECL_SOURCE_LOCATION (decl), decl);\n \t  TREE_TYPE (decl) = error_mark_node;\n \t}\n \n@@ -2859,7 +2899,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \t    constant_expression_warning (DECL_SIZE (decl));\n \t  else\n-\t    error_with_decl (decl, \"storage size of `%s' isn't constant\");\n+\t    error (\"%Hstorage size of '%D' isn't constant\",\n+                   &DECL_SOURCE_LOCATION (decl), decl);\n \t}\n \n       if (TREE_USED (type))\n@@ -2938,8 +2979,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t      if (TREE_CODE (decl) == VAR_DECL\n \t\t  && !DECL_REGISTER (decl)\n \t\t  && !TREE_STATIC (decl))\n-\t\twarning_with_decl (decl,\n-\t\t\t\t   \"ignoring asm-specifier for non-static local variable `%s'\");\n+\t\twarning (\"%Hignoring asm-specifier for non-static local \"\n+                         \"variable '%D'\", &DECL_SOURCE_LOCATION (decl), decl);\n \t      else\n \t\tSET_DECL_ASSEMBLER_NAME (decl, get_identifier (asmspec));\n \t    }\n@@ -4426,7 +4467,8 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (inlinep)\n-\t  pedwarn_with_decl (decl, \"variable `%s' declared `inline'\");\n+\t  pedwarn (\"%Hvariable '%D' declared `inline'\",\n+                   &DECL_SOURCE_LOCATION (decl), decl);\n \n \tDECL_EXTERNAL (decl) = extern_ref;\n \n@@ -4609,8 +4651,8 @@ get_parm_info (int void_at_end)\n \t}\n       else if (TREE_ASM_WRITTEN (decl))\n \t{\n-\t  error_with_decl (decl,\n-\t\t\t   \"parameter `%s' has just a forward declaration\");\n+\t  error (\"%Hparameter '%D' has just a forward declaration\",\n+                 &DECL_SOURCE_LOCATION (decl), decl);\n \t  TREE_CHAIN (decl) = new_parms;\n \t  new_parms = decl;\n \t}\n@@ -4892,7 +4934,8 @@ detect_field_duplicates (tree fieldlist)\n \t    for (y = fieldlist; y != x; y = TREE_CHAIN (y))\n \t      if (DECL_NAME (y) == DECL_NAME (x))\n \t\t{\n-\t\t  error_with_decl (x, \"duplicate member `%s'\");\n+\t\t  error (\"%Hduplicate member '%D'\",\n+                         &DECL_SOURCE_LOCATION (x), x);\n \t\t  DECL_NAME (x) = NULL_TREE;\n \t\t}\n \t  }\n@@ -4908,7 +4951,8 @@ detect_field_duplicates (tree fieldlist)\n \t    slot = htab_find_slot (htab, y, INSERT);\n \t    if (*slot)\n \t      {\n-\t\terror_with_decl (x, \"duplicate member `%s'\");\n+\t\terror (\"%Hduplicate member '%D'\",\n+                       &DECL_SOURCE_LOCATION (x), x);\n \t\tDECL_NAME (x) = NULL_TREE;\n \t      }\n \t    *slot = y;\n@@ -5009,8 +5053,8 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t    constant_expression_warning (DECL_INITIAL (x));\n \t  else\n \t    {\n-\t      error_with_decl (x,\n-\t\t\t       \"bit-field `%s' width not an integer constant\");\n+\t      error (\"%Hbit-field '%D' width not an integer constant\",\n+                     &DECL_SOURCE_LOCATION (x), x);\n \t      DECL_INITIAL (x) = NULL;\n \t    }\n \t}\n@@ -5021,7 +5065,8 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE\n \t  && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n \t{\n-\t  error_with_decl (x, \"bit-field `%s' has invalid type\");\n+\t  error (\"%Hbit-field '%D' has invalid type\",\n+                 &DECL_SOURCE_LOCATION (x), x);\n \t  DECL_INITIAL (x) = NULL;\n \t}\n \n@@ -5033,7 +5078,8 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  && !(TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n \t       && (TYPE_PRECISION (TREE_TYPE (x))\n \t\t   == TYPE_PRECISION (integer_type_node))))\n-\tpedwarn_with_decl (x, \"bit-field `%s' type invalid in ISO C\");\n+\tpedwarn (\"%Hbit-field '%D' type invalid in ISO C\",\n+                 &DECL_SOURCE_LOCATION (x), x);\n \n       /* Detect and ignore out of range field width and process valid\n \t field widths.  */\n@@ -5044,11 +5090,14 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t       ? CHAR_TYPE_SIZE : TYPE_PRECISION (TREE_TYPE (x)));\n \n \t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n-\t    error_with_decl (x, \"negative width in bit-field `%s'\");\n+\t    error (\"%Hnegative width in bit-field '%D'\",\n+                   &DECL_SOURCE_LOCATION (x), x);\n \t  else if (0 < compare_tree_int (DECL_INITIAL (x), max_width))\n-\t    pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n+\t    pedwarn (\"%Hwidth of '%D' exceeds its type\",\n+                     &DECL_SOURCE_LOCATION (x), x);\n \t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n-\t    error_with_decl (x, \"zero width for bit-field `%s'\");\n+\t    error (\"%Hzero width for bit-field '%D'\",\n+                   &DECL_SOURCE_LOCATION (x), x);\n \t  else\n \t    {\n \t      /* The test above has assured us that TREE_INT_CST_HIGH is 0.  */\n@@ -5061,8 +5110,8 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t\t      || (width\n \t\t\t  < min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n \t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))))))\n-\t\twarning_with_decl (x,\n-\t\t\t\t   \"`%s' is narrower than values of its type\");\n+\t\twarning (\"%H'%D' is narrower than values of its type\",\n+                         &DECL_SOURCE_LOCATION (x), x);\n \n \t      DECL_SIZE (x) = bitsize_int (width);\n \t      DECL_BIT_FIELD (x) = 1;\n@@ -5079,16 +5128,20 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (x))) == NULL_TREE)\n \t{\n \t  if (TREE_CODE (t) == UNION_TYPE)\n-\t    error_with_decl (x, \"flexible array member in union\");\n+\t    error (\"%Hflexible array member in union\",\n+                   &DECL_SOURCE_LOCATION (x));\n \t  else if (TREE_CHAIN (x) != NULL_TREE)\n-\t    error_with_decl (x, \"flexible array member not at end of struct\");\n+\t    error (\"%Hflexible array member not at end of struct\",\n+                   &DECL_SOURCE_LOCATION (x));\n \t  else if (! saw_named_field)\n-\t    error_with_decl (x, \"flexible array member in otherwise empty struct\");\n+\t    error (\"%Hflexible array member in otherwise empty struct\",\n+                   &DECL_SOURCE_LOCATION (x));\n \t}\n \n       if (pedantic && TREE_CODE (t) == RECORD_TYPE\n \t  && flexible_array_type_p (TREE_TYPE (x)))\n-\tpedwarn_with_decl (x, \"invalid use of structure with flexible array member\");\n+\tpedwarn (\"%Hinvalid use of structure with flexible array member\",\n+                 &DECL_SOURCE_LOCATION (x));\n \n       if (DECL_NAME (x))\n \tsaw_named_field = 1;\n@@ -5545,8 +5598,8 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   if (DECL_DECLARED_INLINE_P (decl1)\n       && DECL_UNINLINABLE (decl1)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl1)))\n-    warning_with_decl (decl1,\n-\t\t       \"inline function `%s' given attribute noinline\");\n+    warning (\"%Hinline function '%D' given attribute noinline\",\n+             &DECL_SOURCE_LOCATION (decl1), decl1);\n \n   announce_function (decl1);\n \n@@ -5595,27 +5648,29 @@ start_function (tree declspecs, tree declarator, tree attributes)\n \t   && TREE_PUBLIC (decl1)\n \t   && ! MAIN_NAME_P (DECL_NAME (decl1))\n \t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning_with_decl (decl1, \"no previous prototype for `%s'\");\n+    warning (\"%Hno previous prototype for '%D'\",\n+             &DECL_SOURCE_LOCATION (decl1), decl1);\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n   else if (warn_missing_prototypes\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && TYPE_ARG_TYPES (TREE_TYPE (old_decl)) == 0)\n-    warning_with_decl (decl1,\n-\t\t       \"`%s' was used with no prototype before its definition\");\n+    warning (\"%H'%D' was used with no prototype before its definition\",\n+             &DECL_SOURCE_LOCATION (decl1), decl1);\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n \t   && old_decl == 0\n \t   && ! MAIN_NAME_P (DECL_NAME (decl1)))\n-    warning_with_decl (decl1, \"no previous declaration for `%s'\");\n+    warning (\"%Hno previous declaration for '%D'\",\n+             &DECL_SOURCE_LOCATION (decl1), decl1);\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && C_DECL_IMPLICIT (old_decl))\n-    warning_with_decl (decl1,\n-\t\t       \"`%s' was used with no declaration before its definition\");\n+    warning (\"%H`%D' was used with no declaration before its definition\",\n+             &DECL_SOURCE_LOCATION (decl1), decl1);\n \n   /* This is a definition, not a reference.\n      So normally clear DECL_EXTERNAL.\n@@ -5636,10 +5691,11 @@ start_function (tree declspecs, tree declarator, tree attributes)\n     {\n       tree args;\n       int argct = 0;\n+      const location_t *locus = &DECL_SOURCE_LOCATION (decl1);\n \n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n \t  != integer_type_node)\n-\tpedwarn_with_decl (decl1, \"return type of `%s' is not `int'\");\n+\tpedwarn (\"%Hreturn type of '%D' is not `int'\", locus, decl1);\n \n       for (args = TYPE_ARG_TYPES (TREE_TYPE (decl1)); args;\n \t   args = TREE_CHAIN (args))\n@@ -5654,26 +5710,26 @@ start_function (tree declspecs, tree declarator, tree attributes)\n \t    {\n \t    case 1:\n \t      if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-\t\tpedwarn_with_decl (decl1,\n-\t\t\t\t   \"first argument of `%s' should be `int'\");\n+\t\tpedwarn (\"%Hfirst argument of '%D' should be `int'\",\n+                         locus, decl1);\n \t      break;\n \n \t    case 2:\n \t      if (TREE_CODE (type) != POINTER_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn_with_decl (decl1,\n-\t\t\t\t   \"second argument of `%s' should be `char **'\");\n+\t\tpedwarn (\"%Hsecond argument of '%D' should be 'char **'\",\n+                         locus, decl1);\n \t      break;\n \n \t    case 3:\n \t      if (TREE_CODE (type) != POINTER_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn_with_decl (decl1,\n-\t\t\t\t   \"third argument of `%s' should probably be `char **'\");\n+\t\tpedwarn (\"%Hthird argument of '%D' should probably be \"\n+                         \"'char **'\", locus, decl1);\n \t      break;\n \t    }\n \t}\n@@ -5682,10 +5738,10 @@ start_function (tree declspecs, tree declarator, tree attributes)\n \t argument because it's only mentioned in an appendix of the\n \t standard.  */\n       if (argct > 0 && (argct < 2 || argct > 3))\n-\tpedwarn_with_decl (decl1, \"`%s' takes only zero or two arguments\");\n+\tpedwarn (\"%H'%D' takes only zero or two arguments\", locus, decl1);\n \n       if (! TREE_PUBLIC (decl1))\n-\tpedwarn_with_decl (decl1, \"`%s' is normally a non-static function\");\n+\tpedwarn (\"%H'%D' is normally a non-static function\", locus, decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -5781,8 +5837,8 @@ store_parm_decls (void)\n \t{\n \t  tree decl, link;\n \n-\t  error_with_decl (fndecl,\n-\t\t\t   \"parm types given both in parmlist and separately\");\n+\t  error (\"%Hparm types given both in parmlist and separately\",\n+                 &DECL_SOURCE_LOCATION (fndecl));\n \t  /* Get rid of the erroneous decls; don't keep them on\n \t     the list of parms, since they might not be PARM_DECLs.  */\n \t  for (decl = current_binding_level->names;\n@@ -5799,15 +5855,16 @@ store_parm_decls (void)\n       specparms = nreverse (specparms);\n       for (parm = specparms; parm; parm = next)\n \t{\n+          const location_t *locus = &DECL_SOURCE_LOCATION (parm);\n \t  next = TREE_CHAIN (parm);\n \t  if (TREE_CODE (parm) == PARM_DECL)\n \t    {\n \t      if (DECL_NAME (parm) == 0)\n-\t\terror_with_decl (parm, \"parameter name omitted\");\n+                error (\"%Hparameter name omitted\", locus);\n \t      else if (TREE_CODE (TREE_TYPE (parm)) != ERROR_MARK\n \t\t       && VOID_TYPE_P (TREE_TYPE (parm)))\n \t\t{\n-\t\t  error_with_decl (parm, \"parameter `%s' declared void\");\n+\t\t  error (\"%Hparameter '%D' declared void\", locus, parm);\n \t\t  /* Change the type to error_mark_node so this parameter\n \t\t     will be ignored by assign_parms.  */\n \t\t  TREE_TYPE (parm) = error_mark_node;\n@@ -5866,8 +5923,8 @@ store_parm_decls (void)\n \n \t  if (TREE_VALUE (parm) == 0)\n \t    {\n-\t      error_with_decl (fndecl,\n-\t\t\t       \"parameter name missing from parameter list\");\n+\t      error (\"%Hparameter name missing from parameter list\",\n+                     &DECL_SOURCE_LOCATION (fndecl));\n \t      TREE_PURPOSE (parm) = 0;\n \t      continue;\n \t    }\n@@ -5886,14 +5943,16 @@ store_parm_decls (void)\n \t     Complain, and don't use this decl twice.  */\n \t  if (found && DECL_WEAK (found))\n \t    {\n-\t      error_with_decl (found, \"multiple parameters named `%s'\");\n+\t      error (\"%Hmultiple parameters named '%D'\",\n+                     &DECL_SOURCE_LOCATION (found), found);\n \t      found = 0;\n \t    }\n \n \t  /* If the declaration says \"void\", complain and ignore it.  */\n \t  if (found && VOID_TYPE_P (TREE_TYPE (found)))\n \t    {\n-\t      error_with_decl (found, \"parameter `%s' declared void\");\n+\t      error (\"%Hparameter '%D' declared void\",\n+                     &DECL_SOURCE_LOCATION (found), found);\n \t      TREE_TYPE (found) = integer_type_node;\n \t      DECL_ARG_TYPE (found) = integer_type_node;\n \t      layout_decl (found, 0);\n@@ -5907,9 +5966,11 @@ store_parm_decls (void)\n \t      DECL_ARG_TYPE (found) = TREE_TYPE (found);\n \t      DECL_SOURCE_LOCATION (found) = DECL_SOURCE_LOCATION (fndecl);\n \t      if (flag_isoc99)\n-\t\tpedwarn_with_decl (found, \"type of `%s' defaults to `int'\");\n+\t\tpedwarn (\"%Htype of '%D' defaults to `int'\",\n+                         &DECL_SOURCE_LOCATION (found), found);\n \t      else if (extra_warnings)\n-\t\twarning_with_decl (found, \"type of `%s' defaults to `int'\");\n+\t\twarning (\"%Htype of '%D' defaults to `int'\",\n+                         &DECL_SOURCE_LOCATION (found), found);\n \t      pushdecl (found);\n \t    }\n \n@@ -5928,6 +5989,7 @@ store_parm_decls (void)\n       nonparms = 0;\n       for (parm = parmdecls; parm;)\n \t{\n+          const location_t *locus = &DECL_SOURCE_LOCATION (parm);\n \t  tree next = TREE_CHAIN (parm);\n \t  TREE_CHAIN (parm) = 0;\n \n@@ -5938,14 +6000,14 @@ store_parm_decls (void)\n \t      /* Complain about args with incomplete types.  */\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t\t{\n-\t\t  error_with_decl (parm, \"parameter `%s' has incomplete type\");\n+\t\t  error (\"%Hparameter '%D' has incomplete type\", locus, parm);\n \t\t  TREE_TYPE (parm) = error_mark_node;\n \t\t}\n \n \t      if (! DECL_WEAK (parm))\n \t\t{\n-\t\t  error_with_decl (parm,\n-\t\t\t\t   \"declaration for parameter `%s' but no such parameter\");\n+\t\t  error (\"%Hdeclaration for parameter '%D' but no such \"\n+                         \"parameter\", locus, parm);\n \t          /* Pretend the parameter was not missing.\n \t\t     This gets us to a standard state and minimizes\n \t\t     further error messages.  */\n@@ -6170,8 +6232,9 @@ finish_function (int nested, int can_defer_p)\n \t{\n \t  /* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned.\n \t     If warn_main is -1 (-Wno-main) we don't want to be warned.  */\n-\t  if (! warn_main)\n-\t    pedwarn_with_decl (fndecl, \"return type of `%s' is not `int'\");\n+\t  if (!warn_main)\n+\t    pedwarn (\"%Hreturn type of '%D' is not `int'\",\n+                     &DECL_SOURCE_LOCATION (fndecl), fndecl);\n \t}\n       else\n \t{\n@@ -6422,17 +6485,16 @@ c_expand_body_1 (tree fndecl, int nested_p)\n \t  && 0 < compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n \t\t\t\t   larger_than_size))\n \t{\n+          const location_t *locus = &DECL_SOURCE_LOCATION (fndecl);\n \t  unsigned int size_as_int\n \t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));\n \n \t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n-\t    warning_with_decl (fndecl,\n-\t\t\t       \"size of return value of `%s' is %u bytes\",\n-\t\t\t       size_as_int);\n+\t    warning (\"%Hsize of return value of '%D' is %u bytes\",\n+                     locus, fndecl, size_as_int);\n \t  else\n-\t    warning_with_decl (fndecl,\n-\t\t\t       \"size of return value of `%s' is larger than %d bytes\",\n-\t\t\t       larger_than_size);\n+\t    warning (\"%Hsize of return value of '%D' is larger than %wd bytes\",\n+                     locus, fndecl, larger_than_size);\n \t}\n     }\n \n@@ -6531,12 +6593,16 @@ check_for_loop_decls (void)\n \n   for (t = getdecls (); t; t = TREE_CHAIN (t))\n     {\n+      const location_t *locus = &DECL_SOURCE_LOCATION (t);\n       if (TREE_CODE (t) != VAR_DECL && DECL_NAME (t))\n-\terror_with_decl (t, \"declaration of non-variable `%s' in `for' loop initial declaration\");\n+\terror (\"%Hdeclaration of non-variable '%D' in 'for' loop \"\n+               \"initial declaration\", locus, t);\n       else if (TREE_STATIC (t))\n-\terror_with_decl (t, \"declaration of static variable `%s' in `for' loop initial declaration\");\n+\terror (\"%Hdeclaration of static variable '%D' in 'for' loop \"\n+               \"initial declaration\", locus, t);\n       else if (DECL_EXTERNAL (t))\n-\terror_with_decl (t, \"declaration of `extern' variable `%s' in `for' loop initial declaration\");\n+\terror (\"%Hdeclaration of 'extern' variable '%D' in 'for' loop \"\n+               \"initial declaration\", locus, t);\n     }\n }\n \f\n@@ -6860,8 +6926,10 @@ merge_translation_unit_decls (void)\n \t\t}\n \t      else\n \t\t{\n-\t\t  error_with_decl (decl, \"redefinition of global `%s'\");\n-\t\t  error_with_decl (old_decl, \"`%s' previously defined here\");\n+\t\t  error (\"%Hredefinition of global '%D'\",\n+                         &DECL_SOURCE_LOCATION (decl), decl);\n+\t\t  error (\"%H'%D' previously defined here\",\n+                         &DECL_SOURCE_LOCATION (old_decl), old_decl);\n \t\t}\n \t    }\n \t  else"}]}