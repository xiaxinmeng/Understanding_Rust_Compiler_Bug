{"sha": "a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlNTM3MmQ2YThlMmYxMmI2ZDlhMTVmNzFkNWFkMDc5NGU2NTA3Zg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-07-10T04:57:58Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-07-10T04:57:58Z"}, "message": "tree-ssa-loop-im.c: New file.\n\n\t* tree-ssa-loop-im.c: New file.\n\t* Makefile.in (tree-ssa-loop-im.o): Add.\n\t* cfgloop.c (superloop_at_depth): New function.\n\t* cfgloop.h (superloop_at_depth): Declare.\n\t* common.opt (ftree-lim): New flag.\n\t* expr.c (array_ref_up_bound): New function.\n\t* params.def (PARAM_LIM_EXPENSIVE): New parameter.\n\t* timevar.def (TV_LIM): New timevar.\n\t* tree-dfa.c (compute_immediate_uses): Respect TDFA_USE flags when\n\tcomputing immediate uses of a phi node.\n\t* tree-flow.h (struct tree_ann_common_d): Add aux field.\n\t(loop_commit_inserts, for_each_index, tree_ssa_lim): Declare.\n\t* tree-optimize.c (init_tree_optimization_passes): Add pass_lim.\n\t* tree-pass.h (pass_lim): Declare.\n\t* tree-ssa-loop.c (tree_ssa_loop_im, gate_tree_ssa_loop_im): New\n\tfunctions.\n\t(pass_lim): New pass structure.\n\t* tree-eh.c (tree_could_trap_p): Handle ARRAY_REFs correctly.\n\t* tree.c (in_array_bounds_p): New function.\n\t* tree.h (TREE_THIS_NOTRAP): Define also for ARRAY_REFs.\n\t(in_array_bounds_p, array_ref_up_bound): Declare.\n\t* doc/invoke.texi (-ftree-lim, --param lim-expensive): Document.\n\t* doc/passes.texi (tree-ssa-loop-im.c): Document.\n\nFrom-SVN: r84441", "tree": {"sha": "7fd5b8c64fe84e6fadd94b6c98bdd7f62f3789a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fd5b8c64fe84e6fadd94b6c98bdd7f62f3789a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/comments", "author": null, "committer": null, "parents": [{"sha": "ad6e2a18c2013863e1cf448471e1fa243403eb50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6e2a18c2013863e1cf448471e1fa243403eb50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad6e2a18c2013863e1cf448471e1fa243403eb50"}], "stats": {"total": 1533, "additions": 1521, "deletions": 12}, "files": [{"sha": "e5fd185dfd9a84a12752b2ca38aab23f04673185", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -1,3 +1,29 @@\n+2004-07-09  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* tree-ssa-loop-im.c: New file.\n+\t* Makefile.in (tree-ssa-loop-im.o): Add.\n+\t* cfgloop.c (superloop_at_depth): New function.\n+\t* cfgloop.h (superloop_at_depth): Declare.\n+\t* common.opt (ftree-lim): New flag.\n+\t* expr.c (array_ref_up_bound): New function.\n+\t* params.def (PARAM_LIM_EXPENSIVE): New parameter.\n+\t* timevar.def (TV_LIM): New timevar.\n+\t* tree-dfa.c (compute_immediate_uses): Respect TDFA_USE flags when\n+\tcomputing immediate uses of a phi node.\n+\t* tree-flow.h (struct tree_ann_common_d): Add aux field.\n+\t(loop_commit_inserts, for_each_index, tree_ssa_lim): Declare.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add pass_lim.\n+\t* tree-pass.h (pass_lim): Declare.\n+\t* tree-ssa-loop.c (tree_ssa_loop_im, gate_tree_ssa_loop_im): New\n+\tfunctions.\n+\t(pass_lim): New pass structure.\n+\t* tree-eh.c (tree_could_trap_p): Handle ARRAY_REFs correctly.\n+\t* tree.c (in_array_bounds_p): New function.\n+\t* tree.h (TREE_THIS_NOTRAP): Define also for ARRAY_REFs.\n+\t(in_array_bounds_p, array_ref_up_bound): Declare.\n+\t* doc/invoke.texi (-ftree-lim, --param lim-expensive): Document.\n+\t* doc/passes.texi (tree-ssa-loop-im.c): Document.\n+\n 2004-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* builtins.c (expand_builtin_stpcpy): Don't modify len."}, {"sha": "f1446ed44fd16868c7c79a114ad60ef330ff3623", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -901,7 +901,7 @@ OBJS-common = \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n  cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n- dbxout.o ddg.o tree-ssa-loop-ch.o loop-invariant.o\t\t\t   \\\n+ dbxout.o ddg.o tree-ssa-loop-ch.o loop-invariant.o tree-ssa-loop-im.o\t   \\\n  debug.o df.o diagnostic.o dojump.o dominance.o loop-doloop.o\t\t   \\\n  dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o loop-iv.o\t\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n@@ -1686,6 +1686,10 @@ tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) tree-inline.h \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h flags.h\n+tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h $(PARAMS_H)\\\n+   output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h flags.h\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n    function.h $(TIMEVAR_H) tree-alias-common.h convert.h $(TM_H) coretypes.h \\"}, {"sha": "7709a03b2ab34525f5c88a2a0702f0e88efc6694", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -101,6 +101,20 @@ flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n \t && loop->pred[outer->depth] == outer;\n }\n \n+/* Returns superloop of LOOP at given DEPTH.  */\n+\n+struct loop *\n+superloop_at_depth (struct loop *loop, unsigned depth)\n+{\n+  if (depth > (unsigned) loop->depth)\n+    abort ();\n+\n+  if (depth == (unsigned) loop->depth)\n+    return loop;\n+\n+  return loop->pred[depth];\n+}\n+\n /* Dump the loop information specified by LOOP to the stream FILE\n    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n "}, {"sha": "01b8d64e5f4438f8cd22d52ec55afcee5bb212ac", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -256,6 +256,7 @@ extern bool flow_loop_outside_edge_p (const struct loop *, edge);\n extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n extern bool flow_bb_inside_loop_p (const struct loop *, const basic_block);\n extern struct loop * find_common_loop (struct loop *, struct loop *);\n+struct loop *superloop_at_depth (struct loop *, unsigned);\n extern int num_loop_insns (struct loop *);\n extern int average_num_loop_insns (struct loop *);\n extern unsigned get_loop_level (const struct loop *);"}, {"sha": "fd3df7c7da35e1f06c3c1570dc4c655cd9a94616", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -844,6 +844,10 @@ ftree-fre\n Common Report Var(flag_tree_fre)\n Enable Full Redundancy Elimination (FRE) on trees\n \n+ftree-lim\n+Common Report Var(flag_tree_lim) Init(1)\n+Enable loop invariant motion on trees\n+\n ftree-loop-optimize\n Common Report Var(flag_tree_loop_optimize) Init(1)\n Enable loop optimizations on tree level"}, {"sha": "042982178bc050c814121b0262c5b8b877958495", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -313,6 +313,7 @@ in the following sections.\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n+-ftree-lim @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre @gol\n --param @var{name}=@var{value}\n@@ -4401,6 +4402,14 @@ usually increases code size.\n Perform loop optimizations on trees.  This flag is enabled by default at -O\n and higher.\n \n+@item -ftree-lim\n+Perform loop invariant motion on trees.  This pass moves only invartiants that\n+would be hard to handle on rtl level (function calls, operations that expand to\n+nontrivial sequences of insns).  With @option{-funswitch-loops} it also moves\n+operands of conditions that are invariant out of the loop, so that we can use\n+just trivial invariantness analysis in loop unswitching.  The pass also includes\n+store motion.\n+\n @item -ftree-sra\n Perform scalar replacement of aggregates.  This pass replaces structure\n references with scalars to prevent committing structures to memory too\n@@ -5174,6 +5183,9 @@ The maximum number of insns of an unswitched loop.\n @item max-unswitch-level\n The maximum number of branches unswitched in a single loop.\n \n+@item lim-expensive\n+The minimum cost of an expensive expression in the loop invariant motion.\n+\n @item max-iterations-to-track\n \n The maximum number of iterations of a loop the brute force algorithm"}, {"sha": "9867e7323efc6191b32e6c951608f3c6fbfb6c81", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -363,9 +363,20 @@ and is described by @code{pass_pre}.\n \n @item Loop optimization\n \n-TODO: Presumably we're going to do something with loops here.  At\n-present we don't, and this is a placeholder.  The pass is located\n-in @file{tree-ssa-loop.c} and is described by @code{pass_loop}.\n+The main driver of the pass is placed in @file{tree-ssa-loop.c}\n+and described by @code{pass_loop}.\n+\n+The optimizations performed by this pass are:\n+\n+Loop invariant motion.  This pass moves only invariants that\n+would be hard to handle on rtl level (function calls, operations that expand to\n+nontrivial sequences of insns).  With @option{-funswitch-loops} it also moves\n+operands of conditions that are invariant out of the loop, so that we can use\n+just trivial invariantness analysis in loop unswitching.  The pass also includes\n+store motion.  The pass is implemented in @file{tree-ssa-loop-im.c}.\n+\n+The optimizations also use various utility functions contained in\n+@file{cfgloop.c}, @file{cfgloopanal.c} and @file{cfgloopmanip.c}.\n \n @item Conditional constant propagation\n "}, {"sha": "6cd22b82bb1d3190bae8915cbf28d9f71ce917d7", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -5706,6 +5706,23 @@ array_ref_low_bound (tree exp)\n   return fold_convert (TREE_TYPE (TREE_OPERAND (exp, 1)), integer_zero_node);\n }\n \n+/* Return a tree representing the upper bound of the array mentioned in\n+   EXP, an ARRAY_REF.  */\n+\n+tree\n+array_ref_up_bound (tree exp)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+  /* If there is a domain type and it has an upper bound, use it, substituting\n+     for a PLACEHOLDER_EXPR as needed.  */\n+  if (domain_type && TYPE_MAX_VALUE (domain_type))\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MAX_VALUE (domain_type), exp);\n+\n+  /* Otherwise fail.  */\n+  return NULL_TREE;\n+}\n+\n /* Return a tree representing the offset, in bytes, of the field referenced\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n "}, {"sha": "4b5a9ce7b932d76f2d24ba1f21234350f3e95898", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -312,6 +312,13 @@ DEFPARAM(PARAM_MAX_CSE_PATH_LENGTH,\n \t \"The maximum length of path considered in cse\",\n \t 10)\n \n+/* The cost of expression in loop invariant motion that is considered\n+   expensive.  */\n+DEFPARAM(PARAM_LIM_EXPENSIVE,\n+\t \"lim-expensive\",\n+\t \"The minimum cost of an expensive expression in the loop invariant motion\",\n+\t 20)\n+\n /* The product of the next two is used to decide whether or not to\n    use .GLOBAL_VAR.  See tree-dfa.c.  */\n DEFPARAM(PARAM_GLOBAL_VAR_THRESHOLD,"}, {"sha": "fb09f0685e04a04b79ccb2fee285fe4112aba248", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -82,6 +82,7 @@ DEFTIMEVAR (TV_TREE_DCE\t\t     , \"tree conservative DCE\")\n DEFTIMEVAR (TV_TREE_CD_DCE\t     , \"tree aggressive DCE\")\n DEFTIMEVAR (TV_TREE_DSE\t\t     , \"tree DSE\")\n DEFTIMEVAR (TV_TREE_LOOP\t     , \"tree loop optimization\")\n+DEFTIMEVAR (TV_LIM                   , \"loop invariant motion\")\n DEFTIMEVAR (TV_TREE_CH\t\t     , \"tree copy headers\")\n DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , \"tree SSA to normal\")\n DEFTIMEVAR (TV_TREE_NRV\t\t     , \"tree NRV optimization\")"}, {"sha": "e559ecb2ed44aa148ad6d5a317a47d844f00d387", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -178,7 +178,20 @@ compute_immediate_uses (int flags, bool (*calc_for)(tree))\n       tree phi;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\tcompute_immediate_uses_for_phi (phi, calc_for);\n+\t{\n+\t  if (is_gimple_reg (PHI_RESULT (phi)))\n+\t    {\n+\t      if (!(flags & TDFA_USE_OPS))\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!(flags & TDFA_USE_VOPS))\n+\t\tcontinue;\n+\t    }\n+\n+\t  compute_immediate_uses_for_phi (phi, calc_for);\n+\t}\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n         {"}, {"sha": "8ff1bfa55b70a97bd9539d4a3855c12e9705e693", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -1705,7 +1705,7 @@ tree_could_trap_p (tree expr)\n   bool honor_nans = false;\n   bool honor_snans = false;\n   bool fp_operation = false;\n-  tree t;\n+  tree t, base, idx;\n \n   if (TREE_CODE_CLASS (code) == '<'\n       || TREE_CODE_CLASS (code) == '1'\n@@ -1722,14 +1722,32 @@ tree_could_trap_p (tree expr)\n \n   switch (code)\n     {\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n     case COMPONENT_REF:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case BIT_FIELD_REF:\n-      t = get_base_address (expr);\n-      return !t || tree_could_trap_p (t);\n+      t = TREE_OPERAND (expr, 0);\n+      return tree_could_trap_p (t);\n+\n+    case ARRAY_RANGE_REF:\n+      /* Let us be conservative here for now.  We might be checking bounds of\n+\t the access similarly to the case below.  */\n+      if (!TREE_THIS_NOTRAP (expr))\n+\treturn true;\n+\n+      base = TREE_OPERAND (expr, 0);\n+      return tree_could_trap_p (base);\n+\n+    case ARRAY_REF:\n+      base = TREE_OPERAND (expr, 0);\n+      idx = TREE_OPERAND (expr, 1);\n+      if (tree_could_trap_p (base))\n+\treturn true;\n+\n+      if (TREE_THIS_NOTRAP (expr))\n+\treturn false;\n+\n+      return !in_array_bounds_p (expr);\n \n     case INDIRECT_REF:\n       return !TREE_THIS_NOTRAP (expr);"}, {"sha": "5e3eddec12fc9fc2a9ec5c299959fc91a09ed6e0", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -83,6 +83,10 @@ struct tree_ann_common_d GTY(())\n   /* Annotation type.  */\n   enum tree_ann_type type;\n \n+ /* Auxiliary info specific to a pass.  At all times, this\n+    should either point to valid data or be NULL.  */\n+  PTR GTY ((skip (\"\"))) aux;\n+\n   /* The value handle for this expression.  Used by GVN-PRE.  */\n   tree GTY((skip)) value_handle;\n };\n@@ -636,6 +640,8 @@ struct tree_niter_desc\n \n /* In tree-ssa-loop*.c  */\n \n+void tree_ssa_lim (struct loops *);\n+\n void number_of_iterations_cond (tree, tree, tree, enum tree_code, tree, tree,\n \t\t\t\tstruct tree_niter_desc *);\n bool number_of_iterations_exit (struct loop *, edge,\n@@ -645,6 +651,8 @@ tree find_loop_niter_by_eval (struct loop *, edge *);\n void estimate_numbers_of_iterations (struct loops *);\n tree can_count_iv_in_wider_type (struct loop *, tree, tree, tree, tree);\n void free_numbers_of_iterations_estimates (struct loops *);\n+void loop_commit_inserts (void);\n+bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n \n /* In tree-flow-inline.h  */\n static inline int phi_arg_from_edge (tree, edge);"}, {"sha": "94681c4c0448002794a9ac29c50d3ba5523398b3", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -328,6 +328,7 @@ init_tree_optimization_passes (void)\n \n   p = &pass_loop.sub;\n   NEXT_PASS (pass_loop_init);\n+  NEXT_PASS (pass_lim);\n   NEXT_PASS (pass_loop_done);\n   *p = NULL;\n "}, {"sha": "93129100cefa69f101cbfd68ba247f09ef7bb0dd", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -107,6 +107,7 @@ extern struct tree_opt_pass pass_tail_recursion;\n extern struct tree_opt_pass pass_tail_calls;\n extern struct tree_opt_pass pass_loop;\n extern struct tree_opt_pass pass_loop_init;\n+extern struct tree_opt_pass pass_lim;\n extern struct tree_opt_pass pass_loop_done;\n extern struct tree_opt_pass pass_ch;\n extern struct tree_opt_pass pass_ccp;"}, {"sha": "e7afc24cb786c400f0978f0e26bc84dce6150c61", "filename": "gcc/tree-ssa-loop-im.c", "status": "added", "additions": 1299, "deletions": 0, "changes": 1299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -0,0 +1,1299 @@\n+/* Loop invariant motion.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"domwalk.h\"\n+#include \"params.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+\n+/* A type for the list of statements that have to be moved in order to be able\n+   to hoist an invariant computation.  */\n+\n+struct depend\n+{\n+  tree stmt;\n+  struct depend *next;\n+};\n+\n+/* The possibilities of statement movement.  */\n+\n+enum move_pos\n+{\n+  MOVE_IMPOSSIBLE,\t\t/* No movement -- side effect expression.  */\n+  MOVE_PRESERVE_EXECUTION,\t/* Must not cause the non-executed statement\n+\t\t\t\t   become executed -- memory accesses, ... */\n+  MOVE_POSSIBLE\t\t\t/* Unlimited movement.  */\n+};\n+\n+/* The auxiliary data kept for each statement.  */\n+\n+struct lim_aux_data\n+{\n+  struct loop *max_loop;\t/* The outermost loop in that the statement\n+\t\t\t\t   is invariant.  */\n+\n+  struct loop *tgt_loop;\t/* The loop out of that we want to move the\n+\t\t\t\t   invariant.  */\n+\n+  struct loop *always_executed_in;\n+\t\t\t\t/* The outermost loop for that we are sure\n+\t\t\t\t   the statement is executed if the loop\n+\t\t\t\t   is entered.  */\n+\n+  bool sm_done;\t\t\t/* True iff the store motion for a memory\n+\t\t\t\t   reference in the statement has already\n+\t\t\t\t   been executed.  */\n+\n+  unsigned cost;\t\t/* Cost of the computation performed by the\n+\t\t\t\t   statement.  */\n+\n+  struct depend *depends;\t/* List of statements that must be also hoisted\n+\t\t\t\t   out of the loop when this statement is\n+\t\t\t\t   hoisted; i.e. those that define the operands\n+\t\t\t\t   of the statement and are inside of the\n+\t\t\t\t   MAX_LOOP loop.  */\n+};\n+\n+#define LIM_DATA(STMT) ((struct lim_aux_data *) (stmt_ann (STMT)->common.aux))\n+\n+/* Description of a memory reference for store motion.  */\n+\n+struct mem_ref\n+{\n+  tree *ref;\t\t\t/* The reference itself.  */\n+  tree stmt;\t\t\t/* The statement in that it occurs.  */\n+  struct mem_ref *next;\t\t/* Next use in the chain.  */\n+};\n+\n+/* Minimum cost of an expensive expression.  */\n+#define LIM_EXPENSIVE ((unsigned) PARAM_VALUE (PARAM_LIM_EXPENSIVE))\n+\n+/* The outermost loop for that execution of the header guarantees that the\n+   block will be executed.  */\n+#define ALWAYS_EXECUTED_IN(BB) ((struct loop *) (BB)->aux)\n+\n+/* Maximum uid in the statement in the function.  */\n+\n+static unsigned max_uid;\n+\n+/* Calls CBCK for each index in memory reference ADDR_P.  There are two\n+   kinds situations handled; in each of these cases, the memory reference\n+   and DATA are passed to the callback:\n+   \n+   Access to an array: ARRAY_{RANGE_}REF (base, index).  In this case we also\n+   pass the pointer to the index to the callback.\n+\n+   Pointer dereference: INDIRECT_REF (addr).  In this case we also pass the\n+   pointer to addr to the callback.\n+   \n+   If the callback returns false, the whole search stops and false is returned.\n+   Otherwise the function returns true after traversing through the whole\n+   reference *ADDR_P.  */\n+\n+bool\n+for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n+{\n+  tree *nxt;\n+\n+  for (; ; addr_p = nxt)\n+    {\n+      switch (TREE_CODE (*addr_p))\n+\t{\n+\tcase SSA_NAME:\n+\t  return cbck (*addr_p, addr_p, data);\n+\n+\tcase INDIRECT_REF:\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  return cbck (*addr_p, nxt, data);\n+\n+\tcase BIT_FIELD_REF:\n+\tcase COMPONENT_REF:\n+\tcase VIEW_CONVERT_EXPR:\n+\tcase ARRAY_RANGE_REF:\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  if (!cbck (*addr_p, &TREE_OPERAND (*addr_p, 1), data))\n+\t    return false;\n+\t  break;\n+\n+\tcase VAR_DECL:\n+\tcase PARM_DECL:\n+\tcase STRING_CST:\n+\tcase RESULT_DECL:\n+\t  return true;\n+\n+\tdefault:\n+    \t  abort ();\n+\t}\n+    }\n+}\n+\n+/* If it is possible to hoist the statement STMT unconditionally,\n+   returns MOVE_POSSIBLE.\n+   If it is possible to hoist the statement STMT, but we must avoid making\n+   it executed if it would not be executed in the original program (e.g.\n+   because it may trap), return MOVE_PRESERVE_EXECUTION.\n+   Otherwise return MOVE_IMPOSSIBLE.  */\n+\n+static enum move_pos\n+movement_possibility (tree stmt)\n+{\n+  tree lhs, rhs;\n+\n+  if (flag_unswitch_loops\n+      && TREE_CODE (stmt) == COND_EXPR)\n+    {\n+      /* If we perform unswitching, force the operands of the invariant\n+\t condition to be moved out of the loop.  */\n+      get_stmt_operands (stmt);\n+\n+      return MOVE_POSSIBLE;\n+    }\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return MOVE_IMPOSSIBLE;\n+\n+  if (stmt_ends_bb_p (stmt))\n+    return MOVE_IMPOSSIBLE;\n+\n+  get_stmt_operands (stmt);\n+\n+  if (stmt_ann (stmt)->has_volatile_ops)\n+    return MOVE_IMPOSSIBLE;\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+    return MOVE_IMPOSSIBLE;\n+\n+  rhs = TREE_OPERAND (stmt, 1);\n+\n+  if (TREE_SIDE_EFFECTS (rhs))\n+    return MOVE_IMPOSSIBLE;\n+\n+  if (TREE_CODE (lhs) != SSA_NAME\n+      || tree_could_trap_p (rhs))\n+    return MOVE_PRESERVE_EXECUTION;\n+\n+  return MOVE_POSSIBLE;\n+}\n+\n+/* Suppose that operand DEF is used inside the LOOP.  Returns the outermost\n+   loop to that we could move the expresion using DEF if it did not have\n+   other operands, i.e. the outermost loop enclosing LOOP in that the value\n+   of DEF is invariant.  */\n+\n+static struct loop *\n+outermost_invariant_loop (tree def, struct loop *loop)\n+{\n+  tree def_stmt;\n+  basic_block def_bb;\n+  struct loop *max_loop;\n+\n+  if (TREE_CODE (def) != SSA_NAME)\n+    return superloop_at_depth (loop, 1);\n+\n+  def_stmt = SSA_NAME_DEF_STMT (def);\n+  def_bb = bb_for_stmt (def_stmt);\n+  if (!def_bb)\n+    return superloop_at_depth (loop, 1);\n+\n+  max_loop = find_common_loop (loop, def_bb->loop_father);\n+\n+  if (LIM_DATA (def_stmt) && LIM_DATA (def_stmt)->max_loop)\n+    max_loop = find_common_loop (max_loop,\n+\t\t\t\t LIM_DATA (def_stmt)->max_loop->outer);\n+  if (max_loop == loop)\n+    return NULL;\n+  max_loop = superloop_at_depth (loop, max_loop->depth + 1);\n+\n+  return max_loop;\n+}\n+\n+/* Returns the outermost superloop of LOOP in that the expression EXPR is\n+   invariant.  */\n+\n+static struct loop *\n+outermost_invariant_loop_expr (tree expr, struct loop *loop)\n+{\n+  char class = TREE_CODE_CLASS (TREE_CODE (expr));\n+  unsigned i, nops;\n+  struct loop *max_loop = superloop_at_depth (loop, 1), *aloop;\n+\n+  if (TREE_CODE (expr) == SSA_NAME\n+      || TREE_CODE (expr) == INTEGER_CST\n+      || is_gimple_min_invariant (expr))\n+    return outermost_invariant_loop (expr, loop);\n+\n+  if (class != '1'\n+      && class != '2'\n+      && class != 'e'\n+      && class != '<')\n+    return NULL;\n+\n+  nops = first_rtl_op (TREE_CODE (expr));\n+  for (i = 0; i < nops; i++)\n+    {\n+      aloop = outermost_invariant_loop_expr (TREE_OPERAND (expr, i), loop);\n+      if (!aloop)\n+\treturn NULL;\n+\n+      if (flow_loop_nested_p (max_loop, aloop))\n+\tmax_loop = aloop;\n+    }\n+\n+  return max_loop;\n+}\n+\n+/* DATA is a structure containing information associated with a statement\n+   inside LOOP.  DEF is one of the operands of this statement.\n+   \n+   Find the outermost loop enclosing LOOP in that value of DEF is invariant\n+   and record this in DATA->max_loop field.  If DEF itself is defined inside\n+   this loop as well (i.e. we need to hoist it out of the loop if we want\n+   to hoist the statement represented by DATA), record the statement in that\n+   DEF is defined to the DATA->depends list.  Additionally if ADD_COST is true,\n+   add the cost of the computation of DEF to the DATA->cost.\n+   \n+   If DEF is not invariant in LOOP, return false.  Otherwise return TRUE.  */\n+\n+static bool\n+add_dependency (tree def, struct lim_aux_data *data, struct loop *loop,\n+\t\tbool add_cost)\n+{\n+  tree def_stmt = SSA_NAME_DEF_STMT (def);\n+  basic_block def_bb = bb_for_stmt (def_stmt);\n+  struct loop *max_loop;\n+  struct depend *dep;\n+\n+  if (!def_bb)\n+    return true;\n+\n+  max_loop = outermost_invariant_loop (def, loop);\n+  if (!max_loop)\n+    return false;\n+\n+  if (flow_loop_nested_p (data->max_loop, max_loop))\n+    data->max_loop = max_loop;\n+\n+  if (!LIM_DATA (def_stmt))\n+    return true;\n+\n+  if (add_cost\n+      /* Only add the cost if the statement defining DEF is inside LOOP,\n+\t i.e. if it is likely that by moving the invariants dependent\n+\t on it, we will be able to avoid creating a new register for\n+\t it (since it will be only used in these dependent invariants).  */\n+      && def_bb->loop_father == loop)\n+    data->cost += LIM_DATA (def_stmt)->cost;\n+\n+  dep = xmalloc (sizeof (struct depend));\n+  dep->stmt = def_stmt;\n+  dep->next = data->depends;\n+  data->depends = dep;\n+\n+  return true;\n+}\n+\n+/* Returns an estimate for a cost of statement STMT.  TODO -- the values here\n+   are just ad-hoc constants.  The estimates should be based on target-specific\n+   values.  */\n+\n+static unsigned\n+stmt_cost (tree stmt)\n+{\n+  tree lhs, rhs;\n+  unsigned cost = 1;\n+\n+  /* Always try to create possibilities for unswitching.  */\n+  if (TREE_CODE (stmt) == COND_EXPR)\n+    return LIM_EXPENSIVE;\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  rhs = TREE_OPERAND (stmt, 1);\n+\n+  /* Hoisting memory references out should almost surely be a win.  */\n+  if (!is_gimple_variable (lhs))\n+    cost += 20;\n+  if (is_gimple_addr_expr_arg (rhs) && !is_gimple_variable (rhs))\n+    cost += 20;\n+\n+  switch (TREE_CODE (rhs))\n+    {\n+    case CALL_EXPR:\n+      /* We should be hoisting calls if possible.  */\n+\n+      /* Unless the call is a builtin_constant_p; this always folds to a\n+\t constant, so moving it is useless.  */\n+      rhs = get_callee_fndecl (rhs);\n+      if (DECL_BUILT_IN (rhs)\n+\t  && DECL_FUNCTION_CODE (rhs) == BUILT_IN_CONSTANT_P)\n+\treturn 0;\n+\n+      cost += 20;\n+      break;\n+\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case TRUNC_MOD_EXPR:\n+      /* Division and multiplication are usually expensive.  */\n+      cost += 20;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return cost;\n+}\n+\n+/* Determine the outermost loop to that it is possible to hoist a statement\n+   STMT and store it to LIM_DATA (STMT)->max_loop.  To do this we determine\n+   the outermost loop in that the value computed by STMT is invariant.\n+   If MUST_PRESERVE_EXEC is true, additionally choose such a loop that\n+   we preserve the fact whether STMT is executed.  It also fills other related\n+   information to LIM_DATA (STMT).\n+   \n+   The function returns false if STMT cannot be hoisted outside of the loop it\n+   is defined in, and true otherwise.  */\n+\n+static bool\n+determine_max_movement (tree stmt, bool must_preserve_exec)\n+{\n+  basic_block bb = bb_for_stmt (stmt);\n+  struct loop *loop = bb->loop_father;\n+  struct loop *level;\n+  struct lim_aux_data *lim_data = LIM_DATA (stmt);\n+  use_optype uses;\n+  vuse_optype vuses;\n+  v_may_def_optype v_may_defs;\n+  stmt_ann_t ann = stmt_ann (stmt);\n+  unsigned i;\n+  \n+  if (must_preserve_exec)\n+    level = ALWAYS_EXECUTED_IN (bb);\n+  else\n+    level = superloop_at_depth (loop, 1);\n+  lim_data->max_loop = level;\n+\n+  uses = USE_OPS (ann);\n+  for (i = 0; i < NUM_USES (uses); i++)\n+    if (!add_dependency (USE_OP (uses, i), lim_data, loop, true))\n+      return false;\n+\n+  vuses = VUSE_OPS (ann);\n+  for (i = 0; i < NUM_VUSES (vuses); i++)\n+    if (!add_dependency (VUSE_OP (vuses, i), lim_data, loop, false))\n+      return false;\n+\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    if (!add_dependency (V_MAY_DEF_OP (v_may_defs, i), lim_data, loop, false))\n+      return false;\n+\n+  lim_data->cost += stmt_cost (stmt);\n+\n+  return true;\n+}\n+\n+/* Suppose that some statement in ORIG_LOOP is hoisted to the loop LEVEL,\n+   and that one of the operands of this statement is computed by STMT.\n+   Ensure that STMT (together with all the statements that define its\n+   operands) is hoisted at least out of the loop LEVEL.  */\n+\n+static void\n+set_level (tree stmt, struct loop *orig_loop, struct loop *level)\n+{\n+  struct loop *stmt_loop = bb_for_stmt (stmt)->loop_father;\n+  struct depend *dep;\n+\n+  stmt_loop = find_common_loop (orig_loop, stmt_loop);\n+  if (LIM_DATA (stmt) && LIM_DATA (stmt)->tgt_loop)\n+    stmt_loop = find_common_loop (stmt_loop,\n+\t\t\t\t  LIM_DATA (stmt)->tgt_loop->outer);\n+  if (flow_loop_nested_p (stmt_loop, level))\n+    return;\n+\n+  if (!LIM_DATA (stmt))\n+    abort ();\n+\n+  if (level != LIM_DATA (stmt)->max_loop\n+      && !flow_loop_nested_p (LIM_DATA (stmt)->max_loop, level))\n+    abort ();\n+\n+  LIM_DATA (stmt)->tgt_loop = level;\n+  for (dep = LIM_DATA (stmt)->depends; dep; dep = dep->next)\n+    set_level (dep->stmt, orig_loop, level);\n+}\n+\n+/* Determines an outermost loop from that we want to hoist the statement STMT.\n+   For now we chose the outermost possible loop.  TODO -- use profiling\n+   information to set it more sanely.  */\n+\n+static void\n+set_profitable_level (tree stmt)\n+{\n+  set_level (stmt, bb_for_stmt (stmt)->loop_father, LIM_DATA (stmt)->max_loop);\n+}\n+\n+/* Returns true if STMT is not a pure call.  */\n+\n+static bool\n+nonpure_call_p (tree stmt)\n+{\n+  tree call = get_call_expr_in (stmt);\n+\n+  if (!call)\n+    return false;\n+\n+  return TREE_SIDE_EFFECTS (call) != 0;\n+}\n+\n+/* Releases the memory occupied by DATA.  */\n+\n+static void\n+free_lim_aux_data (struct lim_aux_data *data)\n+{\n+  struct depend *dep, *next;\n+\n+  for (dep = data->depends; dep; dep = next)\n+    {\n+      next = dep->next;\n+      free (dep);\n+    }\n+  free (data);\n+}\n+\n+/* Determine the outermost loops in that statements in basic block BB are\n+   invariant, and record them to the LIM_DATA associated with the statements.\n+   Callback for walk_dominator_tree.  */\n+\n+static void\n+determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n+\t\t\t      basic_block bb)\n+{\n+  enum move_pos pos;\n+  block_stmt_iterator bsi;\n+  tree stmt;\n+  bool maybe_never = ALWAYS_EXECUTED_IN (bb) == NULL;\n+  struct loop *outermost = ALWAYS_EXECUTED_IN (bb);\n+\n+  if (!bb->loop_father->outer)\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Basic block %d (loop %d -- depth %d):\\n\\n\",\n+\t     bb->index, bb->loop_father->num, bb->loop_father->depth);\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      stmt = bsi_stmt (bsi);\n+\n+      pos = movement_possibility (stmt);\n+      if (pos == MOVE_IMPOSSIBLE)\n+\t{\n+\t  if (nonpure_call_p (stmt))\n+\t    {\n+\t      maybe_never = true;\n+\t      outermost = NULL;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      stmt_ann (stmt)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n+      LIM_DATA (stmt)->always_executed_in = outermost;\n+\n+      if (maybe_never && pos == MOVE_PRESERVE_EXECUTION)\n+\tcontinue;\n+\n+      if (!determine_max_movement (stmt, pos == MOVE_PRESERVE_EXECUTION))\n+\t{\n+\t  LIM_DATA (stmt)->max_loop = NULL;\n+\t  continue;\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  print_generic_stmt_indented (dump_file, stmt, 0, 2);\n+\t  fprintf (dump_file, \"  invariant up to level %d, cost %d.\\n\\n\",\n+\t\t   LIM_DATA (stmt)->max_loop->depth,\n+\t\t   LIM_DATA (stmt)->cost);\n+\t}\n+\n+      if (LIM_DATA (stmt)->cost >= LIM_EXPENSIVE)\n+\tset_profitable_level (stmt);\n+    }\n+}\n+\n+/* For each statement determines the outermost loop in that it is invariant,\n+   statements on whose motion it depends and the cost of the computation.\n+   This information is stored to the LIM_DATA structure associated with\n+   each statement.  */\n+\n+static void\n+determine_invariantness (void)\n+{\n+  struct dom_walk_data walk_data;\n+\n+  memset (&walk_data, 0, sizeof (struct dom_walk_data));\n+  walk_data.before_dom_children_before_stmts = determine_invariantness_stmt;\n+\n+  init_walk_dominator_tree (&walk_data);\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  fini_walk_dominator_tree (&walk_data);\n+}\n+\n+/* Commits edge insertions and updates loop structures.  */\n+\n+void\n+loop_commit_inserts (void)\n+{\n+  unsigned old_last_basic_block, i;\n+  basic_block bb;\n+\n+  old_last_basic_block = last_basic_block;\n+  bsi_commit_edge_inserts (NULL);\n+  for (i = old_last_basic_block; i < (unsigned) last_basic_block; i++)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      add_bb_to_loop (bb,\n+\t\t      find_common_loop (bb->succ->dest->loop_father,\n+\t\t\t\t\tbb->pred->src->loop_father));\n+    }\n+}\n+\n+/* Hoist the statements in basic block BB out of the loops prescribed by\n+   data stored in LIM_DATA structres associated with each statement.  Callback\n+   for walk_dominator_tree.  */\n+\n+static void\n+move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n+\t\t\tbasic_block bb)\n+{\n+  struct loop *level;\n+  block_stmt_iterator bsi;\n+  tree stmt;\n+  unsigned cost = 0;\n+\n+  if (!bb->loop_father->outer)\n+    return;\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n+    {\n+      stmt = bsi_stmt (bsi);\n+\n+      if (!LIM_DATA (stmt))\n+\t{\n+\t  bsi_next (&bsi);\n+\t  continue;\n+\t}\n+\n+      cost = LIM_DATA (stmt)->cost;\n+      level = LIM_DATA (stmt)->tgt_loop;\n+      free_lim_aux_data (LIM_DATA (stmt));\n+      stmt_ann (stmt)->common.aux = NULL;\n+\n+      if (!level)\n+\t{\n+\t  bsi_next (&bsi);\n+\t  continue;\n+\t}\n+\n+      /* We do not really want to move conditionals out of the loop; we just\n+\t placed it here to force its operands to be moved if necessary.  */\n+      if (TREE_CODE (stmt) == COND_EXPR)\n+\tcontinue;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Moving statement\\n\");\n+\t  print_generic_stmt (dump_file, stmt, 0);\n+\t  fprintf (dump_file, \"(cost %u) out of loop %d.\\n\\n\",\n+\t\t   cost, level->num);\n+\t}\n+      bsi_insert_on_edge (loop_preheader_edge (level), stmt);\n+      bsi_remove (&bsi);\n+    }\n+}\n+\n+/* Hoist the statements out of the loops prescribed by data stored in\n+   LIM_DATA structres associated with each statement.*/\n+\n+static void\n+move_computations (void)\n+{\n+  struct dom_walk_data walk_data;\n+\n+  memset (&walk_data, 0, sizeof (struct dom_walk_data));\n+  walk_data.before_dom_children_before_stmts = move_computations_stmt;\n+\n+  init_walk_dominator_tree (&walk_data);\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  loop_commit_inserts ();\n+  rewrite_into_ssa (false);\n+  bitmap_clear (vars_to_rename);\n+}\n+\n+/* Checks whether the statement defining variable *INDEX can be hoisted\n+   out of the loop passed in DATA.  Callback for for_each_index.  */\n+\n+static bool\n+may_move_till (tree ref, tree *index, void *data)\n+{\n+  struct loop *loop = data, *max_loop;\n+\n+  /* If REF is an array reference, check also that the step and the lower\n+     bound is invariant in LOOP.  */\n+  if (TREE_CODE (ref) == ARRAY_REF)\n+    {\n+      tree step = array_ref_element_size (ref);\n+      tree lbound = array_ref_low_bound (ref);\n+\n+      max_loop = outermost_invariant_loop_expr (step, loop);\n+      if (!max_loop)\n+\treturn false;\n+\n+      max_loop = outermost_invariant_loop_expr (lbound, loop);\n+      if (!max_loop)\n+\treturn false;\n+    }\n+\n+  max_loop = outermost_invariant_loop (*index, loop);\n+  if (!max_loop)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Forces statements definining (invariant) SSA names in expression EXPR to be\n+   moved out of the LOOP.  */\n+\n+static void\n+force_move_till_expr (tree expr, struct loop *loop)\n+{\n+  char class = TREE_CODE_CLASS (TREE_CODE (expr));\n+  unsigned i, nops;\n+\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      tree stmt = SSA_NAME_DEF_STMT (expr);\n+      if (IS_EMPTY_STMT (stmt))\n+\treturn;\n+\n+      set_level (stmt, bb_for_stmt (stmt)->loop_father, loop);\n+      return;\n+    }\n+\n+  if (class != '1'\n+      && class != '2'\n+      && class != 'e'\n+      && class != '<')\n+    return;\n+\n+  nops = first_rtl_op (TREE_CODE (expr));\n+  for (i = 0; i < nops; i++)\n+    force_move_till_expr (TREE_OPERAND (expr, i), loop);\n+}\n+\n+/* Forces statement defining invariants in REF (and *INDEX) to be moved out of\n+   the loop passed in DATA.  Callback for for_each_index.  */\n+\n+static bool\n+force_move_till (tree ref, tree *index, void *data)\n+{\n+  tree stmt;\n+\n+  if (TREE_CODE (ref) == ARRAY_REF)\n+    {\n+      tree step = array_ref_element_size (ref);\n+      tree lbound = array_ref_low_bound (ref);\n+\n+      force_move_till_expr (step, data);\n+      force_move_till_expr (lbound, data);\n+    }\n+\n+  if (TREE_CODE (*index) != SSA_NAME)\n+    return true;\n+\n+  stmt = SSA_NAME_DEF_STMT (*index);\n+  if (IS_EMPTY_STMT (stmt))\n+    return true;\n+\n+  set_level (stmt, bb_for_stmt (stmt)->loop_father, data);\n+\n+  return true;\n+}\n+\n+/* Records memory reference *REF (that occurs in statement STMT)\n+   to the list MEM_REFS.  */\n+\n+static void\n+record_mem_ref (struct mem_ref **mem_refs, tree stmt, tree *ref)\n+{\n+  struct mem_ref *aref = xmalloc (sizeof (struct mem_ref));\n+\n+  aref->stmt = stmt;\n+  aref->ref = ref;\n+\n+  aref->next = *mem_refs;\n+  *mem_refs = aref;\n+}\n+\n+/* Releases list of memory references MEM_REFS.  */\n+\n+static void\n+free_mem_refs (struct mem_ref *mem_refs)\n+{\n+  struct mem_ref *act;\n+\n+  while (mem_refs)\n+    {\n+      act = mem_refs;\n+      mem_refs = mem_refs->next;\n+      free (act);\n+    }\n+}\n+\n+/* If VAR is defined in LOOP and the statement it is defined in does not belong\n+   to the set SEEN, add the statement to QUEUE of length IN_QUEUE and\n+   to the set SEEN.  */\n+\n+static void\n+maybe_queue_var (tree var, struct loop *loop,\n+\t\t sbitmap seen, tree *queue, unsigned *in_queue)\n+{\n+  tree stmt = SSA_NAME_DEF_STMT (var);\n+  basic_block def_bb = bb_for_stmt (stmt);\n+\t      \n+  if (!def_bb\n+      || !flow_bb_inside_loop_p (loop, def_bb)\n+      || TEST_BIT (seen, stmt_ann (stmt)->uid))\n+    return;\n+\t  \n+  SET_BIT (seen, stmt_ann (stmt)->uid);\n+  queue[(*in_queue)++] = stmt;\n+}\n+\n+/* Determine whether all memory references inside the LOOP that correspond\n+   to virtual ssa names defined in statement STMT are equal.\n+   If so, store the list of the references to MEM_REFS, and return one\n+   of them.  Otherwise store NULL to MEM_REFS and return NULL_TREE.  */\n+\n+static tree\n+single_reachable_address (struct loop *loop, tree stmt,\n+\t\t\t  struct mem_ref **mem_refs)\n+{\n+  tree *queue = xmalloc (sizeof (tree) * max_uid);\n+  sbitmap seen = sbitmap_alloc (max_uid);\n+  tree common_ref = NULL, *aref;\n+  unsigned in_queue = 1;\n+  dataflow_t df;\n+  unsigned i, n;\n+  v_may_def_optype v_may_defs;\n+  vuse_optype vuses;\n+\n+  sbitmap_zero (seen);\n+\n+  *mem_refs = NULL;\n+\n+  queue[0] = stmt;\n+  SET_BIT (seen, stmt_ann (stmt)->uid);\n+\n+  while (in_queue)\n+    {\n+      stmt = queue[--in_queue];\n+\n+      if (LIM_DATA (stmt)\n+\t  && LIM_DATA (stmt)->sm_done)\n+\tgoto fail;\n+\n+      switch (TREE_CODE (stmt))\n+\t{\n+\tcase MODIFY_EXPR:\n+\t  aref = &TREE_OPERAND (stmt, 0);\n+\t  if (is_gimple_reg (*aref)\n+\t      || !is_gimple_lvalue (*aref))\n+\t    aref = &TREE_OPERAND (stmt, 1);\n+\t  if (is_gimple_reg (*aref)\n+\t      || !is_gimple_lvalue (*aref)\n+\t      || (common_ref && !operand_equal_p (*aref, common_ref, 0)))\n+\t    goto fail;\n+\t  common_ref = *aref;\n+\n+\t  record_mem_ref (mem_refs, stmt, aref);\n+\n+\t  /* Traverse also definitions of the VUSES (there may be other\n+\t     distinct from the one we used to get to this statement).  */\n+\t  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n+\t  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t    maybe_queue_var (V_MAY_DEF_OP (v_may_defs, i), loop,\n+\t\t\t     seen, queue, &in_queue);\n+\n+\t  vuses = STMT_VUSE_OPS (stmt);\n+\t  for (i = 0; i < NUM_VUSES (vuses); i++)\n+\t    maybe_queue_var (VUSE_OP (vuses, i), loop,\n+\t\t\t     seen, queue, &in_queue);\n+\t  break;\n+\n+\tcase PHI_NODE:\n+\t  for (i = 0; i < (unsigned) PHI_NUM_ARGS (stmt); i++)\n+\t    maybe_queue_var (PHI_ARG_DEF (stmt, i), loop,\n+\t\t\t     seen, queue, &in_queue);\n+\t  break;\n+\n+\tdefault:\n+\t  goto fail;\n+\t}\n+\n+      /* Find uses of virtual names.  */\n+      df = get_immediate_uses (stmt);\n+      n = num_immediate_uses (df);\n+\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  stmt = immediate_use (df, i);\n+\n+\t  if (!flow_bb_inside_loop_p (loop, bb_for_stmt (stmt)))\n+\t    continue;\n+\n+\t  if (TEST_BIT (seen, stmt_ann (stmt)->uid))\n+\t    continue;\n+\t  SET_BIT (seen, stmt_ann (stmt)->uid);\n+\n+\t  queue[in_queue++] = stmt;\n+\t}\n+    }\n+\n+  free (queue);\n+  sbitmap_free (seen);\n+\n+  return common_ref;\n+\n+fail:\n+  free_mem_refs (*mem_refs);\n+  *mem_refs = NULL;\n+  free (queue);\n+  sbitmap_free (seen);\n+\n+  return NULL;\n+}\n+\n+/* Rewrites memory references in list MEM_REFS by variable TMP_VAR.  */\n+\n+static void\n+rewrite_mem_refs (tree tmp_var, struct mem_ref *mem_refs)\n+{\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  vuse_optype vuses;\n+  unsigned i;\n+  tree var;\n+\n+  for (; mem_refs; mem_refs = mem_refs->next)\n+    {\n+      v_may_defs = STMT_V_MAY_DEF_OPS (mem_refs->stmt);\n+      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t{\n+\t  var = SSA_NAME_VAR (V_MAY_DEF_RESULT (v_may_defs, i));\n+\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t}\n+\n+      v_must_defs = STMT_V_MUST_DEF_OPS (mem_refs->stmt);\n+      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\t{\n+\t  var = SSA_NAME_VAR (V_MUST_DEF_OP (v_must_defs, i));\n+\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t}\n+\n+      vuses = STMT_VUSE_OPS (mem_refs->stmt);\n+      for (i = 0; i < NUM_VUSES (vuses); i++)\n+\t{\n+\t  var = SSA_NAME_VAR (VUSE_OP (vuses, i));\n+\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t}\n+\n+      *mem_refs->ref = tmp_var;\n+      modify_stmt (mem_refs->stmt);\n+    }\n+}\n+\n+/* Records request for store motion of memory reference REF from LOOP.\n+   MEM_REFS is the list of occurences of the reference REF inside LOOP;\n+   these references are rewritten by a new temporary variable.\n+   Exits from the LOOP are stored in EXITS, there are N_EXITS of them.\n+   The initialization of the temporary variable is put to the preheader\n+   of the loop, and assignments to the reference from the temporary variable\n+   are emitted to exits.  */\n+\n+static void\n+schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n+\t     struct mem_ref *mem_refs)\n+{\n+  struct mem_ref *aref;\n+  tree tmp_var;\n+  unsigned i;\n+  tree load, store;\n+\n+  tmp_var = make_rename_temp (TREE_TYPE (ref), \"lsm_tmp\");\n+\n+  for_each_index (&ref, force_move_till, loop);\n+\n+  rewrite_mem_refs (tmp_var, mem_refs);\n+  for (aref = mem_refs; aref; aref = aref->next)\n+    if (LIM_DATA (aref->stmt))\n+      LIM_DATA (aref->stmt)->sm_done = true;\n+\n+  /* Emit the load & stores.  */\n+  load = build (MODIFY_EXPR, void_type_node, tmp_var, ref);\n+  modify_stmt (load);\n+  stmt_ann (load)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n+  LIM_DATA (load)->max_loop = loop;\n+  LIM_DATA (load)->tgt_loop = loop;\n+\n+  /* Put this into the latch, so that we are sure it will be processed after\n+     all dependencies.  */\n+  bsi_insert_on_edge (loop_latch_edge (loop), load);\n+\n+  for (i = 0; i < n_exits; i++)\n+    {\n+      store = build (MODIFY_EXPR, void_type_node,\n+\t\t     unshare_expr (ref), tmp_var);\n+      bsi_insert_on_edge (exits[i], store);\n+    }\n+}\n+\n+/* Determine whether all memory references inside LOOP corresponding to the\n+   virtual ssa name REG are equal to each other, and whether the address of\n+   this common reference can be hoisted outside of the loop.  If this is true,\n+   prepare the statements that load the value of the memory reference to a\n+   temporary variable in the loop preheader, store it back on the loop exits,\n+   and replace all the references inside LOOP by this temporary variable.\n+   LOOP has N_EXITS stored in EXITS.  */\n+\n+static void\n+determine_lsm_reg (struct loop *loop, edge *exits, unsigned n_exits, tree reg)\n+{\n+  tree ref;\n+  struct mem_ref *mem_refs, *aref;\n+  struct loop *must_exec;\n+  \n+  if (is_gimple_reg (reg))\n+    return;\n+  \n+  ref = single_reachable_address (loop, SSA_NAME_DEF_STMT (reg), &mem_refs);\n+  if (!ref)\n+    return;\n+\n+  if (!for_each_index (&ref, may_move_till, loop))\n+    {\n+      free_mem_refs (mem_refs);\n+      return;\n+    }\n+\n+  if (tree_could_trap_p (ref))\n+    {\n+      /* If the memory access is unsafe (i.e. it might trap), ensure that some\n+\t of the statements in that it occurs is always executed when the loop\n+\t is entered.  This way we know that by moving the load from the\n+\t reference out of the loop we will not cause the error that would not\n+\t occur otherwise.\n+\n+\t TODO -- in fact we would like to check for anticipability of the\n+\t reference, i.e. that on each path from loop entry to loop exit at\n+\t least one of the statements containing the memory reference is\n+\t executed.  */\n+\n+      for (aref = mem_refs; aref; aref = aref->next)\n+\t{\n+\t  if (!LIM_DATA (aref->stmt))\n+\t    continue;\n+\n+\t  must_exec = LIM_DATA (aref->stmt)->always_executed_in;\n+\t  if (!must_exec)\n+\t    continue;\n+\n+\t  if (must_exec == loop\n+\t      || flow_loop_nested_p (must_exec, loop))\n+\t    break;\n+\t}\n+\n+      if (!aref)\n+\t{\n+\t  free_mem_refs (mem_refs);\n+\t  return;\n+\t}\n+    }\n+\n+  schedule_sm (loop, exits, n_exits, ref, mem_refs);\n+  free_mem_refs (mem_refs);\n+}\n+\n+/* Checks whether LOOP (with N_EXITS exits stored in EXITS array) is suitable\n+   for a store motion optimization (i.e. whether we can insert statement\n+   on its exits).  */\n+\n+static bool\n+loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED, edge *exits,\n+\t\t      unsigned n_exits)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < n_exits; i++)\n+    if (exits[i]->flags & EDGE_ABNORMAL)\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Try to perform store motion for all memory references modified inside\n+   LOOP.  */\n+\n+static void\n+determine_lsm_loop (struct loop *loop)\n+{\n+  tree phi;\n+  unsigned n_exits;\n+  edge *exits = get_loop_exit_edges (loop, &n_exits);\n+\n+  if (!loop_suitable_for_sm (loop, exits, n_exits))\n+    {\n+      free (exits);\n+      return;\n+    }\n+\n+  for (phi = phi_nodes (loop->header); phi; phi = TREE_CHAIN (phi))\n+    determine_lsm_reg (loop, exits, n_exits, PHI_RESULT (phi));\n+\n+  free (exits);\n+}\n+\n+/* Try to perform store motion for all memory references modified inside\n+   any of LOOPS.  */\n+\n+static void\n+determine_lsm (struct loops *loops)\n+{\n+  struct loop *loop;\n+  basic_block bb;\n+\n+  /* Create a UID for each statement in the function.  Ordering of the\n+     UIDs is not important for this pass.  */\n+  max_uid = 0;\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      tree phi;\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tstmt_ann (bsi_stmt (bsi))->uid = max_uid++;\n+\n+      for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+\tstmt_ann (phi)->uid = max_uid++;\n+    }\n+\n+  compute_immediate_uses (TDFA_USE_VOPS, NULL);\n+\n+  /* Pass the loops from the outermost.  For each virtual operand loop phi node\n+     check whether all the references inside the loop correspond to a single\n+     address, and if so, move them.  */\n+\n+  loop = loops->tree_root->inner;\n+  while (1)\n+    {\n+      determine_lsm_loop (loop);\n+\n+      if (loop->inner)\n+\t{\n+\t  loop = loop->inner;\n+\t  continue;\n+\t}\n+      while (!loop->next)\n+\t{\n+\t  loop = loop->outer;\n+\t  if (loop == loops->tree_root)\n+\t    {\n+\t      free_df ();\n+\t      loop_commit_inserts ();\n+\t      return;\n+\t    }\n+\t}\n+      loop = loop->next;\n+    }\n+}\n+\n+/* Fills ALWAYS_EXECUTED_IN information for basic blocks of LOOP, i.e.\n+   for each such basic block bb records the outermost loop for that execution\n+   of its header implies execution of bb.  CONTAINS_CALL is the bitmap of\n+   blocks that contain a nonpure call.  */\n+\n+static void\n+fill_always_executed_in (struct loop *loop, sbitmap contains_call)\n+{\n+  basic_block bb = NULL, *bbs, last = NULL;\n+  unsigned i;\n+  edge e;\n+  struct loop *inn_loop = loop;\n+\n+  if (!loop->header->aux)\n+    {\n+      bbs = get_loop_body_in_dom_order (loop);\n+\n+      for (i = 0; i < loop->num_nodes; i++)\n+\t{\n+\t  bb = bbs[i];\n+\n+\t  if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\t    last = bb;\n+\n+\t  if (TEST_BIT (contains_call, bb->index))\n+\t    break;\n+\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (!flow_bb_inside_loop_p (loop, e->dest))\n+\t      break;\n+\t  if (e)\n+\t    break;\n+\n+\t  /* A loop might be infinite (TODO use simple loop analysis\n+\t     to disprove this if possible).  */\n+\t  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t    break;\n+\n+\t  if (!flow_bb_inside_loop_p (inn_loop, bb))\n+\t    break;\n+\n+\t  if (bb->loop_father->header == bb)\n+\t    {\n+\t      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\t\tbreak;\n+\n+\t      /* In a loop that is always entered we may proceed anyway.\n+\t\t But record that we entered it and stop once we leave it.  */\n+\t      inn_loop = bb->loop_father;\n+\t    }\n+\t}\n+\n+      while (1)\n+\t{\n+\t  last->aux = loop;\n+\t  if (last == loop->header)\n+\t    break;\n+\t  last = get_immediate_dominator (CDI_DOMINATORS, last);\n+\t}\n+\n+      free (bbs);\n+    }\n+\n+  for (loop = loop->inner; loop; loop = loop->next)\n+    fill_always_executed_in (loop, contains_call);\n+}\n+\n+/* Compute the global information needed by the loop invariant motion pass.\n+   LOOPS is the loop tree.  */\n+\n+static void\n+tree_ssa_lim_initialize (struct loops *loops)\n+{\n+  sbitmap contains_call = sbitmap_alloc (last_basic_block);\n+  block_stmt_iterator bsi;\n+  struct loop *loop;\n+  basic_block bb;\n+\n+  sbitmap_zero (contains_call);\n+  FOR_EACH_BB (bb)\n+    {\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  if (nonpure_call_p (bsi_stmt (bsi)))\n+\t    break;\n+\t}\n+\n+      if (!bsi_end_p (bsi))\n+\tSET_BIT (contains_call, bb->index);\n+    }\n+\n+  for (loop = loops->tree_root->inner; loop; loop = loop->next)\n+    fill_always_executed_in (loop, contains_call);\n+\n+  sbitmap_free (contains_call);\n+}\n+\n+/* Cleans up after the invariant motion pass.  */\n+\n+static void\n+tree_ssa_lim_finalize (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bb->aux = NULL;\n+    }\n+}\n+\n+/* Moves invariants from LOOPS.  Only \"expensive\" invariants are moved out --\n+   i.e. those that are likely to be win regardless of the register pressure.  */\n+\n+void\n+tree_ssa_lim (struct loops *loops)\n+{\n+  tree_ssa_lim_initialize (loops);\n+\n+  /* For each statement determine the outermost loop in that it is\n+     invariant and cost for computing the invariant.  */\n+  determine_invariantness ();\n+\n+  /* For each memory reference determine whether it is possible to hoist it\n+     out of the loop.  Force the necessary invariants to be moved out of the\n+     loops as well.  */\n+  determine_lsm (loops);\n+\n+  /* Move the expressions that are expensive enough.  */\n+  move_computations ();\n+\n+  tree_ssa_lim_finalize ();\n+}"}, {"sha": "816be1526af7203ce58ebcf00af3e10e56af875f", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -111,6 +111,39 @@ struct tree_opt_pass pass_loop_init =\n   0\t\t\t\t\t/* todo_flags_finish */\n };\n \n+/* Loop invariant motion pass.  */\n+\n+static void\n+tree_ssa_loop_im (void)\n+{\n+  if (!current_loops)\n+    return;\n+\n+  tree_ssa_lim (current_loops);\n+}\n+\n+static bool\n+gate_tree_ssa_loop_im (void)\n+{\n+  return flag_tree_lim != 0;\n+}\n+\n+struct tree_opt_pass pass_lim = \n+{\n+  \"lim\",\t\t\t\t/* name */\n+  gate_tree_ssa_loop_im,\t\t/* gate */\n+  tree_ssa_loop_im,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_LIM,\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func                \t/* todo_flags_finish */\n+};\n+\n /* Loop optimizer finalization.  */\n \n static void"}, {"sha": "033c851ea74bd84f57d2a322ff3b7cf7df6068f8", "filename": "gcc/tree.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -5650,6 +5650,34 @@ build_empty_stmt (void)\n }\n \n \n+/* Returns true if it is possible to prove that the index of\n+   an array access REF (an ARRAY_REF expression) falls into the\n+   array bounds.  */\n+\n+bool\n+in_array_bounds_p (tree ref)\n+{\n+  tree idx = TREE_OPERAND (ref, 1);\n+  tree min, max;\n+\n+  if (TREE_CODE (idx) != INTEGER_CST)\n+    return false;\n+\t    \n+  min = array_ref_low_bound (ref);\n+  max = array_ref_up_bound (ref);\n+  if (!min\n+      || !max\n+      || TREE_CODE (min) != INTEGER_CST\n+      || TREE_CODE (max) != INTEGER_CST)\n+    return false;\n+\n+  if (tree_int_cst_lt (idx, min)\n+      || tree_int_cst_lt (max, idx))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return true if T (assumed to be a DECL) must be assigned a memory\n    location.  */\n "}, {"sha": "5c9c0484e95bde321ec6c839c531790720de61e6", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "patch": "@@ -303,7 +303,7 @@ struct tree_common GTY(())\n \t   ..._TYPE\n \n        TREE_THIS_NOTRAP in\n-          INDIRECT_REF\n+          INDIRECT_REF, ARRAY_REF, ARRAY_RANGE_REF\n \n    deprecated_flag:\n \n@@ -798,7 +798,12 @@ extern void tree_operand_check_failed (int, enum tree_code,\n /* Nonzero means this node will not trap.  In an INDIRECT_REF, means\n    accessing the memory pointed to won't generate a trap.  However,\n    this only applies to an object when used appropriately: it doesn't\n-   mean that writing a READONLY mem won't trap.  */\n+   mean that writing a READONLY mem won't trap.\n+   \n+   In ARRAY_REF and ARRAY_RANGE_REF means that we know that the index\n+   (or slice of the array) always belongs to the range of the array.\n+   I.e. that the access will not trap, provided that the access to\n+   the base to the array will not trap.  */\n #define TREE_THIS_NOTRAP(NODE) ((NODE)->common.nothrow_flag)\n \n /* In a VAR_DECL, PARM_DECL or FIELD_DECL, or any kind of ..._REF node,\n@@ -2722,6 +2727,7 @@ extern tree build_method_type (tree, tree);\n extern tree build_offset_type (tree, tree);\n extern tree build_complex_type (tree);\n extern tree array_type_nelts (tree);\n+extern bool in_array_bounds_p (tree);\n \n extern tree value_member (tree, tree);\n extern tree purpose_member (tree, tree);\n@@ -3256,6 +3262,11 @@ extern tree array_ref_element_size (tree);\n \n extern tree array_ref_low_bound (tree);\n \n+/* Return a tree representing the upper bound of the array mentioned in\n+   EXP, an ARRAY_REF.  */\n+\n+extern tree array_ref_up_bound (tree);\n+\n /* Return a tree representing the offset, in bytes, of the field referenced\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n "}]}