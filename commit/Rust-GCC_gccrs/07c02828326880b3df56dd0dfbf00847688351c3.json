{"sha": "07c02828326880b3df56dd0dfbf00847688351c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdjMDI4MjgzMjY4ODBiM2RmNTZkZDBkZmJmMDA4NDc2ODgzNTFjMw==", "commit": {"author": {"name": "Tehila Meyzels", "email": "tehila@il.ibm.com", "date": "2006-11-29T18:24:14Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2006-11-29T18:24:14Z"}, "message": "haifa-sched.c: Remove define LINE_NOTE(INSN).\n\n2006-11-29  Tehila Meyzels  <tehila@il.ibm.com>\n\n      * haifa-sched.c: Remove define LINE_NOTE(INSN).\n      Remove line_note_head.\n      Update documentation.\n      (associate_line_notes_with_blocks): Kill.\n      (extend_bb): Remove basic block argument, put void instead.\n      Remove line number handling for each bb.\n      (save_line_notes): Kill.\n      (restore_line_notes): Kill.\n      (sched_init): Remove line_note_head initialization.\n      Change extend_bb call.\n      (sched_finish): Remove free of line_note_head.\n      (add_block): Change extend_bb call.\n      * sched-ebb.c (schedule_ebb): Remove save_line_notes,\n      rm_line_notes and restore_line_notes calls.\n      (schedule_ebbs): Remove rm_redundant_line_notes.\n      * sched-int.h (struct haifa_insn_data): Remove line_note.\n      (save_line_notes): Remove declaration.\n      (restore_line_notes): Remove declaration.\n      * modulo-sched.c (loop_canon_p): Update debug info printing\n      by using insn locators instead of line note.\n      (sms_schedule): Update debug info printing, by using insn\n      locators instead of line note.\n      * sched-rgn.c (debug_dependencies): Remove handling of case\n      n>0 (line number), since it's a dead code.\n      (schedule_region): Remove save_line_notes and\n      restore_line_notes calls.\n\nFrom-SVN: r119328", "tree": {"sha": "da4032793fa855993d2d1d0ddb8fafbcd3e51adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da4032793fa855993d2d1d0ddb8fafbcd3e51adc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07c02828326880b3df56dd0dfbf00847688351c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c02828326880b3df56dd0dfbf00847688351c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c02828326880b3df56dd0dfbf00847688351c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c02828326880b3df56dd0dfbf00847688351c3/comments", "author": null, "committer": null, "parents": [{"sha": "14502dad061deb34939adf92cb5ea35a06f1da34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14502dad061deb34939adf92cb5ea35a06f1da34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14502dad061deb34939adf92cb5ea35a06f1da34"}], "stats": {"total": 231, "additions": 46, "deletions": 185}, "files": [{"sha": "5145756ff87348d986f6eaabbc72486be995d264", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07c02828326880b3df56dd0dfbf00847688351c3", "patch": "@@ -1,3 +1,31 @@\n+2006-11-29  Tehila Meyzels  <tehila@il.ibm.com>\n+\n+\t* haifa-sched.c: Remove define LINE_NOTE(INSN).  Remove line_note_head.\n+\tUpdate documentation.\n+\t(associate_line_notes_with_blocks): Kill.\n+\t(extend_bb): Remove basic block argument, put void instead. \n+\tRemove line number handling for each bb. \n+\t(save_line_notes): Kill.\n+\t(restore_line_notes): Kill.\n+\t(sched_init): Remove line_note_head initialization.\n+\tChange extend_bb call.\n+\t(sched_finish): Remove free of line_note_head.\n+\t(add_block): Change extend_bb call.\n+\t* sched-ebb.c (schedule_ebb): Remove save_line_notes,\n+\trm_line_notes and restore_line_notes calls.\n+\t(schedule_ebbs): Remove rm_redundant_line_notes.\n+\t* sched-int.h (struct haifa_insn_data): Remove line_note.\n+\t(save_line_notes): Remove declaration.\n+\t(restore_line_notes): Remove declaration.\n+\t* modulo-sched.c (loop_canon_p): Update debug info printing \n+\tby using insn locators instead of line note.\n+\t(sms_schedule): Update debug info printing, by using insn \n+\tlocators instead of line note.\n+\t* sched-rgn.c (debug_dependencies): Remove handling of case \n+\tn>0 (line number), since it's a dead code.\n+\t(schedule_region): Remove save_line_notes and \n+\trestore_line_notes calls.\n+\n 2006-11-29  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/rs6000/predicates.md (gpc_reg_operand): Check"}, {"sha": "0ed0dddad3c2f65b60c451ab8da96088e42f8351", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 147, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=07c02828326880b3df56dd0dfbf00847688351c3", "patch": "@@ -186,7 +186,6 @@ fix_sched_param (const char *param, const char *val)\n \n struct haifa_insn_data *h_i_d;\n \n-#define LINE_NOTE(INSN)\t\t(h_i_d[INSN_UID (INSN)].line_note)\n #define INSN_TICK(INSN)\t\t(h_i_d[INSN_UID (INSN)].tick)\n #define INTER_TICK(INSN)        (h_i_d[INSN_UID (INSN)].inter_tick)\n \n@@ -200,10 +199,6 @@ struct haifa_insn_data *h_i_d;\n    For now, all instructions are equally good.  */\n #define ISSUE_POINTS(INSN) 1\n \n-/* Vector indexed by basic block number giving the starting line-number\n-   for each basic block.  */\n-static rtx *line_note_head;\n-\n /* List of important notes we must keep around.  This is a pointer to the\n    last element in the list.  */\n static rtx note_list;\n@@ -509,7 +504,7 @@ static void advance_one_cycle (void);\n /* Notes handling mechanism:\n    =========================\n    Generally, NOTES are saved before scheduling and restored after scheduling.\n-   The scheduler distinguishes between three types of notes:\n+   The scheduler distinguishes between two types of notes:\n \n    (1) LOOP_BEGIN, LOOP_END, SETJMP, EHREGION_BEG, EHREGION_END notes:\n    Before scheduling a region, a pointer to the note is added to the insn\n@@ -569,12 +564,11 @@ static void init_before_recovery (void);\n static basic_block create_recovery_block (void);\n static void create_check_block_twin (rtx, bool);\n static void fix_recovery_deps (basic_block);\n-static void associate_line_notes_with_blocks (basic_block);\n static void change_pattern (rtx, rtx);\n static int speculate_insn (rtx, ds_t, rtx *);\n static void dump_new_block_header (int, basic_block, rtx, rtx);\n static void restore_bb_notes (basic_block);\n-static void extend_bb (basic_block);\n+static void extend_bb (void);\n static void fix_jump_move (rtx);\n static void move_block_after_check (rtx);\n static void move_succs (VEC(edge,gc) **, basic_block);\n@@ -1321,99 +1315,6 @@ no_real_insns_p (rtx head, rtx tail)\n   return 1;\n }\n \n-/* Save line number notes for each insn in block B.  HEAD and TAIL are\n-   the boundaries of the block in which notes should be processed.  */\n-\n-void\n-save_line_notes (int b, rtx head, rtx tail)\n-{\n-  rtx next_tail;\n-\n-  /* We must use the true line number for the first insn in the block\n-     that was computed and saved at the start of this pass.  We can't\n-     use the current line number, because scheduling of the previous\n-     block may have changed the current line number.  */\n-\n-  rtx line = line_note_head[b];\n-  rtx insn;\n-\n-  next_tail = NEXT_INSN (tail);\n-\n-  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    LINE_NOTE (insn) = line;\n-}\n-\n-/* After a block was scheduled, insert line notes into the insns list.\n-   HEAD and TAIL are the boundaries of the block in which notes should\n-   be processed.  */\n-\n-void\n-restore_line_notes (rtx head, rtx tail)\n-{\n-  rtx line, note, prev, new;\n-  int added_notes = 0;\n-  rtx next_tail, insn;\n-\n-  head = head;\n-  next_tail = NEXT_INSN (tail);\n-\n-  /* Determine the current line-number.  We want to know the current\n-     line number of the first insn of the block here, in case it is\n-     different from the true line number that was saved earlier.  If\n-     different, then we need a line number note before the first insn\n-     of this block.  If it happens to be the same, then we don't want to\n-     emit another line number note here.  */\n-  for (line = head; line; line = PREV_INSN (line))\n-    if (NOTE_P (line) && NOTE_LINE_NUMBER (line) > 0)\n-      break;\n-\n-  /* Walk the insns keeping track of the current line-number and inserting\n-     the line-number notes as needed.  */\n-  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-      line = insn;\n-  /* This used to emit line number notes before every non-deleted note.\n-     However, this confuses a debugger, because line notes not separated\n-     by real instructions all end up at the same address.  I can find no\n-     use for line number notes before other notes, so none are emitted.  */\n-    else if (!NOTE_P (insn)\n-\t     && INSN_UID (insn) < old_max_uid\n-\t     && (note = LINE_NOTE (insn)) != 0\n-\t     && note != line\n-\t     && (line == 0\n-#ifdef USE_MAPPED_LOCATION\n-\t\t || NOTE_SOURCE_LOCATION (note) != NOTE_SOURCE_LOCATION (line)\n-#else\n-\t\t || NOTE_LINE_NUMBER (note) != NOTE_LINE_NUMBER (line)\n-\t\t || NOTE_SOURCE_FILE (note) != NOTE_SOURCE_FILE (line)\n-#endif\n-\t\t ))\n-      {\n-\tline = note;\n-\tprev = PREV_INSN (insn);\n-\tif (LINE_NOTE (note))\n-\t  {\n-\t    /* Re-use the original line-number note.  */\n-\t    LINE_NOTE (note) = 0;\n-\t    PREV_INSN (note) = prev;\n-\t    NEXT_INSN (prev) = note;\n-\t    PREV_INSN (insn) = note;\n-\t    NEXT_INSN (note) = insn;\n-\t    set_block_for_insn (note, BLOCK_FOR_INSN (insn));\n-\t  }\n-\telse\n-\t  {\n-\t    added_notes++;\n-\t    new = emit_note_after (NOTE_LINE_NUMBER (note), prev);\n-#ifndef USE_MAPPED_LOCATION\n-\t    NOTE_SOURCE_FILE (new) = NOTE_SOURCE_FILE (note);\n-#endif\n-\t  }\n-      }\n-  if (sched_verbose && added_notes)\n-    fprintf (sched_dump, \";; added %d line-number notes\\n\", added_notes);\n-}\n-\n /* Delete notes between HEAD and TAIL and put them in the chain\n    of notes ended by NOTE_LIST.  */\n \n@@ -2722,11 +2623,10 @@ sched_init (void)\n \n   init_alias_analysis ();\n \n-  line_note_head = 0;\n   old_last_basic_block = 0;\n   glat_start = 0;  \n   glat_end = 0;\n-  extend_bb (0);\n+  extend_bb ();\n \n   if (current_sched_info->flags & USE_GLAT)\n     init_glat ();\n@@ -2758,7 +2658,6 @@ sched_finish (void)\n   dfa_finish ();\n   free_dependency_caches ();\n   end_alias_analysis ();\n-  free (line_note_head);\n   free_glat ();\n \n   if (targetm.sched.md_finish_global)\n@@ -3902,29 +3801,6 @@ fix_recovery_deps (basic_block rec)\n   add_jump_dependencies (insn, jump);\n }\n \n-/* The function saves line notes at the beginning of block B.  */\n-static void\n-associate_line_notes_with_blocks (basic_block b)\n-{\n-  rtx line;\n-\n-  for (line = BB_HEAD (b); line; line = PREV_INSN (line))\n-    if (NOTE_P (line) && NOTE_LINE_NUMBER (line) > 0)\n-      {\n-        line_note_head[b->index] = line;\n-        break;\n-      }\n-  /* Do a forward search as well, since we won't get to see the first\n-     notes in a basic block.  */\n-  for (line = BB_HEAD (b); line; line = NEXT_INSN (line))\n-    {\n-      if (INSN_P (line))\n-        break;\n-      if (NOTE_P (line) && NOTE_LINE_NUMBER (line) > 0)\n-        line_note_head[b->index] = line;\n-    }\n-}\n-\n /* Changes pattern of the INSN to NEW_PAT.  */\n static void\n change_pattern (rtx insn, rtx new_pat)\n@@ -4087,28 +3963,10 @@ restore_bb_notes (basic_block first)\n    If BB is NULL, initialize structures for the whole CFG.\n    Otherwise, initialize them for the just created BB.  */\n static void\n-extend_bb (basic_block bb)\n+extend_bb (void)\n {\n   rtx insn;\n \n-  if (write_symbols != NO_DEBUG)\n-    {\n-      /* Save-line-note-head:\n-         Determine the line-number at the start of each basic block.\n-         This must be computed and saved now, because after a basic block's\n-         predecessor has been scheduled, it is impossible to accurately\n-         determine the correct line number for the first insn of the block.  */\n-      line_note_head = xrecalloc (line_note_head, last_basic_block, \n-\t\t\t\t  old_last_basic_block,\n-\t\t\t\t  sizeof (*line_note_head));\n-\n-      if (bb)\n-\tassociate_line_notes_with_blocks (bb);\n-      else\n-\tFOR_EACH_BB (bb)\n-\t  associate_line_notes_with_blocks (bb);\n-    }        \n-  \n   old_last_basic_block = last_basic_block;\n \n   if (current_sched_info->flags & USE_GLAT)\n@@ -4143,7 +4001,7 @@ add_block (basic_block bb, basic_block ebb)\n \t      && bb->il.rtl->global_live_at_start == 0\n \t      && bb->il.rtl->global_live_at_end == 0);\n \n-  extend_bb (bb);\n+  extend_bb ();\n \n   glat_start[bb->index] = 0;\n   glat_end[bb->index] = 0;"}, {"sha": "4160e998c1b597763589fde434a3af232528dfca", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=07c02828326880b3df56dd0dfbf00847688351c3", "patch": "@@ -818,7 +818,11 @@ loop_canon_p (struct loop *loop)\n     {\n       if (dump_file)\n \t{\n+\t  rtx insn = BB_END (loop->header);\n+ \n \t  fprintf (dump_file, \"SMS loop many exits \");\n+\t  \t  fprintf (dump_file, \" %s %d (file, line)\\n\",\n+\t\t\t   insn_file (insn), insn_line (insn));\n \t}\n       return false;\n     }\n@@ -827,7 +831,11 @@ loop_canon_p (struct loop *loop)\n     {\n       if (dump_file)\n \t{\n+\t  rtx insn = BB_END (loop->header);\n+ \n \t  fprintf (dump_file, \"SMS loop many BBs. \");\n+\t  fprintf (dump_file, \" %s %d (file, line)\\n\",\n+\t\t   insn_file (insn), insn_line (insn));\n \t}\n       return false;\n     }\n@@ -954,6 +962,8 @@ sms_schedule (void)\n \t{\n \t  if (dump_file)\n \t    {\n+\t      fprintf (dump_file, \" %s %d (file, line)\\n\",\n+\t\t       insn_file (tail), insn_line (tail));\n \t      fprintf (dump_file, \"SMS single-bb-loop\\n\");\n \t      if (profile_info && flag_branch_probabilities)\n \t    \t{\n@@ -1043,6 +1053,8 @@ sms_schedule (void)\n \n       if (dump_file)\n \t{\n+\t  fprintf (dump_file, \" %s %d (file, line)\\n\",\n+\t\t   insn_file (tail), insn_line (tail));\n \t  fprintf (dump_file, \"SMS single-bb-loop\\n\");\n \t  if (profile_info && flag_branch_probabilities)\n \t    {"}, {"sha": "38b81af94e8cd01e6ec4067f1b5a75dad3b2b742", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=07c02828326880b3df56dd0dfbf00847688351c3", "patch": "@@ -479,11 +479,6 @@ schedule_ebb (rtx head, rtx tail)\n   current_sched_info->prev_head = PREV_INSN (head);\n   current_sched_info->next_tail = NEXT_INSN (tail);\n \n-  if (write_symbols != NO_DEBUG)\n-    {\n-      save_line_notes (first_bb->index, head, tail);\n-    }\n-\n   /* rm_other_notes only removes notes which are _inside_ the\n      block---that is, it won't remove notes before the first real insn\n      or after the last real insn of the block.  So if the first insn\n@@ -519,9 +514,6 @@ schedule_ebb (rtx head, rtx tail)\n   head = current_sched_info->head;\n   tail = current_sched_info->tail;\n \n-  if (write_symbols != NO_DEBUG)\n-    restore_line_notes (head, tail);\n-\n   if (EDGE_COUNT (last_bb->preds) == 0)\n     /* LAST_BB is unreachable.  */\n     {"}, {"sha": "14690dfbfbca551521a2e9bb13f236de48643f5c", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=07c02828326880b3df56dd0dfbf00847688351c3", "patch": "@@ -270,11 +270,7 @@ struct haifa_insn_data\n   /* A list of scheduled producers of the instruction.  Links are being moved\n      from LOG_LINKS to RESOLVED_DEPS during scheduling.  */\n   rtx resolved_deps;\n-  \n-  /* The line number note in effect for each insn.  For line number\n-     notes, this indicates whether the note may be reused.  */\n-  rtx line_note;\n-\n+ \n   /* Logical uid gives the original ordering of the insns.  */\n   int luid;\n \n@@ -634,8 +630,6 @@ extern int haifa_classify_insn (rtx);\n extern void get_ebb_head_tail (basic_block, basic_block, rtx *, rtx *);\n extern int no_real_insns_p (rtx, rtx);\n \n-extern void save_line_notes (int, rtx, rtx);\n-extern void restore_line_notes (rtx, rtx);\n extern void rm_other_notes (rtx, rtx);\n \n extern int insn_cost (rtx, rtx, rtx);"}, {"sha": "8b9cf9931beaf0914e77d379a65fc7aba5320072", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c02828326880b3df56dd0dfbf00847688351c3/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=07c02828326880b3df56dd0dfbf00847688351c3", "patch": "@@ -2584,13 +2584,6 @@ debug_dependencies (void)\n \t\t  n = NOTE_LINE_NUMBER (insn);\n \t\t  if (n < 0)\n \t\t    fprintf (sched_dump, \"%s\\n\", GET_NOTE_INSN_NAME (n));\n-\t\t  else\n-\t\t    {\n-\t\t      expanded_location xloc;\n-\t\t      NOTE_EXPANDED_LOCATION (xloc, insn);\n-\t\t      fprintf (sched_dump, \"line %d, file %s\\n\",\n-\t\t\t       xloc.line, xloc.file);\n-\t\t    }\n \t\t}\n \t      else\n \t\tfprintf (sched_dump, \" {%s}\\n\", GET_RTX_NAME (GET_CODE (insn)));\n@@ -2768,7 +2761,6 @@ schedule_region (int rgn)\n     {\n       basic_block first_bb, last_bb, curr_bb;\n       rtx head, tail;\n-      int b = BB_TO_BLOCK (bb);\n \n       first_bb = EBB_FIRST_BB (bb);\n       last_bb = EBB_LAST_BB (bb);\n@@ -2784,10 +2776,6 @@ schedule_region (int rgn)\n       current_sched_info->prev_head = PREV_INSN (head);\n       current_sched_info->next_tail = NEXT_INSN (tail);\n \n-      if (write_symbols != NO_DEBUG)\n-\t{\n-\t  save_line_notes (b, head, tail);\n-\t}\n \n       /* rm_other_notes only removes notes which are _inside_ the\n \t block---that is, it won't remove notes before the first real insn\n@@ -2838,17 +2826,6 @@ schedule_region (int rgn)\n   /* Sanity check: verify that all region insns were scheduled.  */\n   gcc_assert (sched_rgn_n_insns == rgn_n_insns);\n \n-  /* Restore line notes.  */\n-  if (write_symbols != NO_DEBUG)\n-    {\n-      for (bb = 0; bb < current_nr_blocks; bb++)\n-\t{\n-\t  rtx head, tail;\n-\n-\t  get_ebb_head_tail (EBB_FIRST_BB (bb), EBB_LAST_BB (bb), &head, &tail);\n-\t  restore_line_notes (head, tail);\n-\t}\n-    }\n \n   /* Done with this region.  */\n "}]}