{"sha": "b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE3Zjk4YjFjNTQxZGJiYjhhNjE1MDYzYTA0NDliNGM2MjQ1Y2JjMg==", "commit": {"author": {"name": "Edmar Wienskoski", "email": "edmar@freescale.com", "date": "2009-12-07T15:34:21Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2009-12-07T15:34:21Z"}, "message": "config.gcc (cpu_is_64bit): Add new core e500mc64.\n\n2009-12-07  Edmar Wienskoski  <edmar@freescale.com>\n\n        * config.gcc (cpu_is_64bit): Add new core e500mc64.\n        (powerpc*-*-*): Add new core e500mc64.\n        * config/rs6000/e500mc64.md: New file.\n        * config/rs6000/rs6000.c (processor_costs): Add new costs for\n        e500mc64.\n        (rs6000_override_options): Add e500mc64 case to\n        processor_target_table. Altivec and Spe options not allowed with\n        e500mc64. Disable string instructions for e500mc64. Enable branch\n        targets alignment for both e500mc and e500mc64. Initialize\n        rs6000_cost for e500mc64.\n        (rs6000_emit_sISEL): New function.\n        (rs6000_emit_sCOND): Call rs6000_emit_sISEL for isel targets.\n        (rs6000_emit_int_cmove): Fix mode of 64 bit isel pattern\n        generation.\n        (rs6000_issue_rate): Set issue rate for e500mc64.\n        (rs6000_rtx_costs): Set more accurate cost for mfcr instruction\n        on architectures with isel.\n        * config/rs6000/rs6000-protos.h (rs6000_emit_sISEL): Declare.\n        * config/rs6000/rs6000.h (processor_type): Add\n        PROCESSOR_PPCE500MC64.\n        (ASM_CPU_SPEC): Add e500mc64.\n        * config/rs6000/rs6000.md (define_attr \"cpu\"): Add ppce500mc64.\n        Include e500mc64.md.\n        (abssi2_isel): Expand pattern to handle DImode.\n        (nabs<mode>2_isel): New pattern.\n        (absdi2): Change pattern to handle 64 bit isel targets.\n        (absdi2_internal): Exclude ISEL targets.\n        (nabsdi2): Exclude ISEL targets.\n        * doc/invoke.texi: Add e500mc64 to list of cpus.\n\nFrom-SVN: r155044", "tree": {"sha": "4e82947b7eb88a8982ab8dcd325577a711121248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e82947b7eb88a8982ab8dcd325577a711121248"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/comments", "author": null, "committer": null, "parents": [{"sha": "d0d92baf438995061f3c86a8b85c9b431573d986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d92baf438995061f3c86a8b85c9b431573d986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d92baf438995061f3c86a8b85c9b431573d986"}], "stats": {"total": 404, "additions": 376, "deletions": 28}, "files": [{"sha": "73c505bd29fb5b7926b34deb67317abd592b3de6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -1,3 +1,35 @@\n+2009-12-07  Edmar Wienskoski  <edmar@freescale.com>\n+\n+\t* config.gcc (cpu_is_64bit): Add new core e500mc64.\n+\t(powerpc*-*-*): Add new core e500mc64.\n+\t* config/rs6000/e500mc64.md: New file.\n+\t* config/rs6000/rs6000.c (processor_costs): Add new costs for\n+\te500mc64.\n+\t(rs6000_override_options): Add e500mc64 case to\n+\tprocessor_target_table. Altivec and Spe options not allowed with\n+\te500mc64. Disable string instructions for e500mc64. Enable branch\n+\ttargets alignment for both e500mc and e500mc64. Initialize\n+\trs6000_cost for e500mc64.\n+\t(rs6000_emit_sISEL): New function.\n+\t(rs6000_emit_sCOND): Call rs6000_emit_sISEL for isel targets.\n+\t(rs6000_emit_int_cmove): Fix mode of 64 bit isel pattern\n+\tgeneration.\n+\t(rs6000_issue_rate): Set issue rate for e500mc64.\n+\t(rs6000_rtx_costs): Set more accurate cost for mfcr instruction\n+\ton architectures with isel.\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_sISEL): Declare.\n+\t* config/rs6000/rs6000.h (processor_type): Add\n+\tPROCESSOR_PPCE500MC64.\n+\t(ASM_CPU_SPEC): Add e500mc64.\n+\t* config/rs6000/rs6000.md (define_attr \"cpu\"): Add ppce500mc64.\n+\tInclude e500mc64.md.\n+\t(abssi2_isel): Expand pattern to handle DImode.\n+\t(nabs<mode>2_isel): New pattern.\n+\t(absdi2): Change pattern to handle 64 bit isel targets.\n+\t(absdi2_internal): Exclude ISEL targets.\n+\t(nabsdi2): Exclude ISEL targets.\n+\t* doc/invoke.texi: Add e500mc64 to list of cpus.\n+\n 2009-12-07  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (any_or): New code iterator."}, {"sha": "ca9441ff3acceae4df4488e2bae0b26d67583010", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -327,7 +327,7 @@ powerpc*-*-*)\n \textra_headers=\"ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h\"\n \tneed_64bit_hwint=yes\n \tcase x$with_cpu in\n-\t    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[34567]|xpower6x|xrs64a|xcell|xa2)\n+\t    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[34567]|xpower6x|xrs64a|xcell|xa2|xe500mc64)\n \t\tcpu_is_64bit=yes\n \t\t;;\n \tesac\n@@ -3081,7 +3081,7 @@ case \"${target}\" in\n \t\t\t| 401 | 403 | 405 | 405fp | 440 | 440fp | 464 | 464fp \\\n \t\t\t| 476 | 476fp | 505 | 601 | 602 | 603 | 603e | ec603e \\\n \t\t\t| 604 | 604e | 620 | 630 | 740 | 750 | 7400 | 7450 \\\n-\t\t\t| a2 | e300c[23] | 854[08] | e500mc \\\n+\t\t\t| a2 | e300c[23] | 854[08] | e500mc | e500mc64 \\\n \t\t\t| 801 | 821 | 823 | 860 | 970 | G3 | G4 | G5 | cell)\n \t\t\t\t# OK\n \t\t\t\t;;"}, {"sha": "8507514f5c5d6af979076d4dee1e047d1ddc2102", "filename": "gcc/config/rs6000/e500mc64.md", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Fe500mc64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Fe500mc64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fe500mc64.md?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -0,0 +1,191 @@\n+;; Pipeline description for Freescale PowerPC e500mc64 core.\n+;;   Copyright (C) 2009 Free Software Foundation, Inc.\n+;;   Contributed by Edmar Wienskoski (edmar@freescale.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+;;\n+;; e500mc64 64-bit SU(2), LSU, FPU, BPU\n+;; Max issue 3 insns/clock cycle (includes 1 branch)\n+\n+(define_automaton \"e500mc64_most,e500mc64_long,e500mc64_retire\")\n+(define_cpu_unit \"e500mc64_decode_0,e500mc64_decode_1\" \"e500mc64_most\")\n+(define_cpu_unit \"e500mc64_issue_0,e500mc64_issue_1\"   \"e500mc64_most\")\n+(define_cpu_unit \"e500mc64_retire_0,e500mc64_retire_1\" \"e500mc64_retire\")\n+\n+;; SU.\n+(define_cpu_unit \"e500mc64_su0_stage0,e500mc64_su1_stage0\" \"e500mc64_most\")\n+\n+;; MU.\n+(define_cpu_unit \"e500mc64_mu_stage0,e500mc64_mu_stage1\" \"e500mc64_most\")\n+(define_cpu_unit \"e500mc64_mu_stage2,e500mc64_mu_stage3\" \"e500mc64_most\")\n+\n+;; Non-pipelined division.\n+(define_cpu_unit \"e500mc64_mu_div\" \"e500mc64_long\")\n+\n+;; LSU.\n+(define_cpu_unit \"e500mc64_lsu\" \"e500mc64_most\")\n+\n+;; FPU.\n+(define_cpu_unit \"e500mc64_fpu\" \"e500mc64_most\")\n+\n+;; Branch unit.\n+(define_cpu_unit \"e500mc64_bu\" \"e500mc64_most\")\n+\n+;; The following units are used to make the automata deterministic.\n+(define_cpu_unit \"present_e500mc64_decode_0\" \"e500mc64_most\")\n+(define_cpu_unit \"present_e500mc64_issue_0\" \"e500mc64_most\")\n+(define_cpu_unit \"present_e500mc64_retire_0\" \"e500mc64_retire\")\n+(define_cpu_unit \"present_e500mc64_su0_stage0\" \"e500mc64_most\")\n+\n+;; The following sets to make automata deterministic when option ndfa is used.\n+(presence_set \"present_e500mc64_decode_0\" \"e500mc64_decode_0\")\n+(presence_set \"present_e500mc64_issue_0\" \"e500mc64_issue_0\")\n+(presence_set \"present_e500mc64_retire_0\" \"e500mc64_retire_0\")\n+(presence_set \"present_e500mc64_su0_stage0\" \"e500mc64_su0_stage0\")\n+\n+;; Some useful abbreviations.\n+(define_reservation \"e500mc64_decode\"\n+    \"e500mc64_decode_0|e500mc64_decode_1+present_e500mc64_decode_0\")\n+(define_reservation \"e500mc64_issue\"\n+    \"e500mc64_issue_0|e500mc64_issue_1+present_e500mc64_issue_0\")\n+(define_reservation \"e500mc64_retire\"\n+   \"e500mc64_retire_0|e500mc64_retire_1+present_e500mc64_retire_0\")\n+(define_reservation \"e500mc64_su_stage0\"\n+   \"e500mc64_su0_stage0|e500mc64_su1_stage0+present_e500mc64_su0_stage0\")\n+\n+;; Simple SU insns.\n+(define_insn_reservation \"e500mc64_su\" 1\n+  (and (eq_attr \"type\" \"integer,insert_word,insert_dword,delayed_compare,\\\n+\tshift,cntlz,exts\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su_stage0+e500mc64_retire\")\n+\n+(define_insn_reservation \"e500mc64_su2\" 2\n+  (and (eq_attr \"type\" \"cmp,compare,delayed_compare,fast_compare,trap\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su_stage0,e500mc64_retire\")\n+\n+(define_insn_reservation \"e500mc64_delayed\" 2\n+  (and (eq_attr \"type\" \"var_shift_rotate,var_delayed_compare\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su_stage0,e500mc64_retire\")\n+\n+(define_insn_reservation \"e500mc64_two\" 2\n+  (and (eq_attr \"type\" \"two\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su_stage0+e500mc64_retire,\\\n+   e500mc64_issue+e500mc64_su_stage0+e500mc64_retire\")\n+\n+(define_insn_reservation \"e500mc64_three\" 3\n+  (and (eq_attr \"type\" \"three\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su_stage0+e500mc64_retire,\\\n+   e500mc64_issue+e500mc64_su_stage0+e500mc64_retire,\\\n+   e500mc64_issue+e500mc64_su_stage0+e500mc64_retire\")\n+\n+;; Multiply.\n+(define_insn_reservation \"e500mc64_multiply\" 4\n+  (and (eq_attr \"type\" \"imul,imul2,imul3,imul_compare\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_mu_stage0,e500mc64_mu_stage1,\\\n+   e500mc64_mu_stage2,e500mc64_mu_stage3+e500mc64_retire\")\n+\n+;; Divide. We use the average latency time here.\n+(define_insn_reservation \"e500mc64_divide\" 14\n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_mu_stage0+e500mc64_mu_div,\\\n+   e500mc64_mu_div*13\")\n+\n+;; Branch.\n+(define_insn_reservation \"e500mc64_branch\" 1\n+  (and (eq_attr \"type\" \"jmpreg,branch,isync\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_bu,e500mc64_retire\")\n+\n+;; CR logical.\n+(define_insn_reservation \"e500mc64_cr_logical\" 1\n+  (and (eq_attr \"type\" \"cr_logical,delayed_cr\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_bu,e500mc64_retire\")\n+\n+;; Mfcr.\n+(define_insn_reservation \"e500mc64_mfcr\" 4\n+  (and (eq_attr \"type\" \"mfcr\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su1_stage0,e500mc64_su1_stage0*3+e500mc64_retire\")\n+\n+;; Mtcrf.\n+(define_insn_reservation \"e500mc64_mtcrf\" 1\n+  (and (eq_attr \"type\" \"mtcr\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su1_stage0+e500mc64_retire\")\n+\n+;; Mtjmpr.\n+(define_insn_reservation \"e500mc64_mtjmpr\" 1\n+  (and (eq_attr \"type\" \"mtjmpr,mfjmpr\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su_stage0+e500mc64_retire\")\n+\n+;; Brinc.\n+(define_insn_reservation \"e500mc64_brinc\" 1\n+  (and (eq_attr \"type\" \"brinc\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_su_stage0+e500mc64_retire\")\n+\n+;; Loads.\n+(define_insn_reservation \"e500mc64_load\" 3\n+  (and (eq_attr \"type\" \"load,load_ext,load_ext_u,load_ext_ux,load_ux,load_u,\\\n+\t\t\tload_l,sync\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_lsu,nothing,e500mc64_retire\")\n+\n+(define_insn_reservation \"e500mc64_fpload\" 4\n+  (and (eq_attr \"type\" \"fpload,fpload_ux,fpload_u\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_lsu,nothing*2,e500mc64_retire\")\n+\n+;; Stores.\n+(define_insn_reservation \"e500mc64_store\" 3\n+  (and (eq_attr \"type\" \"store,store_ux,store_u,store_c\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_lsu,nothing,e500mc64_retire\")\n+\n+(define_insn_reservation \"e500mc64_fpstore\" 3\n+  (and (eq_attr \"type\" \"fpstore,fpstore_ux,fpstore_u\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_lsu,nothing,e500mc64_retire\")\n+\n+;; The following ignores the retire unit to avoid a large automata.\n+\n+;; FP.\n+(define_insn_reservation \"e500mc64_float\" 7\n+  (and (eq_attr \"type\" \"fpsimple,fp,fpcompare,dmul\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_fpu\")\n+; \"e500mc64_decode,e500mc64_issue+e500mc64_fpu,nothing*5,e500mc64_retire\")\n+\n+;; FP divides are not pipelined.\n+(define_insn_reservation \"e500mc64_sdiv\" 20\n+  (and (eq_attr \"type\" \"sdiv\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_fpu,e500mc64_fpu*19\")\n+\n+(define_insn_reservation \"e500mc64_ddiv\" 35\n+  (and (eq_attr \"type\" \"ddiv\")\n+       (eq_attr \"cpu\" \"ppce500mc64\"))\n+  \"e500mc64_decode,e500mc64_issue+e500mc64_fpu,e500mc64_fpu*34\")"}, {"sha": "14b5496a2f836f70007599ba512896e188f9bc24", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -90,6 +90,7 @@ extern void print_operand_address (FILE *, rtx);\n extern bool rs6000_output_addr_const_extra (FILE *, rtx);\n extern enum rtx_code rs6000_reverse_condition (enum machine_mode,\n \t\t\t\t\t       enum rtx_code);\n+extern void rs6000_emit_sISEL (enum machine_mode, rtx[]);\n extern void rs6000_emit_sCOND (enum machine_mode, rtx[]);\n extern void rs6000_emit_cbranch (enum machine_mode, rtx[]);\n extern char * output_cbranch (rtx, const char *, int, rtx);"}, {"sha": "884b6e35e88ab4efa3e14a5bb6f76d3bb3bbfed3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 95, "deletions": 7, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -759,6 +759,25 @@ struct processor_costs ppce500mc_cost = {\n   1,\t\t\t/* prefetch streams /*/\n };\n \n+/* Instruction costs on PPCE500MC64 processors.  */\n+static const\n+struct processor_costs ppce500mc64_cost = {\n+  COSTS_N_INSNS (4),    /* mulsi */\n+  COSTS_N_INSNS (4),    /* mulsi_const */\n+  COSTS_N_INSNS (4),    /* mulsi_const9 */\n+  COSTS_N_INSNS (4),    /* muldi */\n+  COSTS_N_INSNS (14),   /* divsi */\n+  COSTS_N_INSNS (14),   /* divdi */\n+  COSTS_N_INSNS (4),    /* fp */\n+  COSTS_N_INSNS (10),   /* dmul */\n+  COSTS_N_INSNS (36),   /* sdiv */\n+  COSTS_N_INSNS (66),   /* ddiv */\n+  64,\t\t\t/* cache line size */\n+  32,\t\t\t/* l1 cache */\n+  128,\t\t\t/* l2 cache */\n+  1,\t\t\t/* prefetch streams /*/\n+};\n+\n /* Instruction costs on POWER4 and POWER5 processors.  */\n static const\n struct processor_costs power4_cost = {\n@@ -2215,6 +2234,8 @@ rs6000_override_options (const char *default_cpu)\n \t {\"e300c3\", PROCESSOR_PPCE300C3, POWERPC_BASE_MASK},\n \t {\"e500mc\", PROCESSOR_PPCE500MC, POWERPC_BASE_MASK | MASK_PPC_GFXOPT\n \t  | MASK_ISEL},\n+\t {\"e500mc64\", PROCESSOR_PPCE500MC64, POWERPC_BASE_MASK | MASK_POWERPC64\n+\t  | MASK_PPC_GFXOPT | MASK_ISEL},\n \t {\"860\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"970\", PROCESSOR_POWER4,\n \t  POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n@@ -2343,7 +2364,7 @@ rs6000_override_options (const char *default_cpu)\n     }\n \n   if (rs6000_cpu == PROCESSOR_PPCE300C2 || rs6000_cpu == PROCESSOR_PPCE300C3\n-      || rs6000_cpu == PROCESSOR_PPCE500MC)\n+      || rs6000_cpu == PROCESSOR_PPCE500MC || rs6000_cpu == PROCESSOR_PPCE500MC64)\n     {\n       if (TARGET_ALTIVEC)\n \terror (\"AltiVec not supported in this target\");\n@@ -2535,7 +2556,8 @@ rs6000_override_options (const char *default_cpu)\n   SUB3TARGET_OVERRIDE_OPTIONS;\n #endif\n \n-  if (TARGET_E500 || rs6000_cpu == PROCESSOR_PPCE500MC)\n+  if (TARGET_E500 || rs6000_cpu == PROCESSOR_PPCE500MC\n+      || rs6000_cpu == PROCESSOR_PPCE500MC64)\n     {\n       /* The e500 and e500mc do not have string instructions, and we set\n \t MASK_STRING above when optimizing for size.  */\n@@ -2572,7 +2594,9 @@ rs6000_override_options (const char *default_cpu)\n   rs6000_align_branch_targets = (rs6000_cpu == PROCESSOR_POWER4\n \t\t\t\t || rs6000_cpu == PROCESSOR_POWER5\n \t\t\t\t || rs6000_cpu == PROCESSOR_POWER6\n-\t\t\t\t || rs6000_cpu == PROCESSOR_POWER7);\n+\t\t\t\t || rs6000_cpu == PROCESSOR_POWER7\n+\t\t\t\t || rs6000_cpu == PROCESSOR_PPCE500MC\n+\t\t\t\t || rs6000_cpu == PROCESSOR_PPCE500MC64);\n \n   /* Allow debug switches to override the above settings.  */\n   if (TARGET_ALWAYS_HINT > 0)\n@@ -2774,6 +2798,10 @@ rs6000_override_options (const char *default_cpu)\n \trs6000_cost = &ppce500mc_cost;\n \tbreak;\n \n+      case PROCESSOR_PPCE500MC64:\n+\trs6000_cost = &ppce500mc64_cost;\n+\tbreak;\n+\n       case PROCESSOR_POWER4:\n       case PROCESSOR_POWER5:\n \trs6000_cost = &power4_cost;\n@@ -15374,6 +15402,53 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n \n /* Emit the RTL for an sCOND pattern.  */\n \n+void\n+rs6000_emit_sISEL (enum machine_mode mode, rtx operands[])\n+{\n+  rtx condition_rtx;\n+  enum machine_mode op_mode;\n+  enum rtx_code cond_code;\n+  rtx result = operands[0];\n+\n+  condition_rtx = rs6000_generate_compare (operands[1], mode);\n+  cond_code = GET_CODE (condition_rtx);\n+\n+  op_mode = GET_MODE (XEXP (operands[1], 0));\n+  if (op_mode == VOIDmode)\n+    op_mode = GET_MODE (XEXP (operands[1], 1));\n+\n+  if (TARGET_POWERPC64 && GET_MODE (result) == DImode)\n+    {\n+      PUT_MODE (condition_rtx, DImode);\n+      if (cond_code == GEU || cond_code == GTU || cond_code == LEU\n+         || cond_code == LTU)\n+       emit_insn (gen_isel_unsigned_di (result, condition_rtx,\n+\t\t\t\t\tforce_reg (DImode, const1_rtx),\n+\t\t\t\t\tforce_reg (DImode, const0_rtx),\n+\t\t\t\t\tXEXP (condition_rtx, 0)));\n+      else\n+       emit_insn (gen_isel_signed_di (result, condition_rtx,\n+\t\t\t\t      force_reg (DImode, const1_rtx),\n+\t\t\t\t      force_reg (DImode, const0_rtx),\n+\t\t\t\t      XEXP (condition_rtx, 0)));\n+    }\n+  else\n+    {\n+      PUT_MODE (condition_rtx, SImode);\n+      if (cond_code == GEU || cond_code == GTU || cond_code == LEU\n+\t || cond_code == LTU)\n+       emit_insn (gen_isel_unsigned_si (result, condition_rtx,\n+\t\t\t\t\tforce_reg (SImode, const1_rtx),\n+\t\t\t\t\tforce_reg (SImode, const0_rtx),\n+\t\t\t\t\tXEXP (condition_rtx, 0)));\n+      else\n+       emit_insn (gen_isel_signed_si (result, condition_rtx,\n+\t\t\t\t      force_reg (SImode, const1_rtx),\n+\t\t\t\t      force_reg (SImode, const0_rtx),\n+\t\t\t\t      XEXP (condition_rtx, 0)));\n+    }\n+}\n+\n void\n rs6000_emit_sCOND (enum machine_mode mode, rtx operands[])\n {\n@@ -15382,6 +15457,12 @@ rs6000_emit_sCOND (enum machine_mode mode, rtx operands[])\n   enum rtx_code cond_code;\n   rtx result = operands[0];\n \n+  if (TARGET_ISEL && (mode == SImode || mode == DImode))\n+    {\n+      rs6000_emit_sISEL (mode, operands);\n+      return;\n+    }\n+\n   condition_rtx = rs6000_generate_compare (operands[1], mode);\n   cond_code = GET_CODE (condition_rtx);\n \n@@ -16031,15 +16112,15 @@ static int\n rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   rtx condition_rtx, cr;\n-  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+  enum machine_mode mode = GET_MODE (dest);\n \n   if (mode != SImode && (!TARGET_POWERPC64 || mode != DImode))\n     return 0;\n \n   /* We still have to do the compare, because isel doesn't do a\n      compare, it just looks at the CRx bits set by a previous compare\n      instruction.  */\n-  condition_rtx = rs6000_generate_compare (op, SImode);\n+  condition_rtx = rs6000_generate_compare (op, mode);\n   cr = XEXP (condition_rtx, 0);\n \n   if (mode == SImode)\n@@ -21885,6 +21966,7 @@ rs6000_issue_rate (void)\n   case CPU_PPCE300C2:\n   case CPU_PPCE300C3:\n   case CPU_PPCE500MC:\n+  case CPU_PPCE500MC64:\n     return 2;\n   case CPU_RIOS2:\n   case CPU_PPC476:\n@@ -24698,7 +24780,10 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t{\n \t  if (XEXP (x, 1) == const0_rtx)\n \t    {\n-\t      *total = COSTS_N_INSNS (2);\n+\t      if (TARGET_ISEL && !TARGET_MFCRF)\n+\t\t*total = COSTS_N_INSNS (8);\n+\t      else\n+\t\t*total = COSTS_N_INSNS (2);\n \t      return true;\n \t    }\n \t  else if (mode == Pmode)\n@@ -24714,7 +24799,10 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total,\n     case UNORDERED:\n       if (outer_code == SET && (XEXP (x, 1) == const0_rtx))\n \t{\n-\t  *total = COSTS_N_INSNS (2);\n+\t  if (TARGET_ISEL && !TARGET_MFCRF)\n+\t    *total = COSTS_N_INSNS (8);\n+\t  else\n+\t    *total = COSTS_N_INSNS (2);\n \t  return true;\n \t}\n       /* CC COMPARE.  */"}, {"sha": "a0c2ad79b72811ed1926b3b79e803461b6e73285", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -158,6 +158,7 @@\n %{mcpu=e300c2: -me300} \\\n %{mcpu=e300c3: -me300} \\\n %{mcpu=e500mc: -me500mc} \\\n+%{mcpu=e500mc64: -me500mc64} \\\n %{maltivec: -maltivec} \\\n -many\"\n \n@@ -341,6 +342,7 @@ enum processor_type\n    PROCESSOR_PPCE300C2,\n    PROCESSOR_PPCE300C3,\n    PROCESSOR_PPCE500MC,\n+   PROCESSOR_PPCE500MC64,\n    PROCESSOR_POWER4,\n    PROCESSOR_POWER5,\n    PROCESSOR_POWER6,"}, {"sha": "5b69f7043acaa0d90276e3aeb33a9cb583f71d6a", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -139,7 +139,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rios1,rios2,rs64a,mpccore,ppc403,ppc405,ppc440,ppc476,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,ppce300c2,ppce300c3,ppce500mc,power4,power5,power6,power7,cell,ppca2\"\n+(define_attr \"cpu\" \"rios1,rios2,rs64a,mpccore,ppc403,ppc405,ppc440,ppc476,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,ppce300c2,ppce300c3,ppce500mc,ppce500mc64,power4,power5,power6,power7,cell,ppca2\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n \n@@ -166,6 +166,7 @@\n (include \"8540.md\")\n (include \"e300c2c3.md\")\n (include \"e500mc.md\")\n+(include \"e500mc64.md\")\n (include \"power4.md\")\n (include \"power5.md\")\n (include \"power6.md\")\n@@ -2077,23 +2078,42 @@\n   \"TARGET_POWER\"\n   \"abs %0,%1\")\n \n-(define_insn_and_split \"abssi2_isel\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (abs:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-   (clobber (match_scratch:SI 2 \"=&b\"))\n+(define_insn_and_split \"abs<mode>2_isel\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+        (abs:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"b\")))\n+   (clobber (match_scratch:GPR 2 \"=&b\"))\n    (clobber (match_scratch:CC 3 \"=y\"))]\n   \"TARGET_ISEL\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 2) (neg:SI (match_dup 1)))\n+  [(set (match_dup 2) (neg:GPR (match_dup 1)))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 1)\n \t\t    (const_int 0)))\n    (set (match_dup 0)\n-\t(if_then_else:SI (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n+\t(if_then_else:GPR (ge (match_dup 3)\n+\t\t\t      (const_int 0))\n+\t\t\t  (match_dup 1)\n+\t\t\t  (match_dup 2)))]\n+  \"\")\n+\n+(define_insn_and_split \"nabs<mode>2_isel\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+        (neg:GPR (abs:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"b\"))))\n+   (clobber (match_scratch:GPR 2 \"=&b\"))\n+   (clobber (match_scratch:CC 3 \"=y\"))]\n+  \"TARGET_ISEL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2) (neg:GPR (match_dup 1)))\n+   (set (match_dup 3)\n+\t(compare:CC (match_dup 1)\n+\t\t    (const_int 0)))\n+   (set (match_dup 0)\n+\t(if_then_else:GPR (ge (match_dup 3)\n+\t\t\t      (const_int 0))\n+\t\t\t  (match_dup 2)\n+\t\t\t  (match_dup 1)))]\n   \"\")\n \n (define_insn_and_split \"abssi2_nopower\"\n@@ -6767,8 +6787,9 @@\n (define_insn \"*fix_truncdfdi2_fpr\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=!d#r\")\n \t(fix:DI (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))]\n-  \"(TARGET_POWERPC64 || TARGET_XILINX_FPU) && TARGET_HARD_FLOAT\n-    && TARGET_DOUBLE_FLOAT && TARGET_FPRS && !VECTOR_UNIT_VSX_P (DFmode)\"\n+  \"(TARGET_POWERPC64 || TARGET_XILINX_FPU)\n+    && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n+    && !VECTOR_UNIT_VSX_P (DFmode)\"\n   \"fctidz %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -7197,11 +7218,24 @@\n \f\n ;; PowerPC64 DImode operations.\n \n-(define_insn_and_split \"absdi2\"\n+(define_expand \"absdi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  \"\n+{\n+  if (TARGET_ISEL)\n+    emit_insn (gen_absdi2_isel (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_absdi2_internal (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn_and_split \"absdi2_internal\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n         (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\")))\n    (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n-  \"TARGET_POWERPC64\"\n+  \"TARGET_POWERPC64 && !TARGET_ISEL\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 63)))\n@@ -7213,7 +7247,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n         (neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\"))))\n    (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n-  \"TARGET_POWERPC64\"\n+  \"TARGET_POWERPC64 && !TARGET_ISEL\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 63)))"}, {"sha": "3a484945182cdc2c2b3e224370ced4ee3dc3e150", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17f98b1c541dbbb8a615063a0449b4c6245cbc2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b17f98b1c541dbbb8a615063a0449b4c6245cbc2", "patch": "@@ -14744,10 +14744,10 @@ Supported values for @var{cpu_type} are @samp{401}, @samp{403},\n @samp{603e}, @samp{604}, @samp{604e}, @samp{620}, @samp{630}, @samp{740},\n @samp{7400}, @samp{7450}, @samp{750}, @samp{801}, @samp{821}, @samp{823},\n @samp{860}, @samp{970}, @samp{8540}, @samp{a2}, @samp{e300c2},\n-@samp{e300c3}, @samp{e500mc}, @samp{ec603e}, @samp{G3}, @samp{G4}, @samp{G5},\n-@samp{power}, @samp{power2}, @samp{power3}, @samp{power4},\n-@samp{power5}, @samp{power5+}, @samp{power6}, @samp{power6x}, @samp{power7},\n-@samp{common}, @samp{powerpc}, @samp{powerpc64}, @samp{rios},\n+@samp{e300c3}, @samp{e500mc}, @samp{e500mc64}, @samp{ec603e}, @samp{G3},\n+@samp{G4}, @samp{G5}, @samp{power}, @samp{power2}, @samp{power3},\n+@samp{power4}, @samp{power5}, @samp{power5+}, @samp{power6}, @samp{power6x},\n+@samp{power7}, @samp{common}, @samp{powerpc}, @samp{powerpc64}, @samp{rios},\n @samp{rios1}, @samp{rios2}, @samp{rsc}, and @samp{rs64}.\n \n @option{-mcpu=common} selects a completely generic processor.  Code"}]}